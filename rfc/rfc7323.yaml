- contents:
  - '                  TCP Extensions for High Performance

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document specifies a set of TCP extensions to improve\n   performance
    over paths with a large bandwidth * delay product and to\n   provide reliable
    operation over very high-speed paths.  It defines\n   the TCP Window Scale (WS)
    option and the TCP Timestamps (TS) option\n   and their semantics.  The Window
    Scale option is used to support\n   larger receive windows, while the Timestamps
    option can be used for\n   at least two distinct mechanisms, Protection Against
    Wrapped\n   Sequences (PAWS) and Round-Trip Time Measurement (RTTM), that are\n
    \  also described herein.\n   This document obsoletes RFC 1323 and describes changes
    from it.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7323.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   4\n     1.1.  TCP Performance . . . . . . . . . . . . . . . . . .
    . . .   4\n     1.2.  TCP Reliability . . . . . . . . . . . . . . . . . . . .
    .   5\n     1.3.  Using TCP options . . . . . . . . . . . . . . . . . . . .   6\n
    \    1.4.  Terminology . . . . . . . . . . . . . . . . . . . . . . .   7\n   2.
    \ TCP Window Scale Option . . . . . . . . . . . . . . . . . . .   8\n     2.1.
    \ Introduction  . . . . . . . . . . . . . . . . . . . . . .   8\n     2.2.  Window
    Scale Option . . . . . . . . . . . . . . . . . . .   8\n     2.3.  Using the Window
    Scale Option . . . . . . . . . . . . . .   9\n     2.4.  Addressing Window Retraction
    \ . . . . . . . . . . . . . .  10\n   3.  TCP Timestamps Option . . . . . . .
    . . . . . . . . . . . . .  11\n     3.1.  Introduction  . . . . . . . . . . .
    . . . . . . . . . . .  11\n     3.2.  Timestamps Option . . . . . . . . . . .
    . . . . . . . . .  12\n   4.  The RTTM Mechanism  . . . . . . . . . . . . . .
    . . . . . . .  14\n     4.1.  Introduction  . . . . . . . . . . . . . . . . .
    . . . . .  14\n     4.2.  Updating the RTO Value  . . . . . . . . . . . . . .
    . . .  15\n     4.3.  Which Timestamp to Echo . . . . . . . . . . . . . . . .
    .  16\n   5.  PAWS - Protection Against Wrapped Sequences . . . . . . . . .  19\n
    \    5.1.  Introduction  . . . . . . . . . . . . . . . . . . . . . .  19\n     5.2.
    \ The PAWS Mechanism  . . . . . . . . . . . . . . . . . . .  19\n     5.3.  Basic
    PAWS Algorithm  . . . . . . . . . . . . . . . . . .  20\n     5.4.  Timestamp
    Clock . . . . . . . . . . . . . . . . . . . . .  22\n     5.5.  Outdated Timestamps
    . . . . . . . . . . . . . . . . . . .  24\n     5.6.  Header Prediction . . .
    . . . . . . . . . . . . . . . . .  25\n     5.7.  IP Fragmentation  . . . . .
    . . . . . . . . . . . . . . .  26\n     5.8.  Duplicates from Earlier Incarnations
    of Connection  . . .  26\n   6.  Conclusions and Acknowledgments . . . . . . .
    . . . . . . . .  27\n   7.  Security Considerations . . . . . . . . . . . . .
    . . . . . .  27\n     7.1.  Privacy Considerations  . . . . . . . . . . . . .
    . . . .  29\n   8.  IANA Considerations . . . . . . . . . . . . . . . . . . .
    . .  29\n   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .
    \ 30\n     9.1.  Normative References  . . . . . . . . . . . . . . . . . .  30\n
    \    9.2.  Informative References  . . . . . . . . . . . . . . . . .  30\n   Appendix
    A.  Implementation Suggestions . . . . . . . . . . . . .  34\n   Appendix B.  Duplicates
    from Earlier Connection Incarnations  . .  35\n     B.1.  System Crash with Loss
    of State . . . . . . . . . . . . .  35\n     B.2.  Closing and Reopening a Connection
    \ . . . . . . . . . . .  35\n   Appendix C.  Summary of Notation  . . . . . .
    . . . . . . . . . .  37\n   Appendix D.  Event Processing Summary . . . . . .
    . . . . . . . .  38\n   Appendix E.  Timestamps Edge Cases  . . . . . . . . .
    . . . . . .  44\n   Appendix F.  Window Retraction Example  . . . . . . . . .
    . . . .  44\n   Appendix G.  RTO Calculation Modification . . . . . . . . . .
    . .  45\n   Appendix H.  Changes from RFC 1323  . . . . . . . . . . . . . . .
    \ 46\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The TCP protocol [RFC0793] was designed to operate reliably
    over\n   almost any transmission medium regardless of transmission rate,\n   delay,
    corruption, duplication, or reordering of segments.  Over the\n   years, advances
    in networking technology have resulted in ever-higher\n   transmission speeds,
    and the fastest paths are well beyond the domain\n   for which TCP was originally
    engineered.\n   This document defines a set of modest extensions to TCP to extend
    the\n   domain of its application to match the increasing network capability.\n
    \  It is an update to and obsoletes [RFC1323], which in turn is based\n   upon
    and obsoletes [RFC1072] and [RFC1185].\n   Changes between [RFC1323] and this
    document are detailed in\n   Appendix H.  These changes are partly due to errata
    in [RFC1323], and\n   partly due to the improved understanding of how the involved\n
    \  components interact.\n   For brevity, the full discussions of the merits and
    history behind\n   the TCP options defined within this document have been omitted.\n
    \  [RFC1323] should be consulted for reference.  It is recommended that\n   a
    modern TCP stack implements and make use of the extensions\n   described in this
    document.\n"
  - contents:
    - "1.1.  TCP Performance\n   TCP performance problems arise when the bandwidth
      * delay product is\n   large.  A network having such paths is referred to as
      a \"long, fat\n   network\" (LFN).\n   There are two fundamental performance
      problems with basic TCP over\n   LFN paths:\n   (1)  Window Size Limit\n        The
      TCP header uses a 16-bit field to report the receive window\n        size to
      the sender.  Therefore, the largest window that can be\n        used is 2^16
      = 64 KiB.  For LFN paths where the bandwidth *\n        delay product exceeds
      64 KiB, the receive window limits the\n        maximum throughput of the TCP
      connection over the path, i.e.,\n        the amount of unacknowledged data that
      TCP can send in order to\n        keep the pipeline full.\n        To circumvent
      this problem, Section 2 of this memo defines a TCP\n        option, \"Window
      Scale\", to allow windows larger than 2^16.  This\n        option defines an
      implicit scale factor, which is used to\n        multiply the window size value
      found in a TCP header to obtain\n        the true window size.\n        It must
      be noted that the use of large receive windows increases\n        the chance
      of too quickly wrapping sequence numbers, as\n        described below in Section
      1.2, (1).\n   (2)  Recovery from Losses\n        Packet losses in an LFN can
      have a catastrophic effect on\n        throughput.\n        To generalize the
      Fast Retransmit / Fast Recovery mechanism to\n        handle multiple packets
      dropped per window, Selective\n        Acknowledgments are required.  Unlike
      the normal cumulative\n        acknowledgments of TCP, Selective Acknowledgments
      give the\n        sender a complete picture of which segments are queued at
      the\n        receiver and which have not yet arrived.\n        Selective Acknowledgments
      and their use are specified in\n        separate documents, \"TCP Selective
      Acknowledgment Options\"\n        [RFC2018], \"An Extension to the Selective
      Acknowledgement (SACK)\n        Option for TCP\" [RFC2883], and \"A Conservative
      Loss Recovery\n        Algorithm Based on Selective Acknowledgment (SACK) for
      TCP\"\n        [RFC6675], and are not further discussed in this document.\n"
    title: 1.1.  TCP Performance
  - contents:
    - "1.2.  TCP Reliability\n   An especially serious kind of error may result from
      an accidental\n   reuse of TCP sequence numbers in data segments.  TCP reliability\n
      \  depends upon the existence of a bound on the lifetime of a segment:\n   the
      \"Maximum Segment Lifetime\" or MSL.\n   Duplication of sequence numbers might
      happen in either of two ways:\n   (1)  Sequence number wrap-around on the current
      connection\n        A TCP sequence number contains 32 bits.  At a high enough\n
      \       transfer rate of large volumes of data (at least 4 GiB in the\n        same
      session), the 32-bit sequence space may be \"wrapped\"\n        (cycled) within
      the time that a segment is delayed in queues.\n   (2)  Earlier incarnation of
      the connection\n        Suppose that a connection terminates, either by a proper
      close\n        sequence or due to a host crash, and the same connection (i.e.,\n
      \       using the same pair of port numbers) is immediately reopened.  A\n        delayed
      segment from the terminated connection could fall within\n        the current
      window for the new incarnation and be accepted as\n        valid.\n   Duplicates
      from earlier incarnations, case (2), are avoided by\n   enforcing the current
      fixed MSL of the TCP specification, as\n   explained in Section 5.8 and Appendix
      B.  In addition, the\n   randomizing of ephemeral ports can also help to probabilistically\n
      \  reduce the chances of duplicates from earlier connections.  However,\n   case
      (1), avoiding the reuse of sequence numbers within the same\n   connection,
      requires an upper bound on MSL that depends upon the\n   transfer rate, and
      at high enough rates, a dedicated mechanism is\n   required.\n   A possible
      fix for the problem of cycling the sequence space would be\n   to increase the
      size of the TCP sequence number field.  For example,\n   the sequence number
      field (and also the acknowledgment field) could\n   be expanded to 64 bits.
      \ This could be done either by changing the\n   TCP header or by means of an
      additional option.\n   Section 5 presents a different mechanism, which we call
      PAWS, to\n   extend TCP reliability to transfer rates well beyond the foreseeable\n
      \  upper limit of network bandwidths.  PAWS uses the TCP Timestamps\n   option
      defined in Section 3.2 to protect against old duplicates from\n   the same connection.\n"
    title: 1.2.  TCP Reliability
  - contents:
    - "1.3.  Using TCP options\n   The extensions defined in this document all use
      TCP options.\n   When [RFC1323] was published, there was concern that some buggy
      TCP\n   implementation might crash on the first appearance of an option on a\n
      \  non-<SYN> segment.  However, bugs like that can lead to denial-of-\n   service
      (DoS) attacks against a TCP.  Research has shown that most\n   TCP implementations
      will properly handle unknown options on non-<SYN>\n   segments ([Medina04],
      [Medina05]).  But it is still prudent to be\n   conservative in what you send,
      and avoiding buggy TCP implementation\n   is not the only reason for negotiating
      TCP options on <SYN> segments.\n   The Window Scale option negotiates fundamental
      parameters of the TCP\n   session.  Therefore, it is only sent during the initial
      handshake.\n   Furthermore, the Window Scale option will be sent in a <SYN,ACK>\n
      \  segment only if the corresponding option was received in the initial\n   <SYN>
      segment.\n   The Timestamps option may appear in any data or <ACK> segment,
      adding\n   10 bytes (up to 12 bytes including padding) to the 20-byte TCP\n
      \  header.  It is required that this TCP option will be sent on all\n   non-<SYN>
      segments after an exchange of options on the <SYN> segments\n   has indicated
      that both sides understand this extension.\n   Research has shown that the use
      of the Timestamps option to take\n   additional RTT samples within each RTT
      has little effect on the\n   ultimate retransmission timeout value [Allman99].
      \ However, there are\n   other uses of the Timestamps option, such as the Eifel
      mechanism\n   ([RFC3522], [RFC4015]) and PAWS (see Section 5), which improve\n
      \  overall TCP security and performance.  The extra header bandwidth\n   used
      by this option should be evaluated for the gains in performance\n   and security
      in an actual deployment.\n   Appendix A contains a recommended layout of the
      options in TCP\n   headers to achieve reasonable data field alignment.\n   Finally,
      we observe that most of the mechanisms defined in this\n   document are important
      for LFNs and/or very high-speed networks.  For\n   low-speed networks, it might
      be a performance optimization to NOT use\n   these mechanisms.  A TCP vendor
      concerned about optimal performance\n   over low-speed paths might consider
      turning these extensions off for\n   low-speed paths, or allow a user or installation
      manager to disable\n   them.\n"
    title: 1.3.  Using TCP options
  - contents:
    - "1.4.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
      \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and
      \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n
      \  In this document, these words will appear with that interpretation\n   only
      when in UPPER CASE.  Lower case uses of these words are not to\n   be interpreted
      as carrying [RFC2119] significance.\n"
    title: 1.4.  Terminology
  title: 1.  Introduction
- contents:
  - '2.  TCP Window Scale Option

    '
  - contents:
    - "2.1.  Introduction\n   The window scale extension expands the definition of
      the TCP window\n   to 30 bits and then uses an implicit scale factor to carry
      this\n   30-bit value in the 16-bit window field of the TCP header (SEG.WND
      in\n   [RFC0793]).  The exponent of the scale factor is carried in a TCP\n   option,
      Window Scale.  This option is sent only in a <SYN> segment (a\n   segment with
      the SYN bit on), hence the window scale is fixed in each\n   direction when
      a connection is opened.\n   The maximum receive window, and therefore the scale
      factor, is\n   determined by the maximum receive buffer space.  In a typical
      modern\n   implementation, this maximum buffer space is set by default but can\n
      \  be overridden by a user program before a TCP connection is opened.\n   This
      determines the scale factor, and therefore no new user interface\n   is needed
      for window scaling.\n"
    title: 2.1.  Introduction
  - contents:
    - "2.2.  Window Scale Option\n   The three-byte Window Scale option MAY be sent
      in a <SYN> segment by\n   a TCP.  It has two purposes: (1) indicate that the
      TCP is prepared to\n   both send and receive window scaling, and (2) communicate
      the\n   exponent of a scale factor to be applied to its receive window.\n   Thus,
      a TCP that is prepared to scale windows SHOULD send the option,\n   even if
      its own scale factor is 1 and the exponent 0.  The scale\n   factor is limited
      to a power of two and encoded logarithmically, so\n   it may be implemented
      by binary shift operations.  The maximum scale\n   exponent is limited to 14
      for a maximum permissible receive window\n   size of 1 GiB (2^(14+16)).\n   TCP
      Window Scale option (WSopt):\n   Kind: 3\n   Length: 3 bytes\n          +---------+---------+---------+\n
      \         | Kind=3  |Length=3 |shift.cnt|\n          +---------+---------+---------+\n
      \              1         1         1\n   This option is an offer, not a promise;
      both sides MUST send Window\n   Scale options in their <SYN> segments to enable
      window scaling in\n   either direction.  If window scaling is enabled, then
      the TCP that\n   sent this option will right-shift its true receive-window values
      by\n   'shift.cnt' bits for transmission in SEG.WND.  The value 'shift.cnt'\n
      \  MAY be zero (offering to scale, while applying a scale factor of 1 to\n   the
      receive window).\n   This option MAY be sent in an initial <SYN> segment (i.e.,
      a segment\n   with the SYN bit on and the ACK bit off).  If a Window Scale option\n
      \  was received in the initial <SYN> segment, then this option MAY be\n   sent
      in the <SYN,ACK> segment.  A Window Scale option in a segment\n   without a
      SYN bit MUST be ignored.\n   The window field in a segment where the SYN bit
      is set (i.e., a <SYN>\n   or <SYN,ACK>) MUST NOT be scaled.\n"
    title: 2.2.  Window Scale Option
  - contents:
    - "2.3.  Using the Window Scale Option\n   A model implementation of window scaling
      is as follows, using the\n   notation of [RFC0793]:\n   o  The connection state
      is augmented by two window shift counters,\n      Snd.Wind.Shift and Rcv.Wind.Shift,
      to be applied to the incoming\n      and outgoing window fields, respectively.\n
      \  o  If a TCP receives a <SYN> segment containing a Window Scale\n      option,
      it SHOULD send its own Window Scale option in the\n      <SYN,ACK> segment.\n
      \  o  The Window Scale option MUST be sent with shift.cnt = R, where R\n      is
      the value that the TCP would like to use for its receive\n      window.\n   o
      \ Upon receiving a <SYN> segment with a Window Scale option\n      containing
      shift.cnt = S, a TCP MUST set Snd.Wind.Shift to S and\n      MUST set Rcv.Wind.Shift
      to R; otherwise, it MUST set both\n      Snd.Wind.Shift and Rcv.Wind.Shift to
      zero.\n   o  The window field (SEG.WND) in the header of every incoming\n      segment,
      with the exception of <SYN> segments, MUST be left-\n      shifted by Snd.Wind.Shift
      bits before updating SND.WND:\n                    SND.WND = SEG.WND << Snd.Wind.Shift\n
      \     (assuming the other conditions of [RFC0793] are met, and using the\n      \"C\"
      notation \"<<\" for left-shift).\n   o  The window field (SEG.WND) of every
      outgoing segment, with the\n      exception of <SYN> segments, MUST be right-shifted
      by\n      Rcv.Wind.Shift bits:\n                    SEG.WND = RCV.WND >> Rcv.Wind.Shift\n
      \  TCP determines if a data segment is \"old\" or \"new\" by testing whether\n
      \  its sequence number is within 2^31 bytes of the left edge of the\n   window,
      and if it is not, discarding the data as \"old\".  To insure\n   that new data
      is never mistakenly considered old and vice versa, the\n   left edge of the
      sender's window has to be at most 2^31 away from the\n   right edge of the receiver's
      window.  The same is true of the\n   sender's right edge and receiver's left
      edge.  Since the right and\n   left edges of either the sender's or receiver's
      window differ by the\n   window size, and since the sender and receiver windows
      can be out of\n   phase by at most the window size, the above constraints imply
      that\n   two times the maximum window size must be less than 2^31, or\n                             max
      window < 2^30\n   Since the max window is 2^S (where S is the scaling shift
      count)\n   times at most 2^16 - 1 (the maximum unscaled window), the maximum\n
      \  window is guaranteed to be < 2^30 if S <= 14.  Thus, the shift count\n   MUST
      be limited to 14 (which allows windows of 2^30 = 1 GiB).  If a\n   Window Scale
      option is received with a shift.cnt value larger than\n   14, the TCP SHOULD
      log the error but MUST use 14 instead of the\n   specified value.  This is safe
      as a sender can always choose to only\n   partially use any signaled receive
      window.  If the receiver is\n   scaling by a factor larger than 14 and the sender
      is only scaling by\n   14, then the receive window used by the sender will appear
      smaller\n   than it is in reality.\n   The scale factor applies only to the
      window field as transmitted in\n   the TCP header; each TCP using extended windows
      will maintain the\n   window values locally as 32-bit numbers.  For example,
      the\n   \"congestion window\" computed by slow start and congestion avoidance\n
      \  (see [RFC5681]) is not affected by the scale factor, so window\n   scaling
      will not introduce quantization into the congestion window.\n"
    title: 2.3.  Using the Window Scale Option
  - contents:
    - "2.4.  Addressing Window Retraction\n   When a non-zero scale factor is in use,
      there are instances when a\n   retracted window can be offered -- see Appendix
      F for a detailed\n   example.  The end of the window will be on a boundary based
      on the\n   granularity of the scale factor being used.  If the sequence number\n
      \  is then updated by a number of bytes smaller than that granularity,\n   the
      TCP will have to either advertise a new window that is beyond\n   what it previously
      advertised (and perhaps beyond the buffer) or will\n   have to advertise a smaller
      window, which will cause the TCP window\n   to shrink.  Implementations MUST
      ensure that they handle a shrinking\n   window, as specified in Section 4.2.2.16
      of [RFC1122].\n   For the receiver, this implies that:\n   1)  The receiver
      MUST honor, as in window, any segment that would\n       have been in window
      for any <ACK> sent by the receiver.\n   2)  When window scaling is in effect,
      the receiver SHOULD track the\n       actual maximum window sequence number
      (which is likely to be\n       greater than the window announced by the most
      recent <ACK>, if\n       more than one segment has arrived since the application
      consumed\n       any data in the receive buffer).\n   On the sender side:\n
      \  3)  The initial transmission MUST be within the window announced by\n       the
      most recent <ACK>.\n   4)  On first retransmission, or if the sequence number
      is out of\n       window by less than 2^Rcv.Wind.Shift, then do normal\n       retransmission(s)
      without regard to the receiver window as long\n       as the original segment
      was in window when it was sent.\n   5)  Subsequent retransmissions MAY only
      be sent if they are within\n       the window announced by the most recent <ACK>.\n"
    title: 2.4.  Addressing Window Retraction
  title: 2.  TCP Window Scale Option
- contents:
  - '3.  TCP Timestamps Option

    '
  - contents:
    - "3.1.  Introduction\n   The Timestamps option is introduced to address some
      of the issues\n   mentioned in Sections 1.1 and 1.2.  The Timestamps option
      is\n   specified in a symmetrical manner, so that Timestamp Value (TSval)\n
      \  timestamps are carried in both data and <ACK> segments and are echoed\n   in
      Timestamp Echo Reply (TSecr) fields carried in returning <ACK> or\n   data segments.
      \ Originally used primarily for timestamping individual\n   segments, the properties
      of the Timestamps option allow for taking\n   time measurements (Section 4)
      as well as additional uses (Section 5).\n   It is necessary to remember that
      there is a distinction between the\n   Timestamps option conveying timestamp
      information and the use of that\n   information.  In particular, the RTTM mechanism
      must be viewed\n   independently from updating the Retransmission Timeout (RTO)
      (see\n   Section 4.2).  In this case, the sample granularity also needs to be\n
      \  taken into account.  Other mechanisms, such as PAWS or Eifel, are not\n   built
      upon the timestamp information itself but are based on the\n   intrinsic property
      of monotonically non-decreasing values.\n   The Timestamps option is important
      when large receive windows are\n   used to allow the use of the PAWS mechanism
      (see Section 5).\n   Furthermore, the option may be useful for all TCPs, since
      it\n   simplifies the sender and allows the use of additional optimizations\n
      \  such as Eifel ([RFC3522], [RFC4015]) and others ([RFC6817],\n   [Kuzmanovic03],
      [Kuehlewind10]).\n"
    title: 3.1.  Introduction
  - contents:
    - "3.2.  Timestamps Option\n   TCP is a symmetric protocol, allowing data to be
      sent at any time in\n   either direction, and therefore timestamp echoing may
      occur in either\n   direction.  For simplicity and symmetry, we specify that
      timestamps\n   always be sent and echoed in both directions.  For efficiency,
      we\n   combine the timestamp and timestamp reply fields into a single TCP\n
      \  Timestamps option.\n   TCP Timestamps option (TSopt):\n   Kind: 8\n   Length:
      10 bytes\n          +-------+-------+---------------------+---------------------+\n
      \         |Kind=8 |  10   |   TS Value (TSval)  |TS Echo Reply (TSecr)|\n          +-------+-------+---------------------+---------------------+\n
      \             1       1              4                     4\n   The Timestamps
      option carries two four-byte timestamp fields.  The\n   TSval field contains
      the current value of the timestamp clock of the\n   TCP sending the option.\n
      \  The TSecr field is valid if the ACK bit is set in the TCP header.  If\n   the
      ACK bit is not set in the outgoing TCP header, the sender of that\n   segment
      SHOULD set the TSecr field to zero.  When the ACK bit is set\n   in an outgoing
      segment, the sender MUST echo a recently received\n   TSval sent by the remote
      TCP in the TSval field of a Timestamps\n   option.  The exact rules on which
      TSval MUST be echoed are given in\n   Section 4.3.  When the ACK bit is not
      set, the receiver MUST ignore\n   the value of the TSecr field.\n   A TCP MAY
      send the TSopt in an initial <SYN> segment (i.e., segment\n   containing a SYN
      bit and no ACK bit), and MAY send a TSopt in\n   <SYN,ACK> only if it received
      a TSopt in the initial <SYN> segment\n   for the connection.\n   Once TSopt
      has been successfully negotiated, that is both <SYN> and\n   <SYN,ACK> contain
      TSopt, the TSopt MUST be sent in every non-<RST>\n   segment for the duration
      of the connection, and SHOULD be sent in an\n   <RST> segment (see Section 5.2
      for details).  The TCP SHOULD remember\n   this state by setting a flag, referred
      to as Snd.TS.OK, to one.  If a\n   non-<RST> segment is received without a TSopt,
      a TCP SHOULD silently\n   drop the segment.  A TCP MUST NOT abort a TCP connection
      because any\n   segment lacks an expected TSopt.\n   Implementations are strongly
      encouraged to follow the above rules for\n   handling a missing Timestamps option
      and the order of precedence\n   mentioned in Section 5.3 when deciding on the
      acceptance of a\n   segment.\n   If a receiver chooses to accept a segment without
      an expected\n   Timestamps option, it must be clear that undetectable data corruption\n
      \  may occur.\n   Such a TCP receiver may experience undetectable wrapped-sequence\n
      \  effects, such as data (payload) corruption or session stalls.  In\n   order
      to maintain the integrity of the payload data, in particular on\n   high-speed
      networks, it is paramount to follow the described\n   processing rules.\n   However,
      it has been mentioned that under some circumstances, the\n   above guidelines
      are too strict, and some paths sporadically suppress\n   the Timestamps option,
      while maintaining payload integrity.  A path\n   behaving in this manner should
      be deemed unacceptable, but it has\n   been noted that some implementations
      relax the acceptance rules as a\n   workaround and allow TCP to run across such
      paths [RE-1323BIS].\n   If a TSopt is received on a connection where TSopt was
      not negotiated\n   in the initial three-way handshake, the TSopt MUST be ignored
      and the\n   packet processed normally.\n   In the case of crossing <SYN> segments
      where one <SYN> contains a\n   TSopt and the other doesn't, both sides MAY send
      a TSopt in the\n   <SYN,ACK> segment.\n   TSopt is required for the two mechanisms
      described in Sections 4 and\n   5.  There are also other mechanisms that rely
      on the presence of the\n   TSopt, e.g., [RFC3522].  If a TCP stopped sending
      TSopt at any time\n   during an established session, it interferes with these
      mechanisms.\n   This update to [RFC1323] describes explicitly the previous assumption\n
      \  (see Section 5.2) that each TCP segment must have a TSopt, once\n   negotiated.\n"
    title: 3.2.  Timestamps Option
  title: 3.  TCP Timestamps Option
- contents:
  - '4.  The RTTM Mechanism

    '
  - contents:
    - "4.1.  Introduction\n   One use of the Timestamps option is to measure the round-trip
      time\n   (RTT) of virtually every packet acknowledged.  The RTTM mechanism\n
      \  requires a Timestamps option in every measured segment, with a TSval\n   that
      is obtained from a (virtual) \"timestamp clock\".  Values of this\n   clock
      MUST be at least approximately proportional to real time, in\n   order to measure
      actual RTT.\n   TCP measures the RTT, primarily for the purpose of arriving
      at a\n   reasonable value for the RTO timer interval.  Accurate and current\n
      \  RTT estimates are necessary to adapt to changing traffic conditions,\n   while
      a conservative estimate of the RTO interval is necessary to\n   minimize spurious
      RTOs.\n   These TSval values are echoed in TSecr values in the reverse\n   direction.
      \ The difference between a received TSecr value and the\n   current timestamp
      clock value provides an RTT measurement.\n   When timestamps are used, every
      segment that is received will contain\n   a TSecr value.  However, these values
      cannot all be used to update\n   the measured RTT.  The following example illustrates
      why.  It shows a\n   one-way data flow with segments arriving in sequence without
      loss.\n   Here A, B, C... represent data blocks occupying successive blocks
      of\n   sequence numbers, and ACK(A),...  represent the corresponding\n   cumulative
      acknowledgments.  The two timestamp fields of the\n   Timestamps option are
      shown symbolically as <TSval=x,TSecr=y>.  Each\n   TSecr field contains the
      value most recently received in a TSval\n   field.\n             TCP  A                                     TCP
      B\n                             <A,TSval=1,TSecr=120> ----->\n                  <----
      <ACK(A),TSval=127,TSecr=1>\n                             <B,TSval=5,TSecr=127>
      ----->\n                  <---- <ACK(B),TSval=131,TSecr=5>\n               .
      . . . . . . . . . . . . . . . . . . . . .\n                             <C,TSval=65,TSecr=131>
      ---->\n                  <---- <ACK(C),TSval=191,TSecr=65>\n                                 (etc.)\n
      \  The dotted line marks a pause (60 time units long) in which A had\n   nothing
      to send.  Note that this pause inflates the RTT, which B\n   could infer from
      receiving TSecr=131 in data segment C.  Thus, in\n   one-way data flows, RTTM
      in the reverse direction measures a value\n   that is inflated by gaps in sending
      data.  However, the following\n   rule prevents a resulting inflation of the
      measured RTT:\n   RTTM Rule: A TSecr value received in a segment MAY be used
      to update\n              the averaged RTT measurement only if the segment advances\n
      \             the left edge of the send window, i.e., SND.UNA is\n              increased.\n
      \  Since TCP B is not sending data, the data segment C does not\n   acknowledge
      any new data when it arrives at B.  Thus, the inflated\n   RTTM measurement
      is not used to update B's RTTM measurement.\n"
    title: 4.1.  Introduction
  - contents:
    - "4.2.  Updating the RTO Value\n   When [RFC1323] was originally written, it
      was perceived that taking\n   RTT measurements for each segment, and also during
      retransmissions,\n   would contribute to reduce spurious RTOs, while maintaining
      the\n   timeliness of necessary RTOs.  At the time, RTO was also the only\n
      \  mechanism to make use of the measured RTT.  It has been shown that\n   taking
      more RTT samples has only a very limited effect to optimize\n   RTOs [Allman99].\n
      \  Implementers should note that with timestamps, multiple RTTMs can be\n   taken
      per RTT.  The [RFC6298] RTT estimator has weighting factors,\n   alpha and beta,
      based on an implicit assumption that at most one RTTM\n   will be sampled per
      RTT.  When multiple RTTMs per RTT are available\n   to update the RTT estimator,
      an implementation SHOULD try to adhere\n   to the spirit of the history specified
      in [RFC6298].  An\n   implementation suggestion is detailed in Appendix G.\n
      \  [Ludwig00] and [Floyd05] have highlighted the problem that an\n   unmodified
      RTO calculation, which is updated with per-packet RTT\n   samples, will truncate
      the path history too soon.  This can lead to\n   an increase in spurious retransmissions,
      when the path properties\n   vary in the order of a few RTTs, but a high number
      of RTT samples are\n   taken on a much shorter timescale.\n"
    title: 4.2.  Updating the RTO Value
  - contents:
    - "4.3.  Which Timestamp to Echo\n   If more than one Timestamps option is received
      before a reply segment\n   is sent, the TCP must choose only one of the TSvals
      to echo, ignoring\n   the others.  To minimize the state kept in the receiver
      (i.e., the\n   number of unprocessed TSvals), the receiver should be required
      to\n   retain at most one timestamp in the connection control block.\n   There
      are three situations to consider:\n   (A)  Delayed ACKs.\n        Many TCPs
      acknowledge only every second segment out of a group\n        of segments arriving
      within a short time interval; this policy\n        is known generally as \"delayed
      ACKs\".  The data-sender TCP must\n        measure the effective RTT, including
      the additional time due to\n        delayed ACKs, or else it will retransmit
      unnecessarily.  Thus,\n        when delayed ACKs are in use, the receiver SHOULD
      reply with the\n        TSval field from the earliest unacknowledged segment.\n
      \  (B)  A hole in the sequence space (segment(s) has been lost).\n        The
      sender will continue sending until the window is filled, and\n        the receiver
      may be generating <ACK>s as these out-of-order\n        segments arrive (e.g.,
      to aid \"Fast Retransmit\").\n        The lost segment is probably a sign of
      congestion, and in that\n        situation the sender should be conservative
      about\n        retransmission.  Furthermore, it is better to overestimate than\n
      \       underestimate the RTT.  An <ACK> for an out-of-order segment\n        SHOULD,
      therefore, contain the timestamp from the most recent\n        segment that
      advanced RCV.NXT.\n        The same situation occurs if segments are reordered
      by the\n        network.\n   (C)  A filled hole in the sequence space.\n        The
      segment that fills the hole and advances the window\n        represents the
      most recent measurement of the network\n        characteristics.  An RTT computed
      from an earlier segment would\n        probably include the sender's retransmit
      timeout, badly biasing\n        the sender's average RTT estimate.  Thus, the
      timestamp from the\n        latest segment (which filled the hole) MUST be echoed.\n
      \  An algorithm that covers all three cases is described in the\n   following
      rules for Timestamps option processing on a synchronized\n   connection:\n   (1)
      \ The connection state is augmented with two 32-bit slots:\n        TS.Recent
      holds a timestamp to be echoed in TSecr whenever a\n        segment is sent,
      and Last.ACK.sent holds the ACK field from the\n        last segment sent.  Last.ACK.sent
      will equal RCV.NXT except when\n        <ACK>s have been delayed.\n   (2)  If:\n
      \           SEG.TSval >= TS.Recent and SEG.SEQ <= Last.ACK.sent\n        then
      SEG.TSval is copied to TS.Recent; otherwise, it is ignored.\n   (3)  When a
      TSopt is sent, its TSecr field is set to the current\n        TS.Recent value.\n
      \  The following examples illustrate these rules.  Here A, B, C...\n   represent
      data segments occupying successive blocks of sequence\n   numbers, and ACK(A),...
      represent the corresponding acknowledgment\n   segments.  Note that ACK(A) has
      the same sequence number as B.  We\n   show only one direction of timestamp
      echoing, for clarity.\n   o  Segments arrive in sequence, and some of the <ACK>s
      are delayed.\n      By case (A), the timestamp from the oldest unacknowledged
      segment\n      is echoed.\n                                                  TS.Recent\n
      \               <A, TSval=1> ------------------->\n                                                      1\n
      \               <B, TSval=2> ------------------->\n                                                      1\n
      \               <C, TSval=3> ------------------->\n                                                      1\n
      \                        <---- <ACK(C), TSecr=1>\n                (etc.)\n   o
      \ Segments arrive out of order, and every segment is acknowledged.\n      By
      case (B), the timestamp from the last segment that advanced the\n      left
      window edge is echoed until the missing segment arrives; it\n      is echoed
      according to case (C).  The same sequence would occur if\n      segments B and
      D were lost and retransmitted.\n                                                  TS.Recent\n
      \               <A, TSval=1> ------------------->\n                                                      1\n
      \                        <---- <ACK(A), TSecr=1>\n                                                      1\n
      \               <C, TSval=3> ------------------->\n                                                      1\n
      \                        <---- <ACK(A), TSecr=1>\n                                                      1\n
      \               <B, TSval=2> ------------------->\n                                                      2\n
      \                        <---- <ACK(C), TSecr=2>\n                                                      2\n
      \               <E, TSval=5> ------------------->\n                                                      2\n
      \                        <---- <ACK(C), TSecr=2>\n                                                      2\n
      \               <D, TSval=4> ------------------->\n                                                      4\n
      \                        <---- <ACK(E), TSecr=4>\n                (etc.)\n"
    title: 4.3.  Which Timestamp to Echo
  title: 4.  The RTTM Mechanism
- contents:
  - '5.  PAWS - Protection Against Wrapped Sequences

    '
  - contents:
    - "5.1.  Introduction\n   Another use for the Timestamps option is the PAWS mechanism.\n
      \  Section 5.2 describes a simple mechanism to reject old duplicate\n   segments
      that might corrupt an open TCP connection.  PAWS operates\n   within a single
      TCP connection, using state that is saved in the\n   connection control block.
      \ Section 5.8 and Appendix H discuss the\n   implications of the PAWS mechanism
      for avoiding old duplicates from\n   previous incarnations of the same connection.\n"
    title: 5.1.  Introduction
  - contents:
    - "5.2.  The PAWS Mechanism\n   PAWS uses the TCP Timestamps option described
      earlier and assumes\n   that every received TCP segment (including data and
      <ACK> segments)\n   contains a timestamp SEG.TSval whose values are monotonically
      non-\n   decreasing in time.  The basic idea is that a segment can be\n   discarded
      as an old duplicate if it is received with a timestamp\n   SEG.TSval less than
      some timestamps recently received on this\n   connection.\n   In the PAWS mechanism,
      the \"timestamps\" are 32-bit unsigned integers\n   in a modular 32-bit space.
      \ Thus, \"less than\" is defined the same way\n   it is for TCP sequence numbers,
      and the same implementation\n   techniques apply.  If s and t are timestamp
      values,\n                       s < t  if 0 < (t - s) < 2^31,\n   computed in
      unsigned 32-bit arithmetic.\n   The choice of incoming timestamps to be saved
      for this comparison\n   MUST guarantee a value that is monotonically non-decreasing.
      \ For\n   example, an implementation might save the timestamp from the segment\n
      \  that last advanced the left edge of the receive window, i.e., the\n   most
      recent in-sequence segment.  For simplicity, the value TS.Recent\n   introduced
      in Section 4.3 is used instead, as using a common value\n   for both PAWS and
      RTTM simplifies the implementation.  As Section 4.3\n   explained, TS.Recent
      differs from the timestamp from the last in-\n   sequence segment only in the
      case of delayed <ACK>s, and therefore by\n   less than one window.  Either choice
      will, therefore, protect against\n   sequence number wrap-around.\n   PAWS submits
      all incoming segments to the same test, and therefore\n   protects against duplicate
      <ACK> segments as well as data segments.\n   (An alternative non-symmetric algorithm
      would protect against old\n   duplicate <ACK>s: the sender of data would reject
      incoming <ACK>\n   segments whose TSecr values were less than the TSecr saved
      from the\n   last segment whose ACK field advanced the left edge of the send\n
      \  window.  This algorithm was deemed to lack economy of mechanism and\n   symmetry.)\n
      \  TSval timestamps sent on <SYN> and <SYN,ACK> segments are used to\n   initialize
      PAWS.  PAWS protects against old duplicate non-<SYN>\n   segments and duplicate
      <SYN> segments received while there is a\n   synchronized connection.  Duplicate
      <SYN> and <SYN,ACK> segments\n   received when there is no connection will be
      discarded by the normal\n   3-way handshake and sequence number checks of TCP.\n
      \  [RFC1323] recommended that <RST> segments NOT carry timestamps and\n   that
      they be acceptable regardless of their timestamp.  At that time,\n   the thinking
      was that old duplicate <RST> segments should be\n   exceedingly unlikely, and
      their cleanup function should take\n   precedence over timestamps.  More recently,
      discussions about various\n   blind attacks on TCP connections have raised the
      suggestion that if\n   the Timestamps option is present, SEG.TSecr could be
      used to provide\n   stricter acceptance tests for <RST> segments.\n   While
      still under discussion, to enable research into this area it is\n   now RECOMMENDED
      that when generating an <RST>, if the segment causing\n   the <RST> to be generated
      contains a Timestamps option, the <RST>\n   should also contain a Timestamps
      option.  In the <RST> segment,\n   SEG.TSecr SHOULD be set to SEG.TSval from
      the incoming segment and\n   SEG.TSval SHOULD be set to zero.  If an <RST> is
      being generated\n   because of a user abort, and Snd.TS.OK is set, then a Timestamps\n
      \  option SHOULD be included in the <RST>.  When an <RST> segment is\n   received,
      it MUST NOT be subjected to the PAWS check by verifying an\n   acceptable value
      in SEG.TSval, and information from the Timestamps\n   option MUST NOT be used
      to update connection state information.\n   SEG.TSecr MAY be used to provide
      stricter <RST> acceptance checks.\n"
    title: 5.2.  The PAWS Mechanism
  - contents:
    - "5.3.  Basic PAWS Algorithm\n   If the PAWS algorithm is used, the following
      processing MUST be\n   performed on all incoming segments for a synchronized
      connection.\n   Also, PAWS processing MUST take precedence over the regular
      TCP\n   acceptability check (Section 3.3 in [RFC0793]), which is performed\n
      \  after verification of the received Timestamps option:\n   R1)  If there is
      a Timestamps option in the arriving segment,\n        SEG.TSval < TS.Recent,
      TS.Recent is valid (see later\n        discussion), and if the RST bit is not
      set, then treat the\n        arriving segment as not acceptable:\n           Send
      an acknowledgment in reply as specified in Section 3.9\n           of [RFC0793],
      page 69, and drop the segment.\n           Note: it is necessary to send an
      <ACK> segment in order to\n           retain TCP's mechanisms for detecting
      and recovering from\n           half-open connections.  For an example, see
      Figure 10 of\n           [RFC0793].\n   R2)  If the segment is outside the window,
      reject it (normal TCP\n        processing).\n   R3)  If an arriving segment
      satisfies SEG.TSval >= TS.Recent and\n        SEG.SEQ <= Last.ACK.sent (see
      Section 4.3), then record its\n        timestamp in TS.Recent.\n   R4)  If an
      arriving segment is in sequence (i.e., at the left window\n        edge), then
      accept it normally.\n   R5)  Otherwise, treat the segment as a normal in-window,\n
      \       out-of-sequence TCP segment (e.g., queue it for later delivery\n        to
      the user).\n   Steps R2, R4, and R5 are the normal TCP processing steps specified
      by\n   [RFC0793].\n   It is important to note that the timestamp MUST be checked
      only when\n   a segment first arrives at the receiver, regardless of whether
      it is\n   in sequence or it must be queued for later delivery.\n   Consider
      the following example.\n      Suppose the segment sequence: A.1, B.1, C.1, ...,
      Z.1 has been\n      sent, where the letter indicates the sequence number and
      the digit\n      represents the timestamp.  Suppose also that segment B.1 has
      been\n      lost.  The timestamp in TS.Recent is 1 (from A.1), so C.1, ...,\n
      \     Z.1 are considered acceptable and are queued.  When B is\n      retransmitted
      as segment B.2 (using the latest timestamp), it\n      fills the hole and causes
      all the segments through Z to be\n      acknowledged and passed to the user.
      \ The timestamps of the queued\n      segments are *not* inspected again at
      this time, since they have\n      already been accepted.  When B.2 is accepted,
      TS.Recent is set to\n      2.\n   This rule allows reasonable performance under
      loss.  A full window of\n   data is in transit at all times, and after a loss
      a full window less\n   one segment will show up out of sequence to be queued
      at the receiver\n   (e.g., up to ~2^30 bytes of data); the Timestamps option
      must not\n   result in discarding this data.\n   In certain unlikely circumstances,
      the algorithm of rules R1-R5 could\n   lead to discarding some segments unnecessarily,
      as shown in the\n   following example:\n      Suppose again that segments: A.1,
      B.1, C.1, ..., Z.1 have been\n      sent in sequence and that segment B.1 has
      been lost.  Furthermore,\n      suppose delivery of some of C.1, ... Z.1 is
      delayed until *after*\n      the retransmission B.2 arrives at the receiver.
      \ These delayed\n      segments will be discarded unnecessarily when they do
      arrive,\n      since their timestamps are now out of date.\n   This case is
      very unlikely to occur.  If the retransmission was\n   triggered by a timeout,
      some of the segments C.1, ... Z.1 must have\n   been delayed longer than the
      RTO time.  This is presumably an\n   unlikely event, or there would be many
      spurious timeouts and\n   retransmissions.  If B's retransmission was triggered
      by the \"Fast\n   Retransmit\" algorithm, i.e., by duplicate <ACK>s, then the
      queued\n   segments that caused these <ACK>s must have been received already.\n
      \  Even if a segment were delayed past the RTO, the Fast Retransmit\n   mechanism
      [Jacobson90c] will cause the delayed segments to be\n   retransmitted at the
      same time as B.2, avoiding an extra RTT and,\n   therefore, causing a very small
      performance penalty.\n   We know of no case with a significant probability of
      occurrence in\n   which timestamps will cause performance degradation by unnecessarily\n
      \  discarding segments.\n"
    title: 5.3.  Basic PAWS Algorithm
  - contents:
    - "5.4.  Timestamp Clock\n   It is important to understand that the PAWS algorithm
      does not\n   require clock synchronization between the sender and receiver.
      \ The\n   sender's timestamp clock is used as a source of monotonic non-\n   decreasing
      values to stamp the segments.  The receiver treats the\n   timestamp value as
      simply a monotonically non-decreasing serial\n   number, without any connection
      to time.  From the receiver's\n   viewpoint, the timestamp is acting as a logical
      extension of the\n   high-order bits of the sequence number.\n   The receiver
      algorithm does place some requirements on the frequency\n   of the timestamp
      clock.\n   (a)  The timestamp clock must not be \"too slow\".\n        It MUST
      tick at least once for each 2^31 bytes sent.  In fact,\n        in order to
      be useful to the sender for round-trip timing, the\n        clock SHOULD tick
      at least once per window's worth of data, and\n        even with the window
      extension defined in Section 2.2, 2^31\n        bytes must be at least two windows.\n
      \       To make this more quantitative, any clock faster than 1 tick/sec\n        will
      reject old duplicate segments for link speeds of ~8 Gbps.\n        A 1 ms timestamp
      clock will work at link speeds up to 8 Tbps\n        (8*10^12) bps!\n   (b)
      \ The timestamp clock must not be \"too fast\".\n        The recycling time
      of the timestamp clock MUST be greater than\n        MSL seconds.  Since the
      clock (timestamp) is 32 bits and the\n        worst-case MSL is 255 seconds,
      the maximum acceptable clock\n        frequency is one tick every 59 ns.\n        However,
      it is desirable to establish a much longer recycle\n        period, in order
      to handle outdated timestamps on idle\n        connections (see Section 5.5),
      and to relax the MSL requirement\n        for preventing sequence number wrap-around.
      \ With a 1 ms\n        timestamp clock, the 32-bit timestamp will wrap its sign
      bit in\n        24.8 days.  Thus, it will reject old duplicates on the same\n
      \       connection if MSL is 24.8 days or less.  This appears to be a\n        very
      safe figure; an MSL of 24.8 days or longer can probably be\n        assumed
      in the Internet without requiring precise MSL\n        enforcement.\n   Based
      upon these considerations, we choose a timestamp clock\n   frequency in the
      range 1 ms to 1 sec per tick.  This range also\n   matches the requirements
      of the RTTM mechanism, which does not need\n   much more resolution than the
      granularity of the retransmit timer,\n   e.g., tens or hundreds of milliseconds.\n
      \  The PAWS mechanism also puts a strong monotonicity requirement on the\n   sender's
      timestamp clock.  The method of implementation of the\n   timestamp clock to
      meet this requirement depends upon the system\n   hardware and software.\n   o
      \ Some hosts have a hardware clock that is guaranteed to be\n      monotonic
      between hardware resets.\n   o  A clock interrupt may be used to simply increment
      a binary integer\n      by 1 periodically.\n   o  The timestamp clock may be
      derived from a system clock that is\n      subject to being abruptly changed
      by adding a variable offset\n      value.  This offset is initialized to zero.
      \ When a new timestamp\n      clock value is needed, the offset can be adjusted
      as necessary to\n      make the new value equal to or larger than the previous
      value\n      (which was saved for this purpose).\n   o  A random offset may
      be added to the timestamp clock on a per-\n      connection basis.  See [RFC6528],
      Section 3, on randomizing the\n      initial sequence number (ISN).  The same
      function with a different\n      secret key can be used to generate the per-connection
      timestamp\n      offset.\n"
    title: 5.4.  Timestamp Clock
  - contents:
    - "5.5.  Outdated Timestamps\n   If a connection remains idle long enough for
      the timestamp clock of\n   the other TCP to wrap its sign bit, then the value
      saved in TS.Recent\n   will become too old; as a result, the PAWS mechanism
      will cause all\n   subsequent segments to be rejected, freezing the connection
      (until\n   the timestamp clock wraps its sign bit again).\n   With the chosen
      range of timestamp clock frequencies (1 sec to 1 ms),\n   the time to wrap the
      sign bit will be between 24.8 days and 24800\n   days.  A TCP connection that
      is idle for more than 24 days and then\n   comes to life is exceedingly unusual.
      \ However, it is undesirable in\n   principle to place any limitation on TCP
      connection lifetimes.\n   We therefore require that an implementation of PAWS
      include a\n   mechanism to \"invalidate\" the TS.Recent value when a connection
      is\n   idle for more than 24 days.  (An alternative solution to the problem\n
      \  of outdated timestamps would be to send keep-alive segments at a very\n   low
      rate, but still more often than the wrap-around time for\n   timestamps, e.g.,
      once a day.  This would impose negligible overhead.\n   However, the TCP specification
      has never included keep-alives, so the\n   solution based upon invalidation
      was chosen.)\n   Note that a TCP does not know the frequency, and therefore
      the wrap-\n   around time, of the other TCP, so it must assume the worst.  The\n
      \  validity of TS.Recent needs to be checked only if the basic PAWS\n   timestamp
      check fails, i.e., only if SEG.TSval < TS.Recent.  If\n   TS.Recent is found
      to be invalid, then the segment is accepted,\n   regardless of the failure of
      the timestamp check, and rule R3 updates\n   TS.Recent with the TSval from the
      new segment.\n   To detect how long the connection has been idle, the TCP MAY
      update a\n   clock or timestamp value associated with the connection whenever\n
      \  TS.Recent is updated, for example.  The details will be\n   implementation
      dependent.\n"
    title: 5.5.  Outdated Timestamps
  - contents:
    - "5.6.  Header Prediction\n   \"Header prediction\" [Jacobson90a] is a high-performance
      transport\n   protocol implementation technique that is most important for high-\n
      \  speed links.  This technique optimizes the code for the most common\n   case,
      receiving a segment correctly and in order.  Using header\n   prediction, the
      receiver asks the question, \"Is this segment the next\n   in sequence?\"  This
      question can be answered in fewer machine\n   instructions than the question,
      \"Is this segment within the window?\"\n   Adding header prediction to our timestamp
      procedure leads to the\n   following recommended sequence for processing an
      arriving TCP\n   segment:\n   H1)  Check timestamp (same as step R1 above).\n
      \  H2)  Do header prediction: if the segment is next in sequence and if\n        there
      are no special conditions requiring additional processing,\n        accept the
      segment, record its timestamp, and skip H3.\n   H3)  Process the segment normally,
      as specified in RFC 793.  This\n        includes dropping segments that are
      outside the window and\n        possibly sending acknowledgments, and queuing
      in-window,\n        out-of-sequence segments.\n   Another possibility would
      be to interchange steps H1 and H2, i.e., to\n   perform the header prediction
      step H2 *first*, and perform H1 and H3\n   only when header prediction fails.
      \ This could be a performance\n   improvement, since the timestamp check in
      step H1 is very unlikely to\n   fail, and it requires unsigned modulo arithmetic.
      \ To perform this\n   check on every single segment is contrary to the philosophy
      of header\n   prediction.  We believe that this change might produce a measurable\n
      \  reduction in CPU time for TCP protocol processing on high-speed\n   networks.\n
      \  However, putting H2 first would create a hazard: a segment from 2^32\n   bytes
      in the past might arrive at exactly the wrong time and be\n   accepted mistakenly
      by the header-prediction step.  The following\n   reasoning has been introduced
      in [RFC1185] to show that the\n   probability of this failure is negligible.\n
      \     If all segments are equally likely to show up as old duplicates,\n      then
      the probability of an old duplicate exactly matching the left\n      window
      edge is the maximum segment size (MSS) divided by the size\n      of the sequence
      space.  This ratio must be less than 2^-16, since\n      MSS must be < 2^16;
      for example, it will be (2^12)/(2^32) = 2^-20\n      for [a 100 Mbit/s] link.
      \ However, the older a segment is, the\n      less likely it is to be retained
      in the Internet, and under any\n      reasonable model of segment lifetime the
      probability of an old\n      duplicate exactly at the left window edge must
      be much smaller\n      than 2^-16.\n      The 16 bit TCP checksum also allows
      a basic unreliability of one\n      part in 2^16.  A protocol mechanism whose
      reliability exceeds the\n      reliability of the TCP checksum should be considered
      \"good\n      enough\", i.e., it won't contribute significantly to the overall\n
      \     error rate.  We therefore believe we can ignore the problem of an\n      old
      duplicate being accepted by doing header prediction before\n      checking the
      timestamp.  [Note: the notation for exponentiation\n      has been changed from
      how it appeared in RFC 1185.]\n   However, this probabilistic argument is not
      universally accepted, and\n   the consensus at present is that the performance
      gain does not\n   justify the hazard in the general case.  It is therefore recommended\n
      \  that H2 follow H1.\n"
    title: 5.6.  Header Prediction
  - contents:
    - "5.7.  IP Fragmentation\n   At high data rates, the protection against old segments
      provided by\n   PAWS can be circumvented by errors in IP fragment reassembly
      (see\n   [RFC4963]).  The only way to protect against incorrect IP fragment\n
      \  reassembly is to not allow the segments to be fragmented.  This is\n   done
      by setting the Don't Fragment (DF) bit in the IP header.\n   Setting the DF
      bit implies the use of Path MTU Discovery as described\n   in [RFC1191], [RFC1981],
      and [RFC4821]; thus, any TCP implementation\n   that implements PAWS MUST also
      implement Path MTU Discovery.\n"
    title: 5.7.  IP Fragmentation
  - contents:
    - "5.8.  Duplicates from Earlier Incarnations of Connection\n   The PAWS mechanism
      protects against errors due to sequence number\n   wrap-around on high-speed
      connections.  Segments from an earlier\n   incarnation of the same connection
      are also a potential cause of old\n   duplicate errors.  In both cases, the
      TCP mechanisms to prevent such\n   errors depend upon the enforcement of an
      MSL by the Internet (IP)\n   layer (see the Appendix of RFC 1185 for a detailed
      discussion).\n   Unlike the case of sequence space wrap-around, the MSL required
      to\n   prevent old duplicate errors from earlier incarnations does not\n   depend
      upon the transfer rate.  If the IP layer enforces the\n   recommended 2-minute
      MSL of TCP, and if the TCP rules are followed,\n   TCP connections will be safe
      from earlier incarnations, no matter how\n   high the network speed.  Thus,
      the PAWS mechanism is not required for\n   this case.\n   We may still ask whether
      the PAWS mechanism can provide additional\n   security against old duplicates
      from earlier connections, allowing us\n   to relax the enforcement of MSL by
      the IP layer.  Appendix B explores\n   this question, showing that further assumptions
      and/or mechanisms are\n   required, beyond those of PAWS.  This is not part
      of the current\n   extension.\n"
    title: 5.8.  Duplicates from Earlier Incarnations of Connection
  title: 5.  PAWS - Protection Against Wrapped Sequences
- contents:
  - "6.  Conclusions and Acknowledgments\n   This memo presented a set of extensions
    to TCP to provide efficient\n   operation over large bandwidth * delay product
    paths and reliable\n   operation over very high-speed paths.  These extensions
    are designed\n   to provide compatible interworking with TCP stacks that do not\n
    \  implement the extensions.\n   These mechanisms are implemented using TCP options
    for scaled windows\n   and timestamps.  The timestamps are used for two distinct
    mechanisms:\n   RTTM and PAWS.\n   The Window Scale option was originally suggested
    by Mike St. Johns of\n   USAF/DCA.  The present form of the option was suggested
    by Mike\n   Karels of UC Berkeley in response to a more cumbersome scheme defined\n
    \  by Van Jacobson.  Lixia Zhang helped formulate the PAWS mechanism\n   description
    in [RFC1185].\n   Finally, much of this work originated as the result of discussions\n
    \  within the End-to-End Task Force on the theoretical limitations of\n   transport
    protocols in general and TCP in particular.  Task force\n   members and others
    on the end2end-interest list have made valuable\n   contributions by pointing
    out flaws in the algorithms and the\n   documentation.  Continued discussion and
    development since the\n   publication of [RFC1323] originally occurred in the
    IETF TCP Large\n   Windows Working Group, later on in the End-to-End Task Force,
    and\n   most recently in the IETF TCP Maintenance Working Group.  The authors\n
    \  are grateful for all these contributions.\n"
  title: 6.  Conclusions and Acknowledgments
- contents:
  - "7.  Security Considerations\n   The TCP sequence space is a fixed size, and as
    the window becomes\n   larger, it becomes easier for an attacker to generate forged
    packets\n   that can fall within the TCP window and be accepted as valid\n   segments.
    \ While use of timestamps and PAWS can help to mitigate\n   this, when using PAWS,
    if an attacker is able to forge a packet that\n   is acceptable to the TCP connection,
    a timestamp that is in the\n   future would cause valid segments to be dropped
    due to PAWS checks.\n   Hence, implementers should take care to not open the TCP
    window\n   drastically beyond the requirements of the connection.\n   See [RFC5961]
    for mitigation strategies to blind in-window attacks.\n   A naive implementation
    that derives the timestamp clock value\n   directly from a system uptime clock
    may unintentionally leak this\n   information to an attacker.  This does not directly
    compromise any of\n   the mechanisms described in this document.  However, this
    may be\n   valuable information to a potential attacker.  It is therefore\n   RECOMMENDED
    to generate a random, per-connection offset to be used\n   with the clock source
    when generating the Timestamps option value\n   (see Section 5.4).  By carefully
    choosing this random offset, further\n   improvements as described in [RFC6191]
    are possible.\n   Expanding the TCP window beyond 64 KiB for IPv6 allows Jumbograms\n
    \  [RFC2675] to be used when the local network supports packets larger\n   than
    64 KiB.  When larger TCP segments are used, the TCP checksum\n   becomes weaker.\n
    \  Mechanisms to protect the TCP header from modification should also\n   protect
    the TCP options.\n   Middleboxes and TCP options:\n      Some middleboxes have
    been known to remove the TCP options\n      described in this document from TCP
    segments [Honda11].\n      Middleboxes that remove TCP options described in this
    document\n      from the <SYN> segment interfere with the selection of parameters\n
    \     appropriate for the session.  Removing any of these options in a\n      <SYN,ACK>
    segment will leave the end hosts in a state that\n      destroys the proper operation
    of the protocol.\n      *  If a Window Scale option is removed from a <SYN,ACK>
    segment,\n         the end hosts will not negotiate the window scaling factor\n
    \        correctly.  Middleboxes must not remove or modify the Window\n         Scale
    option from <SYN,ACK> segments.\n      *  If a stateful firewall uses the window
    field to detect whether\n         a received segment is inside the current window,
    and does not\n         support the Window Scale option, it will not be able to\n
    \        correctly determine whether or not a packet is in the window.\n         These
    middle boxes must also support the Window Scale option\n         and apply the
    scale factor when processing segments.  If the\n         window scale factor cannot
    be determined, it must not do\n         window-based processing.\n      *  If
    the Timestamps option is removed from the <SYN> or <SYN,ACK>\n         segments,
    high speed connections that need PAWS would not have\n         that protection.
    \ Successful negotiation of the Timestamps\n         option enforces a stricter
    verification of incoming segments at\n         the receiver.  If the Timestamps
    option was removed from a\n         subsequent data segment after a successful
    negotiation (e.g.,\n         as part of resegmentation), the segment is discarded
    by the\n         receiver without further processing.  Middleboxes should not\n
    \        remove the Timestamps option.\n      *  It must be noted that [RFC1323]
    doesn't address the case of the\n         Timestamps option being dropped or selectively
    omitted after\n         being negotiated, and that the update in this document
    may\n         cause some broken middlebox behavior to be detected\n         (potentially
    unresponsive TCP sessions).\n   Implementations that depend on PAWS could provide
    a mechanism for the\n   application to determine whether or not PAWS is in use
    on the\n   connection and choose to terminate the connection if that protection\n
    \  doesn't exist.  This is not just to protect the connection against\n   middleboxes
    that might remove the Timestamps option, but also against\n   remote hosts that
    do not have Timestamp support.\n"
  - contents:
    - "7.1.  Privacy Considerations\n   The TCP options described in this document
      do not expose individual\n   user's data.  However, a naive implementation simply
      using the system\n   clock as a source for the Timestamps option will reveal\n
      \  characteristics of the TCP, potentially allowing more targeted\n   attacks.
      \ It is therefore RECOMMENDED to generate a random, per-\n   connection offset
      to be used with the clock source when generating\n   the Timestamps option value
      (see Section 5.4).\n   Furthermore, the combination, relative ordering, and
      padding of the\n   TCP options described in Sections 2.2 and 3.2 will reveal
      additional\n   clues to allow the fingerprinting of the system.\n"
    title: 7.1.  Privacy Considerations
  title: 7.  Security Considerations
- contents:
  - "8.  IANA Considerations\n   The described TCP options are well known from the
    superceded\n   [RFC1323].  IANA has updated the \"TCP Option Kind Numbers\" table\n
    \  under \"TCP Parameters\" to list this document (RFC 7323) as the\n   reference
    for \"Window Scale\" and \"Timestamps\".\n"
  title: 8.  IANA Considerations
- contents:
  - '9.  References

    '
  - contents:
    - "9.1.  Normative References\n   [RFC793]   Postel, J., \"Transmission Control
      Protocol\", STD 7, RFC\n              793, September 1981.\n   [RFC1191]  Mogul,
      J. and S. Deering, \"Path MTU discovery\", RFC 1191,\n              November
      1990.\n   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n
      \             Requirement Levels\", BCP 14, RFC 2119, March 1997.\n"
    title: 9.1.  Normative References
  - contents:
    - "9.2.  Informative References\n   [Allman99] Allman, M. and V. Paxson, \"On
      Estimating End-to-End\n              Network Path Properties\", Proceedings
      of the ACM SIGCOMM\n              Technical Symposium, Cambridge, MA, September
      1999,\n              <http://aciri.org/mallman/papers/estimation-la.pdf>.\n
      \  [Floyd05]  Floyd, S., \"Subject: Re: [tcpm] RFC 1323: Timestamps\n              option\",
      message to the TCPM mailing list, 26 January\n              2007, <http://www.ietf.org/mail-archive/web/tcpm/current/\n
      \             msg02508.html>.\n   [Garlick77]\n              Garlick, L., Rom,
      R., and J. Postel, \"Issues in Reliable\n              Host-to-Host Protocols\",
      Proceedings of the Second\n              Berkeley Workshop on Distributed Data
      Management and\n              Computer Networks, March 1977,\n              <http://www.rfc-editor.org/ien/ien12.txt>.\n
      \  [Honda11]  Honda, M., Nishida, Y., Raiciu, C., Greenhalgh, A.,\n              Handley,
      M., and H. Tokuda, \"Is it Still Possible to\n              Extend TCP?\", Proceedings
      of the ACM Internet Measurement\n              Conference (IMC) '11, November
      2011.\n   [Jacobson88a]\n              Jacobson, V., \"Congestion Avoidance
      and Control\", SIGCOMM\n              '88, Stanford, CA, August 1988,\n              <http://ee.lbl.gov/papers/congavoid.pdf>.\n
      \  [Jacobson90a]\n              Jacobson, V., \"4BSD Header Prediction\", ACM
      Computer\n              Communication Review, April 1990.\n   [Jacobson90c]\n
      \             Jacobson, V., \"Subject: modified TCP congestion avoidance\n              algorithm\",
      message to the End2End-Interest mailing list,\n              30 April 1990,
      <ftp://ftp.isi.edu/end2end/\n              end2end-interest-1990.mail>.\n   [Karn87]
      \  Karn, P. and C. Partridge, \"Estimating Round-Trip Times in\n              Reliable
      Transport Protocols\", Proceedings of SIGCOMM '87,\n              August 1987.\n
      \  [Kuehlewind10]\n              Kuehlewind, M. and B. Briscoe, \"Chirping for
      Congestion\n              Control - Implementation Feasibility\", November 2010,\n
      \             <http://bobbriscoe.net/projects/netsvc_i-f/\n              chirp_pfldnet10.pdf>.\n
      \  [Kuzmanovic03]\n              Kuzmanovic, A. and E. Knightly, \"TCP-LP: Low-Priority\n
      \             Service via End-Point Congestion Control\", 2003,\n              <www.cs.northwestern.edu/~akuzma/doc/TCP-LP-ToN.pdf>.\n
      \  [Ludwig00] Ludwig, R. and K. Sklower, \"The Eifel Retransmission\n              Timer\",
      ACM SIGCOMM Computer Communication Review Volume\n              30 Issue 3,
      July 2000,\n              <http://ccr.sigcomm.org/archive/2000/july00/\n              LudwigFinal.pdf>.\n
      \  [Martin03] Martin, D., \"Subject: [Tsvwg] RFC 1323.bis\", message to\n              the
      TSVWG mailing list, 30 September 2003,\n              <http://www.ietf.org/mail-archive/web/tsvwg/current/\n
      \             msg04435.html>.\n   [Medina04] Medina, A., Allman, M., and S.
      Floyd, \"Measuring\n              Interactions Between Transport Protocols and
      Middleboxes\",\n              Proceedings of the ACM SIGCOMM/USENIX Internet
      Measurement\n              Conference, October 2004,\n              <http://www.icir.net/tbit/tbit-Aug2004.pdf>.\n
      \  [Medina05] Medina, A., Allman, M., and S. Floyd, \"Measuring the\n              Evolution
      of Transport Protocols in the Internet\", ACM\n              Computer Communication
      Review Volume 35, No. 2, April\n              2005,\n              <http://icir.net/floyd/papers/TCPevolution-Mar2005.pdf>.\n
      \  [RE-1323BIS]\n              Oppermann, A., \"Subject: Re: [tcpm] I-D Action:
      draft-\n              ietf.tcpm-1323bis-13.txt\", message to the TCPM mailing\n
      \             list, 01 June 2013, <http://www.ietf.org/\n              mail-archive/web/tcpm/current/msg08001.html>.\n
      \  [RFC1072]  Jacobson, V. and R. Braden, \"TCP extensions for long-delay\n
      \             paths\", RFC 1072, October 1988.\n   [RFC1122]  Braden, R., \"Requirements
      for Internet Hosts -\n              Communication Layers\", STD 3, RFC 1122,
      October 1989.\n   [RFC1185]  Jacobson, V., Braden, B., and L. Zhang, \"TCP Extension
      for\n              High-Speed Paths\", RFC 1185, October 1990.\n   [RFC1323]
      \ Jacobson, V., Braden, B., and D. Borman, \"TCP Extensions\n              for
      High Performance\", RFC 1323, May 1992.\n   [RFC1981]  McCann, J., Deering,
      S., and J. Mogul, \"Path MTU Discovery\n              for IP version 6\", RFC
      1981, August 1996.\n   [RFC2018]  Mathis, M., Mahdavi, J., Floyd, S., and A.
      Romanow, \"TCP\n              Selective Acknowledgment Options\", RFC 2018,
      October 1996.\n   [RFC2675]  Borman, D., Deering, S., and R. Hinden, \"IPv6
      Jumbograms\",\n              RFC 2675, August 1999.\n   [RFC2883]  Floyd, S.,
      Mahdavi, J., Mathis, M., and M. Podolsky, \"An\n              Extension to the
      Selective Acknowledgement (SACK) Option\n              for TCP\", RFC 2883,
      July 2000.\n   [RFC3522]  Ludwig, R. and M. Meyer, \"The Eifel Detection Algorithm\n
      \             for TCP\", RFC 3522, April 2003.\n   [RFC4015]  Ludwig, R. and
      A. Gurtov, \"The Eifel Response Algorithm\n              for TCP\", RFC 4015,
      February 2005.\n   [RFC4821]  Mathis, M. and J. Heffner, \"Packetization Layer
      Path MTU\n              Discovery\", RFC 4821, March 2007.\n   [RFC4963]  Heffner,
      J., Mathis, M., and B. Chandler, \"IPv4 Reassembly\n              Errors at
      High Data Rates\", RFC 4963, July 2007.\n   [RFC5681]  Allman, M., Paxson, V.,
      and E. Blanton, \"TCP Congestion\n              Control\", RFC 5681, September
      2009.\n   [RFC5961]  Ramaiah, A., Stewart, R., and M. Dalal, \"Improving TCP's\n
      \             Robustness to Blind In-Window Attacks\", RFC 5961, August\n              2010.\n
      \  [RFC6191]  Gont, F., \"Reducing the TIME-WAIT State Using TCP\n              Timestamps\",
      BCP 159, RFC 6191, April 2011.\n   [RFC6298]  Paxson, V., Allman, M., Chu, J.,
      and M. Sargent,\n              \"Computing TCP's Retransmission Timer\", RFC
      6298, June\n              2011.\n   [RFC6528]  Gont, F. and S. Bellovin, \"Defending
      against Sequence\n              Number Attacks\", RFC 6528, February 2012.\n
      \  [RFC6675]  Blanton, E., Allman, M., Wang, L., Jarvinen, I., Kojo, M.,\n              and
      Y. Nishida, \"A Conservative Loss Recovery Algorithm\n              Based on
      Selective Acknowledgment (SACK) for TCP\", RFC\n              6675, August 2012.\n
      \  [RFC6691]  Borman, D., \"TCP Options and Maximum Segment Size (MSS)\",\n
      \             RFC 6691, July 2012.\n   [RFC6817]  Shalunov, S., Hazel, G., Iyengar,
      J., and M. Kuehlewind,\n              \"Low Extra Delay Background Transport
      (LEDBAT)\", RFC 6817,\n              December 2012.\n"
    title: 9.2.  Informative References
  title: 9.  References
- contents:
  - "Appendix A.  Implementation Suggestions\n   TCP Option Layout\n      The following
    layout is recommended for sending options on\n      non-<SYN> segments to achieve
    maximum feasible alignment of 32-bit\n      and 64-bit machines.\n                   +--------+--------+--------+--------+\n
    \                  |   NOP  |  NOP   |  TSopt |   10   |\n                   +--------+--------+--------+--------+\n
    \                  |          TSval timestamp          |\n                   +--------+--------+--------+--------+\n
    \                  |          TSecr timestamp          |\n                   +--------+--------+--------+--------+\n
    \  Interaction with the TCP Urgent Pointer\n      The TCP Urgent Pointer, like
    the TCP window, is a 16-bit value.\n      Some of the original discussion for
    the TCP Window Scale option\n      included proposals to increase the Urgent Pointer
    to 32 bits.  As\n      it turns out, this is unnecessary.  There are two observations\n
    \     that should be made:\n      (1)  With IP version 4, the largest amount of
    TCP data that can be\n           sent in a single packet is 65495 bytes (64 KiB
    - 1 - size of\n           fixed IP and TCP headers).\n      (2)  Updates to the
    Urgent Pointer while the user is in \"urgent\n           mode\" are invisible
    to the user.\n      This means that if the Urgent Pointer points beyond the end
    of the\n      TCP data in the current segment, then the user will remain in\n
    \     urgent mode until the next TCP segment arrives.  That segment will\n      update
    the Urgent Pointer to a new offset, and the user will never\n      have left urgent
    mode.\n      Thus, to properly implement the Urgent Pointer, the sending TCP\n
    \     only has to check for overflow of the 16-bit Urgent Pointer field\n      before
    filling it in.  If it does overflow, than a value of 65535\n      should be inserted
    into the Urgent Pointer.\n      The same technique applies to IP version 6, except
    in the case of\n      IPv6 Jumbograms.  When IPv6 Jumbograms are supported, [RFC2675]\n
    \     requires additional steps for dealing with the Urgent Pointer;\n      these
    steps are described in Section 5.2 of [RFC2675].\n"
  title: Appendix A.  Implementation Suggestions
- contents:
  - "Appendix B.  Duplicates from Earlier Connection Incarnations\n   There are two
    cases to be considered: (1) a system crashing (and\n   losing connection state)
    and restarting, and (2) the same connection\n   being closed and reopened without
    a loss of host state.  These will\n   be described in the following two sections.\n"
  - contents:
    - "B.1.  System Crash with Loss of State\n   TCP's quiet time of one MSL upon
      system startup handles the loss of\n   connection state in a system crash/restart.
      \ For an explanation, see,\n   for example, \"Knowing When to Keep Quiet\" in
      the TCP protocol\n   specification [RFC0793].  The MSL that is required here
      does not\n   depend upon the transfer speed.  The current TCP MSL of 2 minutes\n
      \  seemed acceptable as an operational compromise, when many host\n   systems
      used to take this long to boot after a crash.  Current host\n   systems can
      boot considerably faster.\n   The Timestamps option may be used to ease the
      MSL requirements (or to\n   provide additional security against data corruption).
      \ If timestamps\n   are being used and if the timestamp clock can be guaranteed
      to be\n   monotonic over a system crash/restart, i.e., if the first value of\n
      \  the sender's timestamp clock after a crash/restart can be guaranteed\n   to
      be greater than the last value before the restart, then a quiet\n   time is
      unnecessary.\n   To dispense totally with the quiet time would require that
      the host\n   clock be synchronized to a time source that is stable over the
      crash/\n   restart period, with an accuracy of one timestamp clock tick or\n
      \  better.  We can back off from this strict requirement to take\n   advantage
      of approximate clock synchronization.  Suppose that the\n   clock is always
      resynchronized to within N timestamp clock ticks and\n   that booting (extended
      with a quiet time, if necessary) takes more\n   than N ticks.  This will guarantee
      monotonicity of the timestamps,\n   which can then be used to reject old duplicates
      even without an\n   enforced MSL.\n"
    title: B.1.  System Crash with Loss of State
  - contents:
    - "B.2.  Closing and Reopening a Connection\n   When a TCP connection is closed,
      a delay of 2*MSL in TIME-WAIT state\n   ties up the socket pair for 4 minutes
      (see Section 3.5 of [RFC0793]).\n   Applications built upon TCP that close one
      connection and open a new\n   one (e.g., an FTP data transfer connection using
      Stream mode) must\n   choose a new socket pair each time.  The TIME-WAIT delay
      serves two\n   different purposes:\n   (a)  Implement the full-duplex reliable
      close handshake of TCP.\n        The proper time to delay the final close step
      is not really\n        related to the MSL; it depends instead upon the RTO for
      the FIN\n        segments and, therefore, upon the RTT of the path.  (It could
      be\n        argued that the side that is sending a FIN knows what degree of\n
      \       reliability it needs, and therefore it should be able to\n        determine
      the length of the TIME-WAIT delay for the FIN's\n        recipient.  This could
      be accomplished with an appropriate TCP\n        option in FIN segments.)\n
      \       Although there is no formal upper bound on RTT, common network\n        engineering
      practice makes an RTT greater than 1 minute very\n        unlikely.  Thus, the
      4-minute delay in TIME-WAIT state works\n        satisfactorily to provide a
      reliable full-duplex TCP close.\n        Note again that this is independent
      of MSL enforcement and\n        network speed.\n        The TIME-WAIT state
      could cause an indirect performance problem\n        if an application needed
      to repeatedly close one connection and\n        open another at a very high
      frequency, since the number of\n        available TCP ports on a host is less
      than 2^16.  However, high\n        network speeds are not the major contributor
      to this problem;\n        the RTT is the limiting factor in how quickly connections
      can be\n        opened and closed.  Therefore, this problem will be no worse
      at\n        high transfer speeds.\n   (b)  Allow old duplicate segments to expire.\n
      \       To replace this function of TIME-WAIT state, a mechanism would\n        have
      to operate across connections.  PAWS is defined strictly\n        within a single
      connection; the last timestamp (TS.Recent) is\n        kept in the connection
      control block and discarded when a\n        connection is closed.\n        An
      additional mechanism could be added to the TCP, a per-host\n        cache of
      the last timestamp received from any connection.  This\n        value could
      then be used in the PAWS mechanism to reject old\n        duplicate segments
      from earlier incarnations of the connection,\n        if the timestamp clock
      can be guaranteed to have ticked at least\n        once since the old connection
      was open.  This would require that\n        the TIME-WAIT delay plus the RTT
      together must be at least one\n        tick of the sender's timestamp clock.
      \ Such an extension is not\n        part of the proposal of this RFC.\n        Note
      that this is a variant on the mechanism proposed by\n        Garlick, Rom, and
      Postel [Garlick77], which required each host\n        to maintain connection
      records containing the highest sequence\n        numbers on every connection.
      \ Using timestamps instead, it is\n        only necessary to keep one quantity
      per remote host, regardless\n        of the number of simultaneous connections
      to that host.\n"
    title: B.2.  Closing and Reopening a Connection
  title: Appendix B.  Duplicates from Earlier Connection Incarnations
- contents:
  - "Appendix C.  Summary of Notation\n   The following notation has been used in
    this document.\n   Options\n      WSopt:            TCP Window Scale option\n
    \     TSopt:            TCP Timestamps option\n   Option Fields\n      shift.cnt:
    \       Window scale byte in WSopt\n      TSval:            32-bit Timestamp Value
    field in TSopt\n      TSecr:            32-bit Timestamp Reply field in TSopt\n
    \  Option Fields in Current Segment\n      SEG.TSval:        TSval field from
    TSopt in current segment\n      SEG.TSecr:        TSecr field from TSopt in current
    segment\n      SEG.WSopt:        8-bit value in WSopt\n   Clock Values\n      my.TSclock:
    \      System-wide source of 32-bit timestamp values\n      my.TSclock.rate:  Period
    of my.TSclock (1 ms to 1 sec)\n      Snd.TSoffset:     An offset for randomizing
    Snd.TSclock\n      Snd.TSclock:      my.TSclock + Snd.TSoffset\n   Per-Connection
    State Variables\n      TS.Recent:        Latest received Timestamp\n      Last.ACK.sent:
    \   Last ACK field sent\n      Snd.TS.OK:        1-bit flag\n      Snd.WS.OK:
    \       1-bit flag\n      Rcv.Wind.Shift:   Receive window scale exponent\n      Snd.Wind.Shift:
    \  Send window scale exponent\n      Start.Time:       Snd.TSclock value when
    the segment being timed\n                        was sent (used by code from before
    RFC 1323).\n   Procedure\n      Update_SRTT(m)    Procedure to update the smoothed
    RTT and RTT\n                        variance estimates, using the rules of\n
    \                       [Jacobson88a], given m, a new RTT measurement\n   Send
    Sequence Variables\n      SND.UNA:          Send unacknowledged\n      SND.NXT:
    \         Send next\n      SND.WND:          Send window\n      ISS:              Initial
    send sequence number\n   Receive Sequence Variables\n      RCV.NXT:          Receive
    next\n      RCV.WND:          Receive window\n      IRS:              Initial
    receive sequence number\n"
  title: Appendix C.  Summary of Notation
- contents:
  - "Appendix D.  Event Processing Summary\n   This appendix attempts to specify the
    algorithms unambiguously by\n   presenting modifications to the Event Processing
    rules in Section 3.9\n   of RFC 793.  The change bars (\"|\") indicate lines that
    are different\n   from RFC 793.\n   OPEN Call\n      ...\n      An initial send
    sequence number (ISS) is selected.  Send a <SYN>\n |    segment of the form:\n
    |\n |      <SEQ=ISS><CTL=SYN><TSval=Snd.TSclock><WSopt=Rcv.Wind.Shift>\n      ...\n
    \  SEND Call\n      CLOSED STATE (i.e., TCB does not exist)\n         ...\n      LISTEN
    STATE\n         If active and the foreign socket is specified, then change the\n
    \        connection from passive to active, select an ISS.  Send a SYN\n |       segment
    containing the options: <TSval=Snd.TSclock> and\n |       <WSopt=Rcv.Wind.Shift>.
    \ Set SND.UNA to ISS, SND.NXT to ISS+1.\n         Enter SYN-SENT state.  ...\n
    \     SYN-SENT STATE\n      SYN-RECEIVED STATE\n         ...\n      ESTABLISHED
    STATE\n      CLOSE-WAIT STATE\n         Segmentize the buffer and send it with
    a piggybacked\n         acknowledgment (acknowledgment value = RCV.NXT).  ...\n
    \        If the urgent flag is set ...\n |       If the Snd.TS.OK flag is set,
    then include the TCP Timestamps\n |       option <TSval=Snd.TSclock,TSecr=TS.Recent>
    in each data\n |       segment.\n |\n |       Scale the receive window for transmission
    in the segment\n |       header:\n |\n |               SEG.WND = (RCV.WND >> Rcv.Wind.Shift).\n
    \  SEGMENT ARRIVES\n      ...\n      If the state is LISTEN then\n         first
    check for an RST\n            ...\n         second check for an ACK\n            ...\n
    \        third check for a SYN\n            If the SYN bit is set, check the security.
    \ If the ...\n               ...\n            If the SEG.PRC is less than the
    TCB.PRC then continue.\n |          Check for a Window Scale option (WSopt); if
    one is found,\n |          save SEG.WSopt in Snd.Wind.Shift and set Snd.WS.OK
    flag on.\n |          Otherwise, set both Snd.Wind.Shift and Rcv.Wind.Shift to\n
    |          zero and clear Snd.WS.OK flag.\n |\n |          Check for a TSopt option;
    if one is found, save SEG.TSval in\n |          the variable TS.Recent and turn
    on the Snd.TS.OK bit.\n            Set RCV.NXT to SEG.SEQ+1, IRS is set to SEG.SEQ
    and any\n            other control or text should be queued for processing later.\n
    \           ISS should be selected and a SYN segment sent of the form:\n                    <SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>\n
    |           If the Snd.WS.OK bit is on, include a WSopt\n |           <WSopt=Rcv.Wind.Shift>
    in this segment.  If the Snd.TS.OK\n |           bit is on, include a TSopt <TSval=Snd.TSclock,\n
    |           TSecr=TS.Recent> in this segment.  Last.ACK.sent is set to\n |           RCV.NXT.\n
    \           SND.NXT is set to ISS+1 and SND.UNA to ISS.  The connection\n            state
    should be changed to SYN-RECEIVED.  Note that any\n            other incoming
    control or data (combined with SYN) will be\n            processed in the SYN-RECEIVED
    state, but processing of SYN\n            and ACK should not be repeated.  If
    the listen was not fully\n            specified (i.e., the foreign socket was
    not fully\n            specified), then the unspecified fields should be filled
    in\n            now.\n         fourth other text or control\n            ...\n
    \     If the state is SYN-SENT then\n         first check the ACK bit\n            ...\n
    \        ...\n         fourth check the SYN bit\n            ...\n            If
    the SYN bit is on and the security/compartment and\n            precedence are
    acceptable then, RCV.NXT is set to SEG.SEQ+1,\n            IRS is set to SEG.SEQ.
    \ SND.UNA should be advanced to equal\n            SEG.ACK (if there is an ACK),
    and any segments on the\n            retransmission queue which are thereby acknowledged
    should\n            be removed.\n |          Check for a Window Scale option (WSopt);
    if it is found,\n |          save SEG.WSopt in Snd.Wind.Shift; otherwise, set
    both\n |          Snd.Wind.Shift and Rcv.Wind.Shift to zero.\n |\n |          Check
    for a TSopt option; if one is found, save SEG.TSval in\n |          variable TS.Recent
    and turn on the Snd.TS.OK bit in the\n |          connection control block.  If
    the ACK bit is set, use\n |          Snd.TSclock - SEG.TSecr as the initial RTT
    estimate.\n            If SND.UNA > ISS (our SYN has been ACKed), change the\n
    \           connection state to ESTABLISHED, form an <ACK> segment:\n                    <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>\n
    |          and send it.  If the Snd.TS.OK bit is on, include a TSopt\n |          option
    <TSval=Snd.TSclock,TSecr=TS.Recent> in this <ACK>\n |          segment.  Last.ACK.sent
    is set to RCV.NXT.\n            Data or controls that were queued for transmission
    may be\n            included.  If there are other controls or text in the\n            segment,
    then continue processing at the sixth step below\n            where the URG bit
    is checked; otherwise, return.\n            Otherwise, enter SYN-RECEIVED, form
    a <SYN,ACK> segment:\n                    <SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>\n
    |          and send it.  If the Snd.TS.OK bit is on, include a TSopt\n |          option
    <TSval=Snd.TSclock,TSecr=TS.Recent> in this segment.\n |          If the Snd.WS.OK
    bit is on, include a WSopt option\n |          <WSopt=Rcv.Wind.Shift> in this
    segment.  Last.ACK.sent is\n |          set to RCV.NXT.\n            If there
    are other controls or text in the segment, queue\n            them for processing
    after the ESTABLISHED state has been\n            reached, return.\n         fifth,
    if neither of the SYN or RST bits is set then drop the\n         segment and return.\n
    \     Otherwise\n      first check the sequence number\n         SYN-RECEIVED
    STATE\n         ESTABLISHED STATE\n         FIN-WAIT-1 STATE\n         FIN-WAIT-2
    STATE\n         CLOSE-WAIT STATE\n         CLOSING STATE\n         LAST-ACK STATE\n
    \        TIME-WAIT STATE\n            Segments are processed in sequence.  Initial
    tests on\n            arrival are used to discard old duplicates, but further\n
    \           processing is done in SEG.SEQ order.  If a segment's\n            contents
    straddle the boundary between old and new, only the\n            new parts should
    be processed.\n |          Rescale the received window field:\n |\n |                TrueWindow
    = SEG.WND << Snd.Wind.Shift,\n |\n |          and use \"TrueWindow\" in place
    of SEG.WND in the following\n |          steps.\n |\n |          Check whether
    the segment contains a Timestamps option and\n |          if bit Snd.TS.OK is
    on.  If so:\n |\n |             If SEG.TSval < TS.Recent and the RST bit is off:\n
    |\n |                If the connection has been idle more than 24 days,\n |                save
    SEG.TSval in variable TS.Recent, else the segment\n |                is not acceptable;
    follow the steps below for an\n |                unacceptable segment.\n |\n |
    \            If SEG.TSval >= TS.Recent and SEG.SEQ <= Last.ACK.sent,\n |             then
    save SEG.TSval in variable TS.Recent.\n            There are four cases for the
    acceptability test for an\n            incoming segment:\n               ...\n
    \           If an incoming segment is not acceptable, an acknowledgment\n            should
    be sent in reply (unless the RST bit is set; if so\n            drop the segment
    and return):\n                    <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>\n |          Last.ACK.sent
    is set to SEG.ACK of the acknowledgment.  If\n |          the Snd.TS.OK bit is
    on, include the Timestamps option\n |          <TSval=Snd.TSclock,TSecr=TS.Recent>
    in this <ACK> segment.\n            Set Last.ACK.sent to SEG.ACK and send the
    <ACK> segment.\n            After sending the acknowledgment, drop the unacceptable\n
    \           segment and return.\n      ...\n      fifth check the ACK field,\n
    \        if the ACK bit is off drop the segment and return\n         if the ACK
    bit is on\n            ...\n            ESTABLISHED STATE\n               If SND.UNA
    < SEG.ACK <= SND.NXT then, set SND.UNA <-\n |             SEG.ACK.  Also compute
    a new estimate of round-trip time.\n |             If Snd.TS.OK bit is on, use
    Snd.TSclock - SEG.TSecr;\n |             otherwise, use the elapsed time since
    the first segment\n |             in the retransmission queue was sent.  Any segments
    on\n               the retransmission queue that are thereby entirely\n               acknowledged...\n
    \     ...\n      seventh, process the segment text,\n         ESTABLISHED STATE\n
    \        FIN-WAIT-1 STATE\n         FIN-WAIT-2 STATE\n            ...\n            Send
    an acknowledgment of the form:\n                    <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>\n
    |          If the Snd.TS.OK bit is on, include the Timestamps option\n |          <TSval=Snd.TSclock,TSecr=TS.Recent>
    in this <ACK> segment.\n |          Set Last.ACK.sent to SEG.ACK of the acknowledgment,
    and send\n |          it.  This acknowledgment should be piggybacked on a segment\n
    \           being transmitted if possible without incurring undue delay.\n            ...\n"
  title: Appendix D.  Event Processing Summary
- contents:
  - "Appendix E.  Timestamps Edge Cases\n   While the rules laid out for when to calculate
    RTTM produce the\n   correct results most of the time, there are some edge cases
    where an\n   incorrect RTTM can be calculated.  All of these situations involve\n
    \  the loss of segments.  It is felt that these scenarios are rare, and\n   that
    if they should happen, they will cause a single RTTM measurement\n   to be inflated,
    which mitigates its effects on RTO calculations.\n   [Martin03] cites two similar
    cases when the returning <ACK> is lost,\n   and before the retransmission timer
    fires, another returning <ACK>\n   segment arrives, which acknowledges the data.
    \ In this case, the RTTM\n   calculated will be inflated:\n          clock\n            tc=1
    \  <A, TSval=1> ------------------->\n            tc=2   (lost) <---- <ACK(A),
    TSecr=1, win=n>\n                (RTTM would have been 1)\n                   (receive
    window opens, window update is sent)\n            tc=5        <---- <ACK(A), TSecr=1,
    win=m>\n                   (RTTM is calculated at 4)\n   One thing to note about
    this situation is that it is somewhat bounded\n   by RTO + RTT, limiting how far
    off the RTTM calculation will be.\n   While more complex scenarios can be constructed
    that produce larger\n   inflations (e.g., retransmissions are lost), those scenarios
    involve\n   multiple segment losses, and the connection will have other more\n
    \  serious operational problems than using an inflated RTTM in the RTO\n   calculation.\n"
  title: Appendix E.  Timestamps Edge Cases
- contents:
  - "Appendix F.  Window Retraction Example\n   Consider an established TCP connection
    using a scale factor of 128,\n   Snd.Wind.Shift=7 and Rcv.Wind.Shift=7, that is
    running with a very\n   small window because the receiver is bottlenecked and
    both ends are\n   doing small reads and writes.\n   Consider the ACKs coming back:\n
    \  SEG.ACK  SEG.WIN computed SND.WIN   receiver's actual window\n   1000     2
    \      1256               1300\n   The sender writes 40 bytes and receiver ACKs:\n
    \  1040     2       1296               1300\n   The sender writes 5 additional
    bytes and the receiver has a problem.\n   Two choices:\n   1045     2       1301
    \              1300   - BEYOND BUFFER\n   1045     1       1173               1300
    \  - RETRACTED WINDOW\n   This is a general problem and can happen any time the
    sender does a\n   write, which is smaller than the window scale factor.\n   In
    most stacks, it is at least partially obscured when the window\n   size is larger
    than some small number of segments because the stacks\n   prefer to announce windows
    that are an integral number of segments,\n   rounded up to the next scale factor.
    \ This plus silly window\n   suppression tends to cause less frequent, larger
    window updates.  If\n   the window was rounded down to a segment size, there is
    more\n   opportunity to advance the window, the BEYOND BUFFER case above,\n   rather
    than retracting it.\n"
  title: Appendix F.  Window Retraction Example
- contents:
  - "Appendix G.  RTO Calculation Modification\n   Taking multiple RTT samples per
    window would shorten the history\n   calculated by the RTO mechanism in [RFC6298],
    and the below algorithm\n   aims to maintain a similar history as originally intended
    by\n   [RFC6298].\n   It is roughly known how many samples a congestion window
    worth of\n   data will yield, not accounting for ACK compression, and ACK losses.\n
    \  Such events will result in more history of the path being reflected\n   in
    the final value for RTO, and are uncritical.  This modification\n   will ensure
    that a similar amount of time is taken into account for\n   the RTO estimation,
    regardless of how many samples are taken per\n   window:\n      ExpectedSamples
    = ceiling(FlightSize / (SMSS * 2))\n      alpha' = alpha / ExpectedSamples\n      beta'
    = beta / ExpectedSamples\n   Note that the factor 2 in ExpectedSamples is due
    to \"Delayed ACKs\".\n   Instead of using alpha and beta in the algorithm of [RFC6298],
    use\n   alpha' and beta' instead:\n      RTTVAR <- (1 - beta') * RTTVAR + beta'
    * |SRTT - R'|\n      SRTT <- (1 - alpha') * SRTT + alpha' * R'\n      (for each
    sample R')\n"
  title: Appendix G.  RTO Calculation Modification
- contents:
  - "Appendix H.  Changes from RFC 1323\n   Several important updates and clarifications
    to the specification in\n   RFC 1323 are made in this document.  The technical
    changes are\n   summarized below:\n   (a)  A wrong reference to SND.WND was corrected
    to SEG.WND in\n        Section 2.3.\n   (b)  Section 2.4 was added describing
    the unavoidable window\n        retraction issue and explicitly describing the
    mitigation steps\n        necessary.\n   (c)  In Section 3.2, the wording how
    the Timestamps option\n        negotiation is to be performed was updated with
    RFC2119 wording.\n        Further, a number of paragraphs were added to clarify
    the\n        expected behavior with a compliant implementation using TSopt,\n
    \       as RFC 1323 left room for interpretation -- e.g., potential late\n        enablement
    of TSopt.\n   (d)  The description of which TSecr values can be used to update
    the\n        measured RTT has been clarified.  Specifically, with timestamps,\n
    \       the Karn algorithm [Karn87] is disabled.  The Karn algorithm\n        disables
    all RTT measurements during retransmission, since it is\n        ambiguous whether
    the <ACK> is for the original segment, or the\n        retransmitted segment.
    \ With timestamps, that ambiguity is\n        removed since the TSecr in the <ACK>
    will contain the TSval from\n        whichever data segment made it to the destination.\n
    \  (e)  RTTM update processing explicitly excludes segments not updating\n        SND.UNA.
    \ The original text could be interpreted to allow taking\n        RTT samples
    when SACK acknowledges some new, non-continuous\n        data.\n   (f)  In RFC
    1323, Section 3.4, step (2) of the algorithm to control\n        which timestamp
    is echoed was incorrect in two regards:\n        (1)  It failed to update TS.Recent
    for a retransmitted segment\n             that resulted from a lost <ACK>.\n        (2)
    \ It failed if SEG.LEN = 0.\n        In the new algorithm, the case of SEG.TSval
    >= TS.Recent is\n        included for consistency with the PAWS test.\n   (g)
    \ It is now recommended that the Timestamps option is included in\n        <RST>
    segments if the incoming segment contained a Timestamps\n        option.\n   (h)
    \ <RST> segments are explicitly excluded from PAWS processing.\n   (i)  Added
    text to clarify the precedence between regular TCP\n        [RFC0793] and this
    document's Timestamps option / PAWS\n        processing.  Discussion about combined
    acceptability checks are\n        ongoing.\n   (j)  Snd.TSoffset and Snd.TSclock
    variables have been added.\n        Snd.TSclock is the sum of my.TSclock and Snd.TSoffset.
    \ This\n        allows the starting points for timestamp values to be randomized\n
    \       on a per-connection basis.  Setting Snd.TSoffset to zero yields\n        the
    same results as [RFC1323].  Text was added to guide\n        implementers to the
    proper selection of these offsets, as\n        entirely random offsets for each
    new connection will conflict\n        with PAWS.\n   (k)  Appendix A has been
    expanded with information about the TCP\n        Urgent Pointer.  An earlier revision
    contained text around the\n        TCP MSS option, which was split off into [RFC6691].\n
    \  (l)  One correction was made to the Event Processing Summary in\n        Appendix
    D.  In SEND CALL/ESTABLISHED STATE, RCV.WND is used to\n        fill in the SEG.WND
    value, not SND.WND.\n   (m)  Appendix G was added to exemplify how an RTO calculation
    might\n        be updated to properly take the much higher RTT sampling\n        frequency
    enabled by the Timestamps option into account.\n   Editorial changes to the document,
    that don't impact the\n   implementation or function of the mechanisms described
    in this\n   document, include:\n   (a)  Removed much of the discussion in Section
    1 to streamline the\n        document.  However, detailed examples and discussions
    in\n        Sections 2, 3, and 5 are kept as guidelines for implementers.\n   (b)
    \ Added short text that the use of WS increases the chances of\n        sequence
    number wrap, thus the PAWS mechanism is required in\n        certain environments.\n
    \  (c)  Removed references to \"new\" options, as the options were\n        introduced
    in [RFC1323] already.  Changed the text in\n        Section 1.3 to specifically
    address TS and WS options.\n   (d)  Section 1.4 was added for [RFC2119] wording.
    \ Normative text was\n        updated with the appropriate phrases.\n   (e)  Added
    < > brackets to mark specific types of segments, and\n        replaced most occurrences
    of \"packet\" with \"segment\", where TCP\n        segments are referred to.\n
    \  (f)  Updated the text in Section 3 to take into account what has been\n        learned
    since [RFC1323].\n   (g)  Removed some unused references.\n   (h)  Removed the
    list of changes between [RFC1323] and prior\n        versions.  These changes
    are mentioned in Appendix C of\n        [RFC1323].\n   (i)  Moved \"Changes from
    RFC 1323\" to the end of the appendices for\n        easier lookup.  In addition,
    the entries were split into a\n        technical and an editorial part, and sorted
    to roughly\n        correspond with the sections in the text where they apply.\n"
  title: Appendix H.  Changes from RFC 1323
- contents:
  - "Authors' Addresses\n   David Borman\n   Quantum Corporation\n   Mendota Heights,
    MN  55120\n   USA\n   EMail: david.borman@quantum.com\n   Bob Braden\n   University
    of Southern California\n   4676 Admiralty Way\n   Marina del Rey, CA  90292\n
    \  USA\n   EMail: braden@isi.edu\n   Van Jacobson\n   Google, Inc.\n   1600 Amphitheatre
    Parkway\n   Mountain View, CA  94043\n   USA\n   EMail: vanj@google.com\n   Richard
    Scheffenegger (editor)\n   NetApp, Inc.\n   Am Euro Platz 2\n   Vienna,  1120\n
    \  Austria\n   EMail: rs@netapp.com\n"
  title: Authors' Addresses
