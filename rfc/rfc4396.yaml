- title: __initial_text__
  contents:
  - "                           RTP Payload Format\n       for 3rd Generation Partnership\
    \ Project (3GPP) Timed Text\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies an RTP payload format for the transmission\
    \ of\n   3GPP (3rd Generation Partnership Project) timed text.  3GPP timed\n \
    \  text is a time-lined, decorated text media format with defined\n   storage\
    \ in a 3GP file.  Timed Text can be synchronized with\n   audio/video contents\
    \ and used in applications such as captioning,\n   titling, and multimedia presentations.\
    \  In the following sections,\n   the problems of streaming timed text are addressed,\
    \ and a payload\n   format for streaming 3GPP timed text over RTP is specified.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Motivation, Requirements, and Design Rationale ..................3\n  \
    \    2.1. Motivation .................................................3\n    \
    \  2.2. Basic Components of the 3GPP Timed Text Media Format .......4\n      2.3.\
    \ Requirements ...............................................5\n      2.4. Limitations\
    \ ................................................6\n      2.5. Design Rationale\
    \ ...........................................7\n   3. Terminology ....................................................10\n\
    \   4. RTP Payload Format for 3GPP Timed Text .........................12\n  \
    \    4.1. Payload Header Definitions ................................13\n    \
    \       4.1.1. Common Payload Header Fields .......................15\n      \
    \     4.1.2. TYPE 1 Header ......................................17\n        \
    \   4.1.3. TYPE 2 Header ......................................20\n          \
    \ 4.1.4. TYPE 3 Header ......................................23\n           4.1.5.\
    \ TYPE 4 Header ......................................24\n           4.1.6. TYPE\
    \ 5 Header ......................................25\n      4.2. Buffering of Sample\
    \ Descriptions ..........................25\n           4.2.1. Dynamic SIDX Wraparound\
    \ Mechanism ..................26\n      4.3. Finding Payload Header Values in\
    \ 3GP Files ................28\n      4.4. Fragmentation of Timed Text Samples\
    \ .......................31\n      4.5. Reassembling Text Samples at the Receiver\
    \ .................33\n      4.6. On Aggregate Payloads .....................................35\n\
    \      4.7. Payload Examples ..........................................39\n  \
    \    4.8. Relation to RFC 3640 ......................................43\n    \
    \  4.9. Relation to RFC 2793 ......................................44\n   5. Resilient\
    \ Transport ............................................45\n   6. Congestion Control\
    \ .............................................46\n   7. Scene Description ..............................................47\n\
    \      7.1. Text Rendering Position and Composition ...................47\n  \
    \    7.2. SMIL Usage ................................................48\n    \
    \  7.3. Finding Layout Values in a 3GP File .......................48\n   8. 3GPP\
    \ Timed Text Media Type .....................................49\n   9. SDP Usage\
    \ ......................................................53\n      9.1. Mapping\
    \ to SDP ............................................53\n      9.2. Parameter\
    \ Usage in the SDP Offer/Answer Model .............53\n           9.2.1. Unicast\
    \ Usage ......................................54\n           9.2.2. Multicast\
    \ Usage ....................................57\n      9.3. Offer/Answer Examples\
    \ .....................................58\n      9.4. Parameter Usage outside\
    \ of Offer/Answer ...................60\n   10. IANA Considerations ...........................................60\n\
    \   11. Security Considerations .......................................60\n  \
    \ 12. References ....................................................61\n    \
    \  12.1. Normative References .....................................61\n      12.2.\
    \ Informative References ...................................61\n   13. Basics\
    \ of the 3GP File Structure ..............................64\n   14. Acknowledgements\
    \ ..............................................65\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   3GPP timed text is a media format for time-lined, decorated\
    \ text\n   specified in the 3GPP Technical Specification TS 26.245, \"Transparent\n\
    \   end-to-end packet switched streaming service (PSS); Timed Text Format\n  \
    \ (Release 6)\" [1].  Besides plain text, the 3GPP timed text format\n   allows\
    \ the creation of decorated text such as that for karaoke\n   applications, scrolling\
    \ text for newscasts, or hyperlinked text.\n   These contents may or may not be\
    \ synchronized with other media, such\n   as audio or video.\n   The purpose of\
    \ this document is to provide a means to stream 3GPP\n   timed text contents using\
    \ RTP [3].  This includes the streaming of\n   timed text being read out of a\
    \ (3GP) file, as well as the streaming\n   of timed text generated in real-time,\
    \ a.k.a. live streaming.\n   Section 2 contains the motivation for this document,\
    \ an overview of\n   the media format, the requirements, and the design rationale.\n\
    \   Section 3 defines the terminology used.  Section 4 specifies the\n   payload\
    \ headers, the fragmentation and re-assembly rules for text\n   samples, the rules\
    \ for payload aggregation, and the relations of this\n   document to RFC 3640\
    \ [12] and RFC 2793 [22].  Section 5 specifies\n   some simple schemes for resilient\
    \ transport and gives pointers to\n   other possible mechanisms.  Section 6 addresses\
    \ congestion control.\n   Section 7 specifies scene description.  Section 8 defines\
    \ the media\n   type.  Section 9 specifies SDP for unicast and multicast sessions,\n\
    \   including usage in the Offer/Answer model [13].  Sections 10 and 11\n   address\
    \ IANA and security considerations.  Section 12 lists\n   references.  Basics\
    \ of the 3GP File Structure are in Section 13.\n"
- title: 2.  Motivation, Requirements, and Design Rationale
  contents:
  - '2.  Motivation, Requirements, and Design Rationale

    '
- title: 2.1.  Motivation
  contents:
  - "2.1.  Motivation\n   The 3GPP timed text format was developed for use in the\
    \ services\n   specified in the 3GPP Transparent End-to-end Packet-switched\n\
    \   Streaming Services (3GPP PSS) specification [16].\n   As of today, PSS allows\
    \ downloading 3GPP timed text contents stored\n   in 3GP files.  However, due\
    \ to the lack of a RTP payload format, it\n   is not possible to stream 3GPP timed\
    \ text contents over RTP.\n   This document specifies such a payload format.\n"
- title: 2.2.  Basic Components of the 3GPP Timed Text Media Format
  contents:
  - "2.2.  Basic Components of the 3GPP Timed Text Media Format\n   Before going into\
    \ the details of the design, it is necessary to know\n   how the media format\
    \ is constructed.  We can identify four\n   differentiated functional components:\
    \ layout information, default\n   formatting, text strings, and decoration.  In\
    \ the following, we\n   shortly explain these and match them to their designations\
    \ in a 3GP\n   file:\n        o Initial spatial layout information related to\
    \ the text\n          strings: These are the height and width of the text region\n\
    \          where text is displayed, the position of the text region in\n     \
    \     the display, and the layer or proximity of the text to the\n          user.\
    \  In 3GP files, this information is contained in the\n          Track Header\
    \ Box (3GP file designations are capitalized for\n          clarity).\n      \
    \  o Default settings for formatting and positioning of text: style\n        \
    \  (font, size, color,...), background color, horizontal and\n          vertical\
    \ justification, line width, scrolling, etc.  For 3GP\n          files, this corresponds\
    \ to the Sample Descriptions.\n        o The actual text strings: encoded characters\
    \ using either UTF-8\n          [18] or UTF-16 [19] encoding.\n        o The decoration:\
    \ If some characters have different style,\n          delay, blink, etc., this\
    \ needs to be indicated.  The\n          decoration is only present in the text\
    \ samples if it is\n          actually needed.  Otherwise, the default settings\
    \ as above\n          apply.  In 3GP files, within each Text Sample, the decoration\n\
    \          (i.e., Modifier Boxes) is appended to the text strings, if\n      \
    \    needed.  At the time of writing this payload format, the\n          following\
    \ modifiers are specified in the 3GPP timed text media\n          format specification\
    \ [1]:\n           - text highlight\n           - highlight color\n          \
    \ - blinking text\n           - karaoke feature\n           - hyperlink\n    \
    \       - text delay\n           - text style\n           - positioning of the\
    \ text box\n           - text wrap indication\n"
- title: 2.3.  Requirements
  contents:
  - "2.3.  Requirements\n   Once the basic components are known, it is necessary to\
    \ define which\n   requirements the payload format shall fulfill:\n     1. It\
    \ shall enable both live streaming and streaming from a 3GP\n        file.\n \
    \               Informative note: For the purpose of this document, the\n    \
    \            term \"live streaming\" refers to those scenarios where\n       \
    \         the timed text stream is sent from a live encoder.  Upon\n         \
    \       reception, the content may or may not be stored in a 3GP\n           \
    \     file.  Typically, in live streaming applications, the\n                sender\
    \ encapsulates the timed text content in RTP\n                packets following\
    \ the guidelines given in this document.\n                At the receiving side,\
    \ a buffer is used to cancel the\n                network delay and delay jitter.\
    \  If receiver and sender\n                support packet loss resilience mechanisms\
    \ (see Section\n                5), it may also be possible to recover from packet\n\
    \                losses.  Note that how sender and receiver actually\n       \
    \         manage and dimension the buffers is an implementation\n            \
    \    design choice.\n     2. Furthermore, it shall be possible for an RTP receiver\
    \ using this\n        payload format, and capable of storing in 3GP format, to\
    \ obtain\n        all necessary information from the RTP packets for storing the\n\
    \        received text contents according to the 3GP file format.  This\n    \
    \    file may or may not be the same as the original file.\n                Informative\
    \ note: The 3GP file format itself is based on\n                the ISO Base Media\
    \ File Format recommendation [2].\n                Section 13.1 gives some insight\
    \ into the 3GP file\n                structure.  Further, Sections 4.3 and 7.3\
    \ specify where\n                the information needed for filling in payload\
    \ headers is\n                found in a 3GP file.  For live streaming, appropriate\n\
    \                values complying with the format and units described in\n   \
    \             [1] shall be used.  Where needed, clarifications on\n          \
    \      appropriate values are given in this document.\n     3. It shall enable\
    \ efficient and resilient transport of timed text\n        contents over RTP.\
    \  In particular:\n          a. Enable the transmission of the sample descriptions\
    \ by both\n             out-of-band and in-band means.  Sample descriptions are\n\
    \             important information, which potentially apply to several\n    \
    \         text samples.  These default formatting settings are\n             typically\
    \ transmitted out-of-band (reliably) once at the\n             initialization\
    \ phase.  If additional sample descriptions\n             are needed in the course\
    \ of a session, these may also be\n             sent out-of-band or in-band. \
    \ In-band transmission,\n             although unreliable, may be more appropriate\
    \ for sending\n             sample descriptions if these should be sent frequently,\
    \ as\n             opposed to establishing an additional communication channel\n\
    \             for SDP, for example.  It is also useful in cases where an\n   \
    \          out-of-band channel may not be available and for live\n           \
    \  streaming, where contents are not known a priori.  Thus,\n             the\
    \ payload format shall enable out-of-band and in-band\n             transmission\
    \ of sample descriptions.  Section 4.1.6\n             specifies a payload header\
    \ for transmitting sample\n             descriptions in-band.  Section 9 specifies\
    \ how sample\n             descriptions are mapped to SDP.\n          b. Enable\
    \ the fragmentation of a text sample into several RTP\n             packets in\
    \ order to cover a wide range of applications and\n             network environments.\
    \  In general, fragmentation should be\n             a rare event, given the low\
    \ bit rates and relatively small\n             text sample sizes.  However, the\
    \ 3GPP Timed Text media\n             format does allow for larger text samples.\
    \  Therefore, the\n             payload format shall take this into account and\
    \ provide a\n             means for coping with fragmentation and reassembly.\
    \ Section\n             4.4 deals with fragmentation.\n          c. Enable the\
    \ aggregation of units into an RTP packet for\n             making the transport\
    \ more efficient.  In a mobile\n             communication environment, a typical\
    \ text sample size is\n             around 100-200 bytes.  If the available bit\
    \ rate and the\n             packet size allow it, units should be aggregated\
    \ into one\n             RTP packet.  Section 4.6 deals with aggregation.\n  \
    \        d. Enable the use of resilient transport mechanisms, such as\n      \
    \       repetition, retransmission [11], and FEC [7] (see Section\n          \
    \   5).  For a more general discussion, refer to RFC 2354 [8],\n             which\
    \ discusses available mechanisms for stream repair.\n"
- title: 2.4.  Limitations
  contents:
  - "2.4.  Limitations\n     The payload headers have been optimized in size for RTP.\
    \  Instead\n     of using 32-bit (S)LEN, SDUR, and SIDX header fields, which would\n\
    \     carry many unused bits much of the time, it has been a design\n     choice\
    \ to reduce the size of these fields.  As a consequence, this\n     payload format\
    \ has reduced maximum values with respect to sizes and\n     durations of (text)\
    \ samples and sample descriptions.  These maximum\n     values differ from those\
    \ allowed in 3GP files, where they are\n     expressed using 32-bit (unsigned)\
    \ integers.  In some cases,\n     extension mechanisms are provided to deal with\
    \ larger values.\n     However, it is noted that the values used here should be\
    \ enough for\n     the streaming applications targeted.\n     The following limitations\
    \ apply:\n     1. The maximum size of text samples carried in RTP packets is\n\
    \        restricted to be a 16-bit (unsigned) integer (this includes the\n   \
    \     text strings and modifiers).  This means a maximum size for the\n      \
    \  unit would be about 64 Kbytes.  No extension mechanism is\n        provided.\n\
    \     2. The sample description index values are restricted to be an 8-\n    \
    \    bit (unsigned) integer.  An extension mechanism is given in\n        Section\
    \ 4.3.\n     3. The text sample duration is restricted to be a 24-bit (unsigned)\n\
    \        integer.  This yields a maximum duration at a timestamp\n        clockrate\
    \ of 1000 Hz of about 4.6 hours.  Nevertheless, an\n        extension mechanism\
    \ is provided in Section 4.3.\n     4. Sample descriptions are also restricted\
    \ in size: If the size\n        cannot be expressed as a 16-bit (unsigned) integer,\
    \ the sample\n        description shall not be conveyed.  As in the case of the\
    \ sample\n        size, no extension mechanism is provided.\n     5. A further\
    \ limitation concerns the UTF-16 encodings supported:\n        Only transport\
    \ of text strings following big endian byte order\n        is supported.  See\
    \ Section 4.1.1 for details.\n"
- title: 2.5.  Design Rationale
  contents:
  - "2.5.  Design Rationale\n   The following design choices were made:\n     1. 'Unit'\
    \ approach: The payload formats specified in this document\n        follow a simple\
    \ scheme: a 3-byte common header (Common Payload\n        Header) followed by\
    \ a specific header for each text sample\n        (fragment) type.  Following\
    \ these headers, the text sample\n        contents are placed (Section 4.1.1 and\
    \ following).  This\n        structure is called a 'unit'.\n        The following\
    \ units have been devised to comply with the\n        requirements mentioned in\
    \ Section 2.3:\n          a. A TYPE 1 unit that contains one complete text sample,\n\
    \          b. A TYPE 2 unit that contains a complete text string or a\n      \
    \       fragment thereof,\n          c. A TYPE 3 unit that contains the complete\
    \ modifiers or only\n             the first fragment thereof,\n          d. A\
    \ TYPE 4 unit that contains one modifier fragment other\n             than the\
    \ first, and\n          e. A TYPE 5 unit that contains one sample description.\n\
    \        This 'unit' approach was motivated by the following reasons:\n      \
    \        1. Allows a simple classification of the text samples and\n         \
    \        text sample fragments that can be conveyed by the\n                 payload\
    \ format.\n              2. Enables easy interoperability with RFC 3640 [12].\n\
    \                 During the development of this payload format, interest\n  \
    \               was shown from MPEG-4 standardization participants in\n      \
    \           developing a common payload structure for the transport\n        \
    \         of 3GPP Timed Text.  While interoperability is not\n               \
    \  strictly necessary for this payload format to work, it\n                 has\
    \ been pursued in this payload format.  Section 4.8\n                 explains\
    \ how this is done.\n     2. Character count is not implemented.  This payload\
    \ format does\n        detect lost text samples fragments, but it does not enable\
    \ an\n        RTP receiver to find out the exact number of text characters\n \
    \       lost.  In fact, the fragment size included in the payload\n        headers\
    \ does not help in finding the number of lost characters\n        because the\
    \ UTF-8/UTF-16 [18][19] encodings used yield a\n        variable number of bytes\
    \ per character.\n        For finding the exact number of lost characters, an\
    \ additional\n        field reflecting the character count (and possibly the character\n\
    \        offset) upon fragmentation would be required.  This would\n        additionally\
    \ require that the entity performing fragmentation\n        count the characters\
    \ included in each text fragment.\n        One benefit of having a character count\
    \ would be that the\n        display application would be able to replace missing\
    \ characters\n        through some other character representing character loss.\
    \  For\n        example:\n             If we take the \"Some text is lost now\"\
    \ and assume the loss\n             of a packet containing the text in the middle,\
    \ this could\n             be displayed (with a character count):\n          \
    \   \"Some ############now\"\n             As opposed to:\n             \"Some\
    \ #now\"\n             which is what this payload format enables (\"#\" indicates\
    \ a\n             missing character or packet, respectively).\n        However,\
    \ it is the consensus of the working group that for\n        applications such\
    \ as subtitling applications and multimedia\n        presentations that use this\
    \ payload format, such partial error\n        correction is not worth the cost\
    \ of including two additional\n        fields; namely, character count and character\
    \ offset.  Instead,\n        it is recommended that some more overhead be invested\
    \ to provide\n        full error correction by protecting the less text sample\n\
    \        fragments using the measures outlined in Section 5.\n     3. Fragment\
    \ re-assembly: In order to re-assemble the text samples,\n        offset information\
    \ is needed.  Instead of a character or byte\n        offset, a single byte, TOTAL/THIS,\
    \ is used.  These two values\n        indicate the total number and current index\
    \ of fragments of a\n        text sample.  This is simpler than having a character\
    \ offset\n        field in each fragment.  Details in Section 4.1.3.\n     4.\
    \ A length field, LEN, is present in the common header fields.\n        While\
    \ the length in the RTP payload format is not needed by most\n        RTP applications\
    \ (typically lower layers, like UDP, provide this\n        information), it does\
    \ ease interoperability with RFC 3640.  This\n        is because the Access Units\
    \ (AUs) used for carriage of data in\n        RFC 3640 must include a length indication.\
    \  Details are in\n        Section 4.8.\n     5. The header fields in the specific\
    \ payload headers (TYPE headers\n        in Sections 4.1.2 to 4.1.6) have been\
    \ arranged for easy\n        processing on 32-bit machines.  For this reason,\
    \ the fields SIDX\n        and SDUR are swapped in TYPE 1 unit, compared to the\
    \ other\n        units.\n"
- title: 3.  Terminology
  contents:
  - "3.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC\
    \ 2119 [5].\n   Furthermore, the following terms are used and have specific meaning\n\
    \   within the context of this document:\n   text sample or whole text sample\n\
    \        In the 3GPP Timed Text media format [1], these terms refer to a\n   \
    \     unit of timed text data as contained in the source (3GP) file.\n       \
    \ This includes the text string byte count, possibly a Byte Order\n        Mark,\
    \ the text string and any modifiers that may follow.  Its\n        equivalent\
    \ in audio/video would be a frame.\n        In this document, however, a text\
    \ sample contains only text\n        strings followed by zero or more modifiers.\
    \  This definition of\n        text sample excludes the 16-bit text string byte\
    \ count and the\n        16-bit Byte Order Mark (BOM) present in 3GP file text\
    \ samples\n        (see Section 4.3 and Figure 9).  The 16-bit BOM is not\n  \
    \      transported in RTP, as explained in Section 4.1.1.\n   text strings\n \
    \       The actual text characters encoded either as UTF-8 or UTF-16.\n      \
    \  When using this payload format, the text string does not contain\n        any\
    \ byte order mark (BOM).  See Figure 9 for details.\n   fragment or text sample\
    \ fragment\n        A fraction of a text sample.  A fragment may contain either\
    \ text\n        strings or modifier (decoration) contents, but not both at the\n\
    \        same time.\n   sample contents\n        General term to identify timed\
    \ text data transported when using\n        this payload format.  Sample contents\
    \ may be one or several text\n        samples, sample descriptions, and sample\
    \ fragments (note that,\n        as per Section 4.6, there is only one case in\
    \ which more than\n        one fragment may be included in a payload).\n   decoration\
    \ or modifiers\n        These terms are used interchangeably throughout the document\
    \ to\n        denote the contents of the text sample that modify the default\n\
    \        text formatting.  Modifiers may, for example, specify different\n   \
    \     font size for a particular sequence of characters or define\n        karaoke\
    \ timing for the sample.\n   sample description\n        Information that is potentially\
    \ shared by more than one text\n        sample.  In a 3GP file, a sample description\
    \ is stored in a\n        place where it can be shared.  It contains setup and\
    \ default\n        information such as scrolling direction, text box position,\n\
    \        delay value, default font, background color, etc.\n   units or transport\
    \ units\n        The payload headers specified in this document encapsulate text\n\
    \        samples, fragments thereof, and sample descriptions by placing a\n  \
    \      common header and specific payload header (Sections 4.1.1 to\n        4.1.6)\
    \ before them, thus building what is here called a\n        (transport) unit.\n\
    \   aggregation or aggregate packet\n        The payload of an aggregate (RTP)\
    \ packet consists of several\n        (transport) units.\n   track or stream\n\
    \        3GP files contain audio/video and text tracks.  This document\n     \
    \   enables streaming of text tracks using RTP.  Therefore, these\n        terms\
    \ are used interchangeably in this document in the context\n        of 3GP files.\n\
    \   Media Header Box / Track Header Box / ...\n        The 3GP file format makes\
    \ use of these structures defined in the\n        ISO Base File Format [2].  When\
    \ referring to these in this\n        document, initials are capitalized for clarity.\n"
- title: 4.  RTP Payload Format for 3GPP Timed Text
  contents:
  - "4.  RTP Payload Format for 3GPP Timed Text\n   The format of an RTP packet containing\
    \ 3GPP timed text is shown\n   below:\n       0                   1          \
    \         2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |V=2|P|X| CC    |M|    PT       |        sequence number        |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                           timestamp                           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |           synchronization source (SSRC) identifier            |\n   \
    \  /+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    | |U|\
    \   R   | TYPE|             LEN               |               :\n    | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \               :\n   U| :           (variable header fields depending on TYPE\
    \           :\n   N| :                                                       \
    \        :\n   I< +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   T| |                                                               |\n   \
    \ | :                    SAMPLE CONTENTS                            :\n    | |\
    \                                               +-+-+-+-+-+-+-+-+\n    | |   \
    \                                            |\n     \\+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \               Figure 1. 3GPP Timed Text RTP Packet Format\n   Marker bit (M):\
    \ The marker bit SHALL be set to 1 if the RTP packet\n   includes one or more\
    \ whole text samples or the last fragment of a\n   text sample; otherwise, it\
    \ is set to zero (0).\n   Timestamp: The timestamp MUST indicate the sampling\
    \ instant of the\n   earliest (or only) unit contained in the RTP packet.  The\
    \ initial\n   value SHOULD be randomly determined, as specified in RTP [3].\n\
    \        The timestamp value should provide enough timing resolution for\n   \
    \     expressing the duration of text samples, for synchronizing text\n      \
    \  with other media, and for performing RTP Control Protocol (RTCP)\n        measurements\
    \ such as the interarrival delay jitter or the RTCP\n        Packet Receipt Times\
    \ Report Block (Section 4.3 of RFC 3611\n        [20]).  This is compliant to\
    \ RTP, Section 5.1:\n             \"The resolution of the clock MUST be sufficient\
    \ for the\n             desired synchronization accuracy and for measuring packet\n\
    \             arrival jitter (one tick per video frame is typically not\n    \
    \         sufficient)\".\n        The above observation applies to both timed\
    \ text tracks included\n        in a 3GP file and live streaming sessions.  In\
    \ the case of a 3GP\n        timed text track, the timestamp clockrate is the\
    \ value of the\n        \"timescale\" parameter in the Media Header Box for that\
    \ text\n        track.  Each track in a 3GP file MAY have its own clockrate as\n\
    \        specified in the Media Header Box.  Likewise, live streaming\n      \
    \  applications SHALL use an appropriate timestamp clockrate.  A\n        default\
    \ value of 1000 Hz is RECOMMENDED.  Other timestamp\n        clockrates MAY be\
    \ used.  In this case, the typical behavior here\n        is to match the 3GPP\
    \ timed text clockrate to that used by an\n        associated audio or video stream.\n\
    \        In an aggregate payload, units MUST be placed in play-out order,\n  \
    \      i.e., earliest first in the payload.  If TYPE 1 units are\n        aggregated,\
    \ the timestamp of the subsequent units MUST be\n        obtained by adding the\
    \ timed text sample duration of previous\n        samples to the RTP timestamp\
    \ value.  There are two exceptions to\n        this rule: TYPE 5 units and an\
    \ aggregate payload containing two\n        fragments of the same text sample.\
    \  The details of the timestamp\n        calculation are given in Section 4.6.\n\
    \        Finally, timestamp clockrates MUST be signaled by out-of-band\n     \
    \   means at session setup, e.g., using the media type \"rate\"\n        parameter\
    \ in SDP.  See Section 9 for details.\n   Payload Type (PT): The payload type\
    \ is set dynamically and sent by\n   out-of-band means.\n   The usage of the remaining\
    \ RTP header fields (namely, V, P, X, CC, SN\n   and SSRC) follows the rules of\
    \ RTP and the profile in use.\n"
- title: 4.1.  Payload Header Definitions
  contents:
  - "4.1.  Payload Header Definitions\n   The (transport) units specified in this\
    \ document consist of a set of\n   common fields (U, R, TYPE, LEN), followed by\
    \ specific header fields\n   (TYPES 1-5) and text sample contents.  See Figure\
    \ 1 and Figure 2.\n   In Figure 2, two example RTP packets are depicted.  The\
    \ first\n   contains an aggregate RTP payload with two complete text samples,\
    \ and\n   the second contains one text sample fragment.  After each unit header\n\
    \   is explained, detailed payload examples follow in Section 4.7.\n         \
    \                               +----------------------+\n                   \
    \                     |                      |\n                             \
    \           |   RTP Header         |\n                                       \
    \ |                      |\n                               ---------+----------------------+\n\
    \                               |        |                      |\n          \
    \                     |        |COMMON + TYPE 1 Header|\n                    \
    \           |        ........................\n                        UNIT 1\
    \ -        |                      |\n                               |        |\
    \    Text Sample       |\n                               |        |          \
    \            |\n                               |-------\\........................\n\
    \                                -------/|                      |\n          \
    \                     |        |COMMON + TYPE 1 Header|\n                    \
    \           |        ........................\n                        UNIT 2\
    \ -        |                      |\n                               |        |\
    \    Text Sample       |\n                               |        |          \
    \            |\n                               |        |                    \
    \  |\n                               ---------+----------------------+\n     \
    \                                   +----------------------+\n               \
    \                         |                      |\n                         \
    \               |   RTP Header         |\n                                   \
    \     |                      |\n                               ---------+----------------------+\n\
    \                               |        |  COMMON + TYPE 2     |\n          \
    \                     |        |    (or 3 or 4) Hdr   |\n                    \
    \           |        ........................\n                        UNIT 3\
    \ -        |                      |\n                               |        |\
    \ Text Sample Fragment |\n                               |        |          \
    \            |\n                               |        |                    \
    \  |\n                               ---------+----------------------+\n     \
    \                Figure 2.  Example RTP packets\n"
- title: 4.1.1.  Common Payload Header Fields
  contents:
  - "4.1.1.  Common Payload Header Fields\n   The fields common to all payload headers\
    \ have the following format:\n            0                   1              \
    \     2\n            0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\n       \
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n           |U|   R   |TYPE\
    \ |             LEN               |\n           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                Figure 3.  Common payload header fields\n   Where:\n   o U (1\
    \ bit) \"UTF Transformation flag\": This is used to inform RTP\n     receivers\
    \ whether UTF-8 (U=0) or UTF-16 (U=1) was used to encode\n     the text string.\
    \  UTF-16 text strings transported by this payload\n     format MUST be serialized\
    \ in big endian order, a.k.a. network byte\n     order.\n        Informative note:\
    \ Timed text clients complying with the 3GPP\n        Timed Text format [1] are\
    \ only required to understand the big\n        endian serialization.  Thus, in\
    \ order to ease interoperability,\n        the reverse serialization (little endian)\
    \ is not supported by\n        this payload format.\n     For the payload formats\
    \ defined in this document, the U bit is only\n     used in TYPE 1 and TYPE 2\
    \ headers.  Senders MUST set the U bit to\n     zero in TYPE 3, TYPE 4, and TYPE\
    \ 5 headers.  Consequently,\n     receivers MUST ignore the U bit in TYPE 3, TYPE\
    \ 4, and TYPE 5\n     headers.\n   o R (4 bits) \"Reserved bits\": for future\
    \ extensions.  This field MUST\n     be set to zero (0x0) and MUST be ignored\
    \ by receivers.\n   o TYPE (3 bits) \"Type Field\": This field specifies which\
    \ specific\n     header fields follow.  The following TYPE values are defined:\n\
    \        - TYPE 1, for a whole text sample.\n        - TYPE 2, for a text string\
    \ fragment (without modifiers).\n        - TYPE 3, for a whole modifier box or\
    \ the first fragment of a\n          modifier box.\n        - TYPE 4, for a modifier\
    \ fragment other than first.\n        - TYPE 5, for a sample description.  Exactly\
    \ one header per\n          sample description.\n        - TYPE 0, 6, and 7 are\
    \ reserved for future extensions.  Note\n          that future extensions are\
    \ possible, e.g., a unit that\n          explicitly signals the number of characters\
    \ present in a\n          fragment (see Section 2.5).  In order to guarantee backwards-\n\
    \          compatibility, it SHALL be possible that older clients ignore\n   \
    \       (newer) units they do not understand, without invalidating the\n     \
    \     timestamp calculation mechanisms or otherwise preventing them\n        \
    \  from decoding the other units.\n   o Finally, the LEN (16 bits) \"Length Field\"\
    : indicates the size (in\n     bytes) of this header field and all the fields\
    \ following, i.e., the\n     LEN field followed by the unit payload: text strings\
    \ and modifiers\n     (if any).  This definition only excludes the initial U/R/TYPE\
    \ byte\n     of the common header.  The LEN field follows network byte order.\n\
    \     The way in which LEN is obtained when streaming out of a 3GP file\n    \
    \ depends on the particular unit type.  This is explained for each\n     unit\
    \ in the sections below.\n     For live streaming, both sample length and the\
    \ LEN value for the\n     current fragment MUST be calculated during the sampling\
    \ process or\n     during fragmentation.\n     In general, LEN may take the following\
    \ values:\n      - TYPE = 1, LEN >= 8\n      - TYPE = 2, LEN > 9\n      - TYPE\
    \ = 3, LEN > 6\n      - TYPE = 4, LEN > 6\n      - TYPE = 5, LEN > 3\n     Receivers\
    \ MUST discard units that do not comply with these values.\n     However, the\
    \ RTP header fields and the rest of the units in the\n     payload (if any) are\
    \ still useful, as guaranteed by the requirement\n     for future extensions above.\n\
    \     In the following subsections the different payload headers for the\n   \
    \  values of TYPE are specified.\n"
- title: 4.1.2.  TYPE 1 Header
  contents:
  - "4.1.2.  TYPE 1 Header\n       0                   1                   2     \
    \              3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |U|   R   |TYPE |       LEN  (always >=8)       |    SIDX       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                      SDUR                     |     TLEN      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |      TLEN     |\n      +-+-+-+-+-+-+-+-+\n                    Figure\
    \ 4.  TYPE 1 Header Format\n   This header type is used to transport whole text\
    \ samples.  This unit\n   should be the most common case, i.e., the text sample\
    \ should usually\n   be small enough to be transported in one unit without having\
    \ to\n   separate text strings from modifiers.  In an aggregate (RTP packet)\n\
    \   payload containing several text samples, every sample is preceded by\n   its\
    \ own TYPE 1 header (see Figure 12).\n        Informative note: As indicated in\
    \ Section 3, \"Terminology\", a\n        text sample is composed of the text strings\
    \ followed by the\n        modifiers (if any).  This is also how text samples\
    \ are stored in\n        3GP files.  The separation of a text sample into text\
    \ strings\n        and modifiers is only needed for large samples (or small\n\
    \        available IP MTU sizes; see Section 4.4), and it is accomplished\n  \
    \      with TYPE 2 and TYPE 3 headers, as explained in the sections\n        below.\n\
    \   Note also that empty text samples are considered whole text samples,\n   although\
    \ they do not contain sample contents.  Empty text samples may\n   be used to\
    \ clear the display or to put an end to samples of unknown\n   duration, for example.\
    \  Units without sample contents SHALL have a\n   LEN field value of 8 (0x0008).\n\
    \   The fields above have the following meaning:\n   o U, R, and TYPE, as defined\
    \ in Section 4.1.1.\n   o LEN, in this case, represents the length of the (complete)\
    \ text\n     sample plus eight (8) bytes of headers.  For finding the length of\n\
    \     the text sample in the Sample Size Box of 3GP files, see Section\n     4.3.\n\
    \   o SIDX (8 bits) \"Text Sample Entry Index\": This is an index used to\n  \
    \   identify the sample descriptions.\n     The SIDX field is used to find the\
    \ sample description corresponding\n     to the unit's payload.  There are two\
    \ types of SIDX values: static\n     and dynamic.\n     Static SIDX values are\
    \ used to identify sample descriptions that\n     MUST be sent out-of-band and\
    \ MUST remain active during the whole\n     session.  A static SIDX value is unequivocally\
    \ linked to one\n     particular sample description during the whole session.\
    \  Carrying\n     many sample descriptions out-of-band SHOULD be avoided, since\
    \ these\n     may become large and, ultimately, transport is not the goal of the\n\
    \     out-of-band channel.  Thus, this feature is RECOMMENDED for\n     transporting\
    \ those sample descriptions that provide a set of\n     minimum default format\
    \ settings.  Static SIDX values MUST fall in\n     the (closed) interval [129,254].\n\
    \     Dynamic SIDX values are used for sample descriptions sent in-band.\n   \
    \  Sample descriptions MAY be sent in-band for several reasons:\n     because\
    \ they are generated in real time, for transport resiliency,\n     or both.  A\
    \ dynamic SIDX value is unequivocally linked to one\n     particular sample description\
    \ during the period in which this is\n     active in the session, and it SHALL\
    \ NOT be modified during that\n     period.  This period MAY be smaller than or\
    \ equal to the session\n     duration.  This period is not known a priori.  A\
    \ maximum of 64\n     dynamic simultaneously active SIDX values is allowed at\
    \ any moment.\n     Dynamic SIDX values MUST fall in the closed interval [0,127].\
    \  This\n     should be enough for both recorded content and live streaming\n\
    \     applications.  Nevertheless, a wraparound mechanism is provided in\n   \
    \  Section 4.2.1 to handle streaming sessions where more than 64 SIDX\n     values\
    \ might be needed.  Servers MAY make use of dynamic sample\n     descriptions.\
    \  Clients MUST be able to receive and interpret\n     dynamic sample descriptions.\n\
    \     Finally, SIDX values 128 and 255 are reserved for future use.\n   o SDUR\
    \ (24 bits) \"Text Sample Duration\": indicates the sample\n     duration in RTP\
    \ timestamp units of the text sample.  For this\n     field, a length of 3 bytes\
    \ is preferred to 2 bytes.  This is\n     because, for a typical clockrate of\
    \ 1000 Hz, 16 bits would allow\n     for a maximum duration of just 65 seconds,\
    \ which might be too short\n     for some streams.  On the other hand, 24 bits\
    \ at 1000 Hz allow for\n     a maximum duration of about 4.6 hours, while for\
    \ 90 KHz, this value\n     is about 3 minutes.  These values should be enough\
    \ for streaming\n     applications.  However, if a larger duration is needed,\
    \ the\n     extension mechanism specified in Section 4.3 SHALL be used.\n    \
    \ Apart from defining the time period during which the text is\n     displayed,\
    \ the duration field is also used to find the timestamp of\n     subsequent units\
    \ within the aggregate RTP packet payload (if any).\n     This is explained in\
    \ Section 4.6.\n     Text samples have generally a known duration at the time\
    \ of\n     transmission.  However, in some cases such as live streaming, the\n\
    \     time for which a text piece shall be presented might not be known a\n  \
    \   priori.  Thus, the value zero SDUR=0 (0x000000) is reserved to\n     signal\
    \ unknown duration.  The amount of time that a sample of\n     unknown duration\
    \ is presented is determined by the timestamp of the\n     next sample that shall\
    \ be displayed at the receiver: Text samples\n     of unknown duration SHALL be\
    \ displayed until the next text sample\n     becomes active, as indicated by its\
    \ timestamp.\n     The next example illustrates how units of unknown duration\
    \ MUST be\n     presented.  If no text sample following is available, it is an\n\
    \     implementation issue what should be displayed.  For example, a\n     server\
    \ could send an empty sample to clear the text box.\n        Example: Imagine\
    \ you are in an airport watching the latest news\n        report while you wait\
    \ for your plane.  Airports are loud, so the\n        news report is transcribed\
    \ in the lower area of the screen.\n        This area displays two lines of text:\
    \ the headlines and the\n        words spoken by the news speaker.  As usual,\
    \ the headlines are\n        shown for a longer time than the rest.  This time\
    \ is, in\n        principle, unknown to the stream server, which is streaming\n\
    \        live.  A headline is just replaced when the next headline is\n      \
    \  received.\n     However, upon storing a text sample with SDUR=0 in a 3GP file,\
    \ the\n     SDUR value MUST be changed to the effective duration of the text\n\
    \     sample, which MUST be always greater than zero (note that the ISO\n    \
    \ file format [2] explicitly forbids a sample duration of zero).  The\n     effective\
    \ duration MUST be calculated as the timestamp difference\n     between the current\
    \ sample (with unknown duration) and the next\n     text sample that is displayed.\n\
    \     Note that samples of unknown duration SHALL NOT use features, which\n  \
    \   require knowledge of the duration of the sample up front.  Such\n     features\
    \ are scrolling and karaoke in [1].  This also applies for\n     future extensions\
    \ of the Timed Text format.  Furthermore, only\n     sample descriptions (TYPE\
    \ 5 units) MAY follow units of unknown\n     duration in the same aggregate payload.\
    \  Otherwise, it would not be\n     possible to calculate the timestamp of these\
    \ other units.\n     For text contents stored in 3GP files, see Section 4.3 for\
    \ details\n     on how to extract the duration value.  For live streaming, live\n\
    \     encoders SHALL assign appropriate values and units according to [1]\n  \
    \   and later releases.\n   o TLEN (16 bits), \"Text String Length\", is a byte\
    \ count of the text\n     string.  The decoder needs the text string length in\
    \ order to know\n     where the modifiers in the payload start.  TLEN is not present\
    \ in\n     text string fragments (TYPE 2) since it can be deductively\n     calculated\
    \ from the LEN values of each fragment.\n     The TLEN value is obtained from\
    \ the text samples as contained in\n     3GP files.  Refer to Section 4.3.  For\
    \ live content, the TLEN MUST\n     be obtained during the sampling process.\n\
    \   o Finally, the actual text sample is placed after the TLEN field.  As\n  \
    \   defined in Section 3, a text sample consists of a string of\n     characters\
    \ encoded using either UTF-8 or UTF-16, followed by zero\n     or more modifiers.\
    \  Note also that no BOM and no byte count are\n     included in the strings carried\
    \ in the payload (as opposed to text\n     samples stored in 3GP files [1]).\n"
- title: 4.1.3.  TYPE 2 Header
  contents:
  - "4.1.3.  TYPE 2 Header\n       0                   1                   2     \
    \              3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |U|   R   |TYPE |          LEN( always >9)      | TOTAL | THIS  |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                    SDUR                       |    SIDX       |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |               SLEN            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      Figure 5.  TYPE 2 Header Format\n   This header type is\
    \ used to transport either a whole text string or a\n   fragment of it.  TYPE\
    \ 2 units SHALL NOT contain modifiers.  In\n   detail:\n   o U, R, and TYPE, as\
    \ defined in Section 4.1.1.\n   o SIDX and SDUR, as defined in Section 4.1.2.\n\
    \        Note that the U, SIDX, and SDUR fields are meaningful since\n       \
    \ partial text strings can also be displayed.\n   o The LEN field (16 bits) indicates\
    \ the length of the text string\n     fragment plus nine (9) bytes of headers.\
    \  Its value is calculated\n     upon fragmentation.  LEN MUST always be greater\
    \ than nine (0x0009).\n     Otherwise, the unit MUST be discarded.\n     According\
    \ to the guidelines in Section 4.4, text strings MUST be\n     split at character\
    \ boundaries for allowing the display of text\n     fragments.  Therefore, a text\
    \ fragment MUST contain at least one\n     character in either UTF-8 or UTF-16.\
    \  Actually, this is just a\n     formalism since by observing the guidelines,\
    \ much larger fragments\n     should be created.\n     Note also that TYPE 2 units\
    \ do not contain an explicit text string\n     length, TLEN (see TYPE 1).  This\
    \ is because TYPE 2 units do not\n     contain any modifiers after the text string.\
    \  If needed, the length\n     of the received string can be obtained using the\
    \ LEN values of the\n     TYPE 2 units.\n   o The SLEN field (16 bits) indicates\
    \ the size (in bytes) of the\n     original (whole) text sample to which this\
    \ fragment belongs.  This\n     length comprises the text string plus any modifier\
    \ boxes present\n     (and includes neither the byte order mark nor the text string\n\
    \     length as mentioned in Section 3, \"Terminology\").\n     Regarding the\
    \ text sample length: Timed text samples are not\n     generated at regular intervals,\
    \ nor is there a default sample size.\n     If 3GP files are streamed, the length\
    \ of the text samples is\n     calculated beforehand and included in the track\
    \ itself, while for\n     live encoding it is the real time encoder that SHALL\
    \ choose an\n     appropriate size for each text sample.  In this case, the amount\
    \ of\n     text 'captured' in a sample depends on the text source and the\n  \
    \   particular application (see examples below).  Samples may, e.g., be\n    \
    \ tailored to match the packet MTU as closely as possible or to\n     provide\
    \ a given redundancy for the available bit rate.  The\n     encoding application\
    \ MUST also take into account the delay\n     constraints of the real-time session\
    \ and assess whether FEC,\n     retransmission, or other similar techniques are\
    \ reasonable options\n     for stream repair.\n     The following examples shall\
    \ illustrate how a real-time encoder may\n     choose its settings to adapt to\
    \ the scenario constraints.\n          Example: Imagine a newscast scenario, where\
    \ the spoken news is\n          transcribed and synchronized with the image and\
    \ voice of the\n          reporter.  We assume that the news speaker talks at\
    \ an average\n          speed of 5 words per second with an average word length\
    \ of 5\n          characters plus one space per word, i.e., 30 characters per\n\
    \          second.  We assume an available IP MTU of 576 bytes and an\n      \
    \    available bitrate of 576*8 bits per second = 4.6 Kbps.  We\n          assume\
    \ each character can be encoded using 2 bytes in UTF-16.\n          In this scenario,\
    \ several constraints may apply; for example:\n          available IP MTU, available\
    \ bandwidth, allowable delay, and\n          required redundancy.  If the target\
    \ were to minimize the\n          packet overhead, a text sample covering 8 seconds\
    \ of text\n          would be closest to the IP MTU:\n       IP/UDP/RTP/TYPE1\
    \ Header + (8-second text sample)\n     = 20 + 8 + 12 + 8 + (~6 chars/word * 5\
    \ word/s * 8 s * 2 chars/word)\n     = 528 bytes < 576 bytes\n    For other scenarios,\
    \ like lossy networks, it may happen that just\n    one packet per sample is too\
    \ low a redundancy.  In this case, a\n    choice could be that the encoder 'collects'\
    \ text every second, thus\n    yielding text samples (TYPE 1 units) of 68 bytes,\
    \ TYPE 1 header\n    included.  We can, e.g., include three contiguous text samples\
    \ in\n    one RTP payload: the current and last two text samples (see below).\n\
    \    This accounts to a total IP packet size of 20 + 8 + 12 + 3*(8 + 60)\n   \
    \ = 244 bytes.  Now, with the same available bitrate of 4.6 Kbps,\n    these 244-byte\
    \ packets can be sent redundantly up two times per\n    second:\n          RTP\
    \ payload (1,2,3)(1,2,3) (2,3,4)(2,3,4) (3,4,5)(3,4,5) ...\n          Time:  \
    \     <----1s------> <----1s------> <-----1s-----> ...\n          This means that\
    \ each text sample is sent at least six times,\n          which should provide\
    \ enough redundancy.  Although not as\n          bandwidth efficient (488*8 <\
    \ 528*8  < 576*8 bps) as the\n          previous packetization, this option increases\
    \ the stream\n          redundancy while still meeting the delay and bandwidth\n\
    \          constraints.\n          Another example would be a user sending timed\
    \ text from a\n          type-in area in the display.  In this case, the text\
    \ sample is\n          created as soon as the user clicks the 'send' button.\n\
    \          Depending on the packet length, fragmentation may be needed.\n    \
    \      In a video conferencing application, text is synchronized with\n      \
    \    audio and video.  Thus, the text samples shall be displayed\n          long\
    \ enough to be read by a human, shall fit in the video\n          screen, and\
    \ shall 'capture' the audio contents rendered during\n          the time the corresponding\
    \ video and audio is rendered.\n     For stored content, see Section 4.3 for details\
    \ on how to find the\n     SLEN value in a 3GP file.  For live content, the SLEN\
    \ MUST be\n     obtained during the sampling process.\n     Finally, note that\
    \ clients MAY use SLEN to buffer space for the\n     remaining fragments of a\
    \ text sample.\n   o The fields TOTAL (4 bits) and THIS (4 bits) indicate the\
    \ total\n     number of fragments in which the original text sample (i.e., the\n\
    \     text string and its modifiers) has been fragmented and which order\n   \
    \  occupies the current fragment in that sequence, respectively.  Note\n     that\
    \ the sequence number alone cannot replace the functionality of\n     the THIS\
    \ field, since packets (and fragments) may be repeated,\n     e.g., as in repeated\
    \ transmission (see Section 5).  Thus, an\n     indication for \"fragment offset\"\
    \ is needed.\n     The usual \"byte offset\" field is not used here for two reasons:\
    \ a)\n     it would take one more byte and b) it does not provide any\n     information\
    \ on the character offset.  UTF-8/UTF-16 text strings\n     have, in general,\
    \ a variable character length ranging from 1 to 6\n     bytes.  Therefore, the\
    \ TOTAL/THIS solution is preferred.  It could\n     also be argued that the LEN\
    \ and SLEN fields be used for this\n     purpose, but while they would provide\
    \ information about the\n     completeness of the text sample, they do not specify\
    \ the order of\n     the fragments.\n     In all cases (TYPEs 2, 3 and 4), if\
    \ the value of THIS is greater\n     than TOTAL or if TOTAL equals zero (0x0),\
    \ the fragment SHALL be\n     discarded.\n   o Finally, the sample contents following\
    \ the SLEN field consist of a\n     fragment of the UTF-8/UTF-16 character string;\
    \ no modifiers follow.\n"
- title: 4.1.4.  TYPE 3 Header
  contents:
  - "4.1.4.  TYPE 3 Header\n       0                   1                   2     \
    \              3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |U|   R   |TYPE |        LEN( always >6)        |TOTAL  |  THIS |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                      SDUR                     |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      Figure 6.  TYPE 3 Header Format\n   This header type is\
    \ used to transport either the entire modifier\n   contents present in a text\
    \ sample or just the first fragment of them.\n   This depends on whether the modifier\
    \ boxes fit in the current RTP\n   payload.\n   If a text sample containing modifiers\
    \ is fragmented, this header MUST\n   be used to transport the first fragment\
    \ or, if possible, the complete\n   modifiers.\n   In detail:\n   o The U, R,\
    \ and TYPE fields are defined as in Section 4.1.1.\n   o LEN indicates the length\
    \ of the modifier contents.  Its value is\n     obtained upon fragmentation. \
    \ Additionally, the LEN field MUST be\n     greater than six (0x0006).  Otherwise,\
    \ the unit MUST be discarded.\n   o The TOTAL/THIS field has the same meaning\
    \ as for TYPE 2.\n     For TYPE 3 units containing the last (trailing) modifier\
    \ fragment,\n     the value of TOTAL MUST be equal to that of THIS (TOTAL=THIS).\
    \  In\n     addition, TOTAL=THIS MUST be greater than one, because the total\n\
    \     number of fragments of a text sample is logically always larger\n     than\
    \ one.\n     Otherwise, if TOTAL is different from THIS in a TYPE 3 unit, this\n\
    \     means that the unit contains the first fragment of the modifiers.\n   o\
    \ The SDUR has the same definition for TYPE 1.  Since the fragments\n     are\
    \ always transported in own RTP packets, this field is only\n     needed to know\
    \ how long this fragment is valid.  This may, e.g., be\n     used to determine\
    \ how long it should be kept in the display buffer.\n   Note that the SLEN and\
    \ SIDX fields are not present in TYPE 3 unit\n   headers.  This is because a)\
    \ these fragments do not contain text\n   strings and b) these types of fragments\
    \ are applied over text string\n   fragments, which already contain this information.\n"
- title: 4.1.5.  TYPE 4 Header
  contents:
  - "4.1.5.  TYPE 4 Header\n       0                   1                   2     \
    \              3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |U|   R   |TYPE |        LEN( always >6)        |TOTAL  |  THIS |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                      SDUR                     |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      Figure 7.  TYPE 4 Header Format\n   This header type is\
    \ placed before modifier fragments, other than the\n   first one.\n   The U, R,\
    \ and TYPE fields are used as per Section 4.1.1.\n   LEN indicates as for TYPE\
    \ 3 the length of the modifier contents and\n   SHALL also be obtained upon fragmentation.\
    \  The LEN field MUST be\n   greater than six (0x0006).  Otherwise, the unit MUST\
    \ be discarded.\n   TOTAL/THIS is used as in TYPE 2.\n   The SDUR field is defined\
    \ as in TYPE 1.  The reasoning behind the\n   absence of SLEN and SIDX is the\
    \ same as in TYPE 3 units.\n"
- title: 4.1.6.  TYPE 5 Header
  contents:
  - "4.1.6.  TYPE 5 Header\n       0                   1                   2     \
    \              3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |U|   R   |TYPE |      LEN( always >3)          |   SIDX        |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \                Figure 8.  TYPE 5 Header Format\n   This header type is used\
    \ to transport (dynamic) sample descriptions.\n   Every sample description MUST\
    \ have its own TYPE 5 header.\n   The U, R, and TYPE fields are used as per Section\
    \ 4.1.1.\n   The LEN field indicates the length of the sample description, plus\n\
    \   three units accounting for the SIDX and LEN field itself.  Thus, this\n  \
    \ field MUST be greater than three (0x0003).  Otherwise, the unit MUST\n   be\
    \ discarded.\n   If the sample is streamed from a 3GP file, the length of the\
    \ sample\n   description contents (i.e., what comes after SIDX in the unit itself)\n\
    \   is obtained from the file (see Section 4.3).\n   The SIDX field contains a\
    \ dynamic SIDX value assigned to the sample\n   description carried as sample\
    \ content of this unit.  As only dynamic\n   sample descriptions are carried using\
    \ TYPE 5, the possible SIDX\n   values are in the (closed) interval [0,127].\n\
    \   Senders MAY make use of TYPE 5 units.  All receivers MUST implement\n   support\
    \ for TYPE 5 units, since it adds minimum complexity and may\n   increase the\
    \ robustness of the streaming session.\n   The next section specifies how SIDX\
    \ values are calculated.\n"
- title: 4.2.  Buffering of Sample Descriptions
  contents:
  - "4.2.  Buffering of Sample Descriptions\n   The buffering of sample descriptions\
    \ is a matter of the client's\n   timed text codec implementation.  In order to\
    \ work properly, this\n   payload format requires that:\n     o Static sample\
    \ descriptions MUST be buffered at the client, at\n       least, for the duration\
    \ of the session.\n     o If dynamic sample descriptions are used, their buffering\
    \ and\n       update of the SIDX values MUST follow the mechanism described in\n\
    \       the next section.\n"
- title: 4.2.1.  Dynamic SIDX Wraparound Mechanism
  contents:
  - "4.2.1.  Dynamic SIDX Wraparound Mechanism\n   The use of dynamic sample descriptions\
    \ by senders is OPTIONAL.\n   However, if they are used, senders MUST implement\
    \ this mechanism.\n   Receivers MUST always implement it.\n   Dynamic SIDX values\
    \ remain active either during the entire duration\n   of the session (if used\
    \ just once) or in different intervals of it\n   (if used once or more).\n   \
    \     Note: In the following, SIDX means dynamic SIDX.\n   For choosing the wraparound\
    \ mechanism, the following rationale was\n   used: There are 128 dynamic SIDX\
    \ values possible, [0..127].  If one\n   chooses to allow a maximum of 127 to\
    \ be used as dynamic SIDXs, then\n   any reordered packet with a new sample description\
    \ would make the\n   mechanism fail.  For example, if the last packet received\
    \ is SIDX=5,\n   then all 127 values except SIDX=6 would be \"active\".  Now,\
    \ if a\n   reordered packet arrives with a new description, SIDX=9, it will be\n\
    \   mistakenly discarded, because the SIDX=9 is, at that moment, marked\n   as\
    \ \"active\" and active sample descriptions shall not be re-written.\n   Therefore,\
    \ a \"guard interval\" is introduced.  This guard interval\n   reduces the number\
    \ of active SIDXs at any point in time to 64.\n   Although most timed text applications\
    \ will probably need less than 64\n   sample descriptions during a session (in\
    \ total), a wraparound\n   mechanism to handle the need for more is described\
    \ here.\n   Thereby, a sliding window of 64 active SIDX values is used.  Values\n\
    \   within the window are \"active\"; all others are marked \"inactive\".  An\n\
    \   SIDX value becomes active if at least one sample description\n   identified\
    \ by that SIDX has been received.  Since sample descriptions\n   MAY be sent redundantly,\
    \ it is possible that a client receives a\n   given SIDX several times.  However,\
    \ active sample descriptions SHALL\n   NOT be overwritten: The receiver SHALL\
    \ ignore redundant sample\n   descriptions and it MUST use the already cached\
    \ copy.  The \"guard\n   interval\" of (64) inactive values ensures that the correct\n\
    \   association SIDX <-> sample description is always used.\n        Informative\
    \ note: As for the \"guard interval\" value itself, 64\n        as 128/2 was considered\
    \ simple enough while still meeting the\n        expected maximum number of sample\
    \ descriptions.  Besides that,\n        there's no other motivation for choosing\
    \ 64 or a different\n        value.\n   The following algorithm is used to buffer\
    \ dynamic sample descriptions\n   and to maintain the dynamic SIDX values:\n \
    \  Let X be the last SIDX received that updated the range of active\n   sample\
    \ descriptions.  Let Y be a value within the allowed range for\n   dynamic SIDX:\
    \ [0,127], and different from X.  Let Z be the SIDX of\n   the last received sample\
    \ description.  Then:\n     1. Initialize all dynamic SIDX values as inactive.\
    \  For stored\n        contents, read the sample description index in the Sample\
    \ to\n        Chunk box (\"stsc\") for that sample.  For live streaming, the\n\
    \        first value MAY be zero or any other value in the interval\n        above.\
    \  Go to step 2.\n     2. First, in-band sample description with SIDX=Z is received\
    \ and\n        stored; set X=Z.  Go to step 3.\n     3. Any SIDX within the interval\
    \ [X+1 modulo(128), X+64 modulo(128)]\n        is marked as inactive, and any\
    \ corresponding sample description\n        is deleted.  Any SIDX within the interval\
    \ [X+65 modulo(128), X]\n        is set active.  Go to step 4 (wait state).\n\
    \     4. Wait for next sample description.  Once the client is\n        initialized,\
    \ the interval of active SIDX values MUST change\n        whenever a sample description\
    \ with an SIDX value in the inactive\n        set is received.  That is, upon\
    \ reception of a sample\n        description with SIDX=Z, do the following:\n\
    \        a. If Z is in the (closed) interval [X+1 modulo(128), X+64\n        \
    \   modulo(128)] then set X=Z, store the sample description, and\n           go\
    \ to step 3.\n        b. Else, Z must be in the interval [X+65 modulo(128), X],\
    \ thus:\n            i. If SIDX=Z is not stored, then store the sample\n     \
    \          description. Go to beginning of step 4 (wait state).\n           ii.\
    \ Else, go to the beginning of step 4 (wait state).\n        Informative note:\
    \ It is allowed that any value of SIDX=X be sent\n        in the interval [0,127].\
    \  For example, if [64..127] is the\n        current active set and SIDX=0 is\
    \ sent, a new sample description\n        is defined (0) and an old one deleted\
    \ (64); thus [65..127] and\n        [0] are active.  Similarly, one could now\
    \ send SIDX=64, thus\n        inverting the active and inactive sets.\n   Example:\n\
    \        If X=4, any SIDX in the interval [5,68] is inactive.  Active\n      \
    \  SIDX values are in the complementary interval [69,127] plus\n        [0,4].\
    \  For example, if the client receives a SIDX=6, then the\n        active interval\
    \ is now different: [0,6] plus [71,127].  If the\n        received SIDX is in\
    \ the current active interval, no change SHALL\n        be applied.\n"
- title: 4.3.  Finding Payload Header Values in 3GP Files
  contents:
  - "4.3.  Finding Payload Header Values in 3GP Files\n   For the purpose of streaming\
    \ timed text contents, some values in the\n   boxes contained in a 3GP file are\
    \ mapped to fields of this payload\n   header.  This section explains where to\
    \ find those values.\n   Additionally, for the duration and sample description\
    \ indexes,\n   extension mechanisms are provided.  All senders MUST implement\
    \ the\n   extension mechanisms described herein.\n   If the file is streamed out\
    \ of a 3GP file, the following guidelines\n   SHALL be followed.\n        Note:\
    \ All fields in the objects (boxes) of a 3GP file are found\n        in network\
    \ byte order.\n   Information obtained from the Sample Table Box (stbl):\n   \
    \     o Sample Descriptions and Sample Description length: The Sample\n      \
    \    Description box (stsd, inside the stbl) contains the sample\n          descriptions.\
    \  For timed text media, each element of stsd is a\n          timed text sample\
    \ entry (type \"tx3g\").\n          The (unsigned) 32 bits of the \"size\" field\
    \ in the stsd box\n          represent the length (in bytes) of the sample description,\
    \ as\n          carried in TYPE 5 units.  On the other hand, the LEN field of\n\
    \          TYPE 5 units is restricted to 16 bits.  Therefore, if the\n       \
    \   value of \"size\" is greater than (2^16-1-3)[bytes], then the\n          sample\
    \ description SHALL NOT be streamed with this payload\n          format.  There\
    \ is no extension mechanism defined in this case,\n          since fragmentation\
    \ of sample descriptions is not defined\n          (sample descriptions are typically\
    \ up to some 200 bytes in\n          size).  Note: The three (3) accounts for\
    \ the TYPE 5 header\n          fields included in the LEN value.\n        o SDUR\
    \ from the Decoding Time to Sample Box (stts).  The\n          (unsigned) 32 bits\
    \ of the \"sample delta\" field are used for\n          calculating SDUR.  However,\
    \ since the SDUR field is only 3\n          bytes long, text samples with duration\
    \ values larger than\n          (2^24-1)/(timestamp clockrate)[seconds] cannot\
    \ be streamed\n          directly.  The solution is simple: Copies of the corresponding\n\
    \          text sample SHALL be sent.  Thereby, the timestamp and\n          duration\
    \ values SHALL be adjusted so that a continuous display\n          is guaranteed\
    \ as if just one sample would have been sent.\n          That is, a sample with\
    \ timestamp TS and duration SDUR can be\n          sent as two samples having\
    \ timestamps TS1 and TS2 and\n          durations SDUR1 and SDUR2, such that TS1=TS,\
    \ TS2=TS1+SDUR1,\n          and SDUR=SDUR1+SDUR2.\n        o Text sample length\
    \ from the Sample Size Box (stsz).  The\n          (unsigned) 32 bits of the \"\
    sample size\" or \"entry size\" (one\n          of them, depending on whether\
    \ the sample size is fixed or\n          variable) indicate the length (in bytes)\
    \ of the 3GP text\n          sample.  For obtaining the length of the (actual)\
    \ streamed\n          text sample, the lengths of the text string byte count (2\n\
    \          bytes) and, in case of UTF-16 strings, the length the BOM\n       \
    \   (also 2 bytes) SHALL be deducted.  This is illustrated in\n          Figure\
    \ 9.\n          Text Sample according to 3GPP TS 26.245\n                    \
    \           TEXT SAMPLE (length=stsz)\n                 .--------------------------------------------------.\n\
    \                /                                                    \\\n   \
    \                            TEXT STRING  (length=TBC)\n                    .------------------------------------.\n\
    \                   /                                      \\\n              \
    \  TBC BOM                                     MODIFIERS\n               +---+---+----------------------------------+-----------+\n\
    \                                     ||\n                                   \
    \  ||    TBC BOM  -> TLEN  field\n                                     ||   +---+---+\
    \    U bit\n                                     ||\n                        \
    \             \\/\n          Text Sample according to this Payload Format\n  \
    \                               TEXT SAMPLE (length=SLEN w/o TBC,BOM)\n      \
    \                  .--------------------------------------------.\n          \
    \             /                                              \\\n            \
    \                         TEXT STRING (length=TLEN)\n                        .--------------------------------.\n\
    \                       /                                  \\\n              \
    \                      TEXT STRING             MODIFIERS\n                   \
    \    +----------------------------------+-----------+\n              KEY:\n  \
    \            TBC = Text string Byte Count\n              BOM = Byte Order Mark\n\
    \                    Figure 9.  Text sample composition\n          Moreover, since\
    \ the LEN field in TYPE 1 unit header is 16 bits\n          long, larger text\
    \ sample sizes than (2^16-1-8) [bytes] SHALL\n          NOT be streamed.  Also,\
    \ in this case, no extension mechanism\n          is defined.  This is because\
    \ this maximum is considered enough\n          for the targeted streaming applications.\
    \ (Note: The eight (8)\n          accounts for the TYPE 1 header fields included\
    \ in the LEN\n          value).\n        o SIDX from the Sample to Chunk Box (stsc):\
    \ The stsc Box is used\n          to find samples and their corresponding sample\
    \ descriptions.\n          These are referenced by the \"sample description index\"\
    , a\n          32-bit (unsigned) integer.  If possible, these indices may be\n\
    \          directly mapped to the SIDX field.  However, there are several\n  \
    \        cases where this may not be possible:\n                  a) The total\
    \ number of indices used is greater than\n               the number of indices\
    \ available, i.e., if the static\n               sample descriptions are more\
    \ than 127 or the dynamic ones\n               are more than 64.\n           \
    \       b) The original SIDX value ranges do not fit in the\n               allowed\
    \ ranges for static (129-254) or dynamic (0-127)\n               values.\n   \
    \       Therefore, when assigning SIDX values to the sample\n          descriptions,\
    \ the following guidelines are provided:\n          o    Static sample descriptions\
    \ can simply be assigned\n               consecutive values within the range 129-254\
    \ (closed\n               interval).  This range should be well enough for static\n\
    \               sample descriptions.\n          o    As for dynamic sample descriptions:\n\
    \                  a) Streams that use less than 64 dynamic sample\n         \
    \      descriptions SHOULD use consecutive values for SIDX\n               anywhere\
    \ in the range 0-127 (closed interval).\n                  b) For streams with\
    \ more than 64 sample descriptions,\n               the SIDX values MUST be assigned\
    \ in usage order, and if\n               any sample description shall be used\
    \ after it has been\n               set inactive, it will need to be re-sent and\
    \ assigned a\n               new SIDX value (according to the algorithm in Section\n\
    \               4.2.1).\n   Information obtained from the Media Data Box:\n  \
    \      o Text strings, TLEN, U bit, and modifiers from the Media Data\n      \
    \    Box (mdat).  Text strings, 16-bit text string byte count, Byte\n        \
    \  Order Mark (BOM, indicating UTF encoding), and modifier boxes\n          can\
    \ be found here.\n          For TYPE 1 units, the value of TLEN is extracted from\
    \ the text\n          string byte count that precedes the text string in the text\n\
    \          sample, as stored in the 3GP file.  If UTF-16 encoding is\n       \
    \   used, two (2) more bytes have to be deducted from this byte\n          count\
    \ beforehand, in order to exclude the BOM.  See Figure 9.\n"
- title: 4.4.  Fragmentation of Timed Text Samples
  contents:
  - "4.4.  Fragmentation of Timed Text Samples\n   This section explains why text\
    \ samples may have to be fragmented and\n   discusses some of the possible approaches\
    \ to doing it.  A solution is\n   proposed together with rules and recommendations\
    \ for fragmenting and\n   transporting text samples.\n   3GPP Timed Text applications\
    \ are expected to operate at low bitrates.\n   This fact, added to the small size\
    \ of timed text samples (typically\n   one or two hundred bytes) makes fragmentation\
    \ of text samples a rare\n   event.  Samples should usually fit into the MTU size\
    \ of the used\n   network path.\n   Nevertheless, some text strings (e.g., ending\
    \ roll in a movie) and\n   some modifier boxes (i.e., for hyperlinks, for karaoke,\
    \ or for\n   styles) may become large.  This may also apply for future modifier\n\
    \   boxes.  In such cases, the first option to consider is whether it is\n   possible\
    \ to adjust the encoding (e.g., the size of sample) in such a\n   way that fragmentation\
    \ is avoided.  If it is, this is preferred to\n   fragmentation and SHOULD be\
    \ done.\n   Otherwise, if this is not possible or other constraints prevent it,\n\
    \   fragmentation MAY be used, and the basic guidelines given in this\n   document\
    \ MUST be followed:\n   o It is RECOMMENDED that text samples be fragmented as\
    \ seldom as\n     possible, i.e., the least possible number of fragments is created\n\
    \     out of a text sample.\n   o If there is some bitrate and free space in the\
    \ payload available,\n     sample descriptions (if at hand) SHOULD be aggregated.\n\
    \   o Text strings MUST split at character boundaries; see TYPE 2 header.\n  \
    \   Otherwise, it is not possible to display the text contents of a\n     fragment\
    \ if a previous fragment was lost.  As a consequence, text\n     string fragmentation\
    \ requires knowledge of the UTF-8/UTF-16\n     encoding formats to determine character\
    \ boundaries.\n   o Unlike text strings, the modifier boxes are NOT REQUIRED to\
    \ be\n     split at meaningful boundaries.  However, it is RECOMMENDED that\n\
    \     this be done whenever possible.  This decreases the effects of\n     packet\
    \ loss.  This payload format does not ensure that partially\n     received modifiers\
    \ are applied to text strings.  If only part of\n     the modifiers is received,\
    \ it is an application issue how to deal\n     with these, i.e., whether or not\
    \ to use them.\n        Informative note: Ensuring that partially received modifiers\
    \ can\n        be applied to text strings in all cases (for all modifier types\n\
    \        and for all fragment loss constellations) would place additional\n  \
    \      requirements on the payload format.  In particular, this would\n      \
    \  require that: a) senders understand the semantics of the\n        modifier\
    \ boxes and b) specific fragment headers for each of the\n        modifier boxes\
    \ are defined, in addition to the payload formats\n        defined below.  Understanding\
    \ the modifiers semantics means\n        knowing, e.g., where each modifier starts\
    \ and ends, which text\n        fragments are affected, which modifiers may or\
    \ may not be split,\n        or what the fields indicate.  This is necessary to\
    \ be able to\n        split the modifiers in such a way that each fragment can\
    \ be\n        applied independently of previous packet losses.  This would\n \
    \       require a more intelligent fragmentation entity and more complex\n   \
    \     headers.  Given the low probability of fragmentation and the\n        desire\
    \ to keep the requirements low, it does not seem reasonable\n        to specify\
    \ such modifier box specific headers.\n   o Modifier and text string fragments\
    \ SHOULD be protected against\n     packet losses, i.e., using FEC [7], retransmission\
    \ [11], repetition\n     (Section 5), or an equivalent technique.  This minimizes\
    \ the\n     effects of packet loss.\n   o An additional requirement when fragmenting\
    \ text samples is that the\n     start of the modifiers MUST be indicated using\
    \ the payload header\n     defined for that purpose, i.e., a TYPE 3 unit MUST\
    \ be used (see\n     Section 4.1.4).  This enables a receiver to detect the start\
    \ of the\n     modifiers as long as there are not two or more consecutive packet\n\
    \     losses.\n   o Finally, sample descriptions SHALL NOT be fragmented because\
    \ they\n     contain important information that may affect several text samples.\n"
- title: 4.5.  Reassembling Text Samples at the Receiver
  contents:
  - "4.5.  Reassembling Text Samples at the Receiver\n   The payload headers defined\
    \ in this document allow reassembling\n   fragmented text samples.  For this purpose,\
    \ the standard RTP\n   timestamp, the duration field (SDUR), and the fields TOTAL/THIS\
    \ in\n   the payload headers are used.\n   Units that belong to the same text\
    \ sample MUST have the same\n   timestamp.  TYPE 5 units do not comply with this\
    \ rule since they are\n   not part of any particular text sample.\n   The process\
    \ for collecting the different fragments (units) of a text\n   sample is as follows:\n\
    \     1. Search for units having the same timestamp value, i.e., units\n     \
    \   that belong to the same text sample or sample descriptions that\n        shall\
    \ become available at that time instant.  If several units\n        of the same\
    \ sample are repeated, only one of them SHALL be used.\n        Repeated units\
    \ are those that have the same timestamp and the\n        same values for TOTAL/THIS.\n\
    \                Note that, as mentioned in Section 4.1.1, the receiver\n    \
    \            SHALL ignore units with unrecognized TYPE value.\n              \
    \  However, the RTP header fields and the rest of the units\n                (if\
    \ any) in the payload are still useful.\n     2. Check within this set whether\
    \ any of the units from the text\n        sample is missing.  This is done using\
    \ the TOTAL and THIS\n        fields; the TOTAL field indicates how many fragments\
    \ were\n        created out of the text sample, and the THIS field indicates the\n\
    \        position of this fragment in the text sample.  As result of this\n  \
    \      operation, two outcomes are possible:\n          a. No fragment is missing.\
    \  Then, the THIS field SHALL be used\n             to order the fragments and\
    \ reassemble the text sample\n             before forwarding it to the decoding\
    \ application.  Special\n             care SHALL be taken when reassembling the\
    \ text string as\n             indicated in bullet 4 below.\n          b. One\
    \ or more fragments are missing: Check whether this\n             fragment belongs\
    \ to the text string or to the modifiers.\n             TYPE 2 units identify\
    \ text string fragments, and TYPE 3 and\n             4 identify modifier fragments:\n\
    \              i. If the fragment or fragments missing belong to the text\n  \
    \               string and the modifiers were received complete, then\n      \
    \           the received text characters may, at least, be\n                 displayed\
    \ as plain text.  Some modifiers may only be\n                 applied as long\
    \ as it is possible to identify the\n                 character numbers, e.g.,\
    \ if only the last text string\n                 fragment is lost.  This is the\
    \ case for modifiers\n                 defining specific font styles ('styl'),\
    \ highlighted\n                 characters ('hlit'), karaoke feature ('krok'),\
    \ and\n                 blinking characters ('blnk').  Other modifiers such as\n\
    \                 'dlay' or 'tbox' can be applied without the knowledge\n    \
    \             of the character number.  It is an application issue to\n      \
    \           decide whether or not to apply the modifiers.\n             ii. If\
    \ the fragment missing belongs to the modifiers and\n                 the text\
    \ strings were received complete, then the\n                 incomplete modifiers\
    \ may be used.  The text string\n                 SHOULD at least be displayed\
    \ as plain text.  As\n                 mentioned in Section 4.4, modifiers may\
    \ split without\n                 observing meaningful boundaries.  Hence, it\
    \ may not\n                 always be possible to make use of partially received\n\
    \                 modifiers.  However, to avoid this, it is RECOMMENDED\n    \
    \             that the modifiers do split at meaningful boundaries.\n        \
    \    iii. A third possibility is that it is not possible to\n                \
    \ discern whether modifiers or text strings were received\n                 complete.\
    \  For example, if the TYPE 3 unit of a sample\n                 plus the following\
    \ or preceding packet is lost, there\n                 is no way for the RTP receiver\
    \ to know if one or both\n                 packets lost belong to the modifiers\
    \ or if there are\n                 also some missing text strings.  Repetition,\
    \ FEC,\n                 retransmission, or other protection mechanisms as per\n\
    \                 section 4.6 are RECOMMENDED to avoid this situation.\n     \
    \        iv. Finally, if it is sure that neither text strings nor\n          \
    \       modifiers were received complete, then the text strings\n            \
    \     and the modifiers may be rendered partially or may be\n                \
    \ discarded.  This is an application choice.\n     3. Sample descriptions can\
    \ be directly associated with the\n        reassembled text samples, via the sample\
    \ description index\n        (SIDX).\n     4. Reassembling of text strings: Since\
    \ the text strings transported\n        in RTP packets MUST NOT include any byte\
    \ order mark (BOM), the\n        receiver MUST prepend it to the reassembled UTF-16\
    \ string before\n        handling it to the timed text decoder (see Figure 9).\
    \  The value\n        of the BOM is 0xFEFF because only big endian serialization\
    \ of\n        UTF-16 strings is supported by this payload format.\n"
- title: 4.6.  On Aggregate Payloads
  contents:
  - "4.6.  On Aggregate Payloads\n   Units SHOULD be aggregated to avoid overhead,\
    \ whenever possible.  The\n   aggregate payloads MUST comply with one of the following\
    \ ordered\n   configurations:\n   1. Zero or more sample descriptions (TYPE 5)\
    \ followed by zero or more\n      whole text samples (TYPE 1 units).  At least\
    \ one unit of either\n      type MUST be present.\n   2. Zero or more sample descriptions\
    \ followed by zero or one modifier\n      fragment, either TYPE 3 or TYPE 4. \
    \ At least one unit MUST be\n      present.\n   3. Zero or more sample descriptions,\
    \ followed by zero or one text\n      string fragment (TYPE 2), followed by zero\
    \ or one TYPE 3 unit.  If\n      a TYPE 2 unit and a TYPE 3 unit are present,\
    \ then they MUST belong\n      to the same text sample.  At least one unit MUST\
    \ be present.\n   Some observations:\n   o Different aggregates than the ones\
    \ listed above SHALL NOT be used.\n   o Sample descriptions MUST be placed in\
    \ the aggregate payload before\n     the occurrence of any non-TYPE 5 units.\n\
    \   o Correct reception of TYPE 5 units is important since their contents\n  \
    \   may be referenced by several other units in the stream.\n     Receivers are\
    \ unable to use text samples until their corresponding\n     sample descriptions\
    \ are received.  Accordingly, a sender SHOULD\n     send multiple copies of a\
    \ sample description to ensure reliability\n     (see Section 5).  Receivers MAY\
    \ use payload-specific feedback\n     messages [21] to tell a sender that they\
    \ have received a particular\n     sample description.\n   o Regarding timestamp\
    \ calculation: In general, the rules for\n     calculating the timestamp of units\
    \ in an aggregate payload depend\n     on the type of unit.  Based on the possible\
    \ constellations for\n     aggregate payloads, as above, we have:\n          \
    \ o Sample descriptions MUST receive the RTP timestamp of the\n             packet\
    \ in which they are included.\n             Note that for TYPE 5 units, the timestamp\
    \ actually does not\n             represent the instant when they are played out,\
    \ but instead\n             the instant at which they become available for use.\n\
    \           o For the first configuration: The first TYPE 1 unit receives\n  \
    \           the RTP timestamp.  The timestamp of any subsequent TYPE 1\n     \
    \        unit MUST be obtained by adding sample duration and\n             timestamp,\
    \ both of the preceding TYPE 1 unit.\n           o For the second and third configuration,\
    \ all units, TYPE 2,\n             3, and 4, MUST receive the RTP timestamp.\n\
    \           Refer to detailed examples on the timestamp calculation\n        \
    \   below.\n   o As per configuration 3 above, a payload MAY contain several\n\
    \     fragments of one (and only one) text sample.  If it does, then\n     exactly\
    \ one TYPE 2 unit followed by exactly one TYPE 3 unit is\n     allowed in the\
    \ same payload.  This is in line with RFC 3640 [12],\n     Section 2.4, which\
    \ explicitly disallows combining fragments of\n     different samples in the same\
    \ RTP payload.  Note that, in this\n     special case, no timestamp calculation\
    \ is needed.  That is, the RTP\n     timestamp of both units is equal to the timestamp\
    \ in the packet's\n     RTP header.\n   o Finally, note that the use of empty\
    \ text samples allows for\n     aggregating non-consecutive TYPE 1 units in the\
    \ same payload.  Two\n     text samples, with timestamps TS1 and TS3 and durations\
    \ SDUR1 and\n     SDUR3, are not consecutive if it holds TS1+SDUR1 < TS3.  A solution\n\
    \     for this is to include an empty TYPE 1 unit with duration SDUR2\n     between\
    \ them, such that TS2+SDUR2 = TS1+SDUR1+SDUR2 = TS3.\n   Some examples of aggregate\
    \ payloads are illustrated in Figure 10.\n   (Note: The figure is not scaled.)\n\
    \      N/A    TS1   TS2     TS3\n    +------+-----+------+-----+\n    |TYPE5 |TYPE1|TYPE1\
    \ |TYPE1|\n    +------+-----+------+-----+\n      N/A   sdur1  sdur2  sdur3\n\
    \                                   N/A    TS4\n                             \
    \    +-----+-------+\n                                 |TYPE5| TYPE 1|       \
    \            a)\n                                 +-----+-------+\n          \
    \                         N/A   sdur4\n                                      \
    \  TS4         TS4    TS4\n                                 +--------------+ +--------------+\n\
    \                                 |    TYPE2     | |TYPE2 |TYPE 3 | b)\n     \
    \                            +--------------+ +--------------+\n             \
    \                          sdur4       sdur4   sdur4\n                       \
    \                 TS4             TS4\n                                 +--------------+\
    \ +--------------+\n                                 | TYPE2| TYPE 3| |     TYPE4\
    \    | c)\n                                 +--------------+ +--------------+\n\
    \                                   sdur4  sdur4        sdur4\n    |----------PAYLOAD\
    \ 1------|  |--PAYLOAD 2---| |--PAYLOAD 3---|\n               rtpts1         \
    \      rtpts2           rtpts3\n        KEY:\n        TSx    = Text Sample x\n\
    \        rtptsy = the standard RTP timestamp for PAYLOAD y\n        sdurx  = the\
    \ duration of Text Sample x\n        N/A    =  not applicable\n              \
    \    Figure 10.  Example aggregate payloads\n   In Figure 10, four text samples\
    \ (TS1 through TS4) are sent using\n   three RTP packets.  These configurations\
    \ have been chosen to show how\n   the 5 TYPE headers are used.  Additionally,\
    \ three different\n   possibilities for the last text sample, TS4, are depicted:\
    \ a), b),\n   and c).\n   In Figure 11, option b) from Figure 10 is chosen to\
    \ illustrate how\n   the timestamp for each unit is found.\n      N/A    TS1 \
    \  TS2    TS3        TS4            TS4    TS4\n    +------+-----+------+-----+\
    \  +--------------+ +--------------+\n    |TYPE5 |TYPE1|TYPE1 |TYPE1|  |    TYPE2\
    \     | |TYPE2 |TYPE 3 |\n    +------+-----+------+-----+  +--------------+ +--------------+\n\
    \      N/A   sdur1 sdur2  sdur3         sdur4       sdur4   sdur4\n     (#1) \
    \   (#2) (#3)   (#4)           (#5)        (#6)    (#7)\n    |----------PAYLOAD\
    \ 1------|  |--PAYLOAD 2---| |--PAYLOAD 3---|\n               rtpts1         \
    \      rtpts2           rtpts3\n               Figure 11.  Selected payloads from\
    \ Figure 10\n   Assuming TSx means Text Sample x, rtptsy represents the standard\
    \ RTP\n   timestamp for PAYLOAD y and sdurx, the duration of Text Sample x, the\n\
    \   timestamp for unit #z, ts(#z), can be found as the sum of rtptsy and\n   the\
    \ cumulative sum of the durations of preceding units in that\n   payload (except\
    \ in the case of PAYLOAD 3 as per rule 3 above).  Thus,\n   we have:\n       \
    \   1. for the units in the first aggregate payload, PAYLOAD 1:\n            \
    \            ts(#1) = rtpts1\n                        ts(#2) = rtpts1\n      \
    \                  ts(#3) = rtpts1 + sdur1\n                        ts(#4) = rtpts1\
    \ + sdur1 + sdur2\n           Note that the TYPE 5 and the first TYPE 1 unit have\
    \ both the\n           RTP timestamp.\n          2. for PAYLOAD 2:\n         \
    \               ts(#5) = rtpts2\n          3. for PAYLOAD 3:\n               \
    \         ts(#6) = ts(#7) = rtpsts2 = rtpts3\n           According to configuration\
    \ 3 above, the TYPE2 and the TYPE 3\n           units shall belong to the same\
    \ sample.  Hence, rtpts3 must be\n           equal to rtpts2.  For the same reason,\
    \ the value of SDUR is\n           not be used to calculate the timestamp of the\
    \ next unit.\n"
- title: 4.7.  Payload Examples
  contents:
  - "4.7.  Payload Examples\n   Some examples of payloads using the defined headers\
    \ are shown below:\n       0                   1                   2         \
    \          3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |V=2|P|X| CC    |M|    PT       |        sequence number        |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                           timestamp                           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |           synchronization source (SSRC) identifier            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |U|\
    \   R   |TYPE1|       LEN  (always >=8)       |    SIDX       |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                     SDUR                      |     TLEN      |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \    TLEN       |                                               |\n      +---------------+\
    \                                               |\n      |                  text\
    \ string (no.bytes=TLEN)                  |\n      |                         \
    \                                      |\n      |                            \
    \                                   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                   modifiers   (no.bytes=LEN - 8 - TLEN)       |\n   \
    \   |                                                               |\n      |\
    \                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |U|   R   |TYPE1|       LEN  (always >=8)       |    SIDX       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                     SDUR                      |     TLEN      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |    TLEN       |                                               |\n   \
    \   +---------------+                                               |\n      |\
    \                  text string (no.bytes=TLEN)                  |\n      |   \
    \                                                            |\n      |      \
    \                                                         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                   modifiers   (no.bytes=LEN - 8 - TLEN)       |\n   \
    \   |                                               +-+-+-+-+-+-+-+-+\n      |\
    \                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \            Figure 12.  A payload carrying two TYPE 1 units\n   In Figure 12,\
    \ an RTP packet carrying two TYPE 1 units is depicted.\n   It can be seen how\
    \ the length fields LEN and TLEN can be used to find\n   the start of the next\
    \ unit (LEN), the start of the modifiers (TLEN),\n   and the length of the modifiers\
    \ (LEN-TLEN).\n       0                   1                   2              \
    \     3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |V=2|P|X| CC    |M|    PT       |        sequence number        |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                           timestamp                           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |           synchronization source (SSRC) identifier            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |U|\
    \   R   |TYPE5|      LEN( always >3)          |   SIDX        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   |                   sample description (no.bytes=LEN - 3)       |\n      |\
    \                                                               |\n      |   \
    \                                                            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |U|   R   |TYPE1|       LEN  (always >=8)       |    SIDX       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                      SDUR                     |     TLEN      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |      TLEN     |                                               |\n   \
    \   +-+-+-+-+-+-+-+-+                                               |\n      |\
    \                  text string fragment (no.bytes=TLEN)         |\n      |   \
    \                                                            |\n      |      \
    \                                                         |\n      |         \
    \                                      +-+-+-+-+-+-+-+-+\n      |            \
    \                                   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     Figure 13.  An RTP packet carrying a TYPE 5 and a TYPE 1 unit\n   In Figure\
    \ 13, a sample description and a TYPE 1 unit are aggregated.\n   The TYPE 1 unit\
    \ happens to contain only text strings and is small, so\n   an additional TYPE\
    \ 5 unit is included to take advantage of the\n   available bits in the packet.\n\
    \       0                   1                   2                   3\n      \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |V=2|P|X| CC    |M|    PT       |        sequence number        |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                           timestamp                           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |           synchronization source (SSRC) identifier            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |U|\
    \   R   |TYPE2|          LEN( always >9)      |TOTAL=4|THIS=1 |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                    SDUR                       |    SIDX       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \               SLEN            |                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               |\n      |                  text string fragment\
    \ (no.bytes=LEN - 9)      |\n      |                                         \
    \                      |\n      :                                            \
    \                   :\n      :                                               \
    \                :\n      |                                               +-+-+-+-+-+-+-+-+\n\
    \      |                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    Figure 14.  Payload with first text string fragment of a sample\n   In Figures\
    \ 14, 15, and 16, a text sample is split into three RTP\n   packets.  In Figure\
    \ 14, the text string is big and takes the whole\n   packet length.  In Figure\
    \ 15, the only possibility for carrying two\n   fragments of the same text sample\
    \ is represented (see configuration 3\n   in Section 4.6).  The last packet, shown\
    \ in Figure 16, carries the\n   last modifier fragment, a TYPE 4.\n       0  \
    \                 1                   2                   3\n       0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |V=2|P|X| CC    |M|    PT       |        sequence number        |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                           timestamp                           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |           synchronization source (SSRC) identifier            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |U|\
    \   R   |TYPE2|          LEN( always >9)      |TOTAL=4|THIS=2 |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                    SDUR                       |    SIDX       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \               SLEN            |                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               |\n      |                  text string fragment\
    \ (no.bytes=LEN - 9)      |\n      |                                         \
    \                      |\n      |                                            \
    \                   |\n      |                                               \
    \                |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |U|   R   |TYPE3|        LEN( always >6)        |TOTAL=4|THIS=3 |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                      SDUR                     |               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \               |\n      |                                                   \
    \            |\n      |                    modifiers (no.bytes=LEN - 6)      \
    \         |\n      |                                               +-+-+-+-+-+-+-+-+\n\
    \      |                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Figure 15.  An RTP packet carrying a TYPE 2 unit and a TYPE 3 unit\n  \
    \     0                   1                   2                   3\n       0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |V=2|P|X| CC    |M|    PT       |        sequence number        |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                           timestamp                           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |           synchronization source (SSRC) identifier            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |U|\
    \   R   |TYPE4|        LEN( always >6)        |TOTAL=4|THIS=4 |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                      SDUR                     |               |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |\n      |\
    \                                                               |\n      |   \
    \                 modifiers (no.bytes=LEN - 6)               |\n      |      \
    \                                         +-+-+-+-+-+-+-+-+\n      |         \
    \                                      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     Figure 16.  An RTP packet carrying last modifiers fragment (TYPE 4)\n"
- title: 4.8.  Relation to RFC 3640
  contents:
  - "4.8.  Relation to RFC 3640\n   RFC 3640 [12] defines a payload format for the\
    \ transport of any non-\n   multiplexed MPEG-4 elementary stream.  One of the\
    \ various MPEG-4\n   elementary stream types is MPEG-4 timed text streams, specified\
    \ in\n   MPEG-4 part 17 [26], also known as ISO/IEC 14496-17.  MPEG-4 timed\n\
    \   text streams are capable of carrying 3GPP timed text data, as\n   specified\
    \ in 3GPP TS 26.245 [1].\n   MPEG-4 timed text streams are intentionally constructed\
    \ so as to\n   guarantee interoperability between RFC 3640 and this payload format.\n\
    \   This means that the construction of the RTP packets carrying timed\n   text\
    \ is the same.  That is, the MPEG-4 timed text elementary stream\n   as per ISO/IEC\
    \ 14496-17 is identical to the (aggregate) payloads\n   constructed using this\
    \ payload format.\n   Figure 17 illustrates the process of constructing an RTP\
    \ packet\n   containing timed text.  As can be seen in the partition block, the\n\
    \   (transport) units used in this payload format are identical to the\n   Timed\
    \ Text Units (TTUs) defined in ISO/IEC 14496-17.  Likewise, the\n   rules for\
    \ payload aggregation as per Section 4.6 are identical to\n   those defined in\
    \ ISO/IEC 14496-17 and are compliant with RFC 3640.\n   As a result, an RTP packet\
    \ that uses this payload format is identical\n   to an RTP packet using RFC 3640\
    \ conveying TTUs according to ISO/IEC\n   14496-17.  In particular, MPEG-4 Part\
    \ 17 specifies that when using\n   RFC 3640 for transporting timed text streams,\
    \ the \"streamType\"\n   parameter value is set to 0x0D, and the value of the\n\
    \   \"objectTypeIndication\" in \"config\" takes the value 0x08.\n           \
    \     +--------------------------------------+\n   Text samples | +--------------+\
    \   +--------------+  |\n   as per 3GPP  | |Text Sample 1 |   |Text Sample N |\
    \  |\n   TS 26245     | +--------------+   +--------------+  |\n             \
    \   +--------------------------------------+\n                               \
    \   \\/\n   +-------------------------------------------------------------------+\n\
    \   | Partition Text Samples into units.  TTU[i]= TYPE i units.         |\n  \
    \ |                                                                   |\n   |[U\
    \ R TYPE LEN][{TOTAL,THIS}SIDX{SDUR}{TLEN}{SLEN}][SampleContents] |\n   |{..}\
    \ means present if applicable, [..] means always present        |\n   +-------------------------------------------------------------------+\n\
    \                   \\/                                \\/\n   +-------------------------------------------------------------------+\n\
    \   |                      Aggregation (if possible)                    |\n  \
    \ +-------------------------------------------------------------------+\n    \
    \               \\/                                \\/\n   +-------------------------------------------------------------------+\n\
    \   | RTP Entity adds and fills RTP header and Sends RTP packet, where  |\n  \
    \ |  RTP packets according to this Payload Format =                   |\n   |\
    \  RTP packets carrying MPEG-4 Timed Text ES over RFC 3640          |\n   +-------------------------------------------------------------------+\n\
    \                     Figure 17.  Relation to RFC 3640\n   Note: The use of RFC\
    \ 3640 for transport of ISO/IEC 14496-17 data does\n   not require any new SDP\
    \ parameters or any new mode definition.\n"
- title: 4.9.  Relation to RFC 2793
  contents:
  - "4.9.  Relation to RFC 2793\n   RFC 2793 [22] and its revision, RFC 4103 [23],\
    \ specify a protocol for\n   enabling text conversation.  Typical applications\
    \ of this payload\n   format are text communication terminals and text conferencing\
    \ tools.\n   Text session contents are specified in ITU-T Recommendation T.140\n\
    \   [24].  T.140 text is UTF-8 coded as specified in T.140 [24] with no\n   extra\
    \ framing.  The T140block contains one or more T.140 code\n   elements as specified\
    \ in T.140.  Code elements are control sequences\n   such as \"New Line\", \"\
    Interrupt\", \"String Terminator\", or \"Start of\n   String\".  Most T.140 code\
    \ elements are single ISO 10646 [25]\n   characters, but some are multiple character\
    \ sequences.  Each\n   character is UTF-8 encoded [18] into one or more octets.\n\
    \   This payload format may also be used for conversational applications\n   (even\
    \ for instant messaging).  However, this is not its main target.\n   The differentiating\
    \ feature of 3GPP Timed Text media format is that\n   it allows text decoration.\
    \  This is especially useful in multimedia\n   presentations, karaoke, commercial\
    \ banners, news tickers, clickable\n   text strings, and captions.  T.140 text\
    \ contents used in RFC 2793 do\n   not allow the use of text decoration.\n   Furthermore,\
    \ the conversational text RTP payload format recommends a\n   method to include\
    \ redundant text from already transmitted packets in\n   order to reduce the risk\
    \ of text loss caused by packet loss.  Thereby\n   payloads would include a redundant\
    \ copy of the last payload sent.\n   This payload format does not describe such\
    \ a method, but this is also\n   applicable here.  As explained in Section 5,\
    \ packet redundancy SHOULD\n   be used, whenever possible.  The aggregation guidelines\
    \ in Section\n   4.6 allow redundant payloads.\n"
- title: 5.  Resilient Transport
  contents:
  - "5.  Resilient Transport\n   Apart from the basic fragmentation guidelines described\
    \ in the\n   section above, the simplest option for packet-loss-resilient\n  \
    \ transport is packet repetition.  This mechanism may consist of a\n   strict\
    \ window-based repetition mechanism or, simply, a repetition\n   mechanism in\
    \ a wider sense, where new and old packets are mixed, for\n   example.\n   A server\
    \ MAY decide to use repetition as a measure for packet loss\n   resilience.  Thereby,\
    \ a server MAY send the same RTP payloads or just\n   some of the units from the\
    \ payloads.\n   As for the case of complete payloads, single repeated units MUST\n\
    \   exactly match the same units sent in the first transmission; i.e., if\n  \
    \ fragmentation is needed, it SHALL be performed only once for each\n   text sample.\
    \  Only then, a receiver can use the already received and\n   the repeated units\
    \ to reconstruct the original text samples.  Since\n   the RTP timestamp is used\
    \ to group together the fragments of a\n   sample, care must taken to preserve\
    \ the timing of units when\n   constructing new RTP packets.\n        For example,\
    \ if a text sample was originally sent as a single\n        non-fragmented text\
    \ sample (one TYPE 1 unit), a repetition of\n        that sample MUST be sent\
    \ also as a single non-fragmented text\n        sample in one unit.  Likewise,\
    \ if the original text sample was\n        fragmented and spread over several\
    \ RTP packets (say, a total of\n        3 units), then the repeated fragments\
    \ SHALL also have the same\n        byte boundaries and use the same unit headers\
    \ and bytes per\n        fragment.\n   With repetition, repeated units resolve\
    \ to the same timestamp as\n   their originals.  Where redundant units are available,\
    \ only one of\n   them SHALL be used.\n   Regarding the RTP header fields:\n \
    \  o If the whole RTP payload is repeated, all payload-specific fields\n     in\
    \ the RTP header (the M, TS and PT fields) MUST keep their\n     original values\
    \ except the sequence number, which MUST be\n     incremented to comply with RTP\
    \ (the fields TOTAL/THIS enable to\n     re-assemble fragments with different\
    \ sequence numbers).\n   o In packets containing single repeated units, the general\
    \ rules in\n     Section 3 for assigning values to the RTP header fields apply.\n\
    \     Keeping the value of the RTP timestamp to preserve the timing of\n     the\
    \ units is particularly relevant here.\n   Apart from repetition, other mechanisms\
    \ such as FEC [7],\n   retransmission [11], or similar techniques could be used\
    \ to cope with\n   packet losses.\n"
- title: 6.  Congestion Control
  contents:
  - "6.  Congestion Control\n   Congestion control for RTP SHALL be implemented in\
    \ accordance with\n   RTP [3] and the applicable RTP profile, e.g., RTP/AVP [17].\n\
    \   When using this payload format, mainly two factors may affect the\n   congestion\
    \ control:\n   o The use of (unit) aggregation may make the payload format more\n\
    \     bandwidth efficient, by avoiding header overhead and thus reducing\n   \
    \  the used bitrate.\n   o The use of resilient transport mechanisms: Although\
    \ timed text\n     applications typically operate at low bitrates, the increase\
    \ due to\n     resilient transport shall be considered for congestion control\n\
    \     mechanisms.  This applies to all mechanisms but especially to less\n   \
    \  efficient ones like repetition.\n"
- title: 7.  Scene Description
  contents:
  - '7.  Scene Description

    '
- title: 7.1.  Text Rendering Position and Composition
  contents:
  - "7.1.  Text Rendering Position and Composition\n   In order to set up a timed\
    \ text session, regardless of the stream\n   being stored in a 3GP file or streamed\
    \ live, some initial layout\n   information is needed by the communicating peers.\n\
    \      +-------------------------------------------+\n      |      <-> tx    \
    \                           |    +-------------+\n      |     +-------------------------------+\
    \     |<---|Display Area |\n      |  ^  |                               |    \
    \ |    +-------------+\n      |  :  |                               |     |\n\
    \      |  :ty|                               |     |    +-------------+\n    \
    \  |  :  |                               |<---------|Video track  |\n      | \
    \ :  |                               |     |    +-------------+\n      |  :  |\
    \                               |     |\n      |  :  |                       \
    \        |     |\n      |  :  |                               |     |\n      |\
    \  v  |                               |     |\n      |  -  |   x-------------------------+\
    \ |     |    +-------------+\n      |h ^  |   |                         |<-----------|Text\
    \ Track   |\n      |e :  +---|-------------------------|-+     |    +-------------+\n\
    \      |i :      | +---------------------+ |       |\n      |g :      | |    \
    \                 | |       |    +-------------+\n      |h :      | |        \
    \             |<------------ |Text Box     |\n      |t v      | +---------------------+\
    \ |       |    +-------------+\n      |  -      +-------------------------+  \
    \     |\n      +-------------------------------------------+\n               \
    \ <........................>\n                        w i d t h\n   Figure 18.\
    \  Illustration of text rendering position and composition\n   The parameters\
    \ used for negotiating the position and size of the text\n   track in the display\
    \ area are shown in Figure 18.  These are the\n   \"width\" and \"height\" of\
    \ the text track, its translation values, \"tx\"\n   and \"ty\", and its \"layer\"\
    \ or proximity to the user.\n   At the same time, the sender of the stream needs\
    \ to know the\n   receiver's capabilities.  In this case, the maximum allowable\
    \ values\n   for the text track height and width: \"max-h\" and \"max-w\", for\
    \ the\n   stream the receiver shall display.\n   This layout information MUST\
    \ be conveyed in a reliable form before\n   the start of the session, e.g., during\
    \ session announcement or in an\n   Offer/Answer (O/A) exchange.  An example of\
    \ a reliable transport may\n   be the out-of-band channel used for SDP.  Sections\
    \ 8 and 9 provide\n   details on the mapping of these parameters to SDP descriptions\
    \ and\n   their usage in O/A.\n   For stored content, the layout values expressing\
    \ stream properties\n   MUST be obtained from the Track Header Box.  See Section\
    \ 7.3.\n   For live streaming, appropriate values as negotiated during session\n\
    \   setup shall be used.\n"
- title: 7.2.  SMIL Usage
  contents:
  - "7.2.  SMIL Usage\n   The attributes contained in the Track Header Boxes of a\
    \ 3GP file only\n   specify the spatial relationship of the tracks within the\
    \ given 3GP\n   file.\n   If multiple 3GP files are sent, they require spatial\
    \ synchronization.\n   For example, for a text and video stream, the positions\
    \ of the text\n   and video tracks in Figure 18 shall be determined.  For this\
    \ purpose,\n   SMIL [9] MAY be used.\n   SMIL assigns regions in the display to\
    \ each of those files and places\n   the tracks within those regions.  Generally,\
    \ in SMIL, the position of\n   one track (or stream) is expressed relative to\
    \ another track.  This\n   is different from the 3GP file, where the upper left\
    \ corner is the\n   reference for all translation offsets.  Hence, only if the\
    \ position\n   in SMIL is relative to the video track origin, then this translation\n\
    \   offset has the same value as (tx, ty) in the 3GP file.\n   Note also that\
    \ the original track header information is used for each\n   track only within\
    \ its region, as assigned by SMIL.  Therefore, even\n   if SMIL scene description\
    \ is used, the track header information\n   pieces SHOULD be sent anyway, as they\
    \ represent the intrinsic media\n   properties.  See 3GPP SMIL Language Profile\
    \ in [27] for details.\n"
- title: 7.3.  Finding Layout Values in a 3GP File
  contents:
  - "7.3.  Finding Layout Values in a 3GP File\n   In a 3GP file, within the Track\
    \ Header Box (tkhd):\n        o tx, ty: These values specify the translation offset\
    \ of the\n          (text) track relative to the upper left corner of the video\n\
    \          track, if present.  They are the second but last and third but\n  \
    \        last values in the unity matrix; values are fixed-point 16.16\n     \
    \     values, restricted to be (signed) integers (i.e., the lower 16\n       \
    \   bits of each value shall be all zeros).  Therefore, only the\n          first\
    \ 16 bits are used for obtaining the value of the media\n          type parameters.\n\
    \        o width, height: They have the same name in the tkhd box.  All\n    \
    \      (unsigned) 32 bits are meaningful.\n        o layer: All (signed) 16 bits\
    \ are used.\n"
- title: 8.  3GPP Timed Text Media Type
  contents:
  - "8.  3GPP Timed Text Media Type\n   The media subtype for the 3GPP Timed Text\
    \ codec is allocated from the\n   standards tree.  The top-level media type under\
    \ which this payload\n   format is registered is 'video'.  This registration is\
    \ done using the\n   template defined in [29] and following RFC 3555 [28].\n \
    \  The receiver MUST ignore any unrecognized parameter.\n   Media type: video\n\
    \   Media subtype: 3gpp-tt\n   Required parameters\n        rate:\n          \
    \      Refer to Section 3 in RFC 4396.\n        sver:\n                The parameter\
    \ \"sver\" contains a list of supported\n                backwards-compatible\
    \ versions of the timed text format\n                specification (3GPP TS 26.245)\
    \ that the sender accepts\n                to receive (and that are the same that\
    \ it would be\n                willing to send).  The first value is the value\n\
    \                preferred to receive (or preferred to send).  The first\n   \
    \             value MAY be followed by a comma-separated list of\n           \
    \     versions that SHOULD be used as alternatives.  The order\n             \
    \   is meaningful, being first the most preferred and last\n                the\
    \ least preferred.  Each entry has the format\n                Zi(xi*256+yi),\
    \ where \"Zi\" is the number of the Release\n                and \"xi\" and \"\
    yi\" are taken from the 3GPP specification\n                version (i.e., vZi.xi.yi).\
    \  For example, for 3GPP TS\n                26.245 v6.0.0, Zi(xi*256+yi)=6(0),\
    \ the version value is\n                \"60\".  (Note that \"60\" is the concatenation\
    \ of the\n                values Zi=6 and (xi*256+yi)=0 and not their product.)\n\
    \                If no \"sver\" value is available, for example, when\n      \
    \          streaming out of a 3GP file, the default value \"60\",\n          \
    \      corresponding to the 3GPP Release 6 version of 3GPP TS\n              \
    \  26.245, SHALL be used.\n   Optional parameters:\n        tx:\n            \
    \    This parameter indicates the horizontal translation\n                offset\
    \ in pixels of the text track with respect to the\n                origin of the\
    \ video track.  This value is the decimal\n                representation of a\
    \ 16-bit signed integer.  Refer to TS\n                3GPP 26.245 for an illustration\
    \ of this parameter.\n        ty:\n                This parameter indicates the\
    \ vertical translation offset\n                in pixels of the text track with\
    \ respect to the origin\n                of the video track.  This value is the\
    \ decimal\n                representation of a 16-bit signed integer.  Refer to\
    \ TS\n                3GPP 26.245 for an illustration of this parameter.\n   \
    \     layer:\n                This parameter indicates the proximity of the text\
    \ track\n                to the viewer.  More negative values mean closer to the\n\
    \                viewer.  This parameter has no units.  This value is the\n  \
    \              decimal representation of a 16-bit signed integer.\n        tx3g:\n\
    \                This parameter MUST be used for conveying sample\n          \
    \      descriptions out-of-band.  It contains a comma-separated\n            \
    \    list of base64-encoded entries.  The entries of this\n                list\
    \ MAY follow any particular order and the list SHALL\n                NOT be empty.\
    \  Each entry is the result of running\n                base64 encoding over the\
    \ concatenation of the (static)\n                SIDX value as an 8-bit unsigned\
    \ integer and the (static)\n                sample description for that SIDX,\
    \ in that order.  The\n                format of a sample description entry can\
    \ be found in\n                3GPP TS 26.245 Release 6 and later releases.  All\n\
    \                servers and clients MUST understand this parameter and\n    \
    \            MUST be capable of using the sample description(s)\n            \
    \    contained in it.  Please refer to RFC 3548 [6] for\n                details\
    \ on the base64 encoding.\n        width:\n                This parameter indicates\
    \ the width in pixels of the text\n                track or area of the text being\
    \ sent.  This value is the\n                decimal representation of a 32-bit\
    \ unsigned integer.\n                Refer to TS 3GPP 26.245 for an illustration\
    \ of this\n                parameter.\n        height:\n                This parameter\
    \ indicates the height in pixels of the\n                text track being sent.\
    \  This value is the decimal\n                representation of a 32-bit unsigned\
    \ integer.  Refer to\n                TS 3GPP 26.245 for an illustration of this\
    \ parameter.\n        max-w:\n                This parameter indicates display\
    \ capabilities.  This is\n                the maximum \"width\" value that the\
    \ sender of this\n                parameter supports.  This value is the decimal\n\
    \                representation of a 32-bit unsigned integer.\n        max-h:\n\
    \                This parameter indicates display capabilities.  This is\n   \
    \             the maximum \"height\" value that the sender of this\n         \
    \       parameter supports.  This value is the decimal\n                representation\
    \ of a 32-bit unsigned integer.\n   Encoding considerations:\n        This media\
    \ type is framed (see Section 4.8 in [29]) and\n        partially contains binary\
    \ data.\n   Restrictions on usage:\n        This media type depends on RTP framing,\
    \ and hence is only\n        defined for transfer via RTP [3].  Transport within\
    \ other\n        framing protocols is not defined at this time.\n   Security considerations:\n\
    \        Please refer to Section 11 of RFC 4396.\n   Interoperability considerations:\n\
    \        The 3GPP Timed Text media format and its file storage is\n        specified\
    \ in Release 6 of 3GPP TS 26.245, \"Transparent end-to-\n        end packet switched\
    \ streaming service (PSS); Timed Text Format\n        (Release 6)\".  Note also\
    \ that 3GPP may in future releases\n        specify extensions or updates to the\
    \ timed text media format in\n        a backwards-compatible way, e.g., new modifier\
    \ boxes or\n        extensions to the sample descriptions.  The payload format\n\
    \        defined in RFC 4396 allows for such extensions.  For future 3GPP\n  \
    \      Releases of the Timed Text Format, the parameter \"sver\" is used\n   \
    \     to identify the exact specification used.\n        The defined storage format\
    \ for 3GPP Timed Text format is the\n        3GPP File Format (3GP) [30]. 3GP\
    \ files may be transferred using\n        the media type video/3gpp as registered\
    \ by RFC 3839 [31].  The\n        3GPP File Format is a container file that may\
    \ contain, e.g.,\n        audio and video that may be synchronized with the 3GPP\
    \ Timed\n        Text.\n   Published specification: RFC 4396\n   Applications\
    \ which use this media type:\n        Multimedia streaming applications.\n   Additional\
    \ information:\n        The 3GPP Timed Text media format is specified in 3GPP\
    \ TS 26.245,\n        \"Transparent end-to-end packet switched streaming service\
    \ (PSS);\n        Timed Text Format (Release 6)\".  This document and future\n\
    \        extensions to the 3GPP Timed Text format are publicly available\n   \
    \     at http://www.3gpp.org.\n        Magic number(s): None.\n        File extension(s):\
    \ None.\n        Macintosh File Type Code(s): None.\n   Person & email address\
    \ to contact for further information:\n        Jose Rey, jose.rey@eu.panasonic.com\n\
    \        Yoshinori Matsui, matsui.yoshinori@jp.panasonic.com\n        Audio/Video\
    \ Transport Working Group.\n   Intended usage: COMMON\n   Authors:\n        Jose\
    \ Rey\n        Yoshinori Matsui\n   Change controller: IETF Audio/Video Transport\
    \ Working Group delegated\n        from the IESG.\n"
- title: 9.  SDP Usage
  contents:
  - '9.  SDP Usage

    '
- title: 9.1.  Mapping to SDP
  contents:
  - "9.1.  Mapping to SDP\n   The information carried in the media type specification\
    \ has a\n   specific mapping to fields in SDP [4].  If SDP is used to specify\n\
    \   sessions using this payload format, the mapping is done as follows:\n   o\
    \ The media type (\"video\") goes in the SDP \"m=\" as the media name.\n     \
    \  m=video <port number> RTP/<RTP profile> <dynamic payload type>\n   o The media\
    \ subtype (\"3gpp-tt\") and the timestamp clockrate \"rate\"\n     (the RECOMMENDED\
    \ 1000 Hz or other value) go in SDP \"a=rtpmap\" line\n     as the encoding name\
    \ and rate, respectively:\n       a=rtpmap:<payload type> 3gpp-tt/1000\n   o The\
    \ REQUIRED parameter \"sver\" goes in the SDP \"a=fmtp\" attribute by\n     copying\
    \ it directly from the media type string as a semicolon-\n     separated parameter=value\
    \ pair.\n   o The OPTIONAL parameters \"tx\", \"ty\", \"layer\", \"tx3g\", \"\
    width\",\n     \"height\", \"max-w\" and \"max-h\" go in the SDP \"a=fmtp\" attribute\
    \ by\n     copying them directly from the media type string as a semicolon\n \
    \    separated list of parameter=value(s) pairs:\n       a=fmtp:<dynamic payload\
    \ type> <parameter\n       name>=<value>[,<value>][; <parameter name>=<value>]\n\
    \   o   Any parameter unknown to the device that uses the SDP SHALL be\n     \
    \  ignored.  For example, parameters added to the media format in\n       later\
    \ specifications MAY be copied into the SDP and SHALL be\n       ignored by receivers\
    \ that do not understand them.\n"
- title: 9.2.  Parameter Usage in the SDP Offer/Answer Model
  contents:
  - "9.2.  Parameter Usage in the SDP Offer/Answer Model\n   In this section, the\
    \ meaning of the SDP parameters defined in this\n   document within the Offer/Answer\
    \ [13] context is explained.\n   In unicast, sender and receiver typically negotiate\
    \ the streams,\n   i.e., which codecs and parameter values are used in the session.\n\
    \   This is also possible in multicast to a lesser extent.\n   Additionally, the\
    \ meaning of the parameters MAY vary depending on\n   which direction is used.\
    \  In the following sections, a\n   \"<directionality> offer\" means an offer\
    \ that contains a stream set to\n   <directionality>.  <directionality> may take\
    \ the values sendrecv,\n   sendonly, and recvonly.  Similar considerations apply\
    \ for answers.\n   For example, an answer to a sendonly offer is a recvonly answer.\n"
- title: 9.2.1. Unicast Usage
  contents:
  - "9.2.1. Unicast Usage\n   The following types of parameters are used in this payload\
    \ format:\n     1. Declarative parameters: Offerer and answerer declare the values\n\
    \        they will use for the incoming (sendrecv/recvonly) or outgoing\n    \
    \    (sendonly) stream.  Offerer and answerer MAY use different\n        values.\n\
    \          a. \"tx\", \"ty\", and \"layer\": These are parameters describing\n\
    \             where the received text track is placed.  Depending on the\n   \
    \          directionality:\n              i. They MUST appear in all sendrecv\
    \ offers and answers and\n                 in all recvonly offers and answers\
    \ (thus applying to\n                 the incoming stream).  In the case of sendrecv\
    \ offers\n                 and answers and in recvonly offers, these values SHOULD\n\
    \                 be used by the sender of the stream unless it has a\n      \
    \           particular preference, in which case, it MUST make sure\n        \
    \         that these different values do not corrupt the\n                 presentation.\
    \  For recvonly answers, the answerer MAY\n                 accept the proposed\
    \ values for the incoming stream (in\n                 a sendonly offer; see ii.\
    \ below) or respond with\n                 different ones.  The offerer MUST use\
    \ the returned\n                 values.\n             ii. They MAY appear in\
    \ sendonly offers and MUST appear in\n                 sendonly answers.  In sendonly\
    \ offers, they specify the\n                 values that the offerer proposes\
    \ for sending (see\n                 example in Section 9.3).  In sendonly answers,\
    \ these\n                 values SHOULD be copied from the corresponding recvonly\n\
    \                 offer upon accepting the stream, unless a particular\n     \
    \            preference by the receiver of the stream exists, as\n           \
    \      explained in the previous point.\n     2. Parameters describing the display\
    \ capabilities, \"max-h\" and\n        \"max-w\", which indicate the maximum dimensions\
    \ of the text track\n        (text display area) for the incoming stream \"tx\"\
    \ and \"ty\" values\n        (see Figure 18).  \"max-h\" and \"max-w\" MUST be\
    \ included in all\n        offers and answers where \"tx\" and \"ty\" refer to\
    \ the incoming\n        stream, thus excluding sendonly offers and answers (see\
    \ example\n        in Section 9.3), where they SHALL NOT be present.\n     3.\
    \ Parameters describing the sent stream properties, i.e., the\n        sender\
    \ of the stream decides upon the values of these:\n          a. \"width\" and\
    \ \"height\" specify the text track dimensions.\n             They SHALL ALWAYS\
    \ be present in sendrecv and sendonly\n             offers and answers.  For recvonly\
    \ answers, the answerer\n             MUST include the offered parameter values\
    \ (if any) verbatim\n             in the answer upon accepting the stream.\n \
    \         b. \"tx3g\" contains static sample descriptions.  It MAY only be\n \
    \            present in sendrecv and sendonly offers and answers.  This\n    \
    \         parameter applies to the stream that offerers or answerers\n       \
    \      send.\n     4. Negotiable parameters, which MUST be agreed on.  This is\
    \ the\n        case of \"sver\".  This parameter MUST be present in every offer\n\
    \        and answer.  The answerer SHALL choose one supported value from\n   \
    \     the offerer's list, or else it MUST remove the stream or reject\n      \
    \  the session.\n     5. Symmetric parameters: \"rate\", timestamp clockrate,\
    \ belongs to\n        this class.  Symmetric parameters MUST be echoed verbatim\
    \ in the\n        answer.  Otherwise, the stream MUST be removed or the session\n\
    \        rejected.\n   The following table summarizes all options:\n     +..---------------------------+----------+----------+----------+\n\
    \     |   ``--..__  Directionality/ | sendrecv | recvonly | sendonly |\n     +\
    \ Type of   ``--..__   O or A +----------+----------+----------+\n     |    Parameter\
    \      ``--..__  |   O/A    |   O/A    |   O/A    |\n     +--------------+------------``+----------+----------+----------+\n\
    \     | Declarative  |tx, ty, layer |   M/M    |   M/M    |   m/M    |\n     |\
    \              |              |          |          |          |\n     +--------------+--------------+----------+----------+----------+\n\
    \     | Display      |max-h, max-w  |   M/M    |   M/M    |   -/-    |\n     |\
    \ Capabilities |              |          |          |          |\n     +--------------+--------------+----------+----------+----------+\n\
    \     | Stream       |height, width |   M/M    |   -/(M)  |   M/M    |\n     |\
    \ properties   |tx3g          |   m/m    |   -/-    |   m/m    |\n     |     \
    \         |              |          |          |          |\n     +--------------+--------------+----------+----------+----------+\n\
    \     |  Negotiable  |sver          |   M/M    |   M/M    |   M/M    |\n     |\
    \              |              |          |          |          |\n     +--------------+--------------+----------+----------+----------+\n\
    \     |  Symmetric   |rate          |   M/M    |   M/M    |   M/M    |\n     +--------------+--------------+----------+----------+----------+\n\
    \          Table 1.  Parameter usage in Unicast Offer / Answer.\n   KEY:\n   \
    \     o M means MUST be present.\n        o m means MAY be present (such as proposed\
    \ values).\n        o (M) or (m) means MUST or MAY, if applicable.\n        o\
    \ a hyphen (\"-\") means the parameter MUST NOT be present.\n   Other observations\
    \ regarding parameter usage:\n     o Translation and transparency values: In sendonly\
    \ offers, \"tx\",\n       \"ty\", and \"layer\" indicate proposed values.  This\
    \ is useful for\n       visually composed sessions where the different streams\
    \ occupy\n       different parts of the display, e.g., a video stream and the\n\
    \       captions.  These are just suggested values; the peer rendering\n     \
    \  the text ultimately decides where to place the text track.\n     o Text track\
    \ (area) dimensions, \"height\" and \"width\": In the case\n       of sendonly\
    \ offers, an answerer accepting the offer MUST be\n       prepared to render the\
    \ stream using these values.  If any of\n       these conditions are not met,\
    \ the stream MUST be removed or the\n       session rejected.\n     o Display\
    \ capabilities, \"max-h\" and \"max-w\": An answerer sending a\n       stream\
    \ SHALL ensure that the \"height\" and \"width\" values in the\n       answer\
    \ are compatible with the offerer's signaled capabilities.\n     o Version handling\
    \ via \"sver\": The idea is that offerer and\n       answerer communicate using\
    \ the same version.  This is achieved by\n       letting the answerer choose from\
    \ a list of supported versions,\n       \"sver\".  For recvonly streams, the first\
    \ value in the list is the\n       preferred version to receive.  Consequently,\
    \ for sendonly (and\n       sendrecv) streams, the first value is the one preferred\
    \ for\n       sending (and receiving).  The answerer MUST choose one value and\n\
    \       return it in the answer.  Upon receiving the answer, the offerer\n   \
    \    SHALL be prepared to send (sendonly and sendrecv) and receive\n       (recvonly\
    \ and sendrecv) a stream using that version.  If none of\n       the versions\
    \ in the list is supported, the stream MUST be removed\n       or the session\
    \ rejected.  Note that, if alternative non-\n       compatible versions are offered,\
    \ then this SHALL be done using\n       different payload types.\n"
- title: 9.2.2.  Multicast Usage
  contents:
  - "9.2.2.  Multicast Usage\n   In multicast, the parameter usage is similar to the\
    \ unicast case,\n   except as follows:\n   o the parameters \"tx\", \"ty\", and\
    \ \"layer\" in multicast offers only\n     have meaning for sendrecv and recvonly\
    \ streams.  In order for all\n     clients to have the same vision of the session,\
    \ they MUST be used\n     symmetrically.\n   o for \"height\", \"width\", and\
    \ \"tx3g\" (for sendrecv and sendonly),\n     multicast offers specify which values\
    \ of these parameters the\n     participants MUST use for sending.  Thus, if the\
    \ stream is\n     accepted, the answerer MUST also include them verbatim in the\n\
    \     answer (also \"tx3g\", if present).\n   o The capability parameters, \"\
    max-h\" and \"max-w\", SHALL NOT be used\n     in multicast.  If the offered text\
    \ track should change in size, a\n     new offer SHALL be used instead.\n   o\
    \ Regarding version handling:\n     In the case of multicast offers, an answerer\
    \ MAY accept a multicast\n     offer as long as one of the versions listed in\
    \ the \"sver\" is\n     supported.  Therefore, if the stream is accepted, the\
    \ answerer MUST\n     choose its preferred version, but, unlike in unicast, the\
    \ offerer\n     SHALL NOT change the offered stream to this chosen version because\n\
    \     there may be other session participants that do support the newer\n    \
    \ extensions.  Consequently, different session participants may end\n     up using\
    \ different backwards-compatible media format versions.  It\n     is RECOMMENDED\
    \ that the multicast offer contains a limited number\n     of versions, in order\
    \ for all participants to have the same view of\n     the session.  This is a\
    \ responsibility of the session creator.  If\n     none of the offered versions\
    \ is supported, the stream SHALL be\n     removed or the session rejected.  Also\
    \ in this case, if alternative\n     non-compatible versions are offered, then\
    \ this SHALL be done using\n     different payload types.\n"
- title: 9.3.  Offer/Answer Examples
  contents:
  - "9.3.  Offer/Answer Examples\n   In these unicast O/A examples, the long lines\
    \ are wrapped around.\n   Static sample descriptions are shortened for clarity.\n\
    \   For sendrecv:\n   O -> A\n   m=video <port> RTP/AVP 98\n   a=rtpmap:98 3gpp-tt/1000\n\
    \   a=fmtp:98 tx=100; ty=100; layer=0; height=80; width=100; max-h=120;\n   max-w=160;\
    \ sver=6256,60; tx3g=81...\n   a=sendrecv\n   A -> O\n   m=video <port> RTP/AVP\
    \ 98..\n   a=rtpmap:98 3gpp-tt/1000\n   a=fmtp:98 tx=100; ty=95; layer=0; height=90;\
    \ width=100; max-h=100;\n   max-w=160; sver=60; tx3g=82...\n   a=sendrecv\n  \
    \ In this example, the offerer is telling the answerer where it will\n   place\
    \ the received stream and what is the maximum height and width\n   allowable for\
    \ the stream that it will receive.  Also, it tells the\n   answerer the dimensions\
    \ of the text track for the stream sent and\n   which sample description it shall\
    \ use.  It offers two versions, 6256\n   and 60.  The answerer responds with an\
    \ equivalent set of parameters\n   for the stream it receives.  In this case,\
    \ the answerer's \"max-h\" and\n   \"max-w\" are compatible with the offerer's\
    \ \"height\" and \"width\".\n   Otherwise, the answerer would have to remove this\
    \ stream, and the\n   offerer would have to issue a new offer taking the answerer's\n\
    \   capabilities into account.  This is possible only if multiple payload\n  \
    \ types are present in the initial offer so that at least one of them\n   matches\
    \ the answerer's capabilities as expressed by \"max-h\" and\n   \"max-w\" in the\
    \ negative answer.  Note also that the answerer's text\n   box dimensions fit\
    \ within the maximum values signaled in the offer.\n   Finally, the answerer chooses\
    \ to use version 60 of the timed text\n   format.\n   For recvonly:\n   Offerer\
    \ -> Answerer\n   m=video <port> RTP/AVP 98\n   a=rtpmap:98 3gpp-tt/1000\n   a=fmtp:98\
    \ tx=100; ty=100; layer=0; max-h=120; max-w=160; sver=6256,60\n   a=recvonly\n\
    \   A -> O\n   m=video <port> RTP/AVP 98..\n   a=rtpmap:98 3gpp-tt/1000\n   a=fmtp:98\
    \ tx=100; ty=100; layer=0; height=90; width=100; sver=60;\n   tx3g=82...\n   a=sendonly\n\
    \   In this case, the offer is different from the previous case: It does\n   not\
    \ include the stream properties \"height\", \"width\", and \"tx3g\".  The\n  \
    \ answerer copies the \"tx\", \"ty\", and \"layer\" values, thus\n   acknowledging\
    \ these.  \"max-h\" and \"max-w\" are not present in the\n   answer because the\
    \ \"tx\" and \"ty\" (and \"layer\") in this special case\n   do not apply to the\
    \ received stream, but to the sent stream.  Also,\n   if offerer and answerer\
    \ had very different display sizes, it would\n   not be possible to express the\
    \ answerer's capabilities.  In the\n   example above and for an answerer with\
    \ a 50x50 display, the\n   translation values are already out of range.\n   For\
    \ sendonly:\n   O -> A\n   m=video <port> RTP/AVP 98\n   a=rtpmap:98 3gpp-tt/1000\n\
    \   a=fmtp:98 tx=100; ty=100; layer=0; height=80; width=100;\n   sver=6256,60;\
    \ tx3g=81...\n   a=sendonly\n   A -> O\n   m=video <port> RTP/AVP 98..\n   a=rtpmap:98\
    \ 3gpp-tt/1000\n   a=fmtp:98 tx=100; ty=100; layer=0; height=80; width=100; max-h=100;\n\
    \   max-w=160; sver=60\n   a=recvonly\n   Note that \"max-h\" and \"max-w\" are\
    \ not present in the offer.  Also,\n   with this answer, the answerer would accept\
    \ the offer as is (thus\n   echoing \"tx\", \"ty\", \"height\", \"width\", and\
    \ \"layer\") and additionally\n   inform the offerer about its capabilities: \"\
    max-h\" and \"max-w\".\n   Another possible answer for this case would be:\n \
    \  A -> O\n   m=video <port> RTP/AVP 98..\n   a=rtpmap:98 3gpp-tt/1000\n   a=fmtp:98\
    \ tx=120; ty=105; layer=0; max-h=95; max-w=150; sver=60\n   a=recvonly\n   In\
    \ this case, the answerer does not accept the values offered.  The\n   offerer\
    \ MUST use these values or else remove the stream.\n"
- title: 9.4.  Parameter Usage outside of Offer/Answer
  contents:
  - "9.4.  Parameter Usage outside of Offer/Answer\n   SDP may also be employed outside\
    \ of the Offer/Answer context, for\n   instance for multimedia sessions that are\
    \ announced through the\n   Session Announcement Protocol (SAP) [14] or streamed\
    \ through the Real\n   Time Streaming Protocol (RTSP) [15].\n   In this case,\
    \ the receiver of a session description is required to\n   support the parameters\
    \ and given values for the streams, or else it\n   MUST reject the session.  It\
    \ is the responsibility of the sender (or\n   creator) of the session descriptions\
    \ to define the session parameters\n   so that the probability of unsuccessful\
    \ session setup is minimized.\n   This is out of the scope of this document.\n"
- title: 10.  IANA Considerations
  contents:
  - "10.  IANA Considerations\n   IANA has registered the media subtype name \"3gpp-tt\"\
    \ for the media\n   type \"video\" as specified in Section 8 of this document.\n"
- title: 11.  Security Considerations
  contents:
  - "11.  Security Considerations\n   RTP packets using the payload format defined\
    \ in this specification\n   are subject to the security considerations discussed\
    \ in the RTP\n   specification [3] and any applicable RTP profile, e.g., AVP [17].\n\
    \   In particular, an attacker may invalidate the current set of active\n   sample\
    \ descriptions at the client by means of repeating a packet with\n   an old sample\
    \ description, i.e., replay attack.  This would mean that\n   the display of the\
    \ text would be corrupted, if displayed at all.\n   Another form of attack may\
    \ consist of sending redundant fragments,\n   whose boundaries do not match the\
    \ exact boundaries of the originals\n   (as indicated by LEN) or fragments that\
    \ carry different sample\n   lengths (SLEN).  This may cause a decoder to crash.\n\
    \   These types of attack may easily be avoided by using source\n   authentication\
    \ and integrity protection.\n   Additionally, peers in a timed text session may\
    \ desire to retain\n   privacy in their communication, i.e., confidentiality.\n\
    \   This payload format does not provide any mechanisms for achieving\n   these.\
    \  Confidentiality, integrity protection, and authentication\n   have to be solved\
    \ by a mechanism external to this payload format,\n   e.g., SRTP [10].\n"
- title: 12.  References
  contents:
  - '12.  References

    '
- title: 12.1.  Normative References
  contents:
  - "12.1.  Normative References\n   [1]  Transparent end-to-end packet switched streaming\
    \ service (PSS);\n        Timed Text Format (Release 6), TS 26.245 v 6.0.0, June\
    \ 2004.\n   [2]  ISO/IEC 14496-12:2004 Information technology - Coding of audio-\n\
    \        visual objects - Part 12: ISO base media file format.\n   [3]  Schulzrinne,\
    \ H.,  Casner, S., Frederick, R., and V. Jacobson,\n        \"RTP: A Transport\
    \ Protocol for Real-Time Applications\", STD 64,\n        RFC 3550, July 2003.\n\
    \   [4]  Handley, M. and V. Jacobson, \"SDP: Session Description\n        Protocol\"\
    , RFC 2327, April 1998.\n   [5]  Bradner, S., \"Key words for use in RFCs to Indicate\
    \ Requirement\n        Levels\", BCP 14, RFC 2119, March 1997.\n   [6]  Josefsson,\
    \ S., \"The Base16, Base32, and Base64 Data Encodings\",\n        RFC 3548, July\
    \ 2003.\n"
- title: 12.2.  Informative References
  contents:
  - "12.2.  Informative References\n   [7]  Rosenberg, J. and H. Schulzrinne, \"An\
    \ RTP Payload Format for\n        Generic Forward Error Correction\", RFC 2733,\
    \ December 1999.\n   [8]  Perkins, C. and O. Hodson, \"Options for Repair of Streaming\n\
    \        Media\", RFC 2354, June 1998.\n   [9]  W3C, \"Synchronised Multimedia\
    \ Integration Language (SMIL 2.0)\",\n        August, 2001.\n   [10] Baugher,\
    \ M., McGrew, D., Naslund, M., Carrara, E., and K.\n        Norrman, \"The Secure\
    \ Real-time Transport Protocol (SRTP)\", RFC\n        3711, March 2004.\n   [11]\
    \ Rey, J., Leon, D., Miyazaki, A., Varsa, V., and R. Hakenberg,\n        \"RTP\
    \ Retransmission Payload Format\", Work in Progress, September\n        2005.\n\
    \   [12] van der Meer, J., Mackie, D., Swaminathan, V., Singer, D., and\n    \
    \    P. Gentric, \"RTP Payload Format for Transport of MPEG-4\n        Elementary\
    \ Streams\", RFC 3640, November 2003.\n   [13] Rosenberg, J. and H. Schulzrinne,\
    \ \"An Offer/Answer Model with\n        Session Description Protocol (SDP)\",\
    \ RFC 3264, June 2002.\n   [14] Handley, M., Perkins, C., and E. Whelan, \"Session\
    \ Announcement\n        Protocol\", RFC 2974, October 2000.\n   [15] Schulzrinne,\
    \ H., Rao, A., and R. Lanphier, \"Real Time Streaming\n        Protocol (RTSP)\"\
    , RFC 2326, April 1998.\n   [16] Transparent end-to-end packet switched streaming\
    \ service (PSS);\n        Protocols and codecs (Release 6), TS 26.234 v 6.1.0,\
    \ September\n        2004.\n   [17] Schulzrinne, H. and S. Casner, \"RTP Profile\
    \ for Audio and Video\n        Conferences with Minimal Control\", STD 65, RFC\
    \ 3551, July 2003.\n   [18] Yergeau, F., \"UTF-8, a transformation format of ISO\
    \ 10646\", STD\n        63, RFC 3629, November 2003.\n   [19] Hoffman, P. and\
    \ F. Yergeau, \"UTF-16, an encoding of ISO 10646\",\n        RFC 2781, February\
    \ 2000.\n   [20] Friedman, T., Caceres, R., and A. Clark, \"RTP Control Protocol\n\
    \        Extended Reports (RTCP XR)\", RFC 3611, November 2003.\n   [21] Ott,\
    \ J., Wenger, S., Sato, N., Burmeister, C., and J. Rey,\n        \"Extended RTP\
    \ Profile for RTCP-based Feedback (RTP/AVPF)\", Work\n        in Progress, August\
    \ 2004.\n   [22] Hellstrom, G., \"RTP Payload for Text Conversation\", RFC 2793,\n\
    \        May 2000.\n   [23] Hellstrom, G. and P. Jones, \"RTP Payload for Text\
    \ Conversation\",\n        RFC 4103, June 2005.\n   [24] ITU-T Recommendation\
    \ T.140 (1998) - Text conversation protocol\n        for multimedia application,\
    \ with amendment 1, (2000).\n   [25] ISO/IEC 10646-1: (1993), Universal Multiple\
    \ Octet Coded\n        Character Set.\n   [26] ISO/IEC FCD 14496-17 Information\
    \ technology - Coding of audio-\n        visual objects - Part 17: Streaming text\
    \ format, Work in\n        progress, June 2004.\n   [27] Transparent end-to-end\
    \ Packet-switched Streaming Service (PSS);\n        3GPP SMIL language profile,\
    \ (Release 6), TS 26.246 v 6.0.0, June\n        2004.\n   [28] Casner, S. and\
    \ P. Hoschka, \"MIME Type Registration of RTP\n        Payload Formats\", RFC\
    \ 3555, July 2003.\n   [29] Freed, N. and J. Klensin, \"Media Type Specifications\
    \ and\n        Registration Procedures\", BCP 13, RFC 4288, December 2005.\n \
    \  [30] Transparent end-to-end packet switched streaming service (PSS);\n    \
    \    3GPP file format (3GP) (Release 6), TS 26.244 V6.3. March 2005.\n   [31]\
    \ Castagno, R. and D. Singer, \"MIME Type Registrations for 3rd\n        Generation\
    \ Partnership Project (3GPP) Multimedia files\", RFC\n        3839, July 2004.\n"
- title: 13.  Basics of the 3GP File Structure
  contents:
  - "13.  Basics of the 3GP File Structure\n   This section provides a coarse overview\
    \ of the 3GP file structure,\n   which follows the ISO Base Media file Format\
    \ [2].\n   Each 3GP file consists of \"Boxes\".  In general, a 3GP file contains\n\
    \   the File Type Box (ftyp), the Movie Box (moov), and the Media Data\n   Box\
    \ (mdat).  The File Type Box identifies the type and properties of\n   the 3GP\
    \ file itself.  The Movie Box and the Media Data Box, serving\n   as containers,\
    \ include their own boxes for each media.  Boxes start\n   with a header, which\
    \ indicates both size and type (these fields are\n   called, namely, \"size\"\
    \ and \"type\").  Additionally, each box type may\n   include a number of boxes.\n\
    \   In the following, only those boxes are mentioned that are useful for\n   the\
    \ purposes of this payload format.\n   The Movie Box (moov) contains one or more\
    \ Track Boxes (trak), which\n   include information about each track.  A Track\
    \ Box contains, among\n   others, the Track Header Box (tkhd), the Media Header\
    \ Box (mdhd), and\n   the Media Information Box (minf).\n   The Track Header Box\
    \ specifies the characteristics of a single track,\n   where a track is, in this\
    \ case, the streamed text during a session.\n   Exactly one Track Header Box is\
    \ present for a track.  It contains\n   information about the track, such as the\
    \ spatial layout (width and\n   height), the video transformation matrix, and\
    \ the layer number.\n   Since these pieces of information are essential and static\
    \ (i.e.,\n   constant) for the duration of the session, they must be sent prior\
    \ to\n   the transmission of any text samples.\n   The Media Header Box contains\
    \ the \"timescale\" or number of time units\n   that pass in one second, i.e.,\
    \ cycles per second or Hertz.  The Media\n   Information Box includes the Sample\
    \ Table Box (stbl), which contains\n   all the time and data indexing of the media\
    \ samples in a track. Using\n   this box, it is possible to locate samples in\
    \ time and to determine\n   their type, size, container, and offset into that\
    \ container. Inside\n   the Sample Table Box, we can find the Sample Description\
    \ Box (stsd,\n   for finding sample descriptions), the Decoding Time to Sample\
    \ Box\n   (stts, for finding sample duration), the Sample Size Box (stsz), and\n\
    \   the Sample to Chunk Box (stsc, for finding the sample description\n   index).\n\
    \   Finally, the Media Data Box contains the media data itself.  In timed\n  \
    \ text tracks, this box contains text samples.  Its equivalent to audio\n   and\
    \ video is audio and video frames, respectively.  The text sample\n   consists\
    \ of the text length, the text string, and one or several\n   Modifier Boxes.\
    \  The text length is the size of the text in bytes.\n   The text string is plain\
    \ text to render.  The Modifier Box is\n   information to render in addition to\
    \ the text, such as color, font,\n   etc.\n"
- title: 14.  Acknowledgements
  contents:
  - "14.  Acknowledgements\n   The authors would like to thank Dave Singer, Jan van\
    \ der Meer, Magnus\n   Westerlund, and Colin Perkins for their comments and suggestions\n\
    \   about this document.\n   The authors would also like to thank Markus Gebhard\
    \ for the free and\n   publicly available JavE ASCII Editor (used for the ASCII\
    \ drawings in\n   this document) and Henrik Levkowetz for the Idnits web service.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Jose Rey\n   Panasonic R&D Center Germany GmbH\n   Monzastr.\
    \ 4c\n   D-63225 Langen, Germany\n   EMail: jose.rey@eu.panasonic.com\n   Phone:\
    \ +49-6103-766-134\n   Fax:   +49-6103-766-166\n   Yoshinori Matsui\n   Matsushita\
    \ Electric Industrial Co., LTD.\n   1006 Kadoma\n   Kadoma-shi, Osaka, Japan\n\
    \   EMail: matsui.yoshinori@jp.panasonic.com\n   Phone: +81 6 6900 9689\n   Fax:\
    \   +81 6 6900 9699\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.  The IETF invites\
    \ any interested party to\n   bring to its attention any copyrights, patents or\
    \ patent\n   applications, or other proprietary rights that may cover technology\n\
    \   that may be required to implement this standard.  Please address the\n   information\
    \ to the IETF at ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n\
    \   Administrative Support Activity (IASA).\n"
