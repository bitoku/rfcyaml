- title: __initial_text__
  contents:
  - '        Asynchronous Layered Coding (ALC) Protocol Instantiation

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2002).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes the Asynchronous Layered Coding (ALC)\n\
    \   protocol, a massively scalable reliable content delivery protocol.\n   Asynchronous\
    \ Layered Coding combines the Layered Coding Transport\n   (LCT) building block,\
    \ a multiple rate congestion control building\n   block and the Forward Error\
    \ Correction (FEC) building block to\n   provide congestion controlled reliable\
    \ asynchronous delivery of\n   content to an unlimited number of concurrent receivers\
    \ from a single\n   sender.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction.................................................2\n\
    \     1.1 Delivery service models...................................3\n     1.2\
    \ Scalability...............................................5\n     1.3 Environmental\
    \ Requirements and Considerations.............6\n   2. Architecture Definition......................................8\n\
    \     2.1 LCT building block........................................9\n     2.2\
    \ Multiple rate congestion control building block..........10\n     2.3 FEC building\
    \ block.......................................11\n     2.4 Session Description......................................13\n\
    \     2.5 Packet authentication building block.....................14\n   3. Conformance\
    \ Statement.......................................14\n   4. Functionality Definition....................................14\n\
    \     4.1 Packet format used by ALC................................15\n     4.2\
    \ Detailed Example of Packet format used by ALC............16\n     4.3 Header-Extension\
    \ Fields..................................23\n     4.4 Sender Operation.........................................26\n\
    \     4.5 Receiver Operation.......................................27\n   5. Security\
    \ Considerations.....................................29\n   6. IANA Considerations.........................................31\n\
    \   7. Intellectual Property Issues................................31\n   8. Acknowledgments.............................................31\n\
    \   9. References..................................................31\n   Authors'\
    \ Addresses.............................................33\n   Full Copyright\
    \ Statement.......................................34\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   This document describes a massively scalable reliable content\n\
    \   delivery protocol, Asynchronous Layered Coding (ALC), for multiple\n   rate\
    \ congestion controlled reliable content delivery.  The protocol\n   is specifically\
    \ designed to provide massive scalability using IP\n   multicast as the underlying\
    \ network service.  Massive scalability in\n   this context means the number of\
    \ concurrent receivers for an object\n   is potentially in the millions, the aggregate\
    \ size of objects to be\n   delivered in a session ranges from hundreds of kilobytes\
    \ to hundreds\n   of gigabytes, each receiver can initiate reception of an object\n\
    \   asynchronously, the reception rate of each receiver in the session is\n  \
    \ the maximum fair bandwidth available between that receiver and the\n   sender,\
    \ and all of this can be supported using a single sender.\n   Because ALC is focused\
    \ on reliable content delivery, the goal is to\n   deliver objects as quickly\
    \ as possible to each receiver while at the\n   same time remaining network friendly\
    \ to competing traffic.  Thus, the\n   congestion control used in conjunction\
    \ with ALC should strive to\n   maximize use of available bandwidth between receivers\
    \ and the sender\n   while at the same time backing off aggressively in the face\
    \ of\n   competing traffic.\n   The sender side of ALC consists of generating\
    \ packets based on\n   objects to be delivered within the session and sending\
    \ the\n   appropriately formatted packets at the appropriate rates to the\n  \
    \ channels associated with the session.  The receiver side of ALC\n   consists\
    \ of joining appropriate channels associated with the session,\n   performing\
    \ congestion control by adjusting the set of joined channels\n   associated with\
    \ the session in response to detected congestion, and\n   using the packets to\
    \ reliably reconstruct objects.  All information\n   flow in an ALC session is\
    \ in the form of data packets sent by a\n   single sender to channels that receivers\
    \ join to receive data.\n   ALC does specify the Session Description needed by\
    \ receivers before\n   they join a session, but the mechanisms by which receivers\
    \ obtain\n   this required information is outside the scope of ALC.  An\n   application\
    \ that uses ALC may require that receivers report\n   statistics on their reception\
    \ experience back to the sender, but the\n   mechanisms by which receivers report\
    \ back statistics is outside the\n   scope of ALC.  In general, ALC is designed\
    \ to be a minimal protocol\n   instantiation that provides reliable content delivery\
    \ without\n   unnecessary limitations to the scalability of the basic protocol.\n\
    \   This document is a product of the IETF RMT WG and follows the general\n  \
    \ guidelines provided in RFC 3269 [8].\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in BCP 14, RFC 2119 [2].\n   Statement of Intent\n      This memo contains part\
    \ of the definitions necessary to fully\n      specify a Reliable Multicast Transport\
    \ protocol in accordance with\n      RFC2357.  As per RFC2357, the use of any\
    \ reliable multicast\n      protocol in the Internet requires an adequate congestion\
    \ control\n      scheme.\n      While waiting for such a scheme to be available,\
    \ or for an\n      existing scheme to be proven adequate, the Reliable Multicast\n\
    \      Transport working group (RMT) publishes this Request for Comments\n   \
    \   in the \"Experimental\" category.\n      It is the intent of RMT to re-submit\
    \ this specification as an IETF\n      Proposed Standard as soon as the above\
    \ condition is met.\n"
- title: 1.1 Delivery service models
  contents:
  - "1.1 Delivery service models\n   ALC can support several different reliable content\
    \ delivery service\n   models.  Some examples are briefly described here.\n  \
    \ Push service model.\n   A push model is a sender initiated concurrent delivery\
    \ of objects to\n   a selected set of receivers.  A push service model can be\
    \ used for\n   example for reliable delivery of a large object such as a 100 GB\n\
    \   file.  The sender could send a Session Description announcement to a\n   control\
    \ channel and receivers could monitor this channel and join a\n   session whenever\
    \ a Session Description of interest arrives.  Upon\n   receipt of the Session\
    \ Description, each receiver could join the\n   session to receive packets until\
    \ enough packets have arrived to\n   reconstruct the object, at which point the\
    \ receiver could report back\n   to the sender that its reception was completed\
    \ successfully.  The\n   sender could decide to continue sending packets for the\
    \ object to the\n   session until all receivers have reported successful reconstruction\n\
    \   or until some other condition has been satisfied.  In this example,\n   the\
    \ sender uses ALC to generate packets based on the object and send\n   packets\
    \ to channels associated with the session, and the receivers\n   use ALC to receive\
    \ packets from the session and reconstruct the\n   object.\n   There are several\
    \ features ALC provides to support the push model.\n   For example, the sender\
    \ can optionally include an Expected Residual\n   Time (ERT) in the packet header\
    \ that indicates the expected remaining\n   time of packet transmission for either\
    \ the single object carried in\n   the session or for the object identified by\
    \ the Transmission Object\n   Identifier (TOI) if there are multiple objects carried\
    \ in the\n   session.  This can be used by receivers to determine if there is\n\
    \   enough time remaining in the session to successfully receive enough\n   additional\
    \ packets to recover the object.  If for example there is\n   not enough time,\
    \ then the push application may have receivers report\n   back to the sender to\
    \ extend the transmission of packets for the\n   object for enough time to allow\
    \ the receivers to obtain enough\n   packets to reconstruct the object.  The sender\
    \ could then include an\n   ERT based on the extended object transmission time\
    \ in each subsequent\n   packet header for the object.  As other examples, the\
    \ LCT header\n   optionally can contain a Close Session flag that indicates when\
    \ the\n   sender is about to end sending packet to the session and a Close\n \
    \  Object flag that indicates when the sender is about to end sending\n   packets\
    \ to the session for the object identified by the Transmission\n   Object ID.\
    \  However, these flags are not a completely reliable\n   mechanism and thus the\
    \ Close Session flag should only be used as a\n   hint of when the session is\
    \ about to close and the Close Object flag\n   should only be used as a hint of\
    \ when transmission of packets for the\n   object is about to end.\n   The push\
    \ model is particularly attractive in satellite networks and\n   wireless networks.\
    \  In these environments a session may include one\n   channel and a sender may\
    \ send packets at a fixed rate to this\n   channel, but sending at a fixed rate\
    \ without congestion control is\n   outside the scope of this document.\n   On-demand\
    \ content delivery model.\n   For an on-demand content delivery service model,\
    \ senders typically\n   transmit for some given time period selected to be long\
    \ enough to\n   allow all the intended receivers to join the session and recover\
    \ a\n   single object.  For example a popular software update might be\n   transmitted\
    \ using ALC for several days, even though a receiver may be\n   able to complete\
    \ the download in one hour total of connection time,\n   perhaps spread over several\
    \ intervals of time.  In this case the\n   receivers join the session at any point\
    \ in time when it is active.\n   Receivers leave the session when they have received\
    \ enough packets to\n   recover the object.  The receivers, for example, obtain\
    \ a Session\n   Description by contacting a web server.\n   Other service models.\n\
    \   There may be other reliable content delivery service models that can\n   be\
    \ supported by ALC.  The description of the potential applications,\n   the appropriate\
    \ delivery service model, and the additional mechanisms\n   to support such functionalities\
    \ when combined with ALC is beyond the\n   scope of this document.\n"
- title: 1.2 Scalability
  contents:
  - "1.2 Scalability\n   Massive scalability is a primary design goal for ALC.  IP\
    \ multicast\n   is inherently massively scalable, but the best effort service\
    \ that it\n   provides does not provide session management functionality,\n  \
    \ congestion control or reliability.  ALC provides all of this on top\n   of IP\
    \ multicast without sacrificing any of the inherent scalability\n   of IP multicast.\
    \  ALC has the following properties:\n   o To each receiver, it appears as if\
    \ though there is a dedicated\n     session from the sender to the receiver, where\
    \ the reception rate\n     adjusts to congestion along the path from sender to\
    \ receiver.\n   o To the sender, there is no difference in load or outgoing rate\
    \ if\n     one receiver is joined to the session or a million (or any number\n\
    \     of) receivers are joined to the session, independent of when the\n     receivers\
    \ join and leave.\n   o No feedback packets are required from receivers to the\
    \ sender.\n   o Almost all packets in the session that pass through a bottleneck\n\
    \     link are utilized by downstream receivers, and the session shares\n    \
    \ the link with competing flows fairly in proportion to their\n     utility.\n\
    \   Thus, ALC provides a massively scalable content delivery transport\n   that\
    \ is network friendly.\n   ALC intentionally omits any application specific features\
    \ that could\n   potentially limit its scalability.  By doing so, ALC provides\
    \ a\n   minimal protocol that is massively scalable.  Applications may be\n  \
    \ built on top of ALC to provide additional features that may limit the\n   scalability\
    \ of the application.  Such applications are outside the\n   scope of this document.\n"
- title: 1.3  Environmental Requirements and Considerations
  contents:
  - "1.3  Environmental Requirements and Considerations\n   All of the environmental\
    \ requirements and considerations that apply\n   to the LCT building block [11],\
    \ the FEC building block [10], the\n   multiple rate congestion control building\
    \ block and to any additional\n   building blocks that ALC uses also apply to\
    \ ALC.\n   ALC requires connectivity between a sender and receivers, but does\n\
    \   not require connectivity from receivers to a sender.  ALC inherently\n   works\
    \ with all types of networks, including LANs, WANs, Intranets,\n   the Internet,\
    \ asymmetric networks, wireless networks, and satellite\n   networks.  Thus, the\
    \ inherent raw scalability of ALC is unlimited.\n   However, ALC requires receivers\
    \ to obtain the Session Description\n   out-of-band before joining a session and\
    \ some implementations of this\n   may limit scalability.\n   If a receiver is\
    \ joined to multiple ALC sessions then the receiver\n   MUST be able to uniquely\
    \ identify and demultiplex packets to the\n   correct session.  The Transmission\
    \ Session Identifier (TSI) that MUST\n   appear in each packet header is used\
    \ for this purpose.  The TSI is\n   scoped by the IP address of the sender, and\
    \ the IP address of the\n   sender together with the TSI uniquely identify the\
    \ session.  Thus,\n   the demultiplexing MUST be done on the basis of the IP address\
    \ of the\n   sender and the TSI of the session from that sender.\n   ALC is presumed\
    \ to be used with an underlying IP multicast network or\n   transport service\
    \ that is a \"best effort\" service that does not\n   guarantee packet reception,\
    \ packet reception order, and which does\n   not have any support for flow or\
    \ congestion control.  There are\n   currently two models of multicast delivery,\
    \ the Any-Source Multicast\n   (ASM) model as defined in RFC 1112 [3] and the\
    \ Source-Specific\n   Multicast (SSM) model as defined in [7].  ALC works with\
    \ both\n   multicast models, but in a slightly different way with somewhat\n \
    \  different environmental concerns.  When using ASM, a sender S sends\n   packets\
    \ to a multicast group G, and an ALC channel address consists\n   of the pair\
    \ (S,G), where S is the IP address of the sender and G is a\n   multicast group\
    \ address.  When using SSM, a sender S sends packets to\n   an SSM channel (S,G),\
    \ and an ALC channel address coincides with the\n   SSM channel address.\n   A\
    \ sender can locally allocate unique SSM channel addresses, and this\n   makes\
    \ allocation of ALC channel addresses easy with SSM.  To allocate\n   ALC channel\
    \ addresses using ASM, the sender must uniquely choose the\n   ASM multicast group\
    \ address across the scope of the group, and this\n   makes allocation of ALC\
    \ channel addresses more difficult with ASM.\n   ALC channels and SSM channels\
    \ coincide, and thus the receiver will\n   only receive packets sent to the requested\
    \ ALC channel.  With ASM,\n   the receiver joins an ALC channel by joining a multicast\
    \ group G, and\n   all packets sent to G, regardless of the sender, may be received\
    \ by\n   the receiver.  Thus, SSM has compelling security advantages over ASM\n\
    \   for prevention of denial of service attacks.  In either case,\n   receivers\
    \ SHOULD use mechanisms to filter out packets from unwanted\n   sources.\n   Other\
    \ issues specific to ALC with respect to ASM is the way the\n   multiple rate\
    \ congestion control building block interacts with ASM.\n   The congestion control\
    \ building block may use the measured difference\n   in time between when a join\
    \ to a channel is sent and when the first\n   packet from the channel arrives\
    \ in determining the receiver reception\n   rate.  The congestion control building\
    \ block may also uses packet\n   sequence numbers per channel to measure losses,\
    \ and this is also used\n   to determine the receiver reception rate.  These features\
    \ raise two\n   concerns with respect to ASM: The time difference between when\
    \ the\n   join to a channel is sent and when the first packet arrives can be\n\
    \   significant due to the use of Rendezvous Points (RPs) and the MSDP\n   protocol,\
    \ and packets can be lost in the switch over from the (*,G)\n   join to the RP\
    \ and the (S,G) join directly to the sender.  Both of\n   these issues could potentially\
    \ substantially degrade the reception\n   rate of receivers.  To ameliorate these\
    \ concerns, it is RECOMMENDED\n   that the RP be as close to the sender as possible.\
    \  SSM does not\n   share these same concerns.  For a fuller consideration of\
    \ these\n   issues, consult the multiple rate congestion control building block.\n\
    \   Some networks are not amenable to some congestion control protocols\n   that\
    \ could be used with ALC.  In particular, for a satellite or\n   wireless network,\
    \ there may be no mechanism for receivers to\n   effectively reduce their reception\
    \ rate since there may be a fixed\n   transmission rate allocated to the session.\n\
    \   ALC is compatible with either IPv4 or IPv6 as no part of the packet\n   is\
    \ IP version specific.\n"
- title: 2.  Architecture Definition
  contents:
  - "2.  Architecture Definition\n   ALC uses the LCT building block [11] to provide\
    \ in-band session\n   management functionality.  ALC uses a multiple rate congestion\n\
    \   control building block that is compliant with RFC 2357 [12] to\n   provide\
    \ congestion control that is feedback free.  Receivers adjust\n   their reception\
    \ rates individually by joining and leaving channels\n   associated with the session.\
    \  ALC uses the FEC building block [10] to\n   provide reliability.  The sender\
    \ generates encoding symbols based on\n   the object to be delivered using FEC\
    \ codes and sends them in packets\n   to channels associated with the session.\
    \  Receivers simply wait for\n   enough packets to arrive in order to reliably\
    \ reconstruct the object.\n   Thus, there is no request for retransmission of\
    \ individual packets\n   from receivers that miss packets in order to assure reliable\n\
    \   reception of an object, and the packets and their rate of\n   transmission\
    \ out of the sender can be independent of the number and\n   the individual reception\
    \ experiences of the receivers.\n   The definition of a session for ALC is the\
    \ same as it is for LCT.  An\n   ALC session comprises multiple channels originating\
    \ at a single\n   sender that are used for some period of time to carry packets\n\
    \   pertaining to the transmission of one or more objects that can be of\n   interest\
    \ to receivers.  Congestion control is performed over the\n   aggregate of packets\
    \ sent to channels belonging to a session.  The\n   fact that an ALC session is\
    \ restricted to a single sender does not\n   preclude the possibility of receiving\
    \ packets for the same objects\n   from multiple senders.  However, each sender\
    \ would be sending packets\n   to a a different session to which congestion control\
    \ is individually\n   applied.  Although receiving concurrently from multiple\
    \ sessions is\n   allowed, how this is done at the application level is outside\
    \ the\n   scope of this document.\n   ALC is a protocol instantiation as defined\
    \ in RFC 3048 [16].  This\n   document describes version 1 of ALC which MUST use\
    \ version 1 of LCT\n   described in [11].  Like LCT, ALC is designed to be used\
    \ with the IP\n   multicast network service.  This specification defines ALC as\
    \ payload\n   of the UDP transport protocol [15] that supports IP multicast\n\
    \   delivery of packets.  Future versions of this specification, or\n   companion\
    \ documents may extend ALC to use the IP network layer\n   service directly. \
    \ ALC could be used as the basis for designing a\n   protocol that uses a different\
    \ underlying network service such as\n   unicast UDP, but the design of such a\
    \ protocol is outside the scope\n   of this document.\n   An ALC packet header\
    \ immediately follows the UDP header and consists\n   of the default LCT header\
    \ that is described in [11] followed by the\n   FEC Payload ID that is described\
    \ in [10].  The Congestion Control\n   Information field within the LCT header\
    \ carries the required\n   Congestion Control Information that is described in\
    \ the multiple rate\n   congestion control building block specified that is compliant\
    \ with\n   RFC 2357 [12].  The packet payload that follows the ALC packet header\n\
    \   consists of encoding symbols that are identified by the FEC Payload\n   ID\
    \ as described in [10].\n   Each receiver is required to obtain a Session Description\
    \ before\n   joining an ALC session.  As described later, the Session Description\n\
    \   includes out-of-band information required for the LCT, FEC and the\n   multiple\
    \ rate congestion control building blocks.  The FEC Object\n   Transmission Information\
    \ specified in the FEC building block [10]\n   required for each object to be\
    \ received by a receiver can be\n   communicated to a receiver either out-of-band\
    \ or in-band using a\n   Header Extension.  The means for communicating the Session\n\
    \   Description and the FEC Object Transmission Information to a receiver\n  \
    \ is outside the scope of this document.\n"
- title: 2.1  LCT building block
  contents:
  - "2.1  LCT building block\n   LCT requires receivers to be able to uniquely identify\
    \ and\n   demultiplex packets associated with an LCT session, and ALC inherits\n\
    \   and strengthens this requirement.  A Transport Session Identifier\n   (TSI)\
    \ MUST be associated with each session and MUST be carried in the\n   LCT header\
    \ of each ALC packet.  The TSI is scoped by the sender IP\n   address, and the\
    \ (sender IP address, TSI) pair MUST uniquely identify\n   the session.\n   The\
    \ LCT header contains a Congestion Control Information (CCI) field\n   that MUST\
    \ be used to carry the Congestion Control Information from\n   the specified multiple\
    \ rate congestion control protocol.  There is a\n   field in the LCT header that\
    \ specifies the length of the CCI field,\n   and the multiple rate congestion\
    \ control building block MUST uniquely\n   identify a format of the CCI field\
    \ that corresponds to this length.\n   The LCT header contains a Codepoint field\
    \ that MAY be used to\n   communicate to a receiver the settings for information\
    \ that may vary\n   during a session.  If used, the mapping between settings and\n\
    \   Codepoint values is to be communicated in the Session Description,\n   and\
    \ this mapping is outside the scope of this document.  For example,\n   the FEC\
    \ Encoding ID that is part of the FEC Object Transmission\n   Information as specified\
    \ in the FEC building block [10] could vary\n   for each object carried in the\
    \ session, and the Codepoint value could\n   be used to communicate the FEC Encoding\
    \ ID to be used for each\n   object.  The mapping between FEC Encoding IDs and\
    \ Codepoints could\n   be, for example, the identity mapping.\n   If more than\
    \ one object is to be carried within a session then the\n   Transmission Object\
    \ Identifier (TOI) MUST be used in the LCT header\n   to identify which packets\
    \ are to be associated with which objects.\n   In this case the receiver MUST\
    \ use the TOI to associate received\n   packets with objects.  The TOI is scoped\
    \ by the IP address of the\n   sender and the TSI, i.e., the TOI is scoped by\
    \ the session.  The TOI\n   for each object is REQUIRED to be unique within a\
    \ session, but MAY\n   NOT be unique across sessions.  Furthermore, the same object\
    \ MAY have\n   a different TOI in different sessions.  The mapping between TOIs\
    \ and\n   objects carried in a session is outside the scope of this document.\n\
    \   If only one object is carried within a session then the TOI MAY be\n   omitted\
    \ from the LCT header.\n   The default LCT header from version 1 of the LCT building\
    \ block [11]\n   MUST be used.\n"
- title: 2.2  Multiple rate congestion control building block
  contents:
  - "2.2  Multiple rate congestion control building block\n   Implementors of ALC\
    \ MUST implement a multiple rate feedback-free\n   congestion control building\
    \ block that is in accordance to RFC 2357\n   [12].  Congestion control MUST be\
    \ applied to all packets within a\n   session independently of which information\
    \ about which object is\n   carried in each packet.  Multiple rate congestion\
    \ control is\n   specified because of its suitability to scale massively and because\n\
    \   of its suitability for reliable content delivery.  The multiple rate\n   congestion\
    \ control building block MUST specify in-band Congestion\n   Control Information\
    \ (CCI) that MUST be carried in the CCI field of\n   the LCT header.  The multiple\
    \ rate congestion control building block\n   MAY specify more than one format,\
    \ but it MUST specify at most one\n   format for each of the possible lengths\
    \ 32, 64, 96 or 128 bits.  The\n   value of C in the LCT header that determines\
    \ the length of the CCI\n   field MUST correspond to one of the lengths for the\
    \ CCI defined in\n   the multiple rate congestion control building block, this\
    \ length MUST\n   be the same for all packets sent to a session, and the CCI format\n\
    \   that corresponds to the length as specified in the multiple rate\n   congestion\
    \ control building block MUST be the format used for the CCI\n   field in the\
    \ LCT header.\n   When using a multiple rate congestion control building block\
    \ a sender\n   sends packets in the session to several channels at potentially\n\
    \   different rates.  Then, individual receivers adjust their reception\n   rate\
    \ within a session by adjusting which set of channels they are\n   joined to at\
    \ each point in time depending on the available bandwidth\n   between the receiver\
    \ and the sender, but independent of other\n   receivers.\n"
- title: 2.3  FEC building block
  contents:
  - "2.3  FEC building block\n   The FEC building block [10] provides reliable object\
    \ delivery within\n   an ALC session.  Each object sent in the session is independently\n\
    \   encoded using FEC codes as described in [9], which provide a more\n   in-depth\
    \ description of the use of FEC codes in reliable content\n   delivery protocols.\
    \  All packets in an ALC session MUST contain an\n   FEC Payload ID in a format\
    \ that is compliant with the FEC building\n   block [10].  The FEC Payload ID\
    \ uniquely identifies the encoding\n   symbols that constitute the payload of\
    \ each packet, and the receiver\n   MUST use the FEC Payload ID to determine how\
    \ the encoding symbols\n   carried in the payload of the packet were generated\
    \ from the object\n   as described in the FEC building block.\n   As described\
    \ in [10], a receiver is REQUIRED to obtain the FEC Object\n   Transmission Information\
    \ for each object for which data packets are\n   received from the session.  The\
    \ FEC Object Transmission Information\n   includes:\n     o The FEC Encoding ID.\n\
    \     o If an Under-Specified FEC Encoding ID is used then the FEC\n       Instance\
    \ ID associated with the FEC Encoding ID.\n     o For each object in the session,\
    \ the length of the object in\n       bytes.\n     o The additional required FEC\
    \ Object Transmission Information for\n       the FEC Encoding ID as prescribed\
    \ in the FEC building block [10].\n       For example, when the FEC Encoding ID\
    \ is 128, the required FEC\n       Object Transmission Information is the number\
    \ of source blocks\n       that the object is partitioned into and the length\
    \ of each source\n       block in bytes.\n   Some of the FEC Object Transmission\
    \ Information MAY be implicit based\n   on the implementation.  As an example,\
    \ source block lengths may be\n   derived by a fixed algorithm from the object\
    \ length.  As another\n   example, it may be that all source blocks are the same\
    \ length and\n   this is what is passed out-of-band to the receiver.  As another\n\
    \   example, it could be that the full sized source block length is\n   provided\
    \ and this is the length used for all but the last source\n   block, which is\
    \ calculated based on the full source block length and\n   the object length.\
    \  As another example, it could be that the same FEC\n   Encoding ID and FEC Instance\
    \ ID are always used for a particular\n   application and thus the FEC Encoding\
    \ ID and FEC Instance ID are\n   implicitly defined.\n   Sometimes the objects\
    \ that will be sent in a session are completely\n   known before the receiver\
    \ joins the session, in which case the FEC\n   Object Transmission Information\
    \ for all objects in the session can be\n   communicated to receivers before they\
    \ join the session.  At other\n   times the objects may not know when the session\
    \ begins, or receivers\n   may join a session in progress and may not be interested\
    \ in some\n   objects for which transmission has finished, or receivers may leave\
    \ a\n   session before some objects are even available within the session.\n \
    \  In these cases, the FEC Object Transmission Information for each\n   object\
    \ may be dynamically communicated to receivers at or before the\n   time packets\
    \ for the object are received from the session.  This may\n   be accomplished\
    \ using either an out-of-band mechanism, in-band using\n   the Codepoint field\
    \ or a Header Extension, or any combination of\n   these methods.  How the FEC\
    \ Object Transmission Information is\n   communicated to receivers is outside\
    \ the scope of this document.\n   If packets for more than one object are transmitted\
    \ within a session\n   then a Transmission Object Identifier (TOI) that uniquely\
    \ identifies\n   objects within a session MUST appear in each packet header. \
    \ Portions\n   of the FEC Object Transmission Information could be the same for\
    \ all\n   objects in the session, in which case these portions can be\n   communicated\
    \ to the receiver with an indication that this applies to\n   all objects in the\
    \ session.  These portions may be implicitly\n   determined based on the application,\
    \ e.g., an application may use the\n   same FEC Encoding ID for all objects in\
    \ all sessions.  If there is a\n   portion of the FEC Object Transmission Information\
    \ that may vary from\n   object to object and if this FEC Object Transmission\
    \ Information is\n   communicated to a receiver out-of-band then the TOI for the\
    \ object\n   MUST also be communicated to the receiver together with the\n   corresponding\
    \ FEC Object Transmission Information, and the receiver\n   MUST use the corresponding\
    \ FEC Object Transmission Information for\n   all packets received with that TOI.\
    \  How the TOI and corresponding\n   FEC Object Transmission Information is communicated\
    \ out-of-band to\n   receivers is outside the scope of this document.\n   It is\
    \ also possible that there is a portion of the FEC Object\n   Transmission Information\
    \ that may vary from object to object that is\n   carried in-band, for example\
    \ in the CodePoint field or in Header\n   Extensions.  How this is done is outside\
    \ the scope of this document.\n   In this case the FEC Object Transmission Information\
    \ is associated\n   with the object identified by the TOI carried in the packet.\n"
- title: 2.4  Session Description
  contents:
  - "2.4  Session Description\n   The Session Description that a receiver is REQUIRED\
    \ to obtain before\n   joining an ALC session MUST contain the following information:\n\
    \     o The multiple rate congestion control building block to be used\n     \
    \  for the session;\n     o The sender IP address;\n     o The number of channels\
    \ in the session;\n     o The address and port number used for each channel in\
    \ the session;\n     o The Transport Session ID (TSI) to be used for the session;\n\
    \     o An indication of whether or not the session carries packets for\n    \
    \   more than one object;\n     o If Header Extensions are to be used, the format\
    \ of these Header\n       Extensions.\n     o Enough information to determine\
    \ the packet authentication scheme\n       being used, if it is being used.\n\
    \   How the Session Description is communicated to receivers is outside\n   the\
    \ scope of this document.\n   The Codepoint field within the LCT portion of the\
    \ header CAN be used\n   to communicate in-band some of the dynamically changing\
    \ information\n   within a session.  To do this, a mapping between Codepoint values\
    \ and\n   the different dynamic settings MUST be included within the Session\n\
    \   Description, and then settings to be used are communicated via the\n   Codepoint\
    \ value placed into each packet.  For example, it is possible\n   that multiple\
    \ objects are delivered within the same session and that\n   a different FEC encoding\
    \ algorithm is used for different types of\n   objects.  Then the Session Description\
    \ could contain the mapping\n   between Codepoint values and FEC Encoding IDs.\
    \  As another example,\n   it is possible that a different packet authentication\
    \ scheme is used\n   for different packets sent to the session.  In this case,\
    \ the mapping\n   between the packet authentication scheme and Codepoint values\
    \ could\n   be provided in the Session Description.  Combinations of settings\
    \ can\n   be mapped to Codepoint values as well.  For example, a particular\n\
    \   combination of a FEC Encoding ID and a packet authentication scheme\n   could\
    \ be associated with a Codepoint value.\n   The Session Description could also\
    \ include, but is not limited to:\n     o The mappings between combinations of\
    \ settings and Codepoint\n       values;\n     o The data rates used for each\
    \ channel;\n     o The length of the packet payload;\n     o Any information that\
    \ is relevant to each object being\n       transported, such as the Object Transmission\
    \ Information for each\n       object, when the object will be available within\
    \ the session and\n       for how long.\n   The Session Description could be in\
    \ a form such as SDP as defined in\n   RFC 2327 [5], or XML metadata as defined\
    \ in RFC 3023 [13], or\n   HTTP/Mime headers as defined in RFC 2068 [4], etc.\
    \  It might be\n   carried in a session announcement protocol such as SAP as defined\
    \ in\n   RFC 2974 [6], obtained using a proprietary session control protocol,\n\
    \   located on a web page with scheduling information, or conveyed via\n   E-mail\
    \ or other out-of-band methods.  Discussion of Session\n   Description formats\
    \ and methods for communication of Session\n   Descriptions to receivers is beyond\
    \ the scope of this document.\n"
- title: 2.5  Packet authentication building block
  contents:
  - "2.5  Packet authentication building block\n   It is RECOMMENDED that implementors\
    \ of ALC use some packet\n   authentication scheme to protect the protocol from\
    \ attacks.  An\n   example of a possibly suitable scheme is described in [14].\
    \  Packet\n   authentication in ALC, if used, is to be integrated through the\n\
    \   Header Extension support for packet authentication provided in the\n   LCT\
    \ building block.\n"
- title: 3.  Conformance Statement
  contents:
  - "3.  Conformance Statement\n   This Protocol Instantiation document, in conjunction\
    \ with the LCT\n   building block [11], the FEC building block [10] and with a\
    \ multiple\n   rate congestion control building block completely specifies a working\n\
    \   reliable multicast transport protocol that conforms to the\n   requirements\
    \ described in RFC 2357 [12].\n"
- title: 4.  Functionality Definition
  contents:
  - "4.  Functionality Definition\n   This section describes the format and functionality\
    \ of the data\n   packets carried in an ALC session as well as the sender and\
    \ receiver\n   operations for a session.\n"
- title: 4.1  Packet format used by ALC
  contents:
  - "4.1  Packet format used by ALC\n   The packet format used by ALC is the UDP header\
    \ followed by the\n   default LCT header followed by the FEC Payload ID followed\
    \ by the\n   packet payload.  The default LCT header is described in the LCT\n\
    \   building block [11] and the FEC Payload ID is described in the FEC\n   building\
    \ block [10].  The Congestion Control Information field in the\n   LCT header\
    \ contains the REQUIRED Congestion Control Information that\n   is described in\
    \ the multiple rate congestion control building block\n   used.  The packet payload\
    \ contains encoding symbols generated from an\n   object.  If more than one object\
    \ is carried in the session then the\n   Transmission Object ID (TOI) within the\
    \ LCT header MUST be used to\n   identify which object the encoding symbols are\
    \ generated from.\n   Within the scope of an object, encoding symbols carried\
    \ in the\n   payload of the packet are identified by the FEC Payload ID as\n \
    \  described in the FEC building block.\n   The version number of ALC specified\
    \ in this document is 1.  This\n   coincides with version 1 of the LCT building\
    \ block [11] used in this\n   specification.  The LCT version number field should\
    \ be interpreted as\n   the ALC version number field.\n   The overall ALC packet\
    \ format is depicted in Figure 1.  The packet is\n   an IP packet, either IPv4\
    \ or IPv6, and the IP header precedes the UDP\n   header.  The ALC packet format\
    \ has no dependencies on the IP version\n   number.  The default LCT header MUST\
    \ be used by ALC and this default\n   is described in detail in the LCT building\
    \ block [11].\n     0                   1                   2                \
    \   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |\
    \                         UDP header                            |\n    |     \
    \                                                          |\n    +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n\
    \    |                     Default LCT header                        |\n    |\
    \                                                               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                       FEC Payload ID                          |\n    |\
    \                                                               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                     Encoding Symbol(s)                        |\n    |\
    \                           ...                                 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                   Figure 1 - Overall ALC packet format\n   In some special cases\
    \ an ALC sender may need to produce ALC packets\n   that do not contain any payload.\
    \  This may be required, for example,\n   to signal the end of a session or to\
    \ convey congestion control\n   information.  These data-less packets do not contain\
    \ the FEC Payload\n   ID either, but only the LCT header fields.  The total datagram\n\
    \   length, conveyed by outer protocol headers (e.g., the IP or UDP\n   header),\
    \ enables receivers to detect the absence of the ALC payload\n   and FEC Payload\
    \ ID.\n"
- title: 4.2  Detailed Example of Packet format used by ALC
  contents:
  - "4.2  Detailed Example of Packet format used by ALC\n   A detailed example of\
    \ an ALC packet starting with the LCT header is\n   shown in Figure 2.  In the\
    \ example, the LCT header is the first 5\n   32-bit words, the FEC Payload ID\
    \ is the next 2 32-bit words, and the\n   remainder of the packet is the payload.\n\
    \     0                   1                   2                   3\n     0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |   1   | 0 | 0 |1| 1 |0|1|0|0|0|       5       |      128      |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |    Congestion Control Information (CCI, length = 32 bits)     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |  Transport Session Identifier (TSI, length = 32 bits)         |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |   Transport Object Identifier (TOI, length = 32 bits)         |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                    Sender Current Time                        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                    Source Block Number                        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                    Encoding Symbol ID                         |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                    Encoding Symbol(s)                         |\n    |\
    \                          ...                                  |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \          Figure 2 - A detailed example of the ALC packet format\n   The LCT\
    \ portion of the overall ALC packet header is of variable size,\n   which is specified\
    \ by a length field in the third byte of the header.\n   All integer fields are\
    \ carried in \"big-endian\" or \"network order\"\n   format, that is, most significant\
    \ byte (octet) first.  Bits\n   designated as \"padding\" or \"reserved\" (r)\
    \ MUST by set to 0 by senders\n   and ignored by receivers.  Unless otherwise\
    \ noted, numeric constants\n   in this specification are in decimal (base 10).\n\
    \   The function and length and particular setting of the value for each\n   field\
    \ in this detailed example of the header is the following,\n   described in the\
    \ order of their appearance in the header.\n     ALC version number (V): 4 bits\n\
    \         Indicates the ALC version number.\n         The ALC version number for\
    \ this specification is 1 as shown.\n         This is also the LCT version number.\n\
    \     Congestion control flag (C): 2 bits\n         The Congestion Control Information\
    \ (CCI) field specified by the\n         multiple rate congestion control building\
    \ block is a multiple\n         of 32-bits in length.  The multiple rate congestion\
    \ control\n         building block MUST specify a format for the CCI.  The\n \
    \        congestion control building block MAY specify formats for\n         different\
    \ CCI lengths, where the set of possible lengths is 32,\n         64, 96 or 128\
    \ bits.  The value of C MUST match the length of\n         exactly one of the\
    \ possible formats for the congestion control\n         building block, and this\
    \ format MUST be used for the CCI field.\n         The value of C MUST be the\
    \ same for all packets sent to a\n         session.\n         C=0 indicates the\
    \ 32-bit CCI field format is to be used.\n         C=1 indicates the 64-bit CCI\
    \ field format is to be used.\n         C=2 indicates the 96-bit CCI field format\
    \ is to be used.\n         C=3 indicates the 128-bit CCI field format is to be\
    \ used.\n         In the example C=0 indicates that a 32-bit format is to be\n\
    \         used.\n     Reserved (r): 2 bits\n         Reserved for future use.\
    \  A sender MUST set these bits to zero\n         and a receiver MUST ignore these\
    \ bits.\n         As required, these bits are set to 0 in the example.\n     Transport\
    \ Session Identifier flag (S): 1 bit\n         This is the number of full 32-bit\
    \ words in the TSI field.  The\n         TSI field is 32*S + 16*H bits in length.\
    \  For ALC the length of\n         the TSI field is REQUIRED to be non-zero. \
    \ This implies that\n         the setting S=0 and H=0 MUST NOT be used.\n    \
    \     In the example S=1 and H=0, and thus the TSI is 32-bits in\n         length.\n\
    \     Transport Object Identifier flag (O): 2 bits\n         This is the number\
    \ of full 32-bit words in the TOI field.  The\n         TOI field is 32*O + 16*H\
    \ bits in length.  If more than one\n         object is to be delivered in the\
    \ session then the TOI MUST be\n         used, in which case the setting O=0 and\
    \ H=0 MUST NOT be used.\n         In the example O=1 and H=0, and thus the TOI\
    \ is 32-bits in\n         length.\n     Half-word flag (H): 1 bit\n         The\
    \ TSI and the TOI fields are both multiples of 32-bits plus\n         16*H bits\
    \ in length.  This allows the TSI and TOI field lengths\n         to be multiples\
    \ of a half-word (16 bits), while ensuring that\n         the aggregate length\
    \ of the TSI and TOI fields is a multiple of\n         32-bits.\n         In the\
    \ example H=0 which indicates that both TSI and TOI are\n         both multiples\
    \ of 32-bits in length.\n     Sender Current Time present flag (T): 1 bit\n  \
    \       T = 0 indicates that the Sender Current Time (SCT) field is not\n    \
    \     present.\n         T = 1 indicates that the SCT field is present.  The SCT\
    \ is\n         inserted by senders to indicate to receivers how long the\n   \
    \      session has been in progress.\n         In the example T=1, which indicates\
    \ that the SCT is carried in\n         this packet.\n     Expected Residual Time\
    \ present flag (R): 1 bit\n         R = 0 indicates that the Expected Residual\
    \ Time (ERT) field is\n         not present.\n         R = 1 indicates that the\
    \ ERT field is present.\n         The ERT is inserted by senders to indicate to\
    \ receivers how\n         much longer packets will be sent to the session for\
    \ either the\n         single object carried in the session or for the object\n\
    \         identified by the TOI if there are multiple objects carried in\n   \
    \      the session.  Senders MUST NOT set R = 1 when the ERT for the\n       \
    \  object is more than 2^32-1 time units (approximately 49 days),\n         where\
    \ time is measured in units of milliseconds.\n         In the example R=0, which\
    \ indicates that the ERT is not carried\n         in this packet.\n     Close\
    \ Session flag (A): 1 bit\n         Normally, A is set to 0.  The sender MAY set\
    \ A to 1 when\n         termination of transmission of packets for the session\
    \ is\n         imminent.  A MAY be set to 1 in just the last packet\n        \
    \ transmitted for the session, or A MAY be set to 1 in the last\n         few\
    \ seconds of packets transmitted for the session.  Once the\n         sender sets\
    \ A to 1 in one packet, the sender SHOULD set A to 1\n         in all subsequent\
    \ packets until termination of transmission of\n         packets for the session.\
    \  A received packet with A set to 1\n         indicates to a receiver that the\
    \ sender will immediately stop\n         sending packets for the session.  When\
    \ a receiver receives a\n         packet with A set to 1 the receiver SHOULD assume\
    \ that no more\n         packets will be sent to the session.\n         In the\
    \ example A=0, and thus this packet does not indicate the\n         close of the\
    \ session.\n     Close Object flag (B): 1 bit\n         Normally, B is set to\
    \ 0.  The sender MAY set B to 1 when\n         termination of transmission of\
    \ packets for an object is\n         imminent.  If the TOI field is in use and\
    \ B is set to 1 then\n         termination of transmission for the object identified\
    \ by the\n         TOI field is imminent.  If the TOI field is not in use and\
    \ B is\n         set to 1 then termination of transmission for the one object\
    \ in\n         the session identified by out-of-band information is imminent.\n\
    \         B MAY be set to 1 in just the last packet transmitted for the\n    \
    \     object, or B MAY be set to 1 in the last few seconds packets\n         transmitted\
    \ for the object.  Once the sender sets B to 1 in one\n         packet for a particular\
    \ object, the sender SHOULD set B to 1 in\n         all subsequent packets for\
    \ the object until termination of\n         transmission of packets for the object.\
    \  A received packet with\n         B set to 1 indicates to a receiver that the\
    \ sender will\n         immediately stop sending packets for the object.  When\
    \ a\n         receiver receives a packet with B set to 1 then it SHOULD\n    \
    \     assume that no more packets will be sent for the object to the\n       \
    \  session.\n         In the example B=0, and thus this packet does not indicate\
    \ the\n         end of sending data packets for the object.\n     LCT header length\
    \ (HDR_LEN): 8 bits\n         Total length of the LCT header in units of 32-bit\
    \ words.  The\n         length of the LCT header MUST be a multiple of 32-bits.\
    \  This\n         field can be used to directly access the portion of the packet\n\
    \         beyond the LCT header, i.e., the FEC Payload ID if the packet\n    \
    \     contains a payload, or the end of the packet if the packet\n         contains\
    \ no payload.\n         In the example HDR_LEN=5 to indicate that the length of\
    \ the LCT\n         header portion of the overall ALC is 5 32-bit words.\n   \
    \  Codepoint (CP): 8 bits\n         This field is used by ALC to carry the mapping\
    \ that identifies\n         settings for portions of the Session Description that\
    \ can\n         change within the session.  The mapping between Codepoint\n  \
    \       values and the settings for portions of the Session Description\n    \
    \     is to be communicated out-of-band.\n         In the example the portion\
    \ of the Session Description that can\n         change within the session is the\
    \ FEC Encoding ID, and the\n         identity mapping is used between Codepoint\
    \ values and FEC\n         Encoding IDs.  Thus, CP=128 identifies FEC Encoding\
    \ ID 128, the\n         \"Small Block, Large Block and Expandable FEC Codes\"\
    \ as\n         described in the FEC building block [10].  The FEC Payload ID\n\
    \         associated with FEC Encoding ID 128 is 64-bits in length.\n     Congestion\
    \ Control Information (CCI): 32, 64, 96 or 128 bits\n         This is field contains\
    \ the Congestion Control Information as\n         defined by the specified multiple\
    \ rate congestion control\n         building block.  The format of this field\
    \ is determined by the\n         multiple rate congestion control building block.\n\
    \         This field MUST be 32 bits if C=0.\n         This field MUST be 64 bits\
    \ if C=1.\n         This field MUST be 96 bits if C=2.\n         This field MUST\
    \ be 128 bits if C=3.\n         In the example, the CCI is 32-bits in length.\
    \  The format of\n         the CCI field for the example MUST correspond to the\
    \ format for\n         the 32-bit version of the CCI specified in the multiple\
    \ rate\n         congestion control building block.\n     Transport Session Identifier\
    \ (TSI): 16, 32 or 48 bits\n         The TSI uniquely identifies a session among\
    \ all sessions from a\n         particular sender.  The TSI is scoped by the sender\
    \ IP address,\n         and thus the (sender IP address, TSI) pair uniquely identify\n\
    \         the session.  For ALC, the TSI MUST be included in the LCT\n       \
    \  header.\n         The TSI MUST be unique among all sessions served by the sender\n\
    \         during the period when the session is active, and for a large\n    \
    \     period of time preceding and following when the session is\n         active.\
    \  A primary purpose of the TSI is to prevent receivers\n         from inadvertently\
    \ accepting packets from a sender that belong\n         to sessions other than\
    \ sessions receivers are subscribed to.\n         For example, suppose a session\
    \ is deactivated and then another\n         session is activated by a sender and\
    \ the two sessions use an\n         overlapping set of channels.  A receiver that\
    \ connects and\n         remains connected to the first session during this sender\n\
    \         activity could possibly accept packets from the second session\n   \
    \      as belonging to the first session if the TSI for the two\n         sessions\
    \ were identical.  The mapping of TSI field values to\n         sessions is outside\
    \ the scope of this document and is to be\n         done out-of-band.\n      \
    \   The length of the TSI field is 32*S + 16*H bits.  Note that the\n        \
    \ aggregate lengths of the TSI field plus the TOI field is a\n         multiple\
    \ of 32 bits.\n         In the example the TSI is 32 bits in length.\n     Transport\
    \ Object Identifier (TOI): 0, 16, 32, 48, 64, 80, 96 or 112\n     bits.\n    \
    \     This field indicates which object within the session this\n         packet\
    \ pertains to.  For example, a sender might send a number\n         of files in\
    \ the same session, using TOI=0 for the first file,\n         TOI=1 for the second\
    \ one, etc.  As another example, the TOI may\n         be a unique global identifier\
    \ of the object that is being\n         transmitted from several senders concurrently,\
    \ and the TOI\n         value may be the output of a hash function applied to\
    \ the\n         object.  The mapping of TOI field values to objects is outside\n\
    \         the scope of this document and is to be done out-of-band.  The\n   \
    \      TOI field MUST be used in all packets if more than one object\n       \
    \  is to be transmitted in a session, i.e., the TOI field is\n         either\
    \ present in all the packets of a session or is never\n         present.\n   \
    \      The length of the TOI field is 32*O + 16*H bits.  Note that the\n     \
    \    aggregate lengths of the TSI field plus the TOI field is a\n         multiple\
    \ of 32 bits.\n         In the example the TOI is 32 bits in length.\n     Sender\
    \ Current Time (SCT): 0 or 32 bits\n         This field represents the current\
    \ clock of the sender at the\n         time this packet was transmitted, measured\
    \ in units of 1ms and\n         computed modulo 2^32 units from the start of the\
    \ session.\n         This field MUST NOT be present if T=0 and MUST be present\
    \ if\n         T=1.\n         In this example the SCT is present.\n     Expected\
    \ Residual Time (ERT): 0 or 32 bits\n         This field represents the sender\
    \ expected residual transmission\n         time of packets for either the single\
    \ object carried in the\n         session or for the object identified by the\
    \ TOI if there are\n         multiple objects carried in the session.\n      \
    \   This field MUST NOT be present if R=0 and MUST be present if\n         R=1.\n\
    \         In this example the ERT is not present.\n     FEC Payload ID: X bits\n\
    \         The length and format of the FEC Payload ID depends on the FEC\n   \
    \      Encoding ID as described in the FEC building block [10].  The\n       \
    \  FEC Payload ID format is determined by the FEC Encoding ID that\n         MUST\
    \ be communicated in the Session Description.  The Session\n         Description\
    \ MAY specify that more than one FEC Encoding ID is\n         used in the session,\
    \ in which case the Session Description MUST\n         contain a mapping that\
    \ identifies which Codepoint values\n         correspond to which FEC Encoding\
    \ IDs.  This mapping, if used,\n         is outside the scope of this document.\n\
    \         The example packet format corresponds to the format for \"Small\n  \
    \       Block, Large Block and Expandable FEC Codes\" as described in\n      \
    \   the FEC building block, for which the associated FEC Encoding\n         ID\
    \ 128.  For FEC Encoding ID 128, the FEC Payload ID consists\n         of the\
    \ following two fields that in total are X = 64 bits in\n         length:\n  \
    \       Source Block Number (SBN): 32 bits\n            The Source Block Number\
    \ identifies from which source block\n            of the object the encoding symbol(s)\
    \ in the payload are\n            generated.  These blocks are numbered consecutively\
    \ from\n            0 to N-1, where N is the number of source blocks in the\n\
    \            object.\n         Encoding Symbol ID (ESI): 32 bits\n           \
    \ The Encoding Symbol ID identifies which specific encoding\n            symbol(s)\
    \ generated from the source block are carried in the\n            packet payload.\
    \  The exact details of the correspondence\n            between Encoding Symbol\
    \ IDs and the encoding symbol(s) in\n            the packet payload are dependent\
    \ on the particular encoding\n            algorithm used as identified by the\
    \ FEC Encoding ID and by\n            the FEC Instance ID.\n   Encoding Symbol(s):\
    \ Y bits\n         The encoding symbols are what the receiver uses to reconstruct\n\
    \         an object.  The total length Y of the encoding symbol(s) in the\n  \
    \       packet can be determined by the receiver of the packet by\n         computing\
    \ the total length of the received packet and\n         subtracting off the length\
    \ of the headers.\n"
- title: 4.3  Header-Extension Fields
  contents:
  - "4.3  Header-Extension Fields\n   Header Extensions can be used to extend the\
    \ LCT header portion of the\n   ALC header to accommodate optional header fields\
    \ that are not always\n   used or have variable size.  Header Extensions are not\
    \ used in the\n   example ALC packet format shown in the previous subsection.\
    \  Examples\n   of the use of Header Extensions include:\n     o Extended-size\
    \ versions of already existing header fields.\n     o Sender and Receiver authentication\
    \ information.\n   The presence of Header Extensions can be inferred by the LCT\
    \ header\n   length (HDR_LEN): if HDR_LEN is larger than the length of the\n \
    \  standard header then the remaining header space is taken by Header\n   Extension\
    \ fields.\n   If present, Header Extensions MUST be processed to ensure that they\n\
    \   are recognized before performing any congestion control procedure or\n   otherwise\
    \ accepting a packet.  The default action for unrecognized\n   Header Extensions\
    \ is to ignore them.  This allows the future\n   introduction of backward-compatible\
    \ enhancements to ALC without\n   changing the ALC version number.  Non backward-compatible\
    \ Header\n   Extensions CANNOT be introduced without changing the ALC version\n\
    \   number.\n   There are two formats for Header Extension fields, as depicted\
    \ below.\n   The first format is used for variable-length extensions, with Header\n\
    \   Extension Type (HET) values between 0 and 127.  The second format is\n   used\
    \ for fixed length (one 32-bit word) extensions, using HET values\n   from 127\
    \ to 255.\n     0                   1                   2                   3\n\
    \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |  HET (<=127)  |       HEL     |                               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n    .                                     \
    \                          .\n    .              Header Extension Content (HEC)\
    \                   .\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     0                   1                   2                   3\n     0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |  HET (>=128)  |       Header Extension Content (HEC)          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                  Figure 3 - Format of additional headers\n   The explanation\
    \ of each sub-field is the following.\n     Header Extension Type (HET): 8 bits\n\
    \         The type of the Header Extension.  This document defines a\n       \
    \  number of possible types.  Additional types may be defined in\n         future\
    \ versions of this specification.  HET values from 0 to\n         127 are used\
    \ for variable-length Header Extensions.  HET values\n         from 128 to 255\
    \ are used for fixed-length 32-bit Header\n         Extensions.\n     Header Extension\
    \ Length (HEL): 8 bits\n         The length of the whole Header Extension field,\
    \ expressed in\n         multiples of 32-bit words.  This field MUST be present\
    \ for\n         variable-length extensions (HET between 0 and 127) and MUST NOT\n\
    \         be present for fixed-length extensions (HET between 128 and\n      \
    \   255).\n     Header Extension Content (HEC): variable length\n         The\
    \ content of the Header Extension.  The format of this sub-\n         field depends\
    \ on the Header Extension type.  For fixed-length\n         Header Extensions,\
    \ the HEC is 24 bits.  For variable-length\n         Header Extensions, the HEC\
    \ field has variable size, as\n         specified by the HEL field.  Note that\
    \ the length of each\n         Header Extension field MUST be a multiple of 32\
    \ bits.  Also\n         note that the total size of the LCT header, including\
    \ all\n         Header Extensions and all optional header fields, cannot exceed\n\
    \         255 32-bit words.\n   Header Extensions are further divided between\
    \ general LCT extensions\n   and Protocol Instantiation specific extensions (PI-specific).\n\
    \   General LCT extensions have HET in the ranges 0:63 and 128:191\n   inclusive.\
    \  PI-specific extensions have HET in the ranges 64:127 and\n   192:255 inclusive.\n\
    \   General LCT extensions are intended to allow the introduction of\n   backward-compatible\
    \ enhancements to LCT without changing the LCT\n   version number.  Non backward-compatible\
    \ Header Extensions CANNOT be\n   introduced without changing the LCT version\
    \ number.\n   PI-specific extensions are reserved for PI-specific use with semantic\n\
    \   and default parsing actions defined by the PI.\n   The following general LCT\
    \ Header Extension types are defined:\n   EXT_NOP=0     No-Operation extension.\n\
    \                 The information present in this extension field MUST be\n  \
    \               ignored by receivers.\n   EXT_AUTH=1    Packet authentication\
    \ extension\n                 Information used to authenticate the sender of the\n\
    \                 packet.  The format of this Header Extension and its\n     \
    \            processing is outside the scope of this document and is\n       \
    \          to be communicated out-of-band as part of the Session\n           \
    \      Description.\n                 It is RECOMMENDED that senders provide some\
    \ form of\n                 packet authentication.  If EXT_AUTH is present,\n\
    \                 whatever packet authentication checks that can be\n        \
    \         performed immediately upon reception of the packet\n               \
    \  SHOULD be performed before accepting the packet and\n                 performing\
    \ any congestion control-related action on it.\n                 Some packet authentication\
    \ schemes impose a delay of\n                 several seconds between when a packet\
    \ is received and\n                 when the packet is fully authenticated.  Any\
    \ congestion\n                 control related action that is appropriate MUST\
    \ NOT be\n                 postponed by any such full packet authentication.\n\
    \   All senders and receivers implementing ALC MUST support the EXT_NOP\n   Header\
    \ Extension and MUST recognize EXT_AUTH, but MAY NOT be able to\n   parse its\
    \ content.\n   For this version of ALC, the following PI-specific extension is\n\
    \   defined:\n   EXT_FTI=64    FEC Object Transmission Information extension\n\
    \                 The purpose of this extension is to carry in-band the\n    \
    \             FEC Object Transmission Information for an object.  The\n      \
    \           format of this Header Extension and its processing is\n          \
    \       outside the scope of this document and is to be\n                 communicated\
    \ out-of-band as part of the Session\n                 Description.\n"
- title: 4.4  Sender Operation
  contents:
  - "4.4  Sender Operation\n   The sender operation when using ALC includes all the\
    \ points made\n   about the sender operation when using the LCT building block\
    \ [11],\n   the FEC building block [10] and the multiple rate congestion control\n\
    \   building block.\n   A sender using ALC MUST make available the required Session\n\
    \   Description as described in Section 2.4.  A sender also MUST make\n   available\
    \ the required FEC Object Transmission Information as\n   described in Section\
    \ 2.3.\n   Within a session a sender transmits a sequence of packets to the\n\
    \   channels associated with the session.  The ALC sender MUST obey the\n   rules\
    \ for filling in the CCI field in the packet headers and MUST\n   send packets\
    \ at the appropriate rates to the channels associated with\n   the session as\
    \ dictated by the multiple rate congestion control\n   building block.\n   The\
    \ ALC sender MUST use the same TSI for all packets in the session.\n   Several\
    \ objects MAY be delivered within the same ALC session.  If\n   more than one\
    \ object is to be delivered within a session then the\n   sender MUST use the\
    \ TOI field and each object MUST be identified by a\n   unique TOI within the\
    \ session, and the sender MUST use corresponding\n   TOI for all packets pertaining\
    \ to the same object.  The FEC Payload\n   ID MUST correspond to the encoding\
    \ symbol(s) for the object carried\n   in the payload of the packet.\n   Objects\
    \ MAY be transmitted sequentially within a session, and they\n   MAY be transmitted\
    \ concurrently.  However, it is good practice to\n   only send objects concurrently\
    \ in the same session if the receivers\n   that participate in that portion of\
    \ the session have interest in\n   receiving all the objects.  The reason for\
    \ this is that it wastes\n   bandwidth and networking resources to have receivers\
    \ receive data for\n   objects that they have no interest in.  However, there\
    \ are no rules\n   with respect to mixing packets for different objects carried\
    \ within\n   the session.  Although this issue affects the efficiency of the\n\
    \   protocol, it does not affect the correctness nor the inter-\n   operability\
    \ of ALC between senders and receivers.\n   Typically, the sender(s) continues\
    \ to send packets in a session until\n   the transmission is considered complete.\
    \  The transmission may be\n   considered complete when some time has expired,\
    \ a certain number of\n   packets have been sent, or some out-of-band signal (possibly\
    \ from a\n   higher level protocol) has indicated completion by a sufficient\n\
    \   number of receivers.\n   It is RECOMMENDED that packet authentication be used.\
    \  If packet\n   authentication is used then the Header Extensions described in\n\
    \   Section 4.3 MUST be used to carry the authentication.\n   This document does\
    \ not pose any restriction on packet sizes.\n   However, network efficiency considerations\
    \ recommend that the sender\n   uses as large as possible packet payload size,\
    \ but in such a way that\n   packets do not exceed the network's maximum transmission\
    \ unit size\n   (MTU), or fragmentation coupled with packet loss might introduce\n\
    \   severe inefficiency in the transmission.  It is RECOMMENDED that all\n   packets\
    \ have the same or very similar sizes, as this can have a\n   severe impact on\
    \ the effectiveness of the multiple rate congestion\n   control building block.\n"
- title: 4.5  Receiver Operation
  contents:
  - "4.5  Receiver Operation\n   The receiver operation when using ALC includes all\
    \ the points made\n   about the receiver operation when using the LCT building\
    \ block [11],\n   the FEC building block [10] and the multiple rate congestion\
    \ control\n   building block.\n   To be able to participate in a session, a receiver\
    \ MUST obtain the\n   REQUIRED Session Description as listed in Section 2.4. \
    \ How receivers\n   obtain a Session Description is outside the scope of this\
    \ document.\n   To be able to be a receiver in a session, the receiver MUST be\
    \ able\n   to process the ALC header.  The receiver MUST be able to discard,\n\
    \   forward, store or process the other headers and the packet payload.\n   If\
    \ a receiver is not able to process the ALC header, it MUST drop\n   from the\
    \ session.\n   To be able to participate in a session, a receiver MUST implement\
    \ the\n   multiple rate congestion control building block using the Congestion\n\
    \   Control Information field provided in the LCT header.  If a receiver\n   is\
    \ not able to implement the multiple rate congestion control\n   building block\
    \ it MUST NOT join the session.\n   Several objects can be carried either sequentially\
    \ or concurrently\n   within the same session.  In this case, each object is identified\
    \ by\n   a unique TOI.  Note that even if a sender stops sending packets for\n\
    \   an old object before starting to transmit packets for a new object,\n   both\
    \ the network and the underlying protocol layers can cause some\n   reordering\
    \ of packets, especially when sent over different channels,\n   and thus receivers\
    \ SHOULD NOT assume that the reception of a packet\n   for a new object means\
    \ that there are no more packets in transit for\n   the previous one, at least\
    \ for some amount of time.\n   As described in Section 2.3, a receiver MUST obtain\
    \ the required FEC\n   Object Transmission Information for each object for which\
    \ the\n   receiver receives and processes packets.\n   A receiver MAY concurrently\
    \ join multiple ALC sessions from one or\n   more senders.  The receiver MUST\
    \ perform congestion control on each\n   such session.  The receiver MAY make\
    \ choices to optimize the packet\n   flow performance across multiple sessions,\
    \ as long as the receiver\n   still adheres to the multiple rate congestion control\
    \ building block\n   for each session individually.\n   Upon receipt of each packet\
    \ the receiver proceeds with the following\n   steps in the order listed.\n  \
    \ (1) The receiver MUST parse the packet header and verify that it is a\n    \
    \   valid header.  If it is not valid then the packet MUST be\n       discarded\
    \ without further processing.  If multiple packets are\n       received that cannot\
    \ be parsed then the receiver SHOULD leave the\n       session.\n   (2) The receiver\
    \ MUST verify that the sender IP address together with\n       the TSI carried\
    \ in the header matches one of the (sender IP\n       address, TSI) pairs that\
    \ was received in a Session Description\n       and that the receiver is currently\
    \ joined to.  If there is not a\n       match then the packet MUST be discarded\
    \ without further\n       processing.  If multiple packets are received with non-matching\n\
    \       (sender IP address, TSI) values then the receiver SHOULD leave\n     \
    \  the session.  If the receiver is joined to multiple ALC sessions\n       then\
    \ the remainder of the steps are performed within the scope of\n       the (sender\
    \ IP address, TSI) session of the received packet.\n   (3) The receiver MUST process\
    \ and act on the CCI field in accordance\n       with the multiple rate congestion\
    \ control building block.\n   (4) If more than one object is carried in the session,\
    \ the receiver\n       MUST verify that the TOI carried in the LCT header is valid.\
    \  If\n       the TOI is not valid, the packet MUST be discarded without\n   \
    \    further processing.\n   (5) The receiver SHOULD process the remainder of\
    \ the packet,\n       including interpreting the other header fields appropriately,\
    \ and\n       using the FEC Payload ID and the encoding symbol(s) in the\n   \
    \    payload to reconstruct the corresponding object.\n   It is RECOMMENDED that\
    \ packet authentication be used.  If packet\n   authentication is used then it\
    \ is RECOMMENDED that the receiver\n   immediately check the authenticity of a\
    \ packet before proceeding with\n   step (3) above.  If immediate checking is\
    \ possible and if the packet\n   fails the check then the receiver MUST discard\
    \ the packet and reduce\n   its reception rate to a minimum before continuing\
    \ to regulate its\n   reception rate using the multiple rate congestion control.\n\
    \   Some packet authentication schemes such as TESLA [14] do not allow an\n  \
    \ immediate authenticity check.  In this case the receiver SHOULD check\n   the\
    \ authenticity of a packet as soon as possible, and if the packet\n   fails the\
    \ check then it MUST be discarded before step (5) above and\n   reduce its reception\
    \ rate to a minimum before continuing to regulate\n   its reception rate using\
    \ the multiple rate congestion control.\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   The same security consideration that apply to\
    \ the LCT, FEC and the\n   multiple rate congestion control building blocks also\
    \ apply to ALC.\n   Because of the use of FEC, ALC is especially vulnerable to\
    \ denial-\n   of-service attacks by attackers that try to send forged packets\
    \ to\n   the session which would prevent successful reconstruction or cause\n\
    \   inaccurate reconstruction of large portions of the object by\n   receivers.\
    \  ALC is also particularly affected by such an attack\n   because many receivers\
    \ may receive the same forged packet.  There are\n   two ways to protect against\
    \ such attacks, one at the application\n   level and one at the packet level.\
    \  It is RECOMMENDED that prevention\n   be provided at both levels.\n   At the\
    \ application level, it is RECOMMENDED that an integrity check\n   on the entire\
    \ received object be done once the object is\n   reconstructed to ensure it is\
    \ the same as the sent object.  Moreover,\n   in order to obtain strong cryptographic\
    \ integrity protection a\n   digital signature verifiable by the receiver SHOULD\
    \ be used to\n   provide this application level integrity check.  However, if\
    \ even one\n   corrupted or forged packet is used to reconstruct the object, it\
    \ is\n   likely that the received object will be reconstructed incorrectly.\n\
    \   This will appropriately cause the integrity check to fail and in this\n  \
    \ case the inaccurately reconstructed object SHOULD be discarded.\n   Thus, the\
    \ acceptance of a single forged packet can be an effective\n   denial of service\
    \ attack for distributing objects, but an object\n   integrity check at least\
    \ prevents inadvertent use of inaccurately\n   reconstructed objects.  The specification\
    \ of an application level\n   integrity check of the received object is outside\
    \ the scope of this\n   document.\n   At the packet level, it is RECOMMENDED that\
    \ a packet level\n   authentication be used to ensure that each received packet\
    \ is an\n   authentic and uncorrupted packet containing FEC data for the object\n\
    \   arriving from the specified sender.  Packet level authentication has\n   the\
    \ advantage that corrupt or forged packets can be discarded\n   individually and\
    \ the received authenticated packets can be used to\n   accurately reconstruct\
    \ the object.  Thus, the effect of a denial of\n   service attack that injects\
    \ forged packets is proportional only to\n   the number of forged packets, and\
    \ not to the object size.  Although\n   there is currently no IETF standard that\
    \ specifies how to do\n   multicast packet level authentication, TESLA [14] is\
    \ a known\n   multicast packet authentication scheme that would work.\n   In addition\
    \ to providing protection against reconstruction of\n   inaccurate objects, packet\
    \ level authentication can also provide some\n   protection against denial of\
    \ service attacks on the multiple rate\n   congestion control.  Attackers can\
    \ try to inject forged packets with\n   incorrect congestion control information\
    \ into the multicast stream,\n   thereby potentially adversely affecting network\
    \ elements and\n   receivers downstream of the attack, and much less significantly\
    \ the\n   rest of the network and other receivers.  Thus, it is also\n   RECOMMENDED\
    \ that packet level authentication be used to protect\n   against such attacks.\
    \  TESLA [14] can also be used to some extent to\n   limit the damage caused by\
    \ such attacks.  However, with TESLA a\n   receiver can only determine if a packet\
    \ is authentic several seconds\n   after it is received, and thus an attack against\
    \ the congestion\n   control protocol can be effective for several seconds before\
    \ the\n   receiver can react to slow down the session reception rate.\n   Reverse\
    \ Path Forwarding checks SHOULD be enabled in all network\n   routers and switches\
    \ along the path from the sender to receivers to\n   limit the possibility of\
    \ a bad agent injecting forged packets into\n   the multicast tree data path.\n\
    \   A receiver with an incorrect or corrupted implementation of the\n   multiple\
    \ rate congestion control building block may affect health of\n   the network\
    \ in the path between the sender and the receiver, and may\n   also affect the\
    \ reception rates of other receivers joined to the\n   session.  It is therefore\
    \ RECOMMENDED that receivers be required to\n   identify themselves as legitimate\
    \ before they receive the Session\n   Description needed to join the session.\
    \  How receivers identify\n   themselves as legitimate is outside the scope of\
    \ this document.\n   Another vulnerability of ALC is the potential of receivers\
    \ obtaining\n   an incorrect Session Description for the session.  The consequences\n\
    \   of this could be that legitimate receivers with the wrong Session\n   Description\
    \ are unable to correctly receive the session content, or\n   that receivers inadvertently\
    \ try to receive at a much higher rate\n   than they are capable of, thereby disrupting\
    \ traffic in portions of\n   the network.  To avoid these problems, it is RECOMMENDED\
    \ that\n   measures be taken to prevent receivers from accepting incorrect\n \
    \  Session Descriptions, e.g., by using source authentication to ensure\n   that\
    \ receivers only accept legitimate Session Descriptions from\n   authorized senders.\
    \  How this is done is outside the scope of this\n   document.\n"
- title: 6.  IANA Considerations
  contents:
  - "6.  IANA Considerations\n   No information in this specification is directly\
    \ subject to IANA\n   registration.  However, building blocks components used\
    \ by ALC may\n   introduce additional IANA considerations.  In particular, the\
    \ FEC\n   building block used by ALC does require IANA registration of the FEC\n\
    \   codecs used.\n"
- title: 7.  Intellectual Property Issues
  contents:
  - "7.  Intellectual Property Issues\n   The IETF has been notified of intellectual\
    \ property rights claimed in\n   regard to some or all of the specification contained\
    \ in this\n   document.  For more information consult the online list of claimed\n\
    \   rights.\n"
- title: 8.  Acknowledgments
  contents:
  - "8.  Acknowledgments\n   Thanks to Vincent Roca, Justin Chapweske and Roger Kermode\
    \ for their\n   detailed comments on this document.\n"
- title: 9.  References
  contents:
  - "9.  References\n   [1]  Bradner, S., \"The Internet Standards Process -- Revision\
    \ 3\", BCP\n        9, RFC 2026, October 1996.\n   [2]  Bradner, S., \"Key words\
    \ for use in RFCs to Indicate Requirement\n        Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [3]  Deering, S., \"Host Extensions for IP Multicasting\", STD\
    \ 5, RFC\n        1112, August 1989.\n   [4]  Fielding, R., Gettys, J., Mogul,\
    \ J., Frystyk, H. and T.\n        Berners-Lee, \"Hypertext Transfer Protocol --\
    \ HTTP/1.1\", RFC\n        2616, January 1997.\n   [5]  Handley, M. and V. Jacobson,\
    \ \"SDP: Session Description\n        Protocol\", RFC 2327, April 1998.\n   [6]\
    \  Handley, M., Perkins, C. and E. Whelan, \"Session Announcement\n        Protocol\"\
    , RFC 2974, October 2000.\n   [7]  Holbrook, H. W., \"A Channel Model for Multicast\"\
    , Ph.D.\n        Dissertation, Stanford University, Department of Computer\n \
    \       Science, Stanford, California, August 2001.\n   [8]  Kermode, R., Vicisano,\
    \ L., \"Author Guidelines for Reliable\n        Multicast Transport (RMT) Building\
    \ Blocks and Protocol\n        Instantiation documents\", RFC 3269, April 2002.\n\
    \   [9]  Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M.  and\n  \
    \      J. Crowcroft, \"The Use of Forward Error Correction (FEC) in\n        Reliable\
    \ Multicast\", RFC 3453, December 2002.\n   [10] Luby, M., Vicisano, L., Gemmell,\
    \ J., Rizzo, L., Handley, M., and\n        J.  Crowcroft, \"Forward Error Correction\
    \ (FEC) Building Block\",\n        RFC 3452, December 2002.\n   [11] Luby, M.,\
    \ Gemmell, J., Vicisano, L., Rizzo, L., Handley, M. and\n        J.  Crowcroft,\
    \ \"Layered Coding Transport (LCT) Building Block\",\n        RFC 3451 December\
    \ 2002.\n   [12] Mankin, A., Romanow, A., Bradner, S. and V. Paxson, \"IETF\n\
    \        Criteria for Evaluating Reliable Multicast Transport and\n        Application\
    \ Protocols\", RFC 2357, June 1998.\n   [13] Murata, M., St.Laurent, S. and D.\
    \ Kohn, \"XML Media Types\", RFC\n        3023, January 2001.\n   [14] Perrig,\
    \ A., Canetti, R., Song, D. and J.D. Tygar, \"Efficient and\n        Secure Source\
    \ Authentication for Multicast\", Network and\n        Distributed System Security\
    \ Symposium, NDSS 2001, pp. 35-46,\n        February 2001.\n   [15] Postel, J.,\
    \ \"User Datagram Protocol\", STD 6, RFC 768, August\n        1980.\n   [16] Whetten,\
    \ B., Vicisano, L., Kermode, R., Handley, M., Floyd, S.\n        and M. Luby,\
    \ \"Reliable Multicast Transport Building Blocks for\n        One-to-Many Bulk-Data\
    \ Transfer\", RFC 3048, January 2001.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Michael Luby\n   Digital Fountain\n   39141 Civic Center\
    \ Dr.\n   Suite 300\n   Fremont, CA, USA, 94538\n   EMail: luby@digitalfountain.com\n\
    \   Jim Gemmell\n   Microsoft Research\n   455 Market St. #1690\n   San Francisco,\
    \ CA, 94105\n   EMail: jgemmell@microsoft.com\n   Lorenzo Vicisano\n   cisco Systems,\
    \ Inc.\n   170 West Tasman Dr.\n   San Jose, CA, USA, 95134\n   EMail: lorenzo@cisco.com\n\
    \   Luigi Rizzo\n   Dip. Ing. dell'Informazione,\n   Univ. di Pisa\n   via Diotisalvi\
    \ 2, 56126 Pisa, Italy\n   EMail: luigi@iet.unipi.it\n   Jon Crowcroft\n   Marconi\
    \ Professor of Communications Systems\n   University of Cambridge\n   Computer\
    \ Laboratory\n   William Gates Building\n   J J Thomson Avenue\n   Cambridge CB3\
    \ 0FD, UK\n   EMail: Jon.Crowcroft@cl.cam.ac.uk\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2002).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
