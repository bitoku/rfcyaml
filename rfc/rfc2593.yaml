- title: __initial_text__
  contents:
  - '             Script MIB Extensibility Protocol Version 1.0

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   The IETF Script MIB defines an interface for the delegation of\n\
    \   management functions based on the Internet management framework. A\n   management\
    \ script is a set of instructions that are executed by a\n   language specific\
    \ runtime system. The Script MIB extensibility\n   protocol (SMX) defined in this\
    \ memo separates language specific\n   runtime systems from language independent\
    \ Script MIB implementations.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   6.2 SMX Message Processing on the SNMP Agent ...................\
    \   13\n   6.2.1 Creating a Runtime System ................................  \
    \ 13\n   6.2.2 Generating the `hello' Command ...........................   13\n\
    \   6.2.3 Generating the `start' Command ...........................   14\n  \
    \ 6.2.4 Generating the `suspend' Command .........................   15\n   6.2.5\
    \ Generating the `resume' Command ..........................   16\n   6.2.6 Generating\
    \ the `abort' Command ...........................   16\n   6.2.7 Generating the\
    \ `status' Command ..........................   17\n   6.2.8 Processing Asynchronous\
    \ Notifications ....................   18\n   7. An Example SMX Message Flow .................................\
    \   19\n   8. Security Considerations .....................................  \
    \ 19\n   9. Acknowledgments .............................................   20\n\
    \   10. References .................................................   20\n  \
    \ 11. Authors' Addresses .........................................   21\n   12.\
    \ Full Copyright Statement ...................................   22\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Script MIB [1] defines a standard interface for the\
    \ delegation of\n   management functions based on the Internet management framework.\
    \ In\n   particular, it provides the following capabilities:\n   1.   Transfer\
    \ of management scripts to a distributed manager.\n   2.   Initiating, suspending,\
    \ resuming and terminating management\n        scripts.\n   3.   Transfer of arguments\
    \ for management scripts.\n   4.   Monitoring and control of running management\
    \ scripts.\n   5.   Transfer of results produced by management scripts.\n   A\
    \ management script is a set of instructions executed by a language\n   specific\
    \ runtime system. The Script MIB does not prescribe a specific\n   language. Instead,\
    \ it allows to control scripts written in different\n   languages that are executing\
    \ concurrently.\n   The Script MIB Extensibility protocol (SMX) defined in this\
    \ memo can\n   be used to separate language specific runtime systems from the\n\
    \   runtime system independent Script MIB implementations. The\n   lightweight\
    \ SMX protocol can be used to support different runtime\n   systems without any\
    \ changes to the language neutral part of a Script\n   MIB implementation.\n \
    \  Examples of languages and runtime systems considered during the\n   design\
    \ of the SMX protocol are the Java virtual machine [2] and the\n   Tool Command\
    \ Language (Tcl) [3]. Other languages with comparable\n   features should be easy\
    \ to integrate as well.\n"
- title: 2.  Process Model and Communication Model
  contents:
  - "2.  Process Model and Communication Model\n   Figure 1 shows the process and\
    \ communication model underlying the SMX\n   protocol. The language and runtime\
    \ system independent SNMP agent\n   implementing the Script MIB communicates with\
    \ one ore more runtime\n   systems via the SMX protocol. A runtime system may\
    \ be able to execute\n   one or multiple scripts simultaneously (multi-threading).\
    \ The SMX\n   protocol supports multi-threading, but it does not require multi-\n\
    \   threaded runtime systems.\n   The SMX protocol uses a local storage device\
    \ (usually implemented on\n   top of the local file system) to transfer scripts\
    \ from the SNMP agent\n   to the runtime systems. The SNMP agent has read and\
    \ write access to\n   the script storage device while the runtime systems only\
    \ need read\n   access. The SMX protocol passes the location of a script in the\
    \ local\n   storage device to the runtime engines. It is then the responsibility\n\
    \   of the runtime engines to load the script from the specified\n   location.\n\
    \                                                    runtime 1\n             \
    \      +--------------+       SMX      +---------+\n                   |     \
    \         |<-------------->| O  O  O |<-+\n           SNMP    |  Script MIB  |\
    \                +---------+  |\n       <---------->|              |         \
    \                    |\n                   |  SNMP Agent  |                 runtime\
    \ 2   |\n                   |              |       SMX      +---------+  |\n \
    \                  |              |<-------------->| O       |  |\n          \
    \         +--------------+                +---------+  |\n                   \
    \        ^                            ^       |\n                           |\
    \       +---------+          |       |\n                           |       | script\
    \  |----------+       |\n                           +------>| storage |------------------+\n\
    \                                   +---------+\n           Figure 1: SMX process\
    \ and communication model\n"
- title: 3.  Security Profiles
  contents:
  - "3.  Security Profiles\n   Security profiles control what a running script is\
    \ allowed to do. It\n   is useful to distinguish two different classes of security\
    \ profiles:\n   -    The operating system security profile specifies the set of\n\
    \        operating system services that can be used by the operating\n       \
    \ system level process which executes a script. Under UNIX, this\n        maps\
    \ to the effective user and group identity for the running\n        process. In\
    \ addition, many UNIX versions allow to set other\n        resource limits, such\
    \ as the number of open files or the maximum\n        stack sizes. Another mechanism\
    \ in UNIX is the chroot() system\n        call which changes the file system root\
    \ for a process. The\n        chroot() mechanism can be used to prevent runtime\
    \ systems from\n        accessing any system files. It is suggested to make use\
    \ of all\n        applicable operating system security mechanism in order to\n\
    \        protect the operating system from malicious scripts or runtime\n    \
    \    systems.\n   -    Secure runtime systems provide fine grained control over\
    \ the set\n        of services that can be used by a running script at a particular\n\
    \        point during script execution. A runtime security profile\n        specifying\
    \ fine grained access control is runtime system\n        dependent. For a Java\
    \ virtual machine, the runtime security\n        profile is interpreted by the\
    \ SecurityManager and ClassLoader\n        classes[4]. For Tcl, the runtime security\
    \ profile maps to the\n        interpreter's security profile [5].\n   The SMX\
    \ protocol allows to execute scripts under different operating\n   system profiles\
    \ and runtime system profiles. Multiple operating\n   system security profiles\
    \ are realized by using multiple runtime\n   systems which execute in operating\
    \ system processes with different\n   security profiles.  Multiple runtime security\
    \ profiles are supported\n   by passing a security profile name to a runtime system\
    \ during script\n   invocation.\n   The Script MIB does not define how operating\
    \ system or runtime system\n   security profiles are identified. This memo suggests\
    \ that the\n   smLaunchOwner is mapped to an operating system security profile\
    \ and a\n   runtime system security profile when a script is started.\n"
- title: 4.  Start of Runtime Systems and Connection Establishment
  contents:
  - "4.  Start of Runtime Systems and Connection Establishment\n   The SNMP agent\
    \ starts runtime systems based on the static properties\n   of the runtime system\
    \ (multi-threaded or single-threaded) and the\n   operating system security profiles.\
    \ Starting a new runtime system\n   requires to create a process environment which\
    \ matches the operating\n   system security profile.\n   The SNMP agent initially\
    \ passes information to the runtime system by\n   means of environment variables.\
    \ The information is needed to\n   establish a trusted communication channel between\
    \ the SNMP agent and\n   a runtime system.\n   The SNMP agent first creates a\
    \ listening TCP socket which accepts\n   connections from runtime systems. It\
    \ is the responsibility of the\n   runtime system to establish a connection to\
    \ this TCP socket once it\n   has been started. The port number of the listening\
    \ TCP socket is\n   passed from the SNMP agent to the runtime system in the environment\n\
    \   variable SMX_PORT.\n   The SNMP agent must ensure that only authorized runtime\
    \ systems\n   establish a connection to the listening TCP socket. The following\n\
    \   rules are used for this purpose:\n   -    The TCP connection must originate\
    \ from the local host.\n   -    The SNMP agent queries the runtime system for\
    \ a security cookie\n        and closes the TCP connection if no valid response\
    \ is received\n        within a given time interval. The security cookie is a\
    \ random\n        number generated by the SNMP agent and passed to the runtime\n\
    \        system as part of its environment. The cookie is found in the\n     \
    \   environment variable SMX_COOKIE.\n   The security assumption here is that\
    \ access to the process\n   environment is protected by the operating system.\n\
    \   Alternate transports (e.g. UNIX domain sockets) are possible but not\n   defined\
    \ at this point in time. The reason to choose TCP as the\n   transport protocol\
    \ for SMX was that TCP is supported by all potential\n   runtime systems, while\
    \ other transports are not universally\n   available.\n"
- title: 5.  SMX Messages
  contents:
  - "5.  SMX Messages\n   The message formats described below are defined using the\
    \ Augmented\n   BNF (ABNF) defined in RFC 2234 [6]. The definitions for `ALPHA',\n\
    \   `DIGIT', `HEXDIG', `WSP', `CRLF', `CR', `LF', `HTAB', `VCHAR' and\n   `DQUOTE'\
    \ are imported from appendix A of RFC 2234 and not repeated\n   here.\n"
- title: 5.1.  Common Definitions
  contents:
  - "5.1.  Common Definitions\n   The following ABNF definitions are used in subsequent\
    \ sections to\n   define the SMX protocol messages.\n     Zero          = %x30\
    \          ; the ASCII character '0'\n     AlNum         = DIGIT / ALPHA / %x2D-2F\n\
    \                                   ; digits, alphas plus '-', '.', '/'\n    \
    \ QuotedString  = DQUOTE *(VCHAR / WSP) DQUOTE\n     HexString     = 1*(HEXDIG\
    \ HEXDIG)\n     Id            = 1*DIGIT       ; identifier for an SMX transaction\n\
    \     Script        = QuotedString  ; script file name\n     RunId         = 1*DIGIT\
    \       ; globally unique identifier for a\n                                 \
    \  ; running script (note, smRunIndex\n                                   ; is\
    \ only unique for a smLaunchOwner,\n                                   ; smLaunchName\
    \ pair)\n     Profile       = 1*AlNum       ; security profile name\n     RunState\
    \      =  \"1\"          ; smRunState `initializing'\n     RunState      =/ \"\
    2\"          ; smRunState `executing'\n     RunState      =/ \"3\"          ;\
    \ smRunState `suspending'\n     RunState      =/ \"4\"          ; smRunState `suspended'\n\
    \     RunState      =/ \"5\"          ; smRunState `resuming'\n     RunState \
    \     =/ \"6\"          ; smRunState `aborting'\n     RunState      =/ \"7\" \
    \         ; smRunState `terminated'\n     ExitCode      =  \"1\"          ; smRunExitCode\
    \ `noError'\n     ExitCode      =/ \"2\"          ; smRunExitCode `halted'\n \
    \    ExitCode      =/ \"3\"          ; smRunExitCode `lifeTimeExceeded'\n    \
    \ ExitCode      =/ \"4\"          ; smRunExitCode `noResourcesLeft'\n     ExitCode\
    \      =/ \"5\"          ; smRunExitCode `languageError'\n     ExitCode      =/\
    \ \"6\"          ; smRunExitCode `runtimeError'\n     ExitCode      =/ \"7\" \
    \         ; smRunExitCode `invalidArgument'\n     ExitCode      =/ \"8\"     \
    \     ; smRunExitCode `securityViolation'\n     ExitCode      =/ \"9\"       \
    \   ; smRunExitCode `genericError'\n     Cookie        = HexString     ; authentication\
    \ cookie\n     Version       = \"SMX/1.0\"     ; current version of the SMX protocol\n\
    \     Argument      = HexString / QuotedString      ; see smRunArgument\n    \
    \ Result        = HexString / QuotedString      ; see smRunResult\n     ErrorMsg\
    \      = HexString / QuotedString      ; see smRunError\n   The definition of\
    \ QuotedString requires further explanation. A quoted\n   string may contain special\
    \ character sequences, all starting with the\n   backslash character (%x5C). The\
    \ interpretation of these sequences is\n   as follows:\n           `\\\\'   backslash\
    \ character       (`%x5C')\n           `\\t'   tab character             (`HTAB')\n\
    \           `\\n'   newline character         (`LF')\n           `\\r'   carriage-return\
    \ character (`CR')\n           `\\\"'   quote character           (`DQUOTE')\n\
    \   In all other cases not listed above, the backslash is dropped and the\n  \
    \ following character is treated as an ordinary character.  `Argument'\n   and\
    \ `Result' is either a QuotedString or a HexString.  The Script MIB\n   defines\
    \ script arguments and results as arbitrary octet strings. The\n   SMX protocol\
    \ supports a binary and a human readable representation\n   since it is likely\
    \ that printable argument and result strings will be\n   used frequently. However,\
    \ an implementation must be able to handle\n   both formats in order to be compliant\
    \ with the Script MIB.\n   The `Cookie' is a HexString which does not carry any\
    \ semantics other\n   than being a random sequence of bytes. It is therefore not\
    \ necessary\n   to have a human readable representation.\n"
- title: 5.2.  Commands
  contents:
  - "5.2.  Commands\n   The following ABNF definitions define the set of SMX commands\
    \ which\n   can be sent from the SNMP agent to a runtime system.\n     Command\
    \ =  \"hello\"   WSP Id CRLF\n     Command =/ \"start\"   WSP Id WSP RunId WSP\
    \ Script WSP Profile\n                          WSP Argument CRLF\n     Command\
    \ =/ \"suspend\" WSP Id WSP RunId CRLF\n     Command =/ \"resume\"  WSP Id WSP\
    \ RunId CRLF\n     Command =/ \"abort\"   WSP Id WSP RunId CRLF\n     Command\
    \ =/ \"status\"  WSP Id WSP RunId CRLF\n   The `hello' command is always the first\
    \ command sent over a SMX\n   connection. It is used to identify and authenticate\
    \ the runtime\n   system. The `start' command starts the execution of a script.\
    \ The\n   `suspend', `resume' and `abort' commands can be used to change the\n\
    \   status of a running script. The `status' command is used to retrieve\n   status\
    \ information for a running script.\n   There is no compile command. It is the\
    \ responsibility of the SNMP\n   agent to perform any compilation steps as needed\
    \ before using the SMX\n   `start' command. There is no SMX command to shutdown\
    \ a runtime\n   system. Closing the connection must be interpreted as a request\
    \ to\n   terminate all running scripts in that runtime system and to shutdown\n\
    \   the runtime system.\n"
- title: 5.3.  Replies
  contents:
  - "5.3.  Replies\n   Every reply message starts with a three digit reply code and\
    \ ends\n   with `CRLF'. The three digits in a reply code have a special meaning.\n\
    \   The first digit identifies the class of a reply message. The\n   following\
    \ classes exist:\n     1yz   transient positive response\n     2yz   permanent\
    \ positive response\n     3yz   transient negative response\n     4yz   permanent\
    \ negative response\n     5yz   asynchronous notification\n   The classes 1yz\
    \ and 3yz are currently not used by SMX version 1.0.\n   They are defined only\
    \ for future SMX extensions.\n   The second digit encodes the specific category.\
    \ The following\n   categories exist:\n     x0z   syntax errors that don't fit\
    \ any other category\n     x1z   replies for commands targeted at the whole runtime\
    \ system\n     x2z   replies for commands targeted at scripts\n     x3z   replies\
    \ for commands targeted at running instances of scripts\n   The third digit gives\
    \ a finer gradation of meaning in each category\n   specified by the second digit.\
    \ Below is the ABNF definition of all\n   reply messages and codes:\n     Reply\
    \ =  \"211\" WSP Id WSP Version WSP Cookie CRLF\n                            \
    \       ; identification of the\n                                   ; runtime\
    \ system\n     Reply =/ \"231\" WSP Id WSP RunState CRLF\n                   \
    \                ; status of a running script\n     Reply =/ \"232\" WSP Id CRLF\
    \    ; abort of a running script\n     Reply =/ \"401\" WSP Id CRLF    ; syntax\
    \ error in command\n     Reply =/ \"402\" WSP Id CRLF    ; unknown command\n \
    \    Reply =/ \"421\" WSP Id CRLF    ; unknown or illegal Script\n     Reply =/\
    \ \"431\" WSP Id CRLF    ; unknown or illegal RunId\n     Reply =/ \"432\" WSP\
    \ Id CRLF    ; unknown or illegal Profile\n     Reply =/ \"433\" WSP Id CRLF \
    \   ; illegal Argument\n     Reply =/ \"434\" WSP Id CRLF    ; unable to change\
    \ the status of\n                                   ; a running script\n     Reply\
    \ =/ \"511\" WSP Zero WSP QuotedString CRLF\n                                \
    \   ; an arbitrary message send from\n                                   ; the\
    \ runtime system\n     Reply =/ \"531\" WSP Zero WSP RunId WSP RunState CRLF\n\
    \                                   ; asynchronous running script\n          \
    \                         ; status change\n     Reply =/ \"532\" WSP Zero WSP\
    \ RunId WSP RunState WSP Result CRLF\n                                   ; intermediate\
    \ script result\n     Reply =/ \"533\" WSP Zero WSP RunId WSP RunState WSP Result\
    \ CRLF\n                                   ; intermediate script result that\n\
    \                                   ; trigger an event report\n     Reply =/ \"\
    534\" WSP Zero WSP RunId WSP Result CRLF\n                                   ;\
    \ normal script termination\n     Reply =/ \"535\" WSP Zero WSP RunId WSP ExitCode\
    \ WSP ErrorMsg CRLF\n                                   ; abnormal script termination.\n"
- title: 6.  Elements of Procedure
  contents:
  - "6.  Elements of Procedure\n   This section describes in detail the processing\
    \ steps performed by\n   the SNMP agent and the runtime system with regard to\
    \ the SMX\n   protocol.\n"
- title: 6.1.  SMX Message Processing on the Runtime Systems
  contents:
  - "6.1.  SMX Message Processing on the Runtime Systems\n   This section describes\
    \ the processing of SMX command messages by a\n   runtime engine and the conditions\
    \ under which asynchronous\n   notifications are generated.\n   When the runtime\
    \ system receives a message, it first tries to\n   recognize a command consisting\
    \ of the command string and the\n   transaction identifier. If the runtime system\
    \ is not able to extract\n   both the command string and the transaction identifier,\
    \ then the\n   message is discarded. An asynchronous `511' reply may be generated\
    \ in\n   this case. Otherwise, the command string is checked to be valid, i.e.\n\
    \   to be one of the strings `hello', `start', `suspend', `resume',\n   `abort',\
    \ or `status'.  If the string is invalid, a `402' reply is\n   sent and processing\
    \ of the message stops.  If a valid command has\n   been detected, further processing\
    \ of the message depends on the\n   command as described below.\n   The command\
    \ specific processing describes several possible syntax\n   errors for which specific\
    \ reply messages are generated. If the\n   runtime engine detects any syntax error\
    \ which is not explicitely\n   mentioned or which cannot be identified uniquely,\
    \ a generic `401'\n   reply is sent indicating that the command cannot be executed.\n"
- title: 6.1.1.  Processing the `hello' Command
  contents:
  - "6.1.1.  Processing the `hello' Command\n   When the runtime system receives a\
    \ `hello' command, it processes it\n   as follows:\n   1.   The runtime system\
    \ obtains the security cookie from its process\n        environment.\n   2.  \
    \ The runtime system sends a `211' reply containing the security\n        cookie.\n"
- title: 6.1.2.  Processing the `start' Command
  contents:
  - "6.1.2.  Processing the `start' Command\n   When the runtime system receives a\
    \ `start' command, it processes it\n   as follows:\n   1.   The syntax of the\
    \ arguments of the `start' command is checked.\n        The following four checks\
    \ must be made:\n        (a)   The syntax of the `RunId' parameter is checked\
    \ and a `431'\n              reply is sent if any syntax error is detected.\n\
    \        (b)   The syntax of the `Script' parameter is checked and a\n       \
    \       `421' reply is sent if any syntax error is detected.\n        (c)   The\
    \ syntax of the `Profile' parameter is checked and a\n              `432' reply\
    \ is sent if any syntax error is detected.\n        (d)   If syntax of the `Argument'\
    \ parameter is checked and a\n              `433' reply is sent if any syntax\
    \ error is detected.\n   2.   The runtime system checks whether the new `RunId'\
    \ is already in\n        use. If yes, a `431' reply is sent and processing stops.\n\
    \   3.   The runtime system checks whether the `Script' parameter is the\n   \
    \     name of a file on the local storage device, that can be read. A\n      \
    \  `421' reply is sent and processing stops if the file does not\n        exist\
    \ or is not readable.\n   4.   The runtime system checks whether the security\
    \ profile is known\n        and sends a `432' reply and stops processing if not.\n\
    \   5.   The runtime engine starts the script given by the script name.\n    \
    \    When the script has been started, a `231' reply is sent\n        including\
    \ the current run state.\n   Processing of the `start' command stops, when the\
    \ script reaches the\n   state `running'. For each asynchronous state change of\
    \ the running\n   script, a `531' reply is sent. Processing of the `start' command\
    \ is\n   also stopped if an error occurs before the state `running' is\n   reached.\
    \ In this case, the run is aborted and a `535' reply is\n   generated.\n   If\
    \ an `abort' command or a `suspend' command for the running script\n   is received\
    \ before processing of the `start' command is complete,\n   then the processing\
    \ of the `start' command may be stopped before the\n   state `running' is reached.\
    \ In this case, the resulting status of the\n   running script is given by the\
    \ respective reply to the `abort' or\n   `suspend' command, and no reply with\
    \ the transaction identifier of\n   the `start' command is generated.\n"
- title: 6.1.3.  Processing the `suspend' Command
  contents:
  - "6.1.3.  Processing the `suspend' Command\n   When the runtime system receives\
    \ a `suspend' command, it processes it\n   as follows:\n   1.   If there is a\
    \ syntax error in the running script identifier or\n        if there is no running\
    \ script matching the identifier, a `431'\n        reply is sent and processing\
    \ of the command is stopped.\n   2.   If the running script is already in the\
    \ state `suspended', a\n        '231' reply is sent and processing of the command\
    \ is stopped.\n   3.   If the running script is in the state `running', it is\
    \ suspended\n        and a `231' reply is sent after suspending. If suspending\
    \ fails,\n        a `434' reply is sent and processing of the command is stopped.\n\
    \   4.   If the running script has not yet reached the state `running'\n     \
    \   (the `start' command still being processed), it may reach the\n        state\
    \ `suspended' without having been in the state `running'.\n        After reaching\
    \ the state `suspended', a `231' reply is sent.\n   5.   If the running script\
    \ is in any other state, a `434' reply is\n        sent.\n"
- title: 6.1.4.  Processing the `resume' Command
  contents:
  - "6.1.4.  Processing the `resume' Command\n   When the runtime system receives\
    \ a `resume' command, it processes it\n   as follows:\n   1.   If there is a syntax\
    \ error in the running script identifier or\n        if there is no running script\
    \ matching the identifier, a `431'\n        reply is sent and processing of the\
    \ command is stopped.\n   2.   If the running script is already in the state `running',\
    \ a `231'\n        reply is sent and processing of the command is stopped.\n \
    \  3.   If the running script is in the state `suspended', it is resumed\n   \
    \     and a `231' reply is sent after resuming. If resuming fails, a\n       \
    \ `434' reply is sent and processing of the command is stopped.\n   4.   If the\
    \ `start' command is still being processed for the script,\n        a `231' reply\
    \ is sent when the state `running' has been reached.\n   5.   If the running script\
    \ is in any other state, a `434' reply is\n        sent.\n"
- title: 6.1.5.  Processing the `abort' Command
  contents:
  - "6.1.5.  Processing the `abort' Command\n   When the runtime system receives an\
    \ `abort' command, it processes it\n   as follows:\n   1.   If there is a syntax\
    \ error in the running script identifier or\n        if there is no running script\
    \ matching the identifier, a `431'\n        reply is sent and processing of the\
    \ command is stopped.\n   2.   If the running script is already aborted, a `232'\
    \ reply is sent\n        and processing of the command is stopped.\n   3.   The\
    \ running script is aborted and a `232' reply is sent after\n        aborting.\
    \ If aborting fails, a `434' reply is sent and\n        processing is stopped.\n"
- title: 6.1.6.  Processing the `status' Command
  contents:
  - "6.1.6.  Processing the `status' Command\n   When the runtime system receives\
    \ a `status' command, it processes it\n   as follows:\n   1.   If there is a syntax\
    \ error in the running script identifier or\n        if there is no running script\
    \ matching the identifier, a `431'\n        reply is sent and processing of the\
    \ command is stopped.\n   2.   The status of the script is obtained and a `231'\
    \ reply is sent.\n"
- title: 6.1.7.  Generation of Asynchronous Notifications
  contents:
  - "6.1.7.  Generation of Asynchronous Notifications\n   The runtime system generates\
    \ or may generate the following\n   notifications:\n   1.   If a change of the\
    \ status of a running script is observed by the\n        runtime system, a `531'\
    \ reply is sent.\n   2.   A `534' reply is sent if a running script terminates\
    \ normally.\n   3.   A `535' reply is sent if a running script terminates abnormally.\n\
    \   4.   If a script generates an intermediate result, a `532' reply is\n    \
    \    sent.\n   5.   If a script requests the generation of a `smScriptResult'\n\
    \        notification, a `533' reply is sent.\n   6.   Besides the notifications\
    \ mentioned above, the runtime system\n        may generate arbitrary `511' replies,\
    \ which are logged or\n        displayed by the SNMP agent.\n"
- title: 6.2.  SMX Message Processing on the SNMP Agent
  contents:
  - "6.2.  SMX Message Processing on the SNMP Agent\n   This section describes the\
    \ conditions under which an SNMP agent\n   implementing the Script MIB generates\
    \ SMX commands. It also describes\n   how the SNMP agent processes replies to\
    \ SMX commands.\n"
- title: 6.2.1.  Creating a Runtime System
  contents:
  - "6.2.1.  Creating a Runtime System\n   New runtime systems are started by the\
    \ SNMP agent while processing\n   set requests for a `smLaunchStart' variable.\
    \ The SNMP agent first\n   searches for an already running runtime systems which\
    \ matches the\n   security profiles associated with the `smLaunchStart' variable.\
    \ If no\n   suitable runtime system is available, a new runtime system is started\n\
    \   by preparing the environment for the new runtime system and starting\n   the\
    \ executable for the runtime system in a new process which conforms\n   to the\
    \ operating system security profile. The SNMP agent prepares to\n   accept a connection\
    \ from the new runtime system. The `smRunState' of\n   all scripts that should\
    \ be executed in this new runtime system is set\n   to `initializing'.\n"
- title: 6.2.2.  Generating the `hello' Command
  contents:
  - "6.2.2.  Generating the `hello' Command\n   The `hello' command is generated once\
    \ a connection request from a\n   runtime system has been accepted. The SNMP agent\
    \ sends the `hello'\n   command as defined in section 5.2. The SNMP agent then\
    \ expects a\n   reply from the runtime system within a reasonable timeout interval.\n\
    \   1.   If the timeout expires before the SNMP agent received a reply,\n    \
    \    then the connection is closed and all data associated with it is\n      \
    \  deleted.  Any scripts that should be running in this runtime\n        system\
    \ are aborted, the `smRunExitCode' is set to `genericError'\n        and `smRunError'\
    \ is modified to describe the error situation.\n   2.   If the received message\
    \ can not be analyzed because it does not\n        have the required format, then\
    \ the connection is closed and all\n        data associated with it is deleted.\
    \ Any scripts that should be\n        running in this runtime system are aborted,\
    \ the `smRunExitCode'\n        is set to `genericError' and `smRunError' is modified\
    \ to\n        describe the error situation.\n   3.   If the received message is\
    \ a `211' reply, then the `Id' is\n        checked whether it matches the `Id'\
    \ used in the `hello' command.\n        If the `Id' matches, then the `Version'\
    \ is checked. If the\n        `Version' matches a supported SMX protocol version,\
    \ then the\n        `Cookie' is checked whether it matches the cookie passed to\
    \ the\n        runtime system. If any of these tests fails, then the connection\n\
    \        is closed and all data associated with this runtime system is\n     \
    \   deleted. Any scripts that should be running in this runtime\n        system\
    \ are aborted, the `smRunExitCode' is set to `genericError'\n        and `smRunError'\
    \ is modified to describe the error situation.\n   4.   Received messages are\
    \ discarded if none of the previous rules\n        applies.\n"
- title: 6.2.3.  Generating the `start' Command
  contents:
  - "6.2.3.  Generating the `start' Command\n   The `start' command is generated while\
    \ processing set-requests for a\n   `smLaunchStart' variable. The `start' command\
    \ assumes that the SNMP\n   agent already determined a runtime system suitable\
    \ to execute the\n   script associated with the `smLaunchStart' variable.  The\
    \ SNMP agent\n   sends the `start' command as defined in section 5.2 to the selected\n\
    \   runtime system. The SNMP agent then expects a reply from the runtime\n   system\
    \ within a reasonable timeout interval.\n   1.   If the timeout expires before\
    \ the SNMP agent received a reply,\n        then the SNMP agent sends an `abort'\
    \ command to abort the\n        running script and sets the `smRunState' of the\
    \ running script\n        to `terminated', the `smRunExitCode' to `genericError'\
    \ and\n        `smRunError' is modified to describe the timeout situation.\n \
    \  2.   If the received message can not be analyzed because it does not\n    \
    \    have the required format, then the message is ignored. The SNMP\n       \
    \ agent continues to wait for a valid reply message until the\n        timeout\
    \ expires.\n   3.   If the received message is a `4yz' reply and the `Id' matches\n\
    \        the `Id' of the `start' command, then the SNMP agent assumes\n      \
    \  that the script can not be started. The `smRunState' of the\n        running\
    \ script is set to `terminated', the `smRunExitCode' to\n        `genericError'\
    \ and the `smRunError' is modified to contain a\n        message describing the\
    \ error situation.\n   4.   If the received message is a `231' reply and the `Id'\
    \ matches\n        the `Id' of the `start' command, then the `smRunState' variable\n\
    \        of the running script is updated.\n   5.   Received messages are discarded\
    \ if none of the previous rules\n        applies.\n"
- title: 6.2.4.  Generating the `suspend' Command
  contents:
  - "6.2.4.  Generating the `suspend' Command\n   The `suspend' command is generated\
    \ while processing set-requests for\n   the `smLaunchControl' and `smRunControl'\
    \ variables which change the\n   value to `suspend'. The SNMP agent sets the `smRunState'\
    \ variable to\n   `suspending' and sends the `suspend' command as defined in section\n\
    \   5.2. The SNMP agent then expects a reply from the runtime system\n   within\
    \ a reasonable timeout interval.\n   1.   If the timeout expires before the SNMP\
    \ agent received a reply,\n        then the SNMP agent sends an `abort' command\
    \ to abort the\n        running script and sets the `smRunState' of the running\
    \ script\n        to `terminated', the `smRunExitCode' to `genericError' and\n\
    \        `smRunError' is modified to describe the timeout situation.\n   2.  \
    \ If the received message can not be analyzed because it does not\n        have\
    \ the required format, then the message is ignored. The SNMP\n        agent continues\
    \ to wait for a valid reply message until the\n        timeout expires.\n   3.\
    \   If the received message is a `401', `402' or a `431' reply and\n        the\
    \ `Id' matches the `Id' of the `suspend' command, then the\n        runtime systems\
    \ is assumed to not provide the suspend/resume\n        capability and processing\
    \ of the `suspend' command stops.\n   4.   If the received message is a `231'\
    \ reply and the `Id' matches\n        the `Id' of the `suspend' command, then\
    \ the `smRunState'\n        variable of the running script is updated.\n   5.\
    \   Received messages are discarded if none of the previous rules\n        applies.\n"
- title: 6.2.5.  Generating the `resume' Command
  contents:
  - "6.2.5.  Generating the `resume' Command\n   The `resume' command is generated\
    \ while processing set-requests for\n   the `smLaunchControl' and `smRunControl'\
    \ variables which change the\n   value to `resume'. The SNMP agent sets the `smRunState'\
    \ variable to\n   `resuming' and sends the `resume' command as defined in section\
    \ 5.2.\n   The SNMP agent then expects a reply from the runtime system within\
    \ a\n   reasonable timeout interval.\n   1.   If the timeout expires before the\
    \ SNMP agent received a reply,\n        then the SNMP agent sends an `abort' command\
    \ to abort the\n        running script and sets the `smRunState' of the running\
    \ script\n        to `terminated', the `smRunExitCode' to `genericError' and\n\
    \        `smRunError' is modified to describe the timeout situation.\n   2.  \
    \ If the received message can not be analyzed because it does not\n        have\
    \ the required format, then the message is ignored. The SNMP\n        agent continues\
    \ to wait for a valid reply message until the\n        timeout expires.\n   3.\
    \   If the received message is a `401', `402' or a `431' reply and\n        the\
    \ `Id' matches the `Id' of the `resume' command, then the\n        runtime systems\
    \ is assumed to not provide the suspend/resume\n        capability and processing\
    \ of the `resume' command stops.\n   4.   If the received message is a `231' reply\
    \ and the `Id' matches\n        the `Id' of the `resume' command, then the `smRunState'\
    \ variable\n        of the running script is updated.\n   5.   Received messages\
    \ are discarded if none of the previous rules\n        applies.\n"
- title: 6.2.6.  Generating the `abort' Command
  contents:
  - "6.2.6.  Generating the `abort' Command\n   The `abort' command is generated while\
    \ processing set-requests for\n   the `smLaunchControl' and `smRunControl' variables\
    \ which change the\n   value to `abort'. In addition, the `abort' command is also\
    \ generated\n   if the `smRunLifeTime' variable reaches the value 0. The SNMP\
    \ agent\n   sends the `abort' command as defined in section 5.2. The SNMP agent\n\
    \   then expects a reply from the runtime system within a reasonable\n   timeout\
    \ interval.\n   1.   If the timeout expires before the SNMP agent received a reply,\n\
    \        then the SNMP agent sets the `smRunState' of the running script\n   \
    \     to `terminated', the `smRunExitCode' to `genericError' and\n        `smRunError'\
    \ is modified to describe the timeout situation.\n   2.   If the received message\
    \ can not be analyzed because it does not\n        have the required format, then\
    \ the message is ignored. The SNMP\n        agent continues to wait for a valid\
    \ reply message until the\n        timeout expires.\n   3.   If the received message\
    \ is a `4yz' reply and the `Id' matches\n        the `Id' of the `abort' command,\
    \ then the SNMP agent assumes\n        that the script can not be aborted. The\
    \ `smRunState' of the\n        running script is set to `terminated', the `smRunExitCode'\
    \ to\n        `genericError' and the `smRunResult' is modified to describe the\n\
    \        error situation.\n   4.   If the received message is a `232' reply and\
    \ the `Id' matches\n        the `Id' of the `abort' command, then the `smRunExitCode'\n\
    \        variable of the terminated script is changed to either `halted'\n   \
    \     (when processing a set-request for the `smLaunchControl' and\n        `smRunControl'\
    \ variables) or `lifeTimeExceeded' (if the `abort'\n        command was generated\
    \ because the `smRunLifeTime' variable\n        reached the value 0). The `smRunState'\
    \ variable is changed to\n        the value `terminated'.\n   5.   Received messages\
    \ are discarded if none of the previous rules\n        applies.\n"
- title: 6.2.7.  Generating the `status' Command
  contents:
  - "6.2.7.  Generating the `status' Command\n   The `status' command is generated\
    \ either periodically or on demand by\n   the SNMP agent in order to retrieve\
    \ status information from running\n   scripts. The SNMP agent sends the `status'\
    \ command as defined in 5.2.\n   The SNMP agent then expects a reply from the\
    \ runtime system within a\n   reasonable timeout interval.\n   1.   If the timeout\
    \ expires before the SNMP agent received a reply,\n        then the SNMP agent\
    \ sends an `abort' command to abort the\n        running script and sets the `smRunState'\
    \ of the running script\n        to `terminated', the `smRunExitCode' to `genericError'\
    \ and\n        `smRunError' is modified to describe the timeout situation.\n \
    \  2.   If the received message can not be analyzed because it does not\n    \
    \    have the required format, then the message is ignored. The SNMP\n       \
    \ agent continues to wait for a valid reply message until the\n        timeout\
    \ expires.\n   3.   If the received message is a `4yz' reply and the `Id' matches\n\
    \        the `Id' of the `status' command, then the SNMP agent assumes\n     \
    \   that the script status can not be read, which is a fatal error\n        condition.\
    \ The SNMP agent sends an `abort' command to abort the\n        running script.\
    \ The `smRunState' of the running script is set to\n        `terminated', the\
    \ `smRunExitCode' to `genericError' and the\n        `smRunError' is modified\
    \ to describe the error situation.\n   4.   If the received message is a `231'\
    \ reply and the `Id' matches\n        the `Id' of the `status' command, then the\
    \ `smRunState' variable\n        of the running script is updated.\n   5.   Received\
    \ messages are discarded if none of the previous rules\n        applies.\n"
- title: 6.2.8.  Processing Asynchronous Notifications
  contents:
  - "6.2.8.  Processing Asynchronous Notifications\n   The runtime system can send\
    \ asynchronous status change notifications.\n   These `5yz' replies are processed\
    \ as described below.\n   1.   If the received message is a `511' reply, then\
    \ the message is\n        displayed or logged appropriately and processing stops.\n\
    \   2.   If the received message is a `531' reply, then the SNMP agent\n     \
    \   checks whether a running script with the given `RunId' exists in\n       \
    \ the runtime system. Processing of the notification stops if\n        there is\
    \ no running script with the `RunId'. Otherwise, the\n        `smRunState' is\
    \ updated.\n   3.   If the received message is a `532' reply, then the SNMP agent\n\
    \        checks whether a running script with the given `RunId' exists in\n  \
    \      the runtime system. Processing of the notification stops if\n        there\
    \ is no running script with the `RunId'. Otherwise,\n        `smRunState' and\
    \ `smRunResult' are updated.\n   4.   If the received message is a `533' reply,\
    \ then the SNMP agent\n        checks whether a running script with the given\
    \ `RunId' exists in\n        the runtime system. Processing of the notification\
    \ stops if\n        there is no running script with the `RunId'. Otherwise,\n\
    \        `smRunState' and `smRunResult' are updated and the\n        `smScriptResult'\
    \ notification is generated.\n   5.   If the received message is a `534' reply,\
    \ then the SNMP agent\n        checks whether a running script with the given\
    \ `RunId' exists in\n        the runtime system. Processing stops if there is\
    \ no running\n        script with the `RunId'. Otherwise, `smExitCode' is set\
    \ to\n        `noError', `smRunState' is set to `terminated' and `smRunResult'\n\
    \        is updated.\n   6.   If the received message is a `535' reply, then the\
    \ SNMP agent\n        checks whether a running script with the given `RunId' exists\
    \ in\n        the runtime system. Processing stops if there is no running\n  \
    \      script with the `RunId'. Otherwise, `smRunState' is set to\n        `terminated'\
    \ and `smExitCode' and `smRunError' are updated.\n"
- title: 7.  An Example SMX Message Flow
  contents:
  - "7.  An Example SMX Message Flow\n   Below is an example SMX message exchange.\
    \ Messages send from the SNMP\n   agent are marked with `>' while replies send\
    \ from the runtime system\n   are marked with `<'. Line terminators (`CRLF') are\
    \ not shown in order\n   to make the example more readable.\n     > hello 1\n\
    \     < 211 1 SMX/1.0 0AF0BAED6F877FBC\n     > start 2 42 \"/var/snmp/scripts/foo.jar\"\
    \ untrusted \"\"\n     > start 5 44 \"/var/snmp/scripts/bar.jar\" trusted \"www.ietf.org\"\
    \n     < 231 2 2\n     > start 12 48 \"/var/snmp/scripts/foo.jar\" funny \"\"\n\
    \     < 231 5 2\n     < 532 0 44 2 \"waiting for response\"\n     > status 18\
    \ 42\n     > status 19 44\n     < 432 12\n     < 231 19 2\n     < 231 18 2\n \
    \    > hello 578\n     < 211 578 SMX/1.0 0AF0BAED6F877FBC\n     > suspend 581\
    \ 42\n     < 231 581 4\n     < 534 0 44 \"test completed\"\n     > abort 611 42\n\
    \     < 232 611\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   The SMX protocol runs on top of a local TCP connection.\
    \ Protocol\n   messages never leave the local system. It is therefore not possible\n\
    \   to attack the message exchanges if the underlying operating system\n   protects\
    \ local TCP connections from other users on the same machine.\n   The only critical\
    \ situation is the connection establishment phase.\n   The rules defined in section\
    \ 4 ensure that only local connections are\n   accepted and that a runtime system\
    \ has to identify itself with a\n   security cookie generated by the SNMP agent\
    \ and passed to the runtime\n   system process as part of its environment. This\
    \ rule ensures that\n   scripts will only be executed on authorized runtime systems.\
    \ This\n   scheme relies on the protection of process environments by the\n  \
    \ operating system. Well maintained UNIX operating systems have this\n   property.\n\
    \   The SMX protocol allows to execute script under different operating\n   system\
    \ and runtime system security profiles. The memo suggests to map\n   the smLaunchOwner\
    \ value to an operating system and a runtime system\n   security profile. The\
    \ operating system security profile is enforced\n   by the operating system by\
    \ setting up a proper process environment.\n   The runtime security profile is\
    \ enforced by a secure runtime system\n   (e.g. the Java virtual machine or a\
    \ safe Tcl interpreter) [7].\n"
- title: 9.  Acknowledgments
  contents:
  - "9.  Acknowledgments\n   The protocol described in this memo is the result of\
    \ a joint project\n   between the Technical University of Braunschweig and C&C\
    \ Research\n   Laboratories of NEC Europe Ltd. in Berlin. We would like to thank\
    \ the\n   following project members for their contributions to the initial\n \
    \  design and the implementation of the protocol described in this memo:\n   \
    \        M. Bolz         (TU Braunschweig)\n           C. Kappler      (NEC Europe\
    \ Ltd.)\n           A. Kind         (NEC Europe Ltd.)\n           S. Mertens \
    \     (TU Braunschweig)\n           J. Nicklisch    (NEC Europe Ltd.)\n"
- title: 10.  References
  contents:
  - "10.  References\n   [1]  Levi, D. and J. Schoenwaelder, \"Definitions of Managed\
    \ Objects\n        for the Delegation of Management Scripts\", RFC 2592, May 1999.\n\
    \   [2]  Lindholm, T., and F. Yellin, \"The Java Virtual Machine\n        Specification\"\
    , Addison Wesley, 1997.\n   [3]  J.K. Ousterhout, \"Tcl and the Tk Toolkit\",\
    \ Addison Wesley, 1994.\n   [4]  Fritzinger, J.S., and M. Mueller, \"Java Security\"\
    , White Paper,\n        Sun Microsystems, Inc., 1996.\n   [5]  Levy, J.Y., Demailly,\
    \ L., Ousterhout, J.K., and B. Welch, \"The\n        Safe-Tcl Security Model\"\
    , Proc. USENIX Annual Technical\n        Conference, June 1998.\n   [6]  Crocker,\
    \ D., and P. Overell, \"Augmented BNF for Syntax\n        Specifications: ABNF\"\
    , RFC 2234, Internet Mail Consortium, Demon\n        Internet Ltd., November 1997.\n\
    \   [7]  Schoenwaelder, J., and J. Quittek, \"Secure Management by\n        Delegation\
    \ within the Internet Management\", Proc. IFIP/IEEE\n        International Symposium\
    \ on Integrated Network Management '99,\n        May 1999.\n"
- title: 11.  Authors' Addresses
  contents:
  - "11.  Authors' Addresses\n   Juergen Schoenwaelder\n   TU Braunschweig\n   Bueltenweg\
    \ 74/75\n   38106 Braunschweig\n   Germany\n   Phone: +49 531 391-3283\n   EMail:\
    \ schoenw@ibr.cs.tu-bs.de\n   Juergen Quittek\n   NEC Europe Ltd.\n   C&C Research\
    \ Laboratories\n   Hardenbergplatz 2\n   10623 Berlin\n   Germany\n   Phone: +49\
    \ 30 254230-19\n   EMail: quittek@ccrle.nec.de\n"
- title: 12.  Full Copyright Statement
  contents:
  - "12.  Full Copyright Statement\n   Copyright (C) The Internet Society (1999).\
    \ All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the  purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
