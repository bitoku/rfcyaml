Distributed Denial of Service Open Threat Signaling (DOTS) Data Channel Specification Abstract
The document specifies a Distributed Denial of Service Open Threat Signaling (DOTS) data channel used for bulk exchange of data that cannot easily or appropriately communicated through the DOTS signal channel under attack conditions.
This is a companion document to "Distributed Denial of Service Open Threat Signaling (DOTS)
Signal Channel Specification" (RFC 8782).
Introduction A distributed denial of service (DDoS) attack is an attempt to make machines or network resources unavailable to their intended users.
In most cases, sufficient scale can be achieved by compromising enough end hosts and using those infected hosts to perpetrate and amplify the attack.
The victim of such an attack can be an application server, a router, a firewall, an entire network, etc.
As discussed in [RFC8612], the lack of a common method to coordinate a real time response among involved actors and network domains inhibits the speed and effectiveness of DDoS attack mitigation.
From that standpoint, DDoS Open Threat Signaling (DOTS) defines an architecture that allows a DOTS client to send requests to a DOTS server for DDoS attack mitigation [DOTS ARCH].
The DOTS approach is thus meant to minimize the impact of DDoS attacks, thereby contributing to the enforcement of more efficient defensive if not proactive security strategies.
To that aim, DOTS defines two channels: the signal channel and the data channel (Figure 1).
The DOTS signal channel is used to carry information about a device or a network (or a part thereof) that is under a DDoS attack.
Such information is sent by a DOTS client to an upstream DOTS server so that appropriate mitigation actions are undertaken on traffic deemed suspicious.
The DOTS signal channel is further elaborated in [RFC8782].
The DOTS data channel is used for infrequent bulk data exchange between DOTS agents to significantly improve the coordination of all the parties involved in the response to the attack.
Section 2 of [DOTS ARCH] mentions that the DOTS data channel is used to perform the following tasks:
Creation of aliases for resources for which mitigation may be requested.
A DOTS client may submit to its DOTS server a collection of prefixes to which it would like to refer by an alias when requesting mitigation.
The DOTS server can respond to this request with either a success or failure response (see Section 2 of [DOTS ARCH]).
Refer to Section 6 for more details.
Policy management, which enables a DOTS client to request the installation or withdrawal of traffic filters, the dropping or rate limiting of unwanted traffic, and the permitting of accept  listed traffic.
A DOTS client is entitled to instruct filtering rules only on IP resources that belong to its domain.
Sample use cases for populating drop  or accept list filtering rules
If a network resource (DOTS client) is informed about a potential DDoS attack from a set of IP addresses, the DOTS client informs its servicing DOTS gateway of all suspect IP addresses that need to be drop listed for further investigation.
The DOTS client could also specify a list of protocols and port numbers in the drop list rule.
The DOTS gateway then propagates the drop listed IP addresses to a DOTS server, which will undertake appropriate actions so that traffic originated by these IP addresses to the target network (specified by the DOTS client) is blocked.
A network that has partner sites from which only legitimate traffic arrives may want to ensure that the traffic from these sites is not subjected to DDoS attack mitigation.
The DOTS client uses the DOTS data channel to convey the accept listed IP prefixes of the partner sites to its DOTS server.
The DOTS server uses this information to accept list flows originated by such IP prefixes and which reach the network.
Refer to Section 7 for more details.
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14
when, and only when, they appear in all capitals, as shown here.
The reader should be familiar with the terms defined in [RFC8612].
The terminology for describing YANG modules is defined in [RFC7950].
The meaning of the symbols in the tree diagrams is defined in [RFC8340].
This document generalizes the notion of Access Control List (ACL) so that it is not device specific
As such, this document defines an ACL as an ordered set of rules that is used to filter traffic.
Each rule is represented by an Access Control Entry (ACE).
ACLs communicated via the DOTS data channel are not bound to a device interface.
For the sake of simplicity, the examples in this document use "/restconf" as the discovered RESTCONF API root path.
Within the examples, many protocol header lines and message body text are split into multiple lines for display purposes only.
It is to be considered to be joined to the next line by deleting the backslash, the following line break, and the leading whitespace of the next line.
Design Overview Unlike the DOTS signal channel, which must remain operational even when confronted with signal degradation due to packet loss, the DOTS data channel is not expected to be fully operational at all times, especially when a DDoS attack is underway.
The requirements for a DOTS data channel protocol are documented in [RFC8612].
This specification does not require an order of DOTS signal and data channel creation nor does it mandate a time interval between them.
These considerations are implementation and deployment specific.
As the primary function of the data channel is data exchange, a reliable transport mode is required in order for DOTS agents to detect data delivery success or failure.
This document uses RESTCONF [RFC8040] over TLS over TCP as the DOTS data channel protocol.
The abstract layering of the DOTS data channel is shown in Figure 2.
DOTS Data Channel   Figure 2: Abstract Layering of DOTS Data Channel
The HTTP POST, PUT, PATCH, and DELETE methods are used to edit data resources represented by DOTS data channel YANG modules.
These basic edit operations allow a DOTS client to alter the running configuration of the DOTS data channel.
Rules for generating and processing RESTCONF methods are defined in Section 4 of [RFC8040].
DOTS data channel configuration information as well as state information can be retrieved with the GET method.
An HTTP status  line is returned for each request to report success or failure for RESTCONF operations (Section 5.4 of [RFC8040]).
The error tag provides more information about encountered errors (Section 7 of [RFC8040]).
DOTS clients perform the root resource discovery procedure discussed in Section 3.1 of [RFC8040] to determine the root of the RESTCONF API.
After discovering the RESTCONF API root, a DOTS client uses this value as the initial part of the path in the request URI in any subsequent request to the DOTS server.
The DOTS server may support the retrieval of the YANG modules it supports (Section 3.7 of [RFC8040]).
For example, a DOTS client may use RESTCONF to retrieve the vendor specific YANG modules supported by its DOTS server.
[RFC8259] payloads are used to propagate the DOTS data channel specific payload messages that carry request parameters and response information, such as errors.
This specification uses the encoding rules defined in [RFC7951] for representing DOTS data channel configuration data using YANG (Section 4) as JSON text.
A DOTS client registers itself with its DOTS server(s) in order to set up DOTS data channel related configuration data and to receive state data (i.e., non configuration data) from the DOTS server(s)
Mutual authentication considerations are specified in Section 8 of [RFC8782].
The coupling of signal and data channels is discussed in Section 4.4.1 of [RFC8782].
A DOTS client can either maintain a persistent connection or initiate periodic connections with its DOTS server(s).
If the DOTS client needs to frequently update the drop list or accept list filtering rules or aliases, it maintains a persistent connection with the DOTS server.
For example, CAPTCHA and cryptographic puzzles can be used by the mitigation service in the DOTS client domain to determine whether or not the IP address is used for legitimate purpose, and the DOTS client can frequently update the drop list filtering rules.
A persistent connection is also useful if the DOTS client subscribes to event notifications (Section 6.3 of [RFC8040]).
Additional considerations related to RESTCONF connection management (including, configuring the connection type or the reconnect strategy) can be found in [RESTCONF MODELS].
A single DOTS data channel between DOTS agents can be used to exchange multiple requests and multiple responses.
To reduce DOTS client and DOTS server workload, DOTS clients SHOULD reuse the same TLS session.
While the communication to the DOTS server is quiescent, the DOTS client MAY probe the server to ensure it has maintained cryptographic state.
Such probes can also keep alive firewall and/or NAT bindings.
A TLS heartbeat [RFC6520] verifies that the DOTS server still has TLS state by returning a TLS message.
A DOTS server may detect conflicting filtering requests from distinct DOTS clients that belong to the same domain.
For example, a DOTS client could request to drop list a prefix by specifying the source prefix, while another DOTS client could request to accept list that same source prefix, but both having the same destination prefix.
DOTS servers SHOULD support a configuration parameter to indicate the behavior to follow when a conflict is detected (e.g., reject all, reject the new request, notify an administrator for validation).
Section 7.2 specifies a default behavior when no instruction is supplied to a DOTS server.
How a DOTS client synchronizes its configuration with the one maintained by its DOTS server(s) is implementation specific.
A DOTS client can reestablish the disconnected DOTS session after an attack is mitigated.
Then, it sends a GET message before a configuration change request.
NAT considerations for the DOTS data channel are similar to those discussed in Section 3 of [RFC8782].
The translation of filtering rules instantiated on a DOTS server into network configuration actions is out of scope of this specification.
Some of the fields introduced in Section 4 are also discussed in Sections 5, 6, and 7.
These sections are authoritative for these fields.
This document assumes that DOTS clients are provisioned with the knowledge of how to reach their DOTS server(s), which could occur by a variety of means (e.g., local configuration or dynamic means such as DHCP [DOTS SERVER DISC]).
The specification of such means are out of scope of this document.
Likewise, it is out of scope of this document to specify the behavior to be followed by a DOTS client to send DOTS requests when multiple DOTS servers are provisioned (e.g., contact all DOTS servers, select one DOTS server among the list).
When a server domain DOTS gateway is involved in DOTS data channel exchanges, the same considerations for manipulating the 'cdid' (client domain identifier)
MUST be followed by DOTS agents.
As a reminder, 'cdid' is meant to assist the DOTS server in enforcing some policies (e.g., limit the number of filtering rules per DOTS client or per DOTS client domain).
A loop detection mechanism for DOTS gateways is specified in Section 3.4.
If a DOTS gateway is involved, the DOTS gateway verifies that the DOTS client is authorized to undertake a data channel action (e.g., instantiate filtering rules).
If the DOTS client is authorized, it propagates the rules to the upstream DOTS server.
Likewise, the DOTS server verifies that the DOTS gateway is authorized to relay data channel actions.
For example, to create or purge filters, a DOTS client sends its request to its DOTS gateway.
The DOTS gateway validates the rules in the request and proxies the requests containing the filtering rules to its DOTS server.
When the DOTS gateway receives the associated response from the DOTS server, it propagates the response back to the DOTS client.
3.4.  Detecting and Preventing Infinite Loops
In order to detect and prevent infinite loops, DOTS gateways MUST support the procedure defined in Section 5.7.1 of [RFC7230].
Messages that cannot be forwarded because of a loop SHOULD be logged with a "508 Loop Detected" status line returned to the DOTS peer.
The structure of the reported error is depicted in Figure 3.
An infinite loop has been detected when forwarding a requests via a proxy.
It is RECOMMENDED that DOTS clients and gateways support methods to alert administrators about loop errors so that appropriate actions are undertaken.
Otherwise, the DOTS agent MUST update or insert the Via header field by appending its own information.
Unless configured otherwise, DOTS gateways at the boundaries of a DOTS client domain SHOULD remove the previous Via header field information after checking for a loop before forwarding.
This behavior is required for topology hiding purposes but can also serve to minimize potential conflicts that may arise if overlapping information is used in distinct DOTS domains (e.g., private IPv4 addresses, aliases that are not globally unique).
In order to avoid stale entries, a lifetime is associated with alias and filtering entries created by DOTS clients.
Also, DOTS servers may track the inactivity timeout of DOTS clients to detect stale entries.
DOTS Data Channel YANG Module 4.1.
The DOTS data channel YANG module 'ietf dots data channel' provides a method for DOTS clients to manage aliases for resources for which mitigation may be requested.
Such aliases may be used in subsequent DOTS signal channel exchanges to refer more efficiently to the resources under attack.
Note that the full module's tree has been split across several figures to aid the exposition of the various subtrees.
The tree structure for the DOTS alias is depicted in Figure 4.
Also, the 'ietf dots data channel' YANG module provides a method for DOTS clients to manage filtering rules.
Accept list management, which enables a DOTS client to inform a DOTS server about sources from which traffic should always be accepted.
Policy management, which enables a DOTS client to request the installation or withdrawal of traffic filters, the dropping or rate limiting of unwanted traffic, and the allowance of accept  listed traffic.
The tree structure for the DOTS filtering entries is depicted in Figure 5.
Investigations into the prospect of augmenting 'ietf access control  list' to meet DOTS requirements concluded that such a design approach did not support many of the DOTS requirements, for example:
Retrieve a filtering entry (or all entries) created by a DOTS client.
Delete a filtering entry that was instantiated by a DOTS client.
Accordingly, new DOTS filtering entries (i.e., ACL) are defined that mimic the structure specified in [RFC8519].
Concretely, DOTS agents are assumed to manipulate an ordered list of ACLs; each ACL contains a separately ordered list of ACEs.
Each ACE has a group of match and a group of action criteria.
Once all of the ACE entries have been iterated though with no match, then all of the following ACL's ACE entries are iterated through until the first match, at which point the specified action is applied.
If there is no match during 'idle' time (i.e., no mitigation is active), then there is no further action to be taken against the packet.
If there is no match during active mitigation, then the packet will still be scrubbed by the DDoS mitigator.
ACLs Subtree Filtering rules instructed by a DOTS client assume a default direction: the destination is the DOTS client domain.
DOTS forwarding actions can be 'accept' (i.e., accept matching traffic) or 'drop' (i.e., drop matching traffic without sending any ICMP error message).
Accepted traffic can be subject to rate  limiting 'rate limit'.
Note that 'reject' action (i.e., drop matching traffic and send an ICMP error message to the source) is not supported in 'ietf dots data channel' because it is not appropriate in the context of DDoS mitigation.
Generating ICMP messages to notify of drops when mitigating a DDoS attack will exacerbate the DDoS attack.
Furthermore, these ICMP messages will be used by an attacker as an explicit signal that the traffic is being blocked.
The 'ietf dots data channel' module reuses the packet fields module 'ietf packet fields' [RFC8519], which defines matching on fields in the packet including IPv4, IPv6, and transport layer fields.
The 'ietf dots data channel' module can be augmented, for example, to support additional protocol specific matching fields.
This specification defines a new IPv4/IPv6 matching field called 'fragment' to efficiently handle fragment related filtering rules.
Indeed, [RFC8519] does not support such capability for IPv6 but offers a partial support for IPv4 by means of 'flags'.
Nevertheless, the use of 'flags' is problematic since it does not allow a bitmask to be defined.
For example, setting other bits not covered by the 'flags' filtering clause in a packet will allow that packet to get through (because it won't match the ACE).
Examples to illustrate how 'fragment' can be used are provided in Appendix A. Figure 6 shows the IPv4 match subtree.
DOTS ACLs Subtree (IPv4 Match)
Figure 7 shows the IPv6 match subtree.
DOTS ACLs Subtree (IPv6 Match)
Figure 8 shows the TCP match subtree.
In addition to the fields defined in [RFC8519], this specification defines a new TCP matching field, called 'flags bitmask', to efficiently handle TCP flags filtering rules.
Some examples are provided in Appendix B.
rw (port range or operator)?
:(destination port range or operator)
DOTS ACLs Subtree (TCP Match)
Figure 9 shows the UDP and ICMP match subtrees.
The same structure is used for both ICMP and ICMPv6.
The indication whether an ACL is about ICMP or ICMPv6 is governed by the 'l3' match or the ACL type.
rw (port range or operator)?
:(destination port range or operator)
DOTS ACLs Subtree (UDP and ICMP Match)
DOTS implementations MUST support the following matching criteria: Match based on the IP header (IPv4 and IPv6), match based on the transport header (TCP, UDP, and ICMP), and match based on any combination thereof.
The same matching fields are used for both ICMP and ICMPv6.
The following match fields MUST be supported by DOTS implementations (Table 1):
The 'ietf dots data channel' YANG module provides a method for an implementation to expose its filtering capabilities.
The tree structure of the 'capabilities' is shown in Figure 10.
DOTS clients that support both 'fragment' and 'flags' (or 'flags bitmask' and 'flags')
matching fields MUST NOT set these fields in the same request.
boolean  ro rest of header?
This module uses the common YANG types defined in [RFC6991] and types defined in [RFC8519].
<CODE BEGINS> file "ietf dots data channel@2020 05 28.yang" module ietf dots data channel { yang version 1.1; namespace "urn:ietf:params:xml:
Open Threat Signaling (DOTS) Working Group"; contact
<mailto:amortensen@arbor.net> Author:  Nik Teague <mailto:nteague@ironmountain.co.uk>"
; description "This module contains YANG definition for configuring aliases for resources and filtering rules using DOTS data channel.
Copyright (c) 2020 IETF Trust and the persons identified as authors of the code.
Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license info).
This is a match on any of the bits in bitmask.
any' and 'match' bits must not be set simultaneously."
For clarity, the 4 bits of byte 12 corresponding to the TCP data offset field are not included in any matching."
; } description "Operations on TCP flags."
; } typedef fragment type { type bits { bit df { position 0; description "Don't fragment bit for IPv4. Must be set to 0 when it appears in an IPv6 filter."
; } grouping target { description "Specifies the targets of the mitigation request."; leaf list target prefix { type inet:ip prefix; description "IPv4 or IPv6 prefix identifying the target."
; } list target port range { key "lower port"; description "Port range.
../lower port' { error message "The upper port number must be greater than or equal to the lower port number."
Values are taken from the IANA protocol registry:
For example, 6 for TCP or 17 for UDP."
; } grouping access lists { description "Specifies the ordered set of Access Control Lists."; list acl { key "name"; ordered by user; description "
An ACL is an ordered list of Access Control Entries (ACE).
Indicates the primary intended type of match criteria (e.g., IPv4, IPv6) used in the list instance."
; description "Indicates the activation type of an ACL.
An ACL can be deactivated, installed immediately, or installed when a mitigation is active.";
} leaf pending lifetime { type int32; units "minutes"
; config false; description "Indicates the pending validity lifetime of the ACL entry."
The rules in this set determine what fields will be matched upon before any action is taken on them.
If no matches are defined in a particular container, then any packet will match that container.
acl ip header fields; uses packet fields:
; container fragment { description "Indicates how to handle IPv4 fragments."; uses fragment fields;
} description "Rule set that matches IPv4 header."
acl ip header fields; uses packet fields:
; container fragment { description "Indicates how to handle IPv6 fragments."; uses fragment fields;
} description "Rule set that matches IPv6 header."
; container flags bitmask { description "Indicates how to handle TCP flags."
; uses tcp flags; } uses ports; description "Rule set that matches TCP header."
; } container udp { uses packet fields:acl udp header fields; uses ports; description "Rule set that matches UDP header."
; } container icmp { uses packet fields:acl icmp header fields; description "Rule set that matches ICMP/
; list dots client { key "cuid"; description "List of DOTS clients."; leaf cuid { type string; description "A unique identifier that is generated by a DOTS client to prevent request collisions."; reference "RFC 8782: Distributed Denial of Service Open Threat Signaling (DOTS)
Values are taken from the IANA protocol registry:
For example, this field contains 1 for ICMP, 6 for TCP 17 for UDP, or 58 for ICMPv6."
; } leaf fragment { type boolean; description "Indicates the capability of a DOTS server to enforce filters on IPv4 fragments.
This includes filtering based on a source port range, destination port range, or both.
All operators (i.e, less than or equal to, greater than or equal to, equal to, and not equal to) are supported.
In particular, this means that the implementation supports filtering based on source port range or operator and destination port range or operator."
This includes filtering based on a source port range, destination port range, or both.
All operators (i.e, less than or equal, greater than or equal, equal to, and not equal to) are supported.
In particular, this means that the implementation supports filtering based on source port range or operator and destination port range or operator."
; } leaf rest of header { type boolean; description "Support of filtering based on the ICMP four byte field / the ICMPv6 message body."
In order to make use of the DOTS data channel, a DOTS client MUST register with its DOTS server(s) by creating a DOTS client ('dots  client') resource.
To that aim, DOTS clients SHOULD send a POST request (shown in Figure 11).
POST /restconf/data/ietf dots data channel:
The 'cuid' (client unique identifier) parameter is described below:
cuid:  A globally unique identifier that is meant to prevent collisions among DOTS clients.
This attribute has the same meaning, syntax, and processing rules as the 'cuid' attribute defined in [RFC8782].
DOTS clients MUST use the same 'cuid' for both signal and data channels.
This is a mandatory attribute.
In deployments where server domain DOTS gateways are enabled, identity information about the origin source client domain SHOULD be supplied to the DOTS server.
That information is meant to assist the DOTS server to enforce some policies.
These policies can be enforced per client, per client domain, or both.
Figure 12 shows a schema of a register request relayed by a server domain DOTS gateway.
POST /restconf/data/ietf dots data channel:
A server domain DOTS gateway SHOULD add the following attribute:
This attribute has the same meaning, syntax, and processing rules as the 'cdid' attribute defined in [RFC8782].
In deployments where server domain DOTS gateways are enabled, 'cdid' does not need to be inserted when relaying DOTS methods to manage aliases (Section 6) or filtering rules (Section 7).
DOTS servers are responsible for maintaining the association between 'cdid' and 'cuid' for policy enforcement purposes.
This is an optional attribute.
An example request to create a 'dots client' resource is depicted in Figure 13.
This request is relayed by a server domain DOTS gateway as hinted by the presence of the 'cdid' attribute.
POST /restconf/data/ietf dots data channel:
As a reminder, DOTS gateways may rewrite the 'cuid' used by peer DOTS clients (Section 4.4.1 of [RFC8782]).
DOTS servers can identify the DOTS client domain using the 'cdid' parameter or using the client's DNS name specified in the Subject Alternative Name extension's dNSName type in the client certificate [RFC6125].
DOTS servers MUST limit the number of 'dots client' resources to be created by the same DOTS client to 1 per request.
Requests with multiple 'dots client' resources MUST be rejected by DOTS servers.
To that aim, the DOTS server MUST rely on the same procedure to unambiguously identify a DOTS client as discussed in Section 4.4.1 of [RFC8782].
The DOTS server indicates the result of processing the POST request using status line codes.
Status codes in the "2xx" range are success, "4xx" codes are some sort of invalid requests and "5xx" codes are returned if the DOTS server has erred or is incapable of accepting the creation of the 'dots client' resource.
"400 Bad Request" status line is returned by the DOTS server if the request does not include a 'cuid' parameter.
The error tag "missing attribute" is used in this case.
"409 Conflict" status line is returned to the requesting DOTS client if the data resource already exists.
The error tag "resource denied" is used in this case.
Once a DOTS client registers itself with a DOTS server, it can create/delete/retrieve aliases (Section 6) and filtering rules (Section 7).
A DOTS client MAY use the PUT request (Section 4.5 of [RFC8040]) to register a DOTS client within the DOTS server.
An example is shown in Figure 14.
PUT /restconf/data/ietf dots data channel:dots data\ /dots client dz6pHjaADkaFTbjr0JGBpw
De registering DOTS Clients A DOTS client de registers from its DOTS server(s) by deleting the 'cuid' resource(s).
Resources bound to this DOTS client will be deleted by the DOTS server.
An example of a de register request is shown in Figure 15.
DELETE /restconf/data/ietf dots data channel:dots data\ /dots client dz6pHjaADkaFTbjr0JGBpw
De register a DOTS Client 6.
The following subsections define the means for a DOTS client to create aliases (Section 6.1), to retrieve one or a list of aliases (Section 6.2), and to delete an alias (Section 6.3).
A POST or PUT request is used by a DOTS client to create aliases for resources for which a mitigation may be requested.
Such aliases may be used in subsequent DOTS signal channel exchanges to refer more efficiently to the resources under attack.
DOTS clients within the same domain can create different aliases for the same resource.
The structure of POST requests used to create aliases is shown in Figure 16.
The parameters are described below:
name:  Name of the alias.
This is a mandatory attribute.
target prefix:  Prefixes are separated by commas.
Prefixes are represented using Classless Inter domain Routing (CIDR) notation [RFC4632].
As a reminder, the prefix length must be less than or equal to 32 for IPv4 or 128 for IPv6.
The prefix list MUST NOT include broadcast, loopback, or multicast addresses.
These addresses are considered as invalid values.
In addition, the DOTS server MUST validate that these prefixes are within the scope of the DOTS client domain.
Other validation checks may be supported by DOTS servers.
This is an optional attribute.
A range of port numbers.
The port range is defined by two bounds, a lower port number ('lower port') and an upper port number ('upper port').
The range is considered to include both the lower and upper bounds.
When only 'lower port' is present, it represents a single port number.
For TCP, UDP, Stream Control Transmission Protocol (SCTP)
[RFC4960], or Datagram Congestion Control Protocol (DCCP)
[RFC4340], the range of port numbers can be, for example, 1024 65535.
This is an optional attribute.
target protocol:  A list of protocols.
Values are taken from the IANA protocol registry [IANA PROTO].
If 'target protocol' is not specified, then the request applies to any protocol.
This is an optional attribute.
target fqdn:  A list of Fully Qualified Domain Names (FQDNs) identifying resources under attack [RFC8499].
How a name is passed to an underlying name resolution library is implementation and deployment specific.
Nevertheless, once the name is resolved into one or multiple IP addresses, DOTS servers MUST apply the same validation checks as those for 'target  prefix'.
The use of FQDNs may be suboptimal because it does not guarantee that the DOTS server will resolve a name to the same IP addresses that the DOTS client does.
This is an optional attribute.
A list of Uniform Resource Identifiers (URIs) [RFC3986].
The same validation checks used for 'target fqdn' MUST be followed by DOTS servers to validate a target URI.
This is an optional attribute.
In POST or PUT requests, at least one of the 'target prefix', 'target fqdn', or 'target uri' attributes MUST be present.
DOTS agents can safely ignore vendor specific parameters they don't understand.
If more than one 'target  ' scope types (e.g., 'target prefix' and 'target fqdn' or 'target fqdn' and 'target uri') are included in a POST or PUT request, the DOTS server binds all resulting IP addresses/prefixes to the same resource.
Figure 17 shows a POST request to create an alias called "https1" for HTTPS servers with IP addresses 2001:db8:6401::1 and 2001:
db8:6401::2 listening on TCP port number 443.
POST /restconf/data/ietf dots data channel:dots data\ /dots client dz6pHjaADkaFTbjr0JGBpw
Example of a POST to Create an Alias A "201 Created" status line MUST be returned in the response if the DOTS server has accepted the alias.
A "409 Conflict" status line MUST be returned to the requesting DOTS client, if the request is conflicting with an existing alias name.
The error tag "resource denied" is used in this case.
If the request is missing a mandatory attribute or it contains an invalid or unknown parameter, a "400 Bad Request" status line MUST be returned by the DOTS server.
The error tag is set to "missing  attribute", "invalid value", or "unknown element" as a function of the encountered error.
If the request is received via a server domain DOTS gateway, but the DOTS server does not maintain a 'cdid' for this 'cuid' while a 'cdid' is expected to be supplied, the DOTS server MUST reply with a "403 Forbidden" status line and the error tag "access denied".
Upon receipt of this message, the DOTS client MUST register (Section 5).
A DOTS client uses the PUT request to modify the aliases in the DOTS server.
In particular, a DOTS client MUST update its alias entries upon change of the prefix indicated in the 'target prefix'.
A DOTS server MUST maintain an alias for at least 10080 minutes (1 week).
If no refresh request is seen from the DOTS client, the DOTS server removes expired entries.
A GET request is used to retrieve one or all installed aliases by a DOTS client from a DOTS server (Section 3.3.1 of [RFC8040]).
If no 'name' is included in the request, this indicates that the request is about retrieving all aliases instantiated by the DOTS client.
Figure 18 shows an example to retrieve all the aliases that were instantiated by the requesting DOTS client.
The "content" query parameter and its permitted values are defined in Section 4.8.1 of [RFC8040].
GET /restconf/data/ietf dots data channel:dots data\ /dots client dz6pHjaADkaFTbjr0JGBpw\ /aliases?content
application/yang data json Figure 18
: GET to Retrieve All Installed Aliases Figure 19
shows an example of the response message body that includes all the aliases that are maintained by the DOTS server for the DOTS client identified by the 'cuid' parameter.
An Example of a Response Body Listing All Installed Figure 20 shows an example of a GET request to retrieve the alias "Server2" that was instantiated by the DOTS client.
GET /restconf/data/ietf dots data channel:dots data\ /dots client dz6pHjaADkaFTbjr0JGBpw\
application/yang data json Figure 20
: GET to Retrieve an Alias
If an alias name ('name') is included in the request, but the DOTS server does not find that alias name for this DOTS client in its configuration data, it MUST respond with a "404 Not Found" status  line.
A DELETE request is used to delete an alias maintained by a DOTS server.
If the DOTS server does not find the alias name that was conveyed in the DELETE request in its configuration data for this DOTS client, it MUST respond with a "404 Not Found" status line.
The DOTS server successfully acknowledges a DOTS client's request to remove the alias using "204 No Content" status line in the response.
Figure 21 shows an example of a request to delete an alias.
/data/ietf dots data channel:dots data\ /dots client dz6pHjaADkaFTbjr0JGBpw\ /aliases
The following subsections define the means for a DOTS client to retrieve DOTS filtering capabilities (Section 7.1), to create filtering rules (Section 7.2), to retrieve active filtering rules (Section 7.3), and to delete a filtering rule (Section 7.4).
A DOTS client MAY send a GET request to retrieve the filtering capabilities supported by a DOTS server.
Figure 22 shows an example of such request.
GET /restconf/data/ietf dots data channel:dots data\ /capabilities
application/yang data json Figure 22
: GET to Retrieve the Capabilities of a DOTS Server A DOTS client, which issued a GET request to retrieve the filtering capabilities supported by its DOTS server, SHOULD NOT request filtering actions that are not supported by that DOTS server.
Installing Filtering Rules A POST or PUT request is used by a DOTS client to communicate filtering rules to a DOTS server.
Figure 24 shows an example of a POST request to block traffic from 192.0.2.0/24 and destined to 198.51.100.0/24.
Other examples are discussed in Appendix A. POST /restconf/data/ietf dots data channel:dots data\ /dots client dz6pHjaADkaFTbjr0JGBpw HTTP/1.1
The meaning of these parameters is as follows:
The name of the access list.
This is a mandatory attribute.
Indicates the primary intended type of match criteria (e.g., IPv4, IPv6).
It is set to 'ipv4 acl type' in the example of Figure 24.
This is an optional attribute.
Indicates whether an ACL has to be activated (immediately or during mitigation time) or instantiated without being activated (deactivated).
Deactivated ACLs can be activated using a variety of means, such as manual configuration on a DOTS server or by using the DOTS data channel.
If this attribute is not provided, the DOTS server MUST use 'activate when mitigating' as the default value.
When a mitigation is in progress, the DOTS server MUST only activate 'activate when mitigating' filters that are bound to the DOTS client that triggered the mitigation.
This is an optional attribute.
matches:  Defines criteria used to identify a flow on which to apply the rule.
It can be "l3" (IPv4, IPv6) or "l4" (TCP, UDP, ICMP).
The detailed match parameters are specified in Section 4.
In the example depicted in Figure 24, an IPv4 matching criteria is used.
This is an optional attribute.
DOTS servers MUST validate that these prefixes are within the scope of the DOTS client domain.
Other validation checks may be supported by DOTS servers.
If this attribute is not provided, the DOTS server enforces the ACL on any destination IP address that belongs to the DOTS client domain.
This is a mandatory attribute in requests with an 'activation  type' set to 'immediate'.
This is an optional attribute.
actions:  Actions in the forwarding ACL category can be 'drop' or 'accept'.
The 'accept' action is used to accept list traffic.
The "drop" action is used to drop list traffic.
Accepted traffic may be subject to 'rate limit'; the allowed traffic rate is represented in bytes per second.
This unit is the same as the one used for "traffic rate" in [RFC5575].
This is a mandatory attribute.
The DOTS server indicates the result of processing the POST request using the status line.
Concretely, a "201 Created" status line MUST be returned in the response if the DOTS server has accepted the filtering rules.
If the request is missing a mandatory attribute or contains an invalid or unknown parameter (e.g., a match field not supported by the DOTS server), a "400 Bad Request" status line MUST be returned by the DOTS server in the response.
The error tag is set to "missing attribute", "invalid value", or "unknown element" as a function of the encountered error.
If the request is received via a server domain DOTS gateway, but the DOTS server does not maintain a 'cdid' for this 'cuid' while a 'cdid' is expected to be supplied, the DOTS server MUST reply with a "403 Forbidden" status line and the error tag "access denied".
Upon receipt of this message, the DOTS client MUST register (Figure 11).
If the request is conflicting with an existing filtering installed by another DOTS client of the domain, absent any local policy, the DOTS server returns a "409 Conflict" status line to the requesting DOTS client.
The error tag "resource denied" is used in this case.
The "insert" query parameter (Section 4.8.5 of [RFC8040])
MAY be used to specify how an access control entry is inserted within an ACL and how an ACL is inserted within an ACL set.
The DOTS client uses the PUT request to modify its filtering rules maintained by the DOTS server.
In particular, a DOTS client MUST update its filtering entries upon change of the destination prefix.
How such change is detected is out of scope.
A DOTS server MUST maintain a filtering rule for at least 10080 minutes (1 week).
If no refresh request is seen from the DOTS client, the DOTS server removes expired entries.
Typically, a refresh request is a PUT request that echoes the content of a response to a GET request with all of the read only parameters stripped out (e.g., 'pending lifetime').
A DOTS client periodically queries its DOTS server to check the counters for installed filtering rules.
A GET request is used to retrieve filtering rules from a DOTS server.
In order to indicate which type of data is requested in a GET request, the DOTS client sets adequately the "content" query parameter.
If the DOTS server does not find the access list name conveyed in the GET request in its configuration data for this DOTS client, it responds with a "404 Not Found" status line.
In order to illustrate the intended behavior, consider the example depicted in Figure 25.
In reference to this example, the DOTS client requests the creation of an immediate ACL called "test acl ipv6 udp".
PUT /restconf/data/ietf dots data channel:dots data\ /dots client paL8p4Zqo4SLv64TLPXrxA/acls\ /acl
Example of a PUT Request to Create a Filtering
The peer DOTS server follows the procedure specified in Section 7.2 to process the request.
We consider in the following that a positive response is sent back to the requesting DOTS client to confirm that the "test acl ipv6 udp" ACL is successfully installed by the DOTS server.
The DOTS client can issue a GET request to retrieve all its filtering rules and the number of matches for the installed filtering rules as illustrated in Figure 26.
The "content" query parameter is set to 'all'.
The message body of the response to this GET request is shown in Figure 27.
GET /restconf/data/ietf dots data channel:dots data\ /dots client dz6pHjaADkaFTbjr0JGBpw\ /acls?content
application/yang data json Figure 26:
Retrieve the Configuration Data and State Data for the Filtering Rules
Retrieve the Configuration Data and State Data for the Filtering Rules (Response Message Body)
Also, a DOTS client can issue a GET request to retrieve only configuration data related to an ACL as shown in Figure 28.
It does so by setting the "content" query parameter to 'config'.
GET /restconf/data/ietf dots data channel:dots data\ /dots client paL8p4Zqo4SLv64TLPXrxA/acls\ /acl
test acl ipv6 udp?content config HTTP/1.1
application/yang data json Figure 28:
Retrieve the Configuration Data for a Filtering Rule
A response to this GET request is shown in Figure 29.
Retrieve the Configuration Data for a Filtering Rule (Response Message Body)
A DOTS client can also issue a GET request with a "content" query parameter set to 'non config' to exclusively retrieve non  configuration data bound to a given ACL as shown in Figure 30.
A response to this GET request is shown in Figure 31.
GET /restconf/data/ietf dots data channel:dots data\ /dots client paL8p4Zqo4SLv64TLPXrxA/acls\ /acl
test acl ipv6 udp?content non config HTTP/1.1
application/yang data json Figure 30:
Retrieve the Non Configuration Data for a Filtering Rule
A DELETE request is used by a DOTS client to delete filtering rules from a DOTS server.
If the DOTS server does not find the access list name carried in the DELETE request in its configuration data for this DOTS client, it MUST respond with a "404 Not Found" status line.
The DOTS server successfully acknowledges a DOTS client's request to withdraw the filtering rules using a "204 No Content" status line, and removes the filtering rules accordingly.
Figure 32 shows an example of a request to remove the IPv4 ACL "sample ipv4 acl" created in Section 7.2.
DELETE  /restconf/data/ietf dots data channel:dots data\ /dots client dz6pHjaADkaFTbjr0JGBpw
/acls\ /acl sample ipv4 acl HTTP/1.1
Remove a Filtering Rule (DELETE Request)
Figure 33 shows an example of a response received from the DOTS server to confirm the deletion of "sample ipv4 acl".
Fri, 27 Jul 2018 10:05:15 GMT Cache Control: no cache Content Type: application/yang data json Content Length: 0 Connection:
Remove a Filtering Rule (Response)
DOTS agents SHOULD enable the DOTS data channel to configure aliases and ACLs, and only use direct configuration as a stop gap mechanism to test DOTS signal channel with aliases and ACLs.
Further, direct configuration SHOULD only be used when the on path DOTS agents are within the same domain.
If a DOTS server has enabled direct configuration, it can reject the DOTS data channel connection using hard ICMP error [RFC1122] or RST (Reset
) bit in the TCP header or reject the RESTCONF request using an error response containing a "503 Service Unavailable" status line.
IANA Considerations IANA has registered the following URI in the "ns" subregistry within the "IETF XML Registry" [RFC3688]
: ID:  yang:ietf dots data channel URI:  urn:ietf:params:xml:ns:
yang:ietf dots data channel Registrant Contact:  The IESG.
N/A; the requested URI is an XML namespace.
RFC 8783 IANA has registered the following YANG module in the "YANG Module Names" subregistry [RFC7950] within the "YANG Parameters" registry.
Name:  ietf dots data channel
yang:ietf dots data channel Prefix:
data channel Reference:  RFC 8783
This module is not maintained by IANA.
Security Considerations RESTCONF security considerations are discussed in [RFC8040].
In particular, DOTS agents MUST follow the security recommendations in Sections 2 and 12 of [RFC8040].
Also, DOTS agents MUST support the mutual authentication TLS profile discussed in Sections 7.1 and 8 of [RFC8782].
Authenticated encryption MUST be used for data confidentiality and message integrity.
The interaction between the DOTS agents requires Transport Layer Security (TLS) with a cipher suite offering confidentiality protection, and the guidance given in [RFC7525] MUST be followed to avoid attacks on TLS.
The installation of drop list or accept list rules using RESTCONF over TLS reveals the attacker IP addresses and legitimate IP addresses only to the DOTS server trusted by the DOTS client.
The secure communication channel between DOTS agents provides privacy and prevents a network eavesdropper from directly gaining access to the drop listed and accept listed IP addresses.
An attacker may be able to inject RST packets, bogus application segments, etc., regardless of whether TLS authentication is used.
Because the application data is TLS protected, this will not result in the application receiving bogus data, but it will constitute a DoS on the connection.
This attack can be countered by using TCP Authentication Option (TCP AO)
If TCP AO is used, then any bogus packets injected by an attacker will be rejected by the TCP AO integrity check and therefore will never reach the TLS layer.
In order to prevent leaking internal information outside a client domain, client side DOTS gateways SHOULD NOT reveal the identity of internal DOTS clients (e.g., source IP address, client's hostname) unless explicitly configured to do so.
DOTS servers MUST verify that requesting DOTS clients are entitled to enforce filtering rules on a given IP prefix.
That is, only filtering rules on IP resources that belong to the DOTS client domain can be authorized by a DOTS server.
The exact mechanism for the DOTS servers to validate that the target prefixes are within the scope of the DOTS client domain is deployment specific.
Rate limiting DOTS requests, including those with new 'cuid' values, from the same DOTS client defends against DoS attacks that would result from varying the 'cuid' to exhaust DOTS server resources.
Rate limit policies SHOULD be enforced on DOTS gateways (if deployed) and DOTS servers.
Applying resources quota per DOTS client and/or per DOTS client domain (e.g., limiting the number of aliases and filters to be installed by DOTS clients) prevents DOTS server resources from being aggressively used by some DOTS clients and therefore ensures DDoS mitigation usage fairness.
Additionally, DOTS servers may limit the number of DOTS clients that can be enabled per domain.
When FQDNs are used as targets, the DOTS server MUST rely upon DNS privacy enabling protocols (e.g., DNS over TLS [RFC7858] or DNS over HTTPS (DoH)
[RFC8484]) to prevent eavesdroppers from possibly identifying the target resources protected by the DDoS mitigation service, and means to ensure the target FQDN resolution is authentic (e.g., DNSSEC [RFC4034]).
The presence of DOTS gateways may lead to infinite forwarding loops, which is undesirable.
To prevent and detect such loops, a mechanism is defined in Section 3.4.
The YANG module specified in this document defines a schema for data that is designed to be accessed via network management protocols such as NETCONF [RFC6241] or RESTCONF [RFC8040].
The lowest NETCONF layer is the secure transport layer, and the mandatory to implement secure transport is Secure Shell (SSH) [RFC6242].
The lowest RESTCONF layer is HTTPS, and the mandatory to implement secure transport is TLS [RFC8446].
The Network Configuration Access Control Model (NACM)
[RFC8341] provides the means to restrict access for particular NETCONF or RESTCONF users to a preconfigured subset of all available NETCONF or RESTCONF protocol operations and content.
There are a number of data nodes defined in this YANG module that are writable/creatable/deletable (i.e., config true, which is the default).
These data nodes may be considered sensitive or vulnerable in some network environments.
Write operations (e.g., edit config) to these data nodes without proper protection can have a negative effect on network operations.
The DOTS data channel is responsible for exchanging configuration data that affect traffic filtering during DDoS attack mitigation, in particular.
Appropriate security measures are recommended to prevent illegitimate users from invoking DOTS data channel primitives on writable data nodes.
Setting an arbitrarily high rate limit, which may lead to the forwarding of illegitimate DDoS traffic (rate limit).
Communicating invalid aliases to the server (alias), which will cause the failure of associating both data and signal channels.
Setting invalid ACL entries, which may prevent legitimate traffic from being forwarded.
Likewise, invalid ACL entries may lead to forward DDoS traffic.
This module reuses YANG structures from [RFC8519], and the security considerations for those nodes continue to apply for this usage.
This specification strongly recommends the use of 'fragment' for handling fragments.
Figure 34 shows the content of the POST request to be issued by a DOTS client to its DOTS server to allow the traffic destined to 198.51.100.0/24 and UDP port number 53, but to drop all fragmented packets.
"allow dns packets" ACE: accepts DNS packets destined to 198.51.100.0/24.
POST /restconf/data/ietf dots data channel:dots data\ /dots client dz6pHjaADkaFTbjr0JGBpw
Filtering IPv4 Fragmented Packets Figure 35 shows an example of a POST request issued by a DOTS client to its DOTS server to allow the traffic destined to 2001:
db8::/32 and UDP port number 53, but to drop all fragmented packets.
That is, IPv6 packets that include a Fragment header (44) are dropped.
"allow dns packets" ACE: accepts DNS packets destined to 2001:
/data/ietf dots data channel:dots data\ /dots client dz6pHjaADkaFTbjr0JGBpw
Filtering TCP Messages This section provides examples to illustrate TCP specific filtering based on the flag bits.
These examples should not be interpreted as recommended filtering behaviors under specific DDoS attacks.
Discard TCP Null Attack Figure 36 shows an example of a DOTS request sent by a DOTS client to install immediately a filter to discard incoming TCP messages having all flags unset.
The bitmask can be set to 255 to check against the (CWR, ECE, URG, ACK, PSH, RST, SYN, FIN) flags.
PUT /restconf/data/ietf dots data channel:dots data\ /dots client paL8p4Zqo4SLv64TLPXrxA/acls\
/acl tcp flags example HTTP/1.1
Example of a DOTS Request to Deny TCP Null Attack Messages B.2.
Rate Limit SYN Flooding Figure 37 shows an ACL example to rate limit incoming SYNs during a SYN flood attack.
PUT /restconf/data/ietf dots data channel:dots data\ /dots client paL8p4Zqo4SLv64TLPXrxA/acls\
/acl tcp flags example HTTP/1.1
} Figure 37: Example of DOTS Request to Rate Limit
Rate Limit ACK Flooding Figure 38 shows an ACL example to rate limit incoming ACKs during an ACK flood attack.
PUT /restconf/data/ietf dots data channel:dots data\ /dots client paL8p4Zqo4SLv64TLPXrxA/acls\
/acl tcp flags example HTTP/1.1
The following people contributed substantially to the content of this document and should be considered coauthors: Kaname Nishizuka NTT Communications GranPark
16F 3 4 1 Shibaura, Minato ku
, Tokyo 108 8118 Japan Email:
kaname@nttv6.jp Liang Xia Huawei 101 Software Avenue, Yuhuatai District Nanjing Jiangsu,
frank.xialiang@huawei.com Prashanth Patil Cisco Systems,
Andrew Mortensen Arbor Networks, Inc. 2727 S. State Street Ann Arbor, Michigan 48104 United States of America Email:
andrew@moretension.com Nik Teague Iron Mountain Data Centers United Kingdom Email: nteague@ironmountain.co.uk
The following individuals have contributed to this document: Dan Wing Email: dwing ietf@fuggles.com
Jon Shallow NCC Group Email: jon.shallow@nccgroup.com
