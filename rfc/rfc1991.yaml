- title: __initial_text__
  contents:
  - '                      PGP Message Exchange Formats

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  This memo\n   does not specify an Internet standard of any kind.  Distribution\
    \ of\n   this memo is unlimited.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   6.2.4 Miscellaneous fields...................................16\n\
    \   6.3   Compressed data packets................................17\n   6.4  \
    \ Conventional-key-encrypted data packets................17\n   6.4.1 Conventional-encryption\
    \ type byte......................18\n   6.5   Public-key-encrypted packets...........................18\n\
    \   6.5.1 RSA-encrypted data encryption key (DEK)................19\n   6.6  \
    \ Public-key Packets.....................................19\n   6.7   User ID\
    \ packets........................................20\n   7.    Transferable Public\
    \ Keys...............................20\n   8.    Acknowledgments........................................20\n\
    \   9.    Security Considerations................................21\n   10.  \
    \ Authors' Addresses.....................................21\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   PGP (Pretty Good Privacy) uses a combination of public-key\
    \ and\n   conventional encryption to provide security services for electronic\n\
    \   mail messages and data files.  These services include confidentiality\n  \
    \ and digital signature.  PGP is widely used throughout the global\n   computer\
    \ community.  This document describes the format of \"PGP\n   files\", i.e., messages\
    \ that have been encrypted and/or signed with\n   PGP.\n   PGP was created by\
    \ Philip Zimmermann and first released, in Version\n   1.0, in 1991. Subsequent\
    \ versions have been designed and implemented\n   by an all-volunteer collaborative\
    \ effort under the design guidance of\n   Philip Zimmermann.  PGP and Pretty Good\
    \ Privacy are trademarks of\n   Philip Zimmermann.\n   This document describes\
    \ versions 2.x of PGP.  Specifically, versions\n   2.6 and 2.7 conform to this\
    \ specification.  Version 2.3 conforms to\n   this specification with minor differences.\n\
    \   A new release of PGP, known as PGP 3.0, is anticipated in 1995. To\n   the\
    \ maximum extent possible, this version will be upwardly compatible\n   with version\
    \ 2.x. At a minimum, PGP 3.0 will be able to read messages\n   and signatures\
    \ produced by version 2.x.\n"
- title: 2. PGP Services
  contents:
  - "2. PGP Services\n   PGP provides four services related to the format of messages\
    \ and data\n   files: digital signature, confidentiality, compression, and radix-64\n\
    \   conversion.\n"
- title: 2.1 Digital signature
  contents:
  - "2.1 Digital signature\n   The digital signature service involves the use of a\
    \ hash code, or\n   message digest, algorithm, and a public-key encryption algorithm.\
    \ The\n   sequence is as follows:\n     -the sender creates a message\n     -the\
    \ sending PGP generates a hash code of the message\n     -the sending PGP encrypts\
    \ the hash code using the sender's private\n      key\n     -the encrypted hash\
    \ code is prepended to the message\n     -the receiving PGP decrypts the hash\
    \ code using the sender's public\n      key\n     -the receiving PGP generates\
    \ a new hash code for the received\n      message and compares it to the decrypted\
    \ hash code. If the two\n      match, the message is accepted as authentic\n \
    \  Although signatures normally are found attached to the message or\n   file\
    \ that they sign, this is not always the case: detached signatures\n   are supported.\
    \ A detached signature may be stored and transmitted\n   separately from the message\
    \ it signs.  This is useful in several\n   contexts. A user may wish to maintain\
    \ a separate signature log of all\n   messages sent or received.  A detached signature\
    \ of an executable\n   program can detect subsequent virus infection. Finally,\
    \ detached\n   signatures can be used when more than one party must sign a document,\n\
    \   such as a legal contract.  Each person's signature is independent and\n  \
    \ therefore is applied only to the document. Otherwise, signatures\n   would have\
    \ to be nested, with the second signer signing both the\n   document and the first\
    \ signature, and so on.\n"
- title: 2.2 Confidentiality
  contents:
  - "2.2 Confidentiality\n   PGP provides confidentiality by encrypting messages to\
    \ be transmitted\n   or data files to be stored locally using conventional encryption.\
    \ In\n   PGP, each conventional key is used only once. That is, a new key is\n\
    \   generated as a random 128-bit number for each message. Since it is to\n  \
    \ be used only once, the session key is bound to the message and\n   transmitted\
    \ with it.  To protect the key, it is encrypted with the\n   receiver's public\
    \ key. The sequence is as follows:\n     -the sender creates a message\n     -the\
    \ sending PGP generates a random number to be used as a session\n      key for\
    \ this message only\n     -the sending PGP encrypts the message using the session\
    \ key\n     -the session key is encrypted using the recipient's public key and\n\
    \      prepended to the encrypted message\n     -the receiving PGP decrypts the\
    \ session key using the recipient's\n      private key\n     -the receiving PGP\
    \ decrypts the message using the session key\n   Both digital signature and confidentiality\
    \ services may be applied to\n   the same message. First, a signature is generated\
    \ for the message and\n   prepended to the message.  Then, the message plus signature\
    \ is\n   encrypted using a conventional session key. Finally, the session key\n\
    \   is encrypted using public-key encryption and prepended to the\n   encrypted\
    \ block.\n"
- title: 2.3 Compression
  contents:
  - "2.3 Compression\n   As a default, PGP compresses the message after applying the\
    \ signature\n   but before encryption.\n"
- title: 2.4 Radix-64 conversion
  contents:
  - "2.4 Radix-64 conversion\n   When PGP is used, usually part of the block to be\
    \ transmitted is\n   encrypted. If only the signature service is used, then the\
    \ message\n   digest is encrypted (with the sender's private key). If the\n  \
    \ confidentiality service is used, the message plus signature (if\n   present)\
    \ are encrypted (with a one-time conventional key). Thus, part\n   or all of the\
    \ resulting block consists of a stream of arbitrary 8-bit\n   bytes.  However,\
    \ many electronic mail systems only permit the use of\n   blocks consisting of\
    \ ASCII text. To accommodate this restriction, PGP\n   provides the service of\
    \ converting the raw 8-bit binary stream to a\n   stream of printable ASCII characters,\
    \ called ASCII Armor.\n   The scheme used for this purpose is radix-64 conversion.\
    \ Each group\n   of three bytes of binary data is mapped into 4 ASCII characters.\
    \ This\n   format also appends a CRC to detect transmission errors.  This\n  \
    \ radix-64 conversion, also called Ascii Armor, is a wrapper around the\n   binary\
    \ PGP messages, and is used to protect the binary messages\n   during transmission\
    \ over non-binary channels, such as Internet Email.\n   The following table defines\
    \ the mapping.  The characters used are the\n   upper- and lower-case letters,\
    \ the digits 0 through 9, and the\n   characters + and /.  The carriage-return\
    \ and linefeed characters\n   aren't used in the conversion, nor is the tab or\
    \ any other character\n   that might be altered by the mail system. The result\
    \ is a text file\n   that is \"immune\" to the modifications inflicted by mail\
    \ systems.\n   6-bit character   6-bit character   6-bit character   6-bit character\n\
    \   value encoding  value  encoding    value   encoding    value encoding\n  \
    \ 0        A        16        Q        32        g        48        w\n   1  \
    \      B        17        R        33        h        49        x\n   2      \
    \  C        18        S        34        i        50        y\n   3        D \
    \       19        T        35        j        51        z\n   4        E     \
    \   20        U        36        k        52        0\n   5        F        21\
    \        V        37        l        53        1\n   6        G        22    \
    \    W        38        m        54        2\n   7        H        23        X\
    \        39        n        55        3\n   8        I        24        Y    \
    \    40        o        56        4\n   9        J        25        Z        41\
    \        p        57        5\n   1        K        26        a        42    \
    \    q        58        6\n   11       L        27        b        43        r\
    \        59        7\n   12       M        28        c        44        s    \
    \    60        8\n   13       N        29        d        45        t        61\
    \        9\n   14       O        30        e        46        u        62    \
    \    +\n   15       P        31        f        47        v        63        /\n\
    \                                                         (pad)       =\n   It\
    \ is possible to use PGP to convert any arbitrary file to ASCII\n   Armor.  When\
    \ this is done, PGP tries to compress the data before it\n   is converted to Radix-64.\n"
- title: 2.4.1 ASCII Armor Formats
  contents:
  - "2.4.1 ASCII Armor Formats\n   When PGP encodes data into ASCII Armor, it puts\
    \ specific headers\n   around the data, so PGP can reconstruct the data at a future\
    \ time.\n   PGP tries to inform the user what kind of data is encoded in the\n\
    \   ASCII armor through the use of the headers.\n   ASCII Armor is created by\
    \ concatenating the following data:\n        - An Armor Headerline, appropriate\
    \ for the type of data\n        - Armor Headers\n        - A blank line\n    \
    \    - The ASCII-Armored data\n        - An Armor Checksum\n        - The Armor\
    \ Tail (which depends on the Armor Headerline).\n   An Armor Headerline is composed\
    \ by taking the appropriate headerline\n   text surrounded by five (5) dashes\
    \ (-) on either side of the\n   headerline text.  The headerline text is chosen\
    \ based upon the type\n   of data that is being encoded in Armor, and how it is\
    \ being encoded.\n   Headerline texts include the following strings:\n    BEGIN\
    \ PGP MESSAGE -- used for signed, encrypted, or compressed files\n    BEGIN PGP\
    \ PUBLIC KEY BLOCK -- used for transferring public keys\n    BEGIN PGP MESSAGE,\
    \ PART X/Y -- used for multi-part messages, where\n                          \
    \          the armor is split amongst Y files,\n                             \
    \       and this is the Xth file out of Y.\n   The Armor Headers are pairs of\
    \ strings that can give the user or the\n   receiving PGP program some information\
    \ about how to decode or use the\n   message.  The Armor Headers are a part of\
    \ the armor, not a part of\n   the message, and hence should not be used to convey\
    \ any important\n   information, since they can be changed in transport.\n   The\
    \ format of an Armor Header is that of a key-value pair, the\n   encoding of RFC-822\
    \ headers.  PGP should consider improperly\n   formatted Armor Headers to be corruption\
    \ of the ASCII Armor.  Unknown\n   Keys should be reported to the user, but so\
    \ long as the RFC-822\n   formatting is correct, PGP should continue to process\
    \ the message.\n   Currently defined Armor Header Keys include \"Version\" and\
    \ \"Comment\",\n   which define the PGP Version used to encode the message and\
    \ a user-\n   defined comment.\n   The Armor Checksum is a 24-bit CRC converted\
    \ to four bytes of radix-\n   64 encoding, prepending an equal-sign (=) to the\
    \ four-byte code.  The\n   CRC is computed by using the generator 0x864CFB and\
    \ an initialization\n   of 0xB704CE.  The accumulation is done on the data before\
    \ it is\n   converted to radix-64, rather than on the converted data.  For more\n\
    \   information on CRC functions, the reader is asked to look at chapter\n   19\
    \ of the book \"C Programmer's Guide to Serial Communications,\" by\n   Joe Campbell.\n\
    \   The Armor Tail is composed in the same manner as the Armor\n   Headerline,\
    \ except the string \"BEGIN\" is replaced by the string\n   \"END\".\n"
- title: 3. Data Element Formats
  contents:
  - '3. Data Element Formats

    '
- title: 3.1 Byte strings
  contents:
  - "3.1 Byte strings\n   The objects considered in this document are all \"byte strings.\"\
    \  A\n   byte string is a finite sequence of bytes.  The concatenation of byte\n\
    \   string X of length M with byte string Y of length N is a byte string\n   Z\
    \ of length M + N; the first M bytes of Z are the bytes of X in the\n   same order,\
    \ and the remaining N bytes of Z are the bytes of Y in the\n   same order.\n \
    \  Literal byte strings are written from left to right, with pairs of\n   hex\
    \ nibbles separated by spaces, enclosed by angle brackets: for\n   instance, <05\
    \ ff 07> is a byte string of length 3 whose bytes have\n   numeric values 5, 255,\
    \ and 7 in that order.  All numbers in this\n   document outside angle brackets\
    \ are written in decimal.\n   The byte string of length 0 is called \"empty\"\
    \ and written <>.\n"
- title: 3.2 Whole number fields
  contents:
  - "3.2 Whole number fields\n   Purpose.  A whole number field can represent any\
    \ nonnegative integer,\n   in a format where the field length is known in advance.\n\
    \   Definition.  A whole number field is any byte string.  It is stored\n   in\
    \ radix-256 MSB-first format.  This means that a whole number field\n   of length\
    \ N with bytes b_0 b_1 ...  b_{N-2} b_{N-1} in that order has\n   value\n    \
    \  b_0 * 256^{N-1} + b_1 * 256^{N-2} + ... + b_{N-2} * 256 + b_{N-1}.\n   Examples.\
    \  The byte string <00 0D 64 11 00 00> is a valid whole\n   number field with\
    \ value 57513410560.  The byte string <FF> is a valid\n   whole number field with\
    \ value 255.  The byte string <00 00> is a\n   valid whole number field with value\
    \ 0.  The empty byte string <> is a\n   valid whole number field with value 0.\n"
- title: 3.3 Multiprecision fields
  contents:
  - "3.3 Multiprecision fields\n   Purpose.  A multiprecision field can represent\
    \ any nonnegative\n   integer which is not too large.  The field length need not\
    \ be known\n   in advance.  Multiprecision fields are designed to waste very little\n\
    \   space: a small integer uses a short field.\n   Definition.  A multiprecision\
    \ field is the concatenation of two\n   fields:\n      (a) a whole number field\
    \ of length 2, with value B;\n      (b) a whole number field, with value V.\n\
    \   Field (b) is of length [(B+7)/8], i.e., the greatest integer which is\n  \
    \ no larger than (B+7)/8.  The value of the multiprecision field is\n   defined\
    \ to be V.  V must be between 2^{B-1} and 2^B - 1 inclusive.\n   In other words\
    \ B must be exactly the number of significant bits in V.\n   Some implementations\
    \ may limit the possible range of B.  The\n   implementor must document which\
    \ values of B are allowed by an\n   implementation.\n   Examples.  The byte string\
    \ <00 00> is a valid multiprecision integer\n   with value 0.  The byte string\
    \ <00 03 05> is a valid multiprecision\n   field with value 5.  The byte strings\
    \ <00 03 85> and <00 00 00> are\n   not valid multiprecision fields.  The former\
    \ is invalild because <85>\n   has 8 significant bits, not 3; the latter is invalid\
    \ because the\n   second field has too many bytes of data given the value of the\
    \ first\n   field.  The byte string <00 09 01 ff> is a valid multiprecision field\n\
    \   with value 511.  The byte string <01 00 80 00 00 00 00 00 00 00 00 00\n  \
    \ 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 07> is\n   a\
    \ valid multiprecision field with value 2^255 + 7.\n"
- title: 3.4  String fields
  contents:
  - "3.4  String fields\n   Purpose.  A string field represents any sequence of bytes\
    \ of length\n   between 0 and 255 inclusive.  The length need not be known in\n\
    \   advance.  By convention, the content of a string field is normally\n   interpreted\
    \ as ASCII codes when it is displayed.\n   Definition.  A string field is the\
    \ concatenation of the following:\n     (a) a whole number field of length 1,\
    \ with value L;\n     (b) a byte string of length L.\n   The content of the string\
    \ field is defined to be field (b).\n   Examples: <05 48 45 4c 4c 4f> is a valid\
    \ string field which would\n   normally be displayed as the string HELLO.  <00>\
    \ is a valid string\n   field which would normally be displayed as the empty string.\
    \  <01 00>\n   is a valid string field.\n"
- title: 3.5  Time fields
  contents:
  - "3.5  Time fields\n   Purpose.  A time field represents the number of seconds\
    \ elapsed since\n   1970 Jan 1 00:00:00 GMT.  It is compatible with the usual\n\
    \   representation of times under UNIX.\n   Definition.  A time field is a whole\
    \ number field of length 4, with\n   value V.  The time represented by the time\
    \ field is the one-second\n   interval beginning V seconds after 1970 Jan 1 00:00:00\
    \ GMT.\n"
- title: 4. Common Fields
  contents:
  - "4. Common Fields\n   This section defines fields found in more than one packet\
    \ format.\n"
- title: 4.1  Packet structure fields
  contents:
  - "4.1  Packet structure fields\n   Purpose.  The packet structure field distinguishes\
    \ between different\n   types of packets, and indicates the length of packets.\n\
    \   Definition.  A packet structure field is a byte string of length 1,\n   2,\
    \ 3, or 5.  Its first byte is the cipher type byte (CTB), with bits\n   labeled\
    \ 76543210, 7 the most significant bit and 0 the least\n   significant bit.  As\
    \ indicated below the length of the packet\n   structure field is determined by\
    \ the CTB.\n      CTB bits 76 have values listed in the following table:\n   \
    \   10 - normal CTB\n      11 - reserved for future experimental work\n      all\
    \ others - reserved\n   CTB bits 5432, the \"packet type bits\", have values listed\
    \ in the\n   following table:\n      0001 - public-key-encrypted packet\n    \
    \  0010 - signature packet\n      0101 - secret-key certificate packet\n     \
    \ 0110 - public-key certificate packet\n      1000 - compressed data packet\n\
    \      1001 - conventional-key-encrypted packet\n      1011 - literal data packet\n\
    \      1100 - keyring trust packet\n      1101 - user id packet\n      1110 -\
    \ comment packet     (*)\n      all others - reserved\n   CTB bits 10, the \"\
    packet-length length bits\", have values listed in\n   the following table:\n\
    \      00 - 1-byte packet-length field\n      01 - 2-byte packet-length field\n\
    \      10 - 4-byte packet-length field\n      11 - no packet length supplied,\
    \ unknown packet length\n   As indicated in this table, depending on the packet-length\
    \ length\n   bits, the remaining 1, 2, 4, or 0 bytes of the packet structure field\n\
    \   are a \"packet-length field\".  The packet-length field is a whole\n   number\
    \ field.  The value of the packet-length field is defined to be\n   the value\
    \ of the whole number field.\n   A value of 11 is currently used in one place:\
    \ on compressed data.\n   That is, a compressed data block currently looks like\
    \ <A3 01 . .  .>,\n   where <A3>, binary 10 1000 11, is an indefinite-length packet.\
    \ The\n   proper interpretation is \"until the end of the enclosing structure\"\
    ,\n   although it should never appear outermost (where the enclosing\n   structure\
    \ is a file).\n   Options marked with an asterisk (*) are not implemented yet;\
    \ PGP\n   2.6.2 will never output this packet type.\n"
- title: 4.2  Number ID fields
  contents:
  - "4.2  Number ID fields\n   Purpose.  The ID of a whole number is its 64 least\
    \ significant bits.\n   The ID is a convenient way to distinguish between large\
    \ numbers such\n   as keys, without having to transmit the number itself. Thus,\
    \ a number\n   that may be hundreds or thousands of decimal digits in length can\
    \ be\n   identified with a 64-bit identifier. Two keys may have the same ID by\n\
    \   chance or by malice; although the probability that two large keys\n   chosen\
    \ at random would have the same ID is extremely small.\n   Definition.  A number\
    \ ID field is a whole number field of length 8.\n   The value of the number ID\
    \ field is defined to be the value of the\n   whole number field.\n"
- title: 4.3  Version fields
  contents:
  - "4.3  Version fields\n   Many packet types include a version number as the first\
    \ byte of the\n   body.  The format and meaning of the body depend on the version\n\
    \   number.  More versions of packets, with new version numbers, may be\n   defined\
    \ in the future.  An implementation need not support every\n   version of each\
    \ packet type.  However, the implementor must document\n   which versions of each\
    \ packet type are supported by the\n   implementation.\n   A version number of\
    \ 2 or 3 is currently allowed for each packet\n   format.  New versions will probably\
    \ be numbered sequentially up from\n   3.  For backwards compatibility, implementations\
    \ will usually be\n   expected to support version N of a packet whenever they\
    \ support\n   version N+1.  Version 255 may be used for experimental purposes.\n"
- title: 5. Packets
  contents:
  - '5. Packets

    '
- title: 5.1 Overview
  contents:
  - "5.1 Overview\n   A packet is a digital envelope with data inside.  A PGP file,\
    \ by\n   definition, is the concatenation of one or more packets. In addition,\n\
    \   one or more of the packets in a file may be subject to a\n   transformation\
    \ using encryption, compression, or radix-64 conversion.\n   A packet is the concatenation\
    \ of the following:\n      (a) a packet structure field;\n      (b) a byte string\
    \ of some length N.\n   Byte string (b) is called the \"body\" of the packet.\
    \  The value of the\n   packet-length field inside the packet structure field\
    \ (a) must equal\n   N, the length of the body.\n   Other characteristics of the\
    \ packet are determined by the type of the\n   packet.  See the definitions of\
    \ particular packet types for further\n   details.  The CTB packet-type bits inside\
    \ the packet structure always\n   indicate the packet type.\n   Note that packets\
    \ may be nested: one digital envelope may be placed\n   inside another.  For example,\
    \ a conventional-key-encrypted packet\n   contains a disguised packet, which in\
    \ turn might be a compressed data\n   packet.\n"
- title: 5.2  General packet structure
  contents:
  - "5.2  General packet structure\n   A pgp file consists of three components: a\
    \ message component, a\n   signature (optional), and a session key component (optional).\n"
- title: 5.2.1 Message component
  contents:
  - "5.2.1 Message component\n   The message component includes the actual data to\
    \ be stored or\n   transmitted as well as a header that includes control information\n\
    \   generated by PGP. The message component consists of a single literal\n   data\
    \ packet.\n"
- title: 5.2.2 Signature component
  contents:
  - "5.2.2 Signature component\n   The signature component is the signature of the\
    \ message component,\n   formed using a hash code of the message component and\
    \ the public key\n   of the sending PGP entity.  The signature component consists\
    \ of a\n   single signature packet.\n   If the default option of compression is\
    \ chosen, then the block\n   consisting of the literal data packet and the signature\
    \ packet is\n   compressed to form a compressed data packet.\n"
- title: 5.2.3 Session key component
  contents:
  - "5.2.3 Session key component\n   The session key component includes the encrypted\
    \ session key and the\n   identifier of the recipients public key used by the\
    \ sender to encrypt\n   the session key.  The session key component consists of\
    \ a single\n   public-key-encrypted packet for each recipient of the message.\n\
    \   If compression has been used, then conventional encryption is applied\n  \
    \ to the compressed data packet formed from the compression of the\n   signature\
    \ packet and the literal data packet. Otherwise, conventional\n   encryption is\
    \ applied to the block consisting of the signature packet\n   and the literal\
    \ data packet.  In either case, the cyphertext is\n   referred to as a conventional-key-encrypted\
    \ data packet.\n"
- title: 6.  PGP Packet Types
  contents:
  - "6.  PGP Packet Types\n   PGP includes the following types of packets:\n     \
    \  -literal data packet\n       -signature packet\n       -compressed data packet\n\
    \       -conventional-key-encrypted data packet\n       -public-key-encrypted\
    \ packet\n       -public-key packet\n       -User ID packet\n"
- title: 6.1 Literal data packets
  contents:
  - "6.1 Literal data packets\n   Purpose.  A literal data packet is the lowest level\
    \ of contents of a\n   digital envelope.  The data inside a literal data packet\
    \ is not\n   subject to any further interpretation by PGP.\n   Definition.  A\
    \ literal data packet is the concatenation of the\n   following fields:\n    \
    \  (a) a packet structure field;\n      (b) a byte, giving a mode;\n      (c)\
    \ a string field, giving a filename;\n      (d) a time field;\n      (e) a byte\
    \ string of literal data.\n   Fields (b), (c), and (d) suggest how the data should\
    \ be written to a\n   file. Byte (b) is either ASCII b <62>, for binary, or ASCII\
    \ t <74>,\n   for text. Byte (b) may also take on the value ASCII 1, indicating\
    \ a\n   machine-local conversion. It is not defined how PGP will convert this\n\
    \   across platforms.\n   Field (c) suggests a filename. Field (d) should be the\
    \ time at which\n   the file was last modified, or the time at which the data\
    \ packet was\n   created, or 0.\n   Note that only field (e) of a literal data\
    \ packet is fed to a\n   message-digest function for the formation of a signature.\
    \ The\n   exclusion of the other fields ensures that detached signatures are\n\
    \   exactly the same as attached signatures prefixed to the message.\n   Detached\
    \ signatures are calculated on a separate file that has none\n   of the literal\
    \ data packet header fields.\n"
- title: 6.2 Signature packet
  contents:
  - "6.2 Signature packet\n   Purpose.  Signatures are attached to data, in such a\
    \ way that only\n   one entity, called the \"writer,\" can create the signature.\
    \  The\n   writer must first create a \"public key\" K and distribute it.  The\n\
    \   writer keeps certain private data related to K.  Only someone\n   cooperating\
    \ with the writer can sign data using K, enveloping the\n   data in a signature\
    \ packet (also known as a private-key-encrypted\n   packet).  Anyone can look\
    \ through the glass in the envelope and\n   verify that the signature was attached\
    \ to the data using K.  If the\n   data is altered in any way then the verification\
    \ will fail.\n   Signatures have different meanings.  For example, a signature\
    \ might\n   mean \"I wrote this document,\" or \"I received this document.\" \
    \ A\n   signature packet includes a \"classification\" which expresses its\n \
    \  meaning.\n   Definition.  A signature packet, version 2 or 3, is the concatenation\n\
    \   of the following fields:\n      (a) packet structure field (2, 3, or 5 bytes);\n\
    \      (b) version number = 2 or 3 (1 byte);\n      (c) length of following material\
    \ included in MD calculation\n          (1 byte, always the value 5);\n      (d1)\
    \ signature classification (1 byte);\n      (d2) signature time stamp (4 bytes);\n\
    \      (e) key ID for key used for singing (8 bytes);\n      (f) public-key-cryptosystem\
    \ (PKC) type (1 byte);\n      (g) message digest algorithm type (1 byte);\n  \
    \    (h) first two bytes of the MD output, used as a checksum\n          (2 bytes);\n\
    \      (i) a byte string of encrypted data holding the RSA-signed digest.\n  \
    \ The message digest is taken of the bytes of the file, followed by the\n   bytes\
    \ of field (d). It was originally intended that the length (c)\n   could vary,\
    \ but now it seems that it will alwaye remain a constant\n   value of 5, and that\
    \ is the only value that will be accepted.  Thus,\n   only the fields (d1) and\
    \ (d2) will be hashed into the signature along\n   with the main message.\n"
- title: 6.2.1 Message-digest-related fields
  contents:
  - "6.2.1 Message-digest-related fields\n   The message digest algorithm is specified\
    \ by the message digest (MD)\n   number of field (g). The following MD numbers\
    \ are currently defined:\n      1 - MD5 (output length 16)\n      255 - experimental\n\
    \   More MD numbers may be defined in the future.  An implementation need\n  \
    \ not support every MD number.  The implementor must document the MD\n   numbers\
    \ understood by an implementation.\n   A message digest algorithm reads a byte\
    \ string of any length, and\n   writes a byte string of some fixed length, as\
    \ indicated in the table\n   above.\n   The input to the message digest algorithm\
    \ is the concatenation of\n   some \"primary input\" and some \"appended input.\"\
    \n   The appended input is specified by field (c), which gives a number of\n \
    \  bytes to be taken from the following fields: (d1), (d2), and so on.\n   The\
    \ current implementation uses the value 5 for this number, for\n   fields (d1)\
    \ and (d2).  Any field not included in the appended input\n   is not \"signed\"\
    \ by field (i).\n   The primary input is determined by the signature classification\
    \ byte\n   (d1).  Byte (d1) is one of the following hex numbers, with these\n\
    \   meanings:\n     <00> - document signature, binary image (\"I wrote this document\"\
    )\n     <01> - document signature, canonical text (\"I wrote this document\")\n\
    \     <10> - public key packet and user ID packet, generic certification\n   \
    \       (\"I think this key was created by this user, but I won't say\n      \
    \    how sure I am\")\n     <11> - public key packet and user ID packet, persona\
    \ certification\n          (\"This key was created by someone who has told me\
    \ that he is\n          this user\") (#)\n     <12> - public key packet and user\
    \ ID packet, casual certification\n          (\"This key was created by someone\
    \ who I believe, after casual\n          verification, to be this user\")  (#)\n\
    \     <13> - public key packet and user ID packet, positive certification\n  \
    \        (\"This key was created by someone who I believe, after\n          heavy-duty\
    \ identification such as picture ID, to be this\n          user\")  (#)\n    \
    \ <20> - public key packet, key compromise (\"This is my key, and I\n        \
    \  have revoked it\")\n     <30> - public key packet and user ID packet, revocation\
    \ (\"I retract\n          all my previous statements that this key is related\
    \ to this\n          user\")  (*)\n     <40> - time stamping (\"I saw this document\"\
    ) (*)\n   More classification numbers may be defined in the future to handle\n\
    \   other meanings of signatures, but only the above numbers may be used\n   with\
    \ version 2 or version 3 of a signature packet.  It should be\n   noted that PGP\
    \ 2.6.2 has not implemented the packets marked with an\n   asterisk (*), and the\
    \ packets marked with a hash (#) are not output\n   by PGP 2.6.2.\n   Signature\
    \ packets are used in two different contexts. One (signature\n   type <00> or\
    \ <01>) is of text (either the contents of a literal\n   packet or a separate\
    \ file), while types <10> through <1F> appear only\n   in key files, after the\
    \ keys and user IDs that they sign.  Type <20>\n   appears in key files, after\
    \ the keys that it signs, and type <30>\n   also appears after a key/userid combination.\
    \ Type <40> is intended to\n   be a signature of a signature, as a notary seal\
    \ on a signed document.\n   The output of the message digest algorithm is a message\
    \ digest, or\n   hash code. Field i contains the cyphertext produced by encrypting\
    \ the\n   message digest with the signer's private key.  Field h contains the\n\
    \   first two bytes of the unencrypted message digest. This enables the\n   recipient\
    \ to determine if the correct public key was used to decrypt\n   the message digest\
    \ for authentication, by comparing this plaintext\n   copy of the first two byes\
    \ with the first two bytes of the decrypted\n   digest. These two bytes also serve\
    \ as a 16-bit frame check sequence\n   for the message.\n"
- title: 6.2.2 Public-key-related fields
  contents:
  - "6.2.2 Public-key-related fields\n   The message digest is signed by encrypting\
    \ it using the writer's\n   private key. Field (e) is the ID of the corresponding\
    \ public key.\n   The public-key-encryption algorithm is specified by the public-key\n\
    \   cryptosystem (PKC) number of field (f). The following PKC numbers are\n  \
    \ currently defined:\n      1 - RSA\n      255 - experimental\n   More PKC numbers\
    \ may be defined in the future.  An implementation\n   need not support every\
    \ PKC number.  The implementor must document the\n   PKC numbers understood by\
    \ an implementation.\n   A PKC number identifies both a public-key encryption\
    \ method and a\n   signature method.  Both of these methods are fully defined\
    \ as part of\n   the definition of the PKC number.  Some cryptosystems are usable\
    \ only\n   for encryption, or only for signatures; if any such PKC numbers are\n\
    \   defined in the future, they will be marked appropriately.\n"
- title: 6.2.3 RSA signatures
  contents:
  - "6.2.3 RSA signatures\n   An RSA-signed byte string is a multiprecision field\
    \ that is formed by\n   taking the message digest and filling in an ASN structure,\
    \ and then\n   encrypting the whole byte string in the RSA key of the signer.\n\
    \   PGP versions 2.3 and later encode the MD into a PKCS-format signature\n  \
    \ string, which has the following format:\n          MSB               .   . \
    \  .                    LSB\n          0   1   <FF>(n bytes)   0   ASN(18 bytes)\
    \   MD(16 bytes)\n   See RFC1423 for an explanation of the meaning of the ASN\
    \ string.  It\n   is the following 18 byte long hex value:\n          <30 20 30\
    \ 0C 06 08 2A 86 48 86 F7 0D 02 05 05 00 04 10>\n   Enough bytes of <FF> padding\
    \ are added to make the length of this\n   whole string equal to the number of\
    \ bytes in the modulus.\n"
- title: 6.2.4 Miscellaneous fields
  contents:
  - "6.2.4 Miscellaneous fields\n   The timestamp field (d2) is analogous to the date\
    \ box next to a\n   signature box on a form.  It represents a time which is typically\n\
    \   close to the moment that the signature packet was created.  However,\n   this\
    \ is not a requirement.  Users may choose to date their signatures\n   as they\
    \ wish, just as they do now in handwritten signatures.\n   If an application requires\
    \ the creation of trusted timestamps on\n   signatures, a detached signature certificate\
    \ with an untrusted\n   timestamp may be submitted to a trusted timestamp notary\
    \ service to\n   sign the signature packet with another signature packet, creating\
    \ a\n   signature of a signature.  The notary's signature's timestamp could\n\
    \   be used as the trusted \"legal\" time of the original signature.\n"
- title: 6.3 Compressed data packets
  contents:
  - "6.3 Compressed data packets\n   Purpose.  A compressed data packet is an envelope\
    \ which safely\n   squeezes its contents into a small space.\n   Definition. \
    \ A compressed data packet is the concatenation of the\n   following fields:\n\
    \      (a) a packet structure field;\n      (b) a byte, giving a compression type;\n\
    \      (c) a byte string of compressed data.\n   Byte string (c) is a packet which\
    \ may be decompressed using the\n   algorithm identified in byte (b).  Typically,\
    \ the data that are\n   compressed consist of a literal data packet or a signature\
    \ packet\n   concatenated to a literal data packet.\n   A compression type selects\
    \ a compression algorithm for use in\n   compressed data packets.  The following\
    \ compression numbers are\n   currently defined.\n      1 - ZIP\n      255 - experimental\n\
    \   More compression numbers may be defined in the future.  An\n   implementation\
    \ need not support every MD number.  The implementor\n   must document the compression\
    \ numbers understood by an\n   implementation.\n"
- title: 6.4 Conventional-key-encrypted data packets
  contents:
  - "6.4 Conventional-key-encrypted data packets\n   Purpose.  A conventional-key-encrypted\
    \ data packet is formed by\n   encrypting a block of data with a conventional\
    \ encryption algorithm\n   using a one-time session key. Typically, the block\
    \ to be encrypted is\n   a compressed data packet.\n   Definition.  A conventional-key-encrypted\
    \ data packet is the\n   concatenation of the following fields:\n      (a) a packet\
    \ structure field;\n      (b) a byte string of encrypted data.\n   The plaintext\
    \ or compressed plaintext that is encrypted to form field\n   (b) is first prepended\
    \ with 64 bits of random data plus 16 \"key\n   check\" bits.  The random prefix\
    \ serves to start off the cipher\n   feedback chaining process with 64 bits of\
    \ random material; this\n   serves the same function as an initialization vector\
    \ (IV) for a\n   cipher-block-chaining encryption scheme.  The key check prefix\
    \ is\n   equal to the last 16 bits of the random prefix. During decryption, a\n\
    \   comparison is made to see if the 7th and 8th byte of the decrypted\n   material\
    \ match the 9th and 10th bytes.  If so, then the conventional\n   session key\
    \ used for decryption is assumed to be correct.\n"
- title: 6.4.1 Conventional-encryption type byte
  contents:
  - "6.4.1 Conventional-encryption type byte\n   Purpose.  The conventional-encryption\
    \ type byte is used to determine\n   what conventional encryption algorithm is\
    \ in use.  The algorithm type\n   byte will also define how long the conventional\
    \ encryption key is,\n   based upon the algorithm in use.\n   Definition.  A conventional-encryption\
    \ type byte is a single byte\n   which defines the algorithm in use.  It is possible\
    \ that the\n   algorithm in use may require further definition, such as key-length.\n\
    \   It is up to the implementor to document the supported key-length in\n   such\
    \ a situation.\n      1 - IDEA (16-byte key)\n      255 - experimental\n"
- title: 6.5 Public-key-encrypted packets
  contents:
  - "6.5 Public-key-encrypted packets\n   Purpose.  The public-key-encrypted packet\
    \ is the format for the\n   session key component of a message. The purpose of\
    \ this packet is to\n   convey the one-time session key used to encrypt the message\
    \ to the\n   recipient in a secure manner. This is done by encrypting the session\n\
    \   key with the recipient's public key, so that only the recipient can\n   recover\
    \ the session key.\n   Definition.  A public-key-encrypted packet, version 2 or\
    \ 3, is the\n   concatenation of the following fields:\n      (a) a packet structure\
    \ field;\n      (b) a byte, giving the version number, 2 or 3;\n      (c) a number\
    \ ID field, giving the ID of a key;\n      (d) a byte, giving a PKC number;\n\
    \      (e) a byte string of encrypted data (DEK).\n   Byte string (e) represents\
    \ the value of the session key, encrypted\n   using the reader's public key K,\
    \ under the cryptosystem identified in\n   byte (d).\n   The value of field (c)\
    \ is the ID of K.\n   Note that the packet does not actually identify K: two keys\
    \ may have\n   the same ID, by chance or by malice.  Normally it will be obvious\n\
    \   from the context which key K was used to create the packet.  But\n   sometimes\
    \ it is not obvious.  In this case field (c) is useful.  If,\n   for example,\
    \ a reader has created several keys, and receives a\n   message, then he should\
    \ attempt to decrypt the message only with the\n   key whose ID matches the value\
    \ of field (c).  If he has accidentally\n   generated two keys with the same ID,\
    \ then he must attempt to decrypt\n   the message with both keys, but this case\
    \ is highly unlikely to occur\n   by chance.\n"
- title: 6.5.1 RSA-encrypted data encryption key (DEK)
  contents:
  - "6.5.1 RSA-encrypted data encryption key (DEK)\n   The Data Encryption Key (DEK)\
    \ is a multiprecision field which stores\n   an RSA encrypted byte string.  The\
    \ byte string is a PKCS encoding of\n   the secret key used the encrypt the message,\
    \ with random padding for\n   each Public-Key encrypted packet.\n   PGP version\
    \ 2.3 and later encode the DEK into an MPI using the\n   following format:\n \
    \    MSB                       .   .   .                       LSB\n      0  \
    \ 2   RND(n bytes)   0  ALG(1 byte)  DEK(k bytes)  CSUM(2 bytes)\n   ALG refers\
    \ to the algorithm byte for the secret key algorithm used to\n   encrypt the data\
    \ packet.  The DEK is the actual Data Encryption Key,\n   and its size is dependent\
    \ upon the encryption algorithm defined by\n   ALG.  For the IDEA encryption algorithm,\
    \ type byte 1, the DEK is 16\n   bytes long.  CSUM is a 16-bit checksum of the\
    \ DEK, used to determine\n   that the correct Private key was used to decrypt\
    \ this packet.  The\n   checksum is computed by the 16-bit sum of the bytes in\
    \ the DEK.  RND\n   is random padding to expand the byte to fill the size of the\
    \ RSA\n   Public Key that is used to encrypt the whole byte.\n"
- title: 6.6 Public Key Packet
  contents:
  - "6.6 Public Key Packet\n   Purpose.  A public key packet defines an RSA public\
    \ key.\n   Definition.  A public key packet is the concatenation of the\n   following\
    \ fields:\n      (a) packet structure field (2 or 3 bytes);\n      (b) version\
    \ number = 2 or 3 (1 byte);;\n      (c) time stamp of key creation (4 bytes);\n\
    \      (d) validity period in days (0 means forever) (2 bytes);\n      (e) public-key-cryptosystem\
    \ (PKC) type (1 byte);\n      (f) MPI of RSA public modulus n;\n      (g) MPI\
    \ of RSA public encryption exponent e.\n    The validity period is always set\
    \ to 0.\n"
- title: 6.7 User ID Packet
  contents:
  - "6.7 User ID Packet\n   Purpose.  A user ID packet identifies a user and is associated\
    \ with a\n   public or private key.\n   Definition.  A user ID packet is the concatenation\
    \ of the following\n   fields:\n      (a) packet structure field (2 bytes);\n\
    \      (b) User ID string.\n   The User ID string may be any string of printable\
    \ ASCII characters.\n   However, since the purpose of this packet is to uniquely\
    \ identify an\n   individual, the usual practice is for the User ID string to\
    \ consist\n   of the user's name followed by an e-mail address for that user,\
    \ the\n   latter enclosed in angle brackets.\n"
- title: 7. Transferable Public Keys
  contents:
  - "7. Transferable Public Keys\n   Public keys may transferred between PGP users.\
    \ The essential elements\n   of a transferable public key are\n      (a) One public\
    \ key packet;\n      (b) One or more user ID packets;\n      (c) Zero or more\
    \ signature packets\n   The public key packet occurs first.  Each of the following\
    \ user ID\n   packets provides the identity of the owner of this public key. \
    \ If\n   there are multiple user ID packets, this corresponds to multiple\n  \
    \ means of identifying the same unique individual user; for example, a\n   user\
    \ may enjoy the use of more than one e-mail address, and construct\n   a user\
    \ ID packet for each one.  Immediately following each user ID\n   packet, there\
    \ are zero or more signature packets. Each signature\n   packet is calculated\
    \ on the immediately preceding user ID packet and\n   the initial public key packet.\
    \  The signature serves to certify the\n   corresponding public key and user ID.\
    \  In effect, the signer is\n   testifying to his or her belief that this public\
    \ key belongs to the\n   user identified by this user ID.\n"
- title: 8. Acknowledgments
  contents:
  - "8. Acknowledgments\n   Philip Zimmermann is the creator of PGP 1.0, which is\
    \ the precursor\n   of PGP 2.x.  Major parts of later versions of PGP have been\n\
    \   implemented by an international collaborative effort involving a\n   large\
    \ number of contributors, under the design guidance of Philip\n   Zimmermann.\n"
- title: 9. Security Considerations
  contents:
  - "9. Security Considerations\n   Security issues are discussed throughout this\
    \ memo.\n"
- title: 10. Authors' Addresses
  contents:
  - "10. Authors' Addresses\n   Derek Atkins\n   12 Rindge Ave. #1R\n   Cambridge,\
    \ MA\n   Phone: +1 617 868-4469\n   EMail: warlord@MIT.EDU\n   William Stallings\n\
    \   Comp-Comm Consulting\n   P. O. Box 2405\n   Brewster, MA 02631\n   EMail:\
    \ stallings@ACM.org\n   Philip Zimmermann\n   Boulder Software Engineering\n \
    \  3021 Eleventh Street\n   Boulder, Colorado 80304  USA\n   Phone: +1-303-541-0140\n\
    \   EMail: prz@acm.org\n"
