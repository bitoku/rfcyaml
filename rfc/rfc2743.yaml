- title: __initial_text__
  contents:
  - "         Generic Security Service Application Program Interface\n           \
    \               Version 2, Update 1\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   The Generic Security Service Application Program Interface (GSS-API),\n\
    \   Version 2, as defined in [RFC-2078], provides security services to\n   callers\
    \ in a generic fashion, supportable with a range of underlying\n   mechanisms\
    \ and technologies and hence allowing source-level\n   portability of applications\
    \ to different environments. This\n   specification defines GSS-API services and\
    \ primitives at a level\n   independent of underlying mechanism and programming\
    \ language\n   environment, and is to be complemented by other, related\n   specifications:\n\
    \      documents defining specific parameter bindings for particular\n      language\
    \ environments\n      documents defining token formats, protocols, and procedures\
    \ to be\n      implemented in order to realize GSS-API services atop particular\n\
    \      security mechanisms\n   This memo obsoletes [RFC-2078], making specific,\
    \ incremental changes\n   in response to implementation experience and liaison\
    \ requests. It is\n   intended, therefore, that this memo or a successor version\
    \ thereto\n   will become the basis for subsequent progression of the GSS-API\n\
    \   specification on the standards track.\n"
- title: TABLE OF CONTENTS
  contents:
  - "TABLE OF CONTENTS\n   1: GSS-API Characteristics and Concepts . . . . . . . .\
    \ . . . .  4\n   1.1: GSS-API Constructs . . . . . . . . . . . . . . . . . . .\
    \ .  6\n   1.1.1:  Credentials . . . . . . . . . . . . . . . . . . . . . .  6\n\
    \   1.1.1.1: Credential Constructs and Concepts . . . . . . . . . .  6\n   1.1.1.2:\
    \ Credential Management  . . . . . . . . . . . . . . . .  7\n   1.1.1.3: Default\
    \ Credential Resolution  . . . . . . . . . . . .  8\n   1.1.2: Tokens . . . .\
    \ . . . . . . . . . . . . . . . . . . . . .  9\n   1.1.3:  Security Contexts .\
    \ . . . . . . . . . . . . . . . . . . 11\n   1.1.4:  Mechanism Types . . . . .\
    \ . . . . . . . . . . . . . . . 12\n   1.1.5:  Naming  . . . . . . . . . . . .\
    \ . . . . . . . . . . . . 13\n   1.1.6:  Channel Bindings  . . . . . . . . . .\
    \ . . . . . . . . . 16\n   1.2:  GSS-API Features and Issues . . . . . . . . .\
    \ . . . . . . 17\n   1.2.1:  Status Reporting  and Optional Service Support  .\
    \ . . . 17\n   1.2.1.1: Status Reporting . . . . . . . . . . . . . . . . . . .\
    \ 17\n   1.2.1.2: Optional Service Support . . . . . . . . . . . . . . . 19\n\
    \   1.2.2: Per-Message Security Service Availability  . . . . . . . 20\n   1.2.3:\
    \ Per-Message Replay Detection and Sequencing  . . . . . . 21\n   1.2.4:  Quality\
    \ of Protection . . . . . . . . . . . . . . . . . 24\n   1.2.5: Anonymity Support\
    \  . . . . . . . . . . . . . . . . . . . 25\n   1.2.6: Initialization . . . .\
    \ . . . . . . . . . . . . . . . . . 25\n   1.2.7: Per-Message Protection During\
    \ Context Establishment  . . 26\n   1.2.8: Implementation Robustness  . . . .\
    \ . . . . . . . . . . . 27\n   1.2.9: Delegation . . . . . . . . . . . . . . .\
    \ . . . . . . . . 28\n   1.2.10: Interprocess Context Transfer . . . . . . . .\
    \ . . . . . 28\n   2:  Interface Descriptions  . . . . . . . . . . . . . . . .\
    \ . . 29\n   2.1:  Credential management calls . . . . . . . . . . . . . . . 31\n\
    \   2.1.1:  GSS_Acquire_cred call . . . . . . . . . . . . . . . . . 31\n   2.1.2:\
    \  GSS_Release_cred call . . . . . . . . . . . . . . . . . 34\n   2.1.3:  GSS_Inquire_cred\
    \ call . . . . . . . . . . . . . . . . . 35\n   2.1.4:  GSS_Add_cred call . .\
    \ . . . . . . . . . . . . . . . . . 37\n   2.1.5:  GSS_Inquire_cred_by_mech call\
    \ . . . . . . . . . . . . . 40\n   2.2:  Context-level calls . . . . . . . . .\
    \ . . . . . . . . . . 41\n   2.2.1:  GSS_Init_sec_context call . . . . . . . .\
    \ . . . . . . . 42\n   2.2.2:  GSS_Accept_sec_context call . . . . . . . . . .\
    \ . . . . 49\n   2.2.3:  GSS_Delete_sec_context call . . . . . . . . . . . . .\
    \ . 53\n   2.2.4:  GSS_Process_context_token call  . . . . . . . . . . . . 54\n\
    \   2.2.5:  GSS_Context_time call . . . . . . . . . . . . . . . . . 55\n   2.2.6:\
    \  GSS_Inquire_context call  . . . . . . . . . . . . . . . 56\n   2.2.7:  GSS_Wrap_size_limit\
    \ call  . . . . . . . . . . . . . . . 57\n   2.2.8:  GSS_Export_sec_context call\
    \ . . . . . . . . . . . . . . 59\n   2.2.9:  GSS_Import_sec_context call . . .\
    \ . . . . . . . . . . . 61\n   2.3:  Per-message calls . . . . . . . . . . . .\
    \ . . . . . . . . 62\n   2.3.1:  GSS_GetMIC call . . . . . . . . . . . . . . .\
    \ . . . . . 63\n   2.3.2:  GSS_VerifyMIC call  . . . . . . . . . . . . . . . .\
    \ . . 64\n   2.3.3:  GSS_Wrap call . . . . . . . . . . . . . . . . . . . . . 65\n\
    \   2.3.4:  GSS_Unwrap call . . . . . . . . . . . . . . . . . . . . 66\n   2.4:\
    \  Support calls . . . . . . . . . . . . . . . . . . . . . . 68\n   2.4.1:  GSS_Display_status\
    \ call . . . . . . . . . . . . . . . . 68\n   2.4.2:  GSS_Indicate_mechs call\
    \ . . . . . . . . . . . . . . . . 69\n   2.4.3:  GSS_Compare_name call . . . .\
    \ . . . . . . . . . . . . . 70\n   2.4.4:  GSS_Display_name call . . . . . . .\
    \ . . . . . . . . . . 71\n   2.4.5:  GSS_Import_name call  . . . . . . . . . .\
    \ . . . . . . . 72\n   2.4.6:  GSS_Release_name call . . . . . . . . . . . . .\
    \ . . . . 73\n   2.4.7:  GSS_Release_buffer call . . . . . . . . . . . . . . .\
    \ . 74\n   2.4.8:  GSS_Release_OID_set call  . . . . . . . . . . . . . . . 74\n\
    \   2.4.9:  GSS_Create_empty_OID_set call . . . . . . . . . . . . . 75\n   2.4.10:\
    \ GSS_Add_OID_set_member call . . . . . . . . . . . . . . 76\n   2.4.11: GSS_Test_OID_set_member\
    \ call  . . . . . . . . . . . . . 76\n   2.4.12: GSS_Inquire_names_for_mech call\
    \ . . . . . . . . . . . . 77\n   2.4.13: GSS_Inquire_mechs_for_name call . . .\
    \ . . . . . . . . . 77\n   2.4.14: GSS_Canonicalize_name call  . . . . . . . .\
    \ . . . . . . 78\n   2.4.15: GSS_Export_name call  . . . . . . . . . . . . . .\
    \ . . . 79\n   2.4.16: GSS_Duplicate_name call . . . . . . . . . . . . . . . .\
    \ 80\n   3: Data Structure Definitions for GSS-V2 Usage  . . . . . . . . 81\n\
    \   3.1: Mechanism-Independent Token Format . . . . . . . . . . . . 81\n   3.2:\
    \ Mechanism-Independent Exported Name Object Format  . . . . 84\n   4: Name Type\
    \ Definitions  . . . . . . . . . . . . . . . . . . . 85\n   4.1: Host-Based Service\
    \ Name Form . . . . . . . . . . . . . . . 85\n   4.2: User Name Form . . . . .\
    \ . . . . . . . . . . . . . . . . . 86\n   4.3: Machine UID Form . . . . . . .\
    \ . . . . . . . . . . . . . . 87\n   4.4: String UID Form  . . . . . . . . . .\
    \ . . . . . . . . . . . 87\n   4.5: Anonymous Nametype . . . . . . . . . . . .\
    \ . . . . . . . . 87\n   4.6: GSS_C_NO_OID . . . . . . . . . . . . . . . . . .\
    \ . . . . . 88\n   4.7: Exported Name Object . . . . . . . . . . . . . . . . .\
    \ . . 88\n   4.8: GSS_C_NO_NAME  . . . . . . . . . . . . . . . . . . . . . . 88\n\
    \   5:  Mechanism-Specific Example Scenarios  . . . . . . . . . . . 88\n   5.1:\
    \ Kerberos V5, single-TGT  . . . . . . . . . . . . . . . . . 89\n   5.2: Kerberos\
    \ V5, double-TGT  . . . . . . . . . . . . . . . . . 89\n   5.3:  X.509 Authentication\
    \ Framework  . . . . . . . . . . . . . 90\n   6:  Security Considerations . .\
    \ . . . . . . . . . . . . . . . . 91\n   7:  Related Activities  . . . . . . .\
    \ . . . . . . . . . . . . . 92\n   8:  Referenced Documents  . . . . . . . . .\
    \ . . . . . . . . . . 93\n   Appendix A: Mechanism Design Constraints  . . . .\
    \ . . . . . . . 94\n   Appendix B: Compatibility with GSS-V1 . . . . . . . . .\
    \ . . . . 94\n   Appendix C: Changes Relative to RFC-2078  . . . . . . . . . .\
    \ . 96\n   Author's Address  . . . . . . . . . . . . . . . . . . . . . . .100\n\
    \   Full Copyright Statement  . . . . . . . . . . . . . . . . . . .101\n"
- title: '1: GSS-API Characteristics and Concepts'
  contents:
  - "1: GSS-API Characteristics and Concepts\n   GSS-API operates in the following\
    \ paradigm.  A typical GSS-API caller\n   is itself a communications protocol,\
    \ calling on GSS-API in order to\n   protect its communications with authentication,\
    \ integrity, and/or\n   confidentiality security services.  A GSS-API caller accepts\
    \ tokens\n   provided to it by its local GSS-API implementation and transfers\
    \ the\n   tokens to a peer on a remote system; that peer passes the received\n\
    \   tokens to its local GSS-API implementation for processing. The\n   security\
    \ services available through GSS-API in this fashion are\n   implementable (and\
    \ have been implemented) over a range of underlying\n   mechanisms based on secret-key\
    \ and public-key cryptographic\n   technologies.\n   The GSS-API separates the\
    \ operations of initializing a security\n   context between peers, achieving peer\
    \ entity authentication\n   (GSS_Init_sec_context() and GSS_Accept_sec_context()\
    \ calls), from the\n   operations of providing per-message data origin authentication\
    \ and\n   data integrity protection (GSS_GetMIC() and GSS_VerifyMIC() calls)\n\
    \   for messages subsequently transferred in conjunction with that\n   context.\
    \  (The definition for the peer entity authentication service,\n   and other definitions\
    \ used in this document, corresponds to that\n   provided in [ISO-7498-2].) When\
    \ establishing a security context, the\n   GSS-API enables a context initiator\
    \ to optionally permit its\n   credentials to be delegated, meaning that the context\
    \ acceptor may\n   initiate further security contexts on behalf of the initiating\n\
    \   caller. Per-message GSS_Wrap() and GSS_Unwrap() calls provide the\n   data\
    \ origin authentication and data integrity services which\n   GSS_GetMIC() and\
    \ GSS_VerifyMIC() offer, and also support selection of\n   confidentiality services\
    \ as a caller option. Additional calls provide\n   supportive functions to the\
    \ GSS-API's users.\n   The following paragraphs provide an example illustrating\
    \ the\n   dataflows involved in use of the GSS-API by a client and server in a\n\
    \   mechanism-independent fashion, establishing a security context and\n   transferring\
    \ a protected message. The example assumes that credential\n   acquisition has\
    \ already been completed.  The example also assumes\n   that the underlying authentication\
    \ technology is capable of\n   authenticating a client to a server using elements\
    \ carried within a\n   single token, and of authenticating the server to the client\
    \ (mutual\n   authentication) with a single returned token; this assumption holds\n\
    \   for some presently-documented CAT mechanisms but is not necessarily\n   true\
    \ for other cryptographic technologies and associated protocols.\n   The client\
    \ calls GSS_Init_sec_context() to establish a security\n   context to the server\
    \ identified by targ_name, and elects to set the\n   mutual_req_flag so that mutual\
    \ authentication is performed in the\n   course of context establishment. GSS_Init_sec_context()\
    \ returns an\n   output_token to be passed to the server, and indicates\n   GSS_S_CONTINUE_NEEDED\
    \ status pending completion of the mutual\n   authentication sequence. Had mutual_req_flag\
    \ not been set, the\n   initial call to GSS_Init_sec_context() would have returned\n\
    \   GSS_S_COMPLETE status. The client sends the output_token to the\n   server.\n\
    \   The server passes the received token as the input_token parameter to\n   GSS_Accept_sec_context().\
    \  GSS_Accept_sec_context indicates\n   GSS_S_COMPLETE status, provides the client's\
    \ authenticated identity\n   in the src_name result, and provides an output_token\
    \ to be passed to\n   the client. The server sends the output_token to the client.\n\
    \   The client passes the received token as the input_token parameter to\n   a\
    \ successor call to GSS_Init_sec_context(), which processes data\n   included\
    \ in the token in order to achieve mutual authentication from\n   the client's\
    \ viewpoint. This call to GSS_Init_sec_context() returns\n   GSS_S_COMPLETE status,\
    \ indicating successful mutual authentication\n   and the completion of context\
    \ establishment for this example.\n   The client generates a data message and\
    \ passes it to GSS_Wrap().\n   GSS_Wrap() performs data origin authentication,\
    \ data integrity, and\n   (optionally) confidentiality processing on the message\
    \ and\n   encapsulates the result into output_message, indicating\n   GSS_S_COMPLETE\
    \ status. The client sends the output_message to the\n   server.\n   The server\
    \ passes the received message to GSS_Unwrap().  GSS_Unwrap()\n   inverts the encapsulation\
    \ performed by GSS_Wrap(), deciphers the\n   message if the optional confidentiality\
    \ feature was applied, and\n   validates the data origin authentication and data\
    \ integrity checking\n   quantities. GSS_Unwrap() indicates successful validation\
    \ by returning\n   GSS_S_COMPLETE status along with the resultant output_message.\n\
    \   For purposes of this example, we assume that the server knows by\n   out-of-band\
    \ means that this context will have no further use after\n   one protected message\
    \ is transferred from client to server. Given\n   this premise, the server now\
    \ calls GSS_Delete_sec_context() to flush\n   context-level information.  Optionally,\
    \ the server-side application\n   may provide a token buffer to GSS_Delete_sec_context(),\
    \ to receive a\n   context_token to be transferred to the client in order to request\n\
    \   that client-side context-level information be deleted.\n   If a context_token\
    \ is transferred, the client passes the\n   context_token to GSS_Process_context_token(),\
    \ which returns\n   GSS_S_COMPLETE status after deleting context-level information\
    \ at the\n   client system.\n   The GSS-API design assumes and addresses several\
    \ basic goals,\n   including:\n      Mechanism independence: The GSS-API defines\
    \ an interface to\n      cryptographically implemented strong authentication and\
    \ other\n      security services at a generic level which is independent of\n\
    \      particular underlying mechanisms. For example, GSS-API-provided\n     \
    \ services have been implemented using secret-key technologies\n      (e.g., Kerberos,\
    \ per [RFC-1964]) and with public-key approaches\n      (e.g., SPKM, per [RFC-2025]).\n\
    \      Protocol environment independence: The GSS-API is independent of\n    \
    \  the communications protocol suites with which it is employed,\n      permitting\
    \ use in a broad range of protocol environments. In\n      appropriate environments,\
    \ an intermediate implementation \"veneer\"\n      which is oriented to a particular\
    \ communication protocol may be\n      interposed between applications which call\
    \ that protocol and the\n      GSS-API (e.g., as defined in [RFC-2203] for Open\
    \ Network Computing\n      Remote Procedure Call (RPC)), thereby invoking GSS-API\
    \ facilities\n      in conjunction with that protocol's communications invocations.\n\
    \      Protocol association independence: The GSS-API's security context\n   \
    \   construct is independent of communications protocol association\n      constructs.\
    \ This characteristic allows a single GSS-API\n      implementation to be utilized\
    \ by a variety of invoking protocol\n      modules on behalf of those modules'\
    \ calling applications. GSS-API\n      services can also be invoked directly by\
    \ applications, wholly\n      independent of protocol associations.\n      Suitability\
    \ to a range of implementation placements: GSS-API\n      clients are not constrained\
    \ to reside within any Trusted Computing\n      Base (TCB) perimeter defined on\
    \ a system where the GSS-API is\n      implemented; security services are specified\
    \ in a manner suitable\n      to both intra-TCB and extra-TCB callers.\n"
- title: '1.1: GSS-API Constructs'
  contents:
  - "1.1: GSS-API Constructs\n   This section describes the basic elements comprising\
    \ the GSS-API.\n"
- title: '1.1.1:  Credentials'
  contents:
  - '1.1.1:  Credentials

    '
- title: '1.1.1.1: Credential Constructs and Concepts'
  contents:
  - "1.1.1.1: Credential Constructs and Concepts\n   Credentials provide the prerequisites\
    \ which permit GSS-API peers to\n   establish security contexts with each other.\
    \ A caller may designate\n   that the credential elements which are to be applied\
    \ for context\n   initiation or acceptance be selected by default.  Alternately,\
    \ those\n   GSS-API callers which need to make explicit selection of particular\n\
    \   credentials structures may make references to those credentials\n   through\
    \ GSS-API-provided credential handles (\"cred_handles\").  In all\n   cases, callers'\
    \ credential references are indirect, mediated by GSS-\n   API implementations\
    \ and not requiring callers to access the selected\n   credential elements.\n\
    \   A single credential structure may be used to initiate outbound\n   contexts\
    \ and to accept inbound contexts. Callers needing to operate\n   in only one of\
    \ these modes may designate this fact when credentials\n   are acquired for use,\
    \ allowing underlying mechanisms to optimize\n   their processing and storage\
    \ requirements. The credential elements\n   defined by a particular mechanism\
    \ may contain multiple cryptographic\n   keys, e.g., to enable authentication\
    \ and message encryption to be\n   performed with different algorithms.\n   A\
    \ GSS-API credential structure may contain multiple credential\n   elements, each\
    \ containing mechanism-specific information for a\n   particular underlying mechanism\
    \ (mech_type), but the set of elements\n   within a given credential structure\
    \ represent a common entity.  A\n   credential structure's contents will vary\
    \ depending on the set of\n   mech_types supported by a particular GSS-API implementation.\
    \ Each\n   credential element identifies the data needed by its mechanism in\n\
    \   order to establish contexts on behalf of a particular principal, and\n   may\
    \ contain separate credential references for use in context\n   initiation and\
    \ context acceptance.  Multiple credential elements\n   within a given credential\
    \ having overlapping combinations of\n   mechanism, usage mode, and validity period\
    \ are not permitted.\n   Commonly, a single mech_type will be used for all security\
    \ contexts\n   established by a particular initiator to a particular target. A\
    \ major\n   motivation for supporting credential sets representing multiple\n\
    \   mech_types is to allow initiators on systems which are equipped to\n   handle\
    \ multiple types to initiate contexts to targets on other\n   systems which can\
    \ accommodate only a subset of the set supported at\n   the initiator's system.\n"
- title: '1.1.1.2: Credential Management'
  contents:
  - "1.1.1.2: Credential Management\n   It is the responsibility of underlying system-specific\
    \ mechanisms and\n   OS functions below the GSS-API to ensure that the ability\
    \ to acquire\n   and use credentials associated with a given identity is constrained\n\
    \   to appropriate processes within a system. This responsibility should\n   be\
    \ taken seriously by implementors, as the ability for an entity to\n   utilize\
    \ a principal's credentials is equivalent to the entity's\n   ability to successfully\
    \ assert that principal's identity.\n   Once a set of GSS-API credentials is established,\
    \ the transferability\n   of that credentials set to other processes or analogous\
    \ constructs\n   within a system is a local matter, not defined by the GSS-API.\
    \ An\n   example local policy would be one in which any credentials received\n\
    \   as a result of login to a given user account, or of delegation of\n   rights\
    \ to that account, are accessible by, or transferable to,\n   processes running\
    \ under that account.\n   The credential establishment process (particularly when\
    \ performed on\n   behalf of users rather than server processes) is likely to\
    \ require\n   access to passwords or other quantities which should be protected\n\
    \   locally and exposed for the shortest time possible. As a result, it\n   will\
    \ often be appropriate for preliminary credential establishment to\n   be performed\
    \ through local means at user login time, with the\n   result(s) cached for subsequent\
    \ reference. These preliminary\n   credentials would be set aside (in a system-specific\
    \ fashion) for\n   subsequent use, either:\n      to be accessed by an invocation\
    \ of the GSS-API GSS_Acquire_cred()\n      call, returning an explicit handle\
    \ to reference that credential\n      to comprise default credential elements\
    \ to be installed, and to be\n      used when default credential behavior is requested\
    \ on behalf of a\n      process\n"
- title: '1.1.1.3: Default Credential Resolution'
  contents:
  - "1.1.1.3: Default Credential Resolution\n   The GSS_Init_sec_context() and GSS_Accept_sec_context()\
    \ routines\n   allow the value GSS_C_NO_CREDENTIAL to be specified as their\n\
    \   credential handle parameter.  This special credential handle\n   indicates\
    \ a desire by the application to act as a default principal.\n   In support of\
    \ application portability, support for the default\n   resolution behavior described\
    \ below for initiator credentials\n   (GSS_Init_sec_context() usage) is mandated;\
    \ support for the default\n   resolution behavior described below for acceptor\
    \ credentials\n   (GSS_Accept_sec_context() usage) is recommended. If default\n\
    \   credential resolution fails, GSS_S_NO_CRED status is to be returned.\n   \
    \   GSS_Init_sec_context:\n         (i) If there is only a single principal capable\
    \ of initiating\n         security contexts that the application is authorized\
    \ to act on\n         behalf of, then that principal shall be used, otherwise\n\
    \         (ii) If the platform maintains a concept of a default network-\n   \
    \      identity, and if the application is authorized to act on behalf\n     \
    \    of that identity for the purpose of initiating security\n         contexts,\
    \ then the principal corresponding to that identity\n         shall be used, otherwise\n\
    \         (iii) If the platform maintains a concept of a default local\n     \
    \    identity, and provides a means to map local identities into\n         network-identities,\
    \ and if the application is authorized to act\n         on behalf of the network-identity\
    \ image of the default local\n         identity for the purpose of initiating\
    \ security contexts, then\n         the principal corresponding to that identity\
    \ shall be used,\n         otherwise\n         (iv) A user-configurable default\
    \ identity should be used.\n      GSS_Accept_sec_context:\n         (i) If there\
    \ is only a single authorized principal identity\n         capable of accepting\
    \ security contexts, then that principal\n         shall be used, otherwise\n\
    \         (ii) If the mechanism can determine the identity of the target\n   \
    \      principal by examining the context-establishment token, and if\n      \
    \   the accepting application is authorized to act as that\n         principal\
    \ for the purpose of accepting security contexts, then\n         that principal\
    \ identity shall be used, otherwise\n         (iii) If the mechanism supports\
    \ context acceptance by any\n         principal, and mutual authentication was\
    \ not requested, any\n         principal that the application is authorized to\
    \ accept security\n         contexts under may be used, otherwise\n         (iv)\
    \ A user-configurable default identity shall be used.\n   The purpose of the above\
    \ rules is to allow security contexts to be\n   established by both initiator\
    \ and acceptor using the default behavior\n   wherever possible.  Applications\
    \ requesting default behavior are\n   likely to be more portable across mechanisms\
    \ and platforms than those\n   that use GSS_Acquire_cred() to request a specific\
    \ identity.\n"
- title: '1.1.2: Tokens'
  contents:
  - "1.1.2: Tokens\n   Tokens are data elements transferred between GSS-API callers,\
    \ and are\n   divided into two classes. Context-level tokens are exchanged in\
    \ order\n   to establish and manage a security context between peers. Per-message\n\
    \   tokens relate to an established context and are exchanged to provide\n   protective\
    \ security services (i.e., data origin authentication,\n   integrity, and optional\
    \ confidentiality) for corresponding data\n   messages.\n   The first context-level\
    \ token obtained from GSS_Init_sec_context() is\n   required to indicate at its\
    \ very beginning a globally-interpretable\n   mechanism identifier, i.e., an Object\
    \ Identifier (OID) of the\n   security mechanism. The remaining part of this token\
    \ as well as the\n   whole content of all other tokens are specific to the particular\n\
    \   underlying mechanism used to support the GSS-API. Section 3.1 of this\n  \
    \ document provides, for designers of GSS-API mechanisms, the\n   description\
    \ of the header of the first context-level token which is\n   then followed by\
    \ mechanism-specific information.\n   Tokens' contents are opaque from the viewpoint\
    \ of GSS-API callers.\n   They are generated within the GSS-API implementation\
    \ at an end\n   system, provided to a GSS-API caller to be transferred to the\
    \ peer\n   GSS-API caller at a remote end system, and processed by the GSS-API\n\
    \   implementation at that remote end system.\n   Context-level tokens may be\
    \ output by GSS-API calls (and should be\n   transferred to GSS-API peers) whether\
    \ or not the calls' status\n   indicators indicate successful completion.  Per-message\
    \ tokens, in\n   contrast, are to be returned only upon successful completion\
    \ of per-\n   message calls. Zero-length tokens are never returned by GSS routines\n\
    \   for transfer to a peer. Token transfer may take place in an in-band\n   manner,\
    \ integrated into the same protocol stream used by the GSS-API\n   callers for\
    \ other data transfers, or in an out-of-band manner across\n   a logically separate\
    \ channel.\n   Different GSS-API tokens are used for different purposes (e.g.,\n\
    \   context initiation, context acceptance, protected message data on an\n   established\
    \ context), and it is the responsibility of a GSS-API\n   caller receiving tokens\
    \ to distinguish their types, associate them\n   with corresponding security contexts,\
    \ and pass them to appropriate\n   GSS-API processing routines.  Depending on\
    \ the caller protocol\n   environment, this distinction may be accomplished in\
    \ several ways.\n   The following examples illustrate means through which tokens'\
    \ types\n   may be distinguished:\n      - implicit tagging based on state information\
    \ (e.g., all tokens on\n      a new association are considered to be context establishment\n\
    \      tokens until context establishment is completed, at which point\n     \
    \ all tokens are considered to be wrapped data objects for that\n      context),\n\
    \      - explicit tagging at the caller protocol level,\n      - a hybrid of these\
    \ approaches.\n   Commonly, the encapsulated data within a token includes internal\n\
    \   mechanism-specific tagging information, enabling mechanism-level\n   processing\
    \ modules to distinguish tokens used within the mechanism\n   for different purposes.\
    \  Such internal mechanism-level tagging is\n   recommended to mechanism designers,\
    \ and enables mechanisms to\n   determine whether a caller has passed a particular\
    \ token for\n   processing by an inappropriate GSS-API routine.\n   Development\
    \ of GSS-API mechanisms based on a particular underlying\n   cryptographic technique\
    \ and protocol (i.e., conformant to a specific\n   GSS-API mechanism definition)\
    \ does not necessarily imply that GSS-API\n   callers using that GSS-API mechanism\
    \ will be able to interoperate\n   with peers invoking the same technique and\
    \ protocol outside the GSS-\n   API paradigm, or with peers implementing a different\
    \ GSS-API\n   mechanism based on the same underlying technology.  The format of\n\
    \   GSS-API tokens defined in conjunction with a particular mechanism,\n   and\
    \ the techniques used to integrate those tokens into callers'\n   protocols, may\
    \ not be interoperable with the tokens used by non-GSS-\n   API callers of the\
    \ same underlying technique.\n"
- title: '1.1.3:  Security Contexts'
  contents:
  - "1.1.3:  Security Contexts\n   Security contexts are established between peers,\
    \ using credentials\n   established locally in conjunction with each peer or received\
    \ by\n   peers via delegation. Multiple contexts may exist simultaneously\n  \
    \ between a pair of peers, using the same or different sets of\n   credentials.\
    \ Coexistence of multiple contexts using different\n   credentials allows graceful\
    \ rollover when credentials expire.\n   Distinction among multiple contexts based\
    \ on the same credentials\n   serves applications by distinguishing different\
    \ message streams in a\n   security sense.\n   The GSS-API is independent of underlying\
    \ protocols and addressing\n   structure, and depends on its callers to transport\
    \ GSS-API-provided\n   data elements. As a result of these factors, it is a caller\n\
    \   responsibility to parse communicated messages, separating GSS-API-\n   related\
    \ data elements from caller-provided data.  The GSS-API is\n   independent of\
    \ connection vs. connectionless orientation of the\n   underlying communications\
    \ service.\n   No correlation between security context and communications protocol\n\
    \   association is dictated. (The optional channel binding facility,\n   discussed\
    \ in Section 1.1.6 of this document, represents an\n   intentional exception to\
    \ this rule, supporting additional protection\n   features within GSS-API supporting\
    \ mechanisms.) This separation\n   allows the GSS-API to be used in a wide range\
    \ of communications\n   environments, and also simplifies the calling sequences\
    \ of the\n   individual calls. In many cases (depending on underlying security\n\
    \   protocol, associated mechanism, and availability of cached\n   information),\
    \ the state information required for context setup can be\n   sent concurrently\
    \ with initial signed user data, without interposing\n   additional message exchanges.\
    \  Messages may be protected and\n   transferred in both directions on an established\
    \ GSS-API security\n   context concurrently; protection of messages in one direction\
    \ does\n   not interfere with protection of messages in the reverse direction.\n\
    \   GSS-API implementations are expected to retain inquirable context\n   data\
    \ on a context until the context is released by a caller, even\n   after the context\
    \ has expired, although underlying cryptographic data\n   elements may be deleted\
    \ after expiration in order to limit their\n   exposure.\n"
- title: '1.1.4:  Mechanism Types'
  contents:
  - "1.1.4:  Mechanism Types\n   In order to successfully establish a security context\
    \ with a target\n   peer, it is necessary to identify an appropriate underlying\
    \ mechanism\n   type (mech_type) which both initiator and target peers support.\
    \ The\n   definition of a mechanism embodies not only the use of a particular\n\
    \   cryptographic technology (or a hybrid or choice among alternative\n   cryptographic\
    \ technologies), but also definition of the syntax and\n   semantics of data element\
    \ exchanges which that mechanism will employ\n   in order to support security\
    \ services.\n   It is recommended that callers initiating contexts specify the\n\
    \   \"default\" mech_type value, allowing system-specific functions within\n \
    \  or invoked by the GSS-API implementation to select the appropriate\n   mech_type,\
    \ but callers may direct that a particular mech_type be\n   employed when necessary.\n\
    \   For GSS-API purposes, the phrase \"negotiating mechanism\" refers to a\n \
    \  mechanism which itself performs negotiation in order to select a\n   concrete\
    \ mechanism which is shared between peers and is then used for\n   context establishment.\
    \  Only those mechanisms which are defined in\n   their specifications as negotiating\
    \ mechanisms are to yield selected\n   mechanisms with different identifier values\
    \ than the value which is\n   input by a GSS-API caller, except for the case of\
    \ a caller requesting\n   the \"default\" mech_type.\n   The means for identifying\
    \ a shared mech_type to establish a security\n   context with a peer will vary\
    \ in different environments and\n   circumstances; examples include (but are not\
    \ limited to):\n      use of a fixed mech_type, defined by configuration, within\
    \ an\n      environment\n      syntactic convention on a target-specific basis,\
    \ through\n      examination of a target's name lookup of a target's name in a\n\
    \      naming service or other database in order to identify mech_types\n    \
    \  supported by that target\n      explicit negotiation between GSS-API callers\
    \ in advance of\n      security context setup\n      use of a negotiating mechanism\n\
    \   When transferred between GSS-API peers, mech_type specifiers (per\n   Section\
    \ 3 of this document, represented as Object Identifiers (OIDs))\n   serve to qualify\
    \ the interpretation of associated tokens. (The\n   structure and encoding of\
    \ Object Identifiers is defined in [ISOIEC-\n   8824] and [ISOIEC-8825].) Use\
    \ of hierarchically structured OIDs\n   serves to preclude ambiguous interpretation\
    \ of mech_type specifiers.\n   The OID representing the DASS ([RFC-1507]) MechType,\
    \ for example, is\n   1.3.12.2.1011.7.5, and that of the Kerberos V5 mechanism\
    \ ([RFC-\n   1964]), having been advanced to the level of Proposed Standard, is\n\
    \   1.2.840.113554.1.2.2.\n"
- title: '1.1.5:  Naming'
  contents:
  - "1.1.5:  Naming\n   The GSS-API avoids prescribing naming structures, treating\
    \ the names\n   which are transferred across the interface in order to initiate\
    \ and\n   accept security contexts as opaque objects.  This approach supports\n\
    \   the GSS-API's goal of implementability atop a range of underlying\n   security\
    \ mechanisms, recognizing the fact that different mechanisms\n   process and authenticate\
    \ names which are presented in different\n   forms. Generalized services offering\
    \ translation functions among\n   arbitrary sets of naming environments are outside\
    \ the scope of the\n   GSS-API; availability and use of local conversion functions\
    \ to\n   translate among the naming formats supported within a given end\n   system\
    \ is anticipated.\n   Different classes of name representations are used in conjunction\n\
    \   with different GSS-API parameters:\n      - Internal form (denoted in this\
    \ document by INTERNAL NAME),\n      opaque to callers and defined by individual\
    \ GSS-API\n      implementations.  GSS-API implementations supporting multiple\n\
    \      namespace types must maintain internal tags to disambiguate the\n     \
    \ interpretation of particular names.  A Mechanism Name (MN) is a\n      special\
    \ case of INTERNAL NAME, guaranteed to contain elements\n      corresponding to\
    \ one and only one mechanism; calls which are\n      guaranteed to emit MNs or\
    \ which require MNs as input are so\n      identified within this specification.\n\
    \      - Contiguous string (\"flat\") form (denoted in this document by\n    \
    \  OCTET STRING); accompanied by OID tags identifying the namespace\n      to\
    \ which they correspond.  Depending on tag value, flat names may\n      or may\
    \ not be printable strings for direct acceptance from and\n      presentation\
    \ to users. Tagging of flat names allows GSS-API\n      callers and underlying\
    \ GSS-API mechanisms to disambiguate name\n      types and to determine whether\
    \ an associated name's type is one\n      which they are capable of processing,\
    \ avoiding aliasing problems\n      which could result from misinterpreting a\
    \ name of one type as a\n      name of another type.\n      - The GSS-API Exported\
    \ Name Object, a special case of flat name\n      designated by a reserved OID\
    \ value, carries a canonicalized form\n      of a name suitable for binary comparisons.\n\
    \   In addition to providing means for names to be tagged with types,\n   this\
    \ specification defines primitives to support a level of naming\n   environment\
    \ independence for certain calling applications. To provide\n   basic services\
    \ oriented towards the requirements of callers which\n   need not themselves interpret\
    \ the internal syntax and semantics of\n   names, GSS-API calls for name comparison\
    \ (GSS_Compare_name()),\n   human-readable display (GSS_Display_name()), input\
    \ conversion\n   (GSS_Import_name()), internal name deallocation (GSS_Release_name()),\n\
    \   and internal name duplication (GSS_Duplicate_name()) functions are\n   defined.\
    \ (It is anticipated that these proposed GSS-API calls will be\n   implemented\
    \ in many end systems based on system-specific name\n   manipulation primitives\
    \ already extant within those end systems;\n   inclusion within the GSS-API is\
    \ intended to offer GSS-API callers a\n   portable means to perform specific operations,\
    \ supportive of\n   authorization and audit requirements, on authenticated names.)\n\
    \   GSS_Import_name() implementations can, where appropriate, support\n   more\
    \ than one printable syntax corresponding to a given namespace\n   (e.g., alternative\
    \ printable representations for X.500 Distinguished\n   Names), allowing flexibility\
    \ for their callers to select among\n   alternative representations. GSS_Display_name()\
    \ implementations\n   output a printable syntax selected as appropriate to their\n\
    \   operational environments; this selection is a local matter. Callers\n   desiring\
    \ portability across alternative printable syntaxes should\n   refrain from implementing\
    \ comparisons based on printable name forms\n   and should instead use the GSS_Compare_name()\
    \  call to determine\n   whether or not one internal-format name matches another.\n\
    \   When used in large access control lists, the overhead of invoking\n   GSS_Import_name()\
    \ and GSS_Compare_name() on each name from the ACL\n   may be prohibitive.  As\
    \ an alternative way of supporting this case,\n   GSS-API defines a special form\
    \ of the contiguous string name which\n   may be compared directly (e.g., with\
    \ memcmp()).  Contiguous names\n   suitable for comparison are generated by the\
    \ GSS_Export_name()\n   routine, which requires an MN as input.  Exported names\
    \ may be re-\n   imported by the GSS_Import_name() routine, and the resulting\
    \ internal\n   name will also be an MN.  The symbolic constant GSS_C_NT_EXPORT_NAME\n\
    \   identifies the \"export name\" type. Structurally, an exported name\n   object\
    \ consists of a header containing an OID identifying the\n   mechanism that authenticated\
    \ the name, and a trailer containing the\n   name itself, where the syntax of\
    \ the trailer is defined by the\n   individual mechanism specification.  The precise\
    \ format of an\n   exported name is defined in Section 3.2 of this specification.\n\
    \   Note that the results obtained by using GSS_Compare_name() will in\n   general\
    \ be different from those obtained by invoking\n   GSS_Canonicalize_name() and\
    \ GSS_Export_name(), and then comparing the\n   exported names.  The first series\
    \ of operations determines whether\n   two (unauthenticated) names identify the\
    \ same principal; the second\n   whether a particular mechanism would authenticate\
    \ them as the same\n   principal.  These two operations will in general give the\
    \ same\n   results only for MNs.\n   The following diagram illustrates the intended\
    \ dataflow among name-\n   related GSS-API processing routines.\n            \
    \            GSS-API library defaults\n                               |\n    \
    \                           |\n                               V              \
    \           text, for\n   text -------------->  internal_name (IN) ----------->\
    \ display only\n         import_name()          /          display_name()\n  \
    \                             /\n                              /\n           \
    \                  /\n    accept_sec_context()    /\n          |             \
    \   /\n          |               /\n          |              /  canonicalize_name()\n\
    \          |             /\n          |            /\n          |           /\n\
    \          |          /\n          |         /\n          |        |\n       \
    \   V        V     <---------------------\n    single mechanism        import_name()\
    \         exported name: flat\n    internal_name (MN)                        \
    \    binary \"blob\" usable\n                         ---------------------->\
    \  for access control\n                            export_name()\n"
- title: '1.1.6:  Channel Bindings'
  contents:
  - "1.1.6:  Channel Bindings\n   The GSS-API accommodates the concept of caller-provided\
    \ channel\n   binding (\"chan_binding\") information.  Channel bindings are used\
    \ to\n   strengthen the quality with which peer entity authentication is\n   provided\
    \ during context establishment, by limiting the scope within\n   which an intercepted\
    \ context establishment token can be reused by an\n   attacker. Specifically,\
    \ they enable GSS-API callers to bind the\n   establishment of a security context\
    \ to relevant characteristics\n   (e.g., addresses, transformed representations\
    \ of encryption keys) of\n   the underlying communications channel, of protection\
    \ mechanisms\n   applied to that communications channel, and to application-specific\n\
    \   data.\n   The caller initiating a security context must determine the\n  \
    \ appropriate channel binding values to provide as input to the\n   GSS_Init_sec_context()\
    \ call, and consistent values must be provided\n   to GSS_Accept_sec_context()\
    \ by the context's target, in order for\n   both peers' GSS-API mechanisms to\
    \ validate that received tokens\n   possess correct channel-related characteristics.\
    \ Use or non-use of\n   the GSS-API channel binding facility is a caller option.\
    \  GSS-API\n   mechanisms can operate in an environment where NULL channel bindings\n\
    \   are presented; mechanism implementors are encouraged, but not\n   required,\
    \ to make use of caller-provided channel binding data within\n   their mechanisms.\
    \ Callers should not assume that underlying\n   mechanisms provide confidentiality\
    \ protection for channel binding\n   information.\n   When non-NULL channel bindings\
    \ are provided by callers, certain\n   mechanisms can offer enhanced security\
    \ value by interpreting the\n   bindings' content (rather than simply representing\
    \ those bindings, or\n   integrity check values computed on them, within tokens)\
    \ and will\n   therefore depend on presentation of specific data in a defined\n\
    \   format. To this end, agreements among mechanism implementors are\n   defining\
    \ conventional interpretations for the contents of channel\n   binding arguments,\
    \ including address specifiers (with content\n   dependent on communications protocol\
    \ environment) for context\n   initiators and acceptors. (These conventions are\
    \ being incorporated\n   in GSS-API mechanism specifications and into the GSS-API\
    \ C language\n   bindings specification.) In order for GSS-API callers to be portable\n\
    \   across multiple mechanisms and achieve the full security\n   functionality\
    \ which each mechanism can provide, it is strongly\n   recommended that GSS-API\
    \ callers provide channel bindings consistent\n   with these conventions and those\
    \ of the networking environment in\n   which they operate.\n"
- title: '1.2:  GSS-API Features and Issues'
  contents:
  - "1.2:  GSS-API Features and Issues\n   This section describes aspects of GSS-API\
    \ operations, of the security\n   services which the GSS-API provides, and provides\
    \ commentary on\n   design issues.\n"
- title: '1.2.1:  Status Reporting and Optional Service Support'
  contents:
  - '1.2.1:  Status Reporting and Optional Service Support

    '
- title: '1.2.1.1: Status Reporting'
  contents:
  - "1.2.1.1: Status Reporting\n   Each GSS-API call provides two status return values.\
    \ Major_status\n   values provide a mechanism-independent indication of call status\n\
    \   (e.g., GSS_S_COMPLETE, GSS_S_FAILURE, GSS_S_CONTINUE_NEEDED),\n   sufficient\
    \ to drive normal control flow within the caller in a\n   generic fashion. Table\
    \ 1 summarizes the defined major_status return\n   codes in tabular fashion.\n\
    \   Sequencing-related informatory major_status codes\n   (GSS_S_DUPLICATE_TOKEN,\
    \ GSS_S_OLD_TOKEN, GSS_S_UNSEQ_TOKEN, and\n   GSS_S_GAP_TOKEN) can be indicated\
    \ in conjunction with either\n   GSS_S_COMPLETE or GSS_S_FAILURE status for GSS-API\
    \ per-message calls.\n   For context establishment calls, these sequencing-related\
    \ codes will\n   be indicated only in conjunction with GSS_S_FAILURE status (never\
    \ in\n   conjunction with GSS_S_COMPLETE or GSS_S_CONTINUE_NEEDED), and,\n   therefore,\
    \ always correspond to fatal failures if encountered during\n   the context establishment\
    \ phase.\n   Table 1: GSS-API Major Status Codes\n   FATAL ERROR CODES\n   GSS_S_BAD_BINDINGS\
    \            channel binding mismatch\n   GSS_S_BAD_MECH                unsupported\
    \ mechanism requested\n   GSS_S_BAD_NAME                invalid name provided\n\
    \   GSS_S_BAD_NAMETYPE            name of unsupported type provided\n   GSS_S_BAD_STATUS\
    \              invalid input status selector\n   GSS_S_BAD_SIG               \
    \  token had invalid integrity check\n   GSS_S_BAD_MIC                   preferred\
    \ alias for GSS_S_BAD_SIG\n   GSS_S_CONTEXT_EXPIRED         specified security\
    \ context expired\n   GSS_S_CREDENTIALS_EXPIRED     expired credentials detected\n\
    \   GSS_S_DEFECTIVE_CREDENTIAL    defective credential detected\n   GSS_S_DEFECTIVE_TOKEN\
    \         defective token detected\n   GSS_S_FAILURE                 failure,\
    \ unspecified at GSS-API\n                                   level\n   GSS_S_NO_CONTEXT\
    \              no valid security context specified\n   GSS_S_NO_CRED         \
    \        no valid credentials provided\n   GSS_S_BAD_QOP                 unsupported\
    \ QOP value\n   GSS_S_UNAUTHORIZED            operation unauthorized\n   GSS_S_UNAVAILABLE\
    \             operation unavailable\n   GSS_S_DUPLICATE_ELEMENT       duplicate\
    \ credential element requested\n   GSS_S_NAME_NOT_MN             name contains\
    \ multi-mechanism elements\n   INFORMATORY STATUS CODES\n   GSS_S_COMPLETE   \
    \             normal completion\n   GSS_S_CONTINUE_NEEDED         continuation\
    \ call to routine\n                                  required\n   GSS_S_DUPLICATE_TOKEN\
    \         duplicate per-message token\n                                  detected\n\
    \   GSS_S_OLD_TOKEN               timed-out per-message token\n              \
    \                    detected\n   GSS_S_UNSEQ_TOKEN             reordered (early)\
    \ per-message token\n                                  detected\n   GSS_S_GAP_TOKEN\
    \               skipped predecessor token(s)\n                               \
    \   detected\n   Minor_status provides more detailed status information which\
    \ may\n   include status codes specific to the underlying security mechanism.\n\
    \   Minor_status values are not specified in this document.\n   GSS_S_CONTINUE_NEEDED\
    \ major_status returns, and optional message\n   outputs, are provided in GSS_Init_sec_context()\
    \ and\n   GSS_Accept_sec_context() calls so that different mechanisms'\n   employment\
    \ of different numbers of messages within their\n   authentication sequences need\
    \ not be reflected in separate code paths\n   within calling applications. Instead,\
    \ such cases are accommodated\n   with sequences of continuation calls to GSS_Init_sec_context()\
    \  and\n   GSS_Accept_sec_context().  The same facility is used to encapsulate\n\
    \   mutual authentication within the GSS-API's context initiation calls.\n   For\
    \ mech_types which require interactions with third-party servers in\n   order\
    \ to establish a security context, GSS-API context establishment\n   calls may\
    \ block pending completion of such third-party interactions.\n   On the other\
    \ hand, no GSS-API calls pend on serialized interactions\n   with GSS-API peer\
    \ entities.  As a result, local GSS-API status\n   returns cannot reflect unpredictable\
    \ or asynchronous exceptions\n   occurring at remote peers, and reflection of\
    \ such status information\n   is a caller responsibility outside the GSS-API.\n"
- title: '1.2.1.2: Optional Service Support'
  contents:
  - "1.2.1.2: Optional Service Support\n   A context initiator may request various\
    \ optional services at context\n   establishment time. Each of these services\
    \ is requested by setting a\n   flag in the req_flags input parameter to GSS_Init_sec_context().\n\
    \   The optional services currently defined are:\n      - Delegation - The (usually\
    \ temporary) transfer of rights from\n      initiator to acceptor, enabling the\
    \ acceptor to authenticate\n      itself as an agent of the initiator.\n     \
    \ - Mutual Authentication - In addition to the initiator\n      authenticating\
    \ its identity to the context acceptor, the context\n      acceptor should also\
    \ authenticate itself to the initiator.\n      - Replay detection - In addition\
    \ to providing message integrity\n      services, GSS_GetMIC() and GSS_Wrap()\
    \ should include message\n      numbering information to enable GSS_VerifyMIC()\
    \ and GSS_Unwrap()\n      to detect if a message has been duplicated.\n      -\
    \ Out-of-sequence detection - In addition to providing message\n      integrity\
    \ services, GSS_GetMIC() and GSS_Wrap() should include\n      message sequencing\
    \ information to enable GSS_VerifyMIC() and\n      GSS_Unwrap() to detect if a\
    \ message has been received out of\n      sequence.\n      - Anonymous authentication\
    \ - The establishment of the security\n      context should not reveal the initiator's\
    \ identity to the context\n      acceptor.\n      - Available per-message confidentiality\
    \ - requests that per-\n      message confidentiality services be available on\
    \ the context.\n      - Available per-message integrity - requests that per-message\n\
    \      integrity services be available on the context.\n   Any currently undefined\
    \ bits within such flag arguments should be\n   ignored by GSS-API implementations\
    \ when presented by an application,\n   and should be set to zero when returned\
    \ to the application by the\n   GSS-API implementation.\n   Some mechanisms may\
    \ not support all optional services, and some\n   mechanisms may only support\
    \ some services in conjunction with others.\n   Both GSS_Init_sec_context() and\
    \ GSS_Accept_sec_context() inform the\n   applications which services will be\
    \ available from the context when\n   the establishment phase is complete, via\
    \ the ret_flags output\n   parameter.  In general, if the security mechanism is\
    \ capable of\n   providing a requested service, it should do so, even if additional\n\
    \   services must be enabled in order to provide the requested service.\n   If\
    \ the mechanism is incapable of providing a requested service, it\n   should proceed\
    \ without the service, leaving the application to abort\n   the context establishment\
    \ process if it considers the requested\n   service to be mandatory.\n   Some\
    \ mechanisms may specify that support for some services is\n   optional, and that\
    \ implementors of the mechanism need not provide it.\n   This is most commonly\
    \ true of the confidentiality service, often\n   because of legal restrictions\
    \ on the use of data-encryption, but may\n   apply to any of the services.  Such\
    \ mechanisms are required to send\n   at least one token from acceptor to initiator\
    \ during context\n   establishment when the initiator indicates a desire to use\
    \ such a\n   service, so that the initiating GSS-API can correctly indicate\n\
    \   whether the service is supported by the acceptor's GSS-API.\n"
- title: '1.2.2: Per-Message Security Service Availability'
  contents:
  - "1.2.2: Per-Message Security Service Availability\n   When a context is established,\
    \ two flags are returned to indicate the\n   set of per-message protection security\
    \ services which will be\n   available on the context:\n      the integ_avail\
    \ flag indicates whether per-message integrity and\n      data origin authentication\
    \ services are available\n      the conf_avail flag indicates whether per-message\
    \ confidentiality\n      services are available, and will never be returned TRUE\
    \ unless the\n      integ_avail flag is also returned TRUE\n   GSS-API callers\
    \ desiring per-message security services should check\n   the values of these\
    \ flags at context establishment time, and must be\n   aware that a returned FALSE\
    \ value for integ_avail means that\n   invocation of GSS_GetMIC() or GSS_Wrap()\
    \ primitives on the associated\n   context will apply no cryptographic protection\
    \ to user data messages.\n   The GSS-API per-message integrity and data origin\
    \ authentication\n   services provide assurance to a receiving caller that protection\
    \ was\n   applied to a message by the caller's peer on the security context,\n\
    \   corresponding to the entity named at context initiation.  The GSS-API\n  \
    \ per-message confidentiality service provides assurance to a sending\n   caller\
    \ that the message's content is protected from access by\n   entities other than\
    \ the context's named peer.\n   The GSS-API per-message protection service primitives,\
    \ as the\n   category name implies, are oriented to operation at the granularity\n\
    \   of protocol data units. They perform cryptographic operations on the\n   data\
    \ units, transfer cryptographic control information in tokens,\n   and, in the\
    \ case of GSS_Wrap(), encapsulate the protected data unit.\n   As such, these\
    \ primitives are not oriented to efficient data\n   protection for stream-paradigm\
    \ protocols (e.g., Telnet) if\n   cryptography must be applied on an octet-by-octet\
    \ basis.\n"
- title: '1.2.3: Per-Message Replay Detection and Sequencing'
  contents:
  - "1.2.3: Per-Message Replay Detection and Sequencing\n   Certain underlying mech_types\
    \ offer support for replay detection\n   and/or sequencing of messages transferred\
    \ on the contexts they\n   support. These optionally-selectable protection features\
    \ are distinct\n   from replay detection and sequencing features applied to the\
    \ context\n   establishment operation itself; the presence or absence of context-\n\
    \   level replay or sequencing features is wholly a function of the\n   underlying\
    \ mech_type's capabilities, and is not selected or omitted\n   as a caller option.\n\
    \   The caller initiating a context provides flags (replay_det_req_flag\n   and\
    \ sequence_req_flag) to specify whether the use of per-message\n   replay detection\
    \ and sequencing features is desired on the context\n   being established. The\
    \ GSS-API implementation at the initiator system\n   can determine whether these\
    \ features are supported (and whether they\n   are optionally selectable) as a\
    \ function of the selected mechanism,\n   without need for bilateral negotiation\
    \ with the target. When enabled,\n   these features provide recipients with indicators\
    \ as a result of\n   GSS-API processing of incoming messages, identifying whether\
    \ those\n   messages were detected as duplicates or out-of-sequence. Detection\
    \ of\n   such events does not prevent a suspect message from being provided to\n\
    \   a recipient; the appropriate course of action on a suspect message is\n  \
    \ a matter of caller policy.\n   The semantics of the replay detection and sequencing\
    \ services applied\n   to received messages, as visible across the interface which\
    \ the GSS-\n   API provides to its clients, are as follows:\n   When replay_det_state\
    \ is TRUE, the possible major_status returns for\n   well-formed and correctly\
    \ signed messages are as follows:\n      1. GSS_S_COMPLETE, without concurrent\
    \ indication of\n      GSS_S_DUPLICATE_TOKEN or GSS_S_OLD_TOKEN, indicates that\
    \ the\n      message was within the window (of time or sequence space) allowing\n\
    \      replay events to be detected, and that the message was not a\n      replay\
    \ of a previously-processed message within that window.\n      2. GSS_S_DUPLICATE_TOKEN\
    \ indicates that the cryptographic\n      checkvalue on the received message was\
    \ correct, but that the\n      message was recognized as a duplicate of a previously-processed\n\
    \      message.  In addition to identifying duplicated tokens originated\n   \
    \   by a context's peer, this status may also be used to identify\n      reflected\
    \ copies of locally-generated tokens; it is recommended\n      that mechanism\
    \ designers include within their protocols facilities\n      to detect and report\
    \ such tokens.\n      3. GSS_S_OLD_TOKEN indicates that the cryptographic checkvalue\
    \ on\n      the received message was correct, but that the message is too old\n\
    \      to be checked for duplication.\n   When sequence_state is TRUE, the possible\
    \ major_status returns for\n   well-formed and correctly signed messages are as\
    \ follows:\n      1. GSS_S_COMPLETE, without concurrent indication of\n      GSS_S_DUPLICATE_TOKEN,\
    \ GSS_S_OLD_TOKEN, GSS_S_UNSEQ_TOKEN, or\n      GSS_S_GAP_TOKEN, indicates that\
    \ the message was within the window\n      (of time or sequence space) allowing\
    \ replay events to be detected,\n      that the message was not a replay of a\
    \ previously-processed\n      message within that window, and that no predecessor\
    \ sequenced\n      messages are missing relative to the last received message\
    \ (if\n      any) processed on the context with a correct cryptographic\n    \
    \  checkvalue.\n      2. GSS_S_DUPLICATE_TOKEN indicates that the integrity check\
    \ value\n      on the received message was correct, but that the message was\n\
    \      recognized as a duplicate of a previously-processed message.  In\n    \
    \  addition to identifying duplicated tokens originated by a\n      context's\
    \ peer, this status may also be used to identify reflected\n      copies of locally-generated\
    \ tokens; it is recommended that\n      mechanism designers include within their\
    \ protocols facilities to\n      detect and report such tokens.\n      3. GSS_S_OLD_TOKEN\
    \ indicates that the integrity check value on the\n      received message was\
    \ correct, but that the token is too old to be\n      checked for duplication.\n\
    \      4. GSS_S_UNSEQ_TOKEN indicates that the cryptographic checkvalue\n    \
    \  on the received message was correct, but that it is earlier in a\n      sequenced\
    \ stream than a message already processed on the context.\n      [Note: Mechanisms\
    \ can be architected to provide a stricter form of\n      sequencing service,\
    \ delivering particular messages to recipients\n      only after all predecessor\
    \ messages in an ordered stream have been\n      delivered.  This type of support\
    \ is incompatible with the GSS-API\n      paradigm in which recipients receive\
    \ all messages, whether in\n      order or not, and provide them (one at a time,\
    \ without intra-GSS-\n      API message buffering) to GSS-API routines for validation.\
    \  GSS-\n      API facilities provide supportive functions, aiding clients to\n\
    \      achieve strict message stream integrity in an efficient manner in\n   \
    \   conjunction with sequencing provisions in communications\n      protocols,\
    \ but the GSS-API does not offer this level of message\n      stream integrity\
    \ service by itself.]\n      5. GSS_S_GAP_TOKEN indicates that the cryptographic\
    \ checkvalue on\n      the received message was correct, but that one or more\
    \ predecessor\n      sequenced messages have not been successfully processed relative\n\
    \      to the last received message (if any) processed on the context\n      with\
    \ a correct cryptographic checkvalue.\n   As the message stream integrity features\
    \ (especially sequencing) may\n   interfere with certain applications' intended\
    \ communications\n   paradigms, and since support for such features is likely\
    \ to be\n   resource intensive, it is highly recommended that mech_types\n   supporting\
    \ these features allow them to be activated selectively on\n   initiator request\
    \ when a context is established. A context initiator\n   and target are provided\
    \ with corresponding indicators\n   (replay_det_state and sequence_state), signifying\
    \ whether these\n   features are active on a given context.\n   An example mech_type\
    \ supporting per-message replay detection could\n   (when replay_det_state is\
    \ TRUE) implement the feature as follows: The\n   underlying mechanism would insert\
    \ timestamps in data elements output\n   by GSS_GetMIC() and GSS_Wrap(), and would\
    \ maintain (within a time-\n   limited window) a cache (qualified by originator-recipient\
    \ pair)\n   identifying received data elements processed by GSS_VerifyMIC() and\n\
    \   GSS_Unwrap(). When this feature is active, exception status returns\n   (GSS_S_DUPLICATE_TOKEN,\
    \ GSS_S_OLD_TOKEN) will be provided when\n   GSS_VerifyMIC() or GSS_Unwrap() is\
    \ presented with a message which is\n   either a detected duplicate of a prior\
    \ message or which is too old to\n   validate against a cache of recently received\
    \ messages.\n"
- title: '1.2.4:  Quality of Protection'
  contents:
  - "1.2.4:  Quality of Protection\n   Some mech_types provide their users with fine\
    \ granularity control\n   over the means used to provide per-message protection,\
    \ allowing\n   callers to trade off security processing overhead dynamically against\n\
    \   the protection requirements of particular messages. A per-message\n   quality-of-protection\
    \ parameter (analogous to quality-of-service, or\n   QOS) selects among different\
    \ QOP options supported by that mechanism.\n   On context establishment for a\
    \ multi-QOP mech_type, context-level\n   data provides the prerequisite data for\
    \ a range of protection\n   qualities.\n   It is expected that the majority of\
    \ callers will not wish to exert\n   explicit mechanism-specific QOP control and\
    \ will therefore request\n   selection of a default QOP. Definitions of, and choices\
    \ among, non-\n   default QOP values are mechanism-specific, and no ordered sequences\n\
    \   of QOP values can be assumed equivalent across different mechanisms.\n   Meaningful\
    \ use of non-default QOP values demands that callers be\n   familiar with the\
    \ QOP definitions of an underlying mechanism or\n   mechanisms, and is therefore\
    \ a non-portable construct.  The\n   GSS_S_BAD_QOP major_status value is defined\
    \ in order to indicate that\n   a provided QOP value is unsupported for a security\
    \ context, most\n   likely because that value is unrecognized by the underlying\n\
    \   mechanism.\n   In the interests of interoperability, mechanisms which allow\
    \ optional\n   support of particular QOP values shall satisfy one of the following\n\
    \   conditions.  Either:\n      (i) All implementations of the mechanism are required\
    \ to be\n      capable of processing messages protected using any QOP value,\n\
    \      regardless of whether they can apply protection corresponding to\n    \
    \  that QOP, or\n      (ii) The set of mutually-supported receiver QOP values\
    \ must be\n      determined during context establishment, and messages may be\n\
    \      protected by either peer using only QOP values from this\n      mutually-supported\
    \ set.\n   NOTE: (i) is just a special-case of (ii), where implementations are\n\
    \   required to support all QOP values on receipt.\n"
- title: '1.2.5: Anonymity Support'
  contents:
  - "1.2.5: Anonymity Support\n   In certain situations or environments, an application\
    \ may wish to\n   authenticate a peer and/or protect communications using GSS-API\
    \ per-\n   message services without revealing its own identity.  For example,\n\
    \   consider an application which provides read access to a research\n   database,\
    \ and which permits queries by arbitrary requestors.  A\n   client of such a service\
    \ might wish to authenticate the service, to\n   establish trust in the information\
    \ received from it, but might not\n   wish to disclose its identity to the service\
    \ for privacy reasons.\n   In ordinary GSS-API usage, a context initiator's identity\
    \ is made\n   available to the context acceptor as part of the context\n   establishment\
    \ process.  To provide for anonymity support, a facility\n   (input anon_req_flag\
    \ to GSS_Init_sec_context()) is provided through\n   which context initiators\
    \ may request that their identity not be\n   provided to the context acceptor.\
    \  Mechanisms are not required to\n   honor this request, but a caller will be\
    \ informed (via returned\n   anon_state indicator from GSS_Init_sec_context())\
    \ whether or not the\n   request is honored. Note that authentication as the anonymous\n\
    \   principal does not necessarily imply that credentials are not\n   required\
    \ in order to establish a context.\n   Section 4.5 of this document defines the\
    \ Object Identifier value used\n   to identify an anonymous principal.\n   Four\
    \ possible combinations of anon_state and mutual_state are\n   possible, with\
    \ the following results:\n      anon_state == FALSE, mutual_state == FALSE: initiator\n\
    \      authenticated to target.\n      anon_state == FALSE, mutual_state == TRUE:\
    \ initiator authenticated\n      to target, target authenticated to initiator.\n\
    \      anon_state == TRUE, mutual_state == FALSE: initiator authenticated\n  \
    \    as anonymous principal to target.\n      anon_state == TRUE, mutual_state\
    \ == TRUE: initiator authenticated\n      as anonymous principal to target, target\
    \ authenticated to\n      initiator.\n"
- title: '1.2.6: Initialization'
  contents:
  - "1.2.6: Initialization\n   No initialization calls (i.e., calls which must be\
    \ invoked prior to\n   invocation of other facilities in the interface) are defined\
    \ in GSS-\n   API.  As an implication of this fact, GSS-API implementations must\n\
    \   themselves be self-initializing.\n"
- title: '1.2.7: Per-Message Protection During Context Establishment'
  contents:
  - "1.2.7: Per-Message Protection During Context Establishment\n   A facility is\
    \ defined in GSS-V2 to enable protection and buffering of\n   data messages for\
    \ later transfer while a security context's\n   establishment is in GSS_S_CONTINUE_NEEDED\
    \ status, to be used in cases\n   where the caller side already possesses the\
    \ necessary session key to\n   enable this processing. Specifically, a new state\
    \ Boolean, called\n   prot_ready_state, is added to the set of information returned\
    \ by\n   GSS_Init_sec_context(), GSS_Accept_sec_context(), and\n   GSS_Inquire_context().\n\
    \   For context establishment calls, this state Boolean is valid and\n   interpretable\
    \ when the associated major_status is either\n   GSS_S_CONTINUE_NEEDED, or GSS_S_COMPLETE.\
    \  Callers of GSS-API (both\n   initiators and acceptors) can assume that per-message\
    \ protection (via\n   GSS_Wrap(), GSS_Unwrap(), GSS_GetMIC() and GSS_VerifyMIC())\
    \ is\n   available and ready for use if either: prot_ready_state == TRUE, or\n\
    \   major_status == GSS_S_COMPLETE, though mutual authentication (if\n   requested)\
    \ cannot be guaranteed until GSS_S_COMPLETE is returned.\n   Callers making use\
    \ of per-message protection services in advance of\n   GSS_S_COMPLETE status should\
    \ be aware of the possibility that a\n   subsequent context establishment step\
    \ may fail, and that certain\n   context data (e.g., mech_type) as returned for\
    \ subsequent calls may\n   change.\n   This approach achieves full, transparent\
    \ backward compatibility for\n   GSS-API V1 callers, who need not even know of\
    \ the existence of\n   prot_ready_state, and who will get the expected behavior\
    \ from\n   GSS_S_COMPLETE, but who will not be able to use per-message\n   protection\
    \ before GSS_S_COMPLETE is returned.\n   It is not a requirement that GSS-V2 mechanisms\
    \ ever return TRUE\n   prot_ready_state before completion of context establishment\
    \ (indeed,\n   some mechanisms will not evolve usable message protection keys,\n\
    \   especially at the context acceptor, before context establishment is\n   complete).\
    \  It is expected but not required that GSS-V2 mechanisms\n   will return TRUE\
    \ prot_ready_state upon completion of context\n   establishment if they support\
    \ per-message protection at all (however\n   GSS-V2 applications should not assume\
    \ that TRUE prot_ready_state will\n   always be returned together with the GSS_S_COMPLETE\
    \ major_status,\n   since GSS-V2 implementations may continue to support GSS-V1\
    \ mechanism\n   code, which will never return TRUE prot_ready_state).\n   When\
    \ prot_ready_state is returned TRUE, mechanisms shall also set\n   those context\
    \ service indicator flags (deleg_state, mutual_state,\n   replay_det_state, sequence_state,\
    \ anon_state, trans_state,\n   conf_avail, integ_avail) which represent facilities\
    \ confirmed, at\n   that time, to be available on the context being established.\
    \  In\n   situations where prot_ready_state is returned before GSS_S_COMPLETE,\n\
    \   it is possible that additional facilities may be confirmed and\n   subsequently\
    \ indicated when GSS_S_COMPLETE is returned.\n"
- title: '1.2.8: Implementation Robustness'
  contents:
  - "1.2.8: Implementation Robustness\n   This section recommends aspects of GSS-API\
    \ implementation behavior in\n   the interests of overall robustness.\n   Invocation\
    \ of GSS-API calls is to incur no undocumented side effects\n   visible at the\
    \ GSS-API level.\n   If a token is presented for processing on a GSS-API security\
    \ context\n   and that token generates a fatal error in processing or is otherwise\n\
    \   determined to be invalid for that context, the context's state should\n  \
    \ not be disrupted for purposes of processing subsequent valid tokens.\n   Certain\
    \ local conditions at a GSS-API implementation (e.g.,\n   unavailability of memory)\
    \ may preclude, temporarily or permanently,\n   the successful processing of tokens\
    \ on a GSS-API security context,\n   typically generating GSS_S_FAILURE major_status\
    \ returns along with\n   locally-significant minor_status.  For robust operation\
    \ under such\n   conditions, the following recommendations are made:\n      Failing\
    \ calls should free any memory they allocate, so that\n      callers may retry\
    \ without causing further loss of resources.\n      Failure of an individual call\
    \ on an established context should not\n      preclude subsequent calls from succeeding\
    \ on the same context.\n      Whenever possible, it should be possible for\n \
    \     GSS_Delete_sec_context() calls to be successfully processed even\n     \
    \ if other calls cannot succeed, thereby enabling context-related\n      resources\
    \ to be released.\n   A failure of GSS_GetMIC() or GSS_Wrap() due to an attempt\
    \ to use an\n   unsupported QOP will not interfere with context validity, nor\
    \ shall\n   such a failure impact the ability of the application to subsequently\n\
    \   invoke GSS_GetMIC() or GSS_Wrap() using a supported QOP. Any state\n   information\
    \ concerning sequencing of outgoing messages shall be\n   unchanged by an unsuccessful\
    \ call of GSS_GetMIC() or GSS_Wrap().\n"
- title: '1.2.9: Delegation'
  contents:
  - "1.2.9: Delegation\n   The GSS-API allows delegation to be controlled by the initiating\n\
    \   application via a Boolean parameter to GSS_Init_sec_context(), the\n   routine\
    \ that establishes a security context.  Some mechanisms do not\n   support delegation,\
    \ and for such mechanisms attempts by an\n   application to enable delegation\
    \ are ignored.\n   The acceptor of a security context for which the initiator\
    \ enabled\n   delegation will receive (via the delegated_cred_handle parameter\
    \ of\n   GSS_Accept_sec_context()) a credential handle that contains the\n   delegated\
    \ identity, and this credential handle may be used to\n   initiate subsequent\
    \ GSS-API security contexts as an agent or delegate\n   of the initiator.  If\
    \ the original initiator's identity is \"A\" and\n   the delegate's identity is\
    \ \"B\", then, depending on the underlying\n   mechanism, the identity embodied\
    \ by the delegated credential may be\n   either \"A\" or \"B acting for A\".\n\
    \   For many mechanisms that support delegation, a simple Boolean does\n   not\
    \ provide enough control.  Examples of additional aspects of\n   delegation control\
    \ that a mechanism might provide to an application\n   are duration of delegation,\
    \ network addresses from which delegation\n   is valid, and constraints on the\
    \ tasks that may be performed by a\n   delegate.  Such controls are presently\
    \ outside the scope of the GSS-\n   API.  GSS-API implementations supporting mechanisms\
    \ offering\n   additional controls should provide extension routines that allow\n\
    \   these controls to be exercised (perhaps by modifying the initiator's\n   GSS-API\
    \ credential prior to its use in establishing a context).\n   However, the simple\
    \ delegation control provided by GSS-API should\n   always be able to over-ride\
    \ other mechanism-specific delegation\n   controls; if the application instructs\
    \ GSS_Init_sec_context() that\n   delegation is not desired, then the implementation\
    \ must not permit\n   delegation to occur.  This is an exception to the general\
    \ rule that a\n   mechanism may enable services even if they are not requested;\n\
    \   delegation may only be provided at the explicit request of the\n   application.\n"
- title: '1.2.10: Interprocess Context Transfer'
  contents:
  - "1.2.10: Interprocess Context Transfer\n   GSS-API V2 provides routines (GSS_Export_sec_context()\
    \ and\n   GSS_Import_sec_context()) which allow a security context to be\n   transferred\
    \ between processes on a single machine.  The most common\n   use for such a feature\
    \ is a client-server design where the server is\n   implemented as a single process\
    \ that accepts incoming security\n   contexts, which then launches child processes\
    \ to deal with the data\n   on these contexts.  In such a design, the child processes\
    \ must have\n   access to the security context data structure created within the\n\
    \   parent by its call to GSS_Accept_sec_context() so that they can use\n   per-message\
    \ protection services and delete the security context when\n   the communication\
    \ session ends.\n   Since the security context data structure is expected to contain\n\
    \   sequencing information, it is impractical in general to share a\n   context\
    \ between processes.  Thus GSS-API provides a call\n   (GSS_Export_sec_context())\
    \ that the process which currently owns the\n   context can call to declare that\
    \ it has no intention to use the\n   context subsequently, and to create an inter-process\
    \ token containing\n   information needed by the adopting process to successfully\
    \ import the\n   context.  After successful completion of this call, the original\n\
    \   security context is made inaccessible to the calling process by GSS-\n   API,\
    \ and any context handles referring to this context are no longer\n   valid. \
    \ The originating process transfers the inter-process token to\n   the adopting\
    \ process, which passes it to GSS_Import_sec_context(),\n   and a fresh context\
    \ handle is created such that it is functionally\n   identical to the original\
    \ context.\n   The inter-process token may contain sensitive data from the original\n\
    \   security context (including cryptographic keys).  Applications using\n   inter-process\
    \ tokens to transfer security contexts must take\n   appropriate steps to protect\
    \ these tokens in transit.\n   Implementations are not required to support the\
    \ inter-process\n   transfer of security contexts.  The ability to transfer a\
    \ security\n   context is indicated when the context is created, by\n   GSS_Init_sec_context()\
    \ or GSS_Accept_sec_context() indicating a TRUE\n   trans_state return value.\n"
- title: '2:  Interface Descriptions'
  contents:
  - "2:  Interface Descriptions\n   This section describes the GSS-API's service interface,\
    \ dividing the\n   set of calls offered into four groups. Credential management\
    \ calls\n   are related to the acquisition and release of credentials by\n   principals.\
    \ Context-level calls are related to the management of\n   security contexts between\
    \ principals. Per-message calls are related\n   to the protection of individual\
    \ messages on established security\n   contexts. Support calls provide ancillary\
    \ functions useful to GSS-API\n   callers. Table 2 groups and summarizes the calls\
    \ in tabular fashion.\n   Table 2:  GSS-API Calls\n   CREDENTIAL MANAGEMENT\n\
    \   GSS_Acquire_cred             acquire credentials for use\n   GSS_Release_cred\
    \             release credentials after use\n   GSS_Inquire_cred             display\
    \ information about\n                                credentials\n   GSS_Add_cred\
    \                 construct credentials incrementally\n   GSS_Inquire_cred_by_mech\
    \     display per-mechanism credential\n                                  information\n\
    \   CONTEXT-LEVEL CALLS\n   GSS_Init_sec_context         initiate outbound security\
    \ context\n   GSS_Accept_sec_context       accept inbound security context\n \
    \  GSS_Delete_sec_context       flush context when no longer needed\n   GSS_Process_context_token\
    \    process received control token on\n                                  context\n\
    \   GSS_Context_time             indicate validity time remaining on\n       \
    \                              context\n   GSS_Inquire_context          display\
    \ information about context\n   GSS_Wrap_size_limit          determine GSS_Wrap\
    \ token size limit\n   GSS_Export_sec_context       transfer context to other\
    \ process\n   GSS_Import_sec_context       import transferred context\n   PER-MESSAGE\
    \ CALLS\n   GSS_GetMIC                   apply integrity check, receive as\n \
    \                                 token separate from message\n   GSS_VerifyMIC\
    \                validate integrity check token\n                            \
    \      along with message\n   GSS_Wrap                     sign, optionally encrypt,\n\
    \                                  encapsulate\n   GSS_Unwrap                \
    \   decapsulate, decrypt if needed,\n                                  validate\
    \ integrity check\n   SUPPORT CALLS\n   GSS_Display_status           translate\
    \ status codes to printable\n                                  form\n   GSS_Indicate_mechs\
    \           indicate mech_types supported on\n                               \
    \   local system\n   GSS_Compare_name             compare two names for equality\n\
    \   GSS_Display_name             translate name to printable form\n   GSS_Import_name\
    \              convert printable name to\n                                  normalized\
    \ form\n   GSS_Release_name             free storage of normalized-form\n    \
    \                              name\n   GSS_Release_buffer           free storage\
    \ of general GSS-allocated\n                                  object\n   GSS_Release_OID_set\
    \          free storage of OID set object\n   GSS_Create_empty_OID_set     create\
    \ empty OID set\n   GSS_Add_OID_set_member       add member to OID set\n   GSS_Test_OID_set_member\
    \      test if OID is member of OID set\n   GSS_Inquire_names_for_mech   indicate\
    \ name types supported by\n                                  mechanism\n   GSS_Inquire_mechs_for_name\
    \   indicates mechanisms supporting name\n                                  type\n\
    \   GSS_Canonicalize_name        translate name to per-mechanism form\n   GSS_Export_name\
    \              externalize per-mechanism name\n   GSS_Duplicate_name         \
    \  duplicate name object\n"
- title: '2.1:  Credential management calls'
  contents:
  - "2.1:  Credential management calls\n   These GSS-API calls provide functions related\
    \ to the management of\n   credentials. Their characterization with regard to\
    \ whether or not\n   they may block pending exchanges with other network entities\
    \ (e.g.,\n   directories or authentication servers) depends in part on OS-specific\n\
    \   (extra-GSS-API) issues, so is not specified in this document.\n   The GSS_Acquire_cred()\
    \ call is defined within the GSS-API in support\n   of application portability,\
    \ with a particular orientation towards\n   support of portable server applications.\
    \ It is recognized that (for\n   certain systems and mechanisms) credentials for\
    \ interactive users may\n   be managed differently from credentials for server\
    \ processes; in such\n   environments, it is the GSS-API implementation's responsibility\
    \ to\n   distinguish these cases and the procedures for making this\n   distinction\
    \ are a local matter. The GSS_Release_cred() call provides\n   a means for callers\
    \ to indicate to the GSS-API that use of a\n   credentials structure is no longer\
    \ required. The GSS_Inquire_cred()\n   call allows callers to determine information\
    \ about a credentials\n   structure.  The GSS_Add_cred() call enables callers\
    \ to append\n   elements to an existing credential structure, allowing iterative\n\
    \   construction of a multi-mechanism credential. The\n   GSS_Inquire_cred_by_mech()\
    \ call enables callers to extract per-\n   mechanism information describing a\
    \ credentials structure.\n"
- title: '2.1.1:  GSS_Acquire_cred call'
  contents:
  - "2.1.1:  GSS_Acquire_cred call\n   Inputs:\n   o  desired_name INTERNAL NAME,\
    \ -- NULL requests locally-determined\n   -- default\n   o  lifetime_req INTEGER,\
    \ -- in seconds; 0 requests default\n   o  desired_mechs SET OF OBJECT IDENTIFIER,\
    \ -- NULL requests\n   -- system-selected default\n   o  cred_usage INTEGER --\
    \ 0=INITIATE-AND-ACCEPT, 1=INITIATE-ONLY,\n   -- 2=ACCEPT-ONLY\n   Outputs:\n\
    \   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o  output_cred_handle\
    \ CREDENTIAL HANDLE, -- if returned non-NULL,\n   -- caller must release with\
    \ GSS_Release_cred()\n   o  actual_mechs SET OF OBJECT IDENTIFIER, -- if returned\
    \ non-NULL,\n   -- caller must release with GSS_Release_oid_set()\n   o  lifetime_rec\
    \ INTEGER -- in seconds, or reserved value for\n   -- INDEFINITE\n   Return major_status\
    \ codes:\n   o  GSS_S_COMPLETE indicates that requested credentials were\n   successfully\
    \ established, for the duration indicated in lifetime_rec,\n   suitable for the\
    \ usage requested in cred_usage, for the set of\n   mech_types indicated in actual_mechs,\
    \ and that those credentials can\n   be referenced for subsequent use with the\
    \ handle returned in\n   output_cred_handle.\n   o  GSS_S_BAD_MECH indicates that\
    \ a mech_type unsupported by the GSS-\n   API implementation type was requested,\
    \ causing the credential\n   establishment operation to fail.\n   o  GSS_S_BAD_NAMETYPE\
    \ indicates that the provided desired_name is\n   uninterpretable or of a type\
    \ unsupported by the applicable underlying\n   GSS-API mechanism(s), so no credentials\
    \ could be established for the\n   accompanying desired_name.\n   o  GSS_S_BAD_NAME\
    \ indicates that the provided desired_name is\n   inconsistent in terms of internally-incorporated\
    \ type specifier\n   information, so no credentials could be established for the\n\
    \   accompanying desired_name.\n   o  GSS_S_CREDENTIALS_EXPIRED indicates that\
    \ underlying credential\n   elements corresponding to the requested desired_name\
    \ have expired, so\n   requested credentials could not be established.\n   o GSS_S_NO_CRED\
    \ indicates that no credential elements corresponding\n   to the requested desired_name\
    \ and usage could be accessed, so\n   requested credentials could not be established.\
    \  In particular, this\n   status should be returned upon temporary user-fixable\
    \ conditions\n   preventing successful credential establishment and upon lack\
    \ of\n   authorization to establish and use credentials associated with the\n\
    \   identity named in the input desired_name argument.\n   o  GSS_S_FAILURE indicates\
    \ that credential establishment failed for\n   reasons unspecified at the GSS-API\
    \ level.\n   GSS_Acquire_cred() is used to acquire credentials so that a principal\n\
    \   can (as a function of the input cred_usage parameter) initiate and/or\n  \
    \ accept security contexts under the identity represented by the\n   desired_name\
    \ input argument. On successful completion, the returned\n   output_cred_handle\
    \ result provides a handle for subsequent references\n   to the acquired credentials.\
    \  Typically, single-user client processes\n   requesting that default credential\
    \ behavior be applied for context\n   establishment purposes will have no need\
    \ to invoke this call.\n   A caller may provide the value NULL (GSS_C_NO_NAME)\
    \ for desired_name,\n   which will be interpreted as a request for a credential\
    \ handle that\n   will invoke default behavior when passed to GSS_Init_sec_context(),\n\
    \   if cred_usage is GSS_C_INITIATE or GSS_C_BOTH, or\n   GSS_Accept_sec_context(),\
    \ if cred_usage is GSS_C_ACCEPT or\n   GSS_C_BOTH.  It is possible that multiple\
    \ pre-established credentials\n   may exist for the same principal identity (for\
    \ example, as a result\n   of multiple user login sessions) when GSS_Acquire_cred()\
    \ is called;\n   the means used in such cases to select a specific credential\
    \ are\n   local matters.  The input lifetime_req argument to GSS_Acquire_cred()\n\
    \   may provide useful information for local GSS-API implementations to\n   employ\
    \ in making this disambiguation in a manner which will best\n   satisfy a caller's\
    \ intent.\n   This routine is expected to be used primarily by context acceptors,\n\
    \   since implementations are likely to provide mechanism-specific ways\n   of\
    \ obtaining GSS-API initiator credentials from the system login\n   process. \
    \ Some implementations may therefore not support the\n   acquisition of GSS_C_INITIATE\
    \ or GSS_C_BOTH credentials via\n   GSS_Acquire_cred() for any name other than\
    \ GSS_C_NO_NAME, or a name\n   resulting from applying GSS_Inquire_context() to\
    \ an active context,\n   or a name resulting from applying GSS_Inquire_cred()\
    \ against a\n   credential handle corresponding to default behavior. It is important\n\
    \   to recognize that the explicit name which is yielded by resolving a\n   default\
    \ reference may change over time, e.g., as a result of local\n   credential element\
    \ management operations outside GSS-API; once\n   resolved, however, the value\
    \ of such an explicit name will remain\n   constant.\n   The lifetime_rec result\
    \ indicates the length of time for which the\n   acquired credentials will be\
    \ valid, as an offset from the present. A\n   mechanism may return a reserved\
    \ value indicating INDEFINITE if no\n   constraints on credential lifetime are\
    \ imposed.  A caller of\n   GSS_Acquire_cred() can request a length of time for\
    \ which acquired\n   credentials are to be valid (lifetime_req argument), beginning\
    \ at the\n   present, or can request credentials with a default validity interval.\n\
    \   (Requests for postdated credentials are not supported within the\n   GSS-API.)\
    \ Certain mechanisms and implementations may bind in\n   credential validity period\
    \ specifiers at a point preliminary to\n   invocation of the GSS_Acquire_cred()\
    \ call (e.g., in conjunction with\n   user login procedures). As a result, callers\
    \ requesting non-default\n   values for lifetime_req must recognize that such\
    \ requests cannot\n   always be honored and must be prepared to accommodate the\
    \ use of\n   returned credentials with different lifetimes as indicated in\n \
    \  lifetime_rec.\n   The caller of GSS_Acquire_cred() can explicitly specify a\
    \ set of\n   mech_types which are to be accommodated in the returned credentials\n\
    \   (desired_mechs argument), or can request credentials for a system-\n   defined\
    \ default set of mech_types. Selection of the system-specified\n   default set\
    \ is recommended in the interests of application\n   portability. The actual_mechs\
    \ return value may be interrogated by the\n   caller to determine the set of mechanisms\
    \ with which the returned\n   credentials may be used.\n"
- title: '2.1.2:  GSS_Release_cred call'
  contents:
  - "2.1.2:  GSS_Release_cred call\n   Input:\n   o  cred_handle CREDENTIAL HANDLE\
    \ -- if GSS_C_NO_CREDENTIAL\n   -- is specified, the call will complete successfully,\
    \ but\n   -- will have no effect; no credential elements will be\n   -- released.\n\
    \   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER\n   Return\
    \ major_status codes:\n   o  GSS_S_COMPLETE indicates that the credentials referenced\
    \ by the\n   input cred_handle were released for purposes of subsequent access\
    \ by\n   the caller. The effect on other processes which may be authorized\n \
    \  shared access to such credentials is a local matter.\n   o  GSS_S_NO_CRED indicates\
    \ that no release operation was performed,\n   either because the input cred_handle\
    \ was invalid or because the\n   caller lacks authorization to access the referenced\
    \ credentials.\n   o  GSS_S_FAILURE indicates that the release operation failed\
    \ for\n   reasons unspecified at the GSS-API level.\n   Provides a means for a\
    \ caller to explicitly request that credentials\n   be released when their use\
    \ is no longer required. Note that system-\n   specific credential management\
    \ functions are also likely to exist,\n   for example to assure that credentials\
    \ shared among processes are\n   properly deleted when all affected processes\
    \ terminate, even if no\n   explicit release requests are issued by those processes.\
    \ Given the\n   fact that multiple callers are not precluded from gaining authorized\n\
    \   access to the same credentials, invocation of GSS_Release_cred()\n   cannot\
    \ be assumed to delete a particular set of credentials on a\n   system-wide basis.\n"
- title: '2.1.3:  GSS_Inquire_cred call'
  contents:
  - "2.1.3:  GSS_Inquire_cred call\n   Input:\n   o  cred_handle CREDENTIAL HANDLE\
    \ -- if GSS_C_NO_CREDENTIAL\n   -- is specified, default initiator credentials\
    \ are queried\n   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n\
    \   o  cred_name INTERNAL NAME,  -- caller must release with\n   -- GSS_Release_name()\n\
    \   o  lifetime_rec INTEGER -- in seconds, or reserved value for\n   -- INDEFINITE\n\
    \   o  cred_usage INTEGER, -- 0=INITIATE-AND-ACCEPT, 1=INITIATE-ONLY,\n   -- 2=ACCEPT-ONLY\n\
    \   o  mech_set SET OF OBJECT IDENTIFIER  -- caller must release\n   -- with GSS_Release_oid_set()\n\
    \   Return major_status codes:\n   o  GSS_S_COMPLETE indicates that the credentials\
    \ referenced by the\n   input cred_handle argument were valid, and that the output\
    \ cred_name,\n   lifetime_rec, and cred_usage values represent, respectively,\
    \ the\n   credentials' associated principal name, remaining lifetime, suitable\n\
    \   usage modes, and supported mechanism types.\n   o  GSS_S_NO_CRED indicates\
    \ that no information could be returned\n   about the referenced credentials,\
    \ either because the input\n   cred_handle was invalid or because the caller lacks\
    \ authorization to\n   access the referenced credentials.\n   o  GSS_S_DEFECTIVE_CREDENTIAL\
    \ indicates that the referenced\n   credentials are invalid.\n   o  GSS_S_CREDENTIALS_EXPIRED\
    \ indicates that the referenced\n   credentials have expired.\n   o  GSS_S_FAILURE\
    \ indicates that the operation failed for reasons\n   unspecified at the GSS-API\
    \ level.\n   The GSS_Inquire_cred() call is defined primarily for the use of those\n\
    \   callers which request use of default credential behavior rather than\n   acquiring\
    \ credentials explicitly with GSS_Acquire_cred().  It enables\n   callers to determine\
    \ a credential structure's associated principal\n   name, remaining validity period,\
    \ usability for security context\n   initiation and/or acceptance, and supported\
    \ mechanisms.\n   For a multi-mechanism credential, the returned \"lifetime\"\
    \ specifier\n   indicates the shortest lifetime of any of the mechanisms' elements\
    \ in\n   the credential (for either context initiation or acceptance\n   purposes).\n\
    \   GSS_Inquire_cred() should indicate INITIATE-AND-ACCEPT for\n   \"cred_usage\"\
    \ if both of the following conditions hold:\n      (1) there exists in the credential\
    \ an element which allows context\n      initiation using some mechanism\n   \
    \   (2) there exists in the credential an element which allows context\n     \
    \ acceptance using some mechanism (allowably, but not necessarily,\n      one\
    \ of the same mechanism(s) qualifying for (1)).\n   If condition (1) holds but\
    \ not condition (2), GSS_Inquire_cred()\n   should indicate INITIATE-ONLY for\
    \ \"cred_usage\".  If condition (2)\n   holds but not condition (1), GSS_Inquire_cred()\
    \ should indicate\n   ACCEPT-ONLY for \"cred_usage\".\n   Callers requiring finer\
    \ disambiguation among available combinations\n   of lifetimes, usage modes, and\
    \ mechanisms should call the\n   GSS_Inquire_cred_by_mech() routine, passing that\
    \ routine one of the\n   mech OIDs returned by GSS_Inquire_cred().\n"
- title: '2.1.4:  GSS_Add_cred call'
  contents:
  - "2.1.4:  GSS_Add_cred call\n   Inputs:\n   o  input_cred_handle CREDENTIAL HANDLE\
    \ -- handle to credential\n   -- structure created with prior GSS_Acquire_cred()\
    \ or\n   -- GSS_Add_cred() call; see text for definition of behavior\n   -- when\
    \ GSS_C_NO_CREDENTIAL provided.\n   o  desired_name INTERNAL NAME\n   o  initiator_time_req\
    \ INTEGER -- in seconds; 0 requests default\n   o  acceptor_time_req INTEGER --\
    \ in seconds; 0 requests default\n   o  desired_mech OBJECT IDENTIFIER\n   o \
    \ cred_usage INTEGER -- 0=INITIATE-AND-ACCEPT, 1=INITIATE-ONLY,\n   -- 2=ACCEPT-ONLY\n\
    \   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o \
    \ output_cred_handle CREDENTIAL HANDLE, -- NULL to request that\n   -- credential\
    \ elements be added \"in place\" to the credential\n   -- structure identified\
    \ by input_cred_handle,\n   -- non-NULL pointer to request that\n   -- a new credential\
    \ structure and handle be created.\n   -- if credential handle returned, caller\
    \ must release with\n   -- GSS_Release_cred()\n   o  actual_mechs SET OF OBJECT\
    \ IDENTIFIER, -- if returned, caller must\n   -- release with GSS_Release_oid_set()\n\
    \   o  initiator_time_rec INTEGER -- in seconds, or reserved value for\n   --\
    \ INDEFINITE\n   o  acceptor_time_rec INTEGER -- in seconds, or reserved value\
    \ for\n   -- INDEFINITE\n   o  cred_usage INTEGER, -- 0=INITIATE-AND-ACCEPT, 1=INITIATE-ONLY,\n\
    \   -- 2=ACCEPT-ONLY\n   o  mech_set SET OF OBJECT IDENTIFIER -- full set of mechanisms\n\
    \   -- supported by resulting credential.\n   Return major_status codes:\n   o\
    \  GSS_S_COMPLETE indicates that the credentials referenced by the\n   input_cred_handle\
    \ argument were valid, and that the resulting\n   credential from GSS_Add_cred()\
    \ is valid for the durations indicated\n   in initiator_time_rec and acceptor_time_rec,\
    \ suitable for the usage\n   requested in cred_usage, and for the mechanisms indicated\
    \ in\n   actual_mechs.\n   o  GSS_S_DUPLICATE_ELEMENT indicates that the input\
    \ desired_mech\n   specified a mechanism for which the referenced credential already\n\
    \   contained a credential element with overlapping cred_usage and\n   validity\
    \ time specifiers.\n   o  GSS_S_BAD_MECH indicates that the input desired_mech\
    \ specified a\n   mechanism unsupported by the GSS-API implementation, causing\
    \ the\n   GSS_Add_cred() operation to fail.\n   o  GSS_S_BAD_NAMETYPE indicates\
    \ that the provided desired_name is\n   uninterpretable or of a type unsupported\
    \ by the applicable underlying\n   GSS-API mechanism(s), so the GSS_Add_cred()\
    \ operation could not be\n   performed for that name.\n   o  GSS_S_BAD_NAME indicates\
    \ that the provided desired_name is\n   inconsistent in terms of internally-incorporated\
    \ type specifier\n   information, so the GSS_Add_cred() operation could not be\
    \ performed\n   for that name.\n   o  GSS_S_NO_CRED indicates that the input_cred_handle\
    \ referenced\n   invalid or inaccessible credentials. In particular, this status\n\
    \   should be returned upon temporary user-fixable conditions preventing\n   successful\
    \ credential establishment or upon lack of authorization to\n   establish or use\
    \ credentials representing the requested identity.\n   o  GSS_S_CREDENTIALS_EXPIRED\
    \ indicates that referenced credential\n   elements have expired, so the GSS_Add_cred()\
    \ operation could not be\n   performed.\n   o  GSS_S_FAILURE indicates that the\
    \ operation failed for reasons\n   unspecified at the GSS-API level.\n   GSS_Add_cred()\
    \ enables callers to construct credentials iteratively\n   by adding credential\
    \ elements in successive operations, corresponding\n   to different mechanisms.\
    \  This offers particular value in multi-\n   mechanism environments, as the major_status\
    \ and minor_status values\n   returned on each iteration are individually visible\
    \ and can therefore\n   be interpreted unambiguously on a per-mechanism basis.\
    \ A credential\n   element is identified by the name of the principal to which\
    \ it\n   refers.  GSS-API implementations must impose a local access control\n\
    \   policy on callers of this routine to prevent unauthorized callers\n   from\
    \ acquiring credential elements to which they are not entitled.\n   This routine\
    \ is not intended to provide a \"login to the network\"\n   function, as such\
    \ a function would involve the creation of new\n   mechanism-specific authentication\
    \ data, rather than merely acquiring\n   a GSS-API handle to existing data.  Such\
    \ functions, if required,\n   should be defined in implementation-specific extension\
    \ routines.\n   If credential acquisition is time-consuming for a mechanism, the\n\
    \   mechanism may choose to delay the actual acquisition until the\n   credential\
    \ is required (e.g. by GSS_Init_sec_context() or\n   GSS_Accept_sec_context()).\
    \  Such mechanism-specific implementation\n   decisions should be invisible to\
    \ the calling application; thus a call\n   of GSS_Inquire_cred() immediately following\
    \ the call of\n   GSS_Acquire_cred() must return valid credential data, and may\n\
    \   therefore incur the overhead of a deferred credential acquisition.\n   If\
    \ GSS_C_NO_CREDENTIAL is specified as input_cred_handle, a non-NULL\n   output_cred_handle\
    \ must be supplied.  For the case of\n   GSS_C_NO_CREDENTIAL as input_cred_handle,\
    \ GSS_Add_cred() will create\n   the credential referenced by its output_cred_handle\
    \ based on default\n   behavior.  That is, the call will have the same effect\
    \ as if the\n   caller had previously called GSS_Acquire_cred(), specifying the\
    \ same\n   usage and passing GSS_C_NO_NAME as the desired_name parameter\n   (thereby\
    \ obtaining an explicit credential handle corresponding to\n   default behavior),\
    \ had passed that credential handle to\n   GSS_Add_cred(), and had finally called\
    \ GSS_Release_cred() on the\n   credential handle received from GSS_Acquire_cred().\n\
    \   This routine is expected to be used primarily by context acceptors,\n   since\
    \ implementations are likely to provide mechanism-specific ways\n   of obtaining\
    \ GSS-API initiator credentials from the system login\n   process.  Some implementations\
    \ may therefore not support the\n   acquisition of GSS_C_INITIATE or GSS_C_BOTH\
    \ credentials via\n   GSS_Acquire_cred() for any name other than GSS_C_NO_NAME,\
    \ or a name\n   resulting from applying GSS_Inquire_context() to an active context,\n\
    \   or a name resulting from applying GSS_Inquire_cred() against a\n   credential\
    \ handle corresponding to default behavior. It is important\n   to recognize that\
    \ the explicit name which is yielded by resolving a\n   default reference may\
    \ change over time, e.g., as a result of local\n   credential element management\
    \ operations outside GSS-API; once\n   resolved, however, the value of such an\
    \ explicit name will remain\n   constant.\n   A caller may provide the value NULL\
    \ (GSS_C_NO_NAME) for desired_name,\n   which will be interpreted as a request\
    \ for a credential handle that\n   will invoke default behavior when passed to\
    \ GSS_Init_sec_context(),\n   if cred_usage is GSS_C_INITIATE or GSS_C_BOTH, or\n\
    \   GSS_Accept_sec_context(), if cred_usage is GSS_C_ACCEPT or\n   GSS_C_BOTH.\n\
    \   The same input desired_name, or default reference, should be used on\n   all\
    \ GSS_Acquire_cred() and GSS_Add_cred() calls corresponding to a\n   particular\
    \ credential.\n"
- title: '2.1.5:  GSS_Inquire_cred_by_mech call'
  contents:
  - "2.1.5:  GSS_Inquire_cred_by_mech call\n   Inputs:\n   o  cred_handle CREDENTIAL\
    \ HANDLE -- if GSS_C_NO_CREDENTIAL\n   -- specified, default initiator credentials\
    \ are queried\n   o  mech_type OBJECT IDENTIFIER  -- specific mechanism for\n\
    \   -- which credentials are being queried\n   Outputs:\n   o  major_status INTEGER,\n\
    \   o  minor_status INTEGER,\n   o  cred_name INTERNAL NAME, -- guaranteed to\
    \ be MN; caller must\n   -- release with GSS_Release_name()\n   o  lifetime_rec_initiate\
    \ INTEGER -- in seconds, or reserved value for\n   -- INDEFINITE\n   o  lifetime_rec_accept\
    \ INTEGER -- in seconds, or reserved value for\n   -- INDEFINITE\n   o  cred_usage\
    \ INTEGER, -- 0=INITIATE-AND-ACCEPT, 1=INITIATE-ONLY,\n   -- 2=ACCEPT-ONLY\n \
    \  Return major_status codes:\n   o  GSS_S_COMPLETE indicates that the credentials\
    \ referenced by the\n   input cred_handle argument were valid, that the mechanism\
    \ indicated\n   by the input mech_type was represented with elements within those\n\
    \   credentials, and that the output cred_name, lifetime_rec_initiate,\n   lifetime_rec_accept,\
    \ and cred_usage values represent, respectively,\n   the credentials' associated\
    \ principal name, remaining lifetimes, and\n   suitable usage modes.\n   o  GSS_S_NO_CRED\
    \ indicates that no information could be returned\n   about the referenced credentials,\
    \ either because the input\n   cred_handle was invalid or because the caller lacks\
    \ authorization to\n   access the referenced credentials.\n   o  GSS_S_DEFECTIVE_CREDENTIAL\
    \ indicates that the referenced\n   credentials are invalid.\n   o  GSS_S_CREDENTIALS_EXPIRED\
    \ indicates that the referenced\n   credentials have expired.\n   o  GSS_S_BAD_MECH\
    \ indicates that the referenced credentials do not\n   contain elements for the\
    \ requested mechanism.\n   o  GSS_S_FAILURE indicates that the operation failed\
    \ for reasons\n   unspecified at the GSS-API level.\n   The GSS_Inquire_cred_by_mech()\
    \ call enables callers in multi-\n   mechanism environments to acquire specific\
    \ data about available\n   combinations of lifetimes, usage modes, and mechanisms\
    \ within a\n   credential structure.  The lifetime_rec_initiate result indicates\
    \ the\n   available lifetime for context initiation purposes; the\n   lifetime_rec_accept\
    \ result indicates the available lifetime for\n   context acceptance purposes.\n"
- title: '2.2:  Context-level calls'
  contents:
  - "2.2:  Context-level calls\n   This group of calls is devoted to the establishment\
    \ and management of\n   security contexts between peers. A context's initiator\
    \ calls\n   GSS_Init_sec_context(), resulting in generation of a token which the\n\
    \   caller passes to the target. At the target, that token is passed to\n   GSS_Accept_sec_context().\
    \ Depending on the underlying mech_type and\n   specified options, additional\
    \ token exchanges may be performed in the\n   course of context establishment;\
    \ such exchanges are accommodated by\n   GSS_S_CONTINUE_NEEDED status returns\
    \ from GSS_Init_sec_context() and\n   GSS_Accept_sec_context().\n   Either party\
    \ to an established context may invoke\n   GSS_Delete_sec_context() to flush context\
    \ information when a context\n   is no longer required. GSS_Process_context_token()\
    \ is used to process\n   received tokens carrying context-level control information.\n\
    \   GSS_Context_time() allows a caller to determine the length of time\n   for\
    \ which an established context will remain valid.\n   GSS_Inquire_context() returns\
    \ status information describing context\n   characteristics. GSS_Wrap_size_limit()\
    \ allows a caller to determine\n   the size of a token which will be generated\
    \ by a GSS_Wrap()\n   operation.  GSS_Export_sec_context() and GSS_Import_sec_context()\n\
    \   enable transfer of active contexts between processes on an end\n   system.\n"
- title: '2.2.1:  GSS_Init_sec_context call'
  contents:
  - "2.2.1:  GSS_Init_sec_context call\n   Inputs:\n   o  claimant_cred_handle CREDENTIAL\
    \ HANDLE, -- NULL specifies \"use\n   -- default\"\n   o  input_context_handle\
    \ CONTEXT HANDLE, -- 0\n   -- (GSS_C_NO_CONTEXT) specifies \"none assigned yet\"\
    \n   o  targ_name INTERNAL NAME,\n   o  mech_type OBJECT IDENTIFIER, -- NULL parameter\
    \ specifies \"use\n   -- default\"\n   o  deleg_req_flag BOOLEAN,\n   o  mutual_req_flag\
    \ BOOLEAN,\n   o  replay_det_req_flag BOOLEAN,\n   o  sequence_req_flag BOOLEAN,\n\
    \   o  anon_req_flag BOOLEAN,\n   o  conf_req_flag BOOLEAN,\n   o  integ_req_flag\
    \ BOOLEAN,\n   o  lifetime_req INTEGER, -- 0 specifies default lifetime\n   o\
    \  chan_bindings OCTET STRING,\n   o  input_token OCTET STRING -- NULL or token\
    \ received from target\n   Outputs:\n   o  major_status INTEGER,\n   o  minor_status\
    \ INTEGER,\n   o  output_context_handle CONTEXT HANDLE,  -- once returned non-NULL,\n\
    \   -- caller must release with GSS_Delete_sec_context()\n   o  mech_type OBJECT\
    \ IDENTIFIER, -- actual mechanism always\n   -- indicated, never NULL; caller\
    \ should treat as read-only\n   -- and should not attempt to release\n   o  output_token\
    \ OCTET STRING, -- NULL or token to pass to context\n   -- target; caller must\
    \ release with GSS_Release_buffer()\n   o  deleg_state BOOLEAN,\n   o  mutual_state\
    \ BOOLEAN,\n   o  replay_det_state BOOLEAN,\n   o  sequence_state BOOLEAN,\n \
    \  o  anon_state BOOLEAN,\n   o  trans_state BOOLEAN,\n   o  prot_ready_state\
    \ BOOLEAN, -- see Section 1.2.7\n   o  conf_avail BOOLEAN,\n   o  integ_avail\
    \ BOOLEAN,\n   o  lifetime_rec INTEGER -- in seconds, or reserved value for\n\
    \   -- INDEFINITE\n   This call may block pending network interactions for those\
    \ mech_types\n   in which an authentication server or other network entity must\
    \ be\n   consulted on behalf of a context initiator in order to generate an\n\
    \   output_token suitable for presentation to a specified target.\n   Return major_status\
    \ codes:\n   o  GSS_S_COMPLETE indicates that context-level information was\n\
    \   successfully initialized, and that the returned output_token will\n   provide\
    \ sufficient information for the target to perform per-message\n   processing\
    \ on the newly-established context.\n   o  GSS_S_CONTINUE_NEEDED indicates that\
    \ control information in the\n   returned output_token must be sent to the target,\
    \ and that a reply\n   must be received and passed as the input_token argument\n\
    \   to a continuation call to GSS_Init_sec_context(), before per-message\n   processing\
    \ can be performed in conjunction with this context (unless\n   the prot_ready_state\
    \ value is concurrently returned TRUE).\n   o  GSS_S_DEFECTIVE_TOKEN indicates\
    \ that consistency checks performed\n   on the input_token failed, preventing\
    \ further processing from being\n   performed based on that token.\n   o  GSS_S_DEFECTIVE_CREDENTIAL\
    \ indicates that consistency checks\n   performed on the credential structure\
    \ referenced by\n   claimant_cred_handle failed, preventing further processing\
    \ from being\n   performed using that credential structure.\n   o  GSS_S_BAD_SIG\
    \ (GSS_S_BAD_MIC) indicates that the received\n   input_token contains an incorrect\
    \ integrity check, so context setup\n   cannot be accomplished.\n   o  GSS_S_NO_CRED\
    \ indicates that no context was established, either\n   because the input cred_handle\
    \ was invalid, because the referenced\n   credentials are valid for context acceptor\
    \ use only, because the\n   caller lacks authorization to access the referenced\
    \ credentials, or\n   because the resolution of default credentials failed.\n\
    \   o  GSS_S_CREDENTIALS_EXPIRED indicates that the credentials provided\n   through\
    \ the input claimant_cred_handle argument are no longer valid,\n   so context\
    \ establishment cannot be completed.\n   o  GSS_S_BAD_BINDINGS indicates that\
    \ a mismatch between the caller-\n   provided chan_bindings and those extracted\
    \ from the input_token was\n   detected, signifying a security-relevant event\
    \ and preventing context\n   establishment. (This result will be returned by\n\
    \   GSS_Init_sec_context() only for contexts where mutual_state is TRUE.)\n  \
    \ o  GSS_S_OLD_TOKEN indicates that the input_token is too old to be\n   checked\
    \ for integrity. This is a fatal error during context\n   establishment.\n   o\
    \  GSS_S_DUPLICATE_TOKEN indicates that the input token has a correct\n   integrity\
    \ check, but is a duplicate of a token already processed.\n   This is a fatal\
    \ error during context establishment.\n   o  GSS_S_NO_CONTEXT indicates that no\
    \ valid context was recognized\n   for the input context_handle provided; this\
    \ major status will be\n   returned only for successor calls following GSS_S_CONTINUE_\
    \ NEEDED\n   status returns.\n   o  GSS_S_BAD_NAMETYPE indicates that the provided\
    \ targ_name is of a\n   type uninterpretable or unsupported by the applicable\
    \ underlying\n   GSS-API mechanism(s), so context establishment cannot be completed.\n\
    \   o  GSS_S_BAD_NAME indicates that the provided targ_name is\n   inconsistent\
    \ in terms of internally-incorporated type specifier\n   information, so context\
    \ establishment cannot be accomplished.\n   o  GSS_S_BAD_MECH indicates receipt\
    \ of a context establishment token\n   or of a caller request specifying a mechanism\
    \ unsupported by the\n   local system or with the caller's active credentials\n\
    \   o  GSS_S_FAILURE indicates that context setup could not be\n   accomplished\
    \ for reasons unspecified at the GSS-API level, and that\n   no interface-defined\
    \ recovery action is available.\n   This routine is used by a context initiator,\
    \ and ordinarily emits an\n   output_token suitable for use by the target within\
    \ the selected\n   mech_type's protocol.  For the case of a multi-step exchange,\
    \ this\n   output_token will be one in a series, each generated by a successive\n\
    \   call. Using information in the credentials structure referenced by\n   claimant_cred_handle,\
    \ GSS_Init_sec_context() initializes the data\n   structures required to establish\
    \ a security context with target\n   targ_name.\n   The targ_name may be any valid\
    \ INTERNAL NAME; it need not be an MN.\n   In addition to support for other name\
    \ types, it is recommended (newly\n   as of GSS-V2, Update 1) that mechanisms\
    \ be able to accept\n   GSS_C_NO_NAME as an input type for targ_name.  While recommended,\n\
    \   such support is not required, and it is recognized that not all\n   mechanisms\
    \ can construct tokens without explicitly naming the context\n   target, even\
    \ when mutual authentication of the target is not\n   obtained.  Callers wishing\
    \ to make use of this facility and concerned\n   with portability should be aware\
    \ that support for GSS_C_NO_NAME as\n   input targ_name type is unlikely to be\
    \ provided within mechanism\n   definitions specified prior to GSS-V2, Update\
    \ 1.\n   The claimant_cred_handle must correspond to the same valid\n   credentials\
    \ structure on the initial call to GSS_Init_sec_context()\n   and on any successor\
    \ calls resulting from GSS_S_CONTINUE_NEEDED\n   status returns; different protocol\
    \ sequences modeled by the\n   GSS_S_CONTINUE_NEEDED facility will require access\
    \ to credentials at\n   different points in the context establishment sequence.\n\
    \   The caller-provided input_context_handle argument is to be 0\n   (GSS_C_NO_CONTEXT),\
    \ specifying \"not yet assigned\", on the first\n   GSS_Init_sec_context()  call\
    \ relating to a given context. If\n   successful (i.e., if accompanied by major_status\
    \ GSS_S_COMPLETE or\n   GSS_S_CONTINUE_NEEDED), and only if successful, the initial\n\
    \   GSS_Init_sec_context() call returns a non-zero output_context_handle\n   for\
    \ use in future references to this context.  Once a non-zero\n   output_context_handle\
    \ has been returned, GSS-API callers should call\n   GSS_Delete_sec_context()\
    \ to release context-related resources if\n   errors occur in later phases of\
    \ context establishment, or when an\n   established context is no longer required.\
    \ If GSS_Init_sec_context()\n   is passed the handle of a context which is already\
    \ fully established,\n   GSS_S_FAILURE status is returned.\n   When continuation\
    \ attempts to GSS_Init_sec_context() are needed to\n   perform context establishment,\
    \ the previously-returned non-zero\n   handle value is entered into the input_context_handle\
    \ argument and\n   will be echoed in the returned output_context_handle argument.\
    \ On\n   such continuation attempts (and only on continuation attempts) the\n\
    \   input_token value is used, to provide the token returned from the\n   context's\
    \ target.\n   The chan_bindings argument is used by the caller to provide\n  \
    \ information binding the security context to security-related\n   characteristics\
    \ (e.g., addresses, cryptographic keys) of the\n   underlying communications channel.\
    \ See Section 1.1.6 of this document\n   for more discussion of this argument's\
    \ usage.\n   The input_token argument contains a message received from the target,\n\
    \   and is significant only on a call to GSS_Init_sec_context() which\n   follows\
    \ a previous return indicating GSS_S_CONTINUE_NEEDED\n   major_status.\n   It\
    \ is the caller's responsibility to establish a communications path\n   to the\
    \ target, and to transmit any returned output_token (independent\n   of the accompanying\
    \ returned major_status value) to the target over\n   that path. The output_token\
    \ can, however, be transmitted along with\n   the first application-provided input\
    \ message to be processed by\n   GSS_GetMIC() or GSS_Wrap() in conjunction with\
    \ a successfully-\n   established context. (Note: when the GSS-V2 prot_ready_state\n\
    \   indicator is returned TRUE, it can be possible to transfer a\n   protected\
    \ message before context establishment is complete:  see also\n   Section 1.2.7)\n\
    \   The initiator may request various context-level functions through\n   input\
    \ flags: the deleg_req_flag requests delegation of access rights,\n   the mutual_req_flag\
    \ requests mutual authentication, the\n   replay_det_req_flag requests that replay\
    \ detection features be\n   applied to messages transferred on the established\
    \ context, and the\n   sequence_req_flag requests that sequencing be enforced.\
    \ (See Section\n   1.2.3 for more information on replay detection and sequencing\n\
    \   features.)  The anon_req_flag requests that the initiator's identity\n   not\
    \ be transferred within tokens to be sent to the acceptor.\n   The conf_req_flag\
    \ and integ_req_flag provide informatory inputs to\n   the GSS-API implementation\
    \ as to whether, respectively, per-message\n   confidentiality and per-message\
    \ integrity services will be required\n   on the context.  This information is\
    \ important as an input to\n   negotiating mechanisms.  It is important to recognize,\
    \ however, that\n   the inclusion of these flags (which are newly defined for\
    \ GSS-V2)\n   introduces a backward incompatibility with callers implemented to\n\
    \   GSS-V1, where the flags were not defined.  Since no GSS-V1 callers\n   would\
    \ set these flags, even if per-message services are desired,\n   GSS-V2 mechanism\
    \ implementations which enable such services\n   selectively based on the flags'\
    \ values may fail to provide them to\n   contexts established for GSS-V1 callers.\
    \  It may be appropriate under\n   certain circumstances, therefore, for such\
    \ mechanism implementations\n   to infer these service request flags to be set\
    \ if a caller is known\n   to be implemented to GSS-V1.\n   Not all of the optionally-requestable\
    \ features will be available in\n   all underlying mech_types. The corresponding\
    \ return state values\n   deleg_state, mutual_state, replay_det_state, and sequence_state\n\
    \   indicate, as a function of mech_type processing capabilities and\n   initiator-provided\
    \ input flags, the set of features which will be\n   active on the context.  The\
    \ returned trans_state value indicates\n   whether the context is transferable\
    \ to other processes through use of\n   GSS_Export_sec_context().  These state\
    \ indicators' values are\n   undefined unless either the routine's major_status\
    \ indicates\n   GSS_S_COMPLETE, or TRUE prot_ready_state is returned along with\n\
    \   GSS_S_CONTINUE_NEEDED major_status; for the latter case, it is\n   possible\
    \ that additional features, not confirmed or indicated along\n   with TRUE prot_ready_state,\
    \ will be confirmed and indicated when\n   GSS_S_COMPLETE is subsequently returned.\n\
    \   The returned anon_state and prot_ready_state values are significant\n   for\
    \ both GSS_S_COMPLETE and GSS_S_CONTINUE_NEEDED major_status\n   returns from\
    \ GSS_Init_sec_context(). When anon_state is returned\n   TRUE, this indicates\
    \ that neither the current token nor its\n   predecessors delivers or has delivered\
    \ the initiator's identity.\n   Callers wishing to perform context establishment\
    \ only if anonymity\n   support is provided should transfer a returned token from\n\
    \   GSS_Init_sec_context() to the peer only if it is accompanied by a\n   TRUE\
    \ anon_state indicator.  When prot_ready_state is returned TRUE in\n   conjunction\
    \ with GSS_S_CONTINUE_NEEDED major_status, this indicates\n   that per-message\
    \ protection operations may be applied on the context:\n   see Section 1.2.7 for\
    \ further discussion of this facility.\n   Failure to provide the precise set\
    \ of features requested by the\n   caller does not cause context establishment\
    \ to fail; it is the\n   caller's prerogative to delete the context if the feature\
    \ set\n   provided is unsuitable for the caller's use.\n   The returned mech_type\
    \ value indicates the specific mechanism\n   employed on the context; it will\
    \ never indicate the value for\n   \"default\".  A valid mech_type result must\
    \ be returned along with a\n   GSS_S_COMPLETE status return; GSS-API implementations\
    \ may (but are\n   not required to) also return mech_type along with predecessor\
    \ calls\n   indicating GSS_S_CONTINUE_NEEDED status or (if a mechanism is\n  \
    \ determinable) in conjunction with fatal error cases.  For the case of\n   mechanisms\
    \ which themselves perform negotiation, the returned\n   mech_type result may\
    \ indicate selection of a mechanism identified by\n   an OID different than that\
    \ passed in the input mech_type argument,\n   and the returned value may change\
    \ between successive calls returning\n   GSS_S_CONTINUE_NEEDED and the final call\
    \ returning GSS_S_COMPLETE.\n   The conf_avail return value indicates whether\
    \ the context supports\n   per-message confidentiality services, and so informs\
    \ the caller\n   whether or not a request for encryption through the conf_req_flag\n\
    \   input to GSS_Wrap() can be honored. In similar fashion, the\n   integ_avail\
    \ return value indicates whether per-message integrity\n   services are available\
    \ (through either GSS_GetMIC() or GSS_Wrap()) on\n   the established context.\
    \ These state indicators' values are undefined\n   unless either the routine's\
    \ major_status indicates GSS_S_COMPLETE, or\n   TRUE prot_ready_state is returned\
    \ along with GSS_S_CONTINUE_NEEDED\n   major_status.\n   The lifetime_req input\
    \ specifies a desired upper bound for the\n   lifetime of the context to be established,\
    \ with a value of 0 used to\n   request a default lifetime. The lifetime_rec return\
    \ value indicates\n   the length of time for which the context will be valid,\
    \ expressed as\n   an offset from the present; depending on mechanism capabilities,\n\
    \   credential lifetimes, and local policy, it may not correspond to the\n   value\
    \ requested in lifetime_req.  If no constraints on context\n   lifetime are imposed,\
    \ this may be indicated by returning a reserved\n   value representing INDEFINITE\
    \ lifetime_req. The value of lifetime_rec\n   is undefined unless the routine's\
    \ major_status indicates\n   GSS_S_COMPLETE.\n   If the mutual_state is TRUE,\
    \ this fact will be reflected within the\n   output_token. A call to GSS_Accept_sec_context()\
    \ at the target in\n   conjunction with such a context will return a token, to\
    \ be processed\n   by a continuation call to GSS_Init_sec_context(), in order\
    \ to achieve\n   mutual authentication.\n"
- title: '2.2.2:  GSS_Accept_sec_context call'
  contents:
  - "2.2.2:  GSS_Accept_sec_context call\n   Inputs:\n   o  acceptor_cred_handle CREDENTIAL\
    \ HANDLE, -- NULL specifies\n   -- \"use default\"\n   o  input_context_handle\
    \ CONTEXT HANDLE, -- 0\n   -- (GSS_C_NO_CONTEXT) specifies \"not yet assigned\"\
    \n   o  chan_bindings OCTET STRING,\n   o  input_token OCTET STRING\n   Outputs:\n\
    \   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o  src_name INTERNAL\
    \ NAME, -- guaranteed to be MN\n   -- once returned, caller must release with\
    \ GSS_Release_name()\n   o  mech_type OBJECT IDENTIFIER, -- caller should treat\
    \ as\n   -- read-only; does not need to be released\n   o  output_context_handle\
    \ CONTEXT HANDLE, -- once returned\n   -- non-NULL in context establishment sequence,\
    \ caller\n   -- must release with GSS_Delete_sec_context()\n   o  deleg_state\
    \ BOOLEAN,\n   o  mutual_state BOOLEAN,\n   o  replay_det_state BOOLEAN,\n   o\
    \  sequence_state BOOLEAN,\n   o  anon_state BOOLEAN,\n   o  trans_state BOOLEAN,\n\
    \   o  prot_ready_state BOOLEAN, -- see Section 1.2.7 for discussion\n   o  conf_avail\
    \ BOOLEAN,\n   o  integ_avail BOOLEAN,\n   o  lifetime_rec INTEGER, -- in seconds,\
    \ or reserved value for\n   -- INDEFINITE\n   o  delegated_cred_handle CREDENTIAL\
    \ HANDLE, -- if returned non-NULL,\n   -- caller must release with GSS_Release_cred()\n\
    \   o  output_token OCTET STRING -- NULL or token to pass to context\n   -- initiator;\
    \ if returned non-NULL, caller must release with\n   -- GSS_Release_buffer()\n\
    \   This call may block pending network interactions for those mech_types\n  \
    \ in which a directory service or other network entity must be\n   consulted on\
    \ behalf of a context acceptor in order to validate a\n   received input_token.\n\
    \   Return major_status codes:\n   o  GSS_S_COMPLETE indicates that context-level\
    \ data structures were\n   successfully initialized, and that per-message processing\
    \ can now be\n   performed in conjunction with this context.\n   o  GSS_S_CONTINUE_NEEDED\
    \ indicates that control information in the\n   returned output_token must be\
    \ sent to the initiator, and that a\n   response must be received and passed as\
    \ the input_token argument to a\n   continuation call to GSS_Accept_sec_context(),\
    \ before per-message\n   processing can be performed in conjunction with this\
    \ context.\n   o  GSS_S_DEFECTIVE_TOKEN indicates that consistency checks performed\n\
    \   on the input_token failed, preventing further processing from being\n   performed\
    \ based on that token.\n   o  GSS_S_DEFECTIVE_CREDENTIAL indicates that consistency\
    \ checks\n   performed on the credential structure referenced by\n   acceptor_cred_handle\
    \ failed, preventing further processing from being\n   performed using that credential\
    \ structure.\n   o  GSS_S_BAD_SIG (GSS_S_BAD_MIC) indicates that the received\n\
    \   input_token contains an incorrect integrity check, so context setup\n   cannot\
    \ be accomplished.\n   o  GSS_S_DUPLICATE_TOKEN indicates that the integrity check\
    \ on the\n   received input_token was correct, but that the input_token was\n\
    \   recognized as a duplicate of an input_token already processed. No new\n  \
    \ context is established.\n   o  GSS_S_OLD_TOKEN indicates that the integrity\
    \ check on the received\n   input_token was correct, but that the input_token\
    \ is too old to be\n   checked for duplication against previously-processed input_tokens.\
    \ No\n   new context is established.\n   o  GSS_S_NO_CRED indicates that no context\
    \ was established, either\n   because the input cred_handle was invalid, because\
    \ the referenced\n   credentials are valid for context initiator use only, because\
    \ the\n   caller lacks authorization to access the referenced credentials, or\n\
    \   because the procedure for default credential resolution failed.\n   o  GSS_S_CREDENTIALS_EXPIRED\
    \ indicates that the credentials provided\n   through the input acceptor_cred_handle\
    \ argument are no longer valid,\n   so context establishment cannot be completed.\n\
    \   o  GSS_S_BAD_BINDINGS indicates that a mismatch between the caller-\n   provided\
    \ chan_bindings and those extracted from the input_token was\n   detected, signifying\
    \ a security-relevant event and preventing context\n   establishment.\n   o  GSS_S_NO_CONTEXT\
    \ indicates that no valid context was recognized\n   for the input context_handle\
    \ provided; this major status will be\n   returned only for successor calls following\
    \ GSS_S_CONTINUE_ NEEDED\n   status returns.\n   o  GSS_S_BAD_MECH indicates receipt\
    \ of a context establishment token\n   specifying a mechanism unsupported by the\
    \ local system or with the\n   caller's active credentials.\n   o  GSS_S_FAILURE\
    \ indicates that context setup could not be\n   accomplished for reasons unspecified\
    \ at the GSS-API level, and that\n   no interface-defined recovery action is available.\n\
    \   The GSS_Accept_sec_context() routine is used by a context target.\n   Using\
    \ information in the credentials structure referenced by the\n   input acceptor_cred_handle,\
    \ it verifies the incoming input_token and\n   (following the successful completion\
    \ of a context establishment\n   sequence) returns the authenticated src_name\
    \ and the mech_type used.\n   The returned src_name is guaranteed to be an MN,\
    \ processed by the\n   mechanism under which the context was established. The\n\
    \   acceptor_cred_handle must correspond to the same valid credentials\n   structure\
    \ on the initial call to GSS_Accept_sec_context() and on any\n   successor calls\
    \ resulting from GSS_S_CONTINUE_NEEDED status returns;\n   different protocol\
    \ sequences modeled by the GSS_S_CONTINUE_NEEDED\n   mechanism will require access\
    \ to credentials at different points in\n   the context establishment sequence.\n\
    \   The caller-provided input_context_handle argument is to be 0\n   (GSS_C_NO_CONTEXT),\
    \ specifying \"not yet assigned\", on the first\n   GSS_Accept_sec_context() call\
    \ relating to a given context. If\n   successful (i.e., if accompanied by major_status\
    \ GSS_S_COMPLETE or\n   GSS_S_CONTINUE_NEEDED), and only if successful, the initial\n\
    \   GSS_Accept_sec_context() call returns a non-zero\n   output_context_handle\
    \ for use in future references to this context.\n   Once a non-zero output_context_handle\
    \ has been returned, GSS-API\n   callers should call GSS_Delete_sec_context()\
    \ to release context-\n   related resources if errors occur in later phases of\
    \ context\n   establishment, or when an established context is no longer required.\n\
    \   If GSS_Accept_sec_context() is passed the handle of a context which\n   is\
    \ already fully established, GSS_S_FAILURE status is returned.\n   The chan_bindings\
    \ argument is used by the caller to provide\n   information binding the security\
    \ context to security-related\n   characteristics (e.g., addresses, cryptographic\
    \ keys) of the\n   underlying communications channel. See Section 1.1.6 of this\
    \ document\n   for more discussion of this argument's usage.\n   The returned\
    \ state results (deleg_state, mutual_state,\n   replay_det_state, sequence_state,\
    \ anon_state, trans_state, and\n   prot_ready_state) reflect the same information\
    \ as described for\n   GSS_Init_sec_context(), and their values are significant\
    \ under the\n   same return state conditions.\n   The conf_avail return value\
    \ indicates whether the context supports\n   per-message confidentiality services,\
    \ and so informs the caller\n   whether or not a request for encryption through\
    \ the conf_req_flag\n   input to GSS_Wrap() can be honored. In similar fashion,\
    \ the\n   integ_avail return value indicates whether per-message integrity\n \
    \  services are available (through either GSS_GetMIC()  or GSS_Wrap())\n   on\
    \ the established context.  These values are significant under the\n   same return\
    \ state conditions as described under\n   GSS_Init_sec_context().\n   The lifetime_rec\
    \ return value is significant only in conjunction with\n   GSS_S_COMPLETE major_status,\
    \ and indicates the length of time for\n   which the context will be valid, expressed\
    \ as an offset from the\n   present.\n   The returned mech_type value indicates\
    \ the specific mechanism\n   employed on the context; it will never indicate the\
    \ value for\n   \"default\".  A valid mech_type result must be returned whenever\n\
    \   GSS_S_COMPLETE status is indicated; GSS-API implementations may (but\n   are\
    \ not required to) also return mech_type along with predecessor\n   calls indicating\
    \ GSS_S_CONTINUE_NEEDED status or (if a mechanism is\n   determinable) in conjunction\
    \ with fatal error cases.  For the case of\n   mechanisms which themselves perform\
    \ negotiation, the returned\n   mech_type result may indicate selection of a mechanism\
    \ identified by\n   an OID different than that passed in the input mech_type argument,\n\
    \   and the returned value may change between successive calls returning\n   GSS_S_CONTINUE_NEEDED\
    \ and the final call returning GSS_S_COMPLETE.\n   The delegated_cred_handle result\
    \ is significant only when deleg_state\n   is TRUE, and provides a means for the\
    \ target to reference the\n   delegated credentials. The output_token result,\
    \ when non-NULL,\n   provides a context-level token to be returned to the context\n\
    \   initiator to continue a multi-step context establishment sequence. As\n  \
    \ noted with GSS_Init_sec_context(), any returned token should be\n   transferred\
    \ to the context's peer (in this case, the context\n   initiator), independent\
    \ of the value of the accompanying returned\n   major_status.\n   Note: A target\
    \ must be able to distinguish a context-level\n   input_token, which is passed\
    \ to GSS_Accept_sec_context(), from the\n   per-message data elements passed to\
    \ GSS_VerifyMIC()  or GSS_Unwrap().\n   These data elements may arrive in a single\
    \ application message, and\n   GSS_Accept_sec_context() must be performed before\
    \ per-message\n   processing can be performed successfully.\n"
- title: '2.2.3: GSS_Delete_sec_context call'
  contents:
  - "2.2.3: GSS_Delete_sec_context call\n   Input:\n   o  context_handle CONTEXT HANDLE\n\
    \   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o \
    \ output_context_token OCTET STRING\n   Return major_status codes:\n   o  GSS_S_COMPLETE\
    \ indicates that the context was recognized, and that\n   relevant context-specific\
    \ information was flushed.  If the caller\n   provides a non-null buffer to receive\
    \ an output_context_token, and\n   the mechanism returns a non-NULL token into\
    \ that buffer, the returned\n   output_context_token is ready for transfer to\
    \ the context's peer.\n   o  GSS_S_NO_CONTEXT indicates that no valid context\
    \ was recognized\n   for the input context_handle provided, so no deletion was\
    \ performed.\n   o  GSS_S_FAILURE indicates that the context is recognized, but\
    \ that\n   the GSS_Delete_sec_context() operation could not be performed for\n\
    \   reasons unspecified at the GSS-API level.\n   This call can be made by either\
    \ peer in a security context, to flush\n   context-specific information. Once\
    \ a non-zero output_context_handle\n   has been returned by context establishment\
    \ calls, GSS-API callers\n   should call GSS_Delete_sec_context() to release context-related\n\
    \   resources if errors occur in later phases of context establishment,\n   or\
    \ when an established context is no longer required.  This call may\n   block\
    \ pending network interactions for mech_types in which active\n   notification\
    \ must be made to a central server when a security context\n   is to be deleted.\n\
    \   If a non-null output_context_token parameter is provided by the\n   caller,\
    \ an output_context_token may be returned to the caller.  If an\n   output_context_token\
    \ is provided to the caller, it can be passed to\n   the context's peer to inform\
    \ the peer's GSS-API implementation that\n   the peer's corresponding context\
    \ information can also be flushed.\n   (Once a context is established, the peers\
    \ involved are expected to\n   retain cached credential and context-related information\
    \ until the\n   information's expiration time is reached or until a\n   GSS_Delete_sec_context()\
    \ call is made.)\n   The facility for context_token usage to signal context deletion\
    \ is\n   retained for compatibility with GSS-API Version 1.  For current\n   usage,\
    \ it is recommended that both peers to a context invoke\n   GSS_Delete_sec_context()\
    \ independently, passing a null\n   output_context_token buffer to indicate that\
    \ no context_token is\n   required.  Implementations of GSS_Delete_sec_context()\
    \ should delete\n   relevant locally-stored context information.\n   Attempts\
    \ to perform per-message processing on a deleted context will\n   result in error\
    \ returns.\n"
- title: '2.2.4:  GSS_Process_context_token call'
  contents:
  - "2.2.4:  GSS_Process_context_token call\n   Inputs:\n   o  context_handle CONTEXT\
    \ HANDLE,\n   o  input_context_token OCTET STRING\n   Outputs:\n   o  major_status\
    \ INTEGER,\n   o  minor_status INTEGER,\n   Return major_status codes:\n   o \
    \ GSS_S_COMPLETE indicates that the input_context_token was\n   successfully processed\
    \ in conjunction with the context referenced by\n   context_handle.\n   o  GSS_S_DEFECTIVE_TOKEN\
    \ indicates that consistency checks performed\n   on the received context_token\
    \ failed, preventing further processing\n   from being performed with that token.\n\
    \   o  GSS_S_NO_CONTEXT indicates that no valid context was recognized\n   for\
    \ the input context_handle provided.\n   o  GSS_S_FAILURE indicates that the context\
    \ is recognized, but that\n   the GSS_Process_context_token() operation could\
    \ not be performed for\n   reasons unspecified at the GSS-API level.\n   This\
    \ call is used to process context_tokens received from a peer once\n   a context\
    \ has been established, with corresponding impact on\n   context-level state information.\
    \ One use for this facility is\n   processing of the context_tokens generated\
    \ by\n   GSS_Delete_sec_context(); GSS_Process_context_token() will not block\n\
    \   pending network interactions for that purpose. Another use is to\n   process\
    \ tokens indicating remote-peer context establishment failures\n   after the point\
    \ where the local GSS-API implementation has already\n   indicated GSS_S_COMPLETE\
    \ status.\n"
- title: '2.2.5:  GSS_Context_time call'
  contents:
  - "2.2.5:  GSS_Context_time call\n   Input:\n   o  context_handle CONTEXT HANDLE,\n\
    \   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o \
    \ lifetime_rec INTEGER -- in seconds, or reserved value for\n   -- INDEFINITE\n\
    \   Return major_status codes:\n   o  GSS_S_COMPLETE indicates that the referenced\
    \ context is valid, and\n   will remain valid for the amount of time indicated\
    \ in lifetime_rec.\n   o  GSS_S_CONTEXT_EXPIRED indicates that data items related\
    \ to the\n   referenced context have expired.\n   o  GSS_S_NO_CONTEXT indicates\
    \ that no valid context was recognized\n   for the input context_handle provided.\n\
    \   o  GSS_S_FAILURE indicates that the requested operation failed for\n   reasons\
    \ unspecified at the GSS-API level.\n   This call is used to determine the amount\
    \ of time for which a\n   currently established context will remain valid.\n"
- title: '2.2.6: GSS_Inquire_context call'
  contents:
  - "2.2.6: GSS_Inquire_context call\n   Input:\n   o  context_handle CONTEXT HANDLE,\n\
    \   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o \
    \ src_name INTERNAL NAME,  -- name of context initiator,\n   -- guaranteed to\
    \ be MN;\n   -- caller must release with GSS_Release_name() if returned\n   o\
    \  targ_name INTERNAL NAME,  -- name of context target,\n   -- guaranteed to be\
    \ MN;\n   -- caller must release with GSS_Release_name() if returned\n   o  lifetime_rec\
    \ INTEGER -- in seconds, or reserved value for\n   -- INDEFINITE or EXPIRED\n\
    \   o  mech_type OBJECT IDENTIFIER, -- the mechanism supporting this\n   -- security\
    \ context; caller should treat as read-only and not\n   -- attempt to release\n\
    \   o  deleg_state BOOLEAN,\n   o  mutual_state BOOLEAN,\n   o  replay_det_state\
    \ BOOLEAN,\n   o  sequence_state BOOLEAN,\n   o  anon_state BOOLEAN,\n   o  trans_state\
    \ BOOLEAN,\n   o  prot_ready_state BOOLEAN,\n   o  conf_avail BOOLEAN,\n   o \
    \ integ_avail BOOLEAN,\n   o  locally_initiated BOOLEAN, -- TRUE if initiator,\
    \ FALSE if acceptor\n   o  open BOOLEAN, -- TRUE if context fully established,\
    \ FALSE\n   -- if partly established (in CONTINUE_NEEDED state)\n   Return major_status\
    \ codes:\n   o  GSS_S_COMPLETE indicates that the referenced context is valid\
    \ and\n   that deleg_state, mutual_state, replay_det_state, sequence_state,\n\
    \   anon_state, trans_state, prot_ready_state, conf_avail, integ_avail,\n   locally_initiated,\
    \ and open return values describe the corresponding\n   characteristics of the\
    \ context.  If open is TRUE, lifetime_rec is\n   also returned: if open is TRUE\
    \ and the context peer's name is known,\n   src_name and targ_name are valid in\
    \ addition to the values listed\n   above.  The mech_type value must be returned\
    \ for contexts where open\n   is TRUE and may be returned for contexts where open\
    \ is FALSE.\n   o  GSS_S_NO_CONTEXT indicates that no valid context was recognized\n\
    \   for the input context_handle provided. Return values other than\n   major_status\
    \ and minor_status are undefined.\n   o  GSS_S_FAILURE indicates that the requested\
    \ operation failed for\n   reasons unspecified at the GSS-API level. Return values\
    \ other than\n   major_status and minor_status are undefined.\n   This call is\
    \ used to extract information describing characteristics\n   of a security context.\
    \  Note that GSS-API implementations are\n   expected to retain inquirable context\
    \ data on a context until the\n   context is released by a caller, even after\
    \ the context has expired,\n   although underlying cryptographic data elements\
    \ may be deleted after\n   expiration in order to limit their exposure.\n"
- title: '2.2.7:   GSS_Wrap_size_limit call'
  contents:
  - "2.2.7:   GSS_Wrap_size_limit call\n   Inputs:\n   o  context_handle CONTEXT HANDLE,\n\
    \   o  conf_req_flag BOOLEAN,\n   o  qop INTEGER,\n   o  output_size INTEGER\n\
    \   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o \
    \ max_input_size INTEGER\n   Return major_status codes:\n   o  GSS_S_COMPLETE\
    \ indicates a successful token size determination:\n   an input message with a\
    \ length in octets equal to the returned\n   max_input_size value will, when passed\
    \ to GSS_Wrap() for processing\n   on the context identified by the context_handle\
    \ parameter with the\n   confidentiality request state as provided in conf_req_flag\
    \ and with\n   the quality of protection specifier provided in the qop parameter,\n\
    \   yield an output token no larger than the value of the provided\n   output_size\
    \ parameter.\n   o  GSS_S_CONTEXT_EXPIRED indicates that the provided input\n\
    \   context_handle is recognized, but that the referenced context has\n   expired.\
    \  Return values other than major_status and minor_status are\n   undefined.\n\
    \   o  GSS_S_NO_CONTEXT indicates that no valid context was recognized\n   for\
    \ the input context_handle provided. Return values other than\n   major_status\
    \ and minor_status are undefined.\n   o  GSS_S_BAD_QOP indicates that the provided\
    \ QOP value is not\n   recognized or supported for the context.\n   o  GSS_S_FAILURE\
    \ indicates that the requested operation failed for\n   reasons unspecified at\
    \ the GSS-API level. Return values other than\n   major_status and minor_status\
    \ are undefined.\n   This call is used to determine the largest input datum which\
    \ may be\n   passed to GSS_Wrap() without yielding an output token larger than\
    \ a\n   caller-specified value.\n"
- title: '2.2.8:   GSS_Export_sec_context call'
  contents:
  - "2.2.8:   GSS_Export_sec_context call\n   Inputs:\n   o  context_handle CONTEXT\
    \ HANDLE\n   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n\
    \   o  interprocess_token OCTET STRING  -- caller must release\n   -- with GSS_Release_buffer()\n\
    \   Return major_status codes:\n   o  GSS_S_COMPLETE indicates that the referenced\
    \ context has been\n   successfully exported to a representation in the interprocess_token,\n\
    \   and is no longer available for use by the caller.\n   o  GSS_S_UNAVAILABLE\
    \ indicates that the context export facility is\n   not available for use on the\
    \ referenced context.  (This status should\n   occur only for contexts for which\
    \ the trans_state value is FALSE.)\n   Return values other than major_status and\
    \ minor_status are undefined.\n   o  GSS_S_CONTEXT_EXPIRED indicates that the\
    \ provided input\n   context_handle is recognized, but that the referenced context\
    \ has\n   expired.  Return values other than major_status and minor_status are\n\
    \   undefined.\n   o  GSS_S_NO_CONTEXT indicates that no valid context was recognized\n\
    \   for the input context_handle provided. Return values other than\n   major_status\
    \ and minor_status are undefined.\n   o  GSS_S_FAILURE indicates that the requested\
    \ operation failed for\n   reasons unspecified at the GSS-API level. Return values\
    \ other than\n   major_status and minor_status are undefined.\n   This call generates\
    \ an interprocess token for transfer to another\n   process within an end system,\
    \ in order to transfer control of a\n   security context to that process.  The\
    \ recipient of the interprocess\n   token will call GSS_Import_sec_context() to\
    \ accept the transfer.  The\n   GSS_Export_sec_context() operation is defined\
    \ for use only with\n   security contexts which are fully and successfully established\
    \ (i.e.,\n   those for which GSS_Init_sec_context() and GSS_Accept_sec_context()\n\
    \   have returned GSS_S_COMPLETE major_status).\n   A successful GSS_Export_sec_context()\
    \ operation deactivates the\n   security context for the calling process; for\
    \ this case, the GSS-API\n   implementation shall deallocate all process-wide\
    \ resources associated\n   with the security context and shall set the context_handle\
    \ to\n   GSS_C_NO_CONTEXT.  In the event of an error that makes it impossible\n\
    \   to complete export of the security context, the GSS-API\n   implementation\
    \ must not return an interprocess token and should\n   strive to leave the security\
    \ context referenced by the context_handle\n   untouched.  If this is impossible,\
    \ it is permissible for the\n   implementation to delete the security context,\
    \ provided that it also\n   sets the context_handle parameter to GSS_C_NO_CONTEXT.\n\
    \   Portable callers must not assume that a given interprocess token can\n   be\
    \ imported by GSS_Import_sec_context() more than once, thereby\n   creating multiple\
    \ instantiations of a single context.  GSS-API\n   implementations may detect\
    \ and reject attempted multiple imports, but\n   are not required to do so.\n\
    \   The internal representation contained within the interprocess token\n   is\
    \ an implementation-defined local matter.  Interprocess tokens\n   cannot be assumed\
    \ to be transferable across different GSS-API\n   implementations.\n   It is recommended\
    \ that GSS-API implementations adopt policies suited\n   to their operational\
    \ environments in order to define the set of\n   processes eligible to import\
    \ a context, but specific constraints in\n   this area are local matters.  Candidate\
    \ examples include transfers\n   between processes operating on behalf of the\
    \ same user identity, or\n   processes comprising a common job.  However, it may\
    \ be impossible to\n   enforce such policies in some implementations.\n   In support\
    \ of the above goals, implementations may protect the\n   transferred context\
    \ data by using cryptography to protect data within\n   the interprocess token,\
    \ or by using interprocess tokens as a means to\n   reference local interprocess\
    \ communication facilities (protected by\n   other means) rather than storing\
    \ the context data directly within the\n   tokens.\n   Transfer of an open context\
    \ may, for certain mechanisms and\n   implementations, reveal data about the credential\
    \ which was used to\n   establish the context.  Callers should, therefore, be\
    \ cautious about\n   the trustworthiness of processes to which they transfer contexts.\n\
    \   Although the GSS-API implementation may provide its own set of\n   protections\
    \ over the exported context, the caller is responsible for\n   protecting the\
    \ interprocess token from disclosure, and for taking\n   care that the context\
    \ is transferred to an appropriate destination\n   process.\n"
- title: '2.2.9:   GSS_Import_sec_context call'
  contents:
  - "2.2.9:   GSS_Import_sec_context call\n   Inputs:\n   o  interprocess_token OCTET\
    \ STRING\n   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n\
    \   o  context_handle CONTEXT HANDLE  -- if successfully returned,\n   -- caller\
    \ must release with GSS_Delete_sec_context()\n   Return major_status codes:\n\
    \   o  GSS_S_COMPLETE indicates that the context represented by the input\n  \
    \ interprocess_token has been successfully transferred to the caller,\n   and\
    \ is available for future use via the output context_handle.\n   o  GSS_S_NO_CONTEXT\
    \ indicates that the context represented by the\n   input interprocess_token was\
    \ invalid. Return values other than\n   major_status and minor_status are undefined.\n\
    \   o  GSS_S_DEFECTIVE_TOKEN indicates that the input interprocess_token\n   was\
    \ defective.  Return values other than major_status and\n   minor_status are undefined.\n\
    \   o  GSS_S_UNAVAILABLE indicates that the context import facility is\n   not\
    \ available for use on the referenced context.  Return values other\n   than major_status\
    \ and minor_status are undefined.\n   o  GSS_S_UNAUTHORIZED indicates that the\
    \ context represented by the\n   input interprocess_token is unauthorized for\
    \ transfer to the caller.\n   Return values other than major_status and minor_status\
    \ are undefined.\n   o  GSS_S_FAILURE indicates that the requested operation failed\
    \ for\n   reasons unspecified at the GSS-API level. Return values other than\n\
    \   major_status and minor_status are undefined.\n   This call processes an interprocess\
    \ token generated by\n   GSS_Export_sec_context(), making the transferred context\
    \ available\n   for use by the caller.  After a successful GSS_Import_sec_context()\n\
    \   operation, the imported context is available for use by the importing\n  \
    \ process. In particular, the imported context is usable for all per-\n   message\
    \ operations and may be deleted or exported by its importer.\n   The inability\
    \ to receive delegated credentials through\n   gss_import_sec_context() precludes\
    \ establishment of new contexts\n   based on information delegated to the importer's\
    \ end system within\n   the context which is being imported, unless those delegated\n\
    \   credentials are obtained through separate routines (e.g., XGSS-API\n   calls)\
    \ outside the GSS-V2 definition.\n   For further discussion of the security and\
    \ authorization issues\n   regarding this call, please see the discussion in Section\
    \ 2.2.8.\n"
- title: '2.3:  Per-message calls'
  contents:
  - "2.3:  Per-message calls\n   This group of calls is used to perform per-message\
    \ protection\n   processing on an established security context. None of these\
    \ calls\n   block pending network interactions. These calls may be invoked by\
    \ a\n   context's initiator or by the context's target.  The four members of\n\
    \   this group should be considered as two pairs; the output from\n   GSS_GetMIC()\
    \ is properly input to GSS_VerifyMIC(), and the output\n   from GSS_Wrap() is\
    \ properly input to GSS_Unwrap().\n   GSS_GetMIC() and GSS_VerifyMIC() support\
    \ data origin authentication\n   and data integrity services. When GSS_GetMIC()\
    \ is invoked on an input\n   message, it yields a per-message token containing\
    \ data items which\n   allow underlying mechanisms to provide the specified security\n\
    \   services. The original message, along with the generated per-message\n   token,\
    \ is passed to the remote peer; these two data elements are\n   processed by GSS_VerifyMIC(),\
    \ which validates the message in\n   conjunction with the separate token.\n  \
    \ GSS_Wrap() and GSS_Unwrap() support caller-requested confidentiality\n   in\
    \ addition to the data origin authentication and data integrity\n   services offered\
    \ by GSS_GetMIC() and GSS_VerifyMIC(). GSS_Wrap()\n   outputs a single data element,\
    \ encapsulating optionally enciphered\n   user data as well as associated token\
    \ data items.  The data element\n   output from GSS_Wrap() is passed to the remote\
    \ peer and processed by\n   GSS_Unwrap() at that system. GSS_Unwrap() combines\
    \ decipherment (as\n   required) with validation of data items related to authentication\
    \ and\n   integrity.\n   Although zero-length tokens are never returned by GSS\
    \ calls for\n   transfer to a context's peer, a zero-length object may be passed\
    \ by a\n   caller into GSS_Wrap(), in which case the corresponding peer calling\n\
    \   GSS_Unwrap() on the transferred token will receive a zero-length\n   object\
    \ as output from GSS_Unwrap().  Similarly, GSS_GetMIC() can be\n   called on an\
    \ empty object, yielding a MIC which GSS_VerifyMIC() will\n   successfully verify\
    \ against the active security context in\n   conjunction with a zero-length object.\n"
- title: '2.3.1:  GSS_GetMIC call'
  contents:
  - "2.3.1:  GSS_GetMIC call\n   Note: This call is functionally equivalent to the\
    \ GSS_Sign call as\n   defined in previous versions of this specification. In\
    \ the interests\n   of backward compatibility, it is recommended that implementations\n\
    \   support this function under both names for the present; future\n   references\
    \ to this function as GSS_Sign are deprecated.\n   Inputs:\n   o  context_handle\
    \ CONTEXT HANDLE,\n   o  qop_req INTEGER, -- 0 specifies default QOP\n   o  message\
    \ OCTET STRING\n   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n\
    \   o  per_msg_token OCTET STRING  -- caller must release\n   -- with GSS_Release_buffer()\n\
    \   Return major_status codes:\n   o  GSS_S_COMPLETE indicates that an integrity\
    \ check, suitable for an\n   established security context, was successfully applied\
    \ and that the\n   message and corresponding per_msg_token are ready for transmission.\n\
    \   o  GSS_S_CONTEXT_EXPIRED indicates that context-related data items\n   have\
    \ expired, so that the requested operation cannot be performed.\n   o  GSS_S_NO_CONTEXT\
    \ indicates that no context was recognized for the\n   input context_handle provided.\n\
    \   o  GSS_S_BAD_QOP indicates that the provided QOP value is not\n   recognized\
    \ or supported for the context.\n   o  GSS_S_FAILURE indicates that the context\
    \ is recognized, but that\n   the requested operation could not be performed for\
    \ reasons\n   unspecified at the GSS-API level.\n   Using the security context\
    \ referenced by context_handle, apply an\n   integrity check to the input message\
    \ (along with timestamps and/or\n   other data included in support of mech_type-specific\
    \ mechanisms) and\n   (if GSS_S_COMPLETE status is indicated) return the result\
    \ in\n   per_msg_token. The qop_req parameter, interpretation of which is\n  \
    \ discussed in Section 1.2.4, allows quality-of-protection control. The\n   caller\
    \ passes the message and the per_msg_token to the target.\n   The GSS_GetMIC()\
    \ function completes before the message and\n   per_msg_token is sent to the peer;\
    \ successful application of\n   GSS_GetMIC() does not guarantee that a corresponding\
    \ GSS_VerifyMIC()\n   has been (or can necessarily be) performed successfully\
    \ when the\n   message arrives at the destination.\n   Mechanisms which do not\
    \ support per-message protection services\n   should return GSS_S_FAILURE if this\
    \ routine is called.\n"
- title: '2.3.2:  GSS_VerifyMIC call'
  contents:
  - "2.3.2:  GSS_VerifyMIC call\n   Note: This call is functionally equivalent to\
    \ the GSS_Verify call as\n   defined in previous versions of this specification.\
    \ In the interests\n   of backward compatibility, it is recommended that implementations\n\
    \   support this function under both names for the present; future\n   references\
    \ to this function as GSS_Verify are deprecated.\n   Inputs:\n   o  context_handle\
    \ CONTEXT HANDLE,\n   o  message OCTET STRING,\n   o  per_msg_token OCTET STRING\n\
    \   Outputs:\n   o  qop_state INTEGER,\n   o  major_status INTEGER,\n   o  minor_status\
    \ INTEGER,\n   Return major_status codes:\n   o  GSS_S_COMPLETE indicates that\
    \ the message was successfully\n   verified.\n   o  GSS_S_DEFECTIVE_TOKEN indicates\
    \ that consistency checks performed\n   on the received per_msg_token failed,\
    \ preventing further processing\n   from being performed with that token.\n  \
    \ o  GSS_S_BAD_SIG (GSS_S_BAD_MIC) indicates that the received\n   per_msg_token\
    \ contains an incorrect integrity check for the message.\n   o  GSS_S_DUPLICATE_TOKEN,\
    \ GSS_S_OLD_TOKEN, GSS_S_UNSEQ_TOKEN, and\n   GSS_S_GAP_TOKEN values appear in\
    \ conjunction with the optional per-\n   message replay detection features described\
    \ in Section 1.2.3; their\n   semantics are described in that section.\n   o \
    \ GSS_S_CONTEXT_EXPIRED indicates that context-related data items\n   have expired,\
    \ so that the requested operation cannot be performed.\n   o  GSS_S_NO_CONTEXT\
    \ indicates that no context was recognized for the\n   input context_handle provided.\n\
    \   o  GSS_S_FAILURE indicates that the context is recognized, but that\n   the\
    \ GSS_VerifyMIC() operation could not be performed for reasons\n   unspecified\
    \ at the GSS-API level.\n   Using the security context referenced by context_handle,\
    \ verify that\n   the input per_msg_token contains an appropriate integrity check\
    \ for\n   the input message, and apply any active replay detection or\n   sequencing\
    \ features. Returns an indication of the quality-of-\n   protection applied to\
    \ the processed message in the qop_state result.\n   Mechanisms which do not support\
    \ per-message protection services\n   should return GSS_S_FAILURE if this routine\
    \ is called.\n"
- title: '2.3.3: GSS_Wrap call'
  contents:
  - "2.3.3: GSS_Wrap call\n   Note: This call is functionally equivalent to the GSS_Seal\
    \ call as\n   defined in previous versions of this specification. In the interests\n\
    \   of backward compatibility, it is recommended that implementations\n   support\
    \ this function under both names for the present; future\n   references to this\
    \ function as GSS_Seal are deprecated.\n   Inputs:\n   o  context_handle CONTEXT\
    \ HANDLE,\n   o  conf_req_flag BOOLEAN,\n   o  qop_req INTEGER, -- 0 specifies\
    \ default QOP\n   o  input_message OCTET STRING\n   Outputs:\n   o  major_status\
    \ INTEGER,\n   o  minor_status INTEGER,\n   o  conf_state BOOLEAN,\n   o  output_message\
    \ OCTET STRING  -- caller must release with\n   -- GSS_Release_buffer()\n   Return\
    \ major_status codes:\n   o  GSS_S_COMPLETE indicates that the input_message was\
    \ successfully\n   processed and that the output_message is ready for transmission.\n\
    \   o  GSS_S_CONTEXT_EXPIRED indicates that context-related data items\n   have\
    \ expired, so that the requested operation cannot be performed.\n   o  GSS_S_NO_CONTEXT\
    \ indicates that no context was recognized for the\n   input context_handle provided.\n\
    \   o  GSS_S_BAD_QOP indicates that the provided QOP value is not\n   recognized\
    \ or supported for the context.\n   o  GSS_S_FAILURE indicates that the context\
    \ is recognized, but that\n   the GSS_Wrap() operation could not be performed\
    \ for reasons\n   unspecified at the GSS-API level.\n   Performs the data origin\
    \ authentication and data integrity functions\n   of GSS_GetMIC().  If the input\
    \ conf_req_flag is TRUE, requests that\n   confidentiality be applied to the input_message.\
    \  Confidentiality may\n   not be supported in all mech_types or by all implementations;\
    \ the\n   returned conf_state flag indicates whether confidentiality was\n   provided\
    \ for the input_message. The qop_req parameter, interpretation\n   of which is\
    \ discussed in Section 1.2.4, allows quality-of-protection\n   control.\n   When\
    \ GSS_S_COMPLETE status is returned, the GSS_Wrap() call yields a\n   single output_message\
    \ data element containing (optionally enciphered)\n   user data as well as control\
    \ information.\n   Mechanisms which do not support per-message protection services\n\
    \   should return GSS_S_FAILURE if this routine is called.\n"
- title: '2.3.4: GSS_Unwrap call'
  contents:
  - "2.3.4: GSS_Unwrap call\n   Note: This call is functionally equivalent to the\
    \ GSS_Unseal call as\n   defined in previous versions of this specification. In\
    \ the interests\n   of backward compatibility, it is recommended that implementations\n\
    \   support this function under both names for the present; future\n   references\
    \ to this function as GSS_Unseal are deprecated.\n   Inputs:\n   o  context_handle\
    \ CONTEXT HANDLE,\n   o  input_message OCTET STRING\n   Outputs:\n   o  conf_state\
    \ BOOLEAN,\n   o  qop_state INTEGER,\n   o  major_status INTEGER,\n   o  minor_status\
    \ INTEGER,\n   o  output_message OCTET STRING  -- caller must release with\n \
    \  -- GSS_Release_buffer()\n   Return major_status codes:\n   o  GSS_S_COMPLETE\
    \ indicates that the input_message was successfully\n   processed and that the\
    \ resulting output_message is available.\n   o  GSS_S_DEFECTIVE_TOKEN indicates\
    \ that consistency checks performed\n   on the per_msg_token extracted from the\
    \ input_message failed,\n   preventing further processing from being performed.\n\
    \   o  GSS_S_BAD_SIG (GSS_S_BAD_MIC) indicates that an incorrect\n   integrity\
    \ check was detected for the message.\n   o  GSS_S_DUPLICATE_TOKEN, GSS_S_OLD_TOKEN,\
    \ GSS_S_UNSEQ_TOKEN, and\n   GSS_S_GAP_TOKEN values appear in conjunction with\
    \ the optional per-\n   message replay detection features described in Section\
    \ 1.2.3; their\n   semantics are described in that section.\n   o  GSS_S_CONTEXT_EXPIRED\
    \ indicates that context-related data items\n   have expired, so that the requested\
    \ operation cannot be performed.\n   o  GSS_S_NO_CONTEXT indicates that no context\
    \ was recognized for the\n   input context_handle provided.\n   o  GSS_S_FAILURE\
    \ indicates that the context is recognized, but that\n   the GSS_Unwrap() operation\
    \ could not be performed for reasons\n   unspecified at the GSS-API level.\n \
    \  Processes a data element generated (and optionally enciphered) by\n   GSS_Wrap(),\
    \ provided as input_message. The returned conf_state value\n   indicates whether\
    \ confidentiality was applied to the input_message.\n   If conf_state is TRUE,\
    \ GSS_Unwrap() has deciphered the input_message.\n   Returns an indication of\
    \ the quality-of-protection applied to the\n   processed message in the qop_state\
    \ result. GSS_Unwrap() performs the\n   data integrity and data origin authentication\
    \ checking functions of\n   GSS_VerifyMIC() on the plaintext data. Plaintext data\
    \ is returned in\n   output_message.\n   Mechanisms which do not support per-message\
    \ protection services\n   should return GSS_S_FAILURE if this routine is called.\n"
- title: '2.4:  Support calls'
  contents:
  - "2.4:  Support calls\n   This group of calls provides support functions useful\
    \ to GSS-API\n   callers, independent of the state of established contexts. Their\n\
    \   characterization with regard to blocking or non-blocking status in\n   terms\
    \ of network interactions is unspecified.\n"
- title: '2.4.1:  GSS_Display_status call'
  contents:
  - "2.4.1:  GSS_Display_status call\n   Inputs:\n   o  status_value INTEGER, -- GSS-API\
    \ major_status or minor_status\n   -- return value\n   o  status_type INTEGER,\
    \ -- 1 if major_status, 2 if minor_status\n   o  mech_type OBJECT IDENTIFIER --\
    \ mech_type to be used for\n   -- minor_status translation\n   Outputs:\n   o\
    \  major_status INTEGER,\n   o  minor_status INTEGER,\n   o  status_string_set\
    \ SET OF OCTET STRING  -- required calls for\n   -- release by caller are specific\
    \ to language bindings\n   Return major_status codes:\n   o  GSS_S_COMPLETE indicates\
    \ that a valid printable status\n   representation (possibly representing more\
    \ than one status event\n   encoded within the status_value) is available in the\
    \ returned\n   status_string_set.\n   o  GSS_S_BAD_MECH indicates that translation\
    \ in accordance with an\n   unsupported mech_type was requested, so translation\
    \ could not be\n   performed.\n   o  GSS_S_BAD_STATUS indicates that the input\
    \ status_value was\n   invalid, or that the input status_type carried a value\
    \ other than 1\n   or 2, so translation could not be performed.\n   o  GSS_S_FAILURE\
    \ indicates that the requested operation could not be\n   performed for reasons\
    \ unspecified at the GSS-API level.\n   Provides a means for callers to translate\
    \ GSS-API-returned major and\n   minor status codes into printable string representations.\
    \  Note: some\n   language bindings may employ an iterative approach in order\
    \ to emit\n   successive status components; this approach is acceptable but not\n\
    \   required for conformance with the current specification.\n   Although not\
    \ contemplated in [RFC-2078], it has been observed that\n   some existing GSS-API\
    \ implementations return GSS_S_CONTINUE_NEEDED\n   status when iterating through\
    \ successive messages returned from\n   GSS_Display_status(). This behavior is\
    \ deprecated;\n   GSS_S_CONTINUE_NEEDED should be returned only by\n   GSS_Init_sec_context()\
    \ and GSS_Accept_sec_context().  For maximal\n   portability, however, it is recommended\
    \ that defensive callers be\n   able to accept and ignore GSS_S_CONTINUE_NEEDED\
    \ status if indicated\n   by GSS_Display_status() or any other call other than\n\
    \   GSS_Init_sec_context() or GSS_Accept_sec_context().\n"
- title: '2.4.2:  GSS_Indicate_mechs call'
  contents:
  - "2.4.2:  GSS_Indicate_mechs call\n   Input:\n   o  (none)\n   Outputs:\n   o \
    \ major_status INTEGER,\n   o  minor_status INTEGER,\n   o  mech_set SET OF OBJECT\
    \ IDENTIFIER  -- caller must release\n   -- with GSS_Release_oid_set()\n   Return\
    \ major_status codes:\n   o  GSS_S_COMPLETE indicates that a set of available\
    \ mechanisms has\n   been returned in mech_set.\n   o  GSS_S_FAILURE indicates\
    \ that the requested operation could not be\n   performed for reasons unspecified\
    \ at the GSS-API level.\n   Allows callers to determine the set of mechanism types\
    \ available on\n   the local system. This call is intended for support of specialized\n\
    \   callers who need to request non-default mech_type sets from GSS-API\n   calls\
    \ which accept input mechanism type specifiers.\n"
- title: '2.4.3:  GSS_Compare_name call'
  contents:
  - "2.4.3:  GSS_Compare_name call\n   Inputs:\n   o  name1 INTERNAL NAME,\n   o \
    \ name2 INTERNAL NAME\n   Outputs:\n   o  major_status INTEGER,\n   o  minor_status\
    \ INTEGER,\n   o  name_equal BOOLEAN\n   Return major_status codes:\n   o  GSS_S_COMPLETE\
    \ indicates that name1 and name2 were comparable, and\n   that the name_equal\
    \ result indicates whether name1 and name2\n   represent the same entity.\n  \
    \ o  GSS_S_BAD_NAMETYPE indicates that the two input names' types are\n   different\
    \ and incomparable, so that the comparison operation could\n   not be completed.\n\
    \   o  GSS_S_BAD_NAME indicates that one or both of the input names was\n   ill-formed\
    \ in terms of its internal type specifier, so the comparison\n   operation could\
    \ not be completed.\n   o  GSS_S_FAILURE indicates that the call's operation could\
    \ not be\n   performed for reasons unspecified at the GSS-API level.\n   Allows\
    \ callers to compare two internal name representations to\n   determine whether\
    \ they refer to the same entity.  If either name\n   presented to GSS_Compare_name()\
    \ denotes an anonymous principal,\n   GSS_Compare_name() shall indicate FALSE.\
    \  It is not required that\n   either or both inputs name1 and name2 be MNs; for\
    \ some\n   implementations and cases, GSS_S_BAD_NAMETYPE may be returned,\n  \
    \ indicating name incomparability, for the case where neither input\n   name is\
    \ an MN.\n"
- title: '2.4.4:  GSS_Display_name call'
  contents:
  - "2.4.4:  GSS_Display_name call\n   Inputs:\n   o  name INTERNAL NAME\n   Outputs:\n\
    \   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o  name_string OCTET\
    \ STRING, -- caller must release\n   -- with GSS_Release_buffer()\n   o  name_type\
    \ OBJECT IDENTIFIER  -- caller should treat\n   -- as read-only; does not need\
    \ to be released\n   Return major_status codes:\n   o  GSS_S_COMPLETE indicates\
    \ that a valid printable name\n   representation is available in the returned\
    \ name_string.\n   o  GSS_S_BAD_NAME indicates that the contents of the provided\
    \ name\n   were inconsistent with the internally-indicated name type, so no\n\
    \   printable representation could be generated.\n   o  GSS_S_FAILURE indicates\
    \ that the requested operation could not be\n   performed for reasons unspecified\
    \ at the GSS-API level.\n   Allows callers to translate an internal name representation\
    \ into a\n   printable form with associated namespace type descriptor. The syntax\n\
    \   of the printable form is a local matter.\n   If the input name represents\
    \ an anonymous identity, a reserved value\n   (GSS_C_NT_ANONYMOUS) shall be returned\
    \ for name_type.\n   The GSS_C_NO_OID name type is to be returned only when the\n\
    \   corresponding internal name was created through import with\n   GSS_C_NO_OID.\
    \ It is acceptable for mechanisms to normalize names\n   imported with GSS_C_NO_OID\
    \ into other supported types and, therefore,\n   to display them with types other\
    \ than GSS_C_NO_OID.\n"
- title: '2.4.5:  GSS_Import_name call'
  contents:
  - "2.4.5:  GSS_Import_name call\n   Inputs:\n   o  input_name_string OCTET STRING,\n\
    \   o  input_name_type OBJECT IDENTIFIER\n   Outputs:\n   o  major_status INTEGER,\n\
    \   o  minor_status INTEGER,\n   o  output_name INTERNAL NAME  -- caller must\
    \ release with\n   -- GSS_Release_name()\n   Return major_status codes:\n   o\
    \  GSS_S_COMPLETE indicates that a valid name representation is\n   output in\
    \ output_name and described by the type value in\n   output_name_type.\n   o \
    \ GSS_S_BAD_NAMETYPE indicates that the input_name_type is\n   unsupported by\
    \ the applicable underlying GSS-API mechanism(s), so the\n   import operation\
    \ could not be completed.\n   o  GSS_S_BAD_NAME indicates that the provided input_name_string\
    \ is\n   ill-formed in terms of the input_name_type, so the import operation\n\
    \   could not be completed.\n   o  GSS_S_BAD_MECH indicates that the input presented\
    \ for import was\n   an exported name object and that its enclosed mechanism type\
    \ was not\n   recognized or was unsupported by the GSS-API implementation.\n \
    \  o  GSS_S_FAILURE indicates that the requested operation could not be\n   performed\
    \ for reasons unspecified at the GSS-API level.\n   Allows callers to provide\
    \ a name representation as a contiguous octet\n   string, designate the type of\
    \ namespace in conjunction with which it\n   should be parsed, and convert that\
    \ representation to an internal form\n   suitable for input to other GSS-API routines.\
    \  The syntax of the\n   input_name_string is defined in conjunction with its\
    \ associated name\n   type; depending on the input_name_type, the associated\n\
    \   input_name_string may or may not be a printable string.  If the\n   input_name_type's\
    \ value is GSS_C_NO_OID, a mechanism-specific default\n   printable syntax (which\
    \ shall be specified in the corresponding GSS-\n   V2 mechanism specification)\
    \ is assumed for the input_name_string;\n   other input_name_type values as registered\
    \ by GSS-API implementations\n   can be used to indicate specific non-default\
    \ name syntaxes. Note: The\n   input_name_type argument serves to describe and\
    \ qualify the\n   interpretation of the associated input_name_string; it does\
    \ not\n   specify the data type of the returned output_name.\n   If a mechanism\
    \ claims support for a particular name type, its\n   GSS_Import_name() operation\
    \ shall be able to accept all possible\n   values conformant to the external name\
    \ syntax as defined for that\n   name type.  These imported values may correspond\
    \ to:\n      (1) locally registered entities (for which credentials may be\n \
    \     acquired),\n      (2) non-local entities (for which local credentials cannot\
    \ be\n      acquired, but which may be referenced as targets of initiated\n  \
    \    security contexts or initiators of accepted security contexts), or\n    \
    \  to\n      (3) neither of the above.\n   Determination of whether a particular\
    \ name belongs to class (1), (2),\n   or (3) as described above is not guaranteed\
    \ to be performed by the\n   GSS_Import_name() function.\n   The internal name\
    \ generated by a GSS_Import_name() operation may be a\n   single-mechanism MN,\
    \ and is likely to be an MN within a single-\n   mechanism implementation, but\
    \ portable callers must not depend on\n   this property (and must not, therefore,\
    \ assume that the output from\n   GSS_Import_name() can be passed directly to\
    \ GSS_Export_name() without\n   first being processed through GSS_Canonicalize_name()).\n"
- title: '2.4.6: GSS_Release_name call'
  contents:
  - "2.4.6: GSS_Release_name call\n   Inputs:\n   o  name INTERNAL NAME\n   Outputs:\n\
    \   o  major_status INTEGER,\n   o  minor_status INTEGER\n   Return major_status\
    \ codes:\n   o  GSS_S_COMPLETE indicates that the storage associated with the\n\
    \   input name was successfully released.\n   o  GSS_S_BAD_NAME indicates that\
    \ the input name argument did not\n   contain a valid name.\n   o  GSS_S_FAILURE\
    \ indicates that the requested operation could not be\n   performed for reasons\
    \ unspecified at the GSS-API level.\n   Allows callers to release the storage\
    \ associated with an internal\n   name representation.  This call's specific behavior\
    \ depends on the\n   language and programming environment within which a GSS-API\n\
    \   implementation operates, and is therefore detailed within applicable\n   bindings\
    \ specifications; in particular, implementation and invocation\n   of this call\
    \ may be superfluous (and may be omitted) within bindings\n   where memory management\
    \ is automatic.\n"
- title: '2.4.7: GSS_Release_buffer call'
  contents:
  - "2.4.7: GSS_Release_buffer call\n   Inputs:\n   o  buffer OCTET STRING\n   Outputs:\n\
    \   o  major_status INTEGER,\n   o  minor_status INTEGER\n   Return major_status\
    \ codes:\n   o  GSS_S_COMPLETE indicates that the storage associated with the\n\
    \   input buffer was successfully released.\n   o  GSS_S_FAILURE indicates that\
    \ the requested operation could not be\n   performed for reasons unspecified at\
    \ the GSS-API level.\n   Allows callers to release the storage associated with\
    \ an OCTET STRING\n   buffer allocated by another GSS-API call.  This call's specific\n\
    \   behavior depends on the language and programming environment within\n   which\
    \ a GSS-API implementation operates, and is therefore detailed\n   within applicable\
    \ bindings specifications; in particular,\n   implementation and invocation of\
    \ this call may be superfluous (and\n   may be omitted) within bindings where\
    \ memory management is automatic.\n"
- title: '2.4.8: GSS_Release_OID_set call'
  contents:
  - "2.4.8: GSS_Release_OID_set call\n   Inputs:\n   o  buffer SET OF OBJECT IDENTIFIER\n\
    \   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER\n   Return\
    \ major_status codes:\n   o  GSS_S_COMPLETE indicates that the storage associated\
    \ with the\n   input object identifier set was successfully released.\n   o  GSS_S_FAILURE\
    \ indicates that the requested operation could not be\n   performed for reasons\
    \ unspecified at the GSS-API level.\n   Allows callers to release the storage\
    \ associated with an object\n   identifier set object allocated by another GSS-API\
    \ call.  This call's\n   specific behavior depends on the language and programming\
    \ environment\n   within which a GSS-API implementation operates, and is therefore\n\
    \   detailed within applicable bindings specifications; in particular,\n   implementation\
    \ and invocation of this call may be superfluous (and\n   may be omitted) within\
    \ bindings where memory management is automatic.\n"
- title: '2.4.9: GSS_Create_empty_OID_set call'
  contents:
  - "2.4.9: GSS_Create_empty_OID_set call\n   Inputs:\n   o  (none)\n   Outputs:\n\
    \   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o  oid_set SET OF\
    \ OBJECT IDENTIFIER  -- caller must release\n   -- with GSS_Release_oid_set()\n\
    \   Return major_status codes:\n   o  GSS_S_COMPLETE indicates successful completion\n\
    \   o  GSS_S_FAILURE indicates that the operation failed\n   Creates an object\
    \ identifier set containing no object identifiers, to\n   which members may be\
    \ subsequently added using the\n   GSS_Add_OID_set_member() routine.  These routines\
    \ are intended to be\n   used to construct sets of mechanism object identifiers,\
    \ for input to\n   GSS_Acquire_cred().\n"
- title: '2.4.10: GSS_Add_OID_set_member call'
  contents:
  - "2.4.10: GSS_Add_OID_set_member call\n   Inputs:\n   o  member_oid OBJECT IDENTIFIER,\n\
    \   o  oid_set SET OF OBJECT IDENTIFIER\n   Outputs:\n   o  major_status INTEGER,\n\
    \   o  minor_status INTEGER,\n   Return major_status codes:\n   o  GSS_S_COMPLETE\
    \ indicates successful completion\n   o  GSS_S_FAILURE indicates that the operation\
    \ failed\n   Adds an Object Identifier to an Object Identifier set.  This routine\n\
    \   is intended for use in conjunction with GSS_Create_empty_OID_set()\n   when\
    \ constructing a set of mechanism OIDs for input to\n   GSS_Acquire_cred().\n"
- title: '2.4.11: GSS_Test_OID_set_member call'
  contents:
  - "2.4.11: GSS_Test_OID_set_member call\n   Inputs:\n   o  member OBJECT IDENTIFIER,\n\
    \   o  set SET OF OBJECT IDENTIFIER\n   Outputs:\n   o  major_status INTEGER,\n\
    \   o  minor_status INTEGER,\n   o  present BOOLEAN\n   Return major_status codes:\n\
    \   o  GSS_S_COMPLETE indicates successful completion\n   o  GSS_S_FAILURE indicates\
    \ that the operation failed\n   Interrogates an Object Identifier set to determine\
    \ whether a\n   specified Object Identifier is a member.  This routine is intended\
    \ to\n   be used with OID sets returned by GSS_Indicate_mechs(),\n   GSS_Acquire_cred(),\
    \ and GSS_Inquire_cred().\n"
- title: '2.4.12:  GSS_Inquire_names_for_mech call'
  contents:
  - "2.4.12:  GSS_Inquire_names_for_mech call\n   Input:\n   o  input_mech_type OBJECT\
    \ IDENTIFIER, -- mechanism type\n   Outputs:\n   o  major_status INTEGER,\n  \
    \ o  minor_status INTEGER,\n   o  name_type_set SET OF OBJECT IDENTIFIER -- caller\
    \ must release\n   -- with GSS_Release_oid_set()\n   Return major_status codes:\n\
    \   o  GSS_S_COMPLETE indicates that the output name_type_set contains a\n   list\
    \ of name types which are supported by the locally available\n   mechanism identified\
    \ by input_mech_type.\n   o  GSS_S_BAD_MECH indicates that the mechanism identified\
    \ by\n   input_mech_type was unsupported within the local implementation,\n  \
    \ causing the query to fail.\n   o  GSS_S_FAILURE indicates that the requested\
    \ operation could not be\n   performed for reasons unspecified at the GSS-API\
    \ level.\n   Allows callers to determine the set of name types which are\n   supportable\
    \ by a specific locally-available mechanism.\n"
- title: '2.4.13: GSS_Inquire_mechs_for_name call'
  contents:
  - "2.4.13: GSS_Inquire_mechs_for_name call\n   Inputs:\n   o  input_name INTERNAL\
    \ NAME,\n   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n\
    \   o  mech_types SET OF OBJECT IDENTIFIER  -- caller must release\n   -- with\
    \ GSS_Release_oid_set()\n   Return major_status codes:\n   o  GSS_S_COMPLETE indicates\
    \ that a set of object identifiers,\n   corresponding to the set of mechanisms\
    \ suitable for processing the\n   input_name, is available in mech_types.\n  \
    \ o  GSS_S_BAD_NAME indicates that the input_name was ill-formed and\n   could\
    \ not be processed.\n   o  GSS_S_BAD_NAMETYPE indicates that the input_name parameter\n\
    \   contained an invalid name type or a name type unsupported by the\n   GSS-API\
    \ implementation.\n   o  GSS_S_FAILURE indicates that the requested operation\
    \ could not be\n   performed for reasons unspecified at the GSS-API level.\n \
    \  This routine returns the mechanism set with which the input_name may\n   be\
    \ processed.\n   Each mechanism returned will recognize at least one element within\n\
    \   the name. It is permissible for this routine to be implemented within\n  \
    \ a mechanism-independent GSS-API layer, using the type information\n   contained\
    \ within the presented name, and based on registration\n   information provided\
    \ by individual mechanism implementations.  This\n   means that the returned mech_types\
    \ result may indicate that a\n   particular mechanism will understand a particular\
    \ name when in fact\n   it would refuse to accept that name as input to\n   GSS_Canonicalize_name(),\
    \ GSS_Init_sec_context(), GSS_Acquire_cred(),\n   or GSS_Add_cred(), due to some\
    \ property of the particular name rather\n   than a property of the name type.\
    \  Thus, this routine should be used\n   only as a pre-filter for a call to a\
    \ subsequent mechanism-specific\n   routine.\n"
- title: '2.4.14: GSS_Canonicalize_name call'
  contents:
  - "2.4.14: GSS_Canonicalize_name call\n   Inputs:\n   o  input_name INTERNAL NAME,\n\
    \   o  mech_type OBJECT IDENTIFIER  -- must be explicit mechanism,\n   -- not\
    \ \"default\" specifier or identifier of negotiating mechanism\n   Outputs:\n\
    \   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o  output_name INTERNAL\
    \ NAME  -- caller must release with\n   -- GSS_Release_name()\n   Return major_status\
    \ codes:\n   o  GSS_S_COMPLETE indicates that a mechanism-specific reduction of\n\
    \   the input_name, as processed by the mechanism identified by\n   mech_type,\
    \ is available in output_name.\n   o  GSS_S_BAD_MECH indicates that the identified\
    \ mechanism is\n   unsupported for this operation; this may correspond either\
    \ to a\n   mechanism wholly unsupported by the local GSS-API implementation or\n\
    \   to a negotiating mechanism with which the canonicalization operation\n   cannot\
    \ be performed.\n   o  GSS_S_BAD_NAMETYPE indicates that the input name does not\
    \ contain\n   an element with suitable type for processing by the identified\n\
    \   mechanism.\n   o  GSS_S_BAD_NAME indicates that the input name contains an\
    \ element\n   with suitable type for processing by the identified mechanism, but\n\
    \   that this element could not be processed successfully.\n   o  GSS_S_FAILURE\
    \ indicates that the requested operation could not be\n   performed for reasons\
    \ unspecified at the GSS-API level.\n   This routine reduces a GSS-API internal\
    \ name input_name, which may in\n   general contain elements corresponding to\
    \ multiple mechanisms, to a\n   mechanism-specific Mechanism Name (MN) output_name\
    \ by applying the\n   translations corresponding to the mechanism identified by\
    \ mech_type.\n   The contents of input_name are unaffected by the\n   GSS_Canonicalize_name()\
    \ operation.  References to output_name will\n   remain valid until output_name\
    \ is released, independent of whether or\n   not input_name is subsequently released.\n"
- title: '2.4.15: GSS_Export_name call'
  contents:
  - "2.4.15: GSS_Export_name call\n   Inputs:\n   o  input_name INTERNAL NAME, --\
    \ required to be MN\n   Outputs:\n   o  major_status INTEGER,\n   o  minor_status\
    \ INTEGER,\n   o  output_name OCTET STRING  -- caller must release\n   -- with\
    \ GSS_Release_buffer()\n   Return major_status codes:\n   o  GSS_S_COMPLETE indicates\
    \ that a flat representation of the input\n   name is available in output_name.\n\
    \   o  GSS_S_NAME_NOT_MN indicates that the input name contained elements\n  \
    \ corresponding to multiple mechanisms, so cannot be exported into a\n   single-mechanism\
    \ flat form.\n   o  GSS_S_BAD_NAME indicates that the input name was an MN, but\
    \ could\n   not be processed.\n   o  GSS_S_BAD_NAMETYPE indicates that the input\
    \ name was an MN, but\n   that its type is unsupported by the GSS-API implementation.\n\
    \   o  GSS_S_FAILURE indicates that the requested operation could not be\n   performed\
    \ for reasons unspecified at the GSS-API level.\n   This routine creates a flat\
    \ name representation, suitable for\n   bytewise comparison or for input to GSS_Import_name()\
    \ in conjunction\n   with the reserved GSS-API Exported Name Object OID, from\
    \ a internal-\n   form Mechanism Name (MN) as emitted, e.g., by GSS_Canonicalize_name()\n\
    \   or GSS_Accept_sec_context().\n   The emitted GSS-API Exported Name Object\
    \ is self-describing; no\n   associated parameter-level OID need be emitted by\
    \ this call.  This\n   flat representation consists of a mechanism-independent\
    \ wrapper\n   layer, defined in Section 3.2 of this document, enclosing a\n  \
    \ mechanism-defined name representation.\n   In all cases, the flat name output\
    \ by GSS_Export_name() to correspond\n   to a particular input MN must be invariant\
    \ over time within a\n   particular installation.\n   The GSS_S_NAME_NOT_MN status\
    \ code is provided to enable\n   implementations to reject input names which are\
    \ not MNs.  It is not,\n   however, required for purposes of conformance to this\
    \ specification\n   that all non-MN input names must necessarily be rejected.\n"
- title: '2.4.16: GSS_Duplicate_name call'
  contents:
  - "2.4.16: GSS_Duplicate_name call\n   Inputs:\n   o  src_name INTERNAL NAME\n \
    \  Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o  dest_name\
    \ INTERNAL NAME  -- caller must release\n   -- with GSS_Release_name()\n   Return\
    \ major_status codes:\n   o  GSS_S_COMPLETE indicates that dest_name references\
    \ an internal\n   name object containing the same name as passed to src_name.\n\
    \   o  GSS_S_BAD_NAME indicates that the input name was invalid.\n   o  GSS_S_FAILURE\
    \ indicates that the requested operation could not be\n   performed for reasons\
    \ unspecified at the GSS-API level.\n   This routine takes input internal name\
    \ src_name, and returns another\n   reference (dest_name) to that name which can\
    \ be used even if src_name\n   is later freed.  (Note: This may be implemented\
    \ by copying or through\n   use of reference counts.)\n"
- title: '3: Data Structure Definitions for GSS-V2 Usage'
  contents:
  - "3: Data Structure Definitions for GSS-V2 Usage\n   Subsections of this section\
    \ define, for interoperability and\n   portability purposes, certain data structures\
    \ for use with GSS-V2.\n"
- title: '3.1: Mechanism-Independent Token Format'
  contents:
  - "3.1: Mechanism-Independent Token Format\n   This section specifies a mechanism-independent\
    \ level of encapsulating\n   representation for the initial token of a GSS-API\
    \ context\n   establishment sequence, incorporating an identifier of the mechanism\n\
    \   type to be used on that context and enabling tokens to be interpreted\n  \
    \ unambiguously at GSS-API peers. Use of this format is required for\n   initial\
    \ context establishment tokens of Internet standards-track\n   GSS-API mechanisms;\
    \ use in non-initial tokens is optional.\n   The encoding format for the token\
    \ tag is derived from ASN.1 and DER\n   (per illustrative ASN.1 syntax included\
    \ later within this\n   subsection), but its concrete representation is defined\
    \ directly in\n   terms of octets rather than at the ASN.1 level in order to facilitate\n\
    \   interoperable implementation without use of general ASN.1 processing\n   code.\
    \  The token tag consists of the following elements, in order:\n      1. 0x60\
    \ -- Tag for [APPLICATION 0] SEQUENCE; indicates that\n      -- constructed form,\
    \ definite length encoding follows.\n      2. Token length octets, specifying\
    \ length of subsequent data\n      (i.e., the summed lengths of elements 3-5 in\
    \ this list, and of the\n      mechanism-defined token object following the tag).\
    \  This element\n      comprises a variable number of octets:\n         2a. If\
    \ the indicated value is less than 128, it shall be\n         represented in a\
    \ single octet with bit 8 (high order) set to\n         \"0\" and the remaining\
    \ bits representing the value.\n         2b. If the indicated value is 128 or\
    \ more, it shall be\n         represented in two or more octets, with bit 8 of\
    \ the first\n         octet set to \"1\" and the remaining bits of the first octet\n\
    \         specifying the number of additional octets.  The subsequent\n      \
    \   octets carry the value, 8 bits per octet, most significant\n         digit\
    \ first.  The minimum number of octets shall be used to\n         encode the length\
    \ (i.e., no octets representing leading zeros\n         shall be included within\
    \ the length encoding).\n      3. 0x06 -- Tag for OBJECT IDENTIFIER\n      4.\
    \ Object identifier length -- length (number of octets) of\n      -- the encoded\
    \ object identifier contained in element 5,\n      -- encoded per rules as described\
    \ in 2a. and 2b. above.\n      5. Object identifier octets -- variable number\
    \ of octets,\n      -- encoded per ASN.1 BER rules:\n         5a. The first octet\
    \ contains the sum of two values: (1) the\n         top-level object identifier\
    \ component, multiplied by 40\n         (decimal), and (2) the second-level object\
    \ identifier\n         component.  This special case is the only point within\
    \ an\n         object identifier encoding where a single octet represents\n  \
    \       contents of more than one component.\n         5b. Subsequent octets,\
    \ if required, encode successively-lower\n         components in the represented\
    \ object identifier.  A component's\n         encoding may span multiple octets,\
    \ encoding 7 bits per octet\n         (most significant bits first) and with bit\
    \ 8 set to \"1\" on all\n         but the final octet in the component's encoding.\
    \  The minimum\n         number of octets shall be used to encode each component\
    \ (i.e.,\n         no octets representing leading zeros shall be included within\
    \ a\n         component's encoding).\n      (Note: In many implementations, elements\
    \ 3-5 may be stored and\n      referenced as a contiguous string constant.)\n\
    \   The token tag is immediately followed by a mechanism-defined token\n   object.\
    \  Note that no independent size specifier intervenes following\n   the object\
    \ identifier value to indicate the size of the mechanism-\n   defined token object.\
    \  While ASN.1 usage within mechanism-defined\n   tokens is permitted, there is\
    \ no requirement that the mechanism-\n   specific innerContextToken, innerMsgToken,\
    \ and sealedUserData data\n   elements must employ ASN.1 BER/DER encoding conventions.\n\
    \   The following ASN.1 syntax is included for descriptive purposes only,\n  \
    \ to illustrate structural relationships among token and tag objects.\n   For\
    \ interoperability purposes, token and tag encoding shall be\n   performed using\
    \ the concrete encoding procedures described earlier in\n   this subsection.\n\
    \      GSS-API DEFINITIONS ::=\n      BEGIN\n      MechType ::= OBJECT IDENTIFIER\n\
    \      -- data structure definitions\n      -- callers must be able to distinguish\
    \ among\n      -- InitialContextToken, SubsequentContextToken,\n      -- PerMsgToken,\
    \ and SealedMessage data elements\n      -- based on the usage in which they occur\n\
    \      InitialContextToken ::=\n      -- option indication (delegation, etc.)\
    \ indicated within\n      -- mechanism-specific token\n      [APPLICATION 0] IMPLICIT\
    \ SEQUENCE {\n              thisMech MechType,\n              innerContextToken\
    \ ANY DEFINED BY thisMech\n                 -- contents mechanism-specific\n \
    \                -- ASN.1 structure not required\n              }\n      SubsequentContextToken\
    \ ::= innerContextToken ANY\n      -- interpretation based on predecessor InitialContextToken\n\
    \      -- ASN.1 structure not required\n      PerMsgToken ::=\n      -- as emitted\
    \ by GSS_GetMIC and processed by GSS_VerifyMIC\n      -- ASN.1 structure not required\n\
    \              innerMsgToken ANY\n      SealedMessage ::=\n      -- as emitted\
    \ by GSS_Wrap and processed by GSS_Unwrap\n      -- includes internal, mechanism-defined\
    \ indicator\n      -- of whether or not encrypted\n      -- ASN.1 structure not\
    \ required\n              sealedUserData ANY\n      END\n"
- title: '3.2: Mechanism-Independent Exported Name Object Format'
  contents:
  - "3.2: Mechanism-Independent Exported Name Object Format\n   This section specifies\
    \ a mechanism-independent level of encapsulating\n   representation for names\
    \ exported via the GSS_Export_name() call,\n   including an object identifier\
    \ representing the exporting mechanism.\n   The format of names encapsulated via\
    \ this representation shall be\n   defined within individual mechanism drafts.\
    \  The Object Identifier\n   value to indicate names of this type is defined in\
    \ Section 4.7 of\n   this document.\n   No name type OID is included in this mechanism-independent\
    \ level of\n   format definition, since (depending on individual mechanism\n \
    \  specifications) the enclosed name may be implicitly typed or may be\n   explicitly\
    \ typed using a means other than OID encoding.\n   The bytes within MECH_OID_LEN\
    \ and NAME_LEN elements are represented\n   most significant byte first (equivalently,\
    \ in IP network byte order).\n        Length    Name          Description\n  \
    \      2               TOK_ID          Token Identifier\n                    \
    \                    For exported name objects, this\n                       \
    \                 must be hex 04 01.\n        2               MECH_OID_LEN   \
    \ Length of the Mechanism OID\n        MECH_OID_LEN    MECH_OID        Mechanism\
    \ OID, in DER\n        4               NAME_LEN        Length of name\n      \
    \  NAME_LEN        NAME            Exported name; format defined in\n        \
    \                                applicable mechanism draft.\n   A concrete example\
    \ of the contents of an exported name object,\n   derived from the Kerberos Version\
    \ 5 mechanism, is as follows:\n   04 01 00 0B 06 09 2A 86 48 86 F7 12 01 02 02\
    \ hx xx xx xl pp qq ... zz\n   04 01        mandatory token identifier\n   00\
    \ 0B        2-byte length of the immediately following DER-encoded\n         \
    \       ASN.1 value of type OID, most significant octet first\n   06 09 2A 86\
    \ 48 86 F7 12 01 02 02    DER-encoded ASN.1 value\n                          \
    \             of type OID; Kerberos V5\n                                     \
    \  mechanism OID indicates\n                                       Kerberos V5\
    \ exported name\n          in Detail:      06                  Identifier octet\
    \ (6=OID)\n                          09                           Length octet(s)\n\
    \                          2A 86 48 86 F7 12 01 02 02   Content octet(s)\n   hx\
    \ xx xx xl   4-byte length of the immediately following exported\n           \
    \      name blob, most significant octet first\n   pp qq ... zz  exported name\
    \ blob of specified length,\n                 bits and bytes specified in the\n\
    \                 (Kerberos 5) GSS-API v2 mechanism spec\n"
- title: '4: Name Type Definitions'
  contents:
  - "4: Name Type Definitions\n   This section includes definitions for name types\
    \ and associated\n   syntaxes which are defined in a mechanism-independent fashion\
    \ at the\n   GSS-API level rather than being defined in individual mechanism\n\
    \   specifications.\n"
- title: '4.1: Host-Based Service Name Form'
  contents:
  - "4.1: Host-Based Service Name Form\n   This name form shall be represented by\
    \ the Object Identifier:\n   {iso(1) member-body(2) United States(840) mit(113554)\
    \ infosys(1)\n   \"gssapi(2) generic(1) service_name(4)}.\n   The recommended\
    \ symbolic name for this type is\n   \"GSS_C_NT_HOSTBASED_SERVICE\".\n   For reasons\
    \ of compatibility with existing implementations, it is\n   recommended that this\
    \ OID be used rather than the alternate value as\n   included in [RFC-2078]:\n\
    \   {1(iso), 3(org), 6(dod), 1(internet), 5(security), 6(nametypes),\n   2(gss-host-based-services)}\n\
    \   While it is not recommended that this alternate value be emitted on\n   output\
    \ by GSS implementations, it is recommended that it be accepted\n   on input as\
    \ equivalent to the recommended value.\n   This name type is used to represent\
    \ services associated with host\n   computers.  Support for this name form is\
    \ recommended to mechanism\n   designers in the interests of portability, but\
    \ is not mandated by\n   this specification. This name form is constructed using\
    \ two elements,\n   \"service\" and \"hostname\", as follows:\n   service@hostname\n\
    \   When a reference to a name of this type is resolved, the \"hostname\"\n  \
    \ may (as an example implementation strategy) be canonicalized by\n   attempting\
    \ a DNS lookup and using the fully-qualified domain name\n   which is returned,\
    \ or by using the \"hostname\" as provided if the DNS\n   lookup fails.  The canonicalization\
    \ operation also maps the host's\n   name into lower-case characters.\n   The\
    \ \"hostname\" element may be omitted. If no \"@\" separator is\n   included,\
    \ the entire name is interpreted as the service specifier,\n   with the \"hostname\"\
    \ defaulted to the canonicalized name of the local\n   host.\n   Documents specifying\
    \ means for GSS integration into a particular\n   protocol should state either:\n\
    \      (a) that a specific IANA-registered name associated with that\n      protocol\
    \ shall be used for the \"service\" element (this admits, if\n      needed, the\
    \ possibility that a single name can be registered and\n      shared among a related\
    \ set of protocols), or\n      (b) that the generic name \"host\" shall be used\
    \ for the \"service\"\n      element, or\n      (c) that, for that protocol, fallback\
    \ in specified order (a, then\n      b) or (b, then a) shall be applied.\n   IANA\
    \ registration of specific names per (a) should be handled in\n   accordance with\
    \ the \"Specification Required\" assignment policy,\n   defined by BCP 26, RFC\
    \ 2434 as follows: \"Values and their meaning\n   must be documented in an RFC\
    \ or other available reference, in\n   sufficient detail so that interoperability\
    \ between independent\n   implementations is possible.\"\n"
- title: '4.2: User Name Form'
  contents:
  - "4.2: User Name Form\n   This name form shall be represented by the Object Identifier\
    \ {iso(1)\n   member-body(2) United States(840) mit(113554) infosys(1) gssapi(2)\n\
    \   generic(1) user_name(1)}. The recommended mechanism-independent\n   symbolic\
    \ name for this type is \"GSS_C_NT_USER_NAME\". (Note: the same\n   name form\
    \ and OID is defined within the Kerberos V5 GSS-API\n   mechanism, but the symbolic\
    \ name recommended there begins with a\n   \"GSS_KRB5_NT_\" prefix.)\n   This\
    \ name type is used to indicate a named user on a local system.\n   Its syntax\
    \ and interpretation may be OS-specific. This name form is\n   constructed as:\n\
    \   username\n"
- title: '4.3: Machine UID Form'
  contents:
  - "4.3: Machine UID Form\n   This name form shall be represented by the Object Identifier\
    \ {iso(1)\n   member-body(2) United States(840) mit(113554) infosys(1) gssapi(2)\n\
    \   generic(1) machine_uid_name(2)}.  The recommended mechanism-\n   independent\
    \ symbolic name for this type is\n   \"GSS_C_NT_MACHINE_UID_NAME\".  (Note: the\
    \ same name form and OID is\n   defined within the Kerberos V5 GSS-API mechanism,\
    \ but the symbolic\n   name recommended there begins with a \"GSS_KRB5_NT_\" prefix.)\n\
    \   This name type is used to indicate a numeric user identifier\n   corresponding\
    \ to a user on a local system.  Its interpretation is\n   OS-specific.  The gss_buffer_desc\
    \ representing a name of this type\n   should contain a locally-significant user\
    \ ID, represented in host\n   byte order.  The GSS_Import_name() operation resolves\
    \ this uid into a\n   username, which is then treated as the User Name Form.\n"
- title: '4.4: String UID Form'
  contents:
  - "4.4: String UID Form\n   This name form shall be represented by the Object Identifier\
    \ {iso(1)\n   member-body(2) United States(840) mit(113554) infosys(1) gssapi(2)\n\
    \   generic(1) string_uid_name(3)}.  The recommended symbolic name for\n   this\
    \ type is \"GSS_C_NT_STRING_UID_NAME\".  (Note: the same name form\n   and OID\
    \ is defined within the Kerberos V5 GSS-API mechanism, but the\n   symbolic name\
    \ recommended there begins with a \"GSS_KRB5_NT_\" prefix.)\n   This name type\
    \ is used to indicate a string of digits representing\n   the numeric user identifier\
    \ of a user on a local system.  Its\n   interpretation is OS-specific. This name\
    \ type is similar to the\n   Machine UID Form, except that the buffer contains\
    \ a string\n   representing the user ID.\n"
- title: '4.5: Anonymous Nametype'
  contents:
  - "4.5: Anonymous Nametype\n   The following Object Identifier value is provided\
    \ as a means to\n   identify anonymous names, and can be compared against in order\
    \ to\n   determine, in a mechanism-independent fashion, whether a name refers\n\
    \   to an anonymous principal:\n   {1(iso), 3(org), 6(dod), 1(internet), 5(security),\
    \ 6(nametypes),\n   3(gss-anonymous-name)}\n   The recommended symbolic name corresponding\
    \ to this definition is\n   GSS_C_NT_ANONYMOUS.\n"
- title: '4.6: GSS_C_NO_OID'
  contents:
  - "4.6: GSS_C_NO_OID\n   The recommended symbolic name GSS_C_NO_OID corresponds\
    \ to a null\n   input value instead of an actual object identifier.  Where specified,\n\
    \   it indicates interpretation of an associated name based on a\n   mechanism-specific\
    \ default printable syntax.\n"
- title: '4.7: Exported Name Object'
  contents:
  - "4.7: Exported Name Object\n   Name objects of the Mechanism-Independent Exported\
    \ Name Object type,\n   as defined in Section 3.2 of this document, will be identified\
    \ with\n   the following Object Identifier:\n   {1(iso), 3(org), 6(dod), 1(internet),\
    \ 5(security), 6(nametypes),\n   4(gss-api-exported-name)}\n   The recommended\
    \ symbolic name corresponding to this definition is\n   GSS_C_NT_EXPORT_NAME.\n"
- title: '4.8: GSS_C_NO_NAME'
  contents:
  - "4.8: GSS_C_NO_NAME\n   The recommended symbolic name GSS_C_NO_NAME indicates\
    \ that no name is\n   being passed within a particular value of a parameter used\
    \ for the\n   purpose of transferring names. Note: GSS_C_NO_NAME is not an actual\n\
    \   name type, and is not represented by an OID; its acceptability in\n   lieu\
    \ of an actual name is confined to specific calls\n   (GSS_Acquire_cred(), GSS_Add_cred(),\
    \ and GSS_Init_sec_context()) with\n   usages as identified within this specification.\n"
- title: '5:  Mechanism-Specific Example Scenarios'
  contents:
  - "5:  Mechanism-Specific Example Scenarios\n   This section provides illustrative\
    \ overviews of the use of various\n   candidate mechanism types to support the\
    \ GSS-API. These discussions\n   are intended primarily for readers familiar with\
    \ specific security\n   technologies, demonstrating how GSS-API functions can\
    \ be used and\n   implemented by candidate underlying mechanisms. They should\
    \ not be\n   regarded as constrictive to implementations or as defining the only\n\
    \   means through which GSS-API functions can be realized with a\n   particular\
    \ underlying technology, and do not demonstrate all GSS-API\n   features with\
    \ each technology.\n"
- title: '5.1: Kerberos V5, single-TGT'
  contents:
  - "5.1: Kerberos V5, single-TGT\n   OS-specific login functions yield a TGT to the\
    \ local realm Kerberos\n   server; TGT is placed in a credentials structure for\
    \ the client.\n   Client calls GSS_Acquire_cred()  to acquire a cred_handle in\
    \ order to\n   reference the credentials for use in establishing security contexts.\n\
    \   Client calls GSS_Init_sec_context().  If the requested service is\n   located\
    \ in a different realm, GSS_Init_sec_context()  gets the\n   necessary TGT/key\
    \ pairs needed to traverse the path from local to\n   target realm; these data\
    \ are placed in the owner's TGT cache. After\n   any needed remote realm resolution,\
    \ GSS_Init_sec_context() yields a\n   service ticket to the requested service\
    \ with a corresponding session\n   key; these data are stored in conjunction with\
    \ the context. GSS-API\n   code sends KRB_TGS_REQ request(s) and receives KRB_TGS_REP\n\
    \   response(s) (in the successful case) or KRB_ERROR.\n   Assuming success, GSS_Init_sec_context()\
    \  builds a Kerberos-formatted\n   KRB_AP_REQ message, and returns it in output_token.\
    \  The client sends\n   the output_token to the service.\n   The service passes\
    \ the received token as the input_token argument to\n   GSS_Accept_sec_context(),\
    \  which verifies the authenticator, provides\n   the service with the client's\
    \ authenticated name, and returns an\n   output_context_handle.\n   Both parties\
    \ now hold the session key associated with the service\n   ticket, and can use\
    \ this key in subsequent GSS_GetMIC(),\n   GSS_VerifyMIC(),  GSS_Wrap(), and GSS_Unwrap()\
    \ operations.\n"
- title: '5.2: Kerberos V5, double-TGT'
  contents:
  - "5.2: Kerberos V5, double-TGT\n   TGT acquisition as above.\n   Note: To avoid\
    \ unnecessary frequent invocations of error paths when\n   implementing the GSS-API\
    \ atop Kerberos V5, it seems appropriate to\n   represent \"single-TGT K-V5\"\
    \ and \"double-TGT K-V5\" with separate\n   mech_types, and this discussion makes\
    \ that assumption.\n   Based on the (specified or defaulted) mech_type,\n   GSS_Init_sec_context()\
    \  determines that the double-TGT protocol\n   should be employed for the specified\
    \ target. GSS_Init_sec_context()\n   returns GSS_S_CONTINUE_NEEDED major_status,\
    \ and its returned\n   output_token contains a request to the service for the\
    \ service's TGT.\n   (If a service TGT with suitably long remaining lifetime already\n\
    \   exists in a cache, it may be usable, obviating the need for this\n   step.)\
    \ The client passes the output_token to the service.  Note: this\n   scenario\
    \ illustrates a different use for the GSS_S_CONTINUE_NEEDED\n   status return\
    \ facility than for support of mutual authentication;\n   note that both uses\
    \ can coexist as successive operations within a\n   single context establishment\
    \ operation.\n   The service passes the received token as the input_token argument\
    \ to\n   GSS_Accept_sec_context(),  which recognizes it as a request for TGT.\n\
    \   (Note that current Kerberos V5 defines no intra-protocol mechanism to\n  \
    \ represent such a request.) GSS_Accept_sec_context() returns\n   GSS_S_CONTINUE_NEEDED\
    \ major_status and provides the service's TGT in\n   its output_token. The service\
    \ sends the output_token to the client.\n   The client passes the received token\
    \ as the input_token argument to a\n   continuation of GSS_Init_sec_context().\
    \ GSS_Init_sec_context() caches\n   the received service TGT and uses it as part\
    \ of a service ticket\n   request to the Kerberos authentication server, storing\
    \ the returned\n   service ticket and session key in conjunction with the context.\n\
    \   GSS_Init_sec_context() builds a Kerberos-formatted authenticator, and\n  \
    \ returns it in output_token along with GSS_S_COMPLETE return\n   major_status.\
    \ The client sends the output_token to the service.\n   Service passes the received\
    \ token as the input_token argument to a\n   continuation call to GSS_Accept_sec_context().\n\
    \   GSS_Accept_sec_context()  verifies the authenticator, provides the\n   service\
    \ with the client's authenticated name, and returns\n   major_status GSS_S_COMPLETE.\n\
    \   GSS_GetMIC(),  GSS_VerifyMIC(), GSS_Wrap(), and GSS_Unwrap()  as\n   above.\n"
- title: '5.3:  X.509 Authentication Framework'
  contents:
  - "5.3:  X.509 Authentication Framework\n   This example illustrates use of the\
    \ GSS-API in conjunction with\n   public-key mechanisms, consistent with the X.509\
    \ Directory\n   Authentication Framework.\n   The GSS_Acquire_cred() call establishes\
    \ a credentials structure,\n   making the client's private key accessible for\
    \ use on behalf of the\n   client.\n   The client calls GSS_Init_sec_context(),\
    \ which interrogates the\n   Directory to acquire (and validate) a chain of public-key\n\
    \   certificates, thereby collecting the public key of the service.  The\n   certificate\
    \ validation operation determines that suitable integrity\n   checks were applied\
    \ by trusted authorities and that those\n   certificates have not expired. GSS_Init_sec_context()\
    \ generates a\n   secret key for use in per-message protection operations on the\n\
    \   context, and enciphers that secret key under the service's public\n   key.\n\
    \   The enciphered secret key, along with an authenticator quantity\n   signed\
    \ with the client's private key, is included in the output_token\n   from GSS_Init_sec_context().\
    \  The output_token also carries a\n   certification path, consisting of a certificate\
    \ chain leading from\n   the service to the client; a variant approach would defer\
    \ this path\n   resolution to be performed by the service instead of being asserted\n\
    \   by the client. The client application sends the output_token to the\n   service.\n\
    \   The service passes the received token as the input_token argument to\n   GSS_Accept_sec_context().\
    \ GSS_Accept_sec_context() validates the\n   certification path, and as a result\
    \ determines a certified binding\n   between the client's distinguished name and\
    \ the client's public key.\n   Given that public key, GSS_Accept_sec_context()\
    \ can process the\n   input_token's authenticator quantity and verify that the\
    \ client's\n   private key was used to sign the input_token. At this point, the\n\
    \   client is authenticated to the service. The service uses its private\n   key\
    \ to decipher the enciphered secret key provided to it for per-\n   message protection\
    \ operations on the context.\n   The client calls GSS_GetMIC() or GSS_Wrap() on\
    \ a data message, which\n   causes per-message authentication, integrity, and\
    \ (optional)\n   confidentiality facilities to be applied to that message. The\
    \ service\n   uses the context's shared secret key to perform corresponding\n\
    \   GSS_VerifyMIC()  and GSS_Unwrap() calls.\n"
- title: '6:  Security Considerations'
  contents:
  - "6:  Security Considerations\n   This document specifies a service interface for\
    \ security facilities\n   and services; as such, security considerations are considered\n\
    \   throughout the specification.  Nonetheless, it is appropriate to\n   summarize\
    \ certain specific points relevant to GSS-API implementors\n   and calling applications.\
    \  Usage of the GSS-API interface does not in\n   itself provide security services\
    \ or assurance; instead, these\n   attributes are dependent on the underlying\
    \ mechanism(s) which support\n   a GSS-API implementation.  Callers must be attentive\
    \ to the requests\n   made to GSS-API calls and to the status indicators returned\
    \ by GSS-\n   API, as these specify the security service characteristics which\n\
    \   GSS-API will provide.  When the interprocess context transfer\n   facility\
    \ is used, appropriate local controls should be applied to\n   constrain access\
    \ to interprocess tokens and to the sensitive data\n   which they contain.\n"
- title: '7:  Related Activities'
  contents:
  - "7:  Related Activities\n   In order to implement the GSS-API atop existing, emerging,\
    \ and future\n   security mechanisms:\n      object identifiers must be assigned\
    \ to candidate GSS-API\n      mechanisms and the name types which they support\n\
    \      concrete data element formats and processing procedures must be\n     \
    \ defined for candidate mechanisms\n   Calling applications must implement formatting\
    \ conventions which will\n   enable them to distinguish GSS-API tokens from other\
    \ data carried in\n   their application protocols.\n   Concrete language bindings\
    \ are required for the programming\n   environments in which the GSS-API is to\
    \ be employed, as [RFC-1509]\n   defines for the C programming language and GSS-V1.\
    \  C Language\n   bindings for GSS-V2 are defined in [RFC-2744].\n"
- title: '8:  Referenced Documents'
  contents:
  - "8:  Referenced Documents\n   [ISO-7498-2]  International Standard ISO 7498-2-1988(E),\
    \ Security\n                 Architecture.\n   [ISOIEC-8824] ISO/IEC 8824, \"\
    Specification of Abstract Syntax\n                 Notation One (ASN.1)\".\n \
    \  [ISOIEC-8825] ISO/IEC 8825, \"Specification of Basic Encoding Rules\n     \
    \            for Abstract Syntax Notation One (ASN.1)\".)\n   [RFC-1507]:   Kaufman,\
    \ C., \"DASS: Distributed Authentication Security\n                 Service\"\
    , RFC 1507, September 1993.\n   [RFC-1508]:   Linn, J., \"Generic Security Service\
    \ Application Program\n                 Interface\", RFC 1508, September 1993.\n\
    \   [RFC-1509]:   Wray, J., \"Generic Security Service API: C-bindings\",\n  \
    \               RFC 1509, September 1993.\n   [RFC-1964]:   Linn, J., \"The Kerberos\
    \ Version 5 GSS-API Mechanism\",\n                 RFC 1964, June 1996.\n   [RFC-2025]:\
    \   Adams, C., \"The Simple Public-Key GSS-API Mechanism\n                 (SPKM)\"\
    , RFC 2025, October 1996.\n   [RFC-2078]:   Linn, J., \"Generic Security Service\
    \ Application Program\n                 Interface, Version 2\", RFC 2078, January\
    \ 1997.\n   [RFC-2203]:   Eisler, M., Chiu, A. and L. Ling, \"RPCSEC_GSS Protocol\n\
    \                 Specification\", RFC 2203, September 1997.\n   [RFC-2744]: \
    \  Wray, J., \"Generic Security Service API Version 2 :\n                 C-bindings\"\
    , RFC 2744, January 2000.\n"
- title: APPENDIX A
  contents:
  - 'APPENDIX A

    '
- title: MECHANISM DESIGN CONSTRAINTS
  contents:
  - "MECHANISM DESIGN CONSTRAINTS\n   The following constraints on GSS-API mechanism\
    \ designs are adopted in\n   response to observed caller protocol requirements,\
    \ and adherence\n   thereto is anticipated in subsequent descriptions of GSS-API\n\
    \   mechanisms to be documented in standards-track Internet\n   specifications.\n\
    \   It is strongly recommended that mechanisms offering per-message\n   protection\
    \ services also offer at least one of the replay detection\n   and sequencing\
    \ services, as mechanisms offering neither of the latter\n   will fail to satisfy\
    \ recognized requirements of certain candidate\n   caller protocols.\n"
- title: APPENDIX B
  contents:
  - 'APPENDIX B

    '
- title: COMPATIBILITY WITH GSS-V1
  contents:
  - "COMPATIBILITY WITH GSS-V1\n   It is the intent of this document to define an\
    \ interface and\n   procedures which preserve compatibility between GSS-V1 [RFC-1508]\n\
    \   callers and GSS-V2 providers.  All calls defined in GSS-V1 are\n   preserved,\
    \ and it has been a goal that GSS-V1 callers should be able\n   to operate atop\
    \ GSS-V2 provider implementations.  Certain detailed\n   changes, summarized in\
    \ this section, have been made in order to\n   resolve omissions identified in\
    \ GSS-V1.\n   The following GSS-V1 constructs, while supported within GSS-V2,\
    \ are\n   deprecated:\n      Names for per-message processing routines: GSS_Seal()\
    \ deprecated\n      in favor of GSS_Wrap(); GSS_Sign() deprecated in favor of\n\
    \      GSS_GetMIC(); GSS_Unseal() deprecated in favor of GSS_Unwrap();\n     \
    \ GSS_Verify() deprecated in favor of GSS_VerifyMIC().\n      GSS_Delete_sec_context()\
    \ facility for context_token usage,\n      allowing mechanisms to signal context\
    \ deletion, is retained for\n      compatibility with GSS-V1.  For current usage,\
    \ it is recommended\n      that both peers to a context invoke GSS_Delete_sec_context()\n\
    \      independently, passing a null output_context_token buffer to\n      indicate\
    \ that no context_token is required.  Implementations of\n      GSS_Delete_sec_context()\
    \ should delete relevant locally-stored\n      context information.\n   This GSS-V2\
    \ specification adds the following calls which are not\n   present in GSS-V1:\n\
    \      Credential management calls: GSS_Add_cred(),\n      GSS_Inquire_cred_by_mech().\n\
    \      Context-level calls: GSS_Inquire_context(), GSS_Wrap_size_limit(),\n  \
    \    GSS_Export_sec_context(), GSS_Import_sec_context().\n      Per-message calls:\
    \ No new calls.  Existing calls have been\n      renamed.\n      Support calls:\
    \ GSS_Create_empty_OID_set(),\n      GSS_Add_OID_set_member(), GSS_Test_OID_set_member(),\n\
    \      GSS_Inquire_names_for_mech(), GSS_Inquire_mechs_for_name(),\n      GSS_Canonicalize_name(),\
    \ GSS_Export_name(), GSS_Duplicate_name().\n   This GSS-V2 specification introduces\
    \ three new facilities applicable\n   to security contexts, indicated using the\
    \ following context state\n   values which are not present in GSS-V1:\n      anon_state,\
    \ set TRUE to indicate that a context's initiator is\n      anonymous from the\
    \ viewpoint of the target; Section 1.2.5 of this\n      specification provides\
    \ a summary description of the GSS-V2\n      anonymity support facility, support\
    \ and use of which is optional.\n      prot_ready_state, set TRUE to indicate\
    \ that a context may be used\n      for per-message protection before final completion\
    \ of context\n      establishment; Section 1.2.7 of this specification provides\
    \ a\n      summary description of the GSS-V2 facility enabling mechanisms to\n\
    \      selectively permit per-message protection during context\n      establishment,\
    \ support and use of which is optional.\n      trans_state, set TRUE to indicate\
    \ that a context is transferable\n      to another process using the GSS-V2 GSS_Export_sec_context()\n\
    \      facility.\n   These state values are represented (at the C bindings level)\
    \ in\n   positions within a bit vector which are unused in GSS-V1, and may be\n\
    \   safely ignored by GSS-V1 callers.\n   New conf_req_flag and integ_req_flag\
    \ inputs are defined for\n   GSS_Init_sec_context(), primarily to provide information\
    \ to\n   negotiating mechanisms.  This introduces a compatibility issue with\n\
    \   GSS-V1 callers, discussed in section 2.2.1 of this specification.\n   Relative\
    \ to GSS-V1, GSS-V2 provides additional guidance to GSS-API\n   implementors in\
    \ the following areas: implementation robustness,\n   credential management, behavior\
    \ in multi-mechanism configurations,\n   naming support, and inclusion of optional\
    \ sequencing services.  The\n   token tagging facility as defined in GSS-V2, Section\
    \ 3.1, is now\n   described directly in terms of octets to facilitate interoperable\n\
    \   implementation without general ASN.1 processing code; the\n   corresponding\
    \ ASN.1 syntax, included for descriptive purposes, is\n   unchanged from that\
    \ in GSS-V1. For use in conjunction with added\n   naming support facilities,\
    \ a new Exported Name Object construct is\n   added.  Additional name types are\
    \ introduced in Section 4.\n   This GSS-V2 specification adds the following major_status\
    \ values\n   which are not defined in GSS-V1:\n        GSS_S_BAD_QOP         \
    \        unsupported QOP value\n        GSS_S_UNAUTHORIZED            operation\
    \ unauthorized\n        GSS_S_UNAVAILABLE             operation unavailable\n\
    \        GSS_S_DUPLICATE_ELEMENT       duplicate credential element\n        \
    \                                requested\n        GSS_S_NAME_NOT_MN        \
    \           name contains multi-mechanism\n                                  \
    \      elements\n        GSS_S_GAP_TOKEN               skipped predecessor token(s)\n\
    \                                        detected\n   Of these added status codes,\
    \ only two values are defined to be\n   returnable by calls existing in GSS-V1:\
    \ GSS_S_BAD_QOP (returnable by\n   GSS_GetMIC() and GSS_Wrap()), and GSS_S_GAP_TOKEN\
    \ (returnable by\n   GSS_VerifyMIC() and GSS_Unwrap()).\n   Additionally, GSS-V2\
    \ descriptions of certain calls present in GSS-V1\n   have been updated to allow\
    \ return of additional major_status values\n   from the set as defined in GSS-V1:\
    \ GSS_Inquire_cred() has\n   GSS_S_DEFECTIVE_CREDENTIAL and GSS_S_CREDENTIALS_EXPIRED\
    \ defined as\n   returnable, GSS_Init_sec_context() has GSS_S_OLD_TOKEN,\n   GSS_S_DUPLICATE_TOKEN,\
    \ and GSS_S_BAD_MECH defined as returnable, and\n   GSS_Accept_sec_context() has\
    \ GSS_S_BAD_MECH defined as returnable.\n"
- title: APPENDIX C
  contents:
  - 'APPENDIX C

    '
- title: CHANGES RELATIVE TO RFC-2078
  contents:
  - "CHANGES RELATIVE TO RFC-2078\n   This document incorporates a number of changes\
    \ relative to RFC-2078,\n   made primarily in response to implementation experience,\
    \ for purposes\n   of alignment with the GSS-V2 C language bindings document,\
    \ and to add\n   informative clarification.  This section summarizes technical\
    \ changes\n   incorporated.\n   General:\n      Clarified usage of object release\
    \ routines, and incorporated\n      statement that some may be omitted within\
    \ certain operating\n      environments.\n      Removed GSS_Release_OID, GSS_OID_to_str(),\
    \ and GSS_Str_to_OID()\n      routines.\n      Clarified circumstances under which\
    \ zero-length tokens may validly\n      exist as inputs and outputs to/from GSS-API\
    \ calls.\n      Added GSS_S_BAD_MIC status code as alias for GSS_S_BAD_SIG.\n\
    \      For GSS_Display_status(), deferred to language bindings the choice\n  \
    \    of whether to return multiple status values in parallel or via\n      iteration,\
    \ and added commentary deprecating return of\n      GSS_S_CONTINUE_NEEDED.\n \
    \     Adapted and incorporated clarifying material on optional service\n     \
    \ support, delegation, and interprocess context transfer from C\n      bindings\
    \ document.\n      Added and updated references to related documents, and to current\n\
    \      status of cited Kerberos mechanism OID.\n      Added general statement\
    \ about GSS-API calls having no side effects\n      visible at the GSS-API level.\n\
    \   Context-related (including per-message protection issues):\n      Clarified\
    \ GSS_Delete_sec_context() usage for partially-established\n      contexts.\n\
    \      Added clarification on GSS_Export_sec_context() and\n      GSS_Import_sec_context()\
    \ behavior and context usage following an\n      export-import sequence.\n   \
    \   Added informatory conf_req_flag, integ_req_flag inputs to\n      GSS_Init_sec_context().\
    \  (Note: this facility introduces a\n      backward incompatibility with GSS-V1\
    \ callers, discussed in Section\n      2.2.1; this implication was recognized\
    \ and accepted in working\n      group discussion.)\n      Stated that GSS_S_FAILURE\
    \ is to be returned if\n      GSS_Init_sec_context() or GSS_Accept_sec_context()\
    \ is passed the\n      handle of a context which is already fully established.\n\
    \      Re GSS_Inquire_sec_context(), stated that src_name and targ_name\n    \
    \  are not returned until GSS_S_COMPLETE status is reached; removed\n      use\
    \ of GSS_S_CONTEXT_EXPIRED status code (replacing with EXPIRED\n      lifetime\
    \ return value); stated requirement to retain inquirable\n      data until context\
    \ released by caller; added result value\n      indicating whether or not context\
    \ is fully open.\n      Added discussion of interoperability conditions for mechanisms\n\
    \      permitting optional support of QOPs. Removed reference to\n      structured\
    \ QOP elements in GSS_Verify_MIC().\n      Added discussion of use of GSS_S_DUPLICATE_TOKEN\
    \ status to\n      indicate reflected per-message tokens.\n      Clarified use\
    \ of informational sequencing codes from per-message\n      protection calls in\
    \ conjunction with GSS_S_COMPLETE and\n      GSS_S_FAILURE major_status returns,\
    \ adjusting status code\n      descriptions accordingly.\n      Added specific\
    \ statements about impact of GSS_GetMIC() and\n      GSS_Wrap() failures on context\
    \ state information, and generalized\n      existing statements about impact of\
    \ processing failures on\n      received per-message tokens.\n      For GSS_Init_sec_context()\
    \ and GSS_Accept_sec_context(), permitted\n      returned mech_type to be valid\
    \ before GSS_S_COMPLETE, recognizing\n      that the value may change on successive\
    \ continuation calls in the\n      negotiated mechanism case.\n      Deleted GSS_S_CONTEXT_EXPIRED\
    \ status from\n      GSS_Import_sec_context().\n      Added conf_req_flag input\
    \ to GSS_Wrap_size_limit().\n      Stated requirement for mechanisms' support\
    \ of per-message\n      protection services to be usable concurrently in both\
    \ directions\n      on a context.\n   Credential-related:\n      For GSS_Acquire_cred()\
    \ and GSS_Add_cred(), aligned with C bindings\n      statement of likely non-support\
    \ for INITIATE or BOTH credentials\n      if input name is neither empty nor a\
    \ name resulting from applying\n      GSS_Inquire_cred() against the default credential.\
    \  Further,\n      stated that an explicit name returned by GSS_Inquire_context()\n\
    \      should also be accepted.  Added commentary about potentially\n      time-variant\
    \ results of default resolution and attendant\n      implications.  Aligned with\
    \ C bindings re behavior when\n      GSS_C_NO_NAME provided for desired_name.\
    \ In GSS_Acquire_cred(),\n      stated that NULL, rather than empty OID set, should\
    \ be used for\n      desired_mechs in order to request default mechanism set.\n\
    \      Added GSS_S_CREDENTIALS_EXPIRED as returnable major_status for\n      GSS_Acquire_cred(),\
    \ GSS_Add_cred(), also specifying GSS_S_NO_CRED\n      as appropriate return for\
    \ temporary, user-fixable credential\n      unavailability.  GSS_Acquire_cred()\
    \ and GSS_Add_cred() are also to\n      return GSS_S_NO_CRED if an authorization\
    \ failure is encountered\n      upon credential acquisition.\n      Removed GSS_S_CREDENTIALS_EXPIRED\
    \ status return from per-message\n      protection, GSS_Context_time(), and GSS_Inquire_context()\
    \ calls.\n      For GSS_Add_cred(), aligned with C bindings' description of\n\
    \      behavior when addition of elements to the default credential is\n     \
    \ requested.\n      Upgraded recommended default credential resolution algorithm\
    \ to\n      status of requirement for initiator credentials.\n      For GSS_Release_cred(),\
    \ GSS_Inquire_cred(), and\n      GSS_Inquire_cred_by_mech(), clarified behavior\
    \ for input\n      GSS_C_NO_CREDENTIAL.\n   Name-related:\n      Aligned GSS_Inquire_mechs_for_name()\
    \ description with C bindings.\n      Removed GSS_S_BAD_NAMETYPE status return\
    \ from\n      GSS_Duplicate_name(), GSS_Display_name(); constrained its\n    \
    \  applicability for GSS_Compare_name().\n      Aligned with C bindings statement\
    \ re GSS_Import_name() behavior\n      with GSS_C_NO_OID input name type, and\
    \ stated that GSS-V2\n      mechanism specifications are to define processing\
    \ procedures\n      applicable to their mechanisms.  Also clarified GSS_C_NO_OID\
    \ usage\n      with GSS_Display_name().\n      Downgraded reference to name canonicalization\
    \ via DNS lookup to an\n      example.\n      For GSS_Canonicalize_name(), stated\
    \ that neither negotiated\n      mechanisms nor the default mechanism are supported\
    \ input\n      mech_types for this operation, and specified GSS_S_BAD_MECH status\n\
    \      to be returned in this case.  Clarified that the\n      GSS_Canonicalize_name()\
    \ operation is non-destructive to its input\n      name.\n      Clarified semantics\
    \ of GSS_C_NT_USER_NAME name type.\n      Added descriptions of additional name\
    \ types.  Also added\n      discussion of GSS_C_NO_NAME and its constrained usage\
    \ with\n      specific GSS calls.\n      Adapted and incorporated C bindings discussion\
    \ about name\n      comparisons with exported name objects.\n      Added recommendation\
    \ to mechanism designers for support of host-\n      based service name type,\
    \ deferring any requirement statement to\n      individual mechanism specifications.\
    \  Added discussion of host-\n      based service's service name element and proposed\
    \ approach for\n      IANA registration policy therefor.\n      Clarified byte\
    \ ordering within exported name object.  Stated that\n      GSS_S_BAD_MECH is\
    \ to be returned if, in the course of attempted\n      import of an exported name\
    \ object, the name object's enclosed\n      mechanism type is unrecognized or\
    \ unsupported.\n      Stated that mechanisms may optionally accept GSS_C_NO_NAME\
    \ as an\n      input target name to GSS_Init_sec_context(), with comment that\n\
    \      such support is unlikely within mechanisms predating GSS-V2,\n      Update\
    \ 1.\n"
- title: AUTHOR'S ADDRESS
  contents:
  - "AUTHOR'S ADDRESS\n   John Linn\n   RSA Laboratories\n   20 Crosby Drive\n   Bedford,\
    \ MA  01730 USA\n   Phone: +1 781.687.7817\n   EMail: jlinn@rsasecurity.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2000).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
