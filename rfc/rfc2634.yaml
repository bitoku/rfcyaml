- contents:
  - '                 Enhanced Security Services for S/MIME

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "1. Introduction\n   This document describes four optional security service extensions
    for\n   S/MIME. The services are:\n    - signed receipts\n    - security labels\n
    \   - secure mailing lists\n    - signing certificates\n   The first three of
    these services provide functionality that is\n   similar to the Message Security
    Protocol [MSP4], but are useful in\n   many other environments, particularly business
    and finance. Signing\n   certificates are useful in any environment where certificates
    might\n   be transmitted with signed messages.\n   The services described here
    are extensions to S/MIME version 3 ([MSG]\n   and [CERT]), and some of them can
    also be added to S/MIME version 2\n   [SMIME2]. The extensions described here
    will not cause an S/MIME\n   version 3 recipient to be unable to read messages
    from an S/MIME\n   version 2 sender. However, some of the extensions will cause
    messages\n   created by an S/MIME version 3 sender to be unreadable by an S/MIME\n
    \  version 2 recipient.\n   This document describes both the procedures and the
    attributes needed\n   for the four services. Note that some of the attributes
    described in\n   this document are quite useful in other contexts and should be\n
    \  considered when extending S/MIME or other CMS applications.\n   The format
    of the messages are described in ASN.1:1988 [ASN1-1988].\n   The key words \"MUST\",
    \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD
    NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this\n   document are to
    be interpreted as described in [MUSTSHOULD].\n"
  - contents:
    - "1.1 Triple Wrapping\n   Some of the features of each service use the concept
      of a \"triple\n   wrapped\" message. A triple wrapped message is one that has
      been\n   signed, then encrypted, then signed again. The signers of the inner\n
      \  and outer signatures may be different entities or the same entity.\n   Note
      that the S/MIME specification does not limit the number of\n   nested encapsulations,
      so there may be more than three wrappings.\n"
    - contents:
      - "1.1.1 Purpose of Triple Wrapping\n   Not all messages need to be triple wrapped.
        Triple wrapping is used\n   when a message must be signed, then encrypted,
        and then have signed\n   attributes bound to the encrypted body. Outer attributes
        may be added\n   or removed by the message originator or intermediate agents,
        and may\n   be signed by intermediate agents or the final recipient.\n   The
        inside signature is used for content integrity, non-repudiation\n   with proof
        of origin, and binding attributes (such as a security\n   label) to the original
        content. These attributes go from the\n   originator to the recipient, regardless
        of the number of intermediate\n   entities such as mail list agents that process
        the message. The\n   signed attributes can be used for access control to the
        inner body.\n   Requests for signed receipts by the originator are carried
        in the\n   inside signature as well.\n   The encrypted body provides confidentiality,
        including\n   confidentiality of the attributes that are carried in the inside\n
        \  signature.\n   The outside signature provides authentication and integrity
        for\n   information that is processed hop-by-hop, where each hop is an\n   intermediate
        entity such as a mail list agent. The outer signature\n   binds attributes
        (such as a security label) to the encrypted body.\n   These attributes can
        be used for access control and routing\n   decisions.\n"
      title: 1.1.1 Purpose of Triple Wrapping
    - contents:
      - "1.1.2 Steps for Triple Wrapping\n   The steps to create a triple wrapped
        message are:\n   1. Start with a message body, called the \"original content\".\n
        \  2. Encapsulate the original content with the appropriate MIME\n      Content-type
        headers, such as \"Content-type: text/plain\". An\n      exception to this
        MIME encapsulation rule is that a signed receipt\n      is not put in MIME
        headers.\n   3. Sign the result of step 2 (the inner MIME headers and the
        original\n      content). The SignedData encapContentInfo eContentType object\n
        \     identifier MUST be id-data. If the structure you create in step 4\n
        \     is multipart/signed, then the SignedData encapContentInfo eContent\n
        \     MUST be absent. If the structure you create in step 4 is\n      application/pkcs7-mime,
        then the SignedData encapContentInfo\n      eContent MUST contain the result
        of step 2 above. The SignedData\n      structure is encapsulated by a ContentInfo
        SEQUENCE with a\n      contentType of id-signedData.\n   4. Add an appropriate
        MIME construct to the signed message from step\n      3 as defined in [MSG].
        The resulting message is called the \"inside\n      signature\".\n    - If
        you are signing using multipart/signed, the MIME construct\n      added consists
        of a Content-type of multipart/signed with\n      parameters, the boundary,
        the result of step 2 above, the\n      boundary, a Content-type of application/pkcs7-signature,\n
        \     optional MIME headers (such asContent-transfer-encoding and\n      Content-disposition),
        and a body part that is the result of\n      step 3 above.\n    - If you are
        instead signing using application/pkcs7-mime, the MIME\n      construct added
        consists of a Content-type of\n      application/pkcs7-mime with parameters,
        optional MIME headers\n      (such as Content-transfer-encoding and Content-disposition),
        and\n      the result of step 3 above.\n   5. Encrypt the result of step 4
        as a single block, turning it into an\n      application/pkcs7-mime object.
        The EnvelopedData\n      encryptedContentInfo contentType MUST be id-data.\n
        \     The EnvelopedData structure is encapsulated by a ContentInfo\n      SEQUENCE
        with a contentType of id-envelopedData. This is called\n      the \"encrypted
        body\".\n   6. Add the appropriate MIME headers: a Content-type of\n      application/pkcs7-mime
        with parameters, and optional MIME headers\n      such as Content-transfer-encoding
        and Content-disposition.\n   7. Using the same logic as in step 3 above, sign
        the result of step 6\n      (the MIME headers and the encrypted body) as a
        single block\n   8. Using the same logic as in step 4 above, add an appropriate
        MIME\n      construct to the signed message from step 7. The resulting message\n
        \     is called the \"outside signature\", and is also the triple wrapped\n
        \     message.\n"
      title: 1.1.2 Steps for Triple Wrapping
    title: 1.1 Triple Wrapping
  - contents:
    - "1.2 Format of a Triple Wrapped Message\n   A triple wrapped message has many
      layers of encapsulation. The\n   structure differs based on the choice of format
      for the signed\n   portions of the message. Because of the way that MIME encapsulates\n
      \  data, the layers do not appear in order, and the notion of \"layers\"\n   becomes
      vague.\n   There is no need to use the multipart/signed format in an inner\n
      \  signature because it is known that the recipient is able to process\n   S/MIME
      messages (because they decrypted the middle wrapper). A\n   sending agent might
      choose to use the multipart/signed format in the\n   outer layer so that a non-S/MIME
      agent could see that the next inner\n   layer is encrypted; however, this is
      not of great value, since all it\n   shows the recipient is that the rest of
      the message is unreadable.\n   Because many sending agents always use multipart/signed
      structures,\n   all receiving agents MUST be able to interpret either\n   multipart/signed
      or application/pkcs7-mime signature structures.\n   The format of a triple wrapped
      message that uses multipart/signed for\n   both signatures is:\n   [step 8]
      Content-type: multipart/signed;\n   [step 8]    protocol=\"application/pkcs7-signature\";\n
      \  [step 8]    boundary=outerboundary\n   [step 8]\n   [step 8] --outerboundary\n
      \  [step 6] Content-type: application/pkcs7-mime;             )\n   [step 6]
      \   smime-type=enveloped-data                      )\n   [step 6]                                                   )\n
      \  [step 4] Content-type: multipart/signed;                 | )\n   [step 4]
      \   protocol=\"application/pkcs7-signature\";      | )\n   [step 4]    boundary=innerboundary
      \                      | )\n   [step 4]                                                 |
      )\n   [step 4] --innerboundary                                 | )\n   [step
      2] Content-type: text/plain                      % | )\n   [step 2]                                               %
      | )\n   [step 1] Original content                              % | )\n   [step
      4]                                                 | )\n   [step 4] --innerboundary
      \                                | )\n   [step 4] Content-type: application/pkcs7-signature
      \      | )\n   [step 4]                                                 | )\n
      \  [step 3] inner SignedData block (eContent is missing)    | )\n   [step 4]
      \                                                | )\n   [step 4] --innerboundary--
      \                              | )\n   [step 8]\n   [step 8] --outerboundary\n
      \  [step 8] Content-type: application/pkcs7-signature\n   [step 8]\n   [step
      7] outer SignedData block (eContent is missing)\n   [step 8]\n   [step 8] --outerboundary--\n
      \  % = These lines are what the inner signature is computed over.\n   | = These
      lines are what is encrypted in step 5. This encrypted result\n       is opaque
      and is a part of an EnvelopedData block.\n   ) = These lines are what the outer
      signature is computed over.\n   The format of a triple wrapped message that
      uses application/pkcs7-\n   mime for the both signatures is:\n   [step 8] Content-type:
      application/pkcs7-mime;\n   [step 8]    smime-type=signed-data\n   [step 8]\n
      \  [step 7] outer SignedData block (eContent is present)        O\n   [step
      6] Content-type: application/pkcs7-mime;             ) O\n   [step 6]    smime-type=enveloped-data;
      \                    ) O\n   [step 6]                                                   )
      O\n   [step 4] Content-type: application/pkcs7-mime;           | ) O\n   [step
      4]    smime-type=signed-data                       | ) O\n   [step 4]                                                 |
      ) O\n   [step 3] inner SignedData block (eContent is present)  I | ) O\n   [step
      2] Content-type: text/plain                      I | ) O\n   [step 2]                                               I
      | ) O\n   [step 1] Original content                              I | ) O\n   I
      = These lines are the inner SignedData block, which is opaque and\n       contains
      the ASN.1 encoded result of step 2 as well as control\n       information.\n
      \  | = These lines are what is encrypted in step 5. This encrypted result\n
      \      is opaque and is a part of an EnvelopedData block.\n   ) = These lines
      are what the outer signature is computed over.\n   O = These lines are the outer
      SignedData block, which is opaque and\n       contains the ASN.1 encoded result
      of step 6 as well as control\n       information.\n"
    title: 1.2 Format of a Triple Wrapped Message
  - contents:
    - "1.3 Security Services and Triple Wrapping\n   The first three security services
      described in this document are used\n   with triple wrapped messages in different
      ways. This section briefly\n   describes the relationship of each service with
      triple wrapping; the\n   other sections of the document go into greater detail.\n"
    - contents:
      - "1.3.1 Signed Receipts and Triple Wrapping\n   A signed receipt may be requested
        in any SignedData object. However,\n   if a signed receipt is requested for
        a triple wrapped message, the\n   receipt request MUST be in the inside signature,
        not in the outside\n   signature.  A secure mailing list agent may change
        the receipt policy\n   in the outside signature of a triple wrapped message
        when that\n   message is processed by the mailing list.\n   Note: the signed
        receipts and receipt requests described in this memo\n   differ from those
        described in the work done by the IETF Receipt\n   Notification Working Group.
        The output of that Working Group, when\n   finished, is not expected to work
        well with triple wrapped messages\n   as described in this document.\n"
      title: 1.3.1 Signed Receipts and Triple Wrapping
    - contents:
      - "1.3.2 Security Labels and Triple Wrapping\n   A security label may be included
        in the signed attributes of any\n   SignedData object. A security label attribute
        may be included in\n   either the inner signature, outer signature, or both.\n
        \  The inner security label is used for access control decisions related\n
        \  to the plaintext original content. The inner signature provides\n   authentication
        and cryptographically protects the integrity of the\n   original signer's
        security label that is in the inside body. This\n   strategy facilitates the
        forwarding of messages because the original\n   signer's security label is
        included in the SignedData block which can\n   be forwarded to a third party
        that can verify the inner signature\n   which will cover the inner security
        label. The confidentiality\n   security service can be applied to the inner
        security label by\n   encrypting the entire inner SignedData block within
        an EnvelopedData\n   block.\n   A security label may also be included in the
        signed attributes of the\n   outer SignedData block which will include the
        sensitivities of the\n   encrypted message. The outer security label is used
        for access\n   control and routing decisions related to the encrypted message.
        Note\n   that a security label attribute can only be used in a\n   signedAttributes
        block.  An eSSSecurityLabel attribute MUST NOT be\n   used in an EnvelopedData
        or unsigned attributes.\n"
      title: 1.3.2 Security Labels and Triple Wrapping
    - contents:
      - "1.3.3 Secure Mailing Lists and Triple Wrapping\n   Secure mail list message
        processing depends on the structure of\n   S/MIME layers present in the message
        sent to the mail list agent. The\n   mail list agent never changes the data
        that was hashed to form the\n   inner signature, if such a signature is present.
        If an outer\n   signature is present, then the agent will modify the data
        that was\n   hashed to form that outer signature. In all cases, the agent
        adds or\n   updates an mlExpansionHistory attribute to document the agent's\n
        \  processing, and ultimately adds or replaces the outer signature on\n   the
        message to be distributed.\n"
      title: 1.3.3 Secure Mailing Lists and Triple Wrapping
    - contents:
      - "1.3.4 Placement of Attributes\n   Certain attributes should be placed in
        the inner or outer SignedData\n   message; some attributes can be in either.
        Further, some attributes\n   must be signed, while signing is optional for
        others, and some\n   attributes must not be signed. ESS defines several types
        of\n   attributes.  ContentHints and ContentIdentifier MAY appear in any\n
        \  list of attributes. contentReference, equivalentLabel,\n   eSSSecurityLabel
        and mlExpansionHistory MUST be carried in a\n   SignedAttributes or AuthAttributes
        type, and MUST NOT be carried in a\n   UnsignedAttributes, UnauthAttributes
        or UnprotectedAttributes type.\n   msgSigDigest, receiptRequest and signingCertificate
        MUST be carried\n   in a SignedAttributes, and MUST NOT be carried in a AuthAttributes,\n
        \  UnsignedAttributes, UnauthAttributes or UnprotectedAttributes type.\n   The
        following table summarizes the recommendation of this profile. In\n   the
        OID column, [ESS] indicates that the attribute is defined in this\n   document.\n
        \                    |                              |Inner or  |\n   Attribute
        \        |OID                           |outer     |Signed\n   ------------------|-----------------------------
        |----------|--------\n   contentHints      |id-aa-contentHint [ESS]       |either
        \   |MAY\n   contentIdentifier |id-aa-contentIdentifier [ESS] |either    |MAY\n
        \  contentReference  |id-aa-contentReference [ESS]  |either    |MUST\n   contentType
        \      |id-contentType [CMS]          |either    |MUST\n   counterSignature
        \ |id-countersignature [CMS]     |either    |MUST NOT\n   equivalentLabel
        \  |id-aa-equivalentLabels [ESS]  |either    |MUST\n   eSSSecurityLabel  |id-aa-securityLabel
        [ESS]     |either    |MUST\n   messageDigest     |id-messageDigest [CMS]        |either
        \   |MUST\n   msgSigDigest      |id-aa-msgSigDigest [ESS]      |inner only|MUST\n
        \  mlExpansionHistory|id-aa-mlExpandHistory [ESS]   |outer only|MUST\n   receiptRequest
        \   |id-aa-receiptRequest [ESS]    |inner only|MUST\n   signingCertificate|id-aa-signingCertificate
        [ESS]|either    |MUST\n   signingTime       |id-signingTime [CMS]          |either
        \   |MUST\n   smimeCapabilities |sMIMECapabilities [MSG]       |either    |MUST\n
        \  sMIMEEncryption-\n     KeyPreference   |id-aa-encrypKeyPref [MSG]     |either
        \   |MUST\n   CMS defines signedAttrs as a SET OF Attribute and defines\n
        \  unsignedAttrs as a SET OF Attribute. ESS defines the contentHints,\n   contentIdentifier,
        eSSecurityLabel, msgSigDigest, mlExpansionHistory,\n   receiptRequest, contentReference,
        equivalentLabels and\n   signingCertificate attribute types. A signerInfo
        MUST NOT include\n   multiple instances of any of the attribute types defined
        in ESS.\n   Later sections of ESS specify further restrictions that apply
        to the\n   receiptRequest, mlExpansionHistory and eSSecurityLabel attribute\n
        \  types.\n   CMS defines the syntax for the signed and unsigned attributes
        as\n   \"attrValues SET OF AttributeValue\". For all of the attribute types\n
        \  defined in ESS, if the attribute type is present in a signerInfo,\n   then
        it MUST only include a single instance of AttributeValue. In\n   other words,
        there MUST NOT be zero, or multiple, instances of\n   AttributeValue present
        in the attrValues SET OF AttributeValue.\n   If a counterSignature attribute
        is present, then it MUST be included\n   in the unsigned attributes. It MUST
        NOT be included in the signed\n   attributes. The only attributes that are
        allowed in a\n   counterSignature attribute are counterSignature, messageDigest,\n
        \  signingTime, and signingCertificate.\n   Note that the inner and outer
        signatures are usually those of\n   different senders. Because of this, the
        same attribute in the two\n   signatures could lead to very different consequences.\n
        \  ContentIdentifier is an attribute (OCTET STRING) used to carry a\n   unique
        identifier assigned to the message.\n"
      title: 1.3.4 Placement of Attributes
    title: 1.3 Security Services and Triple Wrapping
  - contents:
    - "1.4 Required and Optional Attributes\n   Some security gateways sign messages
      that pass through them. If the\n   message is any type other than a signedData
      type, the gateway has\n   only one way to sign the message: by wrapping it with
      a signedData\n   block and MIME headers. If the message to be signed by the
      gateway is\n   a signedData message already, the gateway can sign the message
      by\n   inserting a signerInfo into the signedData block.\n   The main advantage
      of a gateway adding a signerInfo instead of\n   wrapping the message in a new
      signature is that the message doesn't\n   grow as much as if the gateway wrapped
      the message. The main\n   disadvantage is that the gateway must check for the
      presence of\n   certain attributes in the other signerInfos and either omit
      or copy\n   those attributes.\n   If a gateway or other processor adds a signerInfo
      to an existing\n   signedData block, it MUST copy the mlExpansionHistory and\n
      \  eSSSecurityLabel attributes from other signerInfos. This helps ensure\n   that
      the recipient will process those attributes in a signerInfo that\n   it can
      verify.\n   Note that someone may in the future define an attribute that must
      be\n   present in each signerInfo of a signedData block in order for the\n   signature
      to be processed. If that happens, a gateway that inserts\n   signerInfos and
      doesn't copy that attribute will cause every message\n   with that attribute
      to fail when processed by the recipient. For this\n   reason, it is safer to
      wrap messages with new signatures than to\n   insert signerInfos.\n"
    title: 1.4 Required and Optional Attributes
  - contents:
    - "1.5 Object Identifiers\n   The object identifiers for many of the objects described
      in this memo\n   are found in [CMS], [MSG], and [CERT]. Other object identifiers
      used\n   in S/MIME can be found in the registry kept at\n   <http://www.imc.org/ietf-smime/oids.html>.
      When this memo moves to\n   standards track within the IETF, it is intended
      that the IANA will\n   maintain this registry.\n"
    title: 1.5 Object Identifiers
  title: 1. Introduction
- contents:
  - "2. Signed Receipts\n   Returning a signed receipt provides to the originator
    proof of\n   delivery of a message, and allows the originator to demonstrate to
    a\n   third party that the recipient was able to verify the signature of\n   the
    original message. This receipt is bound to the original message\n   through the
    signature; consequently, this service may be requested\n   only if a message is
    signed. The receipt sender may optionally also\n   encrypt a receipt to provide
    confidentiality between the receipt\n   sender and the receipt recipient.\n"
  - contents:
    - "2.1 Signed Receipt Concepts\n   The originator of a message may request a signed
      receipt from the\n   message's recipients. The request is indicated by adding
      a\n   receiptRequest attribute to the signedAttributes field of the\n   SignerInfo
      object for which the receipt is requested. The receiving\n   user agent software
      SHOULD automatically create a signed receipt when\n   requested to do so, and
      return the receipt in accordance with mailing\n   list expansion options, local
      security policies, and configuration\n   options.\n   Because receipts involve
      the interaction of two parties, the\n   terminology can sometimes be confusing.
      In this section, the \"sender\"\n   is the agent that sent the original message
      that included a request\n   for a receipt. The \"receiver\" is the party that
      received that message\n   and generated the receipt.\n   The steps in a typical
      transaction are:\n   1. Sender creates a signed message including a receipt
      request\n      attribute (Section 2.2).\n   2. Sender transmits the resulting
      message to the recipient or\n      recipients.\n   3. Recipient receives message
      and determines if there is a valid\n      signature and receipt request in the
      message (Section 2.3).\n   4. Recipient creates a signed receipt (Section 2.4).\n
      \  5. Recipient transmits the resulting signed receipt message to the\n      sender
      (Section 2.5).\n   6. Sender receives the message and validates that it contains
      a\n      signed receipt for the original message (Section 2.6). This\n      validation
      relies on the sender having retained either a copy of\n      the original message
      or information extracted from the original\n      message.\n   The ASN.1 syntax
      for the receipt request is given in Section 2.7; the\n   ASN.1 syntax for the
      receipt is given in Section 2.8.\n   Note that a sending agent SHOULD remember
      when it has sent a receipt\n   so that it can avoid re-sending a receipt each
      time it processes the\n   message.\n   A receipt request can indicate that receipts
      be sent to many places,\n   not just to the sender (in fact, the receipt request
      might indicate\n   that the receipts should not even go to the sender). In order
      to\n   verify a receipt, the recipient of the receipt must be the originator\n
      \  or a recipient of the original message. Thus, the sender SHOULD NOT\n   request
      that receipts be sent to anyone who does not have an exact\n   copy of the message.\n"
    title: 2.1 Signed Receipt Concepts
  - contents:
    - "2.2 Receipt Request Creation\n   Multi-layer S/MIME messages may contain multiple
      SignedData layers.\n   However, receipts may be requested only for the innermost
      SignedData\n   layer in a multi-layer S/MIME message, such as a triple wrapped\n
      \  message. Only one receiptRequest attribute can be included in the\n   signedAttributes
      of a SignerInfo.\n   A ReceiptRequest attribute MUST NOT be included in the
      attributes of\n   a SignerInfo in a SignedData object that encapsulates a Receipt\n
      \  content.  In other words, the receiving agent MUST NOT request a\n   signed
      receipt for a signed receipt.\n   A sender requests receipts by placing a receiptRequest
      attribute in\n   the signed attributes of a signerInfo as follows:\n   1. A
      receiptRequest data structure is created.\n   2. A signed content identifier
      for the message is created and assigned\n      to the signedContentIdentifier
      field. The signedContentIdentifier\n      is used to associate the signed receipt
      with the message requesting\n      the signed receipt.\n   3. The entities requested
      to return a signed receipt are noted in the\n      receiptsFrom field.\n   4.
      The message originator MUST populate the receiptsTo field with a\n      GeneralNames
      for each entity to whom the recipient should send the\n      signed receipt.
      If the message originator wants the recipient to\n      send the signed receipt
      to the originator, then the originator MUST\n      include a GeneralNames for
      itself in the receiptsTo field.\n      GeneralNames is a SEQUENCE OF GeneralName.
      receiptsTo is a\n      SEQUENCE OF GeneralNames in which each GeneralNames represents
      an\n      entity.  There may be multiple GeneralName instances in each\n      GeneralNames.
      \ At a minimum, the message originator MUST populate\n      each entity's GeneralNames
      with the address to which the signed\n      receipt should be sent. Optionally,
      the message originator MAY\n      also populate each entity's GeneralNames with
      other GeneralName\n      instances (such as directoryName).\n   5. The completed
      receiptRequest attribute is placed in the\n      signedAttributes field of the
      SignerInfo object.\n"
    - contents:
      - "2.2.1 Multiple Receipt Requests\n   There can be multiple SignerInfos within
        a SignedData object, and\n   each SignerInfo may include signedAttributes.
        Therefore, a single\n   SignedData object may include multiple SignerInfos,
        each SignerInfo\n   having a receiptRequest attribute. For example, an originator
        can\n   send a signed message with two SignerInfos, one containing a DSS\n
        \  signature, the other containing an RSA signature.\n   Each recipient SHOULD
        return only one signed receipt.\n   Not all of the SignerInfos need to include
        receipt requests, but in\n   all of the SignerInfos that do contain receipt
        requests, the receipt\n   requests MUST be identical.\n"
      title: 2.2.1 Multiple Receipt Requests
    - contents:
      - "2.2.2 Information Needed to Validate Signed Receipts\n   The sending agent
        MUST retain one or both of the following items to\n   support the validation
        of signed receipts returned by the recipients.\n    - the original signedData
        object requesting the signed receipt\n    - the message signature digest value
        used to generate the original\n      signedData signerInfo signature value
        and the digest value of the\n      Receipt content containing values included
        in the original\n      signedData object. If signed receipts are requested
        from multiple\n      recipients, then retaining these digest values is a performance\n
        \     enhancement because the sending agent can reuse the saved values\n      when
        verifying each returned signed receipt.\n"
      title: 2.2.2 Information Needed to Validate Signed Receipts
    title: 2.2 Receipt Request Creation
  - contents:
    - "2.3 Receipt Request Processing\n   A receiptRequest is associated only with
      the SignerInfo object to\n   which the receipt request attribute is directly
      attached. Receiving\n   software SHOULD examine the signedAttributes field of
      each of the\n   SignerInfos for which it verifies a signature in the innermost\n
      \  signedData object to determine if a receipt is requested. This may\n   result
      in the receiving agent processing multiple receiptRequest\n   attributes included
      in a single SignedData object, such as requests\n   made from different people
      who signed the object in parallel.\n   Before processing a receiptRequest signedAttribute,
      the receiving\n   agent MUST verify the signature of the SignerInfo which covers
      the\n   receiptRequest attribute. A recipient MUST NOT process a\n   receiptRequest
      attribute that has not been verified. Because all\n   receiptRequest attributes
      in a SignedData object must be identical,\n   the receiving application fully
      processes (as described in the\n   following paragraphs) the first receiptRequest
      attribute that it\n   encounters in a SignerInfo that it verifies, and it then
      ensures that\n   all other receiptRequest attributes in signerInfos that it
      verifies\n   are identical to the first one encountered. If there are verified\n
      \  ReceiptRequest attributes which are not the same, then the processing\n   software
      MUST NOT return any signed receipt. A signed receipt SHOULD\n   be returned
      if any signerInfo containing a receiptRequest attribute\n   can be validated,
      even if other signerInfos containing the same\n   receiptRequest attribute cannot
      be validated because they are signed\n   using an algorithm not supported by
      the receiving agent.\n   If a receiptRequest attribute is absent from the signed
      attributes,\n   then a signed receipt has not been requested from any of the
      message\n   recipients and MUST NOT be created. If a receiptRequest attribute
      is\n   present in the signed attributes, then a signed receipt has been\n   requested
      from some or all of the message recipients. Note that in\n   some cases, a receiving
      agent might receive two almost-identical\n   messages, one with a receipt request
      and the other without one. In\n   this case, the receiving agent SHOULD send
      a signed receipt for the\n   message that requests a signed receipt.\n   If
      a receiptRequest attribute is present in the signed attributes,\n   the following
      process SHOULD be used to determine if a message\n   recipient has been requested
      to return a signed receipt.\n   1. If an mlExpansionHistory attribute is present
      in the outermost\n      signedData block, do one of the following two steps,
      based on the\n      absence or presence of mlReceiptPolicy:\n       1.1. If
      an mlReceiptPolicy value is absent from the last MLData\n            element,
      a Mail List receipt policy has not been specified\n            and the processing
      software SHOULD examine the\n            receiptRequest attribute value to determine
      if a receipt\n            should be created and returned.\n       1.2. If an
      mlReceiptPolicy value is present in the last MLData\n            element, do
      one of the following two steps, based on the\n            value of mlReceiptPolicy:\n
      \          1.2.1. If the mlReceiptPolicy value is none, then the receipt\n                  policy
      of the Mail List supersedes the originator's\n                  request for
      a signed receipt and a signed receipt MUST\n                  NOT be created.\n
      \          1.2.2. If the mlReceiptPolicy value is insteadOf or\n                  inAdditionTo,
      the processing software SHOULD examine\n                  the receiptsFrom value
      from the receiptRequest\n                  attribute to determine if a receipt
      should be created\n                  and returned. If a receipt is created,
      the insteadOf\n                  and inAdditionTo fields identify entities that
      SHOULD\n                  be sent the receipt instead of or in addition to the\n
      \                 originator.\n   2. If the receiptsFrom value of the receiptRequest
      attribute\n      allOrFirstTier, do one of the following two steps based on
      the\n      value of allOrFirstTier.\n       2.1. If the value of allOrFirstTier
      is allReceipts, then a signed\n            receipt SHOULD be created.\n       2.2.
      If the value of allOrFirstTier is firstTierRecipients, do\n            one of
      the following two steps based on the presence of an\n            mlExpansionHistory
      attribute in an outer signedData block:\n           2.2.1. If an mlExpansionHistory
      attribute is present, then\n                  this recipient is not a first
      tier recipient and a\n                  signed receipt MUST NOT be created.\n
      \          2.2.2. If an mlExpansionHistory attribute is not present,\n                  then
      a signed receipt SHOULD be created.\n   3. If the receiptsFrom value of the
      receiptRequest attribute is a\n      receiptList:\n       3.1. If receiptList
      contains one of the GeneralNames of the\n            recipient, then a signed
      receipt SHOULD be created.\n       3.2. If receiptList does not contain one
      of the GeneralNames of\n            the recipient, then a signed receipt MUST
      NOT be created.\n   A flow chart for the above steps to be executed for each
      signerInfo\n   for which the receiving agent verifies the signature would be:\n
      \  0. Receipt Request attribute present?\n          YES -> 1.\n          NO
      \ -> STOP\n   1. Has mlExpansionHistory in outer signedData?\n          YES
      -> 1.1.\n          NO  -> 2.\n   1.1. mlReceiptPolicy absent?\n          YES
      -> 2.\n          NO  -> 1.2.\n   1.2. Pick based on value of mlReceiptPolicy.\n
      \         none -> 1.2.1.\n          insteadOf or inAdditionTo -> 1.2.2.\n   1.2.1.
      STOP.\n   1.2.2. Examine receiptsFrom to determine if a receipt should be\n
      \      created, create it if required, send it to recipients designated\n       by
      mlReceiptPolicy, then -> STOP.\n   2. Is value of receiptsFrom allOrFirstTier?\n
      \         YES -> Pick based on value of allOrFirstTier.\n                allReceipts
      -> 2.1.\n                firstTierRecipients -> 2.2.\n          NO  -> 3.\n
      \  2.1. Create a receipt, then -> STOP.\n   2.2. Has mlExpansionHistory in the
      outer signedData block?\n          YES -> 2.2.1.\n          NO  -> 2.2.2.\n
      \  2.2.1. STOP.\n   2.2.2. Create a receipt, then -> STOP.\n   3. Is receiptsFrom
      value of receiptRequest a receiptList?\n          YES -> 3.1.\n          NO
      \ -> STOP.\n   3.1. Does receiptList contain the recipient?\n          YES ->
      Create a receipt, then -> STOP.\n          NO  -> 3.2.\n   3.2. STOP.\n"
    title: 2.3 Receipt Request Processing
  - contents:
    - "2.4 Signed Receipt Creation\n   A signed receipt is a signedData object encapsulating
      a Receipt\n   content (also called a \"signedData/Receipt\"). Signed receipts
      are\n   created as follows:\n   1. The signature of the original signedData
      signerInfo that includes\n      the receiptRequest signed attribute MUST be
      successfully verified\n      before creating the signedData/Receipt.\n       1.1.
      The content of the original signedData object is digested as\n            described
      in [CMS]. The resulting digest value is then\n            compared with the
      value of the messageDigest attribute\n            included in the signedAttributes
      of the original signedData\n            signerInfo. If these digest values are
      different, then the\n            signature verification process fails and the\n
      \           signedData/Receipt MUST NOT be created.\n       1.2. The ASN.1 DER
      encoded signedAttributes (including\n            messageDigest, receiptRequest
      and, possibly, other signed\n            attributes) in the original signedData
      signerInfo are\n            digested as described in [CMS]. The resulting digest\n
      \           value, called msgSigDigest, is then used to verify the\n            signature
      of the original signedData signerInfo. If the\n            signature verification
      fails, then the signedData/Receipt\n            MUST NOT be created.\n   2.
      A Receipt structure is created.\n       2.1. The value of the Receipt version
      field is set to 1.\n       2.2. The object identifier from the contentType attribute\n
      \           included in the original signedData signerInfo that\n            includes
      the receiptRequest attribute is copied into\n            the Receipt contentType.\n
      \      2.3. The original signedData signerInfo receiptRequest\n            signedContentIdentifier
      is copied into the Receipt\n            signedContentIdentifier.\n       2.4.
      The signature value from the original signedData signerInfo\n            that
      includes the receiptRequest attribute is copied into\n            the Receipt
      originatorSignatureValue.\n   3. The Receipt structure is ASN.1 DER encoded
      to produce a data\n      stream, D1.\n   4. D1 is digested. The resulting digest
      value is included as the\n      messageDigest attribute in the signedAttributes
      of the signerInfo\n      which will eventually contain the signedData/Receipt
      signature\n      value.\n   5. The digest value (msgSigDigest) calculated in
      Step 1 to verify the\n      signature of the original signedData signerInfo
      is included as the\n      msgSigDigest attribute in the signedAttributes of
      the signerInfo\n      which will eventually contain the signedData/Receipt signature\n
      \     value.\n   6. A contentType attribute including the id-ct-receipt object\n
      \     identifier MUST be created and added to the signed attributes of\n      the
      signerInfo which will eventually contain the\n      signedData/Receipt signature
      value.\n   7. A signingTime attribute indicating the time that the\n      signedData/Receipt
      is signed SHOULD be created and added to the\n      signed attributes of the
      signerInfo which will eventually contain\n      the signedData/Receipt signature
      value. Other attributes (except\n      receiptRequest) may be added to the signedAttributes
      of the\n      signerInfo.\n   8. The signedAttributes (messageDigest, msgSigDigest,
      contentType and,\n      possibly, others) of the signerInfo are ASN.1 DER encoded
      and\n      digested as described in [CMS]. The resulting digest value is used\n
      \     to calculate the signature value which is then included in the\n      signedData/Receipt
      signerInfo.\n   9. The ASN.1 DER encoded Receipt content MUST be directly encoded\n
      \     within the signedData encapContentInfo eContent OCTET STRING\n      defined
      in [CMS]. The id-ct-receipt object identifier MUST be\n      included in the
      signedData encapContentInfo eContentType. This\n      results in a single ASN.1
      encoded object composed of a signedData\n      including the Receipt content.
      The Data content type MUST NOT be\n      used.  The Receipt content MUST NOT
      be encapsulated in a MIME\n      header or any other header prior to being encoded
      as part of the\n      signedData object.\n   10. The signedData/Receipt is then
      put in an application/pkcs7-mime\n       MIME wrapper with the smime-type parameter
      set to\n       \"signed-receipt\".  This will allow for identification of signed\n
      \      receipts without having to crack the ASN.1 body. The smime-type\n       parameter
      would still be set as normal in any layer wrapped\n       around this message.\n
      \  11. If the signedData/Receipt is to be encrypted within an\n       envelopedData
      object, then an outer signedData object MUST be\n       created that encapsulates
      the envelopedData object, and a\n       contentHints attribute with contentType
      set to the id-ct-receipt\n       object identifier MUST be included in the outer
      signedData\n       SignerInfo signedAttributes.  When a receiving agent processes
      the\n       outer signedData object, the presence of the id-ct-receipt OID in\n
      \      the contentHints contentType indicates that a signedData/Receipt\n       is
      encrypted within the envelopedData object encapsulated by the\n       outer
      signedData.\n   All sending agents that support the generation of ESS signed
      receipts\n   MUST provide the ability to send encrypted signed receipts (that
      is,\n   a signedData/Receipt encapsulated within an envelopedData). The\n   sending
      agent MAY send an encrypted signed receipt in response to an\n   envelopedData-encapsulated
      signedData requesting a signed receipt. It\n   is a matter of local policy regarding
      whether or not the signed\n   receipt should be encrypted.  The ESS signed receipt
      includes the\n   message digest value calculated for the original signedData
      object\n   that requested the signed receipt. If the original signedData object\n
      \  was sent encrypted within an envelopedData object and the ESS signed\n   receipt
      is sent unencrypted, then the message digest value calculated\n   for the original
      encrypted signedData object is sent unencrypted. The\n   responder should consider
      this when deciding whether or not to\n   encrypt the ESS signed receipt.\n"
    - contents:
      - "2.4.1 MLExpansionHistory Attributes and Receipts\n   An MLExpansionHistory
        attribute MUST NOT be included in the\n   attributes of a SignerInfo in a
        SignedData object that encapsulates a\n   Receipt content. This is true because
        when a SignedData/Receipt is\n   sent to an MLA for distribution, then the
        MLA must always encapsulate\n   the received SignedData/Receipt in an outer
        SignedData in which the\n   MLA will include the MLExpansionHistory attribute.
        The MLA cannot\n   change the signedAttributes of the received SignedData/Receipt\n
        \  object, so it can't add the MLExpansionHistory to the\n   SignedData/Receipt.\n"
      title: 2.4.1 MLExpansionHistory Attributes and Receipts
    title: 2.4 Signed Receipt Creation
  - contents:
    - "2.5 Determining the Recipients of the Signed Receipt\n   If a signed receipt
      was created by the process described in the\n   sections above, then the software
      MUST use the following process to\n   determine to whom the signed receipt should
      be sent.\n   1. The receiptsTo field must be present in the receiptRequest\n
      \     attribute. The software initiates the sequence of recipients with\n      the
      value(s) of receiptsTo.\n   2. If the MlExpansionHistory attribute is present
      in the outer\n      SignedData block, and the last MLData contains an MLReceiptPolicy\n
      \     value of insteadOf, then the software replaces the sequence of\n      recipients
      with the value(s) of insteadOf.\n   3. If the MlExpansionHistory attribute is
      present in the outer\n      SignedData block and the last MLData contains an
      MLReceiptPolicy\n      value of inAdditionTo, then the software adds the value(s)
      of\n      inAdditionTo to the sequence of recipients.\n"
    title: 2.5 Determining the Recipients of the Signed Receipt
  - contents:
    - "2.6. Signed Receipt Validation\n   A signed receipt is communicated as a single
      ASN.1 encoded object\n   composed of a signedData object directly including
      a Receipt content.\n   It is identified by the presence of the id-ct-receipt
      object\n   identifier in the encapContentInfo eContentType value of the\n   signedData
      object including the Receipt content.\n   Although recipients are not supposed
      to send more than one signed\n   receipt, receiving agents SHOULD be able to
      accept multiple signed\n   receipts from a recipient.\n   A signedData/Receipt
      is validated as follows:\n   1. ASN.1 decode the signedData object including
      the Receipt content.\n   2. Extract the contentType, signedContentIdentifier,
      and\n      originatorSignatureValue from the decoded Receipt structure to\n
      \     identify the original signedData signerInfo that requested the\n      signedData/Receipt.\n
      \  3. Acquire the message signature digest value calculated by the sender\n
      \     to generate the signature value included in the original signedData\n
      \     signerInfo that requested the signedData/Receipt.\n       3.1. If the
      sender-calculated message signature digest value has\n            been saved
      locally by the sender, it must be located and\n            retrieved.\n       3.2.
      If it has not been saved, then it must be re-calculated based\n            on
      the original signedData content and signedAttributes as\n            described
      in [CMS].\n   4. The message signature digest value calculated by the sender
      is then\n      compared with the value of the msgSigDigest signedAttribute\n
      \     included in the signedData/Receipt signerInfo. If these digest\n      values
      are identical, then that proves that the message signature\n      digest value
      calculated by the recipient based on the received\n      original signedData
      object is the same as that calculated by the\n      sender. This proves that
      the recipient received exactly the same\n      original signedData content and
      signedAttributes as sent by the\n      sender because that is the only way that
      the recipient could have\n      calculated the same message signature digest
      value as calculated by\n      the sender.  If the digest values are different,
      then the\n      signedData/Receipt signature verification process fails.\n   5.
      Acquire the digest value calculated by the sender for the Receipt\n      content
      constructed by the sender (including the contentType,\n      signedContentIdentifier,
      and signature value that were included in\n      the original signedData signerInfo
      that requested the\n      signedData/Receipt).\n       5.1. If the sender-calculated
      Receipt content digest value has\n            been  saved locally by the sender,
      it must be located and\n            retrieved.\n       5.2. If it has not been
      saved, then it must be re-calculated. As\n            described in section above,
      step 2, create a Receipt\n            structure including the contentType, signedContentIdentifier\n
      \           and signature value that were included in the original\n            signedData
      signerInfo that requested the signed receipt. The\n            Receipt structure
      is then ASN.1 DER encoded to produce a data\n            stream which is then
      digested to produce the Receipt content\n            digest value.\n   6. The
      Receipt content digest value calculated by the sender is then\n      compared
      with the value of the messageDigest signedAttribute\n      included in the signedData/Receipt
      signerInfo. If these digest\n      values are identical, then that proves that
      the values included in\n      the Receipt content by the recipient are identical
      to those that\n      were included in the original signedData signerInfo that
      requested\n      the signedData/Receipt. This proves that the recipient received
      the\n      original signedData signed by the sender, because that is the only\n
      \     way that the recipient could have obtained the original signedData\n      signerInfo
      signature value for inclusion in the Receipt content. If\n      the digest values
      are different, then the signedData/Receipt\n      signature verification process
      fails.\n   7. The ASN.1 DER encoded signedAttributes of the signedData/Receipt\n
      \     signerInfo are digested as described in [CMS].\n   8. The resulting digest
      value is then used to verify the signature\n      value included in the signedData/Receipt
      signerInfo. If the\n      signature verification is successful, then that proves
      the\n      integrity of the signedData/receipt signerInfo signedAttributes and\n
      \     authenticates the identity of the signer of the signedData/Receipt\n      signerInfo.
      Note that the signedAttributes include the\n      recipient-calculated Receipt
      content digest value (messageDigest\n      attribute) and recipient-calculated
      message signature digest value\n      (msgSigDigest attribute). Therefore, the
      aforementioned comparison\n      of the sender-generated and recipient-generated
      digest values\n      combined with the successful signedData/Receipt signature\n
      \     verification proves that the recipient received the exact original\n      signedData
      content and signedAttributes (proven by msgSigDigest\n      attribute) that
      were signed by the sender of the original\n      signedData object (proven by
      messageDigest attribute). If the\n      signature verification fails, then the
      signedData/Receipt signature\n      verification process fails.\n   The signature
      verification process for each signature algorithm that\n   is used in conjunction
      with the CMS protocol is specific to the\n   algorithm.  These processes are
      described in documents specific to\n   the algorithms.\n"
    title: 2.6. Signed Receipt Validation
  - contents:
    - "2. 7 Receipt Request Syntax\n   A receiptRequest attribute value has ASN.1
      type ReceiptRequest. Use\n   the receiptRequest attribute only within the signed
      attributes\n   associated with a signed message.\n"
    - "ReceiptRequest ::= SEQUENCE {\n  signedContentIdentifier ContentIdentifier,\n
      \ receiptsFrom ReceiptsFrom,\n  receiptsTo SEQUENCE SIZE (1..ub-receiptsTo))
      OF GeneralNames }\n"
    - 'ub-receiptsTo INTEGER ::= 16

      '
    - "id-aa-receiptRequest OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n    us(840)
      rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) id-aa(2) 1}\n"
    - 'ContentIdentifier ::= OCTET STRING

      '
    - "id-aa-contentIdentifier OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n    us(840)
      rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) id-aa(2) 7}\n   A signedContentIdentifier
      MUST be created by the message originator\n   when creating a receipt request.
      To ensure global uniqueness, the\n   minimal signedContentIdentifier SHOULD
      contain a concatenation of\n   user-specific identification information (such
      as a user name or\n   public keying material identification information), a
      GeneralizedTime\n   string, and a random number.\n   The receiptsFrom field
      is used by the originator to specify the\n   recipients requested to return
      a signed receipt. A CHOICE is provided\n   to allow specification of:\n    -
      receipts from all recipients are requested\n    - receipts from first tier (recipients
      that did not receive the\n      message as members of a mailing list) recipients
      are requested\n    - receipts from a specific list of recipients are requested\n
      \  ReceiptsFrom ::= CHOICE {\n     allOrFirstTier [0] AllOrFirstTier,\n     --
      formerly \"allOrNone [0]AllOrNone\"\n     receiptList [1] SEQUENCE OF GeneralNames
      }\n   AllOrFirstTier ::= INTEGER { -- Formerly AllOrNone\n     allReceipts (0),\n
      \    firstTierRecipients (1) }\n   The receiptsTo field is used by the originator
      to identify the\n   user(s) to whom the identified recipient should send signed
      receipts.\n   The message originator MUST populate the receiptsTo field with
      a\n   GeneralNames for each entity to whom the recipient should send the\n   signed
      receipt. If the message originator wants the recipient to send\n   the signed
      receipt to the originator, then the originator MUST\n   include a GeneralNames
      for itself in the receiptsTo field.\n"
    title: 2.7 Receipt Request Syntax
  - contents:
    - "2.8 Receipt Syntax\n   Receipts are represented using a new content type, Receipt.
      The\n   Receipt content type shall have ASN.1 type Receipt. Receipts must be\n
      \  encapsulated within a SignedData message.\n"
    - "Receipt ::= SEQUENCE {\n  version ESSVersion,\n  contentType ContentType,\n
      \ signedContentIdentifier ContentIdentifier,\n  originatorSignatureValue OCTET
      STRING }\n"
    - "id-ct-receipt OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840)\n   rsadsi(113549)
      pkcs(1) pkcs-9(9) smime(16) id-ct(1) 1}\n"
    - "ESSVersion ::= INTEGER  { v1(1) }\n   The version field defines the syntax
      version number, which is 1 for\n   this version of the standard.\n"
    title: 2.8 Receipt Syntax
  - contents:
    - "2.9 Content Hints\n   Many applications find it useful to have information
      that describes\n   the innermost signed content of a multi-layer message available
      on\n   the outermost signature layer. The contentHints attribute provides\n
      \  such information.\n"
    - 'Content-hints attribute values have ASN.1 type contentHints.

      '
    - "ContentHints ::= SEQUENCE {\n  contentDescription UTF8String (SIZE (1..MAX))
      OPTIONAL,\n  contentType ContentType }\n"
    - "id-aa-contentHint OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840)\n    rsadsi(113549)
      pkcs(1) pkcs-9(9) smime(16) id-aa(2) 4}\n   The contentDescription field may
      be used to provide information that\n   the recipient may use to select protected
      messages for processing,\n   such as a message subject. If this field is set,
      then the attribute\n   is expected to appear on the signedData object enclosing
      an\n   envelopedData object and not on the inner signedData object. The\n   (SIZE
      (1..MAX)) construct constrains the sequence to have at least\n   one entry.
      MAX indicates the upper bound is unspecified.\n   Implementations are free to
      choose an upper bound that suits their\n   environment.\n   Messages which contain
      a signedData object wrapped around an\n   envelopedData object, thus masking
      the inner content type of the\n   message, SHOULD include a contentHints attribute,
      except for the case\n   of the data content type. Specific message content types
      may either\n   force or preclude the inclusion of the contentHints attribute.
      For\n   example, when a signedData/Receipt is encrypted within an\n   envelopedData
      object, an outer signedData object MUST be created that\n   encapsulates the
      envelopedData object and a contentHints attribute\n   with contentType set to
      the id-ct-receipt object identifier MUST be\n   included in the outer signedData
      SignerInfo signedAttributes.\n"
    title: 2.9 Content Hints
  - contents:
    - "2.10  Message Signature Digest Attribute\n   The msgSigDigest attribute can
      only be used in the signed attributes\n   of a signed receipt. It contains the
      digest of the ASN.1 DER encoded\n   signedAttributes included in the original
      signedData that requested\n   the signed receipt. Only one msgSigDigest attribute
      can appear in a\n   signed attributes set. It is defined as follows:\n"
    - 'msgSigDigest ::= OCTET STRING

      '
    - "id-aa-msgSigDigest OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n    us(840)
      rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) id-aa(2) 5}\n"
    title: 2.10  Message Signature Digest Attribute
  - contents:
    - "2.11 Signed Content Reference Attribute\n   The contentReference attribute
      is a link from one SignedData to\n   another. It may be used to link a reply
      to the original message to\n   which it refers, or to incorporate by reference
      one SignedData into\n   another. The first SignedData MUST include a contentIdentifier
      signed\n   attribute, which SHOULD be constructed as specified in section 2.7.\n
      \  The second SignedData links to the first by including a\n   ContentReference
      signed attribute containing the content type,\n   content identifier, and signature
      value from the first SignedData.\n"
    - "ContentReference ::= SEQUENCE {\n  contentType ContentType,\n  signedContentIdentifier
      ContentIdentifier,\n  originatorSignatureValue OCTET STRING }\n"
    - "id-aa-contentReference   OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n    us(840)
      rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) id-aa(2) 10 }\n"
    title: 2.11 Signed Content Reference Attribute
  title: 2. Signed Receipts
- contents:
  - "3. Security Labels\n   This section describes the syntax to be used for security
    labels that\n   can optionally be associated with S/MIME encapsulated data. A\n
    \  security label is a set of security information regarding the\n   sensitivity
    of the content that is protected by S/MIME encapsulation.\n   \"Authorization\"
    is the act of granting rights and/or privileges to\n   users permitting them access
    to an object. \"Access control\" is a\n   means of enforcing these authorizations.
    The sensitivity information\n   in a security label can be compared with a user's
    authorizations to\n   determine if the user is allowed to access the content that
    is\n   protected by S/MIME encapsulation.\n   Security labels may be used for
    other purposes such as a source of\n   routing information. The labels often describe
    ranked levels\n   (\"secret\", \"confidential\", \"restricted\", and so on) or
    are role-\n   based, describing which kind of people can see the information\n
    \  (\"patient's health-care team\", \"medical billing agents\",\n   \"unrestricted\",
    and so on).\n"
  - contents:
    - "3.1 Security Label Processing Rules\n   A sending agent may include a security
      label attribute in the signed\n   attributes of a signedData object. A receiving
      agent examines the\n   security label on a received message and determines whether
      or not\n   the recipient is allowed to see the contents of the message.\n"
    - contents:
      - "3.1.1 Adding Security Labels\n   A sending agent that is using security labels
        MUST put the security\n   label attribute in the signedAttributes field of
        a SignerInfo block.\n   The security label attribute MUST NOT be included
        in the unsigned\n   attributes. Integrity and authentication security services
        MUST be\n   applied to the security label, therefore it MUST be included as
        a\n   signed attribute, if used. This causes the security label attribute\n
        \  to be part of the data that is hashed to form the SignerInfo\n   signature
        value. A SignerInfo block MUST NOT have more than one\n   security label signed
        attribute.\n   When there are multiple SignedData blocks applied to a message,
        a\n   security label attribute may be included in either the inner\n   signature,
        outer signature, or both. A security label signed\n   attribute may be included
        in a signedAttributes field within the\n   inner SignedData block.  The inner
        security label will include the\n   sensitivities of the original content
        and will be used for access\n   control decisions related to the plaintext
        encapsulated content. The\n   inner signature provides authentication of the
        inner security label\n   and cryptographically protects the original signer's
        inner security\n   label of the original content.\n   When the originator
        signs the plaintext content and signed\n   attributes, the inner security
        label is bound to the plaintext\n   content. An intermediate entity cannot
        change the inner security\n   label without invalidating the inner signature.
        The confidentiality\n   security service can be applied to the inner security
        label by\n   encrypting the entire inner signedData object within an EnvelopedData\n
        \  block.\n   A security label signed attribute may also be included in a\n
        \  signedAttributes field within the outer SignedData block. The outer\n   security
        label will include the sensitivities of the encrypted\n   message and will
        be used for access control decisions related to the\n   encrypted message
        and for routing decisions. The outer signature\n   provides authentication
        of the outer security label (as well as for\n   the encapsulated content which
        may include nested S/MIME messages).\n   There can be multiple SignerInfos
        within a SignedData object, and\n   each SignerInfo may include signedAttributes.
        Therefore, a single\n   SignedData object may include multiple eSSSecurityLabels,
        each\n   SignerInfo having an eSSSecurityLabel attribute. For example, an\n
        \  originator can send a signed message with two SignerInfos, one\n   containing
        a DSS signature, the other containing an RSA signature. If\n   any of the
        SignerInfos included in a SignedData object include an\n   eSSSecurityLabel
        attribute, then all of the SignerInfos in that\n   SignedData object MUST
        include an eSSSecurityLabel attribute and the\n   value of each MUST be identical.\n"
      title: 3.1.1 Adding Security Labels
    - contents:
      - "3.1.2 Processing Security Labels\n   Before processing an eSSSecurityLabel
        signedAttribute, the receiving\n   agent MUST verify the signature of the
        SignerInfo which covers the\n   eSSSecurityLabel attribute. A recipient MUST
        NOT process an\n   eSSSecurityLabel attribute that has not been verified.\n
        \  A receiving agent MUST process the eSSSecurityLabel attribute, if\n   present,
        in each SignerInfo in the SignedData object for which it\n   verifies the
        signature. This may result in the receiving agent\n   processing multiple
        eSSSecurityLabels included in a single SignedData\n   object. Because all
        eSSSecurityLabels in a SignedData object must be\n   identical, the receiving
        agent processes (such as performing access\n   control) on the first eSSSecurityLabel
        that it encounters in a\n   SignerInfo that it verifies, and then ensures
        that all other\n   eSSSecurityLabels in signerInfos that it verifies are identical
        to\n   the first one encountered. If the eSSSecurityLabels in the\n   signerInfos
        that it verifies are not all identical, then the\n   receiving agent MUST
        warn the user of this condition.\n   Receiving agents SHOULD have a local
        policy regarding whether or not\n   to show the inner content of a signedData
        object that includes an\n   eSSSecurityLabel security-policy-identifier that
        the processing\n   software does not recognize. If the receiving agent does
        not\n   recognize the eSSSecurityLabel security-policy-identifier value, then\n
        \  it SHOULD stop processing the message and indicate an error.\n"
      title: 3.1.2 Processing Security Labels
    title: 3.1 Security Label Processing Rules
  - contents:
    - "3.2 Syntax of eSSSecurityLabel\n   The eSSSecurityLabel syntax is derived directly
      from [MTSABS] ASN.1\n   module. (The MTSAbstractService module begins with \"DEFINITIONS\n
      \  IMPLICIT TAGS ::=\".) Further, the eSSSecurityLabel syntax is\n   compatible
      with that used in [MSP4].\n"
    - "ESSSecurityLabel ::= SET {\n  security-policy-identifier SecurityPolicyIdentifier,\n
      \ security-classification SecurityClassification OPTIONAL,\n  privacy-mark ESSPrivacyMark
      OPTIONAL,\n  security-categories SecurityCategories OPTIONAL }\n"
    - "id-aa-securityLabel OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n    us(840)
      rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) id-aa(2) 2}\n"
    - 'SecurityPolicyIdentifier ::= OBJECT IDENTIFIER

      '
    - "SecurityClassification ::= INTEGER {\n  unmarked (0),\n  unclassified (1),\n
      \ restricted (2),\n  confidential (3),\n  secret (4),\n  top-secret (5) } (0..ub-integer-options)\n"
    - 'ub-integer-options INTEGER ::= 256

      '
    - "ESSPrivacyMark ::= CHOICE {\n    pString      PrintableString (SIZE (1..ub-privacy-mark-length)),\n
      \   utf8String   UTF8String (SIZE (1..MAX))\n"
    - '}

      '
    - 'ub-privacy-mark-length INTEGER ::= 128

      '
    - "SecurityCategories ::= SET SIZE (1..ub-security-categories) OF\n        SecurityCategory\n"
    - 'ub-security-categories INTEGER ::= 64

      '
    - "SecurityCategory ::= SEQUENCE {\n  type  [0] OBJECT IDENTIFIER,\n  value [1]
      ANY DEFINED BY type -- defined by type\n"
    - '}

      '
    - '--Note: The aforementioned SecurityCategory syntax produces identical

      '
    - '--hex encodings as the following SecurityCategory syntax that is

      '
    - '--documented in the X.411 specification:

      '
    - '--

      '
    - '--SecurityCategory ::= SEQUENCE {

      '
    - '--     type  [0]  SECURITY-CATEGORY,

      '
    - '--     value [1]  ANY DEFINED BY type }

      '
    - '--

      '
    - '--SECURITY-CATEGORY MACRO ::=

      '
    - '--BEGIN

      '
    - '--TYPE NOTATION ::= type | empty

      '
    - '--VALUE NOTATION ::= value (VALUE OBJECT IDENTIFIER)

      '
    - '--END

      '
    title: 3.2 Syntax of eSSSecurityLabel
  - contents:
    - "3.3  Security Label Components\n   This section gives more detail on the the
      various components of the\n   eSSSecurityLabel syntax.\n"
    - contents:
      - "3.3.1 Security Policy Identifier\n   A security policy is a set of criteria
        for the provision of security\n   services. The eSSSecurityLabel security-policy-identifier
        is used to\n   identify the security policy in force to which the security
        label\n   relates. It indicates the semantics of the other security label\n
        \  components.\n"
      title: 3.3.1 Security Policy Identifier
    - contents:
      - "3.3.2 Security Classification\n   This specification defines the use of the
        Security Classification\n   field exactly as is specified in the X.411 Recommendation,
        which\n   states in part:\n      If present, a security-classification may
        have one of a\n      hierarchical list of values. The basic security-classification\n
        \     hierarchy is defined in this Recommendation, but the use of these\n
        \     values is defined by the security-policy in force. Additional\n      values
        of security-classification, and their position in the\n      hierarchy, may
        also be defined by a security-policy as a local\n      matter or by bilateral
        agreement. The basic security-\n      classification hierarchy is, in ascending
        order: unmarked,\n      unclassified, restricted, confidential, secret, top-secret.\n
        \  This means that the security policy in force (identified by the\n   eSSSecurityLabel
        security-policy-identifier) defines the\n   SecurityClassification integer
        values and their meanings.\n   An organization can develop its own security
        policy that defines the\n   SecurityClassification INTEGER values and their
        meanings. However,\n   the general interpretation of the X.411 specification
        is that the\n   values of 0 through 5 are reserved for the \"basic hierarchy\"
        values\n   of unmarked, unclassified, restricted, confidential, secret, and\n
        \  top-secret. Note that X.411 does not provide the rules for how these\n
        \  values are used to label data and how access control is performed\n   using
        these values.\n   There is no universal definition of the rules for using
        these \"basic\n   hierarchy\" values. Each organization (or group of organizations)
        will\n   define a security policy which documents how the \"basic hierarchy\"\n
        \  values are used (if at all) and how access control is enforced (if at\n
        \  all) within their domain.\n   Therefore, the security-classification value
        MUST be accompanied by a\n   security-policy-identifier value to define the
        rules for its use. For\n   example, a company's \"secret\" classification
        may convey a different\n   meaning than the US Government \"secret\" classification.
        In summary, a\n   security policy SHOULD NOT use integers 0 through 5 for
        other than\n   their X.411 meanings, and SHOULD instead use other values in
        a\n   hierarchical fashion.\n   Note that the set of valid security-classification
        values MUST be\n   hierarchical, but these values do not necessarily need
        to be in\n   ascending numerical order. Further, the values do not need to
        be\n   contiguous.\n   For example, in the Defense Message System 1.0 security
        policy, the\n   security-classification value of 11 indicates Sensitive-But-\n
        \  Unclassified and 5 indicates top-secret. The hierarchy of sensitivity\n
        \  ranks top-secret as more sensitive than Sensitive-But-Unclassified\n   even
        though the numerical value of top-secret is less than\n   Sensitive-But-Unclassified.\n
        \  (Of course, if security-classification values are both hierarchical\n   and
        in ascending order, a casual reader of the security policy is\n   more likely
        to understand it.)\n   An example of a security policy that does not use any
        of the X.411\n   values might be:\n   10 -- anyone\n   15 -- Morgan Corporation
        and its contractors\n   20 -- Morgan Corporation employees\n   25 -- Morgan
        Corporation board of directors\n   An example of a security policy that uses
        part of the X.411 hierarchy\n   might be:\n   0 -- unmarked\n   1 -- unclassified,
        can be read by everyone\n   2 -- restricted to Timberwolf Productions staff\n
        \  6 -- can only be read to Timberwolf Productions executives\n"
      title: 3.3.2 Security Classification
    - contents:
      - "3.3.3 Privacy Mark\n   If present, the eSSSecurityLabel privacy-mark is not
        used for access\n   control. The content of the eSSSecurityLabel privacy-mark
        may be\n   defined by the security policy in force (identified by the\n   eSSSecurityLabel
        security-policy-identifier) which may define a list\n   of values to be used.
        Alternately, the value may be determined by the\n   originator of the security-label.\n"
      title: 3.3.3 Privacy Mark
    - contents:
      - "3.3.4 Security Categories\n   If present, the eSSSecurityLabel security-categories
        provide further\n   granularity for the sensitivity of the message. The security
        policy\n   in force (identified by the eSSSecurityLabel security-policy-\n
        \  identifier) is used to indicate the syntaxes that are allowed to be\n   present
        in the eSSSecurityLabel security-categories. Alternately, the\n   security-categories
        and their values may be defined by bilateral\n   agreement.\n"
      title: 3.3.4 Security Categories
    title: 3.3  Security Label Components
  - contents:
    - "3.4  Equivalent Security Labels\n   Because organizations are allowed to define
      their own security\n   policies, many different security policies will exist.
      Some\n   organizations may wish to create equivalencies between their security\n
      \  policies with the security policies of other organizations. For\n   example,
      the Acme Company and the Widget Corporation may reach a\n   bilateral agreement
      that the \"Acme private\" security-classification\n   value is equivalent to
      the \"Widget sensitive\" security-classification\n   value.\n   Receiving agents
      MUST NOT process an equivalentLabels attribute in a\n   message if the agent
      does not trust the signer of that attribute to\n   translate the original eSSSecurityLabel
      values to the security policy\n   included in the equivalentLabels attribute.
      Receiving agents have the\n   option to process equivalentLabels attributes
      but do not have to. It\n   is acceptable for a receiving agent to only process\n
      \  eSSSecurityLabels. All receiving agents SHOULD recognize\n   equivalentLabels
      attributes even if they do not process them.\n"
    - contents:
      - "3.4.1 Creating Equivalent Labels\n   The EquivalentLabels signed attribute
        is defined as:\n"
      - 'EquivalentLabels ::= SEQUENCE OF ESSSecurityLabel

        '
      - "id-aa-equivalentLabels OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n        us(840)
        rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) id-aa(2) 9}\n   As stated earlier,
        the ESSSecurityLabel contains the sensitivity\n   values selected by the original
        signer of the signedData. If an\n   ESSSecurityLabel is present in a signerInfo,
        all signerInfos in the\n   signedData MUST contain an ESSSecurityLabel and
        they MUST all be\n   identical. In addition to an ESSSecurityLabel, a signerInfo
        MAY also\n   include an equivalentLabels signed attribute. If present, the\n
        \  equivalentLabels attribute MUST include one or more security labels\n   that
        are believed by the signer to be semantically equivalent to the\n   ESSSecurityLabel
        attribute included in the same signerInfo.\n   All security-policy object
        identifiers MUST be unique in the set of\n   ESSSecurityLabel and EquivalentLabels
        security labels. Before using\n   an EquivalentLabels attribute, a receiving
        agent MUST ensure that all\n   security-policy OIDs are unique in the security
        label or labels\n   included in the EquivalentLabels. Once the receiving agent
        selects\n   the security label (within the EquivalentLabels) to be used for\n
        \  processing, then the security-policy OID of the selected\n   EquivalentLabels
        security label MUST be compared with the\n   ESSSecurityLabel security-policy
        OID to ensure that they are unique.\n   In the case that an ESSSecurityLabel
        attribute is not included in a\n   signerInfo, then an EquivalentLabels attribute
        may still be included.\n   For example, in the Acme security policy, the absence
        of an\n   ESSSecurityLabel could be defined to equate to a security label\n
        \  composed of the Acme security-policy OID and the \"unmarked\"\n   security-classification.\n
        \  Note that equivalentLabels MUST NOT be used to convey security labels\n
        \  that are semantically different from the ESSSecurityLabel included in\n
        \  the signerInfos in the signedData. If an entity needs to apply a\n   security
        label that is semantically different from the\n   ESSSecurityLabel, then it
        MUST include the sematically different\n   security label in an outer signedData
        object that encapsulates the\n   signedData object that includes the ESSSecurityLabel.\n
        \  If present, the equivalentLabels attribute MUST be a signed\n   attribute;
        it MUST NOT be an unsigned attribute. [CMS] defines\n   signedAttributes as
        a SET OF Attribute. A signerInfo MUST NOT include\n   multiple instances of
        the equivalentLabels attribute. CMS defines the\n   ASN.1 syntax for the signed
        attributes to include attrValues SET OF\n   AttributeValue. A equivalentLabels
        attribute MUST only include a\n   single instance of AttributeValue. There
        MUST NOT be zero or multiple\n   instances of AttributeValue present in the
        attrValues SET OF\n   AttributeValue.\n"
      title: 3.4.1 Creating Equivalent Labels
    - contents:
      - "3.4.2 Processing Equivalent Labels\n   A receiving agent SHOULD process the
        ESSSecurityLabel before\n   processing any EquivalentLabels. If the policy
        in the\n   ESSSecurityLabel is understood by the receiving agent, it MUST\n
        \  process that label and MUST ignore all EquivalentLabels.\n   When processing
        an EquivalentLabels attribute, the receiving agent\n   MUST validate the signature
        on the EquivalentLabels attribute. A\n   receiving agent MUST NOT act on an
        equivalentLabels attribute for\n   which the signature could not be validated,
        and MUST NOT act on an\n   equivalentLabels attribute unless that attribute
        is signed by an\n   entity trusted to translate the original eSSSecurityLabel
        values to\n   the security policy included in the equivalentLabels attribute.\n
        \  Determining who is allowed to specify equivalence mappings is a local\n
        \  policy. If a message has more than one EquivalentLabels attribute,\n   the
        receiving agent SHOULD process the first one that it reads and\n   validates
        that contains the security policy of interest to the\n   receiving agent.\n"
      title: 3.4.2 Processing Equivalent Labels
    title: 3.4  Equivalent Security Labels
  title: 3. Security Labels
- contents:
  - "4. Mail List Management\n   Sending agents must create recipient-specific data
    structures for\n   each recipient of an encrypted message. This process can impair\n
    \  performance for messages sent to a large number of recipients. Thus,\n   Mail
    List Agents (MLAs) that can take a single message and perform\n   the recipient-specific
    encryption for every recipient are often\n   desired.\n   An MLA appears to the
    message originator as a normal message\n   recipient, but the MLA acts as a message
    expansion point for a Mail\n   List (ML). The sender of a message directs the
    message to the MLA,\n   which then redistributes the message to the members of
    the ML. This\n   process offloads the per-recipient processing from individual
    user\n   agents and allows for more efficient management of large MLs. MLs are\n
    \  true message recipients served by MLAs that provide cryptographic and\n   expansion
    services for the mailing list.\n   In addition to cryptographic handling of messages,
    secure mailing\n   lists also have to prevent mail loops. A mail loop is where
    one\n   mailing list is a member of a second mailing list, and the second\n   mailing
    list is a member of the first. A message will go from one\n   list to the other
    in a rapidly-cascading succession of mail that will\n   be distributed to all
    other members of both lists.\n   To prevent mail loops, MLAs use the mlExpansionHistory
    attribute of\n   the outer signature of a triple wrapped message. The\n   mlExpansionHistory
    attribute is essentially a list of every MLA that\n   has processed the message.
    If an MLA sees its own unique entity\n   identifier in the list, it knows that
    a loop has been formed, and\n   does not send the message to the list again.\n"
  - contents:
    - "4.1 Mail List Expansion\n   Mail list expansion processing is noted in the
      value of the\n   mlExpansionHistory attribute, located in the signed attributes
      of the\n   MLA's SignerInfo block. The MLA creates or updates the signed\n   mlExpansionHistory
      attribute value each time the MLA expands and\n   signs a message for members
      of a mail list.\n   The MLA MUST add an MLData record containing the MLA's identification\n
      \  information, date and time of expansion, and optional receipt policy\n   to
      the end of the mail list expansion history sequence. If the\n   mlExpansionHistory
      attribute is absent, then the MLA MUST add the\n   attribute and the current
      expansion becomes the first element of the\n   sequence. If the mlExpansionHistory
      attribute is present, then the\n   MLA MUST add the current expansion information
      to the end of the\n   existing MLExpansionHistory sequence. Only one mlExpansionHistory\n
      \  attribute can be included in the signedAttributes of a SignerInfo.\n   Note
      that if the mlExpansionHistory attribute is absent, then the\n   recipient is
      a first tier message recipient.\n   There can be multiple SignerInfos within
      a SignedData object, and\n   each SignerInfo may include signedAttributes. Therefore,
      a single\n   SignedData object may include multiple SignerInfos, each SignerInfo\n
      \  having a mlExpansionHistory attribute. For example, an MLA can send a\n   signed
      message with two SignerInfos, one containing a DSS signature,\n   the other
      containing an RSA signature.\n   If an MLA creates a SignerInfo that includes
      an mlExpansionHistory\n   attribute, then all of the SignerInfos created by
      the MLA for that\n   SignedData object MUST include an mlExpansionHistory attribute,
      and\n   the value of each MUST be identical. Note that other agents might\n
      \  later add SignerInfo attributes to the SignedData block, and those\n   additional
      SignerInfos might not include mlExpansionHistory\n   attributes.\n   A recipient
      MUST verify the signature of the SignerInfo which covers\n   the mlExpansionHistory
      attribute before processing the\n   mlExpansionHistory, and MUST NOT process
      the mlExpansionHistory\n   attribute unless the signature over it has been verified.
      If a\n   SignedData object has more than one SignerInfo that has an\n   mlExpansionHistory
      attribute, the recipient MUST compare the\n   mlExpansionHistory attributes
      in all the SignerInfos that it has\n   verified, and MUST NOT process the mlExpansionHistory
      attribute\n   unless every verified mlExpansionHistory attribute in the SignedData\n
      \  block is identical. If the mlExpansionHistory attributes in the\n   verified
      signerInfos are not all identical, then the receiving agent\n   MUST stop processing
      the message and SHOULD notify the user or MLA\n   administrator of this error
      condition. In the mlExpansionHistory\n   processing, SignerInfos that do not
      have an mlExpansionHistory\n   attribute are ignored.\n"
    - contents:
      - "4.1.1 Detecting Mail List Expansion Loops\n   Prior to expanding a message,
        the MLA examines the value of any\n   existing mail list expansion history
        attribute to detect an expansion\n   loop. An expansion loop exists when a
        message expanded by a specific\n   MLA for a specific mail list is redelivered
        to the same MLA for the\n   same mail list.\n   Expansion loops are detected
        by examining the mailListIdentifier\n   field of each MLData entry found in
        the mail list expansion history.\n   If an MLA finds its own identification
        information, then the MLA must\n   discontinue expansion processing and should
        provide warning of an\n   expansion loop to a human mail list administrator.
        The mail list\n   administrator is responsible for correcting the loop condition.\n"
      title: 4.1.1 Detecting Mail List Expansion Loops
    title: 4.1 Mail List Expansion
  - contents:
    - "4.2 Mail List Agent Processing\n   The first few paragraphs of this section
      provide a high-level\n   description of MLA processing. The rest of the section
      provides a\n   detailed description of MLA processing.\n   MLA message processing
      depends on the structure of the S/MIME layers\n   in the message sent to the
      MLA for expansion. In addition to sending\n   triple wrapped messages to an
      MLA, an entity can send other types of\n   messages to an MLA, such as:\n    -
      a single wrapped signedData or envelopedData message\n    - a double wrapped
      message (such as signed and enveloped, enveloped\n      and signed, or signed
      and signed, and so on)\n    - a quadruple-wrapped message (such as if a well-formed
      triple\n      wrapped message was sent through a gateway that added an outer\n
      \     SignedData layer)\n   In all cases, the MLA MUST parse all layers of the
      received message\n   to determine if there are any signedData layers that include
      an\n   eSSSecurityLabel signedAttribute. This may include decrypting an\n   EnvelopedData
      layer to determine if an encapsulated SignedData layer\n   includes an eSSSecurityLabel
      attribute. The MLA MUST fully process\n   each eSSSecurityLabel attribute found
      in the various signedData\n   layers, including performing access control checks,
      before\n   distributing the message to the ML members. The details of the access\n
      \  control checks are beyond the scope of this document. The MLA MUST\n   verify
      the signature of the signerInfo including the eSSSecurityLabel\n   attribute
      before using it.\n   In all cases, the MLA MUST sign the message to be sent
      to the ML\n   members in a new \"outer\" signedData layer. The MLA MUST add
      or update\n   an mlExpansionHistory attribute in the \"outer\" signedData that
      it\n   creates to document MLA processing. If there was an \"outer\"\n   signedData
      layer included in the original message received by the\n   MLA, then the MLA-created
      \"outer\" signedData layer MUST include each\n   signed attribute present in
      the original \"outer\" signedData layer,\n   unless the MLA explicitly replaces
      an attribute (such as signingTime\n   or mlExpansionHistory) with a new value.\n
      \  When an S/MIME message is received by the MLA, the MLA MUST first\n   determine
      which received signedData layer, if any, is the \"outer\"\n   signedData layer.
      \ To identify the received \"outer\" signedData layer,\n   the MLA MUST verify
      the signature and fully process the\n   signedAttributes in each of the outer
      signedData layers (working from\n   the outside in) to determine if any of them
      either include an\n   mlExpansionHistory attribute or encapsulate an envelopedData
      object.\n   The MLA's search for the \"outer\" signedData layer is completed
      when\n   it finds one of the following:\n    - the \"outer\" signedData layer
      that includes an mlExpansionHistory\n      attribute or encapsulates an envelopedData
      object\n    - an envelopedData layer\n    - the original content (that is, a
      layer that is neither\n      envelopedData nor signedData).\n   If the MLA finds
      an \"outer\" signedData layer, then the MLA MUST\n   perform the following steps:\n
      \  1. Strip off all of the signedData layers that encapsulated the\n      \"outer\"
      signedData layer\n   2. Strip off the \"outer\" signedData layer itself (after
      remembering\n      the included signedAttributes)\n   3. Expand the envelopedData
      (if present)\n   4. Sign the message to be sent to the ML members in a new \"outer\"\n
      \     signedData layer that includes the signedAttributes (unless\n      explicitly
      replaced) from the original, received \"outer\" signedData\n      layer.\n   If
      the MLA finds an \"outer\" signedData layer that includes an\n   mlExpansionHistory
      attribute AND the MLA subsequently finds an\n   envelopedData layer buried deeper
      with the layers of the received\n   message, then the MLA MUST strip off all
      of the signedData layers\n   down to the envelopedData layer (including stripping
      off the original\n   \"outer\" signedData layer) and MUST sign the expanded
      envelopedData in\n   a new \"outer\" signedData layer that includes the signedAttributes\n
      \  (unless explicitly replaced) from the original, received \"outer\"\n   signedData
      layer.\n   If the MLA does not find an \"outer\" signedData layer AND does not\n
      \  find an envelopedData layer, then the MLA MUST sign the original,\n   received
      message in a new \"outer\" signedData layer. If the MLA does\n   not find an
      \"outer\" signedData AND does find an envelopedData layer\n   then it MUST expand
      the envelopedData layer, if present, and sign it\n   in a new \"outer\" signedData
      layer.\n"
    - contents:
      - "4.2.1 Examples of Rule Processing\n   The following examples help explain
        the rules above:\n   1) A message (S1(Original Content)) (where S = SignedData)
        is sent to\n      the MLA in which the signedData layer does not include an\n
        \     MLExpansionHistory attribute. The MLA verifies and fully processes\n
        \     the signedAttributes in S1.  The MLA decides that there is not an\n
        \     original, received \"outer\" signedData layer since it finds the\n      original
        content, but never finds an envelopedData and never finds\n      an mlExpansionHistory
        attribute. The MLA calculates a new\n      signedData layer, S2, resulting
        in the following message sent to\n      the ML recipients: (S2(S1(Original
        Content))). The MLA includes an\n      mlExpansionHistory attribute in S2.\n
        \  2) A message (S3(S2(S1(Original Content)))) is sent to the MLA in\n      which
        none of the signedData layers includes an MLExpansionHistory\n      attribute.
        The MLA verifies and fully processes the\n      signedAttributes in S3, S2
        and S1. The MLA decides that there is\n      not an original, received \"outer\"
        signedData layer since it finds\n      the original content, but never finds
        an envelopedData and never\n      finds an mlExpansionHistory attribute. The
        MLA calculates a new\n      signedData layer, S4, resulting in the following\n
        \     message sent to the ML recipients:\n      (S4(S3(S2(S1(Original Content))))).
        The MLA includes an\n      mlExpansionHistory attribute in S4.\n   3) A message
        (E1(S1(Original Content))) (where E = envelopedData) is\n      sent to the
        MLA in which S1 does not include an MLExpansionHistory\n      attribute.  The
        MLA decides that there is not an original,\n      received \"outer\" signedData
        layer since it finds the E1 as the\n      outer layer.  The MLA expands the
        recipientInformation in E1. The\n      MLA calculates a new signedData layer,
        S2, resulting in the\n      following message sent to the ML recipients:\n
        \     (S2(E1(S1(Original Content)))). The MLA includes an\n      mlExpansionHistory
        attribute in S2.\n   4) A message (S2(E1(S1(Original Content)))) is sent to
        the MLA in\n      which S2 includes an MLExpansionHistory attribute. The MLA
        verifies\n      the signature and fully processes the signedAttributes in
        S2. The\n      MLA finds the mlExpansionHistory attribute in S2, so it decides\n
        \     that S2 is the \"outer\" signedData. The MLA remembers the\n      signedAttributes
        included in S2 for later inclusion in the new\n      outer signedData that
        it applies to the message. The MLA strips off\n      S2. The MLA then expands
        the recipientInformation in E1 (this\n      invalidates the signature in S2
        which is why it was stripped). The\n      nMLA calculates a new signedData
        layer, S3, resulting in the\n      following message sent to the ML recipients:
        (S3(E1(S1(Original\n      Content)))). The MLA includes in S3 the attributes
        from S2 (unless\n      it specifically replaces an attribute value) including
        an updated\n      mlExpansionHistory attribute.\n   5) A message (S3(S2(E1(S1(Original
        Content))))) is sent to the MLA in\n      which none of the signedData layers
        include an MLExpansionHistory\n      attribute. The MLA verifies the signature
        and fully processes the\n      signedAttributes in S3 and S2. When the MLA
        encounters E1, then it\n      decides that S2 is the \"outer\" signedData
        since S2 encapsulates E1.\n      The MLA remembers the signedAttributes included
        in S2 for later\n      inclusion in the new outer signedData that it applies
        to the\n      message.  The MLA strips off S3 and S2. The MLA then expands
        the\n      recipientInformation in E1 (this invalidates the signatures in
        S3\n      and S2 which is why they were stripped). The MLA calculates a new\n
        \     signedData layer, S4, resulting in the following message sent to\n      the
        ML recipients: (S4(E1(S1(Original Content)))). The MLA\n      includes in
        S4 the attributes from S2 (unless it specifically\n      replaces an attribute
        value) and includes a new\n      mlExpansionHistory attribute.\n   6) A message
        (S3(S2(E1(S1(Original Content))))) is sent to the MLA in\n      which S3 includes
        an MLExpansionHistory attribute. In this case,\n      the MLA verifies the
        signature and fully processes the\n      signedAttributes in S3. The MLA finds
        the mlExpansionHistory in S3,\n      so it decides that S3 is the \"outer\"
        signedData. The MLA remembers\n      the signedAttributes included in S3 for
        later inclusion in the new\n      outer signedData that it applies to the
        message. The MLA keeps on\n      parsing encapsulated layers because it must
        determine if there are\n      any eSSSecurityLabel attributes contained within.
        The MLA verifies\n      the signature and fully processes the signedAttributes
        in S2. When\n      the MLA encounters E1, then it strips off S3 and S2. The
        MLA then\n      expands the recipientInformation in E1 (this invalidates the\n
        \     signatures in S3 and S2 which is why they were stripped). The MLA\n
        \     calculates a new signedData layer, S4, resulting in the following\n
        \     message sent to the ML recipients: (S4(E1(S1(Original Content)))).\n
        \     The MLA includes in S4 the attributes from S3 (unless it\n      specifically
        replaces an attribute value) including an updated\n      mlExpansionHistory
        attribute.\n"
      title: 4.2.1 Examples of Rule Processing
    - contents:
      - "4.2.3 Processing Choices\n   The processing used depends on the type of the
        outermost layer of the\n   message. There are three cases for the type of
        the outermost data:\n    - EnvelopedData\n    - SignedData\n    - data\n"
      - contents:
        - "4.2.3.1 Processing for EnvelopedData\n   1. The MLA locates its own RecipientInfo
          and uses the information it\n      contains to obtain the message key.\n
          \  2. The MLA removes the existing recipientInfos field and replaces it\n
          \     with a new recipientInfos value built from RecipientInfo\n   structures\n
          \     created for each member of the mailing list. The MLA also removes\n
          \     the existing originatorInfo field and replaces it with a new\n      originatorInfo
          value built from information describing the MLA.\n   3. The MLA encapsulates
          the expanded encrypted message in a\n      SignedData block, adding an mlExpansionHistory
          attribute as\n      described in the \"Mail List Expansion\" section to
          document the\n      expansion.\n   4. The MLA signs the new message and
          delivers the updated message to\n      mail list members to complete MLA
          processing.\n"
        title: 4.2.3.1 Processing for EnvelopedData
      - contents:
        - "4.2.3.2 Processing for SignedData\n   MLA processing of multi-layer messages
          depends on the type of data in\n   each of the layers. Step 3 below specifies
          that different processing\n   will take place depending on the type of CMS
          message that has been\n   signed. That is, it needs to know the type of
          data at the next inner\n   layer, which may or may not be the innermost
          layer.\n   1. The MLA verifies the signature value found in the outermost\n
          \     SignedData layer associated with the signed data. MLA\n      processing
          of the message terminates if the message signature\n      is invalid.\n
          \  2. If the outermost SignedData layer includes a signed\n      mlExpansionHistory
          attribute, the MLA checks for an expansion loop\n      as described in the
          \"Detecting Mail List Expansion Loops\" section,\n      then go to step
          3. If the outermost SignedData layer does not\n      include a signed mlExpansionHistory
          attribute, the MLA signs the\n      whole message (including this outermost
          SignedData layer that\n      doesn't have an mlExpansionHistory attribute),
          and delivers the\n      updated message to mail list members to complete
          MLA processing.\n   3. Determine the type of the data that has been signed.
          That is, look\n      at the type of data on the layer just below the SignedData,
          which\n      may or may not be the \"innermost\" layer. Based on the type
          of data,\n      perform either step 3.1 (EnvelopedData), step 3.2 (SignedData),
          or\n      step 3.3 (all other types).\n       3.1. If the signed data is
          EnvelopedData, the MLA performs\n            expansion processing of the
          encrypted message as\n            described previously. Note that this process
          invalidates the\n            signature value in the outermost SignedData
          layer associated\n            with the original encrypted message.  Proceed
          to section 3.2\n            with the result of the expansion.\n       3.2.
          If the signed data is SignedData, or is the result of\n            expanding
          an EnvelopedData block in step 3.1:\n           3.2.1. The MLA strips the
          existing outermost SignedData layer\n                  after remembering
          the value of the mlExpansionHistory\n                  and all other signed
          attributes in that layer, if\n                  present.\n           3.2.2.
          \ If the signed data is EnvelopedData (from step 3.1),\n                   the
          MLA encapsulates the expanded encrypted message\n                   in a
          new outermost SignedData layer. On the other\n                   hand, if
          the signed data is SignedData (from step\n                   3.2), the MLA
          encapsulates the signed data in a new\n                   outermost SignedData
          layer.\n           3.2.3.  The outermost signedData layer created by the
          MLA\n                   replaces the original outermost signedData layer.
          The\n                   MLA MUST create an signed attribute list for the
          new\n                   outermost signedData layer which MUST include each\n
          \                  signed attribute present in the original outermost\n
          \                  signedData layer, unless the MLA explicitly replaces\n
          \                  one or more particular attributes with new value. A\n
          \                  special case is the mlExpansionHistory attribute. The\n
          \                  MLA MUST add an mlExpansionHistory signed attribute\n
          \                  to the outer signedData layer as follows:\n               3.2.3.1.
          If the original outermost SignedData layer\n                        included
          an mlExpansionHistory attribute, the\n                        attribute's
          value is copied and updated with the\n                        current ML
          expansion information as described in\n                        the \"Mail
          List Expansion\" section.\n               3.2.3.2. If the original outermost
          SignedData layer did\n                        not include an mlExpansionHistory
          attribute, a\n                        new attribute value is created with
          the current\n                        ML expansion information as described
          in the\n                        \"Mail List Expansion\" section.\n       3.3.
          If the signed data is not EnvelopedData or SignedData:\n           3.3.1.
          \ The MLA encapsulates the received signedData object in\n                   an
          outer SignedData object, and adds an\n                   mlExpansionHistory
          attribute to the outer SignedData\n                   object containing
          the current ML expansion information\n                   as described in
          the \"Mail List Expansion\" section.\n   4. The MLA signs the new message
          and delivers the updated message to\n      mail list members to complete
          MLA processing.\n   A flow chart for the above steps would be:\n   1. Has
          a valid signature?\n          YES -> 2.\n          NO  -> STOP.\n   2. Does
          outermost SignedData layer contain mlExpansionHistory?\n          YES ->
          Check it, then -> 3.\n          NO  -> Sign message (including outermost
          SignedData that\n                 doesn't have mlExpansionHistory), deliver
          it, STOP.\n   3. Check type of data just below outermost SignedData.\n          EnvelopedData
          -> 3.1.\n          SignedData -> 3.2.\n          all others -> 3.3.\n   3.1.
          Expand the encrypted message, then -> 3.2.\n   3.2. -> 3.2.1.\n   3.2.1.
          Strip outermost SignedData layer, note value of\n          mlExpansionHistory
          and other signed attributes, then -> 3.2.2.\n   3.2.2. Encapsulate in new
          signature, then -> 3.2.3.\n   3.2.3. Create new signedData layer. Was there
          an old\n          mlExpansionHistory?\n          YES -> copy the old mlExpansionHistory
          values, then -> 4.\n          NO  -> create new mlExpansionHistory value,
          then -> 4.\n   3.3. Encapsulate in a SignedData layer and add an mlExpansionHistory\n
          \         attribute, then -> 4.\n   4. Sign message, deliver it, STOP.\n"
        title: 4.2.3.2 Processing for SignedData
      - contents:
        - "4.2.3.3 Processing for data\n   1. The MLA encapsulates the message in
          a SignedData layer, and adds an\n      mlExpansionHistory attribute containing
          the current ML expansion\n      information as described in the \"Mail List
          Expansion\" section.\n   2. The MLA signs the new message and delivers the
          updated message to\n      mail list members to complete MLA processing.\n
          \  4.3 Mail List Agent Signed Receipt Policy Processing\n   If a mailing
          list (B) is a member of another mailing list (A), list B\n   often needs
          to propagate forward the mailing list receipt policy of\n   A. As a general
          rule, a mailing list should be conservative in\n   propagating forward the
          mailing list receipt policy because the\n   ultimate recipient need only
          process the last item in the ML\n   expansion history. The MLA builds the
          expansion history to meet this\n   requirement.\n   The following table
          describes the outcome of the union of mailing\n   list A's policy (the rows
          in the table) and mailing list B's policy\n   (the columns in the table).\n
          \            |                    B's policy\n"
        - 'A''s policy   | none   insteadOf        inAdditionTo      missing

          '
        - '-----------------------------------------------------------------------

          '
        - 'none         | none   none             none              none

          '
        - 'insteadOf    | none   insteadOf(B)     *1                insteadOf(A)

          '
        - 'inAdditionTo | none   insteadOf(B)     *2                inAdditionTo(A)

          '
        - 'missing      | none   insteadOf(B)     inAdditionTo(B)   missing

          '
        - '*1 = insteadOf(insteadOf(A) + inAdditionTo(B))

          '
        - '*2 = inAdditionTo(inAdditionTo(A) + inAdditionTo(B))

          '
        title: 4.2.3.3 Processing for data
      title: 4.2.3 Processing Choices
    title: 4.2 Mail List Agent Processing
  - contents:
    - "4.4 Mail List Expansion History Syntax\n   An mlExpansionHistory attribute
      value has ASN.1 type\n   MLExpansionHistory. If there are more than ub-ml-expansion-history\n
      \  mailing lists in the sequence, the receiving agent should provide\n   notification
      of the error to a human mail list administrator. The\n   mail list administrator
      is responsible for correcting the overflow\n   condition.\n"
    - "MLExpansionHistory ::= SEQUENCE\n        SIZE (1..ub-ml-expansion-history)
      OF MLData\n"
    - "id-aa-mlExpandHistory OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n    us(840)
      rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) id-aa(2) 3}\n"
    - "ub-ml-expansion-history INTEGER ::= 64\n   MLData contains the expansion history
      describing each MLA that has\n   processed a message. As an MLA distributes
      a message to members of an\n   ML, the MLA records its unique identifier, date
      and time of\n   expansion, and receipt policy in an MLData structure.\n"
    - "MLData ::= SEQUENCE {\n  mailListIdentifier EntityIdentifier,\n  expansionTime
      GeneralizedTime,\n  mlReceiptPolicy MLReceiptPolicy OPTIONAL }\n"
    - "EntityIdentifier ::= CHOICE {\n  issuerAndSerialNumber IssuerAndSerialNumber,\n
      \ subjectKeyIdentifier SubjectKeyIdentifier }\n   The receipt policy of the
      ML can withdraw the originator's request\n   for the return of a signed receipt.
      However, if the originator of the\n   message has not requested a signed receipt,
      the MLA cannot request a\n   signed receipt. In the event that a ML's signed
      receipt policy\n   supersedes the originator's request for signed receipts,
      such that\n   the originator will not receive any signed receipts, then the
      MLA MAY\n   inform the originator of that fact.\n   When present, the mlReceiptPolicy
      specifies a receipt policy that\n   supersedes the originator's request for
      signed receipts. The policy\n   can be one of three possibilities: receipts
      MUST NOT be returned\n   (none); receipts should be returned to an alternate
      list of\n   recipients, instead of to the originator (insteadOf); or receipts\n
      \  should be returned to a list of recipients in addition to the\n   originator
      (inAdditionTo).\n   MLReceiptPolicy ::= CHOICE {\n     none [0] NULL,\n     insteadOf
      [1] SEQUENCE SIZE (1..MAX) OF GeneralNames,\n     inAdditionTo [2] SEQUENCE
      SIZE (1..MAX) OF GeneralNames }\n"
    title: 4.4 Mail List Expansion History Syntax
  title: 4. Mail List Management
- contents:
  - "5. Signing Certificate Attribute\n   Concerns have been raised over the fact
    that the certificate which\n   the signer of a CMS SignedData object desired to
    be bound into the\n   verification process of the SignedData object is not\n   cryptographically
    bound into the signature itself. This section\n   addresses this issue by creating
    a new attribute to be placed in the\n   signed attributes section of a SignerInfo
    object.\n   This section also presents a description of a set of possible attacks\n
    \  dealing with the substitution of one certificate to verify the\n   signature
    for the desired certificate. A set of ways for preventing\n   or addressing these
    attacks is presented to deal with the simplest of\n   the attacks.\n   Authorization
    information can be used as part of a signature\n   verification process. This
    information can be carried in either\n   attribute certificates and other public
    key certificates. The signer\n   needs to have the ability to restrict the set
    of certificates used in\n   the signature verification process, and information
    needs to be\n   encoded so that is covered by the signature on the SignedData
    object.\n   The methods in this section allow for the set of authorization\n   certificates
    to be listed as part of the signing certificate\n   attribute.\n   Explicit certificate
    policies can also be used as part of a signature\n   verification process. If
    a signer desires to state an explicit\n   certificate policy that should be used
    when validating the signature,\n   that policy needs to be cryptographically bound
    into the signing\n   process. The methods described in this section allows for
    a set of\n   certificate policy statements to be listed as part of the signing\n
    \  certificate attribute.\n"
  - contents:
    - "5.1. Attack Descriptions\n   At least three different attacks can be launched
      against a possible\n   signature verification process by replacing the certificate
      or\n   certficates used in the signature verification process.\n"
    - contents:
      - "5.1.1 Substitution Attack Description\n   The first attack deals with simple
        substitution of one certificate\n   for another certificate. In this attack,
        the issuer and serial number\n   in the SignerInfo is modified to refer to
        a new certificate. This new\n   certificate is used during the signature verification
        process.\n   The first version of this attack is a simple denial of service
        attack\n   where an invalid certificate is substituted for the valid\n   certificate.
        This renders the message unverifiable, as the public key\n   in the certificate
        no longer matches the private key used to sign the\n   message.\n   The second
        version is a substitution of one valid certificate for the\n   original valid
        certificate where the public keys in the certificates\n   match.  This allows
        the signature to be validated under potentially\n   different certificate
        constraints than the originator of the message\n   intended.\n"
      title: 5.1.1 Substitution Attack Description
    - contents:
      - "5.1.2 Reissue of Certificate Description\n   The second attack deals with
        a certificate authority (CA) re-issuing\n   the signing certificate (or potentially
        one of its certificates).\n   This attack may start becoming more frequent
        as Certificate\n   Authorities reissue their own root certificates, or as
        certificate\n   authorities change policies in the certificate while reissuing
        their\n   root certificates. This problem also occurs when cross certificates\n
        \  (with potentially different restrictions) are used in the process of\n
        \  verifying a signature.\n"
      title: 5.1.2 Reissue of Certificate Description
    - contents:
      - "5.1.3 Rogue Duplicate CA Description\n   The third attack deals with a rogue
        entity setting up a certificate\n   authority that attempts to duplicate the
        structure of an existing CA.\n   Specifically, the rogue entity issues a new
        certificate with the same\n   public keys as the signer used, but signed by
        the rogue entity's\n   private key.\n"
      title: 5.1.3 Rogue Duplicate CA Description
    title: 5.1. Attack Descriptions
  - contents:
    - "5.2 Attack Responses\n   This document does not attempt to solve all of the
      above attacks;\n   however, a brief description of responses to each of the
      attacks is\n   given in this section.\n"
    - contents:
      - "5.2.1 Substitution Attack Response\n   The denial of service attack cannot
        be prevented. After the\n   certificate identifier has been modified in transit,
        no verification\n   of the signature is possible. There is also no way to
        automatically\n   identify the attack because it is indistinguishable from
        a message\n   corruption.\n   The substitution of a valid certificate can
        be responded to in two\n   different manners. The first is to make a blanket
        statement that the\n   use of the same public key in two different certificates
        is bad\n   practice and has to be avoided. In practice, there is no practical\n
        \  way to prevent users from getting new certificates with the same\n   public
        keys, and it should be assumed that they will do this. Section\n   5.4 provides
        a new attribute that can be included in the SignerInfo\n   signed attributes.
        This binds the correct certificate identifier into\n   the signature. This
        will convert the attack from a potentially\n   successful one to simply a
        denial of service attack.\n"
      title: 5.2.1 Substitution Attack Response
    - contents:
      - "5.2.2 Reissue of Certificate Response\n   A CA should never reissue a certificate
        with different attributes.\n   Certificate Authorities that do so are following
        poor practices and\n   cannot be relied on. Using the hash of the certificate
        as the\n   reference to the certificate prevents this attack for end-entity\n
        \  certificates.\n   Preventing the attack based on reissuing of CA certificates
        would\n   require a substantial change to the usage of the signingCertificate\n
        \  attribute presented in section 5.4. It would require that ESSCertIDs\n
        \  would need to be included in the attribute to represent the issuer\n   certificates
        in the signer's certification path. This presents\n   problems when the relying
        party is using a cross-certificate as part\n   of its authentication process,
        and this certificate does not appear\n   on the list of certificates. The
        problems outside of a closed PKI\n   make the addition of this information
        prone to error, possibly\n   causing the rejection of valid chains.\n"
      title: 5.2.2 Reissue of Certificate Response
    - contents:
      - "5.2.3 Rogue Duplicate CA Response\n   The best method of preventing this
        attack is to avoid trusting the\n   rogue CA. The use of the hash to identify
        certificates prevents the\n   use of end-entity certificates from the rogue
        authority. However the\n   only true way to prevent this attack is to never
        trust the rogue CA.\n"
      title: 5.2.3 Rogue Duplicate CA Response
    title: 5.2 Attack Responses
  - contents:
    - "5.3 Related Signature Verification Context\n   Some applications require that
      additional information be used as part\n   of the signature validation process.
      In particular, authorization\n   information from attribute certificates and
      other public key\n   certificates or policy identifiers provide additional information\n
      \  about the abilities and intent of the signer. The signing certificate\n   attribute
      described in Section 5.4 provides the ability to bind this\n   context information
      as part of the signature.\n"
    - contents:
      - "5.3.1 Authorization Information\n   Some applications require that authorization
        information found in\n   attribute certificates and/or other public key certificates
        be\n   validated. This validation requires that the application be able to\n
        \  find the correct certificates to perform the verification process;\n   however
        there is no list of the certificates to used in a SignerInfo\n   object. The
        sender has the ability to include a set of attribute\n   certificates and
        public key certificates in a SignedData object. The\n   receiver has the ability
        to retrieve attribute certificates and\n   public key certificates from a
        directory service. There are some\n   circumstances where the signer may wish
        to limit the set of\n   certificates that may be used in verifying a signature.
        It is useful\n   to be able to list the set of certificates the signer wants
        the\n   recipient to use in validating the signature.\n"
      title: 5.3.1 Authorization Information
    - contents:
      - "5.3.2 Policy Information\n   A related aspect of the certificate binding
        is the issue of multiple\n   certification paths. In some instances, the semantics
        of a\n   certificate in its use with a message may depend on the Certificate\n
        \  Authorities and policies that apply. To address this issue, the\n   signer
        may also wish to bind that context under the signature. While\n   this could
        be done by either signing the complete certification path\n   or a policy
        ID, only a binding for the policy ID is described here.\n"
      title: 5.3.2 Policy Information
    title: 5.3 Related Signature Verification Context
  - contents:
    - "5.4 Signing Certificate Attribute Definition\n   The signing certificate attribute
      is designed to prevent the simple\n   substitution and re-issue attacks, and
      to allow for a restricted set\n   of authorization certificates to be used in
      verifying a signature.\n   The definition of SigningCertificate is\n   SigningCertificate
      ::=  SEQUENCE {\n       certs        SEQUENCE OF ESSCertID,\n       policies
      \    SEQUENCE OF PolicyInformation OPTIONAL\n   }\n   id-aa-signingCertificate
      OBJECT IDENTIFIER ::= { iso(1)\n       member-body(2) us(840) rsadsi(113549)
      pkcs(1) pkcs9(9)\n       smime(16) id-aa(2) 12 }\n   The first certificate identified
      in the sequence of certificate\n   identifiers MUST be the certificate used
      to verify the signature. The\n   encoding of the ESSCertID for this certificate
      SHOULD include the\n   issuerSerial field. If other constraints ensure that\n
      \  issuerAndSerialNumber will be present in the SignerInfo, the\n   issuerSerial
      field MAY be omitted. The certificate identified is used\n   during the signature
      verification process. If the hash of the\n   certificate does not match the
      certificate used to verify the\n   signature, the signature MUST be considered
      invalid.\n   If more than one certificate is present in the sequence of\n   ESSCertIDs,
      the certificates after the first one limit the set of\n   authorization certificates
      that are used during signature validation.\n   Authorization certificates can
      be either attribute certificates or\n   normal certificates. The issuerSerial
      field (in the ESSCertID\n   structure) SHOULD be present for these certificates,
      unless the\n   client who is validating the signature is expected to have easy\n
      \  access to all the certificates requred for validation. If only the\n   signing
      certificate is present in the sequence, there are no\n   restrictions on the
      set of authorization certificates used in\n   validating the signature.\n   The
      sequence of policy information terms identifies those certificate\n   policies
      that the signer asserts apply to the certificate, and under\n   which the certificate
      should be relied upon. This value suggests a\n   policy value to be used in
      the relying party's certification path\n   validation.\n   If present, the SigningCertificate
      attribute MUST be a signed\n   attribute; it MUST NOT be an unsigned attribute.
      CMS defines\n   SignedAttributes as a SET OF Attribute. A SignerInfo MUST NOT
      include\n   multiple instances of the SigningCertificate attribute. CMS defines\n
      \  the ASN.1 syntax for the signed attributes to include attrValues SET\n   OF
      AttributeValue. A SigningCertificate attribute MUST include only a\n   single
      instance of AttributeValue. There MUST NOT be zero or multiple\n   instances
      of AttributeValue present in the attrValues SET OF\n   AttributeValue.\n"
    - contents:
      - "5.4.1 Certificate Identification\n   The best way to identify certificates
        is an often-discussed issue.\n   [CERT] has imposed a restriction for SignedData
        objects that the\n   issuer DN must be present in all signing certificates.
        The\n   issuer/serial number pair is therefore sufficient to identify the\n
        \  correct signing certificate. This information is already present, as\n
        \  part of the SignerInfo object, and duplication of this information\n   would
        be unfortunate. A hash of the entire certificate serves the\n   same function
        (allowing the receiver to verify that the same\n   certificate is being used
        as when the message was signed), is\n   smaller, and permits a detection of
        the simple substitution attacks.\n   Attribute certificates and additional
        public key certificates\n   containing authorization information do not have
        an issuer/serial\n   number pair represented anywhere in a SignerInfo object.
        When an\n   attribute certificate or an additional public key certificate
        is not\n   included in the SignedData object, it becomes much more difficult
        to\n   get the correct set of certificates based only on a hash of the\n   certificate.
        For this reason, these certificates SHOULD be identified\n   by the IssuerSerial
        object.\n   This document defines a certificate identifier as:\n   ESSCertID
        ::=  SEQUENCE {\n        certHash                 Hash,\n        issuerSerial
        \            IssuerSerial OPTIONAL\n   }\n   Hash ::= OCTET STRING -- SHA1
        hash of entire certificate\n   IssuerSerial ::= SEQUENCE {\n        issuer
        \                  GeneralNames,\n        serialNumber             CertificateSerialNumber\n
        \  }\n   When creating an ESSCertID, the certHash is computed over the entire\n
        \  DER encoded certificate including the signature. The issuerSerial\n   would
        normally be present unless the value can be inferred from other\n   information.\n
        \  When encoding IssuerSerial, serialNumber is the serial number that\n   uniquely
        identifies the certificate. For non-attribute certificates,\n   the issuer
        MUST contain only the issuer name from the certificate\n   encoded in the
        directoryName choice of GeneralNames. For attribute\n   certificates, the
        issuer MUST contain the issuer name field from the\n   attribute certificate.\n"
      title: 5.4.1 Certificate Identification
    title: 5.4 Signing Certificate Attribute Definition
  title: 5. Signing Certificate Attribute
- contents:
  - "6. Security Considerations\n   All security considerations from [CMS] and [SMIME3]
    apply to\n   applications that use procedures described in this document.\n   As
    stated in Section 2.3, a recipient of a receipt request must not\n   send back
    a reply if it cannot validate the signature. Similarly, if\n   there conflicting
    receipt requests in a message, the recipient must\n   not send back receipts,
    since an attacker may have inserted the\n   conflicting request.  Sending a signed
    receipt to an unvalidated\n   sender can expose information about the recipient
    that it may not\n   want to expose to unknown senders.\n   Senders of receipts
    should consider encrypting the receipts to\n   prevent a passive attacker from
    gleaning information in the receipts.\n   Senders must not rely on recipients'
    processing software to correctly\n   process security labels. That is, the sender
    cannot assume that\n   adding a security label to a message will prevent recipients
    from\n   viewing messages the sender doesn't want them to view. It is expected\n
    \  that there will be many S/MIME clients that will not understand\n   security
    labels but will still display a labelled message to a\n   recipient.\n   A receiving
    agent that processes security labels must handle the\n   content of the messages
    carefully. If the agent decides not to show\n   the message to the intended recipient
    after processing the security\n   label, the agent must take care that the recipient
    does not\n   accidentally see the content at a later time. For example, if an\n
    \  error response sent to the originator contains the content that was\n   hidden
    from the recipient, and that error response bounces back to\n   the sender due
    to addressing errors, the original recipient can\n   possibly see the content
    since it is unlikely that the bounce message\n   will have the proper security
    labels.\n   A man-in-the-middle attack can cause a recipient to send receipts
    to\n   an attacker if that attacker has a signature that can be validated by\n
    \  the recipient. The attack consists of intercepting the original\n   message
    and adding a mLData attribute that says that a receipt should\n   be sent to the
    attacker in addition to whoever else was going to get\n   the receipt.\n   Mailing
    lists that encrypt their content may be targets for denial-\n   of-service attacks
    if they do not use the mailing list management\n   described in Section 4. Using
    simple RFC822 header spoofing, it is\n   quite easy to subscribe one encrypted
    mailing list to another,\n   thereby setting up an infinite loop.\n   Mailing
    List Agents need to be aware that they can be used as oracles\n   for the the
    adaptive chosen ciphertext attack described in [CMS].\n   MLAs should notify an
    administrator if a large number of\n   undecryptable messages are received.\n
    \  When verifying a signature using certificates that come with a [CMS]\n   message,
    the recipient should only verify using certificates\n   previously known to be
    valid, or certificates that have come from a\n   signed SigningCertificate attribute.
    Otherwise, the attacks described\n   in Section 5 can cause the receiver to possibly
    think a signature is\n   valid when it is not.\n"
  title: 6. Security Considerations
- contents:
  - 'A. ASN.1 Module

    '
  - "ExtendedSecurityServices\n     { iso(1) member-body(2) us(840) rsadsi(113549)\n
    \      pkcs(1) pkcs-9(9) smime(16) modules(0) ess(2) }\n"
  - 'DEFINITIONS IMPLICIT TAGS ::=

    '
  - 'BEGIN

    '
  - 'IMPORTS

    '
  - "-- Cryptographic Message Syntax (CMS)\n    ContentType, IssuerAndSerialNumber,
    SubjectKeyIdentifier\n    FROM CryptographicMessageSyntax { iso(1) member-body(2)
    us(840)\n    rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) modules(0) cms(1)}\n"
  - '-- PKIX Certificate and CRL Profile, Sec A.2 Implicitly Tagged Module,

    '
  - "--  1988 Syntax\n    PolicyInformation FROM PKIX1Implicit88 {iso(1)\n    identified-organization(3)
    dod(6) internet(1) security(5)\n    mechanisms(5) pkix(7)id-mod(0) id-pkix1-implicit-88(2)}\n"
  - "-- X.509\n    GeneralNames, CertificateSerialNumber FROM CertificateExtensions\n
    \   {joint-iso-ccitt ds(5) module(1) certificateExtensions(26) 0};\n"
  - '-- Extended Security Services

    '
  - '-- The construct "SEQUENCE SIZE (1..MAX) OF" appears in several ASN.1

    '
  - '-- constructs in this module. A valid ASN.1 SEQUENCE can have zero or

    '
  - '-- more entries. The SIZE (1..MAX) construct constrains the SEQUENCE to

    '
  - '-- have at least one entry. MAX indicates the upper bound is unspecified.

    '
  - '-- Implementations are free to choose an upper bound that suits their

    '
  - '-- environment.

    '
  - "UTF8String ::= [UNIVERSAL 12] IMPLICIT OCTET STRING\n    -- The contents are
    formatted as described in [UTF8]\n"
  - '-- Section 2.7

    '
  - "ReceiptRequest ::= SEQUENCE {\n  signedContentIdentifier ContentIdentifier,\n
    \ receiptsFrom ReceiptsFrom,\n  receiptsTo SEQUENCE SIZE (1..ub-receiptsTo) OF
    GeneralNames }\n"
  - 'ub-receiptsTo INTEGER ::= 16

    '
  - "id-aa-receiptRequest OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n    us(840)
    rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) id-aa(2) 1}\n"
  - 'ContentIdentifier ::= OCTET STRING

    '
  - "id-aa-contentIdentifier OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n    us(840)
    rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) id-aa(2) 7}\n"
  - "ReceiptsFrom ::= CHOICE {\n  allOrFirstTier [0] AllOrFirstTier,\n  -- formerly
    \"allOrNone [0]AllOrNone\"\n  receiptList [1] SEQUENCE OF GeneralNames }\n"
  - "AllOrFirstTier ::= INTEGER { -- Formerly AllOrNone\n  allReceipts (0),\n  firstTierRecipients
    (1) }\n"
  - '-- Section 2.8

    '
  - "Receipt ::= SEQUENCE {\n  version ESSVersion,\n  contentType ContentType,\n  signedContentIdentifier
    ContentIdentifier,\n  originatorSignatureValue OCTET STRING }\n"
  - "id-ct-receipt OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840)\n   rsadsi(113549)
    pkcs(1) pkcs-9(9) smime(16) id-ct(1) 1}\n"
  - 'ESSVersion ::= INTEGER  { v1(1) }

    '
  - '-- Section 2.9

    '
  - "ContentHints ::= SEQUENCE {\n  contentDescription UTF8String (SIZE (1..MAX))
    OPTIONAL,\n  contentType ContentType }\n"
  - "id-aa-contentHint OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840)\n    rsadsi(113549)
    pkcs(1) pkcs-9(9) smime(16) id-aa(2) 4}\n"
  - '-- Section 2.10

    '
  - 'MsgSigDigest ::= OCTET STRING

    '
  - "id-aa-msgSigDigest OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n    us(840)
    rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) id-aa(2) 5}\n"
  - '-- Section 2.11

    '
  - "ContentReference ::= SEQUENCE {\n  contentType ContentType,\n  signedContentIdentifier
    ContentIdentifier,\n  originatorSignatureValue OCTET STRING }\n"
  - "id-aa-contentReference   OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n    us(840)
    rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) id-aa(2) 10 }\n"
  - '-- Section 3.2

    '
  - "ESSSecurityLabel ::= SET {\n  security-policy-identifier SecurityPolicyIdentifier,\n
    \ security-classification SecurityClassification OPTIONAL,\n  privacy-mark ESSPrivacyMark
    OPTIONAL,\n  security-categories SecurityCategories OPTIONAL }\n"
  - "id-aa-securityLabel OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n    us(840)
    rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) id-aa(2) 2}\n"
  - 'SecurityPolicyIdentifier ::= OBJECT IDENTIFIER

    '
  - "SecurityClassification ::= INTEGER {\n  unmarked (0),\n  unclassified (1),\n
    \ restricted (2),\n  confidential (3),\n  secret (4),\n  top-secret (5) } (0..ub-integer-options)\n"
  - 'ub-integer-options INTEGER ::= 256

    '
  - "ESSPrivacyMark ::= CHOICE {\n    pString      PrintableString (SIZE (1..ub-privacy-mark-length)),\n
    \   utf8String   UTF8String (SIZE (1..MAX))\n"
  - '}

    '
  - 'ub-privacy-mark-length INTEGER ::= 128

    '
  - "SecurityCategories ::= SET SIZE (1..ub-security-categories) OF\n        SecurityCategory\n"
  - 'ub-security-categories INTEGER ::= 64

    '
  - "SecurityCategory ::= SEQUENCE {\n  type  [0] OBJECT IDENTIFIER,\n  value [1]
    ANY DEFINED BY type -- defined by type\n"
  - '}

    '
  - '--Note: The aforementioned SecurityCategory syntax produces identical

    '
  - '--hex encodings as the following SecurityCategory syntax that is

    '
  - '--documented in the X.411 specification:

    '
  - '--

    '
  - '--SecurityCategory ::= SEQUENCE {

    '
  - '--     type  [0]  SECURITY-CATEGORY,

    '
  - '--     value [1]  ANY DEFINED BY type }

    '
  - '--

    '
  - '--SECURITY-CATEGORY MACRO ::=

    '
  - '--BEGIN

    '
  - '--TYPE NOTATION ::= type | empty

    '
  - '--VALUE NOTATION ::= value (VALUE OBJECT IDENTIFIER)

    '
  - '--END

    '
  - '-- Section 3.4

    '
  - 'EquivalentLabels ::= SEQUENCE OF ESSSecurityLabel

    '
  - "id-aa-equivalentLabels OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n    us(840)
    rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) id-aa(2) 9}\n"
  - '-- Section 4.4

    '
  - "MLExpansionHistory ::= SEQUENCE\n        SIZE (1..ub-ml-expansion-history) OF
    MLData\n"
  - "id-aa-mlExpandHistory OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n    us(840)
    rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) id-aa(2) 3}\n"
  - 'ub-ml-expansion-history INTEGER ::= 64

    '
  - "MLData ::= SEQUENCE {\n  mailListIdentifier EntityIdentifier,\n  expansionTime
    GeneralizedTime,\n  mlReceiptPolicy MLReceiptPolicy OPTIONAL }\n"
  - "EntityIdentifier ::= CHOICE {\n  issuerAndSerialNumber IssuerAndSerialNumber,\n
    \ subjectKeyIdentifier SubjectKeyIdentifier }\n"
  - "MLReceiptPolicy ::= CHOICE {\n  none [0] NULL,\n  insteadOf [1] SEQUENCE SIZE
    (1..MAX) OF GeneralNames,\n  inAdditionTo [2] SEQUENCE SIZE (1..MAX) OF GeneralNames
    }\n"
  - '-- Section 5.4

    '
  - "SigningCertificate ::=  SEQUENCE {\n    certs        SEQUENCE OF ESSCertID,\n
    \   policies     SEQUENCE OF PolicyInformation OPTIONAL\n"
  - '}

    '
  - "id-aa-signingCertificate OBJECT IDENTIFIER ::= { iso(1)\n    member-body(2) us(840)
    rsadsi(113549) pkcs(1) pkcs9(9)\n    smime(16) id-aa(2) 12 }\n"
  - "ESSCertID ::=  SEQUENCE {\n     certHash                 Hash,\n     issuerSerial
    \            IssuerSerial OPTIONAL\n"
  - '}

    '
  - 'Hash ::= OCTET STRING -- SHA1 hash of entire certificate

    '
  - "IssuerSerial ::= SEQUENCE {\n     issuer                   GeneralNames,\n     serialNumber
    \            CertificateSerialNumber\n"
  - '}

    '
  - 'END -- of ExtendedSecurityServices

    '
  title: A. ASN.1 Module
- contents:
  - "B. References\n   [ASN1-1988]  \"Recommendation X.208: Specification of Abstract
    Syntax\n                Notation One (ASN.1)\".\n   [ASN1-1994]  \"Recommendation
    X.680: Specification of Abstract Syntax\n                Notation One (ASN.1)\".\n
    \  [CERT]       Ramsdell, B., Editor, \"S/MIME Version 3 Certificate\n                Handling\",
    RFC 2632, June 1999.\n   [CMS]        Housley, R., \"Cryptographic Message Syntax\",
    RFC 2630,\n                June 1999.\n   [MSG]        Ramsdell, B., Editor, \"S/MIME
    Version 3 Message\n                Specification\", RFC 2633, June 1999.\n   [MUSTSHOULD]
    Bradner, S., \"Key Words for Use in RFCs to Indicate\n                Requirement
    Levels\", BCP 14, RFC 2119, March 1997.\n   [MSP4]       \"Secure Data Network
    System (SDNS) Message Security\n                Protocol (MSP) 4.0\", Specification
    SDN.701, Revision A,\n                1997-02-06.\n   [MTSABS]     \"1988 International
    Telecommunication Union (ITU) Data\n                Communication Networks Message
    Handling Systems: Message\n                Transfer System:  Abstract Service
    Definition and\n                Procedures, Volume VIII, Fascicle VIII.7, Recommendation\n
    \               X.411\"; MTSAbstractService {joint-iso-ccitt mhs-motis(6)\n                mts(3)
    modules(0) mts-abstract-service(1)}\n   [PKCS7-1.5]  Kaliski, B., \"PKCS #7: Cryptographic
    Message Syntax\",\n                RFC 2315, March 1998.\n   [SMIME2]     Dusse,
    S., Hoffman, P., Ramsdell, B., Lundblade, L. and\n                L.  Repka\"S/MIME
    Version 2 Message Specification\", RFC\n                2311, March 1998, and
    Dusse, S., Hoffman, P. and B.\n                Ramsdell,\"S/MIME Version 2 Certificate
    Handling\", RFC\n                2312, March 1998.\n   [UTF8]       Yergeau, F.,
    \"UTF-8, a transformation format of ISO\n                10646\", RFC 2279, January
    1998.\n"
  title: B. References
- contents:
  - "C. Acknowledgments\n   The first draft of this work was prepared by David Solo.
    John Pawling\n   did a huge amount of very detailed revision work during the many\n
    \  phases of the document.\n   Many other people have contributed hard work to
    this memo, including:\n   Andrew Farrell\n   Bancroft Scott\n   Bengt Ackzell\n
    \  Bill Flanigan\n   Blake Ramsdell\n   Carlisle Adams\n   Darren Harter\n   David
    Kemp\n   Denis Pinkas\n   Francois Rousseau\n   Jim Schaad\n   Russ Housley\n
    \  Scott Hollenbeck\n   Steve Dusse\n"
  title: C. Acknowledgments
- contents:
  - "Editor's Address\n   Paul Hoffman\n   Internet Mail Consortium\n   127 Segre
    Place\n   Santa Cruz, CA  95060\n   EMail: phoffman@imc.org\n"
  title: Editor's Address
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (1999).  All
    Rights Reserved.\n   This document and translations of it may be copied and furnished
    to\n   others, and derivative works that comment on or otherwise explain it\n
    \  or assist in its implementation may be prepared, copied, published\n   and
    distributed, in whole or in part, without restriction of any\n   kind, provided
    that the above copyright notice and this paragraph are\n   included on all such
    copies and derivative works.  However, this\n   document itself may not be modified
    in any way, such as by removing\n   the copyright notice or references to the
    Internet Society or other\n   Internet organizations, except as needed for the
    purpose of\n   developing Internet standards in which case the procedures for\n
    \  copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
