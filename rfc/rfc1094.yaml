- title: __initial_text__
  contents:
  - '            NFS: Network File System Protocol Specification

    '
- title: STATUS OF THIS MEMO
  contents:
  - "STATUS OF THIS MEMO\n   This RFC describes a protocol that Sun Microsystems,\
    \ Inc., and others\n   are using.  A new version of the protocol is under development,\
    \ but\n   others may benefit from the descriptions of the current protocol, and\n\
    \   discussion of some of the design issues.  Distribution of this memo\n   is\
    \ unlimited.\n"
- title: 1. INTRODUCTION
  contents:
  - "1. INTRODUCTION\n   The Sun Network Filesystem (NFS) protocol provides transparent\
    \ remote\n   access to shared files across networks.  The NFS protocol is designed\n\
    \   to be portable across different machines, operating systems, network\n   architectures,\
    \ and transport protocols.  This portability is achieved\n   through the use of\
    \ Remote Procedure Call (RPC) primitives built on\n   top of an eXternal Data\
    \ Representation (XDR).  Implementations\n   already exist for a variety of machines,\
    \ from personal computers to\n   supercomputers.\n   The supporting mount protocol\
    \ allows the server to hand out remote\n   access privileges to a restricted set\
    \ of clients.  It performs the\n   operating system-specific functions that allow,\
    \ for example, to\n   attach remote directory trees to some local file system.\n"
- title: 1.1.  Remote Procedure Call
  contents:
  - "1.1.  Remote Procedure Call\n   Sun's Remote Procedure Call specification provides\
    \ a procedure-\n   oriented interface to remote services.  Each server supplies\
    \ a\n   \"program\" that is a set of procedures.  NFS is one such program.  The\n\
    \   combination of host address, program number, and procedure number\n   specifies\
    \ one remote procedure.  A goal of NFS was to not require any\n   specific level\
    \ of reliability from its lower levels, so it could\n   potentially be used on\
    \ many underlying transport protocols, or even\n   another remote procedure call\
    \ implementation.  For ease of\n   discussion, the rest of this document will\
    \ assume NFS is implemented\n   on top of Sun RPC, described in  RFC 1057, \"\
    RPC: Remote Procedure\n   Call Protocol Specification\".\n"
- title: 1.2.  External Data Representation
  contents:
  - "1.2.  External Data Representation\n   The eXternal Data Representation (XDR)\
    \ standard provides a common way\n   of representing a set of data types over\
    \ a network.  The NFS Protocol\n   Specification is written using the RPC data\
    \ description language.\n   For more information, see RFC 1014, \"XDR: External\
    \ Data\n   Representation Standard\".  Although automated RPC/XDR compilers exist\n\
    \   to generate server and client \"stubs\", NFS does not require their\n   use.\
    \  Any software that provides equivalent functionality can be\n   used, and if\
    \ the encoding is exactly the same it can interoperate\n   with other implementations\
    \ of NFS.\n"
- title: 1.3.  Stateless Servers
  contents:
  - "1.3.  Stateless Servers\n   The NFS protocol was intended to be as stateless\
    \ as possible.  That\n   is, a server should not need to maintain any protocol\
    \ state\n   information about any of its clients in order to function correctly.\n\
    \   Stateless servers have a distinct advantage over stateful servers in\n   the\
    \ event of a failure.  With stateless servers, a client need only\n   retry a\
    \ request until the server responds; it does not even need to\n   know that the\
    \ server has crashed, or the network temporarily went\n   down.  The client of\
    \ a stateful server, on the other hand, needs to\n   either detect a server failure\
    \ and rebuild the server's state when it\n   comes back up, or cause client operations\
    \ to fail.\n   This may not sound like an important issue, but it affects the\n\
    \   protocol in some unexpected ways.  We feel that it may be worth a bit\n  \
    \ of extra complexity in the protocol to be able to write very simple\n   servers\
    \ that do not require fancy crash recovery.  Note that even if\n   a so-called\
    \ \"reliable\" transport protocol such as TCP is used, the\n   client must still\
    \ be able to handle interruptions of service by re-\n   opening connections when\
    \ they time out.  Thus, a stateless protocol\n   may actually simplify the  implementation.\n\
    \   On the other hand, NFS deals with objects such as files and\n   directories\
    \ that inherently have state -- what good would a file be\n   if it did not keep\
    \ its contents intact?  The goal was to not\n   introduce any extra state in the\
    \ protocol itself.  Inherently\n   stateful operations such as file or record\
    \ locking, and remote\n   execution,  were implemented as separate services, not\
    \ described in\n   this document.\n   The basic way to simplify recovery was to\
    \ make operations as\n   \"idempotent\" as possible (so that they can potentially\
    \ be repeated).\n   Some operations in this version of the protocol did not attain\
    \ this\n   goal; luckily most of the operations (such as Read and Write) are\n\
    \   idempotent.  Also, most server failures occur between operations, not\n  \
    \ between the receipt of an operation and the response.  Finally,\n   although\
    \ actual server failures may be rare, in complex networks,\n   failures of any\
    \ network, router, or bridge may be indistinguishable\n   from a server failure.\n"
- title: 2. NFS PROTOCOL DEFINITION
  contents:
  - "2. NFS PROTOCOL DEFINITION\n   Servers change over time, and so can the protocol\
    \ that they use.  RPC\n   provides a version number with each RPC request.  This\
    \ RFC describes\n   version two of the NFS protocol.  Even in the second version,\
    \ there\n   are a few obsolete procedures and parameters, which will be removed\n\
    \   in later versions.  An RFC for version three of the NFS protocol is\n   currently\
    \ under preparation.\n"
- title: 2.1.  File System Model
  contents:
  - "2.1.  File System Model\n   NFS assumes a file system that is hierarchical, with\
    \ directories as\n   all but the bottom level of files.  Each entry in a directory\
    \ (file,\n   directory, device, etc.) has a string name.  Different operating\n\
    \   systems may have restrictions on the depth of the tree or the names\n   used,\
    \ as well as using different syntax to represent the \"pathname\",\n   which is\
    \ the concatenation of all the \"components\" (directory and\n   file names) in\
    \ the name.  A \"file system\" is a tree on a single\n   server (usually a single\
    \ disk or physical partition) with a specified\n   \"root\".  Some operating systems\
    \ provide a \"mount\" operation to make\n   all file systems appear as a single\
    \ tree, while others maintain a\n   \"forest\" of file systems.  Files are unstructured\
    \ streams of\n   uninterpreted bytes.  Version 3 of NFS uses slightly more general\n\
    \   file system model.\n   NFS looks up one component of a pathname at a time.\
    \  It may not be\n   obvious why it does not just take the whole pathname, traipse\
    \ down\n   the directories, and return a file handle when it is done.  There are\n\
    \   several good reasons not to do this.  First, pathnames need\n   separators\
    \ between the directory components, and different operating\n   systems use different\
    \ separators.  We could define a Network Standard\n   Pathname Representation,\
    \ but then every pathname would have to be\n   parsed and converted at each end.\
    \  Other issues are discussed in\n   section 3, NFS Implementation Issues.\n \
    \  Although files and directories are similar objects in many ways,\n   different\
    \ procedures are used to read directories and files.  This\n   provides a network\
    \ standard format for representing directories.  The\n   same argument as above\
    \ could have been used to justify a procedure\n   that returns only one directory\
    \ entry per call.  The problem is\n   efficiency.  Directories can contain many\
    \ entries, and a remote call\n   to return each would be just too slow.\n"
- title: 2.2.  Server Procedures
  contents:
  - "2.2.  Server Procedures\n   The protocol definition is given as a set of procedures\
    \ with\n   arguments and results defined using the RPC language (XDR language\n\
    \   extended with program, version, and procedure declarations).  A brief\n  \
    \ description of the function of each procedure should provide enough\n   information\
    \ to allow implementation.  Section 2.3 describes the basic\n   data types in\
    \ more detail.\n   All of the procedures in the NFS protocol are assumed to be\n\
    \   synchronous.  When a procedure returns to the client, the client can\n   assume\
    \ that the operation has completed and any data associated with\n   the request\
    \ is now on stable storage.  For example, a client WRITE\n   request may cause\
    \ the server to update data blocks, filesystem\n   information blocks (such as\
    \ indirect blocks), and file attribute\n   information (size and modify times).\
    \  When the WRITE returns to the\n   client, it can assume that the write is safe,\
    \ even in case of a\n   server crash, and it can discard the data written.  This\
    \ is a very\n   important part of the statelessness of the server.  If the server\n\
    \   waited to flush data from remote requests, the client would have to\n   save\
    \ those requests so that it could resend them in case of a server\n   crash.\n\
    \           /*\n            * Remote file service routines\n            */\n \
    \          program NFS_PROGRAM {\n                   version NFS_VERSION {\n \
    \                          void\n                           NFSPROC_NULL(void)\
    \              = 0;\n                           attrstat\n                   \
    \        NFSPROC_GETATTR(fhandle)        = 1;\n                           attrstat\n\
    \                           NFSPROC_SETATTR(sattrargs)      = 2;\n           \
    \                void\n                           NFSPROC_ROOT(void)         \
    \     = 3;\n                           diropres\n                           NFSPROC_LOOKUP(diropargs)\
    \       = 4;\n                           readlinkres\n                       \
    \    NFSPROC_READLINK(fhandle)       = 5;\n                           readres\n\
    \                           NFSPROC_READ(readargs)          = 6;\n           \
    \                void\n                           NFSPROC_WRITECACHE(void)   \
    \     = 7;\n                           attrstat\n                           NFSPROC_WRITE(writeargs)\
    \        = 8;\n                           diropres\n                         \
    \  NFSPROC_CREATE(createargs)      = 9;\n                           stat\n   \
    \                        NFSPROC_REMOVE(diropargs)       = 10;\n             \
    \              stat\n                           NFSPROC_RENAME(renameargs)   \
    \   = 11;\n                           stat\n                           NFSPROC_LINK(linkargs)\
    \          = 12;\n                           stat\n                          \
    \ NFSPROC_SYMLINK(symlinkargs)    = 13;\n                           diropres\n\
    \                           NFSPROC_MKDIR(createargs)       = 14;\n          \
    \                 stat\n                           NFSPROC_RMDIR(diropargs)  \
    \      = 15;\n                           readdirres\n                        \
    \   NFSPROC_READDIR(readdirargs)    = 16;\n                           statfsres\n\
    \                           NFSPROC_STATFS(fhandle)         = 17;\n          \
    \         } = 2;\n           } = 100003;\n"
- title: 2.2.1.  Do Nothing
  contents:
  - "2.2.1.  Do Nothing\n           void\n           NFSPROC_NULL(void) = 0;\n   This\
    \ procedure does no work.  It is made available in all RPC\n   services to allow\
    \ server response testing and timing.\n"
- title: 2.2.2.  Get File Attributes
  contents:
  - "2.2.2.  Get File Attributes\n           attrstat\n           NFSPROC_GETATTR\
    \ (fhandle) = 1;\n   If the reply status is NFS_OK, then the reply attributes\
    \ contains the\n   attributes for the file given by the input fhandle.\n"
- title: 2.2.3.  Set File Attributes
  contents:
  - "2.2.3.  Set File Attributes\n           struct sattrargs {\n                \
    \   fhandle file;\n                   sattr attributes;\n           };\n     \
    \      attrstat\n           NFSPROC_SETATTR (sattrargs) = 2;\n   The \"attributes\"\
    \ argument contains fields which are either -1 or are\n   the new value for the\
    \ attributes of \"file\".  If the reply status is\n   NFS_OK, then the reply attributes\
    \ have the attributes of the file\n   after the \"SETATTR\" operation has completed.\n\
    \   Notes:  The use of -1 to indicate an unused field in \"attributes\" is\n \
    \  changed in the next version of the protocol.\n"
- title: 2.2.4.  Get Filesystem Root
  contents:
  - "2.2.4.  Get Filesystem Root\n           void\n           NFSPROC_ROOT(void) =\
    \ 3;\n   Obsolete.  This procedure is no longer used because finding the root\n\
    \   file handle of a filesystem requires moving pathnames between client\n   and\
    \ server.  To do this right, we would have to define a network\n   standard representation\
    \ of pathnames.  Instead, the function of\n   looking up the root file handle\
    \ is done by the MNTPROC_MNT procedure.\n   (See Appendix A, \"Mount Protocol\
    \ Definition\", for details).\n"
- title: 2.2.5.  Look Up File Name
  contents:
  - "2.2.5.  Look Up File Name\n           diropres\n           NFSPROC_LOOKUP(diropargs)\
    \ = 4;\n   If the reply \"status\" is NFS_OK, then the reply \"file\" and reply\n\
    \   \"attributes\" are the file handle and attributes for the file \"name\"\n\
    \   in the directory given by \"dir\" in the argument.\n"
- title: 2.2.6.  Read From Symbolic Link
  contents:
  - "2.2.6.  Read From Symbolic Link\n           union readlinkres switch (stat status)\
    \ {\n           case NFS_OK:\n               path data;\n           default:\n\
    \               void;\n           };\n           readlinkres\n           NFSPROC_READLINK(fhandle)\
    \ = 5;\n   If \"status\" has the value NFS_OK, then the reply \"data\" is the\
    \ data\n   in the symbolic link given by the file referred to by the fhandle\n\
    \   argument.\n   Notes:  Since NFS always parses pathnames on the client, the\
    \ pathname\n   in a symbolic link may mean something different (or be meaningless)\n\
    \   on a different client or on the server if a different pathname syntax\n  \
    \ is used.\n"
- title: 2.2.7.  Read From File
  contents:
  - "2.2.7.  Read From File\n           struct readargs {\n                   fhandle\
    \ file;\n                   unsigned offset;\n                   unsigned count;\n\
    \                   unsigned totalcount;\n           };\n           union readres\
    \ switch (stat status) {\n           case NFS_OK:\n                   fattr attributes;\n\
    \                   nfsdata data;\n           default:\n                   void;\n\
    \           };\n           readres\n           NFSPROC_READ(readargs) = 6;\n \
    \  Returns up to \"count\" bytes of \"data\" from the file given by \"file\",\n\
    \   starting at \"offset\" bytes from the beginning of the file.  The first\n\
    \   byte of the file is at offset zero.  The file attributes after the\n   read\
    \ takes place are returned in \"attributes\".\n   Notes:  The argument \"totalcount\"\
    \ is unused, and is removed in the\n   next protocol revision.\n"
- title: 2.2.8.  Write to Cache
  contents:
  - "2.2.8.  Write to Cache\n           void\n           NFSPROC_WRITECACHE(void)\
    \ = 7;\n   To be used in the next protocol revision.\n"
- title: 2.2.9.  Write to File
  contents:
  - "2.2.9.  Write to File\n           struct writeargs {\n                   fhandle\
    \ file;\n                   unsigned beginoffset;\n                   unsigned\
    \ offset;\n                   unsigned totalcount;\n                   nfsdata\
    \ data;\n           };\n           attrstat\n           NFSPROC_WRITE(writeargs)\
    \ = 8;\n   Writes \"data\" beginning \"offset\" bytes from the beginning of \"\
    file\".\n   The first byte of the file is at offset zero.  If the reply \"status\"\
    \n   is NFS_OK, then the reply \"attributes\" contains the attributes of the\n\
    \   file after the write has completed.  The write operation is atomic.\n   Data\
    \ from this \"WRITE\" will not be mixed with data from another\n   client's \"\
    WRITE\".\n   Notes:  The arguments \"beginoffset\" and \"totalcount\" are ignored\
    \ and\n   are removed in the next protocol revision.\n"
- title: 2.2.10.  Create File
  contents:
  - "2.2.10.  Create File\n           struct createargs {\n                   diropargs\
    \ where;\n                   sattr attributes;\n           };\n           diropres\n\
    \           NFSPROC_CREATE(createargs) = 9;\n   The file \"name\" is created in\
    \ the directory given by \"dir\".  The\n   initial attributes of the new file\
    \ are given by \"attributes\".  A\n   reply \"status\" of NFS_OK indicates that\
    \ the file was created, and\n   reply \"file\" and reply \"attributes\" are its\
    \ file handle and\n   attributes.  Any other reply \"status\" means that the operation\
    \ failed\n   and no file was created.\n   Notes:  This routine should pass an\
    \ exclusive create flag, meaning\n   \"create the file only if it is not already\
    \ there\".\n"
- title: 2.2.11.  Remove File
  contents:
  - "2.2.11.  Remove File\n           stat\n           NFSPROC_REMOVE(diropargs) =\
    \ 10;\n   The file \"name\" is removed from the directory given by \"dir\".  A\n\
    \   reply of NFS_OK means the directory entry was removed.\n   Notes:  possibly\
    \ non-idempotent operation.\n"
- title: 2.2.12.  Rename File
  contents:
  - "2.2.12.  Rename File\n           struct renameargs {\n                   diropargs\
    \ from;\n                   diropargs to;\n           };\n           stat\n  \
    \         NFSPROC_RENAME(renameargs) = 11;\n   The existing file \"from.name\"\
    \ in the directory given by \"from.dir\" is\n   renamed to \"to.name\" in the\
    \ directory given by \"to.dir\".  If the\n   reply is NFS_OK, the file was renamed.\
    \  The RENAME operation is\n   atomic on the server; it cannot be interrupted\
    \ in the middle.\n   Notes:  possibly non-idempotent operation.\n"
- title: 2.2.13.  Create Link to File
  contents:
  - "2.2.13.  Create Link to File\n   Procedure 12, Version 2.\n           struct\
    \ linkargs {\n                   fhandle from;\n                   diropargs to;\n\
    \           };\n           stat\n           NFSPROC_LINK(linkargs) = 12;\n   Creates\
    \ the file \"to.name\" in the directory given by \"to.dir\", which\n   is a hard\
    \ link to the existing file given by \"from\".  If the return\n   value is NFS_OK,\
    \ a link was created.  Any other return value\n   indicates an error, and the\
    \ link was not created.\n   A hard link should have the property that changes\
    \ to either of the\n   linked files are reflected in both files.  When a hard\
    \ link is made\n   to a file, the attributes for the file should have a value\
    \ for\n   \"nlink\" that is one greater than the value before the link.\n   Notes:\
    \  possibly non-idempotent operation.\n"
- title: 2.2.14.  Create Symbolic Link
  contents:
  - "2.2.14.  Create Symbolic Link\n           struct symlinkargs {\n            \
    \       diropargs from;\n                   path to;\n                   sattr\
    \ attributes;\n           };\n           stat\n           NFSPROC_SYMLINK(symlinkargs)\
    \ = 13;\n   Creates the file \"from.name\" with ftype NFLNK in the directory given\n\
    \   by \"from.dir\".  The new file contains the pathname \"to\" and has\n   initial\
    \ attributes given by \"attributes\".  If the return value is\n   NFS_OK, a link\
    \ was created.  Any other return value indicates an\n   error, and the link was\
    \ not created.\n   A symbolic link is a pointer to another file.  The name given\
    \ in \"to\"\n   is not interpreted by the server, only stored in the newly created\n\
    \   file.  When the client references a file that is a symbolic link, the\n  \
    \ contents of the symbolic link are normally transparently\n   reinterpreted as\
    \ a pathname to substitute.  A READLINK operation\n   returns the data to the\
    \ client for interpretation.\n   Notes:  On UNIX servers the attributes are never\
    \ used, since symbolic\n   links always have mode 0777.\n"
- title: 2.2.15.  Create Directory
  contents:
  - "2.2.15.  Create Directory\n           diropres\n           NFSPROC_MKDIR (createargs)\
    \ = 14;\n   The new directory \"where.name\" is created in the directory given\
    \ by\n   \"where.dir\".  The initial attributes of the new directory are given\n\
    \   by \"attributes\".  A reply \"status\" of NFS_OK indicates that the new\n\
    \   directory was created, and reply \"file\" and reply \"attributes\" are\n \
    \  its file handle and attributes.  Any other reply \"status\" means that\n  \
    \ the operation failed and no directory was created.\n   Notes:  possibly non-idempotent\
    \ operation.\n"
- title: 2.2.16.  Remove Directory
  contents:
  - "2.2.16.  Remove Directory\n           stat\n           NFSPROC_RMDIR(diropargs)\
    \ = 15;\n   The existing empty directory \"name\" in the directory given by \"\
    dir\"\n   is removed.  If the reply is NFS_OK, the directory was removed.\n  \
    \ Notes:  possibly non-idempotent operation.\n"
- title: 2.2.17.  Read From Directory
  contents:
  - "2.2.17.  Read From Directory\n           struct readdirargs {\n             \
    \      fhandle dir;\n                   nfscookie cookie;\n                  \
    \ unsigned count;\n           };\n           struct entry {\n                \
    \   unsigned fileid;\n                   filename name;\n                   nfscookie\
    \ cookie;\n                   entry *nextentry;\n           };\n           union\
    \ readdirres switch (stat status) {\n           case NFS_OK:\n               \
    \    struct {\n                           entry *entries;\n                  \
    \         bool eof;\n                   } readdirok;\n           default:\n  \
    \                 void;\n           };\n           readdirres\n           NFSPROC_READDIR\
    \ (readdirargs) = 16;\n   Returns a variable number of directory entries, with\
    \ a total size of\n   up to \"count\" bytes, from the directory given by \"dir\"\
    .  If the\n   returned value of \"status\" is NFS_OK, then it is followed by a\n\
    \   variable number of \"entry\"s.  Each \"entry\" contains a \"fileid\" which\n\
    \   consists of a unique number to identify the file within a filesystem,\n  \
    \ the \"name\" of the file, and a \"cookie\" which is an opaque pointer to\n \
    \  the next entry in the directory.  The cookie is used in the next\n   READDIR\
    \ call to get more entries starting at a given point in the\n   directory.  The\
    \ special cookie zero (all bits zero) can be used to\n   get the entries starting\
    \ at the beginning of the directory.  The\n   \"fileid\" field should be the same\
    \ number as the \"fileid\" in the the\n   attributes of the file.  (See section\
    \ \"2.3.5. fattr\" under \"Basic\n   Data Types\".)  The \"eof\" flag has a value\
    \ of TRUE if there are no\n   more entries in the directory.\n"
- title: 2.2.18.  Get Filesystem Attributes
  contents:
  - "2.2.18.  Get Filesystem Attributes\n           union statfsres (stat status)\
    \ {\n           case NFS_OK:\n               struct {\n                   unsigned\
    \ tsize;\n                   unsigned bsize;\n                   unsigned blocks;\n\
    \                   unsigned bfree;\n                   unsigned bavail;\n   \
    \            } info;\n           default:\n                   void;\n        \
    \   };\n           statfsres\n           NFSPROC_STATFS(fhandle) = 17;\n   If\
    \ the reply \"status\" is NFS_OK, then the reply \"info\" gives the\n   attributes\
    \ for the filesystem that contains file referred to by the\n   input fhandle.\
    \  The attribute fields contain the following values:\n      tsize   The optimum\
    \ transfer size of the server in bytes.  This is\n              the number of\
    \ bytes the server would like to have in the\n              data part of READ\
    \ and WRITE requests.\n      bsize   The block size in bytes of the filesystem.\n\
    \      blocks  The total number of \"bsize\" blocks on the filesystem.\n     \
    \ bfree   The number of free \"bsize\" blocks on the filesystem.\n      bavail\
    \  The number of \"bsize\" blocks available to non-privileged\n              users.\n\
    \   Notes:  This call does not work well if a filesystem has variable\n   size\
    \ blocks.\n"
- title: 2.3.  Basic Data Types
  contents:
  - "2.3.  Basic Data Types\n   The following XDR definitions are basic structures\
    \ and types used in\n   other structures described further on.\n"
- title: 2.3.1.  stat
  contents:
  - "2.3.1.  stat\n       enum stat {\n           NFS_OK = 0,\n           NFSERR_PERM=1,\n\
    \           NFSERR_NOENT=2,\n           NFSERR_IO=5,\n           NFSERR_NXIO=6,\n\
    \           NFSERR_ACCES=13,\n           NFSERR_EXIST=17,\n           NFSERR_NODEV=19,\n\
    \           NFSERR_NOTDIR=20,\n           NFSERR_ISDIR=21,\n           NFSERR_FBIG=27,\n\
    \           NFSERR_NOSPC=28,\n           NFSERR_ROFS=30,\n           NFSERR_NAMETOOLONG=63,\n\
    \           NFSERR_NOTEMPTY=66,\n           NFSERR_DQUOT=69,\n           NFSERR_STALE=70,\n\
    \           NFSERR_WFLUSH=99\n       };\n   The \"stat\" type is returned with\
    \ every procedure's results.  A value\n   of NFS_OK indicates that the call completed\
    \ successfully and the\n   results are valid.  The other values indicate some\
    \ kind of error\n   occurred on the server side during the servicing of the procedure.\n\
    \   The error values are derived from UNIX error numbers.\n   NFSERR_PERM\n  \
    \    Not owner.  The caller does not have correct ownership to perform\n     \
    \ the requested operation.\n   NFSERR_NOENT\n      No such file or directory.\
    \  The file or directory specified does\n      not exist.\n   NFSERR_IO\n    \
    \  Some sort of hard error occurred when the operation was in\n      progress.\
    \  This could be a disk error, for example.\n   NFSERR_NXIO\n      No such device\
    \ or address.\n   NFSERR_ACCES\n      Permission denied.  The caller does not\
    \ have the correct\n      permission to perform the requested operation.\n   NFSERR_EXIST\n\
    \      File exists.  The file specified already exists.\n   NFSERR_NODEV\n   \
    \   No such device.\n   NFSERR_NOTDIR\n      Not a directory.  The caller specified\
    \ a non-directory in a\n      directory operation.\n   NFSERR_ISDIR\n      Is\
    \ a directory.  The caller specified a directory in a non-\n      directory operation.\n\
    \   NFSERR_FBIG\n      File too large.  The operation caused a file to grow beyond\
    \ the\n      server's limit.\n   NFSERR_NOSPC\n      No space left on device.\
    \  The operation caused the server's\n      filesystem to reach its limit.\n \
    \  NFSERR_ROFS\n      Read-only filesystem.  Write attempted on a read-only filesystem.\n\
    \   NFSERR_NAMETOOLONG\n      File name too long.  The file name in an operation\
    \ was too long.\n   NFSERR_NOTEMPTY\n      Directory not empty.  Attempted to\
    \ remove a directory that was not\n      empty.\n   NFSERR_DQUOT\n      Disk quota\
    \ exceeded.  The client's disk quota on the server has\n      been exceeded.\n\
    \   NFSERR_STALE\n      The \"fhandle\" given in the arguments was invalid.  That\
    \ is, the\n      file referred to by that file handle no longer exists, or access\n\
    \      to it has been revoked.\n   NFSERR_WFLUSH\n      The server's write cache\
    \ used in the \"WRITECACHE\" call got flushed\n      to disk.\n"
- title: 2.3.2.  ftype
  contents:
  - "2.3.2.  ftype\n          enum ftype {\n              NFNON = 0,\n           \
    \   NFREG = 1,\n              NFDIR = 2,\n              NFBLK = 3,\n         \
    \     NFCHR = 4,\n              NFLNK = 5\n          };\n      The enumeration\
    \ \"ftype\" gives the type of a file.  The type NFNON\n      indicates a non-file,\
    \ NFREG is a regular file, NFDIR is a\n      directory, NFBLK is a block-special\
    \ device, NFCHR is a character-\n      special device, and NFLNK is a symbolic\
    \ link.\n"
- title: 2.3.3.  fhandle
  contents:
  - "2.3.3.  fhandle\n          typedef opaque fhandle[FHSIZE];\n      The \"fhandle\"\
    \ is the file handle passed between the server and the\n      client.  All file\
    \ operations are done using file handles to refer\n      to a file or directory.\
    \  The file handle can contain whatever\n      information the server needs to\
    \ distinguish an individual file.\n"
- title: 2.3.4.  timeval
  contents:
  - "2.3.4.  timeval\n          struct timeval {\n              unsigned int seconds;\n\
    \              unsigned int useconds;\n          };\n      The \"timeval\" structure\
    \ is the number of seconds and microseconds\n      since midnight January 1, 1970,\
    \ Greenwich Mean Time.  It is used\n      to pass time and date information.\n"
- title: 2.3.5.  fattr
  contents:
  - "2.3.5.  fattr\n          struct fattr {\n              ftype        type;\n \
    \             unsigned int mode;\n              unsigned int nlink;\n        \
    \      unsigned int uid;\n              unsigned int gid;\n              unsigned\
    \ int size;\n              unsigned int blocksize;\n              unsigned int\
    \ rdev;\n              unsigned int blocks;\n              unsigned int fsid;\n\
    \              unsigned int fileid;\n              timeval      atime;\n     \
    \         timeval      mtime;\n              timeval      ctime;\n          };\n\
    \      The \"fattr\" structure contains the attributes of a file; \"type\" is\n\
    \      the type of the file; \"nlink\" is the number of hard links to the\n  \
    \    file (the number of different names for the same file); \"uid\" is\n    \
    \  the user identification number of the owner of the file; \"gid\" is\n     \
    \ the group identification number of the group of the file; \"size\"\n      is\
    \ the size in bytes of the file; \"blocksize\" is the size in bytes\n      of\
    \ a block of the file; \"rdev\" is the device number of the file if\n      it\
    \ is type NFCHR or NFBLK; \"blocks\" is the number of blocks the\n      file takes\
    \ up on disk; \"fsid\" is the file system identifier for\n      the filesystem\
    \ containing the file; \"fileid\" is a number that\n      uniquely identifies\
    \ the file within its filesystem; \"atime\" is the\n      time when the file was\
    \ last accessed for either read or write;\n      \"mtime\" is the time when the\
    \ file data was last modified\n      (written); and \"ctime\" is the time when\
    \ the status of the file was\n      last changed.  Writing to the file also changes\
    \ \"ctime\" if the\n      size of the file changes.\n      \"Mode\" is the access\
    \ mode encoded as a set of bits.  Notice that\n      the file type is specified\
    \ both in the mode bits and in the file\n      type.  This is really a bug in\
    \ the protocol and will be fixed in\n      future versions.  The descriptions\
    \ given below specify the bit\n      positions using octal numbers.\n      0040000\
    \ This is a directory; \"type\" field should be NFDIR.\n      0020000 This is\
    \ a character special file; \"type\" field should\n              be NFCHR.\n \
    \     0060000 This is a block special file; \"type\" field should be\n       \
    \       NFBLK.\n      0100000 This is a regular file; \"type\" field should be\
    \ NFREG.\n      0120000 This is a symbolic link file;  \"type\" field should be\n\
    \              NFLNK.\n      0140000 This is a named socket; \"type\" field should\
    \ be NFNON.\n      0004000 Set user id on execution.\n      0002000 Set group\
    \ id on execution.\n      0001000 Save swapped text even after use.\n      0000400\
    \ Read permission for owner.\n      0000200 Write permission for owner.\n    \
    \  0000100 Execute and search permission for owner.\n      0000040 Read permission\
    \ for group.\n      0000020 Write permission for group.\n      0000010 Execute\
    \ and search permission for group.\n      0000004 Read permission for others.\n\
    \      0000002 Write permission for others.\n      0000001 Execute and search\
    \ permission for others.\n      Notes:  The bits are the same as the mode bits\
    \ returned by the\n      stat(2) system call in UNIX.  The file type is specified\
    \ both in\n      the mode bits and in the file type.  This is fixed in future\n\
    \      versions.\n      The \"rdev\" field in the attributes structure is an operating\n\
    \      system specific device specifier.  It will be removed and\n      generalized\
    \ in the next revision of the protocol.\n"
- title: 2.3.6.  sattr
  contents:
  - "2.3.6.  sattr\n          struct sattr {\n              unsigned int mode;\n \
    \             unsigned int uid;\n              unsigned int gid;\n           \
    \   unsigned int size;\n              timeval      atime;\n              timeval\
    \      mtime;\n          };\n      The \"sattr\" structure contains the file attributes\
    \ which can be\n      set from the client.  The fields are the same as for \"\
    fattr\"\n      above.  A \"size\" of zero means the file should be truncated.\
    \  A\n      value of -1 indicates a field that should be ignored.\n"
- title: 2.3.7.  filename
  contents:
  - "2.3.7.  filename\n          typedef string filename<MAXNAMLEN>;\n      The type\
    \ \"filename\" is used for passing file names or pathname\n      components.\n"
- title: 2.3.8.  path
  contents:
  - "2.3.8.  path\n          typedef string path<MAXPATHLEN>;\n      The type \"path\"\
    \ is a pathname.  The server considers it as a\n      string with no internal\
    \ structure, but to the client it is the\n      name of a node in a filesystem\
    \ tree.\n"
- title: 2.3.9.  attrstat
  contents:
  - "2.3.9.  attrstat\n          union attrstat switch (stat status) {\n         \
    \ case NFS_OK:\n              fattr attributes;\n          default:\n        \
    \      void;\n          };\n      The \"attrstat\" structure is a common procedure\
    \ result.  It\n      contains a \"status\" and, if the call succeeded, it also\
    \ contains\n      the attributes of the file on which the operation was done.\n"
- title: 2.3.10.  diropargs
  contents:
  - "2.3.10.  diropargs\n          struct diropargs {\n              fhandle  dir;\n\
    \              filename name;\n          };\n      The \"diropargs\" structure\
    \ is used in directory operations.  The\n      \"fhandle\" \"dir\" is the directory\
    \ in which to find the file \"name\".\n      A directory operation is one in which\
    \ the directory is affected.\n"
- title: 2.3.11.  diropres
  contents:
  - "2.3.11.  diropres\n          union diropres switch (stat status) {\n        \
    \  case NFS_OK:\n              struct {\n                  fhandle file;\n   \
    \               fattr   attributes;\n              } diropok;\n          default:\n\
    \              void;\n          };\n      The results of a directory operation\
    \ are returned in a \"diropres\"\n      structure.  If the call succeeded, a new\
    \ file handle \"file\" and\n      the \"attributes\" associated with that file\
    \ are returned along with\n      the \"status\".\n"
- title: 3. NFS IMPLEMENTATION ISSUES
  contents:
  - "3. NFS IMPLEMENTATION ISSUES\n   The NFS protocol was designed to allow different\
    \ operating systems to\n   share files.  However, since it was designed in a UNIX\
    \ environment,\n   many operations have semantics similar to the operations of\
    \ the UNIX\n   file system.  This section discusses some of the implementation-\n\
    \   specific details and semantic issues.\n"
- title: 3.1.  Server/Client Relationship
  contents:
  - "3.1.  Server/Client Relationship\n   The NFS protocol is designed to allow servers\
    \ to be as simple and\n   general as possible.  Sometimes the simplicity of the\
    \ server can be a\n   problem, if the client wants to implement complicated filesystem\n\
    \   semantics.\n   For example, some operating systems allow removal of open files.\
    \  A\n   process can open a file and, while it is open, remove it from the\n \
    \  directory.  The file can be read and written as long as the process\n   keeps\
    \ it open, even though the file has no name in the filesystem.\n   It is impossible\
    \ for a stateless server to implement these semantics.\n   The client can do some\
    \ tricks such as renaming the file on remove,\n   and only removing it on close.\
    \  We believe that the server provides\n   enough functionality to implement most\
    \ file system semantics on the\n   client.\n   Every NFS client can also potentially\
    \ be a server, and remote and\n   local mounted filesystems can be freely intermixed.\
    \  This leads to\n   some interesting problems when a client travels down the\
    \ directory\n   tree of a remote filesystem and reaches the mount point on the\
    \ server\n   for another remote filesystem.  Allowing the server to follow the\n\
    \   second remote mount would require loop detection, server lookup, and\n   user\
    \ revalidation.  Instead, we decided not to let clients cross a\n   server's mount\
    \ point.  When a client does a LOOKUP on a directory on\n   which the server has\
    \ mounted a filesystem, the client sees the\n   underlying directory instead of\
    \ the mounted directory.\n   For example, if a server has a file system called\
    \ \"/usr\" and mounts\n   another file system on  \"/usr/src\", if a client mounts\
    \ \"/usr\", it\n   does NOT see the mounted version of \"/usr/src\".  A client\
    \ could do\n   remote mounts that match the server's mount points to maintain\
    \ the\n   server's view.  In this example, the client would also have to mount\n\
    \   \"/usr/src\" in addition to \"/usr\", even if they are from the same\n   server.\n"
- title: 3.2. Pathname Interpretation
  contents:
  - "3.2. Pathname Interpretation\n   There are a few complications to the rule that\
    \ pathnames are always\n   parsed on the client.  For example, symbolic links\
    \ could have\n   different interpretations on different clients.  Another common\n\
    \   problem for non-UNIX implementations is the special interpretation of\n  \
    \ the pathname \"..\" to mean the parent of a given directory.  The next\n   revision\
    \ of the protocol uses an explicit flag to indicate the parent\n   instead.\n"
- title: 3.3.  Permission Issues
  contents:
  - "3.3.  Permission Issues\n   The NFS protocol, strictly speaking, does not define\
    \ the permission\n   checking used by servers.  However, it is expected that a\
    \ server will\n   do normal operating system permission checking using AUTH_UNIX\
    \ style\n   authentication as the basis of its protection mechanism.  The server\n\
    \   gets the client's effective \"uid\", effective \"gid\", and groups on\n  \
    \ each call and uses them to check permission.  There are various\n   problems\
    \ with this method that can been resolved in interesting ways.\n   Using \"uid\"\
    \ and \"gid\" implies that the client and server share the\n   same \"uid\" list.\
    \  Every server and client pair must have the same\n   mapping from user to \"\
    uid\" and from group to \"gid\".  Since every\n   client can also be a server,\
    \ this tends to imply that the whole\n   network shares the same \"uid/gid\" space.\
    \  AUTH_DES (and the next\n   revision of the NFS protocol) uses string names\
    \ instead of numbers,\n   but there are still complex problems to be solved.\n\
    \   Another problem arises due to the usually stateful open operation.\n   Most\
    \ operating systems check permission at open time, and then check\n   that the\
    \ file is open on each read and write request.  With stateless\n   servers, the\
    \ server has no idea that the file is open and must do\n   permission checking\
    \ on each read and write call.  On a local\n   filesystem, a user can open a file\
    \ and then change the permissions so\n   that no one is allowed to touch it, but\
    \ will still be able to write\n   to the file because it is open.  On a remote\
    \ filesystem, by contrast,\n   the write would fail.  To get around this problem,\
    \ the server's\n   permission checking algorithm should allow the owner of a file\
    \ to\n   access it regardless of the permission setting.\n   A similar problem\
    \ has to do with paging in from a file over the\n   network.  The operating system\
    \ usually checks for execute permission\n   before opening a file for demand paging,\
    \ and then reads blocks from\n   the open file.  The file may not have read permission,\
    \ but after it\n   is opened it does not matter.  An NFS server can not tell the\n\
    \   difference between a normal file read and a demand page-in read.  To\n   make\
    \ this work, the server allows reading of files if the \"uid\" given\n   in the\
    \ call has either execute or read permission on the file.\n   In most operating\
    \ systems, a particular user (on UNIX, the user ID\n   zero) has access to all\
    \ files no matter what permission and ownership\n   they have.  This \"super-user\"\
    \ permission may not be allowed on the\n   server, since anyone who can become\
    \ super-user on their workstation\n   could gain access to all remote files. \
    \ The UNIX server by default\n   maps user id 0 to -2 before doing its access\
    \ checking.  This works\n   except for NFS root filesystems, where super-user\
    \ access cannot be\n   avoided.\n"
- title: 3.4.  RPC Information
  contents:
  - "3.4.  RPC Information\n   Authentication\n      The NFS service uses AUTH_UNIX,\
    \  AUTH_DES, or AUTH_SHORT style\n      authentication, except in the NULL procedure\
    \ where AUTH_NONE is\n      also allowed.\n   Transport Protocols\n      NFS is\
    \ supported normally on UDP.\n   Port Number\n      The NFS protocol currently\
    \ uses the UDP port number 2049.  This is\n      not an officially assigned port,\
    \ so later versions of the protocol\n      use the \"Portmapping\" facility of\
    \ RPC.\n"
- title: 3.5.  Sizes of XDR Structures
  contents:
  - "3.5.  Sizes of XDR Structures\n   These are the sizes, given in decimal bytes,\
    \ of various XDR\n   structures used in the protocol:\n   /*\n    * The maximum\
    \ number of bytes of data in a READ or WRITE\n    * request.\n    */\n   const\
    \ MAXDATA = 8192;\n   /* The maximum number of bytes in a pathname argument. */\n\
    \   const MAXPATHLEN = 1024;\n   /* The maximum number of bytes in a file name\
    \ argument. */\n   const MAXNAMLEN = 255;\n   /* The size in bytes of the opaque\
    \ \"cookie\" passed by READDIR. */\n   const COOKIESIZE  = 4;\n   /* The size\
    \ in bytes of the opaque file handle. */\n   const FHSIZE = 32;\n"
- title: 3.6. Setting RPC Parameters
  contents:
  - "3.6. Setting RPC Parameters\n   Various file system parameters and options should\
    \ be set at mount\n   time.  The mount protocol is described in the appendix below.\
    \  For\n   example, \"Soft\" mounts as well as \"Hard\" mounts are usually both\n\
    \   provided.  Soft mounted file systems return errors when RPC\n   operations\
    \ fail (after a given number of optional retransmissions),\n   while hard mounted\
    \ file systems continue to retransmit forever.  The\n   maximum transfer sizes\
    \ are implementation dependent.  For efficient\n   operation over a local network,\
    \ 8192 bytes of data are normally used.\n   This may result in lower-level fragmentation\
    \ (such as at the IP\n   level).  Since some network interfaces may not allow\
    \ such packets,\n   for operation over slower-speed networks or hosts, or through\n\
    \   gateways, transfer sizes of 512 or 1024 bytes often provide better\n   results.\n\
    \   Clients and servers may need to keep caches of recent operations to\n   help\
    \ avoid problems with non-idempotent operations.  For example, if\n   the transport\
    \ protocol drops the response for a Remove File\n   operation, upon retransmission\
    \ the server may return an error code of\n   NFSERR_NOENT instead of NFS_OK. \
    \ But if the server keeps around the\n   last operation requested and its result,\
    \ it could return the proper\n   success code.  Of course, the server could be\
    \ crashed and rebooted\n   between retransmissions, but a small cache (even a\
    \ single entry)\n   would solve most problems.\n                   Appendix A.\
    \ MOUNT PROTOCOL DEFINITION\n"
- title: A.1.  Introduction
  contents:
  - "A.1.  Introduction\n   The mount protocol is separate from, but related to, the\
    \ NFS\n   protocol.  It provides operating system specific services to get the\n\
    \   NFS off the ground -- looking up server path names, validating user\n   identity,\
    \ and checking access permissions.  Clients use the mount\n   protocol to get\
    \ the first file handle, which allows them entry into a\n   remote filesystem.\n\
    \   The mount protocol is kept separate from the NFS protocol to make it\n   easy\
    \ to plug in new access checking and validation methods without\n   changing the\
    \ NFS server protocol.\n   Notice that the protocol definition implies stateful\
    \ servers because\n   the server maintains a list of client's mount requests.\
    \  The mount\n   list information is not critical for the correct functioning\
    \ of\n   either the client or the server.  It is intended for advisory use\n \
    \  only, for example, to warn possible clients when a server is going\n   down.\n\
    \   Version one of the mount protocol is used with version two of the NFS\n  \
    \ protocol.  The only information communicated between these two\n   protocols\
    \ is the \"fhandle\" structure.\n"
- title: A.2.  RPC Information
  contents:
  - "A.2.  RPC Information\n   Authentication\n      The mount service uses AUTH_UNIX\
    \ and AUTH_NONE style\n      authentication only.\n   Transport Protocols\n  \
    \    The mount service is supported on both UDP and TCP.\n   Port Number\n   \
    \   Consult the server's portmapper, described in RFC 1057, \"RPC:\n      Remote\
    \ Procedure Call Protocol Specification\", to find the port\n      number on which\
    \ the mount service is registered.\n"
- title: A.3.  Sizes of XDR Structures
  contents:
  - "A.3.  Sizes of XDR Structures\n   These are the sizes, given in decimal bytes,\
    \ of various XDR\n   structures used in the protocol:\n           /* The maximum\
    \ number of bytes in a pathname argument. */\n           const MNTPATHLEN = 1024;\n\
    \           /* The maximum number of bytes in a name argument. */\n          \
    \ const MNTNAMLEN = 255;\n           /* The size in bytes of the opaque file handle.\
    \ */\n           const FHSIZE = 32;\n"
- title: A.4.  Basic Data Types
  contents:
  - "A.4.  Basic Data Types\n   This section presents the data types used by the mount\
    \ protocol.  In\n   many cases they are similar to the types used in NFS.\n"
- title: A.4.1.  fhandle
  contents:
  - "A.4.1.  fhandle\n       typedef opaque fhandle[FHSIZE];\n   The type \"fhandle\"\
    \ is the file handle that the server passes to the\n   client.  All file operations\
    \ are done using file handles to refer to\n   a file or directory.  The file handle\
    \ can contain whatever\n   information the server needs to distinguish an individual\
    \ file.\n   This is the same as the \"fhandle\" XDR definition in version 2 of\
    \ the\n   NFS protocol; see section \"2.3.3. fhandle\" under \"Basic Data Types\"\
    .\n"
- title: A.4.2.  fhstatus
  contents:
  - "A.4.2.  fhstatus\n       union fhstatus switch (unsigned status) {\n       case\
    \ 0:\n           fhandle directory;\n       default:\n           void;\n     \
    \  }\n   The type \"fhstatus\" is a union.  If a \"status\" of zero is returned,\n\
    \   the call completed successfully, and a file handle for the\n   \"directory\"\
    \ follows.  A non-zero status indicates some sort of error.\n   In this case,\
    \ the status is a UNIX error number.\n"
- title: A.4.3.  dirpath
  contents:
  - "A.4.3.  dirpath\n       typedef string dirpath<MNTPATHLEN>;\n   The type \"dirpath\"\
    \ is a server pathname of a directory.\n"
- title: A.4.4.  name
  contents:
  - "A.4.4.  name\n       typedef string name<MNTNAMLEN>;\n   The type \"name\" is\
    \ an arbitrary string used for various names.\n"
- title: A.5.  Server Procedures
  contents:
  - "A.5.  Server Procedures\n   The following sections define the RPC procedures\
    \ supplied by a mount\n   server.\n           /*\n            * Protocol description\
    \ for the mount program\n            */\n           program MOUNTPROG {\n    \
    \               /*\n                    * Version 1 of the mount protocol used\
    \ with\n                    * version 2 of the NFS protocol.\n               \
    \     */\n                   version MOUNTVERS {\n                           void\n\
    \                           MOUNTPROC_NULL(void) = 0;\n                      \
    \     fhstatus\n                           MOUNTPROC_MNT(dirpath) = 1;\n     \
    \                      mountlist\n                           MOUNTPROC_DUMP(void)\
    \ = 2;\n                           void\n                           MOUNTPROC_UMNT(dirpath)\
    \ = 3;\n                           void\n                           MOUNTPROC_UMNTALL(void)\
    \ = 4;\n                           exportlist\n                           MOUNTPROC_EXPORT(void)\
    \  = 5;\n                   } = 1;\n           } = 100005;\n"
- title: A.5.1.  Do Nothing
  contents:
  - "A.5.1.  Do Nothing\n           void\n           MNTPROC_NULL(void) = 0;\n   This\
    \ procedure does no work.  It is made available in all RPC\n   services to allow\
    \ server response testing and timing.\n"
- title: A.5.2.  Add Mount Entry
  contents:
  - "A.5.2.  Add Mount Entry\n           fhstatus\n           MNTPROC_MNT(dirpath)\
    \ = 1;\n   If the reply \"status\" is 0, then the reply \"directory\" contains\
    \ the\n   file handle for the directory \"dirname\".  This file handle may be\n\
    \   used in the NFS protocol.  This procedure also adds a new entry to\n   the\
    \ mount list for this client mounting \"dirname\".\n"
- title: A.5.3.  Return Mount Entries
  contents:
  - "A.5.3.  Return Mount Entries\n           struct *mountlist {\n              \
    \     name      hostname;\n                   dirpath   directory;\n         \
    \          mountlist nextentry;\n           };\n           mountlist\n       \
    \    MNTPROC_DUMP(void) = 2;\n   Returns the list of remote mounted filesystems.\
    \  The \"mountlist\"\n   contains one entry for each \"hostname\" and \"directory\"\
    \ pair.\n"
- title: A.5.4.  Remove Mount Entry
  contents:
  - "A.5.4.  Remove Mount Entry\n           void\n           MNTPROC_UMNT(dirpath)\
    \ = 3;\n   Removes the mount list entry for the input \"dirpath\".\n"
- title: A.5.5.  Remove All Mount Entries
  contents:
  - "A.5.5.  Remove All Mount Entries\n           void\n           MNTPROC_UMNTALL(void)\
    \ = 4;\n   Removes all of the mount list entries for this client.\n"
- title: A.5.6.  Return Export List
  contents:
  - "A.5.6.  Return Export List\n           struct *groups {\n                   name\
    \ grname;\n                   groups grnext;\n           };\n           struct\
    \ *exportlist {\n                   dirpath filesys;\n                   groups\
    \ groups;\n                   exportlist next;\n           };\n           exportlist\n\
    \           MNTPROC_EXPORT(void) = 5;\n   Returns a variable number of export\
    \ list entries.  Each entry\n   contains a filesystem name and a list of groups\
    \ that are allowed to\n   import it.  The filesystem name is in \"filesys\", and\
    \ the group name\n   is in the list \"groups\".\n   Notes:  The exportlist should\
    \ contain more information about the\n   status of the filesystem, such as a read-only\
    \ flag.\n"
- title: 'Author''s Address:'
  contents:
  - "Author's Address:\n   Bill Nowicki\n   Sun Microsystems, Inc.\n   Mail Stop 1-40\n\
    \   2550 Garcia Avenue\n   Mountain View, CA 94043\n   Phone: (415) 336-7278\n\
    \   Email: nowicki@SUN.COM\n"
