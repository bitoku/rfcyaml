- title: __initial_text__
  contents:
  - "     InMon Corporation's sFlow: A Method for Monitoring Traffic in\n        \
    \              Switched and Routed Networks\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2001).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo defines InMon Coporation's sFlow system.  sFlow is a\n\
    \   technology for monitoring traffic in data networks containing\n   switches\
    \ and routers.  In particular, it defines the sampling\n   mechanisms implemented\
    \ in an sFlow Agent for monitoring traffic, the\n   sFlow MIB for controlling\
    \ the sFlow Agent, and the format of sample\n   data used by the sFlow Agent when\
    \ forwarding data to a central data\n   collector.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Overview .....................................................\
    \  2\n   2.  Sampling Mechanisms ..........................................  2\n\
    \       2.1 Sampling of Switched Flows ...............................  3\n  \
    \         2.1.1 Distributed Switching ..............................  4\n    \
    \       2.1.2 Random Number Generation ...........................  4\n      \
    \ 2.2 Sampling of Network Interface Statistics .................  4\n   3.  sFlow\
    \ MIB ....................................................  5\n       3.1 The\
    \ SNMP Management Framework ............................  5\n       3.2 Definitions\
    \ ..............................................  6\n   4.  sFlow Datagram Format\
    \ ........................................ 14\n   5.  Security Considerations\
    \ ...................................... 25\n       5.1 Control ..................................................\
    \ 26\n       5.2 Transport ................................................ 26\n\
    \       5.3 Confidentiality .......................................... 26\n  \
    \ 6.  References ................................................... 27\n   7.\
    \  Authors' Addresses ........................................... 29\n   8.  Intellectual\
    \ Property Statement .............................. 30\n   9.  Full Copyright\
    \ Statement ..................................... 31\n"
- title: 1. Overview
  contents:
  - "1. Overview\n   sFlow is a technology for monitoring traffic in data networks\n\
    \   containing switches and routers.  In particular, it defines the\n   sampling\
    \ mechanisms implemented in an sFlow Agent for monitoring\n   traffic, the sFlow\
    \ MIB for controlling the sFlow Agent, and the\n   format of sample data used\
    \ by the sFlow Agent when forwarding data to\n   a central data collector.\n \
    \  The architecture and sampling techniques used in the sFlow monitoring\n   system\
    \ are designed to provide continuous site-wide (and network-\n   wide) traffic\
    \ monitoring for high speed switched and routed networks.\n   The design specifically\
    \ addresses issues associated with:\n   o Accurately monitoring network traffic\
    \ at Gigabit speeds and higher.\n   o Scaling to manage tens of thousands of agents\
    \ from a single point.\n   o Extremely low cost agent implementation.\n   The\
    \ sFlow monitoring system consists of an sFlow Agent (embedded in a\n   switch\
    \ or router or in a stand alone probe) and a central data\n   collector, or sFlow\
    \ Analyzer.\n   The sFlow Agent uses sampling technology to capture traffic\n\
    \   statistics from the device it is monitoring.  sFlow Datagrams are\n   used\
    \ to immediately forward the sampled traffic statistics to an\n   sFlow Analyzer\
    \ for analysis.\n   This document describes the sampling mechanisms used by the\
    \ sFlow\n   Agent, the SFLOW MIB used by the sFlow Analyzer to control the sFlow\n\
    \   Agent, and the sFlow Datagram Format used by the sFlow Agent to send\n   traffic\
    \ data to the sFlow Analyzer.\n"
- title: 2. Sampling Mechanisms
  contents:
  - "2. Sampling Mechanisms\n   The sFlow Agent uses two forms of sampling: statistical\
    \ packet-based\n   sampling of switched flows, and time-based sampling of network\n\
    \   interface statistics.\n"
- title: 2.1 Sampling of Switched Flows
  contents:
  - "2.1 Sampling of Switched Flows\n   A flow is defined as all the packets that\
    \ are received on one\n   interface, enter the Switching/Routing Module and are\
    \ sent to another\n   interface.  In the case of a one-armed router, the source\
    \ and\n   destination interface could be the same.  In the case of a broadcast\n\
    \   or multicast packet there may be multiple destination interfaces.\n   The\
    \ sampling mechanism must ensure that any packet involved in a flow\n   has an\
    \ equal chance of being sampled, irrespective of the flow to\n   which it belongs.\n\
    \   Sampling flows is accomplished as follows: When a packet arrives on\n   an\
    \ interface, a filtering decision is made that determines whether\n   the packet\
    \ should be dropped.  If the packet is not filtered a\n   destination interface\
    \ is assigned by the switching/routing function.\n   At this point a decision\
    \ is made on whether or not to sample the\n   packet.  The mechanism involves\
    \ a counter that is decremented with\n   each packet.  When the counter reaches\
    \ zero a sample is taken.\n   Whether or not a sample is taken, the counter Total_Packets\
    \ is\n   incremented.  Total_Packets is a count of all the packets that could\n\
    \   have been sampled.\n   Taking a sample involves either copying the packet's\
    \ header, or\n   extracting features from the packet (see sFlow Datagram Format\
    \ for a\n   description of the different forms of sample).  Every time a sample\n\
    \   is taken, the counter Total_Samples, is incremented.  Total_Samples\n   is\
    \ a count of the number of samples generated.  Samples are sent by\n   the sampling\
    \ entity to the sFlow Agent for processing.  The sample\n   includes the packet\
    \ information, and the values of the Total_Packets\n   and Total_Samples counters.\n\
    \   When a sample is taken, the counter indicating how many packets to\n   skip\
    \ before taking the next sample should be reset.  The value of the\n   counter\
    \ should be set to a random integer where the sequence of\n   random integers\
    \ used over time should be such that\n   (1) Total_Packets/Total_Samples = Rate\n\
    \   An alternative strategy for packet sampling is to generate a random\n   number\
    \ for each packet, compare the random number to a preset\n   threshold and take\
    \ a sample whenever the random number is smaller\n   than the threshold value.\
    \  Calculation of an appropriate threshold\n   value depends on the characteristics\
    \ of the random number generator,\n   however, the resulting sample stream must\
    \ still satisfy (1).\n"
- title: 2.1.1 Distributed Switching
  contents:
  - "2.1.1 Distributed Switching\n   The SFLOW MIB permits separate sampling entities\
    \ to be associated\n   with different physical or logical elements of the switch\
    \ (such as\n   interfaces, backplanes or VLANs).  Each sampling engine has its\
    \ own\n   independent state (i.e., Total_Packets, Total_Samples, Skip and\n  \
    \ Rate), and forwards its own sample messages to the sFlow Agent.  The\n   sFlow\
    \ Agent is responsible for packaging the samples into datagrams\n   for transmission\
    \ to an sFlow Analyzer.\n"
- title: 2.1.2 Random Number Generation
  contents:
  - "2.1.2 Random Number Generation\n   The essential property of the random number\
    \ generator is that the\n   mean value of the numbers it generates converges to\
    \ the required\n   sampling rate.\n   A uniform distribution random number generator\
    \ is very effective.\n   The range of skip counts (the variance) does not significantly\
    \ affect\n   results; variation of +-10% of the mean value is sufficient.\n  \
    \ The random number generator must ensure that all numbers in the range\n   between\
    \ its maximum and minimum values of the distribution are\n   possible; a random\
    \ number generator only capable of generating even\n   numbers, or numbers with\
    \ any common divisor is unsuitable.\n   A new skip value is only required every\
    \ time a sample is taken.\n"
- title: 2.2 Sampling of Network Interface Statistics
  contents:
  - "2.2 Sampling of Network Interface Statistics\n   The objective of the counter\
    \ sampling is to efficiently, periodically\n   poll each data source on the device\
    \ and extract key statistics.\n   For efficiency and scalability reasons, the\
    \ sFlow System implements\n   counter polling in the sFlow Agent.  A maximum polling\
    \ interval is\n   assigned to the agent, but the agent is free to schedule polling\
    \ in\n   order maximize internal efficiency.\n   Flow sampling and counter sampling\
    \ are designed as part of an\n   integrated system.  Both types of samples are\
    \ combined in sFlow\n   Datagrams.  Since flow sampling will cause a steady, but\
    \ random,\n   stream of datagrams to be sent to the sFlow Analyzer, counter samples\n\
    \   may be taken opportunistically in order to fill these datagrams.\n   One strategy\
    \ for counter sampling has the sFlow Agent keep a list of\n   counter sources\
    \ being sampled.  When a flow sample is generated the\n   sFlow Agent examines\
    \ the list and adds counters to the sample\n   datagram, least recently sampled\
    \ first.  Counters are only added to\n   the datagram if the sources are within\
    \ a short period, 5 seconds say,\n   of failing to meet the required sampling\
    \ interval (see\n   sFlowCounterSamplingInterval in SFLOW MIB).  Whenever a counter\n\
    \   source's statistics are added to a sample datagram, the time the\n   counter\
    \ source was last sampled is updated and the counter source is\n   placed at the\
    \ end of the list.  Periodically, say every second, the\n   sFlow Agent examines\
    \ the list of counter sources and sends any\n   counters that need to be sent\
    \ to meet the sampling interval\n   requirement.\n   Alternatively, if the agent\
    \ regularly schedules counter sampling,\n   then it should schedule each counter\
    \ source at a different start time\n   (preferably randomly) so that counter sampling\
    \ is not synchronized\n   within an agent or between agents.\n"
- title: 3. sFlow MIB
  contents:
  - "3. sFlow MIB\n   The sFlow MIB defines a control interface for an sFlow Agent.\
    \  This\n   interface provides a standard mechanism for remotely controlling and\n\
    \   configuring an sFlow Agent.\n"
- title: 3.1 The SNMP Management Framework
  contents:
  - "3.1 The SNMP Management Framework\n   The SNMP Management Framework presently\
    \ consists of five major\n   components:\n   o  An overall architecture, described\
    \ in RFC 2571 [2].\n   o  Mechanisms for describing and naming objects and events\
    \ for the\n      purpose of management.  The first version of this Structure of\n\
    \      Management Information (SMI) is called SMIv1 and described in STD\n   \
    \   16,\n      RFC 1155 [3], STD 16, RFC 1212 [4] and RFC 1215 [5].  The second\n\
    \      version, called SMIv2, is described in STD 58, RFC 2578 [6], STD\n    \
    \  58, RFC 2579 [7] and STD 58, RFC 2580 [8].\n   o  Message protocols for transferring\
    \ management information.  The\n      first version of the SNMP message protocol\
    \ is called SNMPv1 and\n      described in STD 15, RFC 1157 [9].  A second version\
    \ of the SNMP\n      message protocol, which is not an Internet standards track\n\
    \      protocol, is called SNMPv2c and described in RFC 1901 [10] and RFC\n  \
    \    1906 [11].  The third version of the message protocol is called\n      SNMPv3\
    \ and described in RFC 1906 [11], RFC 2572 [12] and RFC 2574\n      [13].\n  \
    \ o  Protocol operations for accessing management information.  The\n      first\
    \ set of protocol operations and associated PDU formats is\n      described in\
    \ STD 15, RFC 1157 [9].  A second set of protocol\n      operations and associated\
    \ PDU formats is described in RFC 1905\n      [14].\n   o  A set of fundamental\
    \ applications described in RFC 2573 [15] and\n      the view-based access control\
    \ mechanism described in RFC 2575\n      [16].\n   A more detailed introduction\
    \ to the current SNMP Management Framework\n   can be found in RFC 2570 [17].\n\
    \   Managed objects are accessed via a virtual information store, termed\n   the\
    \ Management Information Base or MIB.  Objects in the MIB are\n   defined using\
    \ the mechanisms defined in the SMI.\n   This memo specifies a MIB module that\
    \ is compliant to the SMIv2.  A\n   MIB conforming to the SMIv1 can be produced\
    \ through the appropriate\n   translations.  The resulting translated MIB must\
    \ be semantically\n   equivalent, except where objects or events are omitted because\
    \ no\n   translation is possible (use of Counter64).  Some machine readable\n\
    \   information in SMIv2 will be converted into textual descriptions in\n   SMIv1\
    \ during the translation process.  However, this loss of machine\n   readable\
    \ information is not considered to change the semantics of the\n   MIB.\n"
- title: 3.2 Definitions
  contents:
  - '3.2 Definitions

    '
- title: SFLOW-MIB DEFINITIONS ::= BEGIN
  contents:
  - 'SFLOW-MIB DEFINITIONS ::= BEGIN

    '
- title: IMPORTS
  contents:
  - 'IMPORTS

    '
- title: MODULE-IDENTITY, OBJECT-TYPE, Integer32, enterprises
  contents:
  - "MODULE-IDENTITY, OBJECT-TYPE, Integer32, enterprises\n        FROM SNMPv2-SMI\n"
- title: SnmpAdminString
  contents:
  - "SnmpAdminString\n        FROM SNMP-FRAMEWORK-MIB\n"
- title: OwnerString
  contents:
  - "OwnerString\n        FROM RMON-MIB\n"
- title: InetAddressType, InetAddress
  contents:
  - "InetAddressType, InetAddress\n        FROM INET-ADDRESS-MIB\n"
- title: MODULE-COMPLIANCE, OBJECT-GROUP
  contents:
  - "MODULE-COMPLIANCE, OBJECT-GROUP\n        FROM SNMPv2-CONF;\n"
- title: sFlowMIB  MODULE-IDENTITY
  contents:
  - "sFlowMIB  MODULE-IDENTITY\n  LAST-UPDATED \"200105150000Z\"   -- May 15, 2001\n\
    \  ORGANIZATION \"InMon Corp.\"\n  CONTACT-INFO\n         \"Peter Phaal\n    \
    \      InMon Corp.\n          http://www.inmon.com/\n          Tel:  +1-415-661-6343\n\
    \          Email: peter_phaal@inmon.com\"\n  DESCRIPTION\n          \"The MIB\
    \ module for managing the generation and transportation\n           of sFlow data\
    \ records.\"\n  --\n  -- Revision History\n  --\n  REVISION    \"200105150000Z\"\
    \     -- May 15, 2001\n  DESCRIPTION\n          \"Version 1.2\n           Brings\
    \ MIB into SMI v2 compliance.\"\n  REVISION    \"200105010000Z\"      -- May 1,\
    \ 2001\n  DESCRIPTION\n           \"Version 1.1\n            Adds sFlowDatagramVersion.\"\
    \n  ::= { enterprises 4300 1 }\n"
- title: sFlowAgent OBJECT IDENTIFIER ::= { sFlowMIB 1 }
  contents:
  - 'sFlowAgent OBJECT IDENTIFIER ::= { sFlowMIB 1 }

    '
- title: sFlowVersion OBJECT-TYPE
  contents:
  - "sFlowVersion OBJECT-TYPE\n     SYNTAX      SnmpAdminString\n     MAX-ACCESS \
    \ read-only\n     STATUS      current\n     DESCRIPTION\n       \"Uniquely identifies\
    \ the version and implementation of this MIB.\n        The version string must\
    \ have the following structure:\n           <MIB Version>;<Organization>;<Software\
    \ Revision>\n        where:\n           <MIB Version>  must be '1.2', the version\
    \ of this MIB.\n           <Organization> the name of the organization responsible\n\
    \                            for the agent implementation.\n           <Revision>\
    \     the specific software build of this agent.\n        As an example, the string\
    \ '1.2;InMon Corp.;2.1.1' indicates\n        that this agent implements version\
    \ '1.2' of the SFLOW MIB, that\n        it was developed by 'InMon Corp.' and\
    \ that the software build\n        is '2.1.1'.\n        The MIB Version will change\
    \ with each revision of the SFLOW\n        MIB.\n        Management entities must\
    \ check the MIB Version and not attempt\n        to manage agents with MIB Versions\
    \ greater than that for which\n        they were designed.\n        Note: The\
    \ sFlow Datagram Format has an independent version\n              number which\
    \ may change independently from <MIB Version>.\n              <MIB Version> applies\
    \ to the structure and semantics of\n              the SFLOW MIB only.\"\n   \
    \  DEFVAL { \"1.2;;\" }\n     ::= { sFlowAgent 1 }\n"
- title: sFlowAgentAddressType OBJECT-TYPE
  contents:
  - "sFlowAgentAddressType OBJECT-TYPE\n     SYNTAX      InetAddressType\n     MAX-ACCESS\
    \  read-only\n     STATUS      current\n     DESCRIPTION\n       \"The address\
    \ type of the address associated with this agent.\n        Only ipv4 and ipv6\
    \ types are supported.\"\n     ::= { sFlowAgent 2 }\n"
- title: sFlowAgentAddress OBJECT-TYPE
  contents:
  - "sFlowAgentAddress OBJECT-TYPE\n     SYNTAX      InetAddress\n     MAX-ACCESS\
    \  read-only\n     STATUS      current\n     DESCRIPTION\n       \"The IP address\
    \ associated with this agent.  In the case of a\n        multi-homed agent, this\
    \ should be the loopback address of the\n        agent.  The sFlowAgent address\
    \ must provide SNMP connectivity\n        to the agent.  The address should be\
    \ an invariant that does not\n        change as interfaces are reconfigured, enabled,\
    \ disabled,\n        added or removed.  A manager should be able to use the\n\
    \        sFlowAgentAddress as a unique key that will identify this\n        agent\
    \ over extended periods of time so that a history can\n        be maintained.\"\
    \n    ::= { sFlowAgent 3 }\n"
- title: sFlowTable OBJECT-TYPE
  contents:
  - "sFlowTable OBJECT-TYPE\n     SYNTAX      SEQUENCE OF SFlowEntry\n     MAX-ACCESS\
    \  not-accessible\n     STATUS      current\n     DESCRIPTION\n       \"A table\
    \ of the sFlow samplers within a device.\"\n     ::= { sFlowAgent 4 }\n"
- title: sFlowEntry OBJECT-TYPE
  contents:
  - "sFlowEntry OBJECT-TYPE\n     SYNTAX      SFlowEntry\n     MAX-ACCESS  not-accessible\n\
    \     STATUS      current\n     DESCRIPTION\n       \"Attributes of an sFlow sampler.\"\
    \n     INDEX { sFlowDataSource }\n     ::= { sFlowTable 1 }\n"
- title: SFlowEntry ::= SEQUENCE {
  contents:
  - "SFlowEntry ::= SEQUENCE {\n     sFlowDataSource               OBJECT IDENTIFIER,\n\
    \     sFlowOwner                    OwnerString,\n     sFlowTimeout          \
    \        Integer32,\n     sFlowPacketSamplingRate       Integer32,\n     sFlowCounterSamplingInterval\
    \  Integer32,\n     sFlowMaximumHeaderSize        Integer32,\n     sFlowMaximumDatagramSize\
    \      Integer32,\n     sFlowCollectorAddressType     InetAddressType,\n     sFlowCollectorAddress\
    \         InetAddress,\n     sFlowCollectorPort            Integer32,\n     sFlowDatagramVersion\
    \          Integer32\n"
- title: '}'
  contents:
  - '}

    '
- title: sFlowDataSource OBJECT-TYPE
  contents:
  - "sFlowDataSource OBJECT-TYPE\n     SYNTAX      OBJECT IDENTIFIER\n     MAX-ACCESS\
    \  read-only\n     STATUS      current\n     DESCRIPTION\n       \"Identifies\
    \ the source of the data for the sFlow sampler.\n       The following data source\
    \ types are currently defined:\n       - ifIndex.<I>\n       DataSources of this\
    \ traditional form are called 'port-based'.\n       Ideally the sampling entity\
    \ will perform sampling on all flows\n       originating from or destined to the\
    \ specified interface.\n       However, if the switch architecture only permits\
    \ input or\n       output sampling then the sampling agent is permitted to only\n\
    \       sample input flows input or output flows.  Each packet must\n       only\
    \ be considered once for sampling, irrespective of the\n       number of ports\
    \ it will be forwarded to.\n       Note: Port 0 is used to indicate that all ports\
    \ on the device\n             are represented by a single data source.\n     \
    \        - sFlowPacketSamplingRate applies to all ports on the\n             \
    \  device capable of packet sampling.\n             - sFlowCounterSamplingInterval\
    \ applies to all ports.\n       - smonVlanDataSource.<V>\n       A dataSource\
    \ of this form refers to a 'Packet-based VLAN'\n       and is called a 'VLAN-based'\
    \ dataSource.  <V> is the VLAN\n       ID as defined by the IEEE 802.1Q standard.\
    \  The\n       value is between 1 and 4094 inclusive, and it represents\n    \
    \   an 802.1Q VLAN-ID with global scope within a given\n       bridged domain.\n\
    \       Sampling is performed on all packets received that are part\n       of\
    \ the specified VLAN (no matter which port they arrived on).\n       Each packet\
    \ will only be considered once for sampling,\n       irrespective of the number\
    \ of ports it will be forwarded to.\n       - entPhysicalEntry.<N>\n       A dataSource\
    \ of this form refers to a physical entity within\n       the agent (e.g., entPhysicalClass\
    \ = backplane(4)) and is called\n       an 'entity-based' dataSource.\n      \
    \ Sampling is performed on all packets entering the resource (e.g.\n       If\
    \ the backplane is being sampled, all packets transmitted onto\n       the backplane\
    \ will be considered as single candidates for\n       sampling irrespective of\
    \ the number of ports they ultimately\n       reach).\n       Note: Since each\
    \ DataSource operates independently, a packet\n             that crosses multiple\
    \ DataSources may generate multiple\n             flow records.\"\n     ::= {\
    \ sFlowEntry 1 }\n"
- title: sFlowOwner OBJECT-TYPE
  contents:
  - "sFlowOwner OBJECT-TYPE\n     SYNTAX      OwnerString\n     MAX-ACCESS  read-write\n\
    \     STATUS      current\n     DESCRIPTION\n       \"The entity making use of\
    \ this sFlow sampler.  The empty string\n        indicates that the sFlow sampler\
    \ is currently unclaimed.\n        An entity wishing to claim an sFlow sampler\
    \ must make sure\n        that the sampler is unclaimed before trying to claim\
    \ it.\n        The sampler is claimed by setting the owner string to identify\n\
    \        the entity claiming the sampler.  The sampler must be claimed\n     \
    \   before any changes can be made to other sampler objects.\n        In order\
    \ to avoid a race condition, the entity taking control\n        of the sampler\
    \ must set both the owner and a value for\n        sFlowTimeout in the same SNMP\
    \ set request.\n        When a management entity is finished using the sampler,\n\
    \        it should set its value back to unclaimed.  The agent\n        must restore\
    \ all other entities this row to their\n        default values when the owner\
    \ is set to unclaimed.\n        This mechanism provides no enforcement and relies\
    \ on the\n        cooperation of management entities in order to ensure that\n\
    \        competition for a sampler is fairly resolved.\"\n     DEFVAL { \"\" }\n\
    \     ::= { sFlowEntry 2 }\n"
- title: sFlowTimeout OBJECT-TYPE
  contents:
  - "sFlowTimeout OBJECT-TYPE\n     SYNTAX      Integer32\n     MAX-ACCESS  read-write\n\
    \     STATUS      current\n     DESCRIPTION\n       \"The time (in seconds) remaining\
    \ before the sampler is released\n        and stops sampling.  When set, the owner\
    \ establishes control\n        for the specified period.  When read, the remaining\
    \ time in the\n        interval is returned.\n        A management entity wanting\
    \ to maintain control of the sampler\n        is responsible for setting a new\
    \ value before the old one\n        expires.\n        When the interval expires,\
    \ the agent is responsible for\n        restoring all other entities in this row\
    \ to their default\n        values.\"\n     DEFVAL { 0 }\n     ::= { sFlowEntry\
    \ 3 }\n"
- title: sFlowPacketSamplingRate OBJECT-TYPE
  contents:
  - "sFlowPacketSamplingRate OBJECT-TYPE\n     SYNTAX      Integer32\n     MAX-ACCESS\
    \  read-write\n     STATUS      current\n     DESCRIPTION\n       \"The statistical\
    \ sampling rate for packet sampling from this\n        source.\n        Set to\
    \ N to sample 1/Nth of the packets in the monitored flows.\n        An agent should\
    \ choose its own algorithm introduce variance\n        into the sampling so that\
    \ exactly every Nth packet is not\n        counted.  A sampling rate of 1 counts\
    \ all packets.  A sampling\n        rate of 0 disables sampling.\n        The\
    \ agent is permitted to have minimum and maximum allowable\n        values for\
    \ the sampling rate.  A minimum rate lets the agent\n        designer set an upper\
    \ bound on the overhead associated with\n        sampling, and a maximum rate\
    \ may be the result of hardware\n        restrictions (such as counter size).\
    \  In addition not all values\n        between the maximum and minimum may be\
    \ realizable as the\n        sampling rate (again because of implementation considerations).\n\
    \        When the sampling rate is set the agent is free to adjust the\n     \
    \   value so that it lies between the maximum and minimum values\n        and\
    \ has the closest achievable value.\n        When read, the agent must return\
    \ the actual sampling rate it\n        will be using (after the adjustments previously\
    \ described).  The\n        sampling algorithm must converge so that over time\
    \ the number\n        of packets sampled approaches 1/Nth of the total number\
    \ of\n        packets in the monitored flows.\"\n     DEFVAL { 0 }\n     ::= {\
    \ sFlowEntry 4 }\n"
- title: sFlowCounterSamplingInterval OBJECT-TYPE
  contents:
  - "sFlowCounterSamplingInterval OBJECT-TYPE\n  SYNTAX      Integer32\n     MAX-ACCESS\
    \  read-write\n     STATUS      current\n     DESCRIPTION\n       \"The maximum\
    \ number of seconds between successive samples of the\n        counters associated\
    \ with this data source.  A sampling interval\n        of 0 disables counter sampling.\"\
    \n     DEFVAL { 0 }\n     ::= { sFlowEntry 5 }\n"
- title: sFlowMaximumHeaderSize OBJECT-TYPE
  contents:
  - "sFlowMaximumHeaderSize OBJECT-TYPE\n     SYNTAX      Integer32\n     MAX-ACCESS\
    \  read-write\n     STATUS      current\n     DESCRIPTION\n       \"The maximum\
    \ number of bytes that should be copied from a\n        sampled packet.  The agent\
    \ may have an internal maximum and\n        minimum permissible sizes.  If an\
    \ attempt is made to set this\n        value outside the permissible range then\
    \ the agent should\n        adjust the value to the closest permissible value.\"\
    \n     DEFVAL { 128 }\n     ::= { sFlowEntry 6 }\n"
- title: sFlowMaximumDatagramSize OBJECT-TYPE
  contents:
  - "sFlowMaximumDatagramSize OBJECT-TYPE\n     SYNTAX      Integer32\n     MAX-ACCESS\
    \  read-write\n     STATUS      current\n     DESCRIPTION\n        \"The maximum\
    \ number of data bytes that can be sent in a single\n         sample datagram.\
    \  The manager should set this value to avoid\n         fragmentation of the sFlow\
    \ datagrams.\"\n     DEFVAL { 1400 }\n     ::= { sFlowEntry 7 }\n"
- title: sFlowCollectorAddressType OBJECT-TYPE
  contents:
  - "sFlowCollectorAddressType OBJECT-TYPE\n     SYNTAX      InetAddressType\n   \
    \  MAX-ACCESS  read-write\n     STATUS      current\n     DESCRIPTION\n      \
    \ \"The type of sFlowCollectorAddress.\"\n     DEFVAL { ipv4 }\n     ::= { sFlowEntry\
    \ 8 }\n"
- title: sFlowCollectorAddress OBJECT-TYPE
  contents:
  - "sFlowCollectorAddress OBJECT-TYPE\n     SYNTAX      InetAddress\n     MAX-ACCESS\
    \  read-write\n     STATUS      current\n     DESCRIPTION\n       \"The IP address\
    \ of the sFlow collector.\n        If set to 0.0.0.0 all sampling is disabled.\"\
    \n     DEFVAL { \"0.0.0.0\" }\n     ::= { sFlowEntry 9 }\n"
- title: sFlowCollectorPort OBJECT-TYPE
  contents:
  - "sFlowCollectorPort OBJECT-TYPE\n     SYNTAX      Integer32\n     MAX-ACCESS \
    \ read-write\n     STATUS      current\n     DESCRIPTION\n       \"The destination\
    \ port for sFlow datagrams.\"\n     DEFVAL { 6343 }\n     ::= { sFlowEntry 10\
    \ }\n"
- title: sFlowDatagramVersion OBJECT-TYPE
  contents:
  - "sFlowDatagramVersion OBJECT-TYPE\n     SYNTAX      Integer32\n     MAX-ACCESS\
    \  read-write\n     STATUS      current\n     DESCRIPTION\n       \"The version\
    \ of sFlow datagrams that should be sent.\n        When set to a value not support\
    \ by the agent, the agent should\n        adjust the value to the highest supported\
    \ value less than the\n        requested value, or return an error if no such\
    \ values exist.\"\n     DEFVAL { 4 }\n     ::= { sFlowEntry 11 }\n --\n -- Compliance\
    \ Statements\n --\n"
- title: sFlowMIBConformance OBJECT IDENTIFIER ::= { sFlowMIB 2 }
  contents:
  - 'sFlowMIBConformance OBJECT IDENTIFIER ::= { sFlowMIB 2 }

    '
- title: sFlowMIBGroups      OBJECT IDENTIFIER ::= { sFlowMIBConformance 1 }
  contents:
  - 'sFlowMIBGroups      OBJECT IDENTIFIER ::= { sFlowMIBConformance 1 }

    '
- title: sFlowMIBCompliances OBJECT IDENTIFIER ::= { sFlowMIBConformance 2 }
  contents:
  - 'sFlowMIBCompliances OBJECT IDENTIFIER ::= { sFlowMIBConformance 2 }

    '
- title: sFlowCompliance MODULE-COMPLIANCE
  contents:
  - "sFlowCompliance MODULE-COMPLIANCE\n     STATUS      current\n     DESCRIPTION\n\
    \       \"Compliance statements for the sFlow Agent.\"\n     MODULE -- this module\n\
    \         MANDATORY-GROUPS { sFlowAgentGroup }\n         OBJECT     sFlowAgentAddressType\n\
    \         SYNTAX     InetAddressType { ipv4(1) }\n         DESCRIPTION\n     \
    \      \"Agents need only support ipv4.\"\n         OBJECT sFlowCollectorAddressType\n\
    \         SYNTAX InetAddressType { ipv4(1) }\n         DESCRIPTION\n         \
    \  \"Agents need only support ipv4.\"\n     ::= { sFlowMIBCompliances 1 }\n"
- title: sFlowAgentGroup OBJECT-GROUP
  contents:
  - "sFlowAgentGroup OBJECT-GROUP\n     OBJECTS { sFlowVersion, sFlowAgentAddressType,\
    \ sFlowAgentAddress,\n               sFlowDataSource, sFlowOwner, sFlowTimeout,\n\
    \               sFlowPacketSamplingRate, sFlowCounterSamplingInterval,\n     \
    \          sFlowMaximumHeaderSize, sFlowMaximumDatagramSize,\n               sFlowCollectorAddressType,\
    \ sFlowCollectorAddress,\n               sFlowCollectorPort, sFlowDatagramVersion\
    \ }\n      STATUS current\n      DESCRIPTION\n        \"A collection of objects\
    \ for managing the generation and\n         transportation of sFlow data records.\"\
    \n       ::= { sFlowMIBGroups 1 }\n"
- title: END
  contents:
  - "END\n   The sFlow MIB references definitions from a number of existing RFCs\n\
    \   [18], [19], [20] and [21].\n"
- title: 4. sFlow Datagram Format
  contents:
  - "4. sFlow Datagram Format\n   The sFlow datagram format specifies a standard format\
    \ for the sFlow\n   Agent to send sampled data to a remote data collector.\n \
    \  The format of the sFlow datagram is specified using the XDR standard\n   [1].\
    \  XDR is more compact than ASN.1 and simpler for the sFlow Agent\n   to encode\
    \ and the sFlow Analyzer to decode.\n   Samples are sent as UDP packets to the\
    \ host and port specified in the\n   SFLOW MIB.  The lack of reliability in the\
    \ UDP transport mechanism\n   does not significantly affect the accuracy of the\
    \ measurements\n   obtained from an sFlow Agent.\n   o  If counter samples are\
    \ lost then new values will be sent during\n      the next polling interval. \
    \ The chance of an undetected counter\n      wrap is negligible.  The sFlow datagram\
    \ specifies 64 bit octet\n      counters, and with typical counter polling intervals\
    \ between 20 to\n      120 seconds, the chance of a long enough sequence of sFlow\n\
    \      datagrams being lost to hide a counter wrap is very small.\n   o  The net\
    \ effect of lost flow samples is a slight reduction in the\n      effective sampling\
    \ rate.\n   The use of UDP reduces the amount of memory required to buffer data.\n\
    \   UDP also provides a robust means of delivering timely traffic\n   information\
    \ during periods of intense traffic (such as a denial of\n   service attack).\
    \  UDP is more robust than a reliable transport\n   mechanism because under overload\
    \ the only effect on overall system\n   performance is a slight increase in transmission\
    \ delay and a greater\n   number of lost packets, neither of which has a significant\
    \ effect on\n   an sFlow-based monitoring system.  If a reliable transport mechanism\n\
    \   were used then an overload would introduce long transmission delays\n   and\
    \ require large amounts of buffer memory on the agent.\n   While the sFlow Datagram\
    \ structure permits multiple samples to be\n   included in each datagram, the\
    \ sampling agent must not wait for a\n   buffer to fill with samples before sending\
    \ the sample datagram.\n   sFlow sampling is intended to provide timely information\
    \ on traffic.\n   The agent may at most delay a sample by 1 second before it is\n\
    \   required to send the datagram.\n   The agent should try to piggyback counter\
    \ samples on the datagram\n   stream resulting from flow sampling.  Before sending\
    \ out a datagram\n   the remaining space in the buffer can be filled with counter\
    \ samples.\n   The agent has discretion in the timing of its counter polling,\
    \ the\n   specified counter sampling intervals sFlowCounterSamplingInterval is\n\
    \   a maximum, so the agent is free to sample counters early if it has\n   space\
    \ in a datagram.  If counters must be sent in order to satisfy\n   the maximum\
    \ sampling interval then a datagram must be sent containing\n   the outstanding\
    \ counters.\n   The following is the XDR description of an sFlow Datagram:\n"
- title: /* sFlow Datagram Version 4 */
  contents:
  - '/* sFlow Datagram Version 4 */

    '
- title: /* Revision History
  contents:
  - "/* Revision History\n   - version 4 adds support BGP communities\n   - version\
    \ 3 adds support for extended_url information\n"
- title: '*/'
  contents:
  - '*/

    '
- title: /* sFlow Sample types */
  contents:
  - '/* sFlow Sample types */

    '
- title: /* Address Types */
  contents:
  - '/* Address Types */

    '
- title: typedef opaque ip_v4[4];
  contents:
  - 'typedef opaque ip_v4[4];

    '
- title: typedef opaque ip_v6[16];
  contents:
  - 'typedef opaque ip_v6[16];

    '
- title: enum address_type {
  contents:
  - "enum address_type {\n   IP_V4    = 1,\n   IP_V6    = 2\n"
- title: '}'
  contents:
  - '}

    '
- title: union address (address_type type) {
  contents:
  - "union address (address_type type) {\n   case IP_V4:\n     ip_v4;\n   case IP_V6:\n\
    \     ip_v6;\n"
- title: '}'
  contents:
  - '}

    '
- title: /* Packet header data */
  contents:
  - '/* Packet header data */

    '
- title: const MAX_HEADER_SIZE = 256;   /* The maximum sampled header size. */
  contents:
  - 'const MAX_HEADER_SIZE = 256;   /* The maximum sampled header size. */

    '
- title: /* The header protocol describes the format of the sampled header */
  contents:
  - '/* The header protocol describes the format of the sampled header */

    '
- title: enum header_protocol {
  contents:
  - "enum header_protocol {\n   ETHERNET-ISO8023     = 1,\n   ISO88024-TOKENBUS  \
    \  = 2,\n   ISO88025-TOKENRING   = 3,\n   FDDI                 = 4,\n   FRAME-RELAY\
    \          = 5,\n   X25                  = 6,\n   PPP                  = 7,\n\
    \   SMDS                 = 8,\n   AAL5                 = 9,\n   AAL5-IP      \
    \        = 10, /* e.g., Cisco AAL5 mux */\n   IPv4                 = 11,\n   IPv6\
    \                 = 12,\n   MPLS                 = 13\n"
- title: '}'
  contents:
  - '}

    '
- title: struct sampled_header {
  contents:
  - "struct sampled_header {\n   header_protocol protocol;       /* Format of sampled\
    \ header */\n   unsigned int frame_length;      /* Original length of packet before\n\
    \                                      sampling */\n   opaque header<MAX_HEADER_SIZE>;\
    \ /* Header bytes */\n"
- title: '}'
  contents:
  - '}

    '
- title: /* Packet IP version 4 data */
  contents:
  - '/* Packet IP version 4 data */

    '
- title: struct sampled_ipv4 {
  contents:
  - "struct sampled_ipv4 {\n   unsigned int length;     /* The length of the IP packet\
    \ excluding\n                               lower layer encapsulations */\n  \
    \ unsigned int protocol;   /* IP Protocol type\n                             \
    \  (for example, TCP = 6, UDP = 17) */\n   ip_v4 src_ip;            /* Source\
    \ IP Address */\n   ip_v4 dst_ip;            /* Destination IP Address */\n  \
    \ unsigned int src_port;   /* TCP/UDP source port number or\n                \
    \               equivalent */\n   unsigned int dst_port;   /* TCP/UDP destination\
    \ port number or\n                               equivalent */\n   unsigned int\
    \ tcp_flags;  /* TCP flags */\n   unsigned int tos;        /* IP type of service\
    \ */\n"
- title: '}'
  contents:
  - '}

    '
- title: /* Packet IP version 6 data */
  contents:
  - '/* Packet IP version 6 data */

    '
- title: struct sampled_ipv6 {
  contents:
  - "struct sampled_ipv6 {\n   unsigned int length;     /* The length of the IP packet\
    \ excluding\n                               lower layer encapsulations */\n  \
    \ unsigned int protocol;   /* IP next header\n                               (for\
    \ example, TCP = 6, UDP = 17) */\n   ip_v6 src_ip;            /* Source IP Address\
    \ */\n   ip_v6 dst_ip;            /* Destination IP Address */\n   unsigned int\
    \ src_port;   /* TCP/UDP source port number or\n                             \
    \  equivalent */\n   unsigned int dst_port;   /* TCP/UDP destination port number\
    \ or\n                               equivalent */\n   unsigned int tcp_flags;\
    \  /* TCP flags */\n   unsigned int priority;   /* IP priority */\n"
- title: '}'
  contents:
  - '}

    '
- title: /* Packet data */
  contents:
  - '/* Packet data */

    '
- title: enum packet_information_type {
  contents:
  - "enum packet_information_type {\n   HEADER  = 1,      /* Packet headers are sampled\
    \ */\n   IPV4    = 2,      /* IP version 4 data */\n   IPV6    = 3       /* IP\
    \ version 6 data */\n"
- title: '}'
  contents:
  - '}

    '
- title: union packet_data_type (packet_information_type type) {
  contents:
  - "union packet_data_type (packet_information_type type) {\n   case HEADER:\n  \
    \    sampled_header header;\n   case IPV4:\n      sampled_ipv4 ipv4;\n   case\
    \ IPV6:\n      sampled_ipv6 ipv6;\n"
- title: '}'
  contents:
  - '}

    '
- title: /* Extended data types */
  contents:
  - '/* Extended data types */

    '
- title: /* Extended switch data */
  contents:
  - '/* Extended switch data */

    '
- title: struct extended_switch {
  contents:
  - "struct extended_switch {\n   unsigned int src_vlan;     /* The 802.1Q VLAN id\
    \ of incoming frame */\n   unsigned int src_priority; /* The 802.1p priority of\
    \ incoming\n                                 frame */\n   unsigned int dst_vlan;\
    \     /* The 802.1Q VLAN id of outgoing frame */\n   unsigned int dst_priority;\
    \ /* The 802.1p priority of outgoing\n                                 frame */\n"
- title: '}'
  contents:
  - '}

    '
- title: /* Extended router data */
  contents:
  - '/* Extended router data */

    '
- title: struct extended_router {
  contents:
  - "struct extended_router {\n   address nexthop;         /* IP address of next hop\
    \ router */\n   unsigned int src_mask;   /* Source address prefix mask bits */\n\
    \   unsigned int dst_mask;   /* Destination address prefix mask bits */\n"
- title: '}'
  contents:
  - '}

    '
- title: /* Extended gateway data */
  contents:
  - '/* Extended gateway data */

    '
- title: enum as_path_segment_type {
  contents:
  - "enum as_path_segment_type {\n   AS_SET      = 1,            /* Unordered set\
    \ of ASs */\n   AS_SEQUENCE = 2             /* Ordered set of ASs */\n"
- title: '}'
  contents:
  - '}

    '
- title: union as_path_type (as_path_segment_type) {
  contents:
  - "union as_path_type (as_path_segment_type) {\n   case AS_SET:\n      unsigned\
    \ int as_set<>;\n   case AS_SEQUENCE:\n      unsigned int as_sequence<>;\n"
- title: '}'
  contents:
  - '}

    '
- title: struct extended_gateway {
  contents:
  - "struct extended_gateway {\n   unsigned int as;            /* Autonomous system\
    \ number of router */\n   unsigned int src_as;        /* Autonomous system number\
    \ of source */\n   unsigned int src_peer_as;   /* Autonomous system number of\
    \ source\n                                  peer */\n   as_path_type dst_as_path<>;\
    \ /* Autonomous system path to the\n                                  destination\
    \ */\n   unsigned int communities<>; /* Communities associated with this\n   \
    \                               route */\n   unsigned int localpref;     /* LocalPref\
    \ associated with this\n                                  route */\n"
- title: '}'
  contents:
  - '}

    '
- title: /* Extended user data */
  contents:
  - '/* Extended user data */

    '
- title: struct extended_user {
  contents:
  - "struct extended_user {\n   string src_user<>;          /* User ID associated\
    \ with packet\n                                  source */\n   string dst_user<>;\
    \          /* User ID associated with packet\n                               \
    \   destination */\n"
- title: '}'
  contents:
  - '}

    '
- title: /* Extended URL data */
  contents:
  - '/* Extended URL data */

    '
- title: enum url_direction {
  contents:
  - "enum url_direction {\n   src    = 1,                 /* URL is associated with\
    \ source\n                                  address */\n   dst    = 2        \
    \          /* URL is associated with destination\n                           \
    \       address */\n"
- title: '}'
  contents:
  - '}

    '
- title: struct extended_url {
  contents:
  - "struct extended_url {\n   url_direction direction;    /* URL associated with\
    \ packet source */\n   string url<>;               /* URL associated with the\
    \ packet flow */\n"
- title: '}'
  contents:
  - '}

    '
- title: /* Extended data */
  contents:
  - '/* Extended data */

    '
- title: enum extended_information_type {
  contents:
  - "enum extended_information_type {\n   SWITCH    = 1,      /* Extended switch information\
    \ */\n   ROUTER    = 2,      /* Extended router information */\n   GATEWAY   =\
    \ 3,      /* Extended gateway router information */\n   USER      = 4,      /*\
    \ Extended TACACS/RADIUS user information */\n   URL       = 5       /* Extended\
    \ URL information */\n"
- title: '}'
  contents:
  - '}

    '
- title: union extended_data_type (extended_information_type type) {
  contents:
  - "union extended_data_type (extended_information_type type) {\n   case SWITCH:\n\
    \      extended_switch switch;\n   case ROUTER:\n      extended_router router;\n\
    \   case GATEWAY:\n      extended_gateway gateway;\n   case USER:\n      extended_user\
    \ user;\n   case URL:\n      extended_url url;\n"
- title: '}'
  contents:
  - '}

    '
- title: /* Format of a single flow sample */
  contents:
  - '/* Format of a single flow sample */

    '
- title: struct flow_sample {
  contents:
  - 'struct flow_sample {

    '
- title: unsigned int sequence_number;    /* Incremented with each flow sample
  contents:
  - "unsigned int sequence_number;    /* Incremented with each flow sample\n     \
    \                               generated by this source_id */\n"
- title: 'unsigned int source_id;          /* sFlowDataSource encoded as follows:'
  contents:
  - "unsigned int source_id;          /* sFlowDataSource encoded as follows:\n   \
    \                                 The most significant byte of the\n         \
    \                           source_id is used to indicate the\n              \
    \                      type of sFlowDataSource\n                             \
    \       (0 = ifIndex,\n                                    1 = smonVlanDataSource,\n\
    \                                    2 = entPhysicalEntry) and the\n         \
    \                           lower three bytes contain the\n                  \
    \                  relevant index value.*/\n"
- title: unsigned int sampling_rate;      /* sFlowPacketSamplingRate */
  contents:
  - 'unsigned int sampling_rate;      /* sFlowPacketSamplingRate */

    '
- title: unsigned int sample_pool;        /* Total number of packets that could
  contents:
  - "unsigned int sample_pool;        /* Total number of packets that could\n    \
    \                                have been sampled (i.e., packets\n          \
    \                          skipped by sampling process + total\n             \
    \                       number of samples) */\n"
- title: unsigned int drops;              /* Number times a packet was dropped
  contents:
  - "unsigned int drops;              /* Number times a packet was dropped\n     \
    \                               due to lack of resources */\n"
- title: unsigned int input;               /* SNMP ifIndex of input interface.
  contents:
  - "unsigned int input;               /* SNMP ifIndex of input interface.\n     \
    \                                0 if interface is not known.  */\n"
- title: unsigned int output;              /* SNMP ifIndex of output interface,
  contents:
  - "unsigned int output;              /* SNMP ifIndex of output interface,\n    \
    \                                 0 if interface is not known.\n             \
    \                        Set most significant bit to\n                       \
    \              indicate multiple destination\n                               \
    \      interfaces (i.e., in case of\n                                     broadcast\
    \ or multicast)\n                                     and set lower order bits\
    \ to\n                                     indicate number of destination\n  \
    \                                   interfaces.\n                            \
    \         Examples:\n                                        0x00000002  indicates\
    \ ifIndex =\n                                                    2\n         \
    \                               0x00000000  ifIndex unknown.\n               \
    \                         0x80000007  indicates a packet\n                   \
    \                                 sent to 7\n                                \
    \                    interfaces.\n                                        0x80000000\
    \  indicates a packet\n                                                    sent\
    \ to an unknown\n                                                    number of\
    \ interfaces\n                                                    greater than\
    \ 1. */\n   packet_data_type packet_data;       /* Information about sampled\n\
    \                                          packet */\n   extended_data_type extended_data<>;\
    \ /* Extended flow information */\n"
- title: '}'
  contents:
  - '}

    '
- title: /* Counter types */
  contents:
  - '/* Counter types */

    '
- title: /* Generic interface counters - see RFC 2233 */
  contents:
  - '/* Generic interface counters - see RFC 2233 */

    '
- title: struct if_counters {
  contents:
  - "struct if_counters {\n   unsigned int ifIndex;\n   unsigned int ifType;\n   unsigned\
    \ hyper ifSpeed;\n   unsigned int ifDirection;    /* derived from MAU MIB (RFC\
    \ 2668)\n                                   0 = unknown, 1=full-duplex,\n    \
    \                               2=half-duplex, 3 = in, 4=out */\n   unsigned int\
    \ ifStatus;       /* bit field with the following bits\n                     \
    \              assigned\n                                   bit 0 = ifAdminStatus\n\
    \                                     (0 = down, 1 = up)\n                   \
    \                bit 1 = ifOperStatus\n                                     (0\
    \ = down, 1 = up) */\n   unsigned hyper ifInOctets;\n   unsigned int ifInUcastPkts;\n\
    \   unsigned int ifInMulticastPkts;\n   unsigned int ifInBroadcastPkts;\n   unsigned\
    \ int ifInDiscards;\n   unsigned int ifInErrors;\n   unsigned int ifInUnknownProtos;\n\
    \   unsigned hyper ifOutOctets;\n   unsigned int ifOutUcastPkts;\n   unsigned\
    \ int ifOutMulticastPkts;\n   unsigned int ifOutBroadcastPkts;\n   unsigned int\
    \ ifOutDiscards;\n   unsigned int ifOutErrors;\n   unsigned int ifPromiscuousMode;\n"
- title: '}'
  contents:
  - '}

    '
- title: /* Ethernet interface counters - see RFC 2358 */
  contents:
  - '/* Ethernet interface counters - see RFC 2358 */

    '
- title: struct ethernet_counters {
  contents:
  - "struct ethernet_counters {\n   if_counters generic;\n   unsigned int dot3StatsAlignmentErrors;\n\
    \   unsigned int dot3StatsFCSErrors;\n   unsigned int dot3StatsSingleCollisionFrames;\n\
    \   unsigned int dot3StatsMultipleCollisionFrames;\n   unsigned int dot3StatsSQETestErrors;\n\
    \   unsigned int dot3StatsDeferredTransmissions;\n   unsigned int dot3StatsLateCollisions;\n\
    \   unsigned int dot3StatsExcessiveCollisions;\n   unsigned int dot3StatsInternalMacTransmitErrors;\n\
    \   unsigned int dot3StatsCarrierSenseErrors;\n   unsigned int dot3StatsFrameTooLongs;\n\
    \   unsigned int dot3StatsInternalMacReceiveErrors;\n   unsigned int dot3StatsSymbolErrors;\n"
- title: '}'
  contents:
  - '}

    '
- title: /* FDDI interface counters - see RFC 1512 */
  contents:
  - '/* FDDI interface counters - see RFC 1512 */

    '
- title: struct fddi_counters {
  contents:
  - "struct fddi_counters {\n  if_counters generic;\n"
- title: '}'
  contents:
  - '}

    '
- title: /* Token ring counters - see RFC 1748 */
  contents:
  - '/* Token ring counters - see RFC 1748 */

    '
- title: struct tokenring_counters {
  contents:
  - "struct tokenring_counters {\n  if_counters generic;\n  unsigned int dot5StatsLineErrors;\n\
    \  unsigned int dot5StatsBurstErrors;\n  unsigned int dot5StatsACErrors;\n  unsigned\
    \ int dot5StatsAbortTransErrors;\n  unsigned int dot5StatsInternalErrors;\n  unsigned\
    \ int dot5StatsLostFrameErrors;\n  unsigned int dot5StatsReceiveCongestions;\n\
    \  unsigned int dot5StatsFrameCopiedErrors;\n  unsigned int dot5StatsTokenErrors;\n\
    \  unsigned int dot5StatsSoftErrors;\n  unsigned int dot5StatsHardErrors;\n  unsigned\
    \ int dot5StatsSignalLoss;\n  unsigned int dot5StatsTransmitBeacons;\n  unsigned\
    \ int dot5StatsRecoverys;\n  unsigned int dot5StatsLobeWires;\n  unsigned int\
    \ dot5StatsRemoves;\n  unsigned int dot5StatsSingles;\n  unsigned int dot5StatsFreqErrors;\n"
- title: '}'
  contents:
  - '}

    '
- title: /* 100 BaseVG interface counters - see RFC 2020 */
  contents:
  - '/* 100 BaseVG interface counters - see RFC 2020 */

    '
- title: struct vg_counters {
  contents:
  - "struct vg_counters {\n  if_counters generic;\n  unsigned int dot12InHighPriorityFrames;\n\
    \  unsigned hyper dot12InHighPriorityOctets;\n  unsigned int dot12InNormPriorityFrames;\n\
    \  unsigned hyper dot12InNormPriorityOctets;\n  unsigned int dot12InIPMErrors;\n\
    \  unsigned int dot12InOversizeFrameErrors;\n  unsigned int dot12InDataErrors;\n\
    \  unsigned int dot12InNullAddressedFrames;\n  unsigned int dot12OutHighPriorityFrames;\n\
    \  unsigned hyper dot12OutHighPriorityOctets;\n  unsigned int dot12TransitionIntoTrainings;\n\
    \  unsigned hyper dot12HCInHighPriorityOctets;\n  unsigned hyper dot12HCInNormPriorityOctets;\n\
    \  unsigned hyper dot12HCOutHighPriorityOctets;\n"
- title: '}'
  contents:
  - '}

    '
- title: /* WAN counters */
  contents:
  - '/* WAN counters */

    '
- title: struct wan_counters {
  contents:
  - "struct wan_counters {\n  if_counters generic;\n"
- title: '}'
  contents:
  - '}

    '
- title: /* VLAN counters */
  contents:
  - '/* VLAN counters */

    '
- title: struct vlan_counters {
  contents:
  - "struct vlan_counters {\n  unsigned int vlan_id;\n  unsigned hyper octets;\n \
    \ unsigned int ucastPkts;\n  unsigned int multicastPkts;\n  unsigned int broadcastPkts;\n\
    \  unsigned int discards;\n"
- title: '}'
  contents:
  - '}

    '
- title: /* Counter data */
  contents:
  - '/* Counter data */

    '
- title: enum counters_version {
  contents:
  - "enum counters_version {\n   GENERIC      = 1,\n   ETHERNET     = 2,\n   TOKENRING\
    \    = 3,\n   FDDI         = 4,\n   VG           = 5,\n   WAN          = 6,\n\
    \   VLAN         = 7\n"
- title: '}'
  contents:
  - '}

    '
- title: union counters_type (counters_version version) {
  contents:
  - "union counters_type (counters_version version) {\n   case GENERIC:\n      if_counters\
    \ generic;\n   case ETHERNET:\n      ethernet_counters ethernet;\n   case TOKENRING:\n\
    \      tokenring_counters tokenring;\n   case FDDI:\n      fddi_counters fddi;\n\
    \   case VG:\n      vg_counters vg;\n   case WAN:\n      wan_counters wan;\n \
    \  case VLAN:\n      vlan_counters vlan;\n"
- title: '}'
  contents:
  - '}

    '
- title: /* Format of a single counter sample */
  contents:
  - '/* Format of a single counter sample */

    '
- title: struct counters_sample {
  contents:
  - "struct counters_sample {\n   unsigned int sequence_number;   /* Incremented with\
    \ each counter\n                                      sample generated by this\n\
    \                                      source_id */\n   unsigned int source_id;\
    \         /* sFlowDataSource encoded as\n                                    \
    \  follows:\n                                       The most significant byte\
    \ of the\n                                       source_id is used to indicate\
    \ the\n                                       type of sFlowDataSource\n      \
    \                                 (0 = ifIndex,\n                            \
    \           1 = smonVlanDataSource,\n                                       2\
    \ = entPhysicalEntry) and the\n                                           lower\
    \ three\n                                       bytes contain the relevant\n \
    \                                      index value.*/\n   unsigned int sampling_interval;\
    \ /* sFlowCounterSamplingInterval*/\n   counters_type counters;\n"
- title: '}'
  contents:
  - '}

    '
- title: /* Format of a sample datagram */
  contents:
  - '/* Format of a sample datagram */

    '
- title: enum sample_types {
  contents:
  - "enum sample_types {\n   FLOWSAMPLE  = 1,\n   COUNTERSSAMPLE = 2\n"
- title: '}'
  contents:
  - '}

    '
- title: union sample_type (sample_types sampletype) {
  contents:
  - "union sample_type (sample_types sampletype) {\n   case FLOWSAMPLE:\n      flow_sample\
    \ flowsample;\n   case COUNTERSSAMPLE:\n      counters_sample counterssample;\n"
- title: '}'
  contents:
  - '}

    '
- title: struct sample_datagram_v4 {
  contents:
  - "struct sample_datagram_v4 {\n   address agent_address           /* IP address\
    \ of sampling agent,\n                                      sFlowAgentAddress.\
    \ */\n   unsigned int sequence_number;  /* Incremented with each sample\n    \
    \                                 datagram generated */\n   unsigned int uptime;\
    \           /* Current time (in milliseconds since\n                         \
    \            device last booted).  Should be set\n                           \
    \          as close to datagram transmission\n                               \
    \      time as possible.*/\n   sample_type samples<>;         /* An array of flow,\
    \ counter and delay\n                                     samples */\n"
- title: '}'
  contents:
  - '}

    '
- title: enum datagram_version {
  contents:
  - "enum datagram_version {\n   VERSION4 = 4\n"
- title: '}'
  contents:
  - '}

    '
- title: union sample_datagram_type (datagram_version version) {
  contents:
  - "union sample_datagram_type (datagram_version version) {\n   case VERSION4:\n\
    \      sample_datagram_v4 datagram;\n"
- title: '}'
  contents:
  - '}

    '
- title: struct sample_datagram {
  contents:
  - "struct sample_datagram {\n   sample_datagram_type version;\n"
- title: '}'
  contents:
  - "}\n   The sFlow Datagram specification makes use of definitions from a\n   number\
    \ of existing RFCs [22], [23], [24], [25], [26], [27] and [28].\n"
- title: 5. Security Considerations
  contents:
  - "5. Security Considerations\n   Deploying a traffic monitoring system raises a\
    \ number of security\n   related issues.  sFlow does not provide specific security\
    \ mechanisms,\n   relying instead on proper deployment and configuration to maintain\
    \ an\n   adequate level of security.\n   While the deployment of traffic monitoring\
    \ systems does create some\n   risk, it also provides a powerful means of detecting\
    \ and tracing\n   unauthorized network activity.\n   This section is intended\
    \ to provide information that will help\n   understand potential risks and configuration\
    \ options for mitigating\n   those risks.\n"
- title: 5.1 Control
  contents:
  - "5.1 Control\n   The sFlow MIB is used to configure the generation of sFlow samples.\n\
    \   The security of SNMP, with access control lists, is usually\n   considered\
    \ adequate in an enterprise setting.  However, there are\n   situations when these\
    \ security measures are insufficient (for example\n   a WAN router) and SNMP configuration\
    \ control will be disabled.\n   When SNMP is disabled, a command line interface\
    \ is typically\n   provided.  The following arguments are required to configure\
    \ sFlow\n   sampling on an interface.\n   -sFlowDataSource               <source>\n\
    \   -sFlowPacketSamplingRate       <rate>\n   -sFlowCounterSamplingInterval  <interval>\n\
    \   -sFlowMaximumHeaderSize        <header size>\n   -sFlowMaximumDatagramSize\
    \      <datagram size>\n   -sFlowCollectorAddress         <address>\n   -sFlowCollectorPort\
    \            <port>\n"
- title: 5.2 Transport
  contents:
  - "5.2 Transport\n   Traffic information is sent unencrypted across the network\
    \ from the\n   sFlow Agent to the sFlow Analyzer and is thus vulnerable to\n \
    \  eavesdropping.  This risk can be limited by creating a secure\n   measurement\
    \ network and routing the sFlow Datagrams over this\n   network.  The choice of\
    \ technology for creating the secure\n   measurement network is deployment specific,\
    \ but could include the use\n   of VLANs or VPN tunnels.\n   The sFlow Analyzer\
    \ is vulnerable to attacks involving spoofed sFlow\n   Datagrams.  To limit this\
    \ vulnerability the sFlow Analyzer should\n   check sequence numbers and verify\
    \ source addresses.  If a secure\n   measurement network has been constructed\
    \ then only sFlow Datagrams\n   received from that network should be processed.\n"
- title: 5.3 Confidentiality
  contents:
  - "5.3 Confidentiality\n   Traffic information can reveal confidential information\
    \ about\n   individual network users.  The degree of visibility of application\n\
    \   level data can be controlled by limiting the number of header bytes\n   captured\
    \ by the sFlow agent.  In addition, packet sampling makes it\n   virtually impossible\
    \ to capture sequences of packets from an\n   individual transaction.\n   The\
    \ traffic patterns discernible by decoding the sFlow Datagrams in\n   the sFlow\
    \ Analyzer can reveal details of an individual's network\n   related activities\
    \ and due care should be taken to secure access to\n   the sFlow Analyzer.\n"
- title: 6. References
  contents:
  - "6. References\n   [1]   Sun Microsystems, Inc., \"XDR: External Data Representation\n\
    \         Standard\", RFC 1014, June 1987.\n   [2]   Harrington, D., Presuhn,\
    \ R., and B. Wijnen, \"An Architecture\n         for Describing SNMP Management\
    \ Frameworks\", RFC 2571, April\n         1999.\n   [3]   Rose, M. and K. McCloghrie,\
    \ \"Structure and Identification of\n         Management Information for TCP/IP-based\
    \ Internets\", STD 16, RFC\n         1155, May 1990.\n   [4]   Rose, M. and K.\
    \ McCloghrie, \"Concise MIB Definitions\", STD 16,\n         RFC 1212, March 1991.\n\
    \   [5]   Rose, M., \"A Convention for Defining Traps for use with the\n     \
    \    SNMP\", RFC 1215, March 1991.\n   [6]   McCloghrie, K., Perkins, D., Schoenwaelder,\
    \ J., Case, J., Rose,\n         M. and S. Waldbusser, \"Structure of Management\
    \ Information\n         Version 2 (SMIv2)\", STD 58, RFC 2578, April 1999.\n \
    \  [7]   McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose,\n   \
    \      M. and S. Waldbusser, \"Textual Conventions for SMIv2\", STD 58,\n    \
    \     RFC 2579, April 1999.\n   [8]   McCloghrie, K., Perkins, D., Schoenwaelder,\
    \ J., Case, J., Rose,\n         M. and S. Waldbusser, \"Conformance Statements\
    \ for SMIv2\", STD\n         58, RFC 2580, April 1999.\n   [9]   Case, J., Fedor,\
    \ M., Schoffstall, M. and J. Davin, \"Simple\n         Network Management Protocol\"\
    , STD 15, RFC 1157, May 1990.\n   [10]  Case, J., McCloghrie, K., Rose, M. and\
    \ S. Waldbusser,\n         \"Introduction to Community-based SNMPv2\", RFC 1901,\
    \ January\n         1996.\n   [11]  Case, J., McCloghrie, K., Rose, M. and S.\
    \ Waldbusser,\n         \"Transport Mappings for Version 2 of the Simple Network\n\
    \         Management Protocol (SNMPv2)\", RFC 1906, January 1996.\n   [12]  Case,\
    \ J., Harrington D., Presuhn R. and B. Wijnen, \"Message\n         Processing\
    \ and Dispatching for the Simple Network Management\n         Protocol (SNMP)\"\
    , RFC 2572, April 1999.\n   [13]  Blumenthal, U. and B. Wijnen, \"User-based Security\
    \ Model (USM)\n         for version 3 of the Simple Network Management Protocol\n\
    \         (SNMPv3)\", RFC 2574, April 1999.\n   [14]  Case, J., McCloghrie, K.,\
    \ Rose, M. and S. Waldbusser, \"Protocol\n         Operations for Version 2 of\
    \ the Simple Network Management\n         Protocol (SNMPv2)\", RFC 1905, January\
    \ 1996.\n   [15]  Levi, D., Meyer, P. and B. Stewart, \"SNMPv3 Applications\"\
    , RFC\n         2573, April 1999.\n   [16]  Wijnen, B., Presuhn, R. and K. McCloghrie,\
    \ \"View-based Access\n         Control Model (VACM) for the Simple Network Management\
    \ Protocol\n         (SNMP)\", RFC 2575, April 1999.\n   [17]  Case, J., Mundy,\
    \ R., Partain, D. and B. Stewart, \"Introduction\n         to Version 3 of the\
    \ Internet-standard Network Management\n         Framework\", RFC 2570, April\
    \ 1999.\n   [18]  Waldbusser, S., \"Remote Network Monitoring Management\n   \
    \      Information Base\", RFC 2819, May 2000.\n   [19]  Waterman, R., Lahaye,\
    \ B., Romascanu, D. and S. Waldbusser,\n         \"Remote Network Monitoring MIB\
    \ Extensions for Switched Networks\n         Version 1.0\", RFC 2613, June 1999.\n\
    \   [20]  Daniele, M., Haberman, B., Routhier, S. and J. Schoenwaelder,\n    \
    \     \"Textual Conventions for Internet Network Addresses\", RFC 2851,\n    \
    \     June 2000.\n   [21]  Brownlee, N., \"Traffic Flow Measurement: Meter MIB\"\
    , RFC 2720,\n         October 1999.\n   [22]  Smith, A., Flick, J., de Graaf,\
    \ K., Romanscanu, D., McMaster,\n         D., McCloghrie, K. and S. Roberts, \"\
    Definition of Managed\n         Objects for IEEE 802.3 Medium Attachment Units\
    \ (MAUs)\", RFC\n         2668, August 1999.\n   [23]  McCloghrie, K. and F. Kastenholz,\
    \ \"The Interfaces Group MIB\n         using SMIv2\", RFC 2233, November 1997.\n\
    \   [24]  Flick, J. and J. Johnson, \"Definition of Managed Objects for\n    \
    \     the Ethernet-like Interface Types\", RFC 2358, June 1998.\n   [25]  Case,\
    \ J., \"FDDI Management Information Base\", RFC 1512,\n         September 1993.\n\
    \   [26]  McCloghrie, K. and E. Decker, \"IEEE 802.5 MIB using SMIv2\", RFC\n\
    \         1748, December 1994.\n   [27]  Flick, J., \"Definitions of Managed Objects\
    \ for IEEE 802.12\n         Interfaces\", RFC 2020, October 1996.\n   [28]  Willis,\
    \ S., Burruss, J. and J. Chu, \"Definitions of Managed\n         Objects for the\
    \ Fourth Version of the Border Gateway Protocol\n         (BGP-4) using SMIv2\"\
    , RFC 1657, July 1994.\n"
- title: 7. Authors' Addresses
  contents:
  - "7. Authors' Addresses\n   Peter Phaal\n   InMon Corporation\n   1404 Irving Street\n\
    \   San Francisco, CA 94122\n   Phone: (415) 661-6343\n   EMail: peter_phaal@INMON.COM\n\
    \   Sonia Panchen\n   InMon Corporation\n   1404 Irving Street\n   San Francisco,\
    \ CA 94122\n   Phone: (415) 661-6343\n   EMail: sonia_panchen@INMON.COM\n   Neil\
    \ McKee\n   InMon Corporation\n   1404 Irving Street\n   San Francisco, CA 94122\n\
    \   Phone: (415) 661-6343\n   EMail: neil_mckee@INMON.COM\n"
- title: 8.  Intellectual Property Statement
  contents:
  - "8.  Intellectual Property Statement\n   The IETF takes no position regarding\
    \ the validity or scope of any\n   intellectual property or other rights that\
    \ might be claimed to\n   pertain to the implementation or use of the technology\
    \ described in\n   this document or the extent to which any license under such\
    \ rights\n   might or might not be available; neither does it represent that it\n\
    \   has made any effort to identify any such rights.  Information on the\n   IETF's\
    \ procedures with respect to rights in standards-track and\n   standards-related\
    \ documentation can be found in BCP-11.  Copies of\n   claims of rights made available\
    \ for publication and any assurances of\n   licenses to be made available, or\
    \ the result of an attempt made to\n   obtain a general license or permission\
    \ for the use of such\n   proprietary rights by implementors or users of this\
    \ specification can\n   be obtained from the IETF Secretariat.\n   The IETF invites\
    \ any interested party to bring to its attention any\n   copyrights, patents or\
    \ patent applications, or other proprietary\n   rights which may cover technology\
    \ that may be required to practice\n   this standard.  Please address the information\
    \ to the IETF Executive\n   Director.\n"
- title: 9.  Full Copyright Statement
  contents:
  - "9.  Full Copyright Statement\n   Copyright (C) The Internet Society (2001). \
    \ All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
