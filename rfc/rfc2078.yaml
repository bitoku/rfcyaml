- title: __initial_text__
  contents:
  - '   Generic Security Service Application Program Interface, Version 2

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   The Generic Security Service Application Program Interface (GSS-API),\n\
    \   as defined in RFC-1508, provides security services to callers in a\n   generic\
    \ fashion, supportable with a range of underlying mechanisms\n   and technologies\
    \ and hence allowing source-level portability of\n   applications to different\
    \ environments. This specification defines\n   GSS-API services and primitives\
    \ at a level independent of underlying\n   mechanism and programming language\
    \ environment, and is to be\n   complemented by other, related specifications:\n\
    \      documents defining specific parameter bindings for particular\n      language\
    \ environments\n      documents defining token formats, protocols, and procedures\
    \ to be\n      implemented in order to realize GSS-API services atop particular\n\
    \      security mechanisms\n   This memo revises RFC-1508, making specific, incremental\
    \ changes in\n   response to implementation experience and liaison requests. It\
    \ is\n   intended, therefore, that this memo or a successor version thereto\n\
    \   will become the basis for subsequent progression of the GSS-API\n   specification\
    \ on the standards track.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.1.2: Tokens....................................................\
    \  9\n   1.1.3:  Security Contexts........................................ 10\n\
    \   1.1.4:  Mechanism Types.......................................... 11\n   1.1.5:\
    \  Naming................................................... 12\n   1.1.6:  Channel\
    \ Bindings......................................... 14\n   1.2:  GSS-API Features\
    \ and Issues................................ 15\n   1.2.1:  Status Reporting.........................................\
    \ 15\n   1.2.2: Per-Message Security Service Availability................. 17\n\
    \   1.2.3: Per-Message Replay Detection and Sequencing............... 18\n   1.2.4:\
    \  Quality of Protection.................................... 20\n   1.2.5: Anonymity\
    \ Support......................................... 21\n   1.2.6: Initialization............................................\
    \ 22\n   1.2.7: Per-Message Protection During Context Establishment....... 22\n\
    \   1.2.8: Implementation Robustness................................. 23\n   2:\
    \  Interface Descriptions....................................... 23\n   2.1: \
    \ Credential management calls................................ 25\n   2.1.1:  GSS_Acquire_cred\
    \ call.................................... 26\n   2.1.2:  GSS_Release_cred call....................................\
    \ 28\n   2.1.3:  GSS_Inquire_cred call.................................... 29\n\
    \   2.1.4:  GSS_Add_cred call........................................ 31\n   2.1.5:\
    \  GSS_Inquire_cred_by_mech call............................ 33\n   2.2:  Context-level\
    \ calls........................................ 34\n   2.2.1:  GSS_Init_sec_context\
    \ call................................ 34\n   2.2.2:  GSS_Accept_sec_context call..............................\
    \ 40\n   2.2.3:  GSS_Delete_sec_context call.............................. 44\n\
    \   2.2.4:  GSS_Process_context_token call........................... 46\n   2.2.5:\
    \  GSS_Context_time call.................................... 47\n   2.2.6:  GSS_Inquire_context\
    \ call................................. 47\n   2.2.7:  GSS_Wrap_size_limit call.................................\
    \ 49\n   2.2.8:  GSS_Export_sec_context call.............................. 50\n\
    \   2.2.9:  GSS_Import_sec_context call.............................. 52\n   2.3:\
    \  Per-message calls.......................................... 53\n   2.3.1: \
    \ GSS_GetMIC call.......................................... 54\n   2.3.2:  GSS_VerifyMIC\
    \ call....................................... 55\n   2.3.3:  GSS_Wrap call............................................\
    \ 56\n   2.3.4:  GSS_Unwrap call.......................................... 58\n\
    \   2.4:  Support calls.............................................. 59\n   2.4.1:\
    \  GSS_Display_status call.................................. 60\n   2.4.2:  GSS_Indicate_mechs\
    \ call.................................. 60\n   2.4.3:  GSS_Compare_name call....................................\
    \ 61\n   2.4.4:  GSS_Display_name call.................................... 62\n\
    \   2.4.5:  GSS_Import_name call..................................... 63\n   2.4.6:\
    \  GSS_Release_name call.................................... 64\n   2.4.7:  GSS_Release_buffer\
    \ call.................................. 65\n   2.4.8:  GSS_Release_OID_set call.................................\
    \ 65\n   2.4.9:  GSS_Create_empty_OID_set call............................ 66\n\
    \   2.4.10: GSS_Add_OID_set_member call.............................. 67\n   2.4.11:\
    \ GSS_Test_OID_set_member call............................. 67\n   2.4.12: GSS_Release_OID\
    \ call..................................... 68\n   2.4.13: GSS_OID_to_str call......................................\
    \ 68\n   2.4.14: GSS_Str_to_OID call...................................... 69\n\
    \   2.4.15: GSS_Inquire_names_for_mech call.......................... 69\n   2.4.16:\
    \ GSS_Inquire_mechs_for_name call.......................... 70\n   2.4.17: GSS_Canonicalize_name\
    \ call............................... 71\n   2.4.18: GSS_Export_name call.....................................\
    \ 72\n   2.4.19: GSS_Duplicate_name call.................................. 73\n\
    \   3: Data Structure Definitions for GSS-V2 Usage................... 73\n   3.1:\
    \ Mechanism-Independent Token Format.......................... 74\n   3.2: Mechanism-Independent\
    \ Exported Name Object Format........... 77\n   4: Name Type Definitions.........................................\
    \ 77\n   4.1: Host-Based Service Name Form................................ 77\n\
    \   4.2: User Name Form.............................................. 78\n   4.3:\
    \ Machine UID Form............................................ 78\n   4.4: String\
    \ UID Form............................................. 79\n   5:  Mechanism-Specific\
    \ Example Scenarios......................... 79\n   5.1: Kerberos V5, single-TGT.....................................\
    \ 79\n   5.2: Kerberos V5, double-TGT..................................... 80\n\
    \   5.3:  X.509 Authentication Framework............................. 81\n   6:\
    \  Security Considerations...................................... 82\n   7:  Related\
    \ Activities........................................... 82\n   Appendix A: Mechanism\
    \ Design Constraints......................... 83\n   Appendix B: Compatibility\
    \ with GSS-V1............................ 83\n"
- title: '1: GSS-API Characteristics and Concepts'
  contents:
  - "1: GSS-API Characteristics and Concepts\n   GSS-API operates in the following\
    \ paradigm.  A typical GSS-API caller\n   is itself a communications protocol,\
    \ calling on GSS-API in order to\n   protect its communications with authentication,\
    \ integrity, and/or\n   confidentiality security services.  A GSS-API caller accepts\
    \ tokens\n   provided to it by its local GSS-API implementation and transfers\
    \ the\n   tokens to a peer on a remote system; that peer passes the received\n\
    \   tokens to its local GSS-API implementation for processing. The\n   security\
    \ services available through GSS-API in this fashion are\n   implementable (and\
    \ have been implemented) over a range of underlying\n   mechanisms based on secret-key\
    \ and public-key cryptographic\n   technologies.\n   The GSS-API separates the\
    \ operations of initializing a security\n   context between peers, achieving peer\
    \ entity authentication (This\n   security service definition, and other definitions\
    \ used in this\n   document, corresponds to that provided in International Standard\
    \ ISO\n   7498-2-1988(E), Security Architecture.) (GSS_Init_sec_context()  and\n\
    \   GSS_Accept_sec_context() calls), from the operations of providing\n   per-message\
    \ data origin authentication and data integrity protection\n   (GSS_GetMIC() \
    \ and GSS_VerifyMIC()  calls) for messages subsequently\n   transferred in conjunction\
    \ with that context.  When establishing a\n   security context, the GSS-API enables\
    \ a context initiator to\n   optionally permit its credentials to be delegated,\
    \ meaning that the\n   context acceptor may initiate further security contexts\
    \ on behalf of\n   the initiating caller. Per-message GSS_Wrap()  and GSS_Unwrap()\
    \ calls\n   provide the data origin authentication and data integrity services\n\
    \   which GSS_GetMIC()  and GSS_VerifyMIC() offer, and also support\n   selection\
    \ of confidentiality services as a caller option.  Additional\n   calls provide\
    \ supportive functions to the GSS-API's users.\n   The following paragraphs provide\
    \ an example illustrating the\n   dataflows involved in use of the GSS-API by\
    \ a client and server in a\n   mechanism-independent fashion, establishing a security\
    \ context and\n   transferring a protected message. The example assumes that credential\n\
    \   acquisition has already been completed.  The example assumes that the\n  \
    \ underlying authentication technology is capable of authenticating a\n   client\
    \ to a server using elements carried within a single token, and\n   of authenticating\
    \ the server to the client (mutual authentication)\n   with a single returned\
    \ token; this assumption holds for presently-\n   documented CAT mechanisms but\
    \ is not necessarily true for other\n   cryptographic technologies and associated\
    \ protocols.\n   The client calls GSS_Init_sec_context()  to establish a security\n\
    \   context to the server identified by targ_name, and elects to set the\n   mutual_req_flag\
    \ so that mutual authentication is performed in the\n   course of context establishment.\
    \ GSS_Init_sec_context()  returns an\n   output_token to be passed to the server,\
    \ and indicates\n   GSS_S_CONTINUE_NEEDED status pending completion of the mutual\n\
    \   authentication sequence. Had mutual_req_flag not been set, the\n   initial\
    \ call to GSS_Init_sec_context()  would have returned\n   GSS_S_COMPLETE status.\
    \ The client sends the output_token to the\n   server.\n   The server passes the\
    \ received token as the input_token parameter to\n   GSS_Accept_sec_context().\
    \  GSS_Accept_sec_context indicates\n   GSS_S_COMPLETE status, provides the client's\
    \ authenticated identity\n   in the src_name result, and provides an output_token\
    \ to be passed to\n   the client. The server sends the output_token to the client.\n\
    \   The client passes the received token as the input_token parameter to\n   a\
    \ successor call to GSS_Init_sec_context(),  which processes data\n   included\
    \ in the token in order to achieve mutual authentication from\n   the client's\
    \ viewpoint. This call to GSS_Init_sec_context()  returns\n   GSS_S_COMPLETE status,\
    \ indicating successful mutual authentication\n   and the completion of context\
    \ establishment for this example.\n   The client generates a data message and\
    \ passes it to GSS_Wrap().\n   GSS_Wrap() performs data origin authentication,\
    \ data integrity, and\n   (optionally) confidentiality processing on the message\
    \ and\n   encapsulates the result into output_message, indicating\n   GSS_S_COMPLETE\
    \ status. The client sends the output_message to the\n   server.\n   The server\
    \ passes the received message to GSS_Unwrap().  GSS_Unwrap()\n   inverts the encapsulation\
    \ performed by GSS_Wrap(),  deciphers the\n   message if the optional confidentiality\
    \ feature was applied, and\n   validates the data origin authentication and data\
    \ integrity checking\n   quantities. GSS_Unwrap()  indicates successful validation\
    \ by\n   returning GSS_S_COMPLETE status along with the resultant\n   output_message.\n\
    \   For purposes of this example, we assume that the server knows by\n   out-of-band\
    \ means that this context will have no further use after\n   one protected message\
    \ is transferred from client to server. Given\n   this premise, the server now\
    \ calls GSS_Delete_sec_context() to flush\n   context-level information.  Optionally,\
    \ the server-side application\n   may provide a token buffer to GSS_Delete_sec_context(),\
    \ to receive a\n   context_token to be transferred to the client in order to request\n\
    \   that client-side context-level information be deleted.\n   If a context_token\
    \ is transferred, the client passes the\n   context_token to GSS_Process_context_token(),\
    \ which returns\n   GSS_S_COMPLETE status after deleting context-level information\
    \ at the\n   client system.\n   The GSS-API design assumes and addresses several\
    \ basic goals,\n   including:\n      Mechanism independence: The GSS-API defines\
    \ an interface to\n      cryptographically implemented strong authentication and\
    \ other\n      security services at a generic level which is independent of\n\
    \      particular underlying mechanisms. For example, GSS-API-provided\n     \
    \ services can be implemented by secret-key technologies (e.g.,\n      Kerberos)\
    \ or public-key approaches (e.g., X.509).\n      Protocol environment independence:\
    \ The GSS-API is independent of\n      the communications protocol suites with\
    \ which it is employed,\n      permitting use in a broad range of protocol environments.\
    \ In\n      appropriate environments, an intermediate implementation \"veneer\"\
    \n      which is oriented to a particular communication protocol (e.g.,\n    \
    \  Remote Procedure Call (RPC)) may be interposed between\n      applications\
    \ which call that protocol and the GSS-API, thereby\n      invoking GSS-API facilities\
    \ in conjunction with that protocol's\n      communications invocations.\n   \
    \   Protocol association independence: The GSS-API's security context\n      construct\
    \ is independent of communications protocol association\n      constructs. This\
    \ characteristic allows a single GSS-API\n      implementation to be utilized\
    \ by a variety of invoking protocol\n      modules on behalf of those modules'\
    \ calling applications. GSS-API\n      services can also be invoked directly by\
    \ applications, wholly\n      independent of protocol associations.\n      Suitability\
    \ to a range of implementation placements: GSS-API\n      clients are not constrained\
    \ to reside within any Trusted Computing\n      Base (TCB) perimeter defined on\
    \ a system where the GSS-API is\n      implemented; security services are specified\
    \ in a manner suitable\n      to both intra-TCB and extra-TCB callers.\n"
- title: '1.1: GSS-API Constructs'
  contents:
  - "1.1: GSS-API Constructs\n   This section describes the basic elements comprising\
    \ the GSS-API.\n"
- title: '1.1.1:  Credentials'
  contents:
  - '1.1.1:  Credentials

    '
- title: '1.1.1.1: Credential Constructs and Concepts'
  contents:
  - "1.1.1.1: Credential Constructs and Concepts\n   Credentials provide the prerequisites\
    \ which permit GSS-API peers to\n   establish security contexts with each other.\
    \ A caller may designate\n   that the credential elements which are to be applied\
    \ for context\n   initiation or acceptance be selected by default.  Alternately,\
    \ those\n   GSS-API callers which need to make explicit selection of particular\n\
    \   credentials structures may make references to those credentials\n   through\
    \ GSS-API-provided credential handles (\"cred_handles\").  In all\n   cases, callers'\
    \ credential references are indirect, mediated by GSS-\n   API implementations\
    \ and not requiring callers to access the selected\n   credential elements.\n\
    \   A single credential structure may be used to initiate outbound\n   contexts\
    \ and to accept inbound contexts. Callers needing to operate\n   in only one of\
    \ these modes may designate this fact when credentials\n   are acquired for use,\
    \ allowing underlying mechanisms to optimize\n   their processing and storage\
    \ requirements. The credential elements\n   defined by a particular mechanism\
    \ may contain multiple cryptographic\n   keys, e.g., to enable authentication\
    \ and message encryption to be\n   performed with different algorithms.\n   A\
    \ GSS-API credential structure may contain multiple credential\n   elements, each\
    \ containing mechanism-specific information for a\n   particular underlying mechanism\
    \ (mech_type), but the set of elements\n   within a given credential structure\
    \ represent a common entity.  A\n   credential structure's contents will vary\
    \ depending on the set of\n   mech_types supported by a particular GSS-API implementation.\
    \ Each\n   credential element identifies the data needed by its mechanism in\n\
    \   order to establish contexts on behalf of a particular principal, and\n   may\
    \ contain separate credential references for use in context\n   initiation and\
    \ context acceptance.  Multiple credential elements\n   within a given credential\
    \ having overlapping combinations of\n   mechanism, usage mode, and validity period\
    \ are not permitted.\n   Commonly, a single mech_type will be used for all security\
    \ contexts\n   established by a particular initiator to a particular target. A\
    \ major\n   motivation for supporting credential sets representing multiple\n\
    \   mech_types is to allow initiators on systems which are equipped to\n   handle\
    \ multiple types to initiate contexts to targets on other\n   systems which can\
    \ accommodate only a subset of the set supported at\n   the initiator's system.\n"
- title: '1.1.1.2: Credential Management'
  contents:
  - "1.1.1.2: Credential Management\n   It is the responsibility of underlying system-specific\
    \ mechanisms and\n   OS functions below the GSS-API to ensure that the ability\
    \ to acquire\n   and use credentials associated with a given identity is constrained\n\
    \   to appropriate processes within a system. This responsibility should\n   be\
    \ taken seriously by implementors, as the ability for an entity to\n   utilize\
    \ a principal's credentials is equivalent to the entity's\n   ability to successfully\
    \ assert that principal's identity.\n   Once a set of GSS-API credentials is established,\
    \ the transferability\n   of that credentials set to other processes or analogous\
    \ constructs\n   within a system is a local matter, not defined by the GSS-API.\
    \ An\n   example local policy would be one in which any credentials received\n\
    \   as a result of login to a given user account, or of delegation of\n   rights\
    \ to that account, are accessible by, or transferable to,\n   processes running\
    \ under that account.\n   The credential establishment process (particularly when\
    \ performed on\n   behalf of users rather than server processes) is likely to\
    \ require\n   access to passwords or other quantities which should be protected\n\
    \   locally and exposed for the shortest time possible. As a result, it\n   will\
    \ often be appropriate for preliminary credential establishment to\n   be performed\
    \ through local means at user login time, with the\n   result(s) cached for subsequent\
    \ reference. These preliminary\n   credentials would be set aside (in a system-specific\
    \ fashion) for\n   subsequent use, either:\n      to be accessed by an invocation\
    \ of the GSS-API GSS_Acquire_cred()\n      call, returning an explicit handle\
    \ to reference that credential\n      to comprise default credential elements\
    \ to be installed, and to be\n      used when default credential behavior is requested\
    \ on behalf of a\n      process\n"
- title: '1.1.1.3: Default Credential Resolution'
  contents:
  - "1.1.1.3: Default Credential Resolution\n   The gss_init_sec_context and gss_accept_sec_context\
    \ routines allow\n   the value GSS_C_NO_CREDENTIAL to be specified as their credential\n\
    \   handle parameter.  This special credential-handle indicates a desire\n   by\
    \ the application to act as a default principal.  While individual\n   GSS-API\
    \ implementations are free to determine such default behavior\n   as appropriate\
    \ to the mechanism, the following default behavior by\n   these routines is recommended\
    \ for portability:\n   GSS_Init_sec_context:\n      (i) If there is only a single\
    \ principal capable of initiating\n      security contexts that the application\
    \ is authorized to act on\n      behalf of, then that principal shall be used,\
    \ otherwise\n      (ii) If the platform maintains a concept of a default network-\n\
    \      identity, and if the application is authorized to act on behalf of\n  \
    \    that identity for the purpose of initiating security contexts,\n      then\
    \ the principal corresponding to that identity shall be used,\n      otherwise\n\
    \      (iii) If the platform maintains a concept of a default local\n      identity,\
    \ and provides a means to map local identities into\n      network-identities,\
    \ and if the application is authorized to act on\n      behalf of the network-identity\
    \ image of the default local identity\n      for the purpose of initiating security\
    \ contexts, then the\n      principal corresponding to that identity shall be\
    \ used, otherwise\n      (iv) A user-configurable default identity should be used.\n\
    \   GSS_Accept_sec_context:\n      (i) If there is only a single authorized principal\
    \ identity\n      capable of accepting security contexts, then that principal\
    \ shall\n      be used, otherwise\n      (ii) If the mechanism can determine the\
    \ identity of the target\n      principal by examining the context-establishment\
    \ token, and if the\n      accepting application is authorized to act as that\
    \ principal for\n      the purpose of accepting security contexts, then that principal\n\
    \      identity shall be used, otherwise\n      (iii) If the mechanism supports\
    \ context acceptance by any\n      principal, and mutual authentication was not\
    \ requested, any\n      principal that the application is authorized to accept\
    \ security\n      contexts under may be used, otherwise\n      (iv) A user-configurable\
    \ default identity shall be used.\n   The purpose of the above rules is to allow\
    \ security contexts to be\n   established by both initiator and acceptor using\
    \ the default behavior\n   wherever possible.  Applications requesting default\
    \ behavior are\n   likely to be more portable across mechanisms and platforms\
    \ than ones\n   that use GSS_Acquire_cred to request a specific identity.\n"
- title: '1.1.2: Tokens'
  contents:
  - "1.1.2: Tokens\n   Tokens are data elements transferred between GSS-API callers,\
    \ and are\n   divided into two classes. Context-level tokens are exchanged in\
    \ order\n   to establish and manage a security context between peers. Per-message\n\
    \   tokens relate to an established context and are exchanged to provide\n   protective\
    \ security services (i.e., data origin authentication,\n   integrity, and optional\
    \ confidentiality) for corresponding data\n   messages.\n   The first context-level\
    \ token obtained from GSS_Init_sec_context() is\n   required to indicate at its\
    \ very beginning a globally-interpretable\n   mechanism identifier, i.e., an Object\
    \ Identifier (OID) of the\n   security mechanism. The remaining part of this token\
    \ as well as the\n   whole content of all other tokens are specific to the particular\n\
    \   underlying mechanism used to support the GSS-API. Section 3 of this\n   document\
    \ provides, for designers of GSS-API support mechanisms, the\n   description of\
    \ the header of the first context-level token which is\n   then followed by mechanism-specific\
    \ information.\n   Tokens' contents are opaque from the viewpoint of GSS-API callers.\n\
    \   They are generated within the GSS-API implementation at an end\n   system,\
    \ provided to a GSS-API caller to be transferred to the peer\n   GSS-API caller\
    \ at a remote end system, and processed by the GSS-API\n   implementation at that\
    \ remote end system. Tokens may be output by\n   GSS-API calls (and should be\
    \ transferred to GSS-API peers) whether or\n   not the calls' status indicators\
    \ indicate successful completion.\n   Token transfer may take place in an in-band\
    \ manner, integrated into\n   the same protocol stream used by the GSS-API callers\
    \ for other data\n   transfers, or in an out-of-band manner across a logically\
    \ separate\n   channel.\n   Different GSS-API tokens are used for different purposes\
    \ (e.g.,\n   context initiation, context acceptance, protected message data on\
    \ an\n   established context), and it is the responsibility of a GSS-API\n   caller\
    \ receiving tokens to distinguish their types, associate them\n   with corresponding\
    \ security contexts, and pass them to appropriate\n   GSS-API processing routines.\
    \  Depending on the caller protocol\n   environment, this distinction may be accomplished\
    \ in several ways.\n   The following examples illustrate means through which tokens'\
    \ types\n   may be distinguished:\n      - implicit tagging based on state information\
    \ (e.g., all tokens on\n      a new association are considered to be context establishment\n\
    \      tokens until context establishment is completed, at which point\n     \
    \ all tokens are considered to be wrapped data objects for that\n      context),\n\
    \      - explicit tagging at the caller protocol level,\n      - a hybrid of these\
    \ approaches.\n   Commonly, the encapsulated data within a token includes internal\n\
    \   mechanism-specific tagging information, enabling mechanism-level\n   processing\
    \ modules to distinguish tokens used within the mechanism\n   for different purposes.\
    \  Such internal mechanism-level tagging is\n   recommended to mechanism designers,\
    \ and enables mechanisms to\n   determine whether a caller has passed a particular\
    \ token for\n   processing by an inappropriate GSS-API routine.\n   Development\
    \ of GSS-API support primitives based on a particular\n   underlying cryptographic\
    \ technique and protocol (i.e., conformant to\n   a specific GSS-API mechanism\
    \ definition) does not necessarily imply\n   that GSS-API callers using that GSS-API\
    \ mechanism will be able to\n   interoperate with peers invoking the same technique\
    \ and protocol\n   outside the GSS-API paradigm, or with peers implementing a\
    \ different\n   GSS-API mechanism based on the same underlying technology.  The\n\
    \   format of GSS-API tokens defined in conjunction with a particular\n   mechanism,\
    \ and the techniques used to integrate those tokens into\n   callers' protocols,\
    \ may not be interoperable with the tokens used by\n   non-GSS-API callers of\
    \ the same underlying technique.\n"
- title: '1.1.3:  Security Contexts'
  contents:
  - "1.1.3:  Security Contexts\n   Security contexts are established between peers,\
    \ using credentials\n   established locally in conjunction with each peer or received\
    \ by\n   peers via delegation. Multiple contexts may exist simultaneously\n  \
    \ between a pair of peers, using the same or different sets of\n   credentials.\
    \ Coexistence of multiple contexts using different\n   credentials allows graceful\
    \ rollover when credentials expire.\n   Distinction among multiple contexts based\
    \ on the same credentials\n   serves applications by distinguishing different\
    \ message streams in a\n   security sense.\n   The GSS-API is independent of underlying\
    \ protocols and addressing\n   structure, and depends on its callers to transport\
    \ GSS-API-provided\n   data elements. As a result of these factors, it is a caller\n\
    \   responsibility to parse communicated messages, separating GSS-API-\n   related\
    \ data elements from caller-provided data.  The GSS-API is\n   independent of\
    \ connection vs. connectionless orientation of the\n   underlying communications\
    \ service.\n   No correlation between security context and communications protocol\n\
    \   association is dictated. (The optional channel binding facility,\n   discussed\
    \ in Section 1.1.6 of this document, represents an\n   intentional exception to\
    \ this rule, supporting additional protection\n   features within GSS-API supporting\
    \ mechanisms.) This separation\n   allows the GSS-API to be used in a wide range\
    \ of communications\n   environments, and also simplifies the calling sequences\
    \ of the\n   individual calls. In many cases (depending on underlying security\n\
    \   protocol, associated mechanism, and availability of cached\n   information),\
    \ the state information required for context setup can be\n   sent concurrently\
    \ with initial signed user data, without interposing\n   additional message exchanges.\n"
- title: '1.1.4:  Mechanism Types'
  contents:
  - "1.1.4:  Mechanism Types\n   In order to successfully establish a security context\
    \ with a target\n   peer, it is necessary to identify an appropriate underlying\
    \ mechanism\n   type (mech_type) which both initiator and target peers support.\
    \ The\n   definition of a mechanism embodies not only the use of a particular\n\
    \   cryptographic technology (or a hybrid or choice among alternative\n   cryptographic\
    \ technologies), but also definition of the syntax and\n   semantics of data element\
    \ exchanges which that mechanism will employ\n   in order to support security\
    \ services.\n   It is recommended that callers initiating contexts specify the\n\
    \   \"default\" mech_type value, allowing system-specific functions within\n \
    \  or invoked by the GSS-API implementation to select the appropriate\n   mech_type,\
    \ but callers may direct that a particular mech_type be\n   employed when necessary.\n\
    \   The means for identifying a shared mech_type to establish a security\n   context\
    \ with a peer will vary in different environments and\n   circumstances; examples\
    \ include (but are not limited to):\n      use of a fixed mech_type, defined by\
    \ configuration, within an\n      environment\n      syntactic convention on a\
    \ target-specific basis, through\n      examination of a target's name\n     \
    \ lookup of a target's name in a naming service or other database in\n      order\
    \ to identify mech_types supported by that target\n      explicit negotiation\
    \ between GSS-API callers in advance of\n      security context setup\n   When\
    \ transferred between GSS-API peers, mech_type specifiers (per\n   Section 3,\
    \ represented as Object Identifiers (OIDs)) serve to qualify\n   the interpretation\
    \ of associated tokens. (The structure and encoding\n   of Object Identifiers\
    \ is defined in ISO/IEC 8824, \"Specification of\n   Abstract Syntax Notation\
    \ One (ASN.1)\" and in ISO/IEC 8825,\n   \"Specification of Basic Encoding Rules\
    \ for Abstract Syntax Notation\n   One (ASN.1)\".) Use of hierarchically structured\
    \ OIDs serves to\n   preclude ambiguous interpretation of mech_type specifiers.\
    \ The OID\n   representing the DASS MechType, for example, is 1.3.12.2.1011.7.5,\n\
    \   and that of the Kerberos V5 mechanism, once advanced to the level of\n   Proposed\
    \ Standard, will be 1.2.840.113554.1.2.2.\n"
- title: '1.1.5:  Naming'
  contents:
  - "1.1.5:  Naming\n   The GSS-API avoids prescribing naming structures, treating\
    \ the names\n   which are transferred across the interface in order to initiate\
    \ and\n   accept security contexts as opaque objects.  This approach supports\n\
    \   the GSS-API's goal of implementability atop a range of underlying\n   security\
    \ mechanisms, recognizing the fact that different mechanisms\n   process and authenticate\
    \ names which are presented in different\n   forms. Generalized services offering\
    \ translation functions among\n   arbitrary sets of naming environments are outside\
    \ the scope of the\n   GSS-API; availability and use of local conversion functions\
    \ to\n   translate among the naming formats supported within a given end\n   system\
    \ is anticipated.\n   Different classes of name representations are used in conjunction\n\
    \   with different GSS-API parameters:\n      - Internal form (denoted in this\
    \ document by INTERNAL NAME),\n      opaque to callers and defined by individual\
    \ GSS-API\n      implementations.  GSS-API implementations supporting multiple\n\
    \      namespace types must maintain internal tags to disambiguate the\n     \
    \ interpretation of particular names.  A Mechanism Name (MN) is a\n      special\
    \ case of INTERNAL NAME, guaranteed to contain elements\n      corresponding to\
    \ one and only one mechanism; calls which are\n      guaranteed to emit MNs or\
    \ which require MNs as input are so\n      identified within this specification.\n\
    \      - Contiguous string (\"flat\") form (denoted in this document by\n    \
    \  OCTET STRING); accompanied by OID tags identifying the namespace\n      to\
    \ which they correspond.  Depending on tag value, flat names may\n      or may\
    \ not be printable strings for direct acceptance from and\n      presentation\
    \ to users. Tagging of flat names allows GSS-API\n      callers and underlying\
    \ GSS-API mechanisms to disambiguate name\n      types and to determine whether\
    \ an associated name's type is one\n      which they are capable of processing,\
    \ avoiding aliasing problems\n      which could result from misinterpreting a\
    \ name of one type as a\n      name of another type.\n      - The GSS-API Exported\
    \ Name Object, a special case of flat name\n      designated by a reserved OID\
    \ value, carries a canonicalized form\n      of a name suitable for binary comparisons.\n\
    \   In addition to providing means for names to be tagged with types,\n   this\
    \ specification defines primitives to support a level of naming\n   environment\
    \ independence for certain calling applications. To provide\n   basic services\
    \ oriented towards the requirements of callers which\n   need not themselves interpret\
    \ the internal syntax and semantics of\n   names, GSS-API calls for name comparison\
    \ (GSS_Compare_name()),\n   human-readable display (GSS_Display_name()), input\
    \ conversion\n   (GSS_Import_name()), internal name deallocation (GSS_Release_name()),\n\
    \   and internal name duplication (GSS_Duplicate_name()) functions are\n   defined.\
    \ (It is anticipated that these proposed GSS-API calls will be\n   implemented\
    \ in many end systems based on system-specific name\n   manipulation primitives\
    \ already extant within those end systems;\n   inclusion within the GSS-API is\
    \ intended to offer GSS-API callers a\n   portable means to perform specific operations,\
    \ supportive of\n   authorization and audit requirements, on authenticated names.)\n\
    \   GSS_Import_name() implementations can, where appropriate, support\n   more\
    \ than one printable syntax corresponding to a given namespace\n   (e.g., alternative\
    \ printable representations for X.500 Distinguished\n   Names), allowing flexibility\
    \ for their callers to select among\n   alternative representations. GSS_Display_name()\
    \ implementations\n   output a printable syntax selected as appropriate to their\n\
    \   operational environments; this selection is a local matter. Callers\n   desiring\
    \ portability across alternative printable syntaxes should\n   refrain from implementing\
    \ comparisons based on printable name forms\n   and should instead use the GSS_Compare_name()\
    \  call to determine\n   whether or not one internal-format name matches another.\n\
    \   The GSS_Canonicalize_name() and GSS_Export_name() calls enable\n   callers\
    \ to acquire and process Exported Name Objects, canonicalized\n   and translated\
    \ in accordance with the procedures of a particular\n   GSS-API mechanism.  Exported\
    \ Name Objects can, in turn, be input to\n   GSS_Import_name(), yielding equivalent\
    \ MNs. These facilities are\n   designed specifically to enable efficient storage\
    \ and comparison of\n   names (e.g., for use in access control lists).\n   The\
    \ following diagram illustrates the intended dataflow among name-\n   related\
    \ GSS-API processing routines.\n                        GSS-API library defaults\n\
    \                               |\n                               |\n        \
    \                       V                         text, for\n   text -------------->\
    \  internal_name (IN) -----------> display only\n         import_name()      \
    \    /          display_name()\n                               /\n           \
    \                   /\n                             /\n    accept_sec_context()\
    \    /\n          |                /\n          |               /\n          |\
    \              /  canonicalize_name()\n          |             /\n          |\
    \            /\n          |           /\n          |          /\n          | \
    \        /\n          |        |\n          V        V     <---------------------\n\
    \    single mechanism        import_name()         exported name: flat\n    internal_name\
    \ (MN)                            binary \"blob\" usable\n                   \
    \      ---------------------->  for access control\n                         \
    \   export_name()\n"
- title: '1.1.6:  Channel Bindings'
  contents:
  - "1.1.6:  Channel Bindings\n   The GSS-API accommodates the concept of caller-provided\
    \ channel\n   binding (\"chan_binding\") information.  Channel bindings are used\
    \ to\n   strengthen the quality with which peer entity authentication is\n   provided\
    \ during context establishment, by limiting the scope within\n   which an intercepted\
    \ context establishment token can be reused by an\n   attacker. Specifically,\
    \ they enable GSS-API callers to bind the\n   establishment of a security context\
    \ to relevant characteristics\n   (e.g., addresses, transformed representations\
    \ of encryption keys) of\n   the underlying communications channel, of protection\
    \ mechanisms\n   applied to that communications channel, and to application-specific\n\
    \   data.\n   The caller initiating a security context must determine the\n  \
    \ appropriate channel binding values to provide as input to the\n   GSS_Init_sec_context()\
    \ call, and consistent values must be provided\n   to GSS_Accept_sec_context()\
    \ by the context's target, in order for\n   both peers' GSS-API mechanisms to\
    \ validate that received tokens\n   possess correct channel-related characteristics.\
    \ Use or non-use of\n   the GSS-API channel binding facility is a caller option.\
    \  GSS-API\n   mechanisms can operate in an environment where NULL channel bindings\n\
    \   are presented; mechanism implementors are encouraged, but not\n   required,\
    \ to make use of caller-provided channel binding data within\n   their mechanisms.\
    \ Callers should not assume that underlying\n   mechanisms provide confidentiality\
    \ protection for channel binding\n   information.\n   When non-NULL channel bindings\
    \ are provided by callers, certain\n   mechanisms can offer enhanced security\
    \ value by interpreting the\n   bindings' content (rather than simply representing\
    \ those bindings, or\n   integrity check values computed on them, within tokens)\
    \ and will\n   therefore depend on presentation of specific data in a defined\n\
    \   format. To this end, agreements among mechanism implementors are\n   defining\
    \ conventional interpretations for the contents of channel\n   binding arguments,\
    \ including address specifiers (with content\n   dependent on communications protocol\
    \ environment) for context\n   initiators and acceptors. (These conventions are\
    \ being incorporated\n   in GSS-API mechanism specifications and into the GSS-API\
    \ C language\n   bindings specification.) In order for GSS-API callers to be portable\n\
    \   across multiple mechanisms and achieve the full security\n   functionality\
    \ which each mechanism can provide, it is strongly\n   recommended that GSS-API\
    \ callers provide channel bindings consistent\n   with these conventions and those\
    \ of the networking environment in\n   which they operate.\n"
- title: '1.2:  GSS-API Features and Issues'
  contents:
  - "1.2:  GSS-API Features and Issues\n   This section describes aspects of GSS-API\
    \ operations, of the security\n   services which the GSS-API provides, and provides\
    \ commentary on\n   design issues.\n"
- title: '1.2.1:  Status Reporting'
  contents:
  - "1.2.1:  Status Reporting\n   Each GSS-API call provides two status return values.\
    \ Major_status\n   values provide a mechanism-independent indication of call status\n\
    \   (e.g., GSS_S_COMPLETE, GSS_S_FAILURE, GSS_S_CONTINUE_NEEDED),\n   sufficient\
    \ to drive normal control flow within the caller in a\n   generic fashion. Table\
    \ 1 summarizes the defined major_status return\n   codes in tabular fashion.\n"
- title: 'Table 1: GSS-API Major Status Codes'
  contents:
  - "Table 1: GSS-API Major Status Codes\n   FATAL ERROR CODES\n   GSS_S_BAD_BINDINGS\
    \            channel binding mismatch\n   GSS_S_BAD_MECH                unsupported\
    \ mechanism requested\n   GSS_S_BAD_NAME                invalid name provided\n\
    \   GSS_S_BAD_NAMETYPE            name of unsupported type provided\n   GSS_S_BAD_STATUS\
    \              invalid input status selector\n   GSS_S_BAD_SIG               \
    \  token had invalid integrity check\n   GSS_S_CONTEXT_EXPIRED         specified\
    \ security context expired\n   GSS_S_CREDENTIALS_EXPIRED     expired credentials\
    \ detected\n   GSS_S_DEFECTIVE_CREDENTIAL    defective credential detected\n \
    \  GSS_S_DEFECTIVE_TOKEN         defective token detected\n   GSS_S_FAILURE  \
    \               failure, unspecified at GSS-API\n                            \
    \       level\n   GSS_S_NO_CONTEXT              no valid security context specified\n\
    \   GSS_S_NO_CRED                 no valid credentials provided\n   GSS_S_BAD_QOP\
    \                 unsupported QOP value\n   GSS_S_UNAUTHORIZED            operation\
    \ unauthorized\n   GSS_S_UNAVAILABLE             operation unavailable\n   GSS_S_DUPLICATE_ELEMENT\
    \       duplicate credential element requested\n   GSS_S_NAME_NOT_MN         \
    \    name contains multi-mechanism elements\n   INFORMATORY STATUS CODES\n   GSS_S_COMPLETE\
    \                normal completion\n   GSS_S_CONTINUE_NEEDED         continuation\
    \ call to routine\n                                  required\n   GSS_S_DUPLICATE_TOKEN\
    \         duplicate per-message token\n                                  detected\n\
    \   GSS_S_OLD_TOKEN               timed-out per-message token\n              \
    \                    detected\n   GSS_S_UNSEQ_TOKEN             reordered (early)\
    \ per-message token\n                                  detected\n   GSS_S_GAP_TOKEN\
    \               skipped predecessor token(s)\n                               \
    \   detected\n   Minor_status provides more detailed status information which\
    \ may\n   include status codes specific to the underlying security mechanism.\n\
    \   Minor_status values are not specified in this document.\n   GSS_S_CONTINUE_NEEDED\
    \ major_status returns, and optional message\n   outputs, are provided in GSS_Init_sec_context()\
    \ and\n   GSS_Accept_sec_context()  calls so that different mechanisms'\n   employment\
    \ of different numbers of messages within their\n   authentication sequences need\
    \ not be reflected in separate code paths\n   within calling applications. Instead,\
    \ such cases are accommodated\n   with sequences of continuation calls to GSS_Init_sec_context()\
    \  and\n   GSS_Accept_sec_context().  The same mechanism is used to encapsulate\n\
    \   mutual authentication within the GSS-API's context initiation calls.\n   For\
    \ mech_types which require interactions with third-party servers in\n   order\
    \ to establish a security context, GSS-API context establishment\n   calls may\
    \ block pending completion of such third-party interactions.\n   On the other\
    \ hand, no GSS-API calls pend on serialized interactions\n   with GSS-API peer\
    \ entities.  As a result, local GSS-API status\n   returns cannot reflect unpredictable\
    \ or asynchronous exceptions\n   occurring at remote peers, and reflection of\
    \ such status information\n   is a caller responsibility outside the GSS-API.\n"
- title: '1.2.2: Per-Message Security Service Availability'
  contents:
  - "1.2.2: Per-Message Security Service Availability\n   When a context is established,\
    \ two flags are returned to indicate the\n   set of per-message protection security\
    \ services which will be\n   available on the context:\n      the integ_avail\
    \ flag indicates whether per-message integrity and\n      data origin authentication\
    \ services are available\n      the conf_avail flag indicates whether per-message\
    \ confidentiality\n      services are available, and will never be returned TRUE\
    \ unless the\n      integ_avail flag is also returned TRUE\n      GSS-API callers\
    \ desiring per-message security services should\n      check the values of these\
    \ flags at context establishment time, and\n      must be aware that a returned\
    \ FALSE value for integ_avail means\n      that invocation of GSS_GetMIC()  or\
    \ GSS_Wrap() primitives on the\n      associated context will apply no cryptographic\
    \ protection to user\n      data messages.\n   The GSS-API per-message integrity\
    \ and data origin authentication\n   services provide assurance to a receiving\
    \ caller that protection was\n   applied to a message by the caller's peer on\
    \ the security context,\n   corresponding to the entity named at context initiation.\
    \  The GSS-API\n   per-message confidentiality service provides assurance to a\
    \ sending\n   caller that the message's content is protected from access by\n\
    \   entities other than the context's named peer.\n   The GSS-API per-message\
    \ protection service primitives, as the\n   category name implies, are oriented\
    \ to operation at the granularity\n   of protocol data units. They perform cryptographic\
    \ operations on the\n   data units, transfer cryptographic control information\
    \ in tokens,\n   and, in the case of GSS_Wrap(), encapsulate the protected data\
    \ unit.\n   As such, these primitives are not oriented to efficient data\n   protection\
    \ for stream-paradigm protocols (e.g., Telnet) if\n   cryptography must be applied\
    \ on an octet-by-octet basis.\n"
- title: '1.2.3: Per-Message Replay Detection and Sequencing'
  contents:
  - "1.2.3: Per-Message Replay Detection and Sequencing\n   Certain underlying mech_types\
    \ offer support for replay detection\n   and/or sequencing of messages transferred\
    \ on the contexts they\n   support. These optionally-selectable protection features\
    \ are distinct\n   from replay detection and sequencing features applied to the\
    \ context\n   establishment operation itself; the presence or absence of context-\n\
    \   level replay or sequencing features is wholly a function of the\n   underlying\
    \ mech_type's capabilities, and is not selected or omitted\n   as a caller option.\n\
    \   The caller initiating a context provides flags (replay_det_req_flag\n   and\
    \ sequence_req_flag) to specify whether the use of per-message\n   replay detection\
    \ and sequencing features is desired on the context\n   being established. The\
    \ GSS-API implementation at the initiator system\n   can determine whether these\
    \ features are supported (and whether they\n   are optionally selectable) as a\
    \ function of mech_type, without need\n   for bilateral negotiation with the target.\
    \ When enabled, these\n   features provide recipients with indicators as a result\
    \ of GSS-API\n   processing of incoming messages, identifying whether those messages\n\
    \   were detected as duplicates or out-of-sequence. Detection of such\n   events\
    \ does not prevent a suspect message from being provided to a\n   recipient; the\
    \ appropriate course of action on a suspect message is a\n   matter of caller\
    \ policy.\n   The semantics of the replay detection and sequencing services applied\n\
    \   to received messages, as visible across the interface which the GSS-\n   API\
    \ provides to its clients, are as follows:\n   When replay_det_state is TRUE,\
    \ the possible major_status returns for\n   well-formed and correctly signed messages\
    \ are as follows:\n      1. GSS_S_COMPLETE indicates that the message was within\
    \ the window\n      (of time or sequence space) allowing replay events to be detected,\n\
    \      and that the message was not a replay of a previously-processed\n     \
    \ message within that window.\n      2. GSS_S_DUPLICATE_TOKEN indicates that the\
    \ cryptographic\n      checkvalue on the received message was correct, but that\
    \ the\n      message was recognized as a duplicate of a previously-processed\n\
    \      message.\n      3. GSS_S_OLD_TOKEN indicates that the cryptographic checkvalue\
    \ on\n      the received message was correct, but that the message is too old\n\
    \      to be checked for duplication.\n   When sequence_state is TRUE, the possible\
    \ major_status returns for\n   well-formed and correctly signed messages are as\
    \ follows:\n      1. GSS_S_COMPLETE indicates that the message was within the\
    \ window\n      (of time or sequence space) allowing replay events to be detected,\n\
    \      that the message was not a replay of a previously-processed\n      message\
    \ within that window, and that no predecessor sequenced\n      messages are missing\
    \ relative to the last received message (if\n      any) processed on the context\
    \ with a correct cryptographic\n      checkvalue.\n      2. GSS_S_DUPLICATE_TOKEN\
    \ indicates that the integrity check value\n      on the received message was\
    \ correct, but that the message was\n      recognized as a duplicate of a previously-processed\
    \ message.\n      3. GSS_S_OLD_TOKEN indicates that the integrity check value\
    \ on the\n      received message was correct, but that the token is too old to\
    \ be\n      checked for duplication.\n      4. GSS_S_UNSEQ_TOKEN indicates that\
    \ the cryptographic checkvalue\n      on the received message was correct, but\
    \ that it is earlier in a\n      sequenced stream than a message already processed\
    \ on the context.\n      [Note: Mechanisms can be architected to provide a stricter\
    \ form of\n      sequencing service, delivering particular messages to recipients\n\
    \      only after all predecessor messages in an ordered stream have been\n  \
    \    delivered.  This type of support is incompatible with the GSS-API\n     \
    \ paradigm in which recipients receive all messages, whether in\n      order or\
    \ not, and provide them (one at a time, without intra-GSS-\n      API message\
    \ buffering) to GSS-API routines for validation.  GSS-\n      API facilities provide\
    \ supportive functions, aiding clients to\n      achieve strict message stream\
    \ integrity in an efficient manner in\n      conjunction with sequencing provisions\
    \ in communications\n      protocols, but the GSS-API does not offer this level\
    \ of message\n      stream integrity service by itself.]\n      5. GSS_S_GAP_TOKEN\
    \ indicates that the cryptographic checkvalue on\n      the received message was\
    \ correct, but that one or more predecessor\n      sequenced messages have not\
    \ been successfully processed relative\n      to the last received message (if\
    \ any) processed on the context\n      with a correct cryptographic checkvalue.\n\
    \   As the message stream integrity features (especially sequencing) may\n   interfere\
    \ with certain applications' intended communications\n   paradigms, and since\
    \ support for such features is likely to be\n   resource intensive, it is highly\
    \ recommended that mech_types\n   supporting these features allow them to be activated\
    \ selectively on\n   initiator request when a context is established. A context\
    \ initiator\n   and target are provided with corresponding indicators\n   (replay_det_state\
    \ and sequence_state), signifying whether these\n   features are active on a given\
    \ context.\n   An example mech_type supporting per-message replay detection could\n\
    \   (when replay_det_state is TRUE) implement the feature as follows: The\n  \
    \ underlying mechanism would insert timestamps in data elements output\n   by\
    \ GSS_GetMIC()  and GSS_Wrap(), and would maintain (within a time-\n   limited\
    \ window) a cache (qualified by originator-recipient pair)\n   identifying received\
    \ data elements processed by GSS_VerifyMIC()  and\n   GSS_Unwrap(). When this\
    \ feature is active, exception status returns\n   (GSS_S_DUPLICATE_TOKEN, GSS_S_OLD_TOKEN)\
    \ will be provided when\n   GSS_VerifyMIC()  or GSS_Unwrap() is presented with\
    \ a message which is\n   either a detected duplicate of a prior message or which\
    \ is too old to\n   validate against a cache of recently received messages.\n"
- title: '1.2.4:  Quality of Protection'
  contents:
  - "1.2.4:  Quality of Protection\n   Some mech_types provide their users with fine\
    \ granularity control\n   over the means used to provide per-message protection,\
    \ allowing\n   callers to trade off security processing overhead dynamically against\n\
    \   the protection requirements of particular messages. A per-message\n   quality-of-protection\
    \ parameter (analogous to quality-of-service, or\n   QOS) selects among different\
    \ QOP options supported by that mechanism.\n   On context establishment for a\
    \ multi-QOP mech_type, context-level\n   data provides the prerequisite data for\
    \ a range of protection\n   qualities.\n   It is expected that the majority of\
    \ callers will not wish to exert\n   explicit mechanism-specific QOP control and\
    \ will therefore request\n   selection of a default QOP. Definitions of, and choices\
    \ among, non-\n   default QOP values are mechanism-specific, and no ordered sequences\n\
    \   of QOP values can be assumed equivalent across different mechanisms.\n   Meaningful\
    \ use of non-default QOP values demands that callers be\n   familiar with the\
    \ QOP definitions of an underlying mechanism or\n   mechanisms, and is therefore\
    \ a non-portable construct.  The\n   GSS_S_BAD_QOP major_status value is defined\
    \ in order to indicate that\n   a provided QOP value is unsupported for a security\
    \ context, most\n   likely because that value is unrecognized by the underlying\n\
    \   mechanism.\n"
- title: '1.2.5: Anonymity Support'
  contents:
  - "1.2.5: Anonymity Support\n   In certain situations or environments, an application\
    \ may wish to\n   authenticate a peer and/or protect communications using GSS-API\
    \ per-\n   message services without revealing its own identity.  For example,\n\
    \   consider an application which provides read access to a research\n   database,\
    \ and which permits queries by arbitrary requestors.  A\n   client of such a service\
    \ might wish to authenticate the service, to\n   establish trust in the information\
    \ received from it, but might not\n   wish to disclose its identity to the service\
    \ for privacy reasons.\n   In ordinary GSS-API usage, a context initiator's identity\
    \ is made\n   available to the context acceptor as part of the context\n   establishment\
    \ process.  To provide for anonymity support, a facility\n   (input anon_req_flag\
    \ to GSS_Init_sec_context()) is provided through\n   which context initiators\
    \ may request that their identity not be\n   provided to the context acceptor.\
    \  Mechanisms are not required to\n   honor this request, but a caller will be\
    \ informed (via returned\n   anon_state indicator from GSS_Init_sec_context())\
    \ whether or not the\n   request is honored. Note that authentication as the anonymous\n\
    \   principal does not necessarily imply that credentials are not\n   required\
    \ in order to establish a context.\n   The following Object Identifier value is\
    \ provided as a means to\n   identify anonymous names, and can be compared against\
    \ in order to\n   determine, in a mechanism-independent fashion, whether a name\
    \ refers\n   to an anonymous principal:\n   {1(iso), 3(org), 6(dod), 1(internet),\
    \ 5(security), 6(nametypes),\n   3(gss-anonymous-name)}\n   The recommended symbolic\
    \ name corresponding to this definition is\n   GSS_C_NT_ANONYMOUS.\n   Four possible\
    \ combinations of anon_state and mutual_state are\n   possible, with the following\
    \ results:\n      anon_state == FALSE, mutual_state == FALSE: initiator\n    \
    \  authenticated to target.\n      anon_state == FALSE, mutual_state == TRUE:\
    \ initiator authenticated\n      to target, target authenticated to initiator.\n\
    \      anon_state == TRUE, mutual_state == FALSE: initiator authenticated\n  \
    \    as anonymous principal to target.\n      anon_state == TRUE, mutual_state\
    \ == TRUE: initiator authenticated\n      as anonymous principal to target, target\
    \ authenticated to\n      initiator.\n"
- title: '1.2.6: Initialization'
  contents:
  - "1.2.6: Initialization\n   No initialization calls (i.e., calls which must be\
    \ invoked prior to\n   invocation of other facilities in the interface) are defined\
    \ in GSS-\n   API.  As an implication of this fact, GSS-API implementations must\n\
    \   themselves be self-initializing.\n"
- title: '1.2.7: Per-Message Protection During Context Establishment'
  contents:
  - "1.2.7: Per-Message Protection During Context Establishment\n   A facility is\
    \ defined in GSS-V2 to enable protection and buffering of\n   data messages for\
    \ later transfer while a security context's\n   establishment is in GSS_S_CONTINUE_NEEDED\
    \ status, to be used in cases\n   where the caller side already possesses the\
    \ necessary session key to\n   enable this processing. Specifically, a new state\
    \ Boolean, called\n   prot_ready_state, is added to the set of information returned\
    \ by\n   GSS_Init_sec_context(), GSS_Accept_sec_context(), and\n   GSS_Inquire_context().\n\
    \   For context establishment calls, this state Boolean is valid and\n   interpretable\
    \ when the associated major_status is either\n   GSS_S_CONTINUE_NEEDED, or GSS_S_COMPLETE.\
    \  Callers of GSS-API (both\n   initiators and acceptors) can assume that per-message\
    \ protection (via\n   GSS_Wrap(), GSS_Unwrap(), GSS_GetMIC() and GSS_VerifyMIC())\
    \ is\n   available and ready for use if either: prot_ready_state == TRUE, or\n\
    \   major_status == GSS_S_COMPLETE, though mutual authentication (if\n   requested)\
    \ cannot be guaranteed until GSS_S_COMPLETE is returned.\n   This achieves full,\
    \ transparent backward compatibility for GSS-API V1\n   callers, who need not\
    \ even know of the existence of prot_ready_state,\n   and who will get the expected\
    \ behavior from GSS_S_COMPLETE, but who\n   will not be able to use per-message\
    \ protection before GSS_S_COMPLETE\n   is returned.\n   It is not a requirement\
    \ that GSS-V2 mechanisms ever return TRUE\n   prot_ready_state before completion\
    \ of context establishment (indeed,\n   some mechanisms will not evolve usable\
    \ message protection keys,\n   especially at the context acceptor, before context\
    \ establishment is\n   complete).  It is expected but not required that GSS-V2\
    \ mechanisms\n   will return TRUE prot_ready_state upon completion of context\n\
    \   establishment if they support per-message protection at all (however\n   GSS-V2\
    \ applications should not assume that TRUE prot_ready_state will\n   always be\
    \ returned together with the GSS_S_COMPLETE major_status,\n   since GSS-V2 implementations\
    \ may continue to support GSS-V1 mechanism\n   code, which will never return TRUE\
    \ prot_ready_state).\n   When prot_ready_state is returned TRUE, mechanisms shall\
    \ also set\n   those context service indicator flags (deleg_state, mutual_state,\n\
    \   replay_det_state, sequence_state, anon_state, trans_state,\n   conf_avail,\
    \ integ_avail) which represent facilities confirmed, at\n   that time, to be available\
    \ on the context being established.  In\n   situations where prot_ready_state\
    \ is returned before GSS_S_COMPLETE,\n   it is possible that additional facilities\
    \ may be confirmed and\n   subsequently indicated when GSS_S_COMPLETE is returned.\n"
- title: '1.2.8: Implementation Robustness'
  contents:
  - "1.2.8: Implementation Robustness\n   This section recommends aspects of GSS-API\
    \ implementation behavior in\n   the interests of overall robustness.\n   If a\
    \ token is presented for processing on a GSS-API security context\n   and that\
    \ token is determined to be invalid for that context, the\n   context's state\
    \ should not be disrupted for purposes of processing\n   subsequent valid tokens.\n\
    \   Certain local conditions at a GSS-API implementation (e.g.,\n   unavailability\
    \ of memory) may preclude, temporarily or permanently,\n   the successful processing\
    \ of tokens on a GSS-API security context,\n   typically generating GSS_S_FAILURE\
    \ major_status returns along with\n   locally-significant minor_status.  For robust\
    \ operation under such\n   conditions, the following recommendations are made:\n\
    \      Failing calls should free any memory they allocate, so that\n      callers\
    \ may retry without causing further loss of resources.\n      Failure of an individual\
    \ call on an established context should not\n      preclude subsequent calls from\
    \ succeeding on the same context.\n      Whenever possible, it should be possible\
    \ for\n      GSS_Delete_sec_context() calls to be successfully processed even\n\
    \      if other calls cannot succeed, thereby enabling context-related\n     \
    \ resources to be released.\n"
- title: '2:  Interface Descriptions'
  contents:
  - "2:  Interface Descriptions\n   This section describes the GSS-API's service interface,\
    \ dividing the\n   set of calls offered into four groups. Credential management\
    \ calls\n   are related to the acquisition and release of credentials by\n   principals.\
    \ Context-level calls are related to the management of\n   security contexts between\
    \ principals. Per-message calls are related\n   to the protection of individual\
    \ messages on established security\n   contexts. Support calls provide ancillary\
    \ functions useful to GSS-API\n   callers. Table 2 groups and summarizes the calls\
    \ in tabular fashion.\n"
- title: 'Table 2:  GSS-API Calls'
  contents:
  - "Table 2:  GSS-API Calls\n   CREDENTIAL MANAGEMENT\n   GSS_Acquire_cred      \
    \       acquire credentials for use\n   GSS_Release_cred             release credentials\
    \ after use\n   GSS_Inquire_cred             display information about\n     \
    \                           credentials\n   GSS_Add_cred                 construct\
    \ credentials incrementally\n   GSS_Inquire_cred_by_mech     display per-mechanism\
    \ credential\n                                information\n   CONTEXT-LEVEL CALLS\n\
    \   GSS_Init_sec_context         initiate outbound security context\n   GSS_Accept_sec_context\
    \       accept inbound security context\n   GSS_Delete_sec_context       flush\
    \ context when no longer needed\n   GSS_Process_context_token    process received\
    \ control token on\n                                context\n   GSS_Context_time\
    \             indicate validity time remaining on\n                          \
    \            context\n   GSS_Inquire_context          display information about\
    \ context\n   GSS_Wrap_size_limit          determine GSS_Wrap token size limit\n\
    \   GSS_Export_sec_context       transfer context to other process\n   GSS_Import_sec_context\
    \       import transferred context\n   PER-MESSAGE CALLS\n   GSS_GetMIC      \
    \             apply integrity check, receive as\n                            \
    \    token separate from message\n   GSS_VerifyMIC                validate integrity\
    \ check token\n                                along with message\n   GSS_Wrap\
    \                     sign, optionally encrypt,\n                            \
    \    encapsulate\n   GSS_Unwrap                   decapsulate, decrypt if needed,\n\
    \                                validate integrity check\n   SUPPORT CALLS\n\
    \   GSS_Display_status           translate status codes to printable\n       \
    \                         form\n   GSS_Indicate_mechs           indicate mech_types\
    \ supported on\n                                local system\n   GSS_Compare_name\
    \             compare two names for equality\n   GSS_Display_name            \
    \ translate name to printable form\n   GSS_Import_name              convert printable\
    \ name to\n                                normalized form\n   GSS_Release_name\
    \             free storage of normalized-form\n                              \
    \  name\n   GSS_Release_buffer           free storage of printable name\n   GSS_Release_OID\
    \              free storage of OID object\n   GSS_Release_OID_set          free\
    \ storage of OID set object\n   GSS_Create_empty_OID_set     create empty OID\
    \ set\n   GSS_Add_OID_set_member       add member to OID set\n   GSS_Test_OID_set_member\
    \      test if OID is member of OID set\n   GSS_OID_to_str               display\
    \ OID as string\n   GSS_Str_to_OID               construct OID from string\n \
    \  GSS_Inquire_names_for_mech   indicate name types supported by\n           \
    \                     mechanism\n   GSS_Inquire_mechs_for_name   indicates mechanisms\
    \ supporting name\n                                type\n   GSS_Canonicalize_name\
    \        translate name to per-mechanism form\n   GSS_Export_name            \
    \  externalize per-mechanism name\n   GSS_Duplicate_name           duplicate name\
    \ object\n"
- title: '2.1:  Credential management calls'
  contents:
  - "2.1:  Credential management calls\n   These GSS-API calls provide functions related\
    \ to the management of\n   credentials. Their characterization with regard to\
    \ whether or not\n   they may block pending exchanges with other network entities\
    \ (e.g.,\n   directories or authentication servers) depends in part on OS-specific\n\
    \   (extra-GSS-API) issues, so is not specified in this document.\n   The GSS_Acquire_cred()\
    \ call is defined within the GSS-API in support\n   of application portability,\
    \ with a particular orientation towards\n   support of portable server applications.\
    \ It is recognized that (for\n   certain systems and mechanisms) credentials for\
    \ interactive users may\n   be managed differently from credentials for server\
    \ processes; in such\n   environments, it is the GSS-API implementation's responsibility\
    \ to\n   distinguish these cases and the procedures for making this\n   distinction\
    \ are a local matter. The GSS_Release_cred()  call provides\n   a means for callers\
    \ to indicate to the GSS-API that use of a\n   credentials structure is no longer\
    \ required. The GSS_Inquire_cred()\n   call allows callers to determine information\
    \ about a credentials\n   structure.  The GSS_Add_cred() call enables callers\
    \ to append\n   elements to an existing credential structure, allowing iterative\n\
    \   construction of a multi-mechanism credential. The\n   GSS_Inquire_cred_by_mech()\
    \ call enables callers to extract per-\n   mechanism information describing a\
    \ credentials structure.\n"
- title: '2.1.1:  GSS_Acquire_cred call'
  contents:
  - "2.1.1:  GSS_Acquire_cred call\n   Inputs:\n   o  desired_name INTERNAL NAME,\
    \ -NULL requests locally-determined\n      default\n   o  lifetime_req INTEGER,-in\
    \ seconds; 0 requests default\n   o  desired_mechs SET OF OBJECT IDENTIFIER,-empty\
    \ set requests\n      system-selected default\n   o  cred_usage INTEGER -0=INITIATE-AND-ACCEPT,\
    \ 1=INITIATE-ONLY,\n      2=ACCEPT-ONLY\n   Outputs:\n   o  major_status INTEGER,\n\
    \   o  minor_status INTEGER,\n   o  output_cred_handle CREDENTIAL HANDLE,\n  \
    \ o  actual_mechs SET OF OBJECT IDENTIFIER,\n   o  lifetime_rec INTEGER -in seconds,\
    \ or reserved value for\n      INDEFINITE\n   Return major_status codes:\n   o\
    \  GSS_S_COMPLETE indicates that requested credentials were\n      successfully\
    \ established, for the duration indicated in\n      lifetime_rec, suitable for\
    \ the usage requested in cred_usage,\n      for the set of mech_types indicated\
    \ in actual_mechs, and that\n      those credentials can be referenced for subsequent\
    \ use with\n      the handle returned in output_cred_handle.\n   o  GSS_S_BAD_MECH\
    \ indicates that a mech_type unsupported by the\n      GSS-API implementation\
    \ type was requested, causing the\n      credential establishment operation to\
    \ fail.\n   o  GSS_S_BAD_NAMETYPE indicates that the provided desired_name is\n\
    \      uninterpretable or of a type unsupported by the applicable\n      underlying\
    \ GSS-API mechanism(s), so no credentials could be\n      established for the\
    \ accompanying desired_name.\n   o  GSS_S_BAD_NAME indicates that the provided\
    \ desired_name is\n      inconsistent in terms of internally-incorporated type\
    \ specifier\n      information, so no credentials could be established for the\n\
    \      accompanying desired_name.\n   o  GSS_S_FAILURE indicates that credential\
    \ establishment failed\n      for reasons unspecified at the GSS-API level, including\
    \ lack\n      of authorization to establish and use credentials associated\n \
    \     with the identity named in the input desired_name argument.\n   GSS_Acquire_cred()\
    \  is used to acquire credentials so that a\n   principal can (as a function of\
    \ the input cred_usage parameter)\n   initiate and/or accept security contexts\
    \ under the identity\n   represented by the desired_name input argument. On successful\n\
    \   completion, the returned output_cred_handle result provides a handle\n   for\
    \ subsequent references to the acquired credentials.  Typically,\n   single-user\
    \ client processes requesting that default credential\n   behavior be applied\
    \ for context establishment purposes will have no\n   need to invoke this call.\n\
    \   A caller may provide the value NULL for desired_name, signifying a\n   request\
    \ for credentials corresponding to a principal identity\n   selected by default\
    \ for the caller. The procedures used by GSS-API\n   implementations to select\
    \ the appropriate principal identity in\n   response to such a request are local\
    \ matters. It is possible that\n   multiple pre-established credentials may exist\
    \ for the same principal\n   identity (for example, as a result of multiple user\
    \ login sessions)\n   when GSS_Acquire_cred() is called; the means used in such\
    \ cases to\n   select a specific credential are local matters.  The input\n  \
    \ lifetime_req argument to GSS_Acquire_cred() may provide useful\n   information\
    \ for local GSS-API implementations to employ in making\n   this disambiguation\
    \ in a manner which will best satisfy a caller's\n   intent.\n   The lifetime_rec\
    \ result indicates the length of time for which the\n   acquired credentials will\
    \ be valid, as an offset from the present. A\n   mechanism may return a reserved\
    \ value indicating INDEFINITE if no\n   constraints on credential lifetime are\
    \ imposed.  A caller of\n   GSS_Acquire_cred()  can request a length of time for\
    \ which acquired\n   credentials are to be valid (lifetime_req argument), beginning\
    \ at the\n   present, or can request credentials with a default validity interval.\n\
    \   (Requests for postdated credentials are not supported within the\n   GSS-API.)\
    \ Certain mechanisms and implementations may bind in\n   credential validity period\
    \ specifiers at a point preliminary to\n   invocation of the GSS_Acquire_cred()\
    \ call (e.g., in conjunction with\n   user login procedures). As a result, callers\
    \ requesting non-default\n   values for lifetime_req must recognize that such\
    \ requests cannot\n   always be honored and must be prepared to accommodate the\
    \ use of\n   returned credentials with different lifetimes as indicated in\n \
    \  lifetime_rec.\n   The caller of GSS_Acquire_cred()  can explicitly specify\
    \ a set of\n   mech_types which are to be accommodated in the returned credentials\n\
    \   (desired_mechs argument), or can request credentials for a system-\n   defined\
    \ default set of mech_types. Selection of the system-specified\n   default set\
    \ is recommended in the interests of application\n   portability. The actual_mechs\
    \ return value may be interrogated by the\n   caller to determine the set of mechanisms\
    \ with which the returned\n   credentials may be used.\n"
- title: '2.1.2:  GSS_Release_cred call'
  contents:
  - "2.1.2:  GSS_Release_cred call\n   Input:\n   o  cred_handle CREDENTIAL HANDLE\
    \ - NULL specifies that\n      the credential elements used when default credential\
    \ behavior\n      is requested be released.\n   Outputs:\n   o  major_status INTEGER,\n\
    \   o  minor_status INTEGER\n   Return major_status codes:\n   o  GSS_S_COMPLETE\
    \ indicates that the credentials referenced by the\n      input cred_handle were\
    \ released for purposes of subsequent\n      access by the caller. The effect\
    \ on other processes which may\n      be authorized shared access to such credentials\
    \ is a local\n      matter.\n   o  GSS_S_NO_CRED indicates that no release operation\
    \ was\n      performed, either because the input cred_handle was invalid or\n\
    \      because the caller lacks authorization to access the\n      referenced\
    \ credentials.\n   o  GSS_S_FAILURE indicates that the release operation failed\
    \ for\n      reasons unspecified at the GSS-API level.\n   Provides a means for\
    \ a caller to explicitly request that credentials\n   be released when their use\
    \ is no longer required. Note that system-\n   specific credential management\
    \ functions are also likely to exist,\n   for example to assure that credentials\
    \ shared among processes are\n   properly deleted when all affected processes\
    \ terminate, even if no\n   explicit release requests are issued by those processes.\
    \ Given the\n   fact that multiple callers are not precluded from gaining authorized\n\
    \   access to the same credentials, invocation of GSS_Release_cred()\n   cannot\
    \ be assumed to delete a particular set of credentials on a\n   system-wide basis.\n"
- title: '2.1.3:  GSS_Inquire_cred call'
  contents:
  - "2.1.3:  GSS_Inquire_cred call\n   Input:\n   o  cred_handle CREDENTIAL HANDLE\
    \ -NULL specifies that the\n      credential elements used when default credential\
    \ behavior is\n      requested are to be queried\n   Outputs:\n   o  major_status\
    \ INTEGER,\n   o  minor_status INTEGER,\n   o  cred_name INTERNAL NAME,\n   o\
    \  lifetime_rec INTEGER -in seconds, or reserved value for\n      INDEFINITE\n\
    \   o  cred_usage INTEGER, -0=INITIATE-AND-ACCEPT, 1=INITIATE-ONLY,\n      2=ACCEPT-ONLY\n\
    \   o  mech_set SET OF OBJECT IDENTIFIER\n   Return major_status codes:\n   o\
    \  GSS_S_COMPLETE indicates that the credentials referenced by the\n      input\
    \ cred_handle argument were valid, and that the output\n      cred_name, lifetime_rec,\
    \ and cred_usage values represent,\n      respectively, the credentials' associated\
    \ principal name,\n      remaining lifetime, suitable usage modes, and supported\n\
    \      mechanism types.\n   o  GSS_S_NO_CRED indicates that no information could\
    \ be returned\n      about the referenced credentials, either because the input\n\
    \      cred_handle was invalid or because the caller lacks\n      authorization\
    \ to access the referenced credentials.\n   o  GSS_S_DEFECTIVE_CREDENTIAL indicates\
    \ that the referenced\n      credentials are invalid.\n   o  GSS_S_CREDENTIALS_EXPIRED\
    \ indicates that the referenced\n      credentials have expired.\n   o  GSS_S_FAILURE\
    \ indicates that the operation failed for\n      reasons unspecified at the GSS-API\
    \ level.\n   The GSS_Inquire_cred() call is defined primarily for the use of those\n\
    \   callers which request use of default credential behavior rather than\n   acquiring\
    \ credentials explicitly with GSS_Acquire_cred().  It enables\n   callers to determine\
    \ a credential structure's associated principal\n   name, remaining validity period,\
    \ usability for security context\n   initiation and/or acceptance, and supported\
    \ mechanisms.\n   For a multi-mechanism credential, the returned \"lifetime\"\
    \ specifier\n   indicates the shortest lifetime of any of the mechanisms' elements\
    \ in\n   the credential (for either context initiation or acceptance\n   purposes).\n\
    \   GSS_Inquire_cred() should indicate INITIATE-AND-ACCEPT for\n   \"cred_usage\"\
    \ if both of the following conditions hold:\n      (1) there exists in the credential\
    \ an element which allows context\n      initiation using some mechanism\n   \
    \   (2) there exists in the credential an element which allows context\n     \
    \ acceptance using some mechanism (allowably, but not necessarily,\n      one\
    \ of the same mechanism(s) qualifying for (1)).\n   If condition (1) holds but\
    \ not condition (2), GSS_Inquire_cred()\n   should indicate INITIATE-ONLY for\
    \ \"cred_usage\".  If condition (2)\n   holds but not condition (1), GSS_Inquire_cred()\
    \ should indicate\n   ACCEPT-ONLY for \"cred_usage\".\n   Callers requiring finer\
    \ disambiguation among available combinations\n   of lifetimes, usage modes, and\
    \ mechanisms should call the\n   GSS_Inquire_cred_by_mech() routine, passing that\
    \ routine one of the\n   mech OIDs returned by GSS_Inquire_cred().\n"
- title: '2.1.4:  GSS_Add_cred call'
  contents:
  - "2.1.4:  GSS_Add_cred call\n   Inputs:\n   o  input_cred_handle CREDENTIAL HANDLE\
    \ - handle to credential\n      structure created with prior GSS_Acquire_cred()\
    \ or\n      GSS_Add_cred() call, or NULL to append elements to the set\n     \
    \ which are applied for the caller when default credential\n      behavior is\
    \ specified.\n   o  desired_name INTERNAL NAME - NULL requests locally-determined\n\
    \      default\n   o  initiator_time_req INTEGER - in seconds; 0 requests default\n\
    \   o  acceptor_time_req INTEGER - in seconds; 0 requests default\n   o  desired_mech\
    \ OBJECT IDENTIFIER\n   o  cred_usage INTEGER - 0=INITIATE-AND-ACCEPT, 1=INITIATE-ONLY,\n\
    \       2=ACCEPT-ONLY\n   Outputs:\n   o  major_status INTEGER,\n   o  minor_status\
    \ INTEGER,\n   o  output_cred_handle CREDENTIAL HANDLE, - NULL to request that\n\
    \      credential elements be added \"in place\" to the credential\n      structure\
    \  identified by input_cred_handle, non-NULL pointer\n      to request that a\
    \ new credential structure and handle be created.\n   o  actual_mechs SET OF OBJECT\
    \ IDENTIFIER,\n   o  initiator_time_rec INTEGER - in seconds, or reserved value\
    \ for\n      INDEFINITE\n   o  acceptor_time_rec INTEGER - in seconds, or reserved\
    \ value for\n      INDEFINITE\n   o  cred_usage INTEGER, -0=INITIATE-AND-ACCEPT,\
    \ 1=INITIATE-ONLY,\n      2=ACCEPT-ONLY\n   o  mech_set SET OF OBJECT IDENTIFIER\
    \ -- full set of mechanisms\n      supported by resulting credential.\n   Return\
    \ major_status codes:\n   o  GSS_S_COMPLETE indicates that the credentials referenced\
    \ by\n      the input_cred_handle argument were valid, and that the\n      resulting\
    \ credential from GSS_Add_cred() is valid for the\n      durations indicated in\
    \ initiator_time_rec and acceptor_time_rec,\n      suitable for the usage requested\
    \ in cred_usage, and for the\n      mechanisms indicated in actual_mechs.\n  \
    \ o  GSS_S_DUPLICATE_ELEMENT indicates that the input desired_mech\n      specified\
    \ a mechanism for which the referenced credential\n      already contained a credential\
    \ element with overlapping\n      cred_usage and validity time specifiers.\n \
    \  o  GSS_S_BAD_MECH indicates that the input desired_mech specified\n      a\
    \ mechanism unsupported by the GSS-API implementation, causing\n      the GSS_Add_cred()\
    \ operation to fail.\n   o  GSS_S_BAD_NAMETYPE indicates that the provided desired_name\n\
    \      is uninterpretable or of a type unsupported by the applicable\n      underlying\
    \ GSS-API mechanism(s), so the GSS_Add_cred() operation\n      could not be performed\
    \ for that name.\n   o  GSS_S_BAD_NAME indicates that the provided desired_name\
    \ is\n      inconsistent in terms of internally-incorporated type specifier\n\
    \      information, so the GSS_Add_cred() operation could not be\n      performed\
    \ for that name.\n   o  GSS_S_NO_CRED indicates that the input_cred_handle referenced\n\
    \      invalid or inaccessible credentials.\n   o  GSS_S_FAILURE indicates that\
    \ the operation failed for\n      reasons unspecified at the GSS-API level, including\
    \ lack of\n      authorization to establish or use credentials representing\n\
    \      the requested identity.\n   GSS_Add_cred() enables callers to construct\
    \ credentials iteratively\n   by adding credential elements in successive operations,\
    \ corresponding\n   to different mechanisms.  This offers particular value in\
    \ multi-\n   mechanism environments, as the major_status and minor_status values\n\
    \   returned on each iteration are individually visible and can therefore\n  \
    \ be interpreted unambiguously on a per-mechanism basis.\n   The same input desired_name,\
    \ or default reference, should be used on\n   all GSS_Acquire_cred() and GSS_Add_cred()\
    \ calls corresponding to a\n   particular credential.\n"
- title: '2.1.5:  GSS_Inquire_cred_by_mech call'
  contents:
  - "2.1.5:  GSS_Inquire_cred_by_mech call\n   Inputs:\n   o  cred_handle CREDENTIAL\
    \ HANDLE  -- NULL specifies that the\n      credential elements used when default\
    \ credential behavior is\n      requested are to be queried\n   o  mech_type OBJECT\
    \ IDENTIFIER  -- specific mechanism for\n      which credentials are being queried\n\
    \   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o \
    \ cred_name INTERNAL NAME, -- guaranteed to be MN\n   o  lifetime_rec_initiate\
    \ INTEGER -- in seconds, or reserved value for\n      INDEFINITE\n   o  lifetime_rec_accept\
    \ INTEGER -- in seconds, or reserved value for\n      INDEFINITE\n   o  cred_usage\
    \ INTEGER, -0=INITIATE-AND-ACCEPT, 1=INITIATE-ONLY,\n      2=ACCEPT-ONLY\n   Return\
    \ major_status codes:\n   o  GSS_S_COMPLETE indicates that the credentials referenced\
    \ by the\n      input cred_handle argument were valid, that the mechanism\n  \
    \    indicated by the input mech_type was represented with elements\n      within\
    \ those credentials, and that the output cred_name,\n      lifetime_rec_initiate,\
    \ lifetime_rec_accept, and cred_usage values\n      represent, respectively, the\
    \ credentials' associated principal\n      name, remaining lifetimes, and suitable\
    \ usage modes.\n   o  GSS_S_NO_CRED indicates that no information could be returned\n\
    \      about the referenced credentials, either because the input\n      cred_handle\
    \ was invalid or because the caller lacks\n      authorization to access the referenced\
    \ credentials.\n   o  GSS_S_DEFECTIVE_CREDENTIAL indicates that the referenced\n\
    \      credentials are invalid.\n   o  GSS_S_CREDENTIALS_EXPIRED indicates that\
    \ the referenced\n      credentials have expired.\n   o  GSS_S_BAD_MECH indicates\
    \ that the referenced credentials do not\n      contain elements for the requested\
    \ mechanism.\n   o  GSS_S_FAILURE indicates that the operation failed for reasons\n\
    \      unspecified at the GSS-API level.\n   The GSS_Inquire_cred_by_mech() call\
    \ enables callers in multi-\n   mechanism environments to acquire specific data\
    \ about available\n   combinations of lifetimes, usage modes, and mechanisms within\
    \ a\n   credential structure.  The lifetime_rec_initiate result indicates the\n\
    \   available lifetime for context initiation purposes; the\n   lifetime_rec_accept\
    \ result indicates the available lifetime for\n   context acceptance purposes.\n"
- title: '2.2:  Context-level calls'
  contents:
  - "2.2:  Context-level calls\n   This group of calls is devoted to the establishment\
    \ and management of\n   security contexts between peers. A context's initiator\
    \ calls\n   GSS_Init_sec_context(),  resulting in generation of a token which\
    \ the\n   caller passes to the target. At the target, that token is passed to\n\
    \   GSS_Accept_sec_context().  Depending on the underlying mech_type and\n   specified\
    \ options, additional token exchanges may be performed in the\n   course of context\
    \ establishment; such exchanges are accommodated by\n   GSS_S_CONTINUE_NEEDED\
    \ status returns from GSS_Init_sec_context()  and\n   GSS_Accept_sec_context().\n\
    \   Either party to an established context may invoke\n   GSS_Delete_sec_context()\
    \ to flush context information when a context\n   is no longer required. GSS_Process_context_token()\
    \  is used to\n   process received tokens carrying context-level control information.\n\
    \   GSS_Context_time()  allows a caller to determine the length of time\n   for\
    \ which an established context will remain valid.\n   GSS_Inquire_context() returns\
    \ status information describing context\n   characteristics. GSS_Wrap_size_limit()\
    \ allows a caller to determine\n   the size of a token which will be generated\
    \ by a GSS_Wrap()\n   operation.  GSS_Export_sec_context() and GSS_Import_sec_context()\n\
    \   enable transfer of active contexts between processes on an end\n   system.\n"
- title: '2.2.1:  GSS_Init_sec_context call'
  contents:
  - "2.2.1:  GSS_Init_sec_context call\n   Inputs:\n   o  claimant_cred_handle CREDENTIAL\
    \ HANDLE, -NULL specifies \"use\n      default\"\n   o  input_context_handle CONTEXT\
    \ HANDLE, -0 specifies \"none assigned\n      yet\"\n   o  targ_name INTERNAL\
    \ NAME,\n   o  mech_type OBJECT IDENTIFIER, -NULL parameter specifies \"use\n\
    \      default\"\n   o  deleg_req_flag BOOLEAN,\n   o  mutual_req_flag BOOLEAN,\n\
    \   o  replay_det_req_flag BOOLEAN,\n   o  sequence_req_flag BOOLEAN,\n   o  anon_req_flag\
    \ BOOLEAN,\n   o  lifetime_req INTEGER,-0 specifies default lifetime\n   o  chan_bindings\
    \ OCTET STRING,\n   o  input_token OCTET STRING-NULL or token received from target\n\
    \   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o \
    \ output_context_handle CONTEXT HANDLE,\n   o  mech_type OBJECT IDENTIFIER, -actual\
    \ mechanism always\n      indicated, never NULL\n   o  output_token OCTET STRING,\
    \ -NULL or token to pass to context\n      target\n   o  deleg_state BOOLEAN,\n\
    \   o  mutual_state BOOLEAN,\n   o  replay_det_state BOOLEAN,\n   o  sequence_state\
    \ BOOLEAN,\n   o  anon_state BOOLEAN,\n   o  trans_state BOOLEAN,\n   o  prot_ready_state\
    \ BOOLEAN, -- see Section 1.2.7\n   o  conf_avail BOOLEAN,\n   o  integ_avail\
    \ BOOLEAN,\n   o  lifetime_rec INTEGER - in seconds, or reserved value for\n \
    \     INDEFINITE\n   This call may block pending network interactions for those\
    \ mech_types\n   in which an authentication server or other network entity must\
    \ be\n   consulted on behalf of a context initiator in order to generate an\n\
    \   output_token suitable for presentation to a specified target.\n   Return major_status\
    \ codes:\n   o  GSS_S_COMPLETE indicates that context-level information was\n\
    \      successfully initialized, and that the returned output_token\n      will\
    \ provide sufficient information for the target to perform\n      per-message\
    \ processing on the newly-established context.\n   o  GSS_S_CONTINUE_NEEDED indicates\
    \ that control information in the\n      returned output_token must be sent to\
    \ the target, and that a\n      reply must be received and passed as the input_token\
    \ argument\n      to a continuation call to GSS_Init_sec_context(),  before\n\
    \      per-message processing can be performed in conjunction with\n      this\
    \ context.\n   o  GSS_S_DEFECTIVE_TOKEN indicates that consistency checks\n  \
    \    performed on the input_token failed, preventing further\n      processing\
    \ from being performed based on that token.\n   o  GSS_S_DEFECTIVE_CREDENTIAL\
    \ indicates that consistency checks\n      performed on the credential structure\
    \ referenced by\n      claimant_cred_handle failed, preventing further processing\
    \ from\n      being performed using that credential structure.\n   o  GSS_S_BAD_SIG\
    \ indicates that the received input_token\n      contains an incorrect integrity\
    \ check, so context setup cannot\n      be accomplished.\n   o  GSS_S_NO_CRED\
    \ indicates that no context was established,\n      either because the input cred_handle\
    \ was invalid, because the\n      referenced credentials are valid for context\
    \ acceptor use\n      only, or because the caller lacks authorization to access\
    \ the\n      referenced credentials.\n   o  GSS_S_CREDENTIALS_EXPIRED indicates\
    \ that the credentials\n      provided through the input claimant_cred_handle\
    \ argument are no\n      longer valid, so context establishment cannot be completed.\n\
    \   o  GSS_S_BAD_BINDINGS indicates that a mismatch between the\n      caller-provided\
    \ chan_bindings and those extracted from the\n      input_token was detected,\
    \ signifying a security-relevant\n      event and preventing context establishment.\
    \ (This result will\n      be returned by GSS_Init_sec_context only for contexts\
    \ where\n      mutual_state is TRUE.)\n   o  GSS_S_OLD_TOKEN indicates that the\
    \ input_token is too old to\n      be checked for integrity. This is a fatal error\
    \ during context\n      establishment.\n   o  GSS_S_DUPLICATE_TOKEN indicates\
    \ that the input token has a\n      correct integrity check, but is a duplicate\
    \ of a token already\n      processed. This is a fatal error during context establishment.\n\
    \   o  GSS_S_NO_CONTEXT indicates that no valid context was recognized\n     \
    \ for the input context_handle provided; this major status will\n      be returned\
    \ only for successor calls following GSS_S_CONTINUE_\n      NEEDED status returns.\n\
    \   o  GSS_S_BAD_NAMETYPE indicates that the provided targ_name is\n      of a\
    \ type uninterpretable or unsupported by the applicable\n      underlying GSS-API\
    \ mechanism(s), so context establishment\n      cannot be completed.\n   o  GSS_S_BAD_NAME\
    \ indicates that the provided targ_name is\n      inconsistent in terms of internally-incorporated\
    \ type specifier\n      information, so context establishment cannot be accomplished.\n\
    \   o  GSS_S_BAD_MECH indicates receipt of a context establishment token\n   \
    \   or of a caller request specifying a mechanism unsupported by\n      the local\
    \ system or with the caller's active credentials\n   o  GSS_S_FAILURE indicates\
    \ that context setup could not be\n      accomplished for reasons unspecified\
    \ at the GSS-API level, and\n      that no interface-defined recovery action is\
    \ available.\n   This routine is used by a context initiator, and ordinarily emits\
    \ one\n   (or, for the case of a multi-step exchange, more than one)\n   output_token\
    \ suitable for use by the target within the selected\n   mech_type's protocol.\
    \ Using information in the credentials structure\n   referenced by claimant_cred_handle,\
    \ GSS_Init_sec_context()\n   initializes the data structures required to establish\
    \ a security\n   context with target targ_name. The targ_name may be any valid\n\
    \   INTERNAL NAME; it need not be an MN. The claimant_cred_handle must\n   correspond\
    \ to the same valid credentials structure on the initial\n   call to GSS_Init_sec_context()\
    \  and on any successor calls resulting\n   from GSS_S_CONTINUE_NEEDED status\
    \ returns; different protocol\n   sequences modeled by the GSS_S_CONTINUE_NEEDED\
    \ facility will require\n   access to credentials at different points in the context\n\
    \   establishment sequence.\n   The input_context_handle argument is 0, specifying\
    \ \"not yet\n   assigned\", on the first GSS_Init_sec_context()  call relating\
    \ to a\n   given context. If successful (i.e., if accompanied by major_status\n\
    \   GSS_S_COMPLETE or GSS_S_CONTINUE_NEEDED), and only if successful, the\n  \
    \ initial GSS_Init_sec_context() call returns a non-zero\n   output_context_handle\
    \ for use in future references to this context.\n   Once a non-zero output_context_handle\
    \ has been returned, GSS-API\n   callers should call GSS_Delete_sec_context()\
    \ to release context-\n   related resources if errors occur in later phases of\
    \ context\n   establishment, or when an established context is no longer required.\n\
    \   When continuation attempts to GSS_Init_sec_context() are needed to\n   perform\
    \ context establishment, the previously-returned non-zero\n   handle value is\
    \ entered into the input_context_handle argument and\n   will be echoed in the\
    \ returned output_context_handle argument. On\n   such continuation attempts (and\
    \ only on continuation attempts) the\n   input_token value is used, to provide\
    \ the token returned from the\n   context's target.\n   The chan_bindings argument\
    \ is used by the caller to provide\n   information binding the security context\
    \ to security-related\n   characteristics (e.g., addresses, cryptographic keys)\
    \ of the\n   underlying communications channel. See Section 1.1.6 of this document\n\
    \   for more discussion of this argument's usage.\n   The input_token argument\
    \ contains a message received from the target,\n   and is significant only on\
    \ a call to GSS_Init_sec_context()  which\n   follows a previous return indicating\
    \ GSS_S_CONTINUE_NEEDED\n   major_status.\n   It is the caller's responsibility\
    \ to establish a communications path\n   to the target, and to transmit any returned\
    \ output_token (independent\n   of the accompanying returned major_status value)\
    \ to the target over\n   that path. The output_token can, however, be transmitted\
    \ along with\n   the first application-provided input message to be processed\
    \ by\n   GSS_GetMIC() or GSS_Wrap() in conjunction with a successfully-\n   established\
    \ context.\n   The initiator may request various context-level functions through\n\
    \   input flags: the deleg_req_flag requests delegation of access rights,\n  \
    \ the mutual_req_flag requests mutual authentication, the\n   replay_det_req_flag\
    \ requests that replay detection features be\n   applied to messages transferred\
    \ on the established context, and the\n   sequence_req_flag requests that sequencing\
    \ be enforced. (See Section\n   1.2.3 for more information on replay detection\
    \ and sequencing\n   features.)  The anon_req_flag requests that the initiator's\
    \ identity\n   not be transferred within tokens to be sent to the acceptor.\n\
    \   Not all of the optionally-requestable features will be available in\n   all\
    \ underlying mech_types. The corresponding return state values\n   deleg_state,\
    \ mutual_state, replay_det_state, and sequence_state\n   indicate, as a function\
    \ of mech_type processing capabilities and\n   initiator-provided input flags,\
    \ the set of features which will be\n   active on the context.  The returned trans_state\
    \ value indicates\n   whether the context is transferable to other processes through\
    \ use of\n   GSS_Export_sec_context().  These state indicators' values are\n \
    \  undefined unless either the routine's major_status indicates\n   GSS_S_COMPLETE,\
    \ or TRUE prot_ready_state is returned along with\n   GSS_S_CONTINUE_NEEDED major_status;\
    \ for the latter case, it is\n   possible that additional features, not confirmed\
    \ or indicated along\n   with TRUE prot_ready_state, will be confirmed and indicated\
    \ when\n   GSS_S_COMPLETE is subsequently returned.\n   The returned anon_state\
    \ and prot_ready_state values are significant\n   for both GSS_S_COMPLETE and\
    \ GSS_S_CONTINUE_NEEDED major_status\n   returns from GSS_Init_sec_context().\
    \  When anon_state is returned\n   TRUE, this indicates that neither the current\
    \ token nor its\n   predecessors delivers or has delivered the initiator's identity.\n\
    \   Callers wishing to perform context establishment only if anonymity\n   support\
    \ is provided should transfer a returned token from\n   GSS_Init_sec_context()\
    \ to the peer only if it is accompanied by a\n   TRUE anon_state indicator.  When\
    \ prot_ready_state is returned TRUE in\n   conjunction with GSS_S_CONTINUE_NEEDED\
    \ major_status, this indicates\n   that per-message protection operations may\
    \ be applied on the context:\n   see Section 1.2.7 for further discussion of this\
    \ facility.\n   Failure to provide the precise set of features requested by the\n\
    \   caller does not cause context establishment to fail; it is the\n   caller's\
    \ prerogative to delete the context if the feature set\n   provided is unsuitable\
    \ for the caller's use.\n   The returned mech_type value indicates the specific\
    \ mechanism\n   employed on the context, is valid only along with major_status\n\
    \   GSS_S_COMPLETE, and will never indicate the value for \"default\".\n   Note\
    \ that, for the case of certain mechanisms which themselves\n   perform negotiation,\
    \ the returned mech_type result may indicate\n   selection of a mechanism identified\
    \ by an OID different than that\n   passed in the input mech_type argument.\n\
    \   The conf_avail return value indicates whether the context supports\n   per-message\
    \ confidentiality services, and so informs the caller\n   whether or not a request\
    \ for encryption through the conf_req_flag\n   input to GSS_Wrap()  can be honored.\
    \ In similar fashion, the\n   integ_avail return value indicates whether per-message\
    \ integrity\n   services are available (through either GSS_GetMIC() or GSS_Wrap())\
    \ on\n   the established context. These state indicators' values are undefined\n\
    \   unless either the routine's major_status indicates GSS_S_COMPLETE, or\n  \
    \ TRUE prot_ready_state is returned along with GSS_S_CONTINUE_NEEDED\n   major_status.\n\
    \   The lifetime_req input specifies a desired upper bound for the\n   lifetime\
    \ of the context to be established, with a value of 0 used to\n   request a default\
    \ lifetime. The lifetime_rec return value indicates\n   the length of time for\
    \ which the context will be valid, expressed as\n   an offset from the present;\
    \ depending on mechanism capabilities,\n   credential lifetimes, and local policy,\
    \ it may not correspond to the\n   value requested in lifetime_req.  If no constraints\
    \ on context\n   lifetime are imposed, this may be indicated by returning a reserved\n\
    \   value representing INDEFINITE lifetime_req. The value of lifetime_rec\n  \
    \ is undefined unless the routine's major_status indicates\n   GSS_S_COMPLETE.\n\
    \   If the mutual_state is TRUE, this fact will be reflected within the\n   output_token.\
    \ A call to GSS_Accept_sec_context()  at the target in\n   conjunction with such\
    \ a context will return a token, to be processed\n   by a continuation call to\
    \ GSS_Init_sec_context(),  in order to\n   achieve mutual authentication.\n"
- title: '2.2.2:  GSS_Accept_sec_context call'
  contents:
  - "2.2.2:  GSS_Accept_sec_context call\n   Inputs:\n   o  acceptor_cred_handle CREDENTIAL\
    \ HANDLE, -- NULL specifies\n      \"use default\"\n   o  input_context_handle\
    \ CONTEXT HANDLE, -- 0 specifies\n      \"not yet assigned\"\n   o  chan_bindings\
    \ OCTET STRING,\n   o  input_token OCTET STRING\n   Outputs:\n   o  major_status\
    \ INTEGER,\n   o  minor_status INTEGER,\n   o  src_name INTERNAL NAME, -- guaranteed\
    \ to be MN\n   o  mech_type OBJECT IDENTIFIER,\n   o  output_context_handle CONTEXT\
    \ HANDLE,\n   o  deleg_state BOOLEAN,\n   o  mutual_state BOOLEAN,\n   o  replay_det_state\
    \ BOOLEAN,\n   o  sequence_state BOOLEAN,\n   o  anon_state BOOLEAN,\n   o  trans_state\
    \ BOOLEAN,\n   o  prot_ready_state BOOLEAN, -- see Section 1.2.7 for discussion\n\
    \   o  conf_avail BOOLEAN,\n   o  integ_avail BOOLEAN,\n   o  lifetime_rec INTEGER,\
    \ - in seconds, or reserved value for\n      INDEFINITE\n   o  delegated_cred_handle\
    \ CREDENTIAL HANDLE,\n   o  output_token OCTET STRING -NULL or token to pass to\
    \ context\n      initiator\n   This call may block pending network interactions\
    \ for those mech_types\n   in which a directory service or other network entity\
    \ must be\n   consulted on behalf of a context acceptor in order to validate a\n\
    \   received input_token.\n   Return major_status codes:\n   o  GSS_S_COMPLETE\
    \ indicates that context-level data structures\n      were successfully initialized,\
    \ and that per-message processing\n      can now be performed in conjunction with\
    \ this context.\n   o  GSS_S_CONTINUE_NEEDED indicates that control information\
    \ in the\n      returned output_token must be sent to the initiator, and that\n\
    \      a response must be received and passed as the input_token\n      argument\
    \ to a continuation call to GSS_Accept_sec_context(),\n      before per-message\
    \ processing can be performed in conjunction\n      with this context.\n   o \
    \ GSS_S_DEFECTIVE_TOKEN indicates that consistency checks performed\n      on\
    \ the input_token failed, preventing further processing from\n      being performed\
    \ based on that token.\n   o  GSS_S_DEFECTIVE_CREDENTIAL indicates that consistency\
    \ checks\n      performed on the credential structure referenced by\n      acceptor_cred_handle\
    \ failed, preventing further processing from\n      being performed using that\
    \ credential structure.\n   o  GSS_S_BAD_SIG indicates that the received input_token\
    \ contains\n      an incorrect integrity check, so context setup cannot be\n \
    \     accomplished.\n   o  GSS_S_DUPLICATE_TOKEN indicates that the integrity\
    \ check on the\n      received input_token was correct, but that the input_token\n\
    \      was recognized as a duplicate of an input_token already\n      processed.\
    \ No new context is established.\n   o  GSS_S_OLD_TOKEN indicates that the integrity\
    \ check on the received\n      input_token was correct, but that the input_token\
    \ is too old\n      to be checked for duplication against previously-processed\n\
    \      input_tokens. No new context is established.\n   o  GSS_S_NO_CRED indicates\
    \ that no context was established, either\n      because the input cred_handle\
    \ was invalid, because the\n      referenced credentials are valid for context\
    \ initiator use\n      only, or because the caller lacks authorization to access\
    \ the\n      referenced credentials.\n   o  GSS_S_CREDENTIALS_EXPIRED indicates\
    \ that the credentials provided\n      through the input acceptor_cred_handle\
    \ argument are no\n      longer valid, so context establishment cannot be completed.\n\
    \   o  GSS_S_BAD_BINDINGS indicates that a mismatch between the\n      caller-provided\
    \ chan_bindings and those extracted from the\n      input_token was detected,\
    \ signifying a security-relevant\n      event and preventing context establishment.\n\
    \   o  GSS_S_NO_CONTEXT indicates that no valid context was recognized\n     \
    \ for the input context_handle provided; this major status will\n      be returned\
    \ only for successor calls following GSS_S_CONTINUE_\n      NEEDED status returns.\n\
    \   o  GSS_S_BAD_MECH indicates receipt of a context establishment token\n   \
    \   specifying a mechanism unsupported by the local system or with\n      the\
    \ caller's active credentials.\n   o  GSS_S_FAILURE indicates that context setup\
    \ could not be\n      accomplished for reasons unspecified at the GSS-API level,\
    \ and\n      that no interface-defined recovery action is available.\n   The GSS_Accept_sec_context()\
    \  routine is used by a context target.\n   Using information in the credentials\
    \ structure referenced by the\n   input acceptor_cred_handle, it verifies the\
    \ incoming input_token and\n   (following the successful completion of a context\
    \ establishment\n   sequence) returns the authenticated src_name and the mech_type\
    \ used.\n   The returned src_name is guaranteed to be an MN, processed by the\n\
    \   mechanism under which the context was established. The\n   acceptor_cred_handle\
    \ must correspond to the same valid credentials\n   structure on the initial call\
    \ to GSS_Accept_sec_context() and on any\n   successor calls resulting from GSS_S_CONTINUE_NEEDED\
    \ status returns;\n   different protocol sequences modeled by the GSS_S_CONTINUE_NEEDED\n\
    \   mechanism will require access to credentials at different points in\n   the\
    \ context establishment sequence.\n   The input_context_handle argument is 0,\
    \ specifying \"not yet\n   assigned\", on the first GSS_Accept_sec_context() \
    \ call relating to a\n   given context.  If successful (i.e., if accompanied by\
    \ major_status\n   GSS_S_COMPLETE or GSS_S_CONTINUE_NEEDED), and only if successful,\
    \ the\n   initial GSS_Accept_sec_context() call returns a non-zero\n   output_context_handle\
    \ for use in future references to this context.\n   Once a non-zero output_context_handle\
    \ has been returned, GSS-API\n   callers should call GSS_Delete_sec_context()\
    \ to release context-\n   related resources if errors occur in later phases of\
    \ context\n   establishment, or when an established context is no longer required.\n\
    \   The chan_bindings argument is used by the caller to provide\n   information\
    \ binding the security context to security-related\n   characteristics (e.g.,\
    \ addresses, cryptographic keys) of the\n   underlying communications channel.\
    \ See Section 1.1.6 of this document\n   for more discussion of this argument's\
    \ usage.\n   The returned state results (deleg_state, mutual_state,\n   replay_det_state,\
    \ sequence_state, anon_state, trans_state, and\n   prot_ready_state) reflect the\
    \ same information as described for\n   GSS_Init_sec_context(), and their values\
    \ are significant under the\n   same return state conditions.\n   The conf_avail\
    \ return value indicates whether the context supports\n   per-message confidentiality\
    \ services, and so informs the caller\n   whether or not a request for encryption\
    \ through the conf_req_flag\n   input to GSS_Wrap()  can be honored. In similar\
    \ fashion, the\n   integ_avail return value indicates whether per-message integrity\n\
    \   services are available (through either GSS_GetMIC()  or GSS_Wrap())\n   on\
    \ the established context.  These values are significant under the\n   same return\
    \ state conditions as described under\n   GSS_Init_sec_context().\n   The lifetime_rec\
    \ return value is significant only in conjunction with\n   GSS_S_COMPLETE major_status,\
    \ and indicates the length of time for\n   which the context will be valid, expressed\
    \ as an offset from the\n   present.\n   The mech_type return value indicates\
    \ the specific mechanism employed\n   on the context, is valid only along with\
    \ major_status GSS_S_COMPLETE,\n   and will never indicate the value for \"default\"\
    .\n   The delegated_cred_handle result is significant only when deleg_state\n\
    \   is TRUE, and provides a means for the target to reference the\n   delegated\
    \ credentials. The output_token result, when non-NULL,\n   provides a context-level\
    \ token to be returned to the context\n   initiator to continue a multi-step context\
    \ establishment sequence. As\n   noted with GSS_Init_sec_context(),  any returned\
    \ token should be\n   transferred to the context's peer (in this case, the context\n\
    \   initiator), independent of the value of the accompanying returned\n   major_status.\n\
    \   Note: A target must be able to distinguish a context-level\n   input_token,\
    \ which is passed to GSS_Accept_sec_context(),  from the\n   per-message data\
    \ elements passed to GSS_VerifyMIC()  or GSS_Unwrap().\n   These data elements\
    \ may arrive in a single application message, and\n   GSS_Accept_sec_context()\
    \  must be performed before per-message\n   processing can be performed successfully.\n"
- title: '2.2.3: GSS_Delete_sec_context call'
  contents:
  - "2.2.3: GSS_Delete_sec_context call\n   Input:\n   o  context_handle CONTEXT HANDLE\n\
    \   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o \
    \ output_context_token OCTET STRING\n   Return major_status codes:\n   o  GSS_S_COMPLETE\
    \ indicates that the context was recognized, and that\n      relevant context-specific\
    \ information was flushed.  If the caller\n      provides a non-null buffer to\
    \ receive an output_context_token, and\n      the mechanism returns a non-NULL\
    \ token into that buffer, the\n      returned output_context_token is ready for\
    \ transfer to the\n      context's peer.\n   o  GSS_S_NO_CONTEXT indicates that\
    \ no valid context was recognized\n      for the input context_handle provided,\
    \ so no deletion was\n      performed.\n   o  GSS_S_FAILURE indicates that the\
    \ context is recognized, but\n      that the GSS_Delete_sec_context()  operation\
    \ could not be\n      performed for reasons unspecified at the GSS-API level.\n\
    \   This call may block pending network interactions for mech_types in\n   which\
    \ active notification must be made to a central server when a\n   security context\
    \ is to be deleted.\n   This call can be made by either peer in a security context,\
    \ to flush\n   context-specific information.  If a non-null output_context_token\n\
    \   parameter is provided by the caller, an output_context_token may be\n   returned\
    \ to the caller.  If an output_context_token is provided to\n   the caller, it\
    \ can be passed to the context's peer to inform the\n   peer's GSS-API implementation\
    \ that the peer's corresponding context\n   information can also be flushed. (Once\
    \ a context is established, the\n   peers involved are expected to retain cached\
    \ credential and context-\n   related information until the information's expiration\
    \ time is\n   reached or until a GSS_Delete_sec_context() call is made.)\n   The\
    \ facility for context_token usage to signal context deletion is\n   retained\
    \ for compatibility with GSS-API Version 1.  For current\n   usage, it is recommended\
    \ that both peers to a context invoke\n   GSS_Delete_sec_context() independently,\
    \ passing a null\n   output_context_token buffer to indicate that no context_token\
    \ is\n   required.  Implementations of GSS_Delete_sec_context() should delete\n\
    \   relevant locally-stored context information.\n   Attempts to perform per-message\
    \ processing on a deleted context will\n   result in error returns.\n"
- title: '2.2.4:  GSS_Process_context_token call'
  contents:
  - "2.2.4:  GSS_Process_context_token call\n   Inputs:\n   o  context_handle CONTEXT\
    \ HANDLE,\n   o  input_context_token OCTET STRING\n   Outputs:\n   o  major_status\
    \ INTEGER,\n   o  minor_status INTEGER,\n   Return major_status codes:\n   o \
    \ GSS_S_COMPLETE indicates that the input_context_token was\n      successfully\
    \ processed in conjunction with the context\n      referenced by context_handle.\n\
    \   o  GSS_S_DEFECTIVE_TOKEN indicates that consistency checks\n      performed\
    \ on the received context_token failed, preventing\n      further processing from\
    \ being performed with that token.\n   o  GSS_S_NO_CONTEXT indicates that no valid\
    \ context was recognized\n      for the input context_handle provided.\n   o \
    \ GSS_S_FAILURE indicates that the context is recognized, but\n      that the\
    \ GSS_Process_context_token()  operation could not be\n      performed for reasons\
    \ unspecified at the GSS-API level.\n   This call is used to process context_tokens\
    \ received from a peer once\n   a context has been established, with corresponding\
    \ impact on\n   context-level state information. One use for this facility is\n\
    \   processing of the context_tokens generated by\n   GSS_Delete_sec_context();\
    \  GSS_Process_context_token() will not block\n   pending network interactions\
    \ for that purpose. Another use is to\n   process tokens indicating remote-peer\
    \ context establishment failures\n   after the point where the local GSS-API implementation\
    \ has already\n   indicated GSS_S_COMPLETE status.\n"
- title: '2.2.5:  GSS_Context_time call'
  contents:
  - "2.2.5:  GSS_Context_time call\n   Input:\n   o  context_handle CONTEXT HANDLE,\n\
    \   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o \
    \ lifetime_rec INTEGER - in seconds, or reserved value for\n      INDEFINITE\n\
    \   Return major_status codes:\n   o  GSS_S_COMPLETE indicates that the referenced\
    \ context is valid,\n      and will remain valid for the amount of time indicated\
    \ in\n      lifetime_rec.\n   o  GSS_S_CONTEXT_EXPIRED indicates that data items\
    \ related to the\n      referenced context have expired.\n   o  GSS_S_CREDENTIALS_EXPIRED\
    \ indicates that the context is\n      recognized, but that its associated credentials\
    \ have expired.\n   o  GSS_S_NO_CONTEXT indicates that no valid context was recognized\n\
    \      for the input context_handle provided.\n   o  GSS_S_FAILURE indicates that\
    \ the requested operation failed for\n       reasons unspecified at the GSS-API\
    \ level.\n   This call is used to determine the amount of time for which a\n \
    \  currently established context will remain valid.\n"
- title: '2.2.6:   GSS_Inquire_context call'
  contents:
  - "2.2.6:   GSS_Inquire_context call\n   Input:\n   o  context_handle CONTEXT HANDLE,\n\
    \   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o \
    \ src_name INTERNAL NAME,  -- name of context initiator,\n                   \
    \            -- guaranteed to be MN\n   o  targ_name INTERNAL NAME,  -- name of\
    \ context target,\n                                -- guaranteed to be MN\n  \
    \ o  lifetime_rec INTEGER -- in seconds, or reserved value for\n      INDEFINITE,\n\
    \   o  mech_type OBJECT IDENTIFIER, -- the mechanism supporting this\n      security\
    \ context\n   o  deleg_state BOOLEAN,\n   o  mutual_state BOOLEAN,\n   o  replay_det_state\
    \ BOOLEAN,\n   o  sequence_state BOOLEAN,\n   o  anon_state BOOLEAN,\n   o  trans_state\
    \ BOOLEAN,\n   o  prot_ready_state BOOLEAN,\n   o  conf_avail BOOLEAN,\n   o \
    \ integ_avail BOOLEAN,\n   o  locally_initiated BOOLEAN, -- TRUE if initiator,\
    \ FALSE if acceptor\n   Return major_status codes:\n   o  GSS_S_COMPLETE indicates\
    \ that the referenced context is valid\n      and that src_name, targ_name, lifetime_rec,\
    \ mech_type, deleg_state,\n      mutual_state, replay_det_state, sequence_state,\
    \ anon_state,\n      trans_state, prot_ready_state, conf_avail, integ_avail, and\n\
    \      locally_initiated return values describe the corresponding\n      characteristics\
    \ of the context.\n   o  GSS_S_CONTEXT_EXPIRED indicates that the provided input\n\
    \      context_handle is recognized, but that the referenced context\n      has\
    \ expired.  Return values other than major_status and\n      minor_status are\
    \ undefined.\n   o  GSS_S_NO_CONTEXT indicates that no valid context was recognized\n\
    \      for the input context_handle provided. Return values other than\n     \
    \ major_status and minor_status are undefined.\n   o  GSS_S_FAILURE indicates\
    \ that the requested operation failed for\n     reasons unspecified at the GSS-API\
    \ level. Return values other than\n         major_status and minor_status are\
    \ undefined.\n   This call is used to extract information describing characteristics\n\
    \   of a security context.\n"
- title: '2.2.7:   GSS_Wrap_size_limit call'
  contents:
  - "2.2.7:   GSS_Wrap_size_limit call\n   Inputs:\n   o  context_handle CONTEXT HANDLE,\n\
    \   o  qop INTEGER,\n   o  output_size INTEGER\n   Outputs:\n   o  major_status\
    \ INTEGER,\n   o  minor_status INTEGER,\n   o  max_input_size INTEGER\n   Return\
    \ major_status codes:\n   o  GSS_S_COMPLETE indicates a successful token size\
    \ determination:\n   an input message with a length in octets equal to the\n \
    \  returned max_input_size value will, when passed to GSS_Wrap()\n   for processing\
    \ on the context identified by the context_handle\n   parameter and with the quality\
    \ of protection specifier provided\n   in the qop parameter, yield an output token\
    \ no larger than the\n   value of the provided output_size parameter.\n   o  GSS_S_CONTEXT_EXPIRED\
    \ indicates that the provided input\n   context_handle is recognized, but that\
    \ the referenced context\n   has expired.  Return values other than major_status\
    \ and\n   minor_status are undefined.\n   o  GSS_S_NO_CONTEXT indicates that no\
    \ valid context was recognized\n   for the input context_handle provided. Return\
    \ values other than\n   major_status and minor_status are undefined.\n   o  GSS_S_BAD_QOP\
    \ indicates that the provided QOP value is not\n   recognized or supported for\
    \ the context.\n   o  GSS_S_FAILURE indicates that the requested operation failed\
    \ for\n   reasons unspecified at the GSS-API level. Return values other than\n\
    \   major_status and minor_status are undefined.\n   This call is used to determine\
    \ the largest input datum which may be\n   passed to GSS_Wrap() without yielding\
    \ an output token larger than a\n   caller-specified value.\n"
- title: '2.2.8:   GSS_Export_sec_context call'
  contents:
  - "2.2.8:   GSS_Export_sec_context call\n   Inputs:\n   o  context_handle CONTEXT\
    \ HANDLE\n   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n\
    \   o  interprocess_token OCTET STRING\n   Return major_status codes:\n   o  GSS_S_COMPLETE\
    \ indicates that the referenced context has been\n   successfully exported to\
    \ a representation in the interprocess_token,\n   and is no longer available for\
    \ use by the caller.\n   o  GSS_S_UNAVAILABLE indicates that the context export\
    \ facility\n   is not available for use on the referenced context.  (This status\n\
    \   should occur only for contexts for which the trans_state value is\n   FALSE.)\
    \ Return values other than major_status and minor_status are\n   undefined.\n\
    \   o GSS_S_CONTEXT_EXPIRED indicates that the provided input\n   context_handle\
    \ is recognized, but that the referenced context has\n   expired.  Return values\
    \ other than major_status and minor_status are\n   undefined.\n   o  GSS_S_NO_CONTEXT\
    \ indicates that no valid context was recognized\n   for the input context_handle\
    \ provided. Return values other than\n   major_status and minor_status are undefined.\n\
    \   o  GSS_S_FAILURE indicates that the requested operation failed for\n   reasons\
    \ unspecified at the GSS-API level. Return values other than\n   major_status\
    \ and minor_status are undefined.\n   This call generates an interprocess token\
    \ for transfer to another\n   process within an end system, in order to transfer\
    \ control of a\n   security context to that process.  The recipient of the interprocess\n\
    \   token will call GSS_Import_sec_context() to accept the transfer.  The\n  \
    \ GSS_Export_sec_context() operation is defined for use only with\n   security\
    \ contexts which are fully and successfully established (i.e.,\n   those for which\
    \ GSS_Init_sec_context() and GSS_Accept_sec_context()\n   have returned GSS_S_COMPLETE\
    \ major_status).\n   To ensure portability, a caller of GSS_Export_sec_context()\
    \ must not\n   assume that a context may continue to be used once it has been\n\
    \   exported; following export, the context referenced by the\n   context_handle\
    \ cannot be assumed to remain valid.  Further, portable\n   callers must not assume\
    \ that a given interprocess token can be\n   imported by GSS_Import_sec_context()\
    \ more than once, thereby creating\n   multiple instantiations of a single context.\
    \  GSS-API implementations\n   may detect and reject attempted multiple imports,\
    \ but are not\n   required to do so.\n   The internal representation contained\
    \ within the interprocess token\n   is an implementation-defined local matter.\
    \  Interprocess tokens\n   cannot be assumed to be transferable across different\
    \ GSS-API\n   implementations.\n   It is recommended that GSS-API implementations\
    \ adopt policies suited\n   to their operational environments in order to define\
    \ the set of\n   processes eligible to import a context, but specific constraints\
    \ in\n   this area are local matters.  Candidate examples include transfers\n\
    \   between processes operating on behalf of the same user identity, or\n   processes\
    \ comprising a common job.  However, it may be impossible to\n   enforce such\
    \ policies in some implementations.\n   In support of the above goals, implementations\
    \ may protect the\n   transferred context data by using cryptography to protect\
    \ data within\n   the interprocess token, or by using interprocess tokens as a\
    \ means to\n   reference local interprocess communication facilities (protected\
    \ by\n   other means) rather than storing the context data directly within the\n\
    \   tokens.\n   Transfer of an open context may, for certain mechanisms and\n\
    \   implementations, reveal data about the credential which was used to\n   establish\
    \ the context.  Callers should, therefore, be cautious about\n   the trustworthiness\
    \ of processes to which they transfer contexts.\n   Although the GSS-API implementation\
    \ may provide its own set of\n   protections over the exported context, the caller\
    \ is responsible for\n   protecting the interprocess token from disclosure, and\
    \ for taking\n   care that the context is transferred to an appropriate destination\n\
    \   process.\n"
- title: '2.2.9:   GSS_Import_sec_context call'
  contents:
  - "2.2.9:   GSS_Import_sec_context call\n   Inputs:\n   o  interprocess_token OCTET\
    \ STRING\n   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n\
    \   o  context_handle CONTEXT HANDLE\n   Return major_status codes:\n   o  GSS_S_COMPLETE\
    \ indicates that the context represented by the\n   input interprocess_token has\
    \ been successfully transferred to\n   the caller, and is available for future\
    \ use via the output\n   context_handle.\n   o  GSS_S_CONTEXT_EXPIRED indicates\
    \ that the context represented by\n   the input interprocess_token has expired.\
    \ Return values other\n   than major_status and minor_status are undefined.\n\
    \   o  GSS_S_NO_CONTEXT indicates that the context represented by the\n   input\
    \ interprocess_token was invalid. Return values other than\n   major_status and\
    \ minor_status are undefined.\n   o  GSS_S_DEFECTIVE_TOKEN indicates that the\
    \ input interprocess_token\n   was defective.  Return values other than major_status\
    \ and\n   minor_status are undefined.\n   o  GSS_S_UNAVAILABLE indicates that\
    \ the context import facility\n   is not available for use on the referenced context.\
    \  Return values\n   other than major_status and minor_status are undefined.\n\
    \   o  GSS_S_UNAUTHORIZED indicates that the context represented by\n   the input\
    \ interprocess_token is unauthorized for transfer to the\n   caller. Return values\
    \ other than major_status and minor_status\n   are undefined.\n   o  GSS_S_FAILURE\
    \ indicates that the requested operation failed for\n   reasons unspecified at\
    \ the GSS-API level. Return values other than\n   major_status and minor_status\
    \ are undefined.\n   This call processes an interprocess token generated by\n\
    \   GSS_Export_sec_context(), making the transferred context available\n   for\
    \ use by the caller.  After a successful GSS_Import_sec_context()\n   operation,\
    \ the imported context is available for use by the importing\n   process.\n  \
    \ For further discussion of the security and authorization issues\n   regarding\
    \ this call, please see the discussion in Section 2.2.8.\n"
- title: '2.3:  Per-message calls'
  contents:
  - "2.3:  Per-message calls\n   This group of calls is used to perform per-message\
    \ protection\n   processing on an established security context. None of these\
    \ calls\n   block pending network interactions. These calls may be invoked by\
    \ a\n   context's initiator or by the context's target.  The four members of\n\
    \   this group should be considered as two pairs; the output from\n   GSS_GetMIC()\
    \  is properly input to GSS_VerifyMIC(),  and the output\n   from GSS_Wrap() is\
    \ properly input to GSS_Unwrap().\n   GSS_GetMIC() and GSS_VerifyMIC() support\
    \ data origin authentication\n   and data integrity services. When GSS_GetMIC()\
    \  is invoked on an\n   input message, it yields a per-message token containing\
    \ data items\n   which allow underlying mechanisms to provide the specified security\n\
    \   services. The original message, along with the generated per-message\n   token,\
    \ is passed to the remote peer; these two data elements are\n   processed by GSS_VerifyMIC(),\
    \  which validates the message in\n   conjunction with the separate token.\n \
    \  GSS_Wrap() and GSS_Unwrap() support caller-requested confidentiality\n   in\
    \ addition to the data origin authentication and data integrity\n   services offered\
    \ by GSS_GetMIC()  and GSS_VerifyMIC(). GSS_Wrap()\n   outputs a single data element,\
    \ encapsulating optionally enciphered\n   user data as well as associated token\
    \ data items.  The data element\n   output from GSS_Wrap()  is passed to the remote\
    \ peer and processed by\n   GSS_Unwrap()  at that system. GSS_Unwrap() combines\
    \ decipherment (as\n   required) with validation of data items related to authentication\
    \ and\n   integrity.\n"
- title: '2.3.1:  GSS_GetMIC call'
  contents:
  - "2.3.1:  GSS_GetMIC call\n   Note: This call is functionally equivalent to the\
    \ GSS_Sign call as\n   defined in previous versions of this specification. In\
    \ the interests\n   of backward compatibility, it is recommended that implementations\n\
    \   support this function under both names for the present; future\n   references\
    \ to this function as GSS_Sign are deprecated.\n   Inputs:\n   o  context_handle\
    \ CONTEXT HANDLE,\n   o  qop_req INTEGER,-0 specifies default QOP\n   o  message\
    \ OCTET STRING\n   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n\
    \   o  per_msg_token OCTET STRING\n   Return major_status codes:\n   o  GSS_S_COMPLETE\
    \ indicates that an integrity check, suitable for an\n      established security\
    \ context, was successfully applied and\n      that the message and corresponding\
    \ per_msg_token are ready\n      for transmission.\n   o  GSS_S_CONTEXT_EXPIRED\
    \ indicates that context-related data\n      items have expired, so that the requested\
    \ operation cannot be\n      performed.\n   o  GSS_S_CREDENTIALS_EXPIRED indicates\
    \ that the context is recognized,\n      but that its associated credentials have\
    \ expired, so\n      that the requested operation cannot be performed.\n   o \
    \ GSS_S_NO_CONTEXT indicates that no valid context was recognized\n      for the\
    \ input context_handle provided.\n   o  GSS_S_BAD_QOP indicates that the provided\
    \ QOP value is not\n      recognized or supported for the context.\n   o  GSS_S_FAILURE\
    \ indicates that the context is recognized, but\n      that the requested operation\
    \ could not be performed for\n      reasons unspecified at the GSS-API level.\n\
    \   Using the security context referenced by context_handle, apply an\n   integrity\
    \ check to the input message (along with timestamps and/or\n   other data included\
    \ in support of mech_type-specific mechanisms) and\n   return the result in per_msg_token.\
    \ The qop_req parameter,\n   interpretation of which is discussed in Section 1.2.4,\
    \ allows\n   quality-of-protection control. The caller passes the message and\
    \ the\n   per_msg_token to the target.\n   The GSS_GetMIC()  function completes\
    \ before the message and\n   per_msg_token is sent to the peer; successful application\
    \ of\n   GSS_GetMIC()  does not guarantee that a corresponding GSS_VerifyMIC()\n\
    \   has been (or can necessarily be) performed successfully when the\n   message\
    \ arrives at the destination.\n   Mechanisms which do not support per-message\
    \ protection services\n   should return GSS_S_FAILURE if this routine is called.\n"
- title: '2.3.2:  GSS_VerifyMIC call'
  contents:
  - "2.3.2:  GSS_VerifyMIC call\n   Note: This call is functionally equivalent to\
    \ the GSS_Verify call as\n   defined in previous versions of this specification.\
    \ In the interests\n   of backward compatibility, it is recommended that implementations\n\
    \   support this function under both names for the present; future\n   references\
    \ to this function as GSS_Verify are deprecated.\n   Inputs:\n   o  context_handle\
    \ CONTEXT HANDLE,\n   o  message OCTET STRING,\n   o  per_msg_token OCTET STRING\n\
    \   Outputs:\n   o  qop_state INTEGER,\n   o  major_status INTEGER,\n   o  minor_status\
    \ INTEGER,\n   Return major_status codes:\n   o  GSS_S_COMPLETE indicates that\
    \ the message was successfully\n      verified.\n   o  GSS_S_DEFECTIVE_TOKEN indicates\
    \ that consistency checks performed\n      on the received per_msg_token failed,\
    \ preventing\n      further processing from being performed with that token.\n\
    \   o  GSS_S_BAD_SIG indicates that the received per_msg_token contains\n    \
    \  an incorrect integrity check for the message.\n   o  GSS_S_DUPLICATE_TOKEN,\
    \ GSS_S_OLD_TOKEN, GSS_S_UNSEQ_TOKEN,\n      and GSS_S_GAP_TOKEN values appear\
    \ in conjunction with the\n      optional per-message replay detection features\
    \ described\n      in Section 1.2.3; their semantics are described in that section.\n\
    \   o  GSS_S_CONTEXT_EXPIRED indicates that context-related data\n      items\
    \ have expired, so that the requested operation cannot be\n      performed.\n\
    \   o  GSS_S_CREDENTIALS_EXPIRED indicates that the context is\n   recognized,\n\
    \      but that its associated credentials have expired, so\n      that the requested\
    \ operation cannot be performed.\n   o  GSS_S_NO_CONTEXT indicates that no valid\
    \ context was recognized\n      for the input context_handle provided.\n   o \
    \ GSS_S_FAILURE indicates that the context is recognized, but\n      that the\
    \ GSS_VerifyMIC() operation could not be performed for\n      reasons unspecified\
    \ at the GSS-API level.\n   Using the security context referenced by context_handle,\
    \ verify that\n   the input per_msg_token contains an appropriate integrity check\
    \ for\n   the input message, and apply any active replay detection or\n   sequencing\
    \ features. Return an indication of the quality-of-\n   protection applied to\
    \ the processed message in the qop_state result.\n   Since the GSS_VerifyMIC()\
    \ routine never provides a confidentiality\n   service, its implementations should\
    \ not return non-zero values in the\n   confidentiality fields of the output qop_state.\n\
    \   Mechanisms which do not support per-message protection services\n   should\
    \ return GSS_S_FAILURE if this routine is called.\n"
- title: '2.3.3: GSS_Wrap call'
  contents:
  - "2.3.3: GSS_Wrap call\n   Note: This call is functionally equivalent to the GSS_Seal\
    \ call as\n   defined in previous versions of this specification. In the interests\n\
    \   of backward compatibility, it is recommended that implementations\n   support\
    \ this function under both names for the present; future\n   references to this\
    \ function as GSS_Seal are deprecated.\n   Inputs:\n   o  context_handle CONTEXT\
    \ HANDLE,\n   o  conf_req_flag BOOLEAN,\n   o  qop_req INTEGER,-0 specifies default\
    \ QOP\n   o  input_message OCTET STRING\n   Outputs:\n   o  major_status INTEGER,\n\
    \   o  minor_status INTEGER,\n   o  conf_state BOOLEAN,\n   o  output_message\
    \ OCTET STRING\n   Return major_status codes:\n   o  GSS_S_COMPLETE indicates\
    \ that the input_message was successfully\n      processed and that the output_message\
    \ is ready for\n      transmission.\n   o  GSS_S_CONTEXT_EXPIRED indicates that\
    \ context-related data\n      items have expired, so that the requested operation\
    \ cannot be\n      performed.\n   o  GSS_S_CREDENTIALS_EXPIRED indicates that\
    \ the context is\n   recognized,\n      but that its associated credentials have\
    \ expired, so\n      that the requested operation cannot be performed.\n   o \
    \ GSS_S_NO_CONTEXT indicates that no valid context was recognized\n      for the\
    \ input context_handle provided.\n   o  GSS_S_BAD_QOP indicates that the provided\
    \ QOP value is not\n      recognized or supported for the context.\n   o  GSS_S_FAILURE\
    \ indicates that the context is recognized, but\n      that the GSS_Wrap()  operation\
    \ could not be performed for\n      reasons unspecified at the GSS-API level.\n\
    \   Performs the data origin authentication and data integrity functions\n   of\
    \ GSS_GetMIC().  If the input conf_req_flag is TRUE, requests that\n   confidentiality\
    \ be applied to the input_message.  Confidentiality may\n   not be supported in\
    \ all mech_types or by all implementations; the\n   returned conf_state flag indicates\
    \ whether confidentiality was\n   provided for the input_message. The qop_req\
    \ parameter, interpretation\n   of which is discussed in Section 1.2.4, allows\
    \ quality-of-protection\n   control.\n   In all cases, the GSS_Wrap()  call yields\
    \ a single output_message\n   data element containing (optionally enciphered)\
    \ user data as well as\n   control information.\n   Mechanisms which do not support\
    \ per-message protection services\n   should return GSS_S_FAILURE if this routine\
    \ is called.\n"
- title: '2.3.4: GSS_Unwrap call'
  contents:
  - "2.3.4: GSS_Unwrap call\n   Note: This call is functionally equivalent to the\
    \ GSS_Unseal call as\n   defined in previous versions of this specification. In\
    \ the interests\n   of backward compatibility, it is recommended that implementations\n\
    \   support this function under both names for the present; future\n   references\
    \ to this function as GSS_Unseal are deprecated.\n   Inputs:\n   o  context_handle\
    \ CONTEXT HANDLE,\n   o  input_message OCTET STRING\n   Outputs:\n   o  conf_state\
    \ BOOLEAN,\n   o  qop_state INTEGER,\n   o  major_status INTEGER,\n   o  minor_status\
    \ INTEGER,\n   o  output_message OCTET STRING\n   Return major_status codes:\n\
    \   o  GSS_S_COMPLETE indicates that the input_message was\n      successfully\
    \ processed and that the resulting output_message is\n      available.\n   o \
    \ GSS_S_DEFECTIVE_TOKEN indicates that consistency checks performed\n      on\
    \ the per_msg_token extracted from the input_message\n      failed, preventing\
    \ further processing from being performed.\n   o  GSS_S_BAD_SIG indicates that\
    \ an incorrect integrity check was\n   detected\n      for the message.\n   o\
    \  GSS_S_DUPLICATE_TOKEN, GSS_S_OLD_TOKEN, GSS_S_UNSEQ_TOKEN,\n      and GSS_S_GAP_TOKEN\
    \ values appear in conjunction with the\n      optional per-message replay detection\
    \ features described\n      in Section 1.2.3; their semantics are described in\
    \ that section.\n   o  GSS_S_CONTEXT_EXPIRED indicates that context-related data\n\
    \      items have expired, so that the requested operation cannot be\n      performed.\n\
    \   o  GSS_S_CREDENTIALS_EXPIRED indicates that the context is\n   recognized,\n\
    \      but that its associated credentials have expired, so\n      that the requested\
    \ operation cannot be performed.\n   o  GSS_S_NO_CONTEXT indicates that no valid\
    \ context was recognized\n      for the input context_handle provided.\n   o \
    \ GSS_S_FAILURE indicates that the context is recognized, but\n      that the\
    \ GSS_Unwrap()  operation could not be performed for\n      reasons unspecified\
    \ at the GSS-API level.\n   Processes a data element generated (and optionally\
    \ enciphered) by\n   GSS_Wrap(),  provided as input_message. The returned conf_state\
    \ value\n   indicates whether confidentiality was applied to the input_message.\n\
    \   If conf_state is TRUE, GSS_Unwrap()  deciphers the input_message.\n   Returns\
    \ an indication of the quality-of-protection applied to the\n   processed message\
    \ in the qop_state result. GSS_Wrap()  performs the\n   data integrity and data\
    \ origin authentication checking functions of\n   GSS_VerifyMIC()  on the plaintext\
    \ data. Plaintext data is returned in\n   output_message.\n   Mechanisms which\
    \ do not support per-message protection services\n   should return GSS_S_FAILURE\
    \ if this routine is called.\n"
- title: '2.4:  Support calls'
  contents:
  - "2.4:  Support calls\n   This group of calls provides support functions useful\
    \ to GSS-API\n   callers, independent of the state of established contexts. Their\n\
    \   characterization with regard to blocking or non-blocking status in\n   terms\
    \ of network interactions is unspecified.\n"
- title: '2.4.1:  GSS_Display_status call'
  contents:
  - "2.4.1:  GSS_Display_status call\n   Inputs:\n   o  status_value INTEGER,-GSS-API\
    \ major_status or minor_status\n      return value\n   o  status_type INTEGER,-1\
    \ if major_status, 2 if minor_status\n   o  mech_type OBJECT IDENTIFIER-mech_type\
    \ to be used for minor_\n      status translation\n   Outputs:\n   o  major_status\
    \ INTEGER,\n   o  minor_status INTEGER,\n   o  status_string_set SET OF OCTET\
    \ STRING\n   Return major_status codes:\n   o  GSS_S_COMPLETE indicates that a\
    \ valid printable status\n      representation (possibly representing more than\
    \ one status event\n      encoded within the status_value) is available in the\
    \ returned\n      status_string_set.\n   o  GSS_S_BAD_MECH indicates that translation\
    \ in accordance with an\n      unsupported mech_type was requested, so translation\
    \ could not\n      be performed.\n   o  GSS_S_BAD_STATUS indicates that the input\
    \ status_value was\n      invalid, or that the input status_type carried a value\
    \ other\n      than 1 or 2, so translation could not be performed.\n   o  GSS_S_FAILURE\
    \ indicates that the requested operation could not\n      be performed for reasons\
    \ unspecified at the GSS-API level.\n   Provides a means for callers to translate\
    \ GSS-API-returned major and\n   minor status codes into printable string representations.\n"
- title: '2.4.2:  GSS_Indicate_mechs call'
  contents:
  - "2.4.2:  GSS_Indicate_mechs call\n   Input:\n   o  (none)\n   Outputs:\n   o \
    \ major_status INTEGER,\n   o  minor_status INTEGER,\n   o  mech_set SET OF OBJECT\
    \ IDENTIFIER\n   Return major_status codes:\n   o  GSS_S_COMPLETE indicates that\
    \ a set of available mechanisms has\n      been returned in mech_set.\n   o  GSS_S_FAILURE\
    \ indicates that the requested operation could not\n      be performed for reasons\
    \ unspecified at the GSS-API level.\n   Allows callers to determine the set of\
    \ mechanism types available on\n   the local system. This call is intended for\
    \ support of specialized\n   callers who need to request non-default mech_type\
    \ sets from\n   GSS_Acquire_cred(),  and should not be needed by other callers.\n"
- title: '2.4.3:  GSS_Compare_name call'
  contents:
  - "2.4.3:  GSS_Compare_name call\n   Inputs:\n   o  name1 INTERNAL NAME,\n   o \
    \ name2 INTERNAL NAME\n   Outputs:\n   o  major_status INTEGER,\n   o  minor_status\
    \ INTEGER,\n   o  name_equal BOOLEAN\n   Return major_status codes:\n   o  GSS_S_COMPLETE\
    \ indicates that name1 and name2 were comparable,\n      and that the name_equal\
    \ result indicates whether name1 and\n      name2 represent the same entity.\n\
    \   o  GSS_S_BAD_NAMETYPE indicates that one or both of name1 and\n      name2\
    \ contained internal type specifiers uninterpretable\n      by the applicable\
    \ underlying GSS-API mechanism(s), or that\n      the two names' types are different\
    \ and incomparable, so that\n      the comparison operation could not be completed.\n\
    \   o  GSS_S_BAD_NAME indicates that one or both of the input names\n      was\
    \ ill-formed in terms of its internal type specifier, so\n      the comparison\
    \ operation could not be completed.\n   o  GSS_S_FAILURE indicates that the call's\
    \ operation could not\n      be performed for reasons unspecified at the GSS-API\
    \ level.\n   Allows callers to compare two internal name representations to\n\
    \   determine whether they refer to the same entity.  If either name\n   presented\
    \ to GSS_Compare_name() denotes an anonymous principal,\n   GSS_Compare_name()\
    \ shall indicate FALSE.  It is not required that\n   either or both inputs name1\
    \ and name2 be MNs; for some\n   implementations and cases, GSS_S_BAD_NAMETYPE\
    \ may be returned,\n   indicating name incomparability, for the case where neither\
    \ input\n   name is an MN.\n"
- title: '2.4.4:  GSS_Display_name call'
  contents:
  - "2.4.4:  GSS_Display_name call\n   Inputs:\n   o  name INTERNAL NAME\n   Outputs:\n\
    \   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o  name_string OCTET\
    \ STRING,\n   o  name_type OBJECT IDENTIFIER\n   Return major_status codes:\n\
    \   o  GSS_S_COMPLETE indicates that a valid printable name\n      representation\
    \ is available in the returned name_string.\n   o  GSS_S_BAD_NAMETYPE indicates\
    \ that the provided name was of a\n      type uninterpretable by the applicable\
    \ underlying GSS-API\n      mechanism(s), so no printable representation could\
    \ be generated.\n   o  GSS_S_BAD_NAME indicates that the contents of the provided\
    \ name\n      were inconsistent with the internally-indicated name type, so\n\
    \      no printable representation could be generated.\n   o  GSS_S_FAILURE indicates\
    \ that the requested operation could not\n      be performed for reasons unspecified\
    \ at the GSS-API level.\n   Allows callers to translate an internal name representation\
    \ into a\n   printable form with associated namespace type descriptor. The syntax\n\
    \   of the printable form is a local matter.\n   If the input name represents\
    \ an anonymous identity, a reserved value\n   (GSS_C_NT_ANONYMOUS) shall be returned\
    \ for name_type.\n"
- title: '2.4.5:  GSS_Import_name call'
  contents:
  - "2.4.5:  GSS_Import_name call\n   Inputs:\n   o  input_name_string OCTET STRING,\n\
    \   o  input_name_type OBJECT IDENTIFIER\n   Outputs:\n   o  major_status INTEGER,\n\
    \   o  minor_status INTEGER,\n   o  output_name INTERNAL NAME\n   Return major_status\
    \ codes:\n   o  GSS_S_COMPLETE indicates that a valid name representation is\n\
    \      output in output_name and described by the type value in\n      output_name_type.\n\
    \   o  GSS_S_BAD_NAMETYPE indicates that the input_name_type is unsupported\n\
    \      by the applicable underlying GSS-API mechanism(s), so the import\n    \
    \  operation could not be completed.\n   o  GSS_S_BAD_NAME indicates that the\
    \ provided input_name_string\n      is ill-formed in terms of the input_name_type,\
    \ so the import\n      operation could not be completed.\n   o  GSS_S_FAILURE\
    \ indicates that the requested operation could not\n      be performed for reasons\
    \ unspecified at the GSS-API level.\n   Allows callers to provide a name representation\
    \ as a contiguous octet\n   string, designate the type of namespace in conjunction\
    \ with which it\n   should be parsed, and convert that representation to an internal\
    \ form\n   suitable for input to other GSS-API routines.  The syntax of the\n\
    \   input_name_string is defined in conjunction with its associated name\n   type;\
    \ depending on the input_name_type, the associated\n   input_name_string may or\
    \ may not be a printable string. Note: The\n   input_name_type argument serves\
    \ to describe and qualify the\n   interpretation of the associated input_name_string;\
    \ it does not\n   specify the data type of the returned output_name.\n   If a\
    \ mechanism claims support for a particular name type, its\n   GSS_Import_name()\
    \ operation shall be able to accept all possible\n   values conformant to the\
    \ external name syntax as defined for that\n   name type.  These imported values\
    \ may correspond to:\n      (1) locally registered entities (for which credentials\
    \ may be\n      acquired),\n      (2) non-local entities (for which local credentials\
    \ cannot be\n      acquired, but which may be referenced as targets of initiated\n\
    \      security contexts or initiators of accepted security contexts), or\n  \
    \    to\n      (3) neither of the above.\n   Determination of whether a particular\
    \ name belongs to class (1), (2),\n   or (3) as described above is not guaranteed\
    \ to be performed by the\n   GSS_Import_name() function.\n   The internal name\
    \ generated by a GSS_Import_name() operation may be a\n   single-mechanism MN,\
    \ and is likely to be an MN within a single-\n   mechanism implementation, but\
    \ portable callers must not depend on\n   this property (and must not, therefore,\
    \ assume that the output from\n   GSS_Import_name() can be passed directly to\
    \ GSS_Export_name() without\n   first being processed through GSS_Canonicalize_name()).\n"
- title: '2.4.6: GSS_Release_name call'
  contents:
  - "2.4.6: GSS_Release_name call\n   Inputs:\n   o  name INTERNAL NAME\n   Outputs:\n\
    \   o  major_status INTEGER,\n   o  minor_status INTEGER\n   Return major_status\
    \ codes:\n   o  GSS_S_COMPLETE indicates that the storage associated with the\n\
    \      input name was successfully released.\n   o  GSS_S_BAD_NAME indicates that\
    \ the input name argument did not\n      contain a valid name.\n   o  GSS_S_FAILURE\
    \ indicates that the requested operation could not\n      be performed for reasons\
    \ unspecified at the GSS-API level.\n   Allows callers to release the storage\
    \ associated with an internal\n   name representation.  This call's specific behavior\
    \ depends on the\n   language and programming environment within which a GSS-API\n\
    \   implementation operates, and is therefore detailed within applicable\n   bindings\
    \ specifications; in particular, this call may be superfluous\n   within bindings\
    \ where memory management is automatic.\n"
- title: '2.4.7: GSS_Release_buffer call'
  contents:
  - "2.4.7: GSS_Release_buffer call\n   Inputs:\n   o  buffer OCTET STRING\n   Outputs:\n\
    \   o  major_status INTEGER,\n   o  minor_status INTEGER\n   Return major_status\
    \ codes:\n   o  GSS_S_COMPLETE indicates that the storage associated with the\n\
    \      input buffer was successfully released.\n   o  GSS_S_FAILURE indicates\
    \ that the requested operation could not\n      be performed for reasons unspecified\
    \ at the GSS-API level.\n   Allows callers to release the storage associated with\
    \ an OCTET STRING\n   buffer allocated by another GSS-API call.  This call's specific\n\
    \   behavior depends on the language and programming environment within\n   which\
    \ a GSS-API implementation operates, and is therefore detailed\n   within applicable\
    \ bindings specifications; in particular, this call\n   may be superfluous within\
    \ bindings where memory management is\n   automatic.\n"
- title: '2.4.8: GSS_Release_OID_set call'
  contents:
  - "2.4.8: GSS_Release_OID_set call\n   Inputs:\n   o  buffer SET OF OBJECT IDENTIFIER\n\
    \   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER\n   Return\
    \ major_status codes:\n   o  GSS_S_COMPLETE indicates that the storage associated\
    \ with the\n      input object identifier set was successfully released.\n   o\
    \  GSS_S_FAILURE indicates that the requested operation could not\n      be performed\
    \ for reasons unspecified at the GSS-API level.\n   Allows callers to release\
    \ the storage associated with an object\n   identifier set object allocated by\
    \ another GSS-API call.  This call's\n   specific behavior depends on the language\
    \ and programming environment\n   within which a GSS-API implementation operates,\
    \ and is therefore\n   detailed within applicable bindings specifications; in\
    \ particular,\n   this call may be superfluous within bindings where memory management\n\
    \   is automatic.\n"
- title: '2.4.9: GSS_Create_empty_OID_set call'
  contents:
  - "2.4.9: GSS_Create_empty_OID_set call\n   Inputs:\n   o  (none)\n   Outputs:\n\
    \   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o  oid_set SET OF\
    \ OBJECT IDENTIFIER\n   Return major_status codes:\n   o  GSS_S_COMPLETE indicates\
    \ successful completion\n   o  GSS_S_FAILURE indicates that the operation failed\n\
    \   Creates an object identifier set containing no object identifiers, to\n  \
    \ which members may be subsequently added using the\n   GSS_Add_OID_set_member()\
    \ routine.  These routines are intended to be\n   used to construct sets of mechanism\
    \ object identifiers, for input to\n   GSS_Acquire_cred().\n"
- title: '2.4.10: GSS_Add_OID_set_member call'
  contents:
  - "2.4.10: GSS_Add_OID_set_member call\n   Inputs:\n   o  member_oid OBJECT IDENTIFIER,\n\
    \   o  oid_set SET OF OBJECT IDENTIFIER\n   Outputs:\n   o  major_status INTEGER,\n\
    \   o  minor_status INTEGER,\n   Return major_status codes:\n   o  GSS_S_COMPLETE\
    \ indicates successful completion\n   o  GSS_S_FAILURE indicates that the operation\
    \ failed\n   Adds an Object Identifier to an Object Identifier set.  This routine\n\
    \   is intended for use in conjunction with GSS_Create_empty_OID_set()\n   when\
    \ constructing a set of mechanism OIDs for input to\n   GSS_Acquire_cred().\n"
- title: '2.4.11: GSS_Test_OID_set_member call'
  contents:
  - "2.4.11: GSS_Test_OID_set_member call\n   Inputs:\n   o  member OBJECT IDENTIFIER,\n\
    \   o  set SET OF OBJECT IDENTIFIER\n   Outputs:\n   o  major_status INTEGER,\n\
    \   o  minor_status INTEGER,\n   o  present BOOLEAN\n   Return major_status codes:\n\
    \   o  GSS_S_COMPLETE indicates successful completion\n   o  GSS_S_FAILURE indicates\
    \ that the operation failed\n   Interrogates an Object Identifier set to determine\
    \ whether a\n   specified Object Identifier is a member.  This routine is intended\
    \ to\n   be used with OID sets returned by GSS_Indicate_mechs(),\n   GSS_Acquire_cred(),\
    \ and GSS_Inquire_cred().\n"
- title: '2.4.12: GSS_Release_OID call'
  contents:
  - "2.4.12: GSS_Release_OID call\n   Inputs:\n   o  oid OBJECT IDENTIFIER\n   Outputs:\n\
    \   o  major_status INTEGER,\n   o  minor_status INTEGER\n   Return major_status\
    \ codes:\n   o  GSS_S_COMPLETE indicates successful completion\n   o  GSS_S_FAILURE\
    \ indicates that the operation failed\n   Allows the caller to release the storage\
    \ associated with an OBJECT\n   IDENTIFIER buffer allocated by another GSS-API\
    \ call. This call's\n   specific behavior depends on the language and programming\
    \ environment\n   within which a GSS-API implementation operates, and is therefore\n\
    \   detailed within applicable bindings specifications; in particular,\n   this\
    \ call may be superfluous within bindings where memory management\n   is automatic.\n"
- title: '2.4.13: GSS_OID_to_str call'
  contents:
  - "2.4.13: GSS_OID_to_str call\n   Inputs:\n   o  oid OBJECT IDENTIFIER\n   Outputs:\n\
    \   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o  oid_str OCTET\
    \ STRING\n   Return major_status codes:\n   o  GSS_S_COMPLETE indicates successful\
    \ completion\n   o  GSS_S_FAILURE indicates that the operation failed\n   The\
    \ function GSS_OID_to_str() returns a string representing the input\n   OID in\
    \ numeric ASN.1 syntax format (curly-brace enclosed, space-\n   delimited, e.g.,\
    \ \"{2 16 840 1 113687 1 2 1}\"). The string is\n   releasable using GSS_Release_buffer().\
    \ If the input \"oid\" does not\n   represent a syntactically valid object identifier,\
    \ GSS_S_FAILURE\n   status is returned and the returned oid_str result is NULL.\n"
- title: '2.4.14: GSS_Str_to_OID call'
  contents:
  - "2.4.14: GSS_Str_to_OID call\n   Inputs:\n   o  oid_str OCTET STRING\n   Outputs:\n\
    \   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o  oid OBJECT IDENTIFIER\n\
    \   Return major_status codes:\n   o  GSS_S_COMPLETE indicates successful completion\n\
    \   o  GSS_S_FAILURE indicates that the operation failed\n   The function GSS_Str_to_OID()\
    \ constructs and returns an OID from its\n   printable form; implementations should\
    \ be able to accept the numeric\n   ASN.1 syntax form as described for GSS_OID_to_str(),\
    \ and this form\n   should be used for portability, but implementations of this\
    \ routine\n   may also accept other formats (e.g., \"1.2.3.3\"). The OID is suitable\n\
    \   for release using the function GSS_Release_OID(). If the input\n   oid_str\
    \ cannot be translated into an OID, GSS_S_FAILURE status is\n   returned and the\
    \ \"oid\" result is NULL.\n"
- title: '2.4.15:  GSS_Inquire_names_for_mech call'
  contents:
  - "2.4.15:  GSS_Inquire_names_for_mech call\n   Input:\n   o  input_mech_type OBJECT\
    \ IDENTIFIER, -- mechanism type\n   Outputs:\n   o  major_status INTEGER,\n  \
    \ o  minor_status INTEGER,\n   o  name_type_set SET OF OBJECT IDENTIFIER\n   Return\
    \ major_status codes:\n   o  GSS_S_COMPLETE indicates that the output name_type_set\
    \ contains\n      a list of name types which are supported by the locally available\n\
    \      mechanism identified by input_mech_type.\n   o  GSS_S_BAD_MECH indicates\
    \ that the mechanism identified by\n      input_mech_type was unsupported within\
    \ the local implementation,\n      causing the query to fail.\n   o  GSS_S_FAILURE\
    \ indicates that the requested operation could not\n      be performed for reasons\
    \ unspecified at the GSS-API level.\n   Allows callers to determine the set of\
    \ name types which are\n   supportable by a specific locally-available mechanism.\n"
- title: '2.4.16: GSS_Inquire_mechs_for_name call'
  contents:
  - "2.4.16: GSS_Inquire_mechs_for_name call\n   Inputs:\n   o  input_name INTERNAL\
    \ NAME,\n   Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n\
    \   o  mech_types SET OF OBJECT IDENTIFIER\n   Return major_status codes:\n  \
    \ o  GSS_S_COMPLETE indicates that a set of object identifiers,\n      corresponding\
    \ to the set of mechanisms suitable for processing\n      the input_name, is available\
    \ in mech_types.\n   o  GSS_S_BAD_NAME indicates that the input_name could not\
    \ be\n      processed.\n   o  GSS_S_BAD_NAMETYPE indicates that the type of the\
    \ input_name\n      is unsupported by the GSS-API implementation.\n   o  GSS_S_FAILURE\
    \ indicates that the requested operation could not\n      be performed for reasons\
    \ unspecified at the GSS-API level.\n   This routine returns the mechanism set\
    \ with which the input_name may\n   be processed.  After use, the mech_types object\
    \ should be freed by\n   the caller via the GSS_Release_OID_set() call.  Note:\
    \ it is\n   anticipated that implementations of GSS_Inquire_mechs_for_name() will\n\
    \   commonly operate based on type information describing the\n   capabilities\
    \ of available mechanisms; it is not guaranteed that all\n   identified mechanisms\
    \ will necessarily be able to canonicalize (via\n   GSS_Canonicalize_name()) a\
    \ particular name.\n"
- title: '2.4.17: GSS_Canonicalize_name call'
  contents:
  - "2.4.17: GSS_Canonicalize_name call\n   Inputs:\n   o  input_name INTERNAL NAME,\n\
    \   o  mech_type OBJECT IDENTIFIER  -- must be explicit mechanism,\n         \
    \                             not \"default\" specifier\n   Outputs:\n   o  major_status\
    \ INTEGER,\n   o  minor_status INTEGER,\n   o  output_name INTERNAL NAME\n   Return\
    \ major_status codes:\n   o  GSS_S_COMPLETE indicates that a mechanism-specific\
    \ reduction of\n      the input_name, as processed by the mechanism identified\
    \ by\n      mech_type, is available in output_name.\n   o  GSS_S_BAD_MECH indicates\
    \ that the identified mechanism is\n      unsupported.\n   o  GSS_S_BAD_NAMETYPE\
    \ indicates that the input name does not\n      contain an element with suitable\
    \ type for processing by the\n      identified mechanism.\n   o  GSS_S_BAD_NAME\
    \ indicates that the input name contains an\n      element with suitable type\
    \ for processing by the identified\n      mechanism, but that this element could\
    \ not be processed\n      successfully.\n   o  GSS_S_FAILURE indicates that the\
    \ requested operation could not\n      be performed for reasons unspecified at\
    \ the GSS-API level.\n   This routine reduces a GSS-API internal name, which may\
    \ in general\n   contain elements corresponding to multiple mechanisms, to a\n\
    \   mechanism-specific Mechanism Name (MN) by applying the translations\n   corresponding\
    \ to the mechanism identified by mech_type.\n"
- title: '2.4.18: GSS_Export_name call'
  contents:
  - "2.4.18: GSS_Export_name call\n   Inputs:\n   o  input_name INTERNAL NAME, --\
    \ required to be MN\n   Outputs:\n   o  major_status INTEGER,\n   o  minor_status\
    \ INTEGER,\n   o  output_name OCTET STRING\n   Return major_status codes:\n  \
    \ o  GSS_S_COMPLETE indicates that a flat representation of the\n      input name\
    \ is available in output_name.\n   o  GSS_S_NAME_NOT_MN indicates that the input\
    \ name contained\n      elements corresponding to multiple mechanisms, so cannot\n\
    \      be exported into a single-mechanism flat form.\n   o  GSS_S_BAD_NAME indicates\
    \ that the input name was an MN,\n      but could not be processed.\n   o  GSS_S_BAD_NAMETYPE\
    \ indicates that the input name was an MN,\n      but that its type is unsupported\
    \ by the GSS-API implementation.\n   o  GSS_S_FAILURE indicates that the requested\
    \ operation could not\n      be performed for reasons unspecified at the GSS-API\
    \ level.\n   This routine creates a flat name representation, suitable for\n \
    \  bytewise comparison or for input to GSS_Import_name() in conjunction\n   with\
    \ the reserved GSS-API Exported Name Object OID, from a internal-\n   form Mechanism\
    \ Name (MN) as emitted, e.g., by GSS_Canonicalize_name()\n   or GSS_Accept_sec_context().\n\
    \   The emitted GSS-API Exported Name Object is self-describing; no\n   associated\
    \ parameter-level OID need be emitted by this call.  This\n   flat representation\
    \ consists of a mechanism-independent wrapper\n   layer, defined in Section 3.2\
    \ of this document, enclosing a\n   mechanism-defined name representation.\n \
    \  In all cases, the flat name output by GSS_Export_name() to correspond\n   to\
    \ a particular input MN must be invariant over time within a\n   particular installation.\n\
    \   The GSS_S_NAME_NOT_MN status code is provided to enable\n   implementations\
    \ to reject input names which are not MNs.  It is not,\n   however, required for\
    \ purposes of conformance to this specification\n   that all non-MN input names\
    \ must necessarily be rejected.\n"
- title: '2.4.19: GSS_Duplicate_name call'
  contents:
  - "2.4.19: GSS_Duplicate_name call\n   Inputs:\n   o  src_name INTERNAL NAME\n \
    \  Outputs:\n   o  major_status INTEGER,\n   o  minor_status INTEGER,\n   o  dest_name\
    \ INTERNAL NAME\n   Return major_status codes:\n   o  GSS_S_COMPLETE indicates\
    \ that dest_name references an internal\n      name object containing the same\
    \ name as passed to src_name.\n   o  GSS_S_BAD_NAME indicates that the input name\
    \ was invalid.\n   o  GSS_S_BAD_NAMETYPE indicates that the input name's type\n\
    \      is unsupported by the GSS-API implementation.\n   o  GSS_S_FAILURE indicates\
    \ that the requested operation could not\n      be performed for reasons unspecified\
    \ at the GSS-API level.\n   This routine takes input internal name src_name, and\
    \ returns another\n   reference (dest_name) to that name which can be used even\
    \ if src_name\n   is later freed.  (Note: This may be implemented by copying or\
    \ through\n   use of reference counts.)\n"
- title: '3: Data Structure Definitions for GSS-V2 Usage'
  contents:
  - "3: Data Structure Definitions for GSS-V2 Usage\n   Subsections of this section\
    \ define, for interoperability and\n   portability purposes, certain data structures\
    \ for use with GSS-V2.\n"
- title: '3.1: Mechanism-Independent Token Format'
  contents:
  - "3.1: Mechanism-Independent Token Format\n   This section specifies a mechanism-independent\
    \ level of encapsulating\n   representation for the initial token of a GSS-API\
    \ context\n   establishment sequence, incorporating an identifier of the mechanism\n\
    \   type to be used on that context and enabling tokens to be interpreted\n  \
    \ unambiguously at GSS-API peers. Use of this format is required for\n   initial\
    \ context establishment tokens of Internet standards-track\n   GSS-API mechanisms;\
    \ use in non-initial tokens is optional.\n   The encoding format for the token\
    \ tag is derived from ASN.1 and DER\n   (per illustrative ASN.1 syntax included\
    \ later within this\n   subsection), but its concrete representation is defined\
    \ directly in\n   terms of octets rather than at the ASN.1 level in order to facilitate\n\
    \   interoperable implementation without use of general ASN.1 processing\n   code.\
    \  The token tag consists of the following elements, in order:\n      1. 0x60\
    \ -- Tag for [APPLICATION 0] SEQUENCE; indicates that\n      constructed form,\
    \ definite length encoding follows.\n      2. Token length octets, specifying\
    \ length of subsequent data\n      (i.e., the summed lengths of elements 3-5 in\
    \ this list, and of the\n      mechanism-defined token object following the tag).\
    \  This element\n      comprises a variable number of octets:\n      2a. If the\
    \ indicated value is less than 128, it shall be\n      represented in a single\
    \ octet with bit 8 (high order) set to \"0\"\n      and the remaining bits representing\
    \ the value.\n      2b. If the indicated value is 128 or more, it shall be represented\n\
    \      in two or more octets, with bit 8 of the first octet set to \"1\"\n   \
    \   and the remaining bits of the first octet specifying the number of\n     \
    \ additional octets.  The subsequent octets carry the value, 8 bits\n      per\
    \ octet, most significant digit first.  The minimum number of\n      octets shall\
    \ be used to encode the length (i.e., no octets\n      representing leading zeros\
    \ shall be included within the length\n      encoding).\n      3. 0x06 -- Tag\
    \ for OBJECT IDENTIFIER\n      4. Object identifier length -- length (number of\
    \ octets) of the\n      encoded object identifier contained in element 5, encoded\
    \ per\n      rules as described in 2a. and 2b. above.\n      5. Object identifier\
    \ octets -- variable number of octets, encoded\n      per ASN.1 BER rules:\n \
    \     5a. The first octet contains the sum of two values: (1) the top-\n     \
    \ level object identifier component, multiplied by 40 (decimal), and\n      (2)\
    \ the second-level object identifier component.  This special\n      case is the\
    \ only point within an object identifier encoding where\n      a single octet\
    \ represents contents of more than one component.\n      5b. Subsequent octets,\
    \ if required, encode successively-lower\n      components in the represented\
    \ object identifier.  A component's\n      encoding may span multiple octets,\
    \ encoding 7 bits per octet (most\n      significant bits first) and with bit\
    \ 8 set to \"1\" on all but the\n      final octet in the component's encoding.\
    \  The minimum number of\n      octets shall be used to encode each component\
    \ (i.e., no octets\n      representing leading zeros shall be included within\
    \ a component's\n      encoding).\n      (Note: In many implementations, elements\
    \ 3-5 may be stored and\n      referenced as a contiguous string constant.)\n\
    \   The token tag is immediately followed by a mechanism-defined token\n   object.\
    \  Note that no independent size specifier intervenes following\n   the object\
    \ identifier value to indicate the size of the mechanism-\n   defined token object.\
    \  While ASN.1 usage within mechanism-defined\n   tokens is permitted, there is\
    \ no requirement that the mechanism-\n   specific innerContextToken, innerMsgToken,\
    \ and sealedUserData data\n   elements must employ ASN.1 BER/DER encoding conventions.\n\
    \   The following ASN.1 syntax is included for descriptive purposes only,\n  \
    \ to illustrate structural relationships among token and tag objects.\n   For\
    \ interoperability purposes, token and tag encoding shall be\n   performed using\
    \ the concrete encoding procedures described earlier in\n   this subsection.\n\
    \       GSS-API DEFINITIONS ::=\n       BEGIN\n       MechType ::= OBJECT IDENTIFIER\n\
    \       -- data structure definitions\n       -- callers must be able to distinguish\
    \ among\n       -- InitialContextToken, SubsequentContextToken,\n       -- PerMsgToken,\
    \ and SealedMessage data elements\n       -- based on the usage in which they\
    \ occur\n       InitialContextToken ::=\n       -- option indication (delegation,\
    \ etc.) indicated within\n       -- mechanism-specific token\n       [APPLICATION\
    \ 0] IMPLICIT SEQUENCE {\n               thisMech MechType,\n               innerContextToken\
    \ ANY DEFINED BY thisMech\n                  -- contents mechanism-specific\n\
    \                  -- ASN.1 structure not required\n               }\n       SubsequentContextToken\
    \ ::= innerContextToken ANY\n       -- interpretation based on predecessor InitialContextToken\n\
    \       -- ASN.1 structure not required\n       PerMsgToken ::=\n       -- as\
    \ emitted by GSS_GetMIC and processed by GSS_VerifyMIC\n       -- ASN.1 structure\
    \ not required\n               innerMsgToken ANY\n       SealedMessage ::=\n \
    \      -- as emitted by GSS_Wrap and processed by GSS_Unwrap\n       -- includes\
    \ internal, mechanism-defined indicator\n       -- of whether or not encrypted\n\
    \       -- ASN.1 structure not required\n               sealedUserData ANY\n \
    \      END\n"
- title: '3.2: Mechanism-Independent Exported Name Object Format'
  contents:
  - "3.2: Mechanism-Independent Exported Name Object Format\n   This section specifies\
    \ a mechanism-independent level of encapsulating\n   representation for names\
    \ exported via the GSS_Export_name() call,\n   including an object identifier\
    \ representing the exporting mechanism.\n   The format of names encapsulated via\
    \ this representation shall be\n   defined within individual mechanism drafts.\
    \  Name objects of this\n   type will be identified with the following Object\
    \ Identifier:\n   {1(iso), 3(org), 6(dod), 1(internet), 5(security), 6(nametypes),\n\
    \   4(gss-api-exported-name)}\n   No name type OID is included in this mechanism-independent\
    \ level of\n   format definition, since (depending on individual mechanism\n \
    \  specifications) the enclosed name may be implicitly typed or may be\n   explicitly\
    \ typed using a means other than OID encoding.\n        Length    Name       \
    \   Description\n        2               TOK_ID          Token Identifier\n  \
    \                                      For exported name objects, this\n     \
    \                                   must be hex 04 01.\n        2            \
    \   MECH_OID_LEN    Length of the Mechanism OID\n        MECH_OID_LEN    MECH_OID\
    \        Mechanism OID, in DER\n        4               NAME_LEN        Length\
    \ of name\n        NAME_LEN        NAME            Exported name; format defined\
    \ in\n                                        applicable mechanism draft.\n"
- title: '4: Name Type Definitions'
  contents:
  - "4: Name Type Definitions\n   This section includes definitions for name types\
    \ and associated\n   syntaxes which are defined in a mechanism-independent fashion\
    \ at the\n   GSS-API level rather than being defined in individual mechanism\n\
    \   specifications.\n"
- title: '4.1: Host-Based Service Name Form'
  contents:
  - "4.1: Host-Based Service Name Form\n   The following Object Identifier value is\
    \ provided as a means to\n   identify this name form:\n   {1(iso), 3(org), 6(dod),\
    \ 1(internet), 5(security), 6(nametypes),\n   2(gss-host-based-services)}\n  \
    \ The recommended symbolic name for this type is\n   \"GSS_C_NT_HOSTBASED_SERVICE\"\
    .\n   This name type is used to represent services associated with host\n   computers.\
    \  This name form is constructed using two elements,\n   \"service\" and \"hostname\"\
    , as follows:\n                             service@hostname\n   When a reference\
    \ to a name of this type is resolved, the \"hostname\"\n   is canonicalized by\
    \ attempting a DNS lookup and using the fully-\n   qualified domain name which\
    \ is returned, or by using the \"hostname\"\n   as provided if the DNS lookup\
    \ fails.  The canonicalization operation\n   also maps the host's name into lower-case\
    \ characters.\n   The \"hostname\" element may be omitted. If no \"@\" separator\
    \ is\n   included, the entire name is interpreted as the service specifier,\n\
    \   with the \"hostname\" defaulted to the canonicalized name of the local\n \
    \  host.\n   Values for the \"service\" element are registered with the IANA.\n"
- title: '4.2: User Name Form'
  contents:
  - "4.2: User Name Form\n   This name form shall be represented by the Object Identifier\
    \ {iso(1)\n   member-body(2) United States(840) mit(113554) infosys(1) gssapi(2)\n\
    \   generic(1) user_name(1)}. The recommended mechanism-independent\n   symbolic\
    \ name for this type is \"GSS_C_NT_USER_NAME\". (Note: the same\n   name form\
    \ and OID is defined within the Kerberos V5 GSS-API\n   mechanism, but the symbolic\
    \ name recommended there begins with a\n   \"GSS_KRB5_NT_\" prefix.)\n   This\
    \ name type is used to indicate a named user on a local system.\n   Its interpretation\
    \ is OS-specific.  This name form is constructed as:\n                       \
    \          username\n"
- title: '4.3: Machine UID Form'
  contents:
  - "4.3: Machine UID Form\n   This name form shall be represented by the Object Identifier\
    \ {iso(1)\n   member-body(2) United States(840) mit(113554) infosys(1) gssapi(2)\n\
    \   generic(1) machine_uid_name(2)}.  The recommended mechanism-\n   independent\
    \ symbolic name for this type is\n   \"GSS_C_NT_MACHINE_UID_NAME\".  (Note: the\
    \ same name form and OID is\n   defined within the Kerberos V5 GSS-API mechanism,\
    \ but the symbolic\n   name recommended there begins with a \"GSS_KRB5_NT_\" prefix.)\n\
    \   This name type is used to indicate a numeric user identifier\n   corresponding\
    \ to a user on a local system.  Its interpretation is\n   OS-specific.  The gss_buffer_desc\
    \ representing a name of this type\n   should contain a locally-significant uid_t,\
    \ represented in host byte\n   order.  The GSS_Import_name() operation resolves\
    \ this uid into a\n   username, which is then treated as the User Name Form.\n"
- title: '4.4: String UID Form'
  contents:
  - "4.4: String UID Form\n   This name form shall be represented by the Object Identifier\
    \ {iso(1)\n   member-body(2) United States(840) mit(113554) infosys(1) gssapi(2)\n\
    \   generic(1) string_uid_name(3)}.  The recommended symbolic name for\n   this\
    \ type is \"GSS_C_NT_STRING_UID_NAME\".  (Note: the same name form\n   and OID\
    \ is defined within the Kerberos V5 GSS-API mechanism, but the\n   symbolic name\
    \ recommended there begins with a \"GSS_KRB5_NT_\" prefix.)\n   This name type\
    \ is used to indicate a string of digits representing\n   the numeric user identifier\
    \ of a user on a local system.  Its\n   interpretation is OS-specific. This name\
    \ type is similar to the\n   Machine UID Form, except that the buffer contains\
    \ a string\n   representing the uid_t.\n"
- title: '5:  Mechanism-Specific Example Scenarios'
  contents:
  - "5:  Mechanism-Specific Example Scenarios\n   This section provides illustrative\
    \ overviews of the use of various\n   candidate mechanism types to support the\
    \ GSS-API. These discussions\n   are intended primarily for readers familiar with\
    \ specific security\n   technologies, demonstrating how GSS-API functions can\
    \ be used and\n   implemented by candidate underlying mechanisms. They should\
    \ not be\n   regarded as constrictive to implementations or as defining the only\n\
    \   means through which GSS-API functions can be realized with a\n   particular\
    \ underlying technology, and do not demonstrate all GSS-API\n   features with\
    \ each technology.\n"
- title: '5.1: Kerberos V5, single-TGT'
  contents:
  - "5.1: Kerberos V5, single-TGT\n   OS-specific login functions yield a TGT to the\
    \ local realm Kerberos\n   server; TGT is placed in a credentials structure for\
    \ the client.\n   Client calls GSS_Acquire_cred()  to acquire a cred_handle in\
    \ order to\n   reference the credentials for use in establishing security contexts.\n\
    \   Client calls GSS_Init_sec_context().  If the requested service is\n   located\
    \ in a different realm, GSS_Init_sec_context()  gets the\n   necessary TGT/key\
    \ pairs needed to traverse the path from local to\n   target realm; these data\
    \ are placed in the owner's TGT cache. After\n   any needed remote realm resolution,\
    \ GSS_Init_sec_context()  yields a\n   service ticket to the requested service\
    \ with a corresponding session\n   key; these data are stored in conjunction with\
    \ the context. GSS-API\n   code sends KRB_TGS_REQ request(s) and receives KRB_TGS_REP\n\
    \   response(s) (in the successful case) or KRB_ERROR.\n   Assuming success, GSS_Init_sec_context()\
    \  builds a Kerberos-formatted\n   KRB_AP_REQ message, and returns it in output_token.\
    \  The client sends\n   the output_token to the service.\n   The service passes\
    \ the received token as the input_token argument to\n   GSS_Accept_sec_context(),\
    \  which verifies the authenticator, provides\n   the service with the client's\
    \ authenticated name, and returns an\n   output_context_handle.\n   Both parties\
    \ now hold the session key associated with the service\n   ticket, and can use\
    \ this key in subsequent GSS_GetMIC(),\n   GSS_VerifyMIC(),  GSS_Wrap(), and GSS_Unwrap()\
    \ operations.\n"
- title: '5.2: Kerberos V5, double-TGT'
  contents:
  - "5.2: Kerberos V5, double-TGT\n   TGT acquisition as above.\n   Note: To avoid\
    \ unnecessary frequent invocations of error paths when\n   implementing the GSS-API\
    \ atop Kerberos V5, it seems appropriate to\n   represent \"single-TGT K-V5\"\
    \ and \"double-TGT K-V5\" with separate\n   mech_types, and this discussion makes\
    \ that assumption.\n   Based on the (specified or defaulted) mech_type,\n   GSS_Init_sec_context()\
    \  determines that the double-TGT protocol\n   should be employed for the specified\
    \ target. GSS_Init_sec_context()\n   returns GSS_S_CONTINUE_NEEDED major_status,\
    \ and its returned\n   output_token contains a request to the service for the\
    \ service's TGT.\n   (If a service TGT with suitably long remaining lifetime already\n\
    \   exists in a cache, it may be usable, obviating the need for this\n   step.)\
    \ The client passes the output_token to the service.  Note: this\n   scenario\
    \ illustrates a different use for the GSS_S_CONTINUE_NEEDED\n   status return\
    \ facility than for support of mutual authentication;\n   note that both uses\
    \ can coexist as successive operations within a\n   single context establishment\
    \ operation.\n   The service passes the received token as the input_token argument\
    \ to\n   GSS_Accept_sec_context(),  which recognizes it as a request for TGT.\n\
    \   (Note that current Kerberos V5 defines no intra-protocol mechanism to\n  \
    \ represent such a request.) GSS_Accept_sec_context()  returns\n   GSS_S_CONTINUE_NEEDED\
    \ major_status and provides the service's TGT in\n   its output_token. The service\
    \ sends the output_token to the client.\n   The client passes the received token\
    \ as the input_token argument to a\n   continuation of GSS_Init_sec_context().\
    \ GSS_Init_sec_context() caches\n   the received service TGT and uses it as part\
    \ of a service ticket\n   request to the Kerberos authentication server, storing\
    \ the returned\n   service ticket and session key in conjunction with the context.\n\
    \   GSS_Init_sec_context()  builds a Kerberos-formatted authenticator,\n   and\
    \ returns it in output_token along with GSS_S_COMPLETE return\n   major_status.\
    \ The client sends the output_token to the service.\n   Service passes the received\
    \ token as the input_token argument to a\n   continuation call to GSS_Accept_sec_context().\n\
    \   GSS_Accept_sec_context()  verifies the authenticator, provides the\n   service\
    \ with the client's authenticated name, and returns\n   major_status GSS_S_COMPLETE.\n\
    \   GSS_GetMIC(),  GSS_VerifyMIC(), GSS_Wrap(), and GSS_Unwrap()  as\n   above.\n"
- title: '5.3:  X.509 Authentication Framework'
  contents:
  - "5.3:  X.509 Authentication Framework\n   This example illustrates use of the\
    \ GSS-API in conjunction with\n   public-key mechanisms, consistent with the X.509\
    \ Directory\n   Authentication Framework.\n   The GSS_Acquire_cred()  call establishes\
    \ a credentials structure,\n   making the client's private key accessible for\
    \ use on behalf of the\n   client.\n   The client calls GSS_Init_sec_context(),\
    \  which interrogates the\n   Directory to acquire (and validate) a chain of public-key\n\
    \   certificates, thereby collecting the public key of the service.  The\n   certificate\
    \ validation operation determines that suitable integrity\n   checks were applied\
    \ by trusted authorities and that those\n   certificates have not expired. GSS_Init_sec_context()\
    \  generates a\n   secret key for use in per-message protection operations on\
    \ the\n   context, and enciphers that secret key under the service's public\n\
    \   key.\n   The enciphered secret key, along with an authenticator quantity\n\
    \   signed with the client's private key, is included in the output_token\n  \
    \ from GSS_Init_sec_context().  The output_token also carries a\n   certification\
    \ path, consisting of a certificate chain leading from\n   the service to the\
    \ client; a variant approach would defer this path\n   resolution to be performed\
    \ by the service instead of being asserted\n   by the client. The client application\
    \ sends the output_token to the\n   service.\n   The service passes the received\
    \ token as the input_token argument to\n   GSS_Accept_sec_context().  GSS_Accept_sec_context()\
    \ validates the\n   certification path, and as a result determines a certified\
    \ binding\n   between the client's distinguished name and the client's public\
    \ key.\n   Given that public key, GSS_Accept_sec_context() can process the\n \
    \  input_token's authenticator quantity and verify that the client's\n   private\
    \ key was used to sign the input_token. At this point, the\n   client is authenticated\
    \ to the service. The service uses its private\n   key to decipher the enciphered\
    \ secret key provided to it for per-\n   message protection operations on the\
    \ context.\n   The client calls GSS_GetMIC()  or GSS_Wrap() on a data message,\
    \ which\n   causes per-message authentication, integrity, and (optional)\n   confidentiality\
    \ facilities to be applied to that message. The service\n   uses the context's\
    \ shared secret key to perform corresponding\n   GSS_VerifyMIC()  and GSS_Unwrap()\
    \ calls.\n"
- title: '6:  Security Considerations'
  contents:
  - "6:  Security Considerations\n   Security issues are discussed throughout this\
    \ memo.\n"
- title: '7:  Related Activities'
  contents:
  - "7:  Related Activities\n   In order to implement the GSS-API atop existing, emerging,\
    \ and future\n   security mechanisms:\n      object identifiers must be assigned\
    \ to candidate GSS-API\n      mechanisms and the name types which they support\n\
    \      concrete data element formats and processing procedures must be\n     \
    \ defined for candidate mechanisms\n   Calling applications must implement formatting\
    \ conventions which will\n   enable them to distinguish GSS-API tokens from other\
    \ data carried in\n   their application protocols.\n   Concrete language bindings\
    \ are required for the programming\n   environments in which the GSS-API is to\
    \ be employed, as RFC-1509\n   defines for the C programming language and GSS-V1.\n"
- title: APPENDIX A
  contents:
  - 'APPENDIX A

    '
- title: MECHANISM DESIGN CONSTRAINTS
  contents:
  - "MECHANISM DESIGN CONSTRAINTS\n   The following constraints on GSS-API mechanism\
    \ designs are adopted in\n   response to observed caller protocol requirements,\
    \ and adherence\n   thereto is anticipated in subsequent descriptions of GSS-API\n\
    \   mechanisms to be documented in standards-track Internet\n   specifications.\n\
    \   It is strongly recommended that mechanisms offering per-message\n   protection\
    \ services also offer at least one of the replay detection\n   and sequencing\
    \ services, as mechanisms offering neither of the latter\n   will fail to satisfy\
    \ recognized requirements of certain candidate\n   caller protocols.\n"
- title: APPENDIX B
  contents:
  - "APPENDIX B\n                         COMPATIBILITY WITH GSS-V1\n   It is the\
    \ intent of this document to define an interface and\n   procedures which preserve\
    \ compatibility between GSS-V1 (RFC-1508)\n   callers and GSS- V2 providers. \
    \ All calls defined in GSS-V1 are\n   preserved, and it has been a goal that GSS-V1\
    \ callers should be able\n   to operate atop GSS-V2 provider implementations.\
    \  Certain detailed\n   changes, summarized in this section, have been made in\
    \ order to\n   resolve omissions identified in GSS-V1.\n   The following GSS-V1\
    \ constructs, while supported within GSS-V2, are\n   deprecated:\n      Names\
    \ for per-message processing routines: GSS_Seal() deprecated\n      in favor of\
    \ GSS_Wrap(); GSS_Sign() deprecated in favor of\n      GSS_GetMIC(); GSS_Unseal()\
    \ deprecated in favor of GSS_Unwrap();\n      GSS_Verify() deprecated in favor\
    \ of GSS_VerifyMIC().\n      GSS_Delete_sec_context() facility for context_token\
    \ usage,\n      allowing mechanisms to signal context deletion, is retained for\n\
    \      compatibility with GSS-V1.  For current usage, it is recommended\n    \
    \  that both peers to a context invoke GSS_Delete_sec_context()\n      independently,\
    \ passing a null output_context_token buffer to\n      indicate that no context_token\
    \ is required.  Implementations of\n      GSS_Delete_sec_context() should delete\
    \ relevant locally-stored\n      context information.\n   This GSS-V2 specification\
    \ adds the following calls which are not\n   present in GSS-V1:\n      Credential\
    \ management calls: GSS_Add_cred(),\n      GSS_Inquire_cred_by_mech().\n     \
    \ Context-level calls: GSS_Inquire_context(), GSS_Wrap_size_limit(),\n      GSS_Export_sec_context(),\
    \ GSS_Import_sec_context().\n      Per-message calls: No new calls.  Existing\
    \ calls have been renamed.\n      Support calls: GSS_Create_empty_OID_set(),\n\
    \      GSS_Add_OID_set_member(), GSS_Test_OID_set_member(),\n      GSS_Release_OID(),\
    \ GSS_OID_to_str(), GSS_Str_to_OID(),\n      GSS_Inquire_names_for_mech(), GSS_Inquire_mechs_for_name(),\n\
    \      GSS_Canonicalize_name(), GSS_Export_name(), GSS_Duplicate_name().\n   This\
    \ GSS-V2 specification introduces three new facilities applicable\n   to security\
    \ contexts, indicated using the following context state\n   values which are not\
    \ present in GSS-V1:\n      anon_state, set TRUE to indicate that a context's\
    \ initiator is\n      anonymous from the viewpoint of the target; Section 1.2.5\
    \ of this\n      specification provides a summary description of the GSS-V2\n\
    \      anonymity support facility, support and use of which is optional.\n   \
    \   prot_ready_state, set TRUE to indicate that a context may be used\n      for\
    \ per-message protection before final completion of context\n      establishment;\
    \ Section 1.2.7 of this specification provides a\n      summary description of\
    \ the GSS-V2 facility enabling mechanisms to\n      selectively permit per-message\
    \ protection during context\n      establishment, support and use of which is\
    \ optional.\n      trans_state, set TRUE to indicate that a context is transferable\
    \ to\n      another process using the GSS-V2 GSS_Export_sec_context() facility.\n\
    \   These state values are represented (at the C bindings level) in\n   positions\
    \ within a bit vector which are unused in GSS-V1, and may be\n   safely ignored\
    \ by GSS-V1 callers.\n   Relative to GSS-V1, GSS-V2 provides additional guidance\
    \ to GSS-API\n   implementors in the following areas: implementation robustness,\n\
    \   credential management, behavior in multi-mechanism configurations,\n   naming\
    \ support, and inclusion of optional sequencing services.  The\n   token tagging\
    \ facility as defined in GSS-V2, Section 3.1, is now\n   described directly in\
    \ terms of octets to facilitate interoperable\n   implementation without general\
    \ ASN.1 processing code; the\n   corresponding ASN.1 syntax, included for descriptive\
    \ purposes, is\n   unchanged from that in GSS-V1. For use in conjunction with\
    \ added\n   naming support facilities, a new Exported Name Object construct is\n\
    \   added.  Additional name types are introduced in Section 4.\n   This GSS-V2\
    \ specification adds the following major_status values\n   which are not defined\
    \ in GSS-V1:\n     GSS_S_BAD_QOP                 unsupported QOP value\n     GSS_S_UNAUTHORIZED\
    \            operation unauthorized\n     GSS_S_UNAVAILABLE             operation\
    \ unavailable\n     GSS_S_DUPLICATE_ELEMENT       duplicate credential element\
    \ requested\n     GSS_S_NAME_NOT_MN             name contains multi-mechanism\
    \ elements\n     GSS_S_GAP_TOKEN               skipped predecessor token(s)\n\
    \                                    detected\n   Of these added status codes,\
    \ only two values are defined to be\n   returnable by calls existing in GSS-V1:\
    \ GSS_S_BAD_QOP (returnable by\n   GSS_GetMIC() and GSS_Wrap()), and GSS_S_GAP_TOKEN\
    \ (returnable by\n   GSS_VerifyMIC() and GSS_Unwrap()).\n   Additionally, GSS-V2\
    \ descriptions of certain calls present in GSS-V1\n   have been updated to allow\
    \ return of additional major_status values\n   from the set as defined in GSS-V1:\
    \ GSS_Inquire_cred() has\n   GSS_S_DEFECTIVE_CREDENTIAL and GSS_S_CREDENTIALS_EXPIRED\
    \ defined as\n   returnable, GSS_Init_sec_context() has GSS_S_OLD_TOKEN,\n   GSS_S_DUPLICATE_TOKEN,\
    \ and GSS_S_BAD_MECH defined as returnable, and\n   GSS_Accept_sec_context() has\
    \ GSS_S_BAD_MECH defined as returnable.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   John Linn\n   OpenVision Technologies\n   One Main St.\n\
    \   Cambridge, MA  02142  USA\n   Phone: +1 617.374.2245\n   EMail: John.Linn@ov.com\n"
