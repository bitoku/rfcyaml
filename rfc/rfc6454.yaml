- contents:
  - '                         The Web Origin Concept

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document defines the concept of an \"origin\", which is often
    used\n   as the scope of authority or privilege by user agents.  Typically,\n
    \  user agents isolate content retrieved from different origins to\n   prevent
    malicious web site operators from interfering with the\n   operation of benign
    web sites.  In addition to outlining the\n   principles that underlie the concept
    of origin, this document details\n   how to determine the origin of a URI and
    how to serialize an origin\n   into a string.  It also defines an HTTP header
    field, named \"Origin\",\n   that indicates which origins are associated with
    an HTTP request.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6454.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  3\n   2.  Conventions  . . . . . . . . . . . . . . . . . . . . .
    . . . .  3\n     2.1.  Conformance Criteria . . . . . . . . . . . . . . . . .
    . .  3\n     2.2.  Syntax Notation  . . . . . . . . . . . . . . . . . . . . .
    \ 4\n     2.3.  Terminology  . . . . . . . . . . . . . . . . . . . . . . .  4\n
    \  3.  Principles of the Same-Origin Policy . . . . . . . . . . . . .  4\n     3.1.
    \ Trust  . . . . . . . . . . . . . . . . . . . . . . . . . .  5\n       3.1.1.
    \ Pitfalls . . . . . . . . . . . . . . . . . . . . . . .  5\n     3.2.  Origin
    . . . . . . . . . . . . . . . . . . . . . . . . . .  6\n       3.2.1.  Examples
    . . . . . . . . . . . . . . . . . . . . . . .  7\n     3.3.  Authority  . . .
    . . . . . . . . . . . . . . . . . . . . .  7\n       3.3.1.  Pitfalls . . . .
    . . . . . . . . . . . . . . . . . . .  8\n     3.4.  Policy . . . . . . . . .
    . . . . . . . . . . . . . . . . .  8\n       3.4.1.  Object Access  . . . . .
    . . . . . . . . . . . . . . .  8\n       3.4.2.  Network Access . . . . . . .
    . . . . . . . . . . . . .  9\n       3.4.3.  Pitfalls . . . . . . . . . . . .
    . . . . . . . . . . .  9\n     3.5.  Conclusion . . . . . . . . . . . . . . .
    . . . . . . . . . 10\n   4.  Origin of a URI  . . . . . . . . . . . . . . . .
    . . . . . . . 10\n   5.  Comparing Origins  . . . . . . . . . . . . . . . . .
    . . . . . 11\n   6.  Serializing Origins  . . . . . . . . . . . . . . . . . .
    . . . 11\n     6.1.  Unicode Serialization of an Origin . . . . . . . . . . .
    . 12\n     6.2.  ASCII Serialization of an Origin . . . . . . . . . . . . . 12\n
    \  7.  The HTTP Origin Header Field . . . . . . . . . . . . . . . . . 13\n     7.1.
    \ Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n     7.2.  Semantics
    \ . . . . . . . . . . . . . . . . . . . . . . . . 13\n     7.3.  User Agent Requirements
    \ . . . . . . . . . . . . . . . . . 14\n   8.  Security Considerations  . . .
    . . . . . . . . . . . . . . . . 14\n     8.1.  Reliance on DNS  . . . . . . .
    . . . . . . . . . . . . . . 15\n     8.2.  Divergent Units of Isolation . . .
    . . . . . . . . . . . . 15\n     8.3.  Ambient Authority  . . . . . . . . . .
    . . . . . . . . . . 16\n     8.4.  IDNA Dependency and Migration  . . . . . .
    . . . . . . . . 16\n   9.  IANA Considerations  . . . . . . . . . . . . . . .
    . . . . . . 17\n   10. References . . . . . . . . . . . . . . . . . . . . . .
    . . . . 17\n     10.1. Normative References . . . . . . . . . . . . . . . . .
    . . 17\n     10.2. Informative References . . . . . . . . . . . . . . . . . .
    18\n   Appendix A.  Acknowledgements  . . . . . . . . . . . . . . . . . . 20\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   User agents interact with content created by a large number
    of\n   authors.  Although many of those authors are well-meaning, some\n   authors
    might be malicious.  To the extent that user agents undertake\n   actions based
    on content they process, user agent implementors might\n   wish to restrict the
    ability of malicious authors to disrupt the\n   confidentiality or integrity of
    other content or servers.\n   As an example, consider an HTTP user agent that
    renders HTML content\n   retrieved from various servers.  If the user agent executes
    scripts\n   contained in those documents, the user agent implementor might wish\n
    \  to prevent scripts retrieved from a malicious server from reading\n   documents
    stored on an honest server, which might, for example, be\n   behind a firewall.\n
    \  Traditionally, user agents have divided content according to its\n   \"origin\".
    \ More specifically, user agents allow content retrieved\n   from one origin to
    interact freely with other content retrieved from\n   that origin, but user agents
    restrict how that content can interact\n   with content from another origin.\n
    \  This document describes the principles behind the so-called same-\n   origin
    policy as well as the \"nuts and bolts\" of comparing and\n   serializing origins.
    \ This document does not describe all the facets\n   of the same-origin policy,
    the details of which are left to other\n   specifications, such as HTML [HTML]
    and WebSockets [RFC6455], because\n   the details are often application-specific.\n"
  title: 1.  Introduction
- contents:
  - '2.  Conventions

    '
  - contents:
    - "2.1.  Conformance Criteria\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
      and \"OPTIONAL\" in this\n   document are to be interpreted as described in
      [RFC2119].\n   Requirements phrased in the imperative as part of algorithms
      (such as\n   \"strip any leading space characters\" or \"return false and abort
      these\n   steps\") are to be interpreted with the meaning of the key word\n
      \  (\"MUST\", \"SHOULD\", \"MAY\", etc.) used in introducing the algorithm.\n
      \  Conformance requirements phrased as algorithms or specific steps can\n   be
      implemented in any manner, so long as the end result is\n   equivalent.  In
      particular, the algorithms defined in this\n   specification are intended to
      be easy to understand and are not\n   intended to be performant.\n"
    title: 2.1.  Conformance Criteria
  - contents:
    - "2.2.  Syntax Notation\n   This specification uses the Augmented Backus-Naur
      Form (ABNF)\n   notation of [RFC5234].\n   The following core rules are included
      by reference, as defined in\n   [RFC5234], Appendix B.1: ALPHA (letters), CR
      (carriage return), CRLF\n   (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE
      (double quote),\n   HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET
      (any 8-bit\n   sequence of data), SP (space), HTAB (horizontal tab), CHAR (any
      US-\n   ASCII character), VCHAR (any visible US-ASCII character), and WSP\n
      \  (whitespace).\n   The OWS rule is used where zero or more linear whitespace
      octets\n   might appear.  OWS SHOULD either not be produced or be produced as
      a\n   single SP.  Multiple OWS octets that occur within field-content\n   SHOULD
      either be replaced with a single SP or transformed to all SP\n   octets (each
      octet other than SP replaced with SP) before\n   interpreting the field value
      or forwarding the message downstream.\n   OWS            = *( SP / HTAB / obs-fold
      )\n                  ; \"optional\" whitespace\n   obs-fold       = CRLF ( SP
      / HTAB )\n                  ; obsolete line folding\n"
    title: 2.2.  Syntax Notation
  - contents:
    - "2.3.  Terminology\n   The terms \"user agent\", \"client\", \"server\", \"proxy\",
      and \"origin\n   server\" have the same meaning as in the HTTP/1.1 specification\n
      \  ([RFC2616], Section 1.3).\n   A globally unique identifier is a value that
      is different from all\n   other previously existing values.  For example, a
      sufficiently long\n   random string is likely to be a globally unique identifier.
      \ If the\n   origin value never leaves the user agent, a monotonically increasing\n
      \  counter local to the user agent can also serve as a globally unique\n   identifier.\n"
    title: 2.3.  Terminology
  title: 2.  Conventions
- contents:
  - "3.  Principles of the Same-Origin Policy\n   Many user agents undertake actions
    on behalf of remote parties.  For\n   example, HTTP user agents follow redirects,
    which are instructions\n   from remote servers, and HTML user agents expose rich
    Document Object\n   Model (DOM) interfaces to scripts retrieved from remote servers.\n
    \  Without any security model, user agents might undertake actions\n   detrimental
    to the user or to other parties.  Over time, many web-\n   related technologies
    have converged towards a common security model,\n   known colloquially as the
    \"same-origin policy\".  Although this\n   security model evolved largely organically,
    the same-origin policy\n   can be understood in terms of a handful of key concepts.
    \ This\n   section presents those concepts and provides advice about how to use\n
    \  these concepts securely.\n"
  - contents:
    - "3.1.  Trust\n   The same-origin policy specifies trust by URI.  For example,
      HTML\n   documents designate which script to run with a URI:\n   <script src=\"https://example.com/library.js\"></script>\n
      \  When a user agent processes this element, the user agent will fetch\n   the
      script at the designated URI and execute the script with the\n   privileges
      of the document.  In this way, the document grants all the\n   privileges it
      has to the resource designated by the URI.  In essence,\n   the document declares
      that it trusts the integrity of information\n   retrieved from that URI.\n   In
      addition to importing libraries from URIs, user agents also send\n   information
      to remote parties designated by URI.  For example,\n   consider the HTML form
      element:\n   <form method=\"POST\" action=\"https://example.com/login\">\n    ...
      <input type=\"password\"> ...\n   </form>\n   When the user enters his or her
      password and submits the form, the\n   user agent sends the password to the
      network endpoint designated by\n   the URI.  In this way, the document exports
      its secret data to that\n   URI, in essence declaring that it trusts the confidentiality
      of\n   information sent to that URI.\n"
    - contents:
      - "3.1.1.  Pitfalls\n   When designing new protocols that use the same-origin
        policy, make\n   sure that important trust distinctions are visible in URIs.
        \ For\n   example, if both Transport Layer Security (TLS) and non-TLS protected\n
        \  resources use the \"http\" URI scheme (as in [RFC2817]), a document\n   would
        be unable to specify that it wishes to retrieve a script only\n   over TLS.
        \ By using the \"https\" URI scheme, documents are able to\n   indicate that
        they wish to interact with resources that are protected\n   from active network
        attackers.\n"
      title: 3.1.1.  Pitfalls
    title: 3.1.  Trust
  - contents:
    - "3.2.  Origin\n   In principle, user agents could treat every URI as a separate\n
      \  protection domain and require explicit consent for content retrieved\n   from
      one URI to interact with another URI.  Unfortunately, this\n   design is cumbersome
      for developers because web applications often\n   consist of a number of resources
      acting in concert.\n   Instead, user agents group URIs together into protection
      domains\n   called \"origins\".  Roughly speaking, two URIs are part of the
      same\n   origin (i.e., represent the same principal) if they have the same\n
      \  scheme, host, and port.  (See Section 4 for full details.)\n   Q: Why not
      just use the host?\n   A: Including the scheme in the origin tuple is essential
      for\n   security.  If user agents did not include the scheme, there would be\n
      \  no isolation between http://example.com and https://example.com\n   because
      the two have the same host.  However, without this isolation,\n   an active
      network attacker could corrupt content retrieved from\n   http://example.com
      and have that content instruct the user agent to\n   compromise the confidentiality
      and integrity of content retrieved\n   from https://example.com, bypassing the
      protections afforded by TLS\n   [RFC5246].\n   Q: Why use the fully qualified
      host name instead of just the \"top-\n   level\" domain?\n   A: Although the
      DNS has hierarchical delegation, the trust\n   relationships between host names
      vary by deployment.  For example, at\n   many educational institutions, students
      can host content at\n   https://example.edu/~student/, but that does not mean
      a document\n   authored by a student should be part of the same origin (i.e.,\n
      \  inhabit the same protection domain) as a web application for managing\n   grades
      hosted at https://grades.example.edu/.\n   The example.edu deployment illustrates
      that grouping resources by\n   origin does not always align perfectly with every
      deployment\n   scenario.  In this deployment, every student's web site inhabits
      the\n   same origin, which might not be desirable.  In some sense, the origin\n
      \  granularity is a historical artifact of how the security model\n   evolved.\n"
    - contents:
      - "3.2.1.  Examples\n   All of the following resources have the same origin:\n
        \  http://example.com/\n   http://example.com:80/\n   http://example.com/path/file\n
        \  Each of the URIs has the same scheme, host, and port components.\n   Each
        of the following resources has a different origin from the\n   others.\n   http://example.com/\n
        \  http://example.com:8080/\n   http://www.example.com/\n   https://example.com:80/\n
        \  https://example.com/\n   http://example.org/\n   http://ietf.org/\n   In
        each case, at least one of the scheme, host, and port component\n   will differ
        from the others in the list.\n"
      title: 3.2.1.  Examples
    title: 3.2.  Origin
  - contents:
    - "3.3.  Authority\n   Although user agents group URIs into origins, not every
      resource in\n   an origin carries the same authority (in the security sense
      of the\n   word \"authority\", not in the [RFC3986] sense).  For example, an
      image\n   is passive content and, therefore, carries no authority, meaning the\n
      \  image has no access to the objects and resources available to its\n   origin.
      \ By contrast, an HTML document carries the full authority of\n   its origin,
      and scripts within (or imported into) the document can\n   access every resource
      in its origin.\n   User agents determine how much authority to grant a resource
      by\n   examining its media type.  For example, resources with a media type\n
      \  of image/png are treated as images, and resources with a media type\n   of
      text/html are treated as HTML documents.\n   When hosting untrusted content
      (such as user-generated content), web\n   applications can limit that content's
      authority by restricting its\n   media type.  For example, serving user-generated
      content as image/png\n   is less risky than serving user-generated content as
      text/html.  Of\n   course, many web applications incorporate untrusted content
      in their\n   HTML documents.  If not done carefully, these applications risk\n
      \  leaking their origin's authority to the untrusted content, a\n   vulnerability
      commonly known as cross-site scripting.\n"
    - contents:
      - "3.3.1.  Pitfalls\n   When designing new pieces of the web platform, be careful
        not to\n   grant authority to resources irrespective of media type.  Many
        web\n   applications serve untrusted content with restricted media types.
        \ A\n   new web platform feature that grants authority to these pieces of\n
        \  content risks introducing vulnerabilities into existing applications.\n
        \  Instead, prefer to grant authority to media types that already\n   possess
        the origin's full authority or to new media types designed\n   specifically
        to carry the new authority.\n   In order to remain compatible with servers
        that supply incorrect\n   media types, some user agents employ \"content sniffing\"
        and treat\n   content as if it had a different media type than the media type\n
        \  supplied by the server.  If not done carefully, content sniffing can\n
        \  lead to security vulnerabilities because user agents might grant low-\n
        \  authority media types, such as images, the privileges of high-\n   authority
        media types, such as HTML documents [SNIFF].\n"
      title: 3.3.1.  Pitfalls
    title: 3.3.  Authority
  - contents:
    - "3.4.  Policy\n   Generally speaking, user agents isolate different origins
      and permit\n   controlled communication between origins.  The details of how
      user\n   agents provide isolation and communication vary depending on several\n
      \  factors.\n"
    - contents:
      - "3.4.1.  Object Access\n   Most objects (also known as application programming
        interfaces or\n   APIs) exposed by the user agent are available only to the
        same\n   origin.  Specifically, content retrieved from one URI can access\n
        \  objects associated with content retrieved from another URI if, and\n   only
        if, the two URIs belong to the same origin, e.g., have the same\n   scheme,
        host, and port.\n   There are some exceptions to this general rule.  For example,
        some\n   parts of HTML's Location interface are available across origins\n
        \  (e.g., to allow for navigating other browsing contexts).  As another\n
        \  example, HTML's postMessage interface is visible across origins\n   explicitly
        to facilitate cross-origin communication.  Exposing\n   objects to foreign
        origins is dangerous and should be done only with\n   great care because doing
        so exposes these objects to potential\n   attackers.\n"
      title: 3.4.1.  Object Access
    - contents:
      - "3.4.2.  Network Access\n   Access to network resources varies depending on
        whether the resources\n   are in the same origin as the content attempting
        to access them.\n   Generally, reading information from another origin is
        forbidden.\n   However, an origin is permitted to use some kinds of resources\n
        \  retrieved from other origins.  For example, an origin is permitted to\n
        \  execute script, render images, and apply style sheets from any\n   origin.
        \ Likewise, an origin can display content from another origin,\n   such as
        an HTML document in an HTML frame.  Network resources can\n   also opt into
        letting other origins read their information, for\n   example, using Cross-Origin
        Resource Sharing [CORS].  In these cases,\n   access is typically granted
        on a per-origin basis.\n   Sending information to another origin is permitted.
        \ However, sending\n   information over the network in arbitrary formats is
        dangerous.  For\n   this reason, user agents restrict documents to sending
        information\n   using particular protocols, such as in an HTTP request without
        custom\n   headers.  Expanding the set of allowed protocols, for example,
        by\n   adding support for WebSockets, must be done carefully to avoid\n   introducing
        vulnerabilities [RFC6455].\n"
      title: 3.4.2.  Network Access
    - contents:
      - "3.4.3.  Pitfalls\n   Whenever user agents allow one origin to interact with
        resources from\n   another origin, they invite security issues.  For example,
        the\n   ability to display images from another origin leaks their height and\n
        \  width.  Similarly, the ability to send network requests to another\n   origin
        gives rise to cross-site request forgery vulnerabilities\n   [CSRF].  However,
        user agent implementors often balance these risks\n   against the benefits
        of allowing the cross-origin interaction.  For\n   example, an HTML user agent
        that blocked cross-origin network\n   requests would prevent its users from
        following hyperlinks, a core\n   feature of the web.\n   When adding new functionality
        to the web platform, it can be tempting\n   to grant a privilege to one resource
        but to withhold that privilege\n   from another resource in the same origin.
        \ However, withholding\n   privileges in this way is ineffective because the
        resource without\n   the privilege can usually obtain the privilege anyway
        because user\n   agents do not isolate resources within an origin.  Instead,\n
        \  privileges should be granted or withheld from origins as a whole\n   (rather
        than discriminating between individual resources within an\n   origin) [BOFGO].\n"
      title: 3.4.3.  Pitfalls
    title: 3.4.  Policy
  - contents:
    - "3.5.  Conclusion\n   The same-origin policy uses URIs to designate trust relationships.\n
      \  URIs are grouped together into origins, which represent protection\n   domains.
      \ Some resources in an origin (e.g., active content) are\n   granted the origin's
      full authority, whereas other resources in the\n   origin (e.g., passive content)
      are not granted the origin's\n   authority.  Content that carries its origin's
      authority is granted\n   access to objects and network resources within its
      own origin.  This\n   content is also granted limited access to objects and
      network\n   resources of other origins, but these cross-origin privileges must
      be\n   designed carefully to avoid security vulnerabilities.\n"
    title: 3.5.  Conclusion
  title: 3.  Principles of the Same-Origin Policy
- contents:
  - "4.  Origin of a URI\n   The origin of a URI is the value computed by the following
    algorithm:\n   1.  If the URI does not use a hierarchical element as a naming\n
    \      authority (see [RFC3986], Section 3.2) or if the URI is not an\n       absolute
    URI, then generate a fresh globally unique identifier\n       and return that
    value.\n          NOTE: Running this algorithm multiple times for the same URI\n
    \         can produce different values each time.  Typically, user\n          agents
    compute the origin of, for example, an HTML document\n          once and use that
    origin for subsequent security checks rather\n          than recomputing the origin
    for each security check.\n   2.  Let uri-scheme be the scheme component of the
    URI, converted to\n       lowercase.\n   3.  If the implementation doesn't support
    the protocol given by uri-\n       scheme, then generate a fresh globally unique
    identifier and\n       return that value.\n   4.  If uri-scheme is \"file\", the
    implementation MAY return an\n       implementation-defined value.\n          NOTE:
    Historically, user agents have granted content from the\n          file scheme
    a tremendous amount of privilege.  However,\n          granting all local files
    such wide privileges can lead to\n          privilege escalation attacks.  Some
    user agents have had\n          success granting local files directory-based privileges,
    but\n          this approach has not been widely adopted.  Other user agents\n
    \         use globally unique identifiers for each file URI, which is\n          the
    most secure option.\n   5.  Let uri-host be the host component of the URI, converted
    to lower\n       case (using the i;ascii-casemap collation defined in [RFC4790]).\n
    \         NOTE: This document assumes that the user agent performs\n          Internationalizing
    Domain Names in Applications (IDNA)\n          processing and validation when
    constructing the URI.  In\n          particular, this document assumes the uri-host
    will contain\n          only LDH labels because the user agent will have already\n
    \         converted any non-ASCII labels to their corresponding A-labels\n          (see
    [RFC5890]).  For this reason, origin-based security\n          policies are sensitive
    to the IDNA algorithm employed by the\n          user agent.  See Section 8.4
    for further discussion.\n   6.  If there is no port component of the URI:\n       1.
    \ Let uri-port be the default port for the protocol given by\n           uri-scheme.\n
    \      Otherwise:\n       2.  Let uri-port be the port component of the URI.\n
    \  7.  Return the triple (uri-scheme, uri-host, uri-port).\n"
  title: 4.  Origin of a URI
- contents:
  - "5.  Comparing Origins\n   Two origins are \"the same\" if, and only if, they
    are identical.  In\n   particular:\n   o  If the two origins are scheme/host/port
    triples, the two origins\n      are the same if, and only if, they have identical
    schemes, hosts,\n      and ports.\n   o  An origin that is a globally unique identifier
    cannot be the same\n      as an origin that is a scheme/host/port triple.\n   Two
    URIs are same-origin if their origins are the same.\n      NOTE: A URI is not
    necessarily same-origin with itself.  For\n      example, a data URI [RFC2397]
    is not same-origin with itself\n      because data URIs do not use a server-based
    naming authority and\n      therefore have globally unique identifiers as origins.\n"
  title: 5.  Comparing Origins
- contents:
  - "6.  Serializing Origins\n   This section defines how to serialize an origin to
    a unicode\n   [Unicode6] string and to an ASCII [RFC20] string.\n"
  - contents:
    - "6.1.  Unicode Serialization of an Origin\n   The unicode-serialization of an
      origin is the value returned by the\n   following algorithm:\n   1.  If the
      origin is not a scheme/host/port triple, then return the\n       string\n          null\n
      \      (i.e., the code point sequence U+006E, U+0075, U+006C, U+006C)\n       and
      abort these steps.\n   2.  Otherwise, let result be the scheme part of the origin
      triple.\n   3.  Append the string \"://\" to result.\n   4.  Append each component
      of the host part of the origin triple\n       (converted as follows) to the
      result, separated by U+002E FULL\n       STOP code points (\".\"):\n       1.
      \ If the component is an A-label, use the corresponding U-label\n           instead
      (see [RFC5890] and [RFC5891]).\n       2.  Otherwise, use the component verbatim.\n
      \  5.  If the port part of the origin triple is different from the\n       default
      port for the protocol given by the scheme part of the\n       origin triple:\n
      \      1.  Append a U+003A COLON code point (\":\") and the given port, in\n
      \          base ten, to result.\n   6.  Return result.\n"
    title: 6.1.  Unicode Serialization of an Origin
  - contents:
    - "6.2.  ASCII Serialization of an Origin\n   The ascii-serialization of an origin
      is the value returned by the\n   following algorithm:\n   1.  If the origin
      is not a scheme/host/port triple, then return the\n       string\n          null\n
      \      (i.e., the code point sequence U+006E, U+0075, U+006C, U+006C)\n       and
      abort these steps.\n   2.  Otherwise, let result be the scheme part of the origin
      triple.\n   3.  Append the string \"://\" to result.\n   4.  Append the host
      part of the origin triple to result.\n   5.  If the port part of the origin
      triple is different from the\n       default port for the protocol given by
      the scheme part of the\n       origin triple:\n       1.  Append a U+003A COLON
      code point (\":\") and the given port, in\n           base ten, to result.\n
      \  6.  Return result.\n"
    title: 6.2.  ASCII Serialization of an Origin
  title: 6.  Serializing Origins
- contents:
  - "7.  The HTTP Origin Header Field\n   This section defines the HTTP Origin header
    field.\n"
  - contents:
    - "7.1.  Syntax\n   The Origin header field has the following syntax:\n   origin
      \             = \"Origin:\" OWS origin-list-or-null OWS\n   origin-list-or-null
      = %x6E %x75 %x6C %x6C / origin-list\n   origin-list         = serialized-origin
      *( SP serialized-origin )\n   serialized-origin   = scheme \"://\" host [ \":\"
      port ]\n                       ; <scheme>, <host>, <port> from RFC 3986\n"
    title: 7.1.  Syntax
  - contents:
    - "7.2.  Semantics\n   When included in an HTTP request, the Origin header field
      indicates\n   the origin(s) that \"caused\" the user agent to issue the request,
      as\n   defined by the API that triggered the user agent to issue the\n   request.\n
      \  For example, consider a user agent that executes scripts on behalf of\n   origins.
      \ If one of those scripts causes the user agent to issue an\n   HTTP request,
      the user agent MAY use the Origin header field to\n   inform the server of the
      security context in which the script was\n   executing when it caused the user
      agent to issue the request.\n   In some cases, a number of origins contribute
      to causing the user\n   agents to issue an HTTP request.  In those cases, the
      user agent MAY\n   list all the origins in the Origin header field.  For example,
      if the\n   HTTP request was initially issued by one origin but then later\n
      \  redirected by another origin, the user agent MAY inform the server\n   that
      two origins were involved in causing the user agent to issue the\n   request.\n"
    title: 7.2.  Semantics
  - contents:
    - "7.3.  User Agent Requirements\n   The user agent MAY include an Origin header
      field in any HTTP\n   request.\n   The user agent MUST NOT include more than
      one Origin header field in\n   any HTTP request.\n   Whenever a user agent issues
      an HTTP request from a \"privacy-\n   sensitive\" context, the user agent MUST
      send the value \"null\" in the\n   Origin header field.\n      NOTE: This document
      does not define the notion of a privacy-\n      sensitive context.  Applications
      that generate HTTP requests can\n      designate contexts as privacy-sensitive
      to impose restrictions on\n      how user agents generate Origin header fields.\n
      \  When generating an Origin header field, the user agent MUST meet the\n   following
      requirements:\n   o  Each of the serialized-origin productions in the grammar
      MUST be\n      the ascii-serialization of an origin.\n   o  No two consecutive
      serialized-origin productions in the grammar\n      can be identical.  In particular,
      if the user agent would generate\n      two consecutive serialized-origins,
      the user agent MUST NOT\n      generate the second one.\n"
    title: 7.3.  User Agent Requirements
  title: 7.  The HTTP Origin Header Field
- contents:
  - "8.  Security Considerations\n   The same-origin policy is one of the cornerstones
    of security for\n   many user agents, including web browsers.  Historically, some
    user\n   agents tried other security models, including taint tracking and\n   exfiltration
    prevention, but those models proved difficult to\n   implement at the time (although
    there has been recent interest in\n   reviving some of these ideas).\n   Evaluating
    the security of the same-origin policy is difficult\n   because the origin concept
    itself plays such a central role in the\n   security landscape.  The notional
    origin itself is just a unit of\n   isolation, imperfect as are most one-size-fits-all
    notions.  That\n   said, there are some systemic weaknesses, discussed below.\n"
  - contents:
    - "8.1.  Reliance on DNS\n   In practice, the same-origin policy relies upon the
      Domain Name\n   System (DNS) for security because many commonly used URI schemes,\n
      \  such as http, use DNS-based naming authorities.  If the DNS is\n   partially
      or fully compromised, the same-origin policy might fail to\n   provide the security
      properties required by applications.\n   Some URI schemes, such as https, are
      more resistant to DNS compromise\n   because user agents employ other mechanisms,
      such as certificates, to\n   verify the source of content retrieved from these
      URIs.  Other URI\n   schemes, such as the chrome-extension URI scheme (see Section
      4.3 of\n   [CRX]), use a public-key-based naming authority and are fully secure\n
      \  against DNS compromise.\n   The web origin concept isolates content retrieved
      from different URI\n   schemes; this is essential to containing the effects
      of DNS\n   compromise.\n"
    title: 8.1.  Reliance on DNS
  - contents:
    - "8.2.  Divergent Units of Isolation\n   Over time, a number of technologies
      have converged on the web origin\n   concept as a convenient unit of isolation.
      \ However, many\n   technologies in use today, such as cookies [RFC6265], pre-date
      the\n   modern web origin concept.  These technologies often have different\n
      \  isolation units, leading to vulnerabilities.\n   One alternative is to use
      only the \"registry-controlled\" domain\n   rather than the fully qualified
      domain name as the unit of isolation\n   (e.g., \"example.com\" instead of \"www.example.com\").
      \ This practice is\n   problematic for a number of reasons and is NOT RECOMMENDED:\n
      \  1.  The notion of a \"registry-controlled\" domain is a function of\n       human
      practice surrounding the DNS rather than a property of the\n       DNS itself.
      \ For example, many municipalities in Japan run public\n       registries quite
      deep in the DNS hierarchy.  There are widely\n       used \"public suffix lists\",
      but these lists are difficult to keep\n       up to date and vary between implementations.\n
      \  2.  This practice is incompatible with URI schemes that do not use a\n       DNS-based
      naming authority.  For example, if a given URI scheme\n       uses public keys
      as naming authorities, the notion of a\n       \"registry-controlled\" public
      key is somewhat incoherent.  Worse,\n       some URI schemes, such as nntp,
      use dotted delegation in the\n       opposite direction from DNS (e.g., alt.usenet.kooks),
      and others\n       use the DNS but present the labels in the reverse of the
      usual\n       order (e.g., com.example.www).\n   At best, using \"registry-controlled\"
      domains is URI-scheme- and\n   implementation-specific.  At worst, differences
      between URI schemes\n   and implementations can lead to vulnerabilities.\n"
    title: 8.2.  Divergent Units of Isolation
  - contents:
    - "8.3.  Ambient Authority\n   When using the same-origin policy, user agents
      grant authority to\n   content based on its URI rather than based on which objects
      the\n   content can designate.  This disentangling of designation from\n   authority
      is an example of ambient authority and can lead to\n   vulnerabilities.\n   Consider,
      for example, cross-site scripting in HTML documents.  If an\n   attacker can
      inject script content into an HTML document, those\n   scripts will run with
      the authority of the document's origin, perhaps\n   allowing the script access
      to sensitive information, such as the\n   user's medical records.  If, however,
      the script's authority were\n   limited to those objects that the script could
      designate, the\n   attacker would not gain any advantage by injecting the script
      into an\n   HTML document hosted by a third party.\n"
    title: 8.3.  Ambient Authority
  - contents:
    - "8.4.  IDNA Dependency and Migration\n   The security properties of the same-origin
      policy can depend\n   crucially on details of the IDNA algorithm employed by
      the user\n   agent.  In particular, a user agent might map some international\n
      \  domain names (for example, those involving the U+00DF character) to\n   different
      ASCII representations depending on whether the user agent\n   uses IDNA2003
      [RFC3490] or IDNA2008 [RFC5890].\n   Migrating from one IDNA algorithm to another
      might redraw a number of\n   security boundaries, potentially erecting new security
      boundaries or,\n   worse, tearing down security boundaries between two mutually\n
      \  distrusting entities.  Changing security boundaries is risky because\n   combining
      two mutually distrusting entities into the same origin\n   might allow one to
      attack the other.\n"
    title: 8.4.  IDNA Dependency and Migration
  title: 8.  Security Considerations
- contents:
  - "9.  IANA Considerations\n   The permanent message header field registry (see
    [RFC3864]) has been\n   updated with the following registration:\n   Header field
    name: Origin\n   Applicable protocol: http\n   Status: standard\n   Author/Change
    controller: IETF\n   Specification document: this specification (Section 7)\n"
  title: 9.  IANA Considerations
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [RFC20]     Cerf, V., \"ASCII format for network
      interchange\", RFC 20,\n               October 1969.\n   [RFC2119]   Bradner,
      S., \"Key words for use in RFCs to Indicate\n               Requirement Levels\",
      BCP 14, RFC 2119, March 1997.\n   [RFC2616]   Fielding, R., Gettys, J., Mogul,
      J., Frystyk, H.,\n               Masinter, L., Leach, P., and T. Berners-Lee,
      \"Hypertext\n               Transfer Protocol -- HTTP/1.1\", RFC 2616, June
      1999.\n   [RFC3864]   Klyne, G., Nottingham, M., and J. Mogul, \"Registration\n
      \              Procedures for Message Header Fields\", BCP 90, RFC 3864,\n               September
      2004.\n   [RFC3986]   Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n
      \              Resource Identifier (URI): Generic Syntax\", STD 66,\n               RFC
      3986, January 2005.\n   [RFC4790]   Newman, C., Duerst, M., and A. Gulbrandsen,
      \"Internet\n               Application Protocol Collation Registry\", RFC 4790,\n
      \              March 2007.\n   [RFC5234]   Crocker, D., Ed. and P. Overell,
      \"Augmented BNF for\n               Syntax Specifications: ABNF\", STD 68, RFC
      5234,\n               January 2008.\n   [RFC5890]   Klensin, J., \"Internationalized
      Domain Names for\n               Applications (IDNA): Definitions and Document
      Framework\",\n               RFC 5890, August 2010.\n   [RFC5891]   Klensin,
      J., \"Internationalized Domain Names in\n               Applications (IDNA):
      Protocol\", RFC 5891, August 2010.\n   [Unicode6]  The Unicode Consortium, \"The
      Unicode Standard, Version\n               6.0.0\", 2011,\n               <http://www.unicode.org/versions/Unicode6.0.0/>.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [BOFGO]     Jackson, C. and A. Barth, \"Beware
      of Finer-Grained\n               Origins\", 2008,\n               <http://w2spconf.com/2008/papers/s2p1.pdf>.\n
      \  [CORS]      van Kesteren, A., \"Cross-Origin Resource Sharing\", W3C\n               Working
      Draft WD-cors-20100727, July 2010,\n               <http://www.w3.org/TR/2010/WD-cors-20100727/>.\n
      \              Latest version available at <http://www.w3.org/TR/cors/>.\n   [CRX]
      \      Barth, A., Felt, A., Saxena, P., and A. Boodman,\n               \"Protecting
      Browsers from Extension Vulnerabilities\",\n               2010, <http://www.isoc.org/isoc/conferences/ndss/10/pdf/\n
      \              04.pdf>.\n   [CSRF]      Barth, A., Jackson, C., and J. Mitchell,
      \"Robust Defenses\n               for Cross-Site Request Forgery\", 2008,\n
      \              <http://portal.acm.org/citation.cfm?id=1455770.1455782>.\n   [HTML]
      \     Hickson, I., \"HTML5\", W3C Working Draft WD-html5-\n               20110525,
      May 2011,\n               <http://www.w3.org/TR/2011/WD-html5-20110525/>.\n
      \              Latest version available at\n               <http://www.w3.org/TR/html5/>.\n
      \  [RFC2397]   Masinter, L., \"The \"data\" URL scheme\", RFC 2397,\n               August
      1998.\n   [RFC2817]   Khare, R. and S. Lawrence, \"Upgrading to TLS Within\n
      \              HTTP/1.1\", RFC 2817, May 2000.\n   [RFC3490]   Faltstrom, P.,
      Hoffman, P., and A. Costello,\n               \"Internationalizing Domain Names
      in Applications (IDNA)\",\n               RFC 3490, March 2003.\n   [RFC5246]
      \  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n               (TLS)
      Protocol Version 1.2\", RFC 5246, August 2008.\n   [RFC6265]   Barth, A., \"HTTP
      State Management Mechanism\", RFC 6265,\n               April 2011.\n   [RFC6455]
      \  Fette, I. and A. Melnikov, \"The WebSocket Protocol\",\n               RFC
      6455, December 2011.\n   [SNIFF]     Barth, A. and I. Hickson, \"Media Type
      Sniffing\", Work\n               in Progress, May 2011.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - "Appendix A.  Acknowledgements\n   We would like to thank Lucas Adamski, Stephen
    Farrell, Miguel A.\n   Garcia, Tobias Gondrom, Ian Hickson, Anne van Kesteren,
    Jeff Hodges,\n   Collin Jackson, Larry Masinter, Alexey Melnikov, Mark Nottingham,\n
    \  Julian Reschke, Peter Saint-Andre, Jonas Sicking, Sid Stamm, Daniel\n   Veditz,
    and Chris Weber for their valuable feedback on this document.\n"
  title: Appendix A.  Acknowledgements
- contents:
  - "Author's Address\n   Adam Barth\n   Google, Inc.\n   EMail: ietf@adambarth.com\n
    \  URI:   http://www.adambarth.com/\n"
  title: Author's Address
