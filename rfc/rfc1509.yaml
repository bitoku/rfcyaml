- title: __initial_text__
  contents:
  - '               Generic Security Service API : C-bindings

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This RFC specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" for the standardization state and status\n   of this protocol.\
    \  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies C language bindings for the Generic Security\n\
    \   Service Application Program Interface (GSS-API), which is described\n   at\
    \ a language-independent conceptual level in other documents.\n   The Generic\
    \ Security Service Application Programming Interface (GSS-\n   API) provides security\
    \ services to its callers, and is intended for\n   implementation atop alternative\
    \ underlying cryptographic mechanisms.\n   Typically, GSS-API callers will be\
    \ application protocols into which\n   security enhancements are integrated through\
    \ invocation of services\n   provided by the GSS-API. The GSS-API allows a caller\
    \ application to\n   authenticate a principal identity associated with a peer\
    \ application,\n   to delegate rights to a peer, and to apply security services\
    \ such as\n   confidentiality and integrity on a per-message basis.\n"
- title: 1. INTRODUCTION
  contents:
  - "1. INTRODUCTION\n   The Generic Security Service Application Programming Interface\
    \ [1]\n   provides security services to calling applications.  It allows a\n \
    \  communicating application to authenticate the user associated with\n   another\
    \ application, to delegate rights to another application, and\n   to apply security\
    \ services such as confidentiality and integrity on a\n   per-message basis.\n\
    \   There are four stages to using the GSSAPI:\n   (a) The application acquires\
    \ a set of credentials with which it may\n       prove its identity to other processes.\
    \  The application's\n       credentials vouch for its global identity, which\
    \ may or may not\n       be related to the local username under which it is running.\n\
    \   (b) A pair of communicating applications establish a joint security\n    \
    \   context using their credentials.  The security context is a\n       pair of\
    \ GSSAPI data structures that contain shared state\n       information, which\
    \ is required in order that per-message\n       security services may be provided.\
    \  As part of the\n       establishment of a security context, the context initiator\
    \ is\n       authenticated to the responder, and may require that the\n      \
    \ responder is authenticated in turn.  The initiator may\n       optionally give\
    \ the responder the right to initiate further\n       security contexts.  This\
    \ transfer of rights is termed\n       delegation, and is achieved by creating\
    \ a set of credentials,\n       similar to those used by the originating application,\
    \ but which\n       may be used by the responder.  To establish and maintain the\n\
    \       shared information that makes up the security context, certain\n     \
    \  GSSAPI calls will return a token data structure, which is a\n       cryptographically\
    \ protected opaque data type.  The caller of\n       such a GSSAPI routine is\
    \ responsible for transferring the token\n       to the peer application, which\
    \ should then pass it to a\n       corresponding GSSAPI routine which will decode\
    \ it and extract\n       the information.\n   (c) Per-message services are invoked\
    \ to apply either:\n       (i) integrity and data origin authentication, or\n\
    \       (ii) confidentiality, integrity and data origin authentication\n     \
    \       to application data, which are treated by GSSAPI as\n            arbitrary\
    \ octet-strings.  The application transmitting a\n            message that it\
    \ wishes to protect will call the appropriate\n            GSSAPI routine (sign\
    \ or seal) to apply protection, specifying\n            the appropriate security\
    \ context, and send the result to the\n            receiving application.  The\
    \ receiver will pass the received\n            data to the corresponding decoding\
    \ routine (verify or unseal)\n            to remove the protection and validate\
    \ the data.\n   (d) At the completion of a communications session (which may extend\n\
    \       across several connections), the peer applications call GSSAPI\n     \
    \  routines to delete the security context.  Multiple contexts may\n       also\
    \ be used (either successively or simultaneously) within a\n       single communications\
    \ association.\n"
- title: 2. GSSAPI Routines
  contents:
  - "2. GSSAPI Routines\n   This section lists the functions performed by each of\
    \ the GSSAPI\n   routines and discusses their major parameters, describing how\
    \ they\n   are to be passed to the routines.  The routines are listed in figure\n\
    \   4-1.\n                      Figure 4-1  GSSAPI Routines\n            Routine\
    \                               Function\n            gss_acquire_cred       \
    \        Assume a global identity\n            gss_release_cred              \
    \ Discard credentials\n            gss_init_sec_context           Initiate a security\
    \ context\n                                           with a peer application\n\
    \            gss_accept_sec_context         Accept a security context\n      \
    \                                     initiated by a peer\n                  \
    \                         application\n            gss_process_context_token \
    \     Process a token on a security\n                                        \
    \   context from a peer\n                                           application\n\
    \            gss_delete_sec_context         Discard a security context\n     \
    \       gss_context_time               Determine for how long a\n            \
    \                               context will remain valid\n            gss_sign\
    \                       Sign a message; integrity\n                          \
    \                 service\n            gss_verify                     Check signature\
    \ on a message\n            gss_seal                       Sign (optionally encrypt)\
    \ a\n                                           message; confidentiality\n   \
    \                                        service\n            gss_unseal     \
    \                Verify (optionally decrypt)\n                               \
    \            message\n            gss_display_status             Convert an API\
    \ status code\n                                           to text\n          \
    \  gss_indicate_mechs             Determine underlying\n                     \
    \                      authentication mechanism\n            gss_compare_name\
    \               Compare two internal-form\n                                  \
    \         names\n            gss_display_name               Convert opaque name\
    \ to text\n            gss_import_name                Convert a textual name to\n\
    \                                           internal-form\n            gss_release_name\
    \               Discard an internal-form\n                                   \
    \        name\n            gss_release_buffer             Discard a buffer\n \
    \           gss_release_oid_set            Discard a set of object\n         \
    \                                  identifiers\n            gss_inquire_cred \
    \              Determine information about\n                                 \
    \          a credential\n   Individual GSSAPI implementations may augment these\
    \ routines by\n   providing additional mechanism-specific routines if required\n\
    \   functionality is not available from the generic forms.  Applications\n   are\
    \ encouraged to use the generic routines wherever possible on\n   portability\
    \ grounds.\n"
- title: 2.1. Data Types and Calling Conventions
  contents:
  - "2.1. Data Types and Calling Conventions\n   The following conventions are used\
    \ by the GSSAPI:\n"
- title: 2.1.1. Structured data types
  contents:
  - "2.1.1. Structured data types\n   Wherever these GSSAPI C-bindings describe structured\
    \ data, only\n   fields that must be provided by all GSSAPI implementation are\n\
    \   documented.  Individual implementations may provide additional\n   fields,\
    \ either for internal use within GSSAPI routines, or for use by\n   non-portable\
    \ applications.\n"
- title: 2.1.2. Integer types
  contents:
  - "2.1.2. Integer types\n   GSSAPI defines the following integer data type:\n  \
    \               OM_uint32      32-bit unsigned integer\n   Where guaranteed minimum\
    \ bit-count is important, this portable data\n   type is used by the GSSAPI routine\
    \ definitions. Individual GSSAPI\n   implementations will include appropriate\
    \ typedef definitions to map\n   this type onto a built-in data type.\n"
- title: 2.1.3. String and similar data
  contents:
  - "2.1.3. String and similar data\n   Many of the GSSAPI routines take arguments\
    \ and return values that\n   describe contiguous multiple-byte data.  All such\
    \ data is passed\n   between the GSSAPI and the caller using the gss_buffer_t\
    \ data type.\n   This data type is a pointer to a buffer descriptor, which consists\
    \ of\n   a length field that contains the total number of bytes in the datum,\n\
    \   and a value field which contains a pointer to the actual datum:\n        \
    \         typedef struct gss_buffer_desc_struct {\n                    size_t\
    \  length;\n                    void    *value;\n                 } gss_buffer_desc,\
    \ *gss_buffer_t;\n   Storage for data passed to the application by a GSSAPI routine\
    \ using\n   the gss_buffer_t conventions is allocated by the GSSAPI routine. \
    \ The\n   application may free this storage by invoking the gss_release_buffer\n\
    \   routine.  Allocation of the gss_buffer_desc object is always the\n   responsibility\
    \ of the application;  Unused gss_buffer_desc objects\n   may be initialized to\
    \ the value GSS_C_EMPTY_BUFFER.\n"
- title: 2.1.3.1. Opaque data types
  contents:
  - "2.1.3.1. Opaque data types\n   Certain multiple-word data items are considered\
    \ opaque data types at\n   the GSSAPI, because their internal structure has no\
    \ significance\n   either to the GSSAPI or to the caller.  Examples of such opaque\
    \ data\n   types are the input_token parameter to gss_init_sec_context (which\
    \ is\n   opaque to the caller), and the input_message parameter to gss_seal\n\
    \   (which is opaque to the GSSAPI).  Opaque data is passed between the\n   GSSAPI\
    \ and the application using the gss_buffer_t datatype.\n"
- title: 2.1.3.2. Character strings
  contents:
  - "2.1.3.2. Character strings\n   Certain multiple-word data items may be regarded\
    \ as simple ISO\n   Latin-1 character strings.  An example of this is the\n  \
    \ input_name_buffer parameter to gss_import_name.  Some GSSAPI routines\n   also\
    \ return character strings.  Character strings are passed between\n   the application\
    \ and the GSSAPI using the gss_buffer_t datatype,\n   defined earlier.\n"
- title: 2.1.4. Object Identifiers
  contents:
  - "2.1.4. Object Identifiers\n   Certain GSSAPI procedures take parameters of the\
    \ type gss_OID, or\n   Object identifier.  This is a type containing ISO-defined\
    \ tree-\n   structured values, and is used by the GSSAPI caller to select an\n\
    \   underlying security mechanism.  A value of type gss_OID has the\n   following\
    \ structure:\n                 typedef struct gss_OID_desc_struct {\n        \
    \            OM_uint32 length;\n                    void      *elements;\n   \
    \              } gss_OID_desc, *gss_OID;\n   The elements field of this structure\
    \ points to the first byte of an\n   octet string containing the ASN.1 BER encoding\
    \ of the value of the\n   gss_OID.  The length field contains the number of bytes\
    \ in this\n   value.  For example, the  gss_OID value corresponding to {iso(1)\n\
    \   identified- oganization(3) icd-ecma(12) member-company(2) dec(1011)\n   cryptoAlgorithms(7)\
    \ SPX(5)} meaning SPX (Digital's X.509\n   authentication mechanism) has a length\
    \ field of 7 and an elements\n   field pointing to seven octets containing the\
    \ following octal values:\n   53,14,2,207,163,7,5. GSSAPI implementations should\
    \ provide constant\n   gss_OID values to allow callers to request any supported\
    \ mechanism,\n   although applications are encouraged on portability grounds to\
    \ accept\n   the default mechanism.   gss_OID values should also be provided to\n\
    \   allow applications to specify particular name types (see section\n   2.1.10).\
    \  Applications should treat gss_OID_desc values returned by\n   GSSAPI routines\
    \ as read-only.  In particular, the application should\n   not attempt to deallocate\
    \ them.  The gss_OID_desc datatype is\n   equivalent to the X/Open OM_object_identifier\
    \ datatype [2].\n"
- title: 2.1.5. Object Identifier Sets
  contents:
  - "2.1.5. Object Identifier Sets\n   Certain GSSAPI procedures take parameters of\
    \ the type gss_OID_set.\n   This type represents one or more object identifiers\
    \ (section 2.1.4).\n   A gss_OID_set object has the following structure:\n   \
    \              typedef struct gss_OID_set_desc_struct {\n                    int\
    \       count;\n                    gss_OID   elements;\n                 } gss_OID_set_desc,\
    \ *gss_OID_set;\n   The count field contains the number of OIDs within the set.\
    \  The\n   elements field is a pointer to an array of gss_OID_desc objects, each\n\
    \   of which describes a single OID. gss_OID_set values are used to name\n   the\
    \ available mechanisms supported by the GSSAPI, to request the use\n   of specific\
    \ mechanisms, and to indicate which mechanisms a given\n   credential supports.\
    \  Storage associated with gss_OID_set values\n   returned to the application\
    \ by the GSSAPI may be deallocated by the\n   gss_release_oid_set routine.\n"
- title: 2.1.6. Credentials
  contents:
  - "2.1.6. Credentials\n   A credential handle is a caller-opaque atomic datum that\
    \ identifies a\n   GSSAPI credential data structure.  It is represented by the\
    \ caller-\n   opaque type gss_cred_id_t, which may be implemented as either an\n\
    \   arithmetic or a pointer type.  Credentials describe a principal, and\n   they\
    \ give their holder the ability to act as that principal.  The\n   GSSAPI does\
    \ not make the actual credentials available to\n   applications; instead the credential\
    \ handle is used to identify a\n   particular credential, held internally by GSSAPI\
    \ or underlying\n   mechanism.  Thus the credential handle contains no security-relavent\n\
    \   information, and requires no special protection by the application.\n   Depending\
    \ on the implementation, a given credential handle may refer\n   to different\
    \ credentials when presented to the GSSAPI by different\n   callers.  Individual\
    \ GSSAPI implementations should define both the\n   scope of a credential handle\
    \ and the scope of a credential itself\n   (which must be at least as wide as\
    \ that of a handle).  Possibilities\n   for credential handle scope include the\
    \ process that acquired the\n   handle, the acquiring process and its children,\
    \ or all processes\n   sharing some local identification information (e.g., UID).\
    \  If no\n   handles exist by which a given credential may be reached, the GSSAPI\n\
    \   may delete the credential.\n   Certain routines allow credential handle parameters\
    \ to be omitted to\n   indicate the use of a default credential.  The mechanism\
    \ by which a\n   default credential is established and its scope should be defined\
    \ by\n   the individual GSSAPI implementation.\n"
- title: 2.1.7. Contexts
  contents:
  - "2.1.7. Contexts\n   The gss_ctx_id_t data type contains a caller-opaque atomic\
    \ value that\n   identifies one end of a GSSAPI security context.  It may be\n\
    \   implemented as either an arithmetic or a pointer type. Depending on\n   the\
    \ implementation, a given gss_ctx_id_t value may refer to different\n   GSSAPI\
    \ security contexts when presented to the GSSAPI by different\n   callers.  The\
    \ security context holds state information about each end\n   of a peer communication,\
    \ including cryptographic state information.\n   Individual GSSAPI implementations\
    \ should define the scope of a\n   context.  Since no way is provided by which\
    \ a new gss_ctx_id_t value\n   may be obtained for an existing context, the scope\
    \ of a context\n   should be the same as the scope of a gss_ctx_id_t.\n"
- title: 2.1.8. Authentication tokens
  contents:
  - "2.1.8. Authentication tokens\n   A token is a caller-opaque type that GSSAPI\
    \ uses to maintain\n   synchronization between the context data structures at\
    \ each end of a\n   GSSAPI security context.  The token is a cryptographically\
    \ protected\n   bit-string, generated by the underlying mechanism at one end of\
    \ a\n   GSSAPI security context for use by the peer mechanism at the other\n \
    \  end.  Encapsulation (if required) and transfer of the token are the\n   responsibility\
    \ of the peer applications.  A token is passed between\n   the GSSAPI and the\
    \ application using the gss_buffer_t conventions.\n"
- title: 2.1.9. Status values
  contents:
  - "2.1.9. Status values\n   One or more status codes are returned by each GSSAPI\
    \ routine.  Two\n   distinct sorts of status codes are returned.  These are termed\
    \ GSS\n   status codes and Mechanism status codes.\n"
- title: 2.1.9.1. GSS status codes
  contents:
  - "2.1.9.1. GSS status codes\n   GSSAPI routines return GSS status codes as their\
    \ OM_uint32 function\n   value.  These codes indicate errors that are independent\
    \ of the\n   underlying mechanism used to provide the security service.  The\n\
    \   errors that can be indicated via a GSS status code are either generic\n  \
    \ API routine errors (errors that are defined in the GSSAPI\n   specification)\
    \ or calling errors (errors that are specific to these\n   bindings).\n   A GSS\
    \ status code can indicate a single fatal generic API error from\n   the routine\
    \ and a single calling error.  In addition, supplementary\n   status information\
    \ may be indicated via the setting of bits in the\n   supplementary info field\
    \ of a GSS status code.\n   These errors are encoded into the 32-bit GSS status\
    \ code as follows:\n      MSB                                                \
    \        LSB\n      |------------------------------------------------------------|\n\
    \      | Calling Error | Routine Error  |    Supplementary Info     |\n      |------------------------------------------------------------|\n\
    \   Bit 31           24 23            16 15                        0\n   Hence\
    \ if a GSSAPI routine returns a GSS status code whose upper 16\n   bits contain\
    \ a non-zero value, the call failed.  If the calling error\n   field is non-zero,\
    \ the invoking application's call of the routine was\n   erroneous.  Calling errors\
    \ are defined in table 5-1.  If the routine\n   error field is non-zero, the routine\
    \ failed for one of the routine-\n   specific reasons listed below in table 5-2.\
    \  Whether or not the upper\n   16 bits indicate a failure or a success, the routine\
    \ may indicate\n   additional information by setting bits in the supplementary\
    \ info\n   field of the status code.  The meaning of individual bits is listed\n\
    \   below in table 5-3.\n                     Table 5-1  Calling Errors\n    \
    \          Name                    Value in        Meaning\n                 \
    \                       Field\n         GSS_S_CALL_INACCESSIBLE_READ     1   \
    \        A required input\n                                                  \
    \    parameter could\n                                                      not\
    \ be read.\n         GSS_S_CALL_INACCESSIBLE_WRITE    2           A required output\n\
    \                                                      parameter could\n     \
    \                                                 not be written.\n         GSS_S_CALL_BAD_STRUCTURE\
    \         3           A parameter was\n                                      \
    \                malformed\n                     Table 5-2  Routine Errors\n \
    \              Name             Value in       Meaning\n                     \
    \            Field\n         GSS_S_BAD_MECH             1      An unsupported\
    \ mechanism was\n                                           requested\n      \
    \   GSS_S_BAD_NAME             2      An invalid name was supplied\n         GSS_S_BAD_NAMETYPE\
    \         3      A supplied name was of an\n                                 \
    \          unsupported type\n         GSS_S_BAD_BINDINGS         4      Incorrect\
    \ channel bindings\n                                           were supplied\n\
    \         GSS_S_BAD_STATUS           5      An invalid status code was\n     \
    \                                      supplied\n         GSS_S_BAD_SIG      \
    \        6      A token had an invalid\n                                     \
    \      signature\n         GSS_S_NO_CRED              7      No credentials were\
    \ supplied\n         GSS_S_NO_CONTEXT           8      No context has been\n \
    \                                          established\n         GSS_S_DEFECTIVE_TOKEN\
    \      9      A token was invalid\n         GSS_S_DEFECTIVE_CREDENTIAL 10    \
    \ A credential was invalid\n         GSS_S_CREDENTIALS_EXPIRED  11     The referenced\
    \ credentials\n                                           have expired\n     \
    \    GSS_S_CONTEXT_EXPIRED      12     The context has expired\n         GSS_S_FAILURE\
    \              13     Miscellaneous failure\n                                \
    \           (see text)\n                     Table 5-3  Supplementary Status Bits\n\
    \         Name                Bit Number         Meaning\n         GSS_S_CONTINUE_NEEDED\
    \   0 (LSB)  The routine must be called\n                                    \
    \      again to complete its\n                                          function.\n\
    \                                          See routine documentation for\n   \
    \                                       detailed description.\n         GSS_S_DUPLICATE_TOKEN\
    \   1        The token was a duplicate of\n                                  \
    \        an earlier token\n         GSS_S_OLD_TOKEN         2        The token's\
    \ validity period\n                                          has expired\n   \
    \      GSS_S_UNSEQ_TOKEN       3        A later token has already been\n     \
    \                                     processed\n   The routine documentation\
    \ also uses the name GSS_S_COMPLETE, which is\n   a zero value, to indicate an\
    \ absence of any API errors or\n   supplementary information bits.\n   All GSS_S_xxx\
    \ symbols equate to complete OM_uint32 status codes,\n   rather than to bitfield\
    \ values.  For example, the actual value of the\n   symbol GSS_S_BAD_NAMETYPE\
    \ (value 3 in the routine error field) is 3\n   << 16.\n   The macros GSS_CALLING_ERROR(),\
    \ GSS_ROUTINE_ERROR() and\n   GSS_SUPPLEMENTARY_INFO() are provided, each of which\
    \ takes a GSS\n   status code and removes all but the relevant field.  For example,\
    \ the\n   value obtained by applying GSS_ROUTINE_ERROR to a status code removes\n\
    \   the calling errors and supplementary info fields, leaving only the\n   routine\
    \ errors field.  The values delivered by these macros may be\n   directly compared\
    \ with a GSS_S_xxx symbol of the appropriate type.\n   The macro GSS_ERROR() is\
    \ also provided, which when applied to a GSS\n   status code returns a non-zero\
    \ value if the status code indicated a\n   calling or routine error, and a zero\
    \ value otherwise.\n   A GSSAPI implementation may choose to signal calling errors\
    \ in a\n   platform-specific manner instead of, or in addition to the routine\n\
    \   value; routine errors and supplementary info should be returned via\n   routine\
    \ status values only.\n"
- title: 2.1.9.2. Mechanism-specific status codes
  contents:
  - "2.1.9.2. Mechanism-specific status codes\n   GSSAPI routines return a minor_status\
    \ parameter, which is used to\n   indicate specialized errors from the underlying\
    \ security mechanism.\n   This parameter may contain a single mechanism-specific\
    \ error,\n   indicated by a OM_uint32 value.\n   The minor_status parameter will\
    \ always be set by a GSSAPI routine,\n   even if it returns a calling error or\
    \ one of the generic API errors\n   indicated above as fatal, although other output\
    \ parameters may remain\n   unset in such cases.  However, output parameters that\
    \ are expected to\n   return pointers to storage allocated by a routine must always\
    \ set set\n   by the routine, even in the event of an error, although in such\
    \ cases\n   the GSSAPI routine may elect to set the returned parameter value to\n\
    \   NULL to indicate that no storage was actually allocated.  Any length\n   field\
    \ associated with such pointers (as in a gss_buffer_desc\n   structure) should\
    \ also be set to zero in such cases.\n   The GSS status code GSS_S_FAILURE is\
    \ used to indicate that the\n   underlying mechanism detected an error for which\
    \ no specific GSS\n   status code is defined.  The mechanism status code will\
    \ provide more\n   details about the error.\n"
- title: 2.1.10. Names
  contents:
  - "2.1.10. Names\n   A name is used to identify a person or entity.  GSSAPI authenticates\n\
    \   the relationship between a name and the entity claiming the name.\n   Two\
    \ distinct representations are defined for names:\n        (a) A printable form,\
    \ for presentation to a user\n        (b) An internal form, for presentation at\
    \ the API\n   The syntax of a printable name is defined by the GSSAPI\n   implementation,\
    \ and may be dependent on local system configuration,\n   or on individual user\
    \ preference.  The internal form provides a\n   canonical representation of the\
    \ name that is independent of\n   configuration.\n   A given GSSAPI implementation\
    \ may support names drawn from multiple\n   namespaces.  In such an implementation,\
    \ the internal form of the name\n   must include fields that identify the namespace\
    \ from which the name\n   is drawn.  The namespace from which a printable name\
    \ is drawn is\n   specified by an accompanying object identifier.\n   Routines\
    \ (gss_import_name and  gss_display_name) are provided to\n   convert names between\
    \ their printable representations and the\n   gss_name_t type.  gss_import_name\
    \ may support multiple syntaxes for\n   each supported namespace, allowing users\
    \ the freedom to choose a\n   preferred name representation.  gss_display_name\
    \ should use an\n   implementation-chosen preferred syntax for each supported\
    \ name-type.\n   Comparison of internal-form names is accomplished via the\n \
    \  gss_compare_names routine.  This removes the need for the application\n   program\
    \ to understand the syntaxes of the various printable names\n   that a given GSSAPI\
    \ implementation may support.\n   Storage is allocated by routines that return\
    \ gss_name_t values.  A\n   procedure, gss_release_name, is provided to free storage\
    \ associated\n   with a name.\n"
- title: 2.1.11. Channel Bindings
  contents:
  - "2.1.11. Channel Bindings\n   GSSAPI supports the use of user-specified tags to\
    \ identify a given\n   context to the peer application.  These tags are used to\
    \ identify the\n   particular communications channel that carries the context.\
    \  Channel\n   bindings are communicated to the GSSAPI using the following\n \
    \  structure:\n                 typedef struct gss_channel_bindings_struct {\n\
    \                    OM_uint32       initiator_addrtype;\n                   \
    \ gss_buffer_desc initiator_address;\n                    OM_uint32       acceptor_addrtype;\n\
    \                    gss_buffer_desc acceptor_address;\n                    gss_buffer_desc\
    \ application_data;\n                 } *gss_channel_bindings_t;\n   The initiator_addrtype\
    \ and acceptor_addrtype fields denote the type\n   of addresses contained in the\
    \ initiator_address and acceptor_address\n   buffers.  The address type should\
    \ be one of the following:\n          GSS_C_AF_UNSPEC      Unspecified address\
    \ type\n          GSS_C_AF_LOCAL       Host-local address type\n          GSS_C_AF_INET\
    \        DARPA Internet address type\n          GSS_C_AF_IMPLINK     ARPAnet IMP\
    \ address type (eg IP)\n          GSS_C_AF_PUP         pup protocols (eg BSP)\
    \ address type\n          GSS_C_AF_CHAOS       MIT CHAOS protocol address type\n\
    \          GSS_C_AF_NS          XEROX NS address type\n          GSS_C_AF_NBS\
    \         nbs address type\n          GSS_C_AF_ECMA        ECMA address type\n\
    \          GSS_C_AF_DATAKIT     datakit protocols address type\n          GSS_C_AF_CCITT\
    \       CCITT protocols (eg X.25)\n          GSS_C_AF_SNA         IBM SNA address\
    \ type\n          GSS_C_AF_DECnet      DECnet address type\n          GSS_C_AF_DLI\
    \         Direct data link interface address type\n          GSS_C_AF_LAT    \
    \     LAT address type\n          GSS_C_AF_HYLINK      NSC Hyperchannel address\
    \ type\n          GSS_C_AF_APPLETALK   AppleTalk address type\n          GSS_C_AF_BSC\
    \         BISYNC 2780/3780 address type\n          GSS_C_AF_DSS         Distributed\
    \ system services address type\n          GSS_C_AF_OSI         OSI TP4 address\
    \ type\n          GSS_C_AF_X25         X25\n          GSS_C_AF_NULLADDR    No\
    \ address specified\n   Note that these name address families rather than specific\
    \ addressing\n   formats.  For address families that contain several alternative\n\
    \   address forms, the initiator_address and acceptor_address fields must\n  \
    \ contain sufficient information to determine which address form is\n   used.\
    \  When not otherwise specified, addresses should be specified in\n   network\
    \ byte-order.\n   Conceptually, the GSSAPI concatenates the initiator_addrtype,\n\
    \   initiator_address, acceptor_addrtype, acceptor_address and\n   application_data\
    \ to form an octet string.  The mechanism signs this\n   octet string, and binds\
    \ the signature to the context establishment\n   token emitted by gss_init_sec_context.\
    \  The same bindings are\n   presented by the context acceptor to gss_accept_sec_context,\
    \ and a\n   signature is calculated in the same way.  The calculated signature\
    \ is\n   compared with that found in the token, and if the signatures differ,\n\
    \   gss_accept_sec_context will return a GSS_S_BAD_BINDINGS error, and\n   the\
    \ context will not be established.  Some mechanisms may include the\n   actual\
    \ channel binding data in the token (rather than just a\n   signature); applications\
    \ should therefore not use confidential data\n   as channel-binding components.\
    \  Individual mechanisms may impose\n   additional constraints on addresses and\
    \ address types that may appear\n   in channel bindings.  For example, a mechanism\
    \ may verify that the\n   initiator_address field of the channel bindings presented\
    \ to\n   gss_init_sec_context contains the correct network address of the host\n\
    \   system.\n"
- title: 2.1.12. Optional parameters
  contents:
  - "2.1.12. Optional parameters\n   Various parameters are described as optional.\
    \  This means that they\n   follow a convention whereby a default value may be\
    \ requested.  The\n   following conventions are used for omitted parameters. \
    \ These\n   conventions apply only to those parameters that are explicitly\n \
    \  documented as optional.\n"
- title: 2.1.12.1. gss_buffer_t types
  contents:
  - "2.1.12.1. gss_buffer_t types\n   Specify GSS_C_NO_BUFFER as a value.  For an\
    \ input parameter this\n   signifies that default behavior is requested, while\
    \ for an output\n   parameter it indicates that the information that would be\
    \ returned\n   via the parameter is not required by the application.\n"
- title: 2.1.12.2. Integer types (input)
  contents:
  - "2.1.12.2. Integer types (input)\n   Individual parameter documentation lists\
    \ values to be used to\n   indicate default actions.\n"
- title: 2.1.12.3. Integer types (output)
  contents:
  - "2.1.12.3. Integer types (output)\n   Specify NULL as the value for the pointer.\n"
- title: 2.1.12.4. Pointer types
  contents:
  - "2.1.12.4. Pointer types\n   Specify NULL as the value.\n"
- title: 2.1.12.5. Object IDs
  contents:
  - "2.1.12.5. Object IDs\n   Specify GSS_C_NULL_OID as the value.\n"
- title: 2.1.12.6. Object ID Sets
  contents:
  - "2.1.12.6. Object ID Sets\n   Specify GSS_C_NULL_OID_SET as the value.\n"
- title: 2.1.12.7. Credentials
  contents:
  - "2.1.12.7. Credentials\n   Specify GSS_C_NO_CREDENTIAL to use the default credential\
    \ handle.\n"
- title: 2.1.12.8. Channel Bindings
  contents:
  - "2.1.12.8. Channel Bindings\n   Specify GSS_C_NO_CHANNEL_BINDINGS to indicate\
    \ that channel bindings\n   are not to be used.\n"
- title: 3. GSSAPI routine descriptions
  contents:
  - '3. GSSAPI routine descriptions

    '
- title: 2.1. gss_acquire_cred
  contents:
  - "2.1. gss_acquire_cred\n      OM_uint32  gss_acquire_cred (\n                \
    \     OM_uint32 *     minor_status,\n                     gss_name_t      desired_name,\n\
    \                     OM_uint32       time_req,\n                     gss_OID_set\
    \     desired_mechs,\n                     int             cred_usage,\n     \
    \                gss_cred_id_t * output_cred_handle,\n                     gss_OID_set\
    \ *   actual_mechs,\n                      OM_int32 *      time_rec)\n   Purpose:\n\
    \   Allows an application to acquire a handle for a pre-existing\n   credential\
    \ by name.  GSSAPI implementations must impose a local\n   access-control policy\
    \ on callers of this routine to prevent\n   unauthorized callers from acquiring\
    \ credentials to which they are not\n   entitled.  This routine is not intended\
    \ to provide a \"login to the\n   network\" function, as such a function would\
    \ result in the creation of\n   new credentials rather than merely acquiring a\
    \ handle to existing\n   credentials.  Such functions, if required, should be\
    \ defined in\n   implementation-specific extensions to the API.\n   If credential\
    \ acquisition is time-consuming for a mechanism, the\n   mechanism may chooses\
    \ to delay the actual acquisition until the\n   credential is required (e.g.,\
    \ by gss_init_sec_context or\n   gss_accept_sec_context).  Such mechanism-specific\
    \ implementation\n   decisions should be invisible to the calling application;\
    \ thus a call\n   of gss_inquire_cred immediately following the call of\n   gss_acquire_cred\
    \ must return valid credential data, and may therefore\n   incur the overhead\
    \ of a deferred credential acquisition.\n   Parameters:\n      desired_name  \
    \    gss_name_t, read\n                        Name of principal whose credential\n\
    \                        should be acquired\n      time_req          integer,\
    \ read\n                        number of seconds that credentials\n         \
    \               should remain valid\n      desired_mechs     Set of Object IDs,\
    \ read\n                        set of underlying security mechanisms that\n \
    \                       may be used.  GSS_C_NULL_OID_SET may be used\n       \
    \                 to obtain an implementation-specific default.\n      cred_usage\
    \        integer, read\n                        GSS_C_BOTH - Credentials may be\
    \ used\n                                     either to initiate or accept\n  \
    \                                   security contexts.\n                     \
    \   GSS_C_INITIATE - Credentials will only be\n                              \
    \           used to initiate security\n                                      \
    \   contexts.\n                        GSS_C_ACCEPT - Credentials will only be\
    \ used to\n                                       accept security contexts.\n\
    \      output_cred_handle   gss_cred_id_t, modify\n                          \
    \ The returned credential handle.\n      actual_mechs      Set of Object IDs,\
    \ modify, optional\n                        The set of mechanisms for which the\n\
    \                        credential is valid.  Specify NULL\n                \
    \        if not required.\n      time_rec          Integer, modify, optional\n\
    \                        Actual number of seconds for which the\n            \
    \            returned credentials will remain valid.  If the\n               \
    \         implementation does not support expiration of\n                    \
    \    credentials, the value GSS_C_INDEFINITE will\n                        be\
    \ returned. Specify NULL if not required\n      minor_status      Integer, modify\n\
    \                        Mechanism specific status code.\n   Function value:\n\
    \      GSS status code:\n      GSS_S_COMPLETE    Successful completion\n     \
    \ GSS_S_BAD_MECH    Unavailable mechanism requested\n      GSS_S_BAD_NAMETYPE\
    \ Type contained within desired_name parameter is\n                        not\
    \ supported\n      GSS_S_BAD_NAME    Value supplied for desired_name parameter\
    \ is\n                        ill-formed.\n      GSS_S_FAILURE     Unspecified\
    \ failure.  The minor_status parameter\n                        contains more\
    \ detailed information\n"
- title: 3.2. gss_release_cred
  contents:
  - "3.2. gss_release_cred\n      OM_uint32  gss_release_cred (\n                \
    \     OM_uint32 *     minor_status,\n                     gss_cred_id_t * cred_handle)\n\
    \   Purpose:\n   Informs GSSAPI that the specified credential handle is no longer\n\
    \   required by the process.  When all processes have released a\n   credential,\
    \ it will be deleted.\n   Parameters:\n      cred_handle       gss_cred_id_t,\
    \ modify, optional\n                        buffer containing opaque credential\n\
    \                        handle.  If  GSS_C_NO_CREDENTIAL  is supplied,\n    \
    \                    the default credential will be released\n      minor_status\
    \      integer, modify\n                        Mechanism specific status code.\n\
    \   Function value:\n      GSS status code:\n      GSS_S_COMPLETE    Successful\
    \ completion\n      GSS_S_NO_CRED     Credentials could not be accessed.\n"
- title: 3.3. gss_init_sec_context
  contents:
  - "3.3. gss_init_sec_context\n      OM_uint32  gss_init_sec_context (\n        \
    \             OM_uint32 *     minor_status,\n                     gss_cred_id_t\
    \   claimant_cred_handle,\n                     gss_ctx_id_t *  context_handle,\n\
    \                     gss_name_t      target_name,\n                     gss_OID\
    \         mech_type,\n                     int             req_flags,\n      \
    \               int             time_req,\n                     gss_channel_bindings_t\n\
    \                                     input_chan_bindings,\n                 \
    \    gss_buffer_t    input_token\n                     gss_OID *       actual_mech_type,\n\
    \                     gss_buffer_t    output_token,\n                     int\
    \ *           ret_flags,\n                     OM_uint32 *     time_rec )\n  \
    \ Purpose:\n   Initiates the establishment of a security context between the\n\
    \   application and a remote peer.  Initially, the input_token parameter\n   should\
    \ be specified as GSS_C_NO_BUFFER.  The routine may return a\n   output_token\
    \ which should be transferred to the peer application,\n   where the peer application\
    \ will present it to gss_accept_sec_context.\n   If no token need be sent, gss_init_sec_context\
    \ will indicate this by\n   setting the length field of the output_token argument\
    \ to zero.  To\n   complete the context establishment, one or more reply tokens\
    \ may be\n   required from the peer application; if so, gss_init_sec_context will\n\
    \   return a status indicating GSS_S_CONTINUE_NEEDED in which case it\n   should\
    \ be called again when the reply token is received from the peer\n   application,\
    \ passing the token to gss_init_sec_context via the\n   input_token parameters.\n\
    \   The values returned via the ret_flags and time_rec parameters are not\n  \
    \ defined unless the routine returns GSS_S_COMPLETE.\n   Parameters:\n      claimant_cred_handle\
    \  gss_cred_id_t, read, optional\n                            handle for credentials\
    \ claimed.  Supply\n                            GSS_C_NO_CREDENTIAL to use default\n\
    \                            credentials.\n      context_handle    gss_ctx_id_t,\
    \ read/modify\n                        context handle for new context.  Supply\n\
    \                        GSS_C_NO_CONTEXT for first call; use value\n        \
    \                returned by first call in continuation calls.\n      target_name\
    \       gss_name_t, read\n                        Name of target\n      mech_type\
    \         OID, read, optional\n                        Object ID of desired mechanism.\
    \ Supply\n                        GSS_C_NULL_OID to obtain an implementation\n\
    \                        specific default\n      req_flags         bit-mask, read\n\
    \                        Contains four independent flags, each of\n          \
    \              which requests that the context support a\n                   \
    \     specific service option.  Symbolic\n                        names are provided\
    \ for each flag, and the\n                        symbolic names corresponding\
    \ to the required\n                        flags should be logically-ORed\n  \
    \                      together to form the bit-mask value.  The\n           \
    \             flags are:\n                        GSS_C_DELEG_FLAG\n         \
    \                     True - Delegate credentials to remote peer\n           \
    \                   False - Don't delegate\n                        GSS_C_MUTUAL_FLAG\n\
    \                              True - Request that remote peer\n             \
    \                        authenticate itself\n                              False\
    \ - Authenticate self to remote peer\n                                      only\n\
    \                        GSS_C_REPLAY_FLAG\n                              True\
    \ - Enable replay detection for signed\n                                     or\
    \ sealed messages\n                              False - Don't attempt to detect\n\
    \                                      replayed messages\n                   \
    \     GSS_C_SEQUENCE_FLAG\n                              True - Enable detection\
    \ of out-of-sequence\n                                     signed or sealed messages\n\
    \                              False - Don't attempt to detect\n             \
    \                         out-of-sequence messages\n      time_req          integer,\
    \ read\n                        Desired number of seconds for which context\n\
    \                        should remain valid.  Supply 0 to request a\n       \
    \                 default validity period.\n      input_chan_bindings     channel\
    \ bindings, read\n                              Application-specified bindings.\
    \  Allows\n                              application to securely bind channel\n\
    \                              identification information to the security\n  \
    \                            context.\n      input_token       buffer, opaque,\
    \ read, optional (see text)\n                        Token received from peer\
    \ application.\n                        Supply GSS_C_NO_BUFFER on initial call.\n\
    \      actual_mech_type  OID, modify\n                        actual mechanism\
    \ used.\n      output_token      buffer, opaque, modify\n                    \
    \    token to be sent to peer application.  If\n                        the length\
    \ field of the returned buffer is\n                        zero, no token need\
    \ be sent to the peer\n                        application.\n      ret_flags \
    \        bit-mask, modify\n                        Contains six independent flags,\
    \ each of which\n                        indicates that the context supports a\
    \ specific\n                        service option.  Symbolic names are provided\n\
    \                        for each flag, and the symbolic names\n             \
    \           corresponding to the required flags should be\n                  \
    \      logically-ANDed with the ret_flags value to test\n                    \
    \    whether a given option is supported by the\n                        context.\
    \  The flags are:\n                        GSS_C_DELEG_FLAG\n                \
    \              True - Credentials were delegated to\n                        \
    \             the remote peer\n                              False - No credentials\
    \ were delegated\n                        GSS_C_MUTUAL_FLAG\n                \
    \              True - Remote peer has been asked to\n                        \
    \             authenticated itself\n                              False - Remote\
    \ peer has not been asked to\n                                      authenticate\
    \ itself\n                        GSS_C_REPLAY_FLAG\n                        \
    \      True - replay of signed or sealed messages\n                          \
    \           will be detected\n                              False - replayed messages\
    \ will not be\n                                      detected\n              \
    \          GSS_C_SEQUENCE_FLAG\n                              True - out-of-sequence\
    \ signed or sealed\n                                     messages will be detected\n\
    \                              False - out-of-sequence messages will not\n   \
    \                                   be detected\n                        GSS_C_CONF_FLAG\n\
    \                              True - Confidentiality service may be\n       \
    \                              invoked by calling seal routine\n             \
    \                 False - No confidentiality service (via\n                  \
    \                    seal) available. seal will provide\n                    \
    \                  message encapsulation, data-origin\n                      \
    \                authentication and integrity\n                              \
    \        services only.\n                        GSS_C_INTEG_FLAG\n          \
    \                    True - Integrity service may be invoked by\n            \
    \                         calling either gss_sign or gss_seal\n              \
    \                       routines.\n                              False - Per-message\
    \ integrity service\n                                      unavailable.\n    \
    \  time_rec          integer, modify, optional\n                        number\
    \ of seconds for which the context\n                        will remain valid.\
    \ If the implementation does\n                        not support credential expiration,\
    \ the value\n                        GSS_C_INDEFINITE will be returned.  Specify\n\
    \                        NULL if not required.\n      minor_status      integer,\
    \ modify\n                        Mechanism specific status code.\n   Function\
    \ value:\n   GSS status code:\n   GSS_S_COMPLETE    Successful completion\n  \
    \ GSS_S_CONTINUE_NEEDED Indicates that a token from the peer\n               \
    \      application is required to complete thecontext, and\n                 \
    \    that gss_init_sec_context must be called again with\n                   \
    \  that token.\n   GSS_S_DEFECTIVE_TOKEN Indicates that consistency checks performed\
    \ on\n                     the input_token failed\n   GSS_S_DEFECTIVE_CREDENTIAL\
    \ Indicates that consistency checks\n                     performed on the credential\
    \ failed.\n   GSS_S_NO_CRED     The supplied credentials were not valid for context\n\
    \                     initiation, or the credential handle did not\n         \
    \            reference any credentials.\n   GSS_S_CREDENTIALS_EXPIRED The referenced\
    \ credentials have expired\n   GSS_S_BAD_BINDINGS The input_token contains different\
    \ channel\n                     bindings to those specified via the\n        \
    \             input_chan_bindings parameter\n   GSS_S_BAD_SIG     The input_token\
    \ contains an invalid signature, or a\n                     signature that could\
    \ not be verified\n   GSS_S_OLD_TOKEN   The input_token was too old.  This is\
    \ a fatal error\n                     during context establishment\n   GSS_S_DUPLICATE_TOKEN\
    \ The input_token is valid, but is a duplicate of\n                     a token\
    \ already processed.  This is a fatal error\n                     during context\
    \ establishment.\n   GSS_S_NO_CONTEXT  Indicates that the supplied context handle\
    \ did not\n                     refer to a valid context\n   GSS_S_BAD_NAMETYPE\
    \ The provided target_name parameter contained an\n                     invalid\
    \ or unsupported type of name\n   GSS_S_BAD_NAME    The provided target_name parameter\
    \ was ill-formed.\n   GSS_S_FAILURE     Failure.  See minor_status for more information\n"
- title: 3.4. gss_accept_sec_context
  contents:
  - "3.4. gss_accept_sec_context\n      OM_uint32  gss_accept_sec_context (\n    \
    \                 OM_uint32 *     minor_status,\n                     gss_ctx_id_t\
    \ *  context_handle,\n                     gss_cred_id_t   verifier_cred_handle,\n\
    \                     gss_buffer_t    input_token_buffer\n                   \
    \  gss_channel_bindings_t\n                                     input_chan_bindings,\n\
    \                     gss_name_t *    src_name,\n                     gss_OID\
    \ *       mech_type,\n                     gss_buffer_t    output_token,\n   \
    \                  int *           ret_flags,\n                     OM_uint32\
    \ *     time_rec,\n                     gss_cred_id_t * delegated_cred_handle)\n\
    \   Purpose:\n   Allows a remotely initiated security context between the application\n\
    \   and a remote peer to be established.  The routine may return a\n   output_token\
    \ which should be transferred to the peer application,\n   where the peer application\
    \ will present it to gss_init_sec_context.\n   If no token need be sent, gss_accept_sec_context\
    \ will indicate this\n   by setting the length field of the output_token argument\
    \ to zero.  To\n   complete the context establishment, one or more reply tokens\
    \ may be\n   required from the peer application; if so, gss_accept_sec_context\n\
    \   will return a status flag of GSS_S_CONTINUE_NEEDED, in which case it\n   should\
    \ be called again when the reply token is received from the peer\n   application,\
    \ passing the token to gss_accept_sec_context via the\n   input_token parameters.\n\
    \   The values returned via the src_name, ret_flags, time_rec, and\n   delegated_cred_handle\
    \ parameters are not defined unless the routine\n   returns GSS_S_COMPLETE.\n\
    \   Parameters:\n      context_handle    gss_ctx_id_t, read/modify\n         \
    \               context handle for new context.  Supply\n                    \
    \    GSS_C_NO_CONTEXT for first call; use value\n                        returned\
    \ in subsequent calls.\n      verifier_cred_handle    gss_cred_id_t, read, optional\n\
    \                              Credential handle claimed by context\n      acceptor.\n\
    \                              Specify GSS_C_NO_CREDENTIAL to use default\n  \
    \                            credentials.  If GSS_C_NO_CREDENTIAL is\n       \
    \                       specified, but the caller has no default\n           \
    \                   credentials established, an\n                            \
    \  implementation-defined default credential\n                              may\
    \ be used.\n      input_token_buffer      buffer, opaque, read\n             \
    \                 token obtained from remote application\n      input_chan_bindings\
    \     channel bindings, read\n                              Application-specified\
    \ bindings.  Allows\n                              application to securely bind\
    \ channel\n                              identification information to the security\n\
    \                              context.\n      src_name          gss_name_t, modify,\
    \ optional\n                        Authenticated name of context initiator.\n\
    \                        After use, this name should be deallocated by\n     \
    \                   passing it to gss_release_name.  If not required,\n      \
    \                  specify NULL.\n      mech_type         Object ID, modify\n\
    \                        Security mechanism used.  The returned\n            \
    \            OID value will be a pointer into static\n                       \
    \ storage, and should be treated as read-only\n                        by the\
    \ caller.\n      output_token      buffer, opaque, modify\n                  \
    \      Token to be passed to peer application. If the\n                      \
    \  length field of the returned token buffer is 0,\n                        then\
    \ no token need be passed to the peer\n                        application.\n\
    \      ret_flags         bit-mask, modify\n                        Contains six\
    \ independent flags, each of\n                        which indicates that the\
    \ context supports a\n                        specific service option.  Symbolic\
    \ names are\n                        provided for each flag, and the symbolic\
    \ names\n                        corresponding to the required flags\n       \
    \                 should be logically-ANDed with the ret_flags\n             \
    \           value to test whether a given option is\n                        supported\
    \ by the context.  The flags are:\n                        GSS_C_DELEG_FLAG\n\
    \                              True - Delegated credentials are available\n  \
    \                                   via the delegated_cred_handle\n          \
    \                           parameter\n                              False - No\
    \ credentials were delegated\n                        GSS_C_MUTUAL_FLAG\n    \
    \                          True - Remote peer asked for mutual\n             \
    \                        authentication\n                              False -\
    \ Remote peer did not ask for mutual\n                                      authentication\n\
    \                        GSS_C_REPLAY_FLAG\n                              True\
    \ - replay of signed or sealed messages\n                                    \
    \ will be detected\n                              False - replayed messages will\
    \ not be\n                                      detected\n                   \
    \     GSS_C_SEQUENCE_FLAG\n                              True - out-of-sequence\
    \ signed or sealed\n                                     messages will be detected\n\
    \                              False - out-of-sequence messages will not\n   \
    \                                   be detected\n                        GSS_C_CONF_FLAG\n\
    \                              True - Confidentiality service may be\n       \
    \                              invoked by calling seal routine\n             \
    \                 False - No confidentiality service (via\n                  \
    \                    seal) available. seal will\n                            \
    \          provide message encapsulation,\n                                  \
    \    data-origin authentication and\n                                      integrity\
    \ services only.\n                        GSS_C_INTEG_FLAG\n                 \
    \             True - Integrity service may be invoked\n                      \
    \               by calling either gss_sign or\n                              \
    \       gss_seal routines.\n                              False - Per-message\
    \ integrity service\n                                      unavailable.\n    \
    \  time_rec          integer, modify, optional\n                        number\
    \ of seconds for which the context\n                        will remain valid.\
    \ Specify NULL if not required.\n      delegated_cred_handle\n               \
    \         gss_cred_id_t, modify\n                        credential handle for\
    \ credentials received from\n                        context initiator.  Only\
    \ valid if deleg_flag in\n                        ret_flags is true.\n      minor_status\
    \      integer, modify\n                        Mechanism specific status code.\n\
    \   Function value:\n      GSS status code:\n      GSS_S_COMPLETE    Successful\
    \ completion\n      GSS_S_CONTINUE_NEEDED Indicates that a token from the peer\n\
    \                        application is required to complete the context,\n  \
    \                      and that gss_accept_sec_context must be called\n      \
    \                  again with that token.\n      GSS_S_DEFECTIVE_TOKEN Indicates\
    \ that consistency checks\n                        performed on the input_token\
    \ failed.\n      GSS_S_DEFECTIVE_CREDENTIAL Indicates that consistency checks\n\
    \                        performed on the credential failed.\n      GSS_S_NO_CRED\
    \ The supplied credentials were not valid for\n                        context\
    \ acceptance, or the credential handle\n                        did not reference\
    \ any credentials.\n      GSS_S_CREDENTIALS_EXPIRED The referenced credentials\
    \ have\n                        expired.\n      GSS_S_BAD_BINDINGS The input_token\
    \ contains different channel\n                        bindings to those specified\
    \ via the\n                        input_chan_bindings parameter.\n      GSS_S_NO_CONTEXT\
    \ Indicates that the supplied context handle did\n                       not refer\
    \ to a valid context.\n      GSS_S_BAD_SIG    The input_token contains an invalid\
    \ signature.\n      GSS_S_OLD_TOKEN   The input_token was too old.  This is a\
    \ fatal\n                        error during context establishment.\n      GSS_S_DUPLICATE_TOKEN\
    \ The input_token is valid, but is a\n                        duplicate of a token\
    \ already processed.  This\n                        is a fatal error during context\
    \ establishment.\n      GSS_S_FAILURE     Failure.  See minor_status for more\
    \ information.\n"
- title: 3.5. gss_process_context_token
  contents:
  - "3.5. gss_process_context_token\n      OM_uint32  gss_process_context_token (\n\
    \                     OM_uint32 *     minor_status,\n                     gss_ctx_id_t\
    \    context_handle,\n                     gss_buffer_t    token_buffer)\n   Purpose:\n\
    \   Provides a way to pass a token to the security service.  Usually,\n   tokens\
    \ are associated either with context establishment (when they\n   would be passed\
    \ to gss_init_sec_context or gss_accept_sec_context) or\n   with per-message security\
    \ service (when they would be passed to\n   gss_verify or gss_unseal).  Occasionally,\
    \ tokens may be received at\n   other times, and gss_process_context_token allows\
    \ such tokens to be\n   passed to the underlying security service for processing.\
    \  At\n   present, such additional tokens may only be generated by\n   gss_delete_sec_context.\
    \  GSSAPI implementation may use this service\n   to implement deletion of the\
    \ security context.\n   Parameters:\n      context_handle    gss_ctx_id_t, read\n\
    \                        context handle of context on which token is to\n    \
    \                    be processed\n      token_buffer      buffer, opaque, read\n\
    \                        pointer to first byte of token to process\n      minor_status\
    \      integer, modify\n                        Implementation specific status\
    \ code.\n   Function value:\n      GSS status code:\n      GSS_S_COMPLETE    Successful\
    \ completion\n      GSS_S_DEFECTIVE_TOKEN Indicates that consistency checks\n\
    \                        performed on the token failed\n      GSS_S_FAILURE  \
    \   Failure.  See minor_status for more information\n      GSS_S_NO_CONTEXT The\
    \ context_handle did not refer to a valid\n                       context\n"
- title: 3.6. gss_delete_sec_context
  contents:
  - "3.6. gss_delete_sec_context\n      OM_uint32  gss_delete_sec_context (\n    \
    \                 OM_uint32 *     minor_status,\n                     gss_ctx_id_t\
    \ *  context_handle,\n                     gss_buffer_t    output_token)\n   Purpose:\n\
    \   Delete a security context.  gss_delete_sec_context will delete the\n   local\
    \ data structures associated with the specified security context,\n   and generate\
    \ an output_token, which when passed to the peer\n   gss_process_context_token\
    \ will instruct it to do likewise.  No\n   further security services may be obtained\
    \ using the context specified\n   by context_handle.\n   Parameters:\n      minor_status\
    \      integer, modify\n                        Mechanism specific status code.\n\
    \      context_handle    gss_ctx_id_t, modify\n                        context\
    \ handle identifying context to delete.\n      output_token      buffer, opaque,\
    \ modify\n                        token to be sent to remote application to\n\
    \                        instruct it to also delete the context\n   Function value:\n\
    \      GSS status code:\n      GSS_S_COMPLETE    Successful completion\n     \
    \ GSS_S_FAILURE     Failure, see minor_status for more information\n      GSS_S_NO_CONTEXT\
    \  No valid context was supplied\n"
- title: 3.7. gss_context_time
  contents:
  - "3.7. gss_context_time\n      OM_uint32  gss_context_time (\n                \
    \     OM_uint32 *     minor_status,\n                     gss_ctx_id_t    context_handle,\n\
    \                     OM_uint32 *     time_rec)\n   Purpose:\n   Determines the\
    \ number of seconds for which the specified context will\n   remain valid.\n \
    \     Parameters:\n      minor_status      integer, modify\n                 \
    \       Implementation specific status code.\n      context_handle    gss_ctx_id_t,\
    \ read\n                        Identifies the context to be interrogated.\n \
    \     time_rec          integer, modify\n                        Number of seconds\
    \ that the context will remain\n                        valid.  If the context\
    \ has already expired,\n                        zero will be returned.\n   Function\
    \ value:\n      GSS status code:\n      GSS_S_COMPLETE    Successful completion\n\
    \      GSS_S_CONTEXT_EXPIRED The context has already expired\n      GSS_S_CREDENTIALS_EXPIRED\
    \ The context is recognized, but\n                        associated credentials\
    \ have expired\n      GSS_S_NO_CONTEXT The context_handle parameter did not identify\
    \ a\n                        valid context\n"
- title: 3.8. gss_sign
  contents:
  - "3.8. gss_sign\n      OM_uint32  gss_sign (\n                     OM_uint32 *\
    \     minor_status,\n                     gss_ctx_id_t    context_handle,\n  \
    \                   int             qop_req,\n                     gss_buffer_t\
    \    message_buffer,\n                     gss_buffer_t    msg_token)\n   Purpose:\n\
    \   Generates a cryptographic signature for the supplied message, and\n   places\
    \ the signature in a token for transfer to the peer application.\n   The qop_req\
    \ parameter allows a choice between several cryptographic\n   algorithms, if supported\
    \ by the chosen mechanism.\n   Parameters:\n      minor_status      integer, modify\n\
    \                        Implementation specific status code.\n      context_handle\
    \    gss_ctx_id_t, read\n                        identifies the context on which\
    \ the message\n                        will be sent\n      qop_req           integer,\
    \ read, optional\n                        Specifies requested quality of protection.\n\
    \                        Callers are encouraged, on portability grounds,\n   \
    \                     to accept the default quality of protection\n          \
    \              offered by the chosen mechanism, which may be\n               \
    \         requested by specifying GSS_C_QOP_DEFAULT for\n                    \
    \    this parameter.  If an unsupported protection\n                        strength\
    \ is requested, gss_sign will return a\n                        major_status of\
    \ GSS_S_FAILURE.\n      message_buffer    buffer, opaque, read\n             \
    \           message to be signed\n      msg_token         buffer, opaque, modify\n\
    \                        buffer to receive token\n   Function value:\n      GSS\
    \ status code:\n      GSS_S_COMPLETE    Successful completion\n      GSS_S_CONTEXT_EXPIRED\
    \ The context has already expired\n      GSS_S_CREDENTIALS_EXPIRED The context\
    \ is recognized, but\n                        associated credentials have expired\n\
    \      GSS_S_NO_CONTEXT  The context_handle parameter did not identify a\n   \
    \                     valid context\n      GSS_S_FAILURE     Failure. See minor_status\
    \ for more information.\n"
- title: 3.9. gss_verify
  contents:
  - "3.9. gss_verify\n      OM_uint32  gss_verify (\n                     OM_uint32\
    \ *     minor_status,\n                     gss_ctx_id_t    context_handle,\n\
    \                     gss_buffer_t    message_buffer,\n                     gss_buffer_t\
    \    token_buffer,\n                     int *           qop_state)\n   Purpose:\n\
    \   Verifies that a cryptographic signature, contained in the token\n   parameter,\
    \ fits the supplied message.  The qop_state parameter allows\n   a message recipient\
    \ to determine the strength of protection that was\n   applied to the message.\n\
    \   Parameters:\n      minor_status      integer, modify\n                   \
    \     Mechanism specific status code.\n      context_handle    gss_ctx_id_t, read\n\
    \                        identifies the context on which the message\n       \
    \                 arrived\n      message_buffer    buffer, opaque, read\n    \
    \                    message to be verified\n      token_buffer      buffer, opaque,\
    \ read\n                        token associated with message\n      qop_state\
    \         integer, modify\n                        quality of protection gained\
    \ from signature\n   Function value:\n      GSS status code:\n      GSS_S_COMPLETE\
    \    Successful completion\n      GSS_S_DEFECTIVE_TOKEN The token failed consistency\
    \ checks\n      GSS_S_BAD_SIG     The signature was incorrect\n      GSS_S_DUPLICATE_TOKEN\
    \ The token was valid, and contained a correct\n                        signature\
    \ for the message, but it had already\n                        been processed\n\
    \      GSS_S_OLD_TOKEN   The token was valid, and contained a correct\n      \
    \                  signature for the message, but it is too old\n      GSS_S_UNSEQ_TOKEN\
    \ The token was valid, and contained a correct\n                        signature\
    \ for the message, but has been\n                        verified out of sequence;\
    \ an earlier token has\n                        been signed or sealed by the remote\n\
    \                        application, but not yet been processed\n           \
    \             locally.\n      GSS_S_CONTEXT_EXPIRED The context has already expired\n\
    \      GSS_S_CREDENTIALS_EXPIRED The context is recognized, but\n            \
    \            associated credentials have expired\n      GSS_S_NO_CONTEXT  The\
    \ context_handle parameter did not identify a\n                        valid context\n\
    \      GSS_S_FAILURE     Failure.  See minor_status for more information.\n"
- title: 3.10. gss_seal
  contents:
  - "3.10. gss_seal\n      OM_uint32  gss_seal (\n                     OM_uint32 *\
    \     minor_status,\n                     gss_ctx_id_t    context_handle,\n  \
    \                   int             conf_req_flag,\n                     int \
    \            qop_req\n                     gss_buffer_t    input_message_buffer,\n\
    \                     int *           conf_state,\n                     gss_buffer_t\
    \    output_message_buffer)\n   Purpose:\n   Cryptographically signs and optionally\
    \ encrypts the specified\n   input_message.  The output_message contains both\
    \ the signature and\n   the message.  The qop_req parameter allows a choice between\
    \ several\n   cryptographic algorithms, if supported by the chosen mechanism.\n\
    \   Parameters:\n      minor_status      integer, modify\n                   \
    \     Mechanism specific status code.\n      context_handle    gss_ctx_id_t, read\n\
    \                        identifies the context on which the message\n       \
    \                 will be sent\n      conf_req_flag     boolean, read\n      \
    \                  True - Both confidentiality and integrity\n               \
    \                services are requested\n                        False - Only\
    \ integrity service is requested\n      qop_req           integer, read, optional\n\
    \                        Specifies required quality of protection.  A\n      \
    \                  mechanism-specific default may be requested by\n          \
    \              setting qop_req to GSS_C_QOP_DEFAULT.  If an\n                \
    \        unsupported protection strength is requested,\n                     \
    \   gss_seal will return a major_status of\n                        GSS_S_FAILURE.\n\
    \      input_message_buffer   buffer, opaque, read\n                         \
    \    message to be sealed\n      conf_state        boolean, modify\n         \
    \               True - Confidentiality, data origin\n                        \
    \       authentication and integrity services\n                              \
    \ have been applied\n                        False - Integrity and data origin\
    \ services only\n                                has been applied.\n      output_message_buffer\
    \  buffer, opaque, modify\n                             buffer to receive sealed\
    \ message\n   Function value:\n      GSS status code:\n      GSS_S_COMPLETE  \
    \  Successful completion\n      GSS_S_CONTEXT_EXPIRED The context has already\
    \ expired\n      GSS_S_CREDENTIALS_EXPIRED The context is recognized, but\n  \
    \                      associated credentials have expired\n      GSS_S_NO_CONTEXT\
    \  The context_handle parameter did not identify a\n                        valid\
    \ context\n      GSS_S_FAILURE     Failure.  See minor_status for more information.\n"
- title: 3.11. gss_unseal
  contents:
  - "3.11. gss_unseal\n      OM_uint32  gss_unseal (\n                     OM_uint32\
    \ *     minor_status,\n                     gss_ctx_id_t    context_handle,\n\
    \                     gss_buffer_t    input_message_buffer,\n                \
    \     gss_buffer_t    output_message_buffer,\n                     int *     \
    \      conf_state,\n                     int *           qop_state)\n   Purpose:\n\
    \   Converts a previously sealed message back to a usable form, verifying\n  \
    \ the embedded signature.  The conf_state parameter indicates whether\n   the\
    \ message was encrypted; the qop_state parameter indicates the\n   strength of\
    \ protection that was used to provide the confidentiality\n   and integrity services.\n\
    \   Parameters:\n      minor_status      integer, modify\n                   \
    \     Mechanism specific status code.\n      context_handle    gss_ctx_id_t, read\n\
    \                        identifies the context on which the message\n       \
    \                 arrived\n      input_message_buffer   buffer, opaque, read\n\
    \                             sealed message\n      output_message_buffer  buffer,\
    \ opaque, modify\n                             buffer to receive unsealed message\n\
    \      conf_state        boolean, modify\n                        True - Confidentiality\
    \ and integrity protection\n                               were used\n       \
    \                 False - Inteegrity service only was used\n      qop_state  \
    \       integer, modify\n                        quality of protection gained\
    \ from signature\n   Function value:\n      GSS status code:\n      GSS_S_COMPLETE\
    \    Successful completion\n      GSS_S_DEFECTIVE_TOKEN The token failed consistency\
    \ checks\n      GSS_S_BAD_SIG     The signature was incorrect\n      GSS_S_DUPLICATE_TOKEN\
    \ The token was valid, and contained a\n                        correct signature\
    \ for the message, but it had\n                        already been processed\n\
    \      GSS_S_OLD_TOKEN The token was valid, and contained a correct\n        \
    \                signature for the message, but it is too old\n      GSS_S_UNSEQ_TOKEN\
    \ The token was valid, and contained a correct\n                        signature\
    \ for the message, but has been\n                        verified out of sequence;\
    \ an earlier token has\n                        been signed or sealed by the remote\n\
    \                        application, but not yet been processed\n           \
    \             locally.\n      GSS_S_CONTEXT_EXPIRED The context has already expired\n\
    \      GSS_S_CREDENTIALS_EXPIRED The context is recognized, but\n            \
    \            associated credentials have expired\n      GSS_S_NO_CONTEXT  The\
    \ context_handle parameter did not identify a\n                        valid context\n\
    \      GSS_S_FAILURE     Failure.  See minor_status for more information.\n"
- title: 3.12. gss_display_status
  contents:
  - "3.12. gss_display_status\n      OM_uint32  gss_display_status (\n           \
    \          OM_uint32 *     minor_status,\n                     int           \
    \  status_value,\n                     int             status_type,\n        \
    \             gss_OID         mech_type,\n                     int *         \
    \  message_context,\n                     gss_buffer_t    status_string)\n   Purpose:\n\
    \   Allows an application to obtain a textual representation of a GSSAPI\n   status\
    \ code, for display to the user or for logging purposes.  Since\n   some status\
    \ values may indicate multiple errors, applications may\n   need to call gss_display_status\
    \ multiple times, each call generating\n   a single text string.  The message_context\
    \ parameter is used to\n   indicate which error message should be extracted from\
    \ a given\n   status_value; message_context should be initialized to 0, and\n\
    \   gss_display_status will return a non-zero value if there are further\n   messages\
    \ to extract.\n   Parameters:\n      minor_status      integer, modify\n     \
    \                   Mechanism specific status code.\n      status_value      integer,\
    \ read\n                        Status value to be converted\n      status_type\
    \       integer, read\n                        GSS_C_GSS_CODE - status_value is\
    \ a GSS status\n                                         code\n              \
    \          GSS_C_MECH_CODE - status_value is a mechanism\n                   \
    \                       status code\n      mech_type         Object ID, read,\
    \ optional\n                        Underlying mechanism (used to interpret a\n\
    \                        minor status value) Supply GSS_C_NULL_OID to\n      \
    \                  obtain the system default.\n      message_context   integer,\
    \ read/modify\n                        Should be initialized to zero by caller\n\
    \                        on first call.  If further messages are\n           \
    \             contained in the status_value parameter,\n                     \
    \   message_context will be non-zero on return,\n                        and this\
    \ value should be passed back to\n                        subsequent calls, along\
    \ with the same\n                        status_value, status_type and mech_type\n\
    \                        parameters.\n      status_string     buffer, character\
    \ string, modify\n                        textual interpretation of the status_value\n\
    \   Function value:\n      GSS status code:\n      GSS_S_COMPLETE    Successful\
    \ completion\n      GSS_S_BAD_MECH    Indicates that translation in accordance\
    \ with\n                        an unsupported mechanism type was requested\n\
    \      GSS_S_BAD_STATUS The status value was not recognized, or the\n        \
    \                status type was neither GSS_C_GSS_CODE nor\n                \
    \        GSS_C_MECH_CODE.\n"
- title: 3.13. gss_indicate_mechs
  contents:
  - "3.13. gss_indicate_mechs\n      OM_uint32  gss_indicate_mechs (\n           \
    \          OM_uint32 *     minor_status,\n                     gss_OID_set * \
    \  mech_set)\n   Purpose:\n         Allows an application to determine which underlying\
    \ security\n         mechanisms are available.\n   Parameters:\n      minor_status\
    \      integer, modify\n                        Mechanism specific status code.\n\
    \      mech_set          set of Object IDs, modify\n                        set\
    \ of implementation-supported mechanisms.\n                        The returned\
    \ gss_OID_set value will be a\n                        pointer into static storage,\
    \ and should be\n                        treated as read-only by the caller.\n\
    \   Function value:\n      GSS status code:\n      GSS_S_COMPLETE    Successful\
    \ completion\n"
- title: 3.14. gss_compare_name
  contents:
  - "3.14. gss_compare_name\n      OM_uint32  gss_compare_name (\n               \
    \      OM_uint32 *     minor_status,\n                     gss_name_t      name1,\n\
    \                     gss_name_t      name2,\n                     int *     \
    \      name_equal)\n   Purpose:\n   Allows an application to compare two internal-form\
    \ names to determine\n   whether they refer to the same entity.\n   Parameters:\n\
    \      minor_status      integer, modify\n                        Mechanism specific\
    \ status code.\n      name1             gss_name_t, read\n                   \
    \     internal-form  name\n      name2             gss_name_t, read\n        \
    \                internal-form  name\n      name_equal        boolean, modify\n\
    \                        True - names refer to same entity\n                 \
    \       False - names refer to different entities\n                          \
    \      (strictly, the names are not known to\n                               \
    \ refer to the same identity).\n   Function value:\n      GSS status code:\n \
    \     GSS_S_COMPLETE    Successful completion\n      GSS_S_BAD_NAMETYPE The type\
    \ contained within either name1 or\n                        name2 was unrecognized,\
    \ or the names were of\n                        incomparable types.\n      GSS_S_BAD_NAME\
    \    One or both of name1 or name2 was ill-formed\n"
- title: 3.15. gss_display_name
  contents:
  - "3.15. gss_display_name\n      OM_uint32  gss_display_name (\n               \
    \      OM_uint32 *     minor_status,\n                     gss_name_t      input_name,\n\
    \                     gss_buffer_t    output_name_buffer,\n                  \
    \   gss_OID *       output_name_type)\n   Purpose:\n   Allows an application to\
    \ obtain a textual representation of an opaque\n   internal-form  name for display\
    \ purposes.  The syntax of a printable\n   name is defined by the GSSAPI implementation.\n\
    \   Parameters:\n      minor_status      integer, modify\n                   \
    \     Mechanism specific status code.\n      input_name        gss_name_t, read\n\
    \                        name to be displayed\n      output_name_buffer   buffer,\
    \ character-string, modify\n                           buffer to receive textual\
    \ name string\n      output_name_type  Object ID, modify\n                   \
    \     The type of the returned name.  The returned\n                        gss_OID\
    \ will be a pointer into static storage,\n                        and should be\
    \ treated as read-only by the caller\n   Function value:\n      GSS status code:\n\
    \      GSS_S_COMPLETE    Successful completion\n      GSS_S_BAD_NAMETYPE The type\
    \ of input_name was not recognized\n      GSS_S_BAD_NAME    input_name was ill-formed\n"
- title: 3.16. gss_import_name
  contents:
  - "3.16. gss_import_name\n      OM_uint32 gss_import_name (\n                  \
    \  OM_uint32 *     minor_status,\n                    gss_buffer_t    input_name_buffer,\n\
    \                    gss_OID         input_name_type,\n                    gss_name_t\
    \ *    output_name)\n   Purpose:\n   Convert a printable name to internal form.\n\
    \   Parameters:\n      minor_status      integer, modify\n                   \
    \     Mechanism specific status code\n      input_name_buffer    buffer, character-string,\
    \ read\n                           buffer containing printable name to convert\n\
    \      input_name_type   Object ID, read, optional\n                        Object\
    \ Id specifying type of printable\n                        name.  Applications\
    \ may specify either\n                        GSS_C_NULL_OID to use a local system-specific\n\
    \                        printable syntax, or an OID registered by the\n     \
    \                   GSSAPI implementation to name a particular\n             \
    \           namespace.\n      output_name       gss_name_t, modify\n         \
    \               returned name in internal form\n   Function value:\n      GSS\
    \ status code\n      GSS_S_COMPLETE    Successful completion\n      GSS_S_BAD_NAMETYPE\
    \ The input_name_type was unrecognized\n      GSS_S_BAD_NAME    The input_name\
    \ parameter could not be\n                        interpreted as a name of the\
    \ specified type\n"
- title: 3.17. gss_release_name
  contents:
  - "3.17. gss_release_name\n      OM_uint32 gss_release_name (\n                \
    \    OM_uint32 *     minor_status,\n                    gss_name_t *    name)\n\
    \   Purpose:\n   Free GSSAPI-allocated storage associated with an internal form\
    \ name.\n   Parameters:\n      minor_status      integer, modify\n           \
    \             Mechanism specific status code\n      name              gss_name_t,\
    \ modify\n                        The name to be deleted\n   Function value:\n\
    \      GSS status code\n      GSS_S_COMPLETE    Successful completion\n      GSS_S_BAD_NAME\
    \    The name parameter did not contain a valid name\n"
- title: 3.18. gss_release_buffer
  contents:
  - "3.18. gss_release_buffer\n      OM_uint32 gss_release_buffer (\n            \
    \        OM_uint32 *     minor_status,\n                    gss_buffer_t    buffer)\n\
    \   Purpose:\n   Free storage associated with a buffer format name.  The storage\
    \ must\n   have been allocated by a GSSAPI routine.  In addition to freeing the\n\
    \   associated storage, the routine will zero the length field in the\n   buffer\
    \ parameter.\n   Parameters:\n      minor_status      integer, modify\n      \
    \                  Mechanism specific status code\n      buffer            buffer,\
    \ modify\n                        The storage associated with the buffer will\
    \ be\n                        deleted.  The gss_buffer_desc object will not\n\
    \                        be freed, but its length field will be zeroed.\n   Function\
    \ value:\n      GSS status code\n      GSS_S_COMPLETE    Successful completion\n"
- title: 3.19. gss_release_oid_set
  contents:
  - "3.19. gss_release_oid_set\n      OM_uint32 gss_release_oid_set (\n          \
    \          OM_uint32 *     minor_status,\n                    gss_OID_set *  \
    \ set)\n   Purpose:\n   Free storage associated with a gss_OID_set object.  The\
    \ storage must\n   have been allocated by a GSSAPI routine.\n   Parameters:\n\
    \      minor_status      integer, modify\n                        Mechanism specific\
    \ status code\n      set               Set of Object IDs, modify\n           \
    \             The storage associated with the gss_OID_set\n                  \
    \      will be deleted.\n   Function value:\n      GSS status code\n      GSS_S_COMPLETE\
    \    Successful completion\n"
- title: 3.20. gss_inquire_cred
  contents:
  - "3.20. gss_inquire_cred\n      OM_uint32 gss_inquire_cred (\n                \
    \    OM_uint32  *    minor_status,\n                    gss_cred_id_t   cred_handle,\n\
    \                    gss_name_t *    name,\n                    OM_uint32 *  \
    \   lifetime,\n                    int *           cred_usage,\n             \
    \       gss_OID_set *   mechanisms )\n   Purpose:\n   Obtains information about\
    \ a credential.  The caller must already have\n   obtained a handle that refers\
    \ to the credential.\n   Parameters:\n      minor_status      integer, modify\n\
    \                        Mechanism specific status code\n      cred_handle   \
    \    gss_cred_id_t, read\n                        A handle that refers to the\
    \ target credential.\n                        Specify GSS_C_NO_CREDENTIAL to inquire\
    \ about\n                        the default credential.\n      name         \
    \     gss_name_t, modify\n                        The name whose identity the\
    \ credential asserts.\n                        Specify NULL if not required.\n\
    \      lifetime          Integer, modify\n                        The number of\
    \ seconds for which the credential\n                        will remain valid.\
    \  If the credential has\n                        expired, this parameter will\
    \ be set to zero.\n                        If the implementation does not support\n\
    \                        credential expiration, the value\n                  \
    \      GSS_C_INDEFINITE will be returned.  Specify\n                        NULL\
    \ if not required.\n      cred_usage        Integer, modify\n                \
    \        How the credential may be used.  One of the\n                       \
    \ following:\n                           GSS_C_INITIATE\n                    \
    \       GSS_C_ACCEPT\n                           GSS_C_BOTH\n                \
    \        Specify NULL if not required.\n      mechanisms        gss_OID_set, modify\n\
    \                        Set of mechanisms supported by the credential.\n    \
    \                    Specify NULL if not required.\n   Function value:\n     \
    \ GSS status code\n      GSS_S_COMPLETE    Successful completion\n      GSS_S_NO_CRED\
    \     The referenced credentials could not be\n                        accessed.\n\
    \      GSS_S_DEFECTIVE_CREDENTIAL The referenced credentials were\n          \
    \              invalid.\n      GSS_S_CREDENTIALS_EXPIRED The referenced credentials\
    \ have expired.\n                        If the lifetime parameter was not passed\
    \ as\n                        NULL, it will be set to 0.\n  #ifndef GSSAPI_H_\n\
    \  #define GSSAPI_H_\n  /*\n   * First, define the platform-dependent types.\n\
    \   */\n  typedef <platform-specific> OM_uint32;\n  typedef <platform-specific>\
    \ gss_ctx_id_t;\n  typedef <platform-specific> gss_cred_id_t;\n  typedef <platform-specific>\
    \ gss_name_t;\n  /*\n   * Note that a platform supporting the xom.h X/Open header\
    \ file\n   * may make use of that header for the definitions of OM_uint32\n  \
    \ * and the structure to which gss_OID_desc equates.\n   */\n  typedef struct\
    \ gss_OID_desc_struct {\n        OM_uint32 length;\n        void      *elements;\n\
    \  } gss_OID_desc, *gss_OID;\n  typedef struct gss_OID_set_desc_struct  {\n  \
    \      int     count;\n        gss_OID elements;\n  } gss_OID_set_desc, *gss_OID_set;\n\
    \  typedef struct gss_buffer_desc_struct {\n        size_t length;\n        void\
    \ *value;\n  } gss_buffer_desc, *gss_buffer_t;\n  typedef struct gss_channel_bindings_struct\
    \ {\n        OM_uint32 initiator_addrtype;\n        gss_buffer_desc initiator_address;\n\
    \        OM_uint32 acceptor_addrtype;\n        gss_buffer_desc acceptor_address;\n\
    \        gss_buffer_desc application_data;\n  } *gss_channel_bindings_t;\n  /*\n\
    \   * Six independent flags each of which indicates that a context\n   * supports\
    \ a specific service option.\n   */\n  #define GSS_C_DELEG_FLAG 1\n  #define GSS_C_MUTUAL_FLAG\
    \ 2\n  #define GSS_C_REPLAY_FLAG 4\n  #define GSS_C_SEQUENCE_FLAG 8\n  #define\
    \ GSS_C_CONF_FLAG 16\n  #define GSS_C_INTEG_FLAG 32\n  /*\n   * Credential usage\
    \ options\n   */\n  #define GSS_C_BOTH 0\n  #define GSS_C_INITIATE 1\n  #define\
    \ GSS_C_ACCEPT 2\n  /*\n   * Status code types for gss_display_status\n   */\n\
    \  #define GSS_C_GSS_CODE 1\n  #define GSS_C_MECH_CODE 2\n  /*\n   * The constant\
    \ definitions for channel-bindings address families\n   */\n  #define GSS_C_AF_UNSPEC\
    \     0;\n  #define GSS_C_AF_LOCAL      1;\n  #define GSS_C_AF_INET       2;\n\
    \  #define GSS_C_AF_IMPLINK    3;\n  #define GSS_C_AF_PUP        4;\n  #define\
    \ GSS_C_AF_CHAOS      5;\n  #define GSS_C_AF_NS         6;\n  #define GSS_C_AF_NBS\
    \        7;\n  #define GSS_C_AF_ECMA       8;\n  #define GSS_C_AF_DATAKIT    9;\n\
    \  #define GSS_C_AF_CCITT      10;\n  #define GSS_C_AF_SNA        11;\n  #define\
    \ GSS_C_AF_DECnet     12;\n  #define GSS_C_AF_DLI        13;\n  #define GSS_C_AF_LAT\
    \        14;\n  #define GSS_C_AF_HYLINK     15;\n  #define GSS_C_AF_APPLETALK\
    \  16;\n  #define GSS_C_AF_BSC        17;\n  #define GSS_C_AF_DSS        18;\n\
    \  #define GSS_C_AF_OSI        19;\n  #define GSS_C_AF_X25        21;\n  #define\
    \ GSS_C_AF_NULLADDR   255;\n  #define GSS_C_NO_BUFFER ((gss_buffer_t) 0)\n  #define\
    \ GSS_C_NULL_OID ((gss_OID) 0)\n  #define GSS_C_NULL_OID_SET ((gss_OID_set) 0)\n\
    \  #define GSS_C_NO_CONTEXT ((gss_ctx_id_t) 0)\n  #define GSS_C_NO_CREDENTIAL\
    \ ((gss_cred_id_t) 0)\n  #define GSS_C_NO_CHANNEL_BINDINGS ((gss_channel_bindings_t)\
    \ 0)\n  #define GSS_C_EMPTY_BUFFER {0, NULL}\n  /*\n   * Define the default Quality\
    \ of Protection for per-message\n   * services.  Note that an implementation that\
    \ offers multiple\n   * levels of QOP may either reserve a value (for example\
    \ zero,\n   * as assumed here) to mean \"default protection\", or alternatively\n\
    \   * may simply equate GSS_C_QOP_DEFAULT to a specific explicit QOP\n   * value.\n\
    \   */\n  #define GSS_C_QOP_DEFAULT 0\n  /*\n   * Expiration time of 2^32-1 seconds\
    \ means infinite lifetime for a\n   * credential or security context\n   */\n\
    \  #define GSS_C_INDEFINITE 0xfffffffful\n  /* Major status codes */\n  #define\
    \ GSS_S_COMPLETE 0\n  /*\n   * Some \"helper\" definitions to make the status\
    \ code macros obvious.\n   */\n  #define GSS_C_CALLING_ERROR_OFFSET 24\n  #define\
    \ GSS_C_ROUTINE_ERROR_OFFSET 16\n  #define GSS_C_SUPPLEMENTARY_OFFSET 0\n  #define\
    \ GSS_C_CALLING_ERROR_MASK 0377ul\n  #define GSS_C_ROUTINE_ERROR_MASK 0377ul\n\
    \  #define GSS_C_SUPPLEMENTARY_MASK 0177777ul\n  /*\n   * The macros that test\
    \ status codes for error conditions\n   */\n  #define GSS_CALLING_ERROR(x) \\\n\
    \    (x & (GSS_C_CALLING_ERROR_MASK << GSS_C_CALLING_ERROR_OFFSET))\n  #define\
    \ GSS_ROUTINE_ERROR(x) \\\n    (x & (GSS_C_ROUTINE_ERROR_MASK << GSS_C_ROUTINE_ERROR_OFFSET))\n\
    \  #define GSS_SUPPLEMENTARY_INFO(x) \\\n    (x & (GSS_C_SUPPLEMENTARY_MASK <<\
    \ GSS_C_SUPPLEMENTARY_OFFSET))\n  #define GSS_ERROR(x) \\\n    ((GSS_CALLING_ERROR(x)\
    \ != 0) || (GSS_ROUTINE_ERROR(x) != 0))\n  /*\n   * Now the actual status code\
    \ definitions\n   */\n  /*\n   * Calling errors:\n   */\n  #define GSS_S_CALL_INACCESSIBLE_READ\
    \ \\\n                               (1ul << GSS_C_CALLING_ERROR_OFFSET)\n  #define\
    \ GSS_S_CALL_INACCESSIBLE_WRITE \\\n                               (2ul << GSS_C_CALLING_ERROR_OFFSET)\n\
    \  #define GSS_S_CALL_BAD_STRUCTURE \\\n                               (3ul <<\
    \ GSS_C_CALLING_ERROR_OFFSET)\n  /*\n   * Routine errors:\n   */\n  #define GSS_S_BAD_MECH\
    \ (1ul << GSS_C_ROUTINE_ERROR_OFFSET)\n  #define GSS_S_BAD_NAME (2ul << GSS_C_ROUTINE_ERROR_OFFSET)\n\
    \  #define GSS_S_BAD_NAMETYPE (3ul << GSS_C_ROUTINE_ERROR_OFFSET)\n  #define GSS_S_BAD_BINDINGS\
    \ (4ul << GSS_C_ROUTINE_ERROR_OFFSET)\n  #define GSS_S_BAD_STATUS (5ul << GSS_C_ROUTINE_ERROR_OFFSET)\n\
    \  #define GSS_S_BAD_SIG (6ul << GSS_C_ROUTINE_ERROR_OFFSET)\n  #define GSS_S_NO_CRED\
    \ (7ul << GSS_C_ROUTINE_ERROR_OFFSET)\n  #define GSS_S_NO_CONTEXT (8ul << GSS_C_ROUTINE_ERROR_OFFSET)\n\
    \  #define GSS_S_DEFECTIVE_TOKEN (9ul << GSS_C_ROUTINE_ERROR_OFFSET)\n  #define\
    \ GSS_S_DEFECTIVE_CREDENTIAL (10ul << GSS_C_ROUTINE_ERROR_OFFSET)\n  #define GSS_S_CREDENTIALS_EXPIRED\
    \ (11ul << GSS_C_ROUTINE_ERROR_OFFSET)\n  #define GSS_S_CONTEXT_EXPIRED (12ul\
    \ << GSS_C_ROUTINE_ERROR_OFFSET)\n  #define GSS_S_FAILURE (13ul << GSS_C_ROUTINE_ERROR_OFFSET)\n\
    \  /*\n   * Supplementary info bits:\n   */\n  #define GSS_S_CONTINUE_NEEDED (1ul\
    \ << (GSS_C_SUPPLEMENTARY_OFFSET + 0))\n  #define GSS_S_DUPLICATE_TOKEN (1ul <<\
    \ (GSS_C_SUPPLEMENTARY_OFFSET + 1))\n  #define GSS_S_OLD_TOKEN (1ul << (GSS_C_SUPPLEMENTARY_OFFSET\
    \ + 2))\n  #define GSS_S_UNSEQ_TOKEN (1ul << (GSS_C_SUPPLEMENTARY_OFFSET + 3))\n\
    \  /*\n   * Finally, function prototypes for the GSSAPI routines.\n   */\n  OM_uint32\
    \ gss_acquire_cred\n             (OM_uint32*,       /* minor_status */\n     \
    \         gss_name_t,       /* desired_name */\n              OM_uint32,     \
    \   /* time_req */\n              gss_OID_set,      /* desired_mechs */\n    \
    \          int,              /* cred_usage */\n              gss_cred_id_t*, \
    \  /* output_cred_handle */\n              gss_OID_set*,     /* actual_mechs */\n\
    \              OM_uint32*        /* time_rec */\n             );\n  OM_uint32\
    \ gss_release_cred,\n             (OM_uint32*,       /* minor_status */\n    \
    \          gss_cred_id_t*    /* cred_handle */\n             );\n  OM_uint32 gss_init_sec_context\n\
    \             (OM_uint32*,       /* minor_status */\n              gss_cred_id_t,\
    \    /* claimant_cred_handle */\n              gss_ctx_id_t*,    /* context_handle\
    \ */\n              gss_name_t,       /* target_name */\n              gss_OID,\
    \          /* mech_type */\n              int,              /* req_flags */\n\
    \              OM_uint32,        /* time_req */\n              gss_channel_bindings_t,\n\
    \                                /* input_chan_bindings */\n              gss_buffer_t,\
    \     /* input_token */\n              gss_OID*,         /* actual_mech_type */\n\
    \              gss_buffer_t,     /* output_token */\n              int*,     \
    \        /* ret_flags */\n              OM_uint32*        /* time_rec */\n   \
    \          );\n  OM_uint32 gss_accept_sec_context\n             (OM_uint32*, \
    \      /* minor_status */\n              gss_ctx_id_t*,    /* context_handle */\n\
    \              gss_cred_id_t,    /* verifier_cred_handle */\n              gss_buffer_t,\
    \     /* input_token_buffer */\n              gss_channel_bindings_t,\n      \
    \                          /* input_chan_bindings */\n              gss_name_t*,\
    \      /* src_name */\n              gss_OID*,         /* mech_type */\n     \
    \         gss_buffer_t,     /* output_token */\n              int*,          \
    \   /* ret_flags */\n              OM_uint32*,       /* time_rec */\n        \
    \      gss_cred_id_t*    /* delegated_cred_handle */\n             );\n  OM_uint32\
    \ gss_process_context_token\n             (OM_uint32*,       /* minor_status */\n\
    \              gss_ctx_id_t,     /* context_handle */\n              gss_buffer_t\
    \      /* token_buffer */\n             );\n  OM_uint32 gss_delete_sec_context\n\
    \             (OM_uint32*,       /* minor_status */\n              gss_ctx_id_t*,\
    \    /* context_handle */\n              gss_buffer_t      /* output_token */\n\
    \             );\n  OM_uint32 gss_context_time\n             (OM_uint32*,    \
    \   /* minor_status */\n              gss_ctx_id_t,     /* context_handle */\n\
    \              OM_uint32*        /* time_rec */\n             );\n  OM_uint32\
    \ gss_sign\n             (OM_uint32*,       /* minor_status */\n             \
    \ gss_ctx_id_t,     /* context_handle */\n              int,              /* qop_req\
    \ */\n              gss_buffer_t,     /* message_buffer */\n              gss_buffer_t\
    \      /* message_token */\n             );\n  OM_uitn32 gss_verify\n        \
    \     (OM_uint32*,       /* minor_status */\n              gss_ctx_id_t,     /*\
    \ context_handle */\n              gss_buffer_t,     /* message_buffer */\n  \
    \            gss_buffer_t,     /* token_buffer */\n              int*        \
    \      /* qop_state */\n             );\n  OM_uint32 gss_seal\n             (OM_uint32*,\
    \       /* minor_status */\n              gss_ctx_id_t,     /* context_handle\
    \ */\n              int,              /* conf_req_flag */\n              int,\
    \              /* qop_req */\n              gss_buffer_t,     /* input_message_buffer\
    \ */\n              int*,             /* conf_state */\n              gss_buffer_t\
    \      /* output_message_buffer */\n             );\n  OM_uint32 gss_unseal\n\
    \             (OM_uint32*,       /* minor_status */\n              gss_ctx_id_t,\
    \     /* context_handle */\n              gss_buffer_t,     /* input_message_buffer\
    \ */\n              gss_buffer_t,     /* output_message_buffer */\n          \
    \    int*,             /* conf_state */\n              int*              /* qop_state\
    \ */\n             );\n  OM_uint32 gss_display_status\n             (OM_uint32*,\
    \       /* minor_status */\n              OM_uint32,        /* status_value */\n\
    \              int,              /* status_type */\n              gss_OID,   \
    \       /* mech_type */\n              int*,             /* message_context */\n\
    \              gss_buffer_t      /* status_string */\n             );\n  OM_uint32\
    \ gss_indicate_mechs\n             (OM_uint32*,       /* minor_status */\n   \
    \           gss_OID_set*      /* mech_set */\n             );\n  OM_uint32 gss_compare_name\n\
    \             (OM_uint32*,       /* minor_status */\n              gss_name_t,\
    \       /* name1 */\n              gss_name_t,       /* name2 */\n           \
    \   int*              /* name_equal */\n             );\n  OM_uint32 gss_display_name,\n\
    \             (OM_uint32*,      /* minor_status */\n              gss_name_t,\
    \      /* input_name */\n              gss_buffer_t,     /* output_name_buffer\
    \ */\n              gss_OID*         /* output_name_type */\n             );\n\
    \  OM_uint32 gss_import_name\n             (OM_uint32*,       /* minor_status\
    \ */\n              gss_buffer_t,     /* input_name_buffer */\n              gss_OID,\
    \          /* input_name_type */\n              gss_name_t*       /* output_name\
    \ */\n             );\n  OM_uint32 gss_release_name\n             (OM_uint32*,\
    \       /* minor_status */\n              gss_name_t*       /* input_name */\n\
    \             );\n  OM_uint32 gss_release_buffer\n             (OM_uint32*,  \
    \     /* minor_status */\n              gss_buffer_t      /* buffer */\n     \
    \        );\n  OM_uint32 gss_release_oid_set\n             (OM_uint32*,      \
    \ /* minor_status */\n              gss_OID_set*      /* set */\n            \
    \ );\n  OM_uint32 gss_inquire_cred\n             (OM_uint32 *,      /* minor_status\
    \ */\n              gss_cred_id_t,    /* cred_handle */\n              gss_name_t\
    \ *,     /* name */\n              OM_uint32 *,      /* lifetime */\n        \
    \      int *,            /* cred_usage */\n              gss_OID_set *     /*\
    \ mechanisms */\n             );\n  #endif /* GSSAPI_H_ */\n"
- title: References
  contents:
  - "References\n   [1] Linn, J., \"Generic Security Service Application Program\n\
    \       Interface\", RFC 1508, Geer Zolot Associate, September 1993.\n   [2] \"\
    OSI Object Management API Specification, Version 2.0 t\", X.400\n       API Association\
    \ & X/Open Company Limited, August 24, 1990.\n       Specification of datatypes\
    \ and routines for manipulating\n       information objects.\n"
- title: Security Considerations
  contents:
  - "Security Considerations\n   Security issues are discussed throughout this memo.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   John Wray\n   Digital Equipment Corporation\n   550 King\
    \ Street, LKG2-2/AA6\n   Littleton, MA  01460\n   USA\n   Phone: +1-508-486-5210\n\
    \   EMail: Wray@tuxedo.enet.dec.com\n"
