- title: __initial_text__
  contents:
  - "\t     An Ethernet Address Resolution Protocol\n                            --\
    \ or --\n              Converting Network Protocol Addresses\n               \
    \    to 48.bit Ethernet Address\n                       for Transmission on\n\
    \                        Ethernet Hardware\n\t\t\t    Abstract\nThe implementation\
    \ of protocol P on a sending host S decides,\nthrough protocol P's routing mechanism,\
    \ that it wants to transmit\nto a target host T located some place on a connected\
    \ piece of\n10Mbit Ethernet cable.  To actually transmit the Ethernet packet\n\
    a 48.bit Ethernet address must be generated.  The addresses of\nhosts within protocol\
    \ P are not always compatible with the\ncorresponding Ethernet address (being\
    \ different lengths or\nvalues).  Presented here is a protocol that allows dynamic\n\
    distribution of the information needed to build tables to\ntranslate an address\
    \ A in protocol P's address space into a\n48.bit Ethernet address.\nGeneralizations\
    \ have been made which allow the protocol to be\nused for non-10Mbit Ethernet\
    \ hardware.  Some packet radio\nnetworks are examples of such hardware.\nThe protocol\
    \ proposed here is the result of a great deal of\ndiscussion with several other\
    \ people, most notably J. Noel\nChiappa, Yogen Dalal, and James E. Kulp, and helpful\
    \ comments\nfrom David Moon.\n[The purpose of this RFC is to present a method\
    \ of Converting\nProtocol Addresses (e.g., IP addresses) to Local Network\nAddresses\
    \ (e.g., Ethernet addresses).  This is a issue of general\nThis protocol was originally\
    \ designed for the DEC/Intel/Xerox\n10Mbit Ethernet.  It has been generalized\
    \ to allow it to be used\nfor other types of networks.  Much of the discussion\
    \ will be\ndirected toward the 10Mbit Ethernet.  Generalizations, where\napplicable,\
    \ will follow the Ethernet-specific discussion.\nDOD Internet Protocol will be\
    \ referred to as Internet.\nNumbers here are in the Ethernet standard, which is\
    \ high byte\nfirst.  This is the opposite of the byte addressing of machines\n\
    such as PDP-11s and VAXes.  Therefore, special care must be taken\nwith the opcode\
    \ field (ar$op) described below.\nAn agreed upon authority is needed to manage\
    \ hardware name space\nvalues (see below).  Until an official authority exists,\
    \ requests\nshould be submitted to\n\tDavid C. Plummer\n\tSymbolics, Inc.\n\t\
    243 Vassar Street\n\tCambridge, Massachusetts  02139\nAlternatively, network mail\
    \ can be sent to DCP@MIT-MC.\nThe Problem:\n------------\nThe world is a jungle\
    \ in general, and the networking game\ncontributes many animals.  At nearly every\
    \ layer of a network\narchitecture there are several potential protocols that\
    \ could be\nused.  For example, at a high level, there is TELNET and SUPDUP\n\
    for remote login.  Somewhere below that there is a reliable byte\nstream protocol,\
    \ which might be CHAOS protocol, DOD TCP, Xerox\nBSP or DECnet.  Even closer to\
    \ the hardware is the logical\ntransport layer, which might be CHAOS, DOD Internet,\
    \ Xerox PUP,\nor DECnet.  The 10Mbit Ethernet allows all of these protocols\n\
    (and more) to coexist on a single cable by means of a type field\nin the Ethernet\
    \ packet header.  However, the 10Mbit Ethernet\nrequires 48.bit addresses on the\
    \ physical cable, yet most\nprotocol addresses are not 48.bits long, nor do they\
    \ necessarily\nhave any relationship to the 48.bit Ethernet address of the\nhardware.\
    \  For example, CHAOS addresses are 16.bits, DOD Internet\nUse of the 10Mbit Ethernet\
    \ is increasing as more manufacturers\nsupply interfaces that conform to the specification\
    \ published by\nDEC, Intel and Xerox.  With this increasing availability, more\n\
    and more software is being written for these interfaces.  There\nare two alternatives:\
    \ (1) Every implementor invents his/her own\nmethod to do some form of address\
    \ resolution, or (2) every\nimplementor uses a standard so that his/her code can\
    \ be\ndistributed to other systems without need for modification.  This\nproposal\
    \ attempts to set the standard.\nDefinitions:\n------------\nDefine the following\
    \ for referring to the values put in the TYPE\nfield of the Ethernet packet header:\n\
    \tether_type$XEROX_PUP,\n\tether_type$DOD_INTERNET,\n\tether_type$CHAOS, \nand\
    \ a new one:\n\tether_type$ADDRESS_RESOLUTION.  \nAlso define the following values\
    \ (to be discussed later):\n\tares_op$REQUEST (= 1, high byte transmitted first)\
    \ and\n\tares_op$REPLY   (= 2), \nand\n\tares_hrd$Ethernet (= 1).\nPacket format:\n\
    --------------\nTo communicate mappings from <protocol, address> pairs to 48.bit\n\
    Ethernet addresses, a packet format that embodies the Address\nResolution protocol\
    \ is needed.  The format of the packet follows.\n    Ethernet transmission layer\
    \ (not necessarily accessible to\n\t the user):\n\t48.bit: Ethernet address of\
    \ destination\n\t48.bit: Ethernet address of sender\n\t16.bit: Protocol type =\
    \ ether_type$ADDRESS_RESOLUTION\n    Ethernet packet data:\n\t16.bit: (ar$hrd)\
    \ Hardware address space (e.g., Ethernet,\n\t\t\t Packet Radio Net.)\n\t16.bit:\
    \ (ar$pro) Protocol address space.  For Ethernet\n\t\t\t hardware, this is from\
    \ the set of type\n\t\t\t fields ether_typ$<protocol>.\n\t 8.bit: (ar$hln) byte\
    \ length of each hardware address\n\t 8.bit: (ar$pln) byte length of each protocol\
    \ address\n\t16.bit: (ar$op)  opcode (ares_op$REQUEST | ares_op$REPLY)\n\tnbytes:\
    \ (ar$sha) Hardware address of sender of this\n\t\t\t packet, n from the ar$hln\
    \ field.\n\tmbytes: (ar$spa) Protocol address of sender of this\n\t\t\t packet,\
    \ m from the ar$pln field.\n------------------\nAs a packet is sent down through\
    \ the network layers, routing\ndetermines the protocol address of the next hop\
    \ for the packet\nand on which piece of hardware it expects to find the station\n\
    with the immediate target protocol address.  In the case of the\n10Mbit Ethernet,\
    \ address resolution is needed and some lower\nlayer (probably the hardware driver)\
    \ must consult the Address\nResolution module (perhaps implemented in the Ethernet\
    \ support\nmodule) to convert the <protocol type, target protocol address>\npair\
    \ to a 48.bit Ethernet address.  The Address Resolution module\ntries to find\
    \ this pair in a table.  If it finds the pair, it\ngives the corresponding 48.bit\
    \ Ethernet address back to the\ncaller (hardware driver) which then transmits\
    \ the packet.  If it\ndoes not, it probably informs the caller that it is throwing\
    \ the\npacket away (on the assumption the packet will be retransmitted\nby a higher\
    \ network layer), and generates an Ethernet packet with\na type field of ether_type$ADDRESS_RESOLUTION.\
    \  The Address\nResolution module then sets the ar$hrd field to\nares_hrd$Ethernet,\
    \ ar$pro to the protocol type that is being\nresolved, ar$hln to 6 (the number\
    \ of bytes in a 48.bit Ethernet\naddress), ar$pln to the length of an address\
    \ in that protocol,\nar$op to ares_op$REQUEST, ar$sha with the 48.bit ethernet\
    \ address\nof itself, ar$spa with the protocol address of itself, and ar$tpa\n\
    with the protocol address of the machine that is trying to be\naccessed.  It does\
    \ not set ar$tha to anything in particular,\nbecause it is this value that it\
    \ is trying to determine.  It\ncould set ar$tha to the broadcast address for the\
    \ hardware (all\nones in the case of the 10Mbit Ethernet) if that makes it\nconvenient\
    \ for some aspect of the implementation.  It then causes\n-----------------\n\
    When an address resolution packet is received, the receiving\nEthernet module\
    \ gives the packet to the Address Resolution module\nwhich goes through an algorithm\
    \ similar to the following.\nNegative conditionals indicate an end of processing\
    \ and a\ndiscarding of the packet.\n?Do I have the hardware type in ar$hrd?\n\
    Yes: (almost definitely)\n  [optionally check the hardware length ar$hln]\n  ?Do\
    \ I speak the protocol in ar$pro?\n  Yes:\n    [optionally check the protocol\
    \ length ar$pln]\n    Merge_flag := false\n    If the pair <protocol type, sender\
    \ protocol address> is\n        already in my translation table, update the sender\n\
    \thardware address field of the entry with the new\n\tinformation in the packet\
    \ and set Merge_flag to true. \n    ?Am I the target protocol address?\n    Yes:\n\
    \      If Merge_flag is false, add the triplet <protocol type,\n          sender\
    \ protocol address, sender hardware address> to\n\t  the translation table.\n\
    \      ?Is the opcode ares_op$REQUEST?  (NOW look at the opcode!!)\n      Yes:\n\
    \tSwap hardware and protocol fields, putting the local\n\t    hardware and protocol\
    \ addresses in the sender fields.\n\tSet the ar$op field to ares_op$REPLY\n\t\
    Send the packet to the (new) target hardware address on\n\t    the same hardware\
    \ on which the request was received.\nNotice that the <protocol type, sender protocol\
    \ address, sender\nhardware address> triplet is merged into the table before the\n\
    opcode is looked at.  This is on the assumption that communcation\nis bidirectional;\
    \ if A has some reason to talk to B, then B will\nprobably have some reason to\
    \ talk to A.  Notice also that if an\nentry already exists for the <protocol type,\
    \ sender protocol\naddress> pair, then the new hardware address supersedes the\
    \ old\none.  Related Issues gives some motivation for this.\nGeneralization: \
    \ The ar$hrd and ar$hln fields allow this protocol\nand packet format to be used\
    \ for non-10Mbit Ethernets.  For the\n10Mbit Ethernet <ar$hrd, ar$hln> takes on\
    \ the value <1, 6>.  For\nother hardware networks, the ar$pro field may no longer\n\
    -------------------------\nPeriodic broadcasting is definitely not desired.  Imagine\
    \ 100\nworkstations on a single Ethernet, each broadcasting address\nresolution\
    \ information once per 10 minutes (as one possible set\nof parameters).  This\
    \ is one packet every 6 seconds.  This is\nalmost reasonable, but what use is\
    \ it?  The workstations aren't\ngenerally going to be talking to each other (and\
    \ therefore have\n100 useless entries in a table); they will be mainly talking\
    \ to a\nmainframe, file server or bridge, but only to a small number of\nother\
    \ workstations (for interactive conversations, for example).\nThe protocol described\
    \ in this paper distributes information as\nit is needed, and only once (probably)\
    \ per boot of a machine.\nThis format does not allow for more than one resolution\
    \ to be\ndone in the same packet.  This is for simplicity.  If things were\nmultiplexed\
    \ the packet format would be considerably harder to\ndigest, and much of the information\
    \ could be gratuitous.  Think\nof a bridge that talks four protocols telling a\
    \ workstation all\nfour protocol addresses, three of which the workstation will\n\
    probably never use.\nThis format allows the packet buffer to be reused if a reply\
    \ is\ngenerated; a reply has the same length as a request, and several\nof the\
    \ fields are the same.\nThe value of the hardware field (ar$hrd) is taken from\
    \ a list for\nthis purpose.  Currently the only defined value is for the 10Mbit\n\
    Ethernet (ares_hrd$Ethernet = 1).  There has been talk of using\nthis protocol\
    \ for Packet Radio Networks as well, and this will\nrequire another value as will\
    \ other future hardware mediums that\nwish to use this protocol.\nFor the 10Mbit\
    \ Ethernet, the value in the protocol field (ar$pro)\nis taken from the set ether_type$.\
    \  This is a natural reuse of\nthe assigned protocol types.  Combining this with\
    \ the opcode\n(ar$op) would effectively halve the number of protocols that can\n\
    be resolved under this protocol and would make a monitor/debugger\nmore complex\
    \ (see Network Monitoring and Debugging below).  It is\nhoped that we will never\
    \ see 32768 protocols, but Murphy made\nsome laws which don't allow us to make\
    \ this assumption.\nIn theory, the length fields (ar$hln and ar$pln) are redundant,\n\
    since the length of a protocol address should be determined by\nthe hardware type\
    \ (found in ar$hrd) and the protocol type (found\nin ar$pro).  It is included\
    \ for optional consistency checking,\nand for network monitoring and debugging\
    \ (see below). \nThe opcode is to determine if this is a request (which may cause\n\
    a reply) or a reply to a previous request.  16 bits for this is\noverkill, but\
    \ a flag (field) is needed.\nenter the sender information in a table or to send\
    \ a reply.  It\nis not necessarily needed in the reply form if one assumes a\n\
    reply is only provoked by a request.  It is included for\ncompleteness, network\
    \ monitoring, and to simplify the suggested\nprocessing algorithm described above\
    \ (which does not look at the\nopcode until AFTER putting the sender information\
    \ in a table).\nThe target hardware address is included for completeness and\n\
    network monitoring.  It has no meaning in the request form, since\nit is this\
    \ number that the machine is requesting.  Its meaning in\nthe reply form is the\
    \ address of the machine making the request.\nIn some implementations (which do\
    \ not get to look at the 14.byte\nethernet header, for example) this may save\
    \ some register\nshuffling or stack space by sending this field to the hardware\n\
    driver as the hardware destination address of the packet.\nThere are no padding\
    \ bytes between addresses.  The packet data\n---------------------------------\n\
    The above Address Resolution protocol allows a machine to gain\nknowledge about\
    \ the higher level protocol activity (e.g., CHAOS,\nInternet, PUP, DECnet) on\
    \ an Ethernet cable.  It can determine\nwhich Ethernet protocol type fields are\
    \ in use (by value) and the\nprotocol addresses within each protocol type.  In\
    \ fact, it is not\nnecessary for the monitor to speak any of the higher level\n\
    protocols involved.  It goes something like this:\nWhen a monitor receives an\
    \ Address Resolution packet, it always\nenters the <protocol type, sender protocol\
    \ address, sender\nhardware address> in a table.  It can determine the length\
    \ of the\nhardware and protocol address from the ar$hln and ar$pln fields\nof\
    \ the packet.  If the opcode is a REPLY the monitor can then\nthrow the packet\
    \ away.  If the opcode is a REQUEST and the target\nprotocol address matches the\
    \ protocol address of the monitor, the\nmonitor sends a REPLY as it normally would.\
    \  The monitor will\nonly get one mapping this way, since the REPLY to the REQUEST\n\
    will be sent directly to the requesting host.  The monitor could\ntry sending\
    \ its own REQUEST, but this could get two monitors into\na REQUEST sending loop,\
    \ and care must be taken.\nBecause the protocol and opcode are not combined into\
    \ one field,\nthe monitor does not need to know which request opcode is\nassociated\
    \ with which reply opcode for the same higher level\nprotocol.  The length fields\
    \ should also give enough information\nto enable it to \"parse\" a protocol addresses,\
    \ although it has no\nknowledge of what the protocol addresses mean.\nA working\
    \ implementation of the Address Resolution protocol can\nalso be used to debug\
    \ a non-working implementation.  Presumably a\nhardware driver will successfully\
    \ broadcast a packet with Ethernet\ntype field of ether_type$ADDRESS_RESOLUTION.\
    \  The format of the\npacket may not be totally correct, because initial\n-----------\n\
    Let there exist machines X and Y that are on the same 10Mbit\nEthernet cable.\
    \  They have Ethernet address EA(X) and EA(Y) and\nDOD Internet addresses IPA(X)\
    \ and IPA(Y) .  Let the Ethernet type\nof Internet be ET(IP).  Machine X has just\
    \ been started, and\nsooner or later wants to send an Internet packet to machine\
    \ Y on\nthe same cable.  X knows that it wants to send to IPA(Y) and\ntells the\
    \ hardware driver (here an Ethernet driver) IPA(Y).  The\ndriver consults the\
    \ Address Resolution module to convert <ET(IP),\nIPA(Y)> into a 48.bit Ethernet\
    \ address, but because X was just\nstarted, it does not have this information.\
    \  It throws the\nInternet packet away and instead creates an ADDRESS RESOLUTION\n\
    packet with\n\t(ar$hrd) = ares_hrd$Ethernet\n\t(ar$pro) = ET(IP)\n\t(ar$hln) =\
    \ length(EA(X))\n\t(ar$pln) = length(IPA(X))\n\t(ar$op)  = ares_op$REQUEST\n\t\
    (ar$sha) = EA(X)\n\t(ar$spa) = IPA(X)\n\t(ar$tha) = don't care\n\t(ar$tpa) = IPA(Y)\n\
    and broadcasts this packet to everybody on the cable.\nMachine Y gets this packet,\
    \ and determines that it understands\nthe hardware type (Ethernet), that it speaks\
    \ the indicated\nprotocol (Internet) and that the packet is for it\n((ar$tpa)=IPA(Y)).\
    \  It enters (probably replacing any existing\nentry) the information that <ET(IP),\
    \ IPA(X)> maps to EA(X).  It\nthen notices that it is a request, so it swaps fields,\
    \ putting\nEA(Y) in the new sender Ethernet address field (ar$sha), sets the\n\
    opcode to reply, and sends the packet directly (not broadcast) to\nEA(X).  At\
    \ this point Y knows how to send to X, but X still\ndoesn't know how to send to\
    \ Y.\nMachine X gets the reply packet from Y, forms the map from\n<ET(IP), IPA(Y)>\
    \ to EA(Y), notices the packet is a reply and\nthrows it away.  The next time\
    \ X's Internet module tries to send\na packet to Y on the Ethernet, the translation\
    \ will succeed, and\nIt may be desirable to have table aging and/or timeouts.\
    \  The\nimplementation of these is outside the scope of this protocol.\nHere is\
    \ a more detailed description (thanks to MOON@SCRC@MIT-MC).\nIf a host moves,\
    \ any connections initiated by that host will\nwork, assuming its own address\
    \ resolution table is cleared when\nit moves.  However, connections initiated\
    \ to it by other hosts\nwill have no particular reason to know to discard their\
    \ old\naddress.  However, 48.bit Ethernet addresses are supposed to be\nunique\
    \ and fixed for all time, so they shouldn't change.  A host\ncould \"move\" if\
    \ a host name (and address in some other protocol)\nwere reassigned to a different\
    \ physical piece of hardware.  Also,\nas we know from experience, there is always\
    \ the danger of\nincorrect routing information accidentally getting transmitted\n\
    through hardware or software error; it should not be allowed to\npersist forever.\
    \  Perhaps failure to initiate a connection should\ninform the Address Resolution\
    \ module to delete the information on\nthe basis that the host is not reachable,\
    \ possibly because it is\ndown or the old translation is no longer valid.  Or\
    \ perhaps\nreceiving of a packet from a host should reset a timeout in the\naddress\
    \ resolution entry used for transmitting packets to that\nhost; if no packets\
    \ are received from a host for a suitable\nlength of time, the address resolution\
    \ entry is forgotten.  This\nmay cause extra overhead to scan the table for each\
    \ incoming\npacket.  Perhaps a hash or index can make this faster.\nThe suggested\
    \ algorithm for receiving address resolution packets\ntries to lessen the time\
    \ it takes for recovery if a host does\nmove.  Recall that if the <protocol type,\
    \ sender protocol\naddress> is already in the translation table, then the sender\n\
    hardware address supersedes the existing entry.  Therefore, on a\nperfect Ethernet\
    \ where a broadcast REQUEST reaches all stations\non the cable, each station will\
    \ be get the new hardware address.\nAnother alternative is to have a daemon perform\
    \ the timeouts.\nAfter a suitable time, the daemon considers removing an entry.\n\
    It first sends (with a small number of retransmissions if needed)\nan address\
    \ resolution packet with opcode REQUEST directly to the\nEthernet address in the\
    \ table.  If a REPLY is not seen in a short\namount of time, the entry is deleted.\
    \  The request is sent\ndirectly so as not to bother every station on the Ethernet.\
    \  Just\nforgetting entries will likely cause useful information to be\nforgotten,\
    \ which must be regained.\nSince hosts don't transmit information about anyone\
    \ other than\nthemselves, rebooting a host will cause its address mapping table\n\
    to be up to date.  Bad information can't persist forever by being\npassed around\
    \ from machine to machine; the only bad information\nthat can exist is in a machine\
    \ that doesn't know that some other\nmachine has changed its 48.bit Ethernet address.\
    \  Perhaps\nmanually resetting (or clearing) the address mapping table will\n\
    suffice.\n"
