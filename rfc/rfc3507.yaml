- title: __initial_text__
  contents:
  - '              Internet Content Adaptation Protocol (ICAP)

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
- title: IESG Note
  contents:
  - "IESG Note\n   The Open Pluggable Services (OPES) working group has been chartered\n\
    \   to produce a standards track protocol specification for a protocol\n   intended\
    \ to perform the same of functions as ICAP.  However, since\n   ICAP is already\
    \ in widespread use the IESG believes it is appropriate\n   to document existing\
    \ usage by publishing the ICAP specification as an\n   informational document.\
    \  The IESG also notes that ICAP was developed\n   before the publication of RFC\
    \ 3238 and therefore does not address the\n   architectural and policy issues\
    \ described in that document.\n"
- title: Abstract
  contents:
  - "Abstract\n   ICAP, the Internet Content Adaption Protocol, is a protocol aimed\
    \ at\n   providing simple object-based content vectoring for HTTP services.\n\
    \   ICAP is, in essence, a lightweight protocol for executing a \"remote\n   procedure\
    \ call\" on HTTP messages.  It allows ICAP clients to pass\n   HTTP messages to\
    \ ICAP servers for some sort of transformation or\n   other processing (\"adaptation\"\
    ).  The server executes its\n   transformation service on messages and sends back\
    \ responses to the\n   client, usually with modified messages.  Typically, the\
    \ adapted\n   messages are either HTTP requests or HTTP responses.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.   Introduction............................................3\n\
    \   2.   Terminology.............................................5\n   3.   ICAP\
    \ Overall Operation..................................8\n        3.1   Request\
    \ Modification..............................8\n        3.2   Response Modification............................10\n\
    \   4.   Protocol Semantics.....................................11\n        4.1\
    \   General Operation................................11\n        4.2   ICAP URIs........................................11\n\
    \        4.3   ICAP Headers.....................................12\n         \
    \     4.3.1   Headers Common to Requests and\n                      Responses................................12\n\
    \              4.3.2   Request Headers..........................13\n         \
    \     4.3.3   Response Headers.........................14\n              4.3.4\
    \   ICAP-Related Headers in HTTP\n                      Messages.................................15\n\
    \        4.4   ICAP Bodies: Encapsulation of HTTP\n              Messages.........................................16\n\
    \              4.4.1   Expected Encapsulated Sections...........16\n         \
    \     4.4.2   Encapsulated HTTP Headers................18\n        4.5   Message\
    \ Preview..................................18\n        4.6   \"204 No Content\"\
    \ Responses outside of\n              Previews.........................................22\n\
    \        4.7   ISTag Response Header............................22\n        4.8\
    \   Request Modification Mode........................23\n              4.8.1 \
    \  Request..................................23\n              4.8.2   Response.................................24\n\
    \              4.8.3   Examples.................................24\n        4.9\
    \   Response Modification Mode.......................27\n              4.9.1 \
    \  Request..................................27\n              4.9.2   Response.................................27\n\
    \              4.9.3   Examples.................................28\n        4.10\
    \  OPTIONS Method...................................29\n              4.10.1 \
    \ OPTIONS request..........................29\n              4.10.2  OPTIONS response.........................30\n\
    \              4.10.3  OPTIONS examples.........................33\n   5.   Caching................................................33\n\
    \   6.   Implementation Notes...................................34\n        6.1\
    \   Vectoring Points.................................34\n        6.2   Application\
    \ Level Errors.........................35\n        6.3   Use of Chunked Transfer-Encoding.................37\n\
    \        6.4   Distinct URIs for Distinct Services..............37\n   7.   Security\
    \ Considerations................................37\n        7.1   Authentication...................................37\n\
    \        7.2   Encryption.......................................38\n        7.3\
    \   Service Validation...............................38\n   8.   Motivations and\
    \ Design Alternatives....................39\n        8.1   To Be HTTP, or Not\
    \ to Be.........................39\n        8.2   Mandatory Use of Chunking........................39\n\
    \        8.3   Use of the null-body directive in the\n              Encapsulated\
    \ header..............................40\n   9.   References.............................................40\n\
    \   10.  Contributors...........................................41\n   Appendix\
    \ A   BNF Grammar for ICAP Messages..................45\n   Authors' Addresses..........................................48\n\
    \   Full Copyright Statement....................................49\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   As the Internet grows, so does the need for scalable Internet\n\
    \   services.  Popular web servers are asked to deliver content to\n   hundreds\
    \ of millions of users connected at ever-increasing\n   bandwidths.  The model\
    \ of centralized, monolithic servers that are\n   responsible for all aspects\
    \ of every client's request seems to be\n   reaching the end of its useful life.\n\
    \   To keep up with the growth in the number of clients, there has been a\n  \
    \ move towards architectures that scale better through the use of\n   replication,\
    \ distribution, and caching.  On the content provider\n   side, replication and\
    \ load-balancing techniques allow the burden of\n   client requests to be spread\
    \ out over a myriad of servers.  Content\n   providers have also begun to deploy\
    \ geographically diverse content\n   distribution networks that bring origin-servers\
    \ closer to the \"edge\"\n   of the network where clients are attached.  These\
    \ networks of\n   distributed origin-servers or \"surrogates\" allow the content\
    \ provider\n   to distribute their content whilst retaining control over the\n\
    \   integrity of that content.  The distributed nature of this type of\n   deployment\
    \ and the proximity of a given surrogate to the end-user\n   enables the content\
    \ provider to offer additional services to a user\n   which might be based, for\
    \ example, on geography where this would have\n   been difficult with a single,\
    \ centralized service.\n   ICAP, the Internet Content Adaption Protocol, is a\
    \ protocol aimed at\n   providing simple object-based content vectoring for HTTP\
    \ services.\n   ICAP is, in essence, a lightweight protocol for executing a \"\
    remote\n   procedure call\" on HTTP messages.  It allows ICAP clients to pass\n\
    \   HTTP messages to ICAP servers for some sort of transformation or\n   other\
    \ processing (\"adaptation\").  The server executes its\n   transformation service\
    \ on messages and sends back responses to the\n   client, usually with modified\
    \ messages.  The adapted messages may be\n   either HTTP requests or HTTP responses.\
    \  Though transformations may\n   be possible on other non-HTTP content, they\
    \ are beyond the scope of\n   this document.\n   This type of Remote Procedure\
    \ Call (RPC) is useful in a number of\n   ways.  For example:\n   o  Simple transformations\
    \ of content can be performed near the edge\n      of the network instead of requiring\
    \ an updated copy of an object\n      from an origin server.  For example, a content\
    \ provider might want\n      to provide a popular web page with a different advertisement\
    \ every\n      time the page is viewed.  Currently, content providers implement\n\
    \      this policy by marking such pages as non-cachable and tracking\n      user\
    \ cookies.  This imposes additional load on the origin server\n      and the network.\
    \  In our architecture, the page could be cached\n      once near the edges of\
    \ the network.  These edge caches can then\n      use an ICAP call to a nearby\
    \ ad-insertion server every time the\n      page is served to a client.\n    \
    \  Other such transformations by edge servers are possible, either\n      with\
    \ cooperation from the content provider (as in a content\n      distribution network),\
    \ or as a value-added service provided by a\n      client's network provider (as\
    \ in a surrogate).  Examples of these\n      kinds of transformations are translation\
    \ of web pages to different\n      human languages or to different formats that\
    \ are appropriate for\n      special physical devices (e.g., PDA-based or cell-phone-based\n\
    \      browsers).\n   o  Surrogates or origin servers can avoid performing expensive\n\
    \      operations by shipping the work off to other servers instead.\n      This\
    \ helps distribute load across multiple machines.  For example,\n      consider\
    \ a user attempting to download an executable program via a\n      surrogate (e.g.,\
    \ a caching proxy).  The surrogate, acting as an\n      ICAP client, can ask an\
    \ external server to check the executable\n      for viruses before accepting\
    \ it into its cache.\n   o  Firewalls or surrogates can act as ICAP clients and\
    \ send outgoing\n      requests to a service that checks to make sure the URI\
    \ in the\n      request is allowed (for example, in a system that allows parental\n\
    \      control of web content viewed by children).  In this case, it is a\n  \
    \    *request* that is being adapted, not an object returned by a\n      response.\n\
    \   In all of these examples, ICAP is helping to reduce or distribute the\n  \
    \ load on origin servers, surrogates, or the network itself.  In some\n   cases,\
    \ ICAP facilitates transformations near the edge of the network,\n   allowing\
    \ greater cachability of the underlying content.  In other\n   examples, devices\
    \ such as origin servers or surrogates are able to\n   reduce their load by distributing\
    \ expensive operations onto other\n   machines.  In all cases, ICAP has also created\
    \ a standard interface\n   for content adaptation to allow greater flexibility\
    \ in content\n   distribution or the addition of value added services in surrogates.\n\
    \   There are two major components in our architecture:\n   1. Transaction semantics\
    \ -- \"How do I ask for adaptation?\"\n   2. Control of policy -- \"When am I\
    \ supposed to ask for adaptation,\n      what kind of adaptation do I ask for,\
    \ and from where?\"\n   Currently, ICAP defines only the transaction semantics.\
    \  For example,\n   this document specifies how to send an HTTP message from an\
    \ ICAP\n   client to an ICAP server, specify the URI of the ICAP resource\n  \
    \ requested along with other resource-specific parameters, and receive\n   the\
    \ adapted message.\n   Although a necessary building-block, this wire-protocol\
    \ defined by\n   ICAP is of limited use without the second part: an accompanying\n\
    \   application framework in which it operates.  The more difficult\n   policy\
    \ issue is beyond the scope of the current ICAP protocol, but is\n   planned in\
    \ future work.\n   In initial implementations, we expect that implementation-specific\n\
    \   manual configuration will be used to define policy.  This includes\n   the\
    \ rules for recognizing messages that require adaptation, the URIs\n   of available\
    \ adaptation resources, and so on.  For ICAP clients and\n   servers to interoperate,\
    \ the exact method used to define policy need\n   not be consistent across implementations,\
    \ as long as the policy\n   itself is consistent.\n   IMPORTANT:\n      Note that\
    \ at this time, in the absence of a policy-framework, it\n      is strongly RECOMMENDED\
    \ that transformations SHOULD only be\n      performed on messages with the explicit\
    \ consent of either the\n      content-provider or the user (or both).  Deployment\
    \ of\n      transformation services without the consent of either leads to, at\n\
    \      best, unpredictable results.  For more discussion of these issues,\n  \
    \    see Section 7.\n   Once the full extent of the typical policy decisions are\
    \ more fully\n   understood through experience with these initial implementations,\n\
    \   later follow-ons to this architecture may define an additional policy\n  \
    \ control protocol.  This future protocol may allow a standard policy\n   definition\
    \ interface complementary to the ICAP transaction interface\n   defined here.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in BCP\
    \ 14, RFC 2119 [2].\n   The special terminology used in this document is defined\
    \ below.  The\n   majority of these terms are taken as-is from HTTP/1.1 [4] and\
    \ are\n   reproduced here for reference.  A thorough understanding of HTTP/1.1\n\
    \   is assumed on the part of the reader.\n   connection:\n      A transport layer\
    \ virtual circuit established between two programs\n      for the purpose of communication.\n\
    \   message:\n      The basic unit of HTTP communication, consisting of a structured\n\
    \      sequence of octets matching the syntax defined in Section 4 of\n      HTTP/1.1\
    \ [4] and transmitted via the connection.\n   request:\n      An HTTP request\
    \ message, as defined in Section 5 of HTTP/1.1 [4].\n   response:\n      An HTTP\
    \ response message, as defined in Section 6 of HTTP/1.1 [4].\n   resource:\n \
    \     A network data object or service that can be identified by a URI,\n    \
    \  as defined in Section 3.2 of HTTP/1.1 [4].  Resources may be\n      available\
    \ in multiple representations (e.g., multiple languages,\n      data formats,\
    \ size, resolutions) or vary in other ways.\n   client:\n      A program that\
    \ establishes connections for the purpose of sending\n      requests.\n   server:\n\
    \      An application program that accepts connections in order to\n      service\
    \ requests by sending back responses.  Any given program may\n      be capable\
    \ of being both a client and a server; our use of these\n      terms refers only\
    \ to the role being performed by the program for a\n      particular connection,\
    \ rather than to the program's capabilities\n      in general. Likewise, any server\
    \ may act as an origin server,\n      surrogate, gateway, or tunnel, switching\
    \ behavior based on the\n      nature of each request.\n   origin server:\n  \
    \    The server on which a given resource resides or is to be created.\n   proxy:\n\
    \      An intermediary program which acts as both a server and a client\n    \
    \  for the purpose of making requests on behalf of other clients.\n      Requests\
    \ are serviced internally or by passing them on, with\n      possible translation,\
    \ to other servers.  A proxy MUST implement\n      both the client and server\
    \ requirements of this specification.\n   cache:\n      A program's local store\
    \ of response messages and the subsystem\n      that controls its message storage,\
    \ retrieval, and deletion.  A\n      cache stores cachable responses in order\
    \ to reduce the response\n      time and network bandwidth consumption on future,\
    \ equivalent\n      requests.  Any client or server may include a cache, though\
    \ a\n      cache cannot be used by a server that is acting as a tunnel.\n   cachable:\n\
    \      A response is cachable if a cache is allowed to store a copy of\n     \
    \ the response message for use in answering subsequent requests.\n      The rules\
    \ for determining the cachability of HTTP responses are\n      defined in Section\
    \ 13 of [4].  Even if a resource is cachable,\n      there may be additional constraints\
    \ on whether a cache can use the\n      cached copy for a particular request.\n\
    \   surrogate:\n      A gateway co-located with an origin server, or at a different\n\
    \      point in the network, delegated the authority to operate on behalf\n  \
    \    of, and typically working in close co-operation with, one or more\n     \
    \ origin servers.  Responses are typically delivered from an\n      internal cache.\
    \  Surrogates may derive cache entries from the\n      origin server or from another\
    \ of the origin server's delegates.\n      In some cases a surrogate may tunnel\
    \ such requests.\n      Where close co-operation between origin servers and surrogates\n\
    \      exists, this enables modifications of some protocol requirements,\n   \
    \   including the Cache-Control directives in [4].  Such modifications\n     \
    \ have yet to be fully specified.\n      Devices commonly known as \"reverse proxies\"\
    \ and \"(origin) server\n      accelerators\" are both more properly defined as\
    \ surrogates.\n   New definitions:\n   ICAP resource:\n      Similar to an HTTP\
    \ resource as described above, but the URI refers\n      to an ICAP service that\
    \ performs adaptations of HTTP messages.\n   ICAP server:\n      Similar to an\
    \ HTTP server as described above, except that the\n      application services\
    \ ICAP requests.\n   ICAP client:\n      A program that establishes connections\
    \ to ICAP servers for the\n      purpose of sending requests.  An ICAP client\
    \ is often, but not\n      always, a surrogate acting on behalf of a user.\n"
- title: 3.  ICAP Overall Operation
  contents:
  - "3.  ICAP Overall Operation\n   Before describing ICAP's semantics in detail,\
    \ we will first give a\n   general overview of the protocol's major functions\
    \ and expected uses.\n   As described earlier, ICAP focuses on modification of\
    \ HTTP requests\n   (Section 3.1), and modification of HTTP responses (Section\
    \ 3.2).\n"
- title: 3.1  Request Modification
  contents:
  - "3.1  Request Modification\n   In \"request modification\" (reqmod) mode, an ICAP\
    \ client sends an HTTP\n   request to an ICAP server.  The ICAP server may then:\n\
    \   1) Send back a modified version of the request.  The ICAP client may\n   \
    \   then perform the modified request by contacting an origin server;\n      or,\
    \ pipeline the modified request to another ICAP server for\n      further modification.\n\
    \   2) Send back an HTTP response to the request.  This is used to\n      provide\
    \ information useful to the user in case of an error (e.g.,\n      \"you sent\
    \ a request to view a page you are not allowed to see\").\n   3) Return an error.\n\
    \   ICAP clients MUST be able to handle all three types of responses.\n   However,\
    \ in line with the guidance provided for HTTP surrogates in\n   Section 13.8 of\
    \ [4], ICAP client implementors do have flexibility in\n   handling errors.  If\
    \ the ICAP server returns an error, the ICAP\n   client may (for example) return\
    \ the error to the user, execute the\n   unadapted request as it arrived from\
    \ the client, or re-try the\n   adaptation again.\n   We will illustrate this\
    \ method with an example application: content\n   filtering.  Consider a surrogate\
    \ that receives a request from a\n   client for a web page on an origin server.\
    \  The surrogate, acting as\n   an ICAP client, sends the client's request to\
    \ an ICAP server that\n   performs URI-based content filtering.  If access to\
    \ the requested URI\n   is allowed, the request is returned to the ICAP client\
    \ unmodified.\n   However, if the ICAP server chooses to disallow access to the\n\
    \   requested resources, it may either:\n   1) Modify the request so that it points\
    \ to a page containing an error\n      message instead of the original URI.\n\
    \   2) Return an encapsulated HTTP response that indicates an HTTP error.\n  \
    \ This method can be used for a variety of other applications; for\n   example,\
    \ anonymization, modification of the Accept: headers to handle\n   special device\
    \ requirements, and so forth.\n   Typical data flow:\n      origin-server\n  \
    \        | /|\\\n          |  |\n       5  |  |  4\n          |  |\n         \\\
    |/ |              2\n      ICAP-client    -------------->   ICAP-resource\n  \
    \    (surrogate)    <--------------   on ICAP-server\n          | /|\\       \
    \      3\n          |  |\n       6  |  |  1\n          |  |\n         \\|/ |\n\
    \         client\n   1. A client makes a request to a ICAP-capable surrogate (ICAP\
    \ client)\n      for an object on an origin server.\n   2. The surrogate sends\
    \ the request to the ICAP server.\n   3. The ICAP server executes the ICAP resource's\
    \ service on the\n      request and sends the possibly modified request, or a\
    \ response to\n      the request back to the ICAP client.\n   If Step 3 returned\
    \ a request:\n   4. The surrogate sends the request, possibly different from original\n\
    \      client request, to the origin server.\n   5. The origin server responds\
    \ to request.\n   6. The surrogate sends the reply (from either the ICAP server\
    \ or the\n      origin server) to the client.\n"
- title: 3.2  Response Modification
  contents:
  - "3.2  Response Modification\n   In the \"response modification\" (respmod) mode,\
    \ an ICAP client sends\n   an HTTP response to an ICAP server.  (The response\
    \ sent by the ICAP\n   client typically has been generated by an origin server.)\
    \  The ICAP\n   server may then:\n   1) Send back a modified version of the response.\n\
    \   2) Return an error.\n   The response modification method is intended for post-processing\n\
    \   performed on an HTTP response before it is delivered to a client.\n   Examples\
    \ include formatting HTML for display on special devices,\n   human language translation,\
    \ virus checking, and so forth.\n   Typical data flow:\n      origin-server\n\
    \          | /|\\\n          |  |\n       3  |  |  2\n          |  |\n       \
    \  \\|/ |            4\n      ICAP-client    -------------->   ICAP-resource\n\
    \      (surrogate)    <--------------   on ICAP-server\n          | /|\\     \
    \       5\n          |  |\n       6  |  |  1\n          |  |\n         \\|/ |\n\
    \         client\n   1. A client makes a request to a ICAP-capable surrogate (ICAP\
    \ client)\n      for an object on an origin server.\n   2. The surrogate sends\
    \ the request to the origin server.\n   3. The origin server responds to request.\n\
    \   4. The ICAP-capable surrogate sends the origin server's reply to the\n   \
    \   ICAP server.\n   5. The ICAP server executes the ICAP resource's service on\
    \ the origin\n      server's reply and sends the possibly modified reply back\
    \ to the\n      ICAP client.\n   6. The surrogate sends the reply, possibly modified\
    \ from the original\n      origin server's reply, to the client.\n"
- title: 4.  Protocol Semantics
  contents:
  - '4.  Protocol Semantics

    '
- title: 4.1  General Operation
  contents:
  - "4.1  General Operation\n   ICAP is a request/response protocol similar in semantics\
    \ and usage to\n   HTTP/1.1 [4].  Despite the similarity, ICAP is not HTTP, nor\
    \ is it an\n   application protocol that runs over HTTP.  This means, for example,\n\
    \   that ICAP messages can not be forwarded by HTTP surrogates.  Our\n   reasons\
    \ for not building directly on top of HTTP are discussed in\n   Section 8.1.\n\
    \   ICAP uses TCP/IP as a transport protocol.  The default port is 1344,\n   but\
    \ other ports may be used.  The TCP flow is initiated by the ICAP\n   client to\
    \ a passively listening ICAP server.\n   ICAP messages consist of requests from\
    \ client to server and responses\n   from server to client.  Requests and responses\
    \ use the generic\n   message format of RFC 2822 [3] -- that is, a start-line\
    \ (either a\n   request line or a status line), a number of header fields (also\
    \ known\n   as \"headers\"), an empty line (i.e., a line with nothing preceding\
    \ the\n   CRLF) indicating the end of the header fields, and a message-body.\n\
    \   The header lines of an ICAP message specify the ICAP resource being\n   requested\
    \ as well as other meta-data such as cache control\n   information. The message\
    \ body of an ICAP request contains the\n   (encapsulated) HTTP messages that are\
    \ being modified.\n   As in HTTP/1.1, a single transport connection MAY (perhaps\
    \ even\n   SHOULD) be re-used for multiple request/response pairs.  The rules\n\
    \   for doing so in ICAP are the same as described in Section 8.1.2.2 of\n   [4].\
    \  Specifically, requests are matched up with responses by\n   allowing only one\
    \ outstanding request on a transport connection at a\n   time.  Multiple parallel\
    \ connections MAY be used as in HTTP.\n"
- title: 4.2  ICAP URIs
  contents:
  - "4.2  ICAP URIs\n   All ICAP requests specify the ICAP resource being requested\
    \ from the\n   server using an ICAP URI.  This MUST be an absolute URI that\n\
    \   specifies both the complete hostname and the path of the resource\n   being\
    \ requested.  For definitive information on URL syntax and\n   semantics, see\
    \ \"Uniform Resource Identifiers (URI): Generic Syntax\n   and Semantics,\" RFC\
    \ 2396 [1], Section 3.  The URI structure defined\n   by ICAP is roughly:\n  \
    \    ICAP_URI = Scheme \":\" Net_Path [ \"?\" Query ]\n      Scheme = \"icap\"\
    \n      Net_Path = \"//\" Authority [ Abs_Path ]\n      Authority = [ userinfo\
    \ \"@\" ] host [ \":\" port ]\n   ICAP adds the new scheme \"icap\" to the ones\
    \ defined in RFC 2396.  If\n   the port is empty or not given, port 1344 is assumed.\
    \  An example\n   ICAP URI line might look like this:\n      icap://icap.example.net:2000/services/icap-service-1\n\
    \   An ICAP server MUST be able to recognize all of its hosts names,\n   including\
    \ any aliases, local variations, and numeric IP addresses of\n   its interfaces.\n\
    \   Any arguments that an ICAP client wishes to pass to an ICAP service\n   to\
    \ modify the nature of the service MAY be passed as part of the\n   ICAP-URI,\
    \ using the standard \"?\"-encoding of attribute-value pairs\n   used in HTTP.\
    \ For example:\n      icap://icap.net/service?mode=translate&lang=french\n"
- title: 4.3  ICAP Headers
  contents:
  - "4.3  ICAP Headers\n   The following sections define the valid headers for ICAP\
    \ messages.\n   Section 4.3.1 describes headers common to both requests and\n\
    \   responses.  Request-specific and response-specific headers are\n   described\
    \ in Sections 4.3.2 and 4.3.3, respectively.\n   User-defined header extensions\
    \ are allowed.  In compliance with the\n   precedent established by the Internet\
    \ mail format [3] and later\n   adopted by HTTP [4], all user-defined headers\
    \ MUST follow the \"X-\"\n   naming convention (\"X-Extension-Header: Foo\").\
    \  ICAP implementations\n   MAY ignore any \"X-\" headers without loss of compliance\
    \ with the\n   protocol as defined in this document.\n   Each header field consists\
    \ of a name followed by a colon (\":\") and\n   the field value.  Field names\
    \ are case-insensitive.  ICAP follows the\n   rules describe in section 4.2 of\
    \ [4].\n"
- title: 4.3.1  Headers Common to Requests and Responses
  contents:
  - "4.3.1  Headers Common to Requests and Responses\n   The headers of all ICAP messages\
    \ MAY include the following\n   directives, defined in ICAP the same as they are\
    \ in HTTP:\n      Cache-Control\n      Connection\n      Date\n      Expires\n\
    \      Pragma\n      Trailer\n      Upgrade\n   Note in particular that the \"\
    Transfer-Encoding\" option is not\n   allowed.  The special transfer-encoding\
    \ requirements of ICAP bodies\n   are described in Section 4.4.\n   The Upgrade\
    \ header MAY be used to negotiate Transport-Layer Security\n   on an ICAP connection,\
    \ exactly as described for HTTP/1.1 in [4].\n   The ICAP-specific headers defined\
    \ are:\n      Encapsulated  (See Section 4.4)\n"
- title: 4.3.2  Request Headers
  contents:
  - "4.3.2  Request Headers\n   Similar to HTTP, ICAP requests MUST start with a request\
    \ line that\n   contains a method, the complete URI of the ICAP resource being\n\
    \   requested, and an ICAP version string.  The current version number of\n  \
    \ ICAP is \"1.0\".\n   This version of ICAP defines three methods:\n      REQMOD\
    \  - for Request Modification (Section 4.8)\n      RESPMOD - for Response Modification\
    \ (Section 4.9)\n      OPTIONS - to learn about configuration (Section 4.10)\n\
    \   The OPTIONS method MUST be implemented by all ICAP servers.  All\n   other\
    \ methods are optional and MAY be implemented.\n   User-defined extension methods\
    \ are allowed.  Before attempting to use\n   an extension method, an ICAP client\
    \ SHOULD use the OPTIONS method to\n   query the ICAP server's list of supported\
    \ methods; see Section 4.10.\n   (If an ICAP server receives a request for an\
    \ unknown method, it MUST\n   give a 501 error response as described in the next\
    \ section.)\n   Given the URI rules described in Section 4.2, a well-formed ICAP\n\
    \   request line looks like the following example:\n      RESPMOD icap://icap.example.net/translate?mode=french\
    \ ICAP/1.0\n   A number of request-specific headers are allowed in ICAP requests,\n\
    \   following the same semantics as the corresponding HTTP request\n   headers\
    \ (Section 5.3 of [4]).  These are:\n      Authorization\n      Allow (see Section\
    \ 4.6)\n      From  (see Section 14.22 of [4])\n      Host (REQUIRED in ICAP as\
    \ it is in HTTP/1.1)\n      Referer (see Section 14.36 of [4])\n      User-Agent\n\
    \   In addition to HTTP-like headers, there are also request headers\n   unique\
    \ to ICAP defined:\n      Preview (see Section 4.5)\n"
- title: 4.3.3  Response Headers
  contents:
  - "4.3.3  Response Headers\n   ICAP responses MUST start with an ICAP status line,\
    \ similar in form\n   to that used by HTTP, including the ICAP version and a status\
    \ code.\n   For example:\n      ICAP/1.0 200 OK\n   Semantics of ICAP status codes\
    \ in ICAP match the status codes defined\n   by HTTP (Section 6.1.1 and 10 of\
    \ [4]), except where otherwise\n   indicated in this document; n.b. 100 (Section\
    \ 4.5) and 204 (Section\n   4.6).\n   ICAP error codes that differ from their\
    \ HTTP counterparts are:\n   100 - Continue after ICAP Preview (Section 4.5).\n\
    \   204 - No modifications needed (Section 4.6).\n   400 - Bad request.\n   404\
    \ - ICAP Service not found.\n   405 - Method not allowed for service (e.g., RESPMOD\
    \ requested for\n         service that supports only REQMOD).\n   408 - Request\
    \ timeout.  ICAP server gave up waiting for a request\n         from an ICAP client.\n\
    \   500 - Server error.  Error on the ICAP server, such as \"out of disk\n   \
    \      space\".\n   501 - Method not implemented.  This response is illegal for\
    \ an\n         OPTIONS request since implementation of OPTIONS is mandatory.\n\
    \   502 - Bad Gateway.  This is an ICAP proxy and proxying produced an\n     \
    \    error.\n   503 - Service overloaded.  The ICAP server has exceeded a maximum\n\
    \         connection limit associated with this service; the ICAP client\n   \
    \      should not exceed this limit in the future.\n   505 - ICAP version not\
    \ supported by server.\n   As in HTTP, the 4xx class of error codes indicate client\
    \ errors, and\n   the 5xx class indicate server errors.\n   ICAP's response-header\
    \ fields allow the server to pass additional\n   information in the response that\
    \ cannot be placed in the ICAP's\n   status line.\n   A response-specific header\
    \ is allowed in ICAP requests, following the\n   same semantics as the corresponding\
    \ HTTP response headers (Section\n   6.2 of [4]).  This is:\n      Server (see\
    \ Section 14.38 of [4])\n   In addition to HTTP-like headers, there is also a\
    \ response header\n   unique to ICAP defined:\n      ISTag (see Section 4.7)\n"
- title: 4.3.4  ICAP-Related Headers in HTTP Messages
  contents:
  - "4.3.4  ICAP-Related Headers in HTTP Messages\n   When an ICAP-enabled HTTP surrogate\
    \ makes an HTTP request to an\n   origin server, it is often useful to advise\
    \ the origin server of the\n   surrogate's ICAP capabilities.  Origin servers\
    \ can use this\n   information to modify its response accordingly.  For example,\
    \ an\n   origin server may choose not to insert an advertisement into a page\n\
    \   if it knows that a downstream ICAP server can insert the ad instead.\n   Although\
    \ this ICAP specification can not mandate how HTTP is used in\n   communication\
    \ between HTTP clients and servers, we do suggest a\n   convention: such headers\
    \ (if used) SHOULD start with \"X-ICAP\".  HTTP\n   clients with ICAP services\
    \ SHOULD minimally include an \"X-ICAP-\n   Version: 1.0\" header along with their\
    \ application-specific headers.\n"
- title: '4.4  ICAP Bodies: Encapsulation of HTTP Messages'
  contents:
  - "4.4  ICAP Bodies: Encapsulation of HTTP Messages\n   The ICAP encapsulation model\
    \ is a lightweight means of packaging any\n   number of HTTP message sections\
    \ into an encapsulating ICAP message-\n   body, in order to allow the vectoring\
    \ of requests, responses, and\n   request/response pairs to an ICAP server.\n\
    \   This is accomplished by concatenating interesting message parts\n   (encapsulatED\
    \ sections) into a single ICAP message-body (the\n   encapsulatING message). \
    \ The encapsulated sections may be the headers\n   or bodies of HTTP messages.\n\
    \   Encapsulated bodies MUST be transferred using the \"chunked\"\n   transfer-coding\
    \ described in Section 3.6.1 of [4].  However,\n   encapsulated headers MUST NOT\
    \ be chunked.  In other words, an ICAP\n   message-body switches from being non-chunked\
    \ to chunked as the body\n   passes from the encapsulated header to encapsulated\
    \ body section.\n   (See Examples in Sections 4.8.3 and 4.9.3.).  The motivation\
    \ behind\n   this decision is described in Section 8.2.\n"
- title: 4.4.1  The "Encapsulated" Header
  contents:
  - "4.4.1  The \"Encapsulated\" Header\n   The offset of each encapsulated section's\
    \ start relative to the start\n   of the encapsulating message's body is noted\
    \ using the \"Encapsulated\"\n   header.  This header MUST be included in every\
    \ ICAP message.  For\n   example, the header\n      Encapsulated: req-hdr=0, res-hdr=45,\
    \ res-body=100\n   indicates a message that encapsulates a group of request headers,\
    \ a\n   group of response headers, and then a response body.  Each of these\n\
    \   is included at the byte-offsets listed.  The byte-offsets are in\n   decimal\
    \ notation for consistency with HTTP's Content-Length header.\n   The special\
    \ entity \"null-body\" indicates there is no encapsulated\n   body in the ICAP\
    \ message.\n   The syntax of an Encapsulated header is:\n   encapsulated_header:\
    \ \"Encapsulated: \" encapsulated_list\n   encapsulated_list: encapsulated_entity\
    \ |\n                      encapsulated_entity \", \" encapsulated_list\n   encapsulated_entity:\
    \ reqhdr | reshdr | reqbody | resbody | optbody\n   reqhdr  = \"req-hdr\" \"=\"\
    \ (decimal integer)\n   reshdr  = \"res-hdr\" \"=\" (decimal integer)\n   reqbody\
    \ = { \"req-body\" | \"null-body\" } \"=\" (decimal integer)\n   resbody = { \"\
    res-body\" | \"null-body\" } \"=\" (decimal integer)\n   optbody = { \"opt-body\"\
    \ | \"null-body\" } \"=\" (decimal integer)\n   There are semantic restrictions\
    \ on Encapsulated headers beyond the\n   syntactic restrictions.  The order in\
    \ which the encapsulated parts\n   appear in the encapsulating message-body MUST\
    \ be the same as the\n   order in which the parts are named in the Encapsulated\
    \ header.  In\n   other words, the offsets listed in the Encapsulated line MUST\
    \ be\n   monotonically increasing.  In addition, the legal forms of the\n   Encapsulated\
    \ header depend on the method being used (REQMOD, RESPMOD,\n   or OPTIONS).  Specifically:\n\
    \   REQMOD  request  encapsulated_list: [reqhdr] reqbody\n   REQMOD  response\
    \ encapsulated_list: {[reqhdr] reqbody} |\n                                  \
    \     {[reshdr] resbody}\n   RESPMOD request  encapsulated_list: [reqhdr] [reshdr]\
    \ resbody\n   RESPMOD response encapsulated_list: [reshdr] resbody\n   OPTIONS\
    \ response encapsulated_list: optbody\n   In the above grammar, note that encapsulated\
    \ headers are always\n   optional.  At most one body per encapsulated message\
    \ is allowed.  If\n   no encapsulated body is presented, the \"null-body\" header\
    \ is used\n   instead; this is useful because it indicates the length of the header\n\
    \   section.\n   Examples of legal Encapsulated headers:\n   /* REQMOD request:\
    \ This encapsulated HTTP request's headers start\n    * at offset 0; the HTTP\
    \ request body (e.g., in a POST) starts\n    * at 412. */\n   Encapsulated: req-hdr=0,\
    \ req-body=412\n   /* REQMOD request: Similar to the above, but no request body\
    \ is\n    * present (e.g., a GET).  We use the null-body directive instead.\n\
    \    * In both this case and the previous one, we can tell from the\n    * Encapsulated\
    \ header that the request headers were 412 bytes\n    * long. */\n   Encapsulated:\
    \ req-hdr=0, null-body=412\n   /* REQMOD response: ICAP server returned a modified\
    \ request,\n    * with body */\n   Encapsulated: req-hdr=0, req-body=512\n   /*\
    \ RESPMOD request: Request headers at 0, response headers at 822,\n    * response\
    \ body at 1655.  Note that no request body is allowed in\n    * RESPMOD requests.\
    \ */\n   Encapsulated: req-hdr=0, res-hdr=822, res-body=1655\n   /* RESPMOD or\
    \ REQMOD response: header and body returned */\n   Encapsulated: res-hdr=0, res-body=749\n\
    \   /* OPTIONS response when there IS an options body */\n   Encapsulated: opt-body=0\n\
    \   /* OPTIONS response when there IS NOT an options body */\n   Encapsulated:\
    \ null-body=0\n"
- title: 4.4.2  Encapsulated HTTP Headers
  contents:
  - "4.4.2  Encapsulated HTTP Headers\n   By default, ICAP messages may encapsulate\
    \ HTTP message headers and\n   entity bodies.  HTTP headers MUST start with the\
    \ request-line or\n   status-line for requests and responses, respectively, followed\
    \ by\n   interesting HTTP headers.\n   The encapsulated headers MUST be terminated\
    \ by a blank line, in order\n   to make them human readable, and in order to terminate\
    \ line-by-line\n   HTTP parsers.\n   HTTP/1.1 makes a distinction between end-to-end\
    \ headers and hop-by-\n   hop headers (see Section 13.5.1 of [4]).  End-to-end\
    \ headers are\n   meaningful to the ultimate recipient of a message, whereas hop-by-hop\n\
    \   headers are meaningful only for a single transport-layer connection.\n   Hop-by-hop\
    \ headers include Connection, Keep-Alive, and so forth.  All\n   end-to-end HTTP\
    \ headers SHOULD be encapsulated, and all hop-by-hop\n   headers MUST NOT be encapsulated.\n\
    \   Despite the above restrictions on encapsulation, the hop-by-hop\n   Proxy-Authenticate\
    \ and Proxy-Authorization headers MUST be forwarded\n   to the ICAP server in\
    \ the ICAP header section (not the encapsulated\n   message).  This allows propagation\
    \ of client credentials that might\n   have been sent to the ICAP client in cases\
    \ where the ICAP client is\n   also an HTTP surrogate.  Note that this does not\
    \ contradict HTTP/1.1,\n   which explicitly states \"A proxy MAY relay the credentials\
    \ from the\n   client request to the next proxy if that is the mechanism by which\n\
    \   the proxies cooperatively authenticate a given request.\"  (Section\n   14.34).\n\
    \   The Via header of an encapsulated message SHOULD be modified by an\n   ICAP\
    \ server as if the encapsulated message were traveling through an\n   HTTP surrogate.\
    \  The Via header added by an ICAP server MUST specify\n   protocol as ICAP/1.0.\n"
- title: 4.5  Message Preview
  contents:
  - "4.5  Message Preview\n   ICAP REQMOD or RESPMOD requests sent by the ICAP client\
    \ to the ICAP\n   server may include a \"preview\".  This feature allows an ICAP\
    \ server\n   to see the beginning of a transaction, then decide if it wants to\n\
    \   opt-out of the transaction early instead of receiving the remainder\n   of\
    \ the request message.  Previewing can yield significant performance\n   improvements\
    \ in a variety of situations, such as the following:\n   -  Virus-checkers can\
    \ certify a large fraction of files as \"clean\"\n      just by looking at the\
    \ file type, file name extension, and the\n      first few bytes of the file.\
    \  Only the remaining files need to be\n      transmitted to the virus-checking\
    \ ICAP server in their entirety.\n   -  Content filters can use Preview to decide\
    \ if an HTTP entity needs\n      to be inspected (the HTTP file type alone is\
    \ not enough in cases\n      where \"text\" actually turns out to be graphics\
    \ data).  The magic\n      numbers at the front of the file can identify a file\
    \ as a JPEG or\n      GIF.\n   -  If an ICAP server wants to transcode all GIF87\
    \ files into GIF89\n      files, then the GIF87 files could quickly be detected\
    \ by looking\n      at the first few body bytes of the file.\n   -  If an ICAP\
    \ server wants to force all cacheable files to expire in\n      24 hours or less,\
    \ then this could be implemented by selecting HTTP\n      messages with expiries\
    \ more than 24 hours in the future.\n   ICAP servers SHOULD use the OPTIONS method\
    \ (see Section 4.10) to\n   specify how many bytes of preview are needed for a\
    \ particular ICAP\n   application on a per-resource basis.  Clients SHOULD be\
    \ able to\n   provide Previews of at least 4096 bytes.  Clients furthermore SHOULD\n\
    \   provide a Preview when using any ICAP resource that has indicated a\n   Preview\
    \ is useful.  (This indication might be provided via the\n   OPTIONS method, or\
    \ some other \"out-of-band\" configuration.)  Clients\n   SHOULD NOT provide a\
    \ larger Preview than a server has indicated it is\n   willing to accept.\n  \
    \ To effect a Preview, an ICAP client MUST add a \"Preview:\" header to\n   its\
    \ request headers indicating the length of the preview.  The ICAP\n   client then\
    \ sends:\n   -  all of the encapsulated header sections, and\n   -  the beginning\
    \ of the encapsulated body section, if any, up to the\n      number of bytes advertised\
    \ in the Preview (possibly 0).\n   After the Preview is sent, the client stops\
    \ and waits for an\n   intermediate response from the ICAP server before continuing.\
    \  This\n   mechanism is similar to the \"100-Continue\" feature found in HTTP,\n\
    \   except that the stop-and-wait point can be within the message body.\n   In\
    \ contrast, HTTP requires that the point must be the boundary\n   between the\
    \ headers and body.\n   For example, to effect a Preview consisting of only encapsulated\
    \ HTTP\n   headers, the ICAP client would add the following header to the ICAP\n\
    \   request:\n      Preview: 0\n   This indicates that the ICAP client will send\
    \ only the encapsulated\n   header sections to the ICAP server, then it will send\
    \ a zero-length\n   chunk and stop and wait for a \"go ahead\" to send more encapsulated\n\
    \   body bytes to the ICAP server.\n   Similarly, the ICAP header:\n      Preview:\
    \ 4096\n   Indicates that the ICAP client will attempt to send 4096 bytes of\n\
    \   origin server data in the encapsulated body of the ICAP request to\n   the\
    \ ICAP server.  It is important to note that the actual transfer\n   may be less,\
    \ because the ICAP client is acting like a surrogate and\n   is not looking ahead\
    \ to find the total length of the origin server\n   response.  The entire ICAP\
    \ encapsulated header section(s) will be\n   sent, followed by up to 4096 bytes\
    \ of encapsulated HTTP body.  The\n   chunk body terminator \"0\\r\\n\\r\\n\"\
    \ is always included in these\n   transactions.\n   After sending the preview,\
    \ the ICAP client will wait for a response\n   from the ICAP server.  The response\
    \ MUST be one of the following:\n   -  204 No Content.  The ICAP server does not\
    \ want to (or can not)\n      modify the ICAP client's request.  The ICAP client\
    \ MUST treat this\n      the same as if it had sent the entire message to the\
    \ ICAP server\n      and an identical message was returned.\n   -  ICAP reqmod\
    \ or respmod response, depending what method was the\n      original request.\
    \  See Section 4.8.2 and 4.9.2 for the format of\n      reqmod and respmod responses.\n\
    \   -  100 Continue.  If the entire encapsulated HTTP body did not fit\n     \
    \ in the preview, the ICAP client MUST send the remainder of its\n      ICAP message,\
    \ starting from the first chunk after the preview.  If\n      the entire message\
    \ fit in the preview (detected by the \"EOF\"\n      symbol explained below),\
    \ then the ICAP server MUST NOT respond\n      with 100 Continue.\n   When an\
    \ ICAP client is performing a preview, it may not yet know how\n   many bytes\
    \ will ultimately be available in the arriving HTTP message\n   that it is relaying\
    \ to the HTTP server.  Therefore, ICAP defines a\n   way for ICAP clients to indicate\
    \ \"EOF\" to ICAP servers if one\n   unexpectedly arrives during the preview process.\
    \  This is a\n   particularly useful optimization if a header-only HTTP response\n\
    \   arrives at the ICAP client (i.e., zero bytes of body); only a single\n   round\
    \ trip will be needed for the complete ICAP server response.\n   We define an\
    \ HTTP chunk-extension of \"ieof\" to indicate that an ICAP\n   chunk is the last\
    \ chunk (see [4]).  The ICAP server MUST strip this\n   chunk extension before\
    \ passing the chunk data to an ICAP application\n   process.\n   For example,\
    \ consider an ICAP client that has just received HTTP\n   response headers from\
    \ an origin server and initiates an ICAP RESPMOD\n   transaction to an ICAP server.\
    \  It does not know yet how many body\n   bytes will be arriving from the origin\
    \ server because the server is\n   not using the Content-Length header.  The ICAP\
    \ client informs the\n   ICAP server that it will be sending a 1024-byte preview\
    \ using a\n   \"Preview:  1024\" request header.  If the HTTP origin server then\n\
    \   closes its connection to the ICAP client before sending any data\n   (i.e.,\
    \ it provides a zero-byte body), the corresponding zero-byte\n   preview for that\
    \ zero-byte origin response would appear as follows:\n      \\r\\n\n      0; ieof\\\
    r\\n\\r\\n\n   If an ICAP server sees this preview, it knows from the presence\
    \ of\n   \"ieof\" that the client will not be sending any more chunk data.  In\n\
    \   this case, the server MUST respond with the modified response or a\n   204\
    \ No Content message right away.  It MUST NOT send a 100-Continue\n   response\
    \ in this case.  (In contrast, if the origin response had been\n   1 byte or larger,\
    \ the \"ieof\" would not have appeared.  In that case,\n   an ICAP server MAY\
    \ reply with 100-Continue, a modified response, or\n   204 No Content.)\n   In\
    \ another example, if the preview is 1024 bytes and the origin\n   response is\
    \ 1024 bytes in two chunks, then the encapsulation would\n   appear as follows:\n\
    \      200\\r\\n\n      <512 bytes of data>\\r\\n\n      200\\r\\n\n      <512\
    \ bytes of data>\\r\\n\n      0; ieof\\r\\n\\r\\n\n      <204 or modified response>\
    \ (100 Continue disallowed due to ieof)\n   If the preview is 1024 bytes and the\
    \ origin response is 1025 bytes\n   (and the ICAP server responds with 100-continue),\
    \ then these chunks\n   would appear on the wire:\n      200\\r\\n\n      <512\
    \ bytes of data>\\r\\n\n      200\\r\\n\n      <512 bytes of data>\\r\\n\n   \
    \   0\\r\\n\n      <100 Continue Message>\n      1\\r\\n\n      <1 byte of data>\\\
    r\\n\n      0\\r\\n\\r\\n  <no ieof because we are no longer in preview mode>\n\
    \   Once the ICAP server receives the eof indicator, it finishes reading\n   the\
    \ current chunk stream.\n   Note that when offering a Preview, the ICAP client\
    \ is committing to\n   temporarily buffer the previewed portion of the message\
    \ so that it\n   can honor a \"204 No Content\" response.  The remainder of the\
    \ message\n   is not necessarily buffered; it might be pipelined directly from\n\
    \   another source to the ICAP server after a 100-Continue.\n"
- title: 4.6  "204 No Content" Responses outside of Previews
  contents:
  - "4.6  \"204 No Content\" Responses outside of Previews\n   An ICAP client MAY\
    \ choose to honor \"204 No Content\" responses for an\n   entire message.  This\
    \ is the decision of the client because it\n   imposes a burden on the client\
    \ of buffering the entire message.\n   An ICAP client MAY include \"Allow: 204\"\
    \ in its request headers,\n   indicating that the server MAY reply to the message\
    \ with a \"204 No\n   Content\" response if the object does not need modification.\n\
    \   If an ICAP server receives a request that does not have \"Allow: 204\",\n\
    \   it MUST NOT reply with a 204.  In this case, an ICAP server MUST\n   return\
    \ the entire message back to the client, even though it is\n   identical to the\
    \ message it received.\n   The ONLY EXCEPTION to this rule is in the case of a\
    \ message preview,\n   as described in the previous section.  If this is the case,\
    \ an ICAP\n   server can respond with a 204 No Content message in response to\
    \ a\n   message preview EVEN if the original request did not have the \"Allow:\n\
    \   204\" header.\n"
- title: 4.7  ISTag Response Header
  contents:
  - "4.7  ISTag Response Header\n   The ISTag (\"ICAP Service Tag\") response-header\
    \ field provides a way\n   for ICAP servers to send a service-specific \"cookie\"\
    \ to ICAP clients\n   that represents a service's current state.  It is a 32-byte-maximum\n\
    \   alphanumeric string of data (not including the null character) that\n   may,\
    \ for example, be a representation of the software version or\n   configuration\
    \ of a service.  An ISTag validates that previous ICAP\n   server responses can\
    \ still be considered fresh by an ICAP client that\n   may be caching them.  If\
    \ a change on the ICAP server invalidates\n   previous responses, the ICAP server\
    \ can invalidate portions of the\n   ICAP client's cache by changing its ISTag.\
    \  The ISTag MUST be\n   included in every ICAP response from an ICAP server.\n\
    \   For example, consider a virus-scanning ICAP service.  The ISTag might\n  \
    \ be a combination of the virus scanner's software version and the\n   release\
    \ number of its virus signature database.  When the database is\n   updated, the\
    \ ISTag can be changed to invalidate all previous\n   responses that had been\
    \ certified as \"clean\" and cached with the old\n   ISTag.\n   ISTag is similar,\
    \ but not identical, to the HTTP ETag.  While an ETag\n   is a validator for a\
    \ particular entity (object), an ISTag validates\n   all entities generated by\
    \ a particular service (URI).  A change in\n   the ISTag invalidates all the other\
    \ entities provided a service with\n   the old ISTag, not just the entity whose\
    \ response contained the\n   updated ISTag.\n   The syntax of an ISTag is simply:\n\
    \      ISTag = \"ISTag: \" quoted-string\n   In this document we use the quoted-string\
    \ definition defined in\n   section 2.2 of [4].\n   For example:\n      ISTag:\
    \ \"874900-1994-1c02798\"\n"
- title: 4.8  Request Modification Mode
  contents:
  - "4.8  Request Modification Mode\n   In this method, described in Section 3.1,\
    \ an ICAP client sends an\n   HTTP request to an ICAP server.  The ICAP server\
    \ returns a modified\n   version of the request, an HTTP response, or (if the\
    \ client indicates\n   it supports 204 responses) an indication that no modification\
    \ is\n   required.\n"
- title: 4.8.1  Request
  contents:
  - "4.8.1  Request\n   In REQMOD mode, the ICAP request MUST contain an encapsulated\
    \ HTTP\n   request.  The headers and body (if any) MUST both be encapsulated,\n\
    \   except that hop-by-hop headers are not encapsulated.\n"
- title: 4.8.2  Response
  contents:
  - "4.8.2  Response\n   The response from the ICAP server back to the ICAP client\
    \ may take\n   one of four forms:\n   -  An error indication,\n   -  A 204 indicating\
    \ that the ICAP client's request requires no\n      adaptation (see Section 4.6\
    \ for limitations of this response),\n   -  An encapsulated, adapted version of\
    \ the ICAP client's request, or\n   -  An encapsulated HTTP error response.  Note\
    \ that Request\n      Modification requests may only be satisfied with HTTP responses\
    \ in\n      cases when the HTTP response is an error (e.g., 403 Forbidden).\n\
    \   The first line of the response message MUST be a status line as\n   described\
    \ in Section 4.3.3.  If the return code is a 2XX, the ICAP\n   client SHOULD continue\
    \ its normal execution of the request.  If the\n   ICAP client is a surrogate,\
    \ this may include serving an object from\n   its cache or forwarding the modified\
    \ request to an origin server.\n   Note it is valid for a 2XX ICAP response to\
    \ contain an encapsulated\n   HTTP error response, which in turn should be returned\
    \ to the\n   downstream client by the ICAP client.\n   For other return codes\
    \ that indicate an error, the ICAP client MAY\n   (for example) return the error\
    \ to the downstream client or user,\n   execute the unadapted request as it arrived\
    \ from the client, or re-\n   try the adaptation again.\n   The modified request\
    \ headers, if any, MUST be returned to the ICAP\n   client using appropriate encapsulation\
    \ as described in Section 4.4.\n"
- title: 4.8.3  Examples
  contents:
  - "4.8.3  Examples\n   Consider the following example, in which a surrogate receives\
    \ a\n   simple GET request from a client.  The surrogate, acting as an ICAP\n\
    \   client, then forwards this request to an ICAP server for\n   modification.\
    \  The ICAP server modifies the request headers and sends\n   them back to the\
    \ ICAP client.  Our hypothetical ICAP server will\n   modify several headers and\
    \ strip the cookie from the original\n   request.\n   In all of our examples,\
    \ we include the extra meta-data added to the\n   message due to chunking the\
    \ encapsulated message body (if any).  We\n   assume that end-of-line terminations,\
    \ and blank lines, are two-byte\n   \"CRLF\" sequences.\n   ICAP Request Modification\
    \ Example 1 - ICAP Request\n   ----------------------------------------------------------------\n\
    \   REQMOD icap://icap-server.net/server?arg=87 ICAP/1.0\n   Host: icap-server.net\n\
    \   Encapsulated: req-hdr=0, null-body=170\n   GET / HTTP/1.1\n   Host: www.origin-server.com\n\
    \   Accept: text/html, text/plain\n   Accept-Encoding: compress\n   Cookie: ff39fk3jur@4ii0e02i\n\
    \   If-None-Match: \"xyzzy\", \"r2d2xxxx\"\n   ----------------------------------------------------------------\n\
    \   ICAP Request Modification Example 1 - ICAP Response\n   ----------------------------------------------------------------\n\
    \   ICAP/1.0 200 OK\n   Date: Mon, 10 Jan 2000  09:55:21 GMT\n   Server: ICAP-Server-Software/1.0\n\
    \   Connection: close\n   ISTag: \"W3E4R7U9-L2E4-2\"\n   Encapsulated: req-hdr=0,\
    \ null-body=231\n   GET /modified-path HTTP/1.1\n   Host: www.origin-server.com\n\
    \   Via: 1.0 icap-server.net (ICAP Example ReqMod Service 1.1)\n   Accept: text/html,\
    \ text/plain, image/gif\n   Accept-Encoding: gzip, compress\n   If-None-Match:\
    \ \"xyzzy\", \"r2d2xxxx\"\n   ----------------------------------------------------------------\n\
    \   The second example is similar to the first, except that the request\n   being\
    \ modified in this case is a POST instead of a GET.  Note that\n   the encapsulated\
    \ Content-Length argument has been modified to reflect\n   the modified body of\
    \ the POST message.  The outer ICAP message does\n   not need a Content-Length\
    \ header because it uses chunking (not\n   shown).\n   In this second example,\
    \ the Encapsulated header shows the division\n   between the forwarded header\
    \ and forwarded body, for both the request\n   and the response.\n   ICAP Request\
    \ Modification Example 2 - ICAP Request\n   ----------------------------------------------------------------\n\
    \   REQMOD icap://icap-server.net/server?arg=87 ICAP/1.0\n   Host: icap-server.net\n\
    \   Encapsulated: req-hdr=0, req-body=147\n   POST /origin-resource/form.pl HTTP/1.1\n\
    \   Host: www.origin-server.com\n   Accept: text/html, text/plain\n   Accept-Encoding:\
    \ compress\n   Pragma: no-cache\n   1e\n   I am posting this information.\n  \
    \ 0\n   ----------------------------------------------------------------\n   ICAP\
    \ Request Modification Example 2 - ICAP Response\n   ----------------------------------------------------------------\n\
    \   ICAP/1.0 200 OK\n   Date: Mon, 10 Jan 2000  09:55:21 GMT\n   Server: ICAP-Server-Software/1.0\n\
    \   Connection: close\n   ISTag: \"W3E4R7U9-L2E4-2\"\n   Encapsulated: req-hdr=0,\
    \ req-body=244\n   POST /origin-resource/form.pl HTTP/1.1\n   Host: www.origin-server.com\n\
    \   Via: 1.0 icap-server.net (ICAP Example ReqMod Service 1.1)\n   Accept: text/html,\
    \ text/plain, image/gif\n   Accept-Encoding: gzip, compress\n   Pragma: no-cache\n\
    \   Content-Length: 45\n   2d\n   I am posting this information.  ICAP powered!\n\
    \   0\n   ----------------------------------------------------------------\n \
    \  Finally, this third example shows an ICAP server returning an error\n   response\
    \ when it receives a Request Modification request.\n   ICAP Request Modification\
    \ Example 3 - ICAP Request\n   ----------------------------------------------------------------\n\
    \   REQMOD icap://icap-server.net/content-filter ICAP/1.0\n   Host: icap-server.net\n\
    \   Encapsulated: req-hdr=0, null-body=119\n   GET /naughty-content HTTP/1.1\n\
    \   Host: www.naughty-site.com\n   Accept: text/html, text/plain\n   Accept-Encoding:\
    \ compress\n   ----------------------------------------------------------------\n\
    \   ICAP Request Modification Example 3 - ICAP Response\n   ----------------------------------------------------------------\n\
    \   ICAP/1.0 200 OK\n   Date: Mon, 10 Jan 2000  09:55:21 GMT\n   Server: ICAP-Server-Software/1.0\n\
    \   Connection: close\n   ISTag: \"W3E4R7U9-L2E4-2\"\n   Encapsulated: res-hdr=0,\
    \ res-body=213\n   HTTP/1.1 403 Forbidden\n   Date: Wed, 08 Nov 2000 16:02:10\
    \ GMT\n   Server: Apache/1.3.12 (Unix)\n   Last-Modified: Thu, 02 Nov 2000 13:51:37\
    \ GMT\n   ETag: \"63600-1989-3a017169\"\n   Content-Length: 58\n   Content-Type:\
    \ text/html\n   3a\n   Sorry, you are not allowed to access that naughty content.\n\
    \   0\n   ----------------------------------------------------------------\n"
- title: 4.9  Response Modification Mode
  contents:
  - "4.9  Response Modification Mode\n   In this method, described in Section 3.2,\
    \ an ICAP client sends an\n   origin server's HTTP response to an ICAP server,\
    \ and (if available)\n   the original client request that caused that response.\
    \  Similar to\n   Request Modification method, the response from the ICAP server\
    \ can be\n   an adapted HTTP response, an error, or a 204 response code indicating\n\
    \   that no adaptation is required.\n"
- title: 4.9.1  Request
  contents:
  - "4.9.1  Request\n   Using encapsulation described in Section 4.4, the header and\
    \ body of\n   the HTTP response to be modified MUST be included in the ICAP body.\n\
    \   If available, the header of the original client request SHOULD also\n   be\
    \ included.  As with the other method, the hop-by-hop headers of the\n   encapsulated\
    \ messages MUST NOT be forwarded.  The Encapsulated header\n   MUST indicate the\
    \ byte-offsets of the beginning of each of these four\n   parts.\n"
- title: 4.9.2  Response
  contents:
  - "4.9.2  Response\n   The response from the ICAP server looks just like a reply\
    \ in the\n   Request Modification method (Section 4.8); that is,\n   -  An error\
    \ indication,\n   -  An encapsulated and potentially modified HTTP response header\
    \ and\n      response body, or\n   -  An HTTP response 204 indicating that the\
    \ ICAP client's request\n      requires no adaptation.\n   The first line of the\
    \ response message MUST be a status line as\n   described in Section 4.3.3.  If\
    \ the return code is a 2XX, the ICAP\n   client SHOULD continue its normal execution\
    \ of the response.  The\n   ICAP client MAY re-examine the headers in the response's\
    \ message\n   headers in order to make further decisions about the response (e.g.,\n\
    \   its cachability).\n   For other return codes that indicate an error, the ICAP\
    \ client SHOULD\n   NOT return these directly to downstream client, since these\
    \ errors\n   only make sense in the ICAP client/server transaction.\n   The modified\
    \ response headers, if any, MUST be returned to the ICAP\n   client using appropriate\
    \ encapsulation as described in Section 4.4.\n"
- title: 4.9.3  Examples
  contents:
  - "4.9.3  Examples\n   In Example 4, an ICAP client is requesting modification of\
    \ an entity\n   that was returned as a result of a client GET.  The original client\n\
    \   GET was to an origin server at \"www.origin-server.com\"; the ICAP\n   server\
    \ is at \"icap.example.org\".\n   ICAP Response Modification Example 4 - ICAP\
    \ Request\n   ----------------------------------------------------------------\n\
    \   RESPMOD icap://icap.example.org/satisf ICAP/1.0\n   Host: icap.example.org\n\
    \   Encapsulated: req-hdr=0, res-hdr=137, res-body=296\n   GET /origin-resource\
    \ HTTP/1.1\n   Host: www.origin-server.com\n   Accept: text/html, text/plain,\
    \ image/gif\n   Accept-Encoding: gzip, compress\n   HTTP/1.1 200 OK\n   Date:\
    \ Mon, 10 Jan 2000 09:52:22 GMT\n   Server: Apache/1.3.6 (Unix)\n   ETag: \"63840-1ab7-378d415b\"\
    \n   Content-Type: text/html\n   Content-Length: 51\n   33\n   This is data that\
    \ was returned by an origin server.\n   0\n   ----------------------------------------------------------------\n\
    \   ICAP Response Modification Example 4 - ICAP Response\n   ----------------------------------------------------------------\n\
    \   ICAP/1.0 200 OK\n   Date: Mon, 10 Jan 2000  09:55:21 GMT\n   Server: ICAP-Server-Software/1.0\n\
    \   Connection: close\n   ISTag: \"W3E4R7U9-L2E4-2\"\n   Encapsulated: res-hdr=0,\
    \ res-body=222\n   HTTP/1.1 200 OK\n   Date: Mon, 10 Jan 2000  09:55:21 GMT\n\
    \   Via: 1.0 icap.example.org (ICAP Example RespMod Service 1.1)\n   Server: Apache/1.3.6\
    \ (Unix)\n   ETag: \"63840-1ab7-378d415b\"\n   Content-Type: text/html\n   Content-Length:\
    \ 92\n   5c\n   This is data that was returned by an origin server, but with\n\
    \   value added by an ICAP server.\n   0\n   ----------------------------------------------------------------\n"
- title: 4.10  OPTIONS Method
  contents:
  - "4.10  OPTIONS Method\n   The ICAP \"OPTIONS\" method is used by the ICAP client\
    \ to retrieve\n   configuration information from the ICAP server.  In this method,\
    \ the\n   ICAP client sends a request addressed to a specific ICAP resource and\n\
    \   receives back a response with options that are specific to the\n   service\
    \ named by the URI.  All OPTIONS requests MAY also return\n   options that are\
    \ global to the server (i.e., apply to all services).\n"
- title: 4.10.1 OPTIONS Request
  contents:
  - "4.10.1 OPTIONS Request\n   The OPTIONS method consists of a request-line, as\
    \ described in\n   Section 4.3.2, such as the following example:\n   OPTIONS icap://icap.server.net/sample-service\
    \ ICAP/1.0 User-Agent:\n   ICAP-client-XYZ/1.001\n   Other headers are also allowed\
    \ as described in Section 4.3.1 and\n   Section 4.3.2 (for example, Host).\n"
- title: 4.10.2 OPTIONS Response
  contents:
  - "4.10.2 OPTIONS Response\n   The OPTIONS response consists of a status line as\
    \ described in\n   section 4.3.3 followed by a series of header field names-value\
    \ pairs\n   optionally followed by an opt-body.  Multiple values in the value\n\
    \   field MUST be separated by commas.  If an opt-body is present in the\n   OPTIONS\
    \ response, the Opt-body-type header describes the format of\n   the opt-body.\n\
    \   The OPTIONS headers supported in this version of the protocol are:\n   --\
    \ Methods:\n      The method that is supported by this service.  This header MUST\
    \ be\n      included in the OPTIONS response.  The OPTIONS method MUST NOT be\n\
    \      in the Methods' list since it MUST be supported by all the ICAP\n     \
    \ server implementations.  Each service should have a distinct URI\n      and\
    \ support only one method in addition to OPTIONS (see Section\n      6.4).\n \
    \     For example:\n      Methods: RESPMOD\n   -- Service:\n      A text description\
    \ of the vendor and product name.  This header\n      MAY be included in the OPTIONS\
    \ response.\n      For example:\n      Service: XYZ Technology Server 1.0\n  \
    \ -- ISTag:\n      See section 4.7 for details.  This header MUST be included\
    \ in the\n      OPTIONS response.\n      For example:\n      ISTag: \"5BDEEEA9-12E4-2\"\
    \n   -- Encapsulated:\n      This header MUST be included in the OPTIONS response;\
    \ see Section\n      4.4.\n      For example:\n      Encapsulated: opt-body=0\n\
    \   -- Opt-body-type:\n      A token identifying the format of the opt-body. \
    \ (Valid opt-body\n      types are not defined by ICAP.)  This header MUST be\
    \ included in\n      the OPTIONS response ONLY if an opt-body type is present.\n\
    \      For example:\n      Opt-body-type: XML-Policy-Table-1.0\n   -- Max-Connections:\n\
    \      The maximum number of ICAP connections the server is able to\n      support.\
    \  This header MAY be included in the OPTIONS response.\n      For example:\n\
    \      Max-Connections: 1500\n   -- Options-TTL:\n      The time (in seconds)\
    \ for which this OPTIONS response is valid.\n      If none is specified, the OPTIONS\
    \ response does not expire.  This\n      header MAY be included in the OPTIONS\
    \ response.  The ICAP client\n      MAY reissue an OPTIONS request once the Options-TTL\
    \ expires.\n      For example:\n      Options-TTL: 3600\n   -- Date:\n      The\
    \ server's clock, specified as an RFC 1123 compliant date/time\n      string.\
    \  This header MAY be included in the OPTIONS response.\n      For example:\n\
    \      Date: Fri, 15 Jun 2001 04:33:55 GMT\n   -- Service-ID:\n      A short label\
    \ identifying the ICAP service.  It MAY be used in\n      attribute header names.\
    \  This header MAY be included in the\n      OPTIONS response.\n      For example:\n\
    \      Service-ID: xyztech\n   -- Allow:\n      A directive declaring a list of\
    \ optional ICAP features that this\n      server has implemented.  This header\
    \ MAY be included in the\n      OPTIONS response.  In this document we define\
    \ the value \"204\" to\n      indicate that the ICAP server supports a 204 response.\n\
    \      For example:\n      Allow: 204\n   -- Preview:\n      The number of bytes\
    \ to be sent by the ICAP client during a\n      preview.  This header MAY be included\
    \ in the OPTIONS response.\n      For example:\n      Preview: 1024\n   -- Transfer-Preview:\n\
    \      A list of file extensions that should be previewed to the ICAP\n      server\
    \ before sending them in their entirety.  This header MAY be\n      included in\
    \ the OPTIONS response.  Multiple file extensions values\n      should be separated\
    \ by commas.  The wildcard value \"*\" specifies\n      the default behavior for\
    \ all the file extensions not specified in\n      any other Transfer-* header\
    \ (see below).\n      For example:\n      Transfer-Preview: *\n   -- Transfer-Ignore:\n\
    \      A list of file extensions that should NOT be sent to the ICAP\n      server.\
    \  This header MAY be included in the OPTIONS response.\n      Multiple file extensions\
    \ should be separated by commas.\n      For example:\n      Transfer-Ignore: html\n\
    \   -- Transfer-Complete:\n      A list of file extensions that should be sent\
    \ in their entirety\n      (without preview) to the ICAP server.  This header\
    \ MAY be included\n      in the OPTIONS response.  Multiple file extensions values\
    \ should\n      be separated by commas.\n      For example:\n      Transfer-Complete:\
    \ asp, bat, exe, com, ole\n   Note: If any of Transfer-* are sent, exactly one\
    \ of them MUST contain\n   the wildcard value \"*\" to specify the default.  If\
    \ no Transfer-* are\n   sent, all responses will be sent in their entirety (without\
    \ Preview).\n"
- title: 4.10.3 OPTIONS Examples
  contents:
  - "4.10.3 OPTIONS Examples\n   In example 5, an ICAP Client sends an OPTIONS Request\
    \ to an ICAP\n   Service named icap.server.net/sample-service in order to get\n\
    \   configuration information for the service provided.\n   ICAP OPTIONS Example\
    \ 5 - ICAP OPTIONS Request\n   ----------------------------------------------------------------\n\
    \   OPTIONS icap://icap.server.net/sample-service ICAP/1.0\n   Host: icap.server.net\n\
    \   User-Agent: BazookaDotCom-ICAP-Client-Library/2.3\n   ----------------------------------------------------------------\n\
    \   ICAP OPTIONS Example 5 - ICAP OPTIONS Response\n   ----------------------------------------------------------------\n\
    \   ICAP/1.0 200 OK\n   Date: Mon, 10 Jan 2000  09:55:21 GMT\n   Methods: RESPMOD\n\
    \   Service: FOO Tech Server 1.0\n   ISTag: \"W3E4R7U9-L2E4-2\"\n   Encapsulated:\
    \ null-body=0\n   Max-Connections: 1000\n   Options-TTL: 7200\n   Allow: 204\n\
    \   Preview: 2048\n   Transfer-Complete: asp, bat, exe, com\n   Transfer-Ignore:\
    \ html\n   Transfer-Preview: *\n   ----------------------------------------------------------------\n"
- title: 5.  Caching
  contents:
  - "5.  Caching\n   ICAP servers' responses MAY be cached by ICAP clients, just as\
    \ any\n   other surrogate might cache HTTP responses.  Similar to HTTP, ICAP\n\
    \   clients MAY always store a successful response (see sections 4.8.2\n   and\
    \ 4.9.2) as a cache entry, and MAY return it without validation if\n   it is fresh.\
    \ ICAP servers use the caching directives described in\n   HTTP/1.1 [4].\n   In\
    \ Request Modification mode, the ICAP server MAY include caching\n   directives\
    \ in the ICAP header section of the ICAP response (NOT in\n   the encapsulated\
    \ HTTP request of the ICAP message body).  In Response\n   Modification mode,\
    \ the ICAP server MAY add or modify the HTTP caching\n   directives located in\
    \ the encapsulated HTTP response (NOT in the ICAP\n   header section).  Consequently,\
    \ the ICAP client SHOULD look for\n   caching directives in the ICAP headers in\
    \ case of REQMOD, and in the\n   encapsulated HTTP response in case of RESPMOD.\n\
    \   In cases where an ICAP server returns a modified version of an object\n  \
    \ created by an origin server, such as in Response Modification mode,\n   the\
    \ expiration of the ICAP-modified object MUST NOT be longer than\n   that of the\
    \ origin object.  In other words, ICAP servers MUST NOT\n   extend the lifetime\
    \ of origin server objects, but MAY shorten it.\n   In cases where the ICAP server\
    \ is the authoritative source of an ICAP\n   response, such as in Request Modification\
    \ mode, the ICAP server is\n   not restricted in its expiration policy.\n   Note\
    \ that the ISTag response-header may also be used to providing\n   caching hints\
    \ to clients; see Section 4.7.\n"
- title: 6.  Implementation Notes
  contents:
  - '6.  Implementation Notes

    '
- title: 6.1  Vectoring Points
  contents:
  - "6.1  Vectoring Points\n   The definition of the ICAP protocol itself only describes\
    \ two\n   different adaptation channels: modification (and satisfaction) of\n\
    \   requests, and modifications of replies.  However, an ICAP client\n   implementation\
    \ is likely to actually distinguish among four different\n   classes of adaptation:\n\
    \   1.  Adaptation of client requests.  This is adaptation done every\n      \
    \ time a request arrives from a client.  This is adaptation done\n       when\
    \ a request is \"on its way into the cache\".  Factors such as\n       the state\
    \ of the objects currently cached will determine whether\n       or not this request\
    \ actually gets forwarded to an origin server\n       (instead of, say, getting\
    \ served off the cache's disk).  An\n       example of this type of adaptation\
    \ would be special access\n       control or authentication services that must\
    \ be performed on a\n       per-client basis.\n   2.  Adaptation of requests on\
    \ their way to an origin server.\n       Although this type of adaptation is also\
    \ an adaptation of\n       requests similar to (1), it describes requests that\
    \ are \"on their\n       way out of the cache\"; i.e., if a request actually requires\
    \ that\n       an origin server be contacted.  These adaptation requests are not\n\
    \       necessarily specific to particular clients.  An example would be\n   \
    \    addition of \"Accept:\"  headers for special devices; these\n       adaptations\
    \ can potentially apply to many clients.\n   3.  Adaptations of responses coming\
    \ from an origin server.  This is\n       the adaptation of an object \"on its\
    \ way into the cache\".  In\n       other words, this is adaptation that a surrogate\
    \ might want to\n       perform on an object before caching it.  The adapted object\
    \ may\n       subsequently served to many clients.  An example of this type of\n\
    \       adaptation is virus checking: a surrogate will want to check an\n    \
    \   incoming origin reply for viruses once, before allowing it into\n       the\
    \ cache -- not every time the cached object is served to a\n       client.\n \
    \      Adaptation of responses coming from the surrogate, heading back\n     \
    \  to the client.  Although this type of adaptation, like (3), is\n       the\
    \ adaptation of a response, it is client-specific.  Client\n       reply adaptation\
    \ is adaptation that is required every time an\n       object is served to a client,\
    \ even if all the replies come from\n       the same cached object off of disk.\
    \  Ad insertion is a common\n       form of this kind of adaptation; e.g., if\
    \ a popular (cached)\n       object that rarely changes needs a different ad inserted\
    \ into it\n       every time it is served off disk to a client.  Note that the\n\
    \       relationship between adaptations of type (3) and (4) is analogous\n  \
    \     to the relationship between types (2) and (1).\n   Although the distinction\
    \ among these four adaptation points is\n   critical for ICAP client implementations,\
    \ the distinction is not\n   significant for the ICAP protocol itself.  From the\
    \ point of view of\n   an ICAP server, a request is a request -- the ICAP server\
    \ doesn't\n   care what policy led the ICAP client to generate the request.  We\n\
    \   therefore did not make these four channels explicit in ICAP for\n   simplicity.\n"
- title: 6.2  Application Level Errors
  contents:
  - "6.2  Application Level Errors\n   Section 4 described \"on the wire\" protocol\
    \ errors that MUST be\n   standardized across implementations to ensure interoperability.\
    \  In\n   this section, we describe errors that are communicated between ICAP\n\
    \   software and the clients and servers on which they are implemented.\n   Although\
    \ such errors are implementation dependent and do not\n   necessarily need to\
    \ be standardized because they are \"within the\n   box\", they are presented\
    \ here as advice to future implementors based\n   on past implementation experience.\n\
    \   Error name                                     Value\n   ====================================================\n\
    \   ICAP_CANT_CONNECT                               1000\n   ICAP_SERVER_RESPONSE_CLOSE\
    \                      1001\n   ICAP_SERVER_RESPONSE_RESET                   \
    \   1002\n   ICAP_SERVER_UNKNOWN_CODE                        1003\n   ICAP_SERVER_UNEXPECTED_CLOSE_204\
    \                1004\n   ICAP_SERVER_UNEXPECTED_CLOSE                    1005\n\
    \   1000 ICAP_CANT_CONNECT:\n       \"Cannot connect to ICAP server\".\n     \
    \  The ICAP server is not connected on the socket.  Maybe the ICAP\n       server\
    \ is dead or it is not connected on the socket.\n   1001 ICAP_SERVER_RESPONSE_CLOSE:\n\
    \       \"ICAP Server closed connection while reading response\".\n       The\
    \ ICAP server TCP-shutdowns the connection before the ICAP\n       client can\
    \ send all the body data.\n   1002 ICAP_SERVER_RESPONSE_RESET:\n       \"ICAP\
    \ Server reset connection while reading response\".\n       The ICAP server TCP-reset\
    \ the connection before the ICAP client\n       can send all the body data.\n\
    \   1003 ICAP_SERVER_UNKNOWN_CODE:\n       \"ICAP Server sent unknown response\
    \ code\".\n       An unknown ICAP response code (see Section 4.x) was received\
    \ by\n       the ICAP client.\n   1004 ICAP_SERVER_UNEXPECTED_CLOSE_204:\n   \
    \    \"ICAP Server closed connection on 204 without 'Connection: close'\n    \
    \   header\".\n       An ICAP server MUST send the \"Connection: close\" header\
    \ if\n       intends to close after the current transaction.\n   1005 ICAP_SERVER_UNEXPECTED_CLOSE:\n\
    \       \"ICAP Server closed connection as ICAP client wrote body\n       preview\"\
    .\n"
- title: 6.3  Use of Chunked Transfer-Encoding
  contents:
  - "6.3  Use of Chunked Transfer-Encoding\n   For simplicity, ICAP messages MUST\
    \ use the \"chunked\" transfer-\n   encoding within the encapsulated body section\
    \ as defined in HTTP/1.1\n   [4].  This requires that ICAP client implementations\
    \ convert incoming\n   objects \"on the fly\" to chunked from whatever transfer-encoding\
    \ on\n   which they arrive.  However, the transformation is simple:\n   -  For\
    \ objects arriving using \"Content-Length\" headers, one big chunk\n      can\
    \ be created of the same size as indicated in the Content-Length\n      header.\n\
    \   -  For objects arriving using a TCP close to signal the end of the\n     \
    \ object, each incoming group of bytes read from the OS can be\n      converted\
    \ into a chunk (by writing the length of the bytes read,\n      followed by the\
    \ bytes themselves)\n   -  For objects arriving using chunked encoding, they can\
    \ be\n      retransmitted as is (without re-chunking).\n"
- title: 6.4  Distinct URIs for Distinct Services
  contents:
  - "6.4  Distinct URIs for Distinct Services\n   ICAP servers SHOULD assign unique\
    \ URIs to each service they provide,\n   even if such services might theoretically\
    \ be differentiated based on\n   their method.  In other words, a REQMOD and RESPMOD\
    \ service should\n   never have the same URI, even if they do something that is\n\
    \   conceptually the same.\n   This situation in ICAP is similar to that found\
    \ in HTTP where it\n   might, in theory, be possible to perform a GET or a POST\
    \ to the same\n   URI and expect two different results.  This kind of overloading\
    \ of\n   URIs only causes confusion and should be avoided.\n"
- title: 7.  Security Considerations
  contents:
  - '7.  Security Considerations

    '
- title: 7.1  Authentication
  contents:
  - "7.1  Authentication\n   Authentication in ICAP is very similar to proxy authentication\
    \ in\n   HTTP as specified in RFC 2617.  Specifically, the following rules\n \
    \  apply:\n   -  WWW-Authenticate challenges and responses are for end-to-end\n\
    \      authentication between a client (user) and an origin server.  As\n    \
    \  any proxy, ICAP clients and ICAP servers MUST forward these\n      headers\
    \ without modification.\n   -  If authentication is required between an ICAP client\
    \ and ICAP\n      server, hop-by-hop Proxy Authentication as described in RFC\
    \ 2617\n      MUST be used.\n   There are potential applications where a user\
    \ (as opposed to ICAP\n   client) might have rights to access an ICAP service.\
    \  In this version\n   of the protocol, we assume that ICAP clients and ICAP servers\
    \ are\n   under the same administrative domain, and contained in a single trust\n\
    \   domain. Therefore, in these cases, we assume that it is sufficient\n   for\
    \ users to authenticate themselves to the ICAP client (which is a\n   surrogate\
    \ from the point of view from the user).  This type of\n   authentication will\
    \ also be Proxy Authentication as described in RFC\n   2617.\n   This standard\
    \ explicitly excludes any method for a user to\n   authenticate directly to an\
    \ ICAP server; the ICAP client MUST be\n   involved as described above.\n"
- title: 7.2  Encryption
  contents:
  - "7.2  Encryption\n   Users of ICAP should note well that ICAP messages are not\
    \ encrypted\n   for transit by default.  In the absence of some other form of\n\
    \   encryption at the link or network layers, eavesdroppers may be able\n   to\
    \ record the unencrypted transactions between ICAP clients and\n   servers.  As\
    \ described in Section 4.3.1, the Upgrade header MAY be\n   used to negotiate\
    \ transport-layer security for an ICAP connection\n   [5].\n   Note also that\
    \ end-to-end encryption between a client and origin\n   server is likely to preclude\
    \ the use of value-added services by\n   intermediaries such as surrogates.  An\
    \ ICAP server that is unable to\n   decrypt a client's messages will, of course,\
    \ be unable to perform any\n   transformations on it.\n"
- title: 7.3  Service Validation
  contents:
  - "7.3  Service Validation\n   Normal HTTP surrogates, when operating correctly,\
    \ should not affect\n   the end-to-end semantics of messages that pass through\
    \ them.  This\n   forms a well-defined criterion to validate that a surrogate\
    \ is\n   working correctly: a message should look the same before the\n   surrogate\
    \ as it does after the surrogate.\n   In contrast, ICAP is meant to cause changes\
    \ in the semantics of\n   messages on their way from origin servers to users.\
    \  The criteria for\n   a correctly operating surrogate are no longer as easy\
    \ to define.\n   This will make validation of ICAP services significantly more\n\
    \   difficult.  Incorrect adaptations may lead to security\n   vulnerabilities\
    \ that were not present in the unadapted content.\n"
- title: 8.  Motivations and Design Alternatives
  contents:
  - "8.  Motivations and Design Alternatives\n   This section describes some of our\
    \ design decisions in more detail,\n   and describes the ideas and motivations\
    \ behind them.  This section\n   does not define protocol requirements, but hopefully\
    \ sheds light on\n   the requirements defined in previous sections.  Nothing in\
    \ this\n   section carries the \"force of law\" or is part of the formal protocol\n\
    \   specification.\n   In general, our guiding principle was to make ICAP the\
    \ simplest\n   possible protocol that would do the job, and no simpler.  Some\n\
    \   features were rejected where alternative (non-protocol-based)\n   solutions\
    \ could be found.  In addition, we have intentionally left a\n   number of issues\
    \ at the discretion of the implementor, where we\n   believe that doing so does\
    \ not compromise interoperability.\n"
- title: 8.1  To Be HTTP, or Not To Be
  contents:
  - "8.1  To Be HTTP, or Not To Be\n   ICAP was initially designed as an application-layer\
    \ protocol built to\n   run on top of HTTP.  This was desirable for a number of\
    \ reasons.\n   HTTP is well-understood in the community and has enjoyed significant\n\
    \   investments in software infrastructure (clients, servers, parsers,\n   etc.).\
    \  Our initial designs focused on leveraging that existing work;\n   we hoped\
    \ that it would be possible to implement ICAP services simply,\n   using CGI scripts\
    \ run by existing web servers.\n   However, the devil (as always) proved to be\
    \ in the details.  Certain\n   features that we considered important were impossible\
    \ to implement\n   with HTTP.  For example, ICAP clients can stop and wait for\
    \ a \"100\n   Continue\" message in the midst of a message-body; HTTP clients\
    \ may\n   only wait between the header and body.  In addition, certain\n   transformations\
    \ of HTTP messages by surrogates are legal (and\n   harmless for HTTP), but caused\
    \ problems with ICAP's \"header-in-\n   header\" encapsulation and other features.\n\
    \   Ultimately, we decided that the tangle of workarounds required to fit\n  \
    \ ICAP into HTTP was more complex and confusing than moving away from\n   HTTP\
    \ and defining a new (but similar) protocol.\n"
- title: 8.2  Mandatory Use of Chunking
  contents:
  - "8.2  Mandatory Use of Chunking\n   Chunking is mandatory in ICAP encapsulated\
    \ bodies for three reasons.\n   First, efficiency is important, and the chunked\
    \ encoding allows both\n   the client and server to keep the transport-layer connection\
    \ open for\n   later reuse.  Second, ICAP servers (and their developers) should\
    \ be\n   encouraged to produce \"incremental\" responses where possible, to\n\
    \   reduce the latency perceived by users.  Chunked encoding is the only\n   way\
    \ to support this type of implementation.  Finally, by\n   standardizing on a\
    \ single encapsulation mechanism, we avoid the\n   complexity that would be required\
    \ in client and server software to\n   support multiple mechanisms.  This simplifies\
    \ ICAP, particularly in\n   the \"body preview\" feature described in Section\
    \ 4.5.\n   While chunking of encapsulated bodies is mandatory, encapsulated\n\
    \   headers are not chunked.  There are two reasons for this decision.\n   First,\
    \ in cases where a chunked HTTP message body is being\n   encapsulated in an ICAP\
    \ message, the ICAP client (HTTP server) can\n   copy it directly from the HTTP\
    \ client to the ICAP server without un-\n   chunking and then re-chunking it.\
    \  Second, many header-parser\n   implementations have difficulty dealing with\
    \ headers that come in\n   multiple chunks.  Earlier drafts of this document mandated\
    \ that a\n   chunk boundary not come within a header.  For clarity, chunking of\n\
    \   encapsulated headers has simply been disallowed.\n"
- title: 8.3  Use of the null-body directive in the Encapsulated header
  contents:
  - "8.3  Use of the null-body directive in the Encapsulated header\n   There is a\
    \ disadvantage to not using the chunked transfer-encoding\n   for encapsulated\
    \ header part of an ICAP message.  Specifically,\n   parsers do not know in advance\
    \ how much header data is coming (e.g.,\n   for buffer allocation).  ICAP does\
    \ not allow chunking in the header\n   part for reasons described in Section 8.2.\
    \  To compensate, the\n   \"null-body\" directive allows the final header's length\
    \ to be\n   determined, despite it not being chunked.\n"
- title: 9.  References
  contents:
  - "9.  References\n   [1]  Berners-Lee, T., Fielding, R. and L. Masinter, \"Uniform\
    \ Resource\n        Identifiers (URI): Generic Syntax and Semantics\", RFC 2396,\n\
    \        August 1998.\n   [2]  Bradner, S., \"Key words for use in RFCs to Indicate\
    \ Requirement\n        Levels\", BCP 14, RFC 2119, March 1997.\n   [3]  Resnick,\
    \ P., \"Internet Message Format\", RFC 2822, April 2001.\n   [4]  Fielding, R.,\
    \ Gettys, J., Mogul, J., Frystyk, H., Masinter, L.,\n        Leach, P. and T.\
    \ Berners-Lee, \"Hypertext Transfer Protocol --\n        HTTP/1.1\", RFC 2616,\
    \ June 1999.\n   [5]  Khare, R. and S. Lawrence, \"Upgrading to TLS Within HTTP/1.1\"\
    ,\n        RFC 2817, May 2000.\n"
- title: 10.  Contributors
  contents:
  - "10.  Contributors\n   ICAP is based on an original idea by John Martin and Peter\
    \ Danzig.\n   Many individuals and organizations have contributed to the\n   development\
    \ of ICAP, including the following contributors (past and\n   present):\n   Lee\
    \ Duggs\n   Network Appliance, Inc.\n   495 East Java Dr.\n   Sunnyvale, CA 94089\
    \ USA\n   Phone: (408) 822-6000\n   EMail: lee.duggs@netapp.com\n   Paul Eastham\n\
    \   Network Appliance, Inc.\n   495 East Java Dr.\n   Sunnyvale, CA 94089 USA\n\
    \   Phone: (408) 822-6000\n   EMail: eastham@netapp.com\n   Debbie Futcher\n \
    \  Network Appliance, Inc.\n   495 East Java Dr.\n   Sunnyvale, CA 94089 USA\n\
    \   Phone: (408) 822-6000\n   EMail: deborah.futcher@netapp.com\n   Don Gillies\n\
    \   Network Appliance, Inc.\n   495 East Java Dr.\n   Sunnyvale, CA 94089 USA\n\
    \   Phone: (408) 822-6000\n   EMail: gillies@netapp.com\n   Steven La\n   Network\
    \ Appliance, Inc.\n   495 East Java Dr.\n   Sunnyvale, CA 94089 USA\n   Phone:\
    \ (408) 822-6000\n   EMail: steven.la@netapp.com\n   John Martin\n   Network Appliance,\
    \ Inc.\n   495 East Java Dr.\n   Sunnyvale, CA 94089 USA\n   Phone: (408) 822-6000\n\
    \   EMail: jmartin@netapp.com\n   Jeff Merrick\n   Network Appliance, Inc.\n \
    \  495 East Java Dr.\n   Sunnyvale, CA 94089 USA\n   Phone: (408) 822-6000\n \
    \  EMail: jeffrey.merrick@netapp.com\n   John Schuster\n   Network Appliance,\
    \ Inc.\n   495 East Java Dr.\n   Sunnyvale, CA 94089 USA\n   Phone: (408) 822-6000\n\
    \   EMail: john.schuster@netapp.com\n   Edward Sharp\n   Network Appliance, Inc.\n\
    \   495 East Java Dr.\n   Sunnyvale, CA 94089 USA\n   Phone: (408) 822-6000\n\
    \   EMail: edward.sharp@netapp.com\n   Peter Danzig\n   Akamai Technologies\n\
    \   1400 Fashion Island Blvd\n   San Mateo, CA 94404 USA\n   Phone: (650) 372-5757\n\
    \   EMail: danzig@akamai.com\n   Mark Nottingham\n   Akamai Technologies\n   1400\
    \ Fashion Island Blvd\n   San Mateo, CA 94404 USA\n   Phone: (650) 372-5757\n\
    \   EMail: mnot@akamai.com\n   Nitin Sharma\n   Akamai Technologies\n   1400 Fashion\
    \ Island Blvd\n   San Mateo, CA 94404 USA\n   Phone: (650) 372-5757\n   EMail:\
    \ nitin@akamai.com\n   Hilarie Orman\n   Novell, Inc.\n   122 East 1700 South\n\
    \   Provo, UT 84606 USA\n   Phone: (801) 861-7021\n   EMail: horman@novell.com\n\
    \   Craig Blitz\n   Novell, Inc.\n   122 East 1700 South\n   Provo, UT 84606 USA\n\
    \   Phone: (801) 861-7021\n   EMail: cblitz@novell.com\n   Gary Tomlinson\n  \
    \ Novell, Inc.\n   122 East 1700 South\n   Provo, UT 84606 USA\n   Phone: (801)\
    \ 861-7021\n   EMail: garyt@novell.com\n   Andre Beck\n   Bell Laboratories /\
    \ Lucent Technologies\n   101 Crawfords Corner Road\n   Holmdel, New Jersey 07733-3030\n\
    \   Phone: (732) 332-5983\n   EMail: abeck@bell-labs.com\n   Markus Hofmann\n\
    \   Bell Laboratories / Lucent Technologies\n   101 Crawfords Corner Road\n  \
    \ Holmdel, New Jersey 07733-3030\n   Phone: (732) 332-5983\n   EMail: hofmann@bell-labs.com\n\
    \   David Bryant\n   CacheFlow, Inc.\n   650 Almanor Avenue\n   Sunnyvale, California\
    \ 94086\n   Phone: (888) 462-3568\n   EMail: david.bryant@cacheflow.com\n"
- title: Appendix A   BNF Grammar for ICAP Messages
  contents:
  - "Appendix A   BNF Grammar for ICAP Messages\n   This grammar is specified in terms\
    \ of the augmented Backus-Naur Form\n   (BNF) similar to that used by the HTTP/1.1\
    \ specification (See Section\n   2.1 of [4]).  Implementors will need to be familiar\
    \ with the notation\n   in order to understand this specification.\n   Many header\
    \ values (where noted) have exactly the same grammar and\n   semantics as in HTTP/1.1.\
    \  We do not reproduce those grammars here.\n   ICAP-Version = \"ICAP/1.0\"\n\
    \   ICAP-Message = Request | Response\n   Request      = Request-Line\n      \
    \            *(Request-Header CRLF)\n                  CRLF\n                \
    \  [ Request-Body ]\n   Request-Line = Method SP ICAP_URI SP ICAP-Version CRLF\n\
    \   Method       = \"REQMOD\"         ; Section 4.8\n                | \"RESPMOD\"\
    \        ; Section 4.9\n                | \"OPTIONS\"        ; Section 4.10\n\
    \                | Extension-Method ; Section 4.3.2\n   Extension-Method = token\n\
    \   ICAP_URI = Scheme \":\" Net_Path [ \"?\" Query ]  ; Section 4.2\n   Scheme\
    \      = \"icap\"\n   Net_Path    = \"//\" Authority [ Abs_Path ]\n   Authority\
    \   = [ userinfo \"@\" ] host [ \":\" port ]\n   Request-Header     = Request-Fields\
    \ \":\" [ Generic-Field-Value ]\n   Request-Fields     = Request-Field-Name\n\
    \                      | Common-Field-Name\n   ; Header fields specific to requests\n\
    \   Request-Field-Name = \"Authorization\"   ; Section 4.3.2\n               \
    \       | \"Allow\"           ; Section 4.3.2\n                      | \"From\"\
    \            ; Section 4.3.2\n                      | \"Host\"            ; Section\
    \ 4.3.2\n                      | \"Referer\"         ; Section 4.3.2\n       \
    \               | \"User-Agent\"      ; Section 4.3.2\n                      |\
    \ \"Preview\"         ; Section 4.5\n   ; Header fields common to both requests\
    \ and responses\n   Common-Field-Name  = \"Cache-Control\"   ; Section 4.3.1\n\
    \                      | \"Connection\"      ; Section 4.3.1\n               \
    \       | \"Date\"            ; Section 4.3.1\n                      | \"Expires\"\
    \         ; Section 4.3.1\n                      | \"Pragma\"          ; Section\
    \ 4.3.1\n                      | \"Trailer\"         ; Section 4.3.1\n       \
    \               | \"Upgrade\"         ; Section 4.3.1\n                      |\
    \ \"Encapsulated\"    ; Section 4.4\n                      | Extension-Field-Name\
    \   ; Section 4.3\n   Extension-Field-Name  = \"X-\" token\n   Generic-Field-Value\
    \   = *( Generic-Field-Content | LWS )\n   Generic-Field-Content = <the OCTETs\
    \ making up the field-value\n                            and consisting of either\
    \ *TEXT or\n                            combinations of token, separators,\n \
    \                           and quoted-string>\n   Request-Body = *OCTET   ; See\
    \ Sections 4.4 and 4.5 for semantics\n   Response    = Status-Line\n         \
    \        *(Response-Header CRLF)\n                 CRLF\n                 [ Response-Body\
    \ ]\n   Status-Line = ICAP-Version SP Status-Code SP Reason-Phrase CRLF\n   Status-Code\
    \ = \"100\"  ; Section 4.5\n               | \"101\"  ; Section 10.1.2 of [4]\n\
    \               | \"200\"  ; Section 10.2.1 of [4]\n               | \"201\" \
    \ ; Section 10.2.2 of [4]\n               | \"202\"  ; Section 10.2.3 of [4]\n\
    \               | \"203\"  ; Section 10.2.4 of [4]\n               | \"204\" \
    \ ; Section 4.6\n               | \"205\"  ; Section 10.2.6 of [4]\n         \
    \      | \"206\"  ; Section 10.2.7 of [4]\n               | \"300\"  ; Section\
    \ 10.3.1 of [4]\n               | \"301\"  ; Section 10.3.2 of [4]\n         \
    \      | \"302\"  ; Section 10.3.3 of [4]\n               | \"303\"  ; Section\
    \ 10.3.4 of [4]\n               | \"304\"  ; Section 10.3.5 of [4]\n         \
    \      | \"305\"  ; Section 10.3.6 of [4]\n               | \"306\"  ; Section\
    \ 10.3.7 of [4]\n               | \"307\"  ; Section 10.3.8 of [4]\n         \
    \      | \"400\"  ; Section 4.3.3\n               | \"401\"  ; Section 10.4.2\
    \ of [4]\n               | \"402\"  ; Section 10.4.3 of [4]\n               |\
    \ \"403\"  ; Section 10.4.4 of [4]\n               | \"404\"  ; Section 4.3.3\n\
    \               | \"405\"  ; Section 4.3.3\n               | \"406\"  ; Section\
    \ 10.4.7 of [4]\n               | \"407\"  ; Section 10.4.8 of [4]\n         \
    \      | \"408\"  ; Section 4.3.3\n               | \"409\"  ; Section 10.4.10\
    \ of [4]\n               | \"410\"  ; Section 10.4.11 of [4]\n               |\
    \ \"411\"  ; Section 10.4.12 of [4]\n               | \"412\"  ; Section 10.4.13\
    \ of [4]\n               | \"413\"  ; Section 10.4.14 of [4]\n               |\
    \ \"414\"  ; Section 10.4.15 of [4]\n               | \"415\"  ; Section 10.4.16\
    \ of [4]\n               | \"416\"  ; Section 10.4.17 of [4]\n               |\
    \ \"417\"  ; Section 10.4.18 of [4]\n               | \"500\"  ; Section 4.3.3\n\
    \               | \"501\"  ; Section 4.3.3\n               | \"502\"  ; Section\
    \ 4.3.3\n               | \"503\"  ; Section 4.3.3\n               | \"504\" \
    \ ; Section 10.5.5 of [4]\n               | \"505\"  ; Section 4.3.3\n       \
    \        | Extension-Code\n   Extension-Code = 3DIGIT\n   Reason-Phrase = *<TEXT,\
    \ excluding CR, LF>\n   Response-Header     = Response-Fields \":\" [ Generic-Field-Value\
    \ ]\n   Response-Fields     = Response-Field-Name\n                       | Common-Field-Name\n\
    \   Response-Field-Name = \"Server\"         ; Section 4.3.3\n               \
    \        | \"ISTag\"          ; Section 4.7\n   Response-Body = *OCTET  ; See\
    \ Sections 4.4 and 4.5 for semantics\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Jeremy Elson\n   University of California Los Angeles\n\
    \   Department of Computer Science\n   3440 Boelter Hall\n   Los Angeles CA 90095\n\
    \   Phone: (310) 206-3925\n   EMail: jelson@cs.ucla.edu\n   Alberto Cerpa\n  \
    \ University of California Los Angeles\n   Department of Computer Science\n  \
    \ 3440 Boelter Hall\n   Los Angeles CA 90095\n   Phone: (310) 206-3925\n   EMail:\
    \ cerpa@cs.ucla.edu\n   ICAP discussion currently takes place at\n           icap-discussions@yahoogroups.com.\n\
    \   For more information, see\n           http://groups.yahoo.com/group/icap-discussions/.\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2003).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
