- title: __initial_text__
  contents:
  - "                   RObust Header Compression (ROHC):\n      Framework and four\
    \ profiles: RTP, UDP, ESP, and uncompressed\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2001).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies a highly robust and efficient header\n \
    \  compression scheme for RTP/UDP/IP (Real-Time Transport Protocol, User\n   Datagram\
    \ Protocol, Internet Protocol), UDP/IP, and ESP/IP\n   (Encapsulating Security\
    \ Payload) headers.\n   Existing header compression schemes do not work well when\
    \ used over\n   links with significant error rates and long round-trip times.\
    \  For\n   many bandwidth limited links where header compression is essential,\n\
    \   such characteristics are common.\n   This is done in a framework designed\
    \ to be extensible.  For example,\n   a scheme for compressing TCP/IP headers\
    \ will be simple to add, and is\n   in development.  Headers specific to Mobile\
    \ IPv4 are not subject to\n   special treatment, but are expected to be compressed\
    \ sufficiently\n   well by the provided methods for compression of sequences of\n\
    \   extension headers and tunneling headers.  For the most part, the same\n  \
    \ will apply to work in progress on Mobile IPv6, but future work might\n   be\
    \ required to handle some extension headers, when a standards track\n   Mobile\
    \ IPv6 has been completed.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction....................................................6\n\
    \   2.  Terminology.....................................................8\n  \
    \ 2.1.  Acronyms.....................................................13\n   3.\
    \  Background.....................................................14\n   3.1.\
    \  Header compression fundamentals..............................14\n   3.2.  Existing\
    \ header compression schemes..........................14\n   3.3.  Requirements\
    \ on a new header compression scheme..............16\n   3.4.  Classification\
    \ of header fields..............................17\n   4.  Header compression\
    \ framework...................................18\n   4.1.  Operating assumptions........................................18\n\
    \   4.2.  Dynamicity...................................................19\n  \
    \ 4.3.  Compression and decompression states.........................21\n   4.3.1.\
    \  Compressor states..........................................21\n   4.3.1.1.\
    \  Initialization and Refresh (IR) State....................22\n   4.3.1.2.  First\
    \ Order (FO) State...................................22\n   4.3.1.3.  Second Order\
    \ (SO) State..................................22\n   4.3.2.  Decompressor states........................................23\n\
    \   4.4.  Modes of operation...........................................23\n  \
    \ 4.4.1.  Unidirectional mode -- U-mode..............................24\n   4.4.2.\
    \  Bidirectional Optimistic mode -- O-mode....................25\n   4.4.3.  Bidirectional\
    \ Reliable mode -- R-mode......................25\n   4.5.  Encoding methods.............................................25\n\
    \   4.5.1.  Least Significant Bits (LSB) encoding .....................25\n  \
    \ 4.5.2.  Window-based LSB encoding (W-LSB encoding).................28\n   4.5.3.\
    \  Scaled RTP Timestamp encoding .............................28\n   4.5.4.  Timer-based\
    \ compression of RTP Timestamp...................31\n   4.5.5.  Offset IP-ID encoding......................................34\n\
    \   4.5.6.  Self-describing variable-length values ....................35\n  \
    \ 4.5.7.  Encoded values across several fields in compressed headers 36\n   4.6.\
    \  Errors caused by residual errors.............................36\n   4.7.  Impairment\
    \ considerations....................................37\n   5.  The protocol...................................................39\n\
    \   5.1.  Data structures..............................................39\n  \
    \ 5.1.1.  Per-channel parameters.....................................39\n   5.1.2.\
    \  Per-context parameters, profiles...........................40\n   5.1.3.  Contexts\
    \ and context identifiers ..........................41\n   5.2.  ROHC packets\
    \ and packet types................................41\n   5.2.1.  ROHC feedback\
    \ .............................................43\n   5.2.2.  ROHC feedback format\
    \ ......................................45\n   5.2.3.  ROHC IR packet type .......................................47\n\
    \   5.2.4.  ROHC IR-DYN packet type ...................................48\n  \
    \ 5.2.5.  ROHC segmentation..........................................49\n   5.2.5.1.\
    \  Segmentation usage considerations........................49\n   5.2.5.2.  Segmentation\
    \ protocol....................................50\n   5.2.6.  ROHC initial decompressor\
    \ processing.......................51\n   5.2.7.  ROHC RTP packet formats from\
    \ compressor to decompressor....53\n   5.2.8.  Parameters needed for mode transition\
    \ in ROHC RTP..........54\n   5.3.  Operation in Unidirectional mode.............................55\n\
    \   5.3.1.  Compressor states and logic (U-mode).......................55\n  \
    \ 5.3.1.1.  State transition logic (U-mode)..........................55\n   5.3.1.1.1.\
    \  Optimistic approach, upwards transition................55\n   5.3.1.1.2.  Timeouts,\
    \ downward transition..........................56\n   5.3.1.1.3.  Need for updates,\
    \ downward transition..................56\n   5.3.1.2.  Compression logic and\
    \ packets used (U-mode)..............56\n   5.3.1.3.  Feedback in Unidirectional\
    \ mode..........................56\n   5.3.2.  Decompressor states and logic (U-mode).....................56\n\
    \   5.3.2.1.  State transition logic (U-mode)..........................57\n  \
    \ 5.3.2.2.  Decompression logic (U-mode).............................57\n   5.3.2.2.1.\
    \  Decide whether decompression is allowed................57\n   5.3.2.2.2.  Reconstruct\
    \ and verify the header......................57\n   5.3.2.2.3.  Actions upon CRC\
    \ failure...............................58\n   5.3.2.2.4.  Correction of SN LSB\
    \ wraparound........................60\n   5.3.2.2.5.  Repair of incorrect SN\
    \ updates.........................61\n   5.3.2.3.  Feedback in Unidirectional\
    \ mode..........................62\n   5.4.  Operation in Bidirectional Optimistic\
    \ mode...................62\n   5.4.1.  Compressor states and logic (O-mode).......................62\n\
    \   5.4.1.1.  State transition logic...................................63\n  \
    \ 5.4.1.1.1.  Negative acknowledgments (NACKs), downward transition..63\n   5.4.1.1.2.\
    \  Optional acknowledgments, upwards transition...........63\n   5.4.1.2.  Compression\
    \ logic and packets used.......................63\n   5.4.2.  Decompressor states\
    \ and logic (O-mode).....................64\n   5.4.2.1.  Decompression logic,\
    \ timer-based timestamp decompression.64\n   5.4.2.2.  Feedback logic (O-mode)..................................64\n\
    \   5.5.  Operation in Bidirectional Reliable mode.....................65\n  \
    \ 5.5.1.  Compressor states and logic (R-mode).......................65\n   5.5.1.1.\
    \  State transition logic (R-mode)..........................65\n   5.5.1.1.1.\
    \  Upwards transition.....................................65\n   5.5.1.1.2.  Downward\
    \ transition....................................66\n   5.5.1.2.  Compression logic\
    \ and packets used (R-mode)..............66\n   5.5.2.  Decompressor states and\
    \ logic (R-mode).....................68\n   5.5.2.1.  Decompression logic (R-mode).............................68\n\
    \   5.5.2.2.  Feedback logic (R-mode)..................................68\n  \
    \ 5.6.  Mode transitions.............................................69\n   5.6.1.\
    \  Compression and decompression during mode transitions......70\n   5.6.2.  Transition\
    \ from Unidirectional to Optimistic mode..........71\n   5.6.3.  From Optimistic\
    \ to Reliable mode...........................72\n   5.6.4.  From Unidirectional\
    \ to Reliable mode.......................72\n   5.6.5.  From Reliable to Optimistic\
    \ mode...........................72\n   5.6.6.  Transition to Unidirectional mode..........................73\n\
    \   5.7.  Packet formats...............................................74\n  \
    \ 5.7.1.  Packet type 0: UO-0, R-0, R-0-CRC .........................78\n   5.7.2.\
    \  Packet type 1 (R-mode): R-1, R-1-TS, R-1-ID ...............79\n   5.7.3.  Packet\
    \ type 1 (U/O-mode): UO-1, UO-1-ID, UO-1-TS ..........80\n   5.7.4.  Packet type\
    \ 2: UOR-2 ......................................82\n   5.7.5.  Extension formats..........................................83\n\
    \   5.7.5.1.  RND flags and packet types...............................88\n  \
    \ 5.7.5.2.  Flags/Fields in context..................................89\n   5.7.6.\
    \  Feedback packets and formats...............................90\n   5.7.6.1.\
    \  Feedback formats for ROHC RTP............................90\n   5.7.6.2.  ROHC\
    \ RTP Feedback options................................91\n   5.7.6.3.  The CRC\
    \ option...........................................92\n   5.7.6.4.  The REJECT\
    \ option........................................92\n   5.7.6.5.  The SN-NOT-VALID\
    \ option..................................92\n   5.7.6.6.  The SN option............................................93\n\
    \   5.7.6.7.  The CLOCK option.........................................93\n  \
    \ 5.7.6.8.  The JITTER option........................................93\n   5.7.6.9.\
    \  The LOSS option..........................................94\n   5.7.6.10. \
    \ Unknown option types....................................94\n   5.7.6.11.  RTP\
    \ feedback example....................................94\n   5.7.7.  RTP IR and\
    \ IR-DYN packets..................................96\n   5.7.7.1.  Basic structure\
    \ of the IR packet.........................96\n   5.7.7.2.  Basic structure of\
    \ the IR-DYN packet.....................98\n   5.7.7.3.  Initialization of IPv6\
    \ Header [IPv6].....................99\n   5.7.7.4.  Initialization of IPv4 Header\
    \ [IPv4, section 3.1].......100\n   5.7.7.5.  Initialization of UDP Header [RFC-768]..................101\n\
    \   5.7.7.6.  Initialization of RTP Header [RTP]......................102\n  \
    \ 5.7.7.7.  Initialization of ESP Header [ESP, section 2]...........103\n   5.7.7.8.\
    \  Initialization of Other Headers.........................104\n   5.8.  List\
    \ compression............................................104\n   5.8.1.  Table-based\
    \ item compression..............................105\n   5.8.1.1.  Translation\
    \ table in R-mode.............................105\n   5.8.1.2.  Translation table\
    \ in U/O-modes..........................106\n   5.8.2.  Reference list determination..............................106\n\
    \   5.8.2.1.  Reference list in R-mode and U/O-mode...................107\n  \
    \ 5.8.3.  Encoding schemes for the compressed list..................109\n   5.8.4.\
    \  Special handling of IP extension headers..................112\n   5.8.4.1.\
    \  Next Header field.......................................112\n   5.8.4.2.  Authentication\
    \ Header (AH)..............................114\n   5.8.4.3.  Encapsulating Security\
    \ Payload Header (ESP).............115\n   5.8.4.4.  GRE Header [RFC 2784, RFC\
    \ 2890].........................117\n   5.8.5.  Format of compressed lists in\
    \ Extension 3.................119\n   5.8.5.1.  Format of IP Extension Header(s)\
    \ field..................119\n   5.8.5.2.  Format of Compressed CSRC List..........................120\n\
    \   5.8.6.  Compressed list formats...................................120\n  \
    \ 5.8.6.1.  Encoding Type 0 (generic scheme)........................120\n   5.8.6.2.\
    \  Encoding Type 1 (insertion only scheme).................122\n   5.8.6.3.  Encoding\
    \ Type 2 (removal only scheme)...................123\n   5.8.6.4.  Encoding Type\
    \ 3 (remove then insert scheme).............124\n   5.8.7.  CRC coverage for extension\
    \ headers........................124\n   5.9.  Header compression CRCs, coverage\
    \ and polynomials...........125\n   5.9.1.  IR and IR-DYN packet CRCs.................................125\n\
    \   5.9.2.  CRCs in compressed headers................................125\n  \
    \ 5.10.  ROHC UNCOMPRESSED -- no compression (Profile 0x0000).......126\n   5.10.1.\
    \  IR packet................................................126\n   5.10.2.  Normal\
    \ packet............................................127\n   5.10.3.  States and\
    \ modes.........................................128\n   5.10.4.  Feedback.................................................129\n\
    \   5.11.  ROHC UDP -- non-RTP UDP/IP compression (Profile 0x0002)....129\n  \
    \ 5.11.1.  Initialization...........................................130\n   5.11.2.\
    \  States and modes.........................................130\n   5.11.3.  Packet\
    \ types.............................................131\n   5.11.4.  Extensions...............................................132\n\
    \   5.11.5.  IP-ID....................................................133\n  \
    \ 5.11.6.  Feedback.................................................133\n   5.12.\
    \  ROHC ESP -- ESP/IP compression (Profile 0x0003)............133\n   5.12.1.\
    \  Initialization...........................................133\n   5.12.2.  Packet\
    \ types.............................................134\n   6.  Implementation\
    \ issues.........................................134\n   6.1.  Reverse decompression.......................................134\n\
    \   6.2.  RTCP........................................................135\n  \
    \ 6.3.  Implementation parameters and signals.......................136\n   6.3.1.\
    \  ROHC implementation parameters at compressor..............137\n   6.3.2.  ROHC\
    \ implementation parameters at decompressor............138\n   6.4.  Handling\
    \ of resource limitations at the decompressor........139\n   6.5.  Implementation\
    \ structures...................................139\n   6.5.1.  Compressor context........................................139\n\
    \   6.5.2.  Decompressor context......................................141\n  \
    \ 6.5.3.  List compression: Sliding windows in R-mode and U/O-mode..142\n   7.\
    \  Security Considerations.......................................143\n   8.  IANA\
    \ Considerations...........................................144\n   9.  Acknowledgments...............................................145\n\
    \   10.  Intellectual Property Right Claim Considerations.............145\n  \
    \ 11.  References...................................................146\n   11.1.\
    \  Normative References.......................................146\n   11.2.  Informative\
    \ References.....................................147\n   12.  Authors' Addresses...........................................148\n\
    \   Appendix A.  Detailed classification of header fields.............152\n  \
    \ A.1.  General classification......................................153\n   A.1.1.\
    \  IPv6 header fields........................................153\n   A.1.2.  IPv4\
    \ header fields........................................155\n   A.1.3.  UDP header\
    \ fields.........................................157\n   A.1.4.  RTP header fields.........................................157\n\
    \   A.1.5.  Summary for IP/UDP/RTP....................................159\n  \
    \ A.2.  Analysis of change patterns of header fields................159\n   A.2.1.\
    \  IPv4 Identification.......................................162\n   A.2.2.  IP\
    \ Traffic-Class / Type-Of-Service........................163\n   A.2.3.  IP Hop-Limit\
    \ / Time-To-Live...............................163\n   A.2.4.  UDP Checksum..............................................163\n\
    \   A.2.5.  RTP CSRC Counter..........................................164\n  \
    \ A.2.6.  RTP Marker................................................164\n   A.2.7.\
    \  RTP Payload Type..........................................164\n   A.2.8.  RTP\
    \ Sequence Number.......................................164\n   A.2.9.  RTP Timestamp.............................................164\n\
    \   A.2.10.  RTP Contributing Sources (CSRC)..........................165\n  \
    \ A.3.  Header compression strategies...............................165\n   A.3.1.\
    \  Do not send at all........................................165\n   A.3.2.  Transmit\
    \ only initially...................................165\n   A.3.3.  Transmit initially,\
    \ but be prepared to update.............166\n   A.3.4.  Be prepared to update\
    \ or send as-is frequently............166\n   A.3.5.  Guarantee continuous robustness...........................166\n\
    \   A.3.6.  Transmit as-is in all packets.............................167\n  \
    \ A.3.7.  Establish and be prepared to update delta.................167\n   Full\
    \ Copyright Statement..........................................168\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   During the last five years, two communication technologies\
    \ in\n   particular have become commonly used by the general public: cellular\n\
    \   telephony and the Internet.  Cellular telephony has provided its\n   users\
    \ with the revolutionary possibility of always being reachable\n   with reasonable\
    \ service quality no matter where they are.  The main\n   service provided by\
    \ the dedicated terminals has been speech.  The\n   Internet, on the other hand,\
    \ has from the beginning been designed for\n   multiple services and its flexibility\
    \ for all kinds of usage has been\n   one of its strengths.  Internet terminals\
    \ have usually been general-\n   purpose and have been attached over fixed connections.\
    \  The\n   experienced quality of some services (such as Internet telephony) has\n\
    \   sometimes been low.\n   Today, IP telephony is gaining momentum thanks to\
    \ improved technical\n   solutions.  It seems reasonable to believe that in the\
    \ years to come,\n   IP will become a commonly used way to carry telephony.  Some\
    \ future\n   cellular telephony links might also be based on IP and IP telephony.\n\
    \   Cellular phones may have become more general-purpose, and may have IP\n  \
    \ stacks supporting not only audio and video, but also web browsing,\n   email,\
    \ gaming, etc.\n   One of the scenarios we are envisioning might then be the one\
    \ in\n   Figure 1.1, where two mobile terminals are communicating with each\n\
    \   other.  Both are connected to base stations over cellular links, and\n   the\
    \ base stations are connected to each other through a wired (or\n   possibly wireless)\
    \ network.  Instead of two mobile terminals, there\n   could of course be one\
    \ mobile and one wired terminal, but the case\n   with two cellular links is technically\
    \ more demanding.\n   Mobile            Base                      Base       \
    \     Mobile\n   Terminal          Station                   Station         Terminal\n\
    \         |  ~   ~   ~  \\ /                       \\ /  ~   ~   ~   ~  |\n  \
    \       |              |                         |                  |\n      +--+\
    \              |                         |               +--+\n      |  |    \
    \          |                         |               |  |\n      |  |        \
    \      |                         |               |  |\n      +--+            \
    \  |                         |               +--+\n                        | \
    \                        |\n                        |=========================|\n\
    \            Cellular              Wired               Cellular\n            Link\
    \                  Network             Link\n        Figure 1.1 : Scenario for\
    \ IP telephony over cellular links\n   It is obvious that the wired network can\
    \ be IP-based.  With the\n   cellular links, the situation is less clear.  IP\
    \ could be terminated\n   in the fixed network, and special solutions implemented\
    \ for each\n   supported service over the cellular link.  However, this would\
    \ limit\n   the flexibility of the services supported.  If technically and\n \
    \  economically feasible, a solution with pure IP all the way from\n   terminal\
    \ to terminal would have certain advantages.  However, to make\n   this a viable\
    \ alternative, a number of problems have to be addressed,\n   in particular problems\
    \ regarding bandwidth efficiency.\n   For cellular phone systems, it is of vital\
    \ importance to use the\n   scarce radio resources in an efficient way.  A sufficient\
    \ number of\n   users per cell is crucial, otherwise deployment costs will be\n\
    \   prohibitive.  The quality of the voice service should also be as good\n  \
    \ as in today's cellular systems.  It is likely that even with support\n   for\
    \ new services, lower quality of the voice service is acceptable\n   only if costs\
    \ are significantly reduced.\n   A problem with IP over cellular links when used\
    \ for interactive voice\n   conversations is the large header overhead.  Speech\
    \ data for IP\n   telephony will most likely be carried by RTP [RTP].  A packet\
    \ will\n   then, in addition to link layer framing, have an IP [IPv4] header (20\n\
    \   octets), a UDP [UDP] header (8 octets), and an RTP header (12 octets)\n  \
    \ for a total of 40 octets.  With IPv6 [IPv6], the IP header is 40\n   octets\
    \ for a total of 60 octets.  The size of the payload depends on\n   the speech\
    \ coding and frame sizes being used and may be as low as\n   15-20 octets.\n \
    \  From these numbers, the need for reducing header sizes for efficiency\n   reasons\
    \ is obvious.  However, cellular links have characteristics\n   that make header\
    \ compression as defined in [IPHC,CRTP] perform less\n   than well.  The most\
    \ important characteristic is the lossy behavior\n   of cellular links, where\
    \ a bit error rate (BER) as high as 1e-3 must\n   be accepted to keep the radio\
    \ resources efficiently utilized.  In\n   severe operating situations, the BER\
    \ can be as high as 1e-2.  The\n   other problematic characteristic is the long\
    \ round-trip time (RTT) of\n   the cellular link, which can be as high as 100-200\
    \ milliseconds.  An\n   additional problem is that the residual BER is nontrivial,\
    \ i.e.,\n   lower layers can sometimes deliver frames containing undetected\n\
    \   errors.  A viable header compression scheme for cellular links must\n   be\
    \ able to handle loss on the link between the compression and\n   decompression\
    \ point as well as loss before the compression point.\n   Bandwidth is the most\
    \ costly resource in cellular links.  Processing\n   power is very cheap in comparison.\
    \  Implementation or computational\n   simplicity of a header compression scheme\
    \ is therefore of less\n   importance than its compression ratio and robustness.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC\
    \ 2119.\n   BER\n      Bit Error Rate.  Cellular radio links can have a fairly\
    \ high BER.\n      In this document BER is usually given as a probability, but\
    \ one\n      also needs to consider the error distribution as bit errors are\n\
    \      not independent.\n   Cellular links\n      Wireless links between mobile\
    \ terminals and base stations.\n   Compression efficiency\n      The performance\
    \ of a header compression scheme can be described\n      with three parameters:\
    \ compression efficiency, robustness and\n      compression transparency.  The\
    \ compression efficiency is\n      determined by how much the header sizes are\
    \ reduced by the\n      compression scheme.\n   Compression transparency\n   \
    \   The performance of a header compression scheme can be described\n      with\
    \ three parameters: compression efficiency, robustness, and\n      compression\
    \ transparency.  The compression transparency is a\n      measure of the extent\
    \ to which the scheme ensures that the\n      decompressed headers are semantically\
    \ identical to the original\n      headers.  If all decompressed headers are semantically\
    \ identical\n      to the corresponding original headers, the transparency is\
    \ 100\n      percent.  Compression transparency is high when damage propagation\n\
    \      is low.\n   Context\n      The context of the compressor is the state it\
    \ uses to compress a\n      header.  The context of the decompressor is the state\
    \ it uses to\n      decompress a header.  Either of these or the two in combination\n\
    \      are usually referred to as \"context\", when it is clear which is\n   \
    \   intended.  The context contains relevant information from previous\n     \
    \ headers in the packet stream, such as static fields and possible\n      reference\
    \ values for compression and decompression.  Moreover,\n      additional information\
    \ describing the packet stream is also part\n      of the context, for example\
    \ information about how the IP\n      Identifier field changes and the typical\
    \ inter-packet increase in\n      sequence numbers or timestamps.\n   Context\
    \ damage\n      When the context of the decompressor is not consistent with the\n\
    \      context of the compressor, decompression may fail to reproduce the\n  \
    \    original header.  This situation can occur when the context of the\n    \
    \  decompressor has not been initialized properly or when packets\n      have\
    \ been lost or damaged between compressor and decompressor.\n      Packets which\
    \ cannot be decompressed due to inconsistent contexts\n      are said to be lost\
    \ due to context damage.  Packets that are\n      decompressed but contain errors\
    \ due to inconsistent contexts are\n      said to be damaged due to context damage.\n\
    \   Context repair mechanism\n      Context repair mechanisms are mechanisms that\
    \ bring the contexts\n      in sync when they were not.  This is needed to avoid\
    \ excessive\n      loss due to context damage.  Examples are the context request\n\
    \      mechanism of CRTP, the NACK mechanisms of O- and R-mode, and the\n    \
    \  periodic refreshes of U-mode.\n      Note that there are also mechanisms that\
    \ prevent (some) context\n      inconsistencies from occurring, for example the\
    \ ACK-based updates\n      of the context in R-mode, the repetitions after change\
    \ in U- and\n      O-mode, and the CRCs which protect context updating information.\n\
    \   CRC-DYNAMIC\n      Opposite of CRC-STATIC.\n   CRC-STATIC\n      A CRC over\
    \ the original header is the primary mechanism used by\n      ROHC to detect incorrect\
    \ decompression.  In order to decrease\n      computational complexity, the fields\
    \ of the header are\n      conceptually rearranged when the CRC is computed, so\
    \ that it is\n      first computed over octets which are static (called CRC-STATIC\
    \ in\n      this document) and then over octets whose values are expected to\n\
    \      change between packets (CRC-DYNAMIC).  In this manner, the\n      intermediate\
    \ result of the CRC computation, after it has covered\n      the CRC-STATIC fields,\
    \ can be reused for several packets.  The\n      restarted CRC computation only\
    \ covers the CRC-DYNAMIC octets.  See\n      section 5.9.\n   Damage propagation\n\
    \      Delivery of incorrect decompressed headers, due to errors in\n      (i.e.,\
    \ loss of or damage to) previous header(s) or feedback.\n   Loss propagation\n\
    \      Loss of headers, due to errors in (i.e., loss of or damage to)\n      previous\
    \ header(s)or feedback.\n   Error detection\n      Detection of errors.  If error\
    \ detection is not perfect, there\n      will be residual errors.\n   Error propagation\n\
    \      Damage propagation or loss propagation.\n   Header compression profile\n\
    \      A header compression profile is a specification of how to compress\n  \
    \    the headers of a certain kind of packet stream over a certain kind\n    \
    \  of link.  Compression profiles provide the details of the header\n      compression\
    \ framework introduced in this document.  The profile\n      concept makes use\
    \ of profile identifiers to separate different\n      profiles which are used\
    \ when setting up the compression scheme.\n      All variations and parameters\
    \ of the header compression scheme\n      that are not part of the context state\
    \ are handled by different\n      profile identifiers.\n   Packet\n      Generally,\
    \ a unit of transmission and reception (protocol data\n      unit).  Specifically,\
    \ when contrasted with \"frame\", the packet\n      compressed and then decompressed\
    \ by ROHC.  Also called\n      \"uncompressed packet\".\n   Packet Stream\n  \
    \    A sequence of packets where the field values and change patterns\n      of\
    \ field values are such that the headers can be compressed using\n      the same\
    \ context.\n   Pre-HC links\n      The Pre-HC links are all links that a packet\
    \ has traversed before\n      the header compression point.  If we consider a\
    \ path with cellular\n      links as first and last hops, the Pre-HC links for\
    \ the compressor\n      at the last link are the first cellular link plus the\
    \ wired links\n      in between.\n   Residual error\n      Error introduced during\
    \ transmission and not detected by lower-\n      layer error detection schemes.\n\
    \   Robustness\n      The performance of a header compression scheme can be described\n\
    \      with three parameters: compression efficiency, robustness, and\n      compression\
    \ transparency.  A robust scheme tolerates loss and\n      residual errors on\
    \ the link over which header compression takes\n      place without losing additional\
    \ packets or introducing additional\n      errors in decompressed headers.\n \
    \  RTT\n      The RTT (round-trip time) is the time elapsing from the moment the\n\
    \      compressor sends a packet until it receives feedback related to\n     \
    \ that packet (when such feedback is sent).\n   Spectrum efficiency\n      Radio\
    \ resources are limited and expensive.  Therefore they must be\n      used efficiently\
    \ to make the system economically feasible.  In\n      cellular systems this is\
    \ achieved by maximizing the number of\n      users served within each cell, while\
    \ the quality of the provided\n      services is kept at an acceptable level.\
    \  A consequence of\n      efficient spectrum use is a high rate of errors (frame\
    \ loss and\n      residual bit errors), even after channel coding with error\n\
    \      correction.\n   String\n      A sequence of headers in which the values\
    \ of all fields being\n      compressed change according to a pattern which is\
    \ fixed with\n      respect to a sequence number.  Each header in a string can\
    \ be\n      compressed by representing it with a ROHC header which essentially\n\
    \      only carries an encoded sequence number.  Fields not being\n      compressed\
    \ (e.g., random IP-ID, UDP Checksum) are irrelevant to\n      this definition.\n\
    \   Timestamp stride\n      The timestamp stride (TS_STRIDE) is the expected increase\
    \ in the\n      timestamp value between two RTP packets with consecutive sequence\n\
    \      numbers.\n"
- title: 2.1.  Acronyms
  contents:
  - "2.1.  Acronyms\n   This section lists most acronyms used for reference.\n   AH\
    \     Authentication Header.\n   CID    Context Identifier.\n   CRC    Cyclic\
    \ Redundancy Check.  Error detection mechanism.\n   CRTP   Compressed RTP.  RFC\
    \ 2508.\n   CTCP   Compressed TCP.  Also called VJ header compression.  RFC 1144.\n\
    \   ESP    Encapsulating Security Payload.\n   FC     Full Context state (decompressor).\n\
    \   FO     First Order state (compressor).\n   GRE    Generic Routing Encapsulation.\
    \  RFC 2784, RFC 2890.\n   HC     Header Compression.\n   IPHC   IP Header Compression.\
    \  RFC 2507.\n   IPX    Flag in Extension 2.\n   IR     Initiation and Refresh\
    \ state (compressor).  Also IR packet.\n   IR-DYN IR-DYN packet.\n   LSB    Least\
    \ Significant Bits.\n   MRRU   Maximum Reconstructed Reception Unit.\n   MTU \
    \   Maximum Transmission Unit.\n   MSB    Most Significant Bits.\n   NBO    Flag\
    \ indicating whether the IP-ID is in Network Byte Order.\n   NC     No Context\
    \ state (decompressor).\n   O-mode Bidirectional Optimistic mode.\n   PPP    Point-to-Point\
    \ Protocol.\n   R-mode Bidirectional Reliable mode.\n   RND    Flag indicating\
    \ whether the IP-ID behaves randomly.\n   ROHC   RObust Header Compression.\n\
    \   RTCP   Real-Time Control Protocol.  See RTP.\n   RTP    Real-Time Protocol.\
    \  RFC 1889.\n   RTT    Round Trip Time (see section 2).\n   SC     Static Context\
    \ state (decompressor).\n   SN     (compressed) Sequence Number.  Usually RTP\
    \ Sequence Number.\n   SO     Second Order state (compressor).\n   SPI    Security\
    \ Parameters Index.\n   SSRC   Sending source.  Field in RTP header.\n   CSRC\
    \   Contributing source.  Optional list of CSRCs in RTP header.\n   TC     Traffic\
    \ Class.  Octet in IPv6 header.  See also TOS.\n   TOS    Type Of Service.  Octet\
    \ in IPv4 header.  See also TC.\n   TS     (compressed) RTP Timestamp.\n   U-mode\
    \ Unidirectional mode.\n   W-LSB  Window based LSB encoding.  See section 4.5.2.\n"
- title: 3.  Background
  contents:
  - "3.  Background\n   This chapter provides a background to the subject of header\n\
    \   compression.  The fundamental ideas are described together with\n   existing\
    \ header compression schemes.  Their drawbacks and\n   requirements are then discussed,\
    \ providing motivation for new header\n   compression solutions.\n"
- title: 3.1.  Header compression fundamentals
  contents:
  - "3.1.  Header compression fundamentals\n   The main reason why header compression\
    \ can be done at all is the fact\n   that there is significant redundancy between\
    \ header fields, both\n   within the same packet header but in particular between\
    \ consecutive\n   packets belonging to the same packet stream.  By sending static\
    \ field\n   information only initially and utilizing dependencies and\n   predictability\
    \ for other fields, the header size can be significantly\n   reduced for most\
    \ packets.\n   Relevant information from past packets is maintained in a context.\n\
    \   The context information is used to compress (decompress) subsequent\n   packets.\
    \  The compressor and decompressor update their contexts upon\n   certain events.\
    \  Impairment events may lead to inconsistencies\n   between the contexts of the\
    \ compressor and decompressor, which in\n   turn may cause incorrect decompression.\
    \  A robust header compression\n   scheme needs mechanisms for avoiding context\
    \ inconsistencies and also\n   needs mechanisms for making the contexts consistent\
    \ when they were\n   not.\n"
- title: 3.2.  Existing header compression schemes
  contents:
  - "3.2.  Existing header compression schemes\n   The original header compression\
    \ scheme, CTCP [VJHC], was invented by\n   Van Jacobson.  CTCP compresses the\
    \ 40 octet IP+TCP header to 4\n   octets.  The CTCP compressor detects transport-level\
    \ retransmissions\n   and sends a header that updates the context completely when\
    \ they\n   occur.  This repair mechanism does not require any explicit signaling\n\
    \   between compressor and decompressor.\n   A general IP header compression scheme,\
    \ IP header compression [IPHC],\n   improves somewhat on CTCP and can compress\
    \ arbitrary IP, TCP, and UDP\n   headers.  When compressing non-TCP headers, IPHC\
    \ does not use delta\n   encoding and is robust.  When compressing TCP, the repair\
    \ mechanism\n   of CTCP is augmented with a link-level nacking scheme which speeds\
    \ up\n   the repair.  IPHC does not compress RTP headers.\n   CRTP [CRTP, IPHC]\
    \ by Casner and Jacobson is a header compression\n   scheme that compresses 40\
    \ octets of IPv4/UDP/RTP headers to a minimum\n   of 2 octets when the UDP Checksum\
    \ is not enabled.  If the UDP\n   Checksum is enabled, the minimum CRTP header\
    \ is 4 octets.  CRTP\n   cannot use the same repair mechanism as CTCP since UDP/RTP\
    \ does not\n   retransmit.  Instead, CRTP uses explicit signaling messages from\n\
    \   decompressor to compressor, called CONTEXT_STATE messages, to\n   indicate\
    \ that the context is out of sync.  The link round-trip time\n   will thus limit\
    \ the speed of this context repair mechanism.\n   On lossy links with long round-trip\
    \ times, such as most cellular\n   links, CRTP does not perform well.  Each lost\
    \ packet over the link\n   causes several subsequent packets to be lost since\
    \ the context is out\n   of sync during at least one link round-trip time.  This\
    \ behavior is\n   documented in [CRTPC].  For voice conversations such long loss\
    \ events\n   will degrade the voice quality.  Moreover, bandwidth is wasted by\
    \ the\n   large headers sent by CRTP when updating the context.  [CRTPC] found\n\
    \   that CRTP did not perform well enough for a lossy cellular link.  It\n   is\
    \ clear that CRTP alone is not a viable header compression scheme\n   for IP telephony\
    \ over cellular links.\n   To avoid losing packets due to the context being out\
    \ of sync, CRTP\n   decompressors can attempt to repair the context locally by\
    \ using a\n   mechanism known as TWICE.  Each CRTP packet contains a counter which\n\
    \   is incremented by one for each packet sent out by the CRTP\n   compressor.\
    \  If the counter increases by more than one, at least one\n   packet was lost\
    \ over the link.  The decompressor then attempts to\n   repair the context by\
    \ guessing how the lost packet(s) would have\n   updated it.  The guess is then\
    \ verified by decompressing the packet\n   and checking the UDP Checksum -- if\
    \ it succeeds, the repair is deemed\n   successful and the packet can be forwarded\
    \ or delivered.  TWICE\n   derives its name from the observation that when the\
    \ compressed packet\n   stream is regular, the correct guess is to apply the update\
    \ in the\n   current packet twice.  [CRTPC] found that even with TWICE, CRTP\n\
    \   doubled the number of lost packets.  TWICE improves CRTP performance\n   significantly.\
    \  However, there are several problems with using TWICE:\n   1) It becomes mandatory\
    \ to use the UDP Checksum:\n      - the minimal compressed header size increases\
    \ by 100% to 4\n        octets.\n      - most speech codecs developed for cellular\
    \ links tolerate errors\n        in the encoded data.  Such codecs will not want\
    \ to enable the\n        UDP Checksum, since they do want damaged packets to be\n\
    \        delivered.\n      - errors in the payload will make the UDP Checksum\
    \ fail when the\n        guess is correct (and might make it succeed when the\
    \ guess is\n        wrong).\n   2) Loss in an RTP stream that occurs before the\
    \ compression point\n      will make updates in CRTP headers less regular.  Simple-minded\n\
    \      versions of TWICE will then perform badly.  More sophisticated\n      versions\
    \ would need more repair attempts to succeed.\n"
- title: 3.3.  Requirements on a new header compression scheme
  contents:
  - "3.3.  Requirements on a new header compression scheme\n   The major problem with\
    \ CRTP is that it is not sufficiently robust\n   against packets being damaged\
    \ between compressor and decompressor.  A\n   viable header compression scheme\
    \ must be less fragile.  This\n   increased robustness must be obtained without\
    \ increasing the\n   compressed header size; a larger header would make IP telephony\
    \ over\n   cellular links economically unattractive.\n   A major cause of the\
    \ bad performance of CRTP over cellular links is\n   the long link round-trip\
    \ time, during which many packets are lost\n   when the context is out of sync.\
    \  This problem can be attacked\n   directly by finding ways to reduce the link\
    \ round-trip time.  Future\n   generations of cellular technologies may indeed\
    \ achieve lower link\n   round-trip times.  However, these will probably always\
    \ be fairly\n   high.  The benefits in terms of lower loss and smaller bandwidth\n\
    \   demands if the context can be repaired locally will be present even\n   if\
    \ the link round-trip time is decreased.  A reliable way to detect a\n   successful\
    \ context repair is then needed.\n   One might argue that a better way to solve\
    \ the problem is to improve\n   the cellular link so that packet loss is less\
    \ likely to occur.  Such\n   modifications do not appear to come for free, however.\
    \  If links were\n   made (almost) error free, the system might not be able to\
    \ support a\n   sufficiently large number of users per cell and might thus be\n\
    \   economically infeasible.\n   One might also argue that the speech codecs should\
    \ be able to deal\n   with the kind of packet loss induced by CRTP, in particular\
    \ since the\n   speech codecs probably must be able to deal with packet loss anyway\n\
    \   if the RTP stream crosses the Internet.  While the latter is true,\n   the\
    \ kind of loss induced by CRTP is difficult to deal with.  It is\n   usually not\
    \ possible to completely hide a loss event where well over\n   100 ms worth of\
    \ sound is completely lost.  If such loss occurs\n   frequently at both ends of\
    \ the end-to-end path, the speech quality\n   will suffer.\n   A detailed description\
    \ of the requirements specified for ROHC may be\n   found in [REQ].\n"
- title: 3.4.  Classification of header fields
  contents:
  - "3.4.  Classification of header fields\n   As mentioned earlier, header compression\
    \ is possible due to the fact\n   that there is much redundancy between header\
    \ field values within\n   packets, but especially between consecutive packets.\
    \  To utilize\n   these properties for header compression, it is important to\n\
    \   understand the change patterns of the various header fields.\n   All header\
    \ fields have been classified in detail in appendix A.  The\n   fields are first\
    \ classified at a high level and then some of them are\n   studied more in detail.\
    \  Finally, the appendix concludes with\n   recommendations on how the various\
    \ fields should be handled by header\n   compression algorithms.  The main conclusion\
    \ that can be drawn is\n   that most of the header fields can easily be compressed\
    \ away since\n   they never or seldom change.  Only 5 fields, with a combined\
    \ size of\n   about 10 octets, need more sophisticated mechanisms.  These fields\n\
    \   are:\n    - IPv4 Identification (16 bits)   - IP-ID\n    - UDP Checksum (16\
    \ bits)\n    - RTP Marker (1 bit)              - M-bit\n    - RTP Sequence Number\
    \ (16 bits)   - SN\n    - RTP Timestamp (32 bits)         - TS\n   The analysis\
    \ in Appendix A reveals that the values of the TS and IP-\n   ID fields can usually\
    \ be predicted from the RTP Sequence Number,\n   which increments by one for each\
    \ packet emitted by an RTP source.\n   The M-bit is also usually the same, but\
    \ needs to be communicated\n   explicitly occasionally.  The UDP Checksum should\
    \ not be predicted\n   and is sent as-is when enabled.\n   The way ROHC RTP compression\
    \ operates, then, is to first establish\n   functions from SN to the other fields,\
    \ and then reliably communicate\n   the SN.  Whenever a function from SN to another\
    \ field changes, i.e.,\n   the existing function gives a result which is different\
    \ from the\n   field in the header to be compressed, additional information is\
    \ sent\n   to update the parameters of that function.\n   Headers specific to\
    \ Mobile IP (for IPv4 or IPv6) do not receive any\n   special treatment in this\
    \ document.  They are compressible, however,\n   and it is expected that the compression\
    \ efficiency for Mobile IP\n   headers will be good enough due to the handling\
    \ of extension header\n   lists and tunneling headers.  It would be relatively\
    \ painless to\n   introduce a new ROHC profile with special treatment for Mobile\
    \ IPv6\n   specific headers should the completed work on the Mobile IPv6\n   protocols\
    \ (work in progress in the IETF) make that necessary.\n"
- title: 4.  Header compression framework
  contents:
  - '4.  Header compression framework

    '
- title: 4.1.  Operating assumptions
  contents:
  - "4.1.  Operating assumptions\n   Cellular links, which are a primary target for\
    \ ROHC, have a number of\n   characteristics that are described briefly here.\
    \  ROHC requires\n   functionality from lower layers that is outlined here and\
    \ more\n   thoroughly described in the lower layer guidelines document [LLG].\n\
    \   Channels\n      ROHC header-compressed packets flow on channels.  Unlike many\n\
    \      fixed links, some cellular radio links can have several channels\n    \
    \  connecting the same pair of nodes.  Each channel can have\n      different\
    \ characteristics in terms of error rate, bandwidth, etc.\n   Context identifiers\n\
    \      On some channels, the ability to transport multiple packet streams\n  \
    \    is required.  It can also be feasible to have channels dedicated\n      to\
    \ individual packet streams.  Therefore, ROHC uses a distinct\n      context identifier\
    \ space per channel and can eliminate context\n      identifiers completely for\
    \ one of the streams when few streams\n      share a channel.\n   Packet type\
    \ indication\n      Packet type indication is done in the header compression scheme\n\
    \      itself.  Unless the link already has a way of indicating packet\n     \
    \ types which can be used, such as PPP, this provides smaller\n      compressed\
    \ headers overall.  It may also be less difficult to\n      allocate a single\
    \ packet type, rather than many, in order to run\n      ROHC over links such as\
    \ PPP.\n   Reordering\n      The channel between compressor and decompressor is\
    \ required to\n      maintain packet ordering, i.e., the decompressor must receive\n\
    \      packets in the same order as the compressor sent them.\n      (Reordering\
    \ before the compression point, however, is dealt with,\n      i.e., there is\
    \ no assumption that the compressor will only receive\n      packets in sequence.)\n\
    \   Duplication\n      The channel between compressor and decompressor is required\
    \ to not\n      duplicate packets.  (Duplication before the compression point,\n\
    \      however, is dealt with, i.e., there is no assumption that the\n      compressor\
    \ will receive only one copy of each packet.)\n   Packet length\n      ROHC is\
    \ designed under the assumption that lower layers indicate\n      the length of\
    \ a compressed packet.  ROHC packets do not contain\n      length information\
    \ for the payload.\n   Framing\n      The link layer must provide framing that\
    \ makes it possible to\n      distinguish frame boundaries and individual frames.\n\
    \   Error detection/protection\n      The ROHC scheme has been designed to cope\
    \ with residual errors in\n      the headers delivered to the decompressor.  CRCs\
    \ and sanity checks\n      are used to prevent or reduce damage propagation. \
    \ However, it is\n      RECOMMENDED that lower layers deploy error detection for\
    \ ROHC\n      headers and do not deliver ROHC headers with high residual error\n\
    \      rates.\n      Without giving a hard limit on the residual error rate acceptable\n\
    \      to ROHC, it is noted that for a residual bit error rate of at most\n  \
    \    1E-5, the ROHC scheme has been designed not to increase the number\n    \
    \  of damaged headers, i.e., the number of damaged headers due to\n      damage\
    \ propagation is designed to be less than the number of\n      damaged headers\
    \ caught by the ROHC error detection scheme.\n   Negotiation\n      In addition\
    \ to the packet handling mechanisms above, the link\n      layer MUST provide\
    \ a way to negotiate header compression\n      parameters, see also section 5.1.1.\
    \  (For unidirectional links,\n      this negotiation may be performed out-of-band\
    \ or even a priori.)\n"
- title: 4.2.  Dynamicity
  contents:
  - "4.2.  Dynamicity\n   The ROHC protocol achieves its compression gain by establishing\
    \ state\n   information at both ends of the link, i.e., at the compressor and\
    \ at\n   the decompressor.  Different parts of the state are established at\n\
    \   different times and with different frequency; hence, it can be said\n   that\
    \ some of the state information is more dynamic than the rest.\n   Some state\
    \ information is established at the time a channel is\n   established; ROHC assumes\
    \ the existence of an out-of-band negotiation\n   protocol (such as PPP), or predefined\
    \ channel state (most useful for\n   unidirectional links).  In both cases, we\
    \ speak of \"negotiated\n   channel state\".  ROHC does not assume that this state\
    \ can change\n   dynamically during the channel lifetime (and does not explicitly\n\
    \   support such changes, although some changes may be innocuous from a\n   protocol\
    \ point of view).  An example of negotiated channel state is\n   the highest context\
    \ ID number to be used by the compressor (MAX_CID).\n   Other state information\
    \ is associated with the individual packet\n   streams in the channel; this state\
    \ is said to be part of the context.\n   Using context identifiers (CIDs), multiple\
    \ packet streams with\n   different contexts can share a channel.  The negotiated\
    \ channel state\n   indicates the highest context identifier to be used, as well\
    \ as the\n   selection of one of two ways to indicate the CID in the compressed\n\
    \   header.\n   It is up to the compressor to decide which packets to associate\
    \ with\n   a context (or, equivalently, which packets constitute a single\n  \
    \ stream); however, ROHC is efficient only when all packets of a stream\n   share\
    \ certain properties, such as having the same values for fields\n   that are described\
    \ as \"static\" in this document (e.g., the IP\n   addresses, port numbers, and\
    \ RTP parameters such as the payload\n   type).  The efficiency of ROHC RTP also\
    \ depends on the compressor\n   seeing most RTP Sequence Numbers.\n   Streams\
    \ need not share all characteristics important for compression.\n   ROHC has a\
    \ notion of compression profiles: a compression profile\n   denotes a predefined\
    \ set of such characteristics.  To provide\n   extensibility, the negotiated channel\
    \ state includes the set of\n   profiles acceptable to the decompressor.  The\
    \ context state includes\n   the profile currently in use for the context.\n \
    \  Other elements of the context state may include the current values of\n   all\
    \ header fields (from these one can deduce whether an IPv4 header\n   is present\
    \ in the header chain, and whether UDP Checksums are\n   enabled), as well as\
    \ additional compression context that is not part\n   of an uncompressed header,\
    \ e.g., TS_STRIDE, IP-ID characteristics\n   (incrementing as a 16-bit value in\
    \ network byte order? random?), a\n   number of old reference headers, and the\
    \ compressor/decompressor\n   state machines (see next section).\n   This document\
    \ actually defines four ROHC profiles: One uncompressed\n   profile, the main\
    \ ROHC RTP compression profile, and two variants of\n   this profile for compression\
    \ of packets with header chains that end\n   in UDP and ESP, respectively, but\
    \ where RTP compression is not\n   applicable.  The descriptive text in the rest\
    \ of this section is\n   referring to the main ROHC RTP compression profile.\n"
- title: 4.3.  Compression and decompression states
  contents:
  - "4.3.  Compression and decompression states\n   Header compression with ROHC can\
    \ be characterized as an interaction\n   between two state machines, one compressor\
    \ machine and one\n   decompressor machine, each instantiated once per context.\
    \  The\n   compressor and the decompressor have three states each, which in many\n\
    \   ways are related to each other even if the meaning of the states are\n   slightly\
    \ different for the two parties.  Both machines start in the\n   lowest compression\
    \ state and transit gradually to higher states.\n   Transitions need not be synchronized\
    \ between the two machines.  In\n   normal operation it is only the compressor\
    \ that temporarily transits\n   back to lower states.  The decompressor will transit\
    \ back only when\n   context damage is detected.\n   Subsequent sections present\
    \ an overview of the state machines and\n   their corresponding states, respectively,\
    \ starting with the\n   compressor.\n"
- title: 4.3.1.  Compressor states
  contents:
  - "4.3.1.  Compressor states\n   For ROHC compression, the three compressor states\
    \ are the\n   Initialization and Refresh (IR), First Order (FO), and Second Order\n\
    \   (SO) states.  The compressor starts in the lowest compression state\n   (IR)\
    \ and transits gradually to higher compression states.  The\n   compressor will\
    \ always operate in the highest possible compression\n   state, under the constraint\
    \ that the compressor is sufficiently\n   confident that the decompressor has\
    \ the information necessary to\n   decompress a header compressed according to\
    \ that state.\n   +----------+                +----------+                +----------+\n\
    \   | IR State |   <-------->   | FO State |   <-------->   | SO State |\n   +----------+\
    \                +----------+                +----------+\n   Decisions about\
    \ transitions between the various compression states\n   are taken by the compressor\
    \ on the basis of:\n      - variations in packet headers\n      - positive feedback\
    \ from decompressor (Acknowledgments -- ACKs)\n      - negative feedback from\
    \ decompressor (Negative ACKs -- NACKs)\n      - periodic timeouts (when operating\
    \ in unidirectional mode, i.e.,\n        over simplex channels or when feedback\
    \ is not enabled)\n   How transitions are performed is explained in detail in\
    \ chapter 5 for\n   each mode of operation.\n"
- title: 4.3.1.1.  Initialization and Refresh (IR) State
  contents:
  - "4.3.1.1.  Initialization and Refresh (IR) State\n   The purpose of the IR state\
    \ is to initialize the static parts of the\n   context at the decompressor or\
    \ to recover after failure.  In this\n   state, the compressor sends complete\
    \ header information.  This\n   includes all static and nonstatic fields in uncompressed\
    \ form plus\n   some additional information.\n   The compressor stays in the IR\
    \ state until it is fairly confident\n   that the decompressor has received the\
    \ static information correctly.\n"
- title: 4.3.1.2.  First Order (FO) State
  contents:
  - "4.3.1.2.  First Order (FO) State\n   The purpose of the FO state is to efficiently\
    \ communicate\n   irregularities in the packet stream.  When operating in this\
    \ state,\n   the compressor rarely sends information about all dynamic fields,\
    \ and\n   the information sent is usually compressed at least partially.  Only\n\
    \   a few static fields can be updated.  The difference between IR and FO\n  \
    \ should therefore be clear.\n   The compressor enters this state from the IR\
    \ state, and from the SO\n   state whenever the headers of the packet stream do\
    \ not conform to\n   their previous pattern.  It stays in the FO state until it\
    \ is\n   confident that the decompressor has acquired all the parameters of\n\
    \   the new pattern.  Changes in fields that are always irregular are\n   communicated\
    \ in all packets and are therefore part of what is a\n   uniform pattern.\n  \
    \ Some or all packets sent in the FO state carry context updating\n   information.\
    \  It is very important to detect corruption of such\n   packets to avoid erroneous\
    \ updates and context inconsistencies.\n"
- title: 4.3.1.3.  Second Order (SO) State
  contents:
  - "4.3.1.3.  Second Order (SO) State\n   This is the state where compression is\
    \ optimal.  The compressor\n   enters the SO state when the header to be compressed\
    \ is completely\n   predictable given the SN (RTP Sequence Number) and the compressor\
    \ is\n   sufficiently confident that the decompressor has acquired all\n   parameters\
    \ of the functions from SN to other fields.  Correct\n   decompression of packets\
    \ sent in the SO state only hinges on correct\n   decompression of the SN.  However,\
    \ successful decompression also\n   requires that the information sent in the\
    \ preceding FO state packets\n   has been successfully received by the decompressor.\n\
    \   The compressor leaves this state and goes back to the FO state when\n   the\
    \ header no longer conforms to the uniform pattern and cannot be\n   independently\
    \ compressed on the basis of previous context\n   information.\n"
- title: 4.3.2.  Decompressor states
  contents:
  - "4.3.2.  Decompressor states\n   The decompressor starts in its lowest compression\
    \ state, \"No Context\"\n   and gradually transits to higher states.  The decompressor\
    \ state\n   machine normally never leaves the \"Full Context\" state once it has\n\
    \   entered this state.\n   +--------------+         +----------------+      \
    \   +--------------+\n   |  No Context  |  <--->  | Static Context |  <--->  |\
    \ Full Context |\n   +--------------+         +----------------+         +--------------+\n\
    \   Initially, while working in the \"No Context\" state, the decompressor\n \
    \  has not yet successfully decompressed a packet.  Once a packet has\n   been\
    \ decompressed correctly (for example, upon reception of an\n   initialization\
    \ packet with static and dynamic information), the\n   decompressor can transit\
    \ all the way to the \"Full Context\" state, and\n   only upon repeated failures\
    \ will it transit back to lower states.\n   However, when that happens it first\
    \ transits back to the \"Static\n   Context\" state.  There, reception of any\
    \ packet sent in the FO state\n   is normally sufficient to enable transition\
    \ to the \"Full Context\"\n   state again.  Only when decompression of several\
    \ packets sent in the\n   FO state fails in the \"Static Context\" state will\
    \ the decompressor go\n   all the way back to the \"No Context\" state.\n   When\
    \ state transitions are performed is explained in detail in\n   chapter 5.\n"
- title: 4.4.  Modes of operation
  contents:
  - "4.4.  Modes of operation\n   The ROHC scheme has three modes of operation, called\
    \ Unidirectional,\n   Bidirectional Optimistic, and Bidirectional Reliable mode.\n\
    \   It is important to understand the difference between states, as\n   described\
    \ in the previous chapter, and modes.  These abstractions are\n   orthogonal to\
    \ each other.  The state abstraction is the same for all\n   modes of operation,\
    \ while the mode controls the logic of state\n   transitions and what actions\
    \ to perform in each state.\n                         +----------------------+\n\
    \                         |  Unidirectional Mode |\n                         |\
    \   +--+  +--+  +--+   |\n                         |   |IR|  |FO|  |SO|   |\n\
    \                         |   +--+  +--+  +--+   |\n                         +----------------------+\n\
    \                           ^                  ^\n                          /\
    \                    \\\n                         /                      \\\n\
    \                        v                        v\n    +----------------------+\
    \                  +----------------------+\n    |   Optimistic Mode    |    \
    \              |    Reliable Mode     |\n    |   +--+  +--+  +--+   |        \
    \          |   +--+  +--+  +--+   |\n    |   |IR|  |FO|  |SO|   | <-------------->\
    \ |   |IR|  |FO|  |SO|   |\n    |   +--+  +--+  +--+   |                  |  \
    \ +--+  +--+  +--+   |\n    +----------------------+                  +----------------------+\n\
    \   The optimal mode to operate in depends on the characteristics of the\n   environment\
    \ of the compression protocol, such as feedback abilities,\n   error probabilities\
    \ and distributions, effects of header size\n   variation, etc.  All ROHC implementations\
    \ MUST implement and support\n   all three modes of operation.  The three modes\
    \ are briefly described\n   in the following subsections.\n   Detailed descriptions\
    \ of the three modes of operation regarding\n   compression and decompression\
    \ logic are given in chapter 5.  The mode\n   transition mechanisms, too, are\
    \ described in chapter 5.\n"
- title: 4.4.1.  Unidirectional mode -- U-mode
  contents:
  - "4.4.1.  Unidirectional mode -- U-mode\n   When in the Unidirectional mode of\
    \ operation, packets are sent in one\n   direction only: from compressor to decompressor.\
    \  This mode therefore\n   makes ROHC usable over links where a return path from\
    \ decompressor to\n   compressor is unavailable or undesirable.\n   In U-mode,\
    \ transitions between compressor states are performed only\n   on account of periodic\
    \ timeouts and irregularities in the header\n   field change patterns in the compressed\
    \ packet stream.  Due to the\n   periodic refreshes and the lack of feedback for\
    \ initiation of error\n   recovery, compression in the Unidirectional mode will\
    \ be less\n   efficient and have a slightly higher probability of loss propagation\n\
    \   compared to any of the Bidirectional modes.\n   Compression with ROHC MUST\
    \ start in the Unidirectional mode.\n   Transition to any of the Bidirectional\
    \ modes can be performed as soon\n   as a packet has reached the decompressor\
    \ and it has replied with a\n   feedback packet indicating that a mode transition\
    \ is desired (see\n   chapter 5).\n"
- title: 4.4.2.  Bidirectional Optimistic mode -- O-mode
  contents:
  - "4.4.2.  Bidirectional Optimistic mode -- O-mode\n   The Bidirectional Optimistic\
    \ mode is similar to the Unidirectional\n   mode.  The difference is that a feedback\
    \ channel is used to send\n   error recovery requests and (optionally) acknowledgments\
    \ of\n   significant context updates from decompressor to compressor (not,\n \
    \  however, for pure sequence number updates).  Periodic refreshes are\n   not\
    \ used in the Bidirectional Optimistic mode.\n   O-mode aims to maximize compression\
    \ efficiency and sparse usage of\n   the feedback channel.  It reduces the number\
    \ of damaged headers\n   delivered to the upper layers due to residual errors\
    \ or context\n   invalidation.  The frequency of context invalidation may be higher\n\
    \   than for R-mode, in particular when long loss/error bursts occur.\n   Refer\
    \ to section 4.7 for more details.\n"
- title: 4.4.3.  Bidirectional Reliable mode -- R-mode
  contents:
  - "4.4.3.  Bidirectional Reliable mode -- R-mode\n   The Bidirectional Reliable\
    \ mode differs in many ways from the\n   previous two.  The most important differences\
    \ are a more intensive\n   usage of the feedback channel and a stricter logic\
    \ at both the\n   compressor and the decompressor that prevents loss of context\n\
    \   synchronization between compressor and decompressor except for very\n   high\
    \ residual bit error rates.  Feedback is sent to acknowledge all\n   context updates,\
    \ including updates of the sequence number field.\n   However, not every packet\
    \ updates the context in Reliable mode.\n   R-mode aims to maximize robustness\
    \ against loss propagation and\n   damage propagation, i.e., minimize the probability\
    \ of context\n   invalidation, even under header loss/error burst conditions.\
    \  It may\n   have a lower probability of context invalidation than O-mode, but\
    \ a\n   larger number of damaged headers may be delivered when the context\n \
    \  actually is invalidated.  Refer to section 4.7 for more details.\n"
- title: 4.5.  Encoding methods
  contents:
  - "4.5.  Encoding methods\n   This chapter describes the encoding methods used for\
    \ header fields.\n   How the methods are applied to each field (e.g., values of\
    \ associated\n   parameters) is specified in section 5.7.\n"
- title: 4.5.1. Least Significant Bits (LSB) encoding
  contents:
  - "4.5.1. Least Significant Bits (LSB) encoding\n   Least Significant Bits (LSB)\
    \ encoding is used for header fields whose\n   values are usually subject to small\
    \ changes.  With LSB encoding, the\n   k least significant bits of the field value\
    \ are transmitted instead\n   of the original field value, where k is a positive\
    \ integer.  After\n   receiving k bits, the decompressor derives the original\
    \ value using a\n   previously received value as reference (v_ref).\n   The scheme\
    \ is guaranteed to be correct if the compressor and the\n   decompressor each\
    \ use interpretation intervals\n       1) in which the original value resides,\
    \ and\n       2) in which the original value is the only value that has the\n\
    \          exact same k least significant bits as those transmitted.\n   The interpretation\
    \ interval can be described as a function f(v_ref,\n   k).  Let\n   f(v_ref, k)\
    \ = [v_ref - p, v_ref + (2^k - 1) - p]\n   where p is an integer.\n         <-------\
    \ interpretation interval (size is 2^k) ------->\n         |-------------+---------------------------------------|\n\
    \      v_ref - p        v_ref                        v_ref + (2^k-1) - p\n   The\
    \ function f has the following property: for any value k, the k\n   least significant\
    \ bits will uniquely identify a value in f(v_ref, k).\n   The parameter p is introduced\
    \ so that the interpretation interval can\n   be shifted with respect to v_ref.\
    \  Choosing a good value for p will\n   yield a more efficient encoding for fields\
    \ with certain\n   characteristics.  Below are some examples:\n   a) For field\
    \ values that are expected always to increase, p can be\n      set to -1.  The\
    \ interpretation interval becomes\n      [v_ref + 1, v_ref + 2^k].\n   b) For\
    \ field values that stay the same or increase, p can be set to\n      0.  The\
    \ interpretation interval becomes [v_ref, v_ref + 2^k - 1].\n   c) For field values\
    \ that are expected to deviate only slightly from a\n      constant value, p can\
    \ be set to 2^(k-1) - 1.  The interpretation\n      interval becomes [v_ref -\
    \ 2^(k-1) + 1, v_ref + 2^(k-1)].\n   d) For field values that are expected to\
    \ undergo small negative\n      changes and larger positive changes, such as the\
    \ RTP TS for video,\n      or RTP SN when there is misordering, p can be set to\
    \ 2^(k-2) - 1.\n      The interval becomes [v_ref - 2^(k-2) + 1, v_ref + 3 * 2^(k-2)],\n\
    \      i.e., 3/4 of the interval is used for positive changes.\n   The following\
    \ is a simplified procedure for LSB compression and\n   decompression; it is modified\
    \ for robustness and damage propagation\n   protection in the next subsection:\n\
    \   1) The compressor (decompressor) always uses v_ref_c (v_ref_d), the\n    \
    \  last value that has been compressed (decompressed), as v_ref;\n   2) When compressing\
    \ a value v, the compressor finds the minimum value\n      of k such that v falls\
    \ into the interval f(v_ref_c, k).  Call this\n      function k = g(v_ref_c, v).\
    \ When only a few distinct values of k\n      are possible, for example due to\
    \ limitations imposed by packet\n      formats (see section 5.7), the compressor\
    \ will instead pick the\n      smallest k that puts v in the interval f(v_ref_c,\
    \ k).\n   3) When receiving m LSBs, the decompressor uses the interpretation\n\
    \      interval f(v_ref_d, m), called interval_d.  It picks as the\n      decompressed\
    \ value the one in interval_d whose LSBs match the\n      received m bits.\n \
    \  Note that the values to be encoded have a finite range; for example,\n   the\
    \ RTP SN ranges from 0 to 0xFFFF.  When the SN value is close to 0\n   or 0xFFFF,\
    \ the interpretation interval can straddle the wraparound\n   boundary between\
    \ 0 and 0xFFFF.\n   The scheme is complicated by two factors: packet loss between\
    \ the\n   compressor and decompressor, and transmission errors undetected by\n\
    \   the lower layer.  In the former case, the compressor and decompressor\n  \
    \ will lose the synchronization of v_ref, and thus also of the\n   interpretation\
    \ interval.  If v is still covered by the\n   intersection(interval_c, interval_d),\
    \ the decompression will be\n   correct.  Otherwise, incorrect decompression will\
    \ result.  The next\n   section will address this issue further.\n   In the case\
    \ of undetected transmission errors, the corrupted LSBs\n   will give an incorrectly\
    \ decompressed value that will later be used\n   as v_ref_d, which in turn is\
    \ likely to lead to damage propagation.\n   This problem is addressed by using\
    \ a secure reference, i.e., a\n   reference value whose correctness is verified\
    \ by a protecting CRC.\n   Consequently, the procedure 1) above is modified as\
    \ follows:\n   1) a) the compressor always uses as v_ref_c the last value that\
    \ has\n         been compressed and sent with a protecting CRC.\n      b) the\
    \ decompressor always uses as v_ref_d the last correct\n         value, as verified\
    \ by a successful CRC.\n   Note that in U/O-mode, 1) b) is modified so that if\
    \ decompression of\n   the SN fails using the last verified SN reference, another\n\
    \   decompression attempt is made using the last but one verified SN\n   reference.\
    \  This procedure mitigates damage propagation when a small\n   CRC fails to detect\
    \ a damaged value.  See section 5.3.2.2.3 for\n   further details.\n"
- title: 4.5.2.  Window-based LSB encoding (W-LSB encoding)
  contents:
  - "4.5.2.  Window-based LSB encoding (W-LSB encoding)\n   This section describes\
    \ how to modify the simplified algorithm in\n   4.5.1 to achieve robustness.\n\
    \   The compressor may not be able to determine the exact value of\n   v_ref_d\
    \ that will be used by the decompressor for a particular value\n   v, since some\
    \ candidates for v_ref_d may have been lost or damaged.\n   However, by using\
    \ feedback or by making reasonable assumptions, the\n   compressor can limit the\
    \ candidate set.  The compressor then\n   calculates k such that no matter which\
    \ v_ref_d in the candidate set\n   the decompressor uses, v is covered by the\
    \ resulting interval_d.\n   Since the decompressor always uses as the reference\
    \ the last received\n   value where the CRC succeeded, the compressor maintains\
    \ a sliding\n   window containing the candidates for v_ref_d.  The sliding window\
    \ is\n   initially empty.  The following operations are performed on the\n   sliding\
    \ window by the compressor:\n   1) After sending a value v (compressed or uncompressed)\
    \ protected by\n      a CRC, the compressor adds v to the sliding window.\n  \
    \ 2) For each value v being compressed, the compressor chooses k =\n      max(g(v_min,\
    \ v), g(v_max, v)), where v_min and v_max are the\n      minimum and maximum values\
    \ in the sliding window, and g is the\n      function defined in the previous\
    \ section.\n   3) When the compressor is sufficiently confident that a certain\
    \ value\n      v and all values older than v will not be used as reference by\
    \ the\n      decompressor, the window is advanced by removing those values\n \
    \     (including v).  The confidence may be obtained by various means.\n     \
    \ In R-mode, an ACK from the decompressor implies that values older\n      than\
    \ the ACKed one can be removed from the sliding window.  In\n      U/O-mode there\
    \ is always a CRC to verify correct decompression,\n      and a sliding window\
    \ with a limited maximum width is used.  The\n      window width is an implementation\
    \ dependent optimization\n      parameter.\n   Note that the decompressor follows\
    \ the procedure described in the\n   previous section, except that in R-mode it\
    \ MUST ACK each header\n   received with a succeeding CRC (see also section 5.5).\n"
- title: 4.5.3. Scaled RTP Timestamp encoding
  contents:
  - "4.5.3. Scaled RTP Timestamp encoding\n   The RTP Timestamp (TS) will usually\
    \ not increase by an arbitrary\n   number from packet to packet.  Instead, the\
    \ increase is normally an\n   integral multiple of some unit (TS_STRIDE).  For\
    \ example, in the case\n   of audio, the sample rate is normally 8 kHz and one\
    \ voice frame may\n   cover 20 ms.  Furthermore, each voice frame is often carried\
    \ in one\n   RTP packet.  In this case, the RTP increment is always n * 160 (=\n\
    \   8000 * 0.02), for some integer n.  Note that silence periods have no\n   impact\
    \ on this, as the sample clock at the source normally keeps\n   running without\
    \ changing either frame rate or frame boundaries.\n   In the case of video, there\
    \ is usually a TS_STRIDE as well when the\n   video frame level is considered.\
    \  The sample rate for most video\n   codecs is 90 kHz.  If the video frame rate\
    \ is fixed, say, to 30\n   frames/second, the TS will increase by n * 3000 (=\
    \ n * 90000 / 30)\n   between video frames.  Note that a video frame is often\
    \ divided into\n   several RTP packets to increase robustness against packet loss.\
    \  In\n   this case several RTP packets will carry the same TS.\n   When using\
    \ scaled RTP Timestamp encoding, the TS is downscaled by a\n   factor of TS_STRIDE\
    \ before compression.  This saves\n      floor(log2(TS_STRIDE))\n   bits for each\
    \ compressed TS.  TS and TS_SCALED satisfy the following\n   equality:\n     \
    \ TS = TS_SCALED * TS_STRIDE + TS_OFFSET\n   TS_STRIDE is explicitly, and TS_OFFSET\
    \ implicitly, communicated to\n   the decompressor.  The following algorithm is\
    \ used:\n   1. Initialization: The compressor sends to the decompressor the value\n\
    \      of TS_STRIDE and the absolute value of one or several TS fields.\n    \
    \  The latter are used by the decompressor to initialize TS_OFFSET to\n      (absolute\
    \ value) modulo TS_STRIDE.  Note that TS_OFFSET is the\n      same regardless\
    \ of which absolute value is used, as long as the\n      unscaled TS value does\
    \ not wrap around; see 4) below.\n   2. Compression: After initialization, the\
    \ compressor no longer\n      compresses the original TS values.  Instead, it\
    \ compresses the\n      downscaled values: TS_SCALED = TS / TS_STRIDE.  The compression\n\
    \      method could be either W-LSB encoding or the timer-based encoding\n   \
    \   described in the next section.\n   3. Decompression: When receiving the compressed\
    \ value of TS_SCALED,\n      the decompressor first derives the value of the original\n\
    \      TS_SCALED.  The original RTP TS is then calculated as TS =\n      TS_SCALED\
    \ * TS_STRIDE + TS_OFFSET.\n   4. Offset at wraparound: Wraparound of the unscaled\
    \ 32-bit TS will\n      invalidate the current value of TS_OFFSET used in the\
    \ equation\n      above.  For example, let us assume TS_STRIDE = 160 = 0xA0 and\
    \ the\n      current TS = 0xFFFFFFF0.  TS_OFFSET is then 0x50 = 80.  Then if\n\
    \      the next RTP TS = 0x00000130 (i.e., the increment is 160 * 2 =\n      320),\
    \ the new TS_OFFSET should be 0x00000130 modulo 0xA0 = 0x90 =\n      144.  The\
    \ compressor is not required to re-initialize TS_OFFSET at\n      wraparound.\
    \  Instead, the decompressor MUST detect wraparound of\n      the unscaled TS\
    \ (which is trivial) and update TS_OFFSET to\n         TS_OFFSET = (Wrapped around\
    \ unscaled TS) modulo TS_STRIDE\n   5. Interpretation interval at wraparound:\
    \ Special rules are needed\n      for the interpretation interval of the scaled\
    \ TS at wraparound,\n      since the maximum scaled TS, TSS_MAX, (0xFFFFFFFF /\
    \ TS_STRIDE) may\n      not have the form 2^m - 1.  For example, when TS_STRIDE\
    \ is 160,\n      the scaled TS is at most 26843545 which has LSBs 10011001.  The\n\
    \      wraparound boundary between the TSS_MAX may thus not correspond to\n  \
    \    a natural boundary between LSBs.\n               interpretation interval\n\
    \          |<------------------------------>|\n                       unused \
    \                      scaled TS\n      ------------|--------------|---------------------->\n\
    \                          TSS_MAX         zero\n      When TSS_MAX is part of\
    \ the interpretation interval, a number of\n      unused values are inserted into\
    \ it after TSS_MAX such that their\n      LSBs follow naturally upon each other.\
    \  For example, for TS_STRIDE\n      = 160 and k = 4, values corresponding to\
    \ the LSBs 1010 through\n      1111 are inserted.  The number of inserted values\
    \ depends on k and\n      the LSBs of the maximum scaled TS.  The number of valid\
    \ values in\n      the interpretation interval should be high enough to maintain\n\
    \      robustness.  This can be ensured by the following rule:\n            Let\
    \ a be the number of LSBs needed if there was no\n            wraparound, and\
    \ let b be the number of LSBs needed to\n            disambiguate between TSS_MAX\
    \ and zero where the a LSBs of\n            TSS_MAX are set to zero.  The number\
    \ of LSB bits to send\n            while TSS_MAX or zero is part of the interpretation\
    \ interval\n            is b.\n   This scaling method can be applied to many frame-based\
    \ codecs.\n   However, the value of TS_STRIDE might change during a session, for\n\
    \   example as a result of adaptation strategies.  If that happens, the\n   unscaled\
    \ TS is compressed until re-initialization of the new\n   TS_STRIDE and TS_OFFSET\
    \ is completed.\n"
- title: 4.5.4.  Timer-based compression of RTP Timestamp
  contents:
  - "4.5.4.  Timer-based compression of RTP Timestamp\n   The RTP Timestamp [RFC 1889]\
    \ is defined to identify the number of the\n   first sample used to generate the\
    \ payload.  When 1) RTP packets carry\n   payloads corresponding to a fixed sampling\
    \ interval, 2) the sampling\n   is done at a constant rate, and 3) packets are\
    \ generated in lock-step\n   with sampling, then the timestamp value will closely\
    \ approximate a\n   linear function of the time of day.  This is the case for\n\
    \   conversational media, such as interactive speech.  The linear ratio\n   is\
    \ determined by the source sample rate.  The linear pattern can be\n   complicated\
    \ by packetization (e.g., in the case of video where a\n   video frame usually\
    \ corresponds to several RTP packets) or frame\n   rearrangement (e.g., B-frames\
    \ are sent out-of-order by some video\n   codecs).\n   With a fixed sample rate\
    \ of 8 kHz, 20 ms in the time domain is\n   equivalent to an increment of 160\
    \ in the unscaled TS domain, and to\n   an increment of 1 in the scaled TS domain\
    \ with TS_STRIDE = 160.\n   As a consequence, the (scaled) TS of headers arriving\
    \ at the\n   decompressor will be a linear function of time of day, with some\n\
    \   deviation due to the delay jitter (and the clock inaccuracies)\n   between\
    \ the source and the decompressor.  In normal operation, i.e.,\n   no crashes\
    \ or failures, the delay jitter will be bounded to meet the\n   requirements of\
    \ conversational real-time traffic.  Hence, by using a\n   local clock the decompressor\
    \ can obtain an approximation of the\n   (scaled) TS in the header to be decompressed\
    \ by considering its\n   arrival time.  The approximation can then be refined\
    \ with the k LSBs\n   of the (scaled) TS carried in the header.  The value of\
    \ k required to\n   ensure correct decompression is a function of the jitter between\
    \ the\n   source and the decompressor.\n   If the compressor knows the potential\
    \ jitter introduced between\n   compressor and decompressor, it can determine\
    \ k by using a local\n   clock to estimate jitter in packet arrival times, or\
    \ alternatively it\n   can use a fixed k and discard packets arriving too much\
    \ out of time.\n   The advantages of this scheme include:\n   a) The size of the\
    \ compressed TS is constant and small.  In\n      particular, it does NOT depend\
    \ on the length of silence intervals.\n      This is in contrast to other TS compression\
    \ techniques, which at\n      the beginning of a talkspurt require sending a number\
    \ of bits\n      dependent on the duration of the preceding silence interval.\n\
    \   b) No synchronization is required between the clock local to the\n      compressor\
    \ and the clock local to the decompressor.\n   Note that although this scheme\
    \ can be made to work using both scaled\n   and unscaled TS, in practice it is\
    \ always combined with scaled TS\n   encoding because of the less demanding requirement\
    \ on the clock\n   resolution, e.g., 20 ms instead of 1/8 ms.  Therefore, the\
    \ algorithm\n   described below assumes that the clock-based encoding scheme operates\n\
    \   on the scaled TS.  The case of unscaled TS would be similar, with\n   changes\
    \ to scale factors.\n   The major task of the compressor is to determine the value\
    \ of k.  Its\n   sliding window now contains not only potential reference values\
    \ for\n   the TS but also their times of arrival at the compressor.\n   1) The\
    \ compressor maintains a sliding window\n      {(T_j, a_j), for each header j\
    \ that can be used as a reference},\n      where T_j is the scaled TS for header\
    \ j, and a_j is the arrival\n      time of header j.  The sliding window serves\
    \ the same purpose as\n      the W-LSB sliding window of section 4.5.2.\n   2)\
    \ When a new header n arrives with T_n as the scaled TS, the\n      compressor\
    \ notes the arrival time a_n.  It then calculates\n         Max_Jitter_BC =\n\
    \            max {|(T_n - T_j) - ((a_n - a_j) / TIME_STRIDE)|,\n             \
    \  for all headers j in the sliding window},\n      where TIME_STRIDE is the time\
    \ interval equivalent to one\n      TS_STRIDE, e.g., 20 ms.  Max_Jitter_BC is\
    \ the maximum observed\n      jitter before the compressor, in units of TS_STRIDE,\
    \ for the\n      headers in the sliding window.\n   3) k is calculated as\n  \
    \          k = ceiling(log2(2 * J + 1),\n         where J = Max_Jitter_BC + Max_Jitter_CD\
    \ + 2.\n      Max_Jitter_CD is the upper bound of jitter expected on the\n   \
    \   communication channel between compressor and decompressor (CD-CC).\n     \
    \ It depends only on the characteristics of CD-CC.\n      The constant 2 accounts\
    \ for the quantization error introduced by\n      the clocks at the compressor\
    \ and decompressor, which can be +/-1.\n      Note that the calculation of k follows\
    \ the compression algorithm\n      described in section 4.5.1, with p = 2^(k-1)\
    \ - 1.\n   4) The sliding window is subject to the same window operations as in\n\
    \      section 4.5.2, 1) and 3), except that the values added and removed\n  \
    \    are paired with their arrival times.\n   Decompressor:\n   1) The decompressor\
    \ uses as its reference header the last correctly\n      (as verified by CRC)\
    \ decompressed header.  It maintains the pair\n      (T_ref, a_ref), where T_ref\
    \ is the scaled TS of the reference\n      header, and a_ref is the arrival time\
    \ of the reference header.\n   2) When receiving a compressed header n at time\
    \ a_n, the\n      approximation of the original scaled TS is calculated as:\n\
    \         T_approx = T_ref + (a_n - a_ref) / TIME_STRIDE.\n   3) The approximation\
    \ is then refined by the k least significant bits\n      carried in header n,\
    \ following the decompression algorithm of\n      section 4.5.1, with p = 2^(k-1)\
    \ - 1.\n      Note: The algorithm does not assume any particular pattern in the\n\
    \      packets arriving at the compressor, i.e., it tolerates reordering\n   \
    \   before the compressor and nonincreasing RTP Timestamp behavior.\n      Note:\
    \ Integer arithmetic is used in all equations above.  If\n      TIME_STRIDE is\
    \ not equal to an integral number of clock ticks,\n      time must be normalized\
    \ such that TIME_STRIDE is an integral\n      number of clock ticks.  For example,\
    \ if a clock tick is 20 ms and\n      TIME_STRIDE is 30 ms, (a_n - a_ref) in 2)\
    \ can be multiplied by 3\n      and TIME_STRIDE can have the value 2.\n      Note:\
    \ The clock resolution of the compressor or decompressor can\n      be worse than\
    \ TIME_STRIDE, in which case the difference, i.e.,\n      actual resolution -\
    \ TIME_STRIDE, is treated as additional jitter\n      in the calculation of k.\n\
    \      Note: The clock resolution of the decompressor may be communicated\n  \
    \    to the compressor using the CLOCK feedback option.\n      Note: The decompressor\
    \ may observe the jitter and report this to\n      the compressor using the JITTER\
    \ feedback option.  The compressor\n      may use this information to refine its\
    \ estimate of Max_Jitter_CD.\n"
- title: 4.5.5.  Offset IP-ID encoding
  contents:
  - "4.5.5.  Offset IP-ID encoding\n   As all IPv4 packets have an IP Identifier to\
    \ allow for fragmentation,\n   ROHC provides for transparent compression of this\
    \ ID.  There is no\n   explicit support in ROHC for the IPv6 fragmentation header,\
    \ so there\n   is never a need to discuss IP IDs outside the context of IPv4.\n\
    \   This section assumes (initially) that the IPv4 stack at the source\n   host\
    \ assigns IP-ID according to the value of a 2-byte counter which\n   is increased\
    \ by one after each assignment to an outgoing packet.\n   Therefore, the IP-ID\
    \ field of a particular IPv4 packet flow will\n   increment by 1 from packet to\
    \ packet except when the source has\n   emitted intermediate packets not belonging\
    \ to that flow.\n   For such IPv4 stacks, the RTP SN will increase by 1 for each\
    \ packet\n   emitted and the IP-ID will increase by at least the same amount.\n\
    \   Thus, it is more efficient to compress the offset, i.e., (IP-ID - RTP\n  \
    \ SN), instead of IP-ID itself.\n   The remainder of section 4.5.5 describes how\
    \ to compress/decompress\n   the sequence of offsets using W-LSB encoding/decoding,\
    \ with p = 0\n   (see section 4.5.1).  All IP-ID arithmetic is done using unsigned\n\
    \   16-bit quantities, i.e., modulo 2^16.\n   Compressor:\n      The compressor\
    \ uses W-LSB encoding (section 4.5.2) to compress a\n      sequence of offsets\n\
    \         Offset_i = ID_i - SN_i,\n      where ID_i and SN_i are the values of\
    \ the IP-ID and RTP SN of\n      header i.  The sliding window contains such offsets\
    \ and not the\n      values of header fields, but the rules for adding and deleting\n\
    \      offsets from the window otherwise follow section 4.5.2.\n   Decompressor:\n\
    \      The reference header is the last correctly (as verified by CRC)\n     \
    \ decompressed header.\n      When receiving a compressed packet m, the decompressor\
    \ calculates\n      Offset_ref = ID_ref - SN_ref, where ID_ref and SN_ref are\
    \ the\n      values of IP-ID and RTP SN in the reference header, respectively.\n\
    \      Then W-LSB decoding is used to decompress Offset_m, using the\n      received\
    \ LSBs in packet m and Offset_ref.  Note that m may contain\n      zero LSBs for\
    \ Offset_m, in which case Offset_m = Offset_ref.\n         Finally, the IP-ID\
    \ for packet m is regenerated as\n         IP-ID for m = decompressed SN of packet\
    \ m + Offset_m\n   Network byte order:\n      Some IPv4 stacks do use a counter\
    \ to generate IP ID values as\n      described, but do not transmit the contents\
    \ of this counter in\n      network byte order, but instead send the two octets\
    \ reversed.  In\n      this case, the compressor can compress the IP-ID field\
    \ after\n      swapping the bytes.  Consequently, the decompressor also swaps\
    \ the\n      bytes of the IP-ID after decompression to regenerate the original\n\
    \      IP-ID.  This requires that the compressor and the decompressor\n      synchronize\
    \ on the byte order of the IP-ID field using the NBO or\n      NBO2 flag (see\
    \ section 5.7).\n   Random IP Identifier:\n      Some IPv4 stacks generate the\
    \ IP Identifier values using a\n      pseudo-random number generator.  While this\
    \ may provide some\n      security benefits, it makes it pointless to attempt\
    \ compressing\n      the field.  Therefore, the compressor should detect such\
    \ random\n      behavior of the field.  After detection and synchronization with\n\
    \      the decompressor using the RND or RND2 flag, the field is sent\n      as-is\
    \ in its entirety as additional octets after the compressed\n      header.\n"
- title: 4.5.6.  Self-describing variable-length values
  contents:
  - "4.5.6.  Self-describing variable-length values\n   The values of TS_STRIDE and\
    \ a few other compression parameters can\n   vary widely.  TS_STRIDE can be 160\
    \ for voice and 90 000 for 1 f/s\n   video.  To optimize the transfer of such\
    \ values, a variable number of\n   octets is used to encode them.  The number\
    \ of octets used is\n   determined by the first few bits of the first octet:\n\
    \   First bit is 0: 1 octet.\n            7 bits transferred.\n            Up\
    \ to 127 decimal.\n            Encoded octets in hexadecimal: 00 to 7F\n   First\
    \ bits are 10: 2 octets.\n            14 bits transferred.\n            Up to\
    \ 16 383 decimal.\n            Encoded octets in hexadecimal: 80 00 to BF FF\n\
    \   First bits are 110: 3 octets.\n            21 bits transferred.\n        \
    \    Up to 2 097 151 decimal.\n            Encoded octets in hexadecimal: C0 00\
    \ 00 to DF FF FF\n   First bits are 111: 4 octets.\n            29 bits transferred.\n\
    \            Up to 536 870 911 decimal.\n            Encoded octets in hexadecimal:\
    \ E0 00 00 00 to FF FF FF FF\n"
- title: 4.5.7.  Encoded values across several fields in compressed headers
  contents:
  - "4.5.7.  Encoded values across several fields in compressed headers\n   When a\
    \ compressed header has an extension, pieces of an encoded value\n   can be present\
    \ in more than one field.  When an encoded value is\n   split over several fields\
    \ in this manner, the more significant bits\n   of the value are closer to the\
    \ beginning of the header.  If the\n   number of bits available in compressed\
    \ header fields exceeds the\n   number of bits in the value, the most significant\
    \ field is padded\n   with zeroes in its most significant bits.\n   For example,\
    \ an unscaled TS value can be transferred using an UOR-2\n   header (see section\
    \ 5.7) with an extension of type 3.  The Tsc bit of\n   the extension is then\
    \ unset (zero) and the variable length TS field\n   of the extension is 4 octets,\
    \ with 29 bits available for the TS (see\n   section 4.5.6).  The UOR-2 TS field\
    \ will contain the three most\n   significant bits of the unscaled TS, and the\
    \ 4-octet TS field in the\n   extension will contain the remaining 29 bits.\n"
- title: 4.6.  Errors caused by residual errors
  contents:
  - "4.6.  Errors caused by residual errors\n   ROHC is designed under the assumption\
    \ that packets can be damaged\n   between the compressor and decompressor, and\
    \ that such damaged\n   packets can be delivered to the decompressor (\"residual\
    \ errors\").\n   Residual errors may damage the SN in compressed headers.  Such\
    \ damage\n   will cause generation of a header which upper layers may not be able\n\
    \   to distinguish from a correct header.  When the compressed header\n   contains\
    \ a CRC, the CRC will catch the bad header with a probability\n   dependent on\
    \ the size of the CRC.  When ROHC does not detect the bad\n   header, it will\
    \ be delivered to upper layers.\n   Damage is not confined to the SN:\n   a) Damage\
    \ to packet type indication bits can cause a header to be\n      interpreted as\
    \ having a different packet type.\n   b) Damage to CID information may cause a\
    \ packet to be interpreted\n      according to another context and possibly also\
    \ according to\n      another profile.  Damage to CIDs will be more harmful when\
    \ a large\n      part of the CID space is being used, so that it is likely that\
    \ the\n      damaged CID corresponds to an active context.\n   c) Feedback information\
    \ can also be subject to residual errors, both\n      when feedback is piggybacked\
    \ and when it is sent in separate ROHC\n      packets.  ROHC uses sanity checks\
    \ and adds CRCs to vital feedback\n      information to allow detection of some\
    \ damaged feedback.\n      Note that context damage can also result in generation\
    \ of\n      incorrect headers; section 4.7 elaborates further on this.\n"
- title: 4.7.  Impairment considerations
  contents:
  - "4.7.  Impairment considerations\n   Impairments to headers can be classified\
    \ into the following types:\n     (1) the lower layer was not able to decode the\
    \ packet and did not\n         deliver it to ROHC,\n     (2) the lower layer was\
    \ able to decode the packet, but discarded\n         it because of a detected\
    \ error,\n     (3) ROHC detected an error in the generated header and discarded\n\
    \         the packet, or\n     (4) ROHC did not detect that the regenerated header\
    \ was damaged\n         and delivered it to upper layers.\n   Impairments cause\
    \ loss or damage of individual headers.  Some\n   impairment scenarios also cause\
    \ context invalidation, which in turn\n   results in loss propagation and damage\
    \ propagation.  Damage\n   propagation and undetected residual errors both contribute\
    \ to the\n   number of damaged headers delivered to upper layers.  Loss\n   propagation\
    \ and impairments resulting in loss or discarding of single\n   packets both contribute\
    \ to the packet loss seen by upper layers.\n   Examples of context invalidating\
    \ scenarios are:\n     (a) Impairment of type (4) on the forward channel, causing\
    \ the\n         decompressor to update its context with incorrect information;\n\
    \     (b) Loss/error burst of pattern update headers: Impairments of\n       \
    \  types (1),(2) and (3) on consecutive pattern update headers; a\n         pattern\
    \ update header is a header carrying a new pattern\n         information, e.g.,\
    \ at the beginning of a new talk spurt; this\n         causes the decompressor\
    \ to lose the pattern update\n         information;\n     (c) Loss/error burst\
    \ of headers: Impairments of types (1),(2) and\n         (3) on a number of consecutive\
    \ headers that is large enough to\n         cause the decompressor to lose the\
    \ SN synchronization;\n     (d) Impairment of type (4) on the feedback channel\
    \ which mimics a\n         valid ACK and makes the compressor update its context;\n\
    \     (e) a burst of damaged headers (3) erroneously triggers the \"k-\n     \
    \    out-of-n\" rule for detecting context invalidation, which\n         results\
    \ in a NACK/update sequence during which headers are\n         discarded.\n  \
    \ Scenario (a) is mitigated by the CRC carried in all context updating\n   headers.\
    \  The larger the CRC, the lower the chance of context\n   invalidation caused\
    \ by (a).  In R-mode, the CRC of context updating\n   headers is always 7 bits\
    \ or more.  In U/O-mode, it is usually 3 bits\n   and sometimes 7 or 8 bits.\n\
    \   Scenario (b) is almost completely eliminated when the compressor\n   ensures\
    \ through ACKs that no context updating headers are lost, as in\n   R-mode.\n\
    \   Scenario (c) is almost completely eliminated when the compressor\n   ensures\
    \ through ACKs that the decompressor will always detect the SN\n   wraparound,\
    \ as in R-mode.  It is also mitigated by the SN repair\n   mechanisms in U/O-mode.\n\
    \   Scenario (d) happens only when the compressor receives a damaged\n   header\
    \ that mimics an ACK of some header present in the W-LSB window,\n   say ACK of\
    \ header 2, while in reality header 2 was never received or\n   accepted by the\
    \ decompressor, i.e., header 2 was subject to\n   impairment (1), (2) or (3).\
    \  The damaged header must mimic the\n   feedback packet type, the ACK feedback\
    \ type, and the SN LSBs of some\n   header in the W-LSB window.\n   Scenario (e)\
    \ happens when a burst of residual errors causes the CRC\n   check to fail in\
    \ k out of the last n headers carrying CRCs.  Large k\n   and n reduces the probability\
    \ of scenario (e), but also increases the\n   number of headers lost or damaged\
    \ as a consequence of any context\n   invalidation.\n   ROHC detects damaged headers\
    \ using CRCs over the original headers.\n   The smallest headers in this document\
    \ either include a 3-bit CRC\n   (U/O-mode) or do not include a CRC (R-mode).\
    \  For the smallest\n   headers, damage is thus detected with a probability of\
    \ roughly 7/8\n   for U/O-mode.  For R-mode, damage to the smallest headers is\
    \ not\n   detected.\n   All other things (coding scheme at lower layers, etc.)\
    \ being equal,\n   the rate of headers damaged by residual errors will be lower\
    \ when\n   headers are compressed compared when they are not, since fewer bits\n\
    \   are transmitted.  Consequently, for a given ROHC CRC setup the rate\n   of\
    \ incorrect headers delivered to applications will also be reduced.\n   The above\
    \ analysis suggests that U/O-mode may be more prone than R-\n   mode to context\
    \ invalidation.  On the other hand, the CRC present in\n   all U/O-mode headers\
    \ continuously screens out residual errors coming\n   from lower layers, reduces\
    \ the number of damaged headers delivered to\n   upper layers when context is\
    \ invalidated, and permits quick detection\n   of context invalidation.\n   R-mode\
    \ always uses a stronger CRC on context updating headers, but no\n   CRC in other\
    \ headers.  A residual error on a header which carries no\n   CRC will result\
    \ in a damaged header being delivered to upper layers\n   (4).  The number of\
    \ damaged headers delivered to the upper layers\n   depends on the ratio of headers\
    \ with CRC vs. headers without CRC,\n   which is a compressor parameter.\n"
- title: 5.  The protocol
  contents:
  - '5.  The protocol

    '
- title: 5.1.  Data structures
  contents:
  - "5.1.  Data structures\n   The ROHC protocol is based on a number of parameters\
    \ that form part\n   of the negotiated channel state and the per-context state.\
    \  This\n   section describes some of this state information in an abstract way.\n\
    \   Implementations can use a different structure for and representation\n   of\
    \ this state.  In particular, negotiation protocols that set up the\n   per-channel\
    \ state need to establish the information that constitutes\n   the negotiated\
    \ channel state, but it is not necessary to exchange it\n   in the form described\
    \ here.\n"
- title: 5.1.1.  Per-channel parameters
  contents:
  - "5.1.1.  Per-channel parameters\n   MAX_CID: Nonnegative integer; highest context\
    \ ID number to be used by\n   the compressor (note that this parameter is not\
    \ coupled to, but in\n   effect further constrained by, LARGE_CIDS).\n   LARGE_CIDS:\
    \ Boolean; if false, the short CID representation (0 bytes\n   or 1 prefix byte,\
    \ covering CID 0 to 15) is used; if true, the\n   embedded CID representation\
    \ (1 or 2 embedded CID bytes covering CID 0\n   to 16383) is used.\n   PROFILES:\
    \ Set of nonnegative integers, each integer indicating a\n   profile supported\
    \ by the decompressor.  The compressor MUST NOT\n   compress using a profile not\
    \ in PROFILES.\n   FEEDBACK_FOR: Optional reference to a channel in the reverse\n\
    \   direction.  If provided, this parameter indicates which channel any\n   feedback\
    \ sent on this channel refers to (see 5.7.6.1).\n   MRRU: Maximum reconstructed\
    \ reception unit.  This is the size of the\n   largest reconstructed unit in octets\
    \ that the decompressor is\n   expected to reassemble from segments (see 5.2.5).\
    \  Note that this\n   size includes the CRC.  If MRRU is negotiated to be 0, no\
    \ segment\n   headers are allowed on the channel.\n"
- title: 5.1.2.  Per-context parameters, profiles
  contents:
  - "5.1.2.  Per-context parameters, profiles\n   Per-context parameters are established\
    \ with IR headers (see section\n   5.2.3).  An IR header contains a profile identifier,\
    \ which determines\n   how the rest of the header is to be interpreted.  Note\
    \ that the\n   profile parameter determines the syntax and semantics of the packet\n\
    \   type identifiers and packet types used in conjunction with a specific\n  \
    \ context.  This document describes profiles 0x0000, 0x0001, 0x0002,\n   and 0x0003;\
    \ further profiles may be defined when ROHC is extended in\n   the future.\n \
    \  Profile 0x0000 is for sending uncompressed IP packets.  See section\n     \
    \ 5.10.\n   Profile 0x0001 is for RTP/UDP/IP compression, see sections 5.3\n \
    \     through 5.9.\n   Profile 0x0002 is for UDP/IP compression, i.e., compression\
    \ of the\n      first 12 octets of the UDP payload is not attempted.  See section\n\
    \      5.11.\n   Profile 0x0003 is for ESP/IP compression, i.e., compression of\
    \ the\n      header chain up to and including the first ESP header, but not\n\
    \      subsequent subheaders.  See section 5.12.\n   Initially, all contexts are\
    \ in no context state, i.e., all packets\n   referencing this context except IR\
    \ packets are discarded.  If defined\n   by a \"ROHC over X\" document, per-channel\
    \ negotiation can be used to\n   pre-establish state information for a context\
    \ (e.g., negotiating\n   profile 0x0000 for CID 15).  Such state information can\
    \ also be\n   marked read-only in the negotiation, which would cause the\n   decompressor\
    \ to discard any IR packet attempting to modify it.\n"
- title: 5.1.3.  Contexts and context identifiers
  contents:
  - "5.1.3.  Contexts and context identifiers\n   Associated with each compressed\
    \ flow is a context, which is the state\n   compressor and decompressor maintain\
    \ in order to correctly compress\n   or decompress the headers of the packet stream.\
    \  Contexts are\n   identified by a context identifier, CID, which is sent along\
    \ with\n   compressed headers and feedback information.\n   The CID space is distinct\
    \ for each channel, i.e., CID 3 over channel\n   A and CID 3 over channel B do\
    \ not refer to the same context, even if\n   the endpoints of A and B are the\
    \ same nodes.  In particular, CIDs for\n   any pairs of forward and reverse channels\
    \ are not related (forward\n   and reverse channels need not even have CID spaces\
    \ of the same size).\n   Context information is conceptually kept in a table.\
    \  The context\n   table is indexed using the CID which is sent along with compressed\n\
    \   headers and feedback information.  The CID space can be negotiated to\n  \
    \ be either small, which means that CIDs can take the values 0 through\n   15,\
    \ or large, which means that CIDs take values between 0 and 2^14 -\n   1 = 16383.\
    \  Whether the CID space is large or small is negotiated no\n   later than when\
    \ a channel is established.\n   A small CID with the value 0 is represented using\
    \ zero bits.  A small\n   CID with a value from 1 to 15 is represented by a four-bit\
    \ field in\n   place of a packet type field (Add-CID) plus four more bits.  A\
    \ large\n   CID is represented using the encoding scheme of section 4.5.6,\n \
    \  limited to two octets.\n"
- title: 5.2.  ROHC packets and packet types
  contents:
  - "5.2.  ROHC packets and packet types\n   The packet type indication scheme for\
    \ ROHC has been designed under\n   the following constraints:\n   a) it must be\
    \ possible to use only a limited number of packet sizes;\n   b) it must be possible\
    \ to send feedback information in separate ROHC\n      packets as well as piggybacked\
    \ on forward packets;\n   c) it is desirable to allow elimination of the CID for\
    \ one packet\n      stream when few packet streams share a channel;\n   d) it\
    \ is anticipated that some packets with large headers may be\n      larger than\
    \ the MTU of very constrained lower layers.\n   These constraints have led to\
    \ a design which includes\n   - optional padding,\n   - a feedback packet type,\n\
    \   - an optional Add-CID octet which provides 4 bits of CID, and\n   - a simple\
    \ segmentation and reassembly mechanism.\n   A ROHC packet has the following general\
    \ format (in the diagram,\n   colons \":\" indicate that the part is optional):\n\
    \    --- --- --- --- --- --- --- ---\n   :           Padding             :  variable\
    \ length\n    --- --- --- --- --- --- --- ---\n   :           Feedback       \
    \     :  0 or more feedback elements\n    --- --- --- --- --- --- --- ---\n  \
    \ :            Header             :  variable, with CID information\n    --- ---\
    \ --- --- --- --- --- ---\n   :           Payload             :\n    --- --- ---\
    \ --- --- --- --- ---\n   Padding is any number (zero or more) of padding octets.\
    \  Either of\n   Feedback or Header must be present.\n   Feedback elements always\
    \ start with a packet type indication.\n   Feedback elements carry internal CID\
    \ information.  Feedback is\n   described in section 5.2.2.\n   Header is either\
    \ a profile-specific header or an IR or IR-DYN header\n   (see sections 5.2.3\
    \ and 5.2.4).  Header either\n   1) does not carry any CID information (indicating\
    \ CID zero), or\n   2) includes one Add-CID Octet (see below), or\n   3) contains\
    \ embedded CID information of length one or two octets.\n   Alternatives 1) and\
    \ 2) apply only to compressed headers in channels\n   where the CID space is small.\
    \  Alternative 3) applies only to\n   compressed headers in channels where the\
    \ CID space is large.\n   Padding Octet\n     0   1   2   3   4   5   6   7\n\
    \   +---+---+---+---+---+---+---+---+\n   | 1   1   1   0   0   0   0   0 |\n\
    \   +---+---+---+---+---+---+---+---+\n   Add-CID Octet\n     0   1   2   3  \
    \ 4   5   6   7\n   +---+---+---+---+---+---+---+---+\n   | 1   1   1   0 |  \
    \    CID      |\n   +---+---+---+---+---+---+---+---+\n   CID:   0x1 through 0xF\
    \ indicates CIDs 1 through 15.\n   Note: The Padding Octet looks like an Add-CID\
    \ octet for CID 0.\n   Header either starts with a packet type indication or has\
    \ a packet\n   type indication immediately following an Add-CID Octet.  All Header\n\
    \   packet types have the following general format (in the diagram,\n   slashes\
    \ \"/\" indicate variable length):\n     0              x-1  x       7\n    ---\
    \ --- --- --- --- --- --- ---\n   :         Add-CID octet         :  if (CID 1-15)\
    \ and (small CIDs)\n   +---+--- --- --- ---+--- --- ---+\n   | type indication\
    \   |   body    |  1 octet (8-x bits of body)\n   +---+--- ---+---+---+--- ---\
    \ ---+\n   :                               :\n   /    0, 1, or 2 octets of CID\
    \   /  1 or 2 octets if (large CIDs)\n   :                               :\n \
    \  +---+---+---+---+---+---+---+---+\n   /             body              /  variable\
    \ length\n   +---+---+---+---+---+---+---+---+\n   The large CID, if present,\
    \ is encoded according to section 4.5.6.\n"
- title: 5.2.1.  ROHC feedback
  contents:
  - "5.2.1.  ROHC feedback\n   Feedback carries information from decompressor to compressor.\
    \  The\n   following principal kinds of feedback are supported.  In addition to\n\
    \   the kind of feedback, other information may be included in profile-\n   specific\
    \ feedback information.\n   ACK         : Acknowledges successful decompression\
    \ of a packet,\n                 which means that the context is up-to-date with\
    \ a high\n                 probability.\n   NACK        : Indicates that the dynamic\
    \ context of the\n                 decompressor is out of sync.  Generated when\
    \ several\n                 successive packets have failed to be decompressed\n\
    \                 correctly.\n   STATIC-NACK : Indicates that the static context\
    \ of the decompressor\n                 is not valid or has not been established.\n\
    \   It is anticipated that feedback to the compressor can be realized in\n   many\
    \ ways, depending on the properties of the particular lower layer.\n   The exact\
    \ details of how feedback is realized is to be specified in a\n   \"ROHC over\
    \ X\" document, for each lower layer X in question.  For\n   example, feedback\
    \ might be realized using\n   1) lower-layer specific mechanisms\n   2) a dedicated\
    \ feedback-only channel, realized for example by the\n      lower layer providing\
    \ a way to indicate that a packet is a\n      feedback packet\n   3) a dedicated\
    \ feedback-only channel, where the timing of the\n      feedback provides information\
    \ about which compressed packet caused\n      the feedback\n   4) interspersing\
    \ of feedback packets among normal compressed packets\n      going in the same\
    \ direction as the feedback (lower layers do not\n      indicate feedback)\n \
    \  5) piggybacking of feedback information in compressed packets going\n     \
    \ in the same direction as the feedback (this technique may reduce\n      the\
    \ per-feedback overhead)\n   6) interspersing and piggybacking on the same channel,\
    \ i.e., both 4)\n      and 5).\n   Alternatives 1-3 do not place any particular\
    \ requirements on the ROHC\n   packet type scheme.  Alternatives 4-6 do, however.\
    \  The ROHC packet\n   type scheme has been designed to allow alternatives 4-6\
    \ (these may be\n   used for example over PPP):\n   a) The ROHC scheme provides\
    \ a feedback packet type.  The packet type\n      is able to carry variable-length\
    \ feedback information.\n   b) The feedback information sent on a particular channel\
    \ is passed\n      to, and interpreted by, the compressor associated with feedback\
    \ on\n      that channel.  Thus, the feedback information must contain CID\n \
    \     information if the associated compressor can use more than one\n      context.\
    \  The ROHC feedback scheme requires that a channel carries\n      feedback to\
    \ at most one compressor.  How a compressor is\n      associated with feedback\
    \ on a particular channel needs to be\n      defined in a \"ROHC over X\" document.\n\
    \   c) The ROHC feedback information format is octet-aligned, i.e.,\n      starts\
    \ at an octet boundary, to allow using the format over a\n      dedicated feedback\
    \ channel, 2).\n   d) To allow piggybacking, 5), it is possible to deduce the\
    \ length of\n      feedback information by examining the first few octets of the\n\
    \      feedback.  This allows the decompressor to pass piggybacked\n      feedback\
    \ information to the associated same-side compressor\n      without understanding\
    \ its format.  The length information\n      decouples the decompressor from the\
    \ compressor in the sense that\n      the decompressor can process the compressed\
    \ header immediately\n      without waiting for the compressor to hand it back\
    \ after parsing\n      the feedback information.\n"
- title: 5.2.2.  ROHC feedback format
  contents:
  - "5.2.2.  ROHC feedback format\n   Feedback sent on a ROHC channel consists of\
    \ one or more concatenated\n   feedback elements, where each feedback element\
    \ has the following\n   format:\n     0   1   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n\
    \   | 1   1   1   1   0 |   Code    |  feedback type octet\n   +---+---+---+---+---+---+---+---+\n\
    \   :             Size              :  if Code = 0\n   +---+---+---+---+---+---+---+---+\n\
    \   /         feedback data         /  variable length\n   +---+---+---+---+---+---+---+---+\n\
    \   Code: 0 indicates that a Size octet is present.\n         1-7 indicates the\
    \ size of the feedback data field in\n         octets.\n   Size: Optional octet\
    \ indicating the size of the feedback data\n         field in octets.\n   feedback\
    \ data: Profile-specific feedback information.  Includes\n         CID information.\n\
    \   The total size of the feedback data field is determinable upon\n   reception\
    \ by the decompressor, by inspection of the Code field and\n   possibly the Size\
    \ field.  This explicit length information allows\n   piggybacking and also sending\
    \ more than one feedback element in a\n   packet.\n   When the decompressor has\
    \ determined the size of the feedback data\n   field, it removes the feedback\
    \ type octet and the Size field (if\n   present) and hands the rest to the same-side\
    \ associated compressor\n   together with an indication of the size.  The feedback\
    \ data received\n   by the compressor has the following structure (feedback sent\
    \ on a\n   dedicated feedback channel MAY also use this format):\n     0   1 \
    \  2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n   :         Add-CID\
    \ octet         : if for small CIDs and (CID != 0)\n   +---+---+---+---+---+---+---+---+\n\
    \   :                               :\n   /  large CID (4.5.6 encoding)   / 1-2\
    \ octets if for large CIDs\n   :                               :\n   +---+---+---+---+---+---+---+---+\n\
    \   /           feedback            /\n   +---+---+---+---+---+---+---+---+\n\
    \   The large CID, if present, is encoded according to section 4.5.6.\n   CID\
    \ information in feedback data indicates the CID of the packet\n   stream for\
    \ which feedback is sent.  Note that the LARGE_CIDS\n   parameter that controls\
    \ whether a large CID is present is taken from\n   the channel state of the receiving\
    \ compressor's channel, NOT from\n   that of the channel carrying the feedback.\n\
    \   It is REQUIRED that the feedback field have either of the following\n   two\
    \ formats:\n   FEEDBACK-1\n     0   1   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n\
    \   | profile specific information  |  1 octet\n   +---+---+---+---+---+---+---+---+\n\
    \   FEEDBACK-2\n     0   1   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n\
    \   |Acktype|                       |\n   +---+---+   profile specific    /  at\
    \ least 2 octets\n   /             information       |\n   +---+---+---+---+---+---+---+---+\n\
    \   Acktype:  0 = ACK\n             1 = NACK\n             2 = STATIC-NACK\n \
    \            3 is reserved (MUST NOT be used.  Otherwise unparseable.)\n   The\
    \ compressor can use the following logic to parse the feedback\n   field.\n  \
    \ 1) If for large CIDs, the feedback will always start with a CID\n      encoded\
    \ according to section 4.5.6.  If the first bit is 0, the\n      CID uses one\
    \ octet.  If the first bit is 1, the CID uses two\n      octets.\n   2) If for\
    \ small CIDs, and the size is one octet, the feedback is a\n      FEEDBACK-1.\n\
    \   3) If for small CIDs, and the size is larger than one octet, and the\n   \
    \   feedback starts with the two bits 11, the feedback starts with an\n      Add-CID\
    \ octet.  If the size is 2, it is followed by FEEDBACK-1.\n      If the size is\
    \ larger than 2, the Add-CID is followed by\n      FEEDBACK-2.\n   4) Otherwise,\
    \ there is no Add-CID octet, and the feedback starts with\n      a FEEDBACK-2.\n"
- title: 5.2.3.  ROHC IR packet type
  contents:
  - "5.2.3.  ROHC IR packet type\n   The IR header associates a CID with a profile,\
    \ and typically also\n   initializes the context.  It can typically also refresh\
    \ (parts of)\n   the context.  It has the following general format.\n     0  \
    \ 1   2   3   4   5   6   7\n    --- --- --- --- --- --- --- ---\n   :       \
    \  Add-CID octet         : if for small CIDs and (CID != 0)\n   +---+---+---+---+---+---+---+---+\n\
    \   | 1   1   1   1   1   1   0 | x | IR type octet\n   +---+---+---+---+---+---+---+---+\n\
    \   :                               :\n   /      0-2 octets of CID        / 1-2\
    \ octets if for large CIDs\n   :                               :\n   +---+---+---+---+---+---+---+---+\n\
    \   |            Profile            | 1 octet\n   +---+---+---+---+---+---+---+---+\n\
    \   |              CRC              | 1 octet\n   +---+---+---+---+---+---+---+---+\n\
    \   |                               |\n   / profile specific information  / variable\
    \ length\n   |                               |\n   +---+---+---+---+---+---+---+---+\n\
    \     x:  Profile specific information.  Interpreted according to the\n      \
    \   profile indicated in the Profile field.\n   Profile: The profile to be associated\
    \ with the CID.  In the IR\n      packet, the profile identifier is abbreviated\
    \ to the 8 least\n      significant bits.  It selects the highest-number profile\
    \ in the\n      channel state parameter PROFILES that matches the 8 LSBs given.\n\
    \   CRC: 8-bit CRC computed using the polynomial of section 5.9.1.  Its\n    \
    \  coverage is profile-dependent, but it MUST cover at least the\n      initial\
    \ part of the packet ending with the Profile field.  Any\n      information which\
    \ initializes the context of the decompressor\n      should be protected by the\
    \ CRC.\n   Profile specific information: The contents of this part of the IR\n\
    \      packet are defined by the individual profiles.  Interpreted\n      according\
    \ to the profile indicated in the Profile field.\n"
- title: 5.2.4.  ROHC IR-DYN packet type
  contents:
  - "5.2.4.  ROHC IR-DYN packet type\n   In contrast to the IR header, the IR-DYN\
    \ header can never initialize\n   an uninitialized context.  However, it can redefine\
    \ what profile is\n   associated with a context, see for example 5.11 (ROHC UDP)\
    \ and 5.12\n   (ROHC ESP).  Thus the type needs to be reserved at the framework\n\
    \   level.  The IR-DYN header typically also initializes or refreshes\n   parts\
    \ of a context, typically the dynamic part.  It has the following\n   general\
    \ format:\n     0   1   2   3   4   5   6   7\n    --- --- --- --- --- --- ---\
    \ ---\n   :         Add-CID octet         : if for small CIDs and (CID != 0)\n\
    \   +---+---+---+---+---+---+---+---+\n   | 1   1   1   1   1   0   0   0 | IR-DYN\
    \ type octet\n   +---+---+---+---+---+---+---+---+\n   :                     \
    \          :\n   /      0-2 octets of CID        / 1-2 octets if for large CIDs\n\
    \   :                               :\n   +---+---+---+---+---+---+---+---+\n\
    \   |            Profile            | 1 octet\n   +---+---+---+---+---+---+---+---+\n\
    \   |              CRC              | 1 octet\n   +---+---+---+---+---+---+---+---+\n\
    \   |                               |\n   / profile specific information  / variable\
    \ length\n   |                               |\n   +---+---+---+---+---+---+---+---+\n\
    \      Profile: The profile to be associated with the CID.  This is\n        \
    \  abbreviated in the same way as with IR packets.\n      CRC: 8-bit CRC computed\
    \ using the polynomial of section 5.9.1.\n          Its coverage is profile-dependent,\
    \ but it MUST cover at least\n          the initial part of the packet ending\
    \ with the Profile field.\n          Any information which initializes the context\
    \ of the\n          decompressor should be protected by the CRC.\n      Profile\
    \ specific information: This part of the IR packet is\n          defined by individual\
    \ profiles.  It is interpreted according\n          to the profile indicated in\
    \ the Profile field.\n"
- title: 5.2.5.  ROHC segmentation
  contents:
  - "5.2.5.  ROHC segmentation\n   Some link layers may provide a much more efficient\
    \ service if the set\n   of different packet sizes to be transported is kept small.\
    \  For such\n   link layers, these sizes will normally be chosen to transport\n\
    \   frequently occurring packets efficiently, with less frequently\n   occurring\
    \ packets possibly adapted to the next larger size by the\n   addition of padding.\
    \  The link layer may, however, be limited in the\n   size of packets it can offer\
    \ in this efficient mode, or it may be\n   desirable to request only a limited\
    \ largest size.  To accommodate the\n   occasional packet that is larger than\
    \ that largest size negotiated,\n   ROHC defines a simple segmentation protocol.\n"
- title: 5.2.5.1.  Segmentation usage considerations
  contents:
  - "5.2.5.1.  Segmentation usage considerations\n   The segmentation protocol defined\
    \ in ROHC is not particularly\n   efficient.  It is not intended to replace link\
    \ layer segmentation\n   functions; these SHOULD be used whenever available and\
    \ efficient for\n   the task at hand.\n   ROHC segmentation should only be used\
    \ for occasional packets with\n   sizes larger than what is efficient to accommodate,\
    \ e.g., due to\n   exceptionally large ROHC headers.  The segmentation scheme\
    \ was\n   designed to reduce packet size variations that may occur due to\n  \
    \ outliers in the header size distribution.  In other cases,\n   segmentation\
    \ should be done at lower layers.  The segmentation scheme\n   should only be\
    \ used for packet sizes that are larger than the maximum\n   size in the allowed\
    \ set of sizes from the lower layers.\n   In summary, ROHC segmentation should\
    \ be used with a relatively low\n   frequency in the packet flow.  If this cannot\
    \ be ensured,\n   segmentation should be performed at lower layers.\n"
- title: 5.2.5.2.  Segmentation protocol
  contents:
  - "5.2.5.2.  Segmentation protocol\n   Segment Packet\n     0   1   2   3   4  \
    \ 5   6   7\n   +---+---+---+---+---+---+---+---+\n   | 1   1   1   1   1   1\
    \   1 | F |\n   +---+---+---+---+---+---+---+---+\n   /           Segment    \
    \         /  variable length\n   +---+---+---+---+---+---+---+---+\n   F: Final\
    \ bit.  If set, it indicates that this is the last segment of\n   a reconstructed\
    \ unit.\n   The segment header may be preceded by padding octets and/or feedback.\n\
    \   It never carries a CID.\n   All segment header packets for one reconstructed\
    \ unit have to be sent\n   consecutively on a channel, i.e., any non-segment-header\
    \ packet\n   following a nonfinal segment header aborts the reassembly of the\n\
    \   current reconstructed unit and causes the decompressor to discard the\n  \
    \ nonfinal segments received on this channel so far.  When a final\n   segment\
    \ header is received, the decompressor reassembles the segment\n   carried in\
    \ this packet and any nonfinal segments that immediately\n   preceded it into\
    \ a single reconstructed unit, in the order they were\n   received.  The reconstructed\
    \ unit has the format:\n   Reconstructed Unit\n     0   1   2   3   4   5   6\
    \   7\n   +---+---+---+---+---+---+---+---+\n   |                            \
    \   |\n   /   Reconstructed ROHC packet   /  variable length\n   |           \
    \                    |\n   +---+---+---+---+---+---+---+---+\n   /           \
    \   CRC              /  4 octets\n   +---+---+---+---+---+---+---+---+\n   The\
    \ CRC is used by the decompressor to validate the reconstructed\n   unit.  It\
    \ uses the FCS-32 algorithm with the following generator\n   polynomial: x^0 +\
    \ x^1 + x^2 + x^4 + x^5 + x^7 + x^8 + x^10 + x^11 +\n   x^12 + x^16 + x^22 + x^23\
    \ + x^26 + x^32 [HDLC].  If the reconstructed\n   unit is 4 octets or less, or\
    \ if the CRC fails, or if it is larger\n   than the channel parameter MRRU (see\
    \ 5.1.1), the reconstructed unit\n   MUST be discarded by the decompressor.\n\
    \   If the CRC succeeds, the reconstructed ROHC packet is interpreted as\n   a\
    \ ROHC Header, optionally followed by a payload.  Note that this\n   means that\
    \ there can be no padding and no feedback in the\n   reconstructed unit, and that\
    \ the CID is derived from the initial\n   octets of the reconstructed unit.\n\
    \   (It should be noted that the ROHC segmentation protocol was inspired\n   by\
    \ SEAL by Steve Deering et al., which later became ATM AAL5.  The\n   same arguments\
    \ for not having sequence numbers in the segments but\n   instead providing a\
    \ strong CRC in the reconstructed unit apply here\n   as well.  Note that, as\
    \ a result of this protocol, there is no way in\n   ROHC to make any use of a\
    \ segment that has residual bit errors.)\n"
- title: 5.2.6.  ROHC initial decompressor processing
  contents:
  - "5.2.6.  ROHC initial decompressor processing\n   The following packet types are\
    \ reserved at the framework level in the\n   ROHC scheme:\n   1110:     Padding\
    \ or Add-CID octet\n   11110:    Feedback\n   11111000: IR-DYN packet\n   1111110:\
    \  IR packet\n   1111111:  Segment\n   Other packet types can be used at will\
    \ by individual profiles.\n   The following steps is an outline of initial decompressor\
    \ processing\n   which upon reception of a ROHC packet can determine its contents.\n\
    \   1) If the first octet is a Padding Octet (11100000),\n      strip away all\
    \ initial Padding Octets and goto next step.\n   2) If the first remaining octet\
    \ starts with 1110, it is an Add-CID\n      octet:\n         remember the Add-CID\
    \ octet; remove the octet.\n   3) If the first remaining octet starts with 11110,\
    \ and an Add-CID\n      octet was found in step 2),\n         an error has occurred;\
    \ the header MUST be discarded without\n         further action.\n   4) If the\
    \ first remaining octet starts with 11110, and an Add-CID\n      octet was not\
    \ found in step 2), this is feedback:\n         find the size of the feedback\
    \ data, call it s;\n         remove the feedback type octet;\n         remove\
    \ the Size octet if Code is 0;\n         send feedback data of length s to the\
    \ same-side associated\n         compressor;\n         if packet exhausted, stop;\
    \ otherwise goto 2).\n   5) If the first remaining octet starts with 1111111,\
    \ this is a\n      segment:\n         attempt reconstruction using the segmentation\
    \ protocol\n         (5.2.5).  If a reconstructed packet is not produced, this\n\
    \         finishes the processing of the original packet.  If a\n         reconstructed\
    \ packet is produced, it is fed into step 1)\n         above.  Padding, segments,\
    \ and feedback are not allowed in\n         reconstructed packets, so when processing\
    \ them, steps 1),\n         4), and 5) are modified so that the packet is discarded\n\
    \         without further action when their conditions match.\n   6) Here, it\
    \ is known that the rest is forward information (unless the\n      header is damaged).\n\
    \   7) If the forward traffic uses small CIDs, there is no large CID in\n    \
    \  the packet.  If an Add-CID immediately preceded the packet type\n      (step\
    \ 2), it has the CID of the Add-CID; otherwise it has CID 0.\n   8) If the forward\
    \ traffic uses large CIDs, the CID starts with the\n      second remaining octet.\
    \  If the first bit(s) of that octet are not\n      0 or 10, the packet MUST be\
    \ discarded without further action.  If\n      an Add-CID octet immediately preceded\
    \ the packet type (step 2),\n      the packet MUST be discarded without further\
    \ action.\n   9) Use the CID to find the context.\n   10) If the packet type is\
    \ IR, the profile indicated in the IR packet\n       determines how it is to be\
    \ processed.  If the CRC fails to verify\n       the packet, it MUST be discarded.\
    \  If a profile is indicated in\n       the context, the logic of that profile\
    \ determines what, if any,\n       feedback is to be sent.  If no profile is noted\
    \ in the context,\n       no further action is taken.\n   11) If the packet type\
    \ is IR-DYN, the profile indicated in the IR-DYN\n       packet determines how\
    \ it is to be processed.\n      a) If the CRC fails to verify the packet, it MUST\
    \ be discarded.\n         If a profile is indicated in the context, the logic\
    \ of that\n         profile determines what, if any, feedback is to be sent. \
    \ If no\n         profile is noted in the context, no further action is taken.\n\
    \      b) If the context has not been initialized by an IR packet, the\n     \
    \    packet MUST be discarded.  The logic of the profile indicated\n         in\
    \ the IR-DYN header (if verified by the CRC), determines what,\n         if any,\
    \ feedback is to be sent.\n   12) Otherwise, the profile noted in the context\
    \ determines how the\n       rest of the packet is to be processed.  If the context\
    \ has not\n       been initialized by an IR packet, the packet MUST be discarded\n\
    \       without further action.\n   The procedure for finding the size of the\
    \ feedback data is as\n   follows:\n   Examine the three bits which immediately\
    \ follow the feedback packet\n   type.  When these bits are\n      1-7, the size\
    \ of the feedback data is given by the bits;\n      0,   a Size octet, which explicitly\
    \ gives the size of the\n           feedback data, is present after the feedback\
    \ type octet.\n"
- title: 5.2.7.  ROHC RTP packet formats from compressor to decompressor
  contents:
  - "5.2.7.  ROHC RTP packet formats from compressor to decompressor\n   ROHC RTP\
    \ uses three packet types to identify compressed headers, and\n   two for initialization/refresh.\
    \  The format of a compressed packet\n   can depend on the mode.  Therefore a\
    \ naming scheme of the form\n      <modes format is used in>-<packet type number>-<some\
    \ property>\n   is used to uniquely identify the format when necessary, e.g.,\
    \ UOR-2,\n   R-1.  For exact formats of the packet types, see section 5.7.\n \
    \  Packet type zero: R-0, R-0-CRC, UO-0.\n      This, the minimal, packet type\
    \ is used when parameters of all SN-\n      functions are known by the decompressor,\
    \ and the header to be\n      compressed adheres to these functions.  Thus, only\
    \ the W-LSB\n      encoded RTP SN needs to be communicated.\n      R-mode: Only\
    \ if a CRC is present (packet type R-0-CRC) may the\n      header be used as a\
    \ reference for subsequent decompression.\n      U-mode and O-mode: A small CRC\
    \ is present in the UO-0 packet.\n   Packet type 1: R-1, R-1-ID, R-1-TS, UO-1,\
    \ UO-1-ID, UO-1-TS.\n      This packet type is used when the number of bits needed\
    \ for the SN\n      exceeds those available in packet type zero, or when the\n\
    \      parameters of the SN-functions for RTP TS or IP-ID change.\n      R-mode:\
    \ R-1-* packets are not used as references for subsequent\n      decompression.\
    \  Values for other fields than the RTP TS or IP-ID\n      can be communicated\
    \ using an extension, but they do not update the\n      context.\n      U-mode\
    \ and O-mode: Only the values of RTP SN, RTP TS and IP-ID can\n      be used as\
    \ references for future compression.  Nonupdating values\n      can be provided\
    \ for other fields using an extension (UO-1-ID).\n   Packet type 2: UOR-2, UOR-2-ID,\
    \ UOR-2-TS\n      This packet type can be used to change the parameters of any\
    \ SN-\n      function, except those for most static fields.  Headers of packets\n\
    \      transferred using packet type 2 can be used as references for\n      subsequent\
    \ decompression.\n   Packet type: IR\n      This packet type communicates the\
    \ static part of the context,\n      i.e., the value of the constant SN-functions.\
    \  It can optionally\n      also communicate the dynamic part of the context,\
    \ i.e., the\n      parameters of the nonconstant SN-functions.\n   Packet type:\
    \ IR-DYN\n      This packet type communicates the dynamic part of the context,\n\
    \      i.e., the parameters of nonconstant SN-functions.\n"
- title: 5.2.8.  Parameters needed for mode transition in ROHC RTP
  contents:
  - "5.2.8.  Parameters needed for mode transition in ROHC RTP\n   The packet types\
    \ IR (with dynamic information), IR-DYN, and UOR-2 are\n   common for all modes.\
    \  They can carry a mode parameter which can take\n   the values U = Unidirectional,\
    \ O = Bidirectional Optimistic, and R =\n   Bidirectional Reliable.\n   Feedback\
    \ of types ACK, NACK, and STATIC-NACK carry sequence numbers,\n   and feedback\
    \ packets can also carry a mode parameter indicating the\n   desired compression\
    \ mode: U, O, or R.\n   As a shorthand, the notation PACKET(mode) is used to indicate\
    \ which\n   mode value a packet carries.  For example, an ACK with mode parameter\n\
    \   R is written ACK(R), and an UOR-2 with mode parameter O is written\n   UOR-2(O).\n"
- title: 5.3.  Operation in Unidirectional mode
  contents:
  - '5.3.  Operation in Unidirectional mode

    '
- title: 5.3.1.  Compressor states and logic (U-mode)
  contents:
  - "5.3.1.  Compressor states and logic (U-mode)\n   Below is the state machine for\
    \ the compressor in Unidirectional mode.\n   Details of the transitions between\
    \ states and compression logic are\n   given subsequent to the figure.\n     \
    \                    Optimistic approach\n      +------>------>------>------>------>------>------>------>------+\n\
    \      |                                                              |\n    \
    \  |        Optimistic approach         Optimistic approach       |\n      | \
    \     +------>------>------+      +------>------>------+      |\n      |     \
    \ |                    |      |                    |      |\n      |      |  \
    \                  v      |                    v      v\n    +----------+    \
    \            +----------+                +----------+\n    | IR State |      \
    \          | FO State |                | SO State |\n    +----------+        \
    \        +----------+                +----------+\n      ^      ^            \
    \        |      ^                    |      |\n      |      |      Timeout   \
    \    |      |  Timeout / Update  |      |\n      |      +------<------<------+\
    \      +------<------<------+      |\n      |                                \
    \                              |\n      |                           Timeout  \
    \                          |\n      +------<------<------<------<------<------<------<------<------+\n"
- title: 5.3.1.1.  State transition logic (U-mode)
  contents:
  - "5.3.1.1.  State transition logic (U-mode)\n   The transition logic for compression\
    \ states in Unidirectional mode is\n   based on three principles: the optimistic\
    \ approach principle,\n   timeouts, and the need for updates.\n"
- title: 5.3.1.1.1.  Optimistic approach, upwards transition
  contents:
  - "5.3.1.1.1.  Optimistic approach, upwards transition\n   Transition to a higher\
    \ compression state in Unidirectional mode is\n   carried out according to the\
    \ optimistic approach principle.  This\n   means that the compressor transits\
    \ to a higher compression state when\n   it is fairly confident that the decompressor\
    \ has received enough\n   information to correctly decompress packets sent according\
    \ to the\n   higher compression state.\n   When the compressor is in the IR state,\
    \ it will stay there until it\n   assumes that the decompressor has correctly\
    \ received the static\n   context information.  For transition from the FO to\
    \ the SO state, the\n   compressor should be confident that the decompressor has\
    \ all\n   parameters needed to decompress according to a fixed pattern.\n   The\
    \ compressor normally obtains its confidence about decompressor\n   status by\
    \ sending several packets with the same information according\n   to the lower\
    \ compression state.  If the decompressor receives any of\n   these packets, it\
    \ will be in sync with the compressor.  The number of\n   consecutive packets\
    \ to send for confidence is not defined in this\n   document.\n"
- title: 5.3.1.1.2.  Timeouts, downward transition
  contents:
  - "5.3.1.1.2.  Timeouts, downward transition\n   When the optimistic approach is\
    \ taken as described above, there will\n   always be a possibility of failure\
    \ since the decompressor may not\n   have received sufficient information for\
    \ correct decompression.\n   Therefore, the compressor MUST periodically transit\
    \ to lower\n   compression states.  Periodic transition to the IR state SHOULD\
    \ be\n   carried out less often than transition to the FO state.  Two\n   different\
    \ timeouts SHOULD therefore be used for these transitions.\n   For an example\
    \ of how to implement periodic refreshes, see [IPHC]\n   chapters 3.3.1-3.3.2.\n"
- title: 5.3.1.1.3.  Need for updates, downward transition
  contents:
  - "5.3.1.1.3.  Need for updates, downward transition\n   In addition to the downward\
    \ state transitions carried out due to\n   periodic timeouts, the compressor must\
    \ also immediately transit back\n   to the FO state when the header to be compressed\
    \ does not conform to\n   the established pattern.\n"
- title: 5.3.1.2.  Compression logic and packets used (U-mode)
  contents:
  - "5.3.1.2.  Compression logic and packets used (U-mode)\n   The compressor chooses\
    \ the smallest possible packet format that can\n   communicate the desired changes,\
    \ and has the required number of bits\n   for W-LSB encoded values.\n"
- title: 5.3.1.3.  Feedback in Unidirectional mode
  contents:
  - "5.3.1.3.  Feedback in Unidirectional mode\n   The Unidirectional mode of operation\
    \ is designed to operate over\n   links where a feedback channel is not available.\
    \  If a feedback\n   channel is available, however, the decompressor MAY send\
    \ an\n   acknowledgment of successful decompression with the mode parameter\n\
    \   set to U (send an ACK(U)).  When the compressor receives such a\n   message,\
    \ it MAY disable (or increase the interval between) periodic\n   IR refreshes.\n"
- title: 5.3.2.  Decompressor states and logic (U-mode)
  contents:
  - "5.3.2.  Decompressor states and logic (U-mode)\n   Below is the state machine\
    \ for the decompressor in Unidirectional\n   mode.  Details of the transitions\
    \ between states and decompression\n   logic are given subsequent to the figure.\n\
    \                                 Success\n                +-->------>------>------>------>------>--+\n\
    \                |                                        |\n    No Static   |\
    \            No Dynamic        Success   |    Success\n     +-->--+    |     \
    \        +-->--+      +--->----->---+    +-->--+\n     |     |    |          \
    \   |     |      |             |    |     |\n     |     v    |             | \
    \    v      |             v    |     v\n   +--------------+         +----------------+\
    \         +--------------+\n   |  No Context  |         | Static Context |   \
    \      | Full Context |\n   +--------------+         +----------------+      \
    \   +--------------+\n      ^                         |        ^             \
    \            |\n      | k_2 out of n_2 failures |        | k_1 out of n_1 failures\
    \ |\n      +-----<------<------<-----+        +-----<------<------<-----+\n"
- title: 5.3.2.1.  State transition logic (U-mode)
  contents:
  - "5.3.2.1.  State transition logic (U-mode)\n   Successful decompression will always\
    \ move the decompressor to the\n   Full Context state.  Repeated failed decompression\
    \ will force the\n   decompressor to transit downwards to a lower state.  The\
    \ decompressor\n   does not attempt to decompress headers at all in the No Context\
    \ and\n   Static Context states unless sufficient information is included in\n\
    \   the packet itself.\n"
- title: 5.3.2.2.  Decompression logic (U-mode)
  contents:
  - "5.3.2.2.  Decompression logic (U-mode)\n   Decompression in Unidirectional mode\
    \ is carried out following three\n   steps which are described in subsequent sections.\n"
- title: 5.3.2.2.1.  Decide whether decompression is allowed
  contents:
  - "5.3.2.2.1.  Decide whether decompression is allowed\n   In Full Context state,\
    \ decompression may be attempted regardless of\n   what kind of packet is received.\
    \  However, for the other states\n   decompression is not always allowed.  In\
    \ the No Context state only IR\n   packets, which carry the static information\
    \ fields, may be\n   decompressed.  Further, when in the Static Context state,\
    \ only\n   packets carrying a 7- or 8-bit CRC can be decompressed (i.e., IR,\n\
    \   IR-DYN, or UOR-2 packets).  If decompression may not be performed the\n  \
    \ packet is discarded, unless the optional delayed decompression\n   mechanism\
    \ is used, see section 6.1.\n"
- title: 5.3.2.2.2.  Reconstruct and verify the header
  contents:
  - "5.3.2.2.2.  Reconstruct and verify the header\n   When reconstructing the header,\
    \ the decompressor takes the header\n   information already stored in the context\
    \ and updates it with the\n   information received in the current header.  (If\
    \ the reconstructed\n   header fails the CRC check, these updates MUST be undone.)\n\
    \   The sequence number is reconstructed by replacing the sequence number\n  \
    \ LSBs in the context with those received in the header.  The resulting\n   value\
    \ is then verified to be within the interpretation interval by\n   comparison\
    \ with a previously reconstructed reference value v_ref (see\n   section 4.5.1).\
    \  If it is not within this interval, an adjustment is\n   applied by adding N\
    \ x interval_size to the reconstructed value so\n   that the result is brought\
    \ within the interpretation interval.  Note\n   that N can be negative.\n   If\
    \ RTP Timestamp and IP Identification fields are not included in the\n   received\
    \ header, they are supposed to be calculated from the sequence\n   number.  The\
    \ IP Identifier usually increases by the same delta as the\n   sequence number\
    \ and the timestamp by the same delta times a fixed\n   value.  See chapters 4.5.3\
    \ and 4.5.5 for details about how these\n   fields are encoded in compressed headers.\n\
    \   When working in Unidirectional mode, all compressed headers carry a\n   CRC\
    \ which MUST be used to verify decompression.\n"
- title: 5.3.2.2.3.  Actions upon CRC failure
  contents:
  - "5.3.2.2.3.  Actions upon CRC failure\n   This section is written so that it is\
    \ applicable to all modes.\n   A mismatch in the CRC can be caused by one or more\
    \ of:\n   1. residual bit errors in the current header\n   2. a damaged context\
    \ due to residual bit errors in previous headers\n   3. many consecutive packets\
    \ being lost between compressor and\n      decompressor (this may cause the LSBs\
    \ of the SN in compressed\n      packets to be interpreted wrongly, because the\
    \ decompressor has\n      not moved the interpretation interval for lack of input\
    \ -- in\n      essence, a kind of context damage).\n   (Cases 2 and 3 do not apply\
    \ to IR packets; case 3 does not apply to\n   IR-DYN packets.)  The 3-bit CRC\
    \ present in some header formats will\n   eventually detect context damage reliably,\
    \ since the probability of\n   undetected context damage decreases exponentially\
    \ with each new\n   header processed.  However, residual bit errors in the current\
    \ header\n   are only detected with good probability, not reliably.\n   When a\
    \ CRC mismatch is caused by residual bit errors in the current\n   header (case\
    \ 1 above), the decompressor should stay in its current\n   state to avoid unnecessary\
    \ loss of subsequent packets.  On the other\n   hand, when the mismatch is caused\
    \ by a damaged context (case 2), the\n   decompressor should attempt to repair\
    \ the context locally.  If the\n   local repair attempt fails, it must move to\
    \ a lower state to avoid\n   delivering incorrect headers.  When the mismatch\
    \ is caused by\n   prolonged loss (case 3), the decompressor might attempt additional\n\
    \   decompression attempts.  Note that case 3 does not occur in R-mode.\n   The\
    \ following actions MUST be taken when a CRC check fails:\n   First, attempt to\
    \ determine whether SN LSB wraparound (case 3) is\n   likely, and if so, attempt\
    \ a correction.  For this, the algorithm of\n   section 5.3.2.2.4 MAY be used.\
    \  If another algorithm is used, it MUST\n   have at least as high a rate of correct\
    \ repairs as the one in\n   5.3.2.2.4.  (This step is not applicable to R-mode.)\n\
    \   Second, if the previous step did not attempt a correction, a repair\n   should\
    \ be attempted under the assumption that the reference SN has\n   been incorrectly\
    \ updated.  For this, the algorithm of section\n   5.3.2.2.5 MAY be used.  If\
    \ another algorithm is used, it MUST have at\n   least as high a rate of correct\
    \ repairs as the one in 5.3.2.2.5.\n   (This step is not applicable to R-mode.)\n\
    \   If both the above steps fail, additional decompression attempts\n   SHOULD\
    \ NOT be made.  There are two possible reasons for the CRC\n   failure: case 1\
    \ or unrecoverable context damage.  It is impossible to\n   know for certain which\
    \ of these is the actual cause.  The following\n   rules are to be used:\n   a.\
    \ When CRC checks fail only occasionally, assume residual errors in\n      the\
    \ current header and simply discard the packet.  NACKs SHOULD\n      NOT be sent\
    \ at this time.\n   b. In the Full Context state: When the CRC check of k_1 out\
    \ of the\n      last n_1 decompressed packets have failed, context damage SHOULD\n\
    \      be assumed and a NACK SHOULD be sent in O- and R-mode.  The\n      decompressor\
    \ moves to the Static Context state and discards all\n      packets until an update\
    \ (IR, IR-DYN, UOR-2) which passes the CRC\n      check is received.\n   c. In\
    \ the Static Context state: When the CRC check of k_2 out of the\n      last n_2\
    \ updates (IR, IR-DYN, UOR-2) have failed, static context\n      damage SHOULD\
    \ be assumed and a STATIC-NACK is sent in O- and R-\n      mode.  The decompressor\
    \ moves to the No Context state.\n   d. In the No Context state: The decompressor\
    \ discards all packets\n      until a static update (IR) which passes the CRC\
    \ check is received.\n      (In O-mode and R-mode, feedback is sent according\
    \ to sections\n      5.4.2.2 and 5.5.2.2, respectively.)\n   Note that appropriate\
    \ values for k_1, n_1, k_2, and n_2, are related\n   to the residual error rate\
    \ of the link.  When the residual error rate\n   is close to zero, k_1 = n_1 =\
    \ k_2 = n_2 = 1 may be appropriate.\n"
- title: 5.3.2.2.4.  Correction of SN LSB wraparound
  contents:
  - "5.3.2.2.4.  Correction of SN LSB wraparound\n   When many consecutive packets\
    \ are lost there will be a risk of\n   sequence number LSB wraparound, i.e., the\
    \ SN LSBs being interpreted\n   wrongly because the interpretation interval has\
    \ not moved for lack of\n   input.  The decompressor might be able to detect this\
    \ situation and\n   avoid context damage by using a local clock.  The following\
    \ algorithm\n   MAY be used:\n   a. The decompressor notes the arrival time, a(i),\
    \ of each incoming\n      packet i.  Arrival times of packets where decompression\
    \ fails are\n      discarded.\n   b. When decompression fails, the decompressor\
    \ computes INTERVAL =\n      a(i) - a(i - 1), i.e., the time elapsed between the\
    \ arrival of the\n      previous, correctly decompressed packet and the current\
    \ packet.\n   c. If wraparound has occurred, INTERVAL will correspond to at least\n\
    \      2^k inter-packet times, where k is the number of SN bits in the\n     \
    \ current header.  On the basis of an estimate of the packet inter-\n      arrival\
    \ time, obtained for example using a moving average of\n      arrival times, TS_STRIDE,\
    \ or TS_TIME, the decompressor judges if\n      INTERVAL can correspond to 2^k\
    \ inter-packet times.\n   d. If INTERVAL is judged to be at least 2^k packet inter-arrival\n\
    \      times, the decompressor adds 2^k to the reference SN and attempts\n   \
    \   to decompress the packet using the new reference SN.\n   e. If this decompression\
    \ succeeds, the decompressor updates the\n      context but SHOULD NOT deliver\
    \ the packet to upper layers.  The\n      following packet is also decompressed\
    \ and updates the context if\n      its CRC succeeds, but SHOULD be discarded.\
    \  If decompression of\n      the third packet using the new context also succeeds,\
    \ the context\n      repair is deemed successful and this and subsequent decompressed\n\
    \      packets are delivered to the upper layers.\n   f. If any of the three decompression\
    \ attempts in d. and e. fails, the\n      decompressor discards the packets and\
    \ acts according to rules a)\n      through c) of section 5.3.2.2.3.\n   Using\
    \ this mechanism, the decompressor may be able to repair the\n   context after\
    \ excessive loss, at the expense of discarding two\n   packets.\n"
- title: 5.3.2.2.5.  Repair of incorrect SN updates
  contents:
  - "5.3.2.2.5.  Repair of incorrect SN updates\n   The CRC can fail to detect residual\
    \ errors in the compressed header\n   because of its limited length, i.e., the\
    \ incorrectly decompressed\n   packet can happen to have the same CRC as the original\
    \ uncompressed\n   packet.  The incorrect decompressed header will then update\
    \ the\n   context.  This can lead to an erroneous reference SN being used in\n\
    \   W-LSB decoding, as the reference SN is updated for each successfully\n   decompressed\
    \ header of certain types.\n   In this situation, the decompressor will detect\
    \ the incorrect\n   decompression of the following packet with high probability,\
    \ but it\n   does not know the reason for the failure.  The following mechanism\n\
    \   allows the decompressor to judge if the context was updated\n   incorrectly\
    \ by an earlier packet and, if so, to attempt a repair.\n   a. The decompressor\
    \ maintains two decompressed sequence numbers: the\n      last one (ref 0) and\
    \ the one before that (ref -1).\n   b. When receiving a compressed header the\
    \ SN (SN curr1) is\n      decompressed using ref 0 as the reference.  The other\
    \ header\n      fields are decompressed using this decompressed SN curr1.  (This\n\
    \      is part of the normal decompression procedure prior to any CRC\n      test\
    \ failures.)\n   c. If the decompressed header generated in b. passes the CRC\
    \ test,\n      the references are shifted as follows:\n           ref -1 = ref\
    \ 0\n           ref  0 = SN curr1.\n   d. If the header generated in b. does not\
    \ pass the CRC test, and the\n      SN (SN curr2) generated when using ref -1\
    \ as the reference is\n      different from SN curr1, an additional decompression\
    \ attempt is\n      performed based on SN curr2 as the decompressed SN.\n   e.\
    \ If the decompressed header generated in b. does not pass the CRC\n      test\
    \ and SN curr2 is the same as SN curr1, an additional\n      decompression attempt\
    \ is not useful and is not attempted.\n   f. If the decompressed header generated\
    \ in d. passes the CRC test,\n      ref -1 is not changed while ref 0 is set to\
    \ SN curr2.\n   g. If the decompressed header generated in d. does not pass the\
    \ CRC\n      test, the decompressor acts according to rules a) through c) of\n\
    \      section 5.3.2.2.3.\n   The purpose of this algorithm is to repair the context.\
    \  If the\n   header generated in d. passes the CRC test, the references are\n\
    \   updated according to f., but two more headers MUST also be\n   successfully\
    \ decompressed before the repair is deemed successful.  Of\n   the three successful\
    \ headers, the first two SHOULD be discarded and\n   only the third delivered\
    \ to upper layers.  If decompression of any of\n   the three headers fails, the\
    \ decompressor MUST discard that header\n   and the previously generated headers,\
    \ and act according to rules a)\n   through c) of section 5.3.2.2.3.\n"
- title: 5.3.2.3.  Feedback in Unidirectional mode
  contents:
  - "5.3.2.3.  Feedback in Unidirectional mode\n   To improve performance for the\
    \ Unidirectional mode over a link that\n   does have a feedback channel, the decompressor\
    \ MAY send an\n   acknowledgment when decompression succeeds.  Setting the mode\n\
    \   parameter in the ACK packet to U indicates that the compressor is to\n   stay\
    \ in Unidirectional mode.  When receiving an ACK(U), the\n   compressor should\
    \ reduce the frequency of IR packets since the static\n   information has been\
    \ correctly received, but it is not required to\n   stop sending IR packets. \
    \ If IR packets continue to arrive, the\n   decompressor MAY repeat the ACK(U),\
    \ but it SHOULD NOT repeat the\n   ACK(U) continuously.\n"
- title: 5.4.  Operation in Bidirectional Optimistic mode
  contents:
  - '5.4.  Operation in Bidirectional Optimistic mode

    '
- title: 5.4.1.  Compressor states and logic (O-mode)
  contents:
  - "5.4.1.  Compressor states and logic (O-mode)\n   Below is the state machine for\
    \ the compressor in Bidirectional\n   Optimistic mode.  The details of each state,\
    \ state transitions, and\n   compression logic are given subsequent to the figure.\n\
    \                            Optimistic approach / ACK\n     +------>------>------>------>------>------>------>------>------+\n\
    \     |                                                              |\n     |\
    \      Optimistic appr. / ACK      Optimistic appr. /ACK   ACK |\n     |     \
    \ +------>------>------+      +------>--- -->-----+  +->--+\n     |      |   \
    \                 |      |                   |  |    |\n     |      |        \
    \            v      |                   v  |    v\n   +----------+           \
    \     +----------+                +----------+\n   | IR State |              \
    \  | FO State |                | SO State |\n   +----------+                +----------+\
    \                +----------+\n     ^      ^                    |      ^     \
    \               |      |\n     |      |    STATIC-NACK     |      |    NACK /\
    \ Update   |      |\n     |      +------<------<------+      +------<------<------+\
    \      |\n     |                                                             \
    \ |\n     |                         STATIC-NACK                          |\n \
    \    +------<------<------<------<------<------<------<------<------+\n"
- title: 5.4.1.1.  State transition logic
  contents:
  - "5.4.1.1.  State transition logic\n   The transition logic for compression states\
    \ in Bidirectional\n   Optimistic mode has much in common with the logic of the\n\
    \   Unidirectional mode.  The optimistic approach principle and\n   transitions\
    \ occasioned by the need for updates work in the same way\n   as described in\
    \ chapter 5.3.1.  However, in Optimistic mode there are\n   no timeouts.  Instead,\
    \ the Optimistic mode makes use of feedback from\n   decompressor to compressor\
    \ for transitions in the backward direction\n   and for OPTIONAL improved forward\
    \ transition.\n"
- title: 5.4.1.1.1.  Negative acknowledgments (NACKs), downward transition
  contents:
  - "5.4.1.1.1.  Negative acknowledgments (NACKs), downward transition\n   Negative\
    \ acknowledgments (NACKs), also called context requests,\n   obviate the periodic\
    \ updates needed in Unidirectional mode.  Upon\n   reception of a NACK the compressor\
    \ transits back to the FO state and\n   sends updates (IR-DYN, UOR-2, or possibly\
    \ IR) to the decompressor.\n   NACKs carry the SN of the latest packet successfully\
    \ decompressed,\n   and this information MAY be used by the compressor to determine\
    \ what\n   fields need to be updated.\n   Similarly, reception of a STATIC-NACK\
    \ packet makes the compressor\n   transit back to the IR state.\n"
- title: 5.4.1.1.2.  Optional acknowledgments, upwards transition
  contents:
  - "5.4.1.1.2.  Optional acknowledgments, upwards transition\n   In addition to NACKs,\
    \ positive feedback (ACKs) MAY also be used for\n   UOR-2 packets in the Bidirectional\
    \ Optimistic mode.  Upon reception\n   of an ACK for an updating packet, the compressor\
    \ knows that the\n   decompressor has received the acknowledged packet and the\
    \ transition\n   to a higher compression state can be carried out immediately.\
    \  This\n   functionality is optional, so a compressor MUST NOT expect to get\n\
    \   such ACKs initially.\n   The compressor MAY use the following algorithm to\
    \ determine when to\n   expect ACKs for UOR-2 packets.  Let an update event be\
    \ when a\n   sequence of UOR-2 headers are sent to communicate an irregularity\
    \ in\n   the packet stream.  When ACKs have been received for k_3 out of the\n\
    \   last n_3 update events, the compressor will expect ACKs.  A\n   compressor\
    \ which expects ACKs will repeat updates (possibly not in\n   every packet) until\
    \ an ACK is received.\n"
- title: 5.4.1.2.  Compression logic and packets used
  contents:
  - "5.4.1.2.  Compression logic and packets used\n   The compression logic is the\
    \ same for the Bidirectional Optimistic\n   mode as for the Unidirectional mode\
    \ (see section 5.3.1.2).\n"
- title: 5.4.2.  Decompressor states and logic (O-mode)
  contents:
  - "5.4.2.  Decompressor states and logic (O-mode)\n   The decompression states and\
    \ the state transition logic are the same\n   as for the Unidirectional case (see\
    \ section 5.3.2).  What differs is\n   the decompression and feedback logic.\n"
- title: 5.4.2.1.  Decompression logic, timer-based timestamp decompression
  contents:
  - "5.4.2.1.  Decompression logic, timer-based timestamp decompression\n   In Bidirectional\
    \ mode (or if there is some other way for the\n   compressor to obtain the decompressor's\
    \ clock resolution and the\n   link's jitter), timer-based timestamp decompression\
    \ may be used to\n   improve compression efficiency when RTP Timestamp values\
    \ are\n   proportional to wall-clock time.  The mechanisms used are those\n  \
    \ described in 4.5.4.\n"
- title: 5.4.2.2.  Feedback logic (O-mode)
  contents:
  - "5.4.2.2.  Feedback logic (O-mode)\n   The feedback logic defines what feedback\
    \ to send due to different\n   events when operating in the various states.  As\
    \ mentioned above,\n   there are three principal kinds of feedback; ACK, NACK\
    \ and STATIC-\n   NACK.  Further, the logic described below will refer to different\n\
    \   kinds of packets that can be received by the decompressor;\n   Initialization\
    \ and Refresh (IR) packets, IR packets without static\n   information (IR-DYN)\
    \ and type 2 packets (UOR-2), or type 1 (UO-1) and\n   type 0 packets (UO-0).\
    \  A type 0 packet carries a packet header\n   compressed according to a fixed\
    \ pattern, while type 1, 2 and IR-DYN\n   packets are used when this pattern is\
    \ broken.\n   Below, rules are defined stating which feedback to use when.  If\
    \ the\n   optional feedback is used once, the decompressor is REQUIRED to\n  \
    \ continue to send optional feedback for the lifetime of the packet\n   stream.\n\
    \   State Actions\n   NC:  - When an IR packet passes the CRC check, send an ACK(O).\n\
    \        - When receiving a type 0, 1, 2 or IR-DYN packet, or an IR\n        \
    \  packet has failed the CRC check, send a STATIC-NACK(O),\n          subject\
    \ to the considerations at the beginning of section\n          5.7.6.\n   SC:\
    \  - When an IR packet is correctly decompressed, send an ACK(O).\n        - When\
    \ a type 2 or an IR-DYN packet is correctly decompressed,\n          optionally\
    \ send an ACK(O).\n        - When a type 0 or 1 packet is received, treat it as\
    \ a\n          mismatching CRC and use the logic of section 5.3.2.2.3 to\n   \
    \       decide if a NACK(O) should be sent.\n        - When decompression of a\
    \ type 2 packet, an IR-DYN packet or an\n          IR packet has failed, use the\
    \ logic of section 5.3.2.2.3 to\n          decide if a STATIC-NACK(O) should be\
    \ sent.\n   FC:  - When an IR packet is correctly decompressed, send an ACK(O).\n\
    \        - When a type 2 or an IR-DYN packet is correctly decompressed,\n    \
    \      optionally send an ACK(O).\n        - When a type 0 or 1 packet is correctly\
    \ decompressed, no\n          feedback is sent.\n        - When any packet fails\
    \ the CRC check, use the logic of\n          5.3.2.2.3 to decide if a NACK(O)\
    \ should be sent.\n"
- title: 5.5.  Operation in Bidirectional Reliable mode
  contents:
  - '5.5.  Operation in Bidirectional Reliable mode

    '
- title: 5.5.1.  Compressor states and logic (R-mode)
  contents:
  - "5.5.1.  Compressor states and logic (R-mode)\n   Below is the state machine for\
    \ the compressor in Bidirectional\n   Reliable mode.  The details of each state,\
    \ state transitions, and\n   compression logic are given subsequent to the figure.\n\
    \                                       ACK\n      +------>------>------>------>------>------>------>------+\n\
    \      |                                                       |\n      |    \
    \           ACK                         ACK         |   ACK\n      |      +------>------>------+\
    \      +------>------>------+  +->-+\n      |      |                    |    \
    \  |                    |  |   |\n      |      |                    v      | \
    \                   v  |   v\n    +----------+                +----------+   \
    \             +----------+\n    | IR State |                | FO State |     \
    \           | SO State |\n    +----------+                +----------+       \
    \         +----------+\n      ^      ^                    |      ^           \
    \         |      |\n      |      |    STATIC-NACK     |      |    NACK / Update\
    \   |      |\n      |      +------<------<------+      +------<------<------+\
    \      |\n      |                                                            \
    \  |\n      |                         STATIC-NACK                          |\n\
    \      +------<------<------<------<------<------<------<------<------+\n"
- title: 5.5.1.1.  State transition logic (R-mode)
  contents:
  - "5.5.1.1.  State transition logic (R-mode)\n   The transition logic for compression\
    \ states in Reliable mode is based\n   on three principles: the secure reference\
    \ principle, the need for\n   updates, and negative acknowledgments.\n"
- title: 5.5.1.1.1.  Upwards transition
  contents:
  - "5.5.1.1.1.  Upwards transition\n   The upwards transition is determined by the\
    \ secure reference\n   principle.  The transition procedure is similar to the\
    \ one described\n   in section 5.3.1.1.1, with one important difference: the compressor\n\
    \   bases its confidence only on acknowledgments received from the\n   decompressor.\
    \  This ensures that the synchronization between the\n   compression context and\
    \ decompression context will never be lost due\n   to packet losses.\n"
- title: 5.5.1.1.2.  Downward transition
  contents:
  - "5.5.1.1.2.  Downward transition\n   Downward transitions are triggered by the\
    \ need for updates or by\n   negative acknowledgment (NACKs and STATIC_NACKs),\
    \ as described in\n   section 5.3.1.1.3 and 5.4.1.1.1, respectively.  Note that\
    \ NACKs\n   should rarely occur in R-mode because of the secure reference used\n\
    \   (see fourth paragraph of next section).\n"
- title: 5.5.1.2.  Compression logic and packets used (R-mode)
  contents:
  - "5.5.1.2.  Compression logic and packets used (R-mode)\n   The compressor starts\
    \ in the IR state by sending IR packets.  It\n   transits to the FO state once\
    \ it receives a valid ACK for an IR\n   packet sent (an ACK can only be valid\
    \ if it refers to an SN sent\n   earlier).  In the FO state, it sends the smallest\
    \ packets that can\n   communicate the changes, according to W-LSB or other encoding\
    \ rules.\n   Those packets could be of type R-1*, UOR-2, or even IR-DYN.\n   The\
    \ compressor will transit to the SO state after it has determined\n   the presence\
    \ of a string (see section 2), while also being confident\n   that the decompressor\
    \ has the string parameters.  The confidence can\n   be based on ACKs.  For example,\
    \ in a typical case where the string\n   pattern has the form of non-SN-field\
    \ = SN * slope + offset, one ACK\n   is enough if the slope has been previously\
    \ established by the\n   decompressor (i.e., only the new offset needs to be synchronized).\n\
    \   Otherwise, two ACKs are required since the decompressor needs two\n   headers\
    \ to learn both the new slope and the new offset.  In the SO\n   state, R-0* packets\
    \ will be sent.\n   Note that a direct transition from the IR state to the SO\
    \ state is\n   possible.\n   The secure reference principle is enforced in both\
    \ compression and\n   decompression logic.  The principle means that only a packet\
    \ carrying\n   a 7- or 8-bit CRC can update the decompression context and be used\
    \ as\n   a reference for subsequent decompression.  Consequently, only field\n\
    \   values of update packets need to be added to the encoding sliding\n   windows\
    \ (see 4.5) maintained by the compressor.\n   Reasons for the compressor to send\
    \ update packets include:\n   1) The update may lead to a transition to higher\
    \ compression\n      efficiency (meaning either a higher compression state or\
    \ smaller\n      packets in the same state).\n   2) It is desirable to shrink\
    \ sliding windows.  Windows are only\n      shrunk when an ACK is received.\n\
    \      The generation of a CRC is infrequent since it is only needed for\n   \
    \   an update packet.\n   One algorithm for sending update packets could be:\n\
    \     * Let pRTT be the number of packets that are sent during one\n       round-trip\
    \ time.  In the SO state, when (64 - pRTT) headers have\n       been sent since\
    \ the last acked reference, the compressor will\n       send m1 consecutive R-0-CRC\
    \ headers, then send (pRTT - m1) R-0\n       headers.  After these headers have\
    \ been sent, if the compressor\n       has not received an ACK to at least one\
    \ of the previously sent\n       R0-CRC, it sends R-0-CRC headers continuously\
    \ until it receives a\n       corresponding ACK.  m1 is an implementation parameter,\
    \ which can\n       be as large as pRTT.\n     * In the FO state, m2 UOR-2 headers\
    \ are sent when there is a\n       pattern change, after which the compressor\
    \ sends (pRTT - m2)\n       R-1-* headers.  m2 is an implementation parameter,\
    \ which can be\n       as large as pRTT.  At that time, if the compressor has\
    \ not\n       received enough ACKs to the previously sent UOR-2 packets in\n \
    \      order to transit to SO state, it can repeat the cycle with the\n      \
    \ same m2, or repeat the cycle with a larger m2, or send UOR-2\n       headers\
    \ continuously (m2 = pRTT).  The operation stops when the\n       compressor has\
    \ received enough ACKs to make the transition.\n   An algorithm for processing\
    \ ACKs could be:\n     * Upon reception of an ACK, the compressor first derives\
    \ the\n       complete SN (see section 5.7.6.1).  Then it searches the sliding\n\
    \       window for an update packet that has the same SN.  If found, that\n  \
    \     packet is the one being ACKed.  Otherwise, the ACK is invalid and\n    \
    \   MUST be discarded.\n     * It is possible, although unlikely, that residual\
    \ errors on the\n       reverse channel could cause a packet to mimic a valid\
    \ ACK\n       feedback.  The compressor may use a local clock to reduce the\n\
    \       probability of processing such a mistaken ACK.  After finding the\n  \
    \     update packet as described above, the compressor can check the\n       time\
    \ elapsed since the packet was sent.  If the time is longer\n       than RTT_U,\
    \ or shorter than RTT_L, the compressor may choose to\n       discard the ACK.\
    \  RTT_U and RTT_L correspond to an upper bound\n       and lower bound of the\
    \ RTT, respectively.  (These bounds should\n       be chosen appropriately to\
    \ allow some variation of RTT.)  Note\n       that the only side effect of discarding\
    \ a good ACK is slightly\n       reduced compression efficiency.\n"
- title: 5.5.2.  Decompressor states and logic (R-mode)
  contents:
  - "5.5.2.  Decompressor states and logic (R-mode)\n   The decompression states and\
    \ the state transition logic are the same\n   as for the Unidirectional case (see\
    \ section 5.3.2).  What differs is\n   the decompression and feedback logic.\n"
- title: 5.5.2.1.  Decompression logic (R-mode)
  contents:
  - "5.5.2.1.  Decompression logic (R-mode)\n   The rules for when decompression is\
    \ allowed are the same as for U-\n   mode.  Although the acking scheme in R-mode\
    \ guarantees that non-\n   decompressible packets are never sent by the compressor,\
    \ residual\n   errors can cause delivery of unexpected packets for which\n   decompression\
    \ should not be attempted.\n   Decompression MUST follow the secure reference\
    \ principle as described\n   in 5.5.1.2.\n   CRC verification is infrequent since\
    \ only update packets carry CRCs.\n   A CRC mismatch can only occur due to 1)\
    \ residual bit errors in the\n   current header, and/or 2) a damaged context due\
    \ to residual bit\n   errors in previous headers or feedback.  Although it is\
    \ impossible to\n   determine which is the actual cause, case 1 is more likely,\
    \ as a\n   previous header reconstructed according to a damaged packet is\n  \
    \ unlikely to pass the 7- or 8-bit CRC, and damaged packets are\n   unlikely to\
    \ result in feedback that damages the context.  The\n   decompressor SHOULD act\
    \ according to section 5.3.2.2.3 when CRCs\n   fail, except that no local repair\
    \ is performed.  Note that all the\n   parameter numbers, k_1, n_1, k_2, and n_2,\
    \ are applied to the update\n   packets only (i.e., exclude R-0, R-1*).\n"
- title: 5.5.2.2.  Feedback logic (R-mode)
  contents:
  - "5.5.2.2.  Feedback logic (R-mode)\n   The feedback logic for the Bidirectional\
    \ Reliable mode is as follows:\n   - When an updating packet (i.e., a packet carrying\
    \ a 7- or 8-bit CRC)\n     is correctly decompressed, send an ACK(R), subject\
    \ to the sparse\n     ACK mechanism described below.\n   - When context damage\
    \ is detected, send a NACK(R) if in Full Context\n     state, or a STATIC-NACK(R)\
    \ if in Static Context state.\n   - In No Context state, send a STATIC-NACK(R)\
    \ when receiving a non-IR\n     packet, subject to the considerations at the beginning\
    \ of section\n     5.7.6.  The decompressor SHOULD NOT send STATIC-NACK(R) when\n\
    \     receiving an IR packet that fails the CRC check, as the compressor\n   \
    \  will stay in IR state and thus continue sending IR packets until a\n     valid\
    \ ACK is received (see section 5.5.1.2).\n   - Feedback is never sent for packets\
    \ not updating the context (i.e.,\n     packets that do not carry a CRC)\n   A\
    \ mechanism called \"Sparse ACK\" can be applied to reduce the feedback\n   overhead\
    \ caused by a large RTT.  For a sequence of ACK-triggering\n   events, a minimal\
    \ set of ACKs MUST be sent:\n   1) For a sequence of R-0-CRC packets, the first\
    \ one MUST be ACKed.\n   2) For a sequence of UOR-2, IR, or IR-DYN packets, the\
    \ first N of\n      them MUST be ACKEd, where N is the number of ACKs needed to\
    \ give\n      the compressor confidence that the decompressor has acquired the\n\
    \      new string parameters (see second paragraph of 5.5.1.2).  In case\n   \
    \   the decompressor cannot determine the value of N, the default\n      value\
    \ 2 SHOULD be used.  If the subsequently received packets\n      continue the\
    \ same change pattern of header fields, sparse ACK can\n      be applied.  Otherwise,\
    \ each new pattern MUST be treated as a new\n      sequence, i.e., the first N\
    \ packets that exhibit a new pattern\n      MUST be ACKed.\n   After sending these\
    \ minimal ACKs, the decompressor MAY choose to ACK\n   only k subsequent packets\
    \ per RTT (\"Sparse ACKs\"), where k is an\n   implementation parameter.  To achieve\
    \ robustness against loss of\n   ACKs, k SHOULD be at least 1.\n   To avoid ambiguity\
    \ at the compressor, the decompressor MUST use the\n   feedback format whose SN\
    \ field length is equal to or larger than the\n   one in the compressed packet\
    \ that triggered the feedback.\n   Context damage is detected according to the\
    \ principles in 5.3.2.2.3.\n   When the decompressor is capable of timer-based\
    \ compression of the\n   RTP Timestamp (e.g., it has access to a clock with sufficient\n\
    \   resolution, and the jitter introduced internally in the receiving\n   node\
    \ is sufficiently small) it SHOULD signal that it is ready to do\n   timer-based\
    \ compression of the RTP Timestamp.  The compressor will\n   then make a decision\
    \ based on its knowledge of the channel and the\n   observed properties of the\
    \ packet stream.\n"
- title: 5.6.  Mode transitions
  contents:
  - "5.6.  Mode transitions\n   The decision to move from one compression mode to\
    \ another is taken by\n   the decompressor and the possible mode transitions are\
    \ shown in the\n   figure below.  Subsequent chapters describe how the transitions\
    \ are\n   performed together with exceptions for the compression and\n   decompression\
    \ functionality during transitions.\n                      +-------------------------+\n\
    \                      | Unidirectional (U) mode |\n                      +-------------------------+\n\
    \                        / ^                 \\ ^\n                       / /\
    \ Feedback(U)       \\ \\ Feedback(U)\n                      / /             \
    \        \\ \\\n                     / /                       \\ \\\n       \
    \ Feedback(O) / /             Feedback(R) \\ \\\n                   v /      \
    \                     v \\\n   +---------------------+    Feedback(R)    +-------------------+\n\
    \   | Optimistic (O) mode | ----------------> | Reliable (R) mode |\n   |    \
    \                 | <---------------- |                   |\n   +---------------------+\
    \    Feedback(O)    +-------------------+\n"
- title: 5.6.1.  Compression and decompression during mode transitions
  contents:
  - "5.6.1.  Compression and decompression during mode transitions\n   The following\
    \ sections assume that, for each context, the compressor\n   and decompressor\
    \ maintain a variable whose value is the current\n   compression mode for that\
    \ context.  The value of the variable\n   controls, for the context in question,\
    \ which packet types to use,\n   which actions to be taken, etc.\n   As a safeguard\
    \ against residual errors, all feedback sent during a\n   mode transition MUST\
    \ be protected by a CRC, i.e., the CRC option MUST\n   be used.  A mode transition\
    \ MUST NOT be initiated by feedback which\n   is not protected by a CRC.\n   The\
    \ subsequent subsections define exactly when to change the value of\n   the MODE\
    \ variable.  When ROHC transits between compression modes,\n   there are several\
    \ cases where the behavior of compressor or\n   decompressor must be restricted\
    \ during the transition phase.  These\n   restrictions are defined by exception\
    \ parameters that specify which\n   restrictions to apply.  The transition descriptions\
    \ in subsequent\n   chapters refer to these exception parameters and defines when\
    \ they\n   are set and to what values.  All mode related parameters are listed\n\
    \   below together with their possible values, with explanations and\n   restrictions:\n\
    \   Parameters for the compressor side:\n      - C_MODE:\n         Possible values\
    \ for the C_MODE parameter are (U)NIDIRECTIONAL,\n         (O)PTIMISTIC and (R)ELIABLE.\
    \  C_MODE MUST be initialized to U.\n      - C_TRANS:\n         Possible values\
    \ for the C_TRANS parameter are (P)ENDING and\n         (D)ONE.  C_TRANS MUST\
    \ be initialized to D.  When C_TRANS is P,\n         it is REQUIRED\n        \
    \ 1) that the compressor only use packet formats common to all\n            modes,\n\
    \         2) that mode information is included in packets sent, at least\n   \
    \         periodically,\n         3) that the compressor not transit to the SO\
    \ state,\n         4) that new mode transition requests be ignored.\n   Parameters\
    \ for the decompressor side:\n      - D_MODE:\n         Possible values for the\
    \ D_MODE parameter are (U)NIDIRECTIONAL,\n         (O)PTIMISTIC and (R)ELIABLE.\
    \  D_MODE MUST be initialized to U.\n      - D_TRANS:\n         Possible values\
    \ for the D_TRANS parameter are (I)NITIATED,\n         (P)ENDING and (D)ONE. \
    \ D_TRANS MUST be initialized to D.  A\n         mode transition can be initiated\
    \ only when D_TRANS is D.  While\n         D_TRANS is I, the decompressor sends\
    \ a NACK or ACK carrying a\n         CRC option for each received packet.\n"
- title: 5.6.2.  Transition from Unidirectional to Optimistic mode
  contents:
  - "5.6.2.  Transition from Unidirectional to Optimistic mode\n   When there is a\
    \ feedback channel available, the decompressor may at\n   any moment decide to\
    \ initiate transition from Unidirectional to\n   Bidirectional Optimistic mode.\
    \  Any feedback packet carrying a CRC\n   can be used with the mode parameter\
    \ set to O.  The decompressor can\n   then directly start working in Optimistic\
    \ mode.  The compressor\n   transits from Unidirectional to Optimistic mode as\
    \ soon as it\n   receives any feedback packet that has the mode parameter set\
    \ to O and\n   that passes the CRC check.  The transition procedure is described\n\
    \   below:\n              Compressor                     Decompressor\n      \
    \       ----------------------------------------------\n                   | \
    \                              |\n                   |        ACK(O)/NACK(O) +-<-<-<-|\
    \  D_MODE = O\n                   |       +-<-<-<-<-<-<-<-+       |\n   C_MODE\
    \ = O      |-<-<-<-+                       |\n                   |           \
    \                    |\n   If the feedback packet is lost, the compressor will\
    \ continue to work\n   in Unidirectional mode, but as soon as any feedback packet\
    \ reaches\n   the compressor it will transit to Optimistic mode.\n"
- title: 5.6.3.  From Optimistic to Reliable mode
  contents:
  - "5.6.3.  From Optimistic to Reliable mode\n   Transition from Optimistic to Reliable\
    \ mode is permitted only after\n   at least one packet has been correctly decompressed,\
    \ which means that\n   at least the static part of the context is established.\
    \  An ACK(R) or\n   a NACK(R) feedback packet carrying a CRC is sent to initiate\
    \ the mode\n   transition.  The compressor MUST NOT use packet types 0 or 1 during\n\
    \   transition.  The transition procedure is described below:\n              Compressor\
    \                     Decompressor\n             ----------------------------------------------\n\
    \                   |                               |\n                   |  \
    \      ACK(R)/NACK(R) +-<-<-<-|  D_TRANS = I\n                   |       +-<-<-<-<-<-<-<-+\
    \       |\n   C_TRANS = P     |-<-<-<-+                       |\n   C_MODE = R\
    \      |                               |\n                   |->->->-+ IR/IR-DYN/UOR-2(SN,R)\
    \ |\n                   |       +->->->->->->->-+       |\n                  \
    \ |->-..                  +->->->-|  D_TRANS = P\n                   |->-..  \
    \                        |  D_MODE = R\n                   |           ACK(SN,R)\
    \   +-<-<-<-|\n                   |       +-<-<-<-<-<-<-<-+       |\n   C_TRANS\
    \ = D     |-<-<-<-+                       |\n                   |            \
    \                   |\n                   |->->->-+   R-0*, R-1*          |\n\
    \                   |       +->->->->->->->-+       |\n                   |  \
    \                     +->->->-|  D_TRANS = D\n                   |           \
    \                    |\n   As long as the decompressor has not received an UOR-2,\
    \ IR-DYN, or IR\n   packet with the mode transition parameter set to R, it must\
    \ stay in\n   Optimistic mode.  The compressor must not send packet types 1 or\
    \ 0\n   while C_TRANS is P, i.e., not until it has received an ACK for a\n   UOR-2,\
    \ IR-DYN, or IR packet sent with the mode transition parameter\n   set to R. \
    \ When the decompressor receives packet types 0 or 1, after\n   having ACKed an\
    \ UOR-2, IR-DYN, or IR packet, it sets D_TRANS to D.\n"
- title: 5.6.4.  From Unidirectional to Reliable mode
  contents:
  - "5.6.4.  From Unidirectional to Reliable mode\n   The transition from Unidirectional\
    \ to Reliable mode follows the same\n   transition procedure as defined in section\
    \ 5.6.3 above.\n"
- title: 5.6.5.  From Reliable to Optimistic mode
  contents:
  - "5.6.5.  From Reliable to Optimistic mode\n   Either the ACK(O) or the NACK(O)\
    \ feedback packet is used to initiate\n   the transition from Reliable to Optimistic\
    \ mode and the compressor\n   MUST always run in the FO state during transition.\
    \  The transition\n   procedure is described below:\n              Compressor\
    \                     Decompressor\n             ----------------------------------------------\n\
    \                   |                               |\n                   |  \
    \      ACK(O)/NACK(O) +-<-<-<-|  D_TRANS = I\n                   |       +-<-<-<-<-<-<-<-+\
    \       |\n   C_TRANS = P     |-<-<-<-+                       |\n   C_MODE = O\
    \      |                               |\n                   |->->->-+ IR/IR-DYN/UOR-2(SN,O)\
    \ |\n                   |       +->->->->->->->-+       |\n                  \
    \ |->-..                  +->->->-|  D_MODE = O\n                   |->-..   \
    \                       |\n                   |           ACK(SN,O)   +-<-<-<-|\n\
    \                   |       +-<-<-<-<-<-<-<-+       |\n   C_TRANS = D     |-<-<-<-+\
    \                       |\n                   |                              \
    \ |\n                   |->->->-+  UO-0, UO-1*          |\n                  \
    \ |       +->->->->->->->-+       |\n                   |                    \
    \   +->->->-|  D_TRANS = D\n                   |                             \
    \  |\n   As long as the decompressor has not received an UOR-2, IR-DYN, or IR\n\
    \   packet with the mode transition parameter set to O, it must stay in\n   Reliable\
    \ mode.  The compressor must not send packet types 0 or 1\n   while C_TRANS is\
    \ P, i.e., not until it has received an ACK for an\n   UOR-2, IR-DYN, or IR packet\
    \ sent with the mode transition parameter\n   set to O.  When the decompressor\
    \ receives packet types 0 or 1, after\n   having ACKed the UOR-2, IR-DYN, or IR\
    \ packet, it sets D_TRANS to D.\n"
- title: 5.6.6.  Transition to Unidirectional mode
  contents:
  - "5.6.6.  Transition to Unidirectional mode\n   The decompressor can force a transition\
    \ back to Unidirectional mode\n   if it desires to do so.  Regardless of which\
    \ mode this transition\n   starts from, a three-way handshake MUST be carried\
    \ out to ensure\n   correct transition on the compressor side.  The transition\
    \ procedure\n   is described below:\n              Compressor                \
    \     Decompressor\n             ----------------------------------------------\n\
    \               |                               |\n               |        ACK(U)/NACK(U)\
    \ +-<-<-<-| D_TRANS = I\n               |       +-<-<-<-<-<-<-<-+       |\n  \
    \ C_TRANS = P |-<-<-<-+                       |\n   C_MODE = U  |            \
    \                   |\n               |->->->-+ IR/IR-DYN/UOR-2(SN,U) |\n    \
    \           |       +->->->->->->->-+       |\n               |->-..         \
    \         +->->->-|\n               |->-..                          |\n      \
    \         |           ACK(SN,U)   +-<-<-<-|\n               |       +-<-<-<-<-<-<-<-+\
    \       |\n   C_TRANS = D |-<-<-<-+                       |\n               |\
    \                               |\n               |->->->-+  UO-0, UO-1*     \
    \     |\n               |       +->->->->->->->-+       |\n               |  \
    \                     +->->->-| D_TRANS = D, D_MODE= U\n   After ACKing the first\
    \ UOR-2(U), IR-DYN(U), or IR(U), the\n   decompressor MUST continue to send feedback\
    \ with the Mode parameter\n   set to U until it receives packet types 0 or 1.\n"
- title: 5.7.  Packet formats
  contents:
  - "5.7.  Packet formats\n   The following notation is used in this section:\n  \
    \    bits(X) = the number of bits for field X present in the compressed\n    \
    \            header (including extension).\n      field(X) = the value of field\
    \ X in the compressed header.\n      context(X) = the value of field X as established\
    \ in the context.\n      value(X) = field(X) if X is present in the compressed\
    \ header;\n               = context(X) otherwise.\n      hdr(X) = the value of\
    \ field X in the uncompressed or\n               decompressed header.\n      Updating\
    \ properties: Lists the fields in the context that are\n         directly updated\
    \ by processing the compressed header.  Note\n         that there may be dependent\
    \ fields that are implicitly also\n         updated (e.g., an update to context(SN)\
    \ often updates\n         context(TS) as well).  See also section 5.2.7.\n   The\
    \ following fields occur in several headers and extensions:\n   SN: The compressed\
    \ RTP Sequence Number.\n       Compressed with W-LSB.  The interpretation intervals,\
    \ see section\n       4.5.1, are defined as follows:\n            p = 1      \
    \             if bits(SN) <= 4\n            p = 2^(bits(SN)-5) - 1  if bits(SN)\
    \ >  4\n   IP-ID: A compressed IP-ID field.\n      IP-ID fields in compressed\
    \ base headers carry the compressed IP-ID\n      of the innermost IPv4 header\
    \ whose corresponding RND flag is not\n      1.  The rules below assume that the\
    \ IP-ID is for the innermost IP\n      header.  If it is for an outer IP header,\
    \ the RND2 and NBO2 flags\n      are used instead of RND and NBO.\n      If value(RND)\
    \ = 0, hdr(IP-ID) is compressed using Offset IP-ID\n      encoding (see section\
    \ 4.5.5) using p = 0 and default-slope(IP-ID\n      offset) = 0.\n      If value(RND)\
    \ = 1, IP-ID is the uncompressed hdr(IP-ID).  IP-ID is\n      then passed as additional\
    \ octets at the end of the compressed\n      header, after any extensions.\n \
    \     If value(NBO) = 0, the octets of hdr(IP-ID) are swapped before\n      compression\
    \ and after decompression.  The value of NBO is ignored\n      when value(RND)\
    \ = 1.\n   TS: The compressed RTP Timestamp value.\n      If value(TIME_STRIDE)\
    \ > 0, timer-based compression of the RTP\n      Timestamp is used (see section\
    \ 4.5.4).\n      If value(Tsc) = 1, Scaled RTP Timestamp encoding is used before\n\
    \      compression (see section 4.5.3), and default-slope(TS) = 1.\n      If value(Tsc)\
    \ = 0, the Timestamp value is compressed as-is, and\n      default-slope(TS) =\
    \ value(TS_STRIDE).\n      The interpretation intervals, see section 4.5.1, are\
    \ defined as\n      follows:\n         p = 2^(bits(TS)-2) - 1\n   CRC: The CRC\
    \ over the original, uncompressed, header.\n      For 3-bit CRCs, the polynomial\
    \ of section 5.9.2 is used.\n      For 7-bit CRCs, the polynomial of section 5.9.2\
    \ is used.\n      For 8-bit CRCs, the polynomial of section 5.9.1 is used.\n \
    \  M: RTP Marker bit.\n      Context(M) is initially zero and is never updated.\
    \  value(M) = 1\n      only when field(M) = 1.\n   The general format for a compressed\
    \ RTP header is as follows:\n     0   1   2   3   4   5   6   7\n    --- --- ---\
    \ --- --- --- --- ---\n   :         Add-CID octet         :  if for small CIDs\
    \ and CID 1-15\n   +---+---+---+---+---+---+---+---+\n   |   first octet of base\
    \ header  |  (with type indication)\n   +---+---+---+---+---+---+---+---+\n  \
    \ :                               :\n   /   0, 1, or 2 octets of CID    /  1-2\
    \ octets if large CIDs\n   :                               :\n   +---+---+---+---+---+---+---+---+\n\
    \   /   remainder of base header    /  variable number of bits\n   +---+---+---+---+---+---+---+---+\n\
    \   :                               :\n   /     Extension (see 5.7.5)     /  extension,\
    \ if X = 1 in base header\n   :                               :\n    --- --- ---\
    \ --- --- --- --- ---\n   :                               :\n   +   IP-ID of outer\
    \ IPv4 header  +  2 octets, if value(RND2) = 1\n   :                         \
    \      :\n    --- --- --- --- --- --- --- ---\n   /    AH data for outer list\
    \     /  variable (see 5.8.4.2)\n    --- --- --- --- --- --- --- ---\n   :   \
    \                            :\n   +   GRE checksum (see 5.8.4.4)  +  2 octets,\
    \ if GRE flag C = 1\n   :                               :\n    --- --- --- ---\
    \ --- --- --- ---\n   :                               :\n   +   IP-ID of inner\
    \ IPv4 header  +  2 octets, if value(RND) = 1\n   :                          \
    \     :\n    --- --- --- --- --- --- --- ---\n   /    AH data for inner list \
    \    /  variable (see 5.8.4.2)\n    --- --- --- --- --- --- --- ---\n   :    \
    \                           :\n   +   GRE checksum (see 5.8.4.4)  +  2 octets,\
    \ if GRE flag C = 1\n   :                               :\n    --- --- --- ---\
    \ --- --- --- ---\n   :                               :\n   +         UDP Checksum\
    \          +  2 octets,\n   :                               :  if context(UDP\
    \ Checksum) != 0\n    --- --- --- --- --- --- --- ---\n   Note that the order\
    \ of the fields following the optional extension is\n   the same as the order\
    \ between the fields in an uncompressed header.\n   In subsequent sections, the\
    \ position of the large CID in the diagrams\n   is indicated using this notation:\n\
    \   +===+===+===+===+===+===+===+===+\n   Whether the UDP Checksum field is present\
    \ or not is controlled by the\n   value of the UDP Checksum in the context.  If\
    \ nonzero, the UDP\n   Checksum is enabled and sent along with each packet.  If\
    \ zero, the\n   UDP Checksum is disabled and not sent.  Should hdr(UDP Checksum)\
    \ be\n   nonzero when context(UDP Checksum) is zero, the header cannot be\n  \
    \ compressed.  It must be sent uncompressed or the context\n   reinitialized using\
    \ an IR packet.  Context(UDP Checksum) is updated\n   only by IR or IR-DYN headers,\
    \ never by UDP checksums sent in headers\n   of type 2, 1, or 0.\n   When an IPv4\
    \ header is present in the static context, for which the\n   corresponding RND\
    \ flag has not been established to be 1, the packet\n   types R-1 and UO-1 MUST\
    \ NOT be used.\n   When no IPv4 header is present in the static context, or the\
    \ RND\n   flags for all IPv4 headers in the context have been established to be\n\
    \   1, the packet types R-1-ID, R-1-TS, UO-1-ID, and UO-1-TS MUST NOT be\n   used.\n\
    \   While in the transient state in which an RND flag is being\n   established,\
    \ the packet types R-1-ID, R-1-TS, UO-1-ID, and UO-1-TS\n   MUST NOT be used.\
    \  This implies that the RND flag(s) of the Extension\n   3 may have to be inspected\
    \ before the format of a base header\n   carrying an Extension 3 can be determined.\n"
- title: '5.7.1. Packet type 0: UO-0, R-0, R-0-CRC'
  contents:
  - "5.7.1. Packet type 0: UO-0, R-0, R-0-CRC\n   Packet type 0 is indicated by the\
    \ first bit being 0:\n   R-0\n     0   1   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n\
    \   | 0   0 |          SN           |\n   +===+===+===+===+===+===+===+===+\n\
    \      Updating properties: R-0 packets do not update any part of the\n      context.\n\
    \   R-0-CRC\n     0   1   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n\
    \   | 0   1 |          SN           |\n   +===+===+===+===+===+===+===+===+\n\
    \   |SN |            CRC            |\n   +---+---+---+---+---+---+---+---+\n\
    \      Note: The SN field straddles the CID field.\n      Updating properties:\
    \ R-0-CRC packets update context(RTP Sequence\n      Number).\n   UO-0\n     0\
    \   1   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n   | 0 |\
    \      SN       |    CRC    |\n   +===+===+===+===+===+===+===+===+\n      Updating\
    \ properties: UO-0 packets update the current value of\n      context(RTP Sequence\
    \ Number).\n"
- title: '5.7.2. Packet type 1 (R-mode): R-1, R-1-TS, R-1-ID'
  contents:
  - "5.7.2. Packet type 1 (R-mode): R-1, R-1-TS, R-1-ID\n   Packet type 1 is indicated\
    \ by the first bits being 10:\n   R-1\n     0   1   2   3   4   5   6   7\n  \
    \ +---+---+---+---+---+---+---+---+\n   | 1   0 |          SN           |\n  \
    \ +===+===+===+===+===+===+===+===+\n   | M | X |          TS           |\n  \
    \ +---+---+---+---+---+---+---+---+\n      Note: R-1 cannot be used if the context\
    \ contains at least one IPv4\n      header with value(RND) = 0.  This disambiguates\
    \ it from R-1-ID and\n      R-1-TS.\n   R-1-ID\n     0   1   2   3   4   5   6\
    \   7\n   +---+---+---+---+---+---+---+---+\n   | 1   0 |          SN        \
    \   |\n   +===+===+===+===+===+===+===+===+\n   | M | X |T=0|       IP-ID    \
    \   |\n   +---+---+---+---+---+---+---+---+\n      Note: R-1-ID cannot be used\
    \ if there is no IPv4 header in the\n      context or if value(RND) and value(RND2)\
    \ are both 1.\n   R-1-TS\n     0   1   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n\
    \   | 1   0 |          SN           |\n   +===+===+===+===+===+===+===+===+\n\
    \   | M | X |T=1|        TS         |\n   +---+---+---+---+---+---+---+---+\n\
    \      Note: R-1-TS cannot be used if there is no IPv4 header in the\n      context\
    \ or if value(RND) and value(RND2) are both 1.\n      X: X = 0 indicates that\
    \ no extension is present;\n         X = 1 indicates that an extension is present.\n\
    \      T: T = 0 indicates format R-1-ID;\n         T = 1 indicates format R-1-TS.\n\
    \      Updating properties: R-1* headers do not update any part of the\n     \
    \ context.\n"
- title: '5.7.3. Packet type 1 (U/O-mode): UO-1, UO-1-ID, UO-1-TS'
  contents:
  - "5.7.3. Packet type 1 (U/O-mode): UO-1, UO-1-ID, UO-1-TS\n   UO-1\n     0   1\
    \   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n   | 1   0 |\
    \          TS           |\n   +===+===+===+===+===+===+===+===+\n   | M |    \
    \  SN       |    CRC    |\n   +---+---+---+---+---+---+---+---+\n      Note: UO-1\
    \ cannot be used if the context contains at least one\n      IPv4 header with\
    \ value(RND) = 0.  This disambiguates it from UO-\n      1-ID and UO-1-TS.\n \
    \  UO-1-ID\n     0   1   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n\
    \   | 1   0 |T=0|       IP-ID       |\n   +===+===+===+===+===+===+===+===+\n\
    \   | X |      SN       |    CRC    |\n   +---+---+---+---+---+---+---+---+\n\
    \      Note: UO-1-ID cannot be used if there is no IPv4 header in the\n      context\
    \ or if value(RND) and value(RND2) are both 1.\n   UO-1-TS\n     0   1   2   3\
    \   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n   | 1   0 |T=1|    \
    \    TS         |\n   +===+===+===+===+===+===+===+===+\n   | M |      SN    \
    \   |    CRC    |\n   +---+---+---+---+---+---+---+---+\n      Note: UO-1-TS cannot\
    \ be used if there is no IPv4 header in the\n      context or if value(RND) and\
    \ value(RND2) are both 1.\n      X: X = 0 indicates that no extension is present;\n\
    \         X = 1 indicates that an extension is present.\n      T: T = 0 indicates\
    \ format UO-1-ID;\n         T = 1 indicates format UO-1-TS.\n      Updating properties:\
    \ UO-1* packets update context(RTP Sequence\n      Number).  UO-1 and UO-1-TS\
    \ packets update context(RTP Timestamp).\n      UO-1-ID packets update context(IP-ID).\
    \  Values provided in\n      extensions, except those in other SN, TS, or IP-ID\
    \ fields, do not\n      update the context.\n"
- title: '5.7.4. Packet type 2: UOR-2'
  contents:
  - "5.7.4. Packet type 2: UOR-2\n   Packet type 2 is indicated by the first bits\
    \ being 110:\n   UOR-2\n     0   1   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n\
    \   | 1   1   0 |        TS         |\n   +===+===+===+===+===+===+===+===+\n\
    \   |TS | M |          SN           |\n   +---+---+---+---+---+---+---+---+\n\
    \   | X |            CRC            |\n   +---+---+---+---+---+---+---+---+\n\
    \      Note: UOR-2 cannot be used if the context contains at least one\n     \
    \ IPv4 header with value(RND) = 0.  This disambiguates it from UOR-\n      2-ID\
    \ and UOR-2-TS.\n      Note: The TS field straddles the CID field.\n   UOR-2-ID\n\
    \     0   1   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n  \
    \ | 1   1   0 |       IP-ID       |\n   +===+===+===+===+===+===+===+===+\n  \
    \ |T=0| M |          SN           |\n   +---+---+---+---+---+---+---+---+\n  \
    \ | X |            CRC            |\n   +---+---+---+---+---+---+---+---+\n  \
    \    Note: UOR-2-ID cannot be used if there is no IPv4 header in the\n      context\
    \ or if value(RND) and value(RND2) are both 1.\n   UOR-2-TS\n     0   1   2  \
    \ 3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n   | 1   1   0 |  \
    \      TS         |\n   +===+===+===+===+===+===+===+===+\n   |T=1| M |      \
    \    SN           |\n   +---+---+---+---+---+---+---+---+\n   | X |          \
    \  CRC            |\n   +---+---+---+---+---+---+---+---+\n      Note: UOR-2-TS\
    \ cannot be used if there is no IPv4 header in the\n      context or if value(RND)\
    \ and value(RND2) are both 1.\n      X: X = 0 indicates that no extension is present;\n\
    \         X = 1 indicates that an extension is present.\n      T: T = 0 indicates\
    \ format UOR-2-ID;\n         T = 1 indicates format UOR-2-TS.\n      Updating\
    \ properties: All values provided in UOR-2* packets update\n      the context,\
    \ unless explicitly stated otherwise.\n"
- title: 5.7.5.  Extension formats
  contents:
  - "5.7.5.  Extension formats\n   (Note: the term extension as used for additional\
    \ information\n   contained in the ROHC headers does not bear any relationship\
    \ to the\n   term extension header used in IP.)\n   Fields in extensions are concatenated\
    \ with the corresponding field in\n   the base compressed header, if there is\
    \ one.  Bits in an extension\n   are less significant than bits in the base compressed\
    \ header (see\n   section 4.5.7).\n   The TS field is scaled in all extensions,\
    \ as it is in the base\n   header, except optionally when using Extension 3 where\
    \ the Tsc flag\n   can indicate that the TS field is not scaled.  Value(TS_STRIDE)\
    \ is\n   used as the scale factor when scaling the TS field.\n   In the following\
    \ three extensions, the interpretation of the fields\n   depends on whether there\
    \ is a T-bit in the base compressed header,\n   and if so, on the value of that\
    \ field.  When there is no T-bit, +T\n   and -T both mean TS.  This is the case\
    \ when there are no IPv4 headers\n   in the static context, and when all IPv4\
    \ headers in the static\n   context have their corresponding RND flag set (i.e.,\
    \ RND = 1).\n   If there is a T-bit,\n      T = 1 indicates that +T is TS, and\n\
    \                           -T is IP-ID;\n      T = 0 indicates that +T is IP-ID,\
    \ and\n                           -T is TS.\n   Extension 0:\n        0   1  \
    \ 2   3   4   5   6   7\n      +---+---+---+---+---+---+---+---+\n      | 0  \
    \ 0 |    SN     |    +T     |\n      +---+---+---+---+---+---+---+---+\n   Extension\
    \ 1:\n      +---+---+---+---+---+---+---+---+\n      | 0   1 |    SN     |   \
    \ +T     |\n      +---+---+---+---+---+---+---+---+\n      |              -T \
    \              |\n      +---+---+---+---+---+---+---+---+\n   Extension 2:\n \
    \     +---+---+---+---+---+---+---+---+\n      | 1   0 |    SN     |    +T   \
    \  |\n      +---+---+---+---+---+---+---+---+\n      |              +T       \
    \        |\n      +---+---+---+---+---+---+---+---+\n      |              -T \
    \              |\n      +---+---+---+---+---+---+---+---+\n   Extension 3 is a\
    \ more elaborate extension which can give values for\n   fields other than SN,\
    \ TS, and IP-ID.  Three optional flag octets\n   indicate changes to IP header(s)\
    \ and RTP header, respectively.\n   Extension 3:\n      0     1     2     3  \
    \   4     5     6     7\n   +-----+-----+-----+-----+-----+-----+-----+-----+\n\
    \   |  1     1  |  S  |R-TS | Tsc |  I  | ip  | rtp |            (FLAGS)\n   +-----+-----+-----+-----+-----+-----+-----+-----+\n\
    \   |            Inner IP header flags        | ip2 |  if ip = 1\n    ..... .....\
    \ ..... ..... ..... ..... ..... .....\n   |            Outer IP header flags \
    \             |  if ip2 = 1\n    ..... ..... ..... ..... ..... ..... ..... .....\n\
    \   |                      SN                       |  if S = 1\n    ..... .....\
    \ ..... ..... ..... ..... ..... .....\n   /       TS (encoded as in section 4.5.6)\
    \        /  1-4 octets,\n    ..... ..... ..... ..... ..... ..... ..... ..... \
    \  if R-TS = 1\n   |                                               |\n   /   \
    \         Inner IP header fields             /  variable,\n   |              \
    \                                 |  if ip = 1\n    ..... ..... ..... ..... .....\
    \ ..... ..... .....\n   |                     IP-ID                     |  2 octets,\
    \ if I = 1\n    ..... ..... ..... ..... ..... ..... ..... .....\n   |        \
    \                                       |\n   /            Outer IP header fields\
    \             /  variable,\n   |                                             \
    \  |  if ip2 = 1\n    ..... ..... ..... ..... ..... ..... ..... .....\n   |  \
    \                                             |\n   /          RTP header flags\
    \ and fields          /  variable,\n   |                                     \
    \          |  if rtp = 1\n    ..... ..... ..... ..... ..... ..... ..... .....\n\
    \      S, R-TS, I, ip, rtp, ip2: Indicate presence of fields as shown to\n   \
    \   the right of each field above.\n      Tsc: Tsc = 0 indicates that TS is not\
    \ scaled;\n           Tsc = 1 indicates that TS is scaled according to section\n\
    \           4.5.3, using value(TS_STRIDE).\n           Context(Tsc) is always\
    \ 1.  If scaling is not desired, the\n           compressor will establish TS_STRIDE\
    \ = 1.\n      SN: See the beginning of section 5.7.\n      TS: Variable number\
    \ of bits of TS, encoded according to\n          section 4.5.6.  See the beginning\
    \ of section 5.7.\n      IP-ID: See the beginning of section 5.7.\n   Inner IP\
    \ header flags\n      These correspond to the inner IP header if there are two,\
    \ and the\n      single IP header otherwise.\n      0     1     2     3     4\
    \     5     6     7\n    ..... ..... ..... ..... ..... ..... ..... .....\n   |\
    \ TOS | TTL | DF  | PR  | IPX | NBO | RND | ip2 |  if ip = 1\n    ..... .....\
    \ ..... ..... ..... ..... ..... .....\n      TOS, TTL, PR, IPX: Indicates presence\
    \ of fields as shown to the\n          right of the field in question below.\n\
    \      DF: Don't Fragment bit of IP header.\n      NBO: Indicates whether the\
    \ octets of hdr(IP identifier) of this IP\n      header are swapped before compression\
    \ and after decompression.\n      NBO = 1 indicates that the octets need not be\
    \ swapped.  NBO = 0\n      indicates that the octets are to be swapped.  See section\
    \ 4.5.5.\n      RND: Indicates whether hdr(IP identifier) is not to be compressed\n\
    \      but instead sent as-is in compressed headers.\n      IP2: Indicates presence\
    \ of Outer IP header fields.  Unless the\n      static context contains two IP\
    \ headers, IP2 is always zero.\n   Inner IP header fields\n    ..... ..... .....\
    \ ..... ..... ..... ..... .....\n   |         Type of Service/Traffic Class  \
    \       |  if TOS = 1\n    ..... ..... ..... ..... ..... ..... ..... .....\n \
    \  |         Time to Live/Hop Limit                |  if TTL = 1\n    ..... .....\
    \ ..... ..... ..... ..... ..... .....\n   |         Protocol/Next Header     \
    \             |  if PR = 1\n    ..... ..... ..... ..... ..... ..... ..... .....\n\
    \   /         IP extension headers                  /  variable,\n    ..... .....\
    \ ..... ..... ..... ..... ..... .....   if IPX = 1\n      Type of Service/Traffic\
    \ Class: That field in the uncompressed IP\n      header (absolute value).\n \
    \     Time to Live/Hop Limit: That field in the uncompressed IP header.\n    \
    \  Protocol/Next Header: That field in the uncompressed IP header.\n      IP extension\
    \ header(s): According to section 5.8.5.\n   Outer IP header flags\n      The\
    \ fields in this part of the Extension 3 header refer to the\n      outermost\
    \ IP header:\n         0     1     2     3     4     5     6     7\n       .....\
    \ ..... ..... ..... ..... ..... ..... .....  | TOS2| TTL2|\n      DF2 | PR2 |IPX2\
    \ |NBO2 |RND2 |  I2 |  if ip2 = 1\n       ..... ..... ..... ..... ..... .....\
    \ ..... .....\n      These flags are the same as the Inner IP header flags, but\
    \ refer\n      to the outer IP header instead of the inner IP header.  The\n \
    \     following flag, however, has no counterpart in the Inner IP header\n   \
    \   flags:\n         I2: Indicates presence of the IP-ID field.\n   Outer IP header\
    \ fields\n       ..... ..... ..... ..... ..... ..... ..... .....\n      |    \
    \  Type of Service/Traffic Class            |  if TOS2 = 1\n       ..... .....\
    \ ..... ..... ..... ..... ..... .....\n      |         Time to Live/Hop Limit\
    \                |  if TTL2 = 1\n       ..... ..... ..... ..... ..... ..... .....\
    \ .....\n      |         Protocol/Next Header                  |  if PR2 = 1\n\
    \       ..... ..... ..... ..... ..... ..... ..... .....\n      /         IP extension\
    \ header(s)                /  variable,\n       ..... ..... ..... ..... .....\
    \ ..... ..... .....    if IPX2 = 1\n      |                  IP-ID           \
    \             |  2 octets,\n       ..... ..... ..... ..... ..... ..... ..... .....\
    \    if I2 = 1\n      The fields in this part of Extension 3 are as for the Inner\
    \ IP\n      header fields, but they refer to the outer IP header instead of\n\
    \      the inner IP header.  The following field, however, has no\n      counterpart\
    \ among the Inner IP header fields:\n         IP-ID: The IP Identifier field of\
    \ the outer IP header, unless\n         the inner header is an IPv6 header, in\
    \ which case I2 is always\n         zero.\n   RTP header flags and fields\n  \
    \    0     1     2     3     4     5     6     7\n    ..... ..... ..... .....\
    \ ..... ..... ..... .....\n   |   Mode    |R-PT |  M  | R-X |CSRC | TSS | TIS\
    \ |  if rtp = 1\n    ..... ..... ..... ..... ..... ..... ..... .....\n   | R-P\
    \ |             RTP PT                      |  if R-PT = 1\n    ..... ..... .....\
    \ ..... ..... ..... ..... .....\n   /           Compressed CSRC list         \
    \       /  if CSRC = 1\n    ..... ..... ..... ..... ..... ..... ..... .....\n\
    \   /                  TS_STRIDE                    /  1-4 oct if TSS = 1\n  \
    \  ..... ..... ..... ..... ..... ..... ..... ....\n   /           TIME_STRIDE\
    \ (milliseconds)          /  1-4 oct if TIS = 1\n    ..... ..... ..... ..... .....\
    \ ..... ..... .....\n      Mode: Compression mode. 0 = Reserved,\n           \
    \                   1 = Unidirectional,\n                              2 = Bidirectional\
    \ Optimistic,\n                              3 = Bidirectional Reliable.\n   \
    \   R-PT, CSRC, TSS, TIS: Indicate presence of fields as shown to the\n      \
    \    right of each field above.\n      R-P: RTP Padding bit, absolute value (presumed\
    \ zero if absent).\n      R-X: RTP eXtension bit, absolute value.\n      M: See\
    \ the beginning of section 5.7.\n      RTP PT: Absolute value of RTP Payload type\
    \ field.\n      Compressed CSRC list: See section 5.8.1.\n      TS_STRIDE: Predicted\
    \ increment/decrement of the RTP Timestamp\n      field when it changes.  Encoded\
    \ as in section 4.5.6.\n      TIME_STRIDE: Predicted time interval in milliseconds\
    \ between\n      changes in the RTP Timestamp.  Also an indication that the\n\
    \      compressor desires to perform timer-based compression of the RTP\n    \
    \  Timestamp field: see section 4.5.4.  Encoded as in section 4.5.6.\n"
- title: 5.7.5.1.  RND flags and packet types
  contents:
  - "5.7.5.1.  RND flags and packet types\n   The values of the RND and RND2 flags\
    \ are changed by sending UOR-2\n   headers with Extension 3, or IR-DYN headers,\
    \ where the flag(s) have\n   their new values.  The establishment procedure of\
    \ the flags is the\n   normal one for the current mode, i.e., in U-mode and O-mode\
    \ the\n   values are repeated several times to ensure that the decompressor\n\
    \   receives at least one.  In R-mode, the flags are sent until an\n   acknowledgment\
    \ for a packet with the new RND flag values is received.\n   The decompressor\
    \ updates the values of its RND and RND2 flags\n   whenever it receives an UOR-2\
    \ with Extension 3 carrying values for\n   RND or RND2, and the UOR-2 CRC verifies\
    \ successful decompression.\n   When an IPv4 header for which the corresponding\
    \ RND flag has not been\n   established to be 1 is present in the static context,\
    \ the packet\n   types R-1 and UO-1 MUST NOT be used.\n   When no IPv4 header\
    \ is present in the static context, or the RND\n   flags for all IPv4 headers\
    \ in the context have been established to be\n   1, the packet types R-1-ID, R-1-TS,\
    \ UO-1-ID, and UO-1-TS MUST NOT be\n   used.\n   While in the transient state\
    \ in which an RND flag is being\n   established, the packet types R-1-ID, R-1-TS,\
    \ UO-1-ID, and UO-1-TS\n   MUST NOT be used.  This implies that the RND flag(s)\
    \ of Extension 3\n   may have to be inspected before the exact format of a base\
    \ header\n   carrying an Extension 3 can be determined, i.e., whether a T-bit\
    \ is\n   present or not.\n"
- title: 5.7.5.2.  Flags/Fields in context
  contents:
  - "5.7.5.2.  Flags/Fields in context\n   Some flags and fields in Extension 3 need\
    \ to be maintained in the\n   context of the decompressor.  Their values are established\
    \ using the\n   mechanism appropriate to the compression mode, unless otherwise\n\
    \   indicated in the table below and in referred sections.\n   Flag/Field    \
    \  Initial value   Comment\n   ---------------------------------------------------------------------\n\
    \     Mode          Unidirectional  See section 5.6\n     NBO               1\
    \           See section 4.5.5\n     RND               0           See sections\
    \ 4.5.5, 5.7.5.1\n     NBO2              1           As NBO, but for outer header\n\
    \     RND2              0           As RND, but for outer header\n     TS_STRIDE\
    \         1           See section 4.5.3\n     TIME_STRIDE       0           See\
    \ section 4.5.4\n     Tsc               1           Tsc is always 1 in context;\n\
    \                                   can be 0 only when an Extension 3\n      \
    \                             is present. See the discussion of the\n        \
    \                           TS field in the beginning of section\n           \
    \                        5.7.\n"
- title: 5.7.6.  Feedback packets and formats
  contents:
  - "5.7.6.  Feedback packets and formats\n   When the round-trip time between compressor\
    \ and decompressor is\n   large, several packets can be in flight concurrently.\
    \  Therefore,\n   several packets may be received by the decompressor after feedback\n\
    \   has been sent and before the compressor has reacted to feedback.\n   Moreover,\
    \ decompression may fail due to residual errors in the\n   compressed header.\n\
    \   Therefore,\n   a) in O-mode, the decompressor SHOULD limit the rate at which\n\
    \      feedback on successful decompression is sent (if it is sent at\n      all);\n\
    \   b) when decompression fails, feedback SHOULD be sent only when\n      decompression\
    \ of several consecutive packets has failed, and when\n      this occurs, the\
    \ feedback rate SHOULD be limited;\n   c) when packets are received which belong\
    \ to a rejected packet\n      stream, the feedback rate SHOULD be limited.\n \
    \  A decompressor MAY limit the feedback rate by sending feedback only\n   for\
    \ one out of every k packets provoking the same (kind of) feedback.\n   The appropriate\
    \ value of k is implementation dependent; k might be\n   chosen such that feedback\
    \ is sent 1-3 times per link round-trip time.\n   See section 5.2.2 for a discussion\
    \ concerning ways to provide\n   feedback information to the compressor.\n"
- title: 5.7.6.1.  Feedback formats for ROHC RTP
  contents:
  - "5.7.6.1.  Feedback formats for ROHC RTP\n   This section describes the format\
    \ for feedback information in ROHC\n   RTP.  See also 5.2.2.\n   Several feedback\
    \ formats carry a field labeled SN.  The SN field\n   contains LSBs of an RTP\
    \ Sequence Number.  The sequence number to use\n   is the sequence number of the\
    \ header which caused the feedback\n   information to be sent.  If that sequence\
    \ number cannot be\n   determined, for example when decompression fails, the sequence\
    \ number\n   to use is that of the last successfully decompressed header.  If\
    \ no\n   sequence number is available, the feedback MUST carry a SN-NOT-VALID\n\
    \   option.  Upon reception, the compressor matches valid SN LSBs with\n   the\
    \ most recent header sent with a SN with matching LSBs.  The\n   decompressor\
    \ must ensure that it sends enough SN LSBs in its feedback\n   that this correlation\
    \ does not become ambiguous; e.g., if an 8-bit SN\n   LSB field could wrap around\
    \ within a round-trip time, the FEEDBACK-1\n   format cannot be used.\n    FEEDBACK-1\n\
    \     0   1   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n  \
    \ |              SN               |\n   +---+---+---+---+---+---+---+---+\n  \
    \    A FEEDBACK-1 is an ACK.  In order to send a NACK or a STATIC-NACK,\n    \
    \  FEEDBACK-2 must be used.  FEEDBACK-1 does not contain any mode\n      information;\
    \ FEEDBACK-2 must be used when mode information is\n      required.\n   FEEDBACK-2\n\
    \     0   1   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n  \
    \ |Acktype| Mode  |      SN       |\n   +---+---+---+---+---+---+---+---+\n  \
    \ |              SN               |\n   +---+---+---+---+---+---+---+---+\n  \
    \ /       Feedback options        /\n   +---+---+---+---+---+---+---+---+\n  \
    \    Acktype:  0 = ACK\n                1 = NACK\n                2 = STATIC-NACK\n\
    \                3 is reserved (MUST NOT be used for parseability)\n      Mode:\
    \     0 is reserved\n                1 = Unidirectional mode\n               \
    \ 2 = Bidirectional Optimistic mode\n                3 = Bidirectional Reliable\
    \ mode\n      Feedback options: A variable number of feedback options, see\n \
    \        section 5.7.6.2.  Options may appear in any order.\n"
- title: 5.7.6.2.  ROHC RTP Feedback options
  contents:
  - "5.7.6.2.  ROHC RTP Feedback options\n   A ROHC RTP Feedback option has variable\
    \ length and the following\n   general format:\n     0   1   2   3   4   5   6\
    \   7\n   +---+---+---+---+---+---+---+---+\n   |   Opt Type    |    Opt Len \
    \   |\n   +---+---+---+---+---+---+---+---+\n   /          option data       \
    \   /  Opt Len octets\n   +---+---+---+---+---+---+---+---+\n   Sections 5.7.6.3-9\
    \ describe the currently defined ROHC RTP feedback\n   options.\n"
- title: 5.7.6.3.  The CRC option
  contents:
  - "5.7.6.3.  The CRC option\n   The CRC option contains an 8-bit CRC computed over\
    \ the entire\n   feedback payload, without the packet type and code octet, but\n\
    \   including any CID fields, using the polynomial of section 5.9.1.  If\n   the\
    \ CID is given with an Add-CID octet, the Add-CID octet immediately\n   precedes\
    \ the FEEDBACK-1 or FEEDBACK-2 format.  For purposes of\n   computing the CRC,\
    \ the CRC fields of all CRC options are zero.\n     0   1   2   3   4   5   6\
    \   7\n   +---+---+---+---+---+---+---+---+\n   |  Opt Type = 1 |  Opt Len = 1\
    \  |\n   +---+---+---+---+---+---+---+---+\n   |              CRC            \
    \  |\n   +---+---+---+---+---+---+---+---+\n   When receiving feedback information\
    \ with a CRC option, the compressor\n   MUST verify the information by computing\
    \ the CRC and comparing the\n   result with the CRC carried in the CRC option.\
    \  If the two are not\n   identical, the feedback information MUST be ignored.\n"
- title: 5.7.6.4.  The REJECT option
  contents:
  - "5.7.6.4.  The REJECT option\n   The REJECT option informs the compressor that\
    \ the decompressor does\n   not have sufficient resources to handle the flow.\n\
    \   +---+---+---+---+---+---+---+---+\n   |  Opt Type = 2 |  Opt Len = 0  |\n\
    \   +---+---+---+---+---+---+---+---+\n   When receiving a REJECT option, the\
    \ compressor stops compressing the\n   packet stream, and should refrain from\
    \ attempting to increase the\n   number of compressed packet streams for some\
    \ time.  Any FEEDBACK\n   packet carrying a REJECT option MUST also carry a CRC\
    \ option.\n"
- title: 5.7.6.5.  The SN-NOT-VALID option
  contents:
  - "5.7.6.5.  The SN-NOT-VALID option\n   The SN-NOT-VALID option indicates that\
    \ the SN of the feedback is not\n   valid.  A compressor MUST NOT use the SN of\
    \ the feedback to find the\n   corresponding sent header when this option is present.\n\
    \   +---+---+---+---+---+---+---+---+\n   |  Opt Type = 3 |  Opt Len = 0  |\n\
    \   +---+---+---+---+---+---+---+---+\n"
- title: 5.7.6.6.  The SN option
  contents:
  - "5.7.6.6.  The SN option\n   The SN option provides 8 additional bits of SN.\n\
    \   +---+---+---+---+---+---+---+---+\n   |  Opt Type = 4 |  Opt Len = 1  |\n\
    \   +---+---+---+---+---+---+---+---+\n   |              SN               |\n\
    \   +---+---+---+---+---+---+---+---+\n"
- title: 5.7.6.7.  The CLOCK option
  contents:
  - "5.7.6.7.  The CLOCK option\n   The CLOCK option informs the compressor of the\
    \ clock resolution of\n   the decompressor.  This is needed to allow the compressor\
    \ to estimate\n   the jitter introduced by the clock of the decompressor when\
    \ doing\n   timer-based compression of the RTP Timestamp.\n   +---+---+---+---+---+---+---+---+\n\
    \   |  Opt Type = 5 |  Opt Len = 1  |\n   +---+---+---+---+---+---+---+---+\n\
    \   |     clock resolution (ms)     |\n   +---+---+---+---+---+---+---+---+\n\
    \   The smallest clock resolution which can be indicated is 1\n   millisecond.\
    \  The value zero has a special meaning: it indicates that\n   the decompressor\
    \ cannot do timer-based compression of the RTP\n   Timestamp.  Any FEEDBACK packet\
    \ carrying a CLOCK option SHOULD also\n   carry a CRC option.\n"
- title: 5.7.6.8.  The JITTER option
  contents:
  - "5.7.6.8.  The JITTER option\n   The JITTER option allows the decompressor to\
    \ report the maximum\n   jitter it has observed lately, using the following formula\
    \ which is\n   very similar to the formula for Max_Jitter_BC in section 4.5.4.\n\
    \   Let observation window i contain the decompressor's best\n   approximation\
    \ of the sliding window of the compressor (see section\n   4.5.4) when header\
    \ i is received.\n      Max_Jitter_i =\n            max {|(T_i - T_j) - ((a_i\
    \ - a_j) / TIME_STRIDE)|,\n                for all headers j in observation window\
    \ i}\n      Max_Jitter =\n            max { Max_Jitter_i, for a large number of\
    \ recent headers i }\n   This information may be used by the compressor to refine\
    \ the formula\n   for determining k when doing timer-based compression of the\
    \ RTP\n   Timestamp.\n   +---+---+---+---+---+---+---+---+\n   |  Opt Type = 6\
    \ |  Opt Len = 1  |\n   +---+---+---+---+---+---+---+---+\n   |          Max_Jitter\
    \           |\n   +---+---+---+---+---+---+---+---+\n   The decompressor MAY ignore\
    \ the oldest observed values of\n   Max_Jitter_i.  Thus, the reported Max_Jitter\
    \ may decrease.\n   Robustness will be reduced if the compressor uses a jitter\
    \ estimate\n   which is too small.  Therefore, a FEEDBACK packet carrying a JITTER\n\
    \   option SHOULD also carry a CRC option.  Moreover, the compressor MAY\n   ignore\
    \ decreasing Max_Jitter values.\n"
- title: 5.7.6.9.  The LOSS option
  contents:
  - "5.7.6.9.  The LOSS option\n   The LOSS option allows the decompressor to report\
    \ the largest\n   observed number of packets lost in sequence.  This information\
    \ MAY be\n   used by the compressor to adjust the size of the reference window\n\
    \   used in U- and O-mode.\n   +---+---+---+---+---+---+---+---+\n   |  Opt Type\
    \ = 7 |  Opt Len = 1  |\n   +---+---+---+---+---+---+---+---+\n   | longest loss\
    \ event (packets)  |\n   +---+---+---+---+---+---+---+---+\n   The decompressor\
    \ MAY choose to ignore the oldest loss events.  Thus,\n   the value reported may\
    \ decrease.  Since setting the reference window\n   too small can reduce robustness,\
    \ a FEEDBACK packet carrying a LOSS\n   option SHOULD also carry a CRC option.\
    \  The compressor MAY choose to\n   ignore decreasing loss values.\n"
- title: 5.7.6.10.  Unknown option types
  contents:
  - "5.7.6.10.  Unknown option types\n   If an option type unknown to the compressor\
    \ is encountered, it must\n   continue parsing the rest of the FEEDBACK packet,\
    \ which is possible\n   since the length of the option is explicit, but MUST otherwise\
    \ ignore\n   the unknown option.\n"
- title: 5.7.6.11.  RTP feedback example
  contents:
  - "5.7.6.11.  RTP feedback example\n   Feedback for CID 8 indicating an ACK for\
    \ SN 17 and Bidirectional\n   Reliable mode can have the following formats.\n\
    \   Assuming small CIDs:\n     0   1   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n\
    \   | 1   1   1   1   0 | 0   1   1 |  feedback packet type, Code = 3\n   +---+---+---+---+---+---+---+---+\n\
    \   | 1   1   1   0 | 1   0   0   0 |  Add-CID octet with CID = 8\n   +---+---+---+---+---+---+---+---+\n\
    \   | 0   0 | 1   1 |  SN MSB = 0   |  AckType = ACK, Mode = Reliable\n   +---+---+---+---+---+---+---+---+\n\
    \   |          SN LSB = 17          |\n   +---+---+---+---+---+---+---+---+\n\
    \      The second, third, and fourth octet are handed to the compressor.\n   The\
    \ FEEDBACK-1 format may also be used.  Assuming large CIDs:\n     0   1   2  \
    \ 3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n   | 1   1   1   1\
    \   0 | 0   1   0 |  feedback packet type, Code = 2\n   +---+---+---+---+---+---+---+---+\n\
    \   | 0   0   0   0   1   0   0   0 |  large CID with value 8\n   +---+---+---+---+---+---+---+---+\n\
    \   |          SN LSB = 17          |\n   +---+---+---+---+---+---+---+---+\n\
    \      The second and third octet are handed to the compressor.\n   Assuming small\
    \ CIDs:\n     0   1   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n\
    \   | 1   1   1   1   0 | 0   1   0 |  feedback packet type, Code = 2\n   +---+---+---+---+---+---+---+---+\n\
    \   | 1   1   1   0 | 1   0   0   0 |  Add-CID octet with CID = 8\n   +---+---+---+---+---+---+---+---+\n\
    \   |          SN LSB = 17          |\n   +---+---+---+---+---+---+---+---+\n\
    \      The second and third octet are handed to the compressor.\n   Assuming small\
    \ CIDs and CID 0 instead of CID 8:\n     0   1   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n\
    \   | 1   1   1   1   0 | 0   0   1 |  feedback packet type, Code = 1\n   +---+---+---+---+---+---+---+---+\n\
    \   |          SN LSB = 17          |\n   +---+---+---+---+---+---+---+---+\n\
    \      The second octet is handed to the compressor.\n"
- title: 5.7.7.  RTP IR and IR-DYN packets
  contents:
  - "5.7.7.  RTP IR and IR-DYN packets\n   The subheaders which are compressible are\
    \ split into a STATIC part\n   and a DYNAMIC part.  These parts are defined in\
    \ sections 5.7.7.3\n   through 5.7.7.7.\n   The structure of a chain of subheaders\
    \ is determined by each header\n   having a Next Header, or Protocol, field. \
    \ This field identifies the\n   type of the following header.  Each Static part\
    \ below that is\n   followed by another Static part contains the Next Header/Protocol\n\
    \   field and allows parsing of the Static chain; the Dynamic chain, if\n   present,\
    \ is structured analogously.\n   IR and IR-DYN packets will cause a packet to\
    \ be delivered to upper\n   layers if and only if the payload is non-empty.  This\
    \ means that an\n   IP/UDP/RTP packet where the UDP length indicates a UDP payload\
    \ of\n   size 12 octets cannot be represented by an IR or IR-DYN packet.  Such\n\
    \   packets can instead be represented using the UNCOMPRESSED profile\n   (section\
    \ 5.10).\n"
- title: 5.7.7.1.  Basic structure of the IR packet
  contents:
  - "5.7.7.1.  Basic structure of the IR packet\n   This packet type communicates\
    \ the static part of the context, i.e.,\n   the values of the constant SN functions.\
    \  It can optionally also\n   communicate the dynamic part of the context, i.e.,\
    \ the parameters of\n   nonconstant SN functions.  It can also optionally communicate\
    \ the\n   payload of an original packet, if any.\n     0   1   2   3   4   5 \
    \  6   7\n    --- --- --- --- --- --- --- ---\n   |         Add-CID octet    \
    \     |  if for small CIDs and CID != 0\n   +---+---+---+---+---+---+---+---+\n\
    \   | 1   1   1   1   1   1   0 | D |\n   +---+---+---+---+---+---+---+---+\n\
    \   |                               |\n   /    0-2 octets of CID info     /  1-2\
    \ octets if for large CIDs\n   |                               |\n   +---+---+---+---+---+---+---+---+\n\
    \   |            Profile            |  1 octet\n   +---+---+---+---+---+---+---+---+\n\
    \   |              CRC              |  1 octet\n   +---+---+---+---+---+---+---+---+\n\
    \   |                               |\n   |         Static chain          |  variable\
    \ length\n   |                               |\n   +---+---+---+---+---+---+---+---+\n\
    \   |                               |\n   |         Dynamic chain         |  present\
    \ if D = 1, variable length\n   |                               |\n    - - - -\
    \ - - - - - - - - - - - -\n   |                               |\n   |        \
    \   Payload             |  variable length\n   |                             \
    \  |\n    - - - - - - - - - - - - - - - -\n      D:   D = 1 indicates that the\
    \ dynamic chain is present.\n      Profile: Profile identifier, abbreviated as\
    \ defined in section\n          5.2.3.\n      CRC: 8-bit CRC, computed according\
    \ to section 5.9.1.\n      Static chain: A chain of static subheader information.\n\
    \      Dynamic chain: A chain of dynamic subheader information.  What\n      \
    \    dynamic information is present is inferred from the Static\n          chain.\n\
    \      Payload: The payload of the corresponding original packet, if any.\n  \
    \        The presence of a payload is inferred from the packet length.\n"
- title: 5.7.7.2.  Basic structure of the IR-DYN packet
  contents:
  - "5.7.7.2.  Basic structure of the IR-DYN packet\n   This packet type communicates\
    \ the dynamic part of the context, i.e.,\n   the parameters of nonconstant SN\
    \ functions.\n     0   1   2   3   4   5   6   7\n    --- --- --- --- --- ---\
    \ --- ---\n   :         Add-CID octet         : if for small CIDs and CID != 0\n\
    \   +---+---+---+---+---+---+---+---+\n   | 1   1   1   1   1   0   0   0 | IR-DYN\
    \ packet type\n   +---+---+---+---+---+---+---+---+\n   :                    \
    \           :\n   /     0-2 octets of CID info    / 1-2 octets if for large CIDs\n\
    \   :                               :\n   +---+---+---+---+---+---+---+---+\n\
    \   |            Profile            | 1 octet\n   +---+---+---+---+---+---+---+---+\n\
    \   |              CRC              | 1 octet\n   +---+---+---+---+---+---+---+---+\n\
    \   |                               |\n   /         Dynamic chain         / variable\
    \ length\n   |                               |\n   +---+---+---+---+---+---+---+---+\n\
    \   :                               :\n   /           Payload             / variable\
    \ length\n   :                               :\n    - - - - - - - - - - - - -\
    \ - - -\n   Profile: Profile identifier, abbreviated as defined in section 5.2.3.\n\
    \      CRC: 8-bit CRC, computed according to section 5.9.1.\n         NOTE: As\
    \ the CRC checks only the integrity of the header\n         itself, an acknowledgment\
    \ of this header does not signify that\n         previous changes to the static\
    \ chain in the context are also\n         acknowledged.  In particular, care should\
    \ be taken when IR\n         packets that update an existing context are followed\
    \ by IR-DYN\n         packets.\n   Dynamic chain: A chain of dynamic subheader\
    \ information.  What\n   dynamic information is present is inferred from the Static\
    \ chain of\n   the context.\n   Payload: The payload of the corresponding original\
    \ packet, if any.\n   The presence of a payload is inferred from the packet length.\n\
    \   Note: The static and dynamic chains of IR or IR-DYN packets for\n   profile\
    \ 0x0001 (ROHC RTP) MUST end with the static and dynamic parts\n   of an RTP header.\
    \  If not, the packet MUST be discarded and the\n   context MUST NOT be updated.\n\
    \   Note: The static or dynamic chains of IR or IR-DYN packets for\n   profile\
    \ 0x0002 (ROHC UDP) MUST end with the static and dynamic parts\n   of a UDP header.\
    \  If not, the packet MUST be discarded and the\n   context MUST NOT be updated.\n\
    \   Note: The static or dynamic chains of IR or IR-DYN packets for\n   profile\
    \ 0x0003 (ROHC ESP) MUST end with the static and dynamic parts\n   of an ESP header.\
    \  If not, the packet MUST be discarded and the\n   context MUST NOT be updated.\n"
- title: 5.7.7.3.  Initialization of IPv6 Header [IPv6]
  contents:
  - "5.7.7.3.  Initialization of IPv6 Header [IPv6]\n   Static part:\n      +---+---+---+---+---+---+---+---+\n\
    \      |  Version = 6  |Flow Label(msb)|   1 octet\n      +---+---+---+---+---+---+---+---+\n\
    \      /        Flow Label (lsb)       /   2 octets\n      +---+---+---+---+---+---+---+---+\n\
    \      |          Next Header          |   1 octet\n      +---+---+---+---+---+---+---+---+\n\
    \      /        Source Address         /   16 octets\n      +---+---+---+---+---+---+---+---+\n\
    \      /      Destination Address      /   16 octets\n      +---+---+---+---+---+---+---+---+\n\
    \   Dynamic part:\n      +---+---+---+---+---+---+---+---+\n      |         Traffic\
    \ Class         |   1 octet\n      +---+---+---+---+---+---+---+---+\n      |\
    \           Hop Limit           |   1 octet\n      +---+---+---+---+---+---+---+---+\n\
    \      / Generic extension header list /   variable length\n      +---+---+---+---+---+---+---+---+\n\
    \   Eliminated:\n      Payload Length\n   Extras:\n      Generic extension header\
    \ list: Encoded according to section\n      5.8.6.1, with all header items present\
    \ in uncompressed form.\n   CRC-DYNAMIC: Payload Length field (octets 5-6).\n\
    \   CRC-STATIC: All other fields (octets 1-4, 7-40).\n   CRC coverage for extension\
    \ headers is defined in section 5.8.7.\n   Note: The Next Header field indicates\
    \ the type of the following\n   header in the static chain, rather than being\
    \ a copy of the Next\n   Header field of the original IPv6 header.  See also section\
    \ 5.7.7.8.\n"
- title: 5.7.7.4.  Initialization of IPv4 Header [IPv4, section 3.1].
  contents:
  - "5.7.7.4.  Initialization of IPv4 Header [IPv4, section 3.1].\n   Static part:\n\
    \      Version, Protocol, Source Address, Destination Address.\n   +---+---+---+---+---+---+---+---+\n\
    \   |  Version = 4  |       0       |\n   +---+---+---+---+---+---+---+---+\n\
    \   |           Protocol            |\n   +---+---+---+---+---+---+---+---+\n\
    \   /        Source Address         /   4 octets\n   +---+---+---+---+---+---+---+---+\n\
    \   /      Destination Address      /   4 octets\n   +---+---+---+---+---+---+---+---+\n\
    \   Dynamic part:\n      Type of Service, Time to Live, Identification, DF, RND,\
    \ NBO,\n      extension header list.\n   +---+---+---+---+---+---+---+---+\n \
    \  |        Type of Service        |\n   +---+---+---+---+---+---+---+---+\n \
    \  |         Time to Live          |\n   +---+---+---+---+---+---+---+---+\n \
    \  /        Identification         /   2 octets\n   +---+---+---+---+---+---+---+---+\n\
    \   | DF|RND|NBO|         0         |\n   +---+---+---+---+---+---+---+---+\n\
    \   / Generic extension header list /  variable length\n   +---+---+---+---+---+---+---+---+\n\
    \   Eliminated:\n      IHL               (IP Header Length, must be 5)\n     \
    \ Total Length      (inferred in decompressed packets)\n      MF flag        \
    \   (More Fragments flag, must be 0)\n      Fragment Offset   (must be 0)\n  \
    \    Header Checksum   (inferred in decompressed packets)\n      Options, Padding\
    \  (must not be present)\n      Extras:\n         RND, NBO           See section\
    \ 5.7.\n         Generic extension header list: Encoded according to section\n\
    \         5.8.6.1, with all header items present in uncompressed form.\n   CRC-DYNAMIC:\
    \ Total Length, Identification, Header Checksum\n                  (octets 3-4,\
    \ 5-6, 11-12).\n   CRC-STATIC: All other fields (octets 1-2, 7-10, 13-20)\n  \
    \ CRC coverage for extension headers is defined in section 5.8.7.\n   Note: The\
    \ Protocol field indicates the type of the following header\n   in the static\
    \ chain, rather than being a copy of the Protocol field\n   of the original IPv4\
    \ header.  See also section 5.7.7.8.\n"
- title: 5.7.7.5.  Initialization of UDP Header [RFC-768].
  contents:
  - "5.7.7.5.  Initialization of UDP Header [RFC-768].\n   Static part:\n      +---+---+---+---+---+---+---+---+\n\
    \      /          Source Port          /   2 octets\n      +---+---+---+---+---+---+---+---+\n\
    \      /       Destination Port        /   2 octets\n      +---+---+---+---+---+---+---+---+\n\
    \   Dynamic part:\n      +---+---+---+---+---+---+---+---+\n      /          \
    \ Checksum            /   2 octets\n      +---+---+---+---+---+---+---+---+\n\
    \   Eliminated:\n      Length\n      The Length field of the UDP header MUST match\
    \ the Length field(s)\n      of the preceding subheaders, i.e., there must not\
    \ be any padding\n      after the UDP payload that is covered by the IP Length.\n\
    \   CRC-DYNAMIC: Length field, Checksum (octets 5-8).\n   CRC-STATIC: All other\
    \ fields (octets 1-4).\n"
- title: 5.7.7.6.  Initialization of RTP Header [RTP].
  contents:
  - "5.7.7.6.  Initialization of RTP Header [RTP].\n   Static part:\n      SSRC.\n\
    \        0   1   2   3   4   5   6   7\n      +---+---+---+---+---+---+---+---+\n\
    \      /             SSRC              /   4 octets\n      +---+---+---+---+---+---+---+---+\n\
    \   Dynamic part:\n      P, X, CC, PT, M, sequence number, timestamp, timestamp\
    \ stride,\n      CSRC identifiers.\n        0   1   2   3   4   5   6   7\n  \
    \    +---+---+---+---+---+---+---+---+\n      |  V=2  | P | RX|      CC      \
    \ |  (RX is NOT the RTP X bit)\n      +---+---+---+---+---+---+---+---+\n    \
    \  | M |            PT             |\n      +---+---+---+---+---+---+---+---+\n\
    \      /      RTP Sequence Number      /  2 octets\n      +---+---+---+---+---+---+---+---+\n\
    \      /   RTP Timestamp (absolute)    /  4 octets\n      +---+---+---+---+---+---+---+---+\n\
    \      /      Generic CSRC list        /  variable length\n      +---+---+---+---+---+---+---+---+\n\
    \      : Reserved  | X |  Mode |TIS|TSS:  if RX = 1\n      +---+---+---+---+---+---+---+---+\n\
    \      :         TS_Stride             :  1-4 octets, if TSS = 1\n      +---+---+---+---+---+---+---+---+\n\
    \      :         Time_Stride           :  1-4 octets, if TIS = 1\n      +---+---+---+---+---+---+---+---+\n\
    \   Eliminated:\n      Nothing.\n   Extras:\n      RX: Controls presence of extension.\n\
    \      Mode: Compression mode. 0 = Reserved,\n                              1\
    \ = Unidirectional,\n                              2 = Bidirectional Optimistic,\n\
    \                              3 = Bidirectional Reliable.\n   X: Copy of X bit\
    \ from RTP header (presumed 0 if RX = 0)\n   Reserved: Set to zero when sending,\
    \ ignored when received.\n   Generic CSRC list: CSRC list encoded according to\
    \ section\n          5.8.6.1, with all CSRC items present.\n   CRC-DYNAMIC: Octets\
    \ containing M-bit, sequence number field,\n                and timestamp (octets\
    \ 2-8).\n   CRC-STATIC: All other fields (octets 1, 9-12, original CSRC list).\n"
- title: 5.7.7.7.  Initialization of ESP Header [ESP, section 2]
  contents:
  - "5.7.7.7.  Initialization of ESP Header [ESP, section 2]\n   This is for the case\
    \ when the NULL encryption algorithm [NULL] is NOT\n   being used with ESP, so\
    \ that subheaders after the ESP header are\n   encrypted (see 5.12).  See 5.8.4.3\
    \ for compression of the ESP header\n   when NULL encryption is being used.\n\
    \   Static part:\n     +---+---+---+---+---+---+---+---+\n     /             \
    \ SPI              /   4 octets\n     +---+---+---+---+---+---+---+---+\n   Dynamic\
    \ part:\n     +---+---+---+---+---+---+---+---+\n     /       Sequence Number\
    \         /   4 octets\n     +---+---+---+---+---+---+---+---+\n   Eliminated:\n\
    \      Other fields are encrypted, and can neither be located nor\n      compressed.\n\
    \   CRC-DYNAMIC: Sequence number (octets 5-8)\n   CRC-STATIC: All other octets.\n\
    \   Note: No encrypted data is considered to be part of the header for\n   purposes\
    \ of computing the CRC, i.e., octets after the eight octet are\n   not considered\
    \ part of the header.\n"
- title: 5.7.7.8.  Initialization of Other Headers
  contents:
  - "5.7.7.8.  Initialization of Other Headers\n   Headers not explicitly listed in\
    \ previous subsections can be\n   compressed only by making them part of an extension\
    \ header chain\n   following an IPv4 or IPv6 header, see section 5.8.\n"
- title: 5.8.  List compression
  contents:
  - "5.8.  List compression\n   Header information from the packet stream to be compressed\
    \ can be\n   structured as an ordered list, which is largely constant between\n\
    \   packets.  The generic structure of such a list is as follows.\n          \
    \  +--------+--------+--...--+--------+\n      list: | item 1 | item 2 |     \
    \  | item n |\n            +--------+--------+--...--+--------+\n   This section\
    \ describes the compression scheme for such information.\n   The basic principles\
    \ of list-based compression are the following:\n   1) While the list is constant,\
    \ no information about the list is sent\n      in compressed headers.\n   2) Small\
    \ changes in the list are represented as additions (Insertion\n      scheme),\
    \ or deletions (Removal scheme), or both (Remove Then\n      Insert scheme).\n\
    \   3) The list can also be sent in its entirety (Generic scheme).\n   There are\
    \ two kinds of lists: CSRC lists in RTP packets, and\n   extension header chains\
    \ in IP packets (both IPv4 and IPv6).\n   IPv6 base headers and IPv4 headers cannot\
    \ be part of an extension\n   header chain.  Headers which can be part of extension\
    \ header chains\n   include\n   a) the AH header\n   b) the null ESP header\n\
    \   c) the minimal encapsulation header [RFC2004, section 3.1]\n   d) the GRE\
    \ header [GRE1, GRE2]\n   e) IPv6 extension headers.\n   The table-based item\
    \ compression scheme (5.8.1), which reduces the\n   size of each item, is described\
    \ first.  Then it is defined which\n   reference list to use in the insertion\
    \ and removal schemes (5.8.2).\n   List encoding schemes are described in section\
    \ 5.8.3, and a few\n   special cases in section 5.8.4.  Finally, exact formats\
    \ are described\n   in sections 5.8.5-5.8.6.\n"
- title: 5.8.1.  Table-based item compression
  contents:
  - "5.8.1.  Table-based item compression\n   The Table-based item compression scheme\
    \ is a way to compress\n   individual items sent in compressed lists.  The compressor\
    \ assigns\n   each item in a list a unique identifier Index.  The compressor\n\
    \   conceptually maintains a table with all items, indexed by Index.  The\n  \
    \ (Index, item) pair is sent together in compressed lists until the\n   compressor\
    \ gains enough confidence that the decompressor has observed\n   the mapping between\
    \ the item and its Index.  Such confidence is\n   obtained by receiving an acknowledgment\
    \ from the decompressor in R-\n   mode, and in U/O-mode by sending L (Index, item)\
    \ pairs (not\n   necessarily consecutively).  After that, the Index alone is sent\
    \ in\n   compressed lists to indicate the corresponding item.  The compressor\n\
    \   may reassign an existing Index to a new item, and then needs to re-\n   establish\
    \ the mapping in the same manner as above.\n   The decompressor conceptually maintains\
    \ a table that contains all\n   (Index, item) pairs it knows about.  The table\
    \ is updated whenever an\n   (Index, item) pair is received (and decompression\
    \ is verified by a\n   CRC).  The decompressor retrieves the item from the table\
    \ whenever an\n   Index without an accompanying item is received.\n"
- title: 5.8.1.1.  Translation table in R-mode
  contents:
  - "5.8.1.1.  Translation table in R-mode\n   At the compressor side, an entry in\
    \ the Translation Table has the\n   following structure.\n              +-------+------+---------------+\n\
    \      Index i | Known | item | SN1, SN2, ... |\n              +-------+------+---------------+\n\
    \   The Known flag indicates whether the mapping between Index i and item\n  \
    \ has been established, i.e., if Index i alone can be sent in\n   compressed lists.\
    \  Known is initially zero.  It is also set to zero\n   whenever Index i is assigned\
    \ to a new item.  Known is set to one when\n   the corresponding (Index, item)\
    \ pair is acknowledged.\n   Acknowledgments are based on the RTP Sequence Number,\
    \ so a list of\n   RTP Sequence Numbers of all packets which contain the (Index,\
    \ item)\n   pair is included in the translation table.  When a packet with a\n\
    \   sequence number in the sequence number list is acknowledged, the\n   Known\
    \ flag is set, and the sequence number list can be discarded.\n   Each entry in\
    \ the Translation Table at the decompressor side has the\n   following structure:\n\
    \              +-------+------+\n      Index i | Known | item |\n            \
    \  +-------+------+\n   All Known fields are initialized to zero.  Whenever the\
    \ decompressor\n   receives an (Index, item) pair, it inserts item into the table\
    \ at\n   position Index and sets the Known flag in that entry to one.  If an\n\
    \   index without an accompanying item is received for which the Known\n   flag\
    \ is zero, the header MUST be discarded and a NACK SHOULD be sent.\n"
- title: 5.8.1.2.  Translation table in U/O-modes
  contents:
  - "5.8.1.2.  Translation table in U/O-modes\n   At the compressor side, each entry\
    \ in the Translation Table has the\n   following structure:\n            +-------+------+---------+\n\
    \      Index | Known | item | Counter |\n            +-------+------+---------+\n\
    \   The Index, Known, and item fields have the same meaning as in section\n  \
    \ 5.8.1.1.\n   Known is set when the (Index, item) pair has been sent in L\n \
    \  compressed lists (not necessarily consecutively).  The Counter field\n   keeps\
    \ track of how many times the pair has been sent.  Counter is set\n   to 0 for\
    \ each new entry added to the table, and whenever Index is\n   assigned to a new\
    \ item.  Counter is incremented by 1 whenever an\n   (Index, item) pair is sent.\
    \  When the counter reaches L, the Known\n   field is set and after that only\
    \ the Index needs to be sent in\n   compressed lists.\n   At the decompressor\
    \ side, the Translation Table is the same as the\n   Translation Table defined\
    \ in R-mode.\n"
- title: 5.8.2.  Reference list determination
  contents:
  - "5.8.2.  Reference list determination\n   In reference based compression schemes\
    \ (i.e., addition or deletion\n   based schemes), compression and decompression\
    \ of a list (curr_list)\n   are based on a reference list (ref_list) which is\
    \ assumed to be\n   present in the context of both compressor and decompressor.\
    \  The\n   compressed list is an encoding of the differences between curr_list\n\
    \   and ref_list.  Upon reception of a compressed list, the decompressor\n   applies\
    \ the differences to its reference list in order to obtain the\n   original list.\n\
    \   To identify the reference list (to be) used, each compressed list\n   carries\
    \ an identifier (ref_id).  The reference list is established by\n   different\
    \ methods in R-mode and U/O-mode.\n"
- title: 5.8.2.1.  Reference list in R-mode and U/O-mode
  contents:
  - "5.8.2.1.  Reference list in R-mode and U/O-mode\n   In R-mode, the choice of\
    \ reference list is based on acknowledgments,\n   i.e., the compressor uses as\
    \ ref_list the latest list which has been\n   acknowledged by the decompressor.\
    \  The ref_list is updated only upon\n   receiving an acknowledgment.  The least\
    \ significant bits of the RTP\n   Sequence Number of the acknowledged packet are\
    \ used as the ref_id.\n   In U/O-mode, a sequence of identical lists are considered\
    \ as\n   belonging to the same generation and are all assigned the same\n   generation\
    \ identifier (gen_id).  Gen_id increases by 1 each time the\n   list changes and\
    \ is carried in compressed and uncompressed lists that\n   are candidates for\
    \ being used as reference lists.  Normally, Gen_id\n   must have been repeated\
    \ in at least L headers before the list can be\n   used as a ref_list.  However,\
    \ some acknowledgments may be sent in O-\n   mode (and also in U-mode), and whenever\
    \ an acknowledgment for a\n   header is received, the list of that header is considered\
    \ known and\n   need not be repeated further.  The least significant bits of the\n\
    \   Gen_id is used as the ref_id in U/O-mode.\n   The logic of the compressor\
    \ and decompressor for reference based list\n   compression is similar to that\
    \ for SN and TS.  The principal\n   difference is that the decompressor maintains\
    \ a sliding window with\n   candidates for ref_list, and retrieves ref_list from\
    \ the sliding\n   window using the ref_id of the compressed list.\n   Logic of\
    \ compressor:\n   a) In the IR state, the compressor sends Generic lists (see\
    \ 5.8.5)\n      containing all items of the current list in order to establish\
    \ or\n      refresh the context of the decompressor.\n      In R-mode, such Generic\
    \ lists are sent until a header is\n      acknowledged.  The list of that header\
    \ can be used as a reference\n      list to compress subsequent lists.\n     \
    \ In U/O-mode, the compressor sends generation identifiers with the\n      Generic\
    \ lists until\n      1) a generation identifier has been repeated L times, or\n\
    \      2) an acknowledgment for a header carrying a generation identifier\n  \
    \       has been received.\n      The repeated (1) or acknowledged (2) list can\
    \ be used as a\n      reference list to compress subsequent lists and is kept\
    \ together\n      with its generation identifier.\n   b) When not in the IR state,\
    \ the compressor moves to the FO state\n      when it observes a difference between\
    \ curr_list and the previous\n      list.  It sends compressed lists based on\
    \ ref_list to update the\n      context of the decompressor.  (However, see d).)\n\
    \      In R-mode, the compressor keeps sending compressed lists using the\n  \
    \    same reference until it receives an acknowledgment for a packet\n      containing\
    \ the newest list.  The compressor may then move to the\n      SO state with regard\
    \ to the list.\n      In U/O-mode, the compressor keeps sending compressed lists\
    \ with\n      generation identifiers until\n      1) a generation identifier has\
    \ been repeated L times, or\n      2) an acknowledgment for a header carrying\
    \ the latest generation\n         identifier has been received.\n      The repeated\
    \ or acknowledged list is used as the future reference\n      list.  The compressor\
    \ may move to the SO state with regard to the\n      list.\n   c) In R-mode, the\
    \ compressor maintains a sliding window containing\n      the lists which have\
    \ been sent to update the context of the\n      decompressor and have not yet\
    \ been acknowledged.  The sliding\n      window shrinks when an acknowledgment\
    \ arrives: all lists sent\n      before the acknowledged list are removed.  The\
    \ compressor may use\n      the Index to represent items of lists in the sliding\
    \ window.\n      In U/O-mode, the compressor needs to store\n      1) the reference\
    \ list and its generation identifier, and\n      2) if the current generation\
    \ identifier is different from the\n         reference generation, the current\
    \ list and the sequence\n         numbers with which the current list has been\
    \ sent.\n      (2) is needed to determine if an acknowledgment concerns the\n\
    \          latest generation.  It is not needed in U-mode.\n   d) In U/O-mode,\
    \ the compressor may choose to not send a generation\n      identifier with a\
    \ compressed list.  Such lists without generation\n      identifiers are not assigned\
    \ a new generation identifier and must\n      not be used as future reference\
    \ lists.  They do not update the\n      context.  This feature is useful when\
    \ a new list is repeated few\n      times and the list then reverts back to its\
    \ old value.\n   Logic of decompressor:\n   e) In R-mode, the decompressor acknowledges\
    \ all received uncompressed\n      or compressed lists which establish or update\
    \ the context.  (Such\n      compressed headers contain a CRC.)\n      In O-mode,\
    \ the decompressor MAY acknowledge a list with a new\n      generation identifier,\
    \ see section 5.4.2.2.\n      In U-mode, the decompressor MAY acknowledge a list\
    \ sent in an IR\n      packet, see section 5.3.2.3.\n   f) The decompressor maintains\
    \ a sliding window which contains the\n      lists that may be used as reference\
    \ lists.\n      In R-mode, the sliding window contains lists which have been\n\
    \      acknowledged but not yet used as reference lists.\n      In U/O-mode, the\
    \ sliding window contains at most one list per\n      generation.  It contains\
    \ all generations seen by the decompressor\n      newer than the last generation\
    \ used as a reference.\n   g) When the decompressor receives a compressed list,\
    \ it retrieves the\n      proper ref_list from the sliding window based on the\
    \ ref_id, and\n      decompresses the compressed list obtaining curr_list.\n \
    \     In R-mode, curr_list is inserted into the sliding window if an\n      acknowledgment\
    \ is sent for it.  The sliding window is shrunk by\n      removing all lists received\
    \ before ref_list.\n      In U/O-mode, curr_list is inserted into the sliding\
    \ window\n      together with its generation identifier if the compressed list\
    \ had\n      a generation identifier and the sliding window does not contain a\n\
    \      list with that generation identifier.  All lists with generations\n   \
    \   older than ref_id are removed from the sliding window.\n"
- title: 5.8.3.  Encoding schemes for the compressed list
  contents:
  - "5.8.3.  Encoding schemes for the compressed list\n   Four encoding schemes for\
    \ the compressed list are described here.\n   The exact formats of the compressed\
    \ CSRC list and compressed IP\n   extension header list using these encoding schemes\
    \ are described in\n   sections 5.8.5-5.8.6.\n   Generic scheme\n      In contrast\
    \ to subsequent schemes, this scheme does not rely on a\n      reference list\
    \ having been established.  The entire list is sent,\n      using table based\
    \ compression for each individual item.  The\n      generic scheme is always used\
    \ when establishing the context of the\n      decompressor and may also be used\
    \ at other times, as the\n      compressor sees fit.\n   Insertion Only scheme\n\
    \      When the new list can be constructed from ref_list by adding\n      items,\
    \ a list of the added items is sent (using table based\n      compression), along\
    \ with the positions in ref_list where the new\n      items will be inserted.\
    \  An insertion bit mask indicates the\n      insertion positions in ref_list.\n\
    \      Upon reception of a list compressed according to the Insertion\n      Only\
    \ scheme, curr_list is obtained by scanning the insertion bit\n      mask from\
    \ left to right.  When a '0' is observed, an item is\n      copied from the ref_list.\
    \  When a '1' is observed, an item is\n      copied from the list of added items.\
    \  If a '1' is observed when\n      the list of added items has been exhausted,\
    \ an error has occurred\n      and decompression fails: The header MUST NOT be\
    \ delivered to upper\n      layers; it should be discarded, and MUST NOT be acknowledged\
    \ nor\n      used as a reference.\n      To construct the insertion bit mask and\
    \ the list of added items,\n      the compressor MAY use the following algorithm:\n\
    \      1) An empty bit list and an empty Inserted Item list are generated\n  \
    \       as the starting point.\n      2) Start by considering the first item of\
    \ curr_list and ref_list.\n      3) If curr_list has a different item than ref_list,\n\
    \            a set bit (1) is appended to the bit list;\n            the first\
    \ item in curr_list (represented using table-based\n            item compression)\
    \ is appended to the Inserted Item list;\n            advance to the next item\
    \ of curr_list;\n      otherwise,\n            a zero bit (0) is appended to the\
    \ bit list;\n            advance to the next item of curr_list;\n            advance\
    \ to the next item of ref_list.\n      4) Repeat 3) until curr_list has been exhausted.\n\
    \      5) If the length of the bit list is less than the required bit\n      \
    \   mask length, append additional zeroes.\n   Removal Only scheme\n      This\
    \ scheme can be used when curr_list can be obtained by removing\n      some items\
    \ in ref_list.  The positions of the items which are in\n      ref_list, but not\
    \ in curr_list, are sent as a removal bit mask.\n      Upon reception of the compressed\
    \ list, the decompressor obtains\n      curr_list by scanning the removal bit\
    \ mask from left to right.\n      When a '0' is observed, the next item of ref_list\
    \ is copied into\n      curr_list.  When a '1' is observed, the next item of ref_list\
    \ is\n      skipped over without being copied.  If a '0' is observed when\n  \
    \    ref_list has been exhausted, an error has occurred and\n      decompression\
    \ fails: The header MUST NOT be delivered to upper\n      layers; it should be\
    \ discarded, and MUST NOT be acknowledged nor\n      used as a reference.\n  \
    \    To construct the removal bit mask and the list of added items, the\n    \
    \  compressor MAY use the following algorithm:\n      1) An empty bit list is\
    \ generated as the starting point.\n      2) Start by considering the first item\
    \ of curr_list and ref_list.\n      3) If curr_list has a different item than\
    \ ref_list,\n         a set bit (1) is appended to the bit list;\n         advance\
    \ to the next item of ref_list;\n      otherwise,\n         a zero bit (0) is\
    \ appended to the bit list;\n         advance to the next item of curr_list;\n\
    \         advance to the next item of ref_list.\n      4) Repeat 3) until curr_list\
    \ has been exhausted.\n      5) If the length of the bit list is less than the\
    \ required bit\n         mask length, append additional ones.\n   Remove Then\
    \ Insert scheme\n      In this scheme, curr_list is obtained by first removing\
    \ items from\n      ref_list, and then inserting items into the resulting list.\
    \  A\n      removal bit mask, an insertion bit mask, and a list of added items\n\
    \      are sent.\n      Upon reception of the compressed list, the decompressor\
    \ processes\n      the removal bit mask as in the Removal Only scheme.  The resulting\n\
    \      list is then used as the reference list when the insertion bit\n      mask\
    \ and the list of added items are processed, as in the\n      Insertion Only scheme.\n"
- title: 5.8.4.  Special handling of IP extension headers
  contents:
  - "5.8.4.  Special handling of IP extension headers\n   In CSRC list compression,\
    \ each CSRC is assigned an index.  In\n   contrast, in IP extension header list\
    \ compression an index is usually\n   associated with a type of extension header.\
    \  When there is more than\n   one IP header, there is more than one list of extension\
    \ headers.  An\n   index per type per list is then used.\n   The association with\
    \ a type means that a new index need not always be\n   used each time a field\
    \ in an IP extension header changes.  However,\n   when a field in an extension\
    \ header changes, the mapping between the\n   index and the new value of the extension\
    \ header needs to be\n   established, except in the special handling cases defined\
    \ in the\n   following subsections.\n"
- title: 5.8.4.1.  Next Header field
  contents:
  - "5.8.4.1.  Next Header field\n   The next header field in an IP header or extension\
    \ header changes\n   whenever the type of the immediately following header changes,\
    \ e.g.,\n   when a new extension header is inserted after it, when the immediate\n\
    \   subsequent extension header is removed from the list, or when the\n   order\
    \ of extension headers is changed.  Thus it may not be uncommon\n   that, for\
    \ a given header, the next header field changes while the\n   remaining fields\
    \ do not change.\n   Therefore, in the case that only the next header field changes,\
    \ the\n   extension header is considered to be unchanged and rules for special\n\
    \   treatment of the change in the next header field are defined below.\n   All\
    \ communicated uncompressed extension header items indicate their\n   own type\
    \ in their Next Header field.  Note that the rules below\n   explain how to treat\
    \ the Next Header fields while showing the\n   conceptual reference list as an\
    \ exact recreation of the original\n   uncompressed extension header list.\n \
    \  a) When a subsequent extension header is removed from the list, the\n     \
    \ new value of the next header field is obtained from the reference\n      extension\
    \ header list.  For example, assume that the reference\n      header list (ref_list)\
    \ consists of headers A, B and C (ref_ext_hdr\n      A, B, C), and the current\
    \ extension header list (curr_list) only\n      consists of extension headers\
    \ A and C (curr_ext_hdr A, C).  The\n      order and value of the next header\
    \ fields of these extension\n      headers are as follows.\n   ref_list:\n   +--------+-----+\
    \    +--------+-----+    +--------+-----+\n   | type B |     |    | type C | \
    \    |    | type D |     |\n   +--------+     |    +--------+     |    +--------+\
    \     |\n   |              |    |              |    |              |\n   +--------------+\
    \    +--------------+    +--------------+\n   ref_ext_hdr A        ref_ext_hdr\
    \ B       ref_ext_hdr C\n    curr_list:\n   +--------+-----+    +--------+-----+\n\
    \   | type C |     |    | type D |     |\n   +--------+     |    +--------+  \
    \   |\n   |              |    |              |\n   +--------------+    +--------------+\n\
    \    curr_ext_hdr A      curr_ext_hdr C\n      Comparing the curr_ext_hdr A in\
    \ curr_list and the ref_ext_hdr A in\n      ref_list, the value of next header\
    \ field is changed from \"type B\"\n      to \"type C\" because of the removal\
    \ of extension header B.  The new\n      value of the next header field in curr_ext_hdr\
    \ A, i.e., \"type C\",\n      does not need to be sent to the decompressor.  Instead,\
    \ it is\n      retrieved from the next header field of the removed ref_ext_hdr\
    \ B.\n   b) When a new extension header is inserted after an existing\n      extension\
    \ header, the next header field in the communicated item\n      will carry the\
    \ type of itself, rather than the type of the header\n      that follows.  For\
    \ example, assume that the reference header list\n      (ref_list) consists of\
    \ headers A and C (ref_ext_hdr A, C), and the\n      current header list (curr_list)\
    \ consists of headers A, B and C\n      (curr_ext_hdr A, B, C).  The order and\
    \ the value of the next\n      header fields of these extension headers are as\
    \ follows.\n   ref_list:\n   +--------+-----+    +--------+-----+\n   | type C\
    \ |     |    | type D |     |\n   +--------+     |    +--------+     |\n   | \
    \             |    |              |\n   +--------------+    +--------------+\n\
    \    ref_ext_hdr A        ref_ext_hdr C\n   curr_list:\n   +--------+-----+  \
    \  +--------+-----+    +--------+-----+\n   | type B |     |    | type C |   \
    \  |    | type D |     |\n   +--------+     |    +--------+     |    +--------+\
    \     |\n   |              |    |              |    |              |\n   +--------------+\
    \    +--------------+    +--------------+\n    curr_ext_hdr A      curr_ext_hdr\
    \ B      curr_ext_hdr C\n      Comparing the curr_list and the ref_list, the value\
    \ of the next\n      header field in extension header A is changed from \"type\
    \ C\" to\n      \"type B\".\n      The uncompressed curr_ext_hdr B is carried\
    \ in the compressed\n      header list.  However, it carries \"type B\" instead\
    \ of \"type C\" in\n      its next header field.  When the decompressor inserts\
    \ a new header\n      after curr_ext_hdr A, the next header field of A is taken\
    \ from the\n      new header, and the next header field of the new header is taken\n\
    \      from ref_ext_hdr A.\n   c) Some headers whose compression is defined in\
    \ this document do not\n      contain Next Header fields or do not have their\
    \ Next Header field\n      in the standard position (first octet of the header).\
    \  The GRE and\n      ESP headers are such headers.  When sent as uncompressed\
    \ items in\n      lists, these headers are modified so that they do have a Next\n\
    \      Header field as their first octet (see 5.8.4.3 and 5.8.4.4).  This\n  \
    \    is necessary to enable the decompressor to decode the item.\n"
- title: 5.8.4.2.  Authentication Header (AH)
  contents:
  - "5.8.4.2.  Authentication Header (AH)\n   The sequence number field in the AH\
    \ [AH] contains a monotonically\n   increasing counter value for a security association.\
    \  Therefore, when\n   comparing curr_list with ref_list, if the sequence number\
    \ in AH\n   changes and SPI field does not change, the AH is not considered as\n\
    \   changed.\n   If the sequence number in the AH linearly increases as the RTP\n\
    \   Sequence Number increases, and the compressor is confident that the\n   decompressor\
    \ has obtained the pattern, the sequence number in AH need\n   not be sent.  The\
    \ decompressor applies linear extrapolation to\n   reconstruct the sequence number\
    \ in the AH.\n   Otherwise, a compressed sequence number is included in the IPX\n\
    \   compression field in an Extension 3 of an UOR-2 header.\n   The authentication\
    \ data field in AH changes from packet to packet and\n   is sent as-is.  If the\
    \ uncompressed AH is sent, the authentication\n   data field is sent inside the\
    \ uncompressed AH; otherwise, it is sent\n   after the compressed IP/UDP/RTP and\
    \ IPv6 extension headers and before\n   the payload.  See beginning of section\
    \ 5.7.\n   Note: The payload length field of the AH uses a different notion of\n\
    \   length than other IPv6 extension headers.\n"
- title: 5.8.4.3.  Encapsulating Security Payload Header (ESP)
  contents:
  - "5.8.4.3.  Encapsulating Security Payload Header (ESP)\n   When the Encapsulating\
    \ Security Payload Header (ESP) [ESP] is present\n   and an encryption algorithm\
    \ other than NULL is being used, the UDP\n   and RTP headers are both encrypted\
    \ and cannot be compressed.  The ESP\n   header thus ends the compressible header\
    \ chain.  The ROHC ESP profile\n   defined in section 5.12 MAY be used for the\
    \ stream in this case.\n   A special case is when the NULL encryption algorithm\
    \ is used.  This\n   is the case when the ESP header is used for authentication\
    \ only, and\n   not for encryption.  The payload is not encrypted by the NULL\n\
    \   encryption algorithm, so compression of the rest of the header chain\n   is\
    \ possible.  The rest of this section describes compression of the\n   ESP header\
    \ when the NULL encryption algorithm is used with ESP.\n   It is not possible\
    \ to determine whether NULL encryption is used by\n   inspecting a header in the\
    \ stream, this information is present only\n   at the encryption endpoints.  However,\
    \ a compressor may attempt\n   compression under the assumption that the NULL\
    \ encryption algorithm\n   is being used, and later abort compression when the\
    \ assumption proves\n   to be false.\n   The compressor may, for example, inspect\
    \ the Next Header fields and\n   the header fields supposed to be static in subsequent\
    \ headers in\n   order to determine if NULL encryption is being used.  If these\
    \ change\n   unpredictably, an encryption algorithm other than NULL is probably\n\
    \   being used and compression of subsequent headers SHOULD be aborted.\n   Compression\
    \ of the stream is then either discontinued, or a profile\n   that compresses\
    \ only up to the ESP header may be used (see 5.12).\n   While attempting to compress\
    \ the header, the compressor should use\n   the SPI of the ESP header together\
    \ with the destination IP address as\n   the defining fields for determining which\
    \ packets belong to the\n   stream.\n   In the ESP header [ESP, section 2], the\
    \ fields that can be compressed\n   are the SPI, the sequence number, the Next\
    \ Header, and the padding\n   bytes if they are in the standard format defined\
    \ in [ESP]. (As\n   always, the decompressor reinserts these fields based on the\n\
    \   information in the context.  Care must be taken to correctly reinsert\n  \
    \ all the information as the Authentication Data must be verified over\n   the\
    \ exact same information it was computed over.)\n   ESP header [ESP, section 2]:\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |              Security Parameters Index (SPI)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Sequence Number                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Payload Data (variable)                    |\n   ~  \
    \                                                             ~\n   |        \
    \                                                       |\n   +              \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |               |    \
    \ Padding (0-255 octets)                    |\n   +-+-+-+-+-+-+-+-+          \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                               |\
    \  Pad Length   | Next Header   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Authentication Data                       |\n   +  \
    \      (variable length, but assumed to be 12 octets)         +\n   |        \
    \                                                       |\n   +              \
    \                                                 +\n   |                    \
    \                                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      SPI: Static.  If it changes, it needs to be reestablished.\n      Sequence\
    \ Number: Not sent when the offset from the sequence number\n          of the\
    \ compressed header is constant.  When the offset is not\n          constant,\
    \ the sequence number may be compressed by sending\n          LSBs.  See 5.8.4.\n\
    \      Payload Data: This is where subsequent headers are to be found.\n     \
    \     Parsed according to the Next Header field.\n      Padding: The padding octets\
    \ are assumed to be as defined in [ESP],\n          i.e., to take the values 1,\
    \ 2, ..., k, where k = Pad Length.\n          If the padding in the static context\
    \ has this pattern, padding\n          in compressed headers is assumed to have\
    \ this pattern as well\n          and is removed.  If padding in the static context\
    \ does not\n          have this pattern, the padding is not removed.\n      Pad\
    \ Length: Dynamic.  Always sent.  14th octet from end of packet.\n      Next Header:\
    \ Static.  13th octet from end of packet.\n   Authentication Data: Can have variable\
    \ length, but when compression\n   of NULL-encryption ESP header is attempted,\
    \ it is assumed to have\n   length 12 octets.\n   The sequence number in ESP has\
    \ the same behavior as the sequence\n   number field in AH.  When it increases\
    \ linearly, it can be compressed\n   to zero bits.  When it does not increase\
    \ linearly, a compressed\n   sequence number is included in the IPX compression\
    \ field in an\n   Extension 3 of an UOR-2 header.\n   The information which is\
    \ part of an uncompressed item of a compressed\n   list is the Next Header field,\
    \ followed by the SPI and the Sequence\n   Number.  Padding, Pad Length, Next\
    \ Header, and Authentication Data\n   are sent as-is at the end of the packet.\
    \  This means that the Next\n   Header occurs in two places.\n   Uncompressed\
    \ ESP list item:\n       +---+---+---+---+---+---+---+---+\n      |          Next\
    \ Header          !  1 octet (see section 5.8.4.1)\n      +---+---+---+---+---+---+---+---+\n\
    \      /              SPI              /  4 octets\n      +---+---+---+---+---+---+---+---+\n\
    \      /        Sequence Number        /  4 octets\n      +---+---+---+---+---+---+---+---+\n\
    \      When sending Uncompressed ESP list items, all ESP fields near the\n   \
    \   the end of the packet are left untouched (Padding, Pad Length,\n      Next\
    \ Header, Authentication Data).\n   A compressed item consists of a compressed\
    \ sequence number.  When an\n   item is compressed, Padding (if it follows the\
    \ 1, 2, ..., k pattern)\n   and Next Header are removed near the end of the packet.\n\
    \   Authentication Data and Pad Length remain as-is near the end of the\n   packet.\n"
- title: 5.8.4.4.  GRE Header [RFC 2784, RFC 2890]
  contents:
  - "5.8.4.4.  GRE Header [RFC 2784, RFC 2890]\n   The GRE header is a set of flags,\
    \ followed by a mandatory Protocol\n   Type and optional parts as indicated by\
    \ the flags.\n   The sequence number field in the GRE header contains a counter\
    \ value\n   for a GRE tunnel.  Therefore, when comparing curr_list with ref_list,\n\
    \   if the sequence number in GRE changes, the GRE is not considered as\n   changed.\n\
    \   If the sequence number in the GRE header linearly increases as the\n   RTP\
    \ Sequence Number increases and the compressor is confident that\n   the decompressor\
    \ has received the pattern, the sequence number in GRE\n   need not be sent. \
    \ The decompressor applies linear extrapolation to\n   reconstruct the sequence\
    \ number in the GRE header.\n   Otherwise, a compressed sequence number is included\
    \ in the IPX\n   compression field in an Extension 3 of an UOR-2 header.\n   The\
    \ checksum data field in GRE, if present, changes from packet to\n   packet and\
    \ is sent as-is.  If the uncompressed GRE header is sent,\n   the checksum data\
    \ field is sent inside the uncompressed GRE header;\n   otherwise, if present,\
    \ it is sent after the compressed IP/UDP/RTP and\n   IPv6 extension headers and\
    \ before the payload.  See beginning of\n   section 5.7.\n   In order to allow\
    \ simple parsing of lists of items, an uncompressed\n   GRE header sent as an\
    \ item in a list is modified from the original\n   GRE header in the following\
    \ manner: 1) the 16-bit Protocol Type field\n   that encodes the type of the subsequent\
    \ header using Ether types (see\n   Ether types section in [ASSIGNED]) is removed.\
    \  2) A one-octet Next\n   Header field is inserted as the first octet of the\
    \ header.  The value\n   of the Next Header field corresponds to GRE (this value\
    \ is 47\n   according to the Assigned Internet Protocol Number section of\n  \
    \ [ASSIGNED]) when the uncompressed item is to be inserted in a list,\n   and\
    \ to the type of the subsequent header when the uncompressed item\n   is in a\
    \ Generic list.  Note that this implies that only GRE headers\n   with Ether types\
    \ that correspond to an IP protocol number can be\n   compressed.\n   Uncompressed\
    \ GRE list item:\n      +---+---+---+---+---+---+---+---+\n      |          Next\
    \ Header          !  1 octet (see section 5.8.4.1)\n      +---+---+---+---+---+---+---+---+\n\
    \      / C |   | K | S |   |    Ver    |  1 octet\n      +---+---+---+---+---+---+---+---+\n\
    \      /           Checksum            /  2 octets, if C=1\n      +---+---+---+---+---+---+---+---+\n\
    \      /              Key              /  4 octets, if K=1\n      +---+---+---+---+---+---+---+---+\n\
    \      /        Sequence Number        /  4 octets, if S=1\n      +---+---+---+---+---+---+---+---+\n\
    \      The bits left blank in the second octet are set to zero when\n      sending\
    \ and ignored when received.\n      The fields Reserved0 and Reserved1 of the\
    \ GRE header [GRE2] must\n      be all zeroes; otherwise, the packet cannot be\
    \ compressed by this\n      profile.\n"
- title: 5.8.5.  Format of compressed lists in Extension 3
  contents:
  - '5.8.5.  Format of compressed lists in Extension 3

    '
- title: 5.8.5.1.  Format of IP Extension Header(s) field
  contents:
  - "5.8.5.1.  Format of IP Extension Header(s) field\n   In Extension 3 (section\
    \ 5.7.5), there is a field called IP extension\n   header(s).  This section describes\
    \ the format of that field.\n         0     1     2     3     4     5     6  \
    \   7\n      +-----+-----+-----+-----+-----+-----+-----+-----+\n      | CL  |\
    \ ASeq| ESeq| Gseq|          res          |  1 octet\n      +-----+-----+-----+-----+-----+-----+-----+-----+\n\
    \      :    compressed AH Seq Number,  1 or 4 octets   :  if ASeq = 1\n      \
    \ ----- ----- ----- ----- ----- ----- ----- -----\n      :    compressed ESP Seq\
    \ Number, 1 or 4 octets   :  if Eseq = 1\n       ----- ----- ----- ----- -----\
    \ ----- ----- -----\n      :    compressed GRE Seq Number, 1 or 4 octets   : \
    \ if Gseq = 1\n       ----- ----- ----- ----- ----- ----- ----- -----\n      :\
    \    compressed header list, variable length    :  if CL = 1\n       ----- -----\
    \ ----- ----- ----- ----- ----- -----\n      ASeq: indicates presence of compressed\
    \ AH Seq Number\n      ESeq: indicates presence of compressed ESP Seq Number\n\
    \      GSeq: indicates presence of compressed GRE Seq Number\n      CL:   indicates\
    \ presence of compressed header list\n      res:  reserved; set to zero when sending,\
    \ ignored when received\n   When Aseq, Eseq, or Gseq is set, the corresponding\
    \ header item (AH,\n   ESP, or GRE header) is compressed.  When not set, the corresponding\n\
    \   header item is sent uncompressed or is not present.\n   The format of compressed\
    \ AH, ESP and GRE Sequence Numbers can each be\n   either of the following:\n\
    \     0   1   2   3   4   5   6   7       0   1   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\
    \   +---+---+---+---+---+---+---+---+\n   | 0 |   LSB of sequence number  |  \
    \ | 1 |                           |\n   +---+---+---+---+---+---+---+---+   +---+\
    \                           +\n                                       |      \
    \                         |\n                                       +     LSB\
    \ of sequence number    +\n                                       |          \
    \                     |\n                                       +            \
    \                   +\n                                       |              \
    \                 |\n                                       +---+---+---+---+---+---+---+---+\n\
    \   The format of the compressed header list field is described in\n   section\
    \ 5.8.6.\n"
- title: 5.8.5.2.  Format of Compressed CSRC List
  contents:
  - "5.8.5.2.  Format of Compressed CSRC List\n   The Compressed CSRC List field in\
    \ the RTP header part of an Extension\n   3 (section 5.7.5) is as in section 5.8.6.\n"
- title: 5.8.6.  Compressed list formats
  contents:
  - "5.8.6.  Compressed list formats\n   This section describes the format of compressed\
    \ lists.  The format is\n   the same for CSRC lists and header lists.  In CSRC\
    \ lists, the items\n   are CSRC identifiers; in header lists, they are uncompressed\
    \ or\n   compressed headers, as described in 5.8.4.2-4.\n"
- title: 5.8.6.1.  Encoding Type 0 (generic scheme)
  contents:
  - "5.8.6.1.  Encoding Type 0 (generic scheme)\n     0   1   2   3   4   5   6  \
    \ 7\n   +---+---+---+---+---+---+---+---+\n   | ET=0  |GP |PS |    CC = m    \
    \ |\n   +---+---+---+---+---+---+---+---+\n   :            gen_id            \
    \ :  1 octet, if GP = 1\n   +---+---+---+---+---+---+---+---+\n   |        XI\
    \ 1, ..., XI m        |  m octets, or m * 4 bits\n   /                --- ---\
    \ --- ---/\n   |               :    Padding    :  if PS = 0 and m is odd\n   +---+---+---+---+---+---+---+---+\n\
    \   |                               |\n   /       item 1, ..., item n     /  variable\n\
    \   |                               |\n   +---+---+---+---+---+---+---+---+\n\
    \      ET: Encoding type is zero.\n      PS: Indicates size of XI fields:\n  \
    \        PS = 0 indicates 4-bit XI fields;\n          PS = 1 indicates 8-bit XI\
    \ fields.\n      GP: Indicates presence of gen_id field.\n      CC: CSRC counter\
    \ from original RTP header.\n      gen_id: Identifier for a sequence of identical\
    \ lists.  It is\n         present in U/O-mode when the compressor decides that\
    \ it may use\n         this list as a future reference list.\n      XI 1, ...,\
    \ XI m: m XI items.  The format of an XI item is as\n            follows:\n  \
    \                +---+---+---+---+\n         PS = 0:  | X |   Index   |\n    \
    \              +---+---+---+---+\n                    0   1   2   3   4   5  \
    \ 6   7\n                  +---+---+---+---+---+---+---+---+\n         PS = 1:\
    \  | X |           Index           |\n                  +---+---+---+---+---+---+---+---+\n\
    \         X = 1 indicates that the item corresponding to the Index\n         \
    \      is sent in the item 0, ..., item n list.\n         X = 0 indicates that\
    \ the item corresponding to the Index is\n               not sent.\n      When\
    \ 4-bit XI items are used and m > 1, the XI items are placed in\n      octets\
    \ in the following manner:\n              0   1   2   3   4   5   6   7\n    \
    \        +---+---+---+---+---+---+---+---+\n            |     XI k      |    XI\
    \ k + 1   |\n            +---+---+---+---+---+---+---+---+\n      Padding: A 4-bit\
    \ padding field is present when PS = 0 and m is\n      odd.  The Padding field\
    \ is set to zero when sending and ignored\n      when receiving.\n      Item 1,\
    \ ..., item n:\n         Each item corresponds to an XI with X = 1 in XI 1, ...,\
    \ XI m.\n"
- title: 5.8.6.2.  Encoding Type 1 (insertion only scheme)
  contents:
  - "5.8.6.2.  Encoding Type 1 (insertion only scheme)\n     0   1   2   3   4   5\
    \   6   7\n   +---+---+---+---+---+---+---+---+\n   | ET=1  |GP |PS |     XI 1\
    \      |\n   +---+---+---+---+---+---+---+---+\n   :            gen_id       \
    \      :  1 octet, if GP = 1\n   +---+---+---+---+---+---+---+---+\n   |     \
    \       ref_id             |\n   +---+---+---+---+---+---+---+---+\n   /     \
    \ insertion bit mask       /  1-2 octets\n   +---+---+---+---+---+---+---+---+\n\
    \   |            XI list            |  k octets, or (k - 1) * 4 bits\n   /   \
    \             --- --- --- ---/\n   |               :    Padding    :  if PS =\
    \ 0 and k is even\n   +---+---+---+---+---+---+---+---+\n   |                \
    \               |\n   /       item 1, ..., item n     /  variable\n   |      \
    \                         |\n   +---+---+---+---+---+---+---+---+\n   Unless explicitly\
    \ stated otherwise, fields have the same meaning and\n   values as for encoding\
    \ type 0.\n      ET: Encoding type is one (1).\n      XI 1: When PS = 0, the first\
    \ 4-bit XI item is placed here.\n            When PS = 1, the field is set to\
    \ zero when sending, and\n            ignored when receiving.\n      ref_id: The\
    \ identifier of the reference CSRC list used when the\n           list was compressed.\
    \  It is the 8 least significant bits of\n           the RTP Sequence Number in\
    \ R-mode and gen_id (see section\n           5.8.2) in U/O-mode.\n      insertion\
    \ bit mask: Bit mask indicating the positions where new\n                items\
    \ are to be inserted.  See Insertion Only scheme in\n                section 5.8.3.\
    \  The bit mask can have either of the\n                following two formats:\n\
    \           0   1   2   3   4   5   6   7\n         +---+---+---+---+---+---+---+---+\n\
    \         | 0 |        7-bit mask         |  bit 1 is the first bit\n        \
    \ +---+---+---+---+---+---+---+---+\n         +---+---+---+---+---+---+---+---+\n\
    \         | 1 |                           |  bit 1 is the first bit\n        \
    \ +---+      15-bit mask          +\n         |                              \
    \ |  bit 7 is the last bit\n         +---+---+---+---+---+---+---+---+\n     \
    \ XI list: XI fields for items to be inserted.  When the insertion\n         bit\
    \ mask has k ones, the total number of XI fields is k.  When\n         PS = 1,\
    \ all XI fields are in the XI list.  When PS = 0, the\n         first XI field\
    \ is in the XI 1 field, and the remaining k - 1\n         XI fields are in the\
    \ XI list.\n      Padding: Present when PS = 0 and k is even.\n      item 1, ...,\
    \ item n: One item for each XI field with the X bit\n         set.\n"
- title: 5.8.6.3.  Encoding Type 2 (removal only scheme)
  contents:
  - "5.8.6.3.  Encoding Type 2 (removal only scheme)\n        0   1   2   3   4  \
    \ 5   6   7\n      +---+---+---+---+---+---+---+---+\n      | ET=2  |GP |res|\
    \     Count     |\n      +---+---+---+---+---+---+---+---+\n      :          \
    \  gen_id             :  1 octet, if GP = 1\n      +---+---+---+---+---+---+---+---+\n\
    \      |            ref_id             |\n      +---+---+---+---+---+---+---+---+\n\
    \      /       removal bit mask        /  1-2 octets\n      +---+---+---+---+---+---+---+---+\n\
    \      Unless explicitly stated otherwise, fields have the same meaning\n    \
    \  and values as in section 5.8.5.2.\n         ET: Encoding type is 2.\n     \
    \    res: Reserved.  Set to zero when sending, ignored when\n            received.\n\
    \         Count: Number of elements in ref_list.\n         removal bit mask: Indicates\
    \ the elements in ref_list to be\n            removed in order to obtain the current\
    \ list.  See section\n            5.8.3.  The removal bit mask has the same format\
    \ as the\n            insertion bit mask of section 5.8.6.3.\n"
- title: 5.8.6.4.  Encoding Type 3 (remove then insert scheme)
  contents:
  - "5.8.6.4.  Encoding Type 3 (remove then insert scheme)\n      See section 5.8.3\
    \ for a description of the Remove then insert\n      scheme.\n        0   1  \
    \ 2   3   4   5   6   7\n      +---+---+---+---+---+---+---+---+\n      | ET=3\
    \  |GP |PS |     XI 1      |\n      +---+---+---+---+---+---+---+---+\n      :\
    \            gen_id             :  1 octet, if GP = 1\n      +---+---+---+---+---+---+---+---+\n\
    \      |            ref_id             |\n      +---+---+---+---+---+---+---+---+\n\
    \      /       removal bit mask        /  1-2 octets\n      +---+---+---+---+---+---+---+---+\n\
    \      /      insertion bit mask       /  1-2 octets\n      +---+---+---+---+---+---+---+---+\n\
    \      |            XI list            |  k octets, or (k - 1) * 4 bits\n    \
    \  /                --- --- --- ---/\n      |               :    Padding    :\
    \  if PS = 0 and k is even\n      +---+---+---+---+---+---+---+---+\n      | \
    \                              |\n      /       item 1, ..., item n     /  variable\n\
    \      |                               |\n      +---+---+---+---+---+---+---+---+\n\
    \      The fields in this header have the same meaning and formats as in\n   \
    \   section 5.8.5.2, except when explicitly stated otherwise below.\n        \
    \ ET: Encoding type is 3.\n         removal bit mask: See section 5.8.6.3.\n"
- title: 5.8.7.  CRC coverage for extension headers
  contents:
  - "5.8.7.  CRC coverage for extension headers\n   All fields of extension headers\
    \ are CRC-STATIC, with the following\n   exceptions which are CRC-DYNAMIC.\n \
    \  1) Entire AH header.\n   2) Entire ESP header.\n   3) Sequence number in GRE,\
    \ Checksum in GRE\n"
- title: 5.9.  Header compression CRCs, coverage and polynomials
  contents:
  - "5.9.  Header compression CRCs, coverage and polynomials\n   This chapter describes\
    \ how to calculate the CRCs used in packet\n   headers defined in this document.\
    \  (Note that another type of CRC is\n   defined for reconstructed units in section\
    \ 5.2.5.)\n"
- title: 5.9.1.  IR and IR-DYN packet CRCs
  contents:
  - "5.9.1.  IR and IR-DYN packet CRCs\n   The CRC in the IR and IR-DYN packet is\
    \ calculated over the entire IR\n   or IR-DYN packet, excluding Payload and including\
    \ CID or any Add-CID\n   octet.  For purposes of computing the CRC, the CRC field\
    \ in the\n   header is set to zero.\n   The initial content of the CRC register\
    \ is to be preset to all 1's.\n   The CRC polynomial to be used for the 8-bit\
    \ CRC is:\n      C(x) = 1 + x + x^2 + x^8\n"
- title: 5.9.2.  CRCs in compressed headers
  contents:
  - "5.9.2.  CRCs in compressed headers\n   The CRC in compressed headers is calculated\
    \ over all octets of the\n   entire original header, before compression, in the\
    \ following manner.\n   The octets of the header are classified as either CRC-STATIC\
    \ or CRC-\n   DYNAMIC, and the CRC is calculated over:\n   1) the concatenated\
    \ CRC-STATIC octets of the original header, placed\n      in the same order as\
    \ they appear in the original header, followed\n      by\n   2) the concatenated\
    \ CRC-DYNAMIC octets of the original header, placed\n      in the same order as\
    \ they appear in the original header.\n   The intention is that the state of the\
    \ CRC computation after 1) will\n   be saved.  As long as the CRC-STATIC octets\
    \ do not change, the CRC\n   calculation will then only need to process the CRC-DYNAMIC\
    \ octets.\n   In a typical RTP/UDP/IPv4 header, 25 octets are CRC-STATIC and 15\
    \ are\n   CRC-DYNAMIC.  In a typical RTP/UDP/IPv6 header, 49 octets are CRC-\n\
    \   STATIC and 11 are CRC-DYNAMIC.  This technique will thus reduce the\n   computational\
    \ complexity of the CRC calculation by roughly 60% for\n   RTP/UDP/IPv4 and by\
    \ roughly 80% for RTP/UDP/IPv6.\n   Note: Whenever the CRC-STATIC fields change,\
    \ the new saved CRC state\n   after 1) is compared with the old state.  If the\
    \ states are\n   identical, the CRC cannot catch the error consisting in the\n\
    \   decompressor not having updated the static context.  In U/O-mode the\n   compressor\
    \ SHOULD then for a while use packet types with another CRC\n   length, for which\
    \ there is a difference in CRC state, to ensure error\n   detection.\n   The initial\
    \ content of the CRC register is preset to all 1's.\n   The polynomial to be used\
    \ for the 3 bit CRC is:\n      C(x) = 1 + x + x^3\n   The polynomial to be used\
    \ for the 7 bit CRC is:\n      C(x) = 1 + x + x^2 + x^3 + x^6 + x^7\n   The CRC\
    \ in compressed headers is calculated over the entire original\n   header, before\
    \ compression.\n"
- title: 5.10.  ROHC UNCOMPRESSED -- no compression (Profile 0x0000)
  contents:
  - "5.10.  ROHC UNCOMPRESSED -- no compression (Profile 0x0000)\n   In ROHC, compression\
    \ has not been defined for all kinds of IP\n   headers.  Profile 0x0000 provides\
    \ a way to send IP packets without\n   compressing them.  This can be used for\
    \ IP fragments, RTCP packets,\n   and in general for any packet for which compression\
    \ of the header has\n   not been defined, is not possible due to resource constraints,\
    \ or is\n   not desirable for some other reason.\n   After initialization, the\
    \ only overhead for sending packets using\n   Profile 0x0000 is the size of the\
    \ CID.  When uncompressed packets are\n   frequent, Profile 0x0000 should be associated\
    \ with a CID with size\n   zero or one octet.  There is no need to associate Profile\
    \ 0x0000 with\n   more than one CID.\n"
- title: 5.10.1.  IR packet
  contents:
  - "5.10.1.  IR packet\n   The initialization packet (IR packet) for Profile 0x0000\
    \ has the\n   following format:\n     0   1   2   3   4   5   6   7\n    --- ---\
    \ --- --- --- --- --- ---\n   :         Add-CID octet         : if for small CIDs\
    \ and (CID != 0)\n   +---+---+---+---+---+---+---+---+\n   | 1   1   1   1   1\
    \   1   0 |res|\n   +---+---+---+---+---+---+---+---+\n   :                  \
    \             :\n   /    0-2 octets of CID info     / 1-2 octets if for large\
    \ CIDs\n   :                               :\n   +---+---+---+---+---+---+---+---+\n\
    \   |          Profile = 0          | 1 octet\n   +---+---+---+---+---+---+---+---+\n\
    \   |              CRC              | 1 octet\n   +---+---+---+---+---+---+---+---+\n\
    \   :                               : (optional)\n   /           IP packet   \
    \        / variable length\n   :                               :\n    --- ---\
    \ --- --- --- --- --- ---\n      res: Always zero.\n      Profile: 0.\n      CRC:\
    \ 8-bit CRC, computed using the polynomial of section 5.9.1.\n      The CRC covers\
    \ the first octet of the IR packet through the\n      Profile octet of the IR\
    \ packet, i.e., it does not cover the\n      CRC itself or the IP packet.\n  \
    \    IP packet: An uncompressed IP packet may be included in the IR\n      packet.\
    \  The decompressor determines if the IP packet is\n      present by considering\
    \ the length of the IR packet.\n"
- title: 5.10.2.  Normal packet
  contents:
  - "5.10.2.  Normal packet\n   A Normal packet is a normal IP packet plus CID information.\
    \  When the\n   channel uses small CIDs, and profile 0x0000 is associated with\
    \ a CID\n   > 0, an Add-CID octet is prepended to the IP packet.  When the\n \
    \  channel uses large CIDs, the CID is placed so that it starts at the\n   second\
    \ octet of the Normal packet.\n     0   1   2   3   4   5   6   7\n    --- ---\
    \ --- --- --- --- --- ---\n   :         Add-CID octet         : if for small CIDs\
    \ and (CID != 0)\n   +---+---+---+---+---+---+---+---+\n   |   first octet of\
    \ IP packet    |\n   +---+---+---+---+---+---+---+---+\n   :                 \
    \              :\n   /    0-2 octets of CID info     / 1-2 octets if for large\
    \ CIDs\n   :                               :\n   +---+---+---+---+---+---+---+---+\n\
    \   |                               |\n   /      rest of IP packet        / variable\
    \ length\n   |                               |\n   +---+---+---+---+---+---+---+---+\n\
    \   Note that the first octet of the IP packet starts with the bit\n   pattern\
    \ 0100 (IPv4) or 0110 (IPv6).  This does not conflict with any\n   reserved packet\
    \ types.  Hence, no bits in addition to the CID are\n   needed.  The profile is\
    \ reasonably future-proof since problems do not\n   occur until IP version 14.\n"
- title: 5.10.3.  States and modes
  contents:
  - "5.10.3.  States and modes\n   There are two modes in Profile 0x0000: Unidirectional\
    \ mode and\n   Bidirectional mode.  In Unidirectional mode, the compressor repeats\n\
    \   the IR packet periodically.  In Bidirectional mode, the compressor\n   never\
    \ repeats the IR packet.  The compressor and decompressor always\n   start in\
    \ Unidirectional mode.  Whenever feedback is received, the\n   compressor switches\
    \ to Bidirectional mode.\n   The compressor can be in either of two states: the\
    \ IR state or the\n   Normal state.  It starts in the IR state.\n   a) IR state:\
    \ Only IR packets can be sent.  After sending a small\n      number of IR packets\
    \ (only one when refreshing), the compressor\n      switches to the Normal state.\n\
    \   b) Normal state: Only Normal packets can be sent. When in\n      Unidirectional\
    \ mode, the compressor periodically transits back to\n      the IR state.  The\
    \ length of the period is implementation\n      dependent, but should be fairly\
    \ long.  Exponential backoff may be\n      used.\n   c) When feedback is received\
    \ in any state, the compressor switches to\n      Bidirectional mode.\n   The\
    \ decompressor can be in either of two states: NO_CONTEXT or\n   FULL_CONTEXT.\
    \  It starts in NO_CONTEXT.\n   d) When an IR packet is received in the NO_CONTEXT\
    \ state, the\n      decompressor first verifies the packet using the CRC.  If\
    \ the\n      packet is OK, the decompressor 1) moves to the FULL_CONTEXT state,\n\
    \      2) delivers the IP packet to upper layers if present, 3) MAY send\n   \
    \   an ACK.  If the packet is not OK, it is discarded without further\n      action.\n\
    \   e) When any other packet is received in the NO_CONTEXT state, it is\n    \
    \  discarded without further action.\n   f) When an IR packet is received in the\
    \ FULL_CONTEXT state, the\n      packet is first verified using the CRC.  If OK,\
    \ the decompressor\n      1) delivers the IP packet to upper layers if present,\
    \ 2) MAY send\n      an ACK.  If the packet is not OK, no action is taken.\n \
    \  g) When a Normal packet is received in the FULL_CONTEXT state, the\n      CID\
    \ information is removed and the IP packet is delivered to upper\n      layers.\n"
- title: 5.10.4.  Feedback
  contents:
  - "5.10.4.  Feedback\n   The only kind of feedback in Profile 0x0000 is ACKs.  Profile\
    \ 0x0000\n   MUST NOT be rejected.  Profile 0x0000 SHOULD be associated with at\n\
    \   most one CID.  ACKs use the FEEDBACK-1 format of section 5.2.  The\n   value\
    \ of the profile-specific octet in the FEEDBACK-1 ACK is 0\n   (zero).\n"
- title: 5.11.  ROHC UDP -- non-RTP UDP/IP compression (Profile 0x0002)
  contents:
  - "5.11.  ROHC UDP -- non-RTP UDP/IP compression (Profile 0x0002)\n   UDP/IP headers\
    \ do not have a sequence number which is as well-behaved\n   as the RTP Sequence\
    \ Number.  For UDP/IPv4, there is an IP-ID field\n   which may be echoed in feedback\
    \ information, but when no IPv4 header\n   is present such feedback identification\
    \ becomes problematic.\n   Therefore, in the ROHC UDP profile, the compressor\
    \ generates a 16-bit\n   sequence number SN which increases by one for each packet\
    \ received in\n   the packet stream.  This sequence number is thus relatively\
    \ well-\n   behaved and can serve as the basis for most mechanisms described for\n\
    \   ROHC RTP.  It is called SN or UDP SN below.  Unless stated otherwise,\n  \
    \ the mechanisms of ROHC RTP are used also for ROHC UDP, with the UDP\n   SN taking\
    \ the role of the RTP Sequence Number.\n   The ROHC UDP profile always uses p\
    \ = -1 when interpreting the SN,\n   since there will be no repetitions or reordering\
    \ of the compressor-\n   generated SN.  The interpretation interval thus always\
    \ starts with\n   (ref_SN + 1).\n"
- title: 5.11.1.  Initialization
  contents:
  - "5.11.1.  Initialization\n   The static context for ROHC UDP streams can be initialized\
    \ in either\n   of two ways:\n   1) By using an IR packet as in section 5.7.7.1,\
    \ where the profile is\n      two (2) and the static chain ends with the static\
    \ part of an UDP\n      packet.  At the compressor, UDP SN is initialized to a\
    \ random\n      value when the IR packet is sent.\n   2) By reusing an existing\
    \ context where the existing static chain\n      contains the static part of a\
    \ UDP packet, e.g., the context of a\n      stream compressed using ROHC RTP (profile\
    \ 0x0001).  This is done\n      with an IR-DYN packet (section 5.7.7.2) identifying\
    \ profile\n      0x0002, where the dynamic chain corresponds to the prefix of\
    \ the\n      existing static chain that ends with the UDP header.  UDP SN is\n\
    \      initialized to the RTP Sequence Number if the earlier profile was\n   \
    \   profile 0x0001, and to a random number otherwise.\n   For ROHC UDP, the dynamic\
    \ part of a UDP packet is different from\n   section 5.7.7.5: a two-octet field\
    \ containing the UDP SN is added\n   after the Checksum field.  This affects the\
    \ format of dynamic chains\n   in IR and IR-DYN packets.\n   Note: 2) can be used\
    \ for packet streams which were initially assumed\n   to be RTP streams, so that\
    \ compression started with profile 0x0001,\n   but were later found evidently\
    \ not to be RTP streams.\n"
- title: 5.11.2.  States and modes
  contents:
  - "5.11.2.  States and modes\n   ROHC UDP uses the same states and modes as ROHC\
    \ RTP.  Mode\n   transitions and state logic are the same except when explicitly\n\
    \   stated otherwise.  Mechanisms dealing with fields in the RTP header\n   (except\
    \ the RTP SN) are not used.  The decompressed UDP SN is never\n   included in\
    \ any header delivered to upper layers.  The UDP SN is used\n   in place of the\
    \ RTP SN in feedback.\n"
- title: 5.11.3.  Packet types
  contents:
  - "5.11.3.  Packet types\n   The general format of a ROHC UDP packet is the same\
    \ as for ROHC RTP\n   (see beginning of section 5.7).  Padding and CIDs are the\
    \ same, as is\n   the feedback packet type (5.7.6.1) and the feedback.  IR and\
    \ IR-DYN\n   packets (5.7.7) are changed as described in 5.11.1.\n   The general\
    \ format of compressed packets is also the same, but there\n   are differences\
    \ in specific formats and extensions as detailed below.\n   The differences are\
    \ caused by removal of all RTP specific information\n   except the RTP SN, which\
    \ is replaced by the UDP SN.\n   Unless explicitly stated below, the packet formats\
    \ are as in sections\n   5.7.1-6.\n   R-1\n      The TS field is replaced by an\
    \ IP-ID field.  The M flag has become\n      part of IP-ID.  The X bit has moved.\
    \  The formats R-1-ID and R-1-\n      TS are not used.\n     0   1   2   3   4\
    \   5   6   7\n   +---+---+---+---+---+---+---+---+\n   | 1   0 |          SN\
    \           |\n   +===+===+===+===+===+===+===+===+\n   | X |           IP-ID\
    \           |\n   +---+---+---+---+---+---+---+---+\n   UO-1\n      The TS field\
    \ is replaced by an IP-ID field.  The M flag has become\n      part of SN.  Formats\
    \ UO-1-ID and UO-1-TS are not used.\n     0   1   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n\
    \   | 1   0 |         IP-ID         |\n   +===+===+===+===+===+===+===+===+\n\
    \   |        SN         |    CRC    |\n   +---+---+---+---+---+---+---+---+\n\
    \   UOR-2\n      New format:\n     0   1   2   3   4   5   6   7\n   +---+---+---+---+---+---+---+---+\n\
    \   | 1   1   0 |        SN         |\n   +===+===+===+===+===+===+===+===+\n\
    \   | X |            CRC            |\n   +---+---+---+---+---+---+---+---+\n"
- title: 5.11.4.  Extensions
  contents:
  - "5.11.4.  Extensions\n   Extensions are as in 5.7.5, with the following exceptions:\n\
    \   Extension 0:\n      +---+---+---+---+---+---+---+---+\n      | 0   0 |   \
    \ SN     |   IP-ID   |\n      +---+---+---+---+---+---+---+---+\n   Extension\
    \ 1:\n      +---+---+---+---+---+---+---+---+\n      | 0   1 |    SN     |   IP-ID\
    \   |\n      +---+---+---+---+---+---+---+---+\n      |             IP-ID    \
    \         |\n      +---+---+---+---+---+---+---+---+\n   Extension 2:\n      +---+---+---+---+---+---+---+---+\n\
    \      | 1   0 |    SN     |   IP-ID2  |\n      +---+---+---+---+---+---+---+---+\n\
    \      |            IP-ID2             |\n      +---+---+---+---+---+---+---+---+\n\
    \      |             IP-ID             |\n      +---+---+---+---+---+---+---+---+\n\
    \         IP-ID2: For outer IP-ID field.\n   Extension 3 is the same as Extension\
    \ 3 in section 5.7.5, with the\n   following exceptions.\n   1) The initial flag\
    \ octet has the following format:\n         0     1     2     3     4     5  \
    \   6     7\n      +-----+-----+-----+-----+-----+-----+-----+-----+\n      |\
    \  1     1  |  S  |   Mode    |  I  | ip  | ip2 |\n      +-----+-----+-----+-----+-----+-----+-----+-----+\n\
    \      Mode: Replaces R-TS and Tsc of 5.7.5.  Provides mode information\n    \
    \  as was earlier done in RTP header flags and fields.\n      ip2: Replaces rtp\
    \ bit of 5.7.5.  Moved here from the Inner IP\n      header flags octet.\n   2)\
    \ The bit which was the ip2 flag in the Inner IP header flags in\n      5.7.5\
    \ is reserved.  It is set to zero when sending and ignored\n      when receiving.\n"
- title: 5.11.5.  IP-ID
  contents:
  - "5.11.5.  IP-ID\n   Treated as in ROHC RTP, but the offset is from UDP SN.\n"
- title: 5.11.6.  Feedback
  contents:
  - "5.11.6.  Feedback\n   Feedback is as for ROHC RTP with the following exceptions:\n\
    \   1) UDP SN replaces RTP SN in feedback.\n   2) The CLOCK option (5.7.6.6) is\
    \ not used.\n   3) The JITTER option (5.7.6.7) is not used.\n"
- title: 5.12.  ROHC ESP -- ESP/IP compression (Profile 0x0003)
  contents:
  - "5.12.  ROHC ESP -- ESP/IP compression (Profile 0x0003)\n   When the ESP header\
    \ is being used with an encryption algorithm other\n   than NULL, subheaders after\
    \ the ESP header are encrypted and cannot\n   be compressed.  Profile 0x0003 is\
    \ for compression of the chain of\n   headers up to and including the ESP header\
    \ in this case.  When the\n   NULL encryption algorithm is being used, other profiles\
    \ can be used\n   and could give higher compression rates.  See section 5.8.4.3.\n\
    \   This profile is very similar to the ROHC UDP profile.  It uses the\n   ESP\
    \ sequence number as the basis for compression instead of a\n   generated number,\
    \ but is otherwise very similar to ROHC UDP.  The\n   interpretation interval\
    \ (value of p) for the ESP-based SN is as with\n   ROHC RTP (profile 0x0001).\
    \  Apart from this, unless stated explicitly\n   below, mechanisms and formats\
    \ are as for ROHC UDP.\n"
- title: 5.12.1.  Initialization
  contents:
  - "5.12.1.  Initialization\n   The static context for ROHC ESP streams can be initialized\
    \ in either\n   of two ways:\n   1) by using an IR packet as in section 5.7.7.1,\
    \ where the profile is\n      three (3) and the static chain ends with the static\
    \ part of an ESP\n      header.\n   2) by reusing an existing context, where the\
    \ existing static chain\n      contains the static part of an ESP header.  This\
    \ is done with an\n      IR-DYN packet (section 5.7.7.2) identifying profile 0x0003,\
    \ where\n      the dynamic chain corresponds to the prefix of the existing static\n\
    \      chain that ends with the ESP header.\n   In contrast to ROHC UDP, no extra\
    \ sequence number is added to the\n   dynamic part of the ESP header: the ESP\
    \ sequence number is the only\n   element.\n   Note: 2) can be used for streams\
    \ where compression has been initiated\n   under the assumption that NULL encryption\
    \ was being used with ESP.\n   When it becomes obvious that an encryption algorithm\
    \ other than NULL\n   is being used, the compressor may send an IR-DYN according\
    \ to 2) to\n   switch to profile 0x0003 without having to send an IR packet.\n"
- title: 5.12.2.  Packet types
  contents:
  - "5.12.2.  Packet types\n   The packet types for ROHC ESP are the same as for ROHC\
    \ UDP, except\n   that the ESP sequence number is used instead of the generated\n\
    \   sequence number of ROHC UDP.  The ESP header is not part of any\n   compressed\
    \ list in ROHC ESP.\n"
- title: 6.  Implementation issues
  contents:
  - "6.  Implementation issues\n   This document specifies mechanisms for the protocol\
    \ and leaves many\n   details on the use of these mechanisms to the implementers.\
    \  This\n   chapter is aimed to give guidelines, ideas and suggestions for\n \
    \  implementing the scheme.\n"
- title: 6.1.  Reverse decompression
  contents:
  - "6.1.  Reverse decompression\n   This section describes an OPTIONAL decompressor\
    \ operation to reduce\n   the number of packets discarded due to an invalid context.\n\
    \   Once a context becomes invalid (e.g., when more consecutive packet\n   losses\
    \ than expected have occurred), subsequent compressed packets\n   cannot immediately\
    \ be decompressed correctly.  Reverse decompression\n   aims at decompressing\
    \ such packets later instead of discarding them,\n   by storing them until the\
    \ context has been updated and validated and\n   then attempting decompression.\n\
    \   Let the sequence of stored packets be i, i + 1, ..., i + k, where i\n   is\
    \ the first packet and i + k is the last packet before the context\n   was updated.\
    \  The decompressor will attempt to recover the stored\n   packets in reverse\
    \ order, i.e., starting with i + k, and working back\n   toward i.  When a stored\
    \ packet has been reconstructed, its\n   correctness is verified using its CRC.\
    \  Packets not carrying a CRC\n   must not be delivered to upper layers.  Packets\
    \ where the CRC\n   succeeds are delivered to upper layers in their original order,\
    \ i.e.,\n   i, i + 1, ..., i + k.\n   Note that this reverse decompression introduces\
    \ buffering while\n   waiting for the context to be validated and thereby introduces\n\
    \   additional delay.  Thus, it should be used only when some amount of\n   delay\
    \ is acceptable.  For example, for video packets belonging to the\n   same video\
    \ frame, the delay in packet arrivals does not cause\n   presentation time delay.\
    \  Delay-insensitive streaming applications\n   can also be tolerant of such delay.\
    \  If the decompressor cannot\n   determine whether the application can tolerate\
    \ delay, it should not\n   perform reverse decompression.\n   The following illustrates\
    \ the decompression procedure in some detail:\n   1. The decompressor stores compressed\
    \ packets that cannot be\n      decompressed correctly due to an invalid context.\n\
    \   2. When the decompressor has received a context updating packet and\n    \
    \  the context has been validated, it proceeds to recover the last\n      packet\
    \ stored.  After decompression, the decompressor checks the\n      correctness\
    \ of the reconstructed header using the CRC.\n   3. If the CRC indicates successful\
    \ decompression, the decompressor\n      stores the complete packet and attempts\
    \ to decompress the\n      preceding packet.  In this way, the stored packets\
    \ are recovered\n      in reverse order until no compressed packets are left.\
    \  For each\n      packet, the decompressor checks the correctness of the\n  \
    \    decompressed headers using the header compression CRC.\n   4. If the CRC\
    \ indicates an incorrectly decompressed packet, the\n      reverse decompression\
    \ attempt MUST be terminated and all remaining\n      uncompressed packets MUST\
    \ be discarded.\n   5. Finally, the decompressor forwards all the correctly decompressed\n\
    \      packets to upper layers in their original order.\n"
- title: 6.2.  RTCP
  contents:
  - "6.2.  RTCP\n   RTCP is the RTP Control Protocol [RTP].  RTCP is based on periodic\n\
    \   transmission of control packets to all participants in a session,\n   using\
    \ the same distribution mechanism as for data packets.  Its\n   primary function\
    \ is to provide feedback from the data receivers on\n   the quality of the data\
    \ distribution.  The feedback information may\n   be used for issues related to\
    \ congestion control functions, and\n   directly useful for control of adaptive\
    \ encodings.\n   In an RTP session there will be two types of packet streams:\
    \ one with\n   the RTP header and application data, and one with the RTCP control\n\
    \   information.  The difference between the streams at the transport\n   level\
    \ is in the UDP port numbers: the RTP port number is always even,\n   the RTCP\
    \ port number is that number plus one and therefore always odd\n   [RTP, section\
    \ 10].  The ROHC header compressor implementation has\n   several ways at hand\
    \ to handle the RTCP stream:\n   1. One compressor/decompressor entity carrying\
    \ both types of streams\n      on the same channel, using CIDs to distinguish\
    \ between them.  For\n      sending a single RTP stream together with its RTCP\
    \ packets on one\n      channel, it is most efficient to set LARGE_CIDS to false,\
    \ send the\n      RTP packets with the implied CID 0 and use the Add-CID mechanism\n\
    \      to send the RTCP packets.\n   2. Two compressor/decompressor entities,\
    \ one for RTP and another one\n      for RTCP, carrying the two types of streams\
    \ on separate channels.\n      This means that they will not share the same CID\
    \ number space.\n   RTCP headers may simply be sent uncompressed using profile\
    \ 0x0000.\n   More efficiently, ROHC UDP compression (profile 0x0002) can be used.\n"
- title: 6.3.  Implementation parameters and signals
  contents:
  - "6.3.  Implementation parameters and signals\n   A ROHC implementation may have\
    \ two kinds of parameters: configuration\n   parameters that are mandatory and\
    \ must be negotiated between\n   compressor and decompressor peers, and implementation\
    \ parameters that\n   are optional and, when used, stipulate how a ROHC implementation\
    \ is\n   to operate.\n   Configuration parameters are mandatory and must be negotiated\
    \ between\n   compressor and decompressor, so that they have the same values at\n\
    \   both compressor and decompressor, see section 5.1.1.\n   Implementation parameters\
    \ make it possible for an external entity to\n   stipulate how an implementation\
    \ of a ROHC compressor or decompressor\n   should operate.  Implementation parameters\
    \ have local significance,\n   are optional to use and are thus not necessary\
    \ to negotiate between\n   compressor and decompressor.  Note that this does not\
    \ preclude\n   signaling or negotiating implementation parameters using lower\
    \ layer\n   functionality in order to set the way a ROHC implementation should\n\
    \   operate.  Some implementation parameters are valid only at either of\n   compressor\
    \ or decompressor.  Implementation parameters may further be\n   divided into\
    \ parameters that allow an external entity to describe the\n   way the implementation\
    \ should operate and parameters that allow an\n   external entity to trigger a\
    \ specific event, i.e., signals.\n"
- title: 6.3.1.  ROHC implementation parameters at compressor
  contents:
  - "6.3.1.  ROHC implementation parameters at compressor\n   CONTEXT_REINITIALIZATION\
    \ -- signal\n   This parameter triggers a reinitialization of the entire context\
    \ at\n   the decompressor, both the static and the dynamic part.  The\n   compressor\
    \ MUST, when CONTEXT_REINITIALIZATION is triggered, back off\n   to the IR state\
    \ and fully reinitialize the context by sending IR\n   packets with both the static\
    \ and dynamic chains covering the entire\n   uncompressed headers until it is\
    \ reasonably confident that the\n   decompressor contexts are reinitialized. \
    \ The context\n   reinitialization MUST be done for all contexts at the compressor.\n\
    \   This parameter may for instance be used to do context relocation at,\n   e.g.,\
    \ a cellular handover that results in a change of compression\n   point in the\
    \ radio access network.\n   NO_OF_PACKET_SIZES_ALLOWED -- value: positive integer\n\
    \   This parameter may be set by an external entity to specify the number\n  \
    \ of packet sizes a ROHC implementation may use.  However, the\n   parameter may\
    \ be used only if PACKET_SIZES is not used by an external\n   entity.  With this\
    \ parameter set, the ROHC implementation at the\n   compressor MUST NOT use more\
    \ different packet sizes than the value\n   this parameter stipulates.  The ROHC\
    \ implementation must itself be\n   able to determine which packet sizes will\
    \ be used and describe these\n   to an external entity using PACKET_SIZES_USED.\
    \  It should be noted\n   that one packet size might be used for several header\
    \ formats, and\n   that the number of packet sizes can be reduced by employing\
    \ padding\n   and segmentation.\n   NO_OF_PACKET_SIZES_USED _- value: positive\
    \ integer\n   This parameter is set by the ROHC implementation to indicate how\
    \ many\n   packet sizes it will actually use.  It can be set to a large value\
    \ to\n   indicate that no particular attempt is made to minimize that number.\n\
    \   PACKET_SIZES_ALLOWED -- value: list of positive integers (bytes)\n   This\
    \ parameter, if set, governs which packet sizes in bytes may be\n   used by the\
    \ ROHC implementation.  Thus, packet sizes not in the set\n   of values for this\
    \ parameter MUST NOT be used.  Hence, an external\n   entity can mandate a ROHC\
    \ implementation to produce packet sizes that\n   fit pre-configured lower layers\
    \ better.  If this parameter is used to\n   stipulate which packet sizes a ROHC\
    \ implementation can use, the\n   following rules apply:\n   - A packet large\
    \ enough to hold the entire IR header (both static and\n     dynamic chain) MUST\
    \ be part of the set of sizes, unless MRRU is set\n     to a large enough value\
    \ to allow segmentation.\n   - The packet size likely to be used most frequently\
    \ in the SO state\n     SHOULD be part of the set.\n   - The packet size likely\
    \ to be used most frequently in the FO state\n     SHOULD be part of the set.\n\
    \   PACKET_SIZES_USED -- values: set of positive integers (bytes)\n   This parameter\
    \ describes which packet sizes a ROHC implementation\n   uses if NO_OF_PACKET_SIZES_ALLOWED\
    \ or PACKET_SIZES_ALLOWED is used by\n   an external entity to stipulate how many\
    \ packet sizes a ROHC\n   implementation should use.  The information about used\
    \ packet sizes\n   (bytes) in this parameter, may then be used to configure lower\n\
    \   layers.\n   PAYLOAD_SIZES -_ values: set of positive integer values (bytes)\n\
    \   This parameter is set by an external entity that wants to make use of\n  \
    \ the PACKET_SIZES_USED parameter to indicate which payload sizes can\n   be expected.\n\
    \   When a ROHC implementation has a limited set of allowed packet sizes,\n  \
    \ and the most preferable header format has a size that is not part of\n   the\
    \ set, it has the following options:\n   - Choose the next larger header format\
    \ from the allowed set.  This is\n     probably the most efficient choice.\n \
    \  - Use the most preferable header format as if there were no\n     restrictions\
    \ on size, and then add padding octets to complete a\n     packet of the next\
    \ larger size in the allowed set.\n   - Use segmentation to fragment the packet\
    \ into pieces that would make\n     up packets of sizes that are permissible (possibly\
    \ after the\n     addition of padding to the last segment).\n   It should be noted\
    \ that even if the two last parameters introduce the\n   possibility of restricting\
    \ the number of packet sizes used, such\n   restrictions will have a negative\
    \ impact on compression performance.\n"
- title: 6.3.2.  ROHC implementation parameters at decompressor
  contents:
  - "6.3.2.  ROHC implementation parameters at decompressor\n   MODE -- values: [U-mode,\
    \ O-mode, R-mode]\n   This parameter triggers a mode transition using the mechanism\n\
    \   described in chapter 5 when the parameter changes value, i.e., to U-\n   mode\
    \ (Unidirectional mode), O-mode (Bidirectional Optimistic mode) or\n   R-mode\
    \ (Bidirectional Reliable mode).  The mode transition is made\n   from the current\
    \ mode to the new mode as signaled by the\n   implementation parameter.  For example,\
    \ if the current mode is\n   Bidirectional Optimistic mode, MODE should have the\
    \ value O-mode.  If\n   the MODE is changed to R-mode, a mode transition MUST\
    \ be made from\n   Bidirectional Optimistic mode to Bidirectional Reliable mode.\
    \  MODE\n   should not only serve as a trigger for mode transitions, but also\n\
    \   make it visible which mode ROHC operates in.\n   CLOCK_RESOLUTION -- value:\
    \ nonnegative integer\n   This parameter indicates the system clock resolution\
    \ in units of\n   milliseconds.  A zero (0) value means that there is no clock\n\
    \   available.  If nonzero, this parameter allows the decompressor to use\n  \
    \ timer-based TS compression (section 4.5.4) and SN wraparound\n   detection (section\
    \ 5.3.2.2.4).  In this case, its specific value is\n   also significant for correctness\
    \ of the algorithms.\n   REVERSE_DECOMPRESSION_DEPTH -- value: nonnegative integer\n\
    \   This parameter determines whether reverse decompression as described\n   in\
    \ section 6.1 should be used or not, and if used, to what extent.\n   The value\
    \ indicates the maximum number of packets that can be\n   buffered, and thus possibly\
    \ be reverse decompressed by the\n   decompressor.  A zero (0) value means that\
    \ reverse decompression MUST\n   NOT be used.\n"
- title: 6.4.  Handling of resource limitations at the decompressor
  contents:
  - "6.4.  Handling of resource limitations at the decompressor\n   In a point-to-point\
    \ link, the two nodes can agree on the number of\n   compressed sessions they\
    \ are prepared to support for this link.  It\n   may, however, not be possible\
    \ for the decompressor to accurately\n   predict when it will run out of resources.\
    \  ROHC allows the\n   negotiated number of contexts to be larger than could be\
    \ accommodated\n   in the worst case.  Then, as context resources are consumed,\
    \ an\n   attempt to set up a new context may be rejected by the decompressor,\n\
    \   using the REJECT option of the feedback payload.\n   Upon reception of a REJECT\
    \ option, the compressor SHOULD wait for a\n   while before attempting to compress\
    \ additional streams destined for\n   the rejecting node.\n"
- title: 6.5.  Implementation structures
  contents:
  - "6.5.  Implementation structures\n   This section provides some explanatory material\
    \ on data structures\n   that a ROHC implementation will have to maintain in one\
    \ form or\n   another.  It is not intended to constrain the implementations.\n"
- title: 6.5.1.  Compressor context
  contents:
  - "6.5.1.  Compressor context\n   The compressor context consists of a static part\
    \ and a dynamic part.\n   The content of the static part is the same as the static\
    \ chain\n   defined in section 5.7.7.  The dynamic part consists of multiple\n\
    \   elements which can be categorized into four types.\n   a) Sliding Window (SW)\n\
    \   b) Translation Table (TT)\n   c) Flag\n   d) Field\n   These elements may\
    \ be common to all modes or mode specific.  The\n   following table summarizes\
    \ all these elements.\n   +--------+---------------------------+-------------+----------------+\n\
    \   |        |         Common to         | Specific to |  Specific to   |\n  \
    \ |        |         all modes         |   R-mode    |    U/O-mode    |\n   +--------+---------------------------+-------------+----------------+\n\
    \   | SWs    | GSW                       | R_CSW       | UO_CSW         |\n  \
    \ |        |                           | R_IESW      | UO_IESW        |\n   +--------+---------------------------+-------------+----------------+\n\
    \   | TTs    |                           | R_CTT       | UO_CTT         |\n  \
    \ |        |                           | R_IETT      | UO_IETT        |\n   +--------+---------------------------+-------------+----------------+\n\
    \   | Flags  | UDP Chksum                |             | ACKED          |\n  \
    \ |        | TSS, TIS                  |             |                |\n   |\
    \        | RND, RND2                 |             |                |\n   |  \
    \      | NBO, NBO2                 |             |                |\n   +--------+---------------------------+-------------+----------------+\n\
    \   | Fields | Profile                   |             | CSRC_REF_ID    |\n  \
    \ |        | C_MODE                    |             | CSRC_GEN_ID    |\n   |\
    \        | C_STATE                   |             | CSRC_GEN_COUNT |\n   |  \
    \      | C_TRANS                   |             | IPEH_REF_ID    |\n   |    \
    \    | TS_STRIDE (if TSS = 1)    |             | IPEH_GEN_ID    |\n   |      \
    \  | TS_OFFSET (if TSS = 1)    |             | IPEH_GEN_COUNT |\n   |        |\
    \ TIME_STRIDE (if TIS = 1)  |             |                |\n   |        | CURR_TIME\
    \ (if TIS = 1)    |             |                |\n   |        | MAX_JITTER_CD\
    \ (if TIS = 1)|             |                |\n   |        | LONGEST_LOSS_EVENT(O)\
    \     |             |                |\n   |        | CLOCK_RESOLUTION(O)    \
    \   |             |                |\n   |        | MAX_JITTER(O)            \
    \ |             |                |\n   +--------+---------------------------+-------------+----------------+\n\
    \   1) GSW: Generic W_LSB Sliding Window\n      Each element in GSW consists of\
    \ all the dynamic fields in the\n      dynamic chain (defined in section 5.7.7)\
    \ plus the fields specified\n      in a) but excluding the fields specified in\
    \ b).\n      a) Packet Arrival Time (if TIS = 1)\n         Scaled RTP Time Stamp\
    \ (if TSS = 1) (optional)\n         Offset_i (if RND = 0) (optional)\n      b)\
    \ UDP Checksum, TS Stride, CSRC list, IPv6 Extension Headers\n   2) R_CSW: CSRC\
    \ Sliding Window in R-mode\n      R_IESW: IPv6 Extension Header Sliding Window\
    \ in R-mode\n      UO_CSW: CSRC Sliding Window in U/O-mode\n      UO_IESW: IPv6\
    \ Extension Header Sliding Window in U/O-mode\n      Each element in R_CSW, R_IESW,\
    \ UO_CSW and UO_IESW is defined in\n      section 6.5.3.\n   3) R_CTT: CSRC Translation\
    \ Table in R-mode\n      R_IETT: IPv6 Extension Header Translation Table in U/O-mode\n\
    \      UO_CTT: CSRC Translation Table in U/O-mode\n      UO_IETT: IPv6 Extension\
    \ Header Translation Table in U/O-mode\n      Each element in R_CTT and R_IETT\
    \ is defined in section 5.8.1.1.\n      Each element in UO_CTT and UO_IETT is\
    \ defined in section 5.8.1.2.\n   4) ACKED: Indicates whether or not the decompressor\
    \ has ever acked\n   5) CURR_TIME: The current time value (used for context relocation\n\
    \      when timer-based timestamp compression is used)\n   6) All the other flags\
    \ and fields are defined elsewhere in the ROHC\n      document.\n"
- title: 6.5.2.  Decompressor context
  contents:
  - "6.5.2.  Decompressor context\n   The decompressor context consists of a static\
    \ part and a dynamic\n   part.  The content of the static part is the same as\
    \ the static chain\n   defined in section 5.7.7.  The dynamic part consists of\
    \ multiple\n   elements, one of which is the nonstatic reference header that\n\
    \   includes all the nonstatic fields.  These nonstatic fields are the\n   fields\
    \ in the dynamic chain defined in section 5.7.7, excluding UDP\n   Checksum and\
    \ TS_Stride.  All the remaining elements can be\n   categorized into four types:\n\
    \   a) Sliding Window (SW)\n   b) Translation Table (TT)\n   d) Flag\n   e) Field\n\
    \   These elements may be mode specific or common to all modes.  The\n   following\
    \ table summarizes all these elements.\n   +--------+---------------------------+-------------+----------------+\n\
    \   |        |       Common to           | Specific to |   Specific to  |\n  \
    \ |        |       all modes           |    R-mode   |     U/O-mode   |\n   +--------+---------------------------+-------------+----------------+\n\
    \   | SWs    |                           | R_CSW       | UO_CSW         |\n  \
    \ |        |                           | R_IESW      | UO_IESW        |\n   +--------+---------------------------+-------------+----------------+\n\
    \   | TTs    |                           | R_CTT       | UO_CTT         |\n  \
    \ |        |                           | R_IETT      | UO_IETT        |\n   +--------+---------------------------+-------------+----------------+\n\
    \   | Flags  | UDP Checksum              |             | ACKED          |\n  \
    \ |        | TSS, TIS                  |             |                |\n   |\
    \        | RND, RND2                 |             |                |\n   |  \
    \      | NBO, NBO2                 |             |                |\n   +--------+---------------------------+-------------+----------------+\n\
    \   | Fields | Profile                   |             | CSRC_GEN_ID    |\n  \
    \ |        | D_MODE                    |             | IPEH_GEN_ID    |\n   |\
    \        | D_STATE                   |             | PRE_SN_V_REF   |\n   |  \
    \      | D_TRANS                   |             |                |\n   |    \
    \    | TS_STRIDE (if TSS = 1)    |             |                |\n   |      \
    \  | TS_OFFSET (if TSS = 1)    |             |                |\n   |        |\
    \ TIME_STRIDE (if TIS = 1)  |             |                |\n   |        | PKT_ARR_TIME\
    \ (if TIS = 1) |             |                |\n   |        | LONGEST_LOSS_EVENT(O)\
    \     |             |                |\n   |        | CLOCK_RESOLUTION(O)    \
    \   |             |                |\n   |        | MAX_JITTER(O)            \
    \ |             |                |\n   +--------+---------------------------+-------------+----------------+\n\
    \   1) ACKED: Indicates whether or not ACK has ever been sent.\n   2) PKT_ARR_TIME:\
    \ The arrival time of the packet that most recently\n      decompressed and verified\
    \ using CRC.\n      PRE_SN_V_REF: The sequence number of the packet verified before\n\
    \      the most recently verified packet.\n      CSRC_GEN_ID: The CSRC gen_id\
    \ of the most recently received packet.\n      IPEH_GEN_ID: The IPv6 Extension\
    \ Header gen_id of the most recently\n      received packet.\n   3) The remaining\
    \ elements are as defined in the compressor context.\n"
- title: '6.5.3.  List compression: Sliding windows in R-mode and U/O-mode'
  contents:
  - "6.5.3.  List compression: Sliding windows in R-mode and U/O-mode\n   In R-mode\
    \ list compression (see section 5.8.2.1), each entry in the\n   sliding window,\
    \ both at the compressor side and at the decompressor\n   side, has the following\
    \ structure:\n   +---------------------+--------+------------+\n   | RTP Sequence\
    \ Number | icount | index list |\n   +---------------------+--------+------------+\n\
    \   The table index list contains a list of index.  Each of these index\n   corresponds\
    \ to the item in the original list carried in the packet\n   identified by the\
    \ RTP Sequence Number.  The mapping between the index\n   and the item is identified\
    \ in the translation table.  The icount\n   field carries the number of index\
    \ in the following index list.\n   In U/O-mode list compression, each entry in\
    \ the sliding window at\n   both the compressor side and decompressor side has\
    \ the following\n   structure.\n   +--------+--------+------------+\n   | Gen_id\
    \ | icount | index list |\n   +--------+--------+------------+\n   The icount\
    \ and index list fields are the same as defined in R-mode.\n   Instead of using\
    \ the RTP Sequence Number to identify each entry, the\n   Gen_id is included in\
    \ the sliding window in U/O-mode.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   Because encryption eliminates the redundancy\
    \ that header compression\n   schemes try to exploit, there is some inducement\
    \ to forego encryption\n   of headers in order to enable operation over low-bandwidth\
    \ links.\n   However, for those cases where encryption of data (and not headers)\n\
    \   is sufficient, RTP does specify an alternative encryption method in\n   which\
    \ only the RTP payload is encrypted and the headers are left in\n   the clear.\
    \  That would still allow header compression to be applied.\n   ROHC compression\
    \ is transparent with regard to the RTP Sequence\n   Number and RTP Timestamp\
    \ fields, so the values of those fields can be\n   used as the basis of payload\
    \ encryption schemes (e.g., for\n   computation of an initialization vector).\n\
    \   A malfunctioning or malicious header compressor could cause the\n   header\
    \ decompressor to reconstitute packets that do not match the\n   original packets\
    \ but still have valid IP, UDP and RTP headers and\n   possibly also valid UDP\
    \ checksums.  Such corruption may be detected\n   with end-to-end authentication\
    \ and integrity mechanisms which will\n   not be affected by the compression.\
    \  Moreover, this header\n   compression scheme uses an internal checksum for\
    \ verification of\n   reconstructed headers.  This reduces the probability of\
    \ producing\n   decompressed headers not matching the original ones without this\n\
    \   being noticed.\n   Denial-of-service attacks are possible if an intruder can\
    \ introduce\n   (for example) bogus STATIC, DYNAMIC or FEEDBACK packets onto the\
    \ link\n   and thereby cause compression efficiency to be reduced.  However, an\n\
    \   intruder having the ability to inject arbitrary packets at the link\n   layer\
    \ in this manner raises additional security issues that dwarf\n   those related\
    \ to the use of header compression.\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   The ROHC profile identifier is a non-negative integer.\
    \ In many\n   negotiation protocols, it will be represented as a 16-bit value.\
    \  Due\n   to the way the profile identifier is abbreviated in ROHC packets, the\n\
    \   8 least significant bits of the profile identifier have a special\n   significance:\
    \ Two profile identifiers with identical 8 LSBs should be\n   assigned only if\
    \ the higher-numbered one is intended to supersede the\n   lower-numbered one.\
    \  To highlight this relationship, profile\n   identifiers should be given in\
    \ hexadecimal (as in 0x1234, which would\n   for example supersede 0x0A34).\n\
    \   Following the policies outlined in [IANA-CONSIDERATIONS], the IANA\n   policy\
    \ for assigning new values for the profile identifier shall be\n   Specification\
    \ Required: values and their meanings must be documented\n   in an RFC or in some\
    \ other permanent and readily available reference,\n   in sufficient detail that\
    \ interoperability between independent\n   implementations is possible.  In the\
    \ 8 LSBs, the range 0 to 127 is\n   reserved for IETF standard-track specifications;\
    \ the range 128 to 254\n   is available for other specifications that meet this\
    \ requirement\n   (such as Informational RFCs).  The LSB value 255 is reserved\
    \ for\n   future extensibility of the present specification.\n   The following\
    \ profile identifiers are already allocated:\n   Profile     Document       Usage\n\
    \   identifier\n   0x0000      RFCthis        ROHC uncompressed\n   0x0001   \
    \   RFCthis        ROHC RTP\n   0x0002      RFCthis        ROHC UDP\n   0x0003\
    \      RFCthis        ROHC ESP\n"
- title: 9.  Acknowledgments
  contents:
  - "9.  Acknowledgments\n   Earlier header compression schemes described in [CJHC],\
    \ [IPHC], and\n   [CRTP] have been important sources of ideas and knowledge.\n\
    \   The editor would like to extend his warmest thanks to Mikael\n   Degermark,\
    \ who actually did a lot of the editing work, and Peter\n   Eriksson, who made\
    \ a copy editing pass through the document,\n   significantly increasing its editorial\
    \ consistency.  Of course, all\n   remaining editorial problems have then been\
    \ inserted by the editor.\n   Thanks to Andreas Jonsson (Lulea University), who\
    \ supported this work\n   by his study of header field change patterns.\n   Finally,\
    \ this work would not have succeeded without the continual\n   advice in navigating\
    \ the IETF standards track, garnished with both\n   editorial and technical comments,\
    \ from the IETF transport area\n   directors, Allison Mankin and Scott Bradner.\n"
- title: 10.  Intellectual Property Right Claim Considerations
  contents:
  - "10.  Intellectual Property Right Claim Considerations\n   The IETF has been notified\
    \ of intellectual property rights claimed in\n   regard to some or all of the\
    \ specification contained in this\n   document.  For more information consult\
    \ the online list of claimed\n   rights.\n   The IETF takes no position regarding\
    \ the validity or scope of any\n   intellectual property or other rights that\
    \ might be claimed to\n   pertain to the implementation or use of the technology\
    \ described in\n   this document or the extent to which any license under such\
    \ rights\n   might or might not be available; neither does it represent that it\n\
    \   has made any effort to identify any such rights.  Information on the\n   IETF's\
    \ procedures with respect to rights in standards-track and\n   standards-related\
    \ documentation can be found in BCP-11.  Copies of\n   claims of rights made available\
    \ for publication and any assurances of\n   licenses to be made available, or\
    \ the result of an attempt made to\n   obtain a general license or permission\
    \ for the use of such\n   proprietary rights by implementors or users of this\
    \ specification can\n   be obtained from the IETF Secretariat.\n   The IETF invites\
    \ any interested party to bring to its attention any\n   copyrights, patents or\
    \ patent applications, or other proprietary\n   rights which may cover technology\
    \ that may be required to practice\n   this standard.  Please address the information\
    \ to the IETF Executive\n   Director.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [UDP]                 Postel, J., \"User Datagram\
    \ Protocol\", STD 6,\n                         RFC 768, August 1980.\n   [IPv4]\
    \                Postel, J.,  \"Internet Protocol\", STD 5, RFC\n            \
    \             791, September 1981.\n   [IPv6]                Deering, S. and R.\
    \ Hinden, \"Internet Protocol,\n                         Version 6 (IPv6) Specification\"\
    , RFC 2460,\n                         December 1998.\n   [RTP]               \
    \  Schulzrinne, H., Casner, S., Frederick, R. and\n                         V.\
    \  Jacobson, \"RTP: A Transport Protocol for\n                         Real-Time\
    \ Applications\", RFC 1889, January\n                         1996.\n   [HDLC]\
    \                Simpson, W., \"PPP in HDLC-like framing\", STD\n            \
    \             51, RFC 1662, July 1994.\n   [ESP]                 Kent, S. and\
    \ R. Atkinson, \"IP Encapsulating\n                         Security Payload\"\
    , RFC 2406, November 1998.\n   [NULL]                Glenn, R. and S. Kent, \"\
    The NULL Encryption\n                         Algorithm and Its Use With Ipsec\"\
    , RFC 2410,\n                         November 1998.\n   [AH]                \
    \  Kent, S. and R. Atkinson, \"IP Authentication\n                         Header\"\
    , RFC 2402, November 1998.\n   [MINE]                Perkins, C., \"Minimal Encapsulation\
    \ within IP\",\n                         RFC 2004, October 1996.\n   [GRE1]  \
    \              Farinacci, D., Li, T., Hanks, S., Meyer, D. and\n             \
    \            P. Traina, \"Generic Routing Encapsulation\n                    \
    \     (GRE)\", RFC 2784, March 2000.\n   [GRE2]                Dommety, G., \"\
    Key and Sequence Number\n                         Extensions to GRE\", RFC 2890,\
    \ August 2000.\n   [ASSIGNED]            Reynolds, J. and J. Postel, \"Assigned\
    \ Numbers\",\n                         STD 2, RFC 1700, October 1994.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [VJHC]                Jacobson, V., \"Compressing\
    \ TCP/IP Headers for\n                         Low-Speed Serial Links\", RFC 1144,\
    \ February\n                         1990.\n   [IPHC]                Degermark,\
    \ M., Nordgren, B. and S. Pink, \"IP\n                         Header Compression\"\
    , RFC 2507, February 1999.\n   [CRTP]                Casner, S. and V. Jacobson,\
    \ \"Compressing\n                         IP/UDP/RTP Headers for Low-Speed Serial\
    \ Links\",\n                         RFC 2508, February 1999.\n   [CRTPC]    \
    \           Degermark, M., Hannu, H., Jonsson, L.E.,\n                       \
    \  Svanbro, K., \"Evaluation of CRTP Performance\n                         over\
    \ Cellular Radio Networks\", IEEE Personal\n                         Communication\
    \ Magazine, Volume 7, number 4, pp.\n                         20-25, August 2000.\n\
    \   [REQ]                 Degermark, M., \"Requirements for robust\n         \
    \                IP/UDP/RTP header compression\", RFC 3096, June\n           \
    \              2001.\n   [LLG]                 Svanbro, K., \"Lower Layer Guidelines\
    \ for Robust\n                         RTP/UDP/IP Header Compression\", Work in\n\
    \                         Progress.\n   [IANA-CONSIDERATIONS] Alvestrand, H. and\
    \ T. Narten, \"Guidelines for\n                         Writing an IANA Considerations\
    \ Section in\n                         RFCs\", BCP 26, RFC 2434, October 1998.\n"
- title: 12.  Authors' Addresses
  contents:
  - "12.  Authors' Addresses\n   Carsten Bormann, Editor\n   Universitaet Bremen TZI\n\
    \   Postfach 330440\n   D-28334 Bremen, Germany\n   Phone: +49 421 218 7024\n\
    \   Fax:   +49 421 218 7000\n   EMail: cabo@tzi.org\n   Carsten Burmeister\n \
    \  Panasonic European Laboratories GmbH\n   Monzastr. 4c\n   63225 Langen, Germany\n\
    \   Phone: +49-6103-766-263\n   Fax:   +49-6103-766-166\n   EMail: burmeister@panasonic.de\n\
    \   Mikael Degermark\n   The University of Arizona\n   Dept of Computer Science\n\
    \   P.O. Box 210077\n   Tucson, AZ 85721-0077, USA\n   Phone: +1 520 621-3498\n\
    \   Fax:   +1 520 621-4642\n   EMail: micke@cs.arizona.edu\n   Hideaki Fukushima\n\
    \   Matsushita Electric Industrial Co.,\n   Ltd006, Kadoma, Kadoma City,\n   Osaka,\
    \ Japan\n   Phone: +81-6-6900-9192\n   Fax:   +81-6-6900-9193\n   EMail: fukusima@isl.mei.co.jp\n\
    \   Hans Hannu\n   Box 920\n   Ericsson Erisoft AB\n   SE-971 28 Lulea, Sweden\n\
    \   Phone: +46 920 20 21 84\n   Fax:   +46 920 20 20 99\n   EMail: hans.hannu@ericsson.com\n\
    \   Lars-Erik Jonsson\n   Box 920\n   Ericsson Erisoft AB\n   SE-971 28 Lulea,\
    \ Sweden\n   Phone: +46 920 20 21 07\n   Fax:   +46 920 20 20 99\n   EMail: lars-erik.jonsson@ericsson.com\n\
    \   Rolf Hakenberg\n   Panasonic European Laboratories GmbH\n   Monzastr. 4c\n\
    \   63225 Langen, Germany\n   Phone: +49-6103-766-162\n   Fax:   +49-6103-766-166\n\
    \   EMail: hakenberg@panasonic.de\n   Tmima Koren\n   Cisco Systems, Inc.\n  \
    \ 170 West Tasman Drive\n   San Jose, CA  95134, USA\n   Phone: +1 408-527-6169\n\
    \   EMail: tmima@cisco.com\n   Khiem Le\n   2-700\n   Mobile Networks Laboratory\n\
    \   Nokia Research Center\n   6000 Connection Drive\n   Irving, TX 75039, USA\n\
    \   Phone: +1-972-894-4882\n   Fax:   +1 972 894-4589\n   EMail: khiem.le@nokia.com\n\
    \   Zhigang Liu\n   2-700\n   Mobile Networks Laboratory\n   Nokia Research Center\n\
    \   6000 Connection Drive\n   Irving, TX 75039, USA\n   Phone: +1 972 894-5935\n\
    \   Fax:   +1 972 894-4589\n   EMail: zhigang.liu@nokia.com\n   Anton Martensson\n\
    \   Ericsson Radio Systems AB\n   Torshamnsgatan 23\n   SE-164 80 Stockholm, Sweden\n\
    \   Phone: +46 8 404 3881\n   Fax:   +46 8 757 5550\n   EMail: anton.martensson@era.ericsson.se\n\
    \   Akihiro Miyazaki\n   Matsushita Electric Industrial Co., Ltd\n   1006, Kadoma,\
    \ Kadoma City, Osaka, Japan\n   Phone: +81-6-6900-9192\n   Fax:   +81-6-6900-9193\n\
    \   EMail: akihiro@isl.mei.co.jp\n   Krister Svanbro\n   Box 920\n   Ericsson\
    \ Erisoft AB\n   SE-971 28 Lulea, Sweden\n   Phone: +46 920 20 20 77\n   Fax:\
    \   +46 920 20 20 99\n   EMail: krister.svanbro@ericsson.com\n   Thomas Wiebke\n\
    \   Panasonic European Laboratories GmbH\n   Monzastr. 4c\n   63225 Langen, Germany\n\
    \   Phone: +49-6103-766-161\n   Fax:   +49-6103-766-166\n   EMail: wiebke@panasonic.de\n\
    \   Takeshi Yoshimura\n   NTT DoCoMo, Inc.\n   3-5, Hikarinooka\n   Yokosuka,\
    \ Kanagawa, 239-8536, Japan\n   Phone: +81-468-40-3515\n   Fax:   +81-468-40-3788\n\
    \   EMail: yoshi@spg.yrp.nttdocomo.co.jp\n   Haihong Zheng\n   2-700\n   Mobile\
    \ Networks Laboratory\n   Nokia Research Center\n   6000 Connection Drive\n  \
    \ Irving, TX 75039, USA\n   Phone: +1 972 894-4232\n   Fax:   +1 972 894-4589\n\
    \   EMail: haihong.zheng@nokia.com\n"
- title: Appendix A.  Detailed classification of header fields
  contents:
  - "Appendix A.  Detailed classification of header fields\n   Header compression\
    \ is possible thanks to the fact that most header\n   fields do not vary randomly\
    \ from packet to packet.  Many of the\n   fields exhibit static behavior or change\
    \ in a more or less\n   predictable way.  When designing a header compression\
    \ scheme, it is\n   of fundamental importance to understand the behavior of the\
    \ fields in\n   detail.\n   In this appendix, all IP, UDP and RTP header fields\
    \ are classified\n   and analyzed in two steps.  First, we have a general classification\n\
    \   in A.1 where the fields are classified on the basis of stable\n   knowledge\
    \ and assumptions.  The general classification does not take\n   into account\
    \ the change characteristics of changing fields because\n   those will vary more\
    \ or less depending on the implementation and on\n   the application used.  A\
    \ less stable but more detailed analysis of\n   the change characteristics is\
    \ then done in A.2.  Finally, A.3\n   summarizes this appendix with conclusions\
    \ about how the various\n   header fields should be handled by the header compression\
    \ scheme to\n   optimize compression and functionality.\n"
- title: A.1.  General classification
  contents:
  - "A.1.  General classification\n   At a general level, the header fields are separated\
    \ into 5 classes:\n   INFERRED       These fields contain values that can be inferred\
    \ from\n                  other values, for example the size of the frame\n  \
    \                carrying the packet, and thus do not have to be\n           \
    \       handled at all by the compression scheme.\n   STATIC         These fields\
    \ are expected to be constant throughout\n                  the lifetime of the\
    \ packet stream.  Static information\n                  must in some way be communicated\
    \ once.\n   STATIC-DEF     STATIC fields whose values define a packet stream.\n\
    \                  They are in general handled as STATIC.\n   STATIC-KNOWN   These\
    \ STATIC fields are expected to have well-known\n                  values and\
    \ therefore do not need to be communicated\n                  at all.\n   CHANGING\
    \       These fields are expected to vary in some way:\n                  randomly,\
    \ within a limited value set or range, or in\n                  some other manner.\n\
    \   In this section, each of the IP, UDP and RTP header fields is\n   assigned\
    \ to one of these classes.  For all fields except those\n   classified as CHANGING,\
    \ the motives for the classification are also\n   stated.  In section A.2, CHANGING\
    \ fields are further examined and\n   classified on the basis of their expected\
    \ change behavior.\n"
- title: A.1.1.  IPv6 header fields
  contents:
  - "A.1.1.  IPv6 header fields\n      +---------------------+-------------+----------------+\n\
    \      | Field               | Size (bits) |    Class       |\n      +---------------------+-------------+----------------+\n\
    \      | Version             |      4      |     STATIC     |\n      | Traffic\
    \ Class       |      8      |    CHANGING    |\n      | Flow Label          |\
    \     20      |   STATIC-DEF   |\n      | Payload Length      |     16      |\
    \    INFERRED    |\n      | Next Header         |      8      |     STATIC   \
    \  |\n      | Hop Limit           |      8      |    CHANGING    |\n      | Source\
    \ Address      |    128      |   STATIC-DEF   |\n      | Destination Address |\
    \    128      |   STATIC-DEF   |\n      +---------------------+-------------+----------------+\n\
    \   Version\n      The version field states which IP version is used.  Packets\
    \ with\n      different values in this field must be handled by different IP\n\
    \      stacks.  All packets of a packet stream must therefore be of the\n    \
    \  same IP version.  Accordingly, the field is classified as STATIC.\n   Flow\
    \ Label\n      This field may be used to identify packets belonging to a specific\n\
    \      packet stream.  If not used, the value should be set to zero.\n      Otherwise,\
    \ all packets belonging to the same stream must have the\n      same value in\
    \ this field, it being one of the fields that define\n      the stream.  The field\
    \ is therefore classified as STATIC-DEF.\n   Payload Length\n      Information\
    \ about packet length (and, consequently, payload\n      length) is expected to\
    \ be provided by the link layer.  The field\n      is therefore classified as\
    \ INFERRED.\n   Next Header\n      This field will usually have the same value\
    \ in all packets of a\n      packet stream.  It encodes the type of the subsequent\
    \ header.\n      Only when extension headers are sometimes present and sometimes\n\
    \      not, will the field change its value during the lifetime of the\n     \
    \ stream.  The field is therefore classified as STATIC.\n   Source and Destination\
    \ addresses\n      These fields are part of the definition of a stream and must\
    \ thus\n      be constant for all packets in the stream.  The fields are\n   \
    \   therefore classified as STATIC-DEF.\n   Total size of the fields in each class:\n\
    \      +--------------+--------------+\n      | Class        | Size (octets)|\n\
    \      +--------------+--------------+\n      | INFERRED     |      2       |\n\
    \      | STATIC       |      1.5     |\n      | STATIC-DEF   |     34.5     |\n\
    \      | CHANGING     |      2       |\n      +--------------+--------------+\n"
- title: A.1.2.  IPv4 header fields
  contents:
  - "A.1.2.  IPv4 header fields\n      +---------------------+-------------+----------------+\n\
    \      | Field               | Size (bits) |     Class      |\n      +---------------------+-------------+----------------+\n\
    \      | Version             |      4      |     STATIC     |\n      | Header\
    \ Length       |      4      |  STATIC-KNOWN  |\n      | Type Of Service     |\
    \      8      |    CHANGING    |\n      | Packet Length       |     16      |\
    \    INFERRED    |\n      | Identification      |     16      |    CHANGING  \
    \  |\n      | Reserved flag       |      1      |  STATIC-KNOWN  |\n      | Don't\
    \ Fragment flag |      1      |     STATIC     |\n      | More Fragments flag\
    \ |      1      |  STATIC-KNOWN  |\n      | Fragment Offset     |     13     \
    \ |  STATIC-KNOWN  |\n      | Time To Live        |      8      |    CHANGING\
    \    |\n      | Protocol            |      8      |     STATIC     |\n      |\
    \ Header Checksum     |     16      |    INFERRED    |\n      | Source Address\
    \      |     32      |   STATIC-DEF   |\n      | Destination Address |     32\
    \      |   STATIC-DEF   |\n      +---------------------+-------------+----------------+\n\
    \   Version\n      The version field states which IP version is used.  Packets\
    \ with\n      different values in this field must be handled by different IP\n\
    \      stacks.  All packets of a packet stream must therefore be of the\n    \
    \  same IP version.  Accordingly, the field is classified as STATIC.\n   Header\
    \ Length\n      As long no options are present in the IP header, the header length\n\
    \      is constant and well known.  If there are options, the fields\n      would\
    \ be STATIC, but it is assumed here that there are no options.\n      The field\
    \ is therefore classified as STATIC-KNOWN.\n   Packet Length\n      Information\
    \ about packet length is expected to be provided by the\n      link layer.  The\
    \ field is therefore classified as INFERRED.\n   Flags\n      The Reserved flag\
    \ must be set to zero and is therefore classified\n      as STATIC-KNOWN.  The\
    \ Don't Fragment (DF) flag will be constant\n      for all packets in a stream\
    \ and is therefore classified as STATIC.\n      Finally, the More Fragments (MF)\
    \ flag is expected to be zero\n      because fragmentation is NOT expected, due\
    \ to the small packet\n      size expected.  The More Fragments flag is therefore\
    \ classified as\n      STATIC-KNOWN.\n   Fragment Offset\n      Under the assumption\
    \ that no fragmentation occurs, the fragment\n      offset is always zero.  The\
    \ field is therefore classified as\n      STATIC-KNOWN.\n   Protocol\n      This\
    \ field will usually have the same value in all packets of a\n      packet stream.\
    \  It encodes the type of the subsequent header.\n      Only when extension headers\
    \ are sometimes present and sometimes\n      not, will the field change its value\
    \ during the lifetime of a\n      stream.  The field is therefore classified as\
    \ STATIC.\n   Header Checksum\n      The header checksum protects individual hops\
    \ from processing a\n      corrupted header. When almost all IP header information\
    \ is\n      compressed away, there is no point in having this additional\n   \
    \   checksum; instead it can be regenerated at the decompressor side.\n      The\
    \ field is therefore classified as INFERRED.\n   Source and Destination addresses\n\
    \      These fields are part of the definition of a stream and must thus\n   \
    \   be constant for all packets in the stream.  The fields are\n      therefore\
    \ classified as STATIC-DEF.\n   Total size of the fields in each class:\n    \
    \  +--------------+----------------+\n      | Class        | Size (octets)  |\n\
    \      +--------------+----------------+\n      | INFERRED     |       4     \
    \   |\n      | STATIC       | 1 oct + 5 bits |\n      | STATIC-DEF   |       8\
    \        |\n      | STATIC-KNOWN | 2 oct + 3 bits |\n      | CHANGING     |  \
    \     4        |\n      +--------------+----------------+\n"
- title: A.1.3.  UDP header fields
  contents:
  - "A.1.3.  UDP header fields\n      +------------------+-------------+-------------+\n\
    \      | Field            | Size (bits) |    Class    |\n      +------------------+-------------+-------------+\n\
    \      | Source Port      |     16      | STATIC-DEF  |\n      | Destination Port\
    \ |     16      | STATIC-DEF  |\n      | Length           |     16      |  INFERRED\
    \   |\n      | Checksum         |     16      |  CHANGING   |\n      +------------------+-------------+-------------+\n\
    \   Source and Destination ports\n      These fields are part of the definition\
    \ of a stream and must thus\n      be constant for all packets in the stream.\
    \  The fields are\n      therefore classified as STATIC-DEF.\n   Length\n    \
    \  This field is redundant and is therefore classified as INFERRED.\n   Total\
    \ size of the fields in each class:\n      +------------+---------------+\n  \
    \    | Class      | Size (octets) |\n      +------------+---------------+\n  \
    \    | INFERRED   |       2       |\n      | STATIC-DEF |       4       |\n  \
    \    | CHANGING   |       2       |\n      +------------+---------------+\n"
- title: A.1.4.  RTP header fields
  contents:
  - "A.1.4.  RTP header fields\n      +-----------------+-------------+----------------+\n\
    \      | Field           | Size (bits) |     Class      |\n      +-----------------+-------------+----------------+\n\
    \      | Version         |      2      |  STATIC-KNOWN  |\n      | Padding   \
    \      |      1      |     STATIC     |\n      | Extension       |      1    \
    \  |     STATIC     |\n      | CSRC Counter    |      4      |    CHANGING   \
    \ |\n      | Marker          |      1      |    CHANGING    |\n      | Payload\
    \ Type    |      7      |    CHANGING    |\n      | Sequence Number |     16 \
    \     |    CHANGING    |\n      | Timestamp       |     32      |    CHANGING\
    \    |\n      | SSRC            |     32      |   STATIC-DEF   |\n      | CSRC\
    \            |   0(-480)   |    CHANGING    |\n      +-----------------+-------------+----------------+\n\
    \   Version\n      Only one working RTP version exists, namely version 2.  The\
    \ field\n      is therefore classified as STATIC-KNOWN.\n   Padding\n      The\
    \ use of this field is application-dependent, but when payload\n      padding\
    \ is used it is likely to be present in all packets.  The\n      field is therefore\
    \ classified as STATIC.\n   Extension\n      If RTP extensions are used by the\
    \ application, these extensions\n      are likely to be present in all packets\
    \ (but the use of extensions\n      is very uncommon).  However, for safety's\
    \ sake this field is\n      classified as STATIC and not STATIC-KNOWN.\n   SSRC\n\
    \      This field is part of the definition of a stream and must thus be\n   \
    \   constant for all packets in the stream.  The field is therefore\n      classified\
    \ as STATIC-DEF.\n   Total size of the fields in each class:\n      +--------------+---------------+\n\
    \      | Class        | Size (octets) |\n      +--------------+---------------+\n\
    \      | STATIC       |    2 bits     |\n      | STATIC-DEF   |      4       \
    \ |\n      | STATIC-KNOWN |    2 bits     |\n      | CHANGING     |  7.5(-67.5)\
    \   |\n      +--------------+---------------+\n"
- title: A.1.5.  Summary for IP/UDP/RTP
  contents:
  - "A.1.5.  Summary for IP/UDP/RTP\n   Summarizing this for IP/UDP/RTP one obtains\n\
    \      +----------------+----------------+----------------+\n      | Class \\\
    \ IP ver | IPv6 (octets)  | IPv4 (octets)  |\n      +----------------+----------------+----------------+\n\
    \      | INFERRED       |        4       |        6       |\n      | STATIC  \
    \       | 1 oct + 6 bits | 1 oct + 7 bits |\n      | STATIC-DEF     |       42.5\
    \     |       16       |\n      | STATIC-KNOWN   |     2 bits     | 2 oct + 5\
    \ bits |\n      | CHANGING       |   11.5(-71.5)  |   13.5(-73.5)  |\n      +----------------+----------------+----------------+\n\
    \      | Total          |    60(-120)    |    40(-100)    |\n      +----------------+----------------+----------------+\n"
- title: A.2.  Analysis of change patterns of header fields
  contents:
  - "A.2.  Analysis of change patterns of header fields\n   To design suitable mechanisms\
    \ for efficient compression of all header\n   fields, their change patterns must\
    \ be analyzed.  For this reason, an\n   extended classification is done based\
    \ on the general classification\n   in A.1, considering the fields which were\
    \ labeled CHANGING in that\n   classification.  Different applications will use\
    \ the fields in\n   different ways, which may affect their behavior.  For the\
    \ fields\n   whose behavior is variable, typical behavior for conversational audio\n\
    \   and video will be discussed.\n   The CHANGING fields are separated into five\
    \ different subclasses:\n   STATIC               These are fields that were classified\
    \ as\n                        CHANGING on a general basis, but are classified\n\
    \                        as STATIC here due to certain additional\n          \
    \              assumptions.\n   SEMISTATIC           These fields are STATIC most\
    \ of the time.\n                        However, occasionally the value changes\
    \ but\n                        reverts to its original value after a known\n \
    \                       number of packets.\n   RARELY-CHANGING (RC) These are\
    \ fields that change their values\n                        occasionally and then\
    \ keep their new values.\n   ALTERNATING          These fields alternate between\
    \ a small number\n                        of different values.\n   IRREGULAR \
    \           These, finally, are the fields for which no\n                    \
    \    useful change pattern can be identified.\n   To further expand the classification\
    \ possibilities without increasing\n   complexity, the classification can be done\
    \ either according to the\n   values of the field and/or according to the values\
    \ of the deltas for\n   the field.\n   When the classification is done, other\
    \ details are also stated\n   regarding possible additional knowledge about the\
    \ field values and/or\n   field deltas, according to the classification.  For\
    \ fields classified\n   as STATIC or SEMISTATIC, the case could be that the value\
    \ of the\n   field is not only STATIC but also well KNOWN a priori (two states\
    \ for\n   SEMISTATIC fields).  For fields with non-irregular change behavior,\n\
    \   it could be known that changes usually are within a LIMITED range\n   compared\
    \ to the maximal change for the field.  For other fields, the\n   values are completely\
    \ UNKNOWN.\n   Table A.1 classifies all the CHANGING fields on the basis of their\n\
    \   expected change patterns, especially for conversational audio and\n   video.\n\
    \   +------------------------+-------------+-------------+-------------+\n   |\
    \         Field          | Value/Delta |    Class    |  Knowledge  |\n   +========================+=============+=============+=============+\n\
    \   |             Sequential |    Delta    |    STATIC   |    KNOWN    |\n   |\
    \             -----------+-------------+-------------+-------------+\n   | IPv4\
    \ Id:    Seq. jump  |    Delta    |      RC     |   LIMITED   |\n   |        \
    \     -----------+-------------+-------------+-------------+\n   |           \
    \  Random     |    Value    |  IRREGULAR  |   UNKNOWN   |\n   +------------------------+-------------+-------------+-------------+\n\
    \   | IP TOS / Tr. Class     |    Value    |      RC     |   UNKNOWN   |\n   +------------------------+-------------+-------------+-------------+\n\
    \   | IP TTL / Hop Limit     |    Value    | ALTERNATING |   LIMITED   |\n   +------------------------+-------------+-------------+-------------+\n\
    \   |               Disabled |    Value    |    STATIC   |    KNOWN    |\n   |\
    \ UDP Checksum: ---------+-------------+-------------+-------------+\n   |   \
    \            Enabled  |    Value    |  IRREGULAR  |   UNKNOWN   |\n   +------------------------+-------------+-------------+-------------+\n\
    \   |                 No mix |    Value    |    STATIC   |    KNOWN    |\n   |\
    \ RTP CSRC Count: -------+-------------+-------------+-------------+\n   |   \
    \              Mixed  |    Value    |      RC     |   LIMITED   |\n   +------------------------+-------------+-------------+-------------+\n\
    \   | RTP Marker             |    Value    |  SEMISTATIC | KNOWN/KNOWN |\n   +------------------------+-------------+-------------+-------------+\n\
    \   | RTP Payload Type       |    Value    |      RC     |   UNKNOWN   |\n   +------------------------+-------------+-------------+-------------+\n\
    \   | RTP Sequence Number    |    Delta    |    STATIC   |    KNOWN    |\n   +------------------------+-------------+-------------+-------------+\n\
    \   | RTP Timestamp          |    Delta    |      RC     |   LIMITED   |\n   +------------------------+-------------+-------------+-------------+\n\
    \   |                 No mix |      -      |      -      |      -      |\n   |\
    \ RTP CSRC List:  -------+-------------+-------------+-------------+\n   |   \
    \              Mixed  |    Value    |      RC     |   UNKNOWN   |\n   +------------------------+-------------+-------------+-------------+\n\
    \      Table A.1 : Classification of CHANGING header fields\n   The following\
    \ subsections discuss the various header fields in\n   detail.  Note that table\
    \ A.1 and the discussions below do not\n   consider changes caused by loss or\
    \ reordering before the compression\n   point.\n"
- title: A.2.1.  IPv4 Identification
  contents:
  - "A.2.1.  IPv4 Identification\n   The Identification field (IP ID) of the IPv4\
    \ header is there to\n   identify which fragments constitute a datagram when reassembling\n\
    \   fragmented datagrams.  The IPv4 specification does not specify\n   exactly\
    \ how this field is to be assigned values, only that each\n   packet should get\
    \ an IP ID that is unique for the source-destination\n   pair and protocol for\
    \ the time the datagram (or any of its fragments)\n   could be alive in the network.\
    \  This means that assignment of IP ID\n   values can be done in various ways,\
    \ which we have separated into\n   three classes.\n   Sequential jump\n      This\
    \ is the most common assignment policy in today's IP stacks.  A\n      single\
    \ IP ID counter is used for all packet streams.  When the\n      sender is running\
    \ more than one packet stream simultaneously, the\n      IP ID can increase by\
    \ more than one between packets in a stream.\n      The IP ID values will be much\
    \ more predictable and require less\n      bits to transfer than random values,\
    \ and the packet-to-packet\n      increment (determined by the number of active\
    \ outgoing packet\n      streams and sending frequencies) will usually be limited.\n\
    \   Random\n      Some IP stacks assign IP ID values using a pseudo-random number\n\
    \      generator.  There is thus no correlation between the ID values of\n   \
    \   subsequent datagrams.  Therefore there is no way to predict the IP\n     \
    \ ID value for the next datagram.  For header compression purposes,\n      this\
    \ means that the IP ID field needs to be sent uncompressed\n      with each datagram,\
    \ resulting in two extra octets of header.  IP\n      stacks in cellular terminals\
    \ SHOULD NOT use this IP ID assignment\n      policy.\n   Sequential\n      This\
    \ assignment policy keeps a separate counter for each outgoing\n      packet stream\
    \ and thus the IP ID value will increment by one for\n      each packet in the\
    \ stream, except at wrap around.  Therefore, the\n      delta value of the field\
    \ is constant and well known a priori.\n      When RTP is used on top of UDP and\
    \ IP, the IP ID value follows\n      the RTP Sequence Number.  This assignment\
    \ policy is the most\n      desirable for header compression purposes.  However,\
    \ its usage is\n      not as common as it perhaps should be.  The reason may be\
    \ that it\n      can be realized only when UDP and IP are implemented together\
    \ so\n      that UDP, which separates packet streams by the Port\n      identification\
    \ fields, can make IP use separate ID counters for\n      each packet stream.\n\
    \      In order to avoid violating [IPv4], packets sharing the same IP\n     \
    \ address pair and IP protocol number cannot use the same IP ID\n      values.\
    \  Therefore, implementations of sequential policies must\n      make the ID number\
    \ spaces disjoint for packet streams of the same\n      IP protocol going between\
    \ the same pair of nodes.  This can be\n      done in a number of ways, all of\
    \ which introduce occasional\n      jumps, and thus makes the policy less than\
    \ perfectly sequential.\n      For header compression purposes less frequent jumps\
    \ are\n      preferred.\n   It should be noted that the ID is an IPv4 mechanism\
    \ and is therefore\n   not a problem for IPv6.  For IPv4 the ID could be handled\
    \ in three\n   different ways.  First, we have the inefficient but reliable solution\n\
    \   where the ID field is sent as-is in all packets, increasing the\n   compressed\
    \ headers by two octets.  This is the best way to handle the\n   ID field if the\
    \ sender uses random assignment of the ID field.\n   Second, there can be solutions\
    \ with more flexible mechanisms\n   requiring less bits for the ID handling as\
    \ long as sequential jump\n   assignment is used.  Such solutions will probably\
    \ require even more\n   bits if random assignment is used by the sender.  Knowledge\
    \ about the\n   sender's assignment policy could therefore be useful when choosing\n\
    \   between the two solutions above.  Finally, even for IPv4, header\n   compression\
    \ could be designed without any additional information for\n   the ID field included\
    \ in compressed headers.  To use such schemes, it\n   must be known which assignment\
    \ policy for the ID field is being used\n   by the sender.  That might not be\
    \ possible to know, which implies\n   that the applicability of such solutions\
    \ is very uncertain.  However,\n   designers of IPv4 stacks for cellular terminals\
    \ SHOULD use an\n   assignment policy close to sequential.\n"
- title: A.2.2.  IP Traffic-Class / Type-Of-Service
  contents:
  - "A.2.2.  IP Traffic-Class / Type-Of-Service\n   The Traffic-Class (IPv6) or Type-Of-Service\
    \ (IPv4) field is expected\n   to be constant during the lifetime of a packet\
    \ stream or to change\n   relatively seldom.\n"
- title: A.2.3.  IP Hop-Limit / Time-To-Live
  contents:
  - "A.2.3.  IP Hop-Limit / Time-To-Live\n   The Hop-Limit (IPv6) or Time-To-Live\
    \ (IPv4) field is expected to be\n   constant during the lifetime of a packet\
    \ stream or to alternate\n   between a limited number of values due to route changes.\n"
- title: A.2.4.  UDP Checksum
  contents:
  - "A.2.4.  UDP Checksum\n   The UDP checksum is optional.  If disabled, its value\
    \ is constantly\n   zero and could be compressed away.  If enabled, its value\
    \ depends on\n   the payload, which for compression purposes is equivalent to\
    \ it\n   changing randomly with every packet.\n"
- title: A.2.5.  RTP CSRC Counter
  contents:
  - "A.2.5.  RTP CSRC Counter\n   This is a counter indicating the number of CSRC\
    \ items present in the\n   CSRC list.  This number is expected to be almost constant\
    \ on a\n   packet- to-packet basis and change by small amounts.  As long as no\n\
    \   RTP mixer is used, the value of this field is zero.\n"
- title: A.2.6.  RTP Marker
  contents:
  - "A.2.6.  RTP Marker\n   For audio the marker bit should be set only in the first\
    \ packet of a\n   talkspurt, while for video it should be set in the last packet\
    \ of\n   every picture.  This means that in both cases the RTP marker is\n   classified\
    \ as SEMISTATIC with well-known values for both states.\n"
- title: A.2.7.  RTP Payload Type
  contents:
  - "A.2.7.  RTP Payload Type\n   Changes of the RTP payload type within a packet\
    \ stream are expected\n   to be rare.  Applications could adapt to congestion\
    \ by changing\n   payload type and/or frame sizes, but that is not expected to\
    \ happen\n   frequently.\n"
- title: A.2.8.  RTP Sequence Number
  contents:
  - "A.2.8.  RTP Sequence Number\n   The RTP Sequence Number will be incremented by\
    \ one for each packet\n   sent.\n"
- title: A.2.9.  RTP Timestamp
  contents:
  - "A.2.9.  RTP Timestamp\n   In the audio case:\n      As long as there are no pauses\
    \ in the audio stream, the RTP\n      Timestamp will be incremented by a constant\
    \ delta, corresponding\n      to the number of samples in the speech frame.  It\
    \ will thus mostly\n      follow the RTP Sequence Number.  When there has been\
    \ a silent\n      period and a new talkspurt begins, the timestamp will jump in\n\
    \      proportion to the length of the silent period.  However, the\n      increment\
    \ will probably be within a relatively limited range.\n   In the video case:\n\
    \      Between two consecutive packets, the timestamp will either be\n      unchanged\
    \ or increase by a multiple of a fixed value corresponding\n      to the picture\
    \ clock frequency.  The timestamp can also decrease\n      by a multiple of the\
    \ fixed value if B-pictures are used.  The\n      delta interval, expressed as\
    \ a multiple of the picture clock\n      frequency, is in most cases very limited.\n"
- title: A.2.10.  RTP Contributing Sources (CSRC)
  contents:
  - "A.2.10.  RTP Contributing Sources (CSRC)\n   The participants in a session, which\
    \ are identified by the CSRC\n   fields, are expected to be almost the same on\
    \ a packet-to-packet\n   basis with relatively few additions and removals.  As\
    \ long as RTP\n   mixers are not used, no CSRC fields are present at all.\n"
- title: A.3.  Header compression strategies
  contents:
  - "A.3.  Header compression strategies\n   This section elaborates on what has been\
    \ done in previous sections.\n   On the basis of the classifications, recommendations\
    \ are given on how\n   to handle the various fields in the header compression\
    \ process.\n   Seven different actions are possible; these are listed together\
    \ with\n   the fields to which each action applies.\n"
- title: A.3.1.  Do not send at all
  contents:
  - "A.3.1.  Do not send at all\n   The fields that have well known values a priori\
    \ do not have to be\n   sent at all.  These are:\n   - IPv6 Payload Length\n \
    \  - IPv4 Header Length\n   - IPv4 Reserved Flag\n   - IPv4 Last Fragment Flag\n\
    \   - IPv4 Fragment Offset\n   - UDP Checksum (if disabled)\n   - RTP Version\n"
- title: A.3.2.  Transmit only initially
  contents:
  - "A.3.2.  Transmit only initially\n   The fields that are constant throughout the\
    \ lifetime of the packet\n   stream have to be transmitted and correctly delivered\
    \ to the\n   decompressor only once.  These are:\n   - IP Version\n   - IP Source\
    \ Address\n   - IP Destination Address\n   - IPv6 Flow Label\n   - IPv4 May Fragment\
    \ Flag\n   - UDP Source Port\n   - UDP Destination Port\n   - RTP Padding Flag\n\
    \   - RTP Extension Flag\n   - RTP SSRC\n"
- title: A.3.3.  Transmit initially, but be prepared to update
  contents:
  - "A.3.3.  Transmit initially, but be prepared to update\n   The fields that are\
    \ changing only occasionally must be transmitted\n   initially but there must\
    \ also be a way to update these fields with\n   new values if they change.  These\
    \ fields are:\n   - IPv6 Next Header\n   - IPv6 Traffic Class\n   - IPv6 Hop Limit\n\
    \   - IPv4 Protocol\n   - IPv4 Type Of Service (TOS)\n   - IPv4 Time To Live (TTL)\n\
    \   - RTP CSRC Counter\n   - RTP Payload Type\n   - RTP CSRC List\n   Since the\
    \ values of the IPv4 Protocol and the IPv6 Next Header fields\n   are in effect\
    \ linked to the type of the subsequent header, they\n   deserve special treatment\
    \ when subheaders are inserted or removed.\n"
- title: A.3.4.  Be prepared to update or send as-is frequently
  contents:
  - "A.3.4.  Be prepared to update or send as-is frequently\n   For fields that normally\
    \ either are constant or have values deducible\n   from some other field, but\
    \ that frequently diverge from that\n   behavior, there must be an efficient way\
    \ to update the field value or\n   send it as-is in some packets.  These fields\
    \ are:\n   - IPv4 Identification (if not sequentially assigned)\n   - RTP Marker\n\
    \   - RTP Timestamp\n"
- title: A.3.5.  Guarantee continuous robustness
  contents:
  - "A.3.5.  Guarantee continuous robustness\n   For fields that behave like a counter\
    \ with a fixed delta for ALL\n   packets, the only requirement on the transmission\
    \ encoding is that\n   packet losses between compressor and decompressor must\
    \ be tolerable.\n   If several such fields exist, all these can be communicated\
    \ together.\n   Such fields can also be used to interpret the values for fields\n\
    \   listed in the previous section.  Fields that have this counter\n   behavior\
    \ are:\n   - IPv4 Identification (if sequentially assigned)\n   - RTP Sequence\
    \ Number\n"
- title: A.3.6.  Transmit as-is in all packets
  contents:
  - "A.3.6.  Transmit as-is in all packets\n   Fields that have completely random\
    \ values for each packet must be\n   included as-is in all compressed headers.\
    \  Those fields are:\n   - IPv4 Identification (if randomly assigned)\n   - UDP\
    \ Checksum (if enabled)\n"
- title: A.3.7.  Establish and be prepared to update delta
  contents:
  - "A.3.7.  Establish and be prepared to update delta\n   Finally, there is a field\
    \ that is usually increasing by a fixed delta\n   and is correlated to another\
    \ field.  For this field it would make\n   sense to make that delta part of the\
    \ context state.  The delta must\n   then be initiated and updated in the same\
    \ way as the fields listed in\n   A.3.3.  The field to which this applies is:\n\
    \   - RTP Timestamp\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2001).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
