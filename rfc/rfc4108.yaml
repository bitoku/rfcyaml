- contents:
  - ' Using Cryptographic Message Syntax (CMS) to Protect Firmware Packages

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document describes the use of the Cryptographic Message Syntax\n
    \  (CMS) to protect firmware packages, which provide object code for one\n   or
    more hardware module components.  CMS is specified in RFC 3852.  A\n   digital
    signature is used to protect the firmware package from\n   undetected modification
    and to provide data origin authentication.\n   Encryption is optionally used to
    protect the firmware package from\n   disclosure, and compression is optionally
    used to reduce the size of\n   the protected firmware package.  A firmware package
    loading receipt\n   can optionally be generated to acknowledge the successful
    loading of\n   a firmware package.  Similarly, a firmware package load error report\n
    \  can optionally be generated to convey the failure to load a firmware\n   package.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \     1.1. Terminology ................................................5\n      1.2.
    Architectural Elements .....................................5\n           1.2.1.
    Hardware Module Requirements ........................7\n           1.2.2. Firmware
    Package Requirements .......................8\n           1.2.3. Bootstrap Loader
    Requirements .......................9\n                  1.2.3.1. Legacy Stale
    Version Processing ...........11\n                  1.2.3.2. Preferred Stale Version
    Processing ........12\n           1.2.4. Trust Anchors ......................................12\n
    \          1.2.5. Cryptographic and Compression Algorithm\n                  Requirements
    .......................................13\n      1.3. Hardware Module Security
    Architecture .....................14\n      1.4. ASN.1 Encoding ............................................14\n
    \     1.5. Protected Firmware Package Loading ........................15\n   2.
    Firmware Package Protection ....................................15\n      2.1.
    Firmware Package Protection CMS Content Type Profile ......18\n           2.1.1.
    ContentInfo ........................................18\n           2.1.2. SignedData
    .........................................18\n                  2.1.2.1. SignerInfo
    ................................19\n                  2.1.2.2. EncapsulatedContentInfo
    ...................20\n           2.1.3. EncryptedData ......................................20\n
    \                 2.1.3.1. EncryptedContentInfo ......................21\n           2.1.4.
    CompressedData .....................................21\n                  2.1.4.1.
    EncapsulatedContentInfo ...................22\n           2.1.5. FirmwarePkgData
    ....................................22\n      2.2. Signed Attributes .........................................22\n
    \          2.2.1. Content Type .......................................23\n           2.2.2.
    Message Digest .....................................24\n           2.2.3. Firmware
    Package Identifier ........................24\n           2.2.4. Target Hardware
    Module Identifiers .................25\n           2.2.5. Decrypt Key Identifier
    .............................26\n           2.2.6. Implemented Crypto Algorithms
    ......................26\n           2.2.7. Implemented Compression Algorithms
    .................27\n           2.2.8. Community Identifiers ..............................27\n
    \          2.2.9. Firmware Package Information .......................29\n           2.2.10.
    Firmware Package Message Digest ...................30\n           2.2.11. Signing
    Time ......................................30\n           2.2.12. Content Hints
    .....................................31\n           2.2.13. Signing Certificate
    ...............................31\n      2.3. Unsigned Attributes .......................................32\n
    \          2.3.1. Wrapped Firmware Decryption Key ....................33\n   3.
    Firmware Package Load Receipt ..................................34\n      3.1.
    Firmware Package Load Receipt CMS Content Type Profile ....36\n           3.1.1.
    ContentInfo ........................................36\n           3.1.2. SignedData
    .........................................36\n                  3.1.2.1. SignerInfo
    ................................37\n                  3.1.2.2. EncapsulatedContentInfo
    ...................38\n           3.1.3. FirmwarePackageLoadReceipt .........................38\n
    \     3.2. Signed Attributes .........................................40\n           3.2.1.
    Content Type .......................................40\n           3.2.2. Message
    Digest .....................................40\n           3.2.3. Signing Time
    .......................................40\n   4. Firmware Package Load Error ....................................41\n
    \     4.1. Firmware Package Load Error CMS Content Type Profile ......42\n           4.1.1.
    ContentInfo ........................................42\n           4.1.2. SignedData
    .........................................43\n                  4.1.2.1. SignerInfo
    ................................43\n                  4.1.2.2. EncapsulatedContentInfo
    ...................43\n           4.1.3. FirmwarePackageLoadError ...........................43\n
    \     4.2. Signed Attributes .........................................49\n           4.2.1.
    Content Type .......................................49\n           4.2.2. Message
    Digest .....................................49\n           4.2.3. Signing Time
    .......................................50\n   5. Hardware Module Name ...........................................50\n
    \  6. Security Considerations ........................................51\n      6.1.
    Cryptographic Keys and Algorithms .........................51\n      6.2. Random
    Number Generation ..................................51\n      6.3. Stale Firmware
    Package Version Number .....................52\n      6.4. Community Identifiers
    .....................................53\n   7. References .....................................................54\n
    \     7.1. Normative References ......................................54\n      7.2.
    Informative References ....................................54\n   Appendix A:
    ASN.1 Module ..........................................56\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This document describes the use of the Cryptographic Message
    Syntax\n   (CMS) [CMS] to protect firmware packages.  This document also\n   describes
    the use of CMS for receipts and error reports for firmware\n   package loading.
    \ The CMS is a data protection encapsulation syntax\n   that makes use of ASN.1
    [X.208-88, X.209-88].  The protected firmware\n   package can be associated with
    any particular hardware module;\n   however, this specification was written with
    the requirements of\n   cryptographic hardware modules in mind, as these modules
    have strong\n   security requirements.\n   The firmware package contains object
    code for one or more\n   programmable components that make up the hardware module.
    \ The\n   firmware package, which is treated as an opaque binary object, is\n
    \  digitally signed.  Optional encryption and compression are also\n   supported.
    \ When all three are used, the firmware package is\n   compressed, then encrypted,
    and then signed.  Compression simply\n   reduces the size of the firmware package,
    allowing more efficient\n   processing and transmission.  Encryption protects
    the firmware\n   package from disclosure, which allows transmission of sensitive\n
    \  firmware packages over insecure links.  The encryption algorithm and\n   mode
    employed may also provide integrity, protecting the firmware\n   package from
    undetected modification.  The encryption protects\n   proprietary algorithms,
    classified algorithms, trade secrets, and\n   implementation techniques.  The
    digital signature protects the\n   firmware package from undetected modification
    and provides data\n   origin authentication.  The digital signature allows the
    hardware\n   module to confirm that the firmware package comes from an acceptable\n
    \  source.\n   If encryption is used, the firmware-decryption key must be made\n
    \  available to the hardware module via a secure path.  The key might be\n   delivered
    via physical media or via an independent electronic path.\n   One optional mechanism
    for distributing the firmware-decryption key\n   is specified in Section 2.3.1,
    but any secure key distribution\n   mechanism is acceptable.\n   The signature
    verification public key must be made available to the\n   hardware module in a
    manner that preserves its integrity and confirms\n   its source.  CMS supports
    the transfer of certificates, and this\n   facility can be used to transfer a
    certificate that contains the\n   signature verification public key (a firmware-signing
    certificate).\n   However, use of this facility introduces a level of indirection.\n
    \  Ultimately, a trust anchor public key must be made available to the\n   hardware
    module.  Section 1.2 establishes a requirement that the\n   hardware module store
    one or more trust anchors.\n   Hardware modules may not be capable of accessing
    certificate\n   repositories or delegated path discovery (DPD) servers [DPD&DPV]
    to\n   acquire certificates needed to complete a certification path.  Thus,\n
    \  it is the responsibility of the firmware package signer to include\n   sufficient
    certificates to enable each module to validate the\n   firmware-signer certificate
    (see Section 2.1.2).  Similarly, hardware\n   modules may not be capable of accessing
    a certificate revocation list\n   (CRL) repository, an OCSP responder [OCSP],
    or a delegated path\n   validation (DPV) server [DPD&DPV] to acquire revocation
    status\n   information.  Thus, if the firmware package signature cannot be\n   validated
    solely with the trust anchor public key and the hardware\n   module is not capable
    of performing full certification path\n   validation, then it is the responsibility
    of the entity loading a\n   package into a hardware module to validate the firmware-signer\n
    \  certification path prior to loading the package into a hardware\n   module.
    \ The means by which this external certificate revocation\n   status checking
    is performed is beyond the scope of this\n   specification.\n   Hardware modules
    will only accept firmware packages with a valid\n   digital signature.  The signature
    is either validated directly using\n   the trust anchor public key or using a
    firmware-signer certification\n   path that is validated to the trust anchor public
    key.  Thus, the\n   trust anchors define the set of entities that can create firmware\n
    \  packages for the hardware module.\n   The disposition of a previously loaded
    firmware package after the\n   successful validation of another firmware package
    is beyond the scope\n   of this specification.  The amount of memory available
    to the\n   hardware module will determine the range of alternatives.\n   In some
    cases, hardware modules can generate receipts to acknowledge\n   the loading of
    a particular firmware package.  Such receipts can be\n   used to determine which
    hardware modules need to receive an updated\n   firmware package whenever a flaw
    in an earlier firmware package is\n   discovered.  Hardware modules can also generate
    error reports to\n   indicate the unsuccessful firmware package loading.  To implement\n
    \  either receipt or error report generation, the hardware module is\n   required
    to have a unique permanent serial number.  Receipts and\n   error reports can
    be either signed or unsigned.  To generate\n   digitally signed receipts or error
    reports, a hardware module MUST be\n   issued its own private signature key and
    a certificate that contains\n   the corresponding signature validation public
    key.  In order to save\n   memory with the hardware module, the hardware module
    might store a\n   certificate designator instead of the certificate itself.  The\n
    \  private signature key requires secure storage.\n"
  - contents:
    - "1.1.  Terminology\n   In this document, the key words MUST, MUST NOT, REQUIRED,
      SHOULD,\n   SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL are to be interpreted
      as\n   described in [STDWORDS].\n"
    title: 1.1.  Terminology
  - contents:
    - "1.2.  Architectural Elements\n   The architecture includes the hardware module,
      the firmware package,\n   and a bootstrap loader.  The bootstrap loader MUST
      have access to one\n   or more trusted public keys, called trust anchors, to
      validate the\n   signature on the firmware package.  If a signed firmware package
      load\n   receipt or error report is created on behalf of the hardware module,\n
      \  then the bootstrap loader MUST have access to a private signature key\n   to
      generate the signature and the signer identifier for the\n   corresponding signature
      validation certificate or its designator.  A\n   signature validation certificate
      MAY be included to aid signature\n   validation.  To implement this optional
      capability, the hardware\n   module MUST have a unique serial number and a private
      signature key;\n   the hardware module MAY also include a certificate that contains
      the\n   corresponding signature validation public key.  These items MUST be\n
      \  installed in the hardware module before it is deployed.  The private\n   key
      and certificate can be generated and installed as part of the\n   hardware module
      manufacture process.  Figure 1 illustrates these\n   architectural elements.\n
      \  ASN.1 object identifiers are the preferred means of naming the\n   architectural
      elements.\n   Details of managing the trust anchors are beyond the scope of
      this\n   specification.  However, one or more trust anchors MUST be installed\n
      \  in the hardware module using a secure process before it is deployed.\n   These
      trust anchors provide a means of controlling the acceptable\n   sources of firmware
      packages.  The hardware module vendor can include\n   provisions for secure,
      remote management of trust anchors.  One\n   approach is to include trust anchors
      in the firmware packages\n   themselves.  This approach is analogous to the
      optional capability\n   described later for updating the bootstrap loader.\n
      \  In a cryptographic hardware module, the firmware package might\n   implement
      many different cryptographic algorithms.\n   When the firmware package is encrypted,
      the firmware-decryption key\n   and the firmware package MUST both be provided
      to the hardware\n   module.  The firmware-decryption key is necessary to use
      the\n   associated firmware package.  Generally, separate distribution\n   mechanisms
      will be employed for the firmware-decryption key and the\n   firmware package.
      \ An optional mechanism for securely distributing\n   the firmware-decryption
      key with the firmware package is specified in\n   Section 2.3.1.\n            +------------------------------------------------------+\n
      \           |  Hardware Module                                     |\n            |
      \                                                     |\n            |   +---------------+
      \  +--------------------------+   |\n            |   |  Bootstrap    |   |  Firmware
      Package        |   |\n            |   |  Loader       |   |                          |
      \  |\n            |   +---------------+   |   +------------------+   |   |\n
      \           |                       |   : Firmware Package :   |   |\n            |
      \  +---------------+   |   : Identifier and   :   |   |\n            |   |  Trust
      \       |   |   : Version Number   :   |   |\n            |   |  Anchor(s)    |
      \  |   +------------------+   |   |\n            |   +---------------+   |                          |
      \  |\n            |                       |   +-------------+        |   |\n
      \           |   +---------------+   |   : Algorithm 1 :        |   |\n            |
      \  |  Serial Num.  |   |   +-+-----------+-+      |   |\n            |   +---------------+
      \  |     : Algorithm 2 :      |   |\n            |                       |     +-+-----------+-+
      \   |   |\n            |   +---------------+   |       : Algorithm n :    |
      \  |\n            |   |  Hardware     |   |       +-------------+    |   |\n
      \           |   |  Module Type  |   |                          |   |\n            |
      \  +---------------+   +--------------------------+   |\n            |                                                      |\n
      \           |        +------------------------------------+        |\n            |
      \       |  Optional Private Signature Key &  |        |\n            |        |
      \ Signature Validation Certificate  |        |\n            |        |  or the
      Certificate Designator     |        |\n            |        +------------------------------------+
      \       |\n            |                                                      |\n
      \           +------------------------------------------------------+\n                     Figure
      1.  Architectural Elements\n"
    - contents:
      - "1.2.1.  Hardware Module Requirements\n   Many different vendors develop hardware
        modules, and each vendor\n   typically identifies its modules by product type
        (family) and\n   revision level.  A unique object identifier MUST name each
        hardware\n   module type and revision.\n   Each hardware module within a hardware
        module family SHOULD have a\n   unique permanent serial number.  However,
        if the optional receipt or\n   error report generation capability is implemented,
        then the hardware\n   module MUST have a unique permanent serial number.  If
        the optional\n   receipt or error report signature capability is implemented,
        then the\n   hardware module MUST have a private signature key and a certificate\n
        \  containing the corresponding public signature validation key or its\n   designator.
        \ If a serial number is present, the bootstrap loader uses\n   it for authorization
        decisions (see Section 2.2.8), receipt\n   generation (see Section 3), and
        error report generation (see\n   Section 4).\n   When the hardware module
        includes more than one firmware-programmable\n   component, the bootstrap
        loader distributes components of the package\n   to the appropriate components
        within the hardware module after the\n   firmware package is validated.  The
        bootstrap loader is discussed\n   further in Section 1.2.3.\n"
      title: 1.2.1.  Hardware Module Requirements
    - contents:
      - "1.2.2.  Firmware Package Requirements\n   Two approaches to naming firmware
        packages are supported: legacy and\n   preferred.  Firmware package names
        are placed in a CMS signed\n   attribute, not in the firmware package itself.\n
        \  Legacy firmware package names are simply octet strings, and no\n   structure
        is assumed.  This firmware package name form is supported\n   in order to
        facilitate existing configuration management systems.  We\n   assume that
        the firmware signer and the bootstrap loader will\n   understand any internal
        structure to the octet string.  In\n   particular, given two legacy firmware
        package names, we assume that\n   the firmware signer and the bootstrap loader
        will be able to\n   determine which one represents the newer version of the
        firmware\n   package.  This capability is necessary to implement the stale
        version\n   feature.  If a firmware package with a disastrous flaw is released,\n
        \  subsequent firmware package versions MAY designate a stale legacy\n   firmware
        package name in order to prevent subsequent rollback to the\n   stale version
        or versions earlier than the stale version.\n   Preferred firmware package
        names are a combination of the firmware\n   package object identifier and
        a version number.  A unique object\n   identifier MUST identify the collection
        of features that characterize\n   the firmware package.  For example, firmware
        packages for a cable\n   modem and a wireless LAN network interface card warrant
        distinct\n   object identifiers.  Similarly, firmware packages that implement\n
        \  distinct suites of cryptographic algorithms and modes of operation,\n   or
        that emulate different (non-programmable) cryptographic devices\n   warrant
        distinct object identifiers.  The version number MUST\n   identify a particular
        build or release of the firmware package.  The\n   version number MUST be
        a monotonically increasing non-negative\n   integer.  Generally, an earlier
        version is replaced with a later one.\n   If a firmware package with a disastrous
        flaw is released, subsequent\n   firmware package versions MAY designate a
        stale version number to\n   prevent subsequent rollback to the stale version
        or versions earlier\n   than the stale version.\n   Firmware packages are
        developed to run on one or more hardware module\n   type.  The firmware package
        digital signature MUST bind the list of\n   supported hardware module object
        identifiers to the firmware package.\n   In many cases, the firmware package
        signature will be validated\n   directly with the trust anchor public key,
        avoiding the need to\n   construct certification paths.  Alternatively, the
        trust anchor can\n   delegate firmware package signing to another public key
        through a\n   certification path.  In the latter case, the firmware package
        SHOULD\n   contain the certificates needed to construct the certification
        path\n   that begins with a certificate issued by the trust anchors and ends\n
        \  with a certificate issued to the firmware package signer.\n   The firmware
        package MAY contain a list of community identifiers.\n   These identifiers
        name the hardware modules that are authorized to\n   load the firmware package.
        \ If the firmware package contains a list\n   of community identifiers, then
        the bootstrap loader MUST reject the\n   firmware package if the hardware
        module is not a member of one of the\n   identified communities.\n   When
        a hardware module includes multiple programmable components, the\n   firmware
        package SHOULD contain executable code for all of the\n   components.  Internal
        tagging within the firmware package MUST tell\n   the bootstrap loader which
        portion of the overall firmware package is\n   intended for each component;
        however, this tagging is expected to be\n   specific to each hardware module.
        \ Because this specification treats\n   the firmware package as an opaque
        binary object, the format of the\n   firmware package is beyond the scope
        of this specification.\n"
      title: 1.2.2.  Firmware Package Requirements
    - contents:
      - "1.2.3.  Bootstrap Loader Requirements\n   The bootstrap loader MUST have
        access to a physical interface and any\n   related driver or protocol software
        necessary to obtain a firmware\n   package.  The same interface SHOULD be
        used to deliver receipts and\n   error reports.  Details of the physical interface
        as well as the\n   driver or protocol software are beyond the scope of this\n
        \  specification.\n   The bootstrap loader can be a permanent part of the
        hardware module,\n   or it can be replaced by loading a firmware package.
        \ In Figure 1,\n   the bootstrap loader is implemented as separate logic within
        the\n   hardware module.  Not all hardware modules will include the ability\n
        \  to replace or update the bootstrap loader, and this specification\n   does
        not mandate such support.\n   If the bootstrap loader can be loaded by a firmware
        package, an\n   initial bootstrap loader MUST be installed in non-volatile
        memory\n   prior to deployment.  All bootstrap loaders, including an initial\n
        \  bootstrap loader if one is employed, MUST meet the requirements in\n   this
        section.  However, the firmware package containing the bootstrap\n   loader
        MAY also contain other routines.\n   The bootstrap loader requires access
        to cryptographic routines.\n   These routines can be implemented specifically
        for the bootstrap\n   loader, or they can be shared with other hardware module
        features.\n   The bootstrap loader MUST have access to a one-way hash function
        and\n   digital signature verification routines to validate the digital\n
        \  signature on the firmware package and to validate the certification\n   path
        for the firmware-signing certificate.\n   If firmware packages are encrypted,
        the bootstrap loader MUST have\n   access to a decryption routine.  Access
        to a corresponding encryption\n   function is not required, since hardware
        modules need not be capable\n   of generating firmware packages.  Because
        some symmetric encryption\n   algorithm implementations (such as AES [AES])
        employ separate logic\n   for encryption and decryption, some hardware module
        savings might\n   result.\n   If firmware packages are compressed, the bootstrap
        loader MUST also\n   have access to a decompression function.  This function
        can be\n   implemented specifically for the bootstrap loader, or it can be\n
        \  shared with other hardware module features.  Access to a\n   corresponding
        compression function is not required, since hardware\n   modules need not
        be capable of generating firmware packages.\n   If the optional receipt generation
        or error report capability is\n   supported, the bootstrap loader MUST have
        access to the hardware\n   module serial number and the object identifier
        for the hardware\n   module type.  If the optional signed receipt generation
        or signed\n   error report capability is supported, the bootstrap loader MUST
        also\n   have access to a one-way hash function and digital signature\n   routines,
        the hardware module private signing key, and the\n   corresponding signature
        validation certificate or its designator.\n   The bootstrap loader requires
        access to one or more trusted public\n   keys, called trust anchors, to validate
        the firmware package digital\n   signature.  One or more trust anchors MUST
        be installed in non-\n   volatile memory prior to deployment.  The bootstrap
        loader MUST\n   reject a firmware package if it cannot validate the signature,
        which\n   MAY require the construction of a valid certification path from
        the\n   firmware-signing certificate to one of the trust anchors [PROFILE].\n
        \  However, in many cases, the firmware package signature will be\n   validated
        directly with the trust anchor public key, avoiding the\n   need to construct
        certification paths.\n   The bootstrap loader MUST reject a firmware package
        if the list of\n   supported hardware module type identifiers within the firmware\n
        \  package does not include the object identifier of the hardware\n   module.\n
        \  The bootstrap loader MUST reject a firmware package if the firmware\n   package
        includes a list of community identifiers and the hardware\n   module is not
        a member of one of the listed communities.  The means\n   of determining community
        membership is beyond the scope of this\n   specification.\n   The bootstrap
        loader MUST reject a firmware package if it cannot\n   successfully decrypt
        the firmware package using the firmware-\n   decryption key available to the
        hardware module.  The firmware\n   package contains an identifier of the firmware-decryption
        key needed\n   for decryption.\n   When an earlier version of a firmware package
        is replacing a later\n   one, the bootstrap loader SHOULD generate a warning.
        \ The manner in\n   which a warning is generated is highly dependent on the
        hardware\n   module and the environment in which it is being used.  If a firmware\n
        \  package with a disastrous flaw is released and subsequent firmware\n   package
        versions designate a stale version, the bootstrap loader\n   SHOULD prevent
        loading of the stale version and versions earlier than\n   the stale version.\n"
      - contents:
        - "1.2.3.1.  Legacy Stale Version Processing\n   In case a firmware package
          with a disastrous flaw is released,\n   subsequent firmware package versions
          that employ the legacy firmware\n   package name form MAY include a stale
          legacy firmware package name to\n   prevent subsequent rollback to the stale
          version or versions earlier\n   than the stale version.  As described in
          the Security Considerations\n   section of this document, the inclusion
          of a stale legacy firmware\n   package name in a firmware package cannot
          completely prevent\n   subsequent use of the stale firmware package.  However,
          many hardware\n   modules are expected to have very few firmware packages
          written for\n   them, allowing the stale firmware package version feature
          to provide\n   important protections.\n   Non-volatile storage for stale
          version numbers is needed.  The number\n   of stale legacy firmware package
          names that can be stored depends on\n   the amount of storage that is available.
          \ When a firmware package is\n   loaded and it contains a stale legacy firmware
          package name, then it\n   SHOULD be added to a list kept in non-volatile
          storage.  When\n   subsequent firmware packages are loaded, the legacy firmware
          package\n   name of the new package is compared to the list in non-volatile\n
          \  storage.  If the legacy firmware package name represents the same\n   version
          or an older version of a member of the list, then the new\n   firmware packages
          SHOULD be rejected.\n   The amount of non-volatile storage that needs to
          be dedicated to\n   saving legacy firmware package names and stale legacy
          firmware\n   packages names depends on the number of firmware packages that
          are\n   likely to be developed for the hardware module.\n"
        title: 1.2.3.1.  Legacy Stale Version Processing
      - contents:
        - "1.2.3.2.  Preferred Stale Version Processing\n   If a firmware package
          with a disastrous flaw is released, subsequent\n   firmware package versions
          that employ preferred firmware package name\n   form MAY include a stale
          version number to prevent subsequent\n   rollback to the stale version or
          versions earlier than the stale\n   version.  As described in the Security
          Considerations section of this\n   document, the inclusion of a stale version
          number in a firmware\n   package cannot completely prevent subsequent use
          of the stale\n   firmware package.  However, many hardware modules are expected
          to\n   have very few firmware packages written for them, allowing the stale\n
          \  firmware package version feature to provide important protections.\n
          \  Non-volatile storage for stale version numbers is needed.  The number\n
          \  of stale version numbers that can be stored depends on the amount of\n
          \  storage that is available.  When a firmware package is loaded and it\n
          \  contains a stale version number, then the object identifier of the\n
          \  firmware package and the stale version number SHOULD be added to a\n
          \  list that is kept in non-volatile storage.  When subsequent firmware\n
          \  packages are loaded, the object identifier and version number of the\n
          \  new package are compared to the list in non-volatile storage.  If the\n
          \  object identifier matches and the version number is less than or\n   equal
          to the stale version number, then the new firmware packages\n   SHOULD be
          rejected.\n   The amount of non-volatile storage that needs to be dedicated
          to\n   saving firmware package identifiers and stale version numbers depends\n
          \  on the number of firmware packages that are likely to be developed\n
          \  for the hardware module.\n"
        title: 1.2.3.2.  Preferred Stale Version Processing
      title: 1.2.3.  Bootstrap Loader Requirements
    - contents:
      - "1.2.4.  Trust Anchors\n   A trust anchor MUST consist of a public key signature
        algorithm and\n   an associated public key, which MAY optionally include parameters.
        \ A\n   trust anchor MUST also include a public key identifier.  A trust\n
        \  anchor MAY also include an X.500 distinguished name.\n   The trust anchor
        public key is used in conjunction with the signature\n   validation algorithm
        in two different ways.  First, the trust anchor\n   public key is used directly
        to validate the firmware package\n   signature.  Second, the trust anchor
        public key is used to validate\n   an X.509 certification path, and then the
        subject public key in the\n   final certificate in the certification path
        is used to validate the\n   firmware package signature.\n   The public key
        names the trust anchor, and each public key has a\n   public key identifier.
        \ The public key identifier identifies the\n   trust anchor as the signer
        when it is used directly to validate\n   firmware package signatures.  This
        key identifier can be stored with\n   the trust anchor, or it can be computed
        from the public key whenever\n   needed.\n   The optional trusted X.500 distinguished
        name MUST be present in\n   order for the trust anchor public key to be used
        to validate an X.509\n   certification path.  Without an X.500 distinguished
        name,\n   certification path construction cannot use the trust anchor.\n"
      title: 1.2.4.  Trust Anchors
    - contents:
      - "1.2.5.  Cryptographic and Compression Algorithm Requirements\n   A firmware
        package for a cryptographic hardware module includes\n   cryptographic algorithm
        implementations.  In addition, a firmware\n   package for a non-cryptographic
        hardware module will likely include\n   cryptographic algorithm implementations
        to support the bootstrap\n   loader in the validation of firmware packages.\n
        \  A unique algorithm object identifier MUST be assigned for each\n   cryptographic
        algorithm and mode implemented by a firmware package.\n   A unique algorithm
        object identifier MUST also be assigned for each\n   compression algorithm
        implemented by a firmware package.  The\n   algorithm object identifiers can
        be used to determine whether a\n   particular firmware package satisfies the
        needs of a particular\n   application.  To facilitate the development of algorithm-agile\n
        \  applications, the cryptographic module interface SHOULD allow\n   applications
        to query the cryptographic module for the object\n   identifiers associated
        with each cryptographic algorithm contained in\n   the currently loaded firmware
        package.  Applications SHOULD also be\n   able to query the cryptographic
        module to determine attributes\n   associated with each algorithm.  Such attributes
        might include the\n   algorithm type (symmetric encryption, asymmetric encryption,
        key\n   agreement, one-way hash function, digital signature, and so on), the\n
        \  algorithm block size or modulus size, and parameters for asymmetric\n   algorithms.
        \ This specification does not establish the conventions\n   for the retrieval
        of algorithm identifiers or algorithm attributes.\n"
      title: 1.2.5.  Cryptographic and Compression Algorithm Requirements
    title: 1.2.  Architectural Elements
  - contents:
    - "1.3.  Hardware Module Security Architecture\n   The bootstrap loader MAY be
      permanently stored in read-only memory or\n   separately loaded into non-volatile
      memory as discussed above.\n   In most hardware module designs, the firmware
      package execution\n   environment offers a single address space.  If it does,
      the firmware\n   package SHOULD contain a complete firmware package load for
      the\n   hardware module.  In this situation, the firmware package does not\n
      \  contain a partial or incremental set of functions.  A complete\n   firmware
      package load will minimize complexity and avoid potential\n   security problems.
      \ From a complexity perspective, the incremental\n   loading of packages makes
      it necessary for each package to identify\n   any other packages that are required
      (its dependencies), and the\n   bootstrap loader needs to verify that all of
      the dependencies are\n   satisfied before attempting to execute the firmware
      package.  When a\n   hardware module is based on a general purpose processor
      or a digital\n   signal processor, it is dangerous to allow arbitrary packages
      to be\n   loaded simultaneously unless there is a reference monitor to ensure\n
      \  that independent portions of the code cannot interfere with one\n   another.
      \ Also, it is difficult to evaluate arbitrary combinations of\n   software modules
      [SECREQMTS].  For these reasons, a complete firmware\n   package load is RECOMMENDED;
      however, this specification allows the\n   firmware signer to identify dependencies
      between firmware packages in\n   order to handle all situations.\n   The firmware
      packages MAY have dependencies on routines provided by\n   other firmware packages.
      \ To minimize the security evaluation\n   complexity of a hardware module employing
      such a design, the firmware\n   package MUST identify the package identifiers
      (and the minimum\n   version numbers when the preferred firmware package name
      form is\n   used) of the packages upon which it depends.  The bootstrap loader\n
      \  MUST reject a firmware package load if it contains a dependency on a\n   firmware
      package that is not available.\n   Loading a firmware package can impact the
      satisfactory resolution of\n   dependencies of other firmware packages that
      are already part of the\n   hardware module configuration.  For this reason,
      the bootstrap loader\n   MUST reject the loading of a firmware package if the
      dependencies of\n   any firmware package in the resulting configurations will
      be\n   unsatisfied.\n"
    title: 1.3.  Hardware Module Security Architecture
  - contents:
    - "1.4.  ASN.1 Encoding\n   The CMS uses Abstract Syntax Notation One (ASN.1)
      [X.208-88,\n   X.209-88].  ASN.1 is a formal notation used for describing data\n
      \  protocols, regardless of the programming language used by the\n   implementation.
      \ Encoding rules describe how the values defined in\n   ASN.1 will be represented
      for transmission.  The Basic Encoding Rules\n   (BER) are the most widely employed
      rule set, but they offer more than\n   one way to represent data structures.
      \ For example, definite length\n   encoding and indefinite length encoding are
      supported.  This\n   flexibility is not desirable when digital signatures are
      used.  As a\n   result, the Distinguished Encoding Rules (DER) [X.509-88] were\n
      \  invented.  DER is a subset of BER that ensures a single way to\n   represent
      a given value.  For example, DER always employs definite\n   length encoding.\n
      \  In this specification, digitally signed structures MUST be encoded\n   with
      DER.  Other structures do not require DER, but the use of\n   definite length
      encoding is strongly RECOMMENDED.  By always using\n   definite length encoding,
      the bootstrap loader will have fewer\n   options to implement.  In situations
      where there is very high\n   confidence that only definite length encoding will
      be used, support\n   for indefinite length decoding MAY be omitted.\n"
    title: 1.4.  ASN.1 Encoding
  - contents:
    - "1.5.  Protected Firmware Package Loading\n   This document does not attempt
      to specify a physical interface, any\n   related driver software, or a protocol
      necessary for loading firmware\n   packages.  Many different delivery mechanisms
      are envisioned,\n   including portable memory devices, file transfer, and web
      pages.\n   Section 2 of this specification defines the format that MUST be\n
      \  presented to the hardware module regardless of the interface that is\n   used.
      \ This specification also specifies the format of the response\n   that MAY
      be generated by the hardware module.  Section 3 of this\n   specification defines
      the format that MAY be returned by the hardware\n   module when a firmware package
      loads successfully.  Section 4 of this\n   specification defines the format
      that MAY be returned by the hardware\n   module when a firmware package load
      is unsuccessful.  The firmware\n   package load receipts and firmware package
      load error reports can be\n   either signed or unsigned.\n"
    title: 1.5.  Protected Firmware Package Loading
  title: 1.  Introduction
- contents:
  - "2.  Firmware Package Protection\n   The Cryptographic Message Syntax (CMS) is
    used to protect a firmware\n   package, which is treated as an opaque binary object.
    \ A digital\n   signature is used to protect the firmware package from undetected\n
    \  modification and to provide data origin authentication.  Encryption\n   is
    optionally used to protect the firmware package from disclosure,\n   and compression
    is optionally used to reduce the size of the\n   protected firmware package.  The
    CMS ContentInfo content type MUST\n   always be present, and it MUST encapsulate
    the CMS SignedData content\n   type.  If the firmware package is encrypted, then
    the CMS SignedData\n   content type MUST encapsulate the CMS EncryptedData content
    type.  If\n   the firmware package is compressed, then either the CMS SignedData\n
    \  content type (when encryption is not used) or the CMS EncryptedData\n   content
    type (when encryption is used) MUST encapsulate the CMS\n   CompressedData content
    type.  Finally, (1) the CMS SignedData content\n   type (when neither encryption
    nor compression is used), (2) the CMS\n   EncryptedData content type (when encryption
    is used, but compression\n   is not), or (3) the CMS CompressedData content type
    (when compression\n   is used) MUST encapsulate the simple firmware package using
    the\n   FirmwarePkgData content type defined in this specification (see\n   Section
    2.1.5).\n   The firmware package protection is summarized as follows (see [CMS]\n
    \  for the full syntax):\n      ContentInfo {\n        contentType          id-signedData,
    -- (1.2.840.113549.1.7.2)\n        content              SignedData\n      }\n
    \     SignedData {\n        version              CMSVersion, -- always set to
    3\n        digestAlgorithms     DigestAlgorithmIdentifiers, -- Only one\n        encapContentInfo
    \    EncapsulatedContentInfo,\n        certificates         CertificateSet, --
    Signer cert. path\n        crls                 CertificateRevocationLists, --
    Optional\n        signerInfos          SET OF SignerInfo -- Only one\n      }\n
    \     SignerInfo {\n        version              CMSVersion, -- always set to
    3\n        sid                  SignerIdentifier,\n        digestAlgorithm      DigestAlgorithmIdentifier,\n
    \       signedAttrs          SignedAttributes, -- Required\n        signatureAlgorithm
    \  SignatureAlgorithmIdentifier,\n        signature            SignatureValue,\n
    \       unsignedAttrs        UnsignedAttributes -- Optional\n      }\n      EncapsulatedContentInfo
    {\n        eContentType         id-encryptedData, -- (1.2.840.113549.1.7.6)\n
    \                            -- OR --\n                             id-ct-compressedData,\n
    \                                      -- (1.2.840.113549.1.9.16.1.9)\n                             --
    OR --\n                             id-ct-firmwarePackage,\n                                       --
    (1.2.840.113549.1.9.16.1.16)\n        eContent             OCTET STRING\n      }
    \                           -- Contains EncryptedData OR\n                                   --
    CompressedData OR\n                                   -- FirmwarePkgData\n      EncryptedData
    {\n        version              CMSVersion, -- Always set to 0\n        encryptedContentInfo
    EncryptedContentInfo,\n        unprotectedAttrs     UnprotectedAttributes -- Omit\n
    \     }\n      EncryptedContentInfo {\n        contentType          id-ct-compressedData,\n
    \                                      -- (1.2.840.113549.1.9.16.1.9)\n                             --
    OR --\n                             id-ct-firmwarePackage,\n                                       --
    (1.2.840.113549.1.9.16.1.16)\n        contentEncryptionAlgorithm ContentEncryptionAlgorithmIdentifier,\n
    \       encryptedContent OCTET STRING\n      }                                --
    Contains CompressedData OR\n                                       -- FirmwarePkgData\n
    \     CompressedData {\n        version              CMSVersion, -- Always set
    to 0\n        compressionAlgorithm CompressionAlgorithmIdentifier,\n        encapContentInfo
    \    EncapsulatedContentInfo\n      }\n      EncapsulatedContentInfo {\n        eContentType
    \        id-ct-firmwarePackage,\n                                         -- (1.2.840.113549.1.9.16.1.16)\n
    \       eContent             OCTET STRING -- Contains FirmwarePkgData\n      }\n
    \     FirmwarePkgData         OCTET STRING -- Contains firmware package\n"
  - contents:
    - "2.1.  Firmware Package Protection CMS Content Type Profile\n   This section
      specifies the conventions for using the CMS ContentInfo,\n   SignedData, EncryptedData,
      and CompressedData content types.  It also\n   defines the FirmwarePkgData content
      type.\n"
    - contents:
      - "2.1.1.  ContentInfo\n   The CMS requires that the outermost encapsulation
        be ContentInfo\n   [CMS].  The fields of ContentInfo are used as follows:\n
        \     contentType indicates the type of the associated content, and in\n         this
        case, the encapsulated type is always SignedData.  The\n         id-signedData
        (1.2.840.113549.1.7.2) object identifier MUST be\n         present in this
        field.\n      content holds the associated content, and in this case, the\n
        \        content field MUST contain SignedData.\n"
      title: 2.1.1.  ContentInfo
    - contents:
      - "2.1.2.  SignedData\n   The SignedData content type [CMS] contains the signed
        firmware\n   package (which might be compressed, encrypted, or compressed
        and then\n   encrypted prior to signature), the certificates needed to validate\n
        \  the signature, and one digital signature value.  The fields of\n   SignedData
        are used as follows:\n   version is the syntax version number, and in this
        case, it MUST be\n      set to 3.\n   digestAlgorithms is a collection of
        message digest algorithm\n      identifiers, and in this case, it MUST contain
        a single message\n      digest algorithm identifier.  The message digest algorithm\n
        \     employed by the firmware package signer MUST be present.\n   encapContentInfo
        contains the signed content, consisting of a content\n      type identifier
        and the content itself.  The use of the\n      EncapsulatedContentInfo type
        is discussed further in Section\n      2.1.2.2.\n   certificates is an optional
        collection of certificates.  If the trust\n      anchor signed the firmware
        package directly, then certificates\n      SHOULD be omitted.  If it did not,
        then certificates SHOULD\n      include the X.509 certificate of the firmware
        package signer.  The\n      set of certificates SHOULD be sufficient for the
        bootstrap loader\n      to construct a certification path from the trust anchor
        to the\n      firmware-signer's certificate.  PKCS#6 extended certificates\n
        \     [PKCS#6] and attribute certificates (either version 1 or\n      version
        2) [X.509-97, X.509-00, ACPROFILE] MUST NOT be included in\n      the set
        of certificates.\n   crls is an optional collection of certificate revocation
        lists\n      (CRLs), and in this case, CRLs SHOULD NOT be included by the\n
        \     firmware package signer.  It is anticipated that firmware packages\n
        \     may be generated, signed, and made available in repositories for\n      downloading
        into hardware modules.  In such contexts, it would be\n      difficult for
        the firmware package signer to include timely CRLs\n      in the firmware
        package.  However, because the CRLs are not\n      covered by the signature,
        timely CRLs MAY be inserted by some\n      other party before the firmware
        package is delivered to the\n      hardware module.\n   signerInfos is a collection
        of per-signer information, and in this\n      case, the collection MUST contain
        exactly one SignerInfo.  The use\n      of the SignerInfo type is discussed
        further in Section 2.1.2.1.\n"
      - contents:
        - "2.1.2.1.  SignerInfo\n   The firmware package signer is represented in
          the SignerInfo type.\n   The fields of SignerInfo are used as follows:\n
          \  version is the syntax version number, and it MUST be 3.\n   sid identifies
          the signer's public key.  CMS supports two\n      alternatives: issuerAndSerialNumber
          and subjectKeyIdentifier.\n      However, the bootstrap loader MUST support
          the\n      subjectKeyIdentifier alternative, which identifies the signer's\n
          \     public key directly.  When this public key is contained in a\n      certificate,
          this identifier SHOULD appear in the X.509\n      subjectKeyIdentifier extension.\n
          \  digestAlgorithm identifies the message digest algorithm, and any\n      associated
          parameters, used by the firmware package signer.  It\n      MUST contain
          the message digest algorithms employed by the\n      firmware package signer.
          \ (Note that this message digest algorithm\n      identifier MUST be the
          same as the one carried in the\n      digestAlgorithms value in SignedData.)\n
          \  signedAttrs is an optional collection of attributes that are signed\n
          \     along with the content.  The signedAttrs are optional in the CMS,\n
          \     but in this specification, signedAttrs are REQUIRED for the\n      firmware
          package; however, implementations MUST ignore\n      unrecognized signed
          attributes.  The SET OF attributes MUST be DER\n      encoded [X.509-88].
          \ Section 2.2 of this document lists the\n      attributes that MUST be
          included in the collection; other\n      attributes MAY be included as well.\n
          \  signatureAlgorithm identifies the signature algorithm, and any\n      associated
          parameters, used by the firmware package signer to\n      generate the digital
          signature.\n   signature is the digital signature value.\n   unsignedAttrs
          is an optional SET of attributes that are not signed.\n      As described
          in Section 2.3, this set can only contain a single\n      instance of the
          wrapped-firmware-decryption-key attribute and no\n      others.\n"
        title: 2.1.2.1.  SignerInfo
      - contents:
        - "2.1.2.2.  EncapsulatedContentInfo\n   The EncapsulatedContentInfo content
          type encapsulates the firmware\n   package, which might be compressed, encrypted,
          or compressed and then\n   encrypted prior to signature.  The firmware package,
          in any of these\n   formats, is carried within the EncapsulatedContentInfo
          type.  The\n   fields of EncapsulatedContentInfo are used as follows:\n
          \  eContentType is an object identifier that uniquely specifies the\n      content
          type, and in this case, the value MUST be id-encryptedData\n      (1.2.840.113549.1.7.6),
          id-ct-compressedData\n      (1.2.840.113549.1.9.16.1.9), or id-ct-firmwarePackage\n
          \     (1.2.840.113549.1.9.16.1.16).  When eContentType contains id-\n      encryptedData,
          the firmware package was encrypted prior to\n      signing, and may also
          have been compressed prior to encryption.\n      When it contains id-ct-compressedData,
          the firmware package was\n      compressed prior to signing, but was not
          encrypted.  When it\n      contains id-ct-firmwarePackage, the firmware
          package was not\n      compressed or encrypted prior to signing.\n   eContent
          contains the signed firmware package, which might also be\n      encrypted,
          compressed, or compressed and then encrypted, prior to\n      signing.  The
          content is encoded as an octet string.  The eContent\n      octet string
          need not be DER encoded.\n"
        title: 2.1.2.2.  EncapsulatedContentInfo
      title: 2.1.2.  SignedData
    - contents:
      - "2.1.3.  EncryptedData\n   The EncryptedData content type [CMS] contains the
        encrypted firmware\n   package (which might be compressed prior to encryption).
        \ However, if\n   the firmware package was not encrypted, the EncryptedData
        content\n   type is not present.  The fields of EncryptedData are used as\n
        \  follows:\n   version is the syntax version number, and in this case, version
        MUST\n      be 0.\n   encryptedContentInfo is the encrypted content information.
        \ The use\n      of the EncryptedContentInfo type is discussed further in
        Section\n      2.1.3.1.\n   unprotectedAttrs is an optional collection of
        unencrypted attributes,\n      and in this case, unprotectedAttrs MUST NOT
        be present.\n"
      - contents:
        - "2.1.3.1.  EncryptedContentInfo\n   The encrypted firmware package, which
          might be compressed prior to\n   encryption, is encapsulated in the EncryptedContentInfo
          type.  The\n   fields of EncryptedContentInfo are used as follows:\n   contentType
          indicates the type of content, and in this case, it MUST\n      contain
          either id-ct-compressedData (1.2.840.113549.1.9.16.1.9) or\n      id-ct-firmwarePackage
          (1.2.840.113549.1.9.16.1.16).  When it\n      contains id-ct-compressedData,
          then the firmware package was\n      compressed prior to encryption.  When
          it contains id-ct-\n      firmwarePackage, then the firmware package was
          not compressed\n      prior to encryption.\n   contentEncryptionAlgorithm
          identifies the firmware-encryption\n      algorithm, and any associated
          parameters, used to encrypt the\n      firmware package.\n   encryptedContent
          is the result of encrypting the firmware package.\n      The field is optional;
          however, in this case, it MUST be present.\n"
        title: 2.1.3.1.  EncryptedContentInfo
      title: 2.1.3.  EncryptedData
    - contents:
      - "2.1.4.  CompressedData\n   The CompressedData content type [COMPRESS] contains
        the compressed\n   firmware package.  If the firmware package was not compressed,
        then\n   the CompressedData content type is not present.  The fields of\n
        \  CompressedData are used as follows:\n   version is the syntax version number;
        in this case, it MUST be 0.\n   compressionAlgorithm identifies the compression
        algorithm, and any\n      associated parameters, used to compress the firmware
        package.\n   encapContentInfo is the compressed content, consisting of a content\n
        \     type identifier and the content itself.  The use of the\n      EncapsulatedContentInfo
        type is discussed further in Section\n      2.1.4.1.\n"
      - contents:
        - "2.1.4.1.  EncapsulatedContentInfo\n   The CompressedData content type encapsulates
          the compressed firmware\n   package, and it is carried within the EncapsulatedContentInfo
          type.\n   The fields of EncapsulatedContentInfo are used as follows:\n   eContentType
          is an object identifier that uniquely specifies the\n      content type,
          and in this case, it MUST be the value of id-ct-\n      firmwarePackage
          (1.2.840.113549.1.9.16.1.16).\n   eContent is the compressed firmware package,
          encoded as an octet\n      string.  The eContent octet string need not be
          DER encoded.\n"
        title: 2.1.4.1.  EncapsulatedContentInfo
      title: 2.1.4.  CompressedData
    - contents:
      - "2.1.5.  FirmwarePkgData\n   The FirmwarePkgData content type contains the
        firmware package.  It\n   is a straightforward encapsulation in an octet string,
        and it need\n   not be DER encoded.\n   The FirmwarePkgData content type is
        identified by the id-ct-\n   firmwarePackage object identifier:\n      id-ct-firmwarePackage
        OBJECT IDENTIFIER ::= {\n        iso(1) member-body(2) us(840) rsadsi(113549)
        pkcs(1) pkcs9(9)\n        smime(16) ct(1) 16 }\n   The FirmwarePkgData content
        type is a simple octet string:\n      FirmwarePkgData ::= OCTET STRING\n"
      title: 2.1.5.  FirmwarePkgData
    title: 2.1.  Firmware Package Protection CMS Content Type Profile
  - contents:
    - "2.2.  Signed Attributes\n   The firmware package signer MUST digitally sign
      a collection of\n   attributes along with the firmware package.  Each attribute
      in the\n   collection MUST be DER encoded [X.509-88].  The syntax for attributes\n
      \  is defined in [CMS], but it is repeated here for convenience:\n      Attribute
      ::= SEQUENCE {\n        attrType OBJECT IDENTIFIER,\n        attrValues SET
      OF AttributeValue }\n      AttributeValue ::= ANY\n   Each of the attributes
      used with this profile has a single attribute\n   value, even though the syntax
      is defined as a SET OF AttributeValue.\n   There MUST be exactly one instance
      of AttributeValue present.\n   The SignedAttributes syntax within signerInfo
      is defined as a SET OF\n   Attribute.  The SignedAttributes MUST include only
      one instance of\n   any particular attribute.\n   The firmware package signer
      MUST include the following four\n   attributes: content-type, message-digest,
      firmware-package-\n   identifier, and target-hardware-module-identifiers.\n
      \  If the firmware package is encrypted, then the firmware package\n   signer
      MUST also include the decrypt-key-identifier attribute.\n   If the firmware
      package implements cryptographic algorithms, then the\n   firmware package signer
      MAY also include the implemented-crypto-\n   algorithms attribute.  Similarly,
      if the firmware package implements\n   compression algorithms, then the firmware
      package signer MAY also\n   include the implemented-compress-algorithms attribute.\n
      \  If the firmware package is intended for use only by specific\n   communities,
      then the firmware package signer MUST also include the\n   community-identifiers
      attribute.\n   If the firmware package depends on the presence of one or more
      other\n   firmware packages to operate properly, then the firmware package\n
      \  signer SHOULD also include the firmware-package-info attribute.  For\n   example,
      the firmware-package-info attribute dependencies field might\n   indicate that
      the firmware package contains a dependency on a\n   particular bootstrap loader
      or separation kernel.\n   The firmware package signer SHOULD also include the
      three following\n   attributes: firmware-package-message-digest, signing-time,
      and\n   content-hints.  Additionally, if the firmware package signer has a\n
      \  certificate (meaning that the firmware package signer is not always\n   configured
      as a trust anchor), then the firmware package signer\n   SHOULD also include
      the signing-certificate attribute.\n   The firmware package signer MAY include
      any other attribute that it\n   deems appropriate.\n"
    - contents:
      - "2.2.1.  Content Type\n   The firmware package signer MUST include a content-type
        attribute\n   with the value of id-encryptedData (1.2.840.113549.1.7.6), id-ct-\n
        \  compressedData (1.2.840.113549.1.9.16.1.9), or id-ct-firmwarePackage\n
        \  (1.2.840.113549.1.9.16.1.16).  When it contains id-encryptedData, the\n
        \  firmware package was encrypted prior to signing.  When it contains\n   id-ct-compressedData,
        the firmware package was compressed prior to\n   signing, but was not encrypted.
        \ When it contains\n   id-ct-firmwarePackage, the firmware package was not
        compressed or\n   encrypted prior to signing.  Section 11.1 of [CMS] defines
        the\n   content-type attribute.\n"
      title: 2.2.1.  Content Type
    - contents:
      - "2.2.2.  Message Digest\n   The firmware package signer MUST include a message-digest
        attribute,\n   having as its value the message digest computed on the\n   encapContentInfo
        eContent octet string, as defined in Section\n   2.1.2.2.  This octet string
        contains the firmware package, and it MAY\n   be compressed, encrypted, or
        both compressed and encrypted.  Section\n   11.2 of [CMS] defines the message-digest
        attribute.\n"
      title: 2.2.2.  Message Digest
    - contents:
      - "2.2.3.  Firmware Package Identifier\n   The firmware-package-identifier attribute
        names the protected\n   firmware package.  Two approaches to naming firmware
        packages are\n   supported:  legacy and preferred.  The firmware package signer
        MUST\n   include a firmware-package-identifier attribute using one of these\n
        \  name forms.\n   A legacy firmware package name is an octet string, and
        no structure\n   within the octet string is assumed.\n   A preferred firmware
        package name is a combination of an object\n   identifier and a version number.
        \ The object identifier names a\n   collection of functions implemented by
        the firmware package, and the\n   version number is a non-negative integer
        that identifies a particular\n   build or release of the firmware package.\n
        \  If a firmware package with a disastrous flaw is released, the\n   firmware
        package that repairs the previously distributed flaw MAY\n   designate a stale
        firmware package version to prevent the reloading\n   of the flawed version.
        \ The hardware module bootstrap loader SHOULD\n   prevent subsequent rollback
        to the stale version or versions earlier\n   than the stale version.  When
        the legacy firmware package name form\n   is used, the stale version is indicated
        by a stale legacy firmware\n   package name, which is an octet string.  We
        assume that the firmware\n   package signer and the bootstrap loader can determine
        whether a given\n   legacy firmware package name represents a version that
        is more recent\n   than the stale one.  When the preferred firmware package
        name form is\n   used, the stale version is indicated by a stale version number,
        which\n   is an integer.\n   The following object identifier identifies the
        firmware-package-\n   identifier attribute:\n      id-aa-firmwarePackageID
        OBJECT IDENTIFIER ::= {\n        iso(1) member-body(2) us(840) rsadsi(113549)
        pkcs(1) pkcs9(9)\n        smime(16) aa(2) 35 }\n   The firmware-package-identifier
        attribute values have ASN.1 type\n   FirmwarePackageIdentifier:\n      FirmwarePackageIdentifier
        ::= SEQUENCE {\n        name PreferredOrLegacyPackageIdentifier,\n        stale
        PreferredOrLegacyStalePackageIdentifier OPTIONAL }\n      PreferredOrLegacyPackageIdentifier
        ::= CHOICE {\n        preferred PreferredPackageIdentifier,\n        legacy
        OCTET STRING }\n      PreferredPackageIdentifier ::= SEQUENCE {\n        fwPkgID
        OBJECT IDENTIFIER,\n        verNum INTEGER (0..MAX) }\n      PreferredOrLegacyStalePackageIdentifier
        ::= CHOICE {\n        preferredStaleVerNum INTEGER (0..MAX),\n        legacyStaleVersion
        OCTET STRING }\n"
      title: 2.2.3.  Firmware Package Identifier
    - contents:
      - "2.2.4.  Target Hardware Module Identifiers\n   The target-hardware-module-identifiers
        attribute names the types of\n   hardware modules that the firmware package
        supports.  A unique object\n   identifier names each supported hardware model
        type and revision.\n   The bootstrap loader MUST reject the firmware package
        if its own\n   hardware module type identifier is not listed in the target-\n
        \  hardware-module-identifiers attribute.\n   The following object identifier
        identifies the target-hardware-\n   module-identifiers attribute:\n      id-aa-targetHardwareIDs
        OBJECT IDENTIFIER ::= {\n        iso(1) member-body(2) us(840) rsadsi(113549)
        pkcs(1) pkcs9(9)\n        smime(16) aa(2) 36 }\n   The target-hardware-module-identifiers
        attribute values have ASN.1\n   type TargetHardwareIdentifiers:\n      TargetHardwareIdentifiers
        ::= SEQUENCE OF OBJECT IDENTIFIER\n"
      title: 2.2.4.  Target Hardware Module Identifiers
    - contents:
      - "2.2.5.  Decrypt Key Identifier\n   The decrypt-key-identifier attribute names
        the symmetric key needed\n   to decrypt the encapsulated firmware package.
        \ The CMS EncryptedData\n   content type is used when the firmware package
        is encrypted.  The\n   decrypt-key-identifier signed attribute is carried
        in the SignedData\n   content type that encapsulates EncryptedData content
        type, naming the\n   symmetric key needed to decrypt the firmware package.
        \ No particular\n   structure is imposed on the key identifier.  The means
        by which the\n   firmware-decryption key is securely distributed to all modules
        that\n   are authorized to use the associated firmware package is beyond the\n
        \  scope of this specification; however, an optional mechanism for\n   securely
        distributing the firmware-decryption key with the firmware\n   package is
        specified in Section 2.3.1.\n   The following object identifier identifies
        the decrypt-key-identifier\n   attribute:\n      id-aa-decryptKeyID OBJECT
        IDENTIFIER ::= {\n        iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
        pkcs9(9)\n        smime(16) aa(2) 37 }\n   The decrypt-key-identifier attribute
        values have ASN.1 type\n   DecryptKeyIdentifier:\n      DecryptKeyIdentifier
        ::= OCTET STRING\n"
      title: 2.2.5.  Decrypt Key Identifier
    - contents:
      - "2.2.6.  Implemented Crypto Algorithms\n   The implemented-crypto-algorithms
        attribute MAY be present in the\n   SignedAttributes, and it names the cryptographic
        algorithms that are\n   implemented by the firmware package and available
        to applications.\n   Only those algorithms that are made available at the
        interface of the\n   cryptographic module are listed.  Any cryptographic algorithm
        that is\n   used internally and is not accessible via the cryptographic module\n
        \  interface MUST NOT be listed.  For example, if the firmware package\n   implements
        the decryption algorithm for future firmware package\n   installations and
        this algorithm is not made available for other\n   uses, then the firmware-decryption
        algorithm would not be listed.\n   The object identifier portion of AlgorithmIdentifier
        identifies an\n   algorithm and its mode of use.  No algorithm parameters
        are included.\n   Cryptographic algorithms include traffic-encryption algorithms,
        key-\n   encryption algorithms, key transport algorithms, key agreement\n
        \  algorithms, one-way hash algorithms, and digital signature\n   algorithms.
        \ Cryptographic algorithms do not include compression\n   algorithms.\n   The
        following object identifier identifies the implemented-crypto-\n   algorithms
        attribute:\n      id-aa-implCryptoAlgs OBJECT IDENTIFIER ::= {\n        iso(1)
        member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs9(9)\n        smime(16)
        aa(2) 38 }\n   The implemented-crypto-algorithms attribute values have ASN.1
        type\n   ImplementedCryptoAlgorithms:\n      ImplementedCryptoAlgorithms ::=
        SEQUENCE OF OBJECT IDENTIFIER\n"
      title: 2.2.6.  Implemented Crypto Algorithms
    - contents:
      - "2.2.7.  Implemented Compression Algorithms\n   The implemented-compress-algorithms
        attribute MAY be present in the\n   SignedAttributes, and it names the compression
        algorithms that are\n   implemented by the firmware package and available
        to applications.\n   Only those algorithms that are made available at the
        interface of the\n   hardware module are listed.  Any compression algorithm
        that is used\n   internally and is not accessible via the hardware module
        interface\n   MUST NOT be listed.  For example, if the firmware package implements\n
        \  a decompression algorithm for future firmware package installations\n   and
        this algorithm is not made available for other uses, then the\n   firmware-decompression
        algorithm would not be listed.\n   The object identifier portion of AlgorithmIdentifier
        identifies a\n   compression algorithm.  No algorithm parameters are included.\n
        \  The following object identifier identifies the implemented-compress-\n
        \  algorithms attribute:\n      id-aa-implCompressAlgs OBJECT IDENTIFIER ::=
        {\n        iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs9(9)\n
        \       smime(16) aa(2) 43 }\n   The implemented-compress-algorithms attribute
        values have ASN.1 type\n   ImplementedCompressAlgorithms:\n      ImplementedCompressAlgorithms
        ::= SEQUENCE OF OBJECT IDENTIFIER\n"
      title: 2.2.7.  Implemented Compression Algorithms
    - contents:
      - "2.2.8.  Community Identifiers\n   If present in the SignedAttributes, the
        community-identifiers\n   attribute names the communities that are permitted
        to execute the\n   firmware package.  The bootstrap loader MUST reject the
        firmware\n   package if the hardware module is not a member of one of the\n
        \  identified communities.  The means of assigning community membership\n
        \  is beyond the scope of this specification.\n   The community-identifiers
        attributes names the authorized communities\n   by a list of community object
        identifiers, by a list of specific\n   hardware modules, or by a combination
        of the two lists.  A specific\n   hardware module is specified by the combination
        of the hardware\n   module identifier (as defined in Section 2.2.4) and a
        serial number.\n   To facilitate compact representation of serial numbers,
        a contiguous\n   block can be specified by the lowest authorized serial number
        and the\n   highest authorized serial number.  Alternatively, all of the serial\n
        \  numbers associated with a hardware module family identifier can be\n   specified
        with the NULL value.\n   If the bootstrap loader does not have a mechanism
        for obtaining a\n   list of object identifiers that identify the communities
        to which the\n   hardware module is a member, then the bootstrap loader MUST
        behave as\n   though the list is empty.  Similarly, if the bootstrap loader
        does\n   not have access to the hardware module serial number, then the\n
        \  bootstrap loader MUST behave as though the hardware module is not\n   included
        on the list of authorized hardware modules.\n   The following object identifier
        identifies the community-identifiers\n   attribute:\n      id-aa-communityIdentifiers
        OBJECT IDENTIFIER ::= {\n        iso(1) member-body(2) us(840) rsadsi(113549)
        pkcs(1) pkcs9(9)\n        smime(16) aa(2) 40 }\n   The community-identifiers
        attribute values have ASN.1 type\n   CommunityIdentifiers:\n      CommunityIdentifiers
        ::= SEQUENCE OF CommunityIdentifier\n      CommunityIdentifier ::= CHOICE
        {\n        communityOID OBJECT IDENTIFIER,\n        hwModuleList HardwareModules
        }\n      HardwareModules ::= SEQUENCE {\n        hwType OBJECT IDENTIFIER,\n
        \       hwSerialEntries SEQUENCE OF HardwareSerialEntry }\n      HardwareSerialEntry
        ::= CHOICE {\n        all NULL,\n        single OCTET STRING,\n        block
        SEQUENCE {\n          low OCTET STRING,\n          high OCTET STRING } }\n"
      title: 2.2.8.  Community Identifiers
    - contents:
      - "2.2.9.  Firmware Package Information\n   If a hardware module supports more
        than one type of firmware package,\n   then the firmware package signer SHOULD
        include the firmware-\n   package-info attribute with a populated fwPkgType
        field to identify\n   the firmware package type.  This value can aid the bootstrap
        loader\n   in the correct placement of the firmware package within the hardware\n
        \  module.  The firmware package type is an INTEGER, and the meaning of\n
        \  the integer value is specific to each hardware module.  For example,\n
        \  a hardware module could assign different integer values for a\n   bootstrap
        loader, a separation kernel, and an application.\n   Some hardware module
        architectures permit one firmware package to use\n   routines provided by
        another.  If the firmware package contains a\n   dependency on another, then
        the firmware package signer SHOULD also\n   include the firmware-package-info
        attribute with a populated\n   dependencies field.  If the firmware package
        does not depend on any\n   other firmware packages, then the firmware package
        signer MUST NOT\n   include the firmware-package-info attribute with a populated\n
        \  dependencies field.\n   Firmware package dependencies are identified by
        the firmware package\n   identifier or by information contained in the firmware
        package\n   itself, and in either case the bootstrap loader ensures that the\n
        \  dependencies are met.  The bootstrap loader MUST reject a firmware\n   package
        load if it identifies a dependency on a firmware package that\n   is not already
        loaded.  Also, the bootstrap loader MUST reject a\n   firmware package load
        if the action will result in a configuration\n   where the dependencies of
        an already loaded firmware package will no\n   longer be satisfied.  As described
        in Section 2.2.3, two approaches\n   to naming firmware packages are supported:
        legacy and preferred.\n   When the legacy firmware package name form is used,
        the dependency is\n   indicated by a legacy firmware package name.  We assume
        that the\n   firmware package signer and the bootstrap loader can determine\n
        \  whether a given legacy firmware package name represents the named\n   version
        of an acceptable newer version.  When the preferred firmware\n   package name
        form is used, an object identifier and an integer are\n   provided.  The object
        identifier MUST exactly match the object\n   identifier portion of a preferred
        firmware package name associated\n   with a firmware package that is already
        loaded, and the integer MUST\n   be less than or equal to the integer portion
        of the preferred\n   firmware package name associated with the same firmware
        package.\n   That is, the dependency specifies the minimum value of the version\n
        \  that is acceptable.\n   The following object identifier identifies the
        firmware-package-info\n   attribute:\n      id-aa-firmwarePackageInfo OBJECT
        IDENTIFIER ::= {\n        iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
        pkcs9(9)\n        smime(16) aa(2) 42 }\n   The firmware-package-info attribute
        values have ASN.1 type\n   FirmwarePackageInfo:\n      FirmwarePackageInfo
        ::= SEQUENCE {\n        fwPkgType INTEGER OPTIONAL,\n        dependencies
        SEQUENCE OF\n          PreferredOrLegacyPackageIdentifier OPTIONAL }\n"
      title: 2.2.9.  Firmware Package Information
    - contents:
      - "2.2.10.  Firmware Package Message Digest\n   The firmware package signer
        SHOULD include a firmware-package-\n   message-digest attribute, which provides
        the message digest algorithm\n   and the message digest value computed on
        the firmware package.  The\n   message digest is computed on the firmware
        package prior to any\n   compression, encryption, or signature processing.
        \ The bootstrap\n   loader MAY use this message digest to confirm that the
        intended\n   firmware package has been recovered after all of the layers of\n
        \  encapsulation are removed.\n   The following object identifier identifies
        the firmware-package-\n   message-digest attribute:\n      id-aa-fwPkgMessageDigest
        OBJECT IDENTIFIER ::= {\n        iso(1) member-body(2) us(840) rsadsi(113549)
        pkcs(1) pkcs9(9)\n        smime(16) aa(2) 41 }\n   The firmware-package-message-digest
        attribute values have ASN.1 type\n   FirmwarePackageMessageDigest:\n      FirmwarePackageMessageDigest
        ::= SEQUENCE {\n        algorithm AlgorithmIdentifier,\n        msgDigest
        OCTET STRING }\n"
      title: 2.2.10.  Firmware Package Message Digest
    - contents:
      - "2.2.11.  Signing Time\n   The firmware package signer SHOULD include a signing-time
        attribute,\n   specifying the time at which the signature was applied to the\n
        \  firmware package.  Section 11.3 of [CMS] defines the signing-time\n   attribute.\n"
      title: 2.2.11.  Signing Time
    - contents:
      - "2.2.12.  Content Hints\n   The firmware package signer SHOULD include a content-hints
        attribute,\n   including a brief text description of the firmware package.
        \ The text\n   is encoded in UTF-8, which supports most of the world's writing\n
        \  systems [UTF-8].  Section 2.9 of [ESS] defines the content-hints\n   attribute.\n
        \  When multiple layers of encapsulation are employed, the content-hints\n
        \  attribute is included in the outermost SignedData to provide\n   information
        about the innermost content.  In this case, the content-\n   hints attribute
        provides a brief text description of the firmware\n   package, which can help
        a person select the correct firmware package\n   when more than one is available.\n
        \  When the preferred firmware package name forms are used, the\n   content-hints
        attribute can provide a linkage to a legacy firmware\n   package name.  This
        is especially helpful when an existing\n   configuration management system
        is in use, but the features\n   associated with the preferred firmware package
        name are deemed\n   useful.  A firmware package name associated with such
        a configuration\n   management system might look something like\n   \"R1234.C0(AJ11).D62.A02.11(b).\"
        \ Including these firmware package\n   names in the text description may be
        helpful to developers by\n   providing a clear linkage between the two name
        forms.\n   The content-hints attribute contains two fields, and in this case,\n
        \  both fields MUST be present.  The fields of ContentHints are used as\n
        \  follows:\n   contentDescription provides a brief text description of the
        firmware\n      package.\n   contentType provides the content type of the
        inner most content type,\n      and in this case, it MUST be id-ct-firmwarePackage\n
        \     (1.2.840.113549.1.9.16.1.16).\n"
      title: 2.2.12.  Content Hints
    - contents:
      - "2.2.13.  Signing Certificate\n   When the firmware-signer's public key is
        contained in a certificate,\n   the firmware package signer SHOULD include
        a signing-certificate\n   attribute to identify the certificate that was employed.
        \ However, if\n   the firmware package signature does not have a certificate
        (meaning\n   that the signature will only be validated with the trust anchor\n
        \  public key), then the firmware package signer is unable to include a\n
        \  signing-certificate attribute.  Section 5.4 of [ESS] defines this\n   attribute.\n
        \  The signing-certificate attribute contains two fields: certs and\n   policies.
        \ The certs field MUST be present, and the policies field\n   MAY be present.
        \ The fields of SigningCertificate are used as\n   follows:\n   certs contains
        a sequence of certificate identifiers.  In this case,\n      sequence of certificate
        identifiers contains a single entry.  The\n      certs field MUST contain
        only the certificate identifier of the\n      certificate that contains the
        public key used to verify the\n      firmware package signature.  The certs
        field uses the ESSCertID\n      syntax specified in Section 5.4 of [ESS],
        and it is comprised of\n      the SHA-1 hash [SHA1] of the entire ASN.1 DER
        encoded certificate\n      and, optionally, the certificate issuer and the
        certificate serial\n      number.  The SHA-1 hash value MUST be present.  The
        certificate\n      issuer and the certificate serial number SHOULD be present.\n
        \  policies is optional; when it is present, it contains a sequence of\n      policy
        information.  The policies field, when present, MUST\n      contain only one
        entry, and that entry MUST match one of the\n      certificate policies in
        the certificate policies extension of the\n      certificate that contains
        the public key used to verify the\n      firmware package signature.  The
        policies field uses the\n      PolicyInformation syntax specified in Section
        4.2.1.5 of\n      [PROFILE], and it is comprised of the certificate policy
        object\n      identifier and, optionally, certificate policy qualifiers.  The\n
        \     certificate policy object identifier MUST be present.  The\n      certificate
        policy qualifiers SHOULD NOT be present.\n"
      title: 2.2.13.  Signing Certificate
    title: 2.2.  Signed Attributes
  - contents:
    - "2.3.  Unsigned Attributes\n   CMS allows a SET of unsigned attributes to be
      included; however, in\n   this specification, the set MUST be absent or include
      a single\n   instance of the wrapped-firmware-decryption-key attribute.  Because\n
      \  the digital signature does not cover this attribute, it can be\n   altered
      at any point in the delivery path from the firmware package\n   signer to the
      hardware module.  This property can be employed to\n   distribute the firmware-decryption
      key along with an encrypted and\n   signed firmware package, allowing the firmware-decryption
      key to be\n   wrapped with a different key-encryption key for each link in the\n
      \  distribution chain.\n   The syntax for attributes is defined in [CMS], and
      it is repeated at\n   the beginning of Section 2.2 of this document for convenience.
      \ Each\n   of the attributes used with this profile has a single attribute\n
      \  value, even though the syntax is defined as a SET OF AttributeValue.\n   There
      MUST be exactly one instance of AttributeValue present.\n   The UnsignedAttributes
      syntax within signerInfo is defined as a SET\n   OF Attribute.  The UnsignedAttributes
      MUST include only one instance\n   of any particular attribute.\n"
    - contents:
      - "2.3.1.  Wrapped Firmware Decryption Key\n   The firmware package signer,
        or any other party in the distribution\n   chain, MAY include a wrapped-firmware-decryption-key
        attribute.\n   The following object identifier identifies the wrapped-firmware-\n
        \  decryption-key attribute:\n      id-aa-wrappedFirmwareKey OBJECT IDENTIFIER
        ::= {\n        iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs9(9)\n
        \       smime(16) aa(2) 39 }\n   The wrapped-firmware-decryption-key attribute
        values have ASN.1 type\n   of EnvelopedData.  Section 6 of [CMS] defines the
        EnvelopedData\n   content type, which is used to construct the value of the
        attribute.\n   EnvelopedData permits the firmware-decryption key to be protected\n
        \  using symmetric or asymmetric techniques.  The EnvelopedData does not\n
        \  include an encrypted content; rather, the EnvelopedData feature of\n   having
        the encrypted content in another location is employed.  The\n   encrypted
        content is found in the eContent field of the EncryptedData\n   structure.
        \ The firmware-decryption key is contained in the\n   recipientInfos field.
        \ Section 6 of [CMS] refers to this key as the\n   content-encryption key.\n
        \  The EnvelopedData syntax supports many different key management\n   algorithms.
        \ Four general techniques are supported: key transport,\n   key agreement,
        symmetric key-encryption keys, and passwords.\n   The EnvelopedData content
        type is profiled for the wrapped-firmware-\n   decryption-key attribute.  The
        EnvelopedData fields are described\n   fully in Section 6 of [CMS].  Additional
        rules apply when\n   EnvelopedData is used as a wrapped-firmware-decryption-key
        attribute.\n   Within the EnvelopedData structure, the following apply:\n
        \  -  The set of certificates included in OriginatorInfo MUST NOT\n      include
        certificates with a type of extendedCertificate,\n      v1AttrCert, or v2AttrCert
        [X.509-97, X.509-00, ACPROFILE].  The\n      optional crls field MAY be present.\n
        \  -  The optional unprotectedAttrs field MUST NOT be present.\n   Within
        the EncryptedContentInfo structure, the following apply:\n   -  contentType
        MUST match the content type object identifier carried\n      in the contentType
        field within the EncryptedContentInfo structure\n      of EncryptedData as
        described in Section 2.1.3.1.\n   -  contentEncryptionAlgorithm identifies
        the firmware-encryption\n      algorithm, and any associated parameters, used
        to encrypt the\n      firmware package carried in the encryptedContent field
        of the\n      EncryptedContentInfo structure of EncryptedData.  Therefore,
        it\n      MUST exactly match the value of the EncryptedContentInfo structure\n
        \     of EncryptedData as described in Section 2.1.3.1.\n   -  encryptedContent
        is optional, and in this case, it MUST NOT be\n      present.\n"
      title: 2.3.1.  Wrapped Firmware Decryption Key
    title: 2.3.  Unsigned Attributes
  title: 2.  Firmware Package Protection
- contents:
  - "3.  Firmware Package Load Receipt\n   The Cryptographic Message Syntax (CMS)
    is used to indicate that a\n   firmware package loaded successfully.  Support
    for firmware package\n   load receipts is OPTIONAL.  However, those hardware modules
    that\n   choose to generate such receipts MUST follow the conventions\n   specified
    in this section.  Because not all hardware modules will\n   have private signature
    keys, the firmware package load receipt can be\n   either signed or unsigned.
    \ Use of the signed firmware package load\n   receipt is RECOMMENDED.\n   Hardware
    modules that support receipt generation MUST have a unique\n   serial number.
    \ Hardware modules that support signed receipt\n   generation MUST have a private
    signature key to sign the receipt and\n   the corresponding signature validation
    certificate or its designator.\n   The designator is the certificate issuer name
    and the certificate\n   serial number, or it is the public key identifier.  Memory-\n
    \  constrained hardware modules will generally store the public key\n   identifier
    since it requires less storage.\n   The unsigned firmware package load receipt
    is encapsulated by\n   ContentInfo.  Alternatively, the signed firmware package
    load receipt\n   is encapsulated by SignedData, which is in turn encapsulated
    by\n   ContentInfo.\n   The firmware package load receipt is summarized as follows
    (see [CMS]\n   for the full syntax):\n   ContentInfo {\n     contentType          id-signedData,
    -- (1.2.840.113549.1.7.2)\n                          -- OR --\n                          id-ct-firmwareLoadReceipt,\n
    \                              -- (1.2.840.113549.1.9.16.1.17)\n     content              SignedData\n
    \                         -- OR --\n                          FirmwarePackageLoadReceipt\n
    \  }\n   SignedData {\n     version              CMSVersion, -- always set to
    3\n     digestAlgorithms     DigestAlgorithmIdentifiers, -- Only one\n     encapContentInfo
    \    EncapsulatedContentInfo,\n     certificates         CertificateSet, -- Optional
    Module certificate\n     crls                 CertificateRevocationLists, -- Optional\n
    \    signerInfos          SET OF SignerInfo -- Only one\n   }\n   SignerInfo {\n
    \    version              CMSVersion, -- either set to 1 or 3\n     sid                  SignerIdentifier,\n
    \    digestAlgorithm      DigestAlgorithmIdentifier,\n     signedAttrs          SignedAttributes,
    -- Required\n     signatureAlgorithm   SignatureAlgorithmIdentifier,\n     signature
    \           SignatureValue,\n     unsignedAttrs        UnsignedAttributes -- Omit\n
    \  }\n   EncapsulatedContentInfo {\n     eContentType         id-ct-firmwareLoadReceipt,\n
    \                              -- (1.2.840.113549.1.9.16.1.17)\n     eContent
    \            OCTET STRING -- Contains receipt\n   }\n   FirmwarePackageLoadReceipt
    {\n     version              INTEGER, -- The DEFAULT is always used\n     hwType
    \              OBJECT IDENTIFIER, -- Hardware module type\n     hwSerialNum          OCTET
    STRING, -- H/W module serial number\n     fwPkgName            PreferredOrLegacyPackageIdentifier,\n
    \    trustAnchorKeyID     OCTET STRING, -- Optional\n     decryptKeyID         OCTET
    STRING -- Optional\n   }\n"
  - contents:
    - "3.1.  Firmware Package Load Receipt CMS Content Type Profile\n   This section
      specifies the conventions for using the CMS ContentInfo\n   and SignedData content
      types for firmware package load receipts.  It\n   also defines the firmware
      package load receipt content type.\n"
    - contents:
      - "3.1.1.  ContentInfo\n   The CMS requires that the outermost encapsulation
        be ContentInfo\n   [CMS].  The fields of ContentInfo are used as follows:\n
        \  contentType indicates the type of the associated content.  If the\n      firmware
        package load receipt is signed, then the encapsulated\n      type MUST be
        SignedData, and the id-signedData\n      (1.2.840.113549.1.7.2) object identifier
        MUST be present in this\n      field.  If the receipt is not signed, then
        the encapsulated type\n      MUST be FirmwarePackageLoadReceipt, and the id-ct-\n
        \     firmwareLoadReceipt (1.2.840.113549.1.9.16.1.17) object identifier\n
        \     MUST be present in this field.\n   content holds the associated content.
        \ If the firmware package load\n      receipt is signed, then this field MUST
        contain the SignedData.\n      If the receipt is not signed, then this field
        MUST contain the\n      FirmwarePackageLoadReceipt.\n"
      title: 3.1.1.  ContentInfo
    - contents:
      - "3.1.2.  SignedData\n   The SignedData content type contains the firmware
        package load\n   receipt and one digital signature.  If the hardware module
        locally\n   stores its certificate, then the certificate can be included as
        well.\n   The fields of SignedData are used as follows:\n   version is the
        syntax version number, and in this case, it MUST be\n      set to 3.\n   digestAlgorithms
        is a collection of message digest algorithm\n      identifiers, and in this
        case, it MUST contain a single message\n      digest algorithm identifier.
        \ The message digest algorithms\n      employed by the hardware module MUST
        be present.\n   encapContentInfo is the signed content, consisting of a content
        type\n      identifier and the content itself.  The use of the\n      EncapsulatedContentInfo
        type is discussed further in Section\n      3.1.2.2.\n   certificates is an
        optional collection of certificates.  If the\n      hardware module locally
        stores its certificate, then the X.509\n      certificate of the hardware
        module SHOULD be included.  If the\n      hardware module does not, then the
        certificates field is omitted.\n      PKCS#6 extended certificates [PKCS#6]
        and attribute certificates\n      (either version 1 or version 2) [X.509-97,
        X.509-00, ACPROFILE]\n      MUST NOT be included in the set of certificates.\n
        \  crls is an optional collection of certificate revocation lists\n      (CRLs).
        \ CRLs MAY be included, but they will normally be omitted\n      since hardware
        modules will not generally have access to the most\n      recent CRL.  Signed
        receipt recipients SHOULD be able to handle\n      the presence of the optional
        crls field.\n   signerInfos is a collection of per-signer information, and
        in this\n      case, the collection MUST contain exactly one SignerInfo.  The
        use\n      of the SignerInfo type is discussed further in Section 3.1.2.1.\n"
      - contents:
        - "3.1.2.1.  SignerInfo\n   The hardware module is represented in the SignerInfo
          type.  The\n   fields of SignerInfo are used as follows:\n   version is
          the syntax version number, and it MUST be either 1 or 3,\n      depending
          on the method used to identify the hardware module's\n      public key.
          \ The use of the subjectKeyIdentifier is RECOMMENDED,\n      which results
          in the use of version 3.\n   sid specifies the hardware module's certificate
          (and thereby the\n      hardware module's public key).  CMS supports two
          alternatives:\n      issuerAndSerialNumber and subjectKeyIdentifier.  The
          hardware\n      module MUST support one or both of the alternatives for
          receipt\n      generation; however, the support of subjectKeyIdentifier
          is\n      RECOMMENDED.  The issuerAndSerialNumber alternative identifies
          the\n      hardware module's certificate by the issuer's distinguished name\n
          \     and the certificate serial number.  The identified certificate, in\n
          \     turn, contains the hardware module's public key.  The\n      subjectKeyIdentifier
          alternative identifies the hardware module's\n      public key directly.
          \ When this public key is contained in a\n      certificate, this identifier
          SHOULD appear in the X.509\n      subjectKeyIdentifier extension.\n   digestAlgorithm
          identifies the message digest algorithm, and any\n      associated parameters,
          used by the hardware module.  It MUST\n      contain the message digest
          algorithms employed to sign the\n      receipt.  (Note that this message
          digest algorithm identifier MUST\n      be the same as the one carried in
          the digestAlgorithms value in\n      SignedData.)\n   signedAttrs is an
          optional collection of attributes that are signed\n      along with the
          content.  The signedAttrs are optional in the CMS,\n      but in this specification,
          signedAttrs are REQUIRED for use with\n      the firmware package load receipt
          content.  The SET OF attributes\n      MUST be DER encoded [X.509-88].  Section
          3.2 of this document\n      lists the attributes that MUST be included in
          the collection.\n      Other attributes MAY be included, but the recipient
          will ignore\n      any unrecognized signed attributes.\n   signatureAlgorithm
          identifies the signature algorithm, and any\n      associated parameters,
          used to sign the receipt.\n   signature is the digital signature.\n   unsignedAttrs
          is an optional collection of attributes that are not\n      signed, and
          in this case, there MUST NOT be any unsigned\n      attributes present.\n"
        title: 3.1.2.1.  SignerInfo
      - contents:
        - "3.1.2.2.  EncapsulatedContentInfo\n   The FirmwarePackageLoadReceipt is
          encapsulated in an OCTET STRING,\n   and it is carried within the EncapsulatedContentInfo
          type.  The\n   fields of EncapsulatedContentInfo are used as follows:\n
          \  eContentType is an object identifier that uniquely specifies the\n      content
          type, and in this case, it MUST be the value of id-ct-\n      firmwareLoadReceipt
          (1.2.840.113549.1.9.16.1.17).\n   eContent is the firmware package load
          receipt, encapsulated in an\n      OCTET STRING.  The eContent octet string
          need not be DER encoded.\n"
        title: 3.1.2.2.  EncapsulatedContentInfo
      title: 3.1.2.  SignedData
    - contents:
      - "3.1.3.  FirmwarePackageLoadReceipt\n   The following object identifier identifies
        the firmware package load\n   receipt content type:\n      id-ct-firmwareLoadReceipt
        OBJECT IDENTIFIER ::= {\n        iso(1) member-body(2) us(840) rsadsi(113549)
        pkcs(1) pkcs9(9)\n        smime(16) ct(1) 17 }\n   The firmware package load
        receipt content type has the ASN.1 type\n   FirmwarePackageLoadReceipt:\n
        \     FirmwarePackageLoadReceipt ::= SEQUENCE {\n        version FWReceiptVersion
        DEFAULT v1,\n        hwType OBJECT IDENTIFIER,\n        hwSerialNum OCTET
        STRING,\n        fwPkgName PreferredOrLegacyPackageIdentifier,\n        trustAnchorKeyID
        OCTET STRING OPTIONAL,\n        decryptKeyID [1] OCTET STRING OPTIONAL }\n
        \     FWReceiptVersion ::= INTEGER { v1(1) }\n   The fields of the FirmwarePackageLoadReceipt
        type have the following\n   meanings:\n   version is an integer that provides
        the syntax version number for\n      compatibility with future revisions of
        this specification.\n      Implementations that conform to this specification
        MUST set the\n      version to the default value, which is v1.\n   hwType
        is an object identifier that identifies the type of hardware\n      module
        on which the firmware package was loaded.\n   hwSerialNum is the serial number
        of the hardware module on which the\n      firmware package was loaded.  No
        particular structure is imposed\n      on the serial number; it need not be
        an integer.  However, the\n      combination of the hwType and hwSerialNum
        uniquely identifies the\n      hardware module.\n   fwPkgName identifies the
        firmware package that was loaded.  As\n      described in Section 2.2.3, two
        approaches to naming firmware\n      packages are supported: legacy and preferred.
        \ A legacy firmware\n      package name is an octet string.  A preferred firmware
        package\n      name is a combination of the firmware package object identifier\n
        \     and an integer version number.\n   trustAnchorKeyID is optional, and
        when it is present, it identifies\n      the trust anchor that was used to
        validate the firmware package\n      signature.\n   decryptKeyID is optional,
        and when it is present, it identifies the\n      firmware-decryption key that
        was used to decrypt the firmware\n      package.\n   The firmware package
        load receipt MUST include the version, hwType,\n   hwSerialNum, and fwPkgName
        fields, and it SHOULD include the\n   trustAnchorKeyID field.  The firmware
        package load receipt MUST NOT\n   include the decryptKeyID, unless the firmware
        package associated with\n   the receipt is encrypted, the firmware-decryption
        key is available to\n   the hardware module, and the firmware package was
        successfully\n   decrypted.\n"
      title: 3.1.3.  FirmwarePackageLoadReceipt
    title: 3.1.  Firmware Package Load Receipt CMS Content Type Profile
  - contents:
    - "3.2.  Signed Attributes\n   The hardware module MUST digitally sign a collection
      of attributes\n   along with the firmware package load receipt.  Each attribute
      in the\n   collection MUST be DER encoded [X.509-88].  The syntax for attributes\n
      \  is defined in [CMS], and it was repeated in Section 2.2 for\n   convenience.\n
      \  Each of the attributes used with this profile has a single attribute\n   value,
      even though the syntax is defined as a SET OF AttributeValue.\n   There MUST
      be exactly one instance of AttributeValue present.\n   The SignedAttributes
      syntax within signerInfo is defined as a SET OF\n   Attributes.  The SignedAttributes
      MUST include only one instance of\n   any particular attribute.\n   The hardware
      module MUST include the content-type and message-digest\n   attributes.  If
      the hardware module includes a real-time clock, then\n   the hardware module
      SHOULD also include the signing-time attribute.\n   The hardware module MAY
      include any other attribute that it deems\n   appropriate.\n"
    - contents:
      - "3.2.1.  Content Type\n   The hardware module MUST include a content-type
        attribute with the\n   value of id-ct-firmwareLoadReceipt (1.2.840.113549.1.9.16.1.17).\n
        \  Section 11.1 of [CMS] defines the content-type attribute.\n"
      title: 3.2.1.  Content Type
    - contents:
      - "3.2.2.  Message Digest\n   The hardware module MUST include a message-digest
        attribute, having\n   as its value the message digest of the FirmwarePackageLoadReceipt\n
        \  content.  Section 11.2 of [CMS] defines the message-digest attribute.\n"
      title: 3.2.2.  Message Digest
    - contents:
      - "3.2.3.  Signing Time\n   If the hardware module includes a real-time clock,
        then the hardware\n   module SHOULD include a signing-time attribute, specifying
        the time\n   at which the receipt was generated.  Section 11.3 of [CMS] defines\n
        \  the signing-time attribute.\n"
      title: 3.2.3.  Signing Time
    title: 3.2.  Signed Attributes
  title: 3.  Firmware Package Load Receipt
- contents:
  - "4.  Firmware Package Load Error\n   The Cryptographic Message Syntax (CMS) is
    used to indicate that an\n   error has occurred while attempting to load a protected
    firmware\n   package.  Support for firmware package load error reports is\n   OPTIONAL.
    \ However, those hardware modules that choose to generate\n   such error reports
    MUST follow the conventions specified in this\n   section.  Not all hardware modules
    have private signature keys;\n   therefore the firmware package load error report
    can be either signed\n   or unsigned.  Use of the signed firmware package error
    report is\n   RECOMMENDED.\n   Hardware modules that support error report generation
    MUST have a\n   unique serial number.  Hardware modules that support signed error\n
    \  report generation MUST also have a private signature key to sign the\n   error
    report and the corresponding signature validation certificate\n   or its designator.
    \ The designator is the certificate issuer name and\n   the certificate serial
    number, or it is the public key identifier.\n   Memory-constrained hardware modules
    will generally store the public\n   key identifier since it requires less storage.\n
    \  The unsigned firmware package load error report is encapsulated by\n   ContentInfo.
    \ Alternatively, the signed firmware package load error\n   report is encapsulated
    by SignedData, which is in turn encapsulated\n   by ContentInfo.\n   The firmware
    package load error report is summarized as follows (see\n   [CMS] for the full
    syntax):\n   ContentInfo {\n     contentType          id-signedData, -- (1.2.840.113549.1.7.2)\n
    \                         -- OR --\n                          id-ct-firmwareLoadError,\n
    \                              -- (1.2.840.113549.1.9.16.1.18)\n     content              SignedData\n
    \                         -- OR --\n                          FirmwarePackageLoadError\n
    \  }\n   SignedData {\n     version              CMSVersion, -- Always set to
    3\n     digestAlgorithms     DigestAlgorithmIdentifiers, -- Only one\n     encapContentInfo
    \    EncapsulatedContentInfo,\n     certificates         CertificateSet, -- Optional
    Module certificate\n     crls                 CertificateRevocationLists, -- Optional\n
    \    signerInfos          SET OF SignerInfo -- Only one\n   }\n   SignerInfo {\n
    \    version              CMSVersion, -- either set to 1 or 3\n     sid                  SignerIdentifier,\n
    \    digestAlgorithm      DigestAlgorithmIdentifier,\n     signedAttrs          SignedAttributes,
    -- Required\n     signatureAlgorithm   SignatureAlgorithmIdentifier,\n     signature
    \           SignatureValue,\n     unsignedAttrs        UnsignedAttributes -- Omit\n
    \  }\n   EncapsulatedContentInfo {\n     eContentType         id-ct-firmwareLoadError,\n
    \                              -- (1.2.840.113549.1.9.16.1.18)\n     eContent
    \            OCTET STRING -- Contains error report\n   }\n   FirmwarePackageLoadError
    {\n     version            INTEGER, -- The DEFAULT is always used\n     hwType
    \            OBJECT IDENTIFIER, -- Hardware module type\n     hwSerialNum        OCTET
    STRING, -- H/W module serial number\n     errorCode          FirmwarePackageLoadErrorCode
    -- Error identifier\n     vendorErrorCode    VendorErrorCode, -- Optional\n     fwPkgName
    \         PreferredOrLegacyPackageIdentifier, -- Optional\n     config             SEQUENCE
    OF CurrentFWConfig, -- Optional\n   }\n   CurrentFWConfig {      -- Repeated for
    each package in configuration\n     fwPkgType            INTEGER, -- Firmware
    package type; Optional\n     fwPkgName            PreferredOrLegacyPackageIdentifier\n
    \  }\n"
  - contents:
    - "4.1.  Firmware Package Load Error CMS Content Type Profile\n   This section
      specifies the conventions for using the CMS ContentInfo\n   and SignedData content
      types for firmware package load error reports.\n   It also defines the firmware
      package load error content type.\n"
    - contents:
      - "4.1.1.  ContentInfo\n   The CMS requires that the outermost encapsulation
        be ContentInfo\n   [CMS].  The fields of ContentInfo are used as follows:\n
        \  contentType indicates the type of the associated content.  If the\n      firmware
        package load error report is signed, then the\n      encapsulated type MUST
        be SignedData, and the id-signedData\n      (1.2.840.113549.1.7.2) object
        identifier MUST be present in this\n      field.  If the report is not signed,
        then the encapsulated type\n      MUST be FirmwarePackageLoadError, and the
        id-ct-firmwareLoadError\n      (1.2.840.113549.1.9.16.1.18) object identifier
        MUST be present in\n      this field.\n   content holds the associated content.
        \ If the firmware package load\n      error report is signed, then this field
        MUST contain the\n      SignedData.  If the report is not signed, then this
        field MUST\n      contain the FirmwarePackageLoadError.\n"
      title: 4.1.1.  ContentInfo
    - contents:
      - "4.1.2.  SignedData\n   The SignedData content type contains the firmware
        package load error\n   report and one digital signature.  If the hardware
        module locally\n   stores its certificate, then the certificate can be included
        as well.\n   The fields of SignedData are used exactly as described in Section\n
        \  3.1.2.\n"
      - contents:
        - "4.1.2.1.  SignerInfo\n   The hardware module is represented in the SignerInfo
          type.  The\n   fields of SignerInfo are used exactly as described in Section\n
          \  3.1.2.1.\n"
        title: 4.1.2.1.  SignerInfo
      - contents:
        - "4.1.2.2.  EncapsulatedContentInfo\n   The FirmwarePackageLoadError is encapsulated
          in an OCTET STRING, and\n   it is carried within the EncapsulatedContentInfo
          type.  The fields of\n   EncapsulatedContentInfo are used as follows:\n
          \  eContentType is an object identifier that uniquely specifies the\n      content
          type, and in this case, it MUST be the value of id-ct-\n      firmwareLoadError
          (1.2.840.113549.1.9.16.1.18).\n   eContent is the firmware package load
          error report, encapsulated in\n      an OCTET STRING.  The eContent octet
          string need not be DER\n      encoded.\n"
        title: 4.1.2.2.  EncapsulatedContentInfo
      title: 4.1.2.  SignedData
    - contents:
      - "4.1.3.  FirmwarePackageLoadError\n   The following object identifier identifies
        the firmware package load\n   error report content type:\n      id-ct-firmwareLoadError
        OBJECT IDENTIFIER ::= {\n        iso(1) member-body(2) us(840) rsadsi(113549)
        pkcs(1) pkcs9(9)\n        smime(16) ct(1) 18 }\n   The firmware package load
        error report content type has the ASN.1\n   type FirmwarePackageLoadError:\n
        \     FirmwarePackageLoadError ::= SEQUENCE {\n        version FWErrorVersion
        DEFAULT v1,\n        hwType OBJECT IDENTIFIER,\n        hwSerialNum OCTET
        STRING,\n        errorCode FirmwarePackageLoadErrorCode,\n        vendorErrorCode
        VendorLoadErrorCode OPTIONAL,\n        fwPkgName PreferredOrLegacyPackageIdentifier
        OPTIONAL,\n        config [1] SEQUENCE OF CurrentFWConfig OPTIONAL }\n      FWErrorVersion
        ::= INTEGER { v1(1) }\n      CurrentFWConfig ::= SEQUENCE {\n        fwPkgType
        INTEGER OPTIONAL,\n        fwPkgName PreferredOrLegacyPackageIdentifier }\n
        \     FirmwarePackageLoadErrorCode ::= ENUMERATED {\n        decodeFailure
        \               (1),\n        badContentInfo               (2),\n        badSignedData
        \               (3),\n        badEncapContent              (4),\n        badCertificate
        \              (5),\n        badSignerInfo                (6),\n        badSignedAttrs
        \              (7),\n        badUnsignedAttrs             (8),\n        missingContent
        \              (9),\n        noTrustAnchor               (10),\n        notAuthorized
        \              (11),\n        badDigestAlgorithm          (12),\n        badSignatureAlgorithm
        \      (13),\n        unsupportedKeySize          (14),\n        signatureFailure
        \           (15),\n        contentTypeMismatch         (16),\n        badEncryptedData
        \           (17),\n        unprotectedAttrsPresent     (18),\n        badEncryptContent
        \          (19),\n        badEncryptAlgorithm         (20),\n        missingCiphertext
        \          (21),\n        noDecryptKey                (22),\n        decryptFailure
        \             (23),\n        badCompressAlgorithm        (24),\n        missingCompressedContent
        \   (25),\n        decompressFailure           (26),\n        wrongHardware
        \              (27),\n        stalePackage                (28),\n        notInCommunity
        \             (29),\n        unsupportedPackageType      (30),\n        missingDependency
        \          (31),\n        wrongDependencyVersion      (32),\n        insufficientMemory
        \         (33),\n        badFirmware                 (34),\n        unsupportedParameters
        \      (35),\n        breaksDependency            (36),\n        otherError
        \                 (99) }\n      VendorLoadErrorCode ::= INTEGER\n   The fields
        of the FirmwarePackageLoadError type have the following\n   meanings:\n   version
        is an integer, and it provides the syntax version number for\n      compatibility
        with future revisions of this specification.\n      Implementations that conform
        to this specification MUST set the\n      version to the default value, which
        is v1.\n   hwType is an object identifier that identifies the type of hardware\n
        \     module on which the firmware package load was attempted.\n   hwSerialNum
        is the serial number of the hardware module on which the\n      firmware package
        load was attempted.  No particular structure is\n      imposed on the serial
        number; it need not be an integer.  However,\n      the combination of the
        hwType and hwSerialNum uniquely identifies\n      the hardware module.\n   errorCode
        identifies the error that occurred.\n   vendorErrorCode is optional; however,
        it MUST be present if the\n      errorCode contains a value of otherError.
        \ When errorCode contains\n      a value other than otherError, the vendorErrorCode
        can provide\n      vendor-specific supplemental information.\n   fwPkgName
        is optional.  When it is present, it identifies the\n      firmware package
        that was being loaded when the error occurred.\n      As described in Section
        2.2.3, two approaches to naming firmware\n      packages are supported: legacy
        and preferred.  A legacy firmware\n      package name is an octet string.
        \ A preferred firmware package\n      name is a combination of the firmware
        package object identifier\n      and an integer version number.\n   config
        identifies the current firmware configuration.  The field is\n      OPTIONAL,
        but support for this field is RECOMMENDED for hardware\n      modules that
        permit the loading of more than one firmware package.\n      One instance
        of CurrentFWConfig is used to provide information\n      about each firmware
        package in hardware module.\n   The fields of the CurrentFWConfig type have
        the following meanings:\n   fwPkgType identifies the firmware package type.
        \ The firmware package\n      type is an INTEGER, and the meaning of the integer
        value is\n      specific to each hardware module.\n   fwPkgName identifies
        the firmware package.  As described in Section\n      2.2.3, two approaches
        to naming firmware packages are supported:\n      legacy and preferred.  A
        legacy firmware package name is an octet\n      string.  A preferred firmware
        package name is a combination of the\n      firmware package object identifier
        and an integer version number.\n   The errorCode values have the following
        meanings:\n   decodeFailure: The ASN.1 decode of the firmware package load
        failed.\n      The provided input did not conform to BER, or it was not ASN.1
        at\n      all.\n   badContentInfo: Invalid ContentInfo syntax, or the contentType\n
        \     carried within the ContentInfo is unknown or unsupported.\n   badSignedData:
        Invalid SignedData syntax, the version is unknown or\n      unsupported, or
        more than one entry is present in\n      digestAlgorithms.\n   badEncapContent:
        Invalid EncapsulatedContentInfo syntax, or the\n      contentType carried
        within the eContentType is unknown or\n      unsupported.  This error can
        be generated due to problems located\n      in SignedData or CompressedData.\n
        \  badCertificate: Invalid syntax for one or more certificates in\n      CertificateSet.\n
        \  badSignerInfo: Invalid SignerInfo syntax, or the version is unknown\n      or
        unsupported.\n   badSignedAttrs: Invalid signedAttrs syntax within SignerInfo.\n
        \  badUnsignedAttrs: The unsignedAttrs within SignerInfo contains an\n      attribute
        other than the wrapped-firmware-decryption-key\n      attribute, which is
        the only unsigned attribute supported by this\n      specification.\n   missingContent:
        The optional eContent is missing in\n      EncapsulatedContentInfo, which
        is required in this specification.\n      This error can be generated due
        to problems located in SignedData\n      or CompressedData.\n   noTrustAnchor:
        Two situations can lead to this error.  In one case,\n      the subjectKeyIdentifier
        does not identify the public key of a\n      trust anchor or a certification
        path that terminates with an\n      installed trust anchor.  In the other
        case, the\n      issuerAndSerialNumber does not identify the public key of
        a trust\n      anchor or a certification path that terminates with an installed\n
        \     trust anchor.\n   notAuthorized: The sid within SignerInfo leads to
        an installed trust\n      anchor, but that trust anchor is not an authorized
        firmware\n      package signer.\n   badDigestAlgorithm: The digestAlgorithm
        in either SignerInfo or\n      SignedData is unknown or unsupported.\n   badSignatureAlgorithm:
        The signatureAlgorithm in SignerInfo is\n      unknown or unsupported.\n   unsupportedKeySize:
        The signatureAlgorithm in SignerInfo is known and\n      supported, but the
        firmware package signature could not be\n      validated because an unsupported
        key size was employed by the\n      signer.\n   signatureFailure: The signatureAlgorithm
        in SignerInfo is known and\n      supported, but the signature in signature
        in SignerInfo could not\n      be validated.\n   contentTypeMismatch: The
        contentType carried within the eContentType\n      does not match the content
        type carried in the signed attribute.\n   badEncryptedData: Invalid EncryptedData
        syntax; the version is\n      unknown or unsupported.\n   unprotectedAttrsPresent:
        EncryptedData contains unprotectedAttrs,\n      which are not permitted in
        this specification.\n   badEncryptContent: Invalid EncryptedContentInfo syntax,
        or the\n      contentType carried within the contentType is unknown or\n      unsupported.\n
        \  badEncryptAlgorithm: The firmware-encryption algorithm identified by\n
        \     contentEncryptionAlgorithm in EncryptedContentInfo is unknown or\n      unsupported.\n
        \  missingCiphertext: The optional encryptedContent is missing in\n      EncryptedContentInfo,
        which is required in this specification.\n   noDecryptKey: The hardware module
        does not have the firmware-\n      decryption key named in the decrypt key
        identifier signed\n      attribute.\n   decryptFailure: The firmware package
        did not decrypt properly.\n   badCompressAlgorithm: The compression algorithm
        identified by\n      compressionAlgorithm in CompressedData is unknown or
        unsupported.\n   missingCompressedContent: The optional eContent is missing
        in\n      EncapsulatedContentInfo, which is required in this specification.\n
        \  decompressFailure: The firmware package did not decompress properly.\n
        \  wrongHardware: The processing hardware module is not listed in the\n      target
        hardware module identifiers signed attribute.\n   stalePackage: The firmware
        package is rejected because it is stale.\n   notInCommunity: The hardware
        module is not a member of the community\n      described in the community
        identifiers signed attribute.\n   unsupportedPackageType: The firmware package
        type identified in the\n      firmware package information signed attribute
        is not supported by\n      the combination of the hardware module and the
        bootstrap loader.\n   missingDependency: The firmware package being loaded
        depends on\n      routines that are part of another firmware package, but
        that\n      firmware package is not available.\n   wrongDependencyVersion:
        The firmware package being loaded depends on\n      routines that are part
        of the another firmware package, and the\n      available version of that
        package has an older version number than\n      is required.  The available
        firmware package does not fulfill the\n      dependencies.\n   insufficientMemory:
        The firmware package could not be loaded because\n      the hardware module
        did not have sufficient memory.\n   badFirmware: The signature on the firmware
        package was validated, but\n      the firmware package itself was not in an
        acceptable format.  The\n      details will be specific to each hardware module.
        \ For example, a\n      hardware module that is composed of multiple firmware-programmable\n
        \     components could not find the internal tagging within the firmware\n
        \     package to distribute executable code to each of the components.\n   unsupportedParameters:
        The signature on the firmware package could\n      not be validated because
        the signer used signature algorithm\n      parameters that are not supported
        by the hardware module signature\n      verification routines.\n   breaksDependency:
        Another firmware package has a dependency that can\n      no longer be satisfied
        if the firmware package being loaded is\n      accepted.\n   otherError: An
        error occurred that does not fit any of the previous\n      error codes.\n"
      title: 4.1.3.  FirmwarePackageLoadError
    title: 4.1.  Firmware Package Load Error CMS Content Type Profile
  - contents:
    - "4.2.  Signed Attributes\n   The hardware module MUST digitally sign a collection
      of attributes\n   along with the firmware package load error report.  Each attribute
      in\n   the collection MUST be DER encoded [X.509-88].  The syntax for\n   attributes
      is defined in [CMS], and it was repeated in Section 2.2\n   for convenience.\n
      \  Each of the attributes used with this profile has a single attribute\n   value,
      even though the syntax is defined as a SET OF AttributeValue.\n   There MUST
      be exactly one instance of AttributeValue present.\n   The SignedAttributes
      syntax within signerInfo is defined as a SET OF\n   Attributes.  The SignedAttributes
      MUST include only one instance of\n   any particular attribute.\n   The hardware
      module MUST include the content-type and message-digest\n   attributes.  If
      the hardware module includes a real-time clock, then\n   the hardware module
      SHOULD also include the signing-time attribute.\n   The hardware module MAY
      include any other attribute that it deems\n   appropriate.\n"
    - contents:
      - "4.2.1.  Content Type\n   The hardware module MUST include a content-type
        attribute with the\n   value of id-ct-firmwareLoadError (1.2.840.113549.1.9.16.1.18).\n
        \  Section 11.1 of [CMS] defines the content-type attribute.\n"
      title: 4.2.1.  Content Type
    - contents:
      - "4.2.2.  Message Digest\n   The hardware module MUST include a message-digest
        attribute, having\n   as its value the message digest of the FirmwarePackageLoadError\n
        \  content.  Section 11.2 of [CMS] defines the message-digest attribute.\n"
      title: 4.2.2.  Message Digest
    - contents:
      - "4.2.3.  Signing Time\n   If the hardware module includes a real-time clock,
        then hardware\n   module SHOULD include a signing-time attribute, specifying
        the time\n   at which the firmware package load error report was generated.\n
        \  Section 11.3 of [CMS] defines the signing-time attribute.\n"
      title: 4.2.3.  Signing Time
    title: 4.2.  Signed Attributes
  title: 4.  Firmware Package Load Error
- contents:
  - "5.  Hardware Module Name\n   Support for firmware package load receipts, as discussed
    in Section\n   3, is OPTIONAL, and support for the firmware package load error\n
    \  reports, as discussed in Section 4, is OPTIONAL.  Hardware modules\n   that
    support receipt or error report generation MUST have unique\n   serial numbers.
    \ Further, hardware modules that support signed\n   receipt or error report generation
    MUST have private signature keys\n   and corresponding signature validation certificates
    [PROFILE] or\n   their designators.  The conventions for hardware module naming
    in the\n   signature validation certificates are specified in this section.\n
    \  The hardware module vendor or a trusted third party MUST issue the\n   signature
    validation certificate prior to deployment of the hardware\n   module.  The certificate
    is likely to be issued at the time of\n   manufacture.  The subject alternative
    name in this certificate\n   identifies the hardware module.  The subject distinguished
    name is\n   empty, but a critical subject alternative name extension contains
    the\n   hardware module name, using the otherName choice within the\n   GeneralName
    structure.\n   The hardware module name form is identified by the id-on-\n   hardwareModuleName
    object identifier:\n      id-on-hardwareModuleName OBJECT IDENTIFIER ::= {\n        iso(1)
    identified-organization(3) dod(6) internet(1) security(5)\n        mechanisms(5)
    pkix(7) on(8) 4 }\n   A HardwareModuleName is composed of an object identifier
    and an octet\n   string:\n      HardwareModuleName ::= SEQUENCE {\n        hwType
    OBJECT IDENTIFIER,\n        hwSerialNum OCTET STRING }\n   The fields of the HardwareModuleName
    type have the following\n   meanings:\n   hwType is an object identifier that
    identifies the type of hardware\n      module.  A unique object identifier names
    a hardware model and\n      revision.\n   hwSerialNum is the serial number of
    the hardware module.  No\n      particular structure is imposed on the serial
    number; it need not\n      be an integer.  However, the combination of the hwType
    and\n      hwSerialNum uniquely identifies the hardware module.\n"
  title: 5.  Hardware Module Name
- contents:
  - "6.  Security Considerations\n   This document describes the use of the Cryptographic
    Message Syntax\n   (CMS) to protect firmware packages; therefore, the security\n
    \  considerations discussed in [CMS] apply to this specification as\n   well.\n
    \  The conventions specified in this document raise a few security\n   considerations
    of their own.\n"
  - contents:
    - "6.1.  Cryptographic Keys and Algorithms\n   Private signature keys must be
      protected.  Compromise of the private\n   key used to sign firmware packages
      permits unauthorized parties to\n   generate firmware packages that are acceptable
      to hardware modules.\n   Compromise of the hardware module private key allows
      unauthorized\n   parties to generate signed firmware package load receipts and
      error\n   reports.\n   The firmware-decryption key must be protected.  Compromise
      of the key\n   may result in the disclosure of the firmware package to unauthorized\n
      \  parties.\n   Cryptographic algorithms become weaker with time.  As new\n
      \  cryptanalysis techniques are developed and computing performance\n   improves,
      the work factor to break a particular cryptographic\n   algorithm will be reduced.
      \ The ability to change the firmware\n   package provides an opportunity to
      update or replace cryptographic\n   algorithms.  Although this capability is
      desirable, cryptographic\n   algorithm replacement can lead to interoperability
      failures.\n   Therefore, the rollout of new cryptographic algorithms must be\n
      \  managed.  Generally, the previous generation of cryptographic\n   algorithms
      and their replacements need to be supported at the same\n   time in order to
      facilitate an orderly transition.\n"
    title: 6.1.  Cryptographic Keys and Algorithms
  - contents:
    - "6.2.  Random Number Generation\n   When firmware packages are encrypted, the
      source of the firmware\n   package must randomly generate firmware-encryption
      keys.  Also, the\n   generation of public/private signature key pairs relies
      on a random\n   numbers.  The use of inadequate pseudo-random number generators\n
      \  (PRNGs) to generate cryptographic keys can result in little or no\n   security.
      \ An attacker may find it much easier to reproduce the PRNG\n   environment
      that produced the keys, searching the resulting small set\n   of possibilities,
      rather than brute-force searching the whole key\n   space.  The generation of
      quality random numbers is difficult.  RFC\n   4086 [RANDOM] offers important
      guidance in this area.\n"
    title: 6.2.  Random Number Generation
  - contents:
    - "6.3.  Stale Firmware Package Version Number\n   The firmware signer determines
      whether a stale version number is\n   included.  The policy of the firmware
      signer needs to consider many\n   factors.  Consider the flaw found by Ian Goldberg
      and David Wagner in\n   the random number generator of the Netscape browser
      in 1996 [DDJ].\n   This flaw completely undermines confidentiality protection.
      \ A\n   firmware signer might use the stale version number to ensure that\n
      \  upgraded hardware modules do not resume use of the flawed firmware.\n   However,
      another firmware signer may not consider this an appropriate\n   situation to
      employ the stale version number, preferring to delegate\n   this decision to
      someone closer to the operation of the hardware\n   module.  Such a person is
      likely to be in a better position to\n   evaluate whether other bugs introduced
      in the newer firmware package\n   impose worse operational concerns than the
      confidentiality concern\n   caused by the flawed random number generator.  For
      example, a user\n   who never uses the encryption feature of the flawed Netscape
      browser\n   will determine the most appropriate version to use without\n   considering
      the random number flaw or its fix.\n   The stale version number is especially
      useful when the security\n   interests of the person choosing which firmware
      package version to\n   load into a particular hardware module do not align with
      the security\n   interests of the firmware package signer.  For example, stale
      version\n   numbers may be useful in hardware modules that provide digital rights\n
      \  management (DRM).  Also, stale version numbers will be useful when\n   the
      deployment organization (as opposed to the firmware package\n   vendor) is the
      firmware signer.  Further, stale version numbers will\n   be useful for firmware
      packages that need to be trusted to implement\n   organizational (as opposed
      to the deployment organization) security\n   policy, regardless of whether the
      firmware signer is the deployment\n   organization or the vendor.  For example,
      hardware devices employed\n   by the military will probably make use of stale
      version numbers.\n   The use of a stale version number in a firmware package
      that employs\n   the preferred firmware package name form cannot completely
      prevent\n   subsequent use of the stale firmware package.  Despite this\n   shortcoming,
      the feature is included since it is useful in some\n   important situations.
      \ By loading different types of firmware\n   packages, each with its own stale
      firmware package version number\n   until the internal storage for the stale
      version number is exceeded,\n   the user can circumvent the mechanism.  Consider
      a hardware module\n   that has storage for two stale version numbers.  Suppose
      that FWPKG-A\n   version 3 is loaded, indicating that FWPKG-A version 2 is stale.
      \ The\n   user can sequentially load the following:\n      - FWPKG-B version
      8, indicating that FWPKG-B version 4 is stale.\n          (Note: The internal
      storage indicates that FWPKG-A version 2\n           and FWPKG-B version 4 are
      stale.)\n      - FWPKG-C version 5, indicating that FWPKG-C version 3 is stale.\n
      \         (Note: The internal storage indicates that FWPKG-B version 4\n           and
      FWPKG-C version 3 are stale.)\n      - FWPKG-A version 2.\n   Because many hardware
      modules are expected to have very few firmware\n   packages written for them,
      the stale firmware package version feature\n   provides important protections.
      \ The amount of non-volatile storage\n   that needs to be dedicated to saving
      firmware package identifiers and\n   version numbers depends on the number of
      firmware packages that are\n   likely to be developed for the hardware module.\n
      \  The use of legacy firmware package name form does not improve this\n   situation.
      \ In fact, the legacy firmware package names are usually\n   larger than an
      object identifier.  Thus, comparable stale version\n   protection requires more
      memory.\n   A firmware signer can ensure that stale version numbers are honored\n
      \  by limiting the number of different types of firmware packages that\n   are
      signed.  If all of the hardware modules are able to store a stale\n   version
      number for each of the different types of firmware package,\n   then the hardware
      module will be able to provide the desired\n   protection.  This requires the
      firmware signer to have a deep\n   understanding of all of the hardware modules
      that might accept the\n   firmware package.\n"
    title: 6.3.  Stale Firmware Package Version Number
  - contents:
    - "6.4.  Community Identifiers\n   When a firmware package includes a community
      identifier, the\n   confidence that the package is only used by the intended
      community\n   depends on the mechanism used to configure community membership.\n
      \  This document does not specify a mechanism for the assignment of\n   community
      membership to hardware modules, and the various\n   alternatives have different
      security properties.  Also, the authority\n   that makes community identifier
      assignments to hardware modules might\n   be different than the authority that
      generates firmware packages.\n"
    title: 6.4.  Community Identifiers
  title: 6.  Security Considerations
- contents:
  - '7.  References

    '
  - contents:
    - "7.1.  Normative References\n   [COMPRESS]   Gutmann, P., \"Compressed Data
      Content Type for\n                Cryptographic Message Syntax (CMS)\", RFC
      3274, June\n                2002.\n   [CMS]        Housley, R., \"Cryptographic
      Message Syntax (CMS)\", RFC\n                3852, July 2004.\n   [ESS]        Hoffman,
      P., \"Enhanced Security Services for S/MIME\",\n                RFC 2634, June
      1999.\n   [PROFILE]    Housley, R., Polk, W., Ford, W., and D. Solo, \"Internet\n
      \               X.509 Public Key Infrastructure Certificate and\n                Certificate
      Revocation List (CRL) Profile\", RFC 3280,\n                April 2002.\n   [SHA1]
      \      National Institute of Standards and Technology.  FIPS\n                Pub
      180-1: Secure Hash Standard.  17 April 1995.\n   [STDWORDS]   Bradner, S., \"Key
      words for use in RFCs to Indicate\n                Requirement Levels\", BCP
      14, RFC 2119, March 1997.\n   [UTF-8]      Yergeau, F., \"UTF-8, a transformation
      format of ISO\n                10646\", STD 63, RFC 3629, November 2003.\n   [X.208-88]
      \  CCITT.  Recommendation X.208: Specification of Abstract\n                Syntax
      Notation One (ASN.1).  1988.\n   [X.209-88]   CCITT.  Recommendation X.209:
      Specification of Basic\n                Encoding Rules for Abstract Syntax Notation
      One (ASN.1).\n                1988.\n   [X.509-88]   CCITT.  Recommendation
      X.509: The Directory -\n                Authentication Framework.  1988.\n"
    title: 7.1.  Normative References
  - contents:
    - "7.2.  Informative References\n   [ACPROFILE]  Farrell, S. and R. Housley, \"An
      Internet Attribute\n                Certificate Profile for Authorization\",
      RFC 3281, April\n                2002.\n   [AES]        National Institute of
      Standards and Technology.  FIPS\n                Pub 197:  Advanced Encryption
      Standard (AES).  26\n                November 2001.\n   [DDJ]        Goldberg,
      I. and D. Wagner.  \"Randomness and the\n                Netscape Browser.\"
      \ Dr. Dobb's Journal, January 1996.\n   [DPD&DPV]    Pinkas, D. and R. Housley,
      \"Delegated Path Validation\n                and Delegated Path Discovery Protocol
      Requirements\", RFC\n                3379, September 2002.\n   [OCSP]       Myers,
      M., Ankney, R., Malpani, A., Galperin, S., and C.\n                Adams, \"X.509
      Internet Public Key Infrastructure Online\n                Certificate Status
      Protocol - OCSP\", RFC 2560, June\n                1999.\n   [PKCS#6]     RSA
      Laboratories.  PKCS #6: Extended-Certificate Syntax\n                Standard,
      Version 1.5.  November 1993.\n   [RANDOM]     Eastlake, D., 3rd, Schiller, J.,
      and S. Crocker,\n                \"Randomness Requirements for Security\", BCP
      106, RFC\n                4086, June 2005.\n   [SECREQMTS]  National Institute
      of Standards and Technology.  FIPS\n                Pub 140-2: Security Requirements
      for Cryptographic\n                Modules.  25 May 2001.\n   [X.509-97]   ITU-T.
      \ Recommendation X.509: The Directory -\n                Authentication Framework.
      \ 1997.\n   [X.509-00]   ITU-T.  Recommendation X.509: The Directory -\n                Authentication
      Framework.  2000.\n"
    title: 7.2.  Informative References
  title: 7.  References
- contents:
  - "Appendix A: ASN.1 Module\n   The ASN.1 module contained in this appendix defines
    the structures\n   that are needed to implement the CMS-based firmware package
    wrapper.\n   It is expected to be used in conjunction with the ASN.1 modules in\n
    \  [CMS], [COMPRESS], and [PROFILE].\n   CMSFirmwareWrapper\n       { iso(1) member-body(2)
    us(840) rsadsi(113549) pkcs(1)\n         pkcs-9(9) smime(16) modules(0) cms-firmware-wrap(22)
    }\n   DEFINITIONS IMPLICIT TAGS ::= BEGIN\n   IMPORTS\n       EnvelopedData\n
    \      FROM CryptographicMessageSyntax -- [CMS]\n            { iso(1) member-body(2)
    us(840) rsadsi(113549)\n              pkcs(1) pkcs-9(9) smime(16) modules(0) cms-2004(24)
    };\n   -- Firmware Package Content Type and Object Identifier\n   id-ct-firmwarePackage
    OBJECT IDENTIFIER ::= {\n     iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
    pkcs9(9)\n     smime(16) ct(1) 16 }\n   FirmwarePkgData ::= OCTET STRING\n   --
    Firmware Package Signed Attributes and Object Identifiers\n   id-aa-firmwarePackageID
    OBJECT IDENTIFIER ::= {\n     iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
    pkcs9(9)\n     smime(16) aa(2) 35 }\n   FirmwarePackageIdentifier ::= SEQUENCE
    {\n     name PreferredOrLegacyPackageIdentifier,\n     stale PreferredOrLegacyStalePackageIdentifier
    OPTIONAL }\n   PreferredOrLegacyPackageIdentifier ::= CHOICE {\n     preferred
    PreferredPackageIdentifier,\n     legacy OCTET STRING }\n   PreferredPackageIdentifier
    ::= SEQUENCE {\n     fwPkgID OBJECT IDENTIFIER,\n     verNum INTEGER (0..MAX)
    }\n   PreferredOrLegacyStalePackageIdentifier ::= CHOICE {\n     preferredStaleVerNum
    INTEGER (0..MAX),\n     legacyStaleVersion OCTET STRING }\n   id-aa-targetHardwareIDs
    OBJECT IDENTIFIER ::= {\n     iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
    pkcs9(9)\n     smime(16) aa(2) 36 }\n   TargetHardwareIdentifiers ::= SEQUENCE
    OF OBJECT IDENTIFIER\n   id-aa-decryptKeyID OBJECT IDENTIFIER ::= {\n     iso(1)
    member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs9(9)\n     smime(16) aa(2) 37
    }\n   DecryptKeyIdentifier ::= OCTET STRING\n   id-aa-implCryptoAlgs OBJECT IDENTIFIER
    ::= {\n     iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs9(9)\n     smime(16)
    aa(2) 38 }\n   ImplementedCryptoAlgorithms ::= SEQUENCE OF OBJECT IDENTIFIER\n
    \  id-aa-implCompressAlgs OBJECT IDENTIFIER ::= {\n     iso(1) member-body(2)
    us(840) rsadsi(113549) pkcs(1) pkcs9(9)\n     smime(16) aa(2) 43 }\n   ImplementedCompressAlgorithms
    ::= SEQUENCE OF OBJECT IDENTIFIER\n   id-aa-communityIdentifiers OBJECT IDENTIFIER
    ::= {\n     iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs9(9)\n     smime(16)
    aa(2) 40 }\n   CommunityIdentifiers ::= SEQUENCE OF CommunityIdentifier\n   CommunityIdentifier
    ::= CHOICE {\n     communityOID OBJECT IDENTIFIER,\n     hwModuleList HardwareModules
    }\n   HardwareModules ::= SEQUENCE {\n     hwType OBJECT IDENTIFIER,\n     hwSerialEntries
    SEQUENCE OF HardwareSerialEntry }\n   HardwareSerialEntry ::= CHOICE {\n     all
    NULL,\n     single OCTET STRING,\n     block SEQUENCE {\n       low OCTET STRING,\n
    \      high OCTET STRING } }\n   id-aa-firmwarePackageInfo OBJECT IDENTIFIER ::=
    {\n     iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs9(9)\n     smime(16)
    aa(2) 42 }\n   FirmwarePackageInfo ::= SEQUENCE {\n     fwPkgType INTEGER OPTIONAL,\n
    \    dependencies SEQUENCE OF\n       PreferredOrLegacyPackageIdentifier OPTIONAL
    }\n   -- Firmware Package Unsigned Attributes and Object Identifiers\n   id-aa-wrappedFirmwareKey
    OBJECT IDENTIFIER ::= {\n     iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
    pkcs9(9)\n     smime(16) aa(2) 39 }\n   WrappedFirmwareKey ::= EnvelopedData\n
    \  -- Firmware Package Load Receipt Content Type and Object Identifier\n   id-ct-firmwareLoadReceipt
    OBJECT IDENTIFIER ::= {\n     iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
    pkcs9(9)\n     smime(16) ct(1) 17 }\n   FirmwarePackageLoadReceipt ::= SEQUENCE
    {\n     version FWReceiptVersion DEFAULT v1,\n     hwType OBJECT IDENTIFIER,\n
    \    hwSerialNum OCTET STRING,\n     fwPkgName PreferredOrLegacyPackageIdentifier,\n
    \    trustAnchorKeyID OCTET STRING OPTIONAL,\n     decryptKeyID [1] OCTET STRING
    OPTIONAL }\n   FWReceiptVersion ::= INTEGER { v1(1) }\n   -- Firmware Package
    Load Error Report Content Type\n   -- and Object Identifier\n   id-ct-firmwareLoadError
    OBJECT IDENTIFIER ::= {\n     iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1)
    pkcs9(9)\n     smime(16) ct(1) 18 }\n   FirmwarePackageLoadError ::= SEQUENCE
    {\n     version FWErrorVersion DEFAULT v1,\n     hwType OBJECT IDENTIFIER,\n     hwSerialNum
    OCTET STRING,\n     errorCode FirmwarePackageLoadErrorCode,\n     vendorErrorCode
    VendorLoadErrorCode OPTIONAL,\n     fwPkgName PreferredOrLegacyPackageIdentifier
    OPTIONAL,\n     config [1] SEQUENCE OF CurrentFWConfig OPTIONAL }\n   FWErrorVersion
    ::= INTEGER { v1(1) }\n   CurrentFWConfig ::= SEQUENCE {\n     fwPkgType INTEGER
    OPTIONAL,\n     fwPkgName PreferredOrLegacyPackageIdentifier }\n   FirmwarePackageLoadErrorCode
    ::= ENUMERATED {\n     decodeFailure                (1),\n     badContentInfo
    \              (2),\n     badSignedData                (3),\n     badEncapContent
    \             (4),\n     badCertificate               (5),\n     badSignerInfo
    \               (6),\n     badSignedAttrs               (7),\n     badUnsignedAttrs
    \            (8),\n     missingContent               (9),\n     noTrustAnchor
    \              (10),\n     notAuthorized               (11),\n     badDigestAlgorithm
    \         (12),\n     badSignatureAlgorithm       (13),\n     unsupportedKeySize
    \         (14),\n     signatureFailure            (15),\n     contentTypeMismatch
    \        (16),\n     badEncryptedData            (17),\n     unprotectedAttrsPresent
    \    (18),\n     badEncryptContent           (19),\n     badEncryptAlgorithm         (20),\n
    \    missingCiphertext           (21),\n     noDecryptKey                (22),\n
    \    decryptFailure              (23),\n     badCompressAlgorithm        (24),\n
    \    missingCompressedContent    (25),\n     decompressFailure           (26),\n
    \    wrongHardware               (27),\n     stalePackage                (28),\n
    \    notInCommunity              (29),\n     unsupportedPackageType      (30),\n
    \    missingDependency           (31),\n     wrongDependencyVersion      (32),\n
    \    insufficientMemory          (33),\n     badFirmware                 (34),\n
    \    unsupportedParameters       (35),\n     breaksDependency            (36),\n
    \    otherError                  (99) }\n   VendorLoadErrorCode ::= INTEGER\n
    \  -- Other Name syntax for Hardware Module Name\n   id-on-hardwareModuleName
    OBJECT IDENTIFIER ::= {\n     iso(1) identified-organization(3) dod(6) internet(1)
    security(5)\n     mechanisms(5) pkix(7) on(8) 4 }\n   HardwareModuleName ::= SEQUENCE
    {\n     hwType OBJECT IDENTIFIER,\n     hwSerialNum OCTET STRING }\n   END\n"
  title: 'Appendix A: ASN.1 Module'
- contents:
  - "Author's Address\n   Russell Housley\n   Vigil Security, LLC\n   918 Spring Knoll
    Drive\n   Herndon, VA 20170\n   USA\n   EMail: housley@vigilsec.com\n"
  title: Author's Address
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This
    document is subject to the rights, licenses and restrictions\n   contained in
    BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n
    \  This document and the information contained herein are provided on an\n   \"AS
    IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING TASK FORCE
    DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT LIMITED TO
    ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT INFRINGE ANY
    RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at ietf-\n   ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
