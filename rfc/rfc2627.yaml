- title: __initial_text__
  contents:
  - '         Key Management for Multicast: Issues and Architectures

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This report contains a discussion of the difficult problem of key\n\
    \   management for multicast communication sessions.  It focuses on two\n   main\
    \ areas of concern with respect to key management, which are,\n   initializing\
    \ the multicast group with a common net key and rekeying\n   the multicast group.\
    \  A rekey may be necessary upon the compromise of\n   a user or for other reasons\
    \ (e.g., periodic rekey).  In particular,\n   this report identifies a technique\
    \ which allows for secure compromise\n   recovery, while also being robust against\
    \ collusion of excluded\n   users.  This is one important feature of multicast\
    \ key management\n   which has not been addressed in detail by most other multicast\
    \ key\n   management proposals [1,2,4].  The benefits of this proposed\n   technique\
    \ are that it minimizes the number of transmissions required\n   to rekey the\
    \ multicast group and it imposes minimal storage\n   requirements on the multicast\
    \ group.\n"
- title: 1.0  MOTIVATION
  contents:
  - "1.0  MOTIVATION\n   It is recognized that future networks will have requirements\
    \ that\n   will strain the capabilities of current key management architectures.\n\
    \   One of these requirements will be the secure multicast requirement.\n   The\
    \ need for high bandwidth, very dynamic secure multicast\n   communications is\
    \ increasingly evident in a wide variety of\n   commercial, government, and Internet\
    \ communities.  Specifically, the\n   secure multicast requirement is the necessity\
    \ for multiple users who\n   share the same security attributes and communication\
    \ requirements to\n   securely communicate with every other member of the multicast\
    \ group\n   using a common multicast group net key.  The largest benefit of the\n\
    \   multicast communication being that multiple receivers simultaneously\n   get\
    \ the same transmission.  Thus the problem is enabling each user to\n   determine/obtain\
    \ the same net key without permitting unauthorized\n   parties to do likewise\
    \ (initializing the multicast group) and\n   securely rekeying the users of the\
    \ multicast group when necessary.\n   At first glance, this may not appear to\
    \ be any different than current\n   key management scenarios.  This paper will\
    \ show, however, that future\n   multicast scenarios will have very divergent\
    \ and dynamically changing\n   requirements which will make it very challenging\
    \ from a key\n   management perspective to address.\n"
- title: 2.0  INTRODUCTION
  contents:
  - "2.0  INTRODUCTION\n   The networks of the future will be able to support gigabit\
    \ bandwidths\n   for individual users, to large groups of users.  These users\
    \ will\n   possess various quality of service options and multimedia\n   applications\
    \ that include video, voice, and data, all on the same\n   network backbone. \
    \ The desire to create small groups of users all\n   interconnected and capable\
    \ of communicating with each other, but who\n   are securely isolated from all\
    \ other users on the network is being\n   expressed strongly by users in a variety\
    \ of communities.\n   The key management infrastructure must support bandwidths\
    \ ranging\n   from kilobits/second to gigabits/second, handle a range of multicast\n\
    \   group sizes, and be flexible enough for example to handle such\n   communications\
    \ environments as wireless and mobile technologies.  In\n   addition to these\
    \ performance and communications requirements, the\n   security requirements of\
    \ different scenarios are also wide ranging.\n   It is required that users can\
    \ be added and removed securely and\n   efficiently, both individually and in\
    \ bulk.  The system must be\n   resistant to compromise, insofar as users who\
    \ have been dropped\n   should not be able to read any subsequent traffic, even\
    \ if they share\n   their secret information.  The costs we seek to minimize are\
    \ time\n   required for setup, storage space for each end user, and total number\n\
    \   of transmissions required for setup, rekey and maintenance.  It is\n   also\
    \ envisioned that any proposed multicast security mechanisms will\n   be implemented\
    \ no lower than any layer with the characteristics of\n   the network layer of\
    \ the protocol stack.  Bandwidth efficiency for\n   any key management system\
    \ must also be considered.  The trade-off\n   between security and performance\
    \ of the entire multicast session\n   establishment will be discussed in further\
    \ detail later in this\n   document.\n   The following section will explain several\
    \ potential scenarios where\n   multicast capabilities may be needed, and quantify\
    \ their requirements\n   from both a performance and security perspective.  It\
    \ will be\n   followed in Section 4.0 by a list of factors one must consider when\n\
    \   designing a potential solution.  While there are several security\n   services\
    \ that will be covered at some point in this document, much of\n   the focus of\
    \ this document has been on the generation and\n   distribution of multicast group\
    \ net keys.  It is assumed that all\n   potential multicast participants either\
    \ through some manual or\n   automated, centralized or decentralized mechanism\
    \ have received\n   initialization keying material (e.g. certificates).  This\
    \ document\n   does not address the initialization key distribution issue.  Section\n\
    \   5 will then detail several potential multicast key management\n   architectures,\
    \ manual (symmetric) and public key based (asymmetric),\n   and highlight their\
    \ relative advantages and disadvantages (Note:The\n   list of advantages and disadvantages\
    \ is by no means all inclusive.).\n   In particular, this section emphasizes our\
    \ technique which allows for\n   secure compromise recovery.\n"
- title: 3.0  MULTICAST SCENARIOS
  contents:
  - "3.0  MULTICAST SCENARIOS\n   There are a variety of potential scenarios that\
    \ may stress the key\n   management infrastructure.  These scenarios include,\
    \ but are not\n   limited to, wargaming, law enforcement, teleconferencing, command\
    \ and\n   control conferencing, disaster relief, and distributed computing.\n\
    \   Potential performance and security requirements, particularly in\n   terms\
    \ of multicast groups that may be formed by these users for each\n   scenario,\
    \ consists of the potential multicast group sizes,\n   initialization requirements\
    \ (how fast do users need to be brought\n   on-line), add/drop requirements (how\
    \ fast a user needs to be added or\n   deleted from the multicast group subsequent\
    \ to initialization), size\n   dynamics (the relative number of people joining/leaving\
    \ these groups\n   per given unit of time), top level security requirements, and\n\
    \   miscellaneous special issues for each scenario.  While some scenarios\n  \
    \ describe future secure multicast requirements, others have immediate\n   security\
    \ needs.\n   As examples, let us consider two scenarios, distributed gaming and\n\
    \   teleconferencing.\n   Distributed gaming deals with the government's need\
    \ to simulate a\n   conflict scenario for the purposes of training and evaluation.\
    \  In\n   addition to actual communications equipment being used, this concept\n\
    \   would include a massive interconnection of computer simulations\n   containing,\
    \ for example, video conferencing and image processing.\n   Distributed gaming\
    \ could be more demanding from a key management\n   perspective than an actual\
    \ scenario for several reasons.  First, the\n   nodes of the simulation net may\
    \ be dispersed throughout the country.\n   Second, very large bandwidth communications,\
    \ which enable the\n   possibility for real time simulation capabilities, will\
    \ drive the\n   need to drop users in and out of the simulation quickly.  This\
    \ is\n   potentially the most demanding scenario of any considered.\n   This scenario\
    \ may involve group sizes of potentially 1000 or more\n   participants, some of\
    \ which may be collected in smaller subgroups.\n   These groups must be initialized\
    \ very rapidly, for example, in a ten\n   second total initialization time.  This\
    \ scenario is also very\n   demanding in that users may be required to be added\
    \ or dropped from\n   the group within one second.  From a size dynamics perspective,\
    \ we\n   estimate that approximately ten percent of the group members may\n  \
    \ change over a one minute time period.  Data rate requirements are\n   broad,\
    \ ranging from kilobits per second (simulating tactical users)\n   to gigabits\
    \ per second (multicast video). The distributed gaming\n   scenario has a fairly\
    \ thorough set of security requirements covering\n   access control, user to user\
    \ authentication, data confidentiality,\n   and data integrity.  It also must\
    \ be \"robust\" which implies the need\n   to handle noisy operating environments\
    \ that are typical for some\n   tactical devices.  Finally, the notion of availability\
    \ is applied to\n   this scenario which implies that the communications network\
    \ supplying\n   the multicast capability must be up and functioning a specified\n\
    \   percentage of the time.\n   The teleconference scenario may involve group\
    \ sizes of potentially\n   1000 or more participants.  These groups may take up\
    \ to minutes to be\n   initialized.  This scenario is less demanding in that users\
    \ may be\n   required to be added or dropped from the group within seconds.  From\n\
    \   a size dynamics perspective, we estimate that approximately ten\n   percent\
    \ of the group members may change over a period of minutes.\n   Data rate requirements\
    \ are broad, ranging from kilobits per second to\n   100's of Mb per second. \
    \ The teleconference scenario also has a\n   fairly thorough set of security requirements\
    \ covering access control,\n   user to user authentication, data confidentiality,\
    \ data integrity,\n   and non-repudiation.  The notion of availability is also\
    \ applicable\n   to this scenario.  The time frame for when this scenario must\
    \ be\n   provided is now.\n"
- title: 4.0   ARCHITECTURAL ISSUES
  contents:
  - "4.0   ARCHITECTURAL ISSUES\n   There are many factors that must be taken into\
    \ account when\n   developing the desired key management architecture.  Important\
    \ issues\n   for key management architectures include level (strength) of\n  \
    \ security, cost, initializing the system, policy concerns, access\n   control\
    \ procedures, performance requirements and support mechanisms.\n   In addition,\
    \ issues particular to multicast groups include:\n      1. What are the security\
    \ requirements of the group members? Most\n         likely there will be some\
    \ group controller, or controllers.  Do\n         the other members possess the\
    \ same security requirements as the\n         controller(s)?\n      2. Interdomain\
    \ issues - When crossing from one \"group domain\" to\n         another domain\
    \ with a potentially different security policy,\n         which policy is enforced?\
    \  An example would be two users\n         wishing to communicate, but having\
    \ different cryptoperiods\n         and/or key length policies.\n      3. How\
    \ does the formation of the multicast group occur?  Will the\n         group controller\
    \ initiate the user joining process, or will the\n         users initiate when\
    \ they join the formation of the multicast\n         group?\n      4. How does\
    \ one handle the case where certain group members have\n         inferior processing\
    \ capabilities which could delay the\n         formation of the net key?  Do these\
    \ users delay the formation\n         of the whole multicast group, or do they\
    \ come on-line later\n         enabling the remaining participants to be brought\
    \ up more\n         quickly?\n      5. One must minimize the number of bits required\
    \ for multicast\n         group net key distribution.  This greatly impacts bandwidth\n\
    \         limited equipments.\n   All of these and other issues need to be taken\
    \ into account, along\n   with the communication protocols that will be used which\
    \ support the\n   desired multicast capability.  The next section addresses some\
    \ of\n   these issues and presents some candidate architectures that could be\n\
    \   used to tackle the key management problem for multicasting.\n"
- title: 5.0  CANDIDATE ARCHITECTURES
  contents:
  - "5.0  CANDIDATE ARCHITECTURES\n   There are several basic functions that must\
    \ be performed in order for\n   a secure multicast session to occur.  The order\
    \ in which these\n   functions will be performed, and the efficiency of the overall\n\
    \   solution results from making trade-offs of the various factors listed\n  \
    \ above.  Before looking at specific architectures, these basic\n   functions\
    \ will be outlined, along with some definition of terms that\n   will be used\
    \ in the representative architectures. These definitions\n   and functions are\
    \ as follows:\n      1. Someone determines the need for a multicast session, sets\
    \ the\n         security attributes for that particular session (e.g.,\n     \
    \    classification levels of traffic, algorithms to be used, key\n         variable\
    \ bit lengths, etc.), and creates the group access\n         control list which\
    \ we will call the initial multicast group\n         participant list.  The entity\
    \ which performs these functions\n         will be called the INITIATOR.  At this\
    \ point, the multicast\n         group participant list is strictly a list of\
    \ users who the\n         initiator wants to be in the multicast group.\n    \
    \  2. The initiator determines who will control the multicast group.\n       \
    \  This controller will be called the ROOT (or equivalently the\n         SERVER).\
    \ Often, the initiator will become the root, but the\n         possibility exists\
    \ where this control may be passed off to\n         someone other than the initiator.\
    \ (Some key management\n         architectures employ multiple roots, see [4].)\
    \ The root's job\n         is to perform the addition and deletion of group participants,\n\
    \         perform user access control against the security attributes of\n   \
    \      that session, and distribute the traffic encryption key for the\n     \
    \    session which we will call the multicast group NET KEY.  After\n        \
    \ initialization, the entity with the authority to accept or\n         reject\
    \ the addition of future group participants, or delete\n         current group\
    \ participants is called the LIST CONTROLLER.\n         This may or may not be\
    \ the initiator. The list controller has\n         been distinguished from the\
    \ root for reasons which will become\n         clear later.  In short, it may\
    \ be desirable for someone to have\n         the authority to accept or reject\
    \ new members, while another\n         party (the root) would actually perform\
    \ the function.\n      3. Every participant in the multicast session will be referred\
    \ to\n         as a GROUP PARTICIPANT.  Specific group participants other than\n\
    \         the root or list controller will be referred to as LEAVES.\n      4.\
    \ After the root checks the security attributes of the\n         participants\
    \ listed on the multicast group participant list to\n         make sure that they\
    \ all support the required security\n         attributes, the root will then pass\
    \ the multicast group list to\n         all other participants and create and\
    \ distribute the Net Key.\n         If a participant on the multicast group list\
    \ did not meet the\n         required security attributes, the leaf must be deleted\
    \ from the\n         list.\n         Multiple issues can be raised with the distribution\
    \ of the\n         multicast group list and Net Key.\n          a.  An issue exists\
    \ with the time ordering of these functions.\n              The multicast group\
    \ list could be distributed before or\n              after the link is secured\
    \ (i.e. the Net Key is\n              distributed).\n          b.  An issue exists\
    \ when a leaf refuses to join the session.\n              If a leaf refuses to\
    \ join a session, we can send out a\n              modified list before sending\
    \ out the Net Key, however\n              sending out modified lists, potentially\
    \ multiple times,\n              would be inefficient.  Instead, the root could\
    \ continue\n              on, and would not send the Net Key to those participants\n\
    \              on the list who rejected the session.\n          For the scenario\
    \ architectures which follow, we assume the\n          multicast group list will\
    \ be distributed to the group\n          participants once before the Net Key\
    \ is distributed.  Unlike\n          the scheme described in [4], we recommend\
    \ that the multicast\n          group participant list be provided to all leaves.\
    \  By\n          distributing this list to the leaves, it allows them to\n   \
    \       determine upfront whether they desire to participate in the\n        \
    \  multicast group or not, thus saving potentially unnecessary\n          key\
    \ exchanges.\n   Four potential key management architectures to distribute keying\n\
    \   material for multicast sessions are presented.  Recall that the\n   features\
    \ that are highly desirable for the architecture to possess\n   include the time\
    \ required to setup the multicast group should be\n   minimized, the number of\
    \ transmissions should be minimized, and\n   memory/storage requirements should\
    \ be minimized. As will be seen, the\n   first three proposals each fall short\
    \ in a different aspect of these\n   desired qualities, whereas the fourth proposal\
    \ appears to strike a\n   balance in the features desired.  Thus, the fourth proposal\
    \ is the\n   one recommended for general implementation and use.\n   Please note\
    \ that these approaches also address securely eliminating\n   users from the multicast\
    \ group, but don't specifically address adding\n   new users to the multicast\
    \ group following initial setup because this\n   is viewed as evident as to how\
    \ it would be performed.\n"
- title: 5.1  MANUAL KEY DISTRIBUTION
  contents:
  - "5.1  MANUAL KEY DISTRIBUTION\n   Through manual key distribution, symmetric key\
    \ is delivered without\n   the use of public key exchanges.  To set up a multicast\
    \ group Net Key\n   utilizing manual key distribution would require a sequence\
    \ of events\n   where Net Key and spare Net Keys would be ordered by the root\
    \ of the\n   multicast session group. Alternate (supersession) Net Keys are\n\
    \   ordered (by the root) to be used in case of a compromise of a group\n   participant(s).\
    \ The Net Keys would be distributed to each individual\n   group participant,\
    \ often through some centralized physical\n   intermediate location. At some predetermined\
    \ time, all group\n   participants would switch to the new Net Key.  Group participants\
    \ use\n   this Net Key until a predetermined time when they need another new\n\
    \   Net Key. If the Net Key is compromised during this time, the\n   alternate\
    \ Net Key is used. Group participants switch to the alternate\n   Net Key as soon\
    \ as they receive it, or upon notification from the\n   root that everyone has\
    \ the new Net Key and thus the switch over\n   should take place. This procedure\
    \ is repeated for each cryptoperiod.\n   A scheme like this may be attractive\
    \ because the methods exist today\n   and are understood by users.  Unfortunately,\
    \ this type of scheme can\n   be time consuming to set up the multicast group\
    \ based on time\n   necessary to order keying material and having it delivered.\
    \  For most\n   real time scenarios, this method is much too slow.\n"
- title: 5.2  N Root/Leaf Pairwise Keys Approach
  contents:
  - "5.2  N Root/Leaf Pairwise Keys Approach\n   This approach is a brute force method\
    \ to provide a common multicast\n   group Net Key to the group participants. In\
    \ this scheme, the\n   initiator sets the security attributes for a particular\
    \ session,\n   generates a list of desired group participants and transmits the\
    \ list\n   to all group participants.  The leaves then respond with an initial\n\
    \   acceptance or rejection of participation.  By sending the list up\n   front,\
    \ time can be saved by not performing key exchanges with people\n   who rejected\
    \ participation in the session.  The root (who for this\n   and future examples\
    \ is assumed to be the initiator) generates a\n   pairwise key with one of the\
    \ participants (leaves) in the multicast\n   group using some standard public\
    \ key exchange technique (e.g., a\n   Diffie-Hellman public key exchange.)  The\
    \ root will then provide the\n   security association parameters of the multicast\
    \ (which may be\n   different from the parameters of the initial pairwise key)\
    \ to this\n   first leaf.  Parameters may include items such as classification\
    \ and\n   policy.  Some negotiation (through the use of a Security Association\n\
    \   Management Protocol, or SAMP) of the parameters may be necessary.\n   The\
    \ possibility exists for the leaf to reject the connection to the\n   multicast\
    \ group based on the above parameters and  multicast group\n   list.  If the leaf\
    \ rejects this session, the root will repeat this\n   process with another leaf.\n\
    \   Once a leaf accepts participation in the multicast session, these two\n  \
    \ then choose a Net Key to be used by the multicast group.  The Net Key\n   could\
    \ be generated through another public key exchange between the\n   two entities,\
    \ or simply chosen by the root, depending upon the policy\n   which is in place\
    \ for the multicast group ( i.e. this policy decision\n   will not be a real time\
    \ choice).  The issue here is the level of\n   trust that the leaf has in the\
    \ root.  If the initial pairwise key\n   exchange provides some level of user\
    \ authentication, then it seems\n   adequate to just have the root select the\
    \ Net Key at this stage.\n   Another issue is the level of trust in the strength\
    \ of the security\n   of the generated key.  Through a cooperative process, both\
    \ entities\n   (leaf and root) will be providing information to be used in the\n\
    \   formation of the Net Key.\n   The root then performs a pairwise key exchange\
    \ with another leaf and\n   optionally performs the negotiation discussed earlier.\
    \  Upon\n   acceptance by the leaf to join the multicast group, the root sends\n\
    \   the leaf the Net Key.\n   This pairwise key exchange and Net Key distribution\
    \ continues for all\n   N users of the multicast group.\n   Root/leaves cache\
    \ pairwise keys for future use.  These keys serve as\n   Key Encryption Keys (KEKs)\
    \ used for rekeying leaves in the net at a\n   later time.  Only the root will\
    \ cache all of the leaves' pairwise\n   keys.  Each individual leaf will cache\
    \ only its own unique pairwise\n   Key Encryption Key.\n   There are two cases\
    \ to consider when caching the KEKs.  The first\n   case is when the Net key and\
    \ KEK are per session keys. In this case,\n   if one wants to exclude a group\
    \ participant from the multicast\n   session (and rekey the remaining participants\
    \ with a new Net Key),\n   the root would distribute a new Net key encrypted with\
    \ each\n   individual KEK to every legitimate remaining participant.  These KEKs\n\
    \   are deleted once the multicast session is completed.\n   The second case to\
    \ consider is when the KEKs are valid for more than\n   one session.  In this\
    \ case, the Net Key may also be valid for\n   multiple sessions, or the Net Key\
    \ may still only be valid for one\n   session as in the above case.  Whether the\
    \ Net Key is valid for one\n   session or more than one session, the KEK will\
    \ be cached.  If the Net\n   Key is only valid per session, the KEKs will be used\
    \ to encrypt new\n   Net Keys for subsequent multicast sessions.  The deleting\
    \ of group\n   participants occurs as in the previous case described above,\n\
    \   regardless of whether the Net Key is per session or to be used for\n   multiple\
    \ sessions.\n   A scheme like this may be attractive to a user because it is a\n\
    \   straightforward extension of certifiable public key exchange\n   techniques.\
    \ It may also be attractive because it does not involve\n   third parties.  Only\
    \ the participants who are part of the multicast\n   session participate in the\
    \ keying mechanism.  What makes this scheme\n   so undesirable is that it will\
    \ be transmission intensive as we scale\n   up in numbers, even for the most computationally\
    \ efficient\n   participants, not to mention those with less capable hardware\n\
    \   (tactical, wireless, etc.).  Every time the need arises to drop an\n   \"\
    unauthorized\" participant, a new Net Key must be distributed.\n   This distribution\
    \ requires a transmission from the Root to each\n   remaining participant, whereby\
    \ the new Net Key will be encrypted\n   under the cover of each participant's\
    \ unique pairwise Key Encryption\n   Key (KEK).\n   Note: This approach is essentially\
    \ the same as one proposal to the\n   Internet Engineering Task Force (IETF) Security\
    \ Subworking Group [Ref\n   1,2].\n   Also note that there exist multiple twists\
    \ to an approach like this.\n   For example, instead of having the root do all\
    \ N key exchanges, the\n   root could pass some of this functionality (and control)\
    \ to a number\n   of leaves beneath him.  For example, the multicast group list\
    \ could\n   be split in half and the root tells one leaf to take half of the\n\
    \   users and perform a key exchange with them (and then distribute the\n   Net\
    \ key) while the root will take care of the other half of the list.\n   (The chosen\
    \ leaves are thus functioning as a root and we can call\n   them \"subroots.\"\
    \  These subroots will have leaves beneath them, and\n   the subroots will maintain\
    \ the KEK of each leaf beneath it.)  This\n   scales better than original approach\
    \ as N becomes large.\n   Specifically, it will require less time to set up (or\
    \ rekey) the\n   multicast net because the singular responsibility of performing\n\
    \   pairwise key exchanges and distributing Net Key will be shared among\n   multiple\
    \ group participants and can be performed in parallel, as\n   opposed to the root\
    \ only distributing the Net Key to all of the\n   participants.\n   This scheme\
    \ is not without its own security concerns.  This scheme\n   pushes trust down\
    \ to each subgroup controller - the root assumes that\n   these \"subroot\" controllers\
    \ are acting in a trustworthy way.  Every\n   control element (root and subroots)\
    \ must remain in the system\n   throughout the multicast.  This effectively makes\
    \ removing someone\n   from the net (especially the subroots) harder and slower\
    \ due to the\n   distributed control.  When removing a participant from the multicast\n\
    \   group which has functioned on behalf of the root, as a subroot, to\n   distribute\
    \ Net Key, additional steps will be necessary.  A new\n   subroot must be delegated\
    \ by the root to replace the removed subroot.\n   A key exchange (to generate\
    \ a new pairwise KEK) must occur between\n   the new subroot and each leaf the\
    \ removed subroot was responsible\n   for.  A new Net Key will now be distributed\
    \ from the root, to the\n   subroots, and to the leaves.  Note that this last\
    \ step would have\n   been the only step required if the removed party was a leaf\
    \ with no\n   controlling responsibilities.\n"
- title: 5.3   COMPLEMENTARY VARIABLE APPROACH
  contents:
  - "5.3   COMPLEMENTARY VARIABLE APPROACH\n   Let us suppose we have N leaves.  The\
    \ Root performs a public key\n   exchange with each leaf i (i= 1,2, ..., N). \
    \ The Root will cache each\n   pairwise KEK. Each leaf stores their own KEK. \
    \ The root would provide\n   the multicast group list of participants and attributes\
    \ to all users.\n   Participants would accept or reject participation in the multicast\n\
    \   session as described in previous sections.  The root encrypts the Net\n  \
    \ Key for the Multicast group to each leaf, using their own unique\n   KEK(i).\
    \  (The Root either generated this Net Key himself, or\n   cooperatively generated\
    \ with one of the leaves as was discussed\n   earlier).  In addition to the encrypted\
    \ Net Key, the root will also\n   encrypt something called complementary variables\
    \ and send them to the\n   leaves.\n   A leaf will NOT receive his own complementary\
    \ variable, but he will\n   receive the other N-1 leaf complementary variables.\
    \  The root sends\n   the Net Key and complementary variables j, where j=1,2,...,N\
    \ and j\n   not equal to i, encrypted by KEK(i) to each leaf. Thus, every leaf\n\
    \   receives and stores N variables which are the Net key, and N-1\n   complementary\
    \ variables.\n   Thus to cut a user from the multicast group and get the remaining\n\
    \   participants back up again on a new Net Key would involve the\n   following.\
    \ Basically, to cut leaf number 20 out of the net, one\n   message is sent out\
    \ that says \"cut leaf 20 from the net.\" All of the\n   other leaves (and Root)\
    \ generate a new Net Key based on the current\n   Net Key and Complementary variable\
    \ 20.  [Thus some type of\n   deterministic key variable generation process will\
    \ be necessary for\n   all participants of the multicast group]. This newly generated\n\
    \   variable will be used as the new Net Key by all remaining\n   participants\
    \ of the multicast group.  Everyone except leaf 20 is able\n   to generate the\
    \ new Net Key, because they have complementary variable\n   20, but leaf 20 does\
    \ not.\n   A scheme like this seems very desirable from the viewpoint of\n   transmission\
    \ savings since a rekey message encrypted with each\n   individual KEK to every\
    \ leaf does not have to be sent to delete\n   someone from the net.  In other\
    \ words, there will be one plaintext\n   message to the multicast group versus\
    \ N encrypted rekey messages.\n   There exists two major drawbacks with this scheme.\
    \  First are the\n   storage requirements necessary for the (N-1) complementary\
    \ variables.\n   Secondly, when deleting multiple users from the multicast group,\n\
    \   collusion will be a concern.  What this means is that these deleted\n   users\
    \ could work together and share their individual complementary\n   variables to\
    \ regain access to the multicast session.\n"
- title: 5.4  HIERARCHICAL TREE APPROACH
  contents:
  - "5.4  HIERARCHICAL TREE APPROACH\n   The Hierarchical Tree Approach is our recommended\
    \ approach to address\n   the multicast key management problem.  This approach\
    \ provides for the\n   following requisite features:\n      1. Provides for the\
    \ secure removal of a compromised user from the\n         multicast group\n  \
    \    2. Provides for transmission efficiency\n      3. Provides for storage efficiency\n\
    \   This approach balances the costs of time, storage and number of\n   required\
    \ message transmissions, using a hierarchical system of\n   auxiliary keys to\
    \ facilitate distribution of new Net Key. The result\n   is that the storage requirement\
    \ for each user and the transmissions\n   required for key replacement are both\
    \ logarithmic in the number of\n   users, with no background transmissions required.\
    \ This approach is\n   robust against collusion of excluded users. Moreover, while\
    \ the\n   scheme is hierarchical in nature, no infrastructure is needed beyond\n\
    \   a server (e.g., a root), though the presence of such elements could\n   be\
    \ used to advantage (See Figure 1).\n                        --------------------------\n\
    \                       |                          |\n                       |\
    \        S E R V E R       |\n                       |                       \
    \   |\n                        --------------------------\n                  \
    \      |    |                   |\n                        |    |     .  .  .\
    \  .    |\n                        -    -                   -\n              \
    \         |1|  |2|                 |n|\n                        -    -       \
    \            -\n                  Figure 1: Assumed Communication Architecture\n\
    \   The scheme, advantages and disadvantages are enumerated in more\n   detail\
    \ below.  Consider Figure 2 below.  This figure illustrates the\n   logical key\
    \ distribution architecture, where keys exist only at the\n   server and at the\
    \ users.  Thus, the server in this architecture would\n   hold Keys A through\
    \ O, and the KEKs of each user.  User 11 in this\n   architecture would hold its\
    \ own unique KEK, and Keys F, K, N, and O.\n  net key                        \
    \ Key O\n                   -------------------------------------\n  intermediate\
    \    |                                     |\n  keys            |            \
    \                         |\n              Key M                             \
    \    Key N\n        -----------------                   --------------------\n\
    \       |                 |                 |                    |\n       | \
    \                |                 |                    |\n     Key I        \
    \     Key J             Key K               Key L\n   --------          --------\
    \         ---------           ----------\n  |        |        |        |     \
    \  |         |         |          |\n  |        |        |        |       |  \
    \       |         |          |\n Key A   Key B   Key C    Key D    Key E     Key\
    \ F     Key G     Key H\n  ---     ---     ---      ---      ---       ----  \
    \    ----      ----\n |   |   |   |   |   |    |   |    |   |     |    |    |\
    \    |    |    |\n -   -   -   -   -   -    -   -   -   --    --   --   --   --\
    \   --   --\n"
- title: '|1| |2| |3| |4| |5| |6|  |7| |8| |9| |10|  |11| |12| |13| |14| |15| |16|'
  contents:
  - "|1| |2| |3| |4| |5| |6|  |7| |8| |9| |10|  |11| |12| |13| |14| |15| |16|\n -\
    \   -   -   -   -   -    -   -   -   --    --   --   --   --   --   --\n     \
    \                          users\n               Figure 2: Logical Key Distribution\
    \ Architecture\n   We now describe the organization of the key hierarchy and the\
    \ setup\n   process.  It will be clear from the description how to add users\n\
    \   after the hierarchy is in place; we will also describe the removal of\n  \
    \ a user.  Note: The passing of the multicast group list and any\n   negotiation\
    \ protocols is not included in this discussion for\n   simplicity purposes.\n\
    \   We construct a rooted tree (from the bottom up) with one leaf\n   corresponding\
    \ to each user, as in Figure 2. (Though we have drawn a\n   balanced binary tree\
    \ for convenience, there is no need for the tree\n   to be either balanced or\
    \ binary - some preliminary analysis on tree\n   shaping has been performed.)\
    \ Each user establishes a unique pairwise\n   key with the server. For users with\
    \ transmission capability, this can\n   be done using the public key exchange\
    \ protocol. The situation is more\n   complicated for receive-only users; it is\
    \ easiest to assume these\n   users have pre-placed key.\n   Once each user has\
    \ a pairwise key known to the server, the server\n   generates (according to the\
    \ security policy in place for that\n   session) a key for each remaining node\
    \ in the tree.  The keys\n   themselves should be generated by a robust process.\
    \  We will also\n   assume users have no information about keys they don't need.\
    \  (Note:\n   There are no users at these remaining nodes, (i.e., they are logical\n\
    \   nodes) and the key for each node need only be generated by the server\n  \
    \ via secure means.)  Starting with those nodes all of whose children\n   are\
    \ leaves and proceeding towards the root, the server transmits the\n   key for\
    \ each node, encrypted using the keys for each of that node's\n   children.  At\
    \ the end of the process, each user can determine the\n   keys corresponding to\
    \ those nodes above her leaf.  In particular, all\n   users hold the root key,\
    \ which serves as the common Net Key for the\n   group.  The storage requirement\
    \ for a user at depth d is d+1 keys\n   (Thus for the example in Figure 2, a user\
    \ at depth d=4 would hold\n   five keys.  That is, the unique Key Encryption Key\
    \ generated as a\n   result of the pairwise key exchange, three intermediate node\
    \ keys -\n   each separately encrypted and transmitted, and the common Net Key\
    \ for\n   the multicast group which is also separately encrypted.)\n   It is also\
    \ possible to transmit all of the intermediate node keys and\n   root node key\
    \ in one message, where the node keys would all be\n   encrypted with the unique\
    \ pairwise key of the individual leaf.  In\n   this manner, only one transmission\
    \ (of a larger message) is required\n   per user to receive all of the node keys\
    \ (as compared to d\n   transmissions).  It is noted for this method, that the\
    \ leaf would\n   require some means to determine which key corresponds to which\
    \ node\n   level.\n   It is important to note that this approach requires additional\n\
    \   processing capabilities at the server where other alternative\n   approaches\
    \ may not.  In the worst case, a server will be responsible\n   for generating\
    \ the intermediate keys required in the architecture.\n"
- title: 5.4.1 The Exclusion Principle
  contents:
  - "5.4.1 The Exclusion Principle\n   Suppose that User 11 (marked on Figure 2 in\
    \ black) needs to be\n   deleted from the multicast group. Then all of the keys\
    \ held by User\n   11 (bolded Keys F, K, N, O) must be changed and distributed\
    \ to the\n   users who need them, without permitting User 11 or anyone else from\n\
    \   obtaining them. To do this, we must replace the bolded keys held by\n   User\
    \ 11, proceeding from the bottom up.  The server chooses a new key\n   for the\
    \ lowest node, then transmits it encrypted with the appropriate\n   daughter keys\
    \ (These transmissions are represented by the dotted\n   lines).  Thus for this\
    \ example, the first key replaced is Key F, and\n   this new key will be sent\
    \ encrypted with User 12's unique pairwise\n   key.\n   Since we are proceeding\
    \ from the bottom up, each of the replacement\n   keys will have been replaced\
    \ before it is used to encrypt another\n   key. (Thus, for the replacement of\
    \ Key K, this new key will be sent\n   encrypted in the newly replaced Key F (for\
    \ User 12) and will also be\n   sent as one multicast transmission encrypted in\
    \ the node key shared\n   by Users 9 and 10 (Key E). For the replacement of Key\
    \ N, this new key\n   will be sent encrypted in the newly replaced Key K (for\
    \ Users 9, 10,\n   and 12) and will also be encrypted in the node key shared by\
    \ Users\n   13, 14, 15, and 16 (Key L).  For the replacement of Key O, this new\n\
    \   key will be sent encrypted in the newly replaced Key N (for Users 9,\n   10,\
    \ 12, 13, 14, 15, and 16) and will also be encrypted in the node\n   key shared\
    \ by Users 1, 2 , 3, 4, 5, 6, 7, and 8 (Key M).)  The number\n   of transmissions\
    \ required is the sum of the degrees of the replaced\n   nodes. In a k-ary tree\
    \ in which a sits at depth d, this comes to at\n   most kd-1 transmissions.  Thus\
    \ in this example, seven transmissions\n   will be required to exclude User 11\
    \ from the multicast group and to\n   get the other 15 users back onto a new multicast\
    \ group Net Key that\n   User 11 does not have access to.  It is easy to see that\
    \ the system\n   is robust against collusion, in that no set of users together\
    \ can\n   read any message unless one of them could have read it individually.\n\
    \   If the same strategy is taken as in the previous section to send\n   multiple\
    \ keys in one message, the number of transmissions required\n   can be reduced\
    \ even further to four transmissions.  Note once again\n   that the messages will\
    \ be larger in the number of bits being\n   transmitted.  Additionally, there\
    \ must exist a means for each leaf to\n   determine which key in the message corresponds\
    \ to which node of the\n   hierarchy.  Thus, in this example, for the replacement\
    \ of keys F, K,\n   N, and O to User 12, the four keys will be encrypted in one\
    \ message\n   under User 12's unique pairwise key.  To replace keys K, N, and\
    \ O for\n   Users 9 and 10, the three keys will be encrypted in one message under\n\
    \   the node key shared by Users 9 and 10 (Key E).  To replace keys N and\n  \
    \ O for Users  13, 14, 15, 16, the two keys will be encrypted in one\n   message\
    \ under the node key shared by Users 13, 14, 15, and 16 (Key\n   L). Finally,\
    \ to replace key O for Users 1, 2 , 3, 4, 5, 6, 7, and 8,\n   key O will be encrypted\
    \ under the node key shared by Users 1, 2 , 3,\n   4, 5, 6, 7, and 8 (Key M).\
    \  Thus the number of transmission required\n   is at most (k-1)d.\n   The following\
    \ table demonstrates the removal of a user, and how the\n   storage and transmission\
    \ requirements grow with the number of users.\n"
- title: 'Table 1: Storage and Transmission Costs'
  contents:
  - 'Table 1: Storage and Transmission Costs

    '
- title: Number    Degree   Storage per user  Transmissions to    Transmissions
  contents:
  - 'Number    Degree   Storage per user  Transmissions to    Transmissions

    '
- title: of users   (k)        (d+1)          rekey remaining     to rekey
  contents:
  - "of users   (k)        (d+1)          rekey remaining     to rekey\n         \
    \                            participants of     remaining\n                 \
    \                    multicast group-    participants of\n                   \
    \                  one key per message multicast\n                           \
    \              (kd-1)          group -\n                                     \
    \                    multiple keys\n                                         \
    \                per message\n                                               \
    \             (k-1)d\n     8       2            4                 5          \
    \       3\n     9       3            3                 5                 4\n \
    \   16       2            5                 7                 4\n  2048      \
    \ 2           12                21                11\n  2187       3         \
    \   8                20                14\n"
- title: 131072       2           18                33                17
  contents:
  - '131072       2           18                33                17

    '
- title: 177147       3           12                32                22
  contents:
  - '177147       3           12                32                22

    '
- title: 'The benefits of a scheme such as this are:'
  contents:
  - "The benefits of a scheme such as this are:\n      1. The costs of user storage\
    \ and rekey transmissions are balanced\n         and scalable as the number of\
    \ users increases.  This is not the\n         case for [1], [2], or [4].\n   \
    \   2. The auxiliary keys can be used to transmit not only other keys,\n     \
    \    but also messages. Thus the hierarchy can be designed to place\n        \
    \ subgroups that wish to communicate securely (i.e. without\n         transmitting\
    \ to the rest of the large multicast group) under\n         particular nodes,\
    \ eliminating the need for maintenance of\n         separate Net Keys for these\
    \ subgroups. This works best if the\n         users operate in a hierarchy to\
    \ begin with (e.g., military\n         operations), which can be reflected by\
    \ the key hierarchy.\n      3. The hierarchy can be designed to reflect network\
    \ architecture,\n         increasing efficiency (each user receives fewer irrelevant\n\
    \         messages). Also, server responsibilities can be divided up\n       \
    \  among subroots (all of which must be secure).\n      4. The security risk associated\
    \ with receive-only users can be\n         minimized by collecting such users\
    \ in a particular area of the\n         tree.\n      5. This approach is resistant\
    \ to collusion among arbitrarily many\n         users.\n   As noted earlier, in\
    \ the rekeying process after one user is\n   compromised, in the case of one key\
    \ per message, each replaced key\n   must be decrypted successfully before the\
    \ next key can be replaced\n   (unless users can cache the rekey messages).  This\
    \ bottleneck could\n   be a problem on a noisy or slow network. (If multiple users\
    \ are being\n   removed, this can be parallelized, so the expected time to rekey\
    \ is\n   roughly independent of the number of users removed.)\n   By increasing\
    \ the valences and decreasing the depth of the tree, one\n   can reduce the storage\
    \ requirements for users at the price of\n   increased transmissions.  For example,\
    \ in the one key per message\n   case, if n users are arranged in a k-ary tree,\
    \ each user will need\n   storage. Rekeying after one user is removed now requires\n\
    \   transmissions.  As k approaches n, this approaches the pairwise key\n   scheme\
    \ described earlier in the paper.\n"
- title: 5.4.2 Hierarchical Tree Approach Options
  contents:
  - '5.4.2 Hierarchical Tree Approach Options

    '
- title: 5.4.2.1  Distributed Hierarchical Tree Approach
  contents:
  - "5.4.2.1  Distributed Hierarchical Tree Approach\n   The Hierarchical Tree Approach\
    \ outlined in this section could be\n   distributed as indicated in Section 5.2\
    \ to more closely resemble the\n   proposal put forth in [4].  Subroots could\
    \ exist at each of the nodes\n   to handle any joining or rekeying that is necessary\
    \ for any of the\n   subordinate users.  This could be particularly attractive\
    \ to users\n   which do not have a direct connection back to the Root.  Recall\
    \ as\n   indicated in Section 5.2, that the trust placed in these subroots to\n\
    \   act with the authority and security of a Root, is a potentially\n   dangerous\
    \ proposition.  This thought is also echoed in [4].\n   Some practical recommendations\
    \ that might be made for these subroots\n   include the following.  The subroots\
    \ should not be allowed to change\n   the multicast group participant list that\
    \ has been provided to them\n   from the Root.  One method to accomplish this,\
    \ would be for the Root\n   to sign the list before providing it to the subroots.\
    \  Authorized\n   subroots could though be allowed to set up new multicast groups\
    \ for\n   users below them in the hierarchy.\n   It is important to note that\
    \ although this distribution may appear to\n   provide some benefits with respect\
    \ to the time required to initialize\n   the multicast group (as compared to the\
    \ time required to initialize\n   the group as described in Section 5.4) and for\
    \ periodic rekeying, it\n   does not appear to provide any benefit in rekeying\
    \ the multicast\n   group when a user has been compromised.\n   It is also noted\
    \ that whatever the key management scheme is\n   (hierarchical tree, distributed\
    \ hierarchical tree, core based tree,\n   GKMP, etc.), there will be a \"hit\"\
    \ incurred to initialize the\n   multicast group with the first multicast group\
    \ net key.  Thus, the\n   hierarchical tree approach does not suffer from additional\
    \ complexity\n   with comparison to the other schemes with respect to initialization.\n"
- title: 5.4.2.2  Multicast Group Formation
  contents:
  - "5.4.2.2  Multicast Group Formation\n   Although this paper has presented the\
    \ formation of the multicast\n   group as being Root initiated, the hierarchical\
    \ approach is\n   consistent with user initiated joining.  User initiated joining\
    \ is\n   the method of multicast group formation presented in [4].  User\n   initiated\
    \ joining may be desirable when some core subset of users in\n   the multicast\
    \ group need to be brought up on-line and communicating\n   more quickly.  Other\
    \ participants in the multicast group can then be\n   brought in when they wish.\
    \  In this type of approach though, there\n   does not exist a finite period of\
    \ time by when it can be ensured all\n   participants will be a part of the multicast\
    \ group.\n   For example, in the case of a single root, the hierarchy is set up\n\
    \   once, in the beginnning, by the initiator (also usually the root) who\n  \
    \ also generates the group participant list. The group of keys for each\n   participant\
    \ can then be individually requested (pulled) as soon as,\n   but not until, each\
    \ participant wishes to join the session.\n"
- title: 5.4.2.3  Sender Specific Authentication
  contents:
  - "5.4.2.3  Sender Specific Authentication\n   In the multicast environment, the\
    \ possibility exists that\n   participants of the group at times may want to uniquely\
    \ identify\n   which participant is the sender of a multicast group message. \
    \ In the\n   multicast key distribution system described by Ballardie [4], the\n\
    \   notion of \"sender specific keys\" is presented.\n   Another option to allow\
    \ participants of a multicast group to uniquely\n   determine the sender of a\
    \ message is through the use of a signature\n   process.  When a member of the\
    \ multicast group signs a message with\n   their own private signature key, the\
    \ recipients of that signed\n   message in the multicast group can use the sender's\
    \ public\n   verification key to determine if indeed the message is from who it\
    \ is\n   claimed to be from.\n   Another related idea to this is the case when\
    \ two users of a\n   multicast group want to communicate strictly with each other,\
    \ and\n   want no one else to listen in on the communication.  If this\n   communication\
    \ relationship is known when the multicast group is\n   originally set up, then\
    \ these two participants could simply be placed\n   adjacent to one another at\
    \ the lowest level of the hierarchy (below a\n   binary node).  Thus, they would\
    \ naturally share a secret pairwise\n   key.  Otherwise, a simple way to accomplish\
    \ this is to perform a\n   public key based pairwise key exchange between the\
    \ two users to\n   generate a traffic encryption key for their private unicast\n\
    \   communications.  Through this process, not only will the encrypted\n   transmissions\
    \ between them be readable only by them, but unique\n   sender authentication\
    \ can be accomplished via the public key based\n   pairwise exchange.\n"
- title: 5.4.2.4  Rekeying the Multicast Group and the Use of Group Key
  contents:
  - "5.4.2.4  Rekeying the Multicast Group and the Use of Group Key\n         Encryption\
    \ Keys\n   Reference [4] makes use of a Group Key Encryption Key that can be\n\
    \   shared by the multicast group for use in periodic rekeys of the\n   multicast\
    \ group. Aside from the potential security drawbacks of\n   implementing a shared\
    \ key for encrypting future keys, the use of a\n   Group Key Encryption Key is\
    \ of no benefit to a multicast group if a\n   rekey is necessary due to the known\
    \ compromise of one of the members.\n   The strategy for rekeying the multicast\
    \ group presented in Section\n   5.4.1 specifically addresses this critical problem\
    \ and offers a means\n   to accomplish this task with minimal message transmissions\
    \ and\n   storage requirements.\n   The question though can now be asked as to\
    \ whether the rekey of a\n   multicast group will be necessary in a non-compromise\
    \ scenario.  For\n   example, if a user decides they do not want to participate\
    \ in the\n   group any longer, and requests the list controller to remove them\n\
    \   from the multicast group participant list, will a rekey of the\n   multicast\
    \ group be necessary?  If the security policy of the\n   multicast group mandates\
    \ that deleted users can no longer receive\n   transmissions, than a rekey of\
    \ a new net key will be required.  If\n   the multicast group security policy\
    \ does not care that the deleted\n   person can still decrypt any transmissions\
    \ (encrypted in the group\n   net key that they might still hold), but does care\
    \ that they can not\n   encrypt and transmit messages, a rekey will once again\
    \ be necessary.\n   The only alternative to rekeying the multicast group under\
    \ this\n   scenario would require a recipient to check every received message\n\
    \   sender, against the group participant list.  Thus rejecting any\n   message\
    \ sent by a user not on the list.  This is not a practical\n   option.  Thus it\
    \ is recommended to always rekey the multicast group\n   when someone is deleted,\
    \ whether it is because of compromise reasons\n   or not.\n"
- title: 5.4.2.5  Bulk Removal of Participants
  contents:
  - "5.4.2.5  Bulk Removal of Participants\n   As indicated in Section 2, the need\
    \ may arise to remove users in\n   bulk.  If the users are setup as discussed\
    \ in Section 5.4.1 into\n   subgroups that wish to communicate securely all being\
    \ under the same\n   node, bulk user removal can be done quite simply if the whole\
    \ node is\n   to be removed.  The same technique as described in Section 5.4.1\
    \ is\n   performed to rekey any shared node key that the remaining\n   participants\
    \ hold in common with the removed node.\n   The problem of bulk removal becomes\
    \ more difficult when the\n   participants to be removed are dispersed throughout\
    \ the tree.\n   Depending on how many participants are to be removed, and where\
    \ they\n   are located within the hierarchy, the number of transmissions\n   required\
    \ to rekey the multicast group could be equivalent to brute\n   force rekeying\
    \ of the remaining participants. Also the question can\n   be raised as to at\
    \ what point the remaining users are restructured\n   into a new hierarchical\
    \ tree, or should a new multicast group be\n   formed.  Restructuring of the hierarchical\
    \ tree would most likely be\n   the preferred option, because it would not necessitate\
    \ the need to\n   perform pairwise key exchanges again to form the new user unique\n\
    \   KEKs.\n"
- title: 5.4.2.6  ISAKMP Compatibility
  contents:
  - "5.4.2.6  ISAKMP Compatibility\n   Thus far this document has had a major focus\
    \ on the architectural\n   trade-offs involved in the generation, distribution,\
    \ and maintenance\n   of traffic encryption keys (Net Keys) for multicast groups.\
    \  There\n   are other elements involved in the establishment of a secure\n  \
    \ connection among the multicast participants that have not been\n   discussed\
    \ in any detail.  For example, the concept of being able to\n   \"pick and choose\"\
    \ and negotiating the capabilities of the key\n   exchange mechanism and various\
    \ other elements is a very important and\n   necessary aspect.\n   The NSA proposal\
    \ to the Internet Engineering Task Force (IETF)\n   Security Subworking Group\
    \ [Ref. 3] entitled \"Internet Security\n   Association and Key Management Protocol\
    \ (ISAKMP)\" has attempted to\n   identify the various functional elements required\
    \ for the\n   establishment of a secure connection for the largest current network,\n\
    \   the Internet.  While the proposal has currently focused on the\n   problem\
    \ of point to point connections, the functional elements should\n   be the same\
    \ for multicast connections, with appropriate changes to\n   the techniques chosen\
    \ to implement the individual functional\n   elements.  Thus the implementation\
    \ of ISAKMP is compatible with the\n   use of the hierarchical tree approach.\n"
- title: 6.0  SUMMARY
  contents:
  - "6.0  SUMMARY\n   As discussed in this report, there are two main areas of concern\
    \ when\n   addressing solutions for the multicast key management problem.  They\n\
    \   are the secure initialization and rekeying of the multicast group\n   with\
    \ a common net key.  At the present time, there are multiple\n   papers which\
    \ address the initialization of a multicast group, but\n   they do not adequately\
    \ address how to efficiently and securely remove\n   a compromised user from the\
    \ multicast group.\n   This paper proposed a hierarchical tree approach to meet\
    \ this\n   difficult problem.  It is robust against collusion, while at the same\n\
    \   time, balancing the number of transmissions required and storage\n   required\
    \ to rekey the multicast group in a time of compromise.\n   It is also important\
    \ to note that the proposal recommended in this\n   paper is consistent with other\
    \ multicast key management solutions\n   [4], and allows for multiple options\
    \ for its implementation.\n"
- title: 7.0 Security Considerations
  contents:
  - "7.0 Security Considerations\n   Security concerns are discussed throughout this\
    \ memo.\n"
- title: 8.0  REFERENCES
  contents:
  - "8.0  REFERENCES\n   1. Harney, H., Muckenhirn, C. and T. Rivers, \"Group Key\
    \ Management\n      Protocol Architecture\", RFC 2094, September 1994.\n   2.\
    \ Harney, H., Muckenhirn, C. and T. Rivers, \"Group Key Management\n      Protocol\
    \ Specification\", RFC 2093,  September 1994.\n   3. Maughan, D., Schertler, M.\
    \ Schneider, M. and J.Turner, \"Internet\n      Security Association and Key Management\
    \ Protocol, Version 7\",\n      February 1997.\n   4. Ballardie, T., \"Scalable\
    \ Multicast Key Distribution\", RFC 1949,\n      May 1996.\n   5. Wong, C., Gouda,\
    \ M. and S. Lam, \"Secure Group Communications Using\n      Key Graphs\", Technical\
    \ Report TR 97-23, Department of Computer\n      Sciences, The University of Texas\
    \ at Austin, July 1997.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Debby M. Wallner\n   National Security Agency\n   Attn:\
    \ R2\n   9800 Savage Road  STE 6451\n   Ft. Meade, MD.  20755-6451\n   Phone:\
    \ 301-688-0331\n   EMail: dmwalln@orion.ncsc.mil\n   Eric J. Harder\n   National\
    \ Security Agency\n   Attn: R2\n   9800 Savage Road  STE 6451\n   Ft. Meade, MD.\
    \  20755-6451\n   Phone: 301-688-0850\n   EMail: ejh@tycho.ncsc.mil\n   Ryan C.\
    \ Agee\n   National Security Agency\n   Attn: R2\n   9800 Savage Road  STE 6451\n\
    \   Ft. Meade, MD.  20755-6451\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (1999).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
