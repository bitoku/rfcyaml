- contents:
  - ''
  title: __initial_text__
- contents:
  - "Distributed Denial-of-Service Open Threat Signaling (DOTS) Data Channel\n                             Specification\n"
  title: Distributed Denial-of-Service Open Threat Signaling (DOTS) Data Channel
- contents:
  - "Abstract\n   The document specifies a Distributed Denial-of-Service Open Threat\n
    \  Signaling (DOTS) data channel used for bulk exchange of data that\n   cannot
    easily or appropriately communicated through the DOTS signal\n   channel under
    attack conditions.\n   This is a companion document to \"Distributed Denial-of-Service
    Open\n   Threat Signaling (DOTS) Signal Channel Specification\" (RFC 8782).\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8783.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2020 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction\n   2.  Terminology\n   3.  DOTS Data
    Channel\n     3.1.  Design Overview\n     3.2.  DOTS Server(s) Discovery\n     3.3.
    \ DOTS Gateways\n     3.4.  Detecting and Preventing Infinite Loops\n     3.5.
    \ Preventing Stale Entries\n   4.  DOTS Data Channel YANG Module\n     4.1.  Generic
    Tree Structure\n     4.2.  Filtering Fields\n     4.3.  YANG Module\n   5.  Managing
    DOTS Clients\n     5.1.  Registering DOTS Clients\n     5.2.  De-registering DOTS
    Clients\n   6.  Managing DOTS Aliases\n     6.1.  Creating Aliases\n     6.2.
    \ Retrieving Installed Aliases\n     6.3.  Deleting Aliases\n   7.  Managing DOTS
    Filtering Rules\n     7.1.  Retrieving DOTS Filtering Capabilities\n     7.2.
    \ Installing Filtering Rules\n     7.3.  Retrieving Installed Filtering Rules\n
    \    7.4.  Removing Filtering Rules\n   8.  Operational Considerations\n   9.
    \ IANA Considerations\n   10. Security Considerations\n   11. References\n     11.1.
    \ Normative References\n     11.2.  Informative References\n   Appendix A.  Examples:
    Filtering Fragments\n   Appendix B.  Examples: Filtering TCP Messages\n     B.1.
    \ Discard TCP Null Attack\n     B.2.  Rate-Limit SYN Flooding\n     B.3.  Rate-Limit
    ACK Flooding\n   Acknowledgements\n   Contributors\n   Authors' Addresses\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   A distributed denial-of-service (DDoS) attack is an attempt
    to make\n   machines or network resources unavailable to their intended users.\n
    \  In most cases, sufficient scale can be achieved by compromising\n   enough
    end hosts and using those infected hosts to perpetrate and\n   amplify the attack.
    \ The victim of such an attack can be an\n   application server, a router, a firewall,
    an entire network, etc.\n   As discussed in [RFC8612], the lack of a common method
    to coordinate\n   a real-time response among involved actors and network domains\n
    \  inhibits the speed and effectiveness of DDoS attack mitigation.  From\n   that
    standpoint, DDoS Open Threat Signaling (DOTS) defines an\n   architecture that
    allows a DOTS client to send requests to a DOTS\n   server for DDoS attack mitigation
    [DOTS-ARCH].  The DOTS approach is\n   thus meant to minimize the impact of DDoS
    attacks, thereby\n   contributing to the enforcement of more efficient defensive
    if not\n   proactive security strategies.  To that aim, DOTS defines two\n   channels:
    the signal channel and the data channel (Figure 1).\n   |               | <-------
    Signal Channel ------> |               |\n   |  DOTS Client  |                                 |
    \ DOTS Server  |\n   |               | <=======  Data Channel  ======> |               |\n
    \                         Figure 1: DOTS Channels\n   The DOTS signal channel
    is used to carry information about a device\n   or a network (or a part thereof)
    that is under a DDoS attack.  Such\n   information is sent by a DOTS client to
    an upstream DOTS server so\n   that appropriate mitigation actions are undertaken
    on traffic deemed\n   suspicious.  The DOTS signal channel is further elaborated
    in\n   [RFC8782].\n   The DOTS data channel is used for infrequent bulk data exchange\n
    \  between DOTS agents to significantly improve the coordination of all\n   the
    parties involved in the response to the attack.  Section 2 of\n   [DOTS-ARCH]
    mentions that the DOTS data channel is used to perform\n   the following tasks:\n
    \  *  Creation of aliases for resources for which mitigation may be\n      requested.\n
    \     A DOTS client may submit to its DOTS server a collection of\n      prefixes
    to which it would like to refer by an alias when\n      requesting mitigation.
    \ The DOTS server can respond to this\n      request with either a success or
    failure response (see Section 2\n      of [DOTS-ARCH]).\n      Refer to Section
    6 for more details.\n   *  Policy management, which enables a DOTS client to request
    the\n      installation or withdrawal of traffic filters, the dropping or\n      rate-limiting
    of unwanted traffic, and the permitting of accept-\n      listed traffic.  A DOTS
    client is entitled to instruct filtering\n      rules only on IP resources that
    belong to its domain.\n      Sample use cases for populating drop- or accept-list
    filtering\n      rules are detailed hereafter:\n      -  If a network resource
    (DOTS client) is informed about a\n         potential DDoS attack from a set of
    IP addresses, the DOTS\n         client informs its servicing DOTS gateway of
    all suspect IP\n         addresses that need to be drop-listed for further\n         investigation.
    \ The DOTS client could also specify a list of\n         protocols and port numbers
    in the drop-list rule.\n         The DOTS gateway then propagates the drop-listed
    IP addresses\n         to a DOTS server, which will undertake appropriate actions
    so\n         that traffic originated by these IP addresses to the target\n         network
    (specified by the DOTS client) is blocked.\n      -  A network that has partner
    sites from which only legitimate\n         traffic arrives may want to ensure
    that the traffic from these\n         sites is not subjected to DDoS attack mitigation.
    \ The DOTS\n         client uses the DOTS data channel to convey the accept-listed\n
    \        IP prefixes of the partner sites to its DOTS server.\n         The DOTS
    server uses this information to accept-list flows\n         originated by such
    IP prefixes and which reach the network.\n      Refer to Section 7 for more details.\n"
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\",
    \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described
    in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all\n   capitals,
    as shown here.\n   The reader should be familiar with the terms defined in [RFC8612].\n
    \  The terminology for describing YANG modules is defined in [RFC7950].\n   The
    meaning of the symbols in the tree diagrams is defined in\n   [RFC8340].\n   This
    document generalizes the notion of Access Control List (ACL) so\n   that it is
    not device specific [RFC8519].  As such, this document\n   defines an ACL as an
    ordered set of rules that is used to filter\n   traffic.  Each rule is represented
    by an Access Control Entry (ACE).\n   ACLs communicated via the DOTS data channel
    are not bound to a device\n   interface.\n   For the sake of simplicity, the examples
    in this document use\n   \"/restconf\" as the discovered RESTCONF API root path.
    \ Within the\n   examples, many protocol header lines and message-body text are
    split\n   into multiple lines for display purposes only.  When a line ends with\n
    \  backslash ('\\') as the last character, the line is wrapped for\n   display
    purposes.  It is to be considered to be joined to the next\n   line by deleting
    the backslash, the following line break, and the\n   leading whitespace of the
    next line.\n"
  title: 2.  Terminology
- contents:
  - '3.  DOTS Data Channel

    '
  - contents:
    - "3.1.  Design Overview\n   Unlike the DOTS signal channel, which must remain
      operational even\n   when confronted with signal degradation due to packet loss,
      the DOTS\n   data channel is not expected to be fully operational at all times,\n
      \  especially when a DDoS attack is underway.  The requirements for a\n   DOTS
      data channel protocol are documented in [RFC8612].\n   This specification does
      not require an order of DOTS signal and data\n   channel creation nor does it
      mandate a time interval between them.\n   These considerations are implementation
      and deployment specific.\n   As the primary function of the data channel is
      data exchange, a\n   reliable transport mode is required in order for DOTS agents
      to\n   detect data delivery success or failure.  This document uses RESTCONF\n
      \  [RFC8040] over TLS over TCP as the DOTS data channel protocol.  The\n   abstract
      layering of the DOTS data channel is shown in Figure 2.\n                           |
      DOTS Data Channel |\n              Figure 2: Abstract Layering of DOTS Data
      Channel\n   The HTTP POST, PUT, PATCH, and DELETE methods are used to edit data\n
      \  resources represented by DOTS data channel YANG modules.  These basic\n   edit
      operations allow a DOTS client to alter the running\n   configuration of the
      DOTS data channel.  Rules for generating and\n   processing RESTCONF methods
      are defined in Section 4 of [RFC8040].\n   DOTS data channel configuration information
      as well as state\n   information can be retrieved with the GET method.  An HTTP
      status-\n   line is returned for each request to report success or failure for\n
      \  RESTCONF operations (Section 5.4 of [RFC8040]).  The error-tag\n   provides
      more information about encountered errors (Section 7 of\n   [RFC8040]).\n   DOTS
      clients perform the root resource discovery procedure discussed\n   in Section
      3.1 of [RFC8040] to determine the root of the RESTCONF\n   API.  After discovering
      the RESTCONF API root, a DOTS client uses\n   this value as the initial part
      of the path in the request URI in any\n   subsequent request to the DOTS server.
      \ The DOTS server may support\n   the retrieval of the YANG modules it supports
      (Section 3.7 of\n   [RFC8040]).  For example, a DOTS client may use RESTCONF
      to retrieve\n   the vendor-specific YANG modules supported by its DOTS server.\n
      \  JavaScript Object Notation (JSON) [RFC8259] payloads are used to\n   propagate
      the DOTS data-channel-specific payload messages that carry\n   request parameters
      and response information, such as errors.  This\n   specification uses the encoding
      rules defined in [RFC7951] for\n   representing DOTS data channel configuration
      data using YANG\n   (Section 4) as JSON text.\n   A DOTS client registers itself
      with its DOTS server(s) in order to\n   set up DOTS data channel-related configuration
      data and to receive\n   state data (i.e., non-configuration data) from the DOTS
      server(s)\n   (Section 5).  Mutual authentication considerations are specified
      in\n   Section 8 of [RFC8782].  The coupling of signal and data channels is\n
      \  discussed in Section 4.4.1 of [RFC8782].\n   A DOTS client can either maintain
      a persistent connection or initiate\n   periodic connections with its DOTS server(s).
      \ If the DOTS client\n   needs to frequently update the drop-list or accept-list
      filtering\n   rules or aliases, it maintains a persistent connection with the
      DOTS\n   server.  For example, CAPTCHA and cryptographic puzzles can be used\n
      \  by the mitigation service in the DOTS client domain to determine\n   whether
      or not the IP address is used for legitimate purpose, and the\n   DOTS client
      can frequently update the drop-list filtering rules.  A\n   persistent connection
      is also useful if the DOTS client subscribes to\n   event notifications (Section
      6.3 of [RFC8040]).  Additional\n   considerations related to RESTCONF connection
      management (including,\n   configuring the connection type or the reconnect
      strategy) can be\n   found in [RESTCONF-MODELS].\n   A single DOTS data channel
      between DOTS agents can be used to\n   exchange multiple requests and multiple
      responses.  To reduce DOTS\n   client and DOTS server workload, DOTS clients
      SHOULD reuse the same\n   TLS session.  While the communication to the DOTS
      server is\n   quiescent, the DOTS client MAY probe the server to ensure it has\n
      \  maintained cryptographic state.  Such probes can also keep alive\n   firewall
      and/or NAT bindings.  A TLS heartbeat [RFC6520] verifies\n   that the DOTS server
      still has TLS state by returning a TLS message.\n   A DOTS server may detect
      conflicting filtering requests from distinct\n   DOTS clients that belong to
      the same domain.  For example, a DOTS\n   client could request to drop-list
      a prefix by specifying the source\n   prefix, while another DOTS client could
      request to accept-list that\n   same source prefix, but both having the same
      destination prefix.\n   DOTS servers SHOULD support a configuration parameter
      to indicate the\n   behavior to follow when a conflict is detected (e.g., reject
      all,\n   reject the new request, notify an administrator for validation).\n
      \  Section 7.2 specifies a default behavior when no instruction is\n   supplied
      to a DOTS server.\n   How a DOTS client synchronizes its configuration with
      the one\n   maintained by its DOTS server(s) is implementation specific.  For\n
      \  example:\n   *  A DOTS client can systematically send a GET message before
      and/or\n      after a configuration change request.\n   *  A DOTS client can
      reestablish the disconnected DOTS session after\n      an attack is mitigated.
      \ Then, it sends a GET message before a\n      configuration change request.\n
      \  NAT considerations for the DOTS data channel are similar to those\n   discussed
      in Section 3 of [RFC8782].\n   The translation of filtering rules instantiated
      on a DOTS server into\n   network configuration actions is out of scope of this
      specification.\n   Some of the fields introduced in Section 4 are also discussed
      in\n   Sections 5, 6, and 7.  These sections are authoritative for these\n   fields.\n"
    title: 3.1.  Design Overview
  - contents:
    - "3.2.  DOTS Server(s) Discovery\n   This document assumes that DOTS clients
      are provisioned with the\n   knowledge of how to reach their DOTS server(s),
      which could occur by\n   a variety of means (e.g., local configuration or dynamic
      means such\n   as DHCP [DOTS-SERVER-DISC]).  The specification of such means
      are out\n   of scope of this document.\n   Likewise, it is out of scope of this
      document to specify the behavior\n   to be followed by a DOTS client to send
      DOTS requests when multiple\n   DOTS servers are provisioned (e.g., contact
      all DOTS servers, select\n   one DOTS server among the list).\n"
    title: 3.2.  DOTS Server(s) Discovery
  - contents:
    - "3.3.  DOTS Gateways\n   When a server-domain DOTS gateway is involved in DOTS
      data channel\n   exchanges, the same considerations for manipulating the 'cdid'\n
      \  (client domain identifier) parameter specified in [RFC8782] MUST be\n   followed
      by DOTS agents.  As a reminder, 'cdid' is meant to assist\n   the DOTS server
      in enforcing some policies (e.g., limit the number of\n   filtering rules per
      DOTS client or per DOTS client domain).  A loop\n   detection mechanism for
      DOTS gateways is specified in Section 3.4.\n   If a DOTS gateway is involved,
      the DOTS gateway verifies that the\n   DOTS client is authorized to undertake
      a data channel action (e.g.,\n   instantiate filtering rules).  If the DOTS
      client is authorized, it\n   propagates the rules to the upstream DOTS server.
      \ Likewise, the DOTS\n   server verifies that the DOTS gateway is authorized
      to relay data\n   channel actions.  For example, to create or purge filters,
      a DOTS\n   client sends its request to its DOTS gateway.  The DOTS gateway\n
      \  validates the rules in the request and proxies the requests\n   containing
      the filtering rules to its DOTS server.  When the DOTS\n   gateway receives
      the associated response from the DOTS server, it\n   propagates the response
      back to the DOTS client.\n"
    title: 3.3.  DOTS Gateways
  - contents:
    - "3.4.  Detecting and Preventing Infinite Loops\n   In order to detect and prevent
      infinite loops, DOTS gateways MUST\n   support the procedure defined in Section
      5.7.1 of [RFC7230].  In\n   particular, each intermediate DOTS gateway MUST
      check that none of\n   its own information (e.g., server names, literal IP addresses)
      is\n   present in the Via header field of a DOTS message it receives:\n   *
      \ If it detects that its own information is present in the Via\n      header
      field, the DOTS gateway MUST NOT forward the DOTS message.\n      Messages that
      cannot be forwarded because of a loop SHOULD be\n      logged with a \"508 Loop
      Detected\" status-line returned to the DOTS\n      peer.  The structure of the
      reported error is depicted in\n      Figure 3.\n      error-app-tag:  loop-detected\n
      \     error-tag:      operation-failed\n      error-type:     transport, application\n
      \     error-info:     <via-header> : A copy of the Via header field when\n                      the
      loop was detected.\n      Description:    An infinite loop has been detected
      when forwarding\n                      a requests via a proxy.\n                        Figure
      3: Loop Detected Error\n      It is RECOMMENDED that DOTS clients and gateways
      support methods\n      to alert administrators about loop errors so that appropriate\n
      \     actions are undertaken.\n   *  Otherwise, the DOTS agent MUST update or
      insert the Via header\n      field by appending its own information.\n   Unless
      configured otherwise, DOTS gateways at the boundaries of a\n   DOTS client domain
      SHOULD remove the previous Via header field\n   information after checking for
      a loop before forwarding.  This\n   behavior is required for topology hiding
      purposes but can also serve\n   to minimize potential conflicts that may arise
      if overlapping\n   information is used in distinct DOTS domains (e.g., private
      IPv4\n   addresses, aliases that are not globally unique).\n"
    title: 3.4.  Detecting and Preventing Infinite Loops
  - contents:
    - "3.5.  Preventing Stale Entries\n   In order to avoid stale entries, a lifetime
      is associated with alias\n   and filtering entries created by DOTS clients.
      \ Also, DOTS servers\n   may track the inactivity timeout of DOTS clients to
      detect stale\n   entries.\n"
    title: 3.5.  Preventing Stale Entries
  title: 3.  DOTS Data Channel
- contents:
  - '4.  DOTS Data Channel YANG Module

    '
  - contents:
    - "4.1.  Generic Tree Structure\n   The DOTS data channel YANG module 'ietf-dots-data-channel'
      provides a\n   method for DOTS clients to manage aliases for resources for which\n
      \  mitigation may be requested.  Such aliases may be used in subsequent\n   DOTS
      signal channel exchanges to refer more efficiently to the\n   resources under
      attack.\n   Note that the full module's tree has been split across several\n
      \  figures to aid the exposition of the various subtrees.\n   The tree structure
      for the DOTS alias is depicted in Figure 4.\n   module: ietf-dots-data-channel\n
      \    +--rw dots-data\n        +--rw dots-client* [cuid]\n        |  +--rw cuid
      \           string\n        |  +--rw cdid?           string\n        |  +--rw
      aliases\n        |  |  +--rw alias* [name]\n        |  |     +--rw name                 string\n
      \       |  |     +--rw target-prefix*       inet:ip-prefix\n        |  |     +--rw
      target-port-range* [lower-port]\n        |  |     |  +--rw lower-port    inet:port-number\n
      \       |  |     |  +--rw upper-port?   inet:port-number\n        |  |     +--rw
      target-protocol*     uint8\n        |  |     +--rw target-fqdn*         inet:domain-name\n
      \       |  |     +--rw target-uri*          inet:uri\n        |  |     +--ro
      pending-lifetime?    int32\n        |  +--rw acls\n        |     ...\n        +--ro
      capabilities\n           ...\n                        Figure 4: DOTS Alias Subtree\n
      \  Also, the 'ietf-dots-data-channel' YANG module provides a method for\n   DOTS
      clients to manage filtering rules.  Examples of filtering\n   management in
      a DOTS context include, but are not limited to:\n   *  Drop-list management,
      which enables a DOTS client to inform a DOTS\n      server about sources from
      which traffic should be discarded.\n   *  Accept-list management, which enables
      a DOTS client to inform a\n      DOTS server about sources from which traffic
      should always be\n      accepted.\n   *  Policy management, which enables a
      DOTS client to request the\n      installation or withdrawal of traffic filters,
      the dropping or\n      rate-limiting of unwanted traffic, and the allowance
      of accept-\n      listed traffic.\n   The tree structure for the DOTS filtering
      entries is depicted in\n   Figure 5.\n   Investigations into the prospect of
      augmenting 'ietf-access-control-\n   list' to meet DOTS requirements concluded
      that such a design approach\n   did not support many of the DOTS requirements,
      for example:\n   *  Retrieve a filtering entry (or all entries) created by a
      DOTS\n      client.\n   *  Delete a filtering entry that was instantiated by
      a DOTS client.\n   Accordingly, new DOTS filtering entries (i.e., ACL) are defined
      that\n   mimic the structure specified in [RFC8519].  Concretely, DOTS agents\n
      \  are assumed to manipulate an ordered list of ACLs; each ACL contains\n   a
      separately ordered list of ACEs.  Each ACE has a group of match and\n   a group
      of action criteria.\n   Once all of the ACE entries have been iterated though
      with no match,\n   then all of the following ACL's ACE entries are iterated
      through\n   until the first match, at which point the specified action is\n
      \  applied.  If there is no match during 'idle' time (i.e., no\n   mitigation
      is active), then there is no further action to be taken\n   against the packet.
      \ If there is no match during active mitigation,\n   then the packet will still
      be scrubbed by the DDoS mitigator.\n   module: ietf-dots-data-channel\n     +--rw
      dots-data\n        +--rw dots-client* [cuid]\n        |  +--rw cuid            string\n
      \       |  +--rw cdid?           string\n        |  +--rw aliases\n        |
      \ |  ...\n        |  +--rw acls\n        |     +--rw acl* [name]\n        |
      \       +--rw name                string\n        |        +--rw type?               ietf-acl:acl-type\n
      \       |        +--rw activation-type?    activation-type\n        |        +--ro
      pending-lifetime?   int32\n        |        +--rw aces\n        |           +--rw
      ace* [name]\n        |              +--rw name          string\n        |              +--rw
      matches\n        |              |  +--rw (l3)?\n        |              |  +--rw
      (l4)?\n        |              +--rw actions\n        |              |  +--rw
      forwarding    identityref\n        |              |  +--rw rate-limit?   decimal64\n
      \       |              +--ro statistics\n        |                 +--ro matched-packets?
      \  yang:counter64\n        |                 +--ro matched-octets?    yang:counter64\n
      \       +--ro capabilities\n           ...\n                        Figure 5:
      DOTS ACLs Subtree\n   Filtering rules instructed by a DOTS client assume a default\n
      \  direction: the destination is the DOTS client domain.\n   DOTS forwarding
      actions can be 'accept' (i.e., accept matching\n   traffic) or 'drop' (i.e.,
      drop matching traffic without sending any\n   ICMP error message).  Accepted
      traffic can be subject to rate-\n   limiting 'rate-limit'.  Note that 'reject'
      action (i.e., drop\n   matching traffic and send an ICMP error message to the
      source) is not\n   supported in 'ietf-dots-data-channel' because it is not appropriate\n
      \  in the context of DDoS mitigation.  Generating ICMP messages to\n   notify
      of drops when mitigating a DDoS attack will exacerbate the\n   DDoS attack.
      \ Furthermore, these ICMP messages will be used by an\n   attacker as an explicit
      signal that the traffic is being blocked.\n"
    title: 4.1.  Generic Tree Structure
  - contents:
    - "4.2.  Filtering Fields\n   The 'ietf-dots-data-channel' module reuses the packet
      fields module\n   'ietf-packet-fields' [RFC8519], which defines matching on
      fields in\n   the packet including IPv4, IPv6, and transport layer fields.  The\n
      \  'ietf-dots-data-channel' module can be augmented, for example, to\n   support
      additional protocol-specific matching fields.\n   This specification defines
      a new IPv4/IPv6 matching field called\n   'fragment' to efficiently handle fragment-related
      filtering rules.\n   Indeed, [RFC8519] does not support such capability for
      IPv6 but\n   offers a partial support for IPv4 by means of 'flags'.  Nevertheless,\n
      \  the use of 'flags' is problematic since it does not allow a bitmask\n   to
      be defined.  For example, setting other bits not covered by the\n   'flags'
      filtering clause in a packet will allow that packet to get\n   through (because
      it won't match the ACE).  Examples to illustrate how\n   'fragment' can be used
      are provided in Appendix A.\n   Figure 6 shows the IPv4 match subtree.\n   module:
      ietf-dots-data-channel\n     +--rw dots-data\n        +--rw dots-client* [cuid]\n
      \       |  ...\n        |  +--rw acls\n        |     +--rw acl* [name]\n        |
      \       ...\n        |        +--rw aces\n        |           +--rw ace* [name]\n
      \       |              +--rw name          string\n        |              +--rw
      matches\n        |              |  +--rw (l3)?\n        |              |  +--rw
      (l4)?\n        |              +--rw actions\n        |              |  ...\n
      \       |              +--ro statistics\n        |                 ...\n        +--ro
      capabilities\n           ...\n                  Figure 6: DOTS ACLs Subtree
      (IPv4 Match)\n   Figure 7 shows the IPv6 match subtree.\n   module: ietf-dots-data-channel\n
      \    +--rw dots-data\n        +--rw dots-client* [cuid]\n        |  ...\n        |
      \ +--rw acls\n        |     +--rw acl* [name]\n        |        ...\n        |
      \       +--rw aces\n        |           +--rw ace* [name]\n        |              +--rw
      name          string\n        |              +--rw matches\n        |              |
      \ +--rw (l3)?\n        |              |  +--rw (l4)?\n        |              +--rw
      actions\n        |              |  ...\n        |              +--ro statistics\n
      \       |                 ...\n        +--ro capabilities\n           ...\n
      \                 Figure 7: DOTS ACLs Subtree (IPv6 Match)\n   Figure 8 shows
      the TCP match subtree.  In addition to the fields\n   defined in [RFC8519],
      this specification defines a new TCP matching\n   field, called 'flags-bitmask',
      to efficiently handle TCP flags\n   filtering rules.  Some examples are provided
      in Appendix B.\n      +--rw matches\n      |  +--rw (l3)?\n      |  |  ...\n
      \     |  +--rw (l4)?\n      |     +--:(tcp)\n      |     |  +--rw tcp\n      |
      \    |     +--rw sequence-number?          uint32\n      |     |     +--rw acknowledgement-number?
      \  uint32\n      |     |     +--rw data-offset?              uint8\n      |
      \    |     +--rw reserved?                 uint8\n      |     |     +--rw flags?
      \                   bits\n      |     |     +--rw window-size?              uint16\n
      \     |     |     +--rw urgent-pointer?           uint16\n      |     |     +--rw
      options?                  binary\n      |     |     +--rw flags-bitmask\n      |
      \    |     |  +--rw operator?            operator\n      |     |     |  +--rw
      bitmask                uint16\n      |     |     +--rw (source-port)?\n      |
      \    |     |  +--:(source-port-range-or-operator)\n      |     |     |     +--rw
      source-port-range-or-operator\n      |     |     |        +--rw (port-range-or-operator)?\n
      \     |     |     +--rw (destination-port)?\n      |     |        +--:(destination-port-range-or-operator)\n
      \     |     |           +--rw destination-port-range-or-operator\n      |     |
      \             +--rw (port-range-or-operator)?\n      |     +--:(udp)\n      |
      \    |  ...\n      |     +--:(icmp)\n      |        ...\n      +--rw actions\n
      \     |  ...\n                  Figure 8: DOTS ACLs Subtree (TCP Match)\n   Figure
      9 shows the UDP and ICMP match subtrees.  The same structure\n   is used for
      both ICMP and ICMPv6.  The indication whether an ACL is\n   about ICMP or ICMPv6
      is governed by the 'l3' match or the ACL type.\n      +--rw matches\n      |
      \ +--rw (l3)?\n      |  |  ...\n      |  +--rw (l4)?\n      |     +--:(tcp)\n
      \     |     |  ...\n      |     +--:(udp)\n      |     |  +--rw udp\n      |
      \    |     +--rw length?          uint16\n      |     |     +--rw (source-port)?\n
      \     |     |     |  +--:(source-port-range-or-operator)\n      |     |     |
      \    +--rw source-port-range-or-operator\n      |     |     |        +--rw (port-range-or-operator)?\n
      \     |     |     +--rw (destination-port)?\n      |     |        +--:(destination-port-range-or-operator)\n
      \     |     |           +--rw destination-port-range-or-operator\n      |     |
      \             +--rw (port-range-or-operator)?\n      |     +--:(icmp)\n      |
      \       +--rw icmp\n      |           +--rw type?             uint8\n      |
      \          +--rw code?             uint8\n      |           +--rw rest-of-header?
      \  binary\n      +--rw actions\n      |  ...\n              Figure 9: DOTS ACLs
      Subtree (UDP and ICMP Match)\n   DOTS implementations MUST support the following
      matching criteria:\n      Match based on the IP header (IPv4 and IPv6), match
      based on the\n      transport header (TCP, UDP, and ICMP), and match based on
      any\n      combination thereof.  The same matching fields are used for both\n
      \     ICMP and ICMPv6.\n   The following match fields MUST be supported by DOTS
      implementations\n   (Table 1):\n       | ACL Match | Mandatory Fields                              |\n
      \      | ipv4      | length, protocol, destination-ipv4-network,   |\n       |
      \          | source-ipv4-network, and fragment             |\n       | ipv6
      \     | length, protocol, destination-ipv6-network,   |\n       |           |
      source-ipv6-network, and fragment             |\n       | tcp       | flags-bitmask,
      source-port-range-or-operator, |\n       |           | and destination-port-range-or-operator
      \       |\n       | udp       | length, source-port-range-or-operator, and    |\n
      \      |           | destination-port-range-or-operator            |\n       |
      icmp      | type and code                                 |\n                Table
      1: Mandatory DOTS Channel Match Fields\n   Implementations MAY support other
      filtering match fields and actions.\n   The 'ietf-dots-data-channel' YANG module
      provides a method for an\n   implementation to expose its filtering capabilities.
      \ The tree\n   structure of the 'capabilities' is shown in Figure 10.  DOTS
      clients\n   that support both 'fragment' and 'flags' (or 'flags-bitmask' and\n
      \  'flags') matching fields MUST NOT set these fields in the same\n   request.\n
      \  module: ietf-dots-data-channel\n     +--rw dots-data\n        ...\n        +--ro
      capabilities\n           +--ro address-family*        enumeration\n           +--ro
      forwarding-actions*    identityref\n           +--ro rate-limit?            boolean\n
      \          +--ro transport-protocols*   uint8\n           +--ro ipv4\n           |
      \ +--ro dscp?                 boolean\n           |  +--ro ecn?                  boolean\n
      \          |  +--ro length?               boolean\n           |  +--ro ttl?
      \                 boolean\n           |  +--ro protocol?             boolean\n
      \          |  +--ro ihl?                  boolean\n           |  +--ro flags?
      \               boolean\n           |  +--ro offset?               boolean\n
      \          |  +--ro identification?       boolean\n           |  +--ro source-prefix?
      \       boolean\n           |  +--ro destination-prefix?   boolean\n           |
      \ +--ro fragment?             boolean\n           +--ro ipv6\n           |  +--ro
      dscp?                 boolean\n           |  +--ro ecn?                  boolean\n
      \          |  +--ro length?               boolean\n           |  +--ro hoplimit?
      \            boolean\n           |  +--ro protocol?             boolean\n           |
      \ +--ro destination-prefix?   boolean\n           |  +--ro source-prefix?        boolean\n
      \          |  +--ro flow-label?           boolean\n           |  +--ro fragment?
      \            boolean\n           +--ro tcp\n           |  +--ro sequence-number?
      \         boolean\n           |  +--ro acknowledgement-number?   boolean\n           |
      \ +--ro data-offset?              boolean\n           |  +--ro reserved?                 boolean\n
      \          |  +--ro flags?                    boolean\n           |  +--ro window-size?
      \             boolean\n           |  +--ro urgent-pointer?           boolean\n
      \          |  +--ro options?                  boolean\n           |  +--ro flags-bitmask?
      \           boolean\n           |  +--ro source-port?              boolean\n
      \          |  +--ro destination-port?         boolean\n           |  +--ro port-range?
      \              boolean\n           +--ro udp\n           |  +--ro length?             boolean\n
      \          |  +--ro source-port?        boolean\n           |  +--ro destination-port?
      \  boolean\n           |  +--ro port-range?         boolean\n           +--ro
      icmp\n              +--ro type?             boolean\n              +--ro code?
      \            boolean\n              +--ro rest-of-header?   boolean\n                 Figure
      10: Filtering Capabilities Subtree\n"
    title: 4.2.  Filtering Fields
  - contents:
    - "4.3.  YANG Module\n   This module uses the common YANG types defined in [RFC6991]
      and types\n   defined in [RFC8519].\n   <CODE BEGINS> file \"ietf-dots-data-channel@2020-05-28.yang\"\n
      \  module ietf-dots-data-channel {\n     yang-version 1.1;\n     namespace \"urn:ietf:params:xml:ns:yang:ietf-dots-data-channel\";\n
      \    prefix data-channel;\n     import ietf-inet-types {\n       prefix inet;\n
      \      reference\n         \"Section 4 of RFC 6991\";\n     }\n     import ietf-access-control-list
      {\n       prefix ietf-acl;\n       reference\n         \"RFC 8519: YANG Data
      Model for Network Access\n                    Control Lists (ACLs)\";\n     }\n
      \    import ietf-packet-fields {\n       prefix packet-fields;\n       reference\n
      \        \"RFC 8519: YANG Data Model for Network Access\n                    Control
      Lists (ACLs)\";\n     }\n     organization\n       \"IETF DDoS Open Threat Signaling
      (DOTS) Working Group\";\n     contact\n       \"WG Web:   <https://datatracker.ietf.org/wg/dots/>\n
      \       WG List:  <mailto:dots@ietf.org>\n        Editor:  Mohamed Boucadair\n
      \                <mailto:mohamed.boucadair@orange.com>\n        Editor:  Konda,
      Tirumaleswar Reddy.K\n                 <mailto:TirumaleswarReddy_Konda@McAfee.com>\n
      \       Author:  Jon Shallow\n                 <mailto:jon.shallow@nccgroup.com>\n
      \       Author:  Kaname Nishizuka\n                 <mailto:kaname@nttv6.jp>\n
      \       Author:  Liang Xia\n                 <mailto:frank.xialiang@huawei.com>\n
      \       Author:  Prashanth Patil\n                 <mailto:praspati@cisco.com>\n
      \       Author:  Andrew Mortensen\n                 <mailto:amortensen@arbor.net>\n
      \       Author:  Nik Teague\n                 <mailto:nteague@ironmountain.co.uk>\";\n
      \    description\n       \"This module contains YANG definition for configuring\n
      \       aliases for resources and filtering rules using DOTS\n        data channel.\n
      \       Copyright (c) 2020 IETF Trust and the persons identified as\n        authors
      of the code.  All rights reserved.\n        Redistribution and use in source
      and binary forms, with or\n        without modification, is permitted pursuant
      to, and subject\n        to the license terms contained in, the Simplified BSD
      License\n        set forth in Section 4.c of the IETF Trust's Legal Provisions\n
      \       Relating to IETF Documents\n        (http://trustee.ietf.org/license-info).\n
      \       This version of this YANG module is part of RFC 8783; see\n        the
      RFC itself for full legal notices.\";\n     revision 2020-05-28 {\n       description\n
      \        \"Initial revision.\";\n       reference\n         \"RFC 8783: Distributed
      Denial-of-Service Open Threat\n                    Signaling (DOTS) Data Channel
      Specification\";\n     }\n     typedef activation-type {\n       type enumeration
      {\n         enum activate-when-mitigating {\n           value 1;\n           description\n
      \            \"The Access Control List (ACL) is installed only when\n              a
      mitigation is active for the DOTS client.\";\n         }\n         enum immediate
      {\n           value 2;\n           description\n             \"The ACL is immediately
      activated.\";\n         }\n         enum deactivate {\n           value 3;\n
      \          description\n             \"The ACL is maintained by the DOTS server,
      but it is\n              deactivated.\";\n         }\n       }\n       description\n
      \        \"Indicates the activation type of an ACL.\";\n     }\n     typedef
      operator {\n       type bits {\n         bit not {\n           position 0;\n
      \          description\n             \"If set, logical negation of operation.\";\n
      \        }\n         bit match {\n           position 1;\n           description\n
      \            \"Match bit.  This is a bitwise match operation\n              defined
      as '(data & value) == value'.\";\n         }\n         bit any {\n           position
      3;\n           description\n             \"Any bit.  This is a match on any
      of the bits in\n              bitmask.  It evaluates to 'true' if any of the
      bits\n              in the value mask are set in the data,\n              i.e.,
      '(data & value) != 0'.\";\n         }\n       }\n       description\n         \"Specifies
      how to apply the defined bitmask.\n          'any' and 'match' bits must not
      be set simultaneously.\";\n     }\n     grouping tcp-flags {\n       leaf operator
      {\n         type operator;\n         default \"match\";\n         description\n
      \          \"Specifies how to interpret the TCP flags.\";\n       }\n       leaf
      bitmask {\n         type uint16;\n         mandatory true;\n         description\n
      \          \"The bitmask matches the last 4 bits of byte 12\n            and
      byte 13 of the TCP header.  For clarity, the 4 bits\n            of byte 12
      corresponding to the TCP data offset field\n            are not included in
      any matching.\";\n       }\n       description\n         \"Operations on TCP
      flags.\";\n     }\n     typedef fragment-type {\n       type bits {\n         bit
      df {\n           position 0;\n           description\n             \"Don't fragment
      bit for IPv4.\n              Must be set to 0 when it appears in an IPv6 filter.\";\n
      \        }\n         bit isf {\n           position 1;\n           description\n
      \            \"Is a fragment.\";\n         }\n         bit ff {\n           position
      2;\n           description\n             \"First fragment.\";\n         }\n
      \        bit lf {\n           position 3;\n           description\n             \"Last
      fragment.\";\n         }\n       }\n       description\n         \"Different
      fragment types to match against.\";\n     }\n     grouping target {\n       description\n
      \        \"Specifies the targets of the mitigation request.\";\n       leaf-list
      target-prefix {\n         type inet:ip-prefix;\n         description\n           \"IPv4
      or IPv6 prefix identifying the target.\";\n       }\n       list target-port-range
      {\n         key \"lower-port\";\n         description\n           \"Port range.
      \ When only lower-port is\n            present, it represents a single port
      number.\";\n         leaf lower-port {\n           type inet:port-number;\n
      \          mandatory true;\n           description\n             \"Lower port
      number of the port range.\";\n         }\n         leaf upper-port {\n           type
      inet:port-number;\n           must '. >= ../lower-port' {\n             error-message\n
      \              \"The upper-port number must be greater than\n                or
      equal to the lower-port number.\";\n           }\n           description\n             \"Upper
      port number of the port range.\";\n         }\n       }\n       leaf-list target-protocol
      {\n         type uint8;\n         description\n           \"Identifies the target
      protocol number.\n            Values are taken from the IANA protocol registry:\n
      \           https://www.iana.org/assignments/protocol-numbers/\n            For
      example, 6 for TCP or 17 for UDP.\";\n       }\n       leaf-list target-fqdn
      {\n         type inet:domain-name;\n         description\n           \"FQDN
      identifying the target.\";\n       }\n       leaf-list target-uri {\n         type
      inet:uri;\n         description\n           \"URI identifying the target.\";\n
      \      }\n     }\n     grouping fragment-fields {\n       leaf operator {\n
      \        type operator;\n         default \"match\";\n         description\n
      \          \"Specifies how to interpret the fragment type.\";\n       }\n       leaf
      type {\n         type fragment-type;\n         mandatory true;\n         description\n
      \          \"Indicates what fragment type to look for.\";\n       }\n       description\n
      \        \"Operations on fragment types.\";\n     }\n     grouping aliases {\n
      \      description\n         \"Top-level container for aliases.\";\n       list
      alias {\n         key \"name\";\n         description\n           \"List of
      aliases.\";\n         leaf name {\n           type string;\n           description\n
      \            \"The name of the alias.\";\n         }\n         uses target;\n
      \        leaf pending-lifetime {\n           type int32;\n           units \"minutes\";\n
      \          config false;\n           description\n             \"Indicates the
      pending validity lifetime of the alias\n              entry.\";\n         }\n
      \      }\n     }\n     grouping ports {\n       choice source-port {\n         container
      source-port-range-or-operator {\n           uses packet-fields:port-range-or-operator;\n
      \          description\n             \"Source port definition.\";\n         }\n
      \        description\n           \"Choice of specifying the source port or referring
      to\n            a group of source port numbers.\";\n       }\n       choice
      destination-port {\n         container destination-port-range-or-operator {\n
      \          uses packet-fields:port-range-or-operator;\n           description\n
      \            \"Destination port definition.\";\n         }\n         description\n
      \          \"Choice of specifying a destination port or referring\n            to
      a group of destination port numbers.\";\n       }\n       description\n         \"Choice
      of specifying a source or destination port numbers.\";\n     }\n     grouping
      access-lists {\n       description\n         \"Specifies the ordered set of
      Access Control Lists.\";\n       list acl {\n         key \"name\";\n         ordered-by
      user;\n         description\n           \"An ACL is an ordered list of Access
      Control Entries (ACE).\n            Each ACE has a list of match criteria and
      a list of\n            actions.\";\n         leaf name {\n           type string
      {\n             length \"1..64\";\n           }\n           description\n             \"The
      name of the access list.\";\n           reference\n             \"RFC 8519:
      YANG Data Model for Network Access\n                        Control Lists (ACLs)\";\n
      \        }\n         leaf type {\n           type ietf-acl:acl-type;\n           description\n
      \            \"Type of access control list.  Indicates the primary\n              intended
      type of match criteria (e.g., IPv4, IPv6)\n              used in the list instance.\";\n
      \          reference\n             \"RFC 8519: YANG Data Model for Network Access\n
      \                       Control Lists (ACLs)\";\n         }\n         leaf activation-type
      {\n           type activation-type;\n           default \"activate-when-mitigating\";\n
      \          description\n             \"Indicates the activation type of an ACL.
      \ An ACL can be\n              deactivated, installed immediately, or installed
      when\n              a mitigation is active.\";\n         }\n         leaf pending-lifetime
      {\n           type int32;\n           units \"minutes\";\n           config
      false;\n           description\n             \"Indicates the pending validity
      lifetime of the ACL\n              entry.\";\n         }\n         container
      aces {\n           description\n             \"The Access Control Entries container
      contains\n              a list of ACEs.\";\n           list ace {\n             key
      \"name\";\n             ordered-by user;\n             description\n               \"List
      of access list entries.\";\n             leaf name {\n               type string
      {\n                 length \"1..64\";\n               }\n               description\n
      \                \"A unique name identifying this ACE.\";\n               reference\n
      \                \"RFC 8519: YANG Data Model for Network Access\n                            Control
      Lists (ACLs)\";\n             }\n             container matches {\n               description\n
      \                \"The rules in this set determine what fields will be\n                  matched
      upon before any action is taken on them.\n                  If no matches are
      defined in a particular container,\n                  then any packet will match
      that container.\n                  If no matches are specified at all in an
      ACE, then any\n                  packet will match the ACE.\";\n               reference\n
      \                \"RFC 8519: YANG Data Model for Network Access\n                            Control
      Lists (ACLs)\";\n               choice l3 {\n                 container ipv4
      {\n                   when \"derived-from(../../../../type, \"\n                      +
      \"'ietf-acl:ipv4-acl-type')\";\n                   uses packet-fields:acl-ip-header-fields;\n
      \                  uses packet-fields:acl-ipv4-header-fields;\n                   container
      fragment {\n                     description\n                       \"Indicates
      how to handle IPv4 fragments.\";\n                     uses fragment-fields;\n
      \                  }\n                   description\n                     \"Rule
      set that matches IPv4 header.\";\n                 }\n                 container
      ipv6 {\n                   when \"derived-from(../../../../type, \"\n                      +
      \"'ietf-acl:ipv6-acl-type')\";\n                   uses packet-fields:acl-ip-header-fields;\n
      \                  uses packet-fields:acl-ipv6-header-fields;\n                   container
      fragment {\n                     description\n                       \"Indicates
      how to handle IPv6 fragments.\";\n                     uses fragment-fields;\n
      \                  }\n                   description\n                     \"Rule
      set that matches IPv6 header.\";\n                 }\n                 description\n
      \                  \"Either IPv4 or IPv6.\";\n               }\n               choice
      l4 {\n                 container tcp {\n                   uses packet-fields:acl-tcp-header-fields;\n
      \                  container flags-bitmask {\n                     description\n
      \                      \"Indicates how to handle TCP flags.\";\n                     uses
      tcp-flags;\n                   }\n                   uses ports;\n                   description\n
      \                    \"Rule set that matches TCP header.\";\n                 }\n
      \                container udp {\n                   uses packet-fields:acl-udp-header-fields;\n
      \                  uses ports;\n                   description\n                     \"Rule
      set that matches UDP header.\";\n                 }\n                 container
      icmp {\n                   uses packet-fields:acl-icmp-header-fields;\n                   description\n
      \                    \"Rule set that matches ICMP/ICMPv6 header.\";\n                 }\n
      \                description\n                   \"Can be TCP, UDP, or ICMP/ICMPv6\";\n
      \              }\n             }\n             container actions {\n               description\n
      \                \"Definitions of action for this ACE.\";\n               leaf
      forwarding {\n                 type identityref {\n                   base ietf-acl:forwarding-action;\n
      \                }\n                 mandatory true;\n                 description\n
      \                  \"Specifies the forwarding action per ACE.\";\n                 reference\n
      \                  \"RFC 8519: YANG Data Model for Network Access\n                              Control
      Lists (ACLs)\";\n               }\n               leaf rate-limit {\n                 when
      \"../forwarding = 'ietf-acl:accept'\" {\n                   description\n                     \"Rate-limit
      is valid only when accept action is\n                      used.\";\n                 }\n
      \                type decimal64 {\n                   fraction-digits 2;\n                 }\n
      \                units \"bytes per second\";\n                 description\n
      \                  \"Specifies how to rate-limit the traffic.\";\n               }\n
      \            }\n             container statistics {\n               config false;\n
      \              description\n                 \"Aggregate statistics.\";\n               uses
      ietf-acl:acl-counters;\n             }\n           }\n         }\n       }\n
      \    }\n     container dots-data {\n       description\n         \"Main container
      for DOTS data channel.\";\n       list dots-client {\n         key \"cuid\";\n
      \        description\n           \"List of DOTS clients.\";\n         leaf cuid
      {\n           type string;\n           description\n             \"A unique
      identifier that is generated by a DOTS client\n              to prevent request
      collisions.\";\n           reference\n             \"RFC 8782: Distributed Denial-of-Service
      Open Threat\n                     Signaling (DOTS) Signal Channel Specification\";\n
      \        }\n         leaf cdid {\n           type string;\n           description\n
      \            \"A client domain identifier conveyed by a\n              server-domain
      DOTS gateway to a remote DOTS server.\";\n           reference\n             \"RFC
      8782: Distributed Denial-of-Service Open Threat\n                     Signaling
      (DOTS) Signal Channel Specification\";\n         }\n         container aliases
      {\n           description\n             \"Set of aliases that are bound to a
      DOTS client.\";\n           uses aliases;\n         }\n         container acls
      {\n           description\n             \"Access lists that are bound to a DOTS
      client.\";\n           uses access-lists;\n         }\n       }\n       container
      capabilities {\n         config false;\n         description\n           \"Match
      capabilities\";\n         leaf-list address-family {\n           type enumeration
      {\n             enum ipv4 {\n               description\n                 \"IPv4
      is supported.\";\n             }\n             enum ipv6 {\n               description\n
      \                \"IPv6 is supported.\";\n             }\n           }\n           description\n
      \            \"Indicates the IP address families supported by\n              the
      DOTS server.\";\n         }\n         leaf-list forwarding-actions {\n           type
      identityref {\n             base ietf-acl:forwarding-action;\n           }\n
      \          description\n             \"Supported forwarding action(s).\";\n
      \        }\n         leaf rate-limit {\n           type boolean;\n           description\n
      \            \"Support of rate-limit action.\";\n         }\n         leaf-list
      transport-protocols {\n           type uint8;\n           description\n             \"Upper-layer
      protocol associated with a filtering rule.\n              Values are taken from
      the IANA protocol registry:\n              https://www.iana.org/assignments/protocol-numbers/\n
      \             For example, this field contains 1 for ICMP, 6 for TCP\n              17
      for UDP, or 58 for ICMPv6.\";\n         }\n         container ipv4 {\n           description\n
      \            \"Indicates IPv4 header fields that are supported to enforce\n
      \             ACLs.\";\n           leaf dscp {\n             type boolean;\n
      \            description\n               \"Support of filtering based on Differentiated
      Services\n                Code Point (DSCP).\";\n           }\n           leaf
      ecn {\n             type boolean;\n             description\n               \"Support
      of filtering based on Explicit Congestion\n                Notification (ECN).\";\n
      \          }\n           leaf length {\n             type boolean;\n             description\n
      \              \"Support of filtering based on the Total Length.\";\n           }\n
      \          leaf ttl {\n             type boolean;\n             description\n
      \              \"Support of filtering based on the Time to Live (TTL).\";\n
      \          }\n           leaf protocol {\n             type boolean;\n             description\n
      \              \"Support of filtering based on protocol field.\";\n           }\n
      \          leaf ihl {\n             type boolean;\n             description\n
      \              \"Support of filtering based on the Internet Header\n                Length
      (IHL).\";\n           }\n           leaf flags {\n             type boolean;\n
      \            description\n               \"Support of filtering based on the
      'flags'.\";\n           }\n           leaf offset {\n             type boolean;\n
      \            description\n               \"Support of filtering based on the
      'offset'.\";\n           }\n           leaf identification {\n             type
      boolean;\n             description\n               \"Support of filtering based
      on the 'identification'.\";\n           }\n           leaf source-prefix {\n
      \            type boolean;\n             description\n               \"Support
      of filtering based on the source prefix.\";\n           }\n           leaf destination-prefix
      {\n             type boolean;\n             description\n               \"Support
      of filtering based on the destination prefix.\";\n           }\n           leaf
      fragment {\n             type boolean;\n             description\n               \"Indicates
      the capability of a DOTS server to\n                enforce filters on IPv4
      fragments.  That is, the match\n                functionality based on the Layer
      3 'fragment' clause\n                is supported.\";\n           }\n         }\n
      \        container ipv6 {\n           description\n             \"Indicates
      IPv6 header fields that are supported to enforce\n              ACLs.\";\n           leaf
      dscp {\n             type boolean;\n             description\n               \"Support
      of filtering based on DSCP.\";\n           }\n           leaf ecn {\n             type
      boolean;\n             description\n               \"Support of filtering based
      on ECN.\";\n           }\n           leaf length {\n             type boolean;\n
      \            description\n               \"Support of filtering based on the
      Payload Length.\";\n           }\n           leaf hoplimit {\n             type
      boolean;\n             description\n               \"Support of filtering based
      on the Hop Limit.\";\n           }\n           leaf protocol {\n             type
      boolean;\n             description\n               \"Support of filtering based
      on the Next Header field.\";\n           }\n           leaf destination-prefix
      {\n             type boolean;\n             description\n               \"Support
      of filtering based on the destination prefix.\";\n           }\n           leaf
      source-prefix {\n             type boolean;\n             description\n               \"Support
      of filtering based on the source prefix.\";\n           }\n           leaf flow-label
      {\n             type boolean;\n             description\n               \"Support
      of filtering based on the Flow Label.\";\n           }\n           leaf fragment
      {\n             type boolean;\n             description\n               \"Indicates
      the capability of a DOTS server to\n                enforce filters on IPv6
      fragments.\";\n           }\n         }\n         container tcp {\n           description\n
      \            \"Set of TCP fields that are supported by the DOTS server\n              to
      enforce filters.\";\n           leaf sequence-number {\n             type boolean;\n
      \            description\n               \"Support of filtering based on the
      TCP sequence number.\";\n           }\n           leaf acknowledgement-number
      {\n             type boolean;\n             description\n               \"Support
      of filtering based on the TCP acknowledgement\n                number.\";\n
      \          }\n           leaf data-offset {\n             type boolean;\n             description\n
      \              \"Support of filtering based on the TCP data-offset.\";\n           }\n
      \          leaf reserved {\n             type boolean;\n             description\n
      \              \"Support of filtering based on the TCP reserved field.\";\n
      \          }\n           leaf flags {\n             type boolean;\n             description\n
      \              \"Support of filtering, as defined in RFC 8519, based\n                on
      the TCP flags.\";\n           }\n           leaf window-size {\n             type
      boolean;\n             description\n               \"Support of filtering based
      on the TCP window size.\";\n           }\n           leaf urgent-pointer {\n
      \            type boolean;\n             description\n               \"Support
      of filtering based on the TCP urgent pointer.\";\n           }\n           leaf
      options {\n             type boolean;\n             description\n               \"Support
      of filtering based on the TCP options.\";\n           }\n           leaf flags-bitmask
      {\n             type boolean;\n             description\n               \"Support
      of filtering based on the TCP flags bitmask.\";\n           }\n           leaf
      source-port {\n             type boolean;\n             description\n               \"Support
      of filtering based on the source port number.\";\n           }\n           leaf
      destination-port {\n             type boolean;\n             description\n               \"Support
      of filtering based on the destination port\n                number.\";\n           }\n
      \          leaf port-range {\n             type boolean;\n             description\n
      \              \"Support of filtering based on a port range.\n                This
      includes filtering based on a source port range,\n                destination
      port range, or both.  All operators\n                (i.e, less than or equal
      to, greater than or equal to,\n                equal to, and not equal to) are
      supported.\n                In particular, this means that the implementation\n
      \               supports filtering based on\n                source-port-range-or-operator
      and\n                destination-port-range-or-operator.\";\n           }\n
      \        }\n         container udp {\n           description\n             \"Set
      of UDP fields that are supported by the DOTS server\n              to enforce
      filters.\";\n           leaf length {\n             type boolean;\n             description\n
      \              \"Support of filtering based on the UDP length.\";\n           }\n
      \          leaf source-port {\n             type boolean;\n             description\n
      \              \"Support of filtering based on the source port number.\";\n
      \          }\n           leaf destination-port {\n             type boolean;\n
      \            description\n               \"Support of filtering based on the
      destination port\n                number.\";\n           }\n           leaf
      port-range {\n             type boolean;\n             description\n               \"Support
      of filtering based on a port range.\n                This includes filtering
      based on a source port range,\n                destination port range, or both.
      \ All operators\n                (i.e, less than or equal, greater than or equal,\n
      \               equal to, and not equal to) are supported.\n                In
      particular, this means that the implementation\n                supports filtering
      based on\n                source-port-range-or-operator and\n                destination-port-range-or-operator.\";\n
      \          }\n         }\n         container icmp {\n           description\n
      \            \"Set of ICMP/ICMPv6 fields that are supported by the DOTS\n              server
      to enforce filters.\";\n           leaf type {\n             type boolean;\n
      \            description\n               \"Support of filtering based on the
      ICMP/ICMPv6 type.\";\n           }\n           leaf code {\n             type
      boolean;\n             description\n               \"Support of filtering based
      on the ICMP/ICMPv6 code.\";\n           }\n           leaf rest-of-header {\n
      \            type boolean;\n             description\n               \"Support
      of filtering based on the ICMP four-byte\n                field / the ICMPv6
      message body.\";\n           }\n         }\n       }\n     }\n   }\n   <CODE
      ENDS>\n"
    title: 4.3.  YANG Module
  title: 4.  DOTS Data Channel YANG Module
- contents:
  - '5.  Managing DOTS Clients

    '
  - contents:
    - "5.1.  Registering DOTS Clients\n   In order to make use of the DOTS data channel,
      a DOTS client MUST\n   register with its DOTS server(s) by creating a DOTS client
      ('dots-\n   client') resource.  To that aim, DOTS clients SHOULD send a POST\n
      \  request (shown in Figure 11).\n    POST /restconf/data/ietf-dots-data-channel:dots-data
      HTTP/1.1\n    Host: {host}:{port}\n    Content-Type: application/yang-data+json\n
      \   {\n      \"ietf-dots-data-channel:dots-client\": [\n        {\n          \"cuid\":
      \"string\"\n        }\n      ]\n    }\n                     Figure 11: POST
      to Register Schema\n   The 'cuid' (client unique identifier) parameter is described
      below:\n   cuid:  A globally unique identifier that is meant to prevent\n      collisions
      among DOTS clients.  This attribute has the same\n      meaning, syntax, and
      processing rules as the 'cuid' attribute\n      defined in [RFC8782].\n      DOTS
      clients MUST use the same 'cuid' for both signal and data\n      channels.\n
      \     This is a mandatory attribute.\n   In deployments where server-domain
      DOTS gateways are enabled,\n   identity information about the origin source
      client domain SHOULD be\n   supplied to the DOTS server.  That information is
      meant to assist the\n   DOTS server to enforce some policies.  These policies
      can be enforced\n   per client, per client domain, or both.  Figure 12 shows
      a schema of\n   a register request relayed by a server-domain DOTS gateway.\n
      \   POST /restconf/data/ietf-dots-data-channel:dots-data HTTP/1.1\n    Host:
      {host}:{port}\n    Content-Type: application/yang-data+json\n    {\n      \"ietf-dots-data-channel:dots-client\":
      [\n        {\n          \"cuid\": \"string\",\n          \"cdid\": \"string\"\n
      \       }\n      ]\n    }\n   Figure 12: POST to Register Schema (via a Server-Domain
      DOTS Gateway)\n   A server-domain DOTS gateway SHOULD add the following attribute:\n
      \  cdid:  This attribute has the same meaning, syntax, and processing\n      rules
      as the 'cdid' attribute defined in [RFC8782].\n      In deployments where server-domain
      DOTS gateways are enabled,\n      'cdid' does not need to be inserted when relaying
      DOTS methods to\n      manage aliases (Section 6) or filtering rules (Section
      7).  DOTS\n      servers are responsible for maintaining the association between\n
      \     'cdid' and 'cuid' for policy enforcement purposes.\n      This is an optional
      attribute.\n   An example request to create a 'dots-client' resource is depicted
      in\n   Figure 13.  This request is relayed by a server-domain DOTS gateway\n
      \  as hinted by the presence of the 'cdid' attribute.\n    POST /restconf/data/ietf-dots-data-channel:dots-data
      HTTP/1.1\n    Host: example.com\n    Content-Type: application/yang-data+json\n
      \   {\n      \"ietf-dots-data-channel:dots-client\": [\n        {\n          \"cuid\":
      \"dz6pHjaADkaFTbjr0JGBpw\",\n          \"cdid\": \"7eeaf349529eb55ed50113\"\n
      \       }\n      ]\n    }\n                 Figure 13: POST to Register (DOTS
      gateway)\n   As a reminder, DOTS gateways may rewrite the 'cuid' used by peer
      DOTS\n   clients (Section 4.4.1 of [RFC8782]).\n   DOTS servers can identify
      the DOTS client domain using the 'cdid'\n   parameter or using the client's
      DNS name specified in the Subject\n   Alternative Name extension's dNSName type
      in the client certificate\n   [RFC6125].\n   DOTS servers MUST limit the number
      of 'dots-client' resources to be\n   created by the same DOTS client to 1 per
      request.  Requests with\n   multiple 'dots-client' resources MUST be rejected
      by DOTS servers.\n   To that aim, the DOTS server MUST rely on the same procedure
      to\n   unambiguously identify a DOTS client as discussed in Section 4.4.1 of\n
      \  [RFC8782].\n   The DOTS server indicates the result of processing the POST
      request\n   using status-line codes.  Status codes in the \"2xx\" range are\n
      \  success, \"4xx\" codes are some sort of invalid requests and \"5xx\"\n   codes
      are returned if the DOTS server has erred or is incapable of\n   accepting the
      creation of the 'dots-client' resource.  In particular,\n   *  \"201 Created\"
      status-line is returned in the response if the DOTS\n      server has accepted
      the request.\n   *  \"400 Bad Request\" status-line is returned by the DOTS
      server if\n      the request does not include a 'cuid' parameter.  The error-tag\n
      \     \"missing-attribute\" is used in this case.\n   *  \"409 Conflict\" status-line
      is returned to the requesting DOTS\n      client if the data resource already
      exists.  The error-tag\n      \"resource-denied\" is used in this case.\n   Once
      a DOTS client registers itself with a DOTS server, it can\n   create/delete/retrieve
      aliases (Section 6) and filtering rules\n   (Section 7).\n   A DOTS client MAY
      use the PUT request (Section 4.5 of [RFC8040]) to\n   register a DOTS client
      within the DOTS server.  An example is shown\n   in Figure 14.\n    PUT /restconf/data/ietf-dots-data-channel:dots-data\\\n
      \       /dots-client=dz6pHjaADkaFTbjr0JGBpw HTTP/1.1\n    Host: example.com\n
      \   Content-Type: application/yang-data+json\n    {\n      \"ietf-dots-data-channel:dots-client\":
      [\n        {\n          \"cuid\": \"dz6pHjaADkaFTbjr0JGBpw\"\n        }\n      ]\n
      \   }\n                         Figure 14: PUT to Register\n   The DOTS gateway
      that inserted a 'cdid' in a PUT request MUST strip\n   the 'cdid' parameter
      in the corresponding response before forwarding\n   the response to the DOTS
      client.\n"
    title: 5.1.  Registering DOTS Clients
  - contents:
    - "5.2.  De-registering DOTS Clients\n   A DOTS client de-registers from its DOTS
      server(s) by deleting the\n   'cuid' resource(s).  Resources bound to this DOTS
      client will be\n   deleted by the DOTS server.  An example of a de-register
      request is\n   shown in Figure 15.\n    DELETE /restconf/data/ietf-dots-data-channel:dots-data\\\n
      \          /dots-client=dz6pHjaADkaFTbjr0JGBpw HTTP/1.1\n    Host: example.com\n
      \                   Figure 15: De-register a DOTS Client\n"
    title: 5.2.  De-registering DOTS Clients
  title: 5.  Managing DOTS Clients
- contents:
  - "6.  Managing DOTS Aliases\n   The following subsections define the means for
    a DOTS client to\n   create aliases (Section 6.1), to retrieve one or a list of
    aliases\n   (Section 6.2), and to delete an alias (Section 6.3).\n"
  - contents:
    - "6.1.  Creating Aliases\n   A POST or PUT request is used by a DOTS client to
      create aliases for\n   resources for which a mitigation may be requested.  Such
      aliases may\n   be used in subsequent DOTS signal channel exchanges to refer
      more\n   efficiently to the resources under attack.\n   DOTS clients within
      the same domain can create different aliases for\n   the same resource.\n   The
      structure of POST requests used to create aliases is shown in\n   Figure 16.\n
      \   POST /restconf/data/ietf-dots-data-channel:dots-data\\\n         /dots-client=cuid
      HTTP/1.1\n    Host: {host}:{port}\n    Content-Type: application/yang-data+json\n
      \   {\n     \"ietf-dots-data-channel:aliases\": {\n       \"alias\": [\n         {\n
      \          \"name\": \"string\",\n           \"target-prefix\": [\n             \"string\"\n
      \          ],\n           \"target-port-range\": [\n             {\n               \"lower-port\":
      integer,\n               \"upper-port\": integer\n             }\n           ],\n
      \          \"target-protocol\": [\n             integer\n           ],\n           \"target-fqdn\":
      [\n             \"string\"\n           ],\n           \"target-uri\": [\n             \"string\"\n
      \          ]\n         }\n       ]\n     }\n   }\n             Figure 16: POST
      to Create Aliases (Request Schema)\n   The parameters are described below:\n
      \  name:  Name of the alias.\n      This is a mandatory attribute.\n   target-prefix:
      \ Prefixes are separated by commas.  Prefixes are\n      represented using Classless
      Inter-domain Routing (CIDR) notation\n      [RFC4632].  As a reminder, the prefix
      length must be less than or\n      equal to 32 for IPv4 or 128 for IPv6.\n      The
      prefix list MUST NOT include broadcast, loopback, or multicast\n      addresses.
      \ These addresses are considered as invalid values.  In\n      addition, the
      DOTS server MUST validate that these prefixes are\n      within the scope of
      the DOTS client domain.  Other validation\n      checks may be supported by
      DOTS servers.\n      This is an optional attribute.\n   target-port-range:  A
      range of port numbers.\n      The port range is defined by two bounds, a lower
      port number\n      ('lower-port') and an upper port number ('upper-port').  The
      range\n      is considered to include both the lower and upper bounds.\n      When
      only 'lower-port' is present, it represents a single port\n      number.\n      For
      TCP, UDP, Stream Control Transmission Protocol (SCTP)\n      [RFC4960], or Datagram
      Congestion Control Protocol (DCCP)\n      [RFC4340], the range of port numbers
      can be, for example,\n      1024-65535.\n      This is an optional attribute.\n
      \  target-protocol:  A list of protocols.  Values are taken from the\n      IANA
      protocol registry [IANA-PROTO].\n      If 'target-protocol' is not specified,
      then the request applies to\n      any protocol.\n      This is an optional
      attribute.\n   target-fqdn:  A list of Fully Qualified Domain Names (FQDNs)\n
      \     identifying resources under attack [RFC8499].\n      How a name is passed
      to an underlying name resolution library is\n      implementation and deployment
      specific.  Nevertheless, once the\n      name is resolved into one or multiple
      IP addresses, DOTS servers\n      MUST apply the same validation checks as those
      for 'target-\n      prefix'.\n      The use of FQDNs may be suboptimal because
      it does not guarantee\n      that the DOTS server will resolve a name to the
      same IP addresses\n      that the DOTS client does.\n      This is an optional
      attribute.\n   target-uri:  A list of Uniform Resource Identifiers (URIs) [RFC3986].\n
      \     The same validation checks used for 'target-fqdn' MUST be followed\n      by
      DOTS servers to validate a target URI.\n      This is an optional attribute.\n
      \  In POST or PUT requests, at least one of the 'target-prefix',\n   'target-fqdn',
      or 'target-uri' attributes MUST be present.  DOTS\n   agents can safely ignore
      vendor-specific parameters they don't\n   understand.\n   If more than one 'target-*'
      scope types (e.g., 'target-prefix' and\n   'target-fqdn' or 'target-fqdn' and
      'target-uri') are included in a\n   POST or PUT request, the DOTS server binds
      all resulting IP\n   addresses/prefixes to the same resource.\n   Figure 17
      shows a POST request to create an alias called \"https1\" for\n   HTTPS servers
      with IP addresses 2001:db8:6401::1 and 2001:db8:6401::2\n   listening on TCP
      port number 443.\n   POST /restconf/data/ietf-dots-data-channel:dots-data\\\n
      \       /dots-client=dz6pHjaADkaFTbjr0JGBpw HTTP/1.1\n   Host: example.com\n
      \  Content-Type: application/yang-data+json\n   {\n     \"ietf-dots-data-channel:aliases\":
      {\n       \"alias\": [\n         {\n           \"name\": \"https1\",\n           \"target-protocol\":
      [\n             6\n           ],\n           \"target-prefix\": [\n             \"2001:db8:6401::1/128\",\n
      \            \"2001:db8:6401::2/128\"\n           ],\n           \"target-port-range\":
      [\n             {\n               \"lower-port\": 443\n             }\n           ]\n
      \        }\n       ]\n     }\n   }\n              Figure 17: Example of a POST
      to Create an Alias\n   A \"201 Created\" status-line MUST be returned in the
      response if the\n   DOTS server has accepted the alias.\n   A \"409 Conflict\"
      status-line MUST be returned to the requesting DOTS\n   client, if the request
      is conflicting with an existing alias name.\n   The error-tag \"resource-denied\"
      is used in this case.\n   If the request is missing a mandatory attribute or
      it contains an\n   invalid or unknown parameter, a \"400 Bad Request\" status-line
      MUST be\n   returned by the DOTS server.  The error-tag is set to \"missing-\n
      \  attribute\", \"invalid-value\", or \"unknown-element\" as a function of\n
      \  the encountered error.\n   If the request is received via a server-domain
      DOTS gateway, but the\n   DOTS server does not maintain a 'cdid' for this 'cuid'
      while a 'cdid'\n   is expected to be supplied, the DOTS server MUST reply with
      a \"403\n   Forbidden\" status-line and the error-tag \"access-denied\".  Upon\n
      \  receipt of this message, the DOTS client MUST register (Section 5).\n   A
      DOTS client uses the PUT request to modify the aliases in the DOTS\n   server.
      \ In particular, a DOTS client MUST update its alias entries\n   upon change
      of the prefix indicated in the 'target-prefix'.\n   A DOTS server MUST maintain
      an alias for at least 10080 minutes (1\n   week).  If no refresh request is
      seen from the DOTS client, the DOTS\n   server removes expired entries.\n"
    title: 6.1.  Creating Aliases
  - contents:
    - "6.2.  Retrieving Installed Aliases\n   A GET request is used to retrieve one
      or all installed aliases by a\n   DOTS client from a DOTS server (Section 3.3.1
      of [RFC8040]).  If no\n   'name' is included in the request, this indicates
      that the request is\n   about retrieving all aliases instantiated by the DOTS
      client.\n   Figure 18 shows an example to retrieve all the aliases that were\n
      \  instantiated by the requesting DOTS client.  The \"content\" query\n   parameter
      and its permitted values are defined in Section 4.8.1 of\n   [RFC8040].\n     GET
      /restconf/data/ietf-dots-data-channel:dots-data\\\n         /dots-client=dz6pHjaADkaFTbjr0JGBpw\\\n
      \        /aliases?content=all HTTP/1.1\n     Host: example.com\n     Accept:
      application/yang-data+json\n              Figure 18: GET to Retrieve All Installed
      Aliases\n   Figure 19 shows an example of the response message body that includes\n
      \  all the aliases that are maintained by the DOTS server for the DOTS\n   client
      identified by the 'cuid' parameter.\n   {\n     \"ietf-dots-data-channel:aliases\":
      {\n       \"alias\": [\n         {\n           \"name\": \"Server1\",\n           \"target-protocol\":
      [\n             6\n           ],\n           \"target-prefix\": [\n             \"2001:db8:6401::1/128\",\n
      \            \"2001:db8:6401::2/128\"\n           ],\n           \"target-port-range\":
      [\n             {\n               \"lower-port\": 443\n             }\n           ],\n
      \          \"pending-lifetime\": 3596\n         },\n         {\n           \"name\":
      \"Server2\",\n           \"target-protocol\": [\n             6\n           ],\n
      \          \"target-prefix\": [\n             \"2001:db8:6401::10/128\",\n             \"2001:db8:6401::20/128\"\n
      \          ],\n           \"target-port-range\": [\n             {\n               \"lower-port\":
      80\n             }\n           ],\n           \"pending-lifetime\": 9869\n         }\n
      \      ]\n     }\n   }\n       Figure 19: An Example of a Response Body Listing
      All Installed\n   Figure 20 shows an example of a GET request to retrieve the
      alias\n   \"Server2\" that was instantiated by the DOTS client.\n     GET /restconf/data/ietf-dots-data-channel:dots-data\\\n
      \        /dots-client=dz6pHjaADkaFTbjr0JGBpw\\\n         /aliases/alias=Server2?content=all
      HTTP/1.1\n     Host: example.com\n     Accept: application/yang-data+json\n
      \                   Figure 20: GET to Retrieve an Alias\n   If an alias name
      ('name') is included in the request, but the DOTS\n   server does not find that
      alias name for this DOTS client in its\n   configuration data, it MUST respond
      with a \"404 Not Found\" status-\n   line.\n"
    title: 6.2.  Retrieving Installed Aliases
  - contents:
    - "6.3.  Deleting Aliases\n   A DELETE request is used to delete an alias maintained
      by a DOTS\n   server.\n   If the DOTS server does not find the alias name that
      was conveyed in\n   the DELETE request in its configuration data for this DOTS
      client, it\n   MUST respond with a \"404 Not Found\" status-line.\n   The DOTS
      server successfully acknowledges a DOTS client's request to\n   remove the alias
      using \"204 No Content\" status-line in the response.\n   Figure 21 shows an
      example of a request to delete an alias.\n     DELETE /restconf/data/ietf-dots-data-channel:dots-data\\\n
      \           /dots-client=dz6pHjaADkaFTbjr0JGBpw\\\n            /aliases/alias=Server1
      HTTP/1.1\n     Host: example.com\n                         Figure 21: Delete
      an Alias\n"
    title: 6.3.  Deleting Aliases
  title: 6.  Managing DOTS Aliases
- contents:
  - "7.  Managing DOTS Filtering Rules\n   The following subsections define the means
    for a DOTS client to\n   retrieve DOTS filtering capabilities (Section 7.1), to
    create\n   filtering rules (Section 7.2), to retrieve active filtering rules\n
    \  (Section 7.3), and to delete a filtering rule (Section 7.4).\n"
  - contents:
    - "7.1.  Retrieving DOTS Filtering Capabilities\n   A DOTS client MAY send a GET
      request to retrieve the filtering\n   capabilities supported by a DOTS server.
      \ Figure 22 shows an example\n   of such request.\n     GET /restconf/data/ietf-dots-data-channel:dots-data\\\n
      \        /capabilities HTTP/1.1\n     Host: example.com\n     Accept: application/yang-data+json\n
      \       Figure 22: GET to Retrieve the Capabilities of a DOTS Server\n   A DOTS
      client, which issued a GET request to retrieve the filtering\n   capabilities
      supported by its DOTS server, SHOULD NOT request\n   filtering actions that
      are not supported by that DOTS server.\n   Figure 23 shows an example of a response
      body received from a DOTS\n   server which supports:\n   *  IPv4, IPv6, TCP,
      UDP, ICMP, and ICMPv6 mandatory match criteria\n      listed in Section 4.2.\n
      \  *  'accept', 'drop', and 'rate-limit' actions.\n    {\n     \"ietf-dots-data-channel:capabilities\":
      {\n       \"address-family\": [\"ipv4\", \"ipv6\"],\n       \"forwarding-actions\":
      [\"drop\", \"accept\"],\n       \"rate-limit\": true,\n       \"transport-protocols\":
      [1, 6, 17, 58],\n       \"ipv4\": {\n         \"length\": true,\n         \"protocol\":
      true,\n         \"destination-prefix\": true,\n         \"source-prefix\": true,\n
      \        \"fragment\": true\n       },\n       \"ipv6\": {\n         \"length\":
      true,\n         \"protocol\": true,\n         \"destination-prefix\": true,\n
      \        \"source-prefix\": true,\n         \"fragment\": true\n       },\n
      \      \"tcp\": {\n         \"flags-bitmask\": true,\n         \"source-port\":
      true,\n         \"destination-port\": true,\n         \"port-range\": true\n
      \      },\n       \"udp\": {\n         \"length\": true,\n         \"source-port\":
      true,\n         \"destination-port\": true,\n         \"port-range\": true\n
      \      },\n       \"icmp\": {\n         \"type\": true,\n         \"code\":
      true\n       }\n     }\n   }\n       Figure 23: Reply to a GET Request with
      Filtering Capabilities\n"
    title: 7.1.  Retrieving DOTS Filtering Capabilities
  - contents:
    - "7.2.  Installing Filtering Rules\n   A POST or PUT request is used by a DOTS
      client to communicate\n   filtering rules to a DOTS server.\n   Figure 24 shows
      an example of a POST request to block traffic from\n   192.0.2.0/24 and destined
      to 198.51.100.0/24.  Other examples are\n   discussed in Appendix A.\n    POST
      /restconf/data/ietf-dots-data-channel:dots-data\\\n         /dots-client=dz6pHjaADkaFTbjr0JGBpw
      HTTP/1.1\n    Host: example.com\n    Content-Type: application/yang-data+json\n
      \   {\n     \"ietf-dots-data-channel:acls\": {\n       \"acl\": [\n         {\n
      \          \"name\": \"sample-ipv4-acl\",\n           \"type\": \"ipv4-acl-type\",\n
      \          \"activation-type\": \"activate-when-mitigating\",\n           \"aces\":
      {\n             \"ace\": [\n               {\n                 \"name\": \"rule1\",\n
      \                \"matches\": {\n                   \"ipv4\": {\n                     \"destination-ipv4-network\":
      \"198.51.100.0/24\",\n                     \"source-ipv4-network\": \"192.0.2.0/24\"\n
      \                  }\n                 },\n                 \"actions\": {\n
      \                  \"forwarding\": \"drop\"\n                 }\n               }\n
      \            ]\n           }\n         }\n       ]\n     }\n    }\n                 Figure
      24: POST to Install Filtering Rules\n   The meaning of these parameters is as
      follows:\n   name:  The name of the access list.\n      This is a mandatory
      attribute.\n   type:  Indicates the primary intended type of match criteria
      (e.g.,\n      IPv4, IPv6).  It is set to 'ipv4-acl-type' in the example of\n
      \     Figure 24.\n      This is an optional attribute.\n   activation-type:
      \ Indicates whether an ACL has to be activated\n      (immediately or during
      mitigation time) or instantiated without\n      being activated (deactivated).
      \ Deactivated ACLs can be activated\n      using a variety of means, such as
      manual configuration on a DOTS\n      server or by using the DOTS data channel.\n
      \     If this attribute is not provided, the DOTS server MUST use\n      'activate-when-mitigating'
      as the default value.\n      When a mitigation is in progress, the DOTS server
      MUST only\n      activate 'activate-when-mitigating' filters that are bound
      to the\n      DOTS client that triggered the mitigation.\n      This is an optional
      attribute.\n   matches:  Defines criteria used to identify a flow on which to
      apply\n      the rule.  It can be \"l3\" (IPv4, IPv6) or \"l4\" (TCP, UDP, ICMP).\n
      \     The detailed match parameters are specified in Section 4.\n      In the
      example depicted in Figure 24, an IPv4 matching criteria is\n      used.\n      This
      is an optional attribute.\n   destination-ipv4-network:  The destination IPv4
      prefix.  DOTS servers\n      MUST validate that these prefixes are within the
      scope of the DOTS\n      client domain.  Other validation checks may be supported
      by DOTS\n      servers.  If this attribute is not provided, the DOTS server\n
      \     enforces the ACL on any destination IP address that belongs to the\n      DOTS
      client domain.\n      This is a mandatory attribute in requests with an 'activation-\n
      \     type' set to 'immediate'.\n   source-ipv4-network:  The source IPv4 prefix.\n
      \     This is an optional attribute.\n   actions:  Actions in the forwarding
      ACL category can be 'drop' or\n      'accept'.  The 'accept' action is used
      to accept-list traffic.\n      The \"drop\" action is used to drop-list traffic.\n
      \     Accepted traffic may be subject to 'rate-limit'; the allowed\n      traffic
      rate is represented in bytes per second.  This unit is the\n      same as the
      one used for \"traffic-rate\" in [RFC5575].\n      This is a mandatory attribute.\n
      \  The DOTS server indicates the result of processing the POST request\n   using
      the status-line.  Concretely, a \"201 Created\" status-line MUST\n   be returned
      in the response if the DOTS server has accepted the\n   filtering rules.  If
      the request is missing a mandatory attribute or\n   contains an invalid or unknown
      parameter (e.g., a match field not\n   supported by the DOTS server), a \"400
      Bad Request\" status-line MUST\n   be returned by the DOTS server in the response.
      \ The error-tag is set\n   to \"missing-attribute\", \"invalid-value\", or \"unknown-element\"
      as a\n   function of the encountered error.\n   If the request is received via
      a server-domain DOTS gateway, but the\n   DOTS server does not maintain a 'cdid'
      for this 'cuid' while a 'cdid'\n   is expected to be supplied, the DOTS server
      MUST reply with a \"403\n   Forbidden\" status-line and the error-tag \"access-denied\".
      \ Upon\n   receipt of this message, the DOTS client MUST register (Figure 11).\n
      \  If the request is conflicting with an existing filtering installed by\n   another
      DOTS client of the domain, absent any local policy, the DOTS\n   server returns
      a \"409 Conflict\" status-line to the requesting DOTS\n   client.  The error-tag
      \"resource-denied\" is used in this case.\n   The \"insert\" query parameter
      (Section 4.8.5 of [RFC8040]) MAY be used\n   to specify how an access control
      entry is inserted within an ACL and\n   how an ACL is inserted within an ACL
      set.\n   The DOTS client uses the PUT request to modify its filtering rules\n
      \  maintained by the DOTS server.  In particular, a DOTS client MUST\n   update
      its filtering entries upon change of the destination prefix.\n   How such change
      is detected is out of scope.\n   A DOTS server MUST maintain a filtering rule
      for at least 10080\n   minutes (1 week).  If no refresh request is seen from
      the DOTS\n   client, the DOTS server removes expired entries.  Typically, a\n
      \  refresh request is a PUT request that echoes the content of a\n   response
      to a GET request with all of the read-only parameters\n   stripped out (e.g.,
      'pending-lifetime').\n"
    title: 7.2.  Installing Filtering Rules
  - contents:
    - "7.3.  Retrieving Installed Filtering Rules\n   A DOTS client periodically queries
      its DOTS server to check the\n   counters for installed filtering rules.  A
      GET request is used to\n   retrieve filtering rules from a DOTS server.  In
      order to indicate\n   which type of data is requested in a GET request, the
      DOTS client\n   sets adequately the \"content\" query parameter.\n   If the
      DOTS server does not find the access list name conveyed in the\n   GET request
      in its configuration data for this DOTS client, it\n   responds with a \"404
      Not Found\" status-line.\n   In order to illustrate the intended behavior, consider
      the example\n   depicted in Figure 25.  In reference to this example, the DOTS
      client\n   requests the creation of an immediate ACL called \"test-acl-ipv6-udp\".\n
      \  PUT /restconf/data/ietf-dots-data-channel:dots-data\\\n       /dots-client=paL8p4Zqo4SLv64TLPXrxA/acls\\\n
      \      /acl=test-acl-ipv6-udp HTTP/1.1\n   Host: example.com\n   Content-Type:
      application/yang-data+json\n   {\n     \"ietf-dots-data-channel:acls\": {\n
      \      \"acl\": [\n         {\n           \"name\": \"test-acl-ipv6-udp\",\n
      \          \"type\": \"ipv6-acl-type\",\n           \"activation-type\": \"immediate\",\n
      \          \"aces\": {\n             \"ace\": [\n               {\n                 \"name\":
      \"my-test-ace\",\n                 \"matches\": {\n                   \"ipv6\":
      {\n                     \"destination-ipv6-network\": \"2001:db8:6401::2/127\",\n
      \                    \"source-ipv6-network\": \"2001:db8:1234::/96\",\n                     \"protocol\":
      17,\n                     \"flow-label\": 10000\n                   },\n                   \"udp\":
      {\n                     \"source-port-range-or-operator\": {\n                       \"operator\":
      \"lte\",\n                       \"port\": 80\n                     },\n                     \"destination-port-range-or-operator\":
      {\n                       \"operator\": \"neq\",\n                       \"port\":
      1010\n                     }\n                   }\n                 },\n                 \"actions\":
      {\n                   \"forwarding\": \"accept\"\n                 }\n               }\n
      \            ]\n           }\n         }\n       ]\n     }\n   }\n         Figure
      25: Example of a PUT Request to Create a Filtering\n   The peer DOTS server
      follows the procedure specified in Section 7.2\n   to process the request.  We
      consider in the following that a positive\n   response is sent back to the requesting
      DOTS client to confirm that\n   the \"test-acl-ipv6-udp\" ACL is successfully
      installed by the DOTS\n   server.\n   The DOTS client can issue a GET request
      to retrieve all its filtering\n   rules and the number of matches for the installed
      filtering rules as\n   illustrated in Figure 26.  The \"content\" query parameter
      is set to\n   'all'.  The message body of the response to this GET request is
      shown\n   in Figure 27.\n     GET /restconf/data/ietf-dots-data-channel:dots-data\\\n
      \        /dots-client=dz6pHjaADkaFTbjr0JGBpw\\\n         /acls?content=all HTTP/1.1\n
      \    Host: example.com\n     Accept: application/yang-data+json\n     Figure
      26: Retrieve the Configuration Data and State Data for the\n                       Filtering
      Rules (GET Request)\n   {\n     \"ietf-dots-data-channel:acls\": {\n       \"acl\":
      [\n         {\n           \"name\": \"test-acl-ipv6-udp\",\n           \"type\":
      \"ipv6-acl-type\",\n           \"activation-type\": \"immediate\",\n           \"pending-lifetime\":9080,\n
      \          \"aces\": {\n             \"ace\": [\n               {\n                 \"name\":
      \"my-test-ace\",\n                 \"matches\": {\n                   \"ipv6\":
      {\n                     \"destination-ipv6-network\": \"2001:db8:6401::2/127\",\n
      \                    \"source-ipv6-network\": \"2001:db8:1234::/96\",\n                     \"protocol\":
      17,\n                     \"flow-label\": 10000\n                   },\n                   \"udp\":
      {\n                     \"source-port-range-or-operator\": {\n                       \"operator\":
      \"lte\",\n                       \"port\": 80\n                     },\n                     \"destination-port-range-or-operator\":
      {\n                       \"operator\": \"neq\",\n                       \"port\":
      1010\n                     }\n                   }\n                 },\n                 \"actions\":
      {\n                   \"forwarding\": \"accept\"\n                 }\n               }\n
      \            ]\n           }\n         }\n       ]\n     }\n   }\n     Figure
      27: Retrieve the Configuration Data and State Data for the\n                  Filtering
      Rules (Response Message Body)\n   Also, a DOTS client can issue a GET request
      to retrieve only\n   configuration data related to an ACL as shown in Figure
      28.  It does\n   so by setting the \"content\" query parameter to 'config'.\n
      \    GET /restconf/data/ietf-dots-data-channel:dots-data\\\n         /dots-client=paL8p4Zqo4SLv64TLPXrxA/acls\\\n
      \        /acl=test-acl-ipv6-udp?content=config HTTP/1.1\n     Host: example.com\n
      \    Accept: application/yang-data+json\n      Figure 28: Retrieve the Configuration
      Data for a Filtering Rule\n   A response to this GET request is shown in Figure
      29.\n   {\n     \"ietf-dots-data-channel:acls\": {\n       \"acl\": [\n         {\n
      \          \"name\": \"test-acl-ipv6-udp\",\n           \"type\": \"ipv6-acl-type\",\n
      \          \"activation-type\": \"immediate\",\n           \"aces\": {\n             \"ace\":
      [\n               {\n                 \"name\": \"my-test-ace\",\n                 \"matches\":
      {\n                   \"ipv6\": {\n                     \"destination-ipv6-network\":
      \"2001:db8:6401::2/127\",\n                     \"source-ipv6-network\": \"2001:db8:1234::/96\",\n
      \                    \"protocol\": 17,\n                     \"flow-label\":
      10000\n                   },\n                   \"udp\": {\n                     \"source-port-range-or-operator\":
      {\n                       \"operator\": \"lte\",\n                       \"port\":
      80\n                     },\n                     \"destination-port-range-or-operator\":
      {\n                       \"operator\": \"neq\",\n                       \"port\":
      1010\n                     }\n                   }\n                 },\n                 \"actions\":
      {\n                   \"forwarding\": \"accept\"\n                 }\n               }\n
      \            ]\n           }\n         }\n       ]\n     }\n   }\n      Figure
      29: Retrieve the Configuration Data for a Filtering Rule\n                          (Response
      Message Body)\n   A DOTS client can also issue a GET request with a \"content\"
      query\n   parameter set to 'non-config' to exclusively retrieve non-\n   configuration
      data bound to a given ACL as shown in Figure 30.  A\n   response to this GET
      request is shown in Figure 31.\n     GET /restconf/data/ietf-dots-data-channel:dots-data\\\n
      \        /dots-client=paL8p4Zqo4SLv64TLPXrxA/acls\\\n         /acl=test-acl-ipv6-udp?content=non-config
      HTTP/1.1\n     Host: example.com\n     Accept: application/yang-data+json\n
      \      Figure 30: Retrieve the Non-Configuration Data for a Filtering\n                             Rule
      (GET Request)\n   {\n     \"ietf-dots-data-channel:acls\":  {\n       \"acl\":
      [\n         {\n           \"name\": \"test-acl-ipv6-udp\",\n           \"pending-lifetime\":
      8000,\n           \"aces\": {\n             \"ace\": [\n               {\n                 \"name\":
      \"my-test-ace\"\n               }\n             ]\n           }\n         }\n
      \      ]\n     }\n   }\n       Figure 31: Retrieve the Non-Configuration Data
      for a Filtering\n                        Rule (Response Message Body)\n"
    title: 7.3.  Retrieving Installed Filtering Rules
  - contents:
    - "7.4.  Removing Filtering Rules\n   A DELETE request is used by a DOTS client
      to delete filtering rules\n   from a DOTS server.\n   If the DOTS server does
      not find the access list name carried in the\n   DELETE request in its configuration
      data for this DOTS client, it\n   MUST respond with a \"404 Not Found\" status-line.
      \ The DOTS server\n   successfully acknowledges a DOTS client's request to withdraw
      the\n   filtering rules using a \"204 No Content\" status-line, and removes
      the\n   filtering rules accordingly.\n   Figure 32 shows an example of a request
      to remove the IPv4 ACL\n   \"sample-ipv4-acl\" created in Section 7.2.\n     DELETE
      \ /restconf/data/ietf-dots-data-channel:dots-data\\\n             /dots-client=dz6pHjaADkaFTbjr0JGBpw/acls\\\n
      \            /acl=sample-ipv4-acl HTTP/1.1\n     Host: example.com\n            Figure
      32: Remove a Filtering Rule (DELETE Request)\n   Figure 33 shows an example
      of a response received from the DOTS\n   server to confirm the deletion of \"sample-ipv4-acl\".\n
      \   HTTP/1.1 204 No Content\n    Server: Apache\n    Date: Fri, 27 Jul 2018
      10:05:15 GMT\n    Cache-Control: no-cache\n    Content-Type: application/yang-data+json\n
      \   Content-Length: 0\n    Connection: Keep-Alive\n               Figure 33:
      Remove a Filtering Rule (Response)\n"
    title: 7.4.  Removing Filtering Rules
  title: 7.  Managing DOTS Filtering Rules
- contents:
  - "8.  Operational Considerations\n   The following operational considerations should
    be taken into\n   account:\n   *  DOTS servers MUST NOT enable both DOTS data
    channel and direct\n      configuration, to avoid race conditions and inconsistent\n
    \     configurations arising from simultaneous updates from multiple\n      sources.\n
    \  *  DOTS agents SHOULD enable the DOTS data channel to configure\n      aliases
    and ACLs, and only use direct configuration as a stop-gap\n      mechanism to
    test DOTS signal channel with aliases and ACLs.\n      Further, direct configuration
    SHOULD only be used when the on-path\n      DOTS agents are within the same domain.\n
    \  *  If a DOTS server has enabled direct configuration, it can reject\n      the
    DOTS data channel connection using hard ICMP error [RFC1122]\n      or RST (Reset)
    bit in the TCP header or reject the RESTCONF\n      request using an error response
    containing a \"503 Service\n      Unavailable\" status-line.\n"
  title: 8.  Operational Considerations
- contents:
  - "9.  IANA Considerations\n   IANA has registered the following URI in the \"ns\"
    subregistry within\n   the \"IETF XML Registry\" [RFC3688]:\n   ID:  yang:ietf-dots-data-channel\n
    \  URI:  urn:ietf:params:xml:ns:yang:ietf-dots-data-channel\n   Registrant Contact:
    \ The IESG.\n   XML:  N/A; the requested URI is an XML namespace.\n   Reference:
    \ RFC 8783\n   IANA has registered the following YANG module in the \"YANG Module\n
    \  Names\" subregistry [RFC7950] within the \"YANG Parameters\" registry.\n   Name:
    \ ietf-dots-data-channel\n   Namespace:  urn:ietf:params:xml:ns:yang:ietf-dots-data-channel\n
    \  Prefix:  data-channel\n   Reference:  RFC 8783\n   This module is not maintained
    by IANA.\n"
  title: 9.  IANA Considerations
- contents:
  - "10.  Security Considerations\n   RESTCONF security considerations are discussed
    in [RFC8040].  In\n   particular, DOTS agents MUST follow the security recommendations
    in\n   Sections 2 and 12 of [RFC8040].  Also, DOTS agents MUST support the\n   mutual
    authentication TLS profile discussed in Sections 7.1 and 8 of\n   [RFC8782].\n
    \  Authenticated encryption MUST be used for data confidentiality and\n   message
    integrity.  The interaction between the DOTS agents requires\n   Transport Layer
    Security (TLS) with a cipher suite offering\n   confidentiality protection, and
    the guidance given in [RFC7525] MUST\n   be followed to avoid attacks on TLS.\n
    \  The installation of drop-list or accept-list rules using RESTCONF\n   over
    TLS reveals the attacker IP addresses and legitimate IP\n   addresses only to
    the DOTS server trusted by the DOTS client.  The\n   secure communication channel
    between DOTS agents provides privacy and\n   prevents a network eavesdropper from
    directly gaining access to the\n   drop-listed and accept-listed IP addresses.\n
    \  An attacker may be able to inject RST packets, bogus application\n   segments,
    etc., regardless of whether TLS authentication is used.\n   Because the application
    data is TLS protected, this will not result\n   in the application receiving bogus
    data, but it will constitute a DoS\n   on the connection.  This attack can be
    countered by using TCP\n   Authentication Option (TCP-AO) [RFC5925].  If TCP-AO
    is used, then\n   any bogus packets injected by an attacker will be rejected by
    the\n   TCP-AO integrity check and therefore will never reach the TLS layer.\n
    \  In order to prevent leaking internal information outside a client\n   domain,
    client-side DOTS gateways SHOULD NOT reveal the identity of\n   internal DOTS
    clients (e.g., source IP address, client's hostname)\n   unless explicitly configured
    to do so.\n   DOTS servers MUST verify that requesting DOTS clients are entitled
    to\n   enforce filtering rules on a given IP prefix.  That is, only\n   filtering
    rules on IP resources that belong to the DOTS client domain\n   can be authorized
    by a DOTS server.  The exact mechanism for the DOTS\n   servers to validate that
    the target prefixes are within the scope of\n   the DOTS client domain is deployment
    specific.\n   Rate-limiting DOTS requests, including those with new 'cuid' values,\n
    \  from the same DOTS client defends against DoS attacks that would\n   result
    from varying the 'cuid' to exhaust DOTS server resources.\n   Rate-limit policies
    SHOULD be enforced on DOTS gateways (if deployed)\n   and DOTS servers.\n   Applying
    resources quota per DOTS client and/or per DOTS client\n   domain (e.g., limiting
    the number of aliases and filters to be\n   installed by DOTS clients) prevents
    DOTS server resources from being\n   aggressively used by some DOTS clients and
    therefore ensures DDoS\n   mitigation usage fairness.  Additionally, DOTS servers
    may limit the\n   number of DOTS clients that can be enabled per domain.\n   When
    FQDNs are used as targets, the DOTS server MUST rely upon DNS\n   privacy enabling
    protocols (e.g., DNS over TLS [RFC7858] or DNS over\n   HTTPS (DoH) [RFC8484])
    to prevent eavesdroppers from possibly\n   identifying the target resources protected
    by the DDoS mitigation\n   service, and means to ensure the target FQDN resolution
    is authentic\n   (e.g., DNSSEC [RFC4034]).\n   The presence of DOTS gateways may
    lead to infinite forwarding loops,\n   which is undesirable.  To prevent and detect
    such loops, a mechanism\n   is defined in Section 3.4.\n   The YANG module specified
    in this document defines a schema for data\n   that is designed to be accessed
    via network management protocols such\n   as NETCONF [RFC6241] or RESTCONF [RFC8040].
    \ The lowest NETCONF layer\n   is the secure transport layer, and the mandatory-to-implement
    secure\n   transport is Secure Shell (SSH) [RFC6242].  The lowest RESTCONF layer\n
    \  is HTTPS, and the mandatory-to-implement secure transport is TLS\n   [RFC8446].\n
    \  The Network Configuration Access Control Model (NACM) [RFC8341]\n   provides
    the means to restrict access for particular NETCONF or\n   RESTCONF users to a
    preconfigured subset of all available NETCONF or\n   RESTCONF protocol operations
    and content.\n   There are a number of data nodes defined in this YANG module
    that are\n   writable/creatable/deletable (i.e., config true, which is the\n   default).
    \ These data nodes may be considered sensitive or vulnerable\n   in some network
    environments.  Write operations (e.g., edit-config)\n   to these data nodes without
    proper protection can have a negative\n   effect on network operations.  The DOTS
    data channel is responsible\n   for exchanging configuration data that affect
    traffic filtering\n   during DDoS attack mitigation, in particular.  Appropriate
    security\n   measures are recommended to prevent illegitimate users from invoking\n
    \  DOTS data channel primitives on writable data nodes.  Nevertheless,\n   an
    attacker who can access a DOTS client is technically capable of\n   launching
    various attacks, such as:\n   *  Setting an arbitrarily low rate-limit, which
    may prevent\n      legitimate traffic from being forwarded (rate-limit).\n   *
    \ Setting an arbitrarily high rate-limit, which may lead to the\n      forwarding
    of illegitimate DDoS traffic (rate-limit).\n   *  Communicating invalid aliases
    to the server (alias), which will\n      cause the failure of associating both
    data and signal channels.\n   *  Setting invalid ACL entries, which may prevent
    legitimate traffic\n      from being forwarded.  Likewise, invalid ACL entries
    may lead to\n      forward DDoS traffic.\n   This module reuses YANG structures
    from [RFC8519], and the security\n   considerations for those nodes continue to
    apply for this usage.\n"
  title: 10.  Security Considerations
- contents:
  - '11.  References

    '
  - contents:
    - "11.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n
      \             DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n
      \  [RFC3688]  Mealling, M., \"The IETF XML Registry\", BCP 81, RFC 3688,\n              DOI
      10.17487/RFC3688, January 2004,\n              <https://www.rfc-editor.org/info/rfc3688>.\n
      \  [RFC4632]  Fuller, V. and T. Li, \"Classless Inter-domain Routing\n              (CIDR):
      The Internet Address Assignment and Aggregation\n              Plan\", BCP 122,
      RFC 4632, DOI 10.17487/RFC4632, August\n              2006, <https://www.rfc-editor.org/info/rfc4632>.\n
      \  [RFC6125]  Saint-Andre, P. and J. Hodges, \"Representation and\n              Verification
      of Domain-Based Application Service Identity\n              within Internet
      Public Key Infrastructure Using X.509\n              (PKIX) Certificates in
      the Context of Transport Layer\n              Security (TLS)\", RFC 6125, DOI
      10.17487/RFC6125, March\n              2011, <https://www.rfc-editor.org/info/rfc6125>.\n
      \  [RFC6241]  Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed.,\n              and
      A. Bierman, Ed., \"Network Configuration Protocol\n              (NETCONF)\",
      RFC 6241, DOI 10.17487/RFC6241, June 2011,\n              <https://www.rfc-editor.org/info/rfc6241>.\n
      \  [RFC6242]  Wasserman, M., \"Using the NETCONF Protocol over Secure\n              Shell
      (SSH)\", RFC 6242, DOI 10.17487/RFC6242, June 2011,\n              <https://www.rfc-editor.org/info/rfc6242>.\n
      \  [RFC6991]  Schoenwaelder, J., Ed., \"Common YANG Data Types\",\n              RFC
      6991, DOI 10.17487/RFC6991, July 2013,\n              <https://www.rfc-editor.org/info/rfc6991>.\n
      \  [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n
      \             Protocol (HTTP/1.1): Message Syntax and Routing\",\n              RFC
      7230, DOI 10.17487/RFC7230, June 2014,\n              <https://www.rfc-editor.org/info/rfc7230>.\n
      \  [RFC7525]  Sheffer, Y., Holz, R., and P. Saint-Andre,\n              \"Recommendations
      for Secure Use of Transport Layer\n              Security (TLS) and Datagram
      Transport Layer Security\n              (DTLS)\", BCP 195, RFC 7525, DOI 10.17487/RFC7525,
      May\n              2015, <https://www.rfc-editor.org/info/rfc7525>.\n   [RFC7950]
      \ Bjorklund, M., Ed., \"The YANG 1.1 Data Modeling Language\",\n              RFC
      7950, DOI 10.17487/RFC7950, August 2016,\n              <https://www.rfc-editor.org/info/rfc7950>.\n
      \  [RFC7951]  Lhotka, L., \"JSON Encoding of Data Modeled with YANG\",\n              RFC
      7951, DOI 10.17487/RFC7951, August 2016,\n              <https://www.rfc-editor.org/info/rfc7951>.\n
      \  [RFC8040]  Bierman, A., Bjorklund, M., and K. Watsen, \"RESTCONF\n              Protocol\",
      RFC 8040, DOI 10.17487/RFC8040, January 2017,\n              <https://www.rfc-editor.org/info/rfc8040>.\n
      \  [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119
      Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,
      <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8259]  Bray, T., Ed., \"The
      JavaScript Object Notation (JSON) Data\n              Interchange Format\",
      STD 90, RFC 8259,\n              DOI 10.17487/RFC8259, December 2017,\n              <https://www.rfc-editor.org/info/rfc8259>.\n
      \  [RFC8341]  Bierman, A. and M. Bjorklund, \"Network Configuration\n              Access
      Control Model\", STD 91, RFC 8341,\n              DOI 10.17487/RFC8341, March
      2018,\n              <https://www.rfc-editor.org/info/rfc8341>.\n   [RFC8446]
      \ Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n              Version
      1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018,\n              <https://www.rfc-editor.org/info/rfc8446>.\n
      \  [RFC8519]  Jethanandani, M., Agarwal, S., Huang, L., and D. Blair,\n              \"YANG
      Data Model for Network Access Control Lists (ACLs)\",\n              RFC 8519,
      DOI 10.17487/RFC8519, March 2019,\n              <https://www.rfc-editor.org/info/rfc8519>.\n
      \  [RFC8782]  Reddy.K, T., Ed., Boucadair, M., Ed., Patil, P.,\n              Mortensen,
      A., and N. Teague, \"Distributed Denial-of-\n              Service Open Threat
      Signaling (DOTS) Signal Channel\n              Specification\", RFC 8782, DOI
      10.17487/RFC8782, May 2020,\n              <https://www.rfc-editor.org/info/rfc8782>.\n"
    title: 11.1.  Normative References
  - contents:
    - "11.2.  Informative References\n   [DOTS-ARCH]\n              Mortensen, A.,
      Reddy.K, T., Andreasen, F., Teague, N., and\n              R. Compton, \"Distributed-Denial-of-Service
      Open Threat\n              Signaling (DOTS) Architecture\", Work in Progress,\n
      \             Internet-Draft, draft-ietf-dots-architecture-18, 6 March\n              2020,
      <https://tools.ietf.org/html/draft-ietf-dots-\n              architecture-18>.\n
      \  [DOTS-SERVER-DISC]\n              Boucadair, M. and T. Reddy.K, \"Distributed-Denial-of-\n
      \             Service Open Threat Signaling (DOTS) Agent Discovery\",\n              Work
      in Progress, Internet-Draft, draft-ietf-dots-server-\n              discovery-10,
      7 February 2020,\n              <https://tools.ietf.org/html/draft-ietf-dots-server-\n
      \             discovery-10>.\n   [IANA-PROTO]\n              IANA, \"Protocol
      Numbers\",\n              <http://www.iana.org/assignments/protocol-numbers>.\n
      \  [RESTCONF-MODELS]\n              Watsen, K., \"RESTCONF Client and Server
      Models\", Work in\n              Progress, Internet-Draft, draft-ietf-netconf-restconf-\n
      \             client-server-19, 20 May 2020,\n              <https://tools.ietf.org/html/draft-ietf-netconf-restconf-\n
      \             client-server-19>.\n   [RFC1122]  Braden, R., Ed., \"Requirements
      for Internet Hosts -\n              Communication Layers\", STD 3, RFC 1122,\n
      \             DOI 10.17487/RFC1122, October 1989,\n              <https://www.rfc-editor.org/info/rfc1122>.\n
      \  [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n              Resource
      Identifier (URI): Generic Syntax\", STD 66,\n              RFC 3986, DOI 10.17487/RFC3986,
      January 2005,\n              <https://www.rfc-editor.org/info/rfc3986>.\n   [RFC4034]
      \ Arends, R., Austein, R., Larson, M., Massey, D., and S.\n              Rose,
      \"Resource Records for the DNS Security Extensions\",\n              RFC 4034,
      DOI 10.17487/RFC4034, March 2005,\n              <https://www.rfc-editor.org/info/rfc4034>.\n
      \  [RFC4340]  Kohler, E., Handley, M., and S. Floyd, \"Datagram\n              Congestion
      Control Protocol (DCCP)\", RFC 4340,\n              DOI 10.17487/RFC4340, March
      2006,\n              <https://www.rfc-editor.org/info/rfc4340>.\n   [RFC4960]
      \ Stewart, R., Ed., \"Stream Control Transmission Protocol\",\n              RFC
      4960, DOI 10.17487/RFC4960, September 2007,\n              <https://www.rfc-editor.org/info/rfc4960>.\n
      \  [RFC5575]  Marques, P., Sheth, N., Raszuk, R., Greene, B., Mauch, J.,\n              and
      D. McPherson, \"Dissemination of Flow Specification\n              Rules\",
      RFC 5575, DOI 10.17487/RFC5575, August 2009,\n              <https://www.rfc-editor.org/info/rfc5575>.\n
      \  [RFC5925]  Touch, J., Mankin, A., and R. Bonica, \"The TCP\n              Authentication
      Option\", RFC 5925, DOI 10.17487/RFC5925,\n              June 2010, <https://www.rfc-editor.org/info/rfc5925>.\n
      \  [RFC6520]  Seggelmann, R., Tuexen, M., and M. Williams, \"Transport\n              Layer
      Security (TLS) and Datagram Transport Layer Security\n              (DTLS) Heartbeat
      Extension\", RFC 6520,\n              DOI 10.17487/RFC6520, February 2012,\n
      \             <https://www.rfc-editor.org/info/rfc6520>.\n   [RFC7858]  Hu,
      Z., Zhu, L., Heidemann, J., Mankin, A., Wessels, D.,\n              and P. Hoffman,
      \"Specification for DNS over Transport\n              Layer Security (TLS)\",
      RFC 7858, DOI 10.17487/RFC7858, May\n              2016, <https://www.rfc-editor.org/info/rfc7858>.\n
      \  [RFC8340]  Bjorklund, M. and L. Berger, Ed., \"YANG Tree Diagrams\",\n              BCP
      215, RFC 8340, DOI 10.17487/RFC8340, March 2018,\n              <https://www.rfc-editor.org/info/rfc8340>.\n
      \  [RFC8484]  Hoffman, P. and P. McManus, \"DNS Queries over HTTPS\n              (DoH)\",
      RFC 8484, DOI 10.17487/RFC8484, October 2018,\n              <https://www.rfc-editor.org/info/rfc8484>.\n
      \  [RFC8499]  Hoffman, P., Sullivan, A., and K. Fujiwara, \"DNS\n              Terminology\",
      BCP 219, RFC 8499, DOI 10.17487/RFC8499,\n              January 2019, <https://www.rfc-editor.org/info/rfc8499>.\n
      \  [RFC8612]  Mortensen, A., Reddy, T., and R. Moskowitz, \"DDoS Open\n              Threat
      Signaling (DOTS) Requirements\", RFC 8612,\n              DOI 10.17487/RFC8612,
      May 2019,\n              <https://www.rfc-editor.org/info/rfc8612>.\n"
    title: 11.2.  Informative References
  title: 11.  References
- contents:
  - "Appendix A.  Examples: Filtering Fragments\n   This specification strongly recommends
    the use of 'fragment' for\n   handling fragments.\n   Figure 34 shows the content
    of the POST request to be issued by a\n   DOTS client to its DOTS server to allow
    the traffic destined to\n   198.51.100.0/24 and UDP port number 53, but to drop
    all fragmented\n   packets.  The following ACEs are defined (in this order):\n
    \  *  \"drop-all-fragments\" ACE: discards all fragments.\n   *  \"allow-dns-packets\"
    ACE: accepts DNS packets destined to\n      198.51.100.0/24.\n   POST /restconf/data/ietf-dots-data-channel:dots-data\\\n
    \       /dots-client=dz6pHjaADkaFTbjr0JGBpw HTTP/1.1\n   Host: example.com\n   Content-Type:
    application/yang-data+json\n   {\n     \"ietf-dots-data-channel:acls\": {\n       \"acl\":
    [\n         {\n           \"name\": \"dns-fragments\",\n           \"type\": \"ipv4-acl-type\",\n
    \          \"aces\": {\n             \"ace\": [\n               {\n                 \"name\":
    \"drop-all-fragments\",\n                 \"matches\": {\n                   \"ipv4\":
    {\n                     \"fragment\": {\n                       \"operator\":
    \"match\",\n                       \"type\": \"isf\"\n                     }\n
    \                  }\n                 },\n                 \"actions\": {\n                   \"forwarding\":
    \"drop\"\n                 }\n               },\n               {\n                 \"name\":
    \"allow-dns-packets\",\n                 \"matches\": {\n                   \"ipv4\":
    {\n                     \"destination-ipv4-network\": \"198.51.100.0/24\"\n                   },\n
    \                  \"udp\": {\n                     \"destination-port-range-or-operator\":
    {\n                       \"operator\": \"eq\",\n                       \"port\":
    53\n                     }\n                   },\n                   \"actions\":
    {\n                     \"forwarding\": \"accept\"\n                   }\n                 }\n
    \              }\n             ]\n           }\n         }\n       ]\n     }\n
    \  }\n                Figure 34: Filtering IPv4 Fragmented Packets\n   Figure
    35 shows an example of a POST request issued by a DOTS client\n   to its DOTS
    server to allow the traffic destined to 2001:db8::/32 and\n   UDP port number
    53, but to drop all fragmented packets.  The\n   following ACEs are defined (in
    this order):\n   *  \"drop-all-fragments\" ACE: discards all fragments (including
    atomic\n      fragments).  That is, IPv6 packets that include a Fragment header\n
    \     (44) are dropped.\n   *  \"allow-dns-packets\" ACE: accepts DNS packets
    destined to\n      2001:db8::/32.\n   POST /restconf/data/ietf-dots-data-channel:dots-data\\\n
    \       /dots-client=dz6pHjaADkaFTbjr0JGBpw HTTP/1.1\n   Host: example.com\n   Content-Type:
    application/yang-data+json\n   {\n     \"ietf-dots-data-channel:acls\": {\n       \"acl\":
    [\n         {\n           \"name\": \"dns-fragments\",\n           \"type\": \"ipv6-acl-type\",\n
    \          \"aces\": {\n             \"ace\": [\n               {\n                 \"name\":
    \"drop-all-fragments\",\n                 \"matches\": {\n                   \"ipv6\":
    {\n                     \"fragment\": {\n                       \"operator\":
    \"match\",\n                       \"type\": \"isf\"\n                     }\n
    \                  }\n                 },\n                 \"actions\": {\n                   \"forwarding\":
    \"drop\"\n                 }\n               },\n               {\n                 \"name\":
    \"allow-dns-packets\",\n                 \"matches\": {\n                   \"ipv6\":
    {\n                     \"destination-ipv6-network\": \"2001:db8::/32\"\n                   },\n
    \                  \"udp\": {\n                     \"destination-port-range-or-operator\":
    {\n                       \"operator\": \"eq\",\n                       \"port\":
    53\n                     }\n                   }\n                 },\n                 \"actions\":
    {\n                   \"forwarding\": \"accept\"\n                 }\n               }\n
    \            ]\n           }\n         }\n       ]\n     }\n   }\n                Figure
    35: Filtering IPv6 Fragmented Packets\n"
  title: 'Appendix A.  Examples: Filtering Fragments'
- contents:
  - "Appendix B.  Examples: Filtering TCP Messages\n   This section provides examples
    to illustrate TCP-specific filtering\n   based on the flag bits.  These examples
    should not be interpreted as\n   recommended filtering behaviors under specific
    DDoS attacks.\n"
  - contents:
    - "B.1.  Discard TCP Null Attack\n   Figure 36 shows an example of a DOTS request
      sent by a DOTS client to\n   install immediately a filter to discard incoming
      TCP messages having\n   all flags unset.  The bitmask can be set to 255 to check
      against the\n   (CWR, ECE, URG, ACK, PSH, RST, SYN, FIN) flags.\n   PUT /restconf/data/ietf-dots-data-channel:dots-data\\\n
      \      /dots-client=paL8p4Zqo4SLv64TLPXrxA/acls\\\n       /acl=tcp-flags-example
      HTTP/1.1\n   Host: example.com\n   Content-Type: application/yang-data+json\n
      \  {\n     \"ietf-dots-data-channel:acls\": {\n       \"acl\": [{\n         \"name\":
      \"tcp-flags-example\",\n         \"activation-type\": \"immediate\",\n         \"aces\":
      {\n           \"ace\": [{\n             \"name\": \"null-attack\",\n             \"matches\":
      {\n               \"tcp\": {\n                 \"flags-bitmask\": {\n                   \"operator\":
      \"not any\",\n                   \"bitmask\": 4095\n                 }\n               }\n
      \            },\n             \"actions\": {\n               \"forwarding\":
      \"drop\"\n             }\n           }]\n         }\n       }]\n     }\n   }\n
      \  Figure 36: Example of a DOTS Request to Deny TCP Null Attack Messages\n"
    title: B.1.  Discard TCP Null Attack
  - contents:
    - "B.2.  Rate-Limit SYN Flooding\n   Figure 37 shows an ACL example to rate-limit
      incoming SYNs during a\n   SYN flood attack.\n   PUT /restconf/data/ietf-dots-data-channel:dots-data\\\n
      \      /dots-client=paL8p4Zqo4SLv64TLPXrxA/acls\\\n       /acl=tcp-flags-example
      HTTP/1.1\n   Host: example.com\n   Content-Type: application/yang-data+json\n
      \  {\n     \"ietf-dots-data-channel:acls\": {\n       \"acl\": [{\n         \"name\":
      \"tcp-flags-example\",\n         \"activation-type\": \"activate-when-mitigating\",\n
      \        \"aces\": {\n           \"ace\": [{\n             \"name\": \"rate-limit-syn\",\n
      \            \"matches\": {\n               \"tcp\": {\n                 \"flags-bitmask\":
      {\n                   \"operator\": \"match\",\n                   \"bitmask\":
      2\n                 }\n               }\n             },\n             \"actions\":
      {\n               \"forwarding\": \"accept\",\n               \"rate-limit\":
      \"20.00\"\n             }\n           }]\n         }\n       }]\n     }\n   }\n
      \    Figure 37: Example of DOTS Request to Rate-Limit Incoming TCP SYNs\n"
    title: B.2.  Rate-Limit SYN Flooding
  - contents:
    - "B.3.  Rate-Limit ACK Flooding\n   Figure 38 shows an ACL example to rate-limit
      incoming ACKs during an\n   ACK flood attack.\n   PUT /restconf/data/ietf-dots-data-channel:dots-data\\\n
      \      /dots-client=paL8p4Zqo4SLv64TLPXrxA/acls\\\n       /acl=tcp-flags-example
      HTTP/1.1\n   Host: example.com\n   Content-Type: application/yang-data+json\n
      \  {\n     \"ietf-dots-data-channel:acls\": {\n       \"acl\": [{\n         \"name\":
      \"tcp-flags-example\",\n         \"type\": \"ipv4-acl-type\",\n         \"activation-type\":
      \"activate-when-mitigating\",\n         \"aces\": {\n           \"ace\": [{\n
      \            \"name\": \"rate-limit-ack\",\n             \"matches\": {\n               \"tcp\":
      {\n                 \"flags-bitmask\": {\n                   \"operator\": \"match\",\n
      \                  \"bitmask\": 16\n                 }\n               }\n             },\n
      \            \"actions\": {\n               \"forwarding\": \"accept\",\n               \"rate-limit\":
      \"20.00\"\n             }\n           }]\n         }\n       }]\n     }\n   }\n
      \    Figure 38: Example of DOTS Request to Rate-Limit Incoming TCP ACKs\n"
    title: B.3.  Rate-Limit ACK Flooding
  title: 'Appendix B.  Examples: Filtering TCP Messages'
- contents:
  - "Acknowledgements\n   Thanks to Christian Jacquenet, Roland Dobbins, Roman Danyliw,
    Ehud\n   Doron, Russ White, Gilbert Clark, Kathleen Moriarty, Nesredien\n   Suleiman,
    Roni Even, and Brian Trammel for the discussion and\n   comments.\n   The authors
    would like to give special thanks to Kaname Nishizuka and\n   Jon Shallow for
    their efforts in implementing the protocol and\n   performing interop testing
    at IETF Hackathons.\n   Many thanks to Benjamin Kaduk for the detailed AD review.\n
    \  Thanks to Martin Bj\xF6rklund for the guidance on RESTCONF.\n   Thanks to Alexey
    Melnikov, Adam Roach, Suresh Krishnan, Mirja\n   K\xFChlewind, and Warren Kumari
    for the review.\n"
  title: Acknowledgements
- contents:
  - "Contributors\n   The following people contributed substantially to the content
    of this\n   document and should be considered coauthors:\n   Kaname Nishizuka\n
    \  NTT Communications\n   GranPark 16F 3-4-1 Shibaura, Minato-ku, Tokyo\n   108-8118\n
    \  Japan\n   Email: kaname@nttv6.jp\n   Liang Xia\n   Huawei\n   101 Software
    Avenue, Yuhuatai District\n   Nanjing\n   Jiangsu, 210012\n   China\n   Email:
    frank.xialiang@huawei.com\n   Prashanth Patil\n   Cisco Systems, Inc.\n   Email:
    praspati@cisco.com\n   Andrew Mortensen\n   Arbor Networks, Inc.\n   2727 S. State
    Street\n   Ann Arbor, Michigan 48104\n   United States of America\n   Email: andrew@moretension.com\n
    \  Nik Teague\n   Iron Mountain Data Centers\n   United Kingdom\n   Email: nteague@ironmountain.co.uk\n
    \  The following individuals have contributed to this document:\n   Dan Wing\n
    \  Email: dwing-ietf@fuggles.com\n   Jon Shallow\n   NCC Group\n   Email: jon.shallow@nccgroup.com\n"
  title: Contributors
- contents:
  - "Authors' Addresses\n   Mohamed Boucadair (editor)\n   Orange\n   35000 Rennes\n
    \  France\n   Email: mohamed.boucadair@orange.com\n   Tirumaleswar Reddy.K (editor)\n
    \  McAfee, Inc.\n   Embassy Golf Link Business Park\n   Bangalore 560071\n   Karnataka\n"
  title: Authors' Addresses
