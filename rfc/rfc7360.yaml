- title: __initial_text__
  contents:
  - "                Datagram Transport Layer Security (DTLS)\n                  \
    \  as a Transport Layer for RADIUS\n"
- title: Abstract
  contents:
  - "Abstract\n   The RADIUS protocol defined in RFC 2865 has limited support for\n\
    \   authentication and encryption of RADIUS packets.  The protocol\n   transports\
    \ data in the clear, although some parts of the packets can\n   have obfuscated\
    \ content.  Packets may be replayed verbatim by an\n   attacker, and client-server\
    \ authentication is based on fixed shared\n   secrets.  This document specifies\
    \ how the Datagram Transport Layer\n   Security (DTLS) protocol may be used as\
    \ a fix for these problems.  It\n   also describes how implementations of this\
    \ proposal can coexist with\n   current RADIUS systems.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Engineering\n   Task Force (IETF).\
    \  It represents the consensus of the IETF\n   community.  It has received public\
    \ review and has been approved for\n   publication by the Internet Engineering\
    \ Steering Group (IESG).  Not\n   all documents approved by the IESG are a candidate\
    \ for any level of\n   Internet Standard; see Section 2 of RFC 5741.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7360.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \      1.1. Terminology ................................................5\n  \
    \    1.2. Requirements Language ......................................5\n    \
    \  1.3. Document Status ............................................5\n   2. Building\
    \ on Existing Foundations ................................6\n      2.1. Changes\
    \ to RADIUS ..........................................7\n      2.2. Similarities\
    \ with RADIUS/TLS ...............................8\n           2.2.1. Changes\
    \ from RADIUS/TLS to RADIUS/DTLS ..............8\n   3. Interaction with RADIUS/UDP\
    \ .....................................9\n      3.1. DTLS Port and Packet Types\
    \ ................................10\n      3.2. Server Behavior ...........................................10\n\
    \   4. Client Behavior ................................................11\n  \
    \ 5. Session Management .............................................12\n    \
    \  5.1. Server Session Management .................................12\n      \
    \     5.1.1. Session Opening and Closing ........................13\n      5.2.\
    \ Client Session Management .................................15\n   6. Implementation\
    \ Guidelines ......................................16\n      6.1. Client Implementations\
    \ ....................................17\n      6.2. Server Implementations ....................................18\n\
    \   7. Diameter Considerations ........................................18\n  \
    \ 8. IANA Considerations ............................................18\n   9.\
    \ Implementation Status ..........................................18\n      9.1.\
    \ Radsecproxy ...............................................19\n      9.2. jradius\
    \ ...................................................19\n   10. Security Considerations\
    \ .......................................19\n      10.1. Crypto-Agility ...........................................20\n\
    \      10.2. Legacy RADIUS Security ...................................21\n  \
    \    10.3. Resource Exhaustion ......................................22\n    \
    \  10.4. Client-Server Authentication with DTLS ...................22\n      10.5.\
    \ Network Address Translation ..............................24\n      10.6. Wildcard\
    \ Clients .........................................24\n      10.7. Session Closing\
    \ ..........................................25\n      10.8. Client Subsystems\
    \ ........................................25\n   11. References ....................................................26\n\
    \      11.1. Normative References .....................................26\n  \
    \    11.2. Informative References ...................................27\n   Acknowledgments\
    \ ...................................................27\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The RADIUS protocol as described in [RFC2865], [RFC2866],\
    \ [RFC5176],\n   and others has traditionally used methods based on MD5 [RFC1321]\
    \ for\n   per-packet authentication and integrity checks.  However, the MD5\n\
    \   algorithm has known weaknesses such as [MD5Attack] and [MD5Break].\n   As\
    \ a result, some specifications, such as [RFC5176], have recommended\n   using\
    \ IPsec to secure RADIUS traffic.\n   While RADIUS over IPsec has been widely\
    \ deployed, there are\n   difficulties with this approach.  The simplest point\
    \ against IPsec is\n   that there is no straightforward way for an application\
    \ to control or\n   monitor the network security policies.  That is, the requirement\
    \ that\n   the RADIUS traffic be encrypted and/or authenticated is implicit in\n\
    \   the network configuration, and it cannot be enforced by the RADIUS\n   application.\n\
    \   This specification takes a different approach.  We define a method\n   for\
    \ using DTLS [RFC6347] as a RADIUS transport protocol.  This\n   approach has\
    \ the benefit that the RADIUS application can directly\n   monitor and control\
    \ the security policies associated with the traffic\n   that it processes.\n \
    \  Another benefit is that RADIUS over DTLS continues to be a UDP-based\n   protocol.\
    \  The change from RADIUS/UDP is largely to add DTLS support,\n   and make any\
    \ necessary related changes to RADIUS.  This allows\n   implementations to remain\
    \ UDP based, without changing to a TCP\n   architecture.\n   This specification\
    \ does not, however, solve all of the problems\n   associated with RADIUS/UDP.\
    \  The DTLS protocol does not add reliable\n   or in-order transport to RADIUS.\
    \  DTLS also does not support\n   fragmentation of application-layer messages,\
    \ or of the DTLS messages\n   themselves.  This specification therefore shares\
    \ with traditional\n   RADIUS the issues of order, reliability, and fragmentation.\
    \  These\n   issues are dealt with in RADIUS/TCP [RFC6613] and RADIUS/TLS\n  \
    \ [RFC6614].\n"
- title: 1.1.  Terminology
  contents:
  - "1.1.  Terminology\n   This document uses the following terms:\n   RADIUS/DTLS\n\
    \      This term is a shorthand for \"RADIUS over DTLS\".\n   RADIUS/DTLS client\n\
    \      This term refers both to RADIUS clients as defined in [RFC2865]\n     \
    \ and to Dynamic Authorization clients as defined in [RFC5176] that\n      implement\
    \ RADIUS/DTLS.\n   RADIUS/DTLS server\n      This term refers both to RADIUS servers\
    \ as defined in [RFC2865]\n      and to Dynamic Authorization servers as defined\
    \ in [RFC5176] that\n      implement RADIUS/DTLS.\n   RADIUS/UDP\n      RADIUS\
    \ over UDP, as defined in [RFC2865].\n   RADIUS/TLS\n      RADIUS over TLS, as\
    \ defined in [RFC6614].\n   silently discard\n      This means that the implementation\
    \ discards the packet without\n      further processing.\n"
- title: 1.2.  Requirements Language
  contents:
  - "1.2.  Requirements Language\n   In this document, several words are used to signify\
    \ the requirements\n   of the specification.  The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\",\n   \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"NOT\n   RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be\n\
    \   interpreted as described in [RFC2119].\n"
- title: 1.3.  Document Status
  contents:
  - "1.3.  Document Status\n   This document is an Experimental RFC.\n   It contains\
    \ one of several approaches to address known cryptographic\n   weaknesses of the\
    \ RADIUS protocol, such as described in [RFC6614].\n   This specification does\
    \ not fulfill all recommendations for an\n   Authentication, Authorization, and\
    \ Accounting (AAA) transport profile\n   as per [RFC3539]; however, unlike [RFC6614],\
    \ it is based on UDP and\n   therefore does not have head-of-line blocking issues.\n\
    \   If this specification is indeed selected for advancement to Standards\n  \
    \ Track, certificate verification options ([RFC6614], Section 2.3,\n   point 2)\
    \ will need to be refined.\n   Another experimental characteristic of this specification\
    \ is the\n   question of key management between RADIUS/DTLS peers.  RADIUS/UDP\n\
    \   only allowed for manual key management, i.e., distribution of a\n   shared\
    \ secret between a client and a server.  RADIUS/DTLS allows\n   manual distribution\
    \ of long-term proofs of peer identity, by using\n   TLS-PSK ciphersuites.  RADIUS/DTLS\
    \ also allows the use of X.509\n   certificates in a PKIX infrastructure.  It\
    \ remains to be seen if one\n   of these methods will prevail or if both will\
    \ find their place in\n   real-life deployments.  The authors can imagine pre-shared\
    \ keys\n   (PSKs) to be popular in small-scale deployments (Small Office, Home\n\
    \   Office (SOHO) or isolated enterprise deployments) where scalability\n   is\
    \ not an issue and the deployment of a Certification Authority (CA)\n   is considered\
    \ too much of a hassle; however, the authors can also\n   imagine large roaming\
    \ consortia to make use of PKIX.  Readers of this\n   specification are encouraged\
    \ to read the discussion of key management\n   issues within [RFC6421] as well\
    \ as [RFC4107].\n   It has yet to be decided whether this approach is to be chosen\
    \ for\n   Standards Track.  One key aspect to judge whether the approach is\n\
    \   usable on a large scale is by observing the uptake, usability, and\n   operational\
    \ behavior of the protocol in large-scale, real-life\n   deployments.\n"
- title: 2.  Building on Existing Foundations
  contents:
  - "2.  Building on Existing Foundations\n   Adding DTLS as a RADIUS transport protocol\
    \ requires a number of\n   changes to systems implementing standard RADIUS.  This\
    \ section\n   outlines those changes, and defines new behaviors necessary to\n\
    \   implement DTLS.\n"
- title: 2.1.  Changes to RADIUS
  contents:
  - "2.1.  Changes to RADIUS\n   The RADIUS packet format is unchanged from [RFC2865],\
    \ [RFC2866], and\n   [RFC5176].  Specifically, all of the following portions of\
    \ RADIUS\n   MUST be unchanged when using RADIUS/DTLS:\n      * Packet format\n\
    \      * Permitted codes\n      * Request Authenticator calculation\n      * Response\
    \ Authenticator calculation\n      * Minimum packet length\n      * Maximum packet\
    \ length\n      * Attribute format\n      * Vendor-Specific Attribute (VSA) format\n\
    \      * Permitted data types\n      * Calculations of dynamic attributes such\
    \ as CHAP-Challenge, or\n        Message-Authenticator.\n      * Calculation of\
    \ \"obfuscated\" attributes such as User-Password and\n        Tunnel-Password.\n\
    \   In short, the application creates a RADIUS packet via the usual\n   methods,\
    \ and then instead of sending it over a UDP socket, sends the\n   packet to a\
    \ DTLS layer for encapsulation.  DTLS then acts as a\n   transport layer for RADIUS:\
    \ hence, the names \"RADIUS/UDP\" and\n   \"RADIUS/DTLS\".\n   The requirement\
    \ that RADIUS remain largely unchanged ensures the\n   simplest possible implementation\
    \ and widest interoperability of this\n   specification.\n   We note that the\
    \ DTLS encapsulation of RADIUS means that RADIUS\n   packets have an additional\
    \ overhead due to DTLS.  Implementations\n   MUST support sending and receiving\
    \ encapsulated RADIUS packets of\n   4096 octets in length, with a corresponding\
    \ increase in the maximum\n   size of the encapsulated DTLS packets.  This larger\
    \ packet size may\n   cause the packet to be larger than the Path MTU (PMTU),\
    \ where a\n   RADIUS/UDP packet may be smaller.  See Section 5.2, below, for more\n\
    \   discussion.\n   The only changes made from RADIUS/UDP to RADIUS/DTLS are the\n\
    \   following two items:\n   (1) The Length checks defined in [RFC2865], Section\
    \ 3, MUST use the\n       length of the decrypted DTLS data instead of the UDP\
    \ packet\n       length.  They MUST treat any decrypted DTLS data octets outside\n\
    \       the range of the Length field as padding and ignore it on\n       reception.\n\
    \   (2) The shared secret used to compute the MD5 integrity checks and\n     \
    \  the attribute encryption MUST be \"radius/dtls\".\n   All other aspects of\
    \ RADIUS are unchanged.\n"
- title: 2.2.  Similarities with RADIUS/TLS
  contents:
  - "2.2.  Similarities with RADIUS/TLS\n   While this specification can be thought\
    \ of as RADIUS/TLS over UDP\n   instead of the Transmission Control Protocol (TCP),\
    \ there are some\n   differences between the two methods.  The bulk of [RFC6614]\
    \ applies\n   to this specification, so we do not repeat it here.\n   This section\
    \ explains the differences between RADIUS/TLS and\n   RADIUS/DTLS, as semantic\
    \ \"patches\" to [RFC6614].  The changes are as\n   follows:\n      * We replace\
    \ references to \"TCP\" with \"UDP\"\n      * We replace references to \"RADIUS/TLS\"\
    \ with \"RADIUS/DTLS\"\n      * We replace references to \"TLS\" with \"DTLS\"\
    \n   Those changes are sufficient to cover the majority of the differences\n \
    \  between the two specifications.  The next section reviews some more\n   detailed\
    \ changes from [RFC6614], giving additional commentary only\n   where necessary.\n"
- title: 2.2.1.  Changes from RADIUS/TLS to RADIUS/DTLS
  contents:
  - "2.2.1.  Changes from RADIUS/TLS to RADIUS/DTLS\n   This section describes how\
    \ particular sections of [RFC6614] apply to\n   RADIUS/DTLS.\n   Section 2.1 applies\
    \ to RADIUS/DTLS, with the exception that the\n   RADIUS/DTLS port is UDP/2083.\n\
    \   Section 2.2 applies to RADIUS/DTLS.  Servers and clients need to be\n   pre-configured\
    \ to use RADIUS/DTLS for a given endpoint.\n   Most of Section 2.3 applies also\
    \ to RADIUS/DTLS.  Item (1) should be\n   interpreted as applying to DTLS session\
    \ initiation, instead of TCP\n   connection establishment.  Item (2) applies,\
    \ except for the\n   recommendation that implementations \"SHOULD\" support\n\
    \   TLS_RSA_WITH_RC4_128_SHA.  This recommendation is a historical\n   artifact\
    \ of RADIUS/TLS, and it does not apply to RADIUS/DTLS.  Item\n   (3) applies to\
    \ RADIUS/DTLS.  Item (4) applies, except that the fixed\n   shared secret is \"\
    radius/dtls\", as described above.\n   Section 2.4 applies to RADIUS/DTLS.  Client\
    \ identities SHOULD be\n   determined from DTLS parameters, instead of relying\
    \ solely on the\n   source IP address of the packet.\n   Section 2.5 does not\
    \ apply to RADIUS/DTLS.  The relationship between\n   RADIUS packet codes and\
    \ UDP ports in RADIUS/DTLS is unchanged from\n   RADIUS/UDP.\n   Sections 3.1,\
    \ 3.2, and 3.3 apply to RADIUS/DTLS.\n   Section 3.4 item (1) does not apply to\
    \ RADIUS/DTLS.  Each RADIUS\n   packet is encapsulated in one DTLS packet, and\
    \ there is no \"stream\"\n   of RADIUS packets inside of a TLS session.  Implementors\
    \ MUST enforce\n   the requirements of [RFC2865], Section 3, for the RADIUS Length\n\
    \   field, using the length of the decrypted DTLS data for the checks.\n   This\
    \ check replaces the RADIUS method of using the Length field from\n   the UDP\
    \ packet.\n   Section 3.4 items (2), (3), (4), and (5) apply to RADIUS/DTLS.\n\
    \   Section 4 does not apply to RADIUS/DTLS.  Protocol compatibility\n   considerations\
    \ are defined in this document.\n   Section 6 applies to RADIUS/DTLS.\n"
- title: 3.  Interaction with RADIUS/UDP
  contents:
  - "3.  Interaction with RADIUS/UDP\n   Transitioning to DTLS is a process that needs\
    \ to be done carefully.\n   A poorly handled transition is complex for administrators\
    \ and\n   potentially subject to security downgrade attacks.  It is not\n   sufficient\
    \ to just disable RADIUS/UDP and enable RADIUS/DTLS.  RADIUS\n   has no provisions\
    \ for protocol negotiation, so simply disabling\n   RADIUS/UDP would result in\
    \ timeouts, lost traffic, and network\n   instabilities.\n   The end result of\
    \ this specification is that nearly all RADIUS/UDP\n   implementations should\
    \ transition to using a secure alternative.  In\n   some cases, RADIUS/UDP may\
    \ remain where IPsec is used as a transport,\n   or where implementation and/or\
    \ business reasons preclude a change.\n   However, we do not recommend long-term\
    \ use of RADIUS/UDP outside of\n   isolated and secure networks.\n   This section\
    \ describes how clients and servers should use\n   RADIUS/DTLS, and how it interacts\
    \ with RADIUS/UDP.\n"
- title: 3.1.  DTLS Port and Packet Types
  contents:
  - "3.1.  DTLS Port and Packet Types\n   The default destination port number for\
    \ RADIUS/DTLS is UDP/2083.\n   There are no separate ports for authentication,\
    \ accounting, and\n   dynamic authorization changes.  The source port is arbitrary.\
    \  The\n   text in [RFC6614], Section 3.4, describes issues surrounding the use\n\
    \   of one port for multiple packet types.  We recognize that\n   implementations\
    \ may allow the use of RADIUS/DTLS over non-standard\n   ports.  In that case,\
    \ the references to UDP/2083 in this document\n   should be read as applying to\
    \ any port used for transport of\n   RADIUS/DTLS traffic.\n"
- title: 3.2.  Server Behavior
  contents:
  - "3.2.  Server Behavior\n   When a server receives packets on UDP/2083, all packets\
    \ MUST be\n   treated as being DTLS.  RADIUS/UDP packets MUST NOT be accepted\
    \ on\n   this port.\n   Servers MUST NOT accept DTLS packets on the old RADIUS/UDP\
    \ ports.\n   Early versions of this specification permitted this behavior.  It\
    \ is\n   forbidden here, as it depended on behavior in DTLS that may change\n\
    \   without notice.\n   Servers MUST authenticate clients.  RADIUS is designed\
    \ to be used by\n   mutually trusted systems.  Allowing anonymous clients would\
    \ ensure\n   privacy for RADIUS/DTLS traffic, but would negate all other security\n\
    \   aspects of the protocol.\n   As RADIUS has no provisions for capability signaling,\
    \ there is no way\n   for a server to indicate to a client that it should transition\
    \ to\n   using DTLS.  This action has to be taken by the administrators of the\n\
    \   two systems, using a method other than RADIUS.  This method will\n   likely\
    \ be out of band, or manual configuration will need to be used.\n   Some servers\
    \ maintain a list of allowed clients per destination port.\n   Others maintain\
    \ a global list of clients that are permitted to send\n   packets to any port.\
    \  Where a client can send packets to multiple\n   ports, the server MUST maintain\
    \ a \"DTLS Required\" flag per client.\n   This flag indicates whether or not\
    \ the client is required to use\n   DTLS.  When set, the flag indicates that the\
    \ only traffic accepted\n   from the client is over UDP/2083.  When packets are\
    \ received from a\n   client on non-DTLS ports, for which DTLS is required, the\
    \ server MUST\n   silently discard these packets, as there is no RADIUS/UDP shared\n\
    \   secret available.\n   This flag will often be set by an administrator.  However,\
    \ if a\n   server receives DTLS traffic from a client, it SHOULD notify the\n\
    \   administrator that DTLS is available for that client.  It MAY mark\n   the\
    \ client as \"DTLS Required\".\n   It is RECOMMENDED that servers support the\
    \ following Perfect Forward\n   Secrecy (PFS) ciphersuites:\n      o  TLS_DHE_RSA_WITH_AES_128_GCM_SHA256\n\
    \      o  TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n   Allowing RADIUS/UDP and RADIUS/DTLS\
    \ from the same client exposes the\n   traffic to downbidding attacks and is NOT\
    \ RECOMMENDED.\n"
- title: 4.  Client Behavior
  contents:
  - "4.  Client Behavior\n   When a client sends packets to the assigned RADIUS/DTLS\
    \ port, all\n   packets MUST be DTLS.  RADIUS/UDP packets MUST NOT be sent to\
    \ this\n   port.\n   Clients MUST authenticate themselves to servers via credentials\
    \ that\n   are unique to each client.\n   It is RECOMMENDED that clients support\
    \ the following PFS\n   ciphersuites:\n      o  TLS_DHE_RSA_WITH_AES_128_GCM_SHA256\n\
    \      o  TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n   RADIUS/DTLS clients SHOULD\
    \ NOT probe servers to see if they support\n   DTLS transport.  Instead, clients\
    \ SHOULD use DTLS as a transport\n   layer only when administratively configured.\
    \  If a client is\n   configured to use DTLS and the server appears to be unresponsive,\
    \ the\n   client MUST NOT fall back to using RADIUS/UDP.  Instead, the client\n\
    \   should treat the server as being down.\n   RADIUS clients often had multiple\
    \ independent RADIUS implementations\n   and/or processes that originate packets.\
    \  This practice was simple to\n   implement, but the result is that each independent\
    \ subsystem must\n   independently discover network issues or server failures.\
    \  It is\n   therefore RECOMMENDED that clients with multiple internal RADIUS\n\
    \   sources use a local proxy as described in Section 6.1, below.\n   Clients\
    \ may implement \"pools\" of servers for fail-over or load-\n   balancing.  These\
    \ pools SHOULD NOT mix RADIUS/UDP and RADIUS/DTLS\n   servers.\n"
- title: 5.  Session Management
  contents:
  - "5.  Session Management\n   Where [RFC6614] can rely on the TCP state machine\
    \ to perform session\n   tracking, this specification cannot.  As a result, implementations\
    \ of\n   this specification may need to perform session management of the DTLS\n\
    \   session in the application layer.  This section describes logically\n   how\
    \ this tracking is done.  Implementations may choose to use the\n   method described\
    \ here, or another, equivalent method.\n   We note that [RFC5080], Section 2.2.2,\
    \ already mandates a duplicate\n   detection cache.  The session tracking described\
    \ below can be seen as\n   an extension of that cache, where entries contain DTLS\
    \ sessions\n   instead of RADIUS/UDP packets.\n   [RFC5080], Section 2.2.2, describes\
    \ how duplicate RADIUS/UDP requests\n   result in the retransmission of a previously\
    \ cached RADIUS/UDP\n   response.  Due to DTLS sequence window requirements, a\
    \ server MUST\n   NOT retransmit a previously sent DTLS packet.  Instead, it should\n\
    \   cache the RADIUS response packet, and re-process it through DTLS to\n   create\
    \ a new RADIUS/DTLS packet, every time it is necessary to\n   retransmit a RADIUS\
    \ response.\n"
- title: 5.1.  Server Session Management
  contents:
  - "5.1.  Server Session Management\n   A RADIUS/DTLS server MUST track ongoing DTLS\
    \ sessions for each, based\n   on the following 4-tuple:\n      * source IP address\n\
    \      * source port\n      * destination IP address\n      * destination port\n\
    \   Note that this 4-tuple is independent of IP address version (IPv4 or\n   IPv6).\n\
    \   Each 4-tuple points to a unique session entry, which usually contains\n  \
    \ the following information:\n   DTLS Session\n      Any information required\
    \ to maintain and manage the DTLS session.\n   Last Traffic\n      A variable\
    \ containing a timestamp that indicates when this session\n      last received\
    \ valid traffic.  If \"Last Traffic\" is not used, this\n      variable may not\
    \ exist.\n   DTLS Data\n      An implementation-specific variable that may contain\
    \ information\n      about the active DTLS session.  This variable may be empty\
    \ or\n      nonexistent.\n      This data will typically contain information such\
    \ as idle\n      timeouts, session lifetimes, and other implementation-specific\n\
    \      data.\n"
- title: 5.1.1.  Session Opening and Closing
  contents:
  - "5.1.1.  Session Opening and Closing\n   Session tracking is subject to Denial-of-Service\
    \ (DoS) attacks due to\n   the ability of an attacker to forge UDP traffic.  RADIUS/DTLS\
    \ servers\n   SHOULD use the stateless cookie tracking technique described in\n\
    \   [RFC6347], Section 4.2.1.  DTLS sessions SHOULD NOT be tracked until\n   a\
    \ ClientHello packet has been received with an appropriate Cookie\n   value. \
    \ Server implementation SHOULD have a way of tracking DTLS\n   sessions that are\
    \ partially set up.  Servers MUST limit both the\n   number and impact on resources\
    \ of partial sessions.\n   Sessions (both 4-tuple and entry) MUST be deleted when\
    \ a TLS Closure\n   Alert ([RFC5246], Section 7.2.1) or a fatal TLS Error Alert\n\
    \   ([RFC5246], Section 7.2.2) is received.  When a session is deleted\n   due\
    \ to it failing security requirements, the DTLS session MUST be\n   closed, any\
    \ TLS session resumption parameters for that session MUST\n   be discarded, and\
    \ all tracking information MUST be deleted.\n   Sessions MUST also be deleted\
    \ when a RADIUS packet fails validation\n   due to a packet being malformed, or\
    \ when it has an invalid Message-\n   Authenticator or invalid Request Authenticator.\
    \  There are other\n   cases when the specifications require that a packet received\
    \ via a\n   DTLS session be \"silently discarded\".  In those cases,\n   implementations\
    \ MAY delete the underlying session as described above.\n   There are few reasons\
    \ to communicate with a Network Access Server\n   (NAS) that is not implementing\
    \ RADIUS.\n   A session MUST be deleted when non-RADIUS traffic is received over\n\
    \   it.  This specification is for RADIUS, and there is no reason to\n   allow\
    \ non-RADIUS traffic over a RADIUS/DTLS session.  A session MUST\n   be deleted\
    \ when RADIUS traffic fails to pass security checks.  There\n   is no reason to\
    \ permit insecure networks.  A session SHOULD NOT be\n   deleted when a well-formed,\
    \ but \"unexpected\", RADIUS packet is\n   received over it.  Future specifications\
    \ may extend RADIUS/DTLS, and\n   we do not want to forbid those specifications.\n\
    \   The goal of the above requirements is to ensure security, while\n   maintaining\
    \ flexibility.  Any security-related issue causes the\n   connection to be closed.\
    \  After the security restrictions have been\n   applied, any unexpected traffic\
    \ may be safely ignored, as it cannot\n   cause a security issue.  There is no\
    \ need to close the session for\n   unexpected but valid traffic, and the session\
    \ can safely remain open.\n   Once a DTLS session is established, a RADIUS/DTLS\
    \ server SHOULD use\n   DTLS Heartbeats [RFC6520] to determine connectivity between\
    \ the two\n   servers.  A server SHOULD also use watchdog packets from the client\n\
    \   to determine that the session is still active.\n   As UDP does not guarantee\
    \ delivery of messages, RADIUS/DTLS servers\n   that do not implement an application-layer\
    \ watchdog MUST also\n   maintain a \"Last Traffic\" timestamp per DTLS session.\
    \  The\n   granularity of this timestamp is not critical and could be limited\
    \ to\n   one-second intervals.  The timestamp SHOULD be updated on reception\n\
    \   of a valid RADIUS/DTLS packet, or a DTLS Heartbeat, but no more than\n   once\
    \ per interval.  The timestamp MUST NOT be updated in other\n   situations.\n\
    \   When a session has not received a packet for a period of time, it is\n   labeled\
    \ \"idle\".  The server SHOULD delete idle DTLS sessions after an\n   \"idle timeout\"\
    .  The server MAY cache the TLS session parameters, in\n   order to provide for\
    \ fast session resumption.\n   This session \"idle timeout\" SHOULD be exposed\
    \ to the administrator as\n   a configurable setting.  It SHOULD NOT be set to\
    \ less than 60 seconds\n   and SHOULD NOT be set to more than 600 seconds (10\
    \ minutes).  The\n   minimum useful value for this timer is determined by the\
    \ application-\n   layer watchdog mechanism defined in the following section.\n\
    \   RADIUS/DTLS servers SHOULD also monitor the total number of open\n   sessions.\
    \  They SHOULD have a \"maximum sessions\" setting exposed to\n   administrators\
    \ as a configurable parameter.  When this maximum is\n   reached and a new session\
    \ is started, the server MUST either drop an\n   old session in order to open\
    \ the new one or not create a new session.\n   RADIUS/DTLS servers SHOULD implement\
    \ session resumption, preferably\n   stateless session resumption as given in\
    \ [RFC5077].  This practice\n   lowers the time and effort required to start a\
    \ DTLS session with a\n   client and increases network responsiveness.\n   Since\
    \ UDP is stateless, the potential exists for the client to\n   initiate a new\
    \ DTLS session using a particular 4-tuple, before the\n   server has closed the\
    \ old session.  For security reasons, the server\n   MUST keep the old session\
    \ active until either it has received secure\n   notification from the client\
    \ that the session is closed or the server\n   decides to close the session based\
    \ on idle timeouts.  Taking any\n   other action would permit unauthenticated\
    \ clients to perform a DoS\n   attack, by reusing a 4-tuple and thus causing the\
    \ server to close an\n   active (and authenticated) DTLS session.\n   As a result,\
    \ servers MUST ignore any attempts to reuse an existing\n   4-tuple from an active\
    \ session.  This requirement can likely be\n   reached by simply processing the\
    \ packet through the existing session,\n   as with any other packet received via\
    \ that 4-tuple.  Non-compliant,\n   or unexpected packets will be ignored by the\
    \ DTLS layer.\n   The above requirement is mitigated by the suggestion in Section\
    \ 6.1,\n   below, that the client use a local proxy for all RADIUS traffic.\n\
    \   That proxy can then track the ports that it uses and ensure that\n   reuse\
    \ of 4-tuples is avoided.  The exact process by which this\n   tracking is done\
    \ is outside of the scope of this document.\n"
- title: 5.2.  Client Session Management
  contents:
  - "5.2.  Client Session Management\n   Clients SHOULD use PMTU discovery [RFC6520]\
    \ to determine the PMTU\n   between the client and server, prior to sending any\
    \ RADIUS traffic.\n   Once a DTLS session is established, a RADIUS/DTLS client\
    \ SHOULD use\n   DTLS Heartbeats [RFC6520] to determine connectivity between the\
    \ two\n   systems.  RADIUS/DTLS clients SHOULD also use the application-layer\n\
    \   watchdog algorithm defined in [RFC3539] to determine server\n   responsiveness.\
    \  The Status-Server packet defined in [RFC5997] SHOULD\n   be used as the \"\
    watchdog packet\" in any application-layer watchdog\n   algorithm.\n   RADIUS/DTLS\
    \ clients SHOULD proactively close sessions when they have\n   been idle for a\
    \ period of time.  Clients SHOULD close a session when\n   the DTLS Heartbeat\
    \ algorithm indicates that the session is no longer\n   active.  Clients SHOULD\
    \ close a session when no traffic other than\n   watchdog packets and (possibly)\
    \ watchdog responses has been sent for\n   three watchdog timeouts.  This behavior\
    \ ensures that clients do not\n   waste resources on the server by causing it\
    \ to track idle sessions.\n   When a client fails to implement both DTLS Heartbeats\
    \ and watchdog\n   packets, it has no way of knowing that a DTLS session has been\n\
    \   closed.  Therefore, there is the possibility that the server closes\n   the\
    \ session without the client knowing.  When that happens, the\n   client may later\
    \ transmit packets in a session, and those packets\n   will be ignored by the\
    \ server.  The client is then forced to time out\n   those packets and then the\
    \ session, leading to delays and network\n   instabilities.\n   For these reasons,\
    \ it is RECOMMENDED that all DTLS sessions be\n   configured to use DTLS Heartbeats\
    \ and/or watchdog packets.\n   DTLS sessions MUST also be deleted when a RADIUS\
    \ packet fails\n   validation due to a packet being malformed, or when it has\
    \ an invalid\n   Message-Authenticator or invalid Response Authenticator.  There\
    \ are\n   other cases when the specifications require that a packet received\n\
    \   via a DTLS session be \"silently discarded\".  In those cases,\n   implementations\
    \ MAY delete the underlying DTLS session.\n   RADIUS/DTLS clients should not send\
    \ both RADIUS/UDP and RADIUS/DTLS\n   packets to different servers from the same\
    \ source socket.  This\n   practice causes increased complexity in the client\
    \ application and\n   increases the potential for security breaches due to implementation\n\
    \   issues.\n   RADIUS/DTLS clients SHOULD implement session resumption, preferably\n\
    \   stateless session resumption as given in [RFC5077].  This practice\n   lowers\
    \ the time and effort required to start a DTLS session with a\n   server and increases\
    \ network responsiveness.\n"
- title: 6.  Implementation Guidelines
  contents:
  - "6.  Implementation Guidelines\n   The text above describes the protocol.  In\
    \ this section, we give\n   additional implementation guidelines.  These guidelines\
    \ are not part\n   of the protocol, but they may help implementors create simple,\n\
    \   secure, and interoperable implementations.\n   Where a TLS-PSK method is used,\
    \ implementations MUST support keys of\n   at least 16 octets in length.  Implementations\
    \ SHOULD support key\n   lengths of 32 octets and SHOULD allow for longer keys.\
    \  The key data\n   MUST be capable of being any value (0 through 255, inclusive).\n\
    \   Implementations MUST NOT limit themselves to using textual keys.  It\n   is\
    \ RECOMMENDED that the administration interface allow for the keys\n   to be entered\
    \ as human-readable strings in hex format.\n   When creating keys for use with\
    \ PSK ciphersuites, it is RECOMMENDED\n   that keys be derived from a Cryptographically\
    \ Secure Pseudorandom\n   Number Generator (CSPRNG) instead of administrators\
    \ inventing keys on\n   their own.  If managing keys is too complicated, a certificate-based\n\
    \   TLS method SHOULD be used instead.\n"
- title: 6.1.  Client Implementations
  contents:
  - "6.1.  Client Implementations\n   RADIUS/DTLS clients should use connected sockets\
    \ where possible.  Use\n   of connected sockets means that the underlying kernel\
    \ tracks the\n   sessions, so that the client subsystem does not need to manage\n\
    \   multiple sessions on one socket.\n   RADIUS/DTLS clients should use a single\
    \ source (IP + port) when\n   sending packets to a particular RADIUS/DTLS server.\
    \  Doing so\n   minimizes the number of DTLS session setups.  It also ensures\
    \ that\n   information about the home server state is discovered only once.\n\
    \   In practice, this means that RADIUS/DTLS clients with multiple\n   internal\
    \ RADIUS sources should use a local proxy that arbitrates all\n   RADIUS traffic\
    \ between the client and all servers.  The proxy should\n   accept traffic only\
    \ from the authorized subsystems on the client\n   machine and should proxy that\
    \ traffic to known servers.  Each\n   authorized subsystem should include an attribute\
    \ that uniquely\n   identifies that subsystem to the proxy, so that the proxy\
    \ can apply\n   origin-specific proxy rules and security policies.  We suggest\
    \ using\n   NAS-Identifier for this purpose.\n   The local proxy should be able\
    \ to interact with multiple servers at\n   the same time.  There is no requirement\
    \ that each server have its own\n   unique proxy on the client, as that would\
    \ be inefficient.\n   The suggestion to use a local proxy means that there is\
    \ only one\n   process that discovers network and/or connectivity issues with\
    \ a\n   server.  If each client subsystem communicated directly with a\n   server,\
    \ issues with that server would have to be discovered\n   independently by each\
    \ subsystem.  The side effect would be increased\n   delays in re-routing traffic,\
    \ error reporting, and network\n   instabilities.\n   Each client subsystem can\
    \ include a subsystem-specific NAS-Identifier\n   in each request.  The format\
    \ of this attribute is implementation-\n   specific.  The proxy should verify\
    \ that the request originated from\n   the local system, ideally via a loopback\
    \ address.  The proxy MUST\n   then rewrite any subsystem-specific NAS-Identifier\
    \ to a NAS-\n   Identifier that identifies the client as a whole, or, remove the\
    \ NAS-\n   Identifier entirely and replace it with NAS-IP-Address or NAS-\n  \
    \ IPv6-Address.\n   In traditional RADIUS, the cost to set up a new \"session\"\
    \ between a\n   client and server was minimal.  The client subsystem could simply\n\
    \   open a port, send a packet, wait for the response, and then close the\n  \
    \ port.  With RADIUS/DTLS, the connection setup is significantly more\n   expensive.\
    \  In addition, there may be a requirement to use DTLS in\n   order to communicate\
    \ with a server, as RADIUS/UDP may not be\n   supported by that server.  The knowledge\
    \ of what protocol to use is\n   best managed by a dedicated RADIUS subsystem,\
    \ rather than by each\n   individual subsystem on the client.\n"
- title: 6.2.  Server Implementations
  contents:
  - "6.2.  Server Implementations\n   RADIUS/DTLS servers should not use connected\
    \ sockets to read DTLS\n   packets from a client.  This recommendation exists\
    \ because a\n   connected UDP socket will accept packets only from one source\
    \ IP\n   address and port.  This limitation would prevent the server from\n  \
    \ accepting packets from multiple clients on the same port.\n"
- title: 7.  Diameter Considerations
  contents:
  - "7.  Diameter Considerations\n   This specification defines a transport layer\
    \ for RADIUS.  It makes no\n   other changes to the RADIUS protocol.  As a result,\
    \ there are no\n   Diameter considerations.\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   No new RADIUS attributes or packet codes are defined.\
    \  IANA has\n   updated the \"Service Name and Transport Protocol Port Number\n\
    \   Registry\".  The entries corresponding to port service name \"radsec\",\n\
    \   port number \"2083\", and transport protocol \"UDP\" have been updated as\n\
    \   follows:\n      o  Assignee: IESG\n      o  Contact: IETF Chair\n      o \
    \ Reference: This document\n      o  Assignment Notes: The UDP port 2083 was already\
    \ previously\n         assigned by IANA for \"RadSec\", an early implementation\
    \ of\n         RADIUS/TLS, prior to issuance of this RFC.\n"
- title: 9.  Implementation Status
  contents:
  - "9.  Implementation Status\n   This section records the status of known implementations\
    \ of\n   RADIUS/DTLS at the time of writing, and is based on a proposal\n   described\
    \ in [RFC6982].\n   The description of implementations in this section is intended\
    \ to\n   assist the IETF in its decision processes in progressing Internet-\n\
    \   Drafts to RFCs.\n"
- title: 9.1.  Radsecproxy
  contents:
  - "9.1.  Radsecproxy\n   Organization: Radsecproxy\n   URL:       https://software.uninett.no/radsecproxy/\n\
    \   Maturity:  Widely used software based on early versions of this\n        \
    \      document.\n              The use of the DTLS functionality is not clear.\n\
    \   Coverage:  The bulk of this specification is implemented, based on\n     \
    \         earlier versions of this document.  Exact revisions that\n         \
    \     were implemented are unknown.\n   Licensing: Freely distributable with acknowledgment.\n\
    \   Implementation experience: No comments from implementors.\n"
- title: 9.2.  jradius
  contents:
  - "9.2.  jradius\n   Organization: Coova\n   URL:       http://www.coova.org/JRadius/RadSec\n\
    \   Maturity:  Production software based on early versions of this\n         \
    \     document.\n              The use of the DTLS functionality is not clear.\n\
    \   Coverage:  The bulk of this specification is implemented, based on\n     \
    \         earlier versions of this document.  Exact revisions that\n         \
    \     were implemented are unknown.\n   Licensing: Freely distributable with requirement\
    \ to redistribute\n              source.\n   Implementation experience: No comments\
    \ from implementors.\n"
- title: 10.  Security Considerations
  contents:
  - "10.  Security Considerations\n   The bulk of this specification is devoted to\
    \ discussing security\n   considerations related to RADIUS.  However, we discuss\
    \ a few\n   additional issues here.\n   This specification relies on the existing\
    \ DTLS, RADIUS/UDP, and\n   RADIUS/TLS specifications.  As a result, all security\
    \ considerations\n   for DTLS apply to the DTLS portion of RADIUS/DTLS.  Similarly,\
    \ the\n   TLS and RADIUS security issues discussed in [RFC6614] also apply to\n\
    \   this specification.  Most of the security considerations for RADIUS\n   apply\
    \ to the RADIUS portion of the specification.\n   However, many security considerations\
    \ raised in the RADIUS documents\n   are related to RADIUS encryption and authorization.\
    \  Those issues are\n   largely mitigated when DTLS is used as a transport method.\
    \  The\n   issues that are not mitigated by this specification are related to\n\
    \   the RADIUS packet format and handling, which is unchanged in this\n   specification.\n\
    \   This specification also suggests that implementations use a session\n   tracking\
    \ table.  This table is an extension of the duplicate\n   detection cache mandated\
    \ in [RFC5080], Section 2.2.2.  The changes\n   given here are that DTLS-specific\
    \ information is tracked for each\n   table entry.  Section 5.1.1, above, describes\
    \ steps to mitigate any\n   DoS issues that result from tracking additional information.\n\
    \   The fixed shared secret given above in Section 2.2.1 is acceptable\n   only\
    \ when DTLS is used with a non-null encryption method.  When a\n   DTLS session\
    \ uses a null encryption method due to misconfiguration or\n   implementation\
    \ error, all of the RADIUS traffic will be readable by\n   an observer.  Therefore,\
    \ implementations MUST NOT use null encryption\n   methods for RADIUS/DTLS.\n\
    \   For systems that perform protocol-based firewalling and/or filtering,\n  \
    \ it is RECOMMENDED that they be configured to permit only DTLS over\n   the RADIUS/DTLS\
    \ port.\n"
- title: 10.1.  Crypto-Agility
  contents:
  - "10.1.  Crypto-Agility\n   Section 4.2 of [RFC6421] makes a number of recommendations\
    \ about\n   security properties of new RADIUS proposals.  All of those\n   recommendations\
    \ are satisfied by using DTLS as the transport layer.\n   Section 4.3 of [RFC6421]\
    \ makes a number of recommendations about\n   backwards compatibility with RADIUS.\
    \  Section 3, above, addresses\n   these concerns in detail.\n   Section 4.4 of\
    \ [RFC6421] recommends that change control be ceded to\n   the IETF, and that\
    \ interoperability is possible.  Both requirements\n   are satisfied.\n   Section\
    \ 4.5 of [RFC6421] requires that the new security methods apply\n   to all packet\
    \ types.  This requirement is satisfied by allowing DTLS\n   to be used for all\
    \ RADIUS traffic.  In addition, Section 3, above,\n   addresses concerns about\
    \ documenting the transition from legacy\n   RADIUS to crypto-agile RADIUS.\n\
    \   Section 4.6 of [RFC6421] requires automated key management.  This\n   requirement\
    \ is satisfied by using DTLS key management.\n"
- title: 10.2.  Legacy RADIUS Security
  contents:
  - "10.2.  Legacy RADIUS Security\n   We reiterate here the poor security of the\
    \ legacy RADIUS protocol.\n   We suggest that RADIUS clients and servers implement\
    \ either this\n   specification or [RFC6614].  New attacks on MD5 have appeared\
    \ over\n   the past few years, and there is a distinct possibility that MD5 may\n\
    \   be completely broken in the near future.  Such a break would mean\n   that\
    \ RADIUS/UDP was completely insecure.\n   The existence of fast and cheap attacks\
    \ on MD5 could result in a loss\n   of all network security that depends on RADIUS.\
    \  Attackers could\n   obtain user passwords and possibly gain complete network\
    \ access.  We\n   cannot overstate the disastrous consequences of a successful\
    \ attack\n   on RADIUS.\n   We also caution implementors (especially client implementors)\
    \ about\n   using RADIUS/DTLS.  It may be tempting to use the shared secret as\n\
    \   the basis for a TLS-PSK method and to leave the user interface\n   otherwise\
    \ unchanged.  This practice MUST NOT be used.  The\n   administrator MUST be given\
    \ the option to use DTLS.  Any shared\n   secret used for RADIUS/UDP MUST NOT\
    \ be used for DTLS.  Reusing a\n   shared secret between RADIUS/UDP and RADIUS/DTLS\
    \ would negate all of\n   the benefits found by using DTLS.\n   RADIUS/DTLS client\
    \ implementors MUST expose a configuration that\n   allows the administrator to\
    \ choose the ciphersuite.  Where\n   certificates are used, RADIUS/DTLS client\
    \ implementors MUST expose a\n   configuration that allows an administrator to\
    \ configure all\n   certificates necessary for certificate-based authentication.\
    \  These\n   certificates include client, server, and root certificates.\n   TLS-PSK\
    \ methods are susceptible to dictionary attacks.  Section 6,\n   above, recommends\
    \ deriving TLS-PSK keys from a Cryptographically\n   Secure Pseudorandom Number\
    \ Generator (CSPRNG), which makes dictionary\n   attacks significantly more difficult.\
    \  Servers SHOULD track failed\n   client connections by TLS-PSK ID and block\
    \ TLS-PSK IDs that seem to\n   be attempting brute-force searches of the keyspace.\n\
    \   The historic RADIUS practice of using shared secrets (here, PSKs)\n   that\
    \ are minor variations of words is NOT RECOMMENDED, as it would\n   negate all\
    \ of the security of DTLS.\n"
- title: 10.3.  Resource Exhaustion
  contents:
  - "10.3.  Resource Exhaustion\n   The use of DTLS allows DoS attacks and resource-exhaustion\
    \ attacks\n   that were not possible in RADIUS/UDP.  These attacks are similar\
    \ to\n   those described in [RFC6614], Section 6, for TCP.\n   Session tracking,\
    \ as described in Section 5.1, can result in resource\n   exhaustion.  Therefore,\
    \ servers MUST limit the absolute number of\n   sessions that they track.  When\
    \ the total number of sessions tracked\n   is going to exceed the configured limit,\
    \ servers MAY free up\n   resources by closing the session that has been idle\
    \ for the longest\n   time.  Doing so may free up idle resources that then allow\
    \ the server\n   to accept a new session.\n   Servers MUST limit the number of\
    \ partially open DTLS sessions.  These\n   limits SHOULD be exposed to the administrator\
    \ as configurable\n   settings.\n"
- title: 10.4.  Client-Server Authentication with DTLS
  contents:
  - "10.4.  Client-Server Authentication with DTLS\n   We expect that the initial\
    \ deployment of DTLS will follow the\n   RADIUS/UDP model of statically configured\
    \ client-server\n   relationships.  The specification for dynamic discovery of\
    \ RADIUS\n   servers is under development, so we will not address that here.\n\
    \   Static configuration of client-server relationships for RADIUS/UDP\n   means\
    \ that a client has a fixed IP address for a server and a shared\n   secret used\
    \ to authenticate traffic sent to that address.  The server\n   in turn has a\
    \ fixed IP address for a client and a shared secret used\n   to authenticate traffic\
    \ from that address.  This model needs to be\n   extended for RADIUS/DTLS.\n \
    \  Instead of a shared secret, TLS credentials MUST be used by each\n   party\
    \ to authenticate the other.  The issue of identity is more\n   problematic. \
    \ As with RADIUS/UDP, IP addresses may be used as a key\n   to determine the authentication\
    \ credentials that a client will\n   present to a server or which credentials\
    \ a server will accept from a\n   client.  This is the fixed IP address model\
    \ of RADIUS/UDP, with the\n   shared secret replaced by TLS credentials.\n   There\
    \ are, however, additional considerations with RADIUS/DTLS.  When\n   a client\
    \ is configured with a hostname for a server, the server may\n   present to the\
    \ client a certificate containing a hostname.  The\n   client MUST then verify\
    \ that the hostnames match.  Any mismatch is a\n   security violation, and the\
    \ connection MUST be closed.\n   A RADIUS/DTLS server MAY be configured with a\
    \ \"wildcard\" IP address\n   match for clients, instead of a unique fixed IP\
    \ address for each\n   client.  In that case, clients MUST be individually configured\
    \ with a\n   unique certificate.  When the server receives a connection from a\n\
    \   client, it MUST determine client identity from the client\n   certificate,\
    \ and MUST authenticate (or not) the client based on that\n   certificate.  See\
    \ [RFC6614], Section 2.4, for a discussion of how to\n   match a certificate to\
    \ a client identity.\n   However, servers SHOULD use IP address filtering to minimize\
    \ the\n   possibility of attacks.  That is, they SHOULD permit clients only\n\
    \   from a limited IP address range or ranges.  They SHOULD silently\n   discard\
    \ all traffic from outside of those ranges.\n   Since the client-server relationship\
    \ is static, the authentication\n   credentials for that relationship must also\
    \ be statically configured.\n   That is, a client connecting to a DTLS server\
    \ SHOULD be pre-\n   configured with the server's credentials (e.g., PSK or certificate).\n\
    \   If the server fails to present the correct credentials, the DTLS\n   session\
    \ MUST be closed.  Each server SHOULD be pre-configured with\n   sufficient information\
    \ to authenticate connecting clients.\n   The requirement for clients to be individually\
    \ configured with a\n   unique certificate can be met by using a private CA for\
    \ certificates\n   used in RADIUS/DTLS environments.  If a client were configured\
    \ to use\n   a public CA, then it could accept as valid any server that has a\n\
    \   certificate signed by that CA.  While the traffic would be secure\n   from\
    \ third-party observers, the server would, however, have\n   unrestricted access\
    \ to all of the RADIUS traffic, including all user\n   credentials and passwords.\n\
    \   Therefore, clients SHOULD NOT be pre-configured with a list of known\n   public\
    \ CAs by the vendor or manufacturer.  Instead, the clients\n   SHOULD start off\
    \ with an empty CA list.  The addition of a CA SHOULD\n   be done only when manually\
    \ configured by an administrator.\n   This scenario is the opposite of web browsers,\
    \ where they are pre-\n   configured with many known CAs.  The goal there is security\
    \ from\n   third-party observers, but also the ability to communicate with any\n\
    \   unknown site that presents a signed certificate.  In contrast, the\n   goal\
    \ of RADIUS/DTLS is both security from third-party observers and\n   the ability\
    \ to communicate with only a small set of well-known\n   servers.\n   This requirement\
    \ does not prevent clients from using hostnames\n   instead of IP addresses for\
    \ locating a particular server.  Instead,\n   it means that the credentials for\
    \ that server should be pre-\n   configured on the client, and associated with\
    \ that hostname.  This\n   requirement does suggest that in the absence of a specification\
    \ for\n   dynamic discovery, clients SHOULD use only those servers that have\n\
    \   been manually configured by an administrator.\n"
- title: 10.5.  Network Address Translation
  contents:
  - "10.5.  Network Address Translation\n   Network Address Translation (NAT) is fundamentally\
    \ incompatible with\n   RADIUS/UDP.  RADIUS/UDP uses the source IP address to\
    \ determine the\n   shared secret for the client, and NAT hides many clients behind\
    \ one\n   source IP address.  As a result, RADIUS/UDP clients cannot be located\n\
    \   behind a NAT gateway.\n   In addition, port reuse on a NAT gateway means that\
    \ packets from\n   different clients may appear to come from the same source port\
    \ on the\n   NAT.  That is, a RADIUS server may receive a RADIUS/DTLS packet from\n\
    \   one source IP/port combination, followed by the reception of a\n   RADIUS/UDP\
    \ packet from that same source IP/port combination.  If this\n   behavior is allowed,\
    \ then the server would have an inconsistent view\n   of the client's security\
    \ profile, allowing an attacker to choose the\n   most insecure method.\n   If\
    \ more than one client is located behind a NAT gateway, then every\n   client\
    \ behind the NAT MUST use a secure transport such as TLS or\n   DTLS.  As discussed\
    \ below, a method for uniquely identifying each\n   client MUST be used.\n"
- title: 10.6.  Wildcard Clients
  contents:
  - "10.6.  Wildcard Clients\n   Some RADIUS server implementations allow for \"wildcard\"\
    \ clients --\n   that is, clients with an IPv4 netmask of other than 32 or an\
    \ IPv6\n   netmask of other than 128.  That practice is not recommended for\n\
    \   RADIUS/UDP, as it means multiple clients will use the same shared\n   secret.\n\
    \   The use of RADIUS/DTLS can allow for the safe usage of wildcards.\n   When\
    \ RADIUS/DTLS is used with wildcards, clients MUST be uniquely\n   identified\
    \ using TLS parameters, and any certificate or PSK used MUST\n   be unique to\
    \ each client.\n"
- title: 10.7.  Session Closing
  contents:
  - "10.7.  Session Closing\n   Section 5.1.1, above, requires that DTLS sessions\
    \ be closed when the\n   transported RADIUS packets are malformed or fail the\
    \ authenticator\n   checks.  The reason is that the session is expected to be\
    \ used for\n   transport of RADIUS packets only.\n   Any non-RADIUS traffic on\
    \ that session means the other party is\n   misbehaving and is a potential security\
    \ risk.  Similarly, any RADIUS\n   traffic failing authentication vector or Message-Authenticator\n\
    \   validation means that two parties do not have a common shared secret,\n  \
    \ and the session is therefore unauthenticated and insecure.\n   We wish to avoid\
    \ the situation where a third party can send well-\n   formed RADIUS packets that\
    \ cause a DTLS session to close.  Therefore,\n   in other situations, the session\
    \ SHOULD remain open in the face of\n   non-conformant packets.\n"
- title: 10.8.  Client Subsystems
  contents:
  - "10.8.  Client Subsystems\n   Many traditional clients treat RADIUS as subsystem-specific.\
    \  That\n   is, each subsystem on the client has its own RADIUS implementation\n\
    \   and configuration.  These independent implementations work for simple\n  \
    \ systems, but break down for RADIUS when multiple servers, fail-over,\n   and\
    \ load-balancing are required.  They have even worse issues when\n   DTLS is enabled.\n\
    \   As noted in Section 6.1, above, clients SHOULD use a local proxy that\n  \
    \ arbitrates all RADIUS traffic between the client and all servers.\n   This proxy\
    \ will encapsulate all knowledge about servers, including\n   security policies,\
    \ fail-over, and load-balancing.  All client\n   subsystems SHOULD communicate\
    \ with this local proxy, ideally over a\n   loopback address.  The requirements\
    \ on using strong shared secrets\n   still apply.\n   The benefit of this configuration\
    \ is that there is one place in the\n   client that arbitrates all RADIUS traffic.\
    \  Subsystems that do not\n   implement DTLS can remain unaware of DTLS.  DTLS\
    \ sessions opened by\n   the proxy can remain open for long periods of time, even\
    \ when client\n   subsystems are restarted.  The proxy can do RADIUS/UDP to some\n\
    \   servers and RADIUS/DTLS to others.\n   Delegation of responsibilities and\
    \ separation of tasks are important\n   security principles.  By moving all RADIUS/DTLS\
    \ knowledge to a DTLS-\n   aware proxy, security analysis becomes simpler, and\
    \ enforcement of\n   correct security becomes easier.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [RFC2119]   Bradner, S., \"Key words for use\
    \ in RFCs to Indicate\n               Requirement Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [RFC2865]   Rigney, C., Willens, S., Rubens, A., and W. Simpson,\n\
    \               \"Remote Authentication Dial In User Service (RADIUS)\",\n   \
    \            RFC 2865, June 2000.\n   [RFC3539]   Aboba, B. and J. Wood, \"Authentication,\
    \ Authorization and\n               Accounting (AAA) Transport Profile\", RFC\
    \ 3539, June 2003.\n   [RFC5077]   Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig,\n\
    \               \"Transport Layer Security (TLS) Session Resumption\n        \
    \       without Server-Side State\", RFC 5077, January 2008.\n   [RFC5080]   Nelson,\
    \ D. and A. DeKok, \"Common Remote Authentication\n               Dial In User\
    \ Service (RADIUS) Implementation Issues and\n               Suggested Fixes\"\
    , RFC 5080, December 2007.\n   [RFC5246]   Dierks, T. and E. Rescorla, \"The Transport\
    \ Layer Security\n               (TLS) Protocol Version 1.2\", RFC 5246, August\
    \ 2008.\n   [RFC5997]   DeKok, A., \"Use of Status-Server Packets in the Remote\n\
    \               Authentication Dial In User Service (RADIUS) Protocol\",\n   \
    \            RFC 5997, August 2010.\n   [RFC6347]   Rescorla, E. and N. Modadugu,\
    \ \"Datagram Transport Layer\n               Security Version 1.2\", RFC 6347,\
    \ January 2012.\n   [RFC6520]   Seggelmann, R., Tuexen, M., and M. Williams, \"\
    Transport\n               Layer Security (TLS) and Datagram Transport Layer\n\
    \               Security (DTLS) Heartbeat Extension\", RFC 6520, February\n  \
    \             2012.\n   [RFC6613]   DeKok, A., \"RADIUS over TCP\", RFC 6613,\
    \ May 2012.\n   [RFC6614]   Winter, S., McCauley, M., Venaas, S., and K. Wierenga,\n\
    \               \"Transport Layer Security (TLS) Encryption for RADIUS\",\n  \
    \             RFC 6614, May 2012.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [RFC1321]   Rivest, R., \"The MD5 Message-Digest\
    \ Algorithm\", RFC 1321,\n               April 1992.\n   [RFC2866]   Rigney, C.,\
    \ \"RADIUS Accounting\", RFC 2866, June 2000.\n   [RFC4107]   Bellovin, S. and\
    \ R. Housley, \"Guidelines for\n               Cryptographic Key Management\"\
    , BCP 107, RFC 4107, June\n               2005.\n   [RFC5176]   Chiba, M., Dommety,\
    \ G., Eklund, M., Mitton, D., and B.\n               Aboba, \"Dynamic Authorization\
    \ Extensions to Remote\n               Authentication Dial In User Service (RADIUS)\"\
    , RFC 5176,\n               January 2008.\n   [RFC6421]   Nelson, D., Ed., \"\
    Crypto-Agility Requirements for Remote\n               Authentication Dial-In\
    \ User Service (RADIUS)\", RFC 6421,\n               November 2011.\n   [RFC6982]\
    \   Sheffer, Y. and A. Farrel, \"Improving Awareness of\n               Running\
    \ Code: The Implementation Status Section\", RFC\n               6982, July 2013.\n\
    \   [MD5Attack] Dobbertin, H., \"The Status of MD5 After a Recent Attack\",\n\
    \               CryptoBytes Vol.2 No.2, Summer 1996.\n   [MD5Break]  Wang, X.\
    \ and H. Yu, \"How to Break MD5 and Other Hash\n               Functions\", EUROCRYPT\
    \ '05 Proceedings of the 24th annual\n               international conference\
    \ on Theory and Applications of\n               Cryptographic Techniques, pp.\
    \ 19-35, ISBN 3-540-25910-4,\n               2005.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   Parts of the text in Section 3 defining the Request and Response\n\
    \   Authenticators were taken with minor edits from [RFC2865], Section 3.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Alan DeKok\n   The FreeRADIUS Server Project\n   URI: http://freeradius.org\n\
    \   EMail: aland@freeradius.org\n"
