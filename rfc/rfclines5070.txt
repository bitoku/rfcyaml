Abstract The Incident Object Description Exchange Format (IODEF) defines a data representation that provides a framework for sharing information commonly exchanged by Computer Security Incident Response Teams (CSIRTs) about computer security incidents.
This document describes the information model for the IODEF and provides an associated data model specified with XML Schema.
Introduction Organizations require help from other parties to mitigate malicious activity targeting their network and to gain insight into potential threats.
This coordination might entail working with an ISP to filter attack traffic, contacting a remote site to take down a bot  network, or sharing watch lists of known malicious IP addresses in a consortium.
The Incident Object Description Exchange Format (IODEF) is a format for representing computer security information commonly exchanged between Computer Security Incident Response Teams (CSIRTs).
It provides an XML representation for conveying incident information across administrative domains between parties that have an operational responsibility of remediation or a watch and warning over a defined constituency.
The data model encodes information about hosts, networks, and the services running on these systems; attack methodology and associated forensic evidence; impact of the activity; and limited approaches for documenting workflow.
The overriding purpose of the IODEF is to enhance the operational capabilities of CSIRTs.
Community adoption of the IODEF provides an improved ability to resolve incidents and convey situational awareness by simplifying collaboration and data sharing.
This structured format provided by the IODEF allows for:  increased automation in processing of incident data, since the resources of security analysts to parse free form textual documents will be reduced;  decreased effort in normalizing similar data (even when highly structured) from different sources; and  a common format on which to build interoperable tools for incident handling and subsequent analysis, specifically when data comes from multiple constituencies.
Coordinating with other CSIRTs is not strictly a technical problem.
There are numerous procedural, trust, and legal considerations that might prevent an organization from sharing information.
The IODEF does not attempt to address them.
However, operational implementations of the IODEF will need to consider this broader context.
Sections 3 and 8 specify the IODEF data model with text and an XML schema.
The types used by the data model are covered in Section 2.
Processing considerations, the handling of extensions, and internationalization issues related to the data model are covered in Sections 4, 5, and 6, respectively.
Examples are listed in Section 7.
Section 1 provides the background for the IODEF, and Section 9 documents the security considerations.
The key words "MUST," "MUST NOT," "REQUIRED," "SHALL," "
SHALL NOT," "SHOULD," "SHOULD NOT,
" "RECOMMENDED," "MAY," and "OPTIONAL" in this document are to be interpreted as described in RFC2119 [6].
Definitions for some of the common computer security related terminology used in this document can be found in Section 2 of [16].
The normative IODEF data model is specified with the text in Section 3 and the XML schema in Section 8.
To help in the understanding of the data elements, Section 3 also depicts the underlying information model using Unified Modeling Language (UML).
This abstract presentation of the IODEF is not normative.
For clarity in this document, the term "XML document" will be used when referring generically to any instance of an XML document.
The term "IODEF document" will be used to refer to specific elements and attributes of the IODEF schema.
The terms "class" and "element" will be used interchangeably to reference either the corresponding data element in the information or data models, respectively.
About the IODEF Data Model
The IODEF data model is a data representation that provides a framework for sharing information commonly exchanged by CSIRTs about computer security incidents.
A number of considerations were made in the design of the data model.
The data model serves as a transport format.
Therefore, its specific representation is not the optimal representation for on  disk storage, long term archiving, or in memory processing.
As there is no precise widely agreed upon definition for an incident, the data model does not attempt to dictate one through its implementation.
Rather, a broad understanding is assumed in the IODEF that is flexible enough to encompass most operators.
Describing an incident for all definitions would require an extremely complex data model.
Therefore, the IODEF only intends to be a framework to convey commonly exchanged incident information.
It ensures that there are ample mechanisms for extensibility to support organization specific information, and techniques to reference information kept outside of the explicit data model.
The domain of security analysis is not fully standardized and must rely on free form textual descriptions.
The IODEF attempts to strike a balance between supporting this free form content, while still allowing automated processing of incident information.
The IODEF is only one of several security relevant data representations being standardized.
Attempts were made to ensure they were complimentary.
The data model of the Intrusion Detection Message Exchange Format [17] influenced the design of the IODEF.
Further discussion of the desirable properties for the IODEF can be found in the Requirements for the Format for Incident Information Exchange (FINE) [16].
1.4.  About the IODEF Implementation
The IODEF implementation is specified as an Extensible Markup Language (XML)
[1] Schema [2] in Section 8.
Implementing the IODEF in XML provides numerous advantages.
Its extensibility makes it ideal for specifying a data encoding framework that supports various character encodings.
Likewise, the abundance of related technologies (e.g., XSL, XPath, XML Signature) makes for simplified manipulation.
However, XML is fundamentally a text representation, which makes it inherently inefficient when binary data must be embedded or large volumes of data must be exchanged.
The various data elements of the IODEF data model are typed.
This section discusses these data types.
When possible, native Schema data types were adopted, but for more complicated formats, regular expressions (see Appendix F of [3]) or external standards were used.
An integer is represented by the INTEGER data type.
Integer data MUST be encoded in Base 10.
The INTEGER data type is implemented as an "xs:integer" [3] in the schema.
Real Numbers Real (floating point)
attributes are represented by the REAL data type.
Real data MUST be encoded in Base 10.
The REAL data type is implemented as an "xs:float" [3] in the schema.
Characters and Strings A single character is represented by the CHARACTER data type.
A character string is represented by the STRING data type.
Special characters must be encoded using entity references.
The CHARACTER and STRING data types are implement as an "xs:string" [3] in the schema.
Multilingual Strings STRING data that represents multi character attributes in a language different than the default encoding of the document is of the ML STRING data type.
The ML STRING data type is implemented as an "iodef:MLStringType" in the schema.
A binary octet is represented by the BYTE data type.
A sequence of binary octets is represented by the BYTE[] data type.
These octets are encoded using base64.
The BYTE data type is implemented as an "xs:
base64Binary" [3] in the schema.
A binary octet is represented by the HEXBIN (and HEXBIN[]) data type.
This octet is encoded as a character tuple consisting of two hexadecimal digits.
The HEXBIN data type is implemented as an "xs:hexBinary" [3] in the schema.
Enumerated Types Enumerated types are represented by the ENUM data type, and consist of an ordered list of acceptable values.
Each value has a representative keyword.
Within the IODEF schema, the enumerated type keywords are used as attribute values.
The ENUM data type is implemented as a series of "xs:NMTOKEN" in the schema.
Date Time Strings Date time strings are represented by the DATETIME data type.
Each date time string identifies a particular instant in time; ranges are not supported.
Date time strings are formatted according to a subset of ISO 8601: 2000 [13] documented in RFC 3339 [12].
The DATETIME data type is implemented as an "xs:dateTime" [3] in the schema.
A timezone offset from UTC is represented by the TIMEZONE data type.
The TIMEZONE data type is implemented as an "xs:string" with a regular expression constraint in the schema.
This regular expression is identical to the timezone representation implemented in an "xs: dateTime".
A list of network ports are represented by the PORTLIST data type.
A PORTLIST consists of a comma separated list of numbers and ranges (N M means ports N through M, inclusive).
For example, "2,5 15,30,32,40 50,55 60".
The PORTLIST data type is implemented as an "xs:string" with a regular expression constraint in the schema.
A postal address is represented by the POSTAL data type.
This data type is an ML STRING whose format is documented in Section 2.23 of RFC 4519 [10].
The POSTAL data type is implemented as an "xs:string" in the schema.
The name of an individual or organization is represented by the NAME data type.
This data type is an ML STRING whose format is documented in Section 2.3 of RFC 4519 [10].
The NAME data type is implemented as an "xs:string" in the schema.
A telephone or fax number is represented by the PHONE data type.
The format of the PHONE data type is documented in Section 2.35 of RFC 4519 [10].
The PHONE data type is implemented as an "xs:string" in the schema.
An email address is represented by the EMAIL data type.
The format of the EMAIL data type is documented in Section 3.4.1 RFC 2822
The EMAIL data type is implemented as an "xs:string" in the schema.
A uniform resource locator (URL) is represented by the URL data type.
The format of the URL data type is documented in RFC 2396 [8].
The URL data type is implemented as an "xs:anyURI" in the schema.
In this section, the individual components of the IODEF data model will be discussed in detail.
For each class, the semantics will be described and the relationship with other classes will be depicted with UML.
When necessary, specific comments will be made about corresponding definition in the schema in Section 8 3.1.
The IODEF Document class is the top level class in the IODEF data model.
All IODEF documents are an instance of this class.
The aggregate class that constitute IODEF Document is: Incident One or more.
The information related to a single incident.
The IODEF Document class has three attributes: version Required.
The IODEF specification version number to which this IODEF document conforms.
The value of this attribute MUST be "1.00" lang Required.
A valid language code per RFC 4646 [7] constrained by the definition of "xs:language".
The interpretation of this code is described in Section 6.
A free form string to convey processing instructions to the recipient of the document.
Its semantics must be negotiated out of band.
Every incident is represented by an instance of the Incident class.
This class provides a standardized representation for commonly exchanged incident data.
<> {0..1} [ AlternativeID   ]
The aggregate classes that constitute Incident are: IncidentID One.
An incident tracking number assigned to this incident by the CSIRT that generated the IODEF document.
The incident tracking numbers used by other CSIRTs to refer to the incident described in the document.
The incident tracking numbers of related incidents.
The time the incident was first detected.
The time the incident started.
The time the incident ended.
The time the incident was reported.
A free form textual description of the incident.
A characterization of the impact of the incident.
The techniques used by the intruder in the incident.
Contact information for the parties involved in the incident.
Description of the events comprising the incident.
A log of significant events or actions that occurred during the course of handling the incident.
Mechanism by which to extend the data model.
The Incident class has four attributes: purpose Required.
The purpose attribute represents the reason why the IODEF document was created.
It is closely related to the Expectation class (Section 3.13).
This attribute is defined as an enumerated list: 1.
The document was sent for trace back purposes.
The document was sent to request aid in mitigating the described activity.
The document was sent to comply with reporting requirements.
The document was sent for purposes specified in the Expectation class.
An escape value used to extend this attribute.
A means by which to extend the purpose attribute.
A valid language code per RFC 4646 [7] constrained by the definition of "xs:language".
The interpretation of this code is described in Section 6.
This attribute indicates the disclosure guidelines to which the sender expects the recipient to adhere for the information represented in this class and its children.
This guideline provides no security since there are no specified technical means to ensure that the recipient of the document handles the information as the sender requested.
The value of this attribute is logically inherited by the children of this class.
That is to say, the disclosure rules applied to this class, also apply to its children.
It is possible to set a granular disclosure policy, since all of the high level classes (i.e., children of the Incident class) have a restriction attribute.
Therefore, a child can override the guidelines of a parent class, be it to restrict or relax the disclosure rules
(e.g., a child has a weaker policy than an ancestor; or an ancestor has a weak policy, and the children selectively apply more rigid controls).
The implicit value of the restriction attribute for a class that did not specify one can be found in the closest ancestor that did specify a value.
This attribute is defined as an enumerated value with a default value of "private".
Note that the default value of the restriction attribute is only defined in the context of the Incident class.
In other classes where this attribute is used, no default is specified.
There are no restrictions placed in the information.
The information may be shared with other parties that are involved in the incident as determined by the recipient of this document (e.g., multiple victim sites can be informed of each other).
The information may not be shared.
The information can be shared according to an information disclosure policy pre arranged by the communicating parties.
The IncidentID class represents an incident tracking number that is unique in the context of the CSIRT and identifies the activity characterized in an IODEF Document.
This identifier would serve as an index into the CSIRT incident handling system.
The combination of the name attribute and the string in the element content MUST be a globally unique identifier describing the activity.
Documents generated by a given CSIRT MUST NOT reuse the same value unless they are referencing the same incident.
The IncidentID class has three attributes: name Required.
An identifier describing the CSIRT that created the document.
In order to have a globally unique CSIRT name, the fully qualified domain name associated with the CSIRT MUST be used.
An identifier referencing a subset of the named incident.
This attribute has been defined in Section 3.2.
The AlternativeID class lists the incident tracking numbers used by CSIRTs, other than the one generating the document, to refer to the identical activity described the IODEF document.
A tracking number listed as an AlternativeID references the same incident detected by another CSIRT.
The incident tracking numbers of the CSIRT that generated the IODEF document should never be considered an AlternativeID.
The aggregate class that constitutes AlternativeID is: IncidentID One or more.
The incident tracking number of another CSIRT.
The AlternativeID class has one attribute: restriction Optional.
This attribute has been defined in Section 3.2.
RelatedActivity Class The RelatedActivity class lists either incident tracking numbers of incidents or URLs (not both) that refer to activity related to the one described in the IODEF document.
These references may be to local incident tracking numbers or to those of other CSIRTs.
The specifics of how a CSIRT comes to believe that two incidents are related are considered out of scope.
The aggregate classes that constitutes RelatedActivity are: IncidentID One or more.
The incident tracking number of a related incident.
A URL to activity related to this incident.
The RelatedActivity class has one attribute: restriction Optional.
This attribute has been defined in Section 3.2.
The AdditionalData class serves as an extension mechanism for information not otherwise represented in the data model.
For relatively simple information, atomic data types (e.g., integers, strings) are provided with a mechanism to annotate their meaning.
The class can also be used to extend the data model (and the associated Schema) to support proprietary extensions by encapsulating entire XML documents conforming to another Schema (e.g., IDMEF).
A detailed discussion for extending the data model and the schema can be found in Section 5.
Unlike XML, which is self describing, atomic data must be documented to convey its meaning.
This information is described in the 'meaning' attribute.
Since these description are outside the scope of the specification, some additional coordination may be required to ensure that a recipient of a document using the AdditionalData classes can make sense of the custom extensions.
The AdditionalData Class The AdditionalData class has five attributes: dtype Required.
The data type of the element content.
The permitted values for this attribute are shown below.
The default value is "string".
The element content is of type BOOLEAN.
The element content is of type BYTE.
The element content is of type CHARACTER.
The element content is of type DATETIME.
The element content is of type INTEGER.
The element content is of type PORTLIST.
The element content is of type REAL.
The element content is of type STRING.
The element content is a base64 encoded binary file encoded as a BYTE[] type.
The element content is a layer 2 frame encoded as a HEXBIN type.
The element content is a layer 3 packet encoded as a HEXBIN type.
The element content is an IPv4 packet encoded as a HEXBIN type.
The element content is an IPv6 packet encoded as a HEXBIN type.
The element content is a file system path encoded as a STRING type.
The element content is of type URL.
The element content is a common separated value (CSV) list per Section 2 of [20] encoded as a STRING type.
The element content is a Windows registry key encoded as a STRING type.
The element content is XML (see Section 5).
An escape value used to extend this attribute.
A means by which to extend the dtype attribute.
A free form description of the element content.
An identifier referencing the format and semantics of the element content.
This attribute has been defined in Section 3.2. 3.7.
The Contact class describes contact information for organizations and personnel involved in the incident.
This class allows for the naming of the involved party, specifying contact information for them, and identifying their role in the incident.
People and organizations are treated interchangeably as contacts; one can be associated with the other using the recursive definition of the class (the Contact class is aggregated into the Contact class).
The 'type' attribute disambiguates the type of contact information being provided.
The inheriting definition of Contact provides a way to relate information without requiring the explicit use of identifiers in the classes or duplication of data.
A complete point of contact is derived by a particular traversal from the root Contact class to the leaf Contact class.
As such, multiple points of contact might be specified in a single instance of a Contact class.
Each child Contact class logically inherits contact information from its ancestors.
The aggregate classes that constitute the Contact class are: ContactName Zero or one.
The name of the contact.
The contact may either be an organization or a person.
The type attribute disambiguates the semantics.
A free form description of this contact.
In the case of a person, this is often the organizational title of the individual.
A handle name into the registry of the contact.
The postal address of the contact.
The email address of the contact.
The telephone number of the contact.
The facsimile telephone number of the contact.
The timezone in which the contact resides formatted according to Section 2.9.
A Contact instance contained within another Contact instance inherits the values of the parent(s).
This recursive definition can be used to group common data pertaining to multiple points of contact and is especially useful when listing multiple contacts at the same organization.
A mechanism by which to extend the data model.
At least one of the aggregate classes MUST be present in an instance of the Contact class.
This is not enforced in the IODEF schema as there is no simple way to accomplish it.
The Contact class has five attributes: role Required.
Indicates the role the contact fulfills.
This attribute is defined as an enumerated list: 1.
The entity that generate the document.
An administrative contact for a host or network.
A technical contact for a host or network.
The CSIRT involved in handling the incident.
An entity that is to be kept informed about the handling of the incident.
An escape value used to extend this attribute.
A means by which to extend the role attribute.
Indicates the type of contact being described.
This attribute is defined as an enumerated list: 1.  person.
The information for this contact references an individual.
The information for this contact references an organization.
An escape value used to extend this attribute.
A means by which to extend the type attribute.
This attribute is defined in Section 3.2.
The RegistryHandle class represents a handle into an Internet registry or community specific database.
The handle is specified in the element content and the type attribute specifies the database.
: The RegistryHandle Class The RegistryHandle class has two attributes: registry Required.
The database to which the handle belongs.
The default value is 'local'.
The possible values are: 1.
Internet Network Information Center 2.
Asia Pacific Network Information Center 3.
American Registry for Internet Numbers 4.
Latin American and Caribbean IP Address Registry 5.
African Internet Numbers Registry 7.
A database local to the CSIRT 8.
An escape value used to extend this attribute.
A means by which to extend the registry attribute.
The PostalAddress class specifies a postal address formatted according to the POSTAL data type (Section 2.11).
The PostalAddress class has two attributes: meaning Optional.
A free form description of the element content.
A valid language code per RFC 4646 [7] constrained by the definition of "xs:language".
The interpretation of this code is described in Section 6.
The Email class specifies an email address formatted according to EMAIL data type (Section 2.14).
The Email class has one attribute: meaning Optional.
A free form description of the element content.
The Telephone and Fax classes specify a voice or fax telephone number respectively, and are formatted according to PHONE data type (Section 2.13).
The Telephone and Fax Classes
The Telephone class has one attribute: meaning Optional.
A free form description of the element content (e.g., hours of coverage for a given number).
The data model uses five different classes to represent a timestamp.
Their definition is identical, but each has a distinct name to convey a difference in semantics.
The element content of each class is a timestamp formatted according to the DATETIME data type (see Section 2.8).
: The Time Classes 3.8.1.
The StartTime class represents the time the incident began.
The EndTime class represents the time the incident ended.
The DetectTime class represents the time the first activity of the incident was detected.
The ReportTime class represents the time the incident was reported.
This timestamp SHOULD coincide to the time at which the IODEF document is generated.
The DateTime class is a generic representation of a timestamp.
Its semantics should be inferred from the parent class in which it is aggregated.
The Method class describes the methodology used by the intruder to perpetrate the events of the incident.
This class consists of a list of references describing the attack method and a free form description of the technique.
The Method class is composed of three aggregate classes.
A reference to a vulnerability, malware sample, advisory, or analysis of an attack technique.
A free form text description of the methodology used by the intruder.
A mechanism by which to extend the data model.
Either an instance of the Reference or Description class MUST be present.
The Method class has one attribute: restriction Optional.
This attribute is defined in Section 3.2.
The Reference class is a reference to a vulnerability, IDS alert, malware sample, advisory, or attack technique.
A reference consists of a name, a URL to this reference, and an optional description.
The aggregate classes that constitute Reference: ReferenceName One.
A URL associated with the reference.
A free form text description of this reference.
The Assessment class describes the technical and non technical repercussions of the incident on the CSIRT's constituency.
This class was derived from the IDMEF[17].
The aggregate classes that constitute Assessment are: Impact Zero or many.
Technical impact of the incident on a network.
Impact of the activity measured with respect to time.
Impact of the activity measured with respect to financial loss.
A counter with which to summarize the magnitude of the activity.
An estimate of confidence in the assessment.
A mechanism by which to extend the data model.
A least one instance of the possible three impact classes (i.e., Impact, TimeImpact, or MonetaryImpact) MUST be present.
The Assessment class has two attributes: occurrence Optional.
Specifies whether the assessment is describing actual or potential outcomes.
The default is "actual" and is assumed if not specified.
This assessment describes activity that has occurred.
This assessment describes potential activity that might occur.
This attribute is defined in Section 3.2.
The Impact class allows for categorizing and describing the technical impact of the incident on the network of an organization.
This class is based on the IDMEF [17].
The element content will be a free form textual description of the impact.
The Impact class has five attributes:
A valid language code per RFC 4646 [7] constrained by the definition of "xs:language".
The interpretation of this code is described in Section 6.
An estimate of the relative severity of the activity.
The permitted values are shown below.
There is no default value.
An indication whether the described activity was successful.
The permitted values are shown below.
There is no default value.
The attempted activity was not successful.
Classifies the malicious activity into incident categories.
The permitted values are shown below.
The default value is "other".
A denial of service was attempted.
An action that impacts the integrity of a file or database was attempted.
An attempt was made to exfiltrate information.
An attempt was made to exploit a mis  configuration in a system.
Activity violating site's policy was attempted.
A social engineering attack was attempted.
The classification of this activity is unknown.
An escape value used to extend this attribute.
A means by which to extend the type attribute.
The TimeImpact class describes the impact of the incident on an organization as a function of time.
It provides a way to convey down time and recovery time.
The element content is a positive, floating point (REAL) number specifying a unit of time.
The duration and metric attributes will imply the semantics of the element content.
The TimeImpact class has five attributes: severity Optional.
An estimate of the relative severity of the activity.
The permitted values are shown below.
There is no default value.
Defines the metric in which the time is expressed.
The permitted values are shown below.
There is no default value.
Total staff time to recovery from the activity (e.g., 2 employees working 4 hours each would be 8 hours).
Elapsed time from the beginning of the recovery to its completion (i.e., wall clock time).
Duration of time for which some provided service(s) was not available.
An escape value used to extend this attribute.
A means by which to extend the metric attribute.
Defines a unit of time
, that when combined with the metric attribute, fully describes a metric of impact that will be conveyed in the element content.
The permitted values are shown below.
The default value is "hour".
The unit of the element content is seconds.
The unit of the element content is minutes.
The unit of the element content is hours.
The unit of the element content is days.
The unit of the element content is months.
The unit of the element content is quarters.
The unit of the element content is years.
An escape value used to extend this attribute.
A means by which to extend the duration attribute.
The MonetaryImpact class describes the financial impact of the activity on an organization.
For example, this impact may consider losses due to the cost of the investigation or recovery, diminished productivity of the staff, or a tarnished reputation that will affect future opportunities.
The element content is a positive, floating point number (REAL) specifying a unit of currency described in the currency attribute.
The MonetaryImpact class has two attributes: severity Optional.
An estimate of the relative severity of the activity.
The permitted values are shown below.
There is no default value.
Defines the currency in which the monetary impact is expressed.
The permitted values are defined in ISO 4217:2001, Codes for the representation of currencies and funds [14].
There is no default value.
The Confidence class represents a best estimate of the validity and accuracy of the described impact (see Section 3.10) of the incident activity.
This estimate can be expressed as a category or a numeric calculation.
This class if based upon the IDMEF [17]).
The element content expresses a numerical assessment in the confidence of the data when the value of the rating attribute is "numeric".
Otherwise, this element should be empty.
The Confidence class has one attribute.
A rating of the analytical validity of the specified Assessment.
The permitted values are shown below.
There is no default value.
Low confidence in the validity.
Medium confidence in the validity.
High confidence in the validity.
The element content contains a number that conveys the confidence of the data.
The semantics of this number outside the scope of this specification.
The History class is a log of the significant events or actions performed by the involved parties during the course of handling the incident.
The level of detail maintained in this log is left up to the discretion of those handling the incident.
The class that constitutes History is: HistoryItem One or many.
Entry in the history log of significant events or actions performed by the involved parties.
The History class has one attribute: restriction Optional.
This attribute is defined in Section 3.2.
The HistoryItem class is an entry in the History (Section 3.11) log that documents a particular action or event that occurred in the course of handling the incident.
The details of the entry are a free form description, but each can be categorized with the type attribute.
The aggregate classes that constitute HistoryItem are: DateTime One.
Timestamp of this entry in the history log (e.g., when the action described in the Description was taken).
In a history log created by multiple parties, the IncidentID provides a mechanism to specify which CSIRT created a particular entry and references this organization's incident tracking number.
When a single organization is maintaining the log, this class can be ignored.
Provides contact information for the person that performed the action documented in this class.
A free form textual description of the action or event.
A mechanism by which to extend the data model.
The HistoryItem class has three attributes: restriction Optional.
This attribute has been defined in Section 3.2.
Classifies a performed action or occurrence documented in this history log entry.
As activity will likely have been instigated either through a previously conveyed expectation or internal investigation, this attribute is identical to the category attribute of the Expectation class.
The difference is only one of tense.
When an action is in this class, it has been completed.
A means by which to extend the action attribute.
The EventData class describes a particular event of the incident for a given set of hosts or networks.
This description includes the systems from which the activity originated and those targeted, an assessment of the techniques used by the intruder, the impact of the activity on the organization, and any forensic evidence discovered.
The aggregate classes that constitute EventData are: Description Zero or more.
A free form textual description of the event.
The time the event was detected.
The time the event started.
The time the event ended.
Contact information for the parties involved in the event.
The impact of the event on the target and the actions taken.
The technique used by the intruder in the event.
A description of the systems or networks involved.
The expected action to be performed by the recipient for the described event.
Supportive data (e.g., log files) that provides additional information about the event.
EventData instances contained within another EventData instance inherit the values of the parent(s); this recursive definition can be used to group common data pertaining to multiple events.
When EventData elements are defined recursively, only the leaf instances (those EventData instances not containing other EventData instances) represent actual events.
An extension mechanism for data not explicitly represented in the data model.
At least one of the aggregate classes MUST be present in an instance of the EventData class.
This is not enforced in the IODEF schema as there is no simple way to accomplish it.
The EventData class has one attribute: restriction Optional.
This attribute is defined in Section 3.2.
Relating the Incident and EventData Classes
There is substantial overlap in the Incident and EventData classes.
Nevertheless, the semantics of these classes are quite different.
The Incident class provides summary information about the entire incident, while the EventData class provides information about the individual events comprising the incident.
In the most common case, the EventData class will provide more specific information for the general description provided in the Incident class.
However, it may also be possible that the overall summarized information about the incident conflicts with some individual information in an EventData class when there is a substantial composition of various events in the incident.
In such a case, the interpretation of the more specific EventData MUST supersede the more generic information provided in IncidentData.
The EventData class can be thought of as a container for the properties of an event in an incident.
These properties include: the hosts involved, impact of the incident activity on the hosts, forensic logs, etc.
With an instance of the EventData class, hosts (i.e., System class) are grouped around these common properties.
The recursive definition (or instance property inheritance) of the EventData class (the EventData class is aggregated into the EventData class) provides a way to related information without requiring the explicit use of unique attribute identifiers in the classes or duplicating information.
Instead, the relative depth (nesting) of a class is used to group (relate) information.
For example, an EventData class might be used to describe two machines involved in an incident.
This description can be achieved using multiple instances of the Flow class.
It happens that there is a common technical contact (i.e., Contact class) for these two machines, but the impact (i.e., Assessment class) on them is different.
A depiction of the representation for this situation can be found in Figure 23.
Recursion in the EventData Class 3.13.
The Expectation class conveys to the recipient of the IODEF document the actions the sender is requesting.
The scope of the requested action is limited to purview of the EventData class in which this class is aggregated.
The aggregate classes that constitute Expectation are: Description Zero or many.
A free form description of the desired action(s).
The time at which the action should be performed.
A timestamp that is earlier than the ReportTime specified in the Incident class denotes that the expectation should be fulfilled as soon as possible.
The absence of this element leaves the execution of the expectation to the discretion of the recipient.
The time by which the action should be completed.
If the action is not carried out by this time, it should no longer be performed.
The expected actor for the action.
The Expectations class has four attributes: restriction Optional.
This attribute is defined in Section 3.2.
Indicates the desired priority of the action.
This attribute is an enumerated list with no default value, and the semantics of these relative measures are context dependent.
Classifies the type of action requested.
This attribute is an enumerated list with no default value.
Do nothing with the information.
Contact the site(s) identified as the source of the activity.
Contact the site(s) identified as the target of the activity.
Contact the originator of the document.
Block traffic from the machine(s) listed as sources the event.
Block traffic from the network(s) lists as sources in the event.
Block the port listed as sources in the event.
Rate limit the traffic from the machine(s) listed as sources in the event.
Rate limit the traffic from the network(s) lists as sources in the event.
the port(s) listed as sources in the event.
Remediate the activity in a way other than by rate limiting or blocking.
Conveys receipts and the triaging of an incident.
Conveys that new information was received for this incident.
Perform some custom action described in the Description class.
An escape value used to extend this attribute.
A means by which to extend the action attribute.
The Flow class groups related the source and target hosts.
The aggregate class that constitutes Flow is: System One or More.
A host or network involved in an event.
The Flow System class has no attributes.
The System class describes a system or network involved in an event.
The systems or networks represented by this class are categorized according to the role they played in the incident through the category attribute.
The value of this category attribute dictates the semantics of the aggregated classes in the System class.
If the category attribute has a value of "source", then the aggregated classes denote the machine and service from which the activity is originating.
With a category attribute value of "target" or "intermediary", then the machine or service is the one targeted in the activity.
A value of "sensor" dictates that this System was part of an instrumentation to monitor the network.
The aggregate classes that constitute System are: Node One.
A host or network involved in the incident.
A network service running on the system.
The operating system running on the system.
A counter with which to summarize properties of this host or network.
A free form text description of the System.
A mechanism by which to extend the data model.
The System class has five attributes: restriction Optional.
This attribute is defined in Section 3.2.
the role the host or network played in the incident.
The possible values are: 1.  source.
The System was the source of the event.
The System was the target of the event.
The System was an intermediary in the event.
The System was a sensor monitoring the event.
The System was an infrastructure node of IODEF document exchange.
An escape value used to extend this attribute.
A means by which to extend the category attribute.
Specifies the interface on which the event(s) on this System originated.
If the Node class specifies a network rather than a host, this attribute has no meaning.
An indication of confidence in whether this System was the true target or attacking host.
The permitted values for this attribute are shown below.
The default value is "unknown".
The accuracy of the category attribute value is unknown.
The category attribute value is probably incorrect.
In the case of a source, the System is likely a decoy; with a target, the System was likely not the intended victim.
The category attribute value is believed to be correct.
The Node class names a system (e.g., PC, router) or network.
This class was derived from the IDMEF [17].
The aggregate classes that constitute Node are: NodeName Zero or more.
The name of the Node (e.g., fully qualified domain name).
This information MUST be provided if no Address information is given.
The hardware, network, or application address of the Node.
If a NodeName is not provided, at least one Address MUST be specified.
A free from description of the physical location of the equipment.
A timestamp of when the resolution between the name and address was performed.
This information SHOULD be provided if both an Address and NodeName are specified.
The intended purpose of the Node.
A counter with which to summarizes properties of this host or network.
The Counter class summarize multiple occurrences of some event, or conveys counts or rates on various features (e.g., packets, sessions, events).
The value of the counter is the element content with its units represented in the type attribute.
A rate for a given feature can be expressed by setting the duration attribute.
The complete semantics are entirely context dependent based on the class in which the Counter is aggregated.
: The Counter Class The Counter class has three attribute: type Required.
Specifies the units of the element content.
Count of flow (e.g., NetFlow records).
Count of notifications generated by another system (e.g., IDS or SIM).
Count of messages (e.g., mail messages).
An escape value used to extend this attribute.
A means by which to extend the type attribute.
If present, the Counter class represents a rate rather than a count over the entire event.
In that case, this attribute specifies the denominator of the rate (where the type attribute specified the nominator).
The possible values of this attribute are defined in Section 3.10.2 ext duration Optional.
A means by which to extend the duration attribute.
The Address class represents a hardware (layer 2), network (layer 3), or application (layer 7) address.
This class was derived from the IDMEF [17].
The Address Class The Address class has four attributes: category Required.
The type of address represented.
The permitted values for this attribute are shown below.
The default value is "ipv4 addr".
Asynchronous Transfer Mode (ATM) address 3.
Electronic mail address (RFC 822) 4.
IPv4 host address in dotted decimal notation (a.b.c.d) 5.
IPv4 network address in dotted decimal notation, slash, significant bits (
IPv4 network address in dotted decimal notation, slash, network mask in dotted decimal notation (a.b.c.d
IPv6 network address, slash, significant bits 9.
IPv6 network address, slash, network mask 10.
Media Access Control (MAC) address 11.
An escape value used to extend this attribute.
A means by which to extend the category attribute.
The name of the Virtual LAN to which the address belongs.
The number of the Virtual LAN to which the address belongs.
The NodeRole class describes the intended function performed by a particular host.
The NodeRole class has three attributes: category Required.
Functionality provided by a node.
Server with internal services 3.
Server with public services 4.
Messaging server (e.g., NNTP, IRC, IM) 7.
Voice server (e.g., SIP, H.323) 9.
File server (e.g., SMB, CVS, AFS) 10.
Peer to peer node 12.
Name server (e.g., DNS, WINS)
Directory server (e.g., LDAP, finger, whois) 14.
Credential server (e.g., domain controller, Kerberos) 15.
Infrastructure server (e.g., router, firewall, DHCP) 19.
An escape value used to extend this attribute.
A means by which to extend the category attribute.
A valid language code per RFC 4646 [7] constrained by the definition of "xs:language".
The interpretation of this code is described in Section 6. 3.17.
The Service class describes a network service of a host or network.
The service is identified by specific port or list of ports, along with the application listening on that port.
When Service occurs as an aggregate class of a System that is a source, then this service is the one from which activity of interest is originating.
Conversely, when Service occurs as an aggregate class of a System that is a target, then that service is the one to which activity of interest is directed.
This class was derived from the IDMEF [17].
The aggregate classes that constitute Service are: Port Zero or one.
A list of port numbers formatted according to Section 2.10.
A layer 4 protocol specific code field (e.g., ICMP code field).
A layer 4 protocol specific type field (e.g., ICMP type field).
A layer 4 protocol specific flag field (e.g., TCP flag field).
The application bound to the specified Port or Portlist.
Either a Port or Portlist class MUST be specified for a given instance of a Service class.
For a given source, System@type "source", a corresponding target, System@type "target", maybe defined, or vice versa.
When a Portlist class is defined in the Service class of both the source and target in a given instance of the Flow class, there MUST be symmetry in the enumeration of the ports.
Thus, if n ports are listed for a source, n ports should be listed for the target.
Likewise, the ports should be listed in an identical sequence such that the n th port in the source corresponds to the n th port of the target.
This symmetry in listing and sequencing of ports applies whether there are 1 to 1, 1 to many, or many to many sources to targets.
In the 1 to many or many to many, the exact order in which the System classes are enumerated in the Flow class is significant.
The Service class has one attribute: ip protocol Required.
The Application class describes an application running on a System providing a Service.
The aggregate class that constitutes Application is: URL Zero or one.
A URL describing the application.
The Application class has seven attributes: swid Optional.
An identifier that can be used to reference this software.
An identifier that can be used to reference a particular configuration of this software.
Vendor name of the software.
Patch or service pack level of the software.
The OperatingSystem class describes the operating system running on a System.
The definition is identical to the Application class (Section 3.17.1).
The Record class is a container class for log and audit data that provides supportive information about the incident.
The source of this data will often be the output of monitoring tools.
These logs should substantiate the activity described in the document.
The aggregate class that constitutes Record is: RecordData One or more.
Log or audit data generated by a particular type of sensor.
Separate instances of the RecordData class SHOULD be used for each sensor type.
The Record class has one attribute: restriction Optional.
This attribute has been defined in Section 3.2.
The RecordData class groups log or audit data from a given sensor (e.g., IDS, firewall log) and provides a way to annotate the output.
The aggregate classes that constitutes RecordData is: DateTime Zero or one.
Timestamp of the RecordItem data.
Free form textual description of the provided RecordItem data.
At minimum, this description should convey the significance of the provided RecordItem data.
Information about the sensor used to generate the RecordItem data.
A search string to precisely find the relevant data in a RecordItem.
Log, audit, or forensic data.
An extension mechanism for data not explicitly represented in the data model.
The RecordData class has one attribute: restriction Optional.
This attribute has been defined in Section 3.2.
The RecordPattern class describes where in the content of the RecordItem relevant information can be found.
It provides a way to reference subsets of information, identified by a pattern, in a large log file, audit trail, or forensic data.
The specific pattern to search with in the RecordItem is defined in the body of the element.
It is further annotated by four attributes: type Required.
Describes the type of pattern being specified in the element content.
regular expression, per Appendix F of [3].
Binhex encoded binary pattern, per the HEXBIN data type.
An escape value used to extend this attribute.
A means by which to extend the type attribute.
Amount of units (determined by the offsetunit attribute) to seek into the RecordItem data before matching the pattern.
Describes the units of the offset attribute.
Offset is a count of lines.
Offset is a count of bytes.
An escape value used to extend this attribute.
A means by which to extend the offsetunit attribute.
Number of types to apply the specified pattern.
The RecordItem class provides a way to incorporate relevant logs, audit trails, or forensic data to support the conclusions made during the course of analyzing the incident.
The class supports both the direct encapsulation of the data, as well as, provides primitives to reference data stored elsewhere.
This class is identical to AdditionalData class (Section 3.6).
This section defines additional requirements on creating and parsing IODEF documents.
Every IODEF document MUST begin with an XML declaration, and MUST specify the XML version used.
If UTF 8 encoding is not used, the character encoding MUST also be explicitly specified.
The IODEF conforms to all XML data encoding conventions and constraints.
The XML declaration with no character encoding will read as follows: <?
> When a character encoding is specified, the XML declaration will read like the following: <?
xml version "1.0" encoding "charset" ?
Where "charset" is the name of the character encoding as registered with the Internet Assigned Numbers Authority (IANA), see [9].
The IODEF schema declares a namespace of "urn:ietf:
ns:iodef 1.0" and registers it per [4].
Each IODEF document SHOULD include a valid reference to the IODEF schema using the "xsi:schemaLocation" attribute.
An example of such a declaration would look as follows:
<IODEF Document version "1.00" lang "en US" xmlns:
The IODEF documents MUST be well formed XML and SHOULD be validated against the schema described in Section 8.
However, mere conformance to the schema is not sufficient for a semantically valid IODEF document.
There is additional specification in the text of Section 3 that cannot be readily encoded in the schema and it must also be considered by an IODEF parser.
The following is a list of discrepancies in what is more strictly specified in the normative text (Section 3), but not enforced in the IODEF schema:
The elements or attributes that are defined as POSTAL, NAME, PHONE, and EMAIL data types are implemented as "xs:string", but more rigid formatting requirements are specified in the text.
The IODEF Document@lang and MLStringType@lang attributes are declared as an "xs:language" that constrains values with a regular expression.
However, the value of this attribute still needs to be validated against the list of possible enumerated values is defined in [7].
The MonetaryImpact@currency attribute is declared as an "xs: string", but the list of valid values as defined in [14].
All of the aggregated classes Contact and EventData are optional in the schema, but at least one of these aggregated classes MUST be present.
There are multiple conventions that can be used to categorize a system using the NodeRole class or to specify software with the Application and OperatingSystem classes.
IODEF parsers MUST accept incident reports that do not use these fields in accordance with local conventions.
The Confidence@rating attribute determines whether the element content of Confidence should be empty.
The Address@type attribute determines the format of the element content.
The attributes AdditionalData@dtype and RecordItem@dtype derived from iodef:ExtensionType determine the semantics and formatting of the element content.
Symmetry in the enumerated ports of a Portlist class is required between sources and targets.
In order to support the changing activity of CSIRTS, the IODEF data model will need to evolve along with them.
This section discusses how new data elements that have no current representation in the data model can be incorporated into the IODEF.
These techniques are designed so that adding new data will not require a change to the IODEF schema.
With proven value, well documented extensions can be incorporated into future versions of the specification.
However, this approach also supports private extensions relevant only to a closed consortium.
Extending the Enumerated Values of Attributes
The data model supports a means by which to add new enumerated values to an attribute.
For each attribute that supports this extension technique, there is a corresponding attribute in the same element whose name is identical, less a prefix of "ext ".
This special attribute is referred to as the extension attribute, and the attribute being extended is referred to as an extensible attribute.
For example, an extensible attribute named "foo" will have a corresponding extension attribute named "ext foo".
An element may have many extensible, and therefore many extension, attributes.
In addition to a corresponding extension attribute, each extensible attribute has "ext value" as one its possible values.
This particular value serves as an escape sequence and has no valid meaning.
In order to add a new enumerated value to an extensible attribute, the value of this attribute MUST be set to "ext value", and the new desired value MUST be set in the corresponding extension attribute.
For example, an extended instance of the type attribute of the Impact class would look as follows:
<Impact type "ext value" ext type "new attack type">
A given extension attribute MUST NOT be set unless the corresponding extensible attribute has been set to "ext value".
The classes of the data model can be extended only through the use of the AdditionalData and RecordItem classes.
These container classes, collectively referred to as the extensible classes, are implemented with the iodef:ExtensionType data type in the schema.
They provide the ability to have new atomic or XML encoded data elements in all of the top level classes of the Incident class and a few of the more complicated subordinate classes.
As there are multiple instances of the extensible classes in the data model, there is discretion on where to add a new data element.
It is RECOMMENDED that the extension be placed in the most closely related class to the new information.
Extensions using the atomic data types (i.e., all values of the dtype attributes other than "xml") MUST:
Set the element content of extensible class to the desired value, and 2.
Set the dtype attribute to correspond to the data type of the element content.
The following guidelines exist for extensions using XML: 1.
The element content of the extensible class MUST be set to the desired value and the dtype attribute MUST be set to "xml".
The extension schema MUST declare a separate namespace.
It is RECOMMENDED that these extensions have the prefix "iodef ".
It is RECOMMENDED that extension schemas follow the naming convention of the IODEF data model.
The names of all elements are capitalized.
For composed names, a capital letter is used for each word.
Attribute names are lower case.
When a parser encounters an IODEF document with an extension it does not understand, this extension MUST be ignored (and not processed), but the remainder of the document MUST be processed.
Parsers will be able to identify these extensions for which they have no processing logic through the namespace declaration.
Parsers that encounter an unrecognized element in a namespace that they do support SHOULD reject the document as a syntax error.
Implementations SHOULD NOT download schemas at runtime due to the security implications, and extensions MUST NOT be required to provide a resolvable location of their schema.
The following schema and XML document excerpt provide a template for an extension schema and its use in the IODEF document.
This example schema defines a namespace of "iodef extension1" and a single element named "newdata".
iodef 1.0" schemaLocation " urn:ietf:params:xml:schema:
> <xs:element name "newdata" type "xs:string" /
The following XML excerpt demonstrates the use of the above schema as an extension to the IODEF.
<IODEF Document version "1.00" lang "en US" xmlns "urn:ietf:params:xml:
ns:iodef 1.0" xmlns:iodef " urn:ietf:params:xml:
ns:iodef 1.0" xmlns:iodef extension1 "iodef
<AdditionalData dtype "xml" meaning "xml"> <
> Field that could not be represented elsewhere </iodef extension1:
Internationalization Issues Internationalization and localization is of specific concern to the IODEF, since it is only through collaboration, often across language barriers, that certain incidents be resolved.
The IODEF supports this goal by depending on XML constructs, and through explicit design choices in the data model.
Since IODEF is implemented as an XML Schema, it implicitly supports all the different character encodings, such as UTF 8 and UTF 16, possible with XML.
Additionally, each IODEF document MUST specify the language in which their contents are encoded.
The language can be specified with the attribute "xml:lang" (per Section 2.12 of [1]) in the top level element (i.e., IODEF Document@lang) and letting all other elements inherit that definition.
All IODEF classes with a free form text definition (i.e., all those defined of type iodef:
MLStringType) can also specify a language different from the rest of the document.
The valid language codes for the "xml:
lang" attribute are described in RFC 4646 [7].
The data model supports multiple translations of free form text.
In the places where free text is used for descriptive purposes, the given class always has a one to many cardinality to its parent (e.g., Description class).
The intent is to allow the identical text to be encoded in different instances of the same class, but each being in a different language.
This approach allows an IODEF document author to send recipients speaking different languages an identical document.
The IODEF parser SHOULD extract the appropriate language relevant to the recipient.
While the intent of the data model is to provide internationalization and localization, the intent is not to do so at the detriment of interoperability.
While the IODEF does support different languages, the data model also relies heavily on standardized enumerated attributes that can crudely approximate the contents of the document.
With this approach, a CSIRT should be able to make some sense of an IODEF document it receives even if the text based data elements are written in a language unfamiliar to the analyst.
This section provides examples of an incident encoded in the IODEF.
These examples do not necessarily represent the only way to encode a particular incident.
An example of a CSIRT reporting an instance of the Code Red worm. <?
xml version "1.0" encoding "UTF 8"?
ns:iodef 1.0" xmlns:xsi "http://www.w3.org/2001/XMLSchema instance" xsi:schemaLocation
iodef 1.0"> <Incident purpose "reporting">
<Description>Host sending out Code Red probes</Description> <!
An administrative privilege was attempted, but failed
> <Impact completion "failed" type "admin"/
> <Contact role "creator" type "organization"> <ContactName>
ipv4 addr">192.0.2.200</Address> <Counter type "event">57</Counter> </Node
> </System> <System category "target"
> <Service ip protocol "6"
<RecordItem> has an excerpt from a log
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX </RecordItem
Contact was previously made with the source network owner   <HistoryItem action "contact source site"> <DateTime>2001 09
>Notification sent to constituency contact@192.0.2.200</Description
An example of a CSIRT reporting a scanning activity. <?
xml version "1.0" encoding "UTF 8" ?
This example describes reconnaissance activity: one to one and one to many scanning
<IODEF Document version "1.00" lang "en" xmlns "urn:ietf:params:xml:
ns:iodef 1.0" xmlns:xsi "http://www.w3.org/2001/XMLSchema instance" xsi:schemaLocation
iodef 1.0"> <Incident purpose "reporting"> <IncidentID name "
> <Assessment> <Impact type "recon" completion "succeeded" /
Organizational contact and that for staff in that organization   <Contact role "creator" type "organization"
Since this <Contact> is nested, Joe Smith is part of the CSIRT for example.com
<Contact role "tech" type "person" restriction "need to know"> <ContactName>
> <Service ip protocol "6"> <Portlist>60524,60526,60527,60531</Portlist> </Service
> </System> <System category "target"
> <Service ip protocol "6"
<Address category "ipv4 addr">192.0.2.240</Address> </Node
> </System> <System category "target"
> <Service ip protocol "6"> <Port>445</Port> </Service
An example of a CSIRT reporting a bot network.
xml version "1.0" encoding "UTF 8" ?
This example describes a compromise and subsequent installation of bots
<IODEF Document version "1.00" lang "en" xmlns "urn:ietf:params:xml:
ns:iodef 1.0" xmlns:xsi "http://www.w3.org/2001/XMLSchema instance" xsi:schemaLocation
"urn:ietf:params:xml:schema:iodef 1.0"> <Incident purpose "mitigation"> <IncidentID name "
Large bot net</Description> <Assessment> <Impact type "dos" severity "high" completion "succeeded" /
References the vulnerability used to compromise the machines
> <ReferenceName>CA 2003 22</ReferenceName> <URL>
<Description>Root compromise via this IE vulnerability to install the GT Bot</Description
A member of the CSIRT that is coordinating this incident
<Contact type "person" role "irt"
These hosts are compromised and acting as bots communicating with irc.example.com.</Description>
bot running on 192.0.2.1 and sending DoS traffic at 10,000 bytes/second   <System category "source"> <Node>
<Counter type "byte" duration "second">10000</Counter> <Description
a second bot on 192.0.2.3
> <Counter type "byte" duration "second">250000</Counter>
Command and control IRC server for these bots
> <DateTime>2006 06 08T01:01:03 05:00</DateTime
<Description>IRC server on #give me cmd channel</Description
Request to take these machines offline
Confirm the source and take machines off line and remediate</Description>
An example of a CSIRT conveying a watch list.
xml version "1.0" encoding "UTF 8" ?
@formatid is set to "watch list 043" to demonstrate how additional semantics about this document could be conveyed assuming both parties understood it
<IODEF Document version "1.00" lang "en" formatid "watch list 043
ns:iodef 1.0" xmlns:xsi "http://www.w3.org/2001/XMLSchema instance" xsi:schemaLocation
"> <Incident purpose "reporting" restriction "private"> <IncidentID name "csirt.example.com">908711</IncidentID
<Description>Watch list of known bad IPs or networks</Description> <Assessment> <Impact type "admin" completion "succeeded" /
> <Contact type "organization" role "creator"
> used to convey different <Expectation
>Source of numerous attacks</Description> </System
Expectation class indicating that sender of list would like to be notified if activity from the host is seen
> Source of heavy scanning over past 1 month </Description
xml version "1.0" encoding "UTF 8"?
ns:iodef 1.0" xmlns "urn:ietf:params:xml:ns:iodef 1.0" xmlns:iodef "urn:ietf:params:xml:ns:iodef 1.0" xmlns:xs "http://www.w3.org/2001/XMLSchema" elementFormDefault "qualified
documentation> Incident Object Description Exchange Format v1.00, see RFC 5070 </xs:documentation> <
element ref "iodef:Incident" maxOccurs "unbounded"/
<xs:attribute name "version" type "xs:
<xs:attribute name "lang" type "xs:language" use "required"/>
<xs:attribute name "formatid" type "xs:string"/
element ref "iodef:AlternativeID" minOccurs "
element ref "iodef:RelatedActivity" minOccurs "
element ref "iodef:DetectTime" minOccurs "
element ref "iodef:Description" minOccurs "0
element ref "iodef:Assessment" maxOccurs "
element ref "iodef:Method" minOccurs "0" maxOccurs "
element ref "iodef:EventData" minOccurs "0" maxOccurs "
element ref "iodef:History" minOccurs "
element ref "iodef:AdditionalData" minOccurs "0" maxOccurs "
<xs:attribute name "purpose" use "required"
<xs:attribute name "lang" type "xs:language"/>
attribute name "restriction" type "iodef:restriction type" default "private"/
attribute name "name" type "xs:string" use "required"/
<xs:attribute name "instance" type "xs:string" use "optional"/>
attribute name "restriction" type "iodef:restriction type" default "public"/
element ref "iodef:IncidentID" maxOccurs "
<xs:attribute name "restriction" type "iodef:restriction
<xs:element ref "iodef:IncidentID" maxOccurs "
element ref "iodef:URL" maxOccurs "
> <xs:attribute name "restriction" type "iodef:restriction
element ref "iodef:Description" minOccurs "0
element ref "iodef:RegistryHandle" minOccurs "0
Email" minOccurs "0" maxOccurs "
"iodef:Telephone" minOccurs "0" maxOccurs "
element ref "iodef:Timezone" minOccurs "
element ref "iodef:Contact" minOccurs "0" maxOccurs "
element ref "iodef:AdditionalData" minOccurs "0" maxOccurs "
<xs:attribute name "role" use "required"> <xs:
<xs:attribute name "type" use "required"
<xs:attribute name "restriction" type "iodef:restriction
complexType> </xs:element> <xs:element name "ContactName" type "iodef:MLStringType"/>
extension base "xs:string"> <xs:attribute name "registry"
complexType> </xs:element> <xs:element name "PostalAddress">
attribute name "meaning" type "xs:string" use "optional"/
element name "Fax" type "
attribute name "meaning" type "xs:string" use "optional"/
element name "Timezone" type "
restriction base "xs:string"> <xs:pattern value "Z
element ref "iodef:HistoryItem" maxOccurs "
attribute name "restriction" type "iodef:restriction type" default "default"/
> </xs:element> <xs:element name "HistoryItem"
> <xs:element ref "iodef:IncidentID" minOccurs "
element ref "iodef:Contact" minOccurs "
element ref "iodef:Description" minOccurs "0
element ref "iodef:AdditionalData" minOccurs "0" maxOccurs "
<xs:attribute name "restriction" type "iodef:restriction
<xs:attribute name "action" type "iodef:action type" use "required"/
element ref "iodef:Description" minOccurs "0
element ref "iodef:Contact" minOccurs "
attribute name "restriction" type "iodef:restriction type" default "default"/>
attribute name "action" type "iodef:action type" default "other"/>
element ref "iodef:AdditionalData" minOccurs "0" maxOccurs "
<xs:attribute name "restriction" type "iodef:restriction
complexType> </xs:element> <xs:element name "Reference"
element name "ReferenceName" type "
element ref "iodef:URL" minOccurs "0" maxOccurs "
element ref "iodef:Description" minOccurs "0
element ref "iodef:Counter" minOccurs "0" maxOccurs "
element ref "iodef:Confidence" minOccurs "
element ref "iodef:AdditionalData" minOccurs "0" maxOccurs "
attribute name "restriction" type "iodef:restriction
complexType> </xs:element> <xs:element name "Impact"
attribute name "type" use "optional" default "unknown"
complexType> </xs:element> <xs:element name "TimeImpact"
<xs:attribute name "duration" type "iodef:duration
complexType> </xs:element> <xs:element name "MonetaryImpact">
complexType> </xs:element> <xs:element name "Confidence"
complexType mixed "true"> <xs:attribute name "rating" use "required"
element ref "iodef:Description" minOccurs "0
element ref "iodef:DetectTime" minOccurs "
element ref "iodef:Contact" minOccurs "0" maxOccurs "
element ref "iodef:Assessment" minOccurs "
element ref "iodef:Method" minOccurs "0" maxOccurs "
"iodef:Flow" minOccurs "0" maxOccurs "
element ref "iodef:Expectation" minOccurs "0
element ref "iodef:Record" minOccurs "
element ref "iodef:EventData" minOccurs "0" maxOccurs "
element ref "iodef:AdditionalData" minOccurs "0" maxOccurs "
attribute name "restriction" type "iodef:restriction type" default "default"/
element ref "iodef:System" maxOccurs "
element ref "iodef:Service" minOccurs "0" maxOccurs "
element ref "iodef:OperatingSystem" minOccurs "0" maxOccurs "
"iodef:Counter" minOccurs "0" maxOccurs "
element ref "iodef:Description" minOccurs "0
element ref "iodef:AdditionalData" minOccurs "0" maxOccurs "
<xs:attribute name "restriction" type "iodef:restriction
attribute name "interface" type "xs:
<xs:attribute name "spoofed" default "unknown"
element name "NodeName" type "
element ref "iodef:Address" minOccurs "0" maxOccurs "
element ref "iodef:Location" minOccurs "
element ref "iodef:DateTime" minOccurs "
element ref "iodef:NodeRole" minOccurs "0
"iodef:Counter" minOccurs "0" maxOccurs "
attribute name "category" default "ipv4 addr"> <xs:
<xs:attribute name "vlan name" type "xs:
<xs:attribute name "vlan num" type "xs:integer"/
complexType> </xs:element> <xs:element name "Location" type "iodef:MLStringType"/>
<xs:attribute name "category" use "required"> <xs:simpleType>
element name "Port" type "xs:integer"/>
element name "Portlist" type "
> <xs:element name "ProtoType" type "xs:integer" minOccurs "
element name "ProtoCode" type "xs:integer" minOccurs "
element name "ProtoField" type "xs:integer" minOccurs "
element ref "iodef:Application" minOccurs "
"ip protocol" type "xs:integer" use "required"/
> </xs:element> <xs:simpleType name "PortlistType"
restriction base "xs:string"> <xs:pattern value "
attribute name "type" use "required"> <xs:
attribute name "meaning" type "xs:string" use "optional"/>
<xs:attribute name "duration" type "iodef:duration
element ref "iodef:RecordData" maxOccurs "
<xs:attribute name "restriction" type "iodef:restriction
complexType> </xs:element> <xs:element name "RecordData"
element ref "iodef:DateTime" minOccurs "
element ref "iodef:Description" minOccurs "0
element ref "iodef:Application" minOccurs "
element ref "iodef:RecordPattern" minOccurs "0
element ref "iodef:RecordItem" maxOccurs "
element ref "iodef:AdditionalData" minOccurs "0" maxOccurs "
<xs:attribute name "restriction" type "iodef:restriction
complexType> </xs:element> <xs:element name "RecordPattern"
attribute name "type" use "required"> <xs:
attribute name "offset" type "xs:
<xs:attribute name "offsetunit" use "optional" default "line"
<xs:attribute name "instance" type "xs:integer" use "optional"/
complexType> </xs:element> <xs:element name "RecordItem" type "iodef
element ref "iodef:URL" minOccurs "
attribute name "swid" type "xs:string" default "0"/
> <xs:attribute name "configid" type "xs:string" default "
:attribute name "vendor" type "xs:string"/
<xs:attribute name "family" type "xs:
<xs:attribute name "name" type "xs:
<xs:attribute name "version" type "xs:string"/
<xs:attribute name "patch" type "xs:string"/
element name "Application" type "iodef:SoftwareType"/
> <xs:element name "OperatingSystem" type "iodef:SoftwareType"/
element name "Description" type "
restriction base "xs:float"> <xs:minExclusive value "0"/
attribute name "lang" type "xs:language" use "optional"/
complexType name "ExtensionType" mixed "true"
<xs:any namespace "##any" processContents "lax" minOccurs "0" maxOccurs "unbounded"/
attribute name "meaning" type "xs:
<xs:attribute name "formatid" type "xs:string"/
<xs:attribute name "restriction" type "iodef:restriction
simpleType name "restriction type"> <xs:restriction base "xs:NMTOKEN"> <xs:enumeration value "default"/>
simpleType name "duration type"> <xs:restriction base "xs:NMTOKEN"> <xs:enumeration value "second"/>
simpleType name "action type"> <xs:restriction base "xs:NMTOKEN"> <xs:enumeration value "nothing"/>
enumeration value "rate limit port"/
The IODEF data model itself does not directly introduce security issues.
Rather, it simply defines a representation for incident information.
As the data encoded by the IODEF might be considered privacy sensitive by the parties exchanging the information or by those described by it, care needs to be taken in ensuring the appropriate disclosure during both document exchange and subsequent processing.
The former must be handled by a messaging format, but the latter risk must be addressed by the systems that process, store, and archive IODEF documents and information derived from them.
The contents of an IODEF document may include a request for action or an IODEF parser may independently have logic to take certain actions based on information that it finds.
For this reason, care must be taken by the parser to properly authenticate the recipient of the document and ascribe an appropriate confidence to the data prior to action.
The underlying messaging format and protocol used to exchange instances of the IODEF MUST provide appropriate guarantees of confidentiality, integrity, and authenticity.
The use of a standardized security protocol is encouraged.
The Real time Inter  network Defense (RID) protocol [18] and its associated transport binding IODEF/RID over SOAP [19] provide such security.
In order to suggest data processing and handling guidelines of the encoded information, the IODEF allows a document sender to convey a privacy policy using the restriction attribute.
The various instances of this attribute allow different data elements of the document to be covered by dissimilar policies.
While flexible, it must be stressed that this approach only serves as a guideline from the sender, as the recipient is free to ignore it.
The issue of enforcement is not a technical problem.
This document uses URNs to describe an XML namespace and schema conforming to a registry mechanism described in [15] Registration for the IODEF namespace:
: See the first author of the "Author's Address" section of this document.
Namespace URIs do not represent an XML specification.
Registration for the IODEF XML schema:  URI:
: See the first author of the "Author's Address" section of this document.
: See the "IODEF Schema" in Section 8 of this document.
