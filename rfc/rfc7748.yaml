- title: __initial_text__
  contents:
  - ''
- title: Internet Research Task Force (IRTF)                           A. Langley
  contents:
  - "Internet Research Task Force (IRTF)                           A. Langley\n  \
    \                    Elliptic Curves for Security\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo specifies two elliptic curves over prime fields that offer\n\
    \   a high level of practical security in cryptographic applications,\n   including\
    \ Transport Layer Security (TLS).  These curves are intended\n   to operate at\
    \ the ~128-bit and ~224-bit security level, respectively,\n   and are generated\
    \ deterministically based on a list of required\n   properties.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Research Task Force\n   (IRTF).  The IRTF publishes the results\
    \ of Internet-related research\n   and development activities.  These results\
    \ might not be suitable for\n   deployment.  This RFC represents the consensus\
    \ of the Crypto Forum\n   Research Group of the Internet Research Task Force (IRTF).\
    \  Documents\n   approved for publication by the IRSG are not a candidate for\
    \ any\n   level of Internet Standard; see Section 2 of RFC 5741.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7748.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2016 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   2\n   2.  Requirements Language . . . . . . . . . . . . . . . .\
    \ . . . .   3\n   3.  Notation  . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . .   3\n   4.  Recommended Curves  . . . . . . . . . . . . . . . . . . .\
    \ . .   4\n     4.1.  Curve25519  . . . . . . . . . . . . . . . . . . . . . .\
    \ .   4\n     4.2.  Curve448  . . . . . . . . . . . . . . . . . . . . . . . .\
    \   5\n   5.  The X25519 and X448 Functions . . . . . . . . . . . . . . . .  \
    \ 7\n     5.1.  Side-Channel Considerations . . . . . . . . . . . . . . .  10\n\
    \     5.2.  Test Vectors  . . . . . . . . . . . . . . . . . . . . . .  11\n  \
    \ 6.  Diffie-Hellman  . . . . . . . . . . . . . . . . . . . . . . .  14\n    \
    \ 6.1.  Curve25519  . . . . . . . . . . . . . . . . . . . . . . .  14\n     6.2.\
    \  Curve448  . . . . . . . . . . . . . . . . . . . . . . . .  15\n   7.  Security\
    \ Considerations . . . . . . . . . . . . . . . . . . .  15\n   8.  References\
    \  . . . . . . . . . . . . . . . . . . . . . . . . .  16\n     8.1.  Normative\
    \ References  . . . . . . . . . . . . . . . . . .  16\n     8.2.  Informative\
    \ References  . . . . . . . . . . . . . . . . .  17\n   Appendix A.  Deterministic\
    \ Generation . . . . . . . . . . . . . .  19\n     A.1.  p = 1 mod 4 . . . . .\
    \ . . . . . . . . . . . . . . . . . .  20\n     A.2.  p = 3 mod 4 . . . . . .\
    \ . . . . . . . . . . . . . . . . .  21\n     A.3.  Base Points . . . . . . .\
    \ . . . . . . . . . . . . . . . .  21\n   Acknowledgements  . . . . . . . . .\
    \ . . . . . . . . . . . . . . .  22\n   Authors' Addresses  . . . . . . . . .\
    \ . . . . . . . . . . . . . .  22\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Since the initial standardization of Elliptic Curve Cryptography\
    \ (ECC\n   [RFC6090]) in [SEC1], there has been significant progress related to\n\
    \   both efficiency and security of curves and implementations.  Notable\n   examples\
    \ are algorithms protected against certain side-channel\n   attacks, various \"\
    special\" prime shapes that allow faster modular\n   arithmetic, and a larger\
    \ set of curve models from which to choose.\n   There is also concern in the community\
    \ regarding the generation and\n   potential weaknesses of the curves defined\
    \ by NIST [NIST].\n   This memo specifies two elliptic curves (\"curve25519\"\
    \ and \"curve448\")\n   that lend themselves to constant-time implementation and\
    \ an\n   exception-free scalar multiplication that is resistant to a wide\n  \
    \ range of side-channel attacks, including timing and cache attacks.\n   They\
    \ are Montgomery curves (where v^2 = u^3 + A*u^2 + u) and thus\n   have birationally\
    \ equivalent Edwards versions.  Edwards curves\n   support the fastest (currently\
    \ known) complete formulas for the\n   elliptic-curve group operations, specifically\
    \ the Edwards curve\n   x^2 + y^2 = 1 + d*x^2*y^2 for primes p when p = 3 mod\
    \ 4, and the\n   twisted Edwards curve -x^2 + y^2 = 1 + d*x^2*y^2 when p = 1 mod\
    \ 4.\n   The maps to/from the Montgomery curves to their (twisted) Edwards\n \
    \  equivalents are also given.\n   This memo also specifies how these curves can\
    \ be used with the\n   Diffie-Hellman protocol for key agreement.\n"
- title: 2.  Requirements Language
  contents:
  - "2.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [RFC2119].\n"
- title: 3.  Notation
  contents:
  - "3.  Notation\n   Throughout this document, the following notation is used:\n\
    \   p        Denotes the prime number defining the underlying field.\n   GF(p)\
    \    The finite field with p elements.\n   A        An element in the finite field\
    \ GF(p), not equal to -2 or 2.\n   d        A non-zero element in the finite field\
    \ GF(p), not equal to\n            1, in the case of an Edwards curve, or not\
    \ equal to -1, in\n            the case of a twisted Edwards curve.\n   order\
    \    The order of the prime-order subgroup.\n   P        A generator point defined\
    \ over GF(p) of prime order.\n   U(P)     The u-coordinate of the elliptic curve\
    \ point P on a\n            Montgomery curve.\n   V(P)     The v-coordinate of\
    \ the elliptic curve point P on a\n            Montgomery curve.\n   X(P)    \
    \ The x-coordinate of the elliptic curve point P on a\n            (twisted) Edwards\
    \ curve.\n   Y(P)     The y-coordinate of the elliptic curve point P on a\n  \
    \          (twisted) Edwards curve.\n   u, v     Coordinates on a Montgomery curve.\n\
    \   x, y     Coordinates on a (twisted) Edwards curve.\n"
- title: 4.  Recommended Curves
  contents:
  - '4.  Recommended Curves

    '
- title: 4.1.  Curve25519
  contents:
  - "4.1.  Curve25519\n   For the ~128-bit security level, the prime 2^255 - 19 is\
    \ recommended\n   for performance on a wide range of architectures.  Few primes\
    \ of the\n   form 2^c-s with s small exist between 2^250 and 2^521, and other\n\
    \   choices of coefficient are not as competitive in performance.  This\n   prime\
    \ is congruent to 1 mod 4, and the derivation procedure in\n   Appendix A results\
    \ in the following Montgomery curve\n   v^2 = u^3 + A*u^2 + u, called \"curve25519\"\
    :\n   p  2^255 - 19\n   A  486662\n   order  2^252 + 0x14def9dea2f79cd65812631a5cf5d3ed\n\
    \   cofactor  8\n   U(P)  9\n   V(P)  147816194475895447910205935684099868872646061346164752889648818\n\
    \      37755586237401\n   The base point is u = 9, v = 1478161944758954479102059356840998688726\n\
    \   4606134616475288964881837755586237401.\n   This curve is birationally equivalent\
    \ to a twisted Edwards curve -x^2\n   + y^2 = 1 + d*x^2*y^2, called \"edwards25519\"\
    , where:\n   p  2^255 - 19\n   d  370957059346694393431380835087545651895421138798432190163887855330\n\
    \      85940283555\n   order  2^252 + 0x14def9dea2f79cd65812631a5cf5d3ed\n   cofactor\
    \  8\n   X(P)  151122213495354007725011514095885315114540126930418572060461132\n\
    \      83949847762202\n   Y(P)  463168356949264781694283940034751631413079938662562256157830336\n\
    \      03165251855960\n   The birational maps are:\n     (u, v) = ((1+y)/(1-y),\
    \ sqrt(-486664)*u/x)\n     (x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))\n   The Montgomery\
    \ curve defined here is equal to the one defined in\n   [curve25519], and the\
    \ equivalent twisted Edwards curve is equal to\n   the one defined in [ed25519].\n"
- title: 4.2.  Curve448
  contents:
  - "4.2.  Curve448\n   For the ~224-bit security level, the prime 2^448 - 2^224 -\
    \ 1 is\n   recommended for performance on a wide range of architectures.  This\n\
    \   prime is congruent to 3 mod 4, and the derivation procedure in\n   Appendix\
    \ A results in the following Montgomery curve, called\n   \"curve448\":\n   p\
    \  2^448 - 2^224 - 1\n   A  156326\n   order  2^446 -\n      0x8335dc163bb124b65129c96fde933d8d723a70aadc873d6d54a7bb0d\n\
    \   cofactor  4\n   U(P)  5\n   V(P)  355293926785568175264127502063783334808976399387714271831880898\n\
    \      435169088786967410002932673765864550910142774147268105838985595290\n  \
    \    606362\n   This curve is birationally equivalent to the Edwards curve x^2\
    \ + y^2\n   = 1 + d*x^2*y^2 where:\n   p  2^448 - 2^224 - 1\n   d  611975850744529176160423220965553317543219696871016626328968936415\n\
    \      087860042636474891785599283666020414768678979989378147065462815545\n  \
    \    017\n   order  2^446 -\n      0x8335dc163bb124b65129c96fde933d8d723a70aadc873d6d54a7bb0d\n\
    \   cofactor  4\n   X(P)  345397493039729516374008604150537410266655260075183290216406970\n\
    \      281645695073672344430481787759340633221708391583424041788924124567\n  \
    \    700732\n   Y(P)  363419362147803445274661903944002267176820680343659030140745099\n\
    \      590306164083365386343198191849338272965044442230921818680526749009\n  \
    \    182718\n   The birational maps are:\n     (u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)\n\
    \     (x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))\n   Both of those curves are also\
    \ 4-isogenous to the following Edwards\n   curve x^2 + y^2 = 1 + d*x^2*y^2, called\
    \ \"edwards448\", where:\n   p  2^448 - 2^224 - 1\n   d  -39081\n   order  2^446\
    \ -\n      0x8335dc163bb124b65129c96fde933d8d723a70aadc873d6d54a7bb0d\n   cofactor\
    \  4\n   X(P)  224580040295924300187604334099896036246789641632564134246125461\n\
    \      686950415467406032909029192869357953282578032075146446173674602635\n  \
    \    247710\n   Y(P)  298819210078481492676017930443930673437544040154080242095928241\n\
    \      372331506189835876003536878655418784733982303233503462500531545062\n  \
    \    832660\n   The 4-isogeny maps between the Montgomery curve and this Edwards\n\
    \   curve are:\n     (u, v) = (y^2/x^2, (2 - x^2 - y^2)*y/x^3)\n     (x, y) =\
    \ (4*v*(u^2 - 1)/(u^4 - 2*u^2 + 4*v^2 + 1),\n               -(u^5 - 2*u^3 - 4*u*v^2\
    \ + u)/\n               (u^5 - 2*u^2*v^2 - 2*u^3 - 2*v^2 + u))\n   The curve edwards448\
    \ defined here is also called \"Goldilocks\" and is\n   equal to the one defined\
    \ in [goldilocks].\n"
- title: 5.  The X25519 and X448 Functions
  contents:
  - "5.  The X25519 and X448 Functions\n   The \"X25519\" and \"X448\" functions perform\
    \ scalar multiplication on\n   the Montgomery form of the above curves.  (This\
    \ is used when\n   implementing Diffie-Hellman.)  The functions take a scalar\
    \ and a\n   u-coordinate as inputs and produce a u-coordinate as output.\n   Although\
    \ the functions work internally with integers, the inputs and\n   outputs are\
    \ 32-byte strings (for X25519) or 56-byte strings (for\n   X448) and this specification\
    \ defines their encoding.\n   The u-coordinates are elements of the underlying\
    \ field GF(2^255 - 19)\n   or GF(2^448 - 2^224 - 1) and are encoded as an array\
    \ of bytes, u, in\n   little-endian order such that u[0] + 256*u[1] + 256^2*u[2]\
    \ + ... +\n   256^(n-1)*u[n-1] is congruent to the value modulo p and u[n-1] is\n\
    \   minimal.  When receiving such an array, implementations of X25519\n   (but\
    \ not X448) MUST mask the most significant bit in the final byte.\n   This is\
    \ done to preserve compatibility with point formats that\n   reserve the sign\
    \ bit for use in other protocols and to increase\n   resistance to implementation\
    \ fingerprinting.\n   Implementations MUST accept non-canonical values and process\
    \ them as\n   if they had been reduced modulo the field prime.  The non-canonical\n\
    \   values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224\n   -\
    \ 1 through 2^448 - 1 for X448.\n   The following functions implement this in\
    \ Python, although the Python\n   code is not intended to be performant nor side-channel\
    \ free.  Here,\n   the \"bits\" parameter should be set to 255 for X25519 and\
    \ 448 for\n   X448:\n   <CODE BEGINS>\n   def decodeLittleEndian(b, bits):\n \
    \      return sum([b[i] << 8*i for i in range((bits+7)/8)])\n   def decodeUCoordinate(u,\
    \ bits):\n       u_list = [ord(b) for b in u]\n       # Ignore any unused bits.\n\
    \       if bits % 8:\n           u_list[-1] &= (1<<(bits%8))-1\n       return\
    \ decodeLittleEndian(u_list, bits)\n   def encodeUCoordinate(u, bits):\n     \
    \  u = u % p\n       return ''.join([chr((u >> 8*i) & 0xff)\n                \
    \       for i in range((bits+7)/8)])\n   <CODE ENDS>\n   Scalars are assumed to\
    \ be randomly generated bytes.  For X25519, in\n   order to decode 32 random bytes\
    \ as an integer scalar, set the three\n   least significant bits of the first\
    \ byte and the most significant bit\n   of the last to zero, set the second most\
    \ significant bit of the last\n   byte to 1 and, finally, decode as little-endian.\
    \  This means that the\n   resulting integer is of the form 2^254 plus eight times\
    \ a value\n   between 0 and 2^251 - 1 (inclusive).  Likewise, for X448, set the\
    \ two\n   least significant bits of the first byte to 0, and the most\n   significant\
    \ bit of the last byte to 1.  This means that the resulting\n   integer is of\
    \ the form 2^447 plus four times a value between 0 and\n   2^445 - 1 (inclusive).\n\
    \   <CODE BEGINS>\n   def decodeScalar25519(k):\n       k_list = [ord(b) for b\
    \ in k]\n       k_list[0] &= 248\n       k_list[31] &= 127\n       k_list[31]\
    \ |= 64\n       return decodeLittleEndian(k_list, 255)\n   def decodeScalar448(k):\n\
    \       k_list = [ord(b) for b in k]\n       k_list[0] &= 252\n       k_list[55]\
    \ |= 128\n       return decodeLittleEndian(k_list, 448)\n   <CODE ENDS>\n   To\
    \ implement the X25519(k, u) and X448(k, u) functions (where k is\n   the scalar\
    \ and u is the u-coordinate), first decode k and u and then\n   perform the following\
    \ procedure, which is taken from [curve25519] and\n   based on formulas from [montgomery].\
    \  All calculations are performed\n   in GF(p), i.e., they are performed modulo\
    \ p.  The constant a24 is\n   (486662 - 2) / 4 = 121665 for curve25519/X25519\
    \ and (156326 - 2) / 4\n   = 39081 for curve448/X448.\n   x_1 = u\n   x_2 = 1\n\
    \   z_2 = 0\n   x_3 = u\n   z_3 = 1\n   swap = 0\n   For t = bits-1 down to 0:\n\
    \       k_t = (k >> t) & 1\n       swap ^= k_t\n       // Conditional swap; see\
    \ text below.\n       (x_2, x_3) = cswap(swap, x_2, x_3)\n       (z_2, z_3) =\
    \ cswap(swap, z_2, z_3)\n       swap = k_t\n       A = x_2 + z_2\n       AA =\
    \ A^2\n       B = x_2 - z_2\n       BB = B^2\n       E = AA - BB\n       C = x_3\
    \ + z_3\n       D = x_3 - z_3\n       DA = D * A\n       CB = C * B\n       x_3\
    \ = (DA + CB)^2\n       z_3 = x_1 * (DA - CB)^2\n       x_2 = AA * BB\n      \
    \ z_2 = E * (AA + a24 * E)\n   // Conditional swap; see text below.\n   (x_2,\
    \ x_3) = cswap(swap, x_2, x_3)\n   (z_2, z_3) = cswap(swap, z_2, z_3)\n   Return\
    \ x_2 * (z_2^(p - 2))\n   (Note that these formulas are slightly different from\
    \ Montgomery's\n   original paper.  Implementations are free to use any correct\n\
    \   formulas.)\n   Finally, encode the resulting value as 32 or 56 bytes in little-\n\
    \   endian order.  For X25519, the unused, most significant bit MUST be\n   zero.\n\
    \   The cswap function SHOULD be implemented in constant time (i.e.,\n   independent\
    \ of the swap argument).  For example, this can be done as\n   follows:\n   cswap(swap,\
    \ x_2, x_3):\n         dummy = mask(swap) AND (x_2 XOR x_3)\n         x_2 = x_2\
    \ XOR dummy\n         x_3 = x_3 XOR dummy\n         Return (x_2, x_3)\n   Where\
    \ mask(swap) is the all-1 or all-0 word of the same length as x_2\n   and x_3,\
    \ computed, e.g., as mask(swap) = 0 - swap.\n"
- title: 5.1.  Side-Channel Considerations
  contents:
  - "5.1.  Side-Channel Considerations\n   X25519 and X448 are designed so that fast,\
    \ constant-time\n   implementations are easier to produce.  The procedure above\
    \ ensures\n   that the same sequence of field operations is performed for all\n\
    \   values of the secret key, thus eliminating a common source of side-\n   channel\
    \ leakage.  However, this alone does not prevent all side-\n   channels by itself.\
    \  It is important that the pattern of memory\n   accesses and jumps not depend\
    \ on the values of any of the bits of k.\n   It is also important that the arithmetic\
    \ used not leak information\n   about the integers modulo p, for example by having\
    \ b*c be\n   distinguishable from c*c.  On some architectures, even primitive\n\
    \   machine instructions, such as single-word division, can have variable\n  \
    \ timing based on their inputs.\n   Side-channel attacks are an active research\
    \ area that still sees\n   significant, new results.  Implementors are advised\
    \ to follow this\n   research closely.\n"
- title: 5.2.  Test Vectors
  contents:
  - "5.2.  Test Vectors\n   Two types of tests are provided.  The first is a pair\
    \ of test vectors\n   for each function that consist of expected outputs for the\
    \ given\n   inputs.  The inputs are generally given as 64 or 112 hexadecimal\n\
    \   digits that need to be decoded as 32 or 56 binary bytes before\n   processing.\n\
    \   X25519:\n   Input scalar:\n     a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4\n\
    \   Input scalar as a number (base 10):\n     31029842492115040904895560451863089656\n\
    \     472772604678260265531221036453811406496\n   Input u-coordinate:\n     e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c\n\
    \   Input u-coordinate as a number (base 10):\n     34426434033919594451155107781188821651\n\
    \     316167215306631574996226621102155684838\n   Output u-coordinate:\n     c3da55379de9c6908e94ea4df28d084f32eccf03491c71f754b4075577a28552\n\
    \   Input scalar:\n     4b66e9d4d1b4673c5ad22691957d6af5c11b6421e0ea01d42ca4169e7918ba0d\n\
    \   Input scalar as a number (base 10):\n     35156891815674817266734212754503633747\n\
    \     128614016119564763269015315466259359304\n   Input u-coordinate:\n     e5210f12786811d3f4b7959d0538ae2c31dbe7106fc03c3efc4cd549c715a493\n\
    \   Input u-coordinate as a number (base 10):\n     88838573511839298940907593866106493194\n\
    \     17338800022198945255395922347792736741\n   Output u-coordinate:\n     95cbde9476e8907d7aade45cb4b873f88b595a68799fa152e6f8f7647aac7957\n\
    \   X448:\n   Input scalar:\n     3d262fddf9ec8e88495266fea19a34d28882acef045104d0d1aae121\n\
    \     700a779c984c24f8cdd78fbff44943eba368f54b29259a4f1c600ad3\n   Input scalar\
    \ as a number (base 10):\n     599189175373896402783756016145213256157230856\n\
    \     085026129926891459468622403380588640249457727\n     683869421921443004045221642549886377526240828\n\
    \   Input u-coordinate:\n     06fce640fa3487bfda5f6cf2d5263f8aad88334cbd07437f020f08f9\n\
    \     814dc031ddbdc38c19c6da2583fa5429db94ada18aa7a7fb4ef8a086\n   Input u-coordinate\
    \ as a number (base 10):\n     382239910814107330116229961234899377031416365\n\
    \     240571325148346555922438025162094455820962429\n     142971339584360034337310079791515452463053830\n\
    \   Output u-coordinate:\n     ce3e4ff95a60dc6697da1db1d85e6afbdf79b50a2412d7546d5f239f\n\
    \     e14fbaadeb445fc66a01b0779d98223961111e21766282f73dd96b6f\n   Input scalar:\n\
    \     203d494428b8399352665ddca42f9de8fef600908e0d461cb021f8c5\n     38345dd77c3e4806e25f46d3315c44e0a5b4371282dd2c8d5be3095f\n\
    \   Input scalar as a number (base 10):\n     633254335906970592779259481534862372382525155\n\
    \     252028961056404001332122152890562527156973881\n     968934311400345568203929409663925541994577184\n\
    \   Input u-coordinate:\n     0fbcc2f993cd56d3305b0b7d9e55d4c1a8fb5dbb52f8e9a1e9b6201b\n\
    \     165d015894e56c4d3570bee52fe205e28a78b91cdfbde71ce8d157db\n   Input u-coordinate\
    \ as a number (base 10):\n     622761797758325444462922068431234180649590390\n\
    \     024811299761625153767228042600197997696167956\n     134770744996690267634159427999832340166786063\n\
    \   Output u-coordinate:\n     884a02576239ff7a2f2f63b2db6a9ff37047ac13568e1e30fe63c4a7\n\
    \     ad1b3ee3a5700df34321d62077e63633c575c1c954514e99da7c179d\n   The second\
    \ type of test vector consists of the result of calling the\n   function in question\
    \ a specified number of times.  Initially, set k\n   and u to be the following\
    \ values:\n   For X25519:\n     0900000000000000000000000000000000000000000000000000000000000000\n\
    \   For X448:\n     05000000000000000000000000000000000000000000000000000000\n\
    \     00000000000000000000000000000000000000000000000000000000\n   For each iteration,\
    \ set k to be the result of calling the function\n   and u to be the old value\
    \ of k.  The final result is the value left\n   in k.\n   X25519:\n   After one\
    \ iteration:\n       422c8e7a6227d7bca1350b3e2bb7279f7897b87bb6854b783c60e80311ae3079\n\
    \   After 1,000 iterations:\n       684cf59ba83309552800ef566f2f4d3c1c3887c49360e3875f2eb94d99532c51\n\
    \   After 1,000,000 iterations:\n       7c3911e0ab2586fd864497297e575e6f3bc601c0883c30df5f4dd2d24f665424\n\
    \   X448:\n   After one iteration:\n       3f482c8a9f19b01e6c46ee9711d9dc14fd4bf67af30765c2ae2b846a\n\
    \       4d23a8cd0db897086239492caf350b51f833868b9bc2b3bca9cf4113\n   After 1,000\
    \ iterations:\n       aa3b4749d55b9daf1e5b00288826c467274ce3ebbdd5c17b975e09d4\n\
    \       af6c67cf10d087202db88286e2b79fceea3ec353ef54faa26e219f38\n   After 1,000,000\
    \ iterations:\n       077f453681caca3693198420bbe515cae0002472519b3e67661a7e89\n\
    \       cab94695c8f4bcd66e61b9b9c946da8d524de3d69bd9d9d66b997e37\n"
- title: 6.  Diffie-Hellman
  contents:
  - '6.  Diffie-Hellman

    '
- title: 6.1.  Curve25519
  contents:
  - "6.1.  Curve25519\n   The X25519 function can be used in an Elliptic Curve Diffie-Hellman\n\
    \   (ECDH) protocol as follows:\n   Alice generates 32 random bytes in a[0] to\
    \ a[31] and transmits K_A =\n   X25519(a, 9) to Bob, where 9 is the u-coordinate\
    \ of the base point\n   and is encoded as a byte with value 9, followed by 31\
    \ zero bytes.\n   Bob similarly generates 32 random bytes in b[0] to b[31], computes\n\
    \   K_B = X25519(b, 9), and transmits it to Alice.\n   Using their generated values\
    \ and the received input, Alice computes\n   X25519(a, K_B) and Bob computes X25519(b,\
    \ K_A).\n   Both now share K = X25519(a, X25519(b, 9)) = X25519(b, X25519(a, 9))\n\
    \   as a shared secret.  Both MAY check, without leaking extra\n   information\
    \ about the value of K, whether K is the all-zero value and\n   abort if so (see\
    \ below).  Alice and Bob can then use a key-derivation\n   function that includes\
    \ K, K_A, and K_B to derive a symmetric key.\n   The check for the all-zero value\
    \ results from the fact that the\n   X25519 function produces that value if it\
    \ operates on an input\n   corresponding to a point with small order, where the\
    \ order divides\n   the cofactor of the curve (see Section 7).  The check may\
    \ be\n   performed by ORing all the bytes together and checking whether the\n\
    \   result is zero, as this eliminates standard side-channels in software\n  \
    \ implementations.\n   Test vector:\n   Alice's private key, a:\n     77076d0a7318a57d3c16c17251b26645df4c2f87ebc0992ab177fba51db92c2a\n\
    \   Alice's public key, X25519(a, 9):\n     8520f0098930a754748b7ddcb43ef75a0dbf3a0d26381af4eba4a98eaa9b4e6a\n\
    \   Bob's private key, b:\n     5dab087e624a8a4b79e17f8b83800ee66f3bb1292618b6fd1c2f8b27ff88e0eb\n\
    \   Bob's public key, X25519(b, 9):\n     de9edb7d7b7dc1b4d35b61c2ece435373f8343c85b78674dadfc7e146f882b4f\n\
    \   Their shared secret, K:\n     4a5d9d5ba4ce2de1728e3bf480350f25e07e21c947d19e3376f09b3c1e161742\n"
- title: 6.2.  Curve448
  contents:
  - "6.2.  Curve448\n   The X448 function can be used in an ECDH protocol very much\
    \ like the\n   X25519 function.\n   If X448 is to be used, the only differences\
    \ are that Alice and Bob\n   generate 56 random bytes (not 32) and calculate K_A\
    \ = X448(a, 5) or\n   K_B = X448(b, 5), where 5 is the u-coordinate of the base\
    \ point and\n   is encoded as a byte with value 5, followed by 55 zero bytes.\n\
    \   As with X25519, both sides MAY check, without leaking extra\n   information\
    \ about the value of K, whether the resulting shared K is\n   the all-zero value\
    \ and abort if so.\n   Test vector:\n   Alice's private key, a:\n     9a8f4925d1519f5775cf46b04b5800d4ee9ee8bae8bc5565d498c28d\n\
    \     d9c9baf574a9419744897391006382a6f127ab1d9ac2d8c0a598726b\n   Alice's public\
    \ key, X448(a, 5):\n     9b08f7cc31b7e3e67d22d5aea121074a273bd2b83de09c63faa73d2c\n\
    \     22c5d9bbc836647241d953d40c5b12da88120d53177f80e532c41fa0\n   Bob's private\
    \ key, b:\n     1c306a7ac2a0e2e0990b294470cba339e6453772b075811d8fad0d1d\n   \
    \  6927c120bb5ee8972b0d3e21374c9c921b09d1b0366f10b65173992d\n   Bob's public key,\
    \ X448(b, 5):\n     3eb7a829b0cd20f5bcfc0b599b6feccf6da4627107bdb0d4f345b430\n\
    \     27d8b972fc3e34fb4232a13ca706dcb57aec3dae07bdc1c67bf33609\n   Their shared\
    \ secret, K:\n     07fff4181ac6cc95ec1c16a94a0f74d12da232ce40a77552281d282b\n\
    \     b60c0b56fd2464c335543936521c24403085d59a449a5037514a879d\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   The security level (i.e., the number of \"operations\"\
    \ needed for a\n   brute-force attack on a primitive) of curve25519 is slightly\
    \ under\n   the standard 128-bit level.  This is acceptable because the standard\n\
    \   security levels are primarily driven by much simpler, symmetric\n   primitives\
    \ where the security level naturally falls on a power of\n   two.  For asymmetric\
    \ primitives, rigidly adhering to a power-of-two\n   security level would require\
    \ compromises in other parts of the\n   design, which we reject.  Additionally,\
    \ comparing security levels\n   between types of primitives can be misleading\
    \ under common threat\n   models where multiple targets can be attacked concurrently\n\
    \   [bruteforce].\n   The ~224-bit security level of curve448 is a trade-off between\n\
    \   performance and paranoia.  Large quantum computers, if ever created,\n   will\
    \ break both curve25519 and curve448, and reasonable projections\n   of the abilities\
    \ of classical computers conclude that curve25519 is\n   perfectly safe.  However,\
    \ some designs have relaxed performance\n   requirements and wish to hedge against\
    \ some amount of analytical\n   advance against elliptic curves and thus curve448\
    \ is also provided.\n   Protocol designers using Diffie-Hellman over the curves\
    \ defined in\n   this document must not assume \"contributory behaviour\".  Specially,\n\
    \   contributory behaviour means that both parties' private keys\n   contribute\
    \ to the resulting shared key.  Since curve25519 and\n   curve448 have cofactors\
    \ of 8 and 4 (respectively), an input point of\n   small order will eliminate\
    \ any contribution from the other party's\n   private key.  This situation can\
    \ be detected by checking for the all-\n   zero output, which implementations\
    \ MAY do, as specified in Section 6.\n   However, a large number of existing implementations\
    \ do not do this.\n   Designers using these curves should be aware that for each\
    \ public\n   key, there are several publicly computable public keys that are\n\
    \   equivalent to it, i.e., they produce the same shared secrets.  Thus\n   using\
    \ a public key as an identifier and knowledge of a shared secret\n   as proof\
    \ of ownership (without including the public keys in the key\n   derivation) might\
    \ lead to subtle vulnerabilities.\n   Designers should also be aware that implementations\
    \ of these curves\n   might not use the Montgomery ladder as specified in this\
    \ document,\n   but could use generic, elliptic-curve libraries instead.  These\n\
    \   implementations could reject points on the twist and could reject\n   non-minimal\
    \ field elements.  While not recommended, such\n   implementations will interoperate\
    \ with the Montgomery ladder\n   specified here but may be trivially distinguishable\
    \ from it.  For\n   example, sending a non-canonical value or a point on the twist\
    \ may\n   cause such implementations to produce an observable error while an\n\
    \   implementation that follows the design in this text would\n   successfully\
    \ produce a shared key.\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n  \
    \            DOI 10.17487/RFC2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [brainpool]\n              ECC Brainpool, \"\
    ECC Brainpool Standard Curves and Curve\n              Generation\", October 2005,\n\
    \              <http://www.ecc-brainpool.org/download/\n              Domain-parameters.pdf>.\n\
    \   [bruteforce]\n              Bernstein, D., \"Understanding brute force\",\
    \ April 2005,\n              <http://cr.yp.to/snuffle/bruteforce-20050425.pdf>.\n\
    \   [curve25519]\n              Bernstein, D., \"Curve25519: new Diffie-Hellman\
    \ speed\n              records\", 2006,\n              <http://www.iacr.org/cryptodb/archive/2006/\n\
    \              PKC/3351/3351.pdf>.\n   [ed25519]  Bernstein, D., Duif, N., Lange,\
    \ T., Schwabe, P., and B.\n              Yang, \"High-Speed High-Security Signatures\"\
    , 2011,\n              <http://link.springer.com/\n              chapter/10.1007/978-3-642-23951-9_9>.\n\
    \   [goldilocks]\n              Hamburg, M., \"Ed448-Goldilocks, a new elliptic\
    \ curve\",\n              2015, <http://eprint.iacr.org/2015/625.pdf>.\n   [montgomery]\n\
    \              Montgomery, P., \"Speeding the Pollard and Elliptic Curve\n   \
    \           Methods of Factorization\", January 1987,\n              <http://www.ams.org/journals/mcom/1987-48-177/\n\
    \              S0025-5718-1987-0866113-7/S0025-5718-1987-0866113-7.pdf>.\n   [NIST]\
    \     National Institute of Standards, \"Recommended Elliptic\n              Curves\
    \ for Federal Government Use\", July 1999,\n              <http://csrc.nist.gov/groups/ST/toolkit/documents/dss/\n\
    \              NISTReCur.pdf>.\n   [reducing] Menezes, A., Okamoto, T., and S.\
    \ Vanstone, \"Reducing\n              elliptic curve logarithms to logarithms\
    \ in a finite\n              field\", DOI 10.1109/18.259647, 1993,\n         \
    \     <http://ieeexplore.ieee.org/xpl/\n              articleDetails.jsp?arnumber=259647>.\n\
    \   [RFC6090]  McGrew, D., Igoe, K., and M. Salter, \"Fundamental Elliptic\n \
    \             Curve Cryptography Algorithms\", RFC 6090,\n              DOI 10.17487/RFC6090,\
    \ February 2011,\n              <http://www.rfc-editor.org/info/rfc6090>.\n  \
    \ [safecurves]\n              Bernstein, D. and T. Lange, \"SafeCurves: choosing\
    \ safe\n              curves for elliptic-curve cryptography\", Oct 2013,\n  \
    \            <http://safecurves.cr.yp.to/>.\n   [satoh]    Satoh, T. and K. Araki,\
    \ \"Fermat quotients and the\n              polynomial time discrete log algorithm\
    \ for anomalous\n              elliptic curves\", 1998.\n   [SEC1]     Certicom\
    \ Research, \"SEC 1: Elliptic Curve Cryptography\",\n              September 2000,\
    \ <http://www.secg.org/sec1-v2.pdf>.\n   [semaev]   Semaev, I., \"Evaluation of\
    \ discrete logarithms on some\n              elliptic curves\", 1998, <http://www.ams.org/journals/\n\
    \              mcom/1998-67-221/S0025-5718-98-00887-4/\n              S0025-5718-98-00887-4.pdf>.\n\
    \   [smart]    Smart, N., \"The Discrete Logarithm Problem on Elliptic\n     \
    \         Curves of Trace One\", 1999,\n              <http://www.hpl.hp.com/techreports/97/HPL-97-128.pdf>.\n"
- title: Appendix A.  Deterministic Generation
  contents:
  - "Appendix A.  Deterministic Generation\n   This section specifies the procedure\
    \ that was used to generate the\n   above curves; specifically, it defines how\
    \ to generate the parameter\n   A of the Montgomery curve y^2 = x^3 + A*x^2 +\
    \ x.  This procedure is\n   intended to be as objective as can reasonably be achieved\
    \ so that\n   it's clear that no untoward considerations influenced the choice\
    \ of\n   curve.  The input to this process is p, the prime that defines the\n\
    \   underlying field.  The size of p determines the amount of work needed\n  \
    \ to compute a discrete logarithm in the elliptic curve group, and\n   choosing\
    \ a precise p depends on many implementation concerns.  The\n   performance of\
    \ the curve will be dominated by operations in GF(p), so\n   carefully choosing\
    \ a value that allows for easy reductions on the\n   intended architecture is\
    \ critical.  This document does not attempt to\n   articulate all these considerations.\n\
    \   The value (A-2)/4 is used in several of the elliptic curve point\n   arithmetic\
    \ formulas.  For simplicity and performance reasons, it is\n   beneficial to make\
    \ this constant small, i.e., to choose A so that\n   (A-2) is a small integer\
    \ that is divisible by four.\n   For each curve at a specific security level:\n\
    \   1.  The trace of Frobenius MUST NOT be in {0, 1} in order to rule out\n  \
    \     the attacks described in [smart], [satoh], and [semaev], as in\n       [brainpool]\
    \ and [safecurves].\n   2.  MOV Degree [reducing]: the embedding degree MUST be\
    \ greater than\n       (order - 1) / 100, as in [brainpool] and [safecurves].\n\
    \   3.  CM Discriminant: discriminant D MUST be greater than 2^100, as in\n  \
    \     [safecurves].\n"
- title: A.1.  p = 1 mod 4
  contents:
  - "A.1.  p = 1 mod 4\n   For primes congruent to 1 mod 4, the minimal cofactors\
    \ of the curve\n   and its twist are either {4, 8} or {8, 4}.  We choose a curve\
    \ with\n   the latter cofactors so that any algorithms that take the cofactor\n\
    \   into account don't have to worry about checking for points on the\n   twist,\
    \ because the twist cofactor will be the smaller of the two.\n   To generate the\
    \ Montgomery curve, we find the minimal, positive A\n   value such that A > 2\
    \ and (A-2) is divisible by four and where the\n   cofactors are as desired. \
    \ The find1Mod4 function in the following\n   Sage script returns this value given\
    \ p:\n   <CODE BEGINS>\n   def findCurve(prime, curveCofactor, twistCofactor):\n\
    \       F = GF(prime)\n       for A in xrange(3, int(1e9)):\n           if (A-2)\
    \ % 4 != 0:\n             continue\n           try:\n             E = EllipticCurve(F,\
    \ [0, A, 0, 1, 0])\n           except:\n             continue\n           groupOrder\
    \ = E.order()\n           twistOrder = 2*(prime+1)-groupOrder\n           if (groupOrder\
    \ % curveCofactor == 0 and\n               is_prime(groupOrder // curveCofactor)\
    \ and\n               twistOrder % twistCofactor == 0 and\n               is_prime(twistOrder\
    \ // twistCofactor)):\n               return A\n   def find1Mod4(prime):\n   \
    \    assert((prime % 4) == 1)\n       return findCurve(prime, 8, 4)\n   <CODE\
    \ ENDS>\n                   Generating a curve where p = 1 mod 4\n"
- title: A.2.  p = 3 mod 4
  contents:
  - "A.2.  p = 3 mod 4\n   For a prime congruent to 3 mod 4, both the curve and twist\
    \ cofactors\n   can be 4, and this is minimal.  Thus, we choose the curve with\
    \ these\n   cofactors and minimal, positive A such that A > 2 and (A-2) is\n \
    \  divisible by four.  The find3Mod4 function in the following Sage\n   script\
    \ returns this value given p:\n   <CODE BEGINS>\n   def find3Mod4(prime):\n  \
    \     assert((prime % 4) == 3)\n       return findCurve(prime, 4, 4)\n   <CODE\
    \ ENDS>\n                   Generating a curve where p = 3 mod 4\n"
- title: A.3.  Base Points
  contents:
  - "A.3.  Base Points\n   The base point for a curve is the point with minimal, positive\
    \ u\n   value that is in the correct subgroup.  The findBasepoint function in\n\
    \   the following Sage script returns this value given p and A:\n   <CODE BEGINS>\n\
    \   def findBasepoint(prime, A):\n       F = GF(prime)\n       E = EllipticCurve(F,\
    \ [0, A, 0, 1, 0])\n       for uInt in range(1, 1e3):\n         u = F(uInt)\n\
    \         v2 = u^3 + A*u^2 + u\n         if not v2.is_square():\n           continue\n\
    \         v = v2.sqrt()\n         point = E(u, v)\n         pointOrder = point.order()\n\
    \         if pointOrder > 8 and pointOrder.is_prime():\n           return point\n\
    \   <CODE ENDS>\n                         Generating the base point\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   This document is the result of a combination of draft-black-rpgecc-01\n\
    \   and draft-turner-thecurve25519function-01.  The following authors of\n   those\
    \ documents wrote much of the text and figures but are not listed\n   as authors\
    \ on this document: Benjamin Black, Joppe W. Bos, Craig\n   Costello, Patrick\
    \ Longa, Michael Naehrig, Watson Ladd, and Rich Salz.\n   The authors would also\
    \ like to thank Tanja Lange, Rene Struik, Rich\n   Salz, Ilari Liusvaara, Deirdre\
    \ Connolly, Simon Josefsson, Stephen\n   Farrell, Georg Nestmann, Trevor Perrin,\
    \ and John Mattsson for their\n   reviews and contributions.\n   The X25519 function\
    \ was developed by Daniel J. Bernstein in\n   [curve25519].\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Adam Langley\n   Google\n   345 Spear Street\n   San Francisco,\
    \ CA  94105\n   United States\n   Email: agl@google.com\n   Mike Hamburg\n   Rambus\
    \ Cryptography Research\n   425 Market Street, 11th Floor\n   San Francisco, CA\
    \  94105\n   United States\n   Email: mike@shiftleft.org\n   Sean Turner\n   sn3rd\n\
    \   Email: sean@sn3rd.com\n"
