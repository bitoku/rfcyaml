- contents:
  - '      Path Computation Element (PCE) Communication Protocol (PCEP)

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2009 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents
    in effect on the date of\n   publication of this document (http://trustee.ietf.org/license-info).\n
    \  Please review these documents carefully, as they describe your rights\n   and
    restrictions with respect to this document.\n   This document may contain material
    from IETF Documents or IETF\n   Contributions published or made publicly available
    before November\n   10, 2008.  The person(s) controlling the copyright in some
    of this\n   material may not have granted the IETF Trust the right to allow\n
    \  modifications of such material outside the IETF Standards Process.\n   Without
    obtaining an adequate license from the person(s) controlling\n   the copyright
    in such materials, this document may not be modified\n   outside the IETF Standards
    Process, and derivative works of it may\n   not be created outside the IETF Standards
    Process, except to format\n   it for publication as an RFC or to translate it
    into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document specifies the Path Computation Element (PCE)\n   Communication
    Protocol (PCEP) for communications between a Path\n   Computation Client (PCC)
    and a PCE, or between two PCEs.  Such\n   interactions include path computation
    requests and path computation\n   replies as well as notifications of specific
    states related to the\n   use of a PCE in the context of Multiprotocol Label Switching
    (MPLS)\n   and Generalized MPLS (GMPLS) Traffic Engineering.  PCEP is designed\n
    \  to be flexible and extensible so as to easily allow for the addition\n   of
    further messages and objects, should further requirements be\n   expressed in
    the future.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................5\n
    \     1.1. Requirements Language ......................................5\n   2.
    Terminology .....................................................5\n   3. Assumptions
    .....................................................6\n   4. Architectural Protocol
    Overview (Model) .........................7\n      4.1. Problem ....................................................7\n
    \     4.2. Architectural Protocol Overview ............................7\n           4.2.1.
    Initialization Phase ................................8\n           4.2.2. Session
    Keepalive ...................................9\n           4.2.3. Path Computation
    Request Sent by a PCC to a PCE ....10\n           4.2.4. Path Computation Reply
    Sent by The PCE to a PCC ....11\n           4.2.5. Notification .......................................12\n
    \          4.2.6. Error ..............................................14\n           4.2.7.
    Termination of the PCEP Session ....................14\n           4.2.8. Intermittent
    versus Permanent PCEP Session .........15\n   5. Transport Protocol .............................................15\n
    \  6. PCEP Messages ..................................................15\n      6.1.
    Common Header .............................................16\n      6.2. Open
    Message ..............................................16\n      6.3. Keepalive
    Message .........................................18\n      6.4. Path Computation
    Request (PCReq) Message ..................19\n      6.5. Path Computation Reply
    (PCRep) Message ....................20\n      6.6. Notification (PCNtf) Message
    ..............................21\n      6.7. Error (PCErr) Message .....................................22\n
    \     6.8. Close Message .............................................23\n      6.9.
    Reception of Unknown Messages .............................23\n   7. Object Formats
    .................................................23\n      7.1. PCEP TLV Format
    ...........................................24\n      7.2. Common Object Header
    ......................................24\n      7.3. OPEN Object ...............................................25\n
    \     7.4. RP Object .................................................27\n           7.4.1.
    Object Definition ..................................27\n           7.4.2. Handling
    of the RP Object ..........................30\n      7.5. NO-PATH Object ............................................31\n
    \     7.6. END-POINTS Object .........................................34\n      7.7.
    BANDWIDTH Object ..........................................35\n      7.8. METRIC
    Object .............................................36\n      7.9. Explicit Route
    Object .....................................39\n      7.10. Reported Route Object
    ....................................39\n      7.11. LSPA Object ..............................................40\n
    \     7.12. Include Route Object .....................................42\n      7.13.
    SVEC Object ..............................................42\n           7.13.1.
    Notion of Dependent and Synchronized Path\n                   Computation Requests
    ..............................42\n           7.13.2. SVEC Object .......................................44\n
    \          7.13.3. Handling of the SVEC Object .......................45\n      7.14.
    NOTIFICATION Object ......................................46\n      7.15. PCEP-ERROR
    Object ........................................49\n      7.16. LOAD-BALANCING
    Object ....................................54\n      7.17. CLOSE Object .............................................55\n
    \  8. Manageability Considerations ...................................56\n      8.1.
    Control of Function and Policy ............................56\n      8.2. Information
    and Data Models ...............................57\n      8.3. Liveness Detection
    and Monitoring .........................57\n      8.4. Verifying Correct Operation
    ...............................58\n      8.5. Requirements on Other Protocols
    and Functional\n           Components ................................................58\n
    \     8.6. Impact on Network Operation ...............................58\n   9.
    IANA Considerations ............................................59\n      9.1.
    TCP Port ..................................................59\n      9.2. PCEP
    Messages .............................................59\n      9.3. PCEP Object
    ...............................................59\n      9.4. PCEP Message Common
    Header ................................61\n      9.5. Open Object Flag Field ....................................61\n
    \     9.6. RP Object .................................................61\n      9.7.
    NO-PATH Object Flag Field .................................62\n      9.8. METRIC
    Object .............................................63\n      9.9. LSPA Object
    Flag Field ....................................63\n      9.10. SVEC Object Flag
    Field ...................................64\n      9.11. NOTIFICATION Object ......................................64\n
    \     9.12. PCEP-ERROR Object ........................................65\n      9.13.
    LOAD-BALANCING Object Flag Field .........................67\n      9.14. CLOSE
    Object .............................................67\n      9.15. PCEP TLV Type
    Indicators .................................68\n      9.16. NO-PATH-VECTOR TLV
    .......................................68\n   10. Security Considerations .......................................69\n
    \     10.1. Vulnerability ............................................69\n      10.2.
    TCP Security Techniques ..................................70\n      10.3. PCEP
    Authentication and Integrity ........................70\n      10.4. PCEP Privacy
    .............................................71\n      10.5. Key Configuration
    and Exchange ...........................71\n      10.6. Access Policy ............................................73\n
    \     10.7. Protection against Denial-of-Service Attacks .............73\n           10.7.1.
    Protection against TCP DoS Attacks ................73\n           10.7.2. Request
    Input Shaping/Policing ....................74\n   11. Acknowledgments ...............................................75\n
    \  12. References ....................................................75\n      12.1.
    Normative References .....................................75\n      12.2. Informative
    References ...................................76\n   Appendix A.  PCEP Finite
    State Machine (FSM) ......................79\n   Appendix B.  PCEP Variables .......................................85\n
    \  Appendix C.  Contributors .........................................86\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   [RFC4655] describes the motivations and architecture for
    a Path\n   Computation Element (PCE) based model for the computation of\n   Multiprotocol
    Label Switching (MPLS) and Generalized MPLS (GMPLS)\n   Traffic Engineering Label
    Switched Paths (TE LSPs).  The model allows\n   for the separation of PCE from
    Path Computation Client (PCC), and\n   allows for the cooperation between PCEs.
    \ This necessitates a\n   communication protocol between PCC and PCE, and between
    PCEs.\n   [RFC4657] states the generic requirements for such a protocol\n   including
    that the same protocol be used between PCC and PCE, and\n   between PCEs.  Additional
    application-specific requirements (for\n   scenarios such as inter-area, inter-AS,
    etc.) are not included in\n   [RFC4657], but there is a requirement that any solution
    protocol must\n   be easily extensible to handle other requirements as they are\n
    \  introduced in application-specific requirements documents.  Examples\n   of
    such application-specific requirements are [RFC4927], [RFC5376],\n   and [INTER-LAYER].\n
    \  This document specifies the Path Computation Element Protocol (PCEP)\n   for
    communications between a PCC and a PCE, or between two PCEs, in\n   compliance
    with [RFC4657].  Such interactions include path\n   computation requests and path
    computation replies as well as\n   notifications of specific states related to
    the use of a PCE in the\n   context of MPLS and GMPLS Traffic Engineering.\n   PCEP
    is designed to be flexible and extensible so as to easily allow\n   for the addition
    of further messages and objects, should further\n   requirements be expressed
    in the future.\n"
  - contents:
    - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
      and \"OPTIONAL\" in this\n   document are to be interpreted as described in
      RFC 2119 [RFC2119].\n"
    title: 1.1.  Requirements Language
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   The following terminology is used in this document.\n   AS:
    \ Autonomous System.\n   Explicit path:  Full explicit path from start to destination;
    made of\n      a list of strict hops where a hop may be an abstract node such
    as\n      an AS.\n   IGP area:  OSPF area or IS-IS level.\n   Inter-domain TE
    LSP:  A TE LSP whose path transits at least two\n      different domains where
    a domain can be an IGP area, an Autonomous\n      System, or a sub-AS (BGP confederation).\n
    \  PCC:  Path Computation Client; any client application requesting a\n      path
    computation to be performed by a Path Computation Element.\n   PCE:  Path Computation
    Element; an entity (component, application, or\n      network node) that is capable
    of computing a network path or route\n      based on a network graph and applying
    computational constraints.\n   PCEP Peer:  An element involved in a PCEP session
    (i.e., a PCC or a\n      PCE).\n   TED:  Traffic Engineering Database that contains
    the topology and\n      resource information of the domain.  The TED may be fed
    by IGP\n      extensions or potentially by other means.\n   TE LSP:  Traffic Engineering
    Label Switched Path.\n   Strict/loose path:  A mix of strict and loose hops comprising
    at\n      least one loose hop representing the destination where a hop may\n      be
    an abstract node such as an AS.\n   Within this document, when describing PCE-PCE
    communications, the\n   requesting PCE fills the role of a PCC.  This provides
    a saving in\n   documentation without loss of function.\n   The message formats
    in this document are specified using Backus-Naur\n   Format (BNF) encoding as
    specified in [RBNF].\n"
  title: 2.  Terminology
- contents:
  - "3.  Assumptions\n   [RFC4655] describes various types of PCE.  PCEP does not
    make any\n   assumption about, and thus does not impose any constraint on, the\n
    \  nature of the PCE.\n   Moreover, it is assumed that the PCE has the required
    information\n   (usually including network topology and resource information)
    so as\n   to perform the computation of a path for a TE LSP.  Such information\n
    \  can be gathered by routing protocols or by some other means.  The way\n   in
    which the information is gathered is out of the scope of this\n   document.\n
    \  Similarly, no assumption is made about the discovery method used by a\n   PCC
    to discover a set of PCEs (e.g., via static configuration or\n   dynamic discovery)
    and on the algorithm used to select a PCE.  For\n   reference, [RFC4674] defines
    a list of requirements for dynamic PCE\n   discovery and IGP-based solutions for
    such PCE discovery are\n   specified in [RFC5088] and [RFC5089].\n"
  title: 3.  Assumptions
- contents:
  - "4.  Architectural Protocol Overview (Model)\n   The aim of this section is to
    describe the PCEP model in the spirit\n   of [RFC4101].  An architectural protocol
    overview (the big picture of\n   the protocol) is provided in this section.  Protocol
    details can be\n   found in further sections.\n"
  - contents:
    - "4.1.  Problem\n   The PCE-based architecture used for the computation of paths
      for MPLS\n   and GMPLS TE LSPs is described in [RFC4655].  When the PCC and
      the\n   PCE are not collocated, a communication protocol between the PCC and\n
      \  the PCE is needed.  PCEP is such a protocol designed specifically for\n   communications
      between a PCC and a PCE or between two PCEs in\n   compliance with [RFC4657]:
      a PCC may use PCEP to send a path\n   computation request for one or more TE
      LSPs to a PCE, and the PCE may\n   reply with a set of computed paths if one
      or more paths can be found\n   that satisfies the set of constraints.\n"
    title: 4.1.  Problem
  - contents:
    - "4.2.  Architectural Protocol Overview\n   PCEP operates over TCP, which fulfills
      the requirements for reliable\n   messaging and flow control without further
      protocol work.\n   Several PCEP messages are defined:\n   o  Open and Keepalive
      messages are used to initiate and maintain a\n      PCEP session, respectively.\n
      \  o  PCReq: a PCEP message sent by a PCC to a PCE to request a path\n      computation.\n
      \  o  PCRep: a PCEP message sent by a PCE to a PCC in reply to a path\n      computation
      request.  A PCRep message can contain either a set of\n      computed paths
      if the request can be satisfied, or a negative\n      reply if not.  The negative
      reply may indicate the reason why no\n      path could be found.\n   o  PCNtf:
      a PCEP notification message either sent by a PCC to a PCE\n      or sent by
      a PCE to a PCC to notify of a specific event.\n   o  PCErr: a PCEP message sent
      upon the occurrence of a protocol error\n      condition.\n   o  Close message:
      a message used to close a PCEP session.\n   The set of available PCEs may be
      either statically configured on a\n   PCC or dynamically discovered.  The mechanisms
      used to discover one\n   or more PCEs and to select a PCE are out of the scope
      of this\n   document.\n   A PCC may have PCEP sessions with more than one PCE,
      and similarly a\n   PCE may have PCEP sessions with multiple PCCs.\n   Each
      PCEP message is regarded as a single transmission unit and parts\n   of messages
      MUST NOT be interleaved.  So, for example, a PCC sending\n   a PCReq and wishing
      to close the session, must complete sending the\n   request message before starting
      to send a Close message.\n"
    - contents:
      - "4.2.1.  Initialization Phase\n   The initialization phase consists of two
        successive steps (described\n   in a schematic form in Figure 1):\n   1)  Establishment
        of a TCP connection (3-way handshake) between the\n       PCC and the PCE.\n
        \  2)  Establishment of a PCEP session over the TCP connection.\n   Once the
        TCP connection is established, the PCC and the PCE (also\n   referred to as
        \"PCEP peers\") initiate PCEP session establishment\n   during which various
        session parameters are negotiated.  These\n   parameters are carried within
        Open messages and include the Keepalive\n   timer, the DeadTimer, and potentially
        other detailed capabilities and\n   policy rules that specify the conditions
        under which path computation\n   requests may be sent to the PCE.  If the
        PCEP session establishment\n   phase fails because the PCEP peers disagree
        on the session parameters\n   or one of the PCEP peers does not answer after
        the expiration of the\n   establishment timer, the TCP connection is immediately
        closed.\n   Successive retries are permitted but an implementation should
        make\n   use of an exponential back-off session establishment retry procedure.\n
        \  Keepalive messages are used to acknowledge Open messages, and are\n   used
        once the PCEP session has been successfully established.\n   Only one PCEP
        session can exist between a pair of PCEP peers at any\n   one time.  Only
        one TCP connection on the PCEP port can exist between\n   a pair of PCEP peers
        at any one time.\n   Details about the Open message and the Keepalive message
        can be found\n   in Sections 6.2 and 6.3, respectively.\n               +-+-+
        \                +-+-+\n               |PCC|                 |PCE|\n               +-+-+
        \                +-+-+\n                 |                     |\n                 |
        Open msg            |\n                 |--------             |\n                 |
        \       \\   Open msg |\n                 |         \\  ---------|\n                 |
        \         \\/         |\n                 |          /\\         |\n                 |
        \        /  -------->|\n                 |        /            |\n                 |<------
        \    Keepalive|\n                 |             --------|\n                 |Keepalive
        \  /        |\n                 |--------   /         |\n                 |
        \       \\/           |\n                 |        /\\           |\n                 |<------
        \  ---------->|\n                 |                     |\n   Figure 1: PCEP
        Initialization Phase (Initiated by a PCC)\n   (Note that once the PCEP session
        is established, the exchange of\n   Keepalive messages is optional.)\n"
      title: 4.2.1.  Initialization Phase
    - contents:
      - "4.2.2.  Session Keepalive\n   Once a session has been established, a PCE
        or PCC may want to know\n   that its PCEP peer is still available for use.\n
        \  It can rely on TCP for this information, but it is possible that the\n
        \  remote PCEP function has failed without disturbing the TCP\n   connection.
        \ It is also possible to rely on the mechanisms built into\n   the TCP implementations,
        but these might not provide failure\n   notifications that are sufficiently
        timely.  Lastly, a PCC could wait\n   until it has a path computation request
        to send and could use its\n   failed transmission or the failure to receive
        a response as evidence\n   that the session has failed, but this is clearly
        inefficient.\n   In order to handle this situation, PCEP includes a keepalive\n
        \  mechanism based on a Keepalive timer, a DeadTimer, and a Keepalive\n   message.\n
        \  Each end of a PCEP session runs a Keepalive timer.  It restarts the\n   timer
        every time it sends a message on the session.  When the timer\n   expires,
        it sends a Keepalive message.  Other traffic may serve as\n   Keepalive (see
        Section 6.3).\n   The ends of the PCEP session also run DeadTimers, and they
        restart\n   the timers whenever a message is received on the session.  If
        one end\n   of the session receives no message before the DeadTimer expires,
        it\n   declares the session dead.\n   Note that this means that the Keepalive
        message is unresponded and\n   does not form part of a two-way keepalive handshake
        as used in some\n   protocols.  Also note that the mechanism is designed to
        reduce to a\n   minimum the amount of keepalive traffic on the session.\n
        \  The keepalive traffic on the session may be unbalanced according to\n   the
        requirements of the session ends.  Each end of the session can\n   specify
        (on an Open message) the Keepalive timer that it will use\n   (i.e., how often
        it will transmit a Keepalive message if there is no\n   other traffic) and
        a DeadTimer that it recommends its peer to use\n   (i.e., how long the peer
        should wait before declaring the session\n   dead if it receives no traffic).
        \ The session ends may use different\n   Keepalive timer values.\n   The minimum
        value of the Keepalive timer is 1 second, and it is\n   specified in units
        of 1 second.  The recommended default value is 30\n   seconds.  The timer
        may be disabled by setting it to zero.\n   The recommended default for the
        DeadTimer is 4 times the value of the\n   Keepalive timer used by the remote
        peer.  This means that there is\n   never any risk of congesting TCP with
        excessive Keepalive messages.\n"
      title: 4.2.2.  Session Keepalive
    - contents:
      - "4.2.3.  Path Computation Request Sent by a PCC to a PCE\n                     +-+-+
        \                 +-+-+\n                     |PCC|                  |PCE|\n
        \                    +-+-+                  +-+-+\n   1) Path computation
        |                      |\n      event            |                      |\n
        \  2) PCE Selection    |                      |\n   3) Path computation |----
        PCReq message--->|\n      request sent to  |                      |\n      the
        selected PCE |                      |\n               Figure 2: Path Computation
        Request\n   Once a PCC has successfully established a PCEP session with one
        or\n   more PCEs, if an event is triggered that requires the computation of\n
        \  a set of paths, the PCC first selects one or more PCEs.  Note that\n   the
        PCE selection decision process may have taken place prior to the\n   PCEP
        session establishment.\n   Once the PCC has selected a PCE, it sends a path
        computation request\n   to the PCE (PCReq message) that contains a variety
        of objects that\n   specify the set of constraints and attributes for the
        path to be\n   computed.  For example, \"Compute a TE LSP path with source
        IP\n   address=x.y.z.t, destination IP address=x'.y'.z'.t', bandwidth=B\n
        \  Mbit/s, Setup/Holding priority=P, ...\".  Additionally, the PCC may\n   desire
        to specify the urgency of such request by assigning a request\n   priority.
        \ Each request is uniquely identified by a request-id number\n   and the PCC-PCE
        address pair.  The process is shown in a schematic\n   form in Figure 2.\n
        \  Note that multiple path computation requests may be outstanding from\n
        \  a PCC to a PCE at any time.\n   Details about the PCReq message can be
        found in Section 6.4.\n"
      title: 4.2.3.  Path Computation Request Sent by a PCC to a PCE
    - contents:
      - "4.2.4.  Path Computation Reply Sent by The PCE to a PCC\n                 +-+-+
        \                 +-+-+\n                 |PCC|                  |PCE|\n                 +-+-+
        \                 +-+-+\n                   |                      |\n                   |----
        PCReq message--->|\n                   |                      |1) Path computation\n
        \                  |                      |   request received\n                   |
        \                     |\n                   |                      |2) Path
        successfully\n                   |                      |   computed\n                   |
        \                     |\n                   |                      |3) Computed
        paths\n                   |                      |   sent to the PCC\n                   |
        \                     |\n                   |<--- PCRep message ---|\n                   |
        \   (Positive reply)  |\n       Figure 3a: Path Computation Request With Successful\n
        \                      Path Computation\n                 +-+-+                  +-+-+\n
        \                |PCC|                  |PCE|\n                 +-+-+                  +-+-+\n
        \                  |                      |\n                   |                      |\n
        \                  |---- PCReq message--->|\n                   |                      |1)
        Path computation\n                   |                      |   request received\n
        \                  |                      |\n                   |                      |2)
        No Path found that\n                   |                      |   satisfies
        the request\n                   |                      |\n                   |
        \                     |3) Negative reply sent to\n                   |                      |
        \  the PCC (optionally with\n                   |                      |   various
        additional\n                   |                      |   information)\n                   |<---
        PCRep message ---|\n                   |   (Negative reply)   |\n       Figure
        3b: Path Computation Request With Unsuccessful\n                       Path
        Computation\n   Upon receiving a path computation request from a PCC, the
        PCE\n   triggers a path computation, the result of which can be either:\n
        \  o  Positive (Figure 3a): the PCE manages to compute a path that\n      satisfies
        the set of required constraints.  In this case, the PCE\n      returns the
        set of computed paths to the requesting PCC.  Note\n      that PCEP supports
        the capability to send a single request that\n      requires the computation
        of more than one path (e.g., computation\n      of a set of link-diverse paths).\n
        \  o  Negative (Figure 3b): no path could be found that satisfies the\n      set
        of constraints.  In this case, a PCE may provide the set of\n      constraints
        that led to the path computation failure.  Upon\n      receiving a negative
        reply, a PCC may decide to resend a modified\n      request or take any other
        appropriate action.\n   Details about the PCRep message can be found in Section
        6.5.\n"
      title: 4.2.4.  Path Computation Reply Sent by The PCE to a PCC
    - contents:
      - "4.2.5.  Notification\n   There are several circumstances in which a PCE may
        want to notify a\n   PCC of a specific event.  For example, suppose that the
        PCE suddenly\n   gets overloaded, potentially leading to unacceptable response
        times.\n   The PCE may want to notify one or more PCCs that some of their\n
        \  requests (listed in the notification) will not be satisfied or may\n   experience
        unacceptable delays.  Upon receiving such notification,\n   the PCC may decide
        to redirect its path computation requests to\n   another PCE should an alternate
        PCE be available.  Similarly, a PCC\n   may desire to notify a PCE of a particular
        event such as the\n   cancellation of pending requests.\n                       +-+-+
        \                 +-+-+\n                       |PCC|                  |PCE|\n
        \                      +-+-+                  +-+-+\n   1) Path computation
        \  |                      |\n      event              |                      |\n
        \  2) PCE Selection      |                      |\n   3) Path computation
        \  |---- PCReq message--->|\n      request X sent to  |                      |4)
        Path computation\n      the selected PCE   |                      |   request
        queued\n                         |                      |\n                         |
        \                     |\n   5) Path computation   |                      |\n
        \     request X cancelled|                      |\n                         |----
        PCNtf message -->|\n                         |                      |6) Path
        computation\n                         |                      |   request X
        cancelled\n      Figure 4: Example of PCC Notification (Cancellation Notification)\n
        \                            Sent to a PCE\n                       +-+-+                  +-+-+\n
        \                      |PCC|                  |PCE|\n                       +-+-+
        \                 +-+-+\n   1) Path computation   |                      |\n
        \     event              |                      |\n   2) PCE Selection      |
        \                     |\n   3) Path computation   |---- PCReq message--->|\n
        \     request X sent to  |                      |4) Path computation\n      the
        selected PCE   |                      |   request queued\n                         |
        \                     |\n                         |                      |\n
        \                        |                      |5) PCE gets overloaded\n
        \                        |                      |\n                         |
        \                     |\n                         |                      |6)
        Path computation\n                         |                      |   request
        X cancelled\n                         |                      |\n                         |<---
        PCNtf message----|\n     Figure 5: Example of PCE Notification (Cancellation
        Notification)\n                            Sent to a PCC\n   Details about
        the PCNtf message can be found in Section 6.6.\n"
      title: 4.2.5.  Notification
    - contents:
      - "4.2.6.  Error\n   The PCEP Error message (also referred to as a PCErr message)
        is sent\n   in several situations: when a protocol error condition is met
        or when\n   the request is not compliant with the PCEP specification (e.g.,\n
        \  capability not supported, reception of a message with a mandatory\n   missing
        object, policy violation, unexpected message, unknown request\n   reference).\n
        \                     +-+-+                  +-+-+\n                      |PCC|
        \                 |PCE|\n                      +-+-+                  +-+-+\n
        \  1) Path computation  |                      |\n      event             |
        \                     |\n   2) PCE Selection     |                      |\n
        \  3) Path computation  |---- PCReq message--->|\n      request X sent to
        |                      |4) Reception of a\n      the selected PCE  |                      |
        \  malformed object\n                        |                      |\n                        |
        \                     |5) Request discarded\n                        |                      |\n
        \                       |<-- PCErr message  ---|\n                        |
        \                     |\n     Figure 6: Example of Error Message Sent by a
        PCE to a PCC\n          in Reply to the Reception of a Malformed Object\n
        \  Details about the PCErr message can be found in Section 6.7.\n"
      title: 4.2.6.  Error
    - contents:
      - "4.2.7.  Termination of the PCEP Session\n   When one of the PCEP peers desires
        to terminate a PCEP session it\n   first sends a PCEP Close message and then
        closes the TCP connection.\n   If the PCEP session is terminated by the PCE,
        the PCC clears all the\n   states related to pending requests previously sent
        to the PCE.\n   Similarly, if the PCC terminates a PCEP session, the PCE clears
        all\n   pending path computation requests sent by the PCC in question as well\n
        \  as the related states.  A Close message can only be sent to terminate\n
        \  a PCEP session if the PCEP session has previously been established.\n   In
        case of TCP connection failure, the PCEP session is immediately\n   terminated.\n
        \  Details about the Close message can be found in Section 6.8.\n"
      title: 4.2.7.  Termination of the PCEP Session
    - contents:
      - "4.2.8.  Intermittent versus Permanent PCEP Session\n   An implementation
        may decide to keep the PCEP session alive (and thus\n   the corresponding
        TCP connection) for an unlimited time.  (For\n   instance, this may be appropriate
        when path computation requests are\n   sent on a frequent basis so as to avoid
        opening a TCP connection each\n   time a path computation request is needed,
        which would incur\n   additional processing delays.)  Conversely, in some
        other\n   circumstances, it may be desirable to systematically open and close
        a\n   PCEP session for each PCEP request (for instance, when sending a path\n
        \  computation request is a rare event).\n"
      title: 4.2.8.  Intermittent versus Permanent PCEP Session
    title: 4.2.  Architectural Protocol Overview
  title: 4.  Architectural Protocol Overview (Model)
- contents:
  - "5.  Transport Protocol\n   PCEP operates over TCP using a registered TCP port
    (4189).  This\n   allows the requirements of reliable messaging and flow control
    to be\n   met without further protocol work.  All PCEP messages MUST be sent\n
    \  using the registered TCP port for the source and destination TCP\n   port.\n"
  title: 5.  Transport Protocol
- contents:
  - "6.  PCEP Messages\n   A PCEP message consists of a common header followed by
    a variable-\n   length body made of a set of objects that can either be mandatory
    or\n   optional.  In the context of this document, an object is said to be\n   mandatory
    in a PCEP message when the object MUST be included for the\n   message to be considered
    valid.  A PCEP message with a missing\n   mandatory object MUST trigger an Error
    message (see Section 7.15).\n   Conversely, if an object is optional, the object
    may or may not be\n   present.\n   A flag referred to as the P flag is defined
    in the common header of\n   each PCEP object (see Section 7.2).  When this flag
    is set in an\n   object in a PCReq, the PCE MUST take the information carried
    in the\n   object into account during the path computation.  For example, the\n
    \  METRIC object defined in Section 7.8 allows a PCC to specify a\n   bounded
    acceptable path cost.  The METRIC object is optional, but a\n   PCC may set a
    flag to ensure that the constraint is taken into\n   account.  In this case, if
    the constraint cannot be taken into\n   account by the PCE, the PCE MUST trigger
    an Error message.\n   For each PCEP message type, rules are defined that specify
    the set of\n   objects that the message can carry.  We use the Backus-Naur Form\n
    \  (BNF) (see [RBNF]) to specify such rules.  Square brackets refer to\n   optional
    sub-sequences.  An implementation MUST form the PCEP\n   messages using the object
    ordering specified in this document.\n"
  - contents:
    - "6.1.  Common Header\n     0                   1                   2                   3\n
      \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   | Ver |  Flags  |  Message-Type |       Message-Length          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \               Figure 7: PCEP Message Common Header\n   Ver (Version - 3 bits):
      \ PCEP version number.  Current version is\n      version 1.\n   Flags (5 bits):
      \ No flags are currently defined.  Unassigned bits are\n      considered as
      reserved.  They MUST be set to zero on transmission\n      and MUST be ignored
      on receipt.\n   Message-Type (8 bits):  The following message types are currently\n
      \     defined:\n         Value    Meaning\n           1        Open\n           2
      \       Keepalive\n           3        Path Computation Request\n           4
      \       Path Computation Reply\n           5        Notification\n           6
      \       Error\n           7        Close\n   Message-Length (16 bits):  total
      length of the PCEP message including\n      the common header, expressed in
      bytes.\n"
    title: 6.1.  Common Header
  - contents:
    - "6.2.  Open Message\n   The Open message is a PCEP message sent by a PCC to
      a PCE and by a\n   PCE to a PCC in order to establish a PCEP session.  The Message-Type\n
      \  field of the PCEP common header for the Open message is set to 1.\n   Once
      the TCP connection has been successfully established, the first\n   message
      sent by the PCC to the PCE or by the PCE to the PCC MUST be\n   an Open message
      as specified in Appendix A.\n   Any message received prior to an Open message
      MUST trigger a protocol\n   error condition causing a PCErr message to be sent
      with Error-Type\n   \"PCEP session establishment failure\" and Error-value \"reception
      of an\n   invalid Open message or a non Open message\" and the PCEP session\n
      \  establishment attempt MUST be terminated by closing the TCP\n   connection.\n
      \  The Open message is used to establish a PCEP session between the PCEP\n   peers.
      \ During the establishment phase, the PCEP peers exchange\n   several session
      characteristics.  If both parties agree on such\n   characteristics, the PCEP
      session is successfully established.\n   The format of an Open message is as
      follows:\n   <Open Message>::= <Common Header>\n                     <OPEN>\n
      \  The Open message MUST contain exactly one OPEN object (see\n   Section 7.3).\n
      \  Various session characteristics are specified within the OPEN object.\n   Once
      the TCP connection has been successfully established, the sender\n   MUST start
      an initialization timer called OpenWait after the\n   expiration of which, if
      no Open message has been received, it sends a\n   PCErr message and releases
      the TCP connection (see Appendix A for\n   details).\n   Once an Open message
      has been sent to a PCEP peer, the sender MUST\n   start an initialization timer
      called KeepWait after the expiration of\n   which, if neither a Keepalive message
      has been received nor a PCErr\n   message in case of disagreement of the session
      characteristics, a\n   PCErr message MUST be sent and the TCP connection MUST
      be released\n   (see Appendix A for details).\n   The OpenWait and KeepWait
      timers have a fixed value of 1 minute.\n   Upon the receipt of an Open message,
      the receiving PCEP peer MUST\n   determine whether the suggested PCEP session
      characteristics are\n   acceptable.  If at least one of the characteristics
      is not acceptable\n   to the receiving peer, it MUST send an Error message.
      \ The Error\n   message SHOULD also contain the related OPEN object and, for
      each\n   unacceptable session parameter, an acceptable parameter value SHOULD\n
      \  be proposed in the appropriate field of the OPEN object in place of\n   the
      originally proposed value.  The PCEP peer MAY decide to resend an\n   Open message
      with different session characteristics.  If a second\n   Open message is received
      with the same set of parameters or with\n   parameters that are still unacceptable,
      the receiving peer MUST send\n   an Error message and it MUST immediately close
      the TCP connection.\n   Details about error messages can be found in Section
      7.15.\n   Successive retries are permitted, but an implementation SHOULD make\n
      \  use of an exponential back-off session establishment retry procedure.\n   If
      the PCEP session characteristics are acceptable, the receiving\n   PCEP peer
      MUST send a Keepalive message (defined in Section 6.3) that\n   serves as an
      acknowledgment.\n   The PCEP session is considered as established once both
      PCEP peers\n   have received a Keepalive message from their peer.\n"
    title: 6.2.  Open Message
  - contents:
    - "6.3.  Keepalive Message\n   A Keepalive message is a PCEP message sent by a
      PCC or a PCE in order\n   to keep the session in active state.  The Keepalive
      message is also\n   used in response to an Open message to acknowledge that
      an Open\n   message has been received and that the PCEP session characteristics\n
      \  are acceptable.  The Message-Type field of the PCEP common header for\n   the
      Keepalive message is set to 2.  The Keepalive message does not\n   contain any
      object.\n   PCEP has its own keepalive mechanism used to ensure the liveness
      of\n   the PCEP session.  This requires the determination of the frequency\n
      \  at which each PCEP peer sends Keepalive messages.  Asymmetric values\n   may
      be chosen; thus, there is no constraint mandating the use of\n   identical keepalive
      frequencies by both PCEP peers.  The DeadTimer is\n   defined as the period
      of time after the expiration of which a PCEP\n   peer declares the session down
      if no PCEP message has been received\n   (Keepalive or any other PCEP message);
      thus, any PCEP message acts as\n   a Keepalive message.  Similarly, there are
      no constraints mandating\n   the use of identical DeadTimers by both PCEP peers.
      \ The minimum\n   Keepalive timer value is 1 second.  Deployments SHOULD consider\n
      \  carefully the impact of using low values for the Keepalive timer as\n   these
      might not give rise to the expected results in periods of\n   temporary network
      instability.\n   Keepalive messages are sent at the frequency specified in the
      OPEN\n   object carried within an Open message according to the rules\n   specified
      in Section 7.3.  Because any PCEP message may serve as\n   Keepalive, an implementation
      may either decide to send Keepalive\n   messages at fixed intervals regardless
      of whether other PCEP messages\n   might have been sent since the last sent
      Keepalive message, or may\n   decide to differ the sending of the next Keepalive
      message based on\n   the time at which the last PCEP message (other than Keepalive)
      was\n   sent.\n   Note that sending Keepalive messages to keep the session alive
      is\n   optional, and PCEP peers may decide not to send Keepalive messages\n
      \  once the PCEP session is established; in which case, the peer that\n   does
      not receive Keepalive messages does not expect to receive them\n   and MUST
      NOT declare the session as inactive.\n   The format of a Keepalive message is
      as follows:\n   <Keepalive Message>::= <Common Header>\n"
    title: 6.3.  Keepalive Message
  - contents:
    - "6.4.  Path Computation Request (PCReq) Message\n   A Path Computation Request
      message (also referred to as a PCReq\n   message) is a PCEP message sent by
      a PCC to a PCE to request a path\n   computation.  A PCReq message may carry
      more than one path\n   computation request.  The Message-Type field of the PCEP
      common\n   header for the PCReq message is set to 3.\n   There are two mandatory
      objects that MUST be included within a PCReq\n   message: the RP and the END-POINTS
      objects (see Section 7).  If one\n   or both of these objects is missing, the
      receiving PCE MUST send an\n   error message to the requesting PCC.  Other objects
      are optional.\n   The format of a PCReq message is as follows:\n   <PCReq Message>::=
      <Common Header>\n                      [<svec-list>]\n                      <request-list>\n
      \  where:\n      <svec-list>::=<SVEC>[<svec-list>]\n      <request-list>::=<request>[<request-list>]\n
      \     <request>::= <RP>\n                   <END-POINTS>\n                   [<LSPA>]\n
      \                  [<BANDWIDTH>]\n                   [<metric-list>]\n                   [<RRO>[<BANDWIDTH>]]\n
      \                  [<IRO>]\n                   [<LOAD-BALANCING>]\n   where:\n
      \  <metric-list>::=<METRIC>[<metric-list>]\n   The SVEC, RP, END-POINTS, LSPA,
      BANDWIDTH, METRIC, RRO, IRO, and\n   LOAD-BALANCING objects are defined in Section
      7.  The special case of\n   two BANDWIDTH objects is discussed in detail in
      Section 7.7.\n   A PCEP implementation is free to process received requests
      in any\n   order.  For example, the requests may be processed in the order they\n
      \  are received, reordered and assigned priority according to local\n   policy,
      reordered according to the priority encoded in the RP object\n   (Section 7.4.1),
      or processed in parallel.\n"
    title: 6.4.  Path Computation Request (PCReq) Message
  - contents:
    - "6.5.  Path Computation Reply (PCRep) Message\n   The PCEP Path Computation
      Reply message (also referred to as a PCRep\n   message) is a PCEP message sent
      by a PCE to a requesting PCC in\n   response to a previously received PCReq
      message.  The Message-Type\n   field of the PCEP common header for the PCRep
      message is set to 4.\n   The bundling of multiple replies to a set of path computation\n
      \  requests within a single PCRep message is supported by PCEP.  If a\n   PCE
      receives non-synchronized path computation requests by means of\n   one or more
      PCReq messages from a requesting PCC, it MAY decide to\n   bundle the computed
      paths within a single PCRep message so as to\n   reduce the control plane load.
      \ Note that the counter side of such an\n   approach is the introduction of
      additional delays for some path\n   computation requests of the set.  Conversely,
      a PCE that receives\n   multiple requests within the same PCReq message MAY
      decide to provide\n   each computed path in separate PCRep messages or within
      the same\n   PCRep message.  A PCRep message may contain positive and negative\n
      \  replies.\n   A PCRep message may contain a set of computed paths corresponding
      to\n   either a single path computation request with load-balancing (see\n   Section
      7.16) or multiple path computation requests originated by a\n   requesting PCC.
      \ The PCRep message may also contain multiple\n   acceptable paths corresponding
      to the same request.\n   The PCRep message MUST contain at least one RP object.
      \ For each\n   reply that is bundled into a single PCReq message, an RP object
      MUST\n   be included that contains a Request-ID-number identical to the one\n
      \  specified in the RP object carried in the corresponding PCReq message\n   (see
      Section 7.4 for the definition of the RP object).\n   If the path computation
      request can be satisfied (i.e., the PCE finds\n   a set of paths that satisfy
      the set of constraints), the set of\n   computed paths specified by means of
      Explicit Route Objects (EROs) is\n   inserted in the PCRep message.  The ERO
      is defined in Section 7.9.\n   The situation where multiple computed paths are
      provided in a PCRep\n   message is discussed in detail in Section 7.13.  Furthermore,
      when a\n   PCC requests the computation of a set of paths for a total amount
      of\n   bandwidth by means of a LOAD-BALANCING object carried within a PCReq\n
      \  message, the ERO of each computed path may be followed by a BANDWIDTH\n   object
      as discussed in section Section 7.16.\n   If the path computation request cannot
      be satisfied, the PCRep\n   message MUST include a NO-PATH object.  The NO-PATH
      object (described\n   in Section 7.5) may also contain other information (e.g,
      reasons for\n   the path computation failure).\n   The format of a PCRep message
      is as follows:\n   <PCRep Message> ::= <Common Header>\n                       <response-list>\n
      \  where:\n      <response-list>::=<response>[<response-list>]\n      <response>::=<RP>\n
      \                 [<NO-PATH>]\n                  [<attribute-list>]\n                  [<path-list>]\n
      \     <path-list>::=<path>[<path-list>]\n      <path>::= <ERO><attribute-list>\n
      \  where:\n    <attribute-list>::=[<LSPA>]\n                       [<BANDWIDTH>]\n
      \                      [<metric-list>]\n                       [<IRO>]\n    <metric-list>::=<METRIC>[<metric-list>]\n"
    title: 6.5.  Path Computation Reply (PCRep) Message
  - contents:
    - "6.6.  Notification (PCNtf) Message\n   The PCEP Notification message (also
      referred to as the PCNtf message)\n   can be sent either by a PCE to a PCC,
      or by a PCC to a PCE, to notify\n   of a specific event.  The Message-Type field
      of the PCEP common\n   header for the PCNtf message is set to 5.\n   The PCNtf
      message MUST carry at least one NOTIFICATION object and MAY\n   contain several
      NOTIFICATION objects should the PCE or the PCC intend\n   to notify of multiple
      events.  The NOTIFICATION object is defined in\n   Section 7.14.  The PCNtf
      message MAY also contain RP objects (see\n   Section 7.4) when the notification
      refers to particular path\n   computation requests.\n   The PCNtf message may
      be sent by a PCC or a PCE in response to a\n   request or in an unsolicited
      manner.\n   The format of a PCNtf message is as follows:\n   <PCNtf Message>::=<Common
      Header>\n                     <notify-list>\n   <notify-list>::=<notify> [<notify-list>]\n
      \  <notify>::= [<request-id-list>]\n                <notification-list>\n   <request-id-list>::=<RP>[<request-id-list>]\n
      \  <notification-list>::=<NOTIFICATION>[<notification-list>]\n"
    title: 6.6.  Notification (PCNtf) Message
  - contents:
    - "6.7.  Error (PCErr) Message\n   The PCEP Error message (also referred to as
      a PCErr message) is sent\n   in several situations: when a protocol error condition
      is met or when\n   the request is not compliant with the PCEP specification
      (e.g.,\n   reception of a malformed message, reception of a message with a\n
      \  mandatory missing object, policy violation, unexpected message,\n   unknown
      request reference).  The Message-Type field of the PCEP\n   common header for
      the PCErr message is set to 6.\n   The PCErr message is sent by a PCC or a PCE
      in response to a request\n   or in an unsolicited manner.  If the PCErr message
      is sent in\n   response to a request, the PCErr message MUST include the set
      of RP\n   objects related to the pending path computation requests that\n   triggered
      the error condition.  In the latter case (unsolicited), no\n   RP object is
      inserted in the PCErr message.  For example, no RP\n   object is inserted in
      a PCErr when the error condition occurred\n   during the initialization phase.
      \ A PCErr message MUST contain a\n   PCEP-ERROR object specifying the PCEP error
      condition.  The PCEP-\n   ERROR object is defined in Section 7.15.\n   The format
      of a PCErr message is as follows:\n   <PCErr Message> ::= <Common Header>\n
      \                      ( <error-obj-list> [<Open>] ) | <error>\n                       [<error-list>]\n
      \  <error-obj-list>::=<PCEP-ERROR>[<error-obj-list>]\n   <error>::=[<request-id-list>]\n
      \             <error-obj-list>\n   <request-id-list>::=<RP>[<request-id-list>]\n
      \  <error-list>::=<error>[<error-list>]\n   The procedure upon the receipt of
      a PCErr message is defined in\n   Section 7.15.\n"
    title: 6.7.  Error (PCErr) Message
  - contents:
    - "6.8.  Close Message\n   The Close message is a PCEP message that is either
      sent by a PCC to a\n   PCE or by a PCE to a PCC in order to close an established
      PCEP\n   session.  The Message-Type field of the PCEP common header for the\n
      \  Close message is set to 7.\n   The format of a Close message is as follows:\n
      \  <Close Message>::= <Common Header>\n                      <CLOSE>\n   The
      Close message MUST contain exactly one CLOSE object (see\n   Section 6.8).  If
      more than one CLOSE object is present, the first\n   MUST be processed and subsequent
      objects ignored.\n   Upon the receipt of a valid Close message, the receiving
      PCEP peer\n   MUST cancel all pending requests, it MUST close the TCP connection\n
      \  and MUST NOT send any further PCEP messages on the PCEP session.\n"
    title: 6.8.  Close Message
  - contents:
    - "6.9.  Reception of Unknown Messages\n   A PCEP implementation that receives
      an unrecognized PCEP message MUST\n   send a PCErr message with Error-value=2
      (capability not supported).\n   If a PCC/PCE receives unrecognized messages
      at a rate equal or\n   greater than MAX-UNKNOWN-MESSAGES unknown message requests
      per\n   minute, the PCC/PCE MUST send a PCEP CLOSE message with close\n   value=\"Reception
      of an unacceptable number of unknown PCEP message\".\n   A RECOMMENDED value
      for MAX-UNKNOWN-MESSAGES is 5.  The PCC/PCE MUST\n   close the TCP session and
      MUST NOT send any further PCEP messages on\n   the PCEP session.\n"
    title: 6.9.  Reception of Unknown Messages
  title: 6.  PCEP Messages
- contents:
  - "7.  Object Formats\n   PCEP objects have a common format.  They begin with a
    common object\n   header (see Section 7.2).  This is followed by object-specific
    fields\n   defined for each different object.  The object may also include one\n
    \  or more type-length-value (TLV) encoded data sets.  Each TLV has the\n   same
    structure as described in Section 7.1.\n"
  - contents:
    - "7.1.  PCEP TLV Format\n   A PCEP object may include a set of one or more optional
      TLVs.\n   All PCEP TLVs have the following format:\n   Type:   2 bytes\n   Length:
      2 bytes\n   Value:  variable\n   A PCEP object TLV is comprised of 2 bytes for
      the type, 2 bytes\n   specifying the TLV length, and a value field.\n   The
      Length field defines the length of the value portion in bytes.\n   The TLV is
      padded to 4-bytes alignment; padding is not included in\n   the Length field
      (so a 3-byte value would have a length of 3, but the\n   total size of the TLV
      would be 8 bytes).\n   Unrecognized TLVs MUST be ignored.\n   IANA management
      of the PCEP Object TLV type identifier codespace is\n   described in Section
      9.\n"
    title: 7.1.  PCEP TLV Format
  - contents:
    - "7.2.  Common Object Header\n   A PCEP object carried within a PCEP message
      consists of one or more\n   32-bit words with a common header that has the following
      format:\n    0                   1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | Object-Class  |   OT  |Res|P|I|   Object Length (bytes)       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                                                               |\n   //
      \                       (Object body)                        //\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                  Figure
      8: PCEP Common Object Header\n   Object-Class (8 bits):  identifies the PCEP
      object class.\n   OT (Object-Type - 4 bits):  identifies the PCEP object type.\n
      \     The Object-Class and Object-Type fields are managed by IANA.\n      The
      Object-Class and Object-Type fields uniquely identify each\n      PCEP object.\n
      \  Res flags (2 bits):  Reserved field.  This field MUST be set to zero\n      on
      transmission and MUST be ignored on receipt.\n   P flag (Processing-Rule - 1-bit):
      \ the P flag allows a PCC to specify\n      in a PCReq message sent to a PCE
      whether the object must be taken\n      into account by the PCE during path
      computation or is just\n      optional.  When the P flag is set, the object
      MUST be taken into\n      account by the PCE.  Conversely, when the P flag is
      cleared, the\n      object is optional and the PCE is free to ignore it.\n   I
      flag (Ignore - 1 bit):  the I flag is used by a PCE in a PCRep\n      message
      to indicate to a PCC whether or not an optional object was\n      processed.
      \ The PCE MAY include the ignored optional object in its\n      reply and set
      the I flag to indicate that the optional object was\n      ignored during path
      computation.  When the I flag is cleared, the\n      PCE indicates that the
      optional object was processed during the\n      path computation.  The setting
      of the I flag for optional objects\n      is purely indicative and optional.
      \ The I flag has no meaning in a\n      PCRep message when the P flag has been
      set in the corresponding\n      PCReq message.\n   If the PCE does not understand
      an object with the P flag set or\n   understands the object but decides to ignore
      the object, the entire\n   PCEP message MUST be rejected and the PCE MUST send
      a PCErr message\n   with Error-Type=\"Unknown Object\" or \"Not supported Object\"
      along with\n   the corresponding RP object.  Note that if a PCReq includes multiple\n
      \  requests, only requests for which an object with the P flag set is\n   unknown/unrecognized
      MUST be rejected.\n   Object Length (16 bits):  Specifies the total object length
      including\n      the header, in bytes.  The Object Length field MUST always
      be a\n      multiple of 4, and at least 4.  The maximum object content length\n
      \     is 65528 bytes.\n"
    title: 7.2.  Common Object Header
  - contents:
    - "7.3.  OPEN Object\n   The OPEN object MUST be present in each Open message
      and MAY be\n   present in a PCErr message.  There MUST be only one OPEN object
      per\n   Open or PCErr message.\n   The OPEN object contains a set of fields
      used to specify the PCEP\n   version, Keepalive frequency, DeadTimer, and PCEP
      session ID, along\n   with various flags.  The OPEN object may also contain
      a set of TLVs\n   used to convey various session characteristics such as the
      detailed\n   PCE capabilities, policy rules, and so on.  No TLVs are currently\n
      \  defined.\n   OPEN Object-Class is 1.\n   OPEN Object-Type is 1.\n   The format
      of the OPEN object body is as follows:\n    0                   1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | Ver |   Flags |   Keepalive   |  DeadTimer    |      SID      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                                                               |\n   //
      \                      Optional TLVs                         //\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                    Figure
      9: OPEN Object Format\n   Ver (3 bits):  PCEP version.  Current version is 1.\n
      \  Flags (5 bits):  No flags are currently defined.  Unassigned bits are\n      considered
      as reserved.  They MUST be set to zero on transmission\n      and MUST be ignored
      on receipt.\n   Keepalive (8 bits):  maximum period of time (in seconds) between
      two\n      consecutive PCEP messages sent by the sender of this message.  The\n
      \     minimum value for the Keepalive is 1 second.  When set to 0, once\n      the
      session is established, no further Keepalive messages are sent\n      to the
      remote peer.  A RECOMMENDED value for the keepalive\n      frequency is 30 seconds.\n
      \  DeadTimer (8 bits):  specifies the amount of time after the\n      expiration
      of which the PCEP peer can declare the session with the\n      sender of the
      Open message to be down if no PCEP message has been\n      received.  The DeadTimer
      SHOULD be set to 0 and MUST be ignored if\n      the Keepalive is set to 0.
      \ A RECOMMENDED value for the DeadTimer\n      is 4 times the value of the Keepalive.\n
      \  Example:\n   A sends an Open message to B with Keepalive=10 seconds and\n
      \  DeadTimer=40 seconds.  This means that A sends Keepalive messages (or\n   any
      other PCEP message) to B every 10 seconds and B can declare the\n   PCEP session
      with A down if no PCEP message has been received from A\n   within any 40-second
      period.\n   SID (PCEP session ID - 8 bits):  unsigned PCEP session number that\n
      \     identifies the current session.  The SID MUST be incremented each\n      time
      a new PCEP session is established.  It is used for logging\n      and troubleshooting
      purposes.  Each increment SHOULD have a value\n      of 1 and may cause a wrap
      back to zero.\n      The SID is used to disambiguate instances of sessions to
      the same\n      peer.  A PCEP implementation could use a single source of SIDs\n
      \     across all peers, or one source for each peer.  The former might\n      constrain
      the implementation to only 256 concurrent sessions.  The\n      latter potentially
      requires more states.  There is one SID number\n      in each direction.\n   Optional
      TLVs may be included within the OPEN object body to specify\n   PCC or PCE characteristics.
      \ The specification of such TLVs is\n   outside the scope of this document.\n
      \  When present in an Open message, the OPEN object specifies the\n   proposed
      PCEP session characteristics.  Upon receiving unacceptable\n   PCEP session
      characteristics during the PCEP session initialization\n   phase, the receiving
      PCEP peer (PCE) MAY include an OPEN object\n   within the PCErr message so as
      to propose alternative acceptable\n   session characteristic values.\n"
    title: 7.3.  OPEN Object
  - contents:
    - "7.4.  RP Object\n   The RP (Request Parameters) object MUST be carried within
      each PCReq\n   and PCRep messages and MAY be carried within PCNtf and PCErr\n
      \  messages.  The RP object is used to specify various characteristics\n   of
      the path computation request.\n   The P flag of the RP object MUST be set in
      PCReq and PCRep messages\n   and MUST be cleared in PCNtf and PCErr messages.
      \ If the RP object is\n   received with the P flag set incorrectly according
      to the rules\n   stated above, the receiving peer MUST send a PCErr message
      with\n   Error-Type=10 and Error-value=1.  The corresponding path computation\n
      \  request MUST be cancelled by the PCE without further notification.\n"
    - contents:
      - "7.4.1.  Object Definition\n   RP Object-Class is 2.\n   RP Object-Type is
        1.\n   The format of the RP object body is as follows:\n    0                   1
        \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                          Flags                    |O|B|R| Pri |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                        Request-ID-number                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                                                               |\n   //
        \                     Optional TLVs                          //\n   |                                                               |\n
        \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                  Figure
        10: RP Object Body Format\n   The RP object body has a variable length and
        may contain additional\n   TLVs.  No TLVs are currently defined.\n   Flags
        (32 bits)\n   The following flags are currently defined:\n   o  Pri (Priority
        - 3 bits): the Priority field may be used by the\n      requesting PCC to
        specify to the PCE the request's priority from 1\n      to 7.  The decision
        of which priority should be used for a\n      specific request is a local
        matter; it MUST be set to 0 when\n      unused.  Furthermore, the use of the
        path computation request\n      priority by the PCE's scheduler is implementation
        specific and out\n      of the scope of this document.  Note that it is not
        required for a\n      PCE to support the priority field: in this case, it
        is RECOMMENDED\n      that the PCC set the priority field to 0 in the RP object.
        \ If the\n      PCE does not take into account the request priority, it is\n
        \     RECOMMENDED to set the priority field to 0 in the RP object\n      carried
        within the corresponding PCRep message, regardless of the\n      priority
        value contained in the RP object carried within the\n      corresponding PCReq
        message.  A higher numerical value of the\n      priority field reflects a
        higher priority.  Note that it is the\n      responsibility of the network
        administrator to make use of the\n      priority values in a consistent manner
        across the various PCCs.\n      The ability of a PCE to support request prioritization
        MAY be\n      dynamically discovered by the PCCs by means of PCE capability\n
        \     discovery.  If not advertised by the PCE, a PCC may decide to set\n
        \     the request priority and will learn the ability of the PCE to\n      support
        request prioritization by observing the Priority field of\n      the RP object
        received in the PCRep message.  If the value of the\n      Pri field is set
        to 0, this means that the PCE does not support\n      the handling of request
        priorities: in other words, the path\n      computation request has been honored
        but without taking the\n      request priority into account.\n   o  R (Reoptimization
        - 1 bit): when set, the requesting PCC specifies\n      that the PCReq message
        relates to the reoptimization of an\n      existing TE LSP.  For all TE LSPs
        except zero-bandwidth LSPs, when\n      the R bit is set, an RRO (see Section
        7.10) MUST be included in\n      the PCReq message to show the path of the
        existing TE LSP.  Also,\n      for all TE LSPs except zero-bandwidth LSPs,
        when the R bit is set,\n      the existing bandwidth of the TE LSP to be reoptimized
        MUST be\n      supplied in a BANDWIDTH object (see Section 7.7).  This BANDWIDTH\n
        \     object is in addition to the instance of that object used to\n      describe
        the desired bandwidth of the reoptimized LSP.  For zero-\n      bandwidth
        LSPs, the RRO and BANDWIDTH objects that report the\n      characteristics
        of the existing TE LSP are optional.\n   o  B (Bi-directional - 1 bit): when
        set, the PCC specifies that the\n      path computation request relates to
        a bi-directional TE LSP that\n      has the same traffic engineering requirements
        including fate\n      sharing, protection and restoration, LSRs, TE links,
        and resource\n      requirements (e.g., latency and jitter) in each direction.
        \ When\n      cleared, the TE LSP is unidirectional.\n   o  O (strict/loose
        - 1 bit): when set, in a PCReq message, this\n      indicates that a loose
        path is acceptable.  Otherwise, when\n      cleared, this indicates to the
        PCE that a path exclusively made of\n      strict hops is required.  In a
        PCRep message, when the O bit is\n      set this indicates that the returned
        path is a loose path;\n      otherwise (when the O bit is cleared), the returned
        path is made\n      of strict hops.\n   Unassigned bits are considered reserved.
        \ They MUST be set to zero on\n   transmission and MUST be ignored on receipt.\n
        \  Request-ID-number (32 bits):  The Request-ID-number value combined\n      with
        the source IP address of the PCC and the PCE address uniquely\n      identify
        the path computation request context.  The Request-ID-\n      number is used
        for disambiguation between pending requests, and\n      thus it MUST be changed
        (such as by incrementing it) each time a\n      new request is sent to the
        PCE, and may wrap.\n      The value 0x00000000 is considered invalid.\n      If
        no path computation reply is received from the PCE (e.g., the\n      request
        is dropped by the PCE because of memory overflow), and the\n      PCC wishes
        to resend its request, the same Request-ID-number MUST\n      be used.  Upon
        receiving a path computation request from a PCC\n      with the same Request-ID-number,
        the PCE SHOULD treat the request\n      as a new request.  An implementation
        MAY choose to cache path\n      computation replies in order to quickly handle
        retransmission\n      without having to process a path computation request
        twice (in the\n      case that the first request was dropped or lost).  Upon
        receiving\n      a path computation reply from a PCE with the same Request-ID-\n
        \     number, the PCC SHOULD silently discard the path computation\n      reply.\n
        \     Conversely, different Request-ID-numbers MUST be used for\n      different
        requests sent to a PCE.\n      The same Request-ID-number MAY be used for
        path computation\n      requests sent to different PCEs.  The path computation
        reply is\n      unambiguously identified by the IP source address of the replying\n
        \     PCE.\n"
      title: 7.4.1.  Object Definition
    - contents:
      - "7.4.2.  Handling of the RP Object\n   If a PCReq message is received that
        does not contain an RP object,\n   the PCE MUST send a PCErr message to the
        requesting PCC with Error-\n   Type=\"Required Object missing\" and Error-value=\"RP
        Object missing\".\n   If the O bit of the RP message carried within a PCReq
        message is\n   cleared and local policy has been configured on the PCE to
        not\n   provide explicit paths (for instance, for confidentiality reasons),
        a\n   PCErr message MUST be sent by the PCE to the requesting PCC and the\n
        \  pending path computation request MUST be discarded.  The Error-Type\n   is
        \"Policy Violation\" and Error-value is \"O bit cleared\".\n   When the R
        bit of the RP object is set in a PCReq message, this\n   indicates that the
        path computation request relates to the\n   reoptimization of an existing
        TE LSP.  In this case, the PCC MUST\n   also provide the strict/loose path
        by including an RRO object in the\n   PCReq message so as to avoid/limit double-bandwidth
        counting if and\n   only if the TE LSP is a non-zero-bandwidth TE LSP.  If
        the PCC has\n   not requested a strict path (O bit set), a reoptimization
        can still\n   be requested by the PCC, but this requires that the PCE either
        be\n   stateful (keep track of the previously computed path with the\n   associated
        list of strict hops), or have the ability to retrieve the\n   complete required
        path segment.  Alternatively, the PCC MUST inform\n   the PCE about the working
        path and the associated list of strict hops\n   in PCReq.  The absence of
        an RRO in the PCReq message for a non-zero-\n   bandwidth TE LSP (when the
        R bit of the RP object is set) MUST\n   trigger the sending of a PCErr message
        with Error-Type=\"Required\n   Object Missing\" and Error-value=\"RRO Object
        missing for\n   reoptimization\".\n   If a PCC/PCE receives a PCRep/PCReq
        message that contains an RP\n   object referring to an unknown Request-ID-number,
        the PCC/PCE MUST\n   send a PCErr message with Error-Type=\"Unknown request
        reference\".\n   This is used for debugging purposes.  If a PCC/PCE receives
        PCRep/\n   PCReq messages with unknown requests at a rate equal or greater
        than\n   MAX-UNKNOWN-REQUESTS unknown requests per minute, the PCC/PCE MUST\n
        \  send a PCEP CLOSE message with close value=\"Reception of an\n   unacceptable
        number of unknown requests/replies\".  A RECOMMENDED\n   value for MAX-UNKNOWN-REQUESTS
        is 5.  The PCC/PCE MUST close the TCP\n   session and MUST NOT send any further
        PCEP messages on the PCEP\n   session.\n   The reception of a PCEP message
        that contains an RP object referring\n   to a Request-ID-number=0x00000000
        MUST be treated in similar manner\n   as an unknown request.\n"
      title: 7.4.2.  Handling of the RP Object
    title: 7.4.  RP Object
  - contents:
    - "7.5.  NO-PATH Object\n   The NO-PATH object is used in PCRep messages in response
      to an\n   unsuccessful path computation request (the PCE could not find a path\n
      \  satisfying the set of constraints).  When a PCE cannot find a path\n   satisfying
      a set of constraints, it MUST include a NO-PATH object in\n   the PCRep message.\n
      \  There are several categories of issue that can lead to a negative\n   reply.
      \ For example, the PCE chain might be broken (should there be\n   more than
      one PCE involved in the path computation) or no path\n   obeying the set constraints
      could be found.  The \"NI (Nature of\n   Issue)\" field in the NO-PATH object
      is used to report the error\n   category.\n   Optionally, if the PCE supports
      such capability, the NO-PATH object\n   MAY contain an optional NO-PATH-VECTOR
      TLV defined below and used to\n   provide more information on the reasons that
      led to a negative reply.\n   The PCRep message MAY also contain a list of objects
      that specify the\n   set of constraints that could not be satisfied.  The PCE
      MAY just\n   replicate the set of objects that was received that was the cause
      of\n   the unsuccessful computation or MAY optionally report a suggested\n   value
      for which a path could have been found (in which case, the\n   value differs
      from the value in the original request).\n   NO-PATH Object-Class is 3.\n   NO-PATH
      Object-Type is 1.\n   The format of the NO-PATH object body is as follows:\n
      \   0                   1                   2                   3\n    0 1 2
      3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |Nature of Issue|C|          Flags              |   Reserved    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                                                               |\n   //
      \                     Optional TLVs                          //\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                 Figure
      11: NO-PATH Object Format\n   NI - Nature of Issue (8 bits):  The NI field is
      used to report the\n      nature of the issue that led to a negative reply.
      \ Two values are\n      currently defined:\n         0: No path satisfying the
      set of constraints could be found\n         1: PCE chain broken\n      The Nature
      of Issue field value can be used by the PCC for various\n      purposes:\n      *
      \ Constraint adjustment before reissuing a new path computation\n         request,\n
      \     *  Explicit selection of a new PCE chain,\n      *  Logging of the error
      type for further action by the network\n         administrator.\n      IANA
      management of the NI field codespace is described in\n      Section 9.\n   Flags
      (16 bits).\n   The following flag is currently defined:\n   o  C flag (1 bit):
      when set, the PCE indicates the set of unsatisfied\n      constraints (reasons
      why a path could not be found) in the PCRep\n      message by including the
      relevant PCEP objects.  When cleared, no\n      failing constraints are specified.
      \ The C flag has no meaning and\n      is ignored unless the NI field is set
      to 0x00.\n   Unassigned bits are considered as reserved.  They MUST be set to
      zero\n   on transmission and MUST be ignored on receipt.\n   Reserved (8 bits):
      \ This field MUST be set to zero on transmission\n      and MUST be ignored
      on receipt.\n   The NO-PATH object body has a variable length and may contain\n
      \  additional TLVs.  The only TLV currently defined is the NO-PATH-\n   VECTOR
      TLV defined below.\n   Example: consider the case of a PCC that sends a path
      computation\n   request to a PCE for a TE LSP of X Mbit/s.  Suppose that PCE
      cannot\n   find a path for X Mbit/s.  In this case, the PCE must include in
      the\n   PCRep message a NO-PATH object.  Optionally, the PCE may also include\n
      \  the original BANDWIDTH object so as to indicate that the reason for\n   the
      unsuccessful computation is the bandwidth constraint (in this\n   case, the
      NI field value is 0x00 and C flag is set).  If the PCE\n   supports such capability,
      it may alternatively include the BANDWIDTH\n   object and report a value of
      Y in the bandwidth field of the\n   BANDWIDTH object (in this case, the C flag
      is set) where Y refers to\n   the bandwidth for which a TE LSP with the same
      other characteristics\n   (such as Setup/Holding priorities, TE LSP attribute,
      local\n   protection, etc.) could have been computed.\n   When the NO-PATH object
      is absent from a PCRep message, the path\n   computation request has been fully
      satisfied and the corresponding\n   paths are provided in the PCRep message.\n
      \  An optional TLV named NO-PATH-VECTOR MAY be included in the NO-PATH\n   object
      in order to provide more information on the reasons that led\n   to a negative
      reply.\n   The NO-PATH-VECTOR TLV is compliant with the PCEP TLV format defined\n
      \  in Section 7.1 and is comprised of 2 bytes for the type, 2 bytes\n   specifying
      the TLV length (length of the value portion in bytes)\n   followed by a fixed-length
      32-bit flags field.\n   Type:   1\n   Length: 4 bytes\n   Value:  32-bit flags
      field\n   IANA manages the space of flags carried in the NO-PATH-VECTOR TLV\n
      \  (see Section 9).\n   The following flags are currently defined:\n   o  Bit
      number: 31 - PCE currently unavailable\n   o  Bit number: 30 - Unknown destination\n
      \  o  Bit number: 29 - Unknown source\n"
    title: 7.5.  NO-PATH Object
  - contents:
    - "7.6.  END-POINTS Object\n   The END-POINTS object is used in a PCReq message
      to specify the\n   source IP address and the destination IP address of the path
      for\n   which a path computation is requested.  The P flag of the END-POINTS\n
      \  object MUST be set.  If the END-POINTS object is received with the P\n   flag
      cleared, the receiving peer MUST send a PCErr message with\n   Error-Type=10
      and Error-value=1.  The corresponding path computation\n   request MUST be cancelled
      by the PCE without further notification.\n   Note that the source and destination
      addresses specified in the END-\n   POINTS object may correspond to the source
      and destination IP address\n   of the TE LSP or to those of a path segment.
      \ Two END-POINTS objects\n   (for IPv4 and IPv6) are defined.\n   END-POINTS
      Object-Class is 4.\n   END-POINTS Object-Type is 1 for IPv4 and 2 for IPv6.\n
      \  The format of the END-POINTS object body for IPv4 (Object-Type=1) is\n   as
      follows:\n       0                   1                   2                   3\n
      \      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |                     Source IPv4 address                       |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |                  Destination IPv4 address                     |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                Figure 12: END-POINTS Object Body Format for IPv4\n   The format
      of the END-POINTS object for IPv6 (Object-Type=2) is as\n   follows:\n       0
      \                  1                   2                   3\n       0 1 2 3
      4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |                                                               |\n      |
      \               Source IPv6 address (16 bytes)                 |\n      |                                                               |\n
      \     |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |                                                               |\n      |
      \             Destination IPv6 address (16 bytes)              |\n      |                                                               |\n
      \     |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                Figure 13: END-POINTS Object Body Format for IPv6\n   The END-POINTS
      object body has a fixed length of 8 bytes for IPv4 and\n   32 bytes for IPv6.\n
      \  If more than one END-POINTS object is present, the first MUST be\n   processed
      and subsequent objects ignored.\n"
    title: 7.6.  END-POINTS Object
  - contents:
    - "7.7.  BANDWIDTH Object\n   The BANDWIDTH object is used to specify the requested
      bandwidth for a\n   TE LSP.  The notion of bandwidth is similar to the one used
      for RSVP\n   signaling in [RFC2205], [RFC3209], and [RFC3473].\n   If the requested
      bandwidth is equal to 0, the BANDWIDTH object is\n   optional.  Conversely,
      if the requested bandwidth is not equal to 0,\n   the PCReq message MUST contain
      a BANDWIDTH object.\n   In the case of the reoptimization of a TE LSP, the bandwidth
      of the\n   existing TE LSP MUST also be included in addition to the requested\n
      \  bandwidth if and only if the two values differ.  Consequently, two\n   Object-Type
      values are defined that refer to the requested bandwidth\n   and the bandwidth
      of the TE LSP for which a reoptimization is being\n   performed.\n   The BANDWIDTH
      object may be carried within PCReq and PCRep messages.\n   BANDWIDTH Object-Class
      is 5.\n   Two Object-Type values are defined for the BANDWIDTH object:\n   o
      \ Requested bandwidth: BANDWIDTH Object-Type is 1.\n   o  Bandwidth of an existing
      TE LSP for which a reoptimization is\n      requested.  BANDWIDTH Object-Type
      is 2.\n   The format of the BANDWIDTH object body is as follows:\n    0                   1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                        Bandwidth                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \               Figure 14: BANDWIDTH Object Body Format\n   Bandwidth (32 bits):
      \ The requested bandwidth is encoded in 32 bits\n      in IEEE floating point
      format (see [IEEE.754.1985]), expressed in\n      bytes per second.  Refer to
      Section 3.1.2 of [RFC3471] for a table\n      of commonly used values.\n   The
      BANDWIDTH object body has a fixed length of 4 bytes.\n"
    title: 7.7.  BANDWIDTH Object
  - contents:
    - "7.8.  METRIC Object\n   The METRIC object is optional and can be used for several
      purposes.\n   In a PCReq message, a PCC MAY insert one or more METRIC objects:\n
      \  o  To indicate the metric that MUST be optimized by the path\n      computation
      algorithm (IGP metric, TE metric, hop counts).\n      Currently, three metrics
      are defined: the IGP cost, the TE metric\n      (see [RFC3785]), and the number
      of hops traversed by a TE LSP.\n   o  To indicate a bound on the path cost that
      MUST NOT be exceeded for\n      the path to be considered as acceptable by the
      PCC.\n   In a PCRep message, the METRIC object MAY be inserted so as to\n   provide
      the cost for the computed path.  It MAY also be inserted\n   within a PCRep
      with the NO-PATH object to indicate that the metric\n   constraint could not
      be satisfied.\n   The path computation algorithmic aspects used by the PCE to
      optimize\n   a path with respect to a specific metric are outside the scope
      of\n   this document.\n   It must be understood that such path metrics are only
      meaningful if\n   used consistently: for instance, if the delay of a computed
      path\n   segment is exchanged between two PCEs residing in different domains,\n
      \  consistent ways of defining the delay must be used.\n   The absence of the
      METRIC object MUST be interpreted by the PCE as a\n   path computation request
      for which no constraints need be applied to\n   any of the metrics.\n   METRIC
      Object-Class is 6.\n   METRIC Object-Type is 1.\n   The format of the METRIC
      object body is as follows:\n    0                   1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |          Reserved             |    Flags  |C|B|       T       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                          metric-value                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                  Figure 15: METRIC Object Body Format\n   The METRIC object
      body has a fixed length of 8 bytes.\n   Reserved (16 bits):  This field MUST
      be set to zero on transmission\n      and MUST be ignored on receipt.\n   T
      (Type - 8 bits):  Specifies the metric type.\n      Three values are currently
      defined:\n      *  T=1: IGP metric\n      *  T=2: TE metric\n      *  T=3: Hop
      Counts\n   Flags (8 bits):  Two flags are currently defined:\n      *  B (Bound
      - 1 bit): When set in a PCReq message, the metric-\n         value indicates
      a bound (a maximum) for the path metric that\n         must not be exceeded
      for the PCC to consider the computed path\n         as acceptable.  The path
      metric must be less than or equal to\n         the value specified in the metric-value
      field.  When the B flag\n         is cleared, the metric-value field is not
      used to reflect a\n         bound constraint.\n      *  C (Computed Metric -
      1 bit): When set in a PCReq message, this\n         indicates that the PCE MUST
      provide the computed path metric\n         value (should a path satisfying the
      constraints be found) in\n         the PCRep message for the corresponding metric.\n
      \     Unassigned flags MUST be set to zero on transmission and MUST be\n      ignored
      on receipt.\n   Metric-value (32 bits):  metric value encoded in 32 bits in
      IEEE\n      floating point format (see [IEEE.754.1985]).\n   Multiple METRIC
      objects MAY be inserted in a PCRep or a PCReq message\n   for a given request
      (i.e., for a given RP).  For a given request,\n   there MUST be at most one
      instance of the METRIC object for each\n   metric type with the same B flag
      value.  If, for a given request, two\n   or more instances of a METRIC object
      with the same B flag value are\n   present for a metric type, only the first
      instance MUST be considered\n   and other instances MUST be ignored.\n   For
      a given request, the presence of two METRIC objects of the same\n   type with
      a different value of the B flag is allowed.  Furthermore,\n   it is also allowed
      to insert, for a given request, two METRIC objects\n   with different types
      that have both their B flag cleared: in this\n   case, an objective function
      must be used by the PCE to solve a multi-\n   parameter optimization problem.\n
      \  A METRIC object used to indicate the metric to optimize during the\n   path
      computation MUST have the B flag cleared and the C flag set to\n   the appropriate
      value.  When the path computation relates to the\n   reoptimization of an exiting
      TE LSP (in which case, the R flag of the\n   RP object is set), an implementation
      MAY decide to set the metric-\n   value field to the computed value of the metric
      of the TE LSP to be\n   reoptimized with regards to a specific metric type.\n
      \  A METRIC object used to reflect a bound MUST have the B flag set, and\n   the
      C flag and metric-value field set to the appropriate values.\n   In a PCRep
      message, unless not allowed by PCE policy, at least one\n   METRIC object MUST
      be present that reports the computed path metric\n   if the C flag of the METRIC
      object was set in the corresponding path\n   computation request (the B flag
      MUST be cleared).  The C flag has no\n   meaning in a PCRep message.  Optionally,
      the PCRep message MAY\n   contain additional METRIC objects that correspond
      to bound\n   constraints; in which case, the metric-value MUST be equal to the\n
      \  corresponding computed path metric (the B flag MUST be set).  If no\n   path
      satisfying the constraints could be found by the PCE, the METRIC\n   objects
      MAY also be present in the PCRep message with the NO-PATH\n   object to indicate
      the constraint metric that could be satisfied.\n   Example: if a PCC sends a
      path computation request to a PCE where the\n   metric to optimize is the IGP
      metric and the TE metric must not\n   exceed the value of M, two METRIC objects
      are inserted in the PCReq\n   message:\n   o  First METRIC object with B=0,
      T=1, C=1, metric-value=0x0000\n   o  Second METRIC object with B=1, T=2, metric-value=M\n
      \  If a path satisfying the set of constraints can be found by the PCE\n   and
      there is no policy that prevents the return of the computed\n   metric, the
      PCE inserts one METRIC object with B=0, T=1, metric-\n   value= computed IGP
      path cost.  Additionally, the PCE may insert a\n   second METRIC object with
      B=1, T=2, metric-value= computed TE path\n   cost.\n"
    title: 7.8.  METRIC Object
  - contents:
    - "7.9.  Explicit Route Object\n   The ERO is used to encode the path of a TE
      LSP through the network.\n   The ERO is carried within a PCRep message to provide
      the computed TE\n   LSP if the path computation was successful.\n   The contents
      of this object are identical in encoding to the contents\n   of the Resource
      Reservation Protocol Traffic Engineering Extensions\n   (RSVP-TE) Explicit Route
      Object (ERO) defined in [RFC3209],\n   [RFC3473], and [RFC3477].  That is, the
      object is constructed from a\n   series of sub-objects.  Any RSVP-TE ERO sub-object
      already defined or\n   that could be defined in the future for use in the RSVP-TE
      ERO is\n   acceptable in this object.\n   PCEP ERO sub-object types correspond
      to RSVP-TE ERO sub-object types.\n   Since the explicit path is available for
      immediate signaling by the\n   MPLS or GMPLS control plane, the meanings of
      all of the sub-objects\n   and fields in this object are identical to those
      defined for the ERO.\n   ERO Object-Class is 7.\n   ERO Object-Type is 1.\n"
    title: 7.9.  Explicit Route Object
  - contents:
    - "7.10.  Reported Route Object\n   The RRO is exclusively carried within a PCReq
      message so as to report\n   the route followed by a TE LSP for which a reoptimization
      is desired.\n   The contents of this object are identical in encoding to the
      contents\n   of the Route Record Object defined in [RFC3209], [RFC3473], and\n
      \  [RFC3477].  That is, the object is constructed from a series of sub-\n   objects.
      \ Any RSVP-TE RRO sub-object already defined or that could be\n   defined in
      the future for use in the RSVP-TE RRO is acceptable in\n   this object.\n   The
      meanings of all of the sub-objects and fields in this object are\n   identical
      to those defined for the RSVP-TE RRO.\n   PCEP RRO sub-object types correspond
      to RSVP-TE RRO sub-object types.\n   RRO Object-Class is 8.\n   RRO Object-Type
      is 1.\n"
    title: 7.10.  Reported Route Object
  - contents:
    - "7.11.  LSPA Object\n   The LSPA (LSP Attributes) object is optional and specifies
      various TE\n   LSP attributes to be taken into account by the PCE during path\n
      \  computation.  The LSPA object can be carried within a PCReq message,\n   or
      a PCRep message in case of unsuccessful path computation (in this\n   case,
      the PCRep message also contains a NO-PATH object, and the LSPA\n   object is
      used to indicate the set of constraints that could not be\n   satisfied).  Most
      of the fields of the LSPA object are identical to\n   the fields of the SESSION-ATTRIBUTE
      object (C-Type = 7) defined in\n   [RFC3209] and [RFC4090].  When absent from
      the PCReq message, this\n   means that the Setup and Holding priorities are
      equal to 0, and there\n   are no affinity constraints.  See Section 4.7.4 of
      [RFC3209] for a\n   detailed description of the use of resource affinities.\n
      \  LSPA Object-Class is 9.\n   LSPA Object-Types is 1.\n   The format of the
      LSPA object body is:\n    0                   1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                       Exclude-any                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                       Include-any                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                       Include-all                             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |  Setup Prio   |  Holding Prio |     Flags   |L|   Reserved    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                                                               |\n   //
      \                    Optional TLVs                           //\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                  Figure
      16: LSPA Object Body Format\n   Setup Prio (Setup Priority - 8 bits):  The priority
      of the TE LSP\n      with respect to taking resources, in the range of 0 to
      7.  The\n      value 0 is the highest priority.  The Setup Priority is used
      in\n      deciding whether this session can preempt another session.\n   Holding
      Prio (Holding Priority - 8 bits):  The priority of the TE LSP\n      with respect
      to holding resources, in the range of 0 to 7.  The\n      value 0 is the highest
      priority.  Holding Priority is used in\n      deciding whether this session
      can be preempted by another session.\n   Flags (8 bits)\n      L flag:  Corresponds
      to the \"Local Protection Desired\" bit\n         ([RFC3209]) of the SESSION-ATTRIBUTE
      Object.  When set, this\n         means that the computed path must include
      links protected with\n         Fast Reroute as defined in [RFC4090].\n      Unassigned
      flags MUST be set to zero on transmission and MUST be\n      ignored on receipt.\n
      \  Reserved (8 bits):  This field MUST be set to zero on transmission\n      and
      MUST be ignored on receipt.\n   Note that optional TLVs may be defined in the
      future to carry\n   additional TE LSP attributes such as those defined in [RFC5420].\n"
    title: 7.11.  LSPA Object
  - contents:
    - "7.12.  Include Route Object\n   The IRO (Include Route Object) is optional
      and can be used to specify\n   that the computed path MUST traverse a set of
      specified network\n   elements.  The IRO MAY be carried within PCReq and PCRep
      messages.\n   When carried within a PCRep message with the NO-PATH object, the
      IRO\n   indicates the set of elements that cause the PCE to fail to find a\n
      \  path.\n   IRO Object-Class is 10.\n   IRO Object-Type is 1.\n    0                   1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                                                               |\n   //
      \                       (Sub-objects)                        //\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                    Figure
      17: IRO Body Format\n   Sub-objects:  The IRO is made of sub-objects identical
      to the ones\n      defined in [RFC3209], [RFC3473], and [RFC3477], where the
      IRO sub-\n      object type is identical to the sub-object type defined in the\n
      \     related documents.\n      The following sub-object types are supported.\n
      \         Type   Sub-object\n           1     IPv4 prefix\n           2     IPv6
      prefix\n           4     Unnumbered Interface ID\n           32    Autonomous
      system number\n   The L bit of such sub-object has no meaning within an IRO.\n"
    title: 7.12.  Include Route Object
  - contents:
    - '7.13.  SVEC Object

      '
    - contents:
      - "7.13.1.  Notion of Dependent and Synchronized Path Computation Requests\n
        \  Independent versus dependent path computation requests: path\n   computation
        requests are said to be independent if they are not\n   related to each other.
        \ Conversely, a set of dependent path\n   computation requests is such that
        their computations cannot be\n   performed independently of each other (a
        typical example of dependent\n   requests is the computation of a set of diverse
        paths).\n   Synchronized versus non-synchronized path computation requests:
        a set\n   of path computation requests is said to be non-synchronized if their\n
        \  respective treatment (path computations) can be performed by a PCE in\n
        \  a serialized and independent fashion.\n   There are various circumstances
        where the synchronization of a set of\n   path computations may be beneficial
        or required.\n   Consider the case of a set of N TE LSPs for which a PCC needs
        to send\n   path computation requests to a PCE.  The first solution consists
        of\n   sending N separate PCReq messages to the selected PCE.  In this case,\n
        \  the path computation requests are non-synchronized.  Note that the\n   PCC
        may chose to distribute the set of N requests across K PCEs for\n   load balancing
        purposes.  Considering that M (with M<N) requests are\n   sent to a particular
        PCEi, as described above, such M requests can be\n   sent in the form of successive
        PCReq messages destined to PCEi or\n   bundled within a single PCReq message
        (since PCEP allows for the\n   bundling of multiple path computation requests
        within a single PCReq\n   message).  That said, even in the case of independent
        requests, it\n   can be desirable to request from the PCE the computation
        of their\n   paths in a synchronized fashion that is likely to lead to more\n
        \  optimal path computations and/or reduced blocking probability if the\n
        \  PCE is a stateless PCE.  In other words, the PCE should not compute\n   the
        corresponding paths in a serialized and independent manner, but\n   it should
        rather \"simultaneously\" compute their paths.  For example,\n   trying to
        \"simultaneously\" compute the paths of M TE LSPs may allow\n   the PCE to
        improve the likelihood to meet multiple constraints.\n   Consider the case
        of two TE LSPs requesting N1 Mbit/s and N2 Mbit/s,\n   respectively, and a
        maximum tolerable end-to-end delay for each TE\n   LSP of X ms.  There may
        be circumstances where the computation of the\n   first TE LSP, irrespectively
        of the second TE LSP, may lead to the\n   impossibility to meet the delay
        constraint for the second TE LSP.\n   A second example is related to the bandwidth
        constraint.  It is quite\n   straightforward to provide examples where a serialized
        independent\n   path computation approach would lead to the impossibility
        to satisfy\n   both requests (due to bandwidth fragmentation), while a synchronized\n
        \  path computation would successfully satisfy both requests.\n   A last example
        relates to the ability to avoid the allocation of the\n   same resource to
        multiple requests, thus helping to reduce the call\n   setup failure probability
        compared to the serialized computation of\n   independent requests.\n   Dependent
        path computations are usually synchronized.  For example,\n   in the case
        of the computation of M diverse paths, if such paths are\n   computed in a
        non-synchronized fashion, this seriously increases the\n   probability of
        not being able to satisfy all requests (sometimes also\n   referred to as
        the well-known \"trapping problem\").\n   Furthermore, this would not allow
        a PCE to implement objective\n   functions such as trying to minimize the
        sum of the TE LSP costs.  In\n   such a case, the path computation requests
        must be synchronized: they\n   cannot be computed independently of each other.\n
        \  Conversely, a set of independent path computation requests may or may\n
        \  not be synchronized.\n   The synchronization of a set of path computation
        requests is achieved\n   by using the SVEC object that specifies the list
        of synchronized\n   requests that can either be dependent or independent.\n
        \  PCEP supports the following three modes:\n   o  Bundle of a set of independent
        and non-synchronized path\n      computation requests,\n   o  Bundle of a
        set of independent and synchronized path computation\n      requests (requires
        the SVEC object defined below),\n   o  Bundle of a set of dependent and synchronized
        path computation\n      requests (requires the SVEC object defined below).\n"
      title: 7.13.1.  Notion of Dependent and Synchronized Path Computation Requests
    - contents:
      - "7.13.2.  SVEC Object\n   Section 7.13.1 details the circumstances under which
        it may be\n   desirable and/or required to synchronize a set of path computation\n
        \  requests.  The SVEC (Synchronization VECtor) object allows a PCC to\n   request
        the synchronization of a set of dependent or independent path\n   computation
        requests.  The SVEC object is optional and may be carried\n   within a PCReq
        message.\n   The aim of the SVEC object carried within a PCReq message is
        to\n   request the synchronization of M path computation requests.  The SVEC\n
        \  object is a variable-length object that lists the set of M path\n   computation
        requests that must be synchronized.  Each path\n   computation request is
        uniquely identified by the Request-ID-number\n   carried within the respective
        RP object.  The SVEC object also\n   contains a set of flags that specify
        the synchronization type.\n   SVEC Object-Class is 11.\n   SVEC Object-Type
        is 1.\n   The format of the SVEC object body is as follows:\n    0                   1
        \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |   Reserved    |                   Flags                 |S|N|L|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                     Request-ID-number #1                      |\n   //
        \                                                            //\n   |                     Request-ID-number
        #M                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \                 Figure 18: SVEC Body Object Format\n   Reserved (8 bits):
        \ This field MUST be set to zero on transmission\n      and MUST be ignored
        on receipt.\n   Flags (24 bits):  Defines the potential dependency between
        the set of\n      path computation requests.\n      *  L (Link diverse) bit:
        when set, this indicates that the\n         computed paths corresponding to
        the requests specified by the\n         following RP objects MUST NOT have
        any link in common.\n      *  N (Node diverse) bit: when set, this indicates
        that the\n         computed paths corresponding to the requests specified
        by the\n         following RP objects MUST NOT have any node in common.\n
        \     *  S (SRLG diverse) bit: when set, this indicates that the\n         computed
        paths corresponding to the requests specified by the\n         following RP
        objects MUST NOT share any SRLG (Shared Risk Link\n         Group).\n      In
        case of a set of M synchronized independent path computation\n      requests,
        the bits L, N, and S are cleared.\n   Unassigned flags MUST be set to zero
        on transmission and MUST be\n   ignored on receipt.\n   The flags defined
        above are not exclusive.\n"
      title: 7.13.2.  SVEC Object
    - contents:
      - "7.13.3.  Handling of the SVEC Object\n   The SVEC object allows a PCC to
        specify a list of M path computation\n   requests that MUST be synchronized
        along with a potential dependency.\n   The set of M path computation requests
        may be sent within a single\n   PCReq message or multiple PCReq messages.
        \ In the latter case, it is\n   RECOMMENDED for the PCE to implement a local
        timer (called the\n   SyncTimer) activated upon the receipt of the first PCReq
        message that\n   contains the SVEC object after the expiration of which, if
        all the M\n   path computation requests have not been received, a protocol
        error is\n   triggered.  When a PCE receives a path computation request that\n
        \  cannot be satisfied (for example, because the PCReq message contains\n
        \  an object with the P bit set that is not supported), the PCE sends a\n
        \  PCErr message for this request (see Section 7.2), the PCE MUST cancel\n
        \  the whole set of related path computation requests and MUST send a\n   PCErr
        message with Error-Type=\"Synchronized path computation request\n   missing\".\n
        \  Note that such PCReq messages may also contain non-synchronized path\n
        \  computation requests.  For example, the PCReq message may comprise N\n
        \  synchronized path computation requests that are related to RP 1, ...,\n
        \  RP N and are listed in the SVEC object along with any other path\n   computation
        requests that are processed as normal.\n"
      title: 7.13.3.  Handling of the SVEC Object
    title: 7.13.  SVEC Object
  - contents:
    - "7.14.  NOTIFICATION Object\n   The NOTIFICATION object is exclusively carried
      within a PCNtf message\n   and can either be used in a message sent by a PCC
      to a PCE or by a\n   PCE to a PCC so as to notify of an event.\n   NOTIFICATION
      Object-Class is 12.\n   NOTIFICATION Object-Type is 1.\n   The format of the
      NOTIFICATION body object is as follows:\n    0                   1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |   Reserved    |     Flags     |      NT       |     NV        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                                                               |\n   //
      \                     Optional TLVs                          //\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n               Figure
      19: NOTIFICATION Body Object Format\n   Reserved (8 bits):  This field MUST
      be set to zero on transmission\n      and MUST be ignored on receipt.\n   Flags
      (8 bits):  No flags are currently defined.  Unassigned flags\n      MUST be
      set to zero on transmission and MUST be ignored on\n      receipt.\n   NT (Notification
      Type - 8 bits):  The Notification-type specifies the\n      class of notification.\n
      \  NV (Notification Value - 8 bits):  The Notification-value provides\n      addition
      information related to the nature of the notification.\n   Both the Notification-type
      and Notification-value are managed by\n   IANA.\n   The following Notification-type
      and Notification-value values are\n   currently defined:\n   o  Notification-type=1:
      Pending Request cancelled\n      *  Notification-value=1: PCC cancels a set
      of pending requests.  A\n         Notification-type=1, Notification-value=1
      indicates that the\n         PCC wants to inform a PCE of the cancellation of
      a set of\n         pending requests.  Such an event could be triggered because
      of\n         external conditions such as the receipt of a positive reply\n         from
      another PCE (should the PCC have sent multiple requests to\n         a set of
      PCEs for the same path computation request), a network\n         event such
      as a network failure rendering the request obsolete,\n         or any other
      events local to the PCC.  A NOTIFICATION object\n         with Notification-type=1,
      Notification-value=1 is carried\n         within a PCNtf message sent by the
      PCC to the PCE.  The RP\n         object corresponding to the cancelled request
      MUST also be\n         present in the PCNtf message.  Multiple RP objects may
      be\n         carried within the PCNtf message; in which case, the\n         notification
      applies to all of them.  If such a notification is\n         received by a PCC
      from a PCE, the PCC MUST silently ignore the\n         notification and no errors
      should be generated.\n      *  Notification-value=2: PCE cancels a set of pending
      requests.  A\n         Notification-type=1, Notification-value=2 indicates that
      the\n         PCE wants to inform a PCC of the cancellation of a set of\n         pending
      requests.  A NOTIFICATION object with Notification-\n         type=1, Notification-value=2
      is carried within a PCNtf message\n         sent by a PCE to a PCC.  The RP
      object corresponding to the\n         cancelled request MUST also be present
      in the PCNtf message.\n         Multiple RP objects may be carried within the
      PCNtf message; in\n         which case, the notification applies to all of them.
      \ If such\n         notification is received by a PCE from a PCC, the PCE MUST\n
      \        silently ignore the notification and no errors should be\n         generated.\n
      \  o  Notification-type=2: Overloaded PCE\n      *  Notification-value=1: A
      Notification-type=2, Notification-\n         value=1 indicates to the PCC that
      the PCE is currently in an\n         overloaded state.  If no RP objects are
      included in the PCNtf\n         message, this indicates that no other requests
      SHOULD be sent\n         to that PCE until the overloaded state is cleared:
      the pending\n         requests are not affected and will be served.  If some
      pending\n         requests cannot be served due to the overloaded state, the
      PCE\n         MUST also include a set of RP objects that identifies the set\n
      \        of pending requests that are cancelled by the PCE and will not\n         be
      honored.  In this case, the PCE does not have to send an\n         additional
      PCNtf message with Notification-type=1 and\n         Notification-value=2 since
      the list of cancelled requests is\n         specified by including the corresponding
      set of RP objects.  If\n         such notification is received by a PCE from
      a PCC, the PCE MUST\n         silently ignore the notification and no errors
      should be\n         generated.\n      *  A PCE implementation SHOULD use a dual-threshold
      mechanism used\n         to determine whether it is in a congestion state with
      regards\n         to specific resource monitoring (e.g.  CPU, memory).  The
      use\n         of such thresholds is to avoid oscillations between overloaded/\n
      \        non-overloaded state that may result in oscillations of request\n         targets
      by the PCCs.\n      *  Optionally, a TLV named OVERLOADED-DURATION may be included
      in\n         the NOTIFICATION object that specifies the period of time\n         during
      which no further request should be sent to the PCE.\n         Once this period
      of time has elapsed, the PCE should no longer\n         be considered in a congested
      state.\n         The OVERLOADED-DURATION TLV is compliant with the PCEP TLV\n
      \        format defined in Section 7.1 and is comprised of 2 bytes for\n         the
      type, 2 bytes specifying the TLV length (length of the\n         value portion
      in bytes), followed by a fixed-length value field\n         of a 32-bit flags
      field.\n         Type:   2\n         Length: 4 bytes\n         Value:  32-bit
      flags field indicates the estimated PCE\n                 congestion duration
      in seconds.\n      *  Notification-value=2: A Notification-type=2, Notification-\n
      \        value=2 indicates that the PCE is no longer in an overloaded\n         state
      and is available to process new path computation\n         requests.  An implementation
      SHOULD make sure that a PCE sends\n         such notification to every PCC to
      which a Notification message\n         (with Notification-type=2, Notification-value=1)
      has been sent\n         unless an OVERLOADED-DURATION TLV has been included
      in the\n         corresponding message and the PCE wishes to wait for the\n
      \        expiration of that period of time before receiving new\n         requests.
      \ If such notification is received by a PCE from a\n         PCC, the PCE MUST
      silently ignore the notification and no\n         errors should be generated.
      \ It is RECOMMENDED to support some\n         dampening notification procedure
      on the PCE so as to avoid too\n         frequent congestion state and congestion
      state release\n         notifications.  For example, an implementation could
      make use\n         of an hysteresis approach using a dual-threshold mechanism
      that\n         triggers the sending of congestion state notifications.\n         Furthermore,
      in case of high instabilities of the PCE\n         resources, an additional
      dampening mechanism SHOULD be used\n         (linear or exponential) to pace
      the notification frequency and\n         avoid oscillation of path computation
      requests.\n   When a PCC receives an overload indication from a PCE, it should\n
      \  consider the impact on the entire network.  It must be remembered\n   that
      other PCCs may also receive the notification, and so many path\n   computation
      requests could be redirected to other PCEs.  This may, in\n   turn, cause further
      overloading at PCEs in the network.  Therefore,\n   an application at a PCC
      receiving an overload notification should\n   consider applying some form of
      back-off (e.g., exponential) to the\n   rate at which it generates path computation
      requests into the\n   network.  This is especially the case as the number of
      PCEs reporting\n   overload grows.\n"
    title: 7.14.  NOTIFICATION Object
  - contents:
    - "7.15.  PCEP-ERROR Object\n   The PCEP-ERROR object is exclusively carried within
      a PCErr message\n   to notify of a PCEP error.\n   PCEP-ERROR Object-Class is
      13.\n   PCEP-ERROR Object-Type is 1.\n   The format of the PCEP-ERROR object
      body is as follows:\n    0                   1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |   Reserved    |      Flags    |   Error-Type  |  Error-value  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                                                               |\n   //
      \                    Optional TLVs                           //\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n               Figure
      20: PCEP-ERROR Object Body Format\n   A PCEP-ERROR object is used to report
      a PCEP error and is\n   characterized by an Error-Type that specifies the type
      of error and\n   an Error-value that provides additional information about the
      error\n   type.  Both the Error-Type and the Error-value are managed by IANA\n
      \  (see the IANA section).\n   Reserved (8 bits):  This field MUST be set to
      zero on transmission\n      and MUST be ignored on receipt.\n   Flags (8 bits):
      \ no flag is currently defined.  This flag MUST be set\n      to zero on transmission
      and MUST be ignored on receipt.\n   Error-Type (8 bits):  defines the class
      of error.\n   Error-value (8 bits):  provides additional details about the error.\n
      \  Optionally, the PCEP-ERROR object may contain additional TLVs so as\n   to
      provide further information about the encountered error.\n   A single PCErr
      message may contain multiple PCEP-ERROR objects.\n   For each PCEP error, an
      Error-Type and an Error-value are defined.\n   Error-Type    Meaning\n      1
      \         PCEP session establishment failure\n                 Error-value=1:
      reception of an invalid Open message or\n                                a non
      Open message.\n                 Error-value=2: no Open message received before
      the\n                                expiration of the OpenWait timer\n                 Error-value=3:
      unacceptable and non-negotiable session\n                                characteristics\n
      \                Error-value=4: unacceptable but negotiable session\n                                characteristics\n
      \                Error-value=5: reception of a second Open message with\n                                still
      unacceptable session\n                                characteristics\n                 Error-value=6:
      reception of a PCErr message proposing\n                                unacceptable
      session characteristics\n                 Error-value=7: No Keepalive or PCErr
      message received\n                                before the expiration of the
      KeepWait\n                                timer\n      2          Capability
      not supported\n      3          Unknown Object\n                  Error-value=1:
      Unrecognized object class\n                  Error-value=2: Unrecognized object
      Type\n      4          Not supported object\n                  Error-value=1:
      Not supported object class\n                  Error-value=2: Not supported object
      Type\n      5          Policy violation\n                  Error-value=1: C
      bit of the METRIC object set\n                                 (request rejected)\n
      \                 Error-value=2: O bit of the RP object set\n                                 (request
      rejected)\n      6          Mandatory Object missing\n                  Error-value=1:
      RP object missing\n                  Error-value=2: RRO object missing for a
      reoptimization\n                                 request (R bit of the RP object
      set)\n                                 when bandwidth is not equal to 0.\n                  Error-value=3:
      END-POINTS object missing\n      7          Synchronized path computation request
      missing\n      8          Unknown request reference\n      9          Attempt
      to establish a second PCEP session\n      10         Reception of an invalid
      object\n                  Error-value=1: reception of an object with P flag
      not\n                  set although the P flag must be set according to this\n
      \                 specification.\n   The error types listed above are described
      below.\n   Error-Type=1: PCEP session establishment failure.\n      If a malformed
      message is received, the receiving PCEP peer MUST\n      send a PCErr message
      with Error-Type=1, Error-value=1.\n      If no Open message is received before
      the expiration of the\n      OpenWait timer, the receiving PCEP peer MUST send
      a PCErr message\n      with Error-Type=1, Error-value=2 (see Appendix A for
      details).\n      If one or more PCEP session characteristics are unacceptable
      by\n      the receiving peer and are not negotiable, it MUST send a PCErr\n
      \     message with Error-Type=1, Error-value=3.\n      If an Open message is
      received with unacceptable session\n      characteristics but these characteristics
      are negotiable, the\n      receiving PCEP peer MUST send a PCErr message with
      Error-Type-1,\n      Error-value=4 (see Section 6.2 for details).\n      If
      a second Open message is received during the PCEP session\n      establishment
      phase and the session characteristics are still\n      unacceptable, the receiving
      PCEP peer MUST send a PCErr message\n      with Error-Type-1, Error-value=5
      (see Section 6.2 for details).\n      If a PCErr message is received during
      the PCEP session\n      establishment phase that contains an Open message proposing\n
      \     unacceptable session characteristics, the receiving PCEP peer MUST\n      send
      a PCErr message with Error-Type=1, Error-value=6.\n      If neither a Keepalive
      message nor a PCErr message is received\n      before the expiration of the
      KeepWait timer during the PCEP\n      session establishment phase, the receiving
      PCEP peer MUST send a\n      PCErr message with Error-Type=1, Error-value=7.\n
      \  Error-Type=2:  the PCE indicates that the path computation request\n      cannot
      be honored because it does not support one or more required\n      capability.
      \ The corresponding path computation request MUST be\n      cancelled.\n   Error-Type=3
      or Error-Type=4:  if a PCEP message is received that\n      carries a PCEP object
      (with the P flag set) not recognized by the\n      PCE or recognized but not
      supported, then the PCE MUST send a\n      PCErr message with a PCEP-ERROR object
      (Error-Type=3 and 4,\n      respectively).  In addition, the PCE MAY include
      in the PCErr\n      message the unknown or not supported object.  The corresponding\n
      \     path computation request MUST be cancelled by the PCE without\n      further
      notification.\n   Error-Type=5:  if a path computation request is received that
      is not\n      compliant with an agreed policy between the PCC and the PCE, the\n
      \     PCE MUST send a PCErr message with a PCEP-ERROR object (Error-\n      Type=5).
      \ The corresponding path computation MUST be cancelled.\n      Policy-specific
      TLVs carried within the PCEP-ERROR object may be\n      defined in other documents
      to specify the nature of the policy\n      violation.\n   Error-Type=6:  if
      a path computation request is received that does\n      not contain a mandatory
      object, the PCE MUST send a PCErr message\n      with a PCEP-ERROR object (Error-Type=6).
      \ If there are multiple\n      mandatory objects missing, the PCErr message
      MUST contain one\n      PCEP-ERROR object per missing object.  The corresponding
      path\n      computation MUST be cancelled.\n   Error-Type=7:  if a PCC sends
      a synchronized path computation request\n      to a PCE and the PCE does not
      receive all the synchronized path\n      computation requests listed within
      the corresponding SVEC object\n      after the expiration of the timer SyncTimer
      defined in\n      Section 7.13.3, the PCE MUST send a PCErr message with a PCEP-\n
      \     ERROR object (Error-Type=7).  The corresponding synchronized path\n      computation
      MUST be cancelled.  It is RECOMMENDED for the PCE to\n      include the REQ-MISSING
      TLVs (defined below) that identify the\n      missing requests.\n      The REQ-MISSING
      TLV is compliant with the PCEP TLV format defined\n      in section 7.1 and
      is comprised of 2 bytes for the type, 2 bytes\n      specifying the TLV length
      (length of the value portion in bytes),\n      followed by a fixed-length value
      field of 4 bytes.\n         Type:   3\n         Length: 4 bytes\n         Value:
      \ 4 bytes that indicate the Request-ID-number that\n                 corresponds
      to the missing request.\n   Error-Type=8:  if a PCC receives a PCRep message
      related to an\n      unknown path computation request, the PCC MUST send a PCErr\n
      \     message with a PCEP-ERROR object (Error-Type=8).  In addition, the\n      PCC
      MUST include in the PCErr message the unknown RP object.\n   Error-Type=9:  if
      a PCEP peer detects an attempt from another PCEP\n      peer to establish a
      second PCEP session, it MUST send a PCErr\n      message with Error-Type=9,
      Error-value=1.  The existing PCEP\n      session MUST be preserved and all subsequent
      messages related to\n      the tentative establishment of the second PCEP session
      MUST be\n      silently ignored.\n   Error-Type=10:  if a PCEP peers receives
      an object with the P flag\n      not set although the P flag must be set according
      to this\n      specification, it MUST send a PCErr message with Error-Type=10,\n
      \     Error-value=1.\n"
    title: 7.15.  PCEP-ERROR Object
  - contents:
    - "7.16.  LOAD-BALANCING Object\n   There are situations where no TE LSP with
      a bandwidth of X could be\n   found by a PCE although such a bandwidth requirement
      could be\n   satisfied by a set of TE LSPs such that the sum of their bandwidths\n
      \  is equal to X.  Thus, it might be useful for a PCC to request a set\n   of
      TE LSPs so that the sum of their bandwidth is equal to X Mbit/s,\n   with potentially
      some constraints on the number of TE LSPs and the\n   minimum bandwidth of each
      of these TE LSPs.  Such a request is made\n   by inserting a LOAD-BALANCING
      object in a PCReq message sent to a\n   PCE.\n   The LOAD-BALANCING object is
      optional.\n   LOAD-BALANCING Object-Class is 14.\n   LOAD-BALANCING Object-Type
      is 1.\n   The format of the LOAD-BALANCING object body is as follows:\n    0
      \                  1                   2                   3\n    0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |           Reserved            |     Flags     |     Max-LSP   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                        Min-Bandwidth                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \               Figure 21: LOAD-BALANCING Object Body Format\n   Reserved (16
      bits):  This field MUST be set to zero on transmission\n      and MUST be ignored
      on receipt.\n   Flags (8 bits):  No flag is currently defined.  The Flags field
      MUST\n      be set to zero on transmission and MUST be ignored on receipt.\n
      \  Max-LSP (8 bits):  maximum number of TE LSPs in the set.\n   Min-Bandwidth
      (32 bits):  Specifies the minimum bandwidth of each\n      element of the set
      of TE LSPs.  The bandwidth is encoded in 32\n      bits in IEEE floating point
      format (see [IEEE.754.1985]),\n      expressed in bytes per second.\n   The
      LOAD-BALANCING object body has a fixed length of 8 bytes.\n   If a PCC requests
      the computation of a set of TE LSPs so that the sum\n   of their bandwidth is
      X, the maximum number of TE LSPs is N, and each\n   TE LSP must at least have
      a bandwidth of B, it inserts a BANDWIDTH\n   object specifying X as the required
      bandwidth and a LOAD-BALANCING\n   object with the Max-LSP and Min-Bandwidth
      fields set to N and B,\n   respectively.\n"
    title: 7.16.  LOAD-BALANCING Object
  - contents:
    - "7.17.  CLOSE Object\n   The CLOSE object MUST be present in each Close message.
      \ There MUST\n   be only one CLOSE object per Close message.  If a Close message
      is\n   received that contains more than one CLOSE object, the first CLOSE\n
      \  object is the one that must be processed.  Other CLOSE objects MUST\n   be
      silently ignored.\n   CLOSE Object-Class is 15.\n   CLOSE Object-Type is 1.\n
      \  The format of the CLOSE object body is as follows:\n    0                   1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |          Reserved             |      Flags    |    Reason     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                                                               |\n   //
      \                        Optional TLVs                       //\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                    Figure
      22: CLOSE Object Format\n   Reserved (16 bits):  This field MUST be set to zero
      on transmission\n      and MUST be ignored on receipt.\n   Flags (8 bits):  No
      flags are currently defined.  The Flag field MUST\n      be set to zero on transmission
      and MUST be ignored on receipt.\n   Reason (8 bits):  specifies the reason for
      closing the PCEP session.\n      The setting of this field is optional.  IANA
      manages the codespace\n      of the Reason field.  The following values are
      currently defined:\n       Reasons\n        Value        Meaning\n          1
      \         No explanation provided\n          2          DeadTimer expired\n
      \         3          Reception of a malformed PCEP message\n          4          Reception
      of an unacceptable number of unknown\n                     requests/replies\n
      \         5          Reception of an unacceptable number of unrecognized\n                     PCEP
      messages\n   Optional TLVs may be included within the CLOSE object body.  The\n
      \  specification of such TLVs is outside the scope of this document.\n"
    title: 7.17.  CLOSE Object
  title: 7.  Object Formats
- contents:
  - "8.  Manageability Considerations\n   This section follows the guidance of [PCE-MANAGE].\n"
  - contents:
    - "8.1.  Control of Function and Policy\n   A PCEP implementation SHOULD allow
      configuring the following PCEP\n   session parameters on the implementation:\n
      \  o  The local Keepalive and DeadTimer (i.e., parameters sent by the\n      PCEP
      peer in an Open message),\n   o  The maximum acceptable remote Keepalive and
      DeadTimer (i.e.,\n      parameters received from a peer in an Open message),\n
      \  o  Whether negotiation is enabled or disabled,\n   o  If negotiation is allowed,
      the minimum acceptable Keepalive and\n      DeadTimer timers received from a
      PCEP peer,\n   o  The SyncTimer,\n   o  The maximum number of sessions that
      can be set up,\n   o  The request timer, the amount of time a PCC waits for
      a reply\n      before resending its path computation requests (potentially to
      an\n      alternate PCE),\n   o  The MAX-UNKNOWN-REQUESTS,\n   o  The MAX-UNKNOWN-MESSAGES.\n
      \  These parameters may be configured as default parameters for any PCEP\n   session
      the PCEP speaker participates in, or may apply to a specific\n   session with
      a given PCEP peer or to a specific group of sessions\n   with a specific group
      of PCEP peers.  A PCEP implementation SHOULD\n   allow configuring the initiation
      of a PCEP session with a selected\n   subset of discovered PCEs.  Note that
      PCE selection is a local\n   implementation issue.  A PCEP implementation SHOULD
      allow configuring\n   a specific PCEP session with a given PCEP peer.  This
      includes the\n   configuration of the following parameters:\n   o  The IP address
      of the PCEP peer,\n   o  The PCEP speaker role: PCC, PCE, or both,\n   o  Whether
      the PCEP speaker should initiate the PCEP session or wait\n      for initiation
      by the peer,\n   o  The PCEP session parameters, as listed above, if they differ
      from\n      the default parameters,\n   o  A set of PCEP policies including
      the type of operations allowed\n      for the PCEP peer (e.g., diverse path
      computation,\n      synchronization, etc.).\n   A PCEP implementation MUST allow
      restricting the set of PCEP peers\n   that can initiate a PCEP session with
      the PCEP speaker (e.g., list of\n   authorized PCEP peers, all PCEP peers in
      the area, all PCEP peers in\n   the AS).\n"
    title: 8.1.  Control of Function and Policy
  - contents:
    - "8.2.  Information and Data Models\n   A PCEP MIB module is defined in [PCEP-MIB]
      that describes managed\n   objects for modeling of PCEP communication including:\n
      \  o  PCEP client configuration and status,\n   o  PCEP peer configuration and
      information,\n   o  PCEP session configuration and information,\n   o  Notifications
      to indicate PCEP session changes.\n"
    title: 8.2.  Information and Data Models
  - contents:
    - "8.3.  Liveness Detection and Monitoring\n   PCEP includes a keepalive mechanism
      to check the liveliness of a PCEP\n   peer and a notification procedure allowing
      a PCE to advertise its\n   overloaded state to a PCC.  Also, procedures in order
      to monitor the\n   liveliness and performances of a given PCE chain (in case
      of\n   multiple-PCE path computation) are defined in [PCE-MONITOR].\n"
    title: 8.3.  Liveness Detection and Monitoring
  - contents:
    - "8.4.  Verifying Correct Operation\n   Verifying the correct operation of a
      PCEP communication can be\n   performed by monitoring various parameters.  A
      PCEP implementation\n   SHOULD provide the following parameters:\n   o  Response
      time (minimum, average, and maximum), on a per-PCE-peer\n      basis,\n   o
      \ PCEP session failures,\n   o  Amount of time the session has been in active
      state,\n   o  Number of corrupted messages,\n   o  Number of failed computations,\n
      \  o  Number of requests for which no reply has been received after the\n      expiration
      of a configurable timer and by verifying that at least\n      one path exists
      that satisfies the set of constraints.\n   A PCEP implementation SHOULD log
      error events (e.g., corrupted\n   messages, unrecognized objects).\n"
    title: 8.4.  Verifying Correct Operation
  - contents:
    - "8.5.  Requirements on Other Protocols and Functional Components\n   PCEP does
      not put any new requirements on other protocols.  As PCEP\n   relies on the
      TCP transport protocol, PCEP management can make use of\n   TCP management mechanisms
      (such as the TCP MIB defined in [RFC4022]).\n   The PCE Discovery mechanisms
      ([RFC5088], [RFC5089]) may have an\n   impact on PCEP.  To avoid that a high
      frequency of PCE Discoveries/\n   Disappearances triggers a high frequency of
      PCEP session setups/\n   deletions, it is RECOMMENDED to introduce some dampening
      for\n   establishment of PCEP sessions.\n"
    title: 8.5.  Requirements on Other Protocols and Functional Components
  - contents:
    - "8.6.  Impact on Network Operation\n   In order to avoid any unacceptable impact
      on network operations, an\n   implementation SHOULD allow a limit to be placed
      on the number of\n   sessions that can be set up on a PCEP speaker, and MAY
      allow a limit\n   to be placed on the rate of messages sent by a PCEP speaker
      and\n   received from a peer.  It MAY also allow sending a notification when\n
      \  a rate threshold is reached.\n"
    title: 8.6.  Impact on Network Operation
  title: 8.  Manageability Considerations
- contents:
  - "9.  IANA Considerations\n   IANA assigns values to the PCEP protocol parameters
    (messages,\n   objects, TLVs).\n   IANA established a new top-level registry to
    contain all PCEP\n   codepoints and sub-registries.\n   The allocation policy
    for each new registry is by IETF Consensus: new\n   values are assigned through
    the IETF consensus process (see\n   [RFC5226]).  Specifically, new assignments
    are made via RFCs approved\n   by the IESG.  Typically, the IESG will seek input
    on prospective\n   assignments from appropriate persons (e.g., a relevant Working
    Group\n   if one exists).\n"
  - contents:
    - "9.1.  TCP Port\n   PCEP has been registered as TCP port 4189.\n"
    title: 9.1.  TCP Port
  - contents:
    - "9.2.  PCEP Messages\n   IANA created a registry for PCEP messages.  Each PCEP
      message has a\n   message type value.\n   Value     Meaning                          Reference\n
      \    1        Open                          This document\n     2        Keepalive
      \                    This document\n     3        Path Computation Request      This
      document\n     4        Path Computation Reply        This document\n     5
      \       Notification                  This document\n     6        Error                         This
      document\n     7        Close                         This document\n"
    title: 9.2.  PCEP Messages
  - contents:
    - "9.3.  PCEP Object\n   IANA created a registry for PCEP objects.  Each PCEP
      object has an\n   Object-Class and an Object-Type.\n   Object-Class Value   Name
      \                              Reference\n          1             OPEN                               This
      document\n                        Object-Type\n                            1\n
      \         2             RP                                 This document\n                        Object-Type\n
      \                           1\n          3             NO-PATH                            This
      document\n                        Object-Type\n                            1\n
      \         4             END-POINTS                         This document\n                        Object-Type\n
      \                           1: IPv4 addresses\n                            2:
      IPv6 addresses\n          5             BANDWIDTH                          This
      document\n                        Object-Type\n                          1:
      Requested bandwidth\n                          2: Bandwidth of an existing TE
      LSP\n                             for which a reoptimization is performed.\n
      \         6             METRIC                             This document\n                        Object-Type\n
      \                           1\n          7             ERO                                This
      document\n                        Object-Type\n                            1\n
      \         8             RRO                                This document\n                        Object-Type\n
      \                           1\n          9             LSPA                               This
      document\n                        Object-Type\n                            1\n
      \        10             IRO                                This document\n                        Object-Type\n
      \                           1\n         11             SVEC                               This
      document\n                        Object-Type\n                            1\n
      \        12             NOTIFICATION                       This document\n                        Object-Type\n
      \                           1\n         13             PCEP-ERROR                         This
      document\n                        Object-Type\n                            1\n
      \        14             LOAD-BALANCING                     This document\n                        Object-Type\n
      \                           1\n         15             CLOSE                              This
      document\n                        Object-Type\n                            1\n"
    title: 9.3.  PCEP Object
  - contents:
    - "9.4.  PCEP Message Common Header\n   IANA created a registry to manage the
      Flag field of the PCEP Message\n   Common Header.\n   New bit numbers may be
      allocated only by an IETF Consensus action.\n   Each bit should be tracked with
      the following qualities:\n   o  Bit number (counting from bit 0 as the most
      significant bit)\n   o  Capability description\n   o  Defining RFC\n   No bits
      are currently defined for the PCEP message common header.\n"
    title: 9.4.  PCEP Message Common Header
  - contents:
    - "9.5.  Open Object Flag Field\n   IANA created a registry to manage the Flag
      field of the OPEN object.\n   New bit numbers may be allocated only by an IETF
      Consensus action.\n   Each bit should be tracked with the following qualities:\n
      \  o  Bit number (counting from bit 0 as the most significant bit)\n   o  Capability
      description\n   o  Defining RFC\n   No bits are currently for the OPEN Object
      flag field.\n"
    title: 9.5.  Open Object Flag Field
  - contents:
    - "9.6.  RP Object\n   New bit numbers may be allocated only by an IETF Consensus
      action.\n   Each bit should be tracked with the following qualities:\n   o  Bit
      number (counting from bit 0 as the most significant bit)\n   o  Capability description\n
      \  o  Defining RFC\n   Several bits are defined for the RP Object flag field
      in this\n   document.  The following values have been assigned:\n   Codespace
      of the Flag field (RP Object)\n     Bit      Description              Reference\n
      \     26      Strict/Loose          This document\n      27      Bi-directional
      \       This document\n      28      Reoptimization        This document\n     29-31
      \   Priority              This document\n"
    title: 9.6.  RP Object
  - contents:
    - "9.7.  NO-PATH Object Flag Field\n   IANA created a registry to manage the codespace
      of the NI field and\n   the Flag field of the NO-PATH object.\n    Value       Meaning
      \                       Reference\n      0    No path satisfying the set        This
      document\n           of constraints could be found\n      1    PCE chain broken
      \                 This document\n   New bit numbers may be allocated only by
      an IETF Consensus action.\n   Each bit should be tracked with the following
      qualities:\n   o  Bit number (counting from bit 0 as the most significant bit)\n
      \  o  Capability description\n   o  Defining RFC\n   One bit is defined for
      the NO-PATH Object flag field in this\n   document:\n   Codespace of the Flag
      field (NO-PATH Object)\n     Bit      Description                      Reference\n
      \     0    Unsatisfied constraint indicated    This document\n"
    title: 9.7.  NO-PATH Object Flag Field
  - contents:
    - "9.8.  METRIC Object\n   IANA created a registry to manage the codespace of
      the T field and\n   the Flag field of the METRIC Object.\n   Codespace of the
      T field (Metric Object)\n    Value      Meaning          Reference\n      1
      \       IGP metric      This document\n      2        TE metric       This document\n
      \     3        Hop Counts      This document\n   New bit numbers may be allocated
      only by an IETF Consensus action.\n   Each bit should be tracked with the following
      qualities:\n   o  Bit number (counting from bit 0 as the most significant bit)\n
      \  o  Capability description\n   o  Defining RFC\n   Several bits are defined
      in this document.  The following values have\n   been assigned:\n   Codespace
      of the Flag field (Metric Object)\n     Bit      Description         Reference\n
      \     6       Computed metric    This document\n      7       Bound              This
      document\n"
    title: 9.8.  METRIC Object
  - contents:
    - "9.9.  LSPA Object Flag Field\n   IANA created a registry to manage the Flag
      field of the LSPA object.\n   New bit numbers may be allocated only by an IETF
      Consensus action.\n   Each bit should be tracked with the following qualities:\n
      \  o  Bit number (counting from bit 0 as the most significant bit)\n   o  Capability
      description\n   o  Defining RFC\n   One bit is defined for the LSPA Object flag
      field in this document:\n   Codespace of the Flag field (LSPA Object)\n     Bit
      \     Description             Reference\n      7    Local Protection Desired
      \  This document\n"
    title: 9.9.  LSPA Object Flag Field
  - contents:
    - "9.10.  SVEC Object Flag Field\n   IANA created a registry to manage the Flag
      field of the SVEC object.\n   New bit numbers may be allocated only by an IETF
      Consensus action.\n   Each bit should be tracked with the following qualities:\n
      \  o  Bit number (counting from bit 0 as the most significant bit)\n   o  Capability
      description\n   o  Defining RFC\n   Three bits are defined for the SVEC Object
      flag field in this\n   document:\n   Codespace of the Flag field (SVEC Object)\n
      \    Bit      Description      Reference\n      21      SRLG Diverse     This
      document\n      22      Node Diverse     This document\n      23      Link Diverse
      \    This document\n"
    title: 9.10.  SVEC Object Flag Field
  - contents:
    - "9.11.  NOTIFICATION Object\n   IANA created a registry for the Notification-type
      and Notification-\n   value of the NOTIFICATION object and manages the code
      space.\n   Notification-type  Name                                 Reference\n
      \        1            Pending Request cancelled            This document\n                      Notification-value\n
      \                       1: PCC cancels a set of pending requests\n                        2:
      PCE cancels a set of pending requests\n         2            Overloaded PCE
      \                      This document\n                      Notification-value\n
      \                       1: PCE in congested state\n                        2:
      PCE no longer in congested state\n   IANA created a registry to manage the Flag
      field of the NOTIFICATION\n   object.\n   New bit numbers may be allocated only
      by an IETF Consensus action.\n   Each bit should be tracked with the following
      qualities:\n   o  Bit number (counting from bit 0 as the most significant bit)\n
      \  o  Capability description\n   o  Defining RFC\n   No bits are currently for
      the Flag Field of the NOTIFICATION object.\n"
    title: 9.11.  NOTIFICATION Object
  - contents:
    - "9.12.  PCEP-ERROR Object\n   IANA created a registry for the Error-Type and
      Error-value of the\n   PCEP Error Object and manages the code space.\n   For
      each PCEP error, an Error-Type and an Error-value are defined.\n"
    - 'Error-  Meaning                                           Reference

      '
    - "Type\n  1     PCEP session establishment failure                This document\n
      \       Error-value=1: reception of an invalid Open message or\n                       a
      non Open message.\n        Error-value=2: no Open message received before the
      expiration\n                       of the OpenWait timer\n        Error-value=3:
      unacceptable and non-negotiable session\n                       characteristics\n
      \       Error-value=4: unacceptable but negotiable session\n                       characteristics\n
      \       Error-value=5: reception of a second Open message with\n                       still
      unacceptable session characteristics\n        Error-value=6: reception of a
      PCErr message proposing\n                       unacceptable session characteristics\n
      \       Error-value=7: No Keepalive or PCErr message received\n                       before
      the expiration of the KeepWait timer\n        Error-value=8: PCEP version not
      supported\n  2     Capability not supported                          This document\n
      \ 3     Unknown Object                                    This document\n         Error-value=1:
      Unrecognized object class\n         Error-value=2: Unrecognized object Type\n
      \ 4     Not supported object                              This document\n         Error-value=1:
      Not supported object class\n         Error-value=2: Not supported object Type\n
      \ 5     Policy violation                                  This document\n         Error-value=1:
      C bit of the METRIC object set\n                        (request rejected)\n
      \        Error-value=2: O bit of the RP object cleared\n                        (request
      rejected)\n  6     Mandatory Object missing                          This document\n
      \        Error-value=1: RP object missing\n         Error-value=2: RRO missing
      for a reoptimization\n                        request (R bit of the RP object
      set)\n         Error-value=3: END-POINTS object missing\n  7     Synchronized
      path computation request missing     This document\n  8     Unknown request
      reference                         This document\n  9     Attempt to establish
      a second PCEP session        This document\n 10     Reception of an invalid
      object                    This document\n         Error-value=1: reception of
      an object with P flag\n                        not set although the P flag must
      be\n                        set according to this specification.\n   IANA created
      a registry to manage the Flag field of the PCEP-ERROR\n   object.\n   New bit
      numbers may be allocated only by an IETF Consensus action.\n   Each bit should
      be tracked with the following qualities:\n   o  Bit number (counting from bit
      0 as the most significant bit)\n   o  Capability description\n   o  Defining
      RFC\n   No bits are currently for the Flag Field of the PCEP-ERROR Object.\n"
    title: 9.12.  PCEP-ERROR Object
  - contents:
    - "9.13.  LOAD-BALANCING Object Flag Field\n   IANA created a registry to manage
      the Flag field of the LOAD-\n   BALANCING object.\n   New bit numbers may be
      allocated only by an IETF Consensus action.\n   Each bit should be tracked with
      the following qualities:\n   o  Bit number (counting from bit 0 as the most
      significant bit)\n   o  Capability description\n   o  Defining RFC\n   No bits
      are currently for the Flag Field of the LOAD-BALANCING\n   Object.\n"
    title: 9.13.  LOAD-BALANCING Object Flag Field
  - contents:
    - "9.14.  CLOSE Object\n   The CLOSE object MUST be present in each Close message
      in order to\n   close a PCEP session.  The reason field of the CLOSE object
      specifies\n   the reason for closing the PCEP session.  The reason field of
      the\n   CLOSE object is managed by IANA.\n   Reasons\n    Value        Meaning\n
      \     1          No explanation provided\n      2          DeadTimer expired\n
      \     3          Reception of a malformed PCEP message\n      4          Reception
      of an unacceptable number of unknown\n                 requests/replies\n      5
      \         Reception of an unacceptable number of unrecognized\n                 PCEP
      messages\n   IANA created a registry to manage the flag field of the CLOSE object.\n
      \  New bit numbers may be allocated only by an IETF Consensus action.\n   Each
      bit should be tracked with the following qualities:\n   o  Bit number (counting
      from bit 0 as the most significant bit)\n   o  Capability description\n   o
      \ Defining RFC\n   No bits are currently for the Flag Field of the CLOSE Object.\n"
    title: 9.14.  CLOSE Object
  - contents:
    - "9.15.  PCEP TLV Type Indicators\n   IANA created a registry for the PCEP TLVs.\n
      \   Value         Meaning                    Reference\n      1          NO-PATH-VECTOR
      TLV         This document\n      2          OVERLOAD-DURATION TLV      This
      document\n      3          REQ-MISSING TLV            This document\n"
    title: 9.15.  PCEP TLV Type Indicators
  - contents:
    - "9.16.  NO-PATH-VECTOR TLV\n   IANA manages the space of flags carried in the
      NO-PATH-VECTOR TLV\n   defined in this document, numbering them from 0 as the
      least\n   significant bit.\n   New bit numbers may be allocated only by an IETF
      Consensus action.\n   Each bit should be tracked with the following qualities:\n
      \  o  Bit number (counting from bit 0 as the most significant bit)\n   o  Name
      flag\n   o  Reference\n   Bit Number       Name                         Reference\n
      \    31             PCE currently unavailable    This document\n     30             Unknown
      destination          This document\n     29             Unknown source               This
      document\n"
    title: 9.16.  NO-PATH-VECTOR TLV
  title: 9.  IANA Considerations
- contents:
  - '10.  Security Considerations

    '
  - contents:
    - "10.1.  Vulnerability\n   Attacks on PCEP may result in damage to active networks.
      \ If path\n   computation responses are changed, the PCC may be encouraged to
      set\n   up inappropriate LSPs.  Such LSPs might deviate to parts of the\n   network
      susceptible to snooping, or might transit congested or\n   reserved links.  Path
      computation responses may be attacked by\n   modification of the PCRep message,
      by impersonation of the PCE, or by\n   modification of the PCReq to cause the
      PCE to perform a different\n   computation from that which was originally requested.\n
      \  It is also possible to damage the operation of a PCE through a\n   variety
      of denial-of-service attacks.  Such attacks can cause the PCE\n   to become
      congested with the result that path computations are\n   supplied too slowly
      to be of value for PCCs.  This could lead to\n   slower-than-acceptable recovery
      times or delayed LSP establishment.\n   In extreme cases, it may be that service
      requests are not satisfied.\n   PCEP could be the target of the following attacks:\n
      \  o  Spoofing (PCC or PCE impersonation)\n   o  Snooping (message interception)\n
      \  o  Falsification\n   o  Denial of Service\n   In inter-AS scenarios when
      PCE-to-PCE communication is required,\n   attacks may be particularly significant
      with commercial as well as\n   service-level implications.\n   Additionally,
      snooping of PCEP requests and responses may give an\n   attacker information
      about the operation of the network.  Simply by\n   viewing the PCEP messages
      someone can determine the pattern of\n   service establishment in the network
      and can know where traffic is\n   being routed, thereby making the network susceptible
      to targeted\n   attacks and the data within specific LSPs vulnerable.\n   The
      following sections identify mechanisms to protect PCEP against\n   security
      attacks.\n"
    title: 10.1.  Vulnerability
  - contents:
    - "10.2.  TCP Security Techniques\n   At the time of writing, TCP-MD5 [RFC2385]
      is the only available\n   security mechanism for securing the TCP connections
      that underly PCEP\n   sessions.\n   As explained in [RFC2385], the use of MD5
      faces some limitations and\n   does not provide as high a level of security
      as was once believed.  A\n   PCEP implementation supporting TCP-MD5 SHOULD be
      designed so that\n   stronger security keying techniques or algorithms that
      may be\n   specified for TCP can be easily integrated in future releases.\n
      \  The TCP Authentication Option [TCP-AUTH] (TCP-AO) specifies new\n   security
      procedures for TCP, but is not yet complete.  Since it is\n   believed that
      [TCP-AUTH] will offer significantly improved security\n   for applications using
      TCP, implementers should expect to update\n   their implementation as soon as
      the TCP Authentication Option is\n   published as an RFC.\n   Implementations
      MUST support TCP-MD5 and should make the security\n   function available as
      a configuration option.\n   Operators will need to observe that some deployed
      PCEP\n   implementations may pre-date the completion of [TCP-AUTH], and it\n
      \  will be necessary to configure policy for secure communication\n   between
      PCEP speakers that support the TCP Authentication Option, and\n   those that
      don't.\n   An alternative approach for security over TCP transport is to use
      the\n   Transport Layer Security (TLS) protocol [RFC5246].  This provides\n
      \  protection against eavesdropping, tampering, and message forgery.\n   But
      TLS doesn't protect the TCP connection itself, because it does\n   not authenticate
      the TCP header.  Thus, it is vulnerable to attacks\n   such as TCP reset attacks
      (something against which TCP-MD5 does\n   protect).  The use of TLS would, however,
      require the specification\n   of how PCEP initiates TLS handshaking and how
      it interprets the\n   certificates exchanged in TLS.  That specification is
      out of the\n   scope of this document, but could be the subject of future work.\n"
    title: 10.2.  TCP Security Techniques
  - contents:
    - "10.3.  PCEP Authentication and Integrity\n   Authentication and integrity checks
      allow the receiver of a PCEP\n   message to know that the message genuinely
      comes from the node that\n   purports to have sent it and to know whether the
      message has been\n   modified.\n   The TCP-MD5 mechanism [RFC2385] described
      in the previous section\n   provides such a mechanism subject to the concerns
      listed in [RFC2385]\n   and [RFC4278].  These issues will be addressed and resolved
      by\n   [TCP-AUTH].\n"
    title: 10.3.  PCEP Authentication and Integrity
  - contents:
    - "10.4.  PCEP Privacy\n   Ensuring PCEP communication privacy is of key importance,
      especially\n   in an inter-AS context, where PCEP communication end-points do
      not\n   reside in the same AS, as an attacker that intercepts a PCE message\n
      \  could obtain sensitive information related to computed paths and\n   resources.\n
      \  PCEP privacy can be ensured by encryption.  TCP MAY be run over IPsec\n   [RFC4303]
      tunnels to provide the required encryption.  Note that\n   IPsec can also ensure
      authentication and integrity; in which case,\n   TCP-MD5 or TCP-AO would not
      be required.  However, there is some\n   concern that IPsec on this scale would
      be hard to configure and\n   operate.  Use of IPSec with PCEP is out of the
      scope of this document\n   and may be addressed in a separate document.\n"
    title: 10.4.  PCEP Privacy
  - contents:
    - "10.5.  Key Configuration and Exchange\n   Authentication, tamper protection,
      and encryption all require the use\n   of keys by sender and receiver.\n   Although
      key configuration per session is possible, it may be\n   particularly onerous
      to operators (in the same way as for the Border\n   Gateway Protocol (BGP) as
      discussed in [BGP-SEC]).  If there is a\n   relatively small number of PCCs
      and PCEs in the network, manual key\n   configuration MAY be considered a valid
      choice by the operator,\n   although it is important to be aware of the vulnerabilities\n
      \  introduced by such mechanisms (i.e., configuration errors, social\n   engineering,
      and carelessness could all give rise to security\n   breaches).  Furthermore,
      manually configured keys are less likely to\n   be regularly updated which also
      increases the security risk.  Where\n   there is a large number of PCCs and
      PCEs, the operator could find\n   that key configuration and maintenance is
      a significant burden as\n   each PCC needs to be configured to the PCE.\n   An
      alternative to individual keys is the use of a group key.  A group\n   key is
      common knowledge among all members of a trust domain.  Thus,\n   since the routers
      in an IGP area or an AS are part of a common trust\n   domain [MPLS-SEC], a
      PCEP group key MAY be shared among all PCCs and\n   PCEs in an IGP area or AS.
      \ The use of a group key will considerably\n   simplify the operator's configuration
      task while continuing to secure\n   PCEP against attack from outside the network.
      \ However, it must be\n   noted that the more entities that have access to a
      key, the greater\n   the risk of that key becoming public.\n   With the use
      of a group key, separate keys would need to be\n   configured for the PCE-to-PCE
      communications that cross trust domain\n   (e.g., AS) boundaries, but the number
      of these relationships is\n   likely to be very small.\n   PCE discovery ([RFC5088]
      and [RFC5089]) is a significant feature for\n   the successful deployment of
      PCEP in large networks.  This mechanism\n   allows a PCC to discover the existence
      of suitable PCEs within the\n   network without the necessity of configuration.
      \ It should be obvious\n   that, where PCEs are discovered and not configured,
      the PCC cannot\n   know the correct key to use.  There are three possible approaches
      to\n   this problem that retain some aspect of security:\n   o  The PCCs may
      use a group key as previously discussed.\n   o  The PCCs may use some form of
      secure key exchange protocol with\n      the PCE (such as the Internet Key Exchange
      protocol v2 (IKE)\n      [RFC4306]).  The drawback to this is that IKE implementations
      on\n      routers are not common and this may be a barrier to the deployment\n
      \     of PCEP.  Details are out of the scope of this document and may be\n      addressed
      in a separate document.\n   o  The PCCs may make use of a key server to determine
      the key to use\n      when talking to the PCE.  To some extent, this is just
      moving the\n      problem, since the PCC's communications with the key server
      must\n      also be secure (for example, using Kerberos [RFC4120]), but there\n
      \     may some (minor) benefit in scaling if the PCC is to learn about\n      several
      PCEs and only needs to know one key server.  Note that key\n      servers currently
      have very limited implementation.  Details are\n      out of the scope of this
      document and may be addressed in a\n      separate document.\n   PCEP relationships
      are likely to be long-lived even if the PCEP\n   sessions are repeatedly closed
      and re-established.  Where protocol\n   relationships persist for a large number
      of protocol interactions or\n   over a long period of time, changes in the keys
      used by the protocol\n   peers is RECOMMENDED [RFC4107].  Note that TCP-MD5
      does not allow the\n   key to be changed without closing and reopening the TCP
      connection\n   which would result in the PCEP session being terminated and needing\n
      \  to be restarted.  That might not be a significant issue for PCEP.\n   Note
      also that the plans for the TCP Authentication Option [TCP-AUTH]\n   will allow
      dynamic key change (roll-over) for an active TCP\n   connection.\n   If key
      exchange is used (for example, through IKE), then it is\n   relatively simple
      to support dynamic key updates and apply these to\n   PCEP.\n   Note that in-band
      key management for the TCP Authentication Option\n   [TCP-AUTH] is currently
      unresolved.\n   [RFC3562] sets out some of the issues for the key management
      of\n   secure TCP connections.\n"
    title: 10.5.  Key Configuration and Exchange
  - contents:
    - "10.6.  Access Policy\n   Unauthorized access to PCE function represents a variety
      of potential\n   attacks.  Not only may this be a simple denial-of-service attack
      (see\n   Section 10.7), but it would be a mechanism for an intruder to\n   determine
      important information about the network and operational\n   network policies
      simply by inserting bogus computation requests.\n   Furthermore, false computation
      requests could be used to predict\n   where traffic will be placed in the network
      when real requests are\n   made, allowing the attacker to target specific network
      resources.\n   PCEs SHOULD be configurable for access policy.  Where authentication\n
      \  is used, access policy can be achieved through the exchange or\n   configuration
      of keys as described in Section 10.5.  More simple\n   policies MAY be configured
      on PCEs in the form of access lists where\n   the IP addresses of the legitimate
      PCCs are listed.  Policies SHOULD\n   also be configurable to limit the type
      of computation requests that\n   are supported from different PCCs.\n   It is
      RECOMMENDED that access policy violations are logged by the PCE\n   and are
      available for inspection by the operator to determine whether\n   attempts have
      been made to attack the PCE.  Such mechanisms MUST be\n   lightweight to prevent
      them from being used to support denial-of-\n   service attacks (see Section
      10.7).\n"
    title: 10.6.  Access Policy
  - contents:
    - "10.7.  Protection against Denial-of-Service Attacks\n   Denial-of-service (DoS)
      attacks could be mounted at the TCP level or\n   at the PCEP level.  That is,
      the PCE could be attacked through\n   attacks on TCP or through attacks within
      established PCEP sessions.\n"
    - contents:
      - "10.7.1.  Protection against TCP DoS Attacks\n   PCEP can be the target of
        TCP DoS attacks, such as for instance SYN\n   attacks, as is the case for
        all protocols that run over TCP.  Other\n   protocol specifications have investigated
        this problem and PCEP can\n   share their experience.  The reader is referred
        to the specification\n   of the Label Distribution Protocol (LDP) [RFC5036]
        for example.  In\n   order to protect against TCP DoS attacks, PCEP implementations
        can\n   support the following techniques.\n   o  PCEP uses a single registered
        port for all communications.  The\n      PCE SHOULD listen for TCP connections
        only on ports where\n      communication is expected.\n   o  The PCE MAY implement
        an access list to immediately reject (or\n      discard) TCP connection attempts
        from unauthorized PCCs.\n   o  The PCE SHOULD NOT allow parallel TCP connections
        from the same\n      PCC on the PCEP-registered port.\n   o  The PCE MAY require
        the use of the MD5 option on all TCP\n      connections, and MAY reject (or
        discard) any connection setup\n      attempt that does not use MD5.  A PCE
        MUST NOT accept any SYN\n      packet for which the MD5 segment checksum is
        invalid.  Note,\n      however, that the use of MD5 requires that the receiver
        use CPU\n      resources to compute the checksum before it can decide to discard\n
        \     an otherwise acceptable SYN segment.\n"
      title: 10.7.1.  Protection against TCP DoS Attacks
    - contents:
      - "10.7.2.  Request Input Shaping/Policing\n   A PCEP implementation may be
        subject to DoS attacks within a\n   legitimate PCEP session.  For example,
        a PCC might send a very large\n   number of PCReq messages causing the PCE
        to become congested or\n   causing requests from other PCCs to be queued.\n
        \  Note that the direct use of the Priority field on the RP object to\n   prioritize
        received requests does not provide any protection since\n   the attacker could
        set all requests to be of the highest priority.\n   Therefore, it is RECOMMENDED
        that PCE implementations include input\n   shaping/policing mechanisms that
        either throttle the requests\n   received from any one PCC, or apply queuing
        or priority-degradation\n   techniques to over-communicative PCCs.\n   Such
        mechanisms MAY be set by default, but SHOULD be available for\n   configuration.
        \ Such techniques may be considered particularly\n   important in multi-service-provider
        environments to protect the\n   resources of one service provider from unwarranted,
        over-zealous, or\n   malicious use by PCEs in another service provider.\n"
      title: 10.7.2.  Request Input Shaping/Policing
    title: 10.7.  Protection against Denial-of-Service Attacks
  title: 10.  Security Considerations
- contents:
  - "11.  Acknowledgments\n   The authors would like to thank Dave Oran, Dean Cheng,
    Jerry Ash,\n   Igor Bryskin, Carol Iturrade, Siva Sivabalan, Rich Bradford, Richard\n
    \  Douville, Jon Parker, Martin German, and Dennis Aristow for their\n   very
    valuable input.  The authors would also like to thank Fabien\n   Verhaeghe for
    the very fruitful discussions and useful suggestions.\n   David McGrew and Brian
    Weis provided valuable input to the Security\n   Considerations section.\n   Ross
    Callon, Magnus Westerlund, Lars Eggert, Pasi Eronen, Tim Polk,\n   Chris Newman,
    and Russ Housley provided important input during IESG\n   review.\n"
  title: 11.  Acknowledgments
- contents:
  - '12.  References

    '
  - contents:
    - "12.1.  Normative References\n   [RFC2119]        Bradner, S., \"Key words for
      use in RFCs to Indicate\n                    Requirement Levels\", BCP 14, RFC
      2119, March 1997.\n   [RFC2205]        Braden, B., Zhang, L., Berson, S., Herzog,
      S., and\n                    S. Jamin, \"Resource ReSerVation Protocol (RSVP)
      --\n                    Version 1 Functional Specification\", RFC 2205,\n                    September
      1997.\n   [RFC2385]        Heffernan, A., \"Protection of BGP Sessions via the\n
      \                   TCP MD5 Signature Option\", RFC 2385, August 1998.\n   [RFC3209]
      \       Awduche, D., Berger, L., Gan, D., Li, T.,\n                    Srinivasan,
      V., and G. Swallow, \"RSVP-TE: Extensions\n                    to RSVP for LSP
      Tunnels\", RFC 3209, December 2001.\n   [RFC3473]        Berger, L., \"Generalized
      Multi-Protocol Label\n                    Switching (GMPLS) Signaling Resource
      ReserVation\n                    Protocol-Traffic Engineering (RSVP-TE) Extensions\",\n
      \                   RFC 3473, January 2003.\n   [RFC3477]        Kompella, K.
      and Y. Rekhter, \"Signalling Unnumbered\n                    Links in Resource
      ReSerVation Protocol - Traffic\n                    Engineering (RSVP-TE)\",
      RFC 3477, January 2003.\n   [RFC4090]        Pan, P., Swallow, G., and A. Atlas,
      \"Fast Reroute\n                    Extensions to RSVP-TE for LSP Tunnels\",
      RFC 4090,\n                    May 2005.\n   [RFC5226]        Narten, T. and
      H. Alvestrand, \"Guidelines for\n                    Writing an IANA Considerations
      Section in RFCs\",\n                    BCP 26, RFC 5226, May 2008.\n"
    title: 12.1.  Normative References
  - contents:
    - "12.2.  Informative References\n   [BGP-SEC]        Christian, B. and T. Tauber,
      \"BGP Security\n                    Requirements\", Work in Progress, November
      2008.\n   [IEEE.754.1985]  IEEE Standard 754, \"Standard for Binary Floating-\n
      \                   Point Arithmetic\", August 1985.\n   [INTER-LAYER]    Oki,
      E., Roux, J., Kumaki, K., Farrel, A., and T.\n                    Takeda, \"PCC-PCE
      Communication and PCE Discovery\n                    Requirements for Inter-Layer
      Traffic Engineering\",\n                    Work in Progress, January 2009.\n
      \  [MPLS-SEC]       Fang, L. and M. Behringer, \"Security Framework for\n                    MPLS
      and GMPLS Networks\", Work in Progress,\n                    November 2008.\n
      \  [PCE-MANAGE]     Farrel, A., \"Inclusion of Manageability Sections in\n                    PCE
      Working Group Drafts\", Work in Progress,\n                    January 2009.\n
      \  [PCE-MONITOR]    Vasseur, J., Roux, J., and Y. Ikejiri, \"A set of\n                    monitoring
      tools for Path Computation Element based\n                    Architecture\",
      Work in Progress, November 2008.\n   [PCEP-MIB]       Stephan, E. and K. Koushik,
      \"PCE communication\n                    protocol (PCEP) Management Information
      Base\",\n                    Work in Progress, November 2008.\n   [RBNF]           Farrel,
      A., \"Reduced Backus-Naur Form (RBNF) A\n                    Syntax Used in
      Various Protocol Specifications\",\n                    Work in Progress, November
      2008.\n   [RFC1321]        Rivest, R., \"The MD5 Message-Digest Algorithm\",\n
      \                   RFC 1321, April 1992.\n   [RFC3471]        Berger, L., \"Generalized
      Multi-Protocol Label\n                    Switching (GMPLS) Signaling Functional
      Description\",\n                    RFC 3471, January 2003.\n   [RFC3562]        Leech,
      M., \"Key Management Considerations for the\n                    TCP MD5 Signature
      Option\", RFC 3562, July 2003.\n   [RFC3785]        Le Faucheur, F., Uppili,
      R., Vedrenne, A., Merckx,\n                    P., and T. Telkamp, \"Use of
      Interior Gateway\n                    Protocol (IGP) Metric as a second MPLS
      Traffic\n                    Engineering (TE) Metric\", BCP 87, RFC 3785,\n
      \                   May 2004.\n   [RFC4022]        Raghunarayan, R., \"Management
      Information Base for\n                    the Transmission Control Protocol
      (TCP)\", RFC 4022,\n                    March 2005.\n   [RFC4101]        Rescorla,
      E. and IAB, \"Writing Protocol Models\",\n                    RFC 4101, June
      2005.\n   [RFC4107]        Bellovin, S. and R. Housley, \"Guidelines for\n                    Cryptographic
      Key Management\", BCP 107, RFC 4107,\n                    June 2005.\n   [RFC4120]
      \       Neuman, C., Yu, T., Hartman, S., and K. Raeburn,\n                    \"The
      Kerberos Network Authentication Service (V5)\",\n                    RFC 4120,
      July 2005.\n   [RFC4278]        Bellovin, S. and A. Zinin, \"Standards Maturity\n
      \                   Variance Regarding the TCP MD5 Signature Option (RFC\n                    2385)
      and the BGP-4 Specification\", RFC 4278,\n                    January 2006.\n
      \  [RFC4303]        Kent, S., \"IP Encapsulating Security Payload (ESP)\",\n
      \                   RFC 4303, December 2005.\n   [RFC4306]        Kaufman, C.,
      \"Internet Key Exchange (IKEv2)\n                    Protocol\", RFC 4306, December
      2005.\n   [RFC5420]        Farrel, A., Ed., Papadimitriou, D., Vasseur, JP.,\n
      \                   and A. Ayyangarps, \"Encoding of Attributes for MPLS\n                    LSP
      Establishment Using Resource Reservation\n                    Protocol Traffic
      Engineering (RSVP-TE)\", RFC 5420,\n                    February 2009.\n   [RFC4655]
      \       Farrel, A., Vasseur, J., and J. Ash, \"A Path\n                    Computation
      Element (PCE)-Based Architecture\",\n                    RFC 4655, August 2006.\n
      \  [RFC4657]        Ash, J. and J. Le Roux, \"Path Computation Element\n                    (PCE)
      Communication Protocol Generic Requirements\",\n                    RFC 4657,
      September 2006.\n   [RFC4674]        Le Roux, J., \"Requirements for Path Computation\n
      \                   Element (PCE) Discovery\", RFC 4674, October 2006.\n   [RFC4927]
      \       Le Roux, J., \"Path Computation Element Communication\n                    Protocol
      (PCECP) Specific Requirements for Inter-\n                    Area MPLS and
      GMPLS Traffic Engineering\", RFC 4927,\n                    June 2007.\n   [RFC5036]
      \       Andersson, L., Minei, I., and B. Thomas, \"LDP\n                    Specification\",
      RFC 5036, October 2007.\n   [RFC5088]        Le Roux, JL., Vasseur, JP., Ikejiri,
      Y., and R.\n                    Zhang, \"OSPF Protocol Extensions for Path\n
      \                   Computation Element (PCE) Discovery\", RFC 5088,\n                    January
      2008.\n   [RFC5089]        Le Roux, JL., Vasseur, JP., Ikejiri, Y., and R.\n
      \                   Zhang, \"IS-IS Protocol Extensions for Path\n                    Computation
      Element (PCE) Discovery\", RFC 5089,\n                    January 2008.\n   [RFC5246]
      \       Dierks, T. and E. Rescorla, \"The Transport Layer\n                    Security
      (TLS) Protocol Version 1.2\", RFC 5246,\n                    August 2008.\n
      \  [RFC5376]        Bitar, N., Zhang, R., and K. Kumaki, \"Inter-AS\n                    Requirements
      for the Path Computation Element\n                    Communication Protocol
      (PCECP)\", RFC 5376,\n                    November 2008.\n   [TCP-AUTH]       Touch,
      J., Mankin, A., and R. Bonica, \"The TCP\n                    Authentication
      Option\", Work in Progress,\n                    November 2008.\n"
    title: 12.2.  Informative References
  title: 12.  References
- contents:
  - "Appendix A.  PCEP Finite State Machine (FSM)\n   The section describes the PCEP
    finite state machine (FSM).  PCEP\n   Finite State Machine\n                          +-+-+-+-+-+-+<------+\n
    \                  +------| SessionUP |<---+  |\n                   |      +-+-+-+-+-+-+
    \   |  |\n                   |                       |  |\n                   |
    \  +->+-+-+-+-+-+-+    |  |\n                   |   |  | KeepWait  |----+  |\n
    \                  |   +--|           |<---+  |\n                   |+-----+-+-+-+-+-+-+
    \   |  |\n                   ||          |           |  |\n                   ||
    \         |           |  |\n                   ||          V           |  |\n
    \                  ||  +->+-+-+-+-+-+-+----+  |\n                   ||  |  | OpenWait
    \ |-------+\n                   ||  +--|           |<------+\n                   ||+----+-+-+-+-+-+-+<---+
    \ |\n                   |||         |           |  |\n                   |||         |
    \          |  |\n                   |||         V           |  |\n                   |||
    +->+-+-+-+-+-+-+    |  |\n                   ||| |  |TCPPending |----+  |\n                   |||
    +--|           |       |\n                   |||+---+-+-+-+-+-+-+<---+  |\n                   ||||
    \       |           |  |\n                   ||||        |           |  |\n                   ||||
    \       V           |  |\n                   |||+--->+-+-+-+-+       |  |\n                   ||+---->|
    Idle  |-------+  |\n                   |+----->|       |----------+\n                   +------>+-+-+-+-+\n
    \       Figure 23: PCEP Finite State Machine for the PCC\n   PCEP defines the
    following set of variables:\n   Connect:  the timer (in seconds) started after
    having initialized a\n      TCP connection using the PCEP-registered TCP port.
    \ The value of\n      the Connect timer is 60 seconds.\n   ConnectRetry:  the
    number of times the system has tried to establish\n      a TCP connection with
    a PCEP peer without success.\n   ConnectMaxRetry:  the maximum number of times
    the system tries to\n      establish a TCP connection using the PCEP-registered
    TCP port\n      before going back to the Idle state.  The value of the\n      ConnectMaxRetry
    is 5.\n   OpenWait:  the timer that corresponds to the amount of time a PCEP\n
    \     peer will wait to receive an Open message from the PCEP peer after\n      the
    expiration of which the system releases the PCEP resource and\n      goes back
    to the Idle state.  The OpenWait timer has a fixed value\n      of 60 seconds.\n
    \  KeepWait:  the timer that corresponds to the amount of time a PCEP\n      peer
    will wait to receive a Keepalive or a PCErr message from the\n      PCEP peer
    after the expiration of which the system releases the\n      PCEP resource and
    goes back to the Idle state.  The KeepWait timer\n      has a fixed value of 60
    seconds.\n   OpenRetry:  the number of times the system has received an Open\n
    \     message with unacceptable PCEP session characteristics.\n   The following
    two state variables are defined:\n   RemoteOK:  a boolean that is set to 1 if
    the system has received an\n      acceptable Open message.\n   LocalOK:  a boolean
    that is set to 1 if the system has received a\n      Keepalive message acknowledging
    that the Open message sent to the\n      peer was valid.\n   Idle State:\n   The
    idle state is the initial PCEP state where the PCEP (also\n   referred to as \"the
    system\") waits for an initialization event that\n   can either be manually triggered
    by the user (configuration) or\n   automatically triggered by various events.
    \ In Idle state, PCEP\n   resources are allocated (memory, potential process,
    etc.) but no PCEP\n   messages are accepted from any PCEP peer.  The system listens
    to the\n   PCEP-registered TCP port.\n   The following set of variables are initialized:\n
    \     TCPRetry=0,\n      LocalOK=0,\n      RemoteOK=0,\n      OpenRetry=0.\n   Upon
    detection of a local initialization event (e.g., user\n   configuration to establish
    a PCEP session with a particular PCEP\n   peer, local event triggering the establishment
    of a PCEP session with\n   a PCEP peer such as the automatic detection of a PCEP
    peer), the\n   system:\n   o  Initiates a TCP connection with the PCEP peer,\n
    \  o  Starts the Connect timer,\n   o  Moves to the TCPPending state.\n   Upon
    receiving a TCP connection on the PCEP-registered TCP port, if\n   the TCP connection
    establishment succeeds, the system:\n   o  Sends an Open message,\n   o  Starts
    the OpenWait timer,\n   o  Moves to the OpenWait state.\n   If the connection
    establishment fails, the system remains in the Idle\n   state.  Any other event
    received in the Idle state is ignored.\n   It is expected that an implementation
    will use an exponentially\n   increasing timer between automatically generated
    Initialization\n   events and between retries of TCP connection establishment.\n
    \  TCPPending State:\n   If the TCP connection establishment succeeds, the system:\n
    \  o  Sends an Open message,\n   o  Starts the OpenWait timer,\n   o  Moves to
    the OpenWait state.\n   If the TCP connection establishment fails (an error is
    detected\n   during the TCP connection establishment) or the Connect timer\n   expires:\n
    \  o  If ConnectRetry = ConnectMaxRetry, the system moves to the Idle\n      State.\n
    \  o  If ConnectRetry < ConnectMaxRetry, the system:\n      1.  Initiates of a
    TCP connection with the PCEP peer,\n      2.  Increments the ConnectRetry variable,\n
    \     3.  Restarts the Connect timer,\n      4.  Stays in the TCPPending state.\n
    \  In response to any other event, the system releases the PCEP\n   resources
    for that peer and moves back to the Idle state.\n   OpenWait State:\n   In the
    OpenWait state, the system waits for an Open message from its\n   PCEP peer.\n
    \  If the system receives an Open message from the PCEP peer before the\n   expiration
    of the OpenWait timer, the system first examines all of\n   its sessions that
    are in the OpenWait or KeepWait state.  If another\n   session with the same PCEP
    peer already exists (same IP address),\n   then the system performs the following
    collision-resolution\n   procedure:\n   o  If the system has initiated the current
    session and it has a lower\n      IP address than the PCEP peer, the system closes
    the TCP\n      connection, releases the PCEP resources for the pending session,\n
    \     and moves back to the Idle state.\n   o  If the session was initiated by
    the PCEP peer and the system has a\n      higher IP address that the PCEP peer,
    the system closes the TCP\n      connection, releases the PCEP resources for the
    pending session,\n      and moves back to the Idle state.\n   o  Otherwise, the
    system checks the PCEP session attributes\n      (Keepalive frequency, DeadTimer,
    etc.).\n   If an error is detected (e.g., malformed Open message, reception of
    a\n   message that is not an Open message, presence of two OPEN objects),\n   PCEP
    generates an error notification, the PCEP peer sends a PCErr\n   message with
    Error-Type=1 and Error-value=1.  The system releases the\n   PCEP resources for
    the PCEP peer, closes the TCP connection, and\n   moves to the Idle state.\n   If
    no errors are detected, OpenRetry=1, and the session\n   characteristics are unacceptable,
    the PCEP peer sends a PCErr with\n   Error-Type=1 and Error-value=5, and the system
    releases the PCEP\n   resources for that peer and moves back to the Idle state.\n
    \  If no errors are detected, and the session characteristics are\n   acceptable
    to the local system, the system:\n   o  Sends a Keepalive message to the PCEP
    peer,\n   o  Starts the Keepalive timer,\n   o  Sets the RemoteOK variable to
    1.\n   If LocalOK=1, the system clears the OpenWait timer and moves to the\n   UP
    state.\n   If LocalOK=0, the system clears the OpenWait timer, starts the\n   KeepWait
    timer, and moves to the KeepWait state.\n   If no errors are detected, but the
    session characteristics are\n   unacceptable and non-negotiable, the PCEP peer
    sends a PCErr with\n   Error-Type=1 and Error-value=3, and the system releases
    the PCEP\n   resources for that peer and moves back to the Idle state.\n   If
    no errors are detected, and OpenRetry is 0, and the session\n   characteristics
    are unacceptable but negotiable (such as, the\n   Keepalive period or the DeadTimer),
    then the system:\n   o  Increments the OpenRetry variable,\n   o  Sends a PCErr
    message with Error-Type=1 and Error-value=4 that\n      contains proposed acceptable
    session characteristics,\n   o  If LocalOK=1, the system restarts the OpenWait
    timer and stays in\n      the OpenWait state.\n   o  If LocalOK=0, the system
    clears the OpenWait timer, starts the\n      KeepWait timer, and moves to the
    KeepWait state.\n   If no Open message is received before the expiration of the
    OpenWait\n   timer, the PCEP peer sends a PCErr message with Error-Type=1 and\n
    \  Error-value=2, the system releases the PCEP resources for the PCEP\n   peer,
    closes the TCP connection, and moves to the Idle state.\n   In response to any
    other event, the system releases the PCEP\n   resources for that peer and moves
    back to the Idle state.\n   KeepWait State:\n   In the Keepwait state, the system
    waits for the receipt of a\n   Keepalive from its PCEP peer acknowledging its
    Open message or a\n   PCErr message in response to unacceptable PCEP session\n
    \  characteristics proposed in the Open message.\n   If an error is detected (e.g.,
    malformed Keepalive message), PCEP\n   generates an error notification, the PCEP
    peer sends a PCErr message\n   with Error-Type=1 and Error-value=1.  The system
    releases the PCEP\n   resources for the PCEP peer, closes the TCP connection,
    and moves to\n   the Idle state.\n   If a Keepalive message is received before
    the expiration of the\n   KeepWait timer, then the system sets LocalOK=1 and:\n
    \  o  If RemoteOK=1, the system clears the KeepWait timer and moves to\n      the
    UP state.\n   o  If RemoteOK=0, the system clears the KeepWait timer, starts the\n
    \     OpenWait timer, and moves to the OpenWait State.\n   If a PCErr message
    is received before the expiration of the KeepWait\n   timer:\n   1.  If the proposed
    values are unacceptable, the PCEP peer sends a\n       PCErr message with Error-Type=1
    and Error-value=6, and the system\n       releases the PCEP resources for that
    PCEP peer, closes the TCP\n       connection, and moves to the Idle state.\n   2.
    \ If the proposed values are acceptable, the system adjusts its\n       PCEP session
    characteristics according to the proposed values\n       received in the PCErr
    message, restarts the KeepWait timer, and\n       sends a new Open message.  If
    RemoteOK=1, the system restarts the\n       KeepWait timer and stays in the KeepWait
    state.  If RemoteOK=0,\n       the system clears the KeepWait timer, starts the
    OpenWait timer,\n       and moves to the OpenWait state.\n   If neither a Keepalive
    nor a PCErr is received after the expiration\n   of the KeepWait timer, the PCEP
    peer sends a PCErr message with\n   Error-Type=1 and Error-value=7, and the system
    releases the PCEP\n   resources for that PCEP peer, closes the TCP connection,
    and moves to\n   the Idle State.\n   In response to any other event, the system
    releases the PCEP\n   resources for that peer and moves back to the Idle state.\n
    \  UP State:\n   In the UP state, the PCEP peer starts exchanging PCEP messages\n
    \  according to the session characteristics.\n   If the Keepalive timer expires,
    the system restarts the Keepalive\n   timer and sends a Keepalive message.\n   If
    no PCEP message (Keepalive, PCReq, PCRep, PCNtf) is received from\n   the PCEP
    peer before the expiration of the DeadTimer, the system\n   terminates the PCEP
    session according to the procedure defined in\n   Section 6.8, releases the PCEP
    resources for that PCEP peer, closes\n   the TCP connection, and moves to the
    Idle State.\n   If a malformed message is received, the system terminates the
    PCEP\n   session according to the procedure defined in Section 6.8, releases\n
    \  the PCEP resources for that PCEP peer, closes the TCP connection and\n   moves
    to the Idle State.\n   If the system detects that the PCEP peer tries to set up
    a second TCP\n   connection, it stops the TCP connection establishment and sends
    a\n   PCErr with Error-Type=9.\n   If the TCP connection fails, the system releases
    the PCEP resources\n   for that PCEP peer, closes the TCP connection, and moves
    to the Idle\n   State.\n"
  title: Appendix A.  PCEP Finite State Machine (FSM)
- contents:
  - "Appendix B.  PCEP Variables\n   PCEP defines the following configurable variables:\n
    \  Keepalive timer:  minimum period of time between the sending of PCEP\n      messages
    (Keepalive, PCReq, PCRep, PCNtf) to a PCEP peer.  A\n      suggested value for
    the Keepalive timer is 30 seconds.\n   DeadTimer:  period of timer after the expiration
    of which a PCEP peer\n      declares the session down if no PCEP message has been
    received.\n   SyncTimer:  timer used in the case of synchronized path computation\n
    \     request using the SVEC object defined in Section 7.13.3.  Consider\n      the
    case where a PCReq message is received by a PCE that contains\n      the SVEC
    object referring to M synchronized path computation\n      requests.  If after
    the expiration of the SyncTimer all the M path\n      computation requests have
    not been received, a protocol error is\n      triggered and the PCE MUST cancel
    the whole set of path\n      computation requests.  The aim of the SyncTimer is
    to avoid the\n      storage of unused synchronized requests should one of them
    get\n      lost for some reason (e.g., a misbehaving PCC).  Thus, the value\n
    \     of the SyncTimer must be large enough to avoid the expiration of\n      the
    timer under normal circumstances.  A RECOMMENDED value for the\n      SyncTimer
    is 60 seconds.\n   MAX-UNKNOWN-REQUESTS:  A RECOMMENDED value is 5.\n   MAX-UNKNOWN-MESSAGES:
    \ A RECOMMENDED value is 5.\n"
  title: Appendix B.  PCEP Variables
- contents:
  - "Appendix C.  Contributors\n   The content of this document was contributed by
    those listed below\n   and the editors listed at the end of the document.\n   Arthi
    Ayyangar\n   Juniper Networks\n   1194 N. Mathilda Ave\n   Sunnyvale, CA  94089\n
    \  USA\n   EMail: arthi@juniper.net\n   Adrian Farrel\n   Old Dog Consulting\n
    \  Phone: +44 (0) 1978 860944\n   EMail: adrian@olddog.co.uk\n   Eiji Oki\n   NTT\n
    \  Midori 3-9-11\n   Musashino, Tokyo,   180-8585\n   JAPAN\n   EMail: oki.eiji@lab.ntt.co.jp\n
    \  Alia Atlas\n   British Telecom\n   EMail: akatlas@alum.mit.edu\n   Andrew Dolganow\n
    \  Alcatel\n   600 March Road\n   Ottawa, ON  K2K 2E6\n   CANADA\n   EMail: andrew.dolganow@alcatel.com\n
    \  Yuichi Ikejiri\n   NTT Communications Corporation\n   1-1-6 Uchisaiwai-cho,
    Chiyoda-ku\n   Tokyo,   100-819\n   JAPAN\n   EMail: y.ikejiri@ntt.com\n   Kenji
    Kumaki\n   KDDI Corporation\n   Garden Air Tower Iidabashi, Chiyoda-ku,\n   Tokyo,
    \  102-8460\n   JAPAN\n   EMail: ke-kumaki@kddi.com\n"
  title: Appendix C.  Contributors
- contents:
  - "Authors' Addresses\n   JP Vasseur (editor)\n   Cisco Systems\n   1414 Massachusetts
    Avenue\n   Boxborough, MA  01719\n   USA\n   EMail: jpv@cisco.com\n   JL Le Roux
    (editor)\n   France Telecom\n   2, Avenue Pierre-Marzin\n   Lannion  22307\n   FRANCE\n
    \  EMail: jeanlouis.leroux@orange-ftgroup.com\n"
  title: Authors' Addresses
