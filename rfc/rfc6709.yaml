- title: __initial_text__
  contents:
  - ''
- title: Internet Architecture Board (IAB)                           B. Carpenter
  contents:
  - "Internet Architecture Board (IAB)                           B. Carpenter\n  \
    \           Design Considerations for Protocol Extensions\n"
- title: Abstract
  contents:
  - "Abstract\n   This document discusses architectural issues related to the\n  \
    \ extensibility of Internet protocols, with a focus on design\n   considerations.\
    \  It is intended to assist designers of both base\n   protocols and extensions.\
    \  Case studies are included.  A companion\n   document, RFC 4775 (BCP 125), discusses\
    \ procedures relating to the\n   extensibility of IETF protocols.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Architecture Board (IAB)\n   and represents information that\
    \ the IAB has deemed valuable to\n   provide for permanent record.  It represents\
    \ the consensus of the\n   Internet Architecture Board (IAB).  Documents approved\
    \ for\n   publication by the IAB are not a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc6709.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2012 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \      1.1. Requirements Language ......................................4\n  \
    \ 2. Routine and Major Extensions ....................................4\n    \
    \  2.1. What Constitutes a Major Extension? ........................4\n      2.2.\
    \ When is an Extension Routine? ..............................6\n   3. Architectural\
    \ Principles ........................................7\n      3.1. Limited Extensibility\
    \ ......................................7\n      3.2. Design for Global Interoperability\
    \ .........................8\n      3.3. Architectural Compatibility ...............................12\n\
    \      3.4. Protocol Variations .......................................13\n  \
    \    3.5. Testability ...............................................16\n    \
    \  3.6. Protocol Parameter Registration ...........................16\n      3.7.\
    \ Extensions to Critical Protocols ..........................17\n   4. Considerations\
    \ for the Base Protocol ...........................18\n      4.1. Version Numbers\
    \ ...........................................19\n      4.2. Reserved Fields ...........................................22\n\
    \      4.3. Encoding Formats ..........................................23\n  \
    \    4.4. Parameter Space Design ....................................23\n    \
    \  4.5. Cryptographic Agility .....................................26\n      4.6.\
    \ Transport .................................................27\n      4.7. Handling\
    \ of Unknown Extensions ............................28\n   5. Security Considerations\
    \ ........................................29\n   6. References .....................................................30\n\
    \      6.1. Normative References ......................................30\n  \
    \    6.2. Informative References ....................................30\n   7.\
    \ Acknowledgments ................................................35\n   8. IAB\
    \ Members at the Time of Approval ............................35\n   Appendix\
    \ A.  Examples .............................................36\n      A.1. Already-Documented\
    \ Cases ..................................36\n      A.2. RADIUS Extensions .........................................36\n\
    \      A.3. TLS Extensions ............................................39\n  \
    \    A.4. L2TP Extensions ...........................................41\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   When developing protocols, IETF Working Groups (WGs) often\
    \ include\n   mechanisms whereby these protocols can be extended in the future.\
    \  It\n   is often a good principle to design extensibility into protocols; as\n\
    \   described in \"What Makes for a Successful Protocol\" [RFC5218], a\n   \"\
    wildly successful\" protocol is one that becomes widely used in ways\n   not originally\
    \ anticipated.  Well-designed extensibility mechanisms\n   facilitate the evolution\
    \ of protocols and help make it easier to roll\n   out incremental changes in\
    \ an interoperable fashion.  However, at the\n   same time, experience has shown\
    \ that extensions carry the risk of\n   unintended consequences, such as interoperability\
    \ issues, operational\n   problems, or security vulnerabilities.\n   The proliferation\
    \ of extensions, even well-designed ones, can be\n   costly.  As noted in \"Simple\
    \ Mail Transfer Protocol\" [RFC5321]\n   Section 2.2.1:\n      Experience with\
    \ many protocols has shown that protocols with few\n      options tend towards\
    \ ubiquity, whereas protocols with many options\n      tend towards obscurity.\n\
    \      Each and every extension, regardless of its benefits, must be\n      carefully\
    \ scrutinized with respect to its implementation,\n      deployment, and interoperability\
    \ costs.\n   This is hardly a recent concern.  \"TCP Extensions Considered Harmful\"\
    \n   [RFC1263] was published in 1991.  \"Extend\" or \"extension\" occurs in\n\
    \   the title of more than 400 existing Request for Comments (RFC)\n   documents.\
    \  Yet, generic extension considerations have not been\n   documented previously.\n\
    \   The purpose of this document is to describe the architectural\n   principles\
    \ of sound extensibility design, in order to minimize such\n   risks.  Formal\
    \ procedures for extending IETF protocols are discussed\n   in \"Procedures for\
    \ Protocol Extensions and Variations\" BCP 125\n   [RFC4775].\n   The rest of\
    \ this document is organized as follows: Section 2\n   discusses routine and major\
    \ extensions.  Section 3 describes\n   architectural principles for protocol extensibility.\
    \  Section 4\n   explains how designers of base protocols can take steps to anticipate\n\
    \   and facilitate the creation of such subsequent extensions in a safe\n   and\
    \ reliable manner.  Section 5 discusses security considerations.\n   Appendix\
    \ A provides case studies.\n   Readers are advised to study the whole document,\
    \ since the\n   considerations are closely linked.\n"
- title: 1.1.  Requirements Language
  contents:
  - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in \"Key words for use in\n   RFCs to Indicate Requirement Levels\" BCP 14 [RFC2119].\n"
- title: 2.  Routine and Major Extensions
  contents:
  - "2.  Routine and Major Extensions\n   The risk of unintended consequences from\
    \ an extension is especially\n   high if the extension is performed by a different\
    \ team than the\n   original designers, who may stray outside implicit design\
    \ constraints\n   or assumptions.  As a result, it is highly desirable for the\
    \ original\n   designers to articulate the design constraints and assumptions,\
    \ so as\n   to enable extensions to be done carefully and with a full\n   understanding\
    \ of the base protocol, existing implementations, and\n   current operational\
    \ practice.\n   To assist extension designers and reviewers, protocol documents\n\
    \   should provide guidelines explaining how extensions should be\n   performed,\
    \ and guidance on how protocol extension mechanisms should\n   be used.\n   Protocol\
    \ components that are designed with the specific intention of\n   allowing extensibility\
    \ should be clearly identified, with specific\n   and complete instructions on\
    \ how to extend them.  This includes the\n   process for adequate review of extension\
    \ proposals: do they need\n   community review, and if so, how much and by whom?\n\
    \   The level of review required for protocol extensions will typically\n   vary\
    \ based on the nature of the extension.  Routine extensions may\n   require minimal\
    \ review, while major extensions may require wide\n   review.  Guidance on which\
    \ extensions may be considered 'routine' and\n   which ones are 'major' is provided\
    \ in the sections that follow.\n"
- title: 2.1.  What Constitutes a Major Extension?
  contents:
  - "2.1.  What Constitutes a Major Extension?\n   Major extensions may have characteristics\
    \ leading to a risk of\n   interoperability failures, security vulnerabilities,\
    \ or operational\n   problems.  Where these characteristics are present, it is\
    \ necessary\n   to pay close attention to backward compatibility with implementations\n\
    \   and deployments of the unextended protocol and to the potential for\n   inadvertent\
    \ introduction of security or operational exposures.\n   Extension designers should\
    \ examine their design for the following\n   issues:\n   1.  Modifications or\
    \ extensions to the underlying protocol.  An\n       extension document should\
    \ be considered to update the underlying\n       protocol specification if an\
    \ implementation of the underlying\n       protocol would need to be updated to\
    \ accommodate the extension.\n       This should not be necessary if the underlying\
    \ protocol was\n       designed with a modular interface.  Examples of extensions\n\
    \       modifying the underlying protocol include specification of\n       additional\
    \ transports (see Section 4.6), changing protocol\n       semantics, or defining\
    \ new message types that may require\n       implementation changes in existing\
    \ and deployed implementations\n       of the protocol, even if they do not want\
    \ to make use of the new\n       functions.  A base protocol that does not uniformly\
    \ permit\n       \"silent discard\" of unknown extensions may automatically enter\n\
    \       this category, even for apparently minor extensions.  Handling of\n  \
    \     \"unknown\" extensions is discussed in more detail in Section 4.7.\n   2.\
    \  Changes to the basic architectural assumptions.  This may include\n       architectural\
    \ assumptions that are explicitly stated or those\n       that have been assumed\
    \ by implementers.  For example, this would\n       include adding a requirement\
    \ for session state to a previously\n       stateless protocol.\n   3.  New usage\
    \ scenarios not originally intended or investigated.\n       This can potentially\
    \ lead to operational difficulties when\n       deployed, even in cases where\
    \ the \"on-the-wire\" format has not\n       changed.  For example, the level\
    \ of traffic carried by the\n       protocol may increase substantially, packet\
    \ sizes may increase,\n       and implementation algorithms that are widely deployed\
    \ may not\n       scale sufficiently or otherwise be up to the new task at hand.\n\
    \       For example, a new DNS Resource Record (RR) type that is too big\n   \
    \    to fit into a single UDP packet could cause interoperability\n       problems\
    \ with existing DNS clients and servers.  Similarly, the\n       additional traffic\
    \ that results from an extension to a routing\n       protocol could have a detrimental\
    \ impact on the performance or\n       stability of implementations that do not\
    \ implement the extension.\n   4.  Changes to the extension model.  Adverse impacts\
    \ are very likely\n       if the base protocol contains an extension mechanism\
    \ and the\n       proposed extension does not fit into the model used to create\
    \ and\n       define that mechanism.  Extensions that have the same properties\n\
    \       as those that were anticipated when an extension mechanism was\n     \
    \  devised are much less likely to be disruptive than extensions\n       that\
    \ don't fit the model.  Also, changes to the extension model\n       itself (including\
    \ changes limiting further extensibility) can\n       create interoperability\
    \ problems.\n   5.  Changes to protocol syntax.  Changes to protocol syntax bring\n\
    \       with them the potential for backward-compatibility issues.  If at\n  \
    \     all possible, extensions should be designed for compatibility\n       with\
    \ existing syntax, so as to avoid interoperability failures.\n   6.  Interrelated\
    \ extensions to multiple protocols.  A set of\n       interrelated extensions\
    \ to multiple protocols typically carries a\n       greater danger of interoperability\
    \ issues or incompatibilities\n       than a simple extension.  Consequently,\
    \ it is important that such\n       proposals receive earlier and more in-depth\
    \ review than unitary\n       extensions.\n   7.  Changes to the security model.\
    \  Changes to the protocol security\n       model (or even addition of new security\
    \ mechanisms within an\n       existing framework) can introduce security vulnerabilities\
    \ or\n       adversely impact operations.  Consequently, it is important that\n\
    \       such proposals undergo security as well as operational review.\n     \
    \  Security considerations are discussed in Section 5.\n   8.  Performance impact.\
    \  An extension that impacts performance can\n       have adverse consequences,\
    \ particularly if the performance of\n       existing deployments is affected.\n"
- title: 2.2.  When is an Extension Routine?
  contents:
  - "2.2.  When is an Extension Routine?\n   An extension may be considered 'routine'\
    \ if it does not meet the\n   criteria for being considered a 'major' extension\
    \ and if its handling\n   is opaque to the protocol itself (e.g., does not substantially\
    \ change\n   the pattern of messages and responses).  For this to apply, no\n\
    \   changes to the base protocol can be required, nor can changes be\n   required\
    \ to existing and currently deployed implementations, unless\n   they make use\
    \ of the extension.  Furthermore, existing\n   implementations should not be impacted.\
    \  This typically requires that\n   implementations be able to ignore 'routine'\
    \ extensions without ill\n   effects.\n   Examples of routine extensions include\
    \ the Dynamic Host Configuration\n   Protocol (DHCP) vendor-specific option [RFC2132],\
    \ Remote\n   Authentication Dial In User Service (RADIUS) Vendor-Specific\n  \
    \ Attributes [RFC2865], the enterprise Object IDentifier (OID) tree for\n   Management\
    \ Information Base (MIB) modules, and vendor Multipurpose\n   Internet Mail Extension\
    \ (MIME) types.  Such extensions can safely be\n   made with minimal discussion.\n\
    \   Processes that allow routine extensions with minimal or no review\n   (such\
    \ as \"First Come First Served\" (FCFS) allocation [RFC5226])\n   should be used\
    \ sparingly.  In particular, they should be limited to\n   cases that are unlikely\
    \ to result in interoperability problems or in\n   security or operational exposures.\n\
    \   Experience has shown that even routine extensions may benefit from\n   review\
    \ by experts.  For example, even though DHCP carries opaque\n   data, defining\
    \ a new option using completely unstructured data may\n   lead to an option that\
    \ is unnecessarily hard for clients and servers\n   to process.\n"
- title: 3.  Architectural Principles
  contents:
  - "3.  Architectural Principles\n   This section describes basic principles of protocol\
    \ extensibility:\n   1.  Extensibility features should be limited to what is reasonably\n\
    \       anticipated when the protocol is developed.\n   2.  Protocol extensions\
    \ should be designed for global\n       interoperability.\n   3.  Protocol extensions\
    \ should be architecturally compatible with the\n       base protocol.\n   4.\
    \  Protocol extension mechanisms should not be used to create\n       incompatible\
    \ protocol variations.\n   5.  Extension mechanisms need to be testable.\n   6.\
    \  Protocol parameter assignments need to be coordinated to avoid\n       potential\
    \ conflicts.\n   7.  Extensions to critical components require special care. \
    \ A\n       critical component is one whose failure can lead to Internet-wide\n\
    \       reliability and security issues or performance degradation.\n"
- title: 3.1.  Limited Extensibility
  contents:
  - "3.1.  Limited Extensibility\n   Protocols should not be made more extensible\
    \ than clearly necessary\n   at inception, in order to enable optimization along\
    \ dimensions (e.g.,\n   bandwidth, state, memory requirements, deployment time,\
    \ latency,\n   etc.) important to the most common use cases.\n   The process for\
    \ defining new extensibility mechanisms should ensure\n   that adequate review\
    \ of proposed extensions will take place before\n   widespread adoption.\n   As\
    \ noted in \"What Makes for a Successful Protocol\" [RFC5218], \"wildly\n   successful\"\
    \ protocols far exceed their original goals, in terms of\n   scale, purpose (being\
    \ used in scenarios far beyond the initial\n   design), or both.  This implies\
    \ that all potential uses may not be\n   known at inception.  As a result, extensibility\
    \ mechanisms may need\n   to be revisited as additional use cases reveal themselves.\
    \  However,\n   this does not imply that an initial design needs to take all\n\
    \   potential needs into account at inception.\n"
- title: 3.2.  Design for Global Interoperability
  contents:
  - "3.2.  Design for Global Interoperability\n   Section 3.1 of \"Procedures for\
    \ Protocol Extensions and Variations\"\n   BCP 125 [RFC4775] notes:\n      According\
    \ to its Mission Statement [RFC3935], the IETF produces\n      high quality, relevant\
    \ technical and engineering documents,\n      including protocol standards.  The\
    \ mission statement goes on to\n      say that the benefit of these standards\
    \ to the Internet \"is in\n      interoperability - that multiple products implementing\
    \ a standard\n      are able to work together in order to deliver valuable functions\n\
    \      to the Internet's users\".\n      One consequence of this mission is that\
    \ the IETF designs protocols\n      for the single Internet.  The IETF expects\
    \ its protocols to work\n      the same everywhere.  Protocol extensions designed\
    \ for limited\n      environments may be reasonable provided that products with\
    \ these\n      extensions interoperate with products without the extensions.\n\
    \      Extensions that break interoperability are unacceptable when\n      products\
    \ with and without the extension are mixed.  It is the\n      IETF's experience\
    \ that this tends to happen on the Internet even\n      when the original designers\
    \ of the extension did not expect this\n      to happen.\n      Another consequence\
    \ of this definition of interoperability is that\n      the IETF values the ability\
    \ to exchange one product implementing a\n      protocol with another.  The IETF\
    \ often specifies mandatory-to-\n      implement functionality as part of its\
    \ protocols so that there is\n      a core set of functionality sufficient for\
    \ interoperability that\n      all products implement.  The IETF tries to avoid\
    \ situations where\n      protocols need to be profiled to specify which optional\
    \ features\n      are required for a given environment, because doing so harms\n\
    \      interoperability on the Internet as a whole.\n   Since the global Internet\
    \ is more than a collection of incompatible\n   protocols (or \"profiles\") for\
    \ use in separate private networks,\n   implementers supporting extensions in\
    \ shipping products or multi-site\n   experimental usage must assume that systems\
    \ will need to interoperate\n   on the global Internet.\n   A key requirement\
    \ for interoperable extension design is that the base\n   protocol must be well\
    \ designed for interoperability and that\n   extensions must have unambiguous\
    \ semantics.  Ideally, the protocol\n   mechanisms for extension and versioning\
    \ should be sufficiently well\n   described that compatibility can be assessed\
    \ on paper.  Otherwise,\n   when two \"private\" or \"experimental\" extensions\
    \ encounter each other\n   on a public network, unexpected interoperability problems\
    \ may occur.\n   However, as noted in the Transport Layer Security (TLS) case\
    \ study\n   (Appendix A.3), it is not sufficient to design extensibility\n   carefully;\
    \ it also must be implemented carefully.\n"
- title: 3.2.1.  Private Extensions
  contents:
  - "3.2.1.  Private Extensions\n   Experience shows that separate private networks\
    \ often end up having\n   portable equipment like laptop computers move between\
    \ them, and\n   networks that were originally envisaged as being separate can\
    \ end up\n   being connected later.\n   Consider a \"private\" extension installed\
    \ on a work computer that,\n   being portable, is sometimes connected to networks\
    \ other than the\n   work network, like a home network or a hotel network.  If\
    \ the\n   \"private\" extension is incompatible with an unextended version of\
    \ the\n   same protocol, problems will occur.\n   Similarly, problems can occur\
    \ if \"private\" extensions conflict with\n   each other.  For example, imagine\
    \ the situation where one site chose\n   to use DHCP [RFC2132] option code 62\
    \ for one meaning and a different\n   site chose to use DHCP option code 62 for\
    \ a completely different,\n   incompatible, meaning.  It may be impossible for\
    \ a vendor of portable\n   computing devices to make a device that works correctly\
    \ in both\n   environments.\n   One approach to solving this problem has been\
    \ to reserve parts of an\n   identifier namespace for \"limited applicability\"\
    \ or \"site-specific\"\n   use, such as \"X-\" headers in email messages [RFC822]\
    \ or \"P-\" headers\n   in SIP [RFC3427].  However, as noted in \"Deprecating\
    \ the \"X-\" Prefix\n   and Similar Constructs in Application Protocols\" [RFC6648],\
    \ Appendix\n   B:\n      The primary problem with the \"X-\" convention is that\n\
    \      unstandardized parameters have a tendency to leak into the\n      protected\
    \ space of standardized parameters, thus introducing the\n      need for migration\
    \ from the \"X-\" name to a standardized name.\n      Migration, in turn, introduces\
    \ interoperability issues (and\n      sometimes security issues) because older\
    \ implementations will\n      support only the \"X-\" name and newer implementations\
    \ might support\n      only the standardized name.  To preserve interoperability,\
    \ newer\n      implementations simply support the \"X-\" name forever, which means\n\
    \      that the unstandardized name has become a de facto standard (thus\n   \
    \   obviating the need for segregation of the name space into\n      standardized\
    \ and unstandardized areas in the first place).\n   As a result, the notion of\
    \ \"X-\" headers from the 1982 Internet\n   Message Format standard [RFC822] was\
    \ removed when the specification\n   was updated in 2001 [RFC2822].  Within SIP,\
    \ the guidance published in\n   2002 regarding \"P-\" headers [RFC3427] was deprecated\
    \ eight years\n   later in Section 4 of the 2010 update [RFC5727].  More generally,\
    \ as\n   noted in Section 1 of the \"X-\" prefix deprecation document [RFC6648]:\n\
    \      This document generalizes from the experience of the email and SIP\n  \
    \    communities by doing the following:\n      1.  Deprecates the \"X-\" convention\
    \ for newly defined parameters in\n          application protocols, including\
    \ new parameters for\n          established protocols.  This change applies even\
    \ where the\n          \"X-\" convention was only implicit, and not explicitly\n\
    \          provided, such as was done for email in [RFC822].\n"
- title: 3.2.2.  Local Use
  contents:
  - "3.2.2.  Local Use\n   Values designated as \"experimental\" or \"local use\"\
    \ are only\n   appropriate in limited circumstances such as in early implementations\n\
    \   of an extension restricted to a single site.\n   For example, \"Experimental\
    \ Values in IPv4, IPv6, ICMPv4, ICMPv6, UDP,\n   and TCP Headers\" [RFC4727] discusses\
    \ experimental values for IP and\n   transport headers, and \"Definition of the\
    \ Differentiated Services\n   Field (DS Field) in the IPv4 and IPv6 Headers\"\
    \ [RFC2474] defines\n   experimental/local use ranges for differentiated services\
    \ code\n   points.\n   Such values should be used with care and only for their\
    \ stated\n   purpose: experiments and local use.  They are unsuitable for\n  \
    \ Internet-wide use, since they may be used for conflicting purposes\n   and thereby\
    \ cause interoperability failures.  Packets containing\n   experimental or local\
    \ use values must not be allowed out of the\n   domain in which they are meaningful.\n\
    \   Section 1 of \"Assigning Experimental and Testing Numbers Considered\n   Useful\"\
    \ BCP 82 [RFC3692] provides guidance on the use of experimental\n   code points:\n\
    \      Numbers in the experimentation range ... are not intended to be\n     \
    \ used in general deployments or be enabled by default in products\n      or other\
    \ general releases.  In those cases where a product or\n      release makes use\
    \ of an experimental number, the end user must be\n      required to explicitly\
    \ enable the experimental feature and\n      likewise have the ability to chose\
    \ and assign which number from\n      the experimental range will be used for\
    \ a specific purpose (i.e.,\n      so the end user can ensure that use of a particular\
    \ number doesn't\n      conflict with other on-going uses).  Shipping a product\
    \ with a\n      specific value pre-enabled would be inappropriate and can lead\
    \ to\n      interoperability problems when the chosen value collides with a\n\
    \      different usage, as it someday surely will.\n      From the above, it follows\
    \ that it would be inappropriate for a\n      group of vendors, a consortia, or\
    \ another Standards Development\n      Organization to agree among themselves\
    \ to use a particular value\n      for a specific purpose and then agree to deploy\
    \ devices using\n      those values.  By definition, experimental numbers are\
    \ not\n      guaranteed to be unique in any environment other than one where\n\
    \      the local system administrator has chosen to use a particular\n      number\
    \ for a particular purpose and can ensure that a particular\n      value is not\
    \ already in use for some other purpose.\n      Once an extension has been tested\
    \ and shown to be useful, a\n      permanent number could be obtained through\
    \ the normal assignment\n      procedures.\n   However, as noted in Appendix B\
    \ of the \"X-\" prefix deprecation\n   document [RFC6648], assigning a parameter\
    \ block for experimental use\n   is only necessary when the parameter pool is\
    \ limited:\n      \"Assigning Experimental and Testing Numbers Considered Useful\"\
    \ ...\n      implies that the \"X-\" prefix is also useful for experimental\n\
    \      parameters.  However, BCP 82 addresses the need for protocol\n      numbers\
    \ when the pool of such numbers is strictly limited (e.g.,\n      DHCP options)\
    \ or when a number is absolutely required even for\n      purely experimental\
    \ purposes (e.g., the Protocol field of the IP\n      header).  In almost all\
    \ application protocols that make use of\n      protocol parameters (including\
    \ email headers, media types, HTTP\n      headers, vCard parameters and properties,\
    \ URNs, and LDAP field\n      names), the name space is not limited or constrained\
    \ in any way,\n      so there is no need to assign a block of names for private\
    \ use or\n      experimental purposes....\n      Therefore, it appears that segregating\
    \ the parameter space into a\n      standardized area and a unstandardized area\
    \ has few, if any,\n      benefits and has at least one significant cost in terms\
    \ of\n      interoperability.\n"
- title: 3.2.3.  Multi-Site Experiments
  contents:
  - "3.2.3.  Multi-Site Experiments\n   Where an experiment is undertaken among a\
    \ diverse set of experimental\n   sites connected via the global Internet, the\
    \ use of \"experimental\" or\n   \"local use\" code points is inadvisable.  This\
    \ might include, for\n   example, sites that take a prototype implementation of\
    \ some protocol\n   and use that both within their site but, importantly, among\
    \ the full\n   set of other sites interested in that protocol.  In such a situation,\n\
    \   it is impractical and probably impossible to coordinate the\n   de-confliction\
    \ of \"experimental\" code points.  Section 4.1 of the\n   IANA Considerations\
    \ guidelines document [RFC5226] notes:\n      For private or local use ... No\
    \ attempt is made to prevent\n      multiple sites from using the same value in\
    \ different (and\n      incompatible) ways....  assignments are not generally\
    \ useful for\n      broad interoperability.  It is the responsibility of the sites\n\
    \      making use of the Private Use range to ensure that no conflicts\n     \
    \ occur (within the intended scope of use).\n   The Host Identity Protocol (HIP)\
    \ [RFC5201] and the Locator/ID\n   Separation Protocol [LISP] are examples where\
    \ a set of experimental\n   sites are collaborating among themselves, but not\
    \ necessarily in a\n   tightly coordinated way.  Both HIP and LISP have dealt\
    \ with this by\n   having unique non-experimental code points allocated to HIP\
    \ and LISP,\n   respectively, at the time of publication of their respective\n\
    \   Experimental RFCs.\n"
- title: 3.3.  Architectural Compatibility
  contents:
  - "3.3.  Architectural Compatibility\n   Since protocol extension mechanisms may\
    \ impact interoperability, it\n   is important that they be architecturally compatible\
    \ with the base\n   protocol.\n   This includes understanding what current implementations\
    \ do and how a\n   proposed extension will interact with deployed systems.  Is\
    \ it clear\n   when a proposed extension (or its proposed usage), if widely\n\
    \   deployed, will operationally stress existing implementations or the\n   underlying\
    \ protocol itself? If this is not explained in the base\n   protocol specification,\
    \ is this covered in an extension design\n   guidelines document?\n   As part\
    \ of the definition of a new extension, it is important to\n   address whether\
    \ the extension makes use of features as envisaged by\n   the original protocol\
    \ designers, or whether a new extension mechanism\n   is being invented.  If a\
    \ new extension mechanism is being invented,\n   then architectural compatibility\
    \ issues need to be addressed.\n   To assist in the assessment of architectural\
    \ compatibility, protocol\n   documents should provide guidelines explaining how\
    \ extensions should\n   be performed, and guidance on how protocol extension mechanisms\n\
    \   should be used.\n   Protocol components that are designed with the specific\
    \ intention of\n   allowing extensibility should be clearly identified, with specific\n\
    \   and complete instructions on how to extend them.  This includes the\n   process\
    \ for adequate review of extension proposals: do they need\n   community review,\
    \ and if so, how much and by whom?\n   Documents relying on extension mechanisms\
    \ need to explicitly identify\n   the mechanisms being relied upon.  For example,\
    \ a document defining\n   new data elements should not implicitly define new data\
    \ types or\n   protocol operations without explicitly describing those dependencies\n\
    \   and discussing their impact.  Where extension guidelines are\n   available,\
    \ mechanisms need to indicate whether they are compliant\n   with those guidelines\
    \ and offer an explanation if they are not.\n   Examples of documents describing\
    \ extension guidelines include:\n   1.  \"Guidelines for Extending the Extensible\
    \ Provisioning Protocol\n       (EPP)\" [RFC3735], which provides guidelines for\
    \ use of EPP's\n       extension mechanisms to define new features and object\
    \ management\n       capabilities.\n   2.  \"Guidelines for Authors and Reviewers\
    \ of MIB Documents\" BCP 111\n       [RFC4181], which provides guidance to protocol\
    \ designers creating\n       new MIB modules.\n   3.  \"Guidelines for Authors\
    \ of Extensions to the Session Initiation\n       Protocol (SIP)\" [RFC4485],\
    \ which outlines guidelines for authors\n       of SIP extensions.\n   4.  \"\
    Considerations for Lightweight Directory Access Protocol (LDAP)\n       Extensions\"\
    \ BCP 118 [RFC4521], which discusses considerations for\n       designers of LDAP\
    \ extensions.\n   5.  \"RADIUS Design Guidelines\" BCP 158 [RFC6158], which provides\n\
    \       guidelines for the design of attributes used by the Remote\n       Authentication\
    \ Dial In User Service (RADIUS) protocol.\n"
- title: 3.4.  Protocol Variations
  contents:
  - "3.4.  Protocol Variations\n   Protocol variations -- specifications that look\
    \ very similar to the\n   original but don't interoperate with each other or with\
    \ the original\n   -- are even more harmful to interoperability than extensions.\
    \  In\n   general, such variations should be avoided.  Causes of protocol\n  \
    \ variations include incompatible protocol extensions, uncoordinated\n   protocol\
    \ development, and poorly designed \"profiles\".\n   Designing a protocol for\
    \ extensibility may have the perverse side\n   effect of making it easy to construct\
    \ incompatible variations.\n   Protocol extension mechanisms should not be used\
    \ to create\n   incompatible forks in development.  An extension may lead to\n\
    \   interoperability failures unless the extended protocol correctly\n   supports\
    \ all mandatory and optional features of the unextended base\n   protocol, and\
    \ implementations of the base protocol operate correctly\n   in the presence of\
    \ the extensions.  In addition, it is necessary for\n   an extension to interoperate\
    \ with other extensions.\n   As noted in Section 1 of \"Uncoordinated Protocol\
    \ Development\n   Considered Harmful\" [RFC5704], incompatible forks in development\
    \ can\n   result from the uncoordinated adaptation of a protocol, parameter, or\n\
    \   code point:\n      In particular, the IAB considers it an essential principle\
    \ of the\n      protocol development process that only one SDO maintains design\n\
    \      authority for a given protocol, with that SDO having ultimate\n      authority\
    \ over the allocation of protocol parameter code-points\n      and over defining\
    \ the intended semantics, interpretation, and\n      actions associated with those\
    \ code-points.\n   Note that problems can occur even when one Standards Development\n\
    \   Organization (SDO) maintains design authority, if protocol parameter\n   code\
    \ points are reused.  As an example, EAP-FAST [RFC5421][RFC5422]\n   reused previously\
    \ assigned Extensible Authentication Protocol (EAP)\n   type codes.  As described\
    \ in the IESG note in the EAP-FAST document\n   [RFC5421]:\n      The reuse of\
    \ previously assigned EAP Type Codes is incompatible\n      with EAP method negotiation\
    \ as defined in RFC 3748.\n"
- title: 3.4.1.  Profiles
  contents:
  - "3.4.1.  Profiles\n   Profiling is a common technique for improving interoperability\
    \ within\n   a target environment or set of scenarios.  Generally speaking, there\n\
    \   are two approaches to profiling:\n   a)  Removal or downgrading of normative\
    \ requirements (thereby\n       creating potential interoperability problems).\n\
    \   b)  Elevation of normative requirement levels (such as from a\n       MAY/SHOULD\
    \ to a MUST).  This can be done in order to improve\n       interoperability by\
    \ narrowing potential implementation choices\n       (such as when the underlying\
    \ protocol is ill-defined enough to\n       permit non-interoperable yet compliant\
    \ implementations) or to\n       meet specific operational requirements (such\
    \ as enabling use of\n       stronger cryptographic mechanisms than those mandated\
    \ in the\n       specification).\n   While approach a) is potentially harmful,\
    \ approach b) may be\n   beneficial.\n   In order to avoid interoperability problems\
    \ when profiled\n   implementations interact with others over the global Internet,\n\
    \   profilers need to remain cognizant of the implications of removing\n   normative\
    \ requirements.  As noted in Section 6 of \"Key words for use\n   in RFCs to Indicate\
    \ Requirement Levels\" [RFC2119], imperatives are to\n   be used with care, and\
    \ as a result, their removal within a profile is\n   likely to result in serious\
    \ consequences:\n      Imperatives of the type defined in this memo must be used\
    \ with\n      care and sparingly.  In particular, they MUST only be used where\n\
    \      it is actually required for interoperation or to limit behavior\n     \
    \ which has potential for causing harm (e.g., limiting\n      retransmissions)\
    \  For example, they must not be used to try to\n      impose a particular method\
    \ on implementors where the method is not\n      required for interoperability.\n\
    \   As noted in Sections 3 and 4 of the Key Words document [RFC2119],\n   recommendations\
    \ cannot be removed from profiles without serious\n   consideration:\n      [T]here\
    \ may exist valid reasons in particular circumstances to\n      ignore a particular\
    \ item, but the full implications must be\n      understood and carefully weighed\
    \ before choosing a different\n      course.\n   Even the removal of optional\
    \ features and requirements can have\n   consequences.  As noted in Section 5\
    \ of the Key Words document\n   [RFC2119], implementations that do not support\
    \ optional features\n   still retain the obligation to ensure interoperation with\n\
    \   implementations that do:\n      An implementation which does not include a\
    \ particular option MUST\n      be prepared to interoperate with another implementation\
    \ which does\n      include the option, though perhaps with reduced functionality.\
    \  In\n      the same vein an implementation which does include a particular\n\
    \      option MUST be prepared to interoperate with another\n      implementation\
    \ which does not include the option (except, of\n      course, for the feature\
    \ the option provides.)\n"
- title: 3.5.  Testability
  contents:
  - "3.5.  Testability\n   Experience has shown that it is insufficient merely to\
    \ specify\n   extensibility and backward compatibility correctly in an RFC.  It\
    \ is\n   also important that implementations respect the compatibility\n   mechanisms;\
    \ if not, non-interoperable pairs of implementations may\n   arise.  The TLS case\
    \ study (Appendix A.3) shows how important this\n   can be.\n   In order to determine\
    \ whether protocol extension mechanisms have been\n   properly implemented, testing\
    \ is required.  However, for this to be\n   possible, test cases need to be developed.\
    \  If a base protocol\n   document specifies extension mechanisms but does not\
    \ utilize them or\n   provide examples, it may not be possible to develop effective\
    \ test\n   cases based on the base protocol specification alone.  As a result,\n\
    \   base protocol implementations may not be properly tested, and non-\n   compliant\
    \ extension behavior may not be detected until these\n   implementations are widely\
    \ deployed.\n   To encourage correct implementation of extension mechanisms, base\n\
    \   protocol specifications should clearly articulate the expected\n   behavior\
    \ of extension mechanisms and should include examples of\n   correct extension\
    \ behavior.\n"
- title: 3.6.  Protocol Parameter Registration
  contents:
  - "3.6.  Protocol Parameter Registration\n   As noted in Section 3.2 of \"Procedures\
    \ for Protocol Extensions and\n   Variations\" BCP 125 [RFC4775]:\n      An extension\
    \ is often likely to make use of additional values\n      added to an existing\
    \ IANA registry....  It is essential that such\n      new values are properly\
    \ registered by the applicable procedures,\n      including expert review where\
    \ applicable....  Extensions may even\n      need to create new IANA registries\
    \ in some cases.\n      Experience shows that the importance of this is often\n\
    \      underestimated during extension design; designers sometimes assume\n  \
    \    that a new codepoint is theirs for the asking, or even simply for\n     \
    \ the taking.\n   Before creating a new protocol parameter registry, existing\n\
    \   registries should be examined to determine whether one of them can be\n  \
    \ used instead (see http://www.iana.org/protocols/).\n   To avoid conflicting\
    \ usage of the same registry value, as well as to\n   prevent potential difficulties\
    \ in determining and transferring\n   parameter ownership, it is essential that\
    \ all new values are\n   registered.  If this is not done, there is nothing to\
    \ prevent two\n   different extensions picking the same value.  When these two\n\
    \   extensions \"meet\" each other on the Internet, failure is inevitable.\n \
    \  A surprisingly common case of this is misappropriation of assigned\n   Transmission\
    \ Control Protocol (TCP) (or User Datagram Protocol (UDP))\n   registered port\
    \ numbers.  This can lead to a client for one service\n   attempting to communicate\
    \ with a server for another service.  Another\n   common case is the use of unregistered\
    \ URI schemes.  Numerous cases\n   could be cited, but not without embarrassing\
    \ specific implementers.\n   For general rules, see the IANA Considerations guidelines\
    \ document\n   [RFC5226], and for specific rules and registries, see the individual\n\
    \   protocol specification RFCs and the IANA web site.\n   While in theory a \"\
    Standards Track\" or \"IETF Consensus\" parameter\n   allocation policy may be\
    \ instituted to encourage protocol parameter\n   registration or to improve interoperability,\
    \ in practice, problems\n   can arise if the procedures result in so much delay\
    \ that requesters\n   give up and \"self-allocate\" by picking presumably unused\
    \ code points.\n   Where self-allocation is prevalent, the information contained\
    \ within\n   registries may become inaccurate, particularly when third parties\
    \ are\n   prohibited from updating entries so as to improve accuracy.  In these\n\
    \   situations, it is important to consider whether registration\n   processes\
    \ need to be changed to support the role of a registry as\n   \"documentation\
    \ of how the Internet is operating\".\n"
- title: 3.7.  Extensions to Critical Protocols
  contents:
  - "3.7.  Extensions to Critical Protocols\n   Some protocols (such as the Domain\
    \ Name System (DNS), the Border\n   Gateway Protocol (BGP), and the Hypertext\
    \ Transfer Protocol (HTTP))\n   or algorithms (such as congestion control) have\
    \ become critical\n   components of the Internet infrastructure.  A critical component\
    \ is\n   one whose failure can lead to Internet-wide reliability and security\n\
    \   issues or performance degradation.  When such protocols or algorithms\n  \
    \ are extended, the potential exists for negatively impacting the\n   reliability\
    \ and security of the global Internet.\n   As a result, special care needs to\
    \ be taken with these extensions,\n   such as taking explicit steps to isolate\
    \ existing uses from new ones.\n   For example, this can be accomplished by requiring\
    \ the extension to\n   utilize a different port or multicast address or by implementing\
    \ the\n   extension within a separate process, without access to the data and\n\
    \   control structures of the base protocol.\n   Experience has shown that even\
    \ when a mechanism has proven benign in\n   other uses, unforeseen issues may\
    \ result when adding it to a critical\n   protocol.  For example, both IS-IS and\
    \ OSPF support opaque Link State\n   Advertisements (LSAs), which are propagated\
    \ by intermediate nodes\n   that don't understand the LSA.  Within Interior Gateway\
    \ Protocols\n   (IGPs), support for opaque LSAs has proven useful without introducing\n\
    \   instability.\n   However, within BGP, \"attribute tunneling\" has resulted\
    \ in large-\n   scale routing instabilities, since remote nodes may reset the\
    \ LOCAL\n   session if the tunneled attributes are malformed or aren't\n   understood.\
    \  This has required modification to BGP error handling, as\n   noted in \"Revised\
    \ Error Handling for BGP UPDATE Messages\"\n   [ERROR-HANDLING].\n   In general,\
    \ when extending protocols with local failure conditions,\n   tunneling of attributes\
    \ that may trigger failures in non-adjacent\n   nodes should be avoided.  This\
    \ is particularly problematic when the\n   originating node receives no indicators\
    \ of remote failures it may\n   have triggered.\n"
- title: 4.  Considerations for the Base Protocol
  contents:
  - "4.  Considerations for the Base Protocol\n   Good extension design depends on\
    \ a well-designed base protocol.  To\n   promote interoperability, designers should:\n\
    \   1.  Ensure a well-written base protocol specification.  Does the base\n  \
    \     protocol specification make clear what an implementer needs to\n       support,\
    \ and does it define the impact that individual operations\n       (e.g., a message\
    \ sent to a peer) will have when invoked?\n   2.  Design for backward compatibility.\
    \  Does the base protocol\n       specification describe how to determine the\
    \ capabilities of a\n       peer and negotiate the use of extensions?  Does it\
    \ indicate how\n       implementations handle extensions that they do not understand?\n\
    \       Is it possible for an extended implementation to negotiate with\n    \
    \   an unextended (or differently-extended) peer to find a common\n       subset\
    \ of useful functions?\n   3.  Respect underlying architectural or security assumptions.\
    \  Is\n       there a document describing the underlying architectural\n     \
    \  assumptions, as well as considerations that have arisen in\n       operational\
    \ experience?  Or are there undocumented considerations\n       that have arisen\
    \ as the result of operational experience, after\n       the original protocol\
    \ was published?\n       For example, will backward-compatibility issues arise\
    \ if\n       extensions reverse the flow of data, allow formerly static\n    \
    \   parameters to be changed on the fly, or change assumptions\n       relating\
    \ to the frequency of reads/writes?\n   4.  Minimize impact on critical infrastructure.\
    \  For a protocol that\n       represents a critical element of Internet infrastructure,\
    \ it is\n       important to explain when it is appropriate to isolate new uses\n\
    \       of the protocol from existing ones.\n       For example, is it explained\
    \ when a proposed extension (or usage)\n       has the potential for negatively\
    \ impacting critical\n       infrastructure to the point where explicit steps\
    \ would be\n       appropriate to isolate existing uses from new ones?\n   5.\
    \  Provide guidance on data model extensions.  Is there a document\n       that\
    \ explains when a protocol extension is routine and when it\n       represents\
    \ a major change?\n       For example, is it clear when a data model extension\
    \ represents a\n       major versus a routine change?  Are there guidelines describing\n\
    \       when an extension (such as a new data type) is likely to require\n   \
    \    a code change within existing implementations?\n"
- title: 4.1.  Version Numbers
  contents:
  - "4.1.  Version Numbers\n   Any mechanism for extension by versioning must include\
    \ provisions to\n   ensure interoperability, or at least clean failure modes.\
    \  Imagine\n   someone creating a protocol and using a \"version\" field and\n\
    \   populating it with a value (1, let's say), but giving no information\n   about\
    \ what would happen when a new version number appears in it.\n   This would be\
    \ a bad protocol design and description; it should be\n   clear what the expectation\
    \ is and how it can be tested.  For example,\n   stating that 1.X must be compatible\
    \ with any version 1 code, but\n   version 2 or greater is not expected to be\
    \ compatible, has different\n   implications than stating that version 1 must\
    \ be a proper subset of\n   version 2.\n   An example of an under-specified versioning\
    \ mechanism is provided by\n   the MIME-Version header, originally defined in\
    \ \"MIME (Multipurpose\n   Internet Mail Extensions)\" [RFC1341].  As noted in\
    \ Section 1 of the\n   MIME specification [RFC1341]:\n      A MIME-Version header\
    \ field ... uses a version number to declare a\n      message to be conformant\
    \ with this specification and allows mail\n      processing agents to distinguish\
    \ between such messages and those\n      generated by older or non-conformant\
    \ software, which is presumed\n      to lack such a field.\n   Beyond this, the\
    \ 1992 MIME specification [RFC1341] provided little\n   guidance on versioning\
    \ behavior, or even the format of the MIME-\n   Version header, which was specified\
    \ to contain \"text\".  The 1993\n   update [RFC1521] better defined the format\
    \ of the version field but\n   still did not clarify the versioning behavior:\n\
    \      Thus, future format specifiers, which might replace or extend\n      \"\
    1.0\", are constrained to be two integer fields, separated by a\n      period.\
    \  If a message is received with a MIME-version value other\n      than \"1.0\"\
    , it cannot be assumed to conform with this\n      specification....\n      It\
    \ is not possible to fully specify how a mail reader that\n      conforms with\
    \ MIME as defined in this document should treat a\n      message that might arrive\
    \ in the future with some value of MIME-\n      Version other than \"1.0\".  However,\
    \ conformant software is\n      encouraged to check the version number and at\
    \ least warn the user\n      if an unrecognized MIME-version is encountered.\n\
    \   Thus, even though the 1993 update [RFC1521] defined a MIME-Version\n   header\
    \ with a syntax suggestive of a \"Major/Minor\" versioning scheme,\n   in practice\
    \ the MIME-Version header was little more than a\n   decoration.\n   An example\
    \ of a protocol with a better versioning scheme is ROHC\n   (Robust Header Compression).\
    \  ROHCv1 [RFC3095] supports a certain set\n   of profiles for compression algorithms.\
    \  But experience had shown\n   that these profiles had limitations, so the ROHC\
    \ WG developed ROHCv2\n   [RFC5225].  A ROHCv1 implementation does not contain\
    \ code for the\n   ROHCv2 profiles.  As the ROHC WG charter said during the development\n\
    \   of ROHCv2:\n      It should be noted that the v2 profiles will thus not be\n\
    \      compatible with the original (ROHCv1) profiles, which means less\n    \
    \  complex ROHC implementations can be realized by not providing\n      support\
    \ for ROHCv1 (over links not yet supporting ROHC, or by\n      shifting out support\
    \ for ROHCv1 in the long run).  Profile support\n      is agreed through the ROHC\
    \ channel negotiation, which is part of\n      the ROHC framework and thus not\
    \ changed by ROHCv2.\n   Thus, in this case, both backward-compatible and backward-\n\
    \   incompatible deployments are possible.  The important point is to\n   have\
    \ a clearly thought out approach to the question of operational\n   compatibility.\n\
    \   In the past, protocols have utilized a variety of strategies for\n   versioning,\
    \ each with its own benefits and drawbacks in terms of\n   capability and complexity\
    \ of implementation:\n   1.  No versioning support.  This approach is exemplified\
    \ by the\n       Extensible Authentication Protocol (EAP) [RFC3748] as well as\
    \ the\n       Remote Authentication Dial In User Service (RADIUS) protocol\n \
    \      [RFC2865], both of which provide no support for versioning.\n       While\
    \ lack of versioning support protects against the\n       proliferation of incompatible\
    \ dialects, the need for\n       extensibility is likely to assert itself in other\
    \ ways, so that\n       ignoring versioning entirely may not be the most forward\
    \ thinking\n       approach.\n   2.  Highest mutually supported version (HMSV).\
    \  In this approach,\n       implementations exchange the version numbers of the\
    \ highest\n       version each supports, with the negotiation agreeing on the\n\
    \       highest mutually supported protocol version.  This approach\n       implicitly\
    \ assumes that later versions provide improved\n       functionality and that\
    \ advertisement of a particular version\n       number implies support for all\
    \ lower version numbers.  Where\n       these assumptions are invalid, this approach\
    \ breaks down,\n       potentially resulting in interoperability problems.  An\
    \ example\n       of this issue occurs in the Protected Extensible Authentication\n\
    \       Protocol [PEAP] where implementations of higher versions may not\n   \
    \    necessarily provide support for lower versions.\n   3.  Assumed backward\
    \ compatibility.  In this approach,\n       implementations may send packets with\
    \ higher version numbers to\n       legacy implementations supporting lower versions,\
    \ but with the\n       assumption that the legacy implementations will interpret\
    \ packets\n       with higher version numbers using the semantics and syntax\n\
    \       defined for lower versions.  This is the approach taken by \"Port-\n \
    \      Based Network Access Control\" [IEEE-802.1X].  For this approach\n    \
    \   to work, legacy implementations need to be able to accept packets\n      \
    \ of known types with higher protocol versions without discarding\n       them;\
    \ protocol enhancements need to permit silent discard of\n       unsupported extensions;\
    \ and implementations supporting higher\n       versions need to refrain from\
    \ mandating new features when\n       encountering legacy implementations.\n \
    \  4.  Major/minor versioning.  In this approach, implementations with\n     \
    \  the same major version but a different minor version are assumed\n       to\
    \ be backward compatible, but implementations are required to\n       negotiate\
    \ a mutually supported major version number.  This\n       approach assumes that\
    \ implementations with a lower minor version\n       number but the same major\
    \ version can safely ignore unsupported\n       protocol messages.\n   5.  Min/max\
    \ versioning.  This approach is similar to HMSV, but\n       without the implied\
    \ obligation for clients and servers to support\n       all versions back to version\
    \ 1, in perpetuity.  It allows clients\n       and servers to cleanly drop support\
    \ for early versions when those\n       versions become so old that they are no\
    \ longer relevant and no\n       longer required.  In this approach, the client\
    \ initiating the\n       connection reports the highest and lowest protocol versions\
    \ it\n       understands.  The server reports back the chosen protocol\n     \
    \  version:\n       a.  If the server understands one or more versions in the\n\
    \           client's range, it reports back the highest mutually\n           understood\
    \ version.\n       b.  If there is no mutual version, then the server reports\
    \ back\n           some version that it does understand (selected as described\n\
    \           below).  The connection is then typically dropped by client\n    \
    \       or server, but reporting this version number first helps\n           facilitate\
    \ useful error messages at the client end:\n           *  If there is no mutual\
    \ version, and the server speaks any\n              version higher than client\
    \ max, it reports the lowest\n              version it speaks that is greater\
    \ than the client max.\n              The client can then report to the user,\
    \ \"You need to\n              upgrade to at least version <xx>\".\n         \
    \  *  Else, the server reports the highest version it speaks.\n              The\
    \ client can then report to the user, \"You need to\n              request the\
    \ server operator to upgrade to at least version\n              <min>\".\n   Protocols\
    \ generally do not need any version-negotiation mechanism\n   more complicated\
    \ than the mechanisms described here.  The nature of\n   protocol version-negotiation\
    \ mechanisms is that, by definition, they\n   don't get widespread real-world\
    \ testing until *after* the base\n   protocol has been deployed for a while, and\
    \ its deficiencies have\n   become evident.  This means that, to be useful, a\
    \ protocol version-\n   negotiation mechanism should be simple enough that it\
    \ can reasonably\n   be assumed that all the implementers of the first protocol\
    \ version at\n   least managed to implement the version-negotiation mechanism\n\
    \   correctly.\n"
- title: 4.2.  Reserved Fields
  contents:
  - "4.2.  Reserved Fields\n   Protocols commonly include one or more \"reserved\"\
    \ fields, clearly\n   intended for future extensions.  It is good practice to\
    \ specify the\n   value to be inserted in such a field by the sender (typically\
    \ zero)\n   and the action to be taken by the receiver when seeing some other\n\
    \   value (typically no action).  In packet format diagrams, such fields\n   are\
    \ typically labeled \"MBZ\", to be read as, \"Must Be Zero on\n   transmission,\
    \ Must Be Ignored on reception\".\n   A common mistake of inexperienced protocol\
    \ implementers is to think\n   that \"MBZ\" means that it's their software's job\
    \ to verify that the\n   value of the field is zero on reception and reject the\
    \ packet if not.\n   This is a mistake, and such software will fail when it encounters\n\
    \   future versions of the protocol where these previously reserved\n   fields\
    \ are given new defined meanings.  Similarly, protocols should\n   carefully specify\
    \ how receivers should react to unknown extensions\n   (headers, TLVs, etc.),\
    \ such that failures occur only when that is\n   truly the intended outcome.\n"
- title: 4.3.  Encoding Formats
  contents:
  - "4.3.  Encoding Formats\n   Using widely supported encoding formats leads to better\n\
    \   interoperability and easier extensibility.\n   As described in \"IAB Thoughts\
    \ on Encodings for Internationalized\n   Domain Names\" [RFC6055], the number\
    \ of encodings should be minimized,\n   and complex encodings are generally a\
    \ bad idea.  As soon as one moves\n   outside the ASCII repertoire, issues arise\
    \ relating to collation,\n   valid code points, encoding, normalization, and comparison,\
    \ which\n   extensions must handle with care\n   [ID-COMPARISON][PRECIS-STATEMENT][PRECIS-FRAMEWORK].\n\
    \   An example is the Simple Network Management Protocol (SNMP) Structure\n  \
    \ of Managed Information (SMI).  Guidelines exist for defining the\n   Management\
    \ Information Base (MIB) objects that SNMP carries\n   [RFC4181].  Also, multiple\
    \ textual conventions have been published,\n   so that MIB designers do not have\
    \ to \"reinvent the wheel\" when they\n   need a commonly encountered construct.\
    \  For example, \"Textual\n   Conventions for Internet Network Addresses\" [RFC4001]\
    \ can be used by\n   any MIB designer needing to define objects containing IP\
    \ addresses,\n   thus ensuring consistency as the body of MIBs is extended.\n"
- title: 4.4.  Parameter Space Design
  contents:
  - "4.4.  Parameter Space Design\n   In some protocols, the parameter space either\
    \ has no specified limit\n   (e.g., Header field names) or is sufficiently large\
    \ that it is\n   unlikely to be exhausted.  In other protocols, the parameter\
    \ space is\n   limited and, in some cases, has proven inadequate to accommodate\n\
    \   demand.  Common mistakes include:\n   a.  A version field that is too small\
    \ (e.g., two bits or less).  When\n       designing a version field, existing\
    \ as well as potential versions\n       of a protocol need to be taken into account.\
    \  For example, if a\n       protocol is being standardized for which there are\
    \ existing\n       implementations with known interoperability issues, more than\
    \ one\n       version for \"pre-standard\" implementations may be required.  If\n\
    \       two \"pre-standard\" versions are required in addition to a version\n\
    \       for an IETF Standard, then a two-bit version field would only\n      \
    \ leave one additional version code point for a future update,\n       which could\
    \ be insufficient.  This problem was encountered during\n       the development\
    \ of the PEAPv2 protocol [PEAP].\n   b.  A small parameter space (e.g., 8 bits\
    \ or less) along with a First\n       Come, First Served (FCFS) allocation policy\
    \ [RFC5226].  In\n       general, an FCFS allocation policy is only appropriate\
    \ in\n       situations where parameter exhaustion is highly unlikely.  In\n \
    \      situations where substantial demand is anticipated within a\n       parameter\
    \ space, the space should either be designed to be\n       sufficient to handle\
    \ that demand, or vendor extensibility should\n       be provided to enable vendors\
    \ to self-allocate.  The combination\n       of a small parameter space, an FCFS\
    \ allocation policy, and no\n       support for vendor extensibility is particularly\
    \ likely to prove\n       ill-advised.  An example of such a combination was the\
    \ design of\n       the original 8-bit EAP Type space [RFC2284].\n   Once the\
    \ potential for parameter exhaustion becomes apparent, it is\n   important that\
    \ it be addressed as quickly as possible.  Protocol\n   changes can take years\
    \ to appear in implementations and by then the\n   exhaustion problem could become\
    \ acute.\n   Options for addressing a protocol parameter exhaustion problem\n\
    \   include:\n   Rethinking the allocation regime\n      Where it becomes apparent\
    \ that the size of a parameter space is\n      insufficient to meet demand, it\
    \ may be necessary to rethink the\n      allocation mechanism, in order to prevent\
    \ or delay parameter space\n      exhaustion.  In revising parameter allocation\
    \ mechanisms, it is\n      important to consider both supply and demand aspects\
    \ so as to\n      avoid unintended consequences such as self-allocation or the\n\
    \      development of black markets for the resale of protocol\n      parameters.\n\
    \      For example, a few years after publication of PPP EAP [RFC2284] in\n  \
    \    1998, it became clear that the combination of an FCFS allocation\n      policy\
    \ [RFC5226] and lack of support for vendor-extensions had\n      created the potential\
    \ for exhaustion of the EAP Method Type space\n      within a few years.  To address\
    \ the issue, Section 6.2 of the 2004\n      update [RFC3748] changed the allocation\
    \ policy for EAP Method\n      Types from FCFS to Expert Review, with Specification\
    \ Required.\n      Since this allocation policy revision did not change the demand\n\
    \      for EAP Method Types, it would have been likely to result in self-\n  \
    \    allocation within the standards space had mechanisms not been\n      provided\
    \ to expand the Method Type space (including support for\n      vendor-specific\
    \ method types).\n   Support for vendor-specific parameters\n      If the demand\
    \ that cannot be accommodated is being generated by\n      vendors, merely making\
    \ allocation harder could make things worse\n      if this encourages vendors\
    \ to self-allocate, creating\n      interoperability problems.  In such a situation,\
    \ support for\n      vendor-specific parameters should be considered, allowing\
    \ each\n      vendor to self-allocate within their own vendor-specific space\n\
    \      based on a vendor's Private Enterprise Code (PEC).  For example,\n    \
    \  in the case of the EAP Method Type space, Section 6.2 of the 2004\n      EAP\
    \ specification [RFC3748] also provided for an Expanded Type\n      space for\
    \ \"functions specific only to one vendor's\n      implementation\".\n   Extensions\
    \ to the parameter space\n      If the goal is to stave off exhaustion in the\
    \ face of high demand,\n      a larger parameter space may be helpful; this may\
    \ require a new\n      version of the protocol (such as was required for IPv6).\
    \  Where\n      vendor-specific parameter support is available, this may be\n\
    \      achieved by allocating a PEC for IETF use.  Otherwise, it may be\n    \
    \  necessary to try to extend the size of the parameter fields, which\n      could\
    \ require a new protocol version or other substantial protocol\n      changes.\n\
    \   Parameter reclamation\n      In order to gain time, it may be necessary to\
    \ reclaim unused\n      parameters.  However, it may not be easy to determine\
    \ whether a\n      parameter that has been allocated is in use or not, particularly\n\
    \      if the entity that obtained the allocation no longer exists or has\n  \
    \    been acquired (possibly multiple times).\n   Parameter transfer\n      When\
    \ all the above mechanisms have proved infeasible and parameter\n      exhaustion\
    \ looms in the near future, enabling the transfer of\n      ownership of protocol\
    \ parameters can be considered as a means for\n      improving allocation efficiency.\
    \  However, enabling transfer of\n      parameter ownership can be far from simple\
    \ if the parameter\n      allocation process was not originally designed to enable\
    \ title\n      searches and ownership transfers.\n      A parameter allocation\
    \ process designed to uniquely allocate code\n      points is fundamentally different\
    \ from one designed to enable\n      title search and transfer.  If the only goal\
    \ is to ensure that a\n      parameter is not allocated more than once, the parameter\
    \ registry\n      will only need to record the initial allocation.  On the other\n\
    \      hand, if the goal is to enable transfer of ownership of a protocol\n  \
    \    parameter, then it is important not only to record the initial\n      allocation,\
    \ but also to track subsequent ownership changes, so as\n      to make it possible\
    \ to determine and transfer the title.  Given\n      the difficulty of converting\
    \ from a unique allocation regime to\n      one requiring support for title search\
    \ and ownership transfer, it\n      is best for the desired capabilities to be\
    \ carefully thought\n      through at the time of registry establishment.\n"
- title: 4.5.  Cryptographic Agility
  contents:
  - "4.5.  Cryptographic Agility\n   Extensibility with respect to cryptographic algorithms\
    \ is desirable\n   in order to provide resilience against the compromise of any\n\
    \   particular algorithm.  Section 3 of \"Guidance for Authentication,\n   Authorization,\
    \ and Accounting (AAA) Key Management\" BCP 132 [RFC4962]\n   provides some basic\
    \ advice:\n      The ability to negotiate the use of a particular cryptographic\n\
    \      algorithm provides resilience against compromise of a particular\n    \
    \  cryptographic algorithm....  This is usually accomplished by\n      including\
    \ an algorithm identifier and parameters in the protocol,\n      and by specifying\
    \ the algorithm requirements in the protocol\n      specification.  While highly\
    \ desirable, the ability to negotiate\n      key derivation functions (KDFs) is\
    \ not required.  For\n      interoperability, at least one suite of mandatory-to-implement\n\
    \      algorithms MUST be selected....\n      This requirement does not mean that\
    \ a protocol must support both\n      public-key and symmetric-key cryptographic\
    \ algorithms.  It means\n      that the protocol needs to be structured in such\
    \ a way that\n      multiple public-key algorithms can be used whenever a public-key\n\
    \      algorithm is employed.  Likewise, it means that the protocol needs\n  \
    \    to be structured in such a way that multiple symmetric-key\n      algorithms\
    \ can be used whenever a symmetric-key algorithm is\n      employed.\n   In practice,\
    \ the most difficult challenge in providing cryptographic\n   agility is providing\
    \ for a smooth transition in the event that a\n   mandatory-to-implement algorithm\
    \ is compromised.  Since it may take\n   significant time to provide for widespread\
    \ implementation of a\n   previously undeployed alternative, it is often advisable\
    \ to recommend\n   implementation of alternative algorithms of distinct lineage\
    \ in\n   addition to those made mandatory-to-implement, so that an alternative\n\
    \   algorithm is readily available.  If such a recommended alternative is\n  \
    \ not in place, then it would be wise to issue such a recommendation as\n   soon\
    \ as indications of a potential weakness surface.  This is\n   particularly important\
    \ in the case of potential weakness in\n   algorithms used to authenticate and\
    \ integrity-protect the\n   cryptographic negotiation itself, such as KDFs or\
    \ message integrity\n   checks (MICs).  Without secure alternatives to compromised\
    \ KDF or MIC\n   algorithms, it may not be possible to secure the cryptographic\n\
    \   negotiation while retaining backward compatibility.\n"
- title: 4.6.  Transport
  contents:
  - "4.6.  Transport\n   In the past, IETF protocols have been specified to operate\
    \ over\n   multiple transports.  Often the protocol was originally specified to\n\
    \   utilize a single transport, but limitations were discovered in\n   subsequent\
    \ deployment, so that additional transports were\n   subsequently specified.\n\
    \   In a number of cases, the protocol was originally specified to\n   operate\
    \ over UDP, but subsequent operation disclosed one or more of\n   the following\
    \ issues, leading to the specification of alternative\n   transports:\n   a. \
    \ Payload fragmentation (often due to the introduction of\n       extensions or\
    \ additional usage scenarios);\n   b.  Problems with congestion control, transport\
    \ reliability, or\n       efficiency; and\n   c.  Lack of deployment in multicast\
    \ scenarios, which had been a\n       motivator for UDP transport.\n   On the\
    \ other hand, there are also protocols that were originally\n   specified to operate\
    \ over reliable transport that have subsequently\n   defined transport over UDP,\
    \ due to one or more of the following\n   issues:\n   a.  NAT traversal concerns\
    \ that were more easily addressed with UDP\n       transport;\n   b.  Scalability\
    \ problems, which could be improved by UDP transport.\n   Since specification\
    \ of a single transport offers the highest\n   potential for interoperability,\
    \ protocol designers should carefully\n   consider not only initial but potential\
    \ future requirements in the\n   selection of a transport protocol.  Where UDP\
    \ transport is selected,\n   the guidance provided in \"Unicast UDP Usage Guidelines\
    \ for\n   Application Designers\" [RFC5405] should be taken into account.\n  \
    \ After significant deployment has occurred, there are few satisfactory\n   options\
    \ for addressing problems with the originally selected\n   transport protocol.\
    \  While specification of additional transport\n   protocols is possible, removal\
    \ of a widely used transport protocol is\n   likely to result in interoperability\
    \ problems and should be avoided.\n   Mandating support for the initially selected\
    \ transport protocol while\n   designating additional transport protocols as optional\
    \ may have\n   limitations.  Since optional transport protocols are typically\n\
    \   introduced due to the advantages they afford in certain scenarios, in\n  \
    \ those situations, implementations not supporting optional transport\n   protocols\
    \ may exhibit degraded performance or may even fail.\n   While mandating support\
    \ for multiple transport protocols may appear\n   attractive, designers need to\
    \ realistically evaluate the likelihood\n   that implementers will conform to\
    \ the requirements.  For example,\n   where resources are limited (such as in\
    \ embedded systems),\n   implementers may choose to only support a subset of the\
    \ mandated\n   transport protocols, resulting in non-interoperable protocol\n\
    \   variants.\n"
- title: 4.7.  Handling of Unknown Extensions
  contents:
  - "4.7.  Handling of Unknown Extensions\n   IETF protocols have utilized several\
    \ techniques for the handling of\n   unknown extensions.  One technique (often\
    \ used for vendor-specific\n   extensions) is to specify that unknown extensions\
    \ be \"silently\n   discarded\".\n   While this approach can deliver a high level\
    \ of interoperability,\n   there are situations in which it is problematic.  For\
    \ example, where\n   security functionality is involved, \"silent discard\" may\
    \ not be\n   satisfactory, particularly if the recipient does not provide feedback\n\
    \   as to whether or not it supports the extension.  This can lead to\n   operational\
    \ security issues that are difficult to detect and correct,\n   as noted in Appendix\
    \ A.2 and in Section 2.5 of \"Common Remote\n   Authentication Dial In User Service\
    \ (RADIUS) Implementation Issues\n   and Suggested Fixes\" [RFC5080].\n   In order\
    \ to ensure that a recipient supports an extension, a\n   recipient encountering\
    \ an unknown extension may be required to\n   explicitly reject it and to return\
    \ an error, rather than ignoring the\n   unknown extension and proceeding with\
    \ the remainder of the message.\n   This can be accomplished via a \"Mandatory\"\
    \ bit in a TLV-based\n   protocol such as the Layer 2 Tunneling Protocol (L2TP)\
    \ [RFC2661], or\n   a \"Require\" or \"Proxy-Require\" header in a text-based\
    \ protocol such\n   as SIP [RFC3261] or HTTP [RFC2616].\n   Since a mandatory\
    \ extension can result in an interoperability failure\n   when communicating with\
    \ a party that does not support the extension,\n   this designation may not be\
    \ permitted for vendor-specific extensions\n   and may only be allowed for Standards\
    \ Track extensions.  To enable\n   fallback operation with degraded functionality,\
    \ it is good practice\n   for the recipient to indicate the reason for the failure,\
    \ including a\n   list of unsupported extensions.  The initiator can then retry\
    \ without\n   the offending extensions.\n   Typically, only the recipient will\
    \ find itself in the position of\n   rejecting a mandatory extension, since the\
    \ initiator can explicitly\n   indicate which extensions are supported, with the\
    \ recipient choosing\n   from among the supported extensions.  This can be accomplished\
    \ via an\n   exchange of TLVs, such as in the Internet Key Exchange Protocol\n\
    \   Version 2 (IKEv2) [RFC5996] or Diameter [RFC3588], or via use of\n   \"Accept\"\
    , \"Accept-Encoding\", \"Accept-Language\", \"Allow\", and\n   \"Supported\" headers\
    \ in a text-based protocol such as SIP [RFC3261] or\n   HTTP [RFC2616].\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   An extension must not introduce new security\
    \ risks without also\n   providing adequate countermeasures; in particular, it\
    \ must not\n   inadvertently defeat security measures in the unextended protocol.\n\
    \   Thus, the security analysis for an extension needs to be as thorough\n   as\
    \ for the original protocol -- effectively, it needs to be a\n   regression analysis\
    \ to check that the extension doesn't inadvertently\n   invalidate the original\
    \ security model.\n   This analysis may be simple (e.g., adding an extra opaque\
    \ data\n   element is unlikely to create a new risk) or quite complex (e.g.,\n\
    \   adding a handshake to a previously stateless protocol may create a\n   completely\
    \ new opportunity for an attacker).\n   When the extensibility of a design includes\
    \ allowing for new and\n   presumably more powerful cryptographic algorithms to\
    \ be added,\n   particular care is needed to ensure that the result is, in fact,\n\
    \   increased security.  For example, it may be undesirable from a\n   security\
    \ viewpoint to allow negotiation down to an older, less secure\n   algorithm.\n"
- title: 6.  References
  contents:
  - '6.  References

    '
- title: 6.1.  Normative References
  contents:
  - "6.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [RFC4775]  Bradner, S., Carpenter, B., Ed., and T. Narten,\n     \
    \         \"Procedures for Protocol Extensions and Variations\", BCP\n       \
    \       125, RFC 4775, December 2006.\n   [RFC5226]  Narten, T. and H. Alvestrand,\
    \ \"Guidelines for Writing an\n              IANA Considerations Section in RFCs\"\
    , BCP 26, RFC 5226,\n              May 2008.\n"
- title: 6.2.  Informative References
  contents:
  - "6.2.  Informative References\n   [ERROR-HANDLING]\n              Scudder, J.,\
    \ Chen, E., Mohapatra, P., and K. Patel,\n              \"Revised Error Handling\
    \ for BGP UPDATE Messages\", Work in\n              Progress, June 2012.\n   [ID-COMPARISON]\n\
    \              Thaler, D., \"Issues in Identifier Comparison for Security\n  \
    \            Purposes\", Work in Progress, August 2012.\n   [IEEE-802.1X]\n  \
    \            Institute of Electrical and Electronics Engineers, \"Local\n    \
    \          and Metropolitan Area Networks: Port-Based Network Access\n       \
    \       Control\", IEEE Standard 802.1X-2004, December 2004.\n   [LISP]     Farinacci,\
    \ D., Fuller, V., Meyer, D., and D. Lewis,\n              \"Locator/ID Separation\
    \ Protocol (LISP)\", Work in Progress,\n              May 2012.\n   [PEAP]   \
    \  Palekar, A., Simon, D., Salowey, J., Zhou, H., Zorn, G.,\n              and\
    \ S. Josefsson, \"Protected EAP Protocol (PEAP) Version\n              2\", Work\
    \ in Progress, October 2004.\n   [PRECIS-FRAMEWORK]\n              Saint-Andre,\
    \ P. and M. Blanchet, \"PRECIS Framework:\n              Preparation and Comparison\
    \ of Internationalized Strings in\n              Application Protocols\", Work\
    \ in Progress, August 2012.\n   [PRECIS-STATEMENT]\n              Blanchet, M.\
    \ and A. Sullivan, \"Stringprep Revision and\n              PRECIS Problem Statement\"\
    , Work in Progress, August 2012.\n   [RFC822]   Crocker, D., \"STANDARD FOR THE\
    \ FORMAT OF ARPA INTERNET\n              TEXT MESSAGES\", STD 11, RFC 822, August\
    \ 1982.\n   [RFC1263]  O'Malley, S. and L. Peterson, \"TCP Extensions Considered\n\
    \              Harmful\", RFC 1263, October 1991.\n   [RFC1341]  Borenstein, N.\
    \ and N. Freed, \"MIME (Multipurpose Internet\n              Mail Extensions):\
    \ Mechanisms for Specifying and Describing\n              the Format of Internet\
    \ Message Bodies\", RFC 1341, June\n              1992.\n   [RFC1521]  Borenstein,\
    \ N. and N. Freed, \"MIME (Multipurpose Internet\n              Mail Extensions)\
    \ Part One: Mechanisms for Specifying and\n              Describing the Format\
    \ of Internet Message Bodies\", RFC\n              1521, September 1993.\n   [RFC2058]\
    \  Rigney, C., Rubens, A., Simpson, W., and S. Willens,\n              \"Remote\
    \ Authentication Dial In User Service (RADIUS)\", RFC\n              2058, January\
    \ 1997.\n   [RFC2132]  Alexander, S. and R. Droms, \"DHCP Options and BOOTP Vendor\n\
    \              Extensions\", RFC 2132, March 1997.\n   [RFC2246]  Dierks, T. and\
    \ C. Allen, \"The TLS Protocol Version 1.0\",\n              RFC 2246, January\
    \ 1999.\n   [RFC2284]  Blunk, L. and J. Vollbrecht, \"PPP Extensible\n       \
    \       Authentication Protocol (EAP)\", RFC 2284, March 1998.\n   [RFC2474] \
    \ Nichols, K., Blake, S., Baker, F., and D. Black,\n              \"Definition\
    \ of the Differentiated Services Field (DS\n              Field) in the IPv4 and\
    \ IPv6 Headers\", RFC 2474, December\n              1998.\n   [RFC2616]  Fielding,\
    \ R., Gettys, J., Mogul, J., Frystyk, H.,\n              Masinter, L., Leach,\
    \ P., and T. Berners-Lee, \"Hypertext\n              Transfer Protocol -- HTTP/1.1\"\
    , RFC 2616, June 1999.\n   [RFC2661]  Townsley, W., Valencia, A., Rubens, A.,\
    \ Pall, G., Zorn,\n              G., and B. Palter, \"Layer Two Tunneling Protocol\
    \ \"L2TP\"\",\n              RFC 2661, August 1999.\n   [RFC2671]  Vixie, P.,\
    \ \"Extension Mechanisms for DNS (EDNS0)\", RFC\n              2671, August 1999.\n\
    \   [RFC2822]  Resnick, P., Ed., \"Internet Message Format\", RFC 2822,\n    \
    \          April 2001.\n   [RFC2865]  Rigney, C., Willens, S., Rubens, A., and\
    \ W. Simpson,\n              \"Remote Authentication Dial In User Service (RADIUS)\"\
    , RFC\n              2865, June 2000.\n   [RFC2882]  Mitton, D., \"Network Access\
    \ Servers Requirements: Extended\n              RADIUS Practices\", RFC 2882,\
    \ July 2000.\n   [RFC3095]  Bormann, C., Burmeister, C., Degermark, M., Fukushima,\
    \ H.,\n              Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le,\n\
    \              K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K.,\n     \
    \         Wiebke, T., Yoshimura, T., and H. Zheng, \"RObust Header\n         \
    \     Compression (ROHC): Framework and four profiles: RTP, UDP,\n           \
    \   ESP, and uncompressed\", RFC 3095, July 2001.\n   [RFC3261]  Rosenberg, J.,\
    \ Schulzrinne, H., Camarillo, G., Johnston,\n              A., Peterson, J., Sparks,\
    \ R., Handley, M., and E.\n              Schooler, \"SIP: Session Initiation Protocol\"\
    , RFC 3261,\n              June 2002.\n   [RFC3427]  Mankin, A., Bradner, S.,\
    \ Mahy, R., Willis, D., Ott, J.,\n              and B. Rosen, \"Change Process\
    \ for the Session Initiation\n              Protocol (SIP)\", RFC 3427, December\
    \ 2002.\n   [RFC3575]  Aboba, B., \"IANA Considerations for RADIUS (Remote\n \
    \             Authentication Dial In User Service)\", RFC 3575, July\n       \
    \       2003.\n   [RFC3588]  Calhoun, P., Loughney, J., Guttman, E., Zorn, G.,\
    \ and J.\n              Arkko, \"Diameter Base Protocol\", RFC 3588, September\
    \ 2003.\n   [RFC3597]  Gustafsson, A., \"Handling of Unknown DNS Resource Record\n\
    \              (RR) Types\", RFC 3597, September 2003.\n   [RFC3692]  Narten,\
    \ T., \"Assigning Experimental and Testing Numbers\n              Considered Useful\"\
    , BCP 82, RFC 3692, January 2004.\n   [RFC3735]  Hollenbeck, S., \"Guidelines\
    \ for Extending the Extensible\n              Provisioning Protocol (EPP)\", RFC\
    \ 3735, March 2004.\n   [RFC3748]  Aboba, B., Blunk, L., Vollbrecht, J., Carlson,\
    \ J., and H.\n              Levkowetz, Ed., \"Extensible Authentication Protocol\n\
    \              (EAP)\", RFC 3748, June 2004.\n   [RFC3935]  Alvestrand, H., \"\
    A Mission Statement for the IETF\", BCP\n              95, RFC 3935, October 2004.\n\
    \   [RFC4001]  Daniele, M., Haberman, B., Routhier, S., and J.\n             \
    \ Schoenwaelder, \"Textual Conventions for Internet Network\n              Addresses\"\
    , RFC 4001, February 2005.\n   [RFC4181]  Heard, C., Ed., \"Guidelines for Authors\
    \ and Reviewers of\n              MIB Documents\", BCP 111, RFC 4181, September\
    \ 2005.\n   [RFC4366]  Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen,\
    \ J.,\n              and T. Wright, \"Transport Layer Security (TLS)\n       \
    \       Extensions\", RFC 4366, April 2006.\n   [RFC4485]  Rosenberg, J. and H.\
    \ Schulzrinne, \"Guidelines for Authors\n              of Extensions to the Session\
    \ Initiation Protocol (SIP)\",\n              RFC 4485, May 2006.\n   [RFC4521]\
    \  Zeilenga, K., \"Considerations for Lightweight Directory\n              Access\
    \ Protocol (LDAP) Extensions\", BCP 118, RFC 4521,\n              June 2006.\n\
    \   [RFC4727]  Fenner, B., \"Experimental Values In IPv4, IPv6, ICMPv4,\n    \
    \          ICMPv6, UDP, and TCP Headers\", RFC 4727, November 2006.\n   [RFC4929]\
    \  Andersson, L., Ed., and A. Farrel, Ed., \"Change Process\n              for\
    \ Multiprotocol Label Switching (MPLS) and Generalized\n              MPLS (GMPLS)\
    \ Protocols and Procedures\", BCP 129, RFC 4929,\n              June 2007.\n \
    \  [RFC4962]  Housley, R. and B. Aboba, \"Guidance for Authentication,\n     \
    \         Authorization, and Accounting (AAA) Key Management\", BCP\n        \
    \      132, RFC 4962, July 2007.\n   [RFC5080]  Nelson, D. and A. DeKok, \"Common\
    \ Remote Authentication\n              Dial In User Service (RADIUS) Implementation\
    \ Issues and\n              Suggested Fixes\", RFC 5080, December 2007.\n   [RFC5201]\
    \  Moskowitz, R., Nikander, P., Jokela, P., Ed., and T.\n              Henderson,\
    \ \"Host Identity Protocol\", RFC 5201, April 2008.\n   [RFC5218]  Thaler, D.\
    \ and B. Aboba, \"What Makes For a Successful\n              Protocol?\", RFC\
    \ 5218, July 2008.\n   [RFC5225]  Pelletier, G. and K. Sandlund, \"RObust Header\
    \ Compression\n              Version 2 (ROHCv2): Profiles for RTP, UDP, IP, ESP\
    \ and\n              UDP-Lite\", RFC 5225, April 2008.\n   [RFC5246]  Dierks,\
    \ T. and E. Rescorla, \"The Transport Layer Security\n              (TLS) Protocol\
    \ Version 1.2\", RFC 5246, August 2008.\n   [RFC5321]  Klensin, J., \"Simple Mail\
    \ Transfer Protocol\", RFC 5321,\n              October 2008.\n   [RFC5405]  Eggert,\
    \ L. and G. Fairhurst, \"Unicast UDP Usage Guidelines\n              for Application\
    \ Designers\", BCP 145, RFC 5405, November\n              2008.\n   [RFC5421]\
    \  Cam-Winget, N. and H. Zhou, \"Basic Password Exchange\n              within\
    \ the Flexible Authentication via Secure Tunneling\n              Extensible Authentication\
    \ Protocol (EAP-FAST)\", RFC 5421,\n              March 2009.\n   [RFC5422]  Cam-Winget,\
    \ N., McGrew, D., Salowey, J., and H. Zhou,\n              \"Dynamic Provisioning\
    \ Using Flexible Authentication via\n              Secure Tunneling Extensible\
    \ Authentication Protocol (EAP-\n              FAST)\", RFC 5422, March 2009.\n\
    \   [RFC5704]  Bryant, S., Ed., Morrow, M., Ed., and IAB, \"Uncoordinated\n  \
    \            Protocol Development Considered Harmful\", RFC 5704,\n          \
    \    November 2009.\n   [RFC5727]  Peterson, J., Jennings, C., and R. Sparks,\
    \ \"Change Process\n              for the Session Initiation Protocol (SIP) and\
    \ the Real-\n              time Applications and Infrastructure Area\", BCP 67,\
    \ RFC\n              5727, March 2010.\n   [RFC5996]  Kaufman, C., Hoffman, P.,\
    \ Nir, Y., and P. Eronen,\n              \"Internet Key Exchange Protocol Version\
    \ 2 (IKEv2)\", RFC\n              5996, September 2010.\n   [RFC6055]  Thaler,\
    \ D., Klensin, J., and S. Cheshire, \"IAB Thoughts on\n              Encodings\
    \ for Internationalized Domain Names\", RFC 6055,\n              February 2011.\n\
    \   [RFC6158]  DeKok, A., Ed., and G. Weber, \"RADIUS Design Guidelines\",\n \
    \             BCP 158, RFC 6158, March 2011.\n   [RFC6648]  Saint-Andre, P., Crocker,\
    \ D., and M. Nottingham,\n              \"Deprecating the \"X-\" Prefix and Similar\
    \ Constructs in\n              Application Protocols\", BCP 178, RFC 6648, June\
    \ 2012.\n"
- title: 7.  Acknowledgments
  contents:
  - "7.  Acknowledgments\n   This document is heavily based on an earlier draft by\
    \ Scott Bradner\n   and Thomas Narten, other parts of which were eventually published\
    \ as\n   RFC 4775.\n   That draft stated: \"The initial version of this document\
    \ was put\n   together by the IESG in 2002.  Since then, it has been reworked\
    \ in\n   response to feedback from John Loughney, Henrik Levkowetz, Mark\n   Townsley,\
    \ Randy Bush and others.\"\n   Valuable comments and suggestions on the current\
    \ form of the document\n   were made by Loa Andersson, Ran Atkinson, Stewart Bryant,\
    \ Leslie\n   Daigle, Alan DeKok, Roy Fielding, Phillip Hallam-Baker, Ted Hardie,\n\
    \   Alfred Hoenes, John Klensin, Barry Leiba, Eric Rescorla, Adam Roach,\n   and\
    \ Pekka Savola.  The text on TLS experience was contributed by\n   Yngve Pettersen.\n"
- title: 8.  IAB Members at the Time of Approval
  contents:
  - "8.  IAB Members at the Time of Approval\n   Bernard Aboba\n   Jari Arkko\n  \
    \ Marc Blanchet\n   Ross Callon\n   Alissa Cooper\n   Spencer Dawkins\n   Joel\
    \ Halpern\n   Russ Housley\n   David Kessens\n   Danny McPherson\n   Jon Peterson\n\
    \   Dave Thaler\n   Hannes Tschofenig\n"
- title: Appendix A.  Examples
  contents:
  - "Appendix A.  Examples\n   This section discusses some specific examples as case\
    \ studies.\n"
- title: A.1.  Already-Documented Cases
  contents:
  - "A.1.  Already-Documented Cases\n   There are certain documents that specify a\
    \ change process or describe\n   extension considerations for specific IETF protocols:\n\
    \      The SIP change process [RFC3427], [RFC4485], [RFC5727]\n      The (G)MPLS\
    \ change process (mainly procedural) [RFC4929]\n      LDAP extensions [RFC4521]\n\
    \      EPP extensions [RFC3735]\n      DNS extensions [RFC2671][RFC3597]\n   \
    \   SMTP extensions [RFC5321]\n   It is relatively common for MIBs, which are\
    \ all in effect extensions\n   of the SMI data model, to be defined or extended\
    \ outside the IETF.\n   BCP 111 [RFC4181] offers detailed guidance for authors\
    \ and reviewers.\n"
- title: A.2.  RADIUS Extensions
  contents:
  - "A.2.  RADIUS Extensions\n   The RADIUS [RFC2865] protocol was designed to be\
    \ extensible via\n   addition of Attributes.  This extensibility model assumed\
    \ that\n   Attributes would conform to a limited set of data types and that\n\
    \   vendor extensions would be limited to use by vendors in situations in\n  \
    \ which interoperability was not required.  Subsequent developments\n   have stretched\
    \ those assumptions.\n   From the beginning, uses of the RADIUS protocol extended\
    \ beyond the\n   scope of the original protocol definition (and beyond the scope\
    \ of\n   the RADIUS Working Group charter).  In addition to rampant self-\n  \
    \ allocation within the limited RADIUS standard attribute space,\n   vendors defined\
    \ their own RADIUS commands.  This led to the rapid\n   proliferation of vendor-specific\
    \ protocol variants.  To this day,\n   many common implementation practices have\
    \ not been documented.  For\n   example, authentication server implementations\
    \ are often typically\n   based on a Data Dictionary, enabling addition of Attributes\
    \ without\n   requiring code changes.  Yet, the concept of a Data Dictionary is\
    \ not\n   mentioned in the RADIUS specification [RFC2865].\n   As noted in \"\
    Extended RADIUS Practices\" [RFC2882], Section 1:\n      The RADIUS Working Group\
    \ was formed in 1995 to document the\n      protocol of the same name, and was\
    \ chartered to stay within a set\n      of bounds for dial-in terminal servers.\
    \  Unfortunately the real\n      world of Network Access Servers (NASes) hasn't\
    \ stayed that small\n      and simple, and continues to evolve at an amazing rate.\n\
    \      This document shows some of the current implementations on the\n      market\
    \ have already outstripped the capabilities of the RADIUS\n      protocol.  A\
    \ quite a few features have been developed completely\n      outside the protocol.\
    \  These features use the RADIUS protocol\n      structure and format, but employ\
    \ operations and semantics well\n      beyond the RFC documents.\n   The limited\
    \ set of data types defined in the RADIUS specification\n   [RFC2865] led to subsequent\
    \ documents defining new data types.  Since\n   new data types are typically defined\
    \ implicitly as part of defining a\n   new attribute and because RADIUS client\
    \ and server implementations\n   differ in their support of these additional specifications,\
    \ there is\n   no definitive registry of RADIUS data types, and data type support\n\
    \   has been inconsistent.  To catalog commonly implemented data types as\n  \
    \ well as to provide guidance for implementers and attribute designers,\n   Section\
    \ 2.1 of \"RADIUS Design Guidelines\" [RFC6158] includes advice\n   on basic and\
    \ complex data types.  Unfortunately, these guidelines\n   [RFC6158] were published\
    \ in 2011, 14 years after the RADIUS protocol\n   was first documented [RFC2058]\
    \ in 1997.\n   Section 6.2 of the RADIUS specification [RFC2865] defines a mechanism\n\
    \   for Vendor-Specific extensions (Attribute 26) and states that use of\n   Vendor-Specific\
    \ extensions:\n      should be encouraged instead of allocation of global attribute\n\
    \      types, for functions specific only to one vendor's implementation\n   \
    \   of RADIUS, where no interoperability is deemed useful.\n   However, in practice,\
    \ usage of Vendor-Specific Attributes (VSAs) has\n   been considerably broader\
    \ than this.  In particular, VSAs have been\n   used by Standards Development\
    \ Organizations (SDOs) to define their\n   own extensions to the RADIUS protocol.\
    \  This has caused a number of\n   problems.\n   One issue concerns the data model\
    \ for VSAs.  Since it was not\n   envisaged that multi-vendor VSA implementations\
    \ would need to\n   interoperate, the RADIUS specification [RFC2865] does not\
    \ define the\n   data model for VSAs and allows multiple sub-attributes to be\
    \ included\n   within a single Attribute of type 26.  Since this enables VSAs\
    \ to be\n   defined that would not be supportable by current implementations if\n\
    \   placed within the standard RADIUS attribute space, this has caused\n   problems\
    \ in standardizing widely deployed VSAs, as discussed in\n   Section 2.4 of \"\
    RADIUS Design Guidelines\" BCP 158 [RFC6158]:\n      RADIUS attributes can often\
    \ be developed within the vendor space\n      without loss (and possibly even\
    \ with gain) in functionality.  As a\n      result, translation of RADIUS attributes\
    \ developed within the\n      vendor space into the standard space may provide\
    \ only modest\n      benefits, while accelerating the exhaustion of the standard\
    \ space.\n      We do not expect that all RADIUS attribute specifications\n  \
    \    requiring interoperability will be developed within the IETF, and\n     \
    \ allocated from the standard space.  A more scalable approach is to\n      recognize\
    \ the flexibility of the vendor space, while working\n      toward improvements\
    \ in the quality and availability of RADIUS\n      attribute specifications, regardless\
    \ of where they are developed.\n      It is therefore NOT RECOMMENDED that specifications\
    \ intended\n      solely for use by a vendor or SDO be translated into the standard\n\
    \      space.\n   Another issue is how implementations should handle unknown VSAs.\n\
    \   Section 5.26 of the RADIUS specification [RFC2865] states:\n      Servers\
    \ not equipped to interpret the vendor-specific information\n      sent by a client\
    \ MUST ignore it (although it may be reported).\n      Clients which do not receive\
    \ desired vendor-specific information\n      SHOULD make an attempt to operate\
    \ without it, although they may do\n      so (and report they are doing so) in\
    \ a degraded mode.\n   However, since VSAs do not contain a \"mandatory\" bit,\
    \ RADIUS clients\n   and servers may not know whether it is safe to ignore unknown\
    \ VSAs.\n   For example, in the case where VSAs pertain to security (e.g.,\n \
    \  Filters), it may not be safe to ignore them.  As a result, Section\n   2.5\
    \ of \"Common Remote Authentication Dial In User Service (RADIUS)\n   Implementation\
    \ Issues and Suggested Fixes\" [RFC5080] includes the\n   following caution:\n\
    \      To avoid misinterpretation of service requests encoded within\n      VSAs,\
    \ RADIUS servers SHOULD NOT send VSAs containing service\n      requests to RADIUS\
    \ clients that are not known to understand them.\n      For example, a RADIUS\
    \ server should not send a VSA encoding a\n      filter without knowledge that\
    \ the RADIUS client supports the VSA.\n   In addition to extending RADIUS by use\
    \ of VSAs, SDOs have also\n   defined new values of the Service-Type attribute\
    \ in order to create\n   new RADIUS commands.  Since the RADIUS specification\
    \ [RFC2865]\n   defined Service-Type values as being allocated First Come, First\n\
    \   Served (FCFS) [RFC5226], this permitted new RADIUS commands to be\n   allocated\
    \ without IETF review.  This oversight has since been fixed\n   in \"IANA Considerations\
    \ for RADIUS\" [RFC3575].\n"
- title: A.3.  TLS Extensions
  contents:
  - "A.3.  TLS Extensions\n   The Secure Sockets Layer (SSL) Version 2 Protocol was\
    \ developed by\n   Netscape to be used to secure online transactions on the Internet.\n\
    \   It was later replaced by SSLv3, also developed by Netscape.  SSLv3\n   was\
    \ then further developed by the IETF as the Transport Layer\n   Security (TLS)\
    \ 1.0 [RFC2246].\n   The SSLv3 protocol was not explicitly specified to be extended.\
    \  Even\n   TLS 1.0 did not define an extension mechanism explicitly.  However,\n\
    \   extension \"loopholes\" were available.  Extension mechanisms were\n   finally\
    \ defined in \"Transport Layer Security (TLS) Extensions\"\n   [RFC4366]:\n  \
    \    o  New versions\n      o  New cipher suites\n      o  Compression\n     \
    \ o  Expanded handshake messages\n      o  New record types\n      o  New handshake\
    \ messages\n   The protocol also defines how implementations should handle unknown\n\
    \   extensions.\n   Of the above extension methods, new versions and expanded\
    \ handshake\n   messages have caused the most interoperability problems.\n   Implementations\
    \ are supposed to ignore unknown record types but to\n   reject unknown handshake\
    \ messages.\n   The new version support in SSL/TLS includes a capability to define\n\
    \   new versions of the protocol, while allowing newer implementations to\n  \
    \ communicate with older implementations.  As part of this\n   functionality,\
    \ some Key Exchange methods include functionality to\n   prevent version rollback\
    \ attacks.\n   The experience with this upgrade functionality in SSL and TLS is\n\
    \   decidedly mixed:\n      o  SSLv2 and SSLv3/TLS are not compatible.  It is\
    \ possible to use\n         SSLv2 protocol messages to initiate an SSLv3/TLS connection,\n\
    \         but it is not possible to communicate with an SSLv2\n         implementation\
    \ using SSLv3/TLS protocol messages.\n      o  There are implementations that\
    \ refuse to accept handshakes\n         using newer versions of the protocol than\
    \ they support.\n      o  There are other implementations that accept newer versions\
    \ but\n         have implemented the version rollback protection clumsily.\n \
    \  The SSLv2 problem has forced SSLv3 and TLS clients to continue to use\n   SSLv2\
    \ Client Hellos for their initial handshake with almost all\n   servers until\
    \ 2006, much longer than would have been desirable, in\n   order to interoperate\
    \ with old servers.\n   The problem with incorrect handling of newer versions\
    \ has also forced\n   many clients to actually disable the newer protocol versions,\
    \ either\n   by default or by automatically disabling the functionality, to be\n\
    \   able to connect to such servers.  Effectively, this means that the\n   version\
    \ rollback protection in SSL and TLS is non-existent if talking\n   to a fatally\
    \ compromised older version.\n   SSLv3 and TLS also permitted extension of the\
    \ Client Hello and Server\n   Hello handshake messages.  This functionality was\
    \ fully defined by\n   the introduction of TLS extensions, which make it possible\
    \ to add new\n   functionality to the handshake, such as the name of the server\
    \ the\n   client is connecting to, request certificate status information, and\n\
    \   indicate Certificate Authority support, maximum record length, etc.\n   Several\
    \ of these extensions also introduce new handshake messages.\n   It has turned\
    \ out that many SSLv3 and TLS implementations that do not\n   support TLS extensions\
    \ did not ignore the unknown extensions, as\n   required by the protocol specifications,\
    \ but instead failed to\n   establish connections.  Since several of the implementations\
    \ behaving\n   in this manner are used by high-profile Internet sites, such as\n\
    \   online banking sites, this has caused a significant delay in the\n   deployment\
    \ of clients supporting TLS extensions, and several of the\n   clients that have\
    \ enabled support are using heuristics that allow\n   them to disable the functionality\
    \ when they detect a problem.\n   Looking forward, the protocol version problem,\
    \ in particular, can\n   cause future security problems for the TLS protocol.\
    \  The strength of\n   the digest algorithms (MD5 and SHA-1) used by SSL and TLS\
    \ is\n   weakening.  If MD5 and SHA-1 weaken to the point where it is feasible\n\
    \   to mount successful attacks against older SSL and TLS versions, the\n   current\
    \ error recovery used by clients would become a security\n   vulnerability (among\
    \ many other serious problems for the Internet).\n   To address this issue, TLS\
    \ 1.2 [RFC5246] makes use of a newer\n   cryptographic hash algorithm (SHA-256)\
    \ during the TLS handshake by\n   default.  Legacy ciphersuites can still be used\
    \ to protect\n   application data, but new ciphersuites are specified for data\n\
    \   protection as well as for authentication within the TLS handshake.\n   The\
    \ hashing method can also be negotiated via a Hello extension.\n   Implementations\
    \ are encouraged to implement new ciphersuites and to\n   enable the negotiation\
    \ of the ciphersuite used during a TLS session\n   to be governed by policy, thus\
    \ enabling a more rapid transition away\n   from weakened ciphersuites.\n   The\
    \ lesson to be drawn from this experience is that it isn't\n   sufficient to design\
    \ extensibility carefully; it must also be\n   implemented carefully by every\
    \ implementer, without exception.  Test\n   suites and certification programs\
    \ can help provide incentives for\n   implementers to pay attention to implementing\
    \ extensibility\n   mechanisms correctly.\n"
- title: A.4.  L2TP Extensions
  contents:
  - "A.4.  L2TP Extensions\n   The Layer Two Tunneling Protocol (L2TP) [RFC2661] carries\
    \ Attribute-\n   Value Pairs (AVPs), with most AVPs having no semantics to the\
    \ L2TP\n   protocol itself.  However, it should be noted that L2TP message types\n\
    \   are identified by a Message Type AVP (Attribute Type 0) with specific\n  \
    \ AVP values indicating the actual message type.  Thus, extensions\n   relating\
    \ to Message Type AVPs would likely be considered major\n   extensions.\n   L2TP\
    \ also provides for vendor-specific AVPs.  Because everything in\n   L2TP is encoded\
    \ using AVPs, it would be easy to define vendor-\n   specific AVPs that would\
    \ be considered major extensions.\n   L2TP also provides for a \"mandatory\" bit\
    \ in AVPs.  Recipients of L2TP\n   messages containing AVPs that they do not understand\
    \ but that have\n   the mandatory bit set, are expected to reject the message\
    \ and\n   terminate the tunnel or session the message refers to.  This leads to\n\
    \   interesting interoperability issues, because a sender can include a\n   vendor-specific\
    \ AVP with the M-bit set, which then causes the\n   recipient to not interoperate\
    \ with the sender.  This sort of behavior\n   is counter to the IETF ideals, as\
    \ implementations of the IETF\n   standard should interoperate successfully with\
    \ other implementations\n   and not require the implementation of non-IETF extensions\
    \ in order to\n   interoperate successfully.  Section 4.2 of the L2TP specification\n\
    \   [RFC2661] includes specific wording on this point, though there was\n   significant\
    \ debate at the time as to whether such language was by\n   itself sufficient.\n\
    \   Fortunately, it does not appear that the potential problems described\n  \
    \ above have yet become a problem in practice.  At the time of this\n   writing,\
    \ the authors are not aware of the existence of any vendor-\n   specific AVPs\
    \ that also set the M-bit.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Brian Carpenter\n   Department of Computer Science\n \
    \  University of Auckland\n   PB 92019\n   Auckland, 1142\n   New Zealand\n  \
    \ EMail: brian.e.carpenter@gmail.com\n   Bernard Aboba (editor)\n   PMB 606\n\
    \   15600 NE 8th Street, Suite B1\n   Bellevue, WA 98008\n   USA\n   EMail: bernard_aboba@hotmail.com\n\
    \   Stuart Cheshire\n   Apple Inc.\n   1 Infinite Loop\n   Cupertino, CA 95014\n\
    \   USA\n   EMail: cheshire@apple.com\n"
