- title: __initial_text__
  contents:
  - '                  An Implementation Guide for RTP MIDI

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The IETF Trust (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo offers non-normative implementation guidance for the Real-\n\
    \   time Protocol (RTP) MIDI (Musical Instrument Digital Interface)\n   payload\
    \ format.  The memo presents its advice in the context of a\n   network musical\
    \ performance application.  In this application two\n   musicians, located in\
    \ different physical locations, interact over a\n   network to perform as they\
    \ would if located in the same room.\n   Underlying the performances are RTP MIDI\
    \ sessions over unicast UDP.\n   Algorithms for sending and receiving recovery\
    \ journals (the\n   resiliency structure for the payload format) are described\
    \ in detail.\n   Although the memo focuses on network musical performance, the\n\
    \   presented implementation advice is relevant to other RTP MIDI\n   applications.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................2\n\
    \   2. Starting the Session ............................................3\n  \
    \ 3. Session Management: Session Housekeeping ........................6\n   4.\
    \ Sending Streams: General Considerations .........................7\n      4.1.\
    \ Queuing and Coding Incoming MIDI Data .....................11\n      4.2. Sending\
    \ Packets with Empty MIDI Lists .....................12\n      4.3. Congestion\
    \ Control and Bandwidth Management ...............13\n   5. Sending Streams: The\
    \ Recovery Journal ..........................14\n      5.1. Initializing the RJSS\
    \ .....................................16\n      5.2. Traversing the RJSS .......................................19\n\
    \      5.3. Updating the RJSS .........................................19\n  \
    \    5.4. Trimming the RJSS .........................................20\n    \
    \  5.5. Implementation Notes ......................................21\n   6. Receiving\
    \ Streams: General Considerations ......................21\n      6.1 The NMP\
    \ Receiver Design ....................................22\n      6.2 High-Jitter\
    \ Networks, Local Area Networks ..................24\n   7. Receiving Streams:\
    \ The Recovery Journal ........................25\n      7.1. Chapter W: MIDI\
    \ Pitch Wheel (0xE) .........................30\n      7.2. Chapter N: MIDI NoteOn\
    \ (0x8) and NoteOff (0x9) ............30\n      7.3. Chapter C: MIDI Control Change\
    \ (0xB) ......................32\n      7.4. Chapter P: MIDI Program Change (0xC)\
    \ ......................34\n   8. Security Considerations ........................................35\n\
    \   9. IANA Considerations ............................................35\n  \
    \ 10. Acknowledgements ..............................................35\n   11.\
    \ References ....................................................35\n      11.1.\
    \ Normative References .....................................35\n      11.2. Informative\
    \ References ...................................36\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   [RFC4695] normatively defines a Real-time Transport Protocol\
    \ (RTP,\n   [RFC3550]) payload format for the MIDI (Musical Instrument Digital\n\
    \   Interface) command language [MIDI], for use under any applicable RTP\n   profile,\
    \ such as the Audio/Visual Profile (AVP, [RFC3551]).\n   However, [RFC4695] does\
    \ not define algorithms for sending and\n   receiving MIDI streams.  Implementors\
    \ are free to use any sending or\n   receiving algorithm that conforms to the\
    \ normative text in [RFC4695],\n   [RFC3550], [RFC3551], and [MIDI].\n   In this\
    \ memo, we offer implementation guidance on sending and\n   receiving MIDI RTP\
    \ streams.  Unlike [RFC4695], this memo is not\n   normative.\n   RTP is a mature\
    \ protocol, and excellent RTP reference materials are\n   available [RTPBOOK].\
    \  This memo aims to complement the existing\n   literature by focusing on issues\
    \ that are specific to the MIDI\n   payload format.\n   The memo focuses on one\
    \ application: two-party network musical\n   performance over wide-area networks,\
    \ following the interoperability\n   guidelines in Appendix C.7.2 of [RFC4695].\
    \  Underlying the\n   performances are RTP MIDI sessions over unicast UDP transport.\n\
    \   Resiliency is provided by the recovery journal system [RFC4695].  The\n  \
    \ application also uses the RTP Control Protocol (RTCP, [RFC3550]).\n   The application\
    \ targets a network with a particular set of\n   characteristics: low nominal\
    \ jitter, low packet loss, and occasional\n   outlier packets that arrive very\
    \ late.  However, in Section 6.2 of\n   this memo, we discuss adapting the application\
    \ to other network\n   environments.\n   As defined in [NMP], a network musical\
    \ performance occurs when\n   musicians located at different physical locations\
    \ interact over a\n   network to perform as they would if located in the same\
    \ room.\n   Sections 2-3 of this memo describe session startup and maintenance.\n\
    \   Sections 4-5 cover sending MIDI streams, and Sections 6-7 cover\n   receiving\
    \ MIDI streams.\n"
- title: 2.  Starting the Session
  contents:
  - "2.  Starting the Session\n   In this section, we describe how the application\
    \ starts a two-player\n   session.  We assume that the two parties have agreed\
    \ on a session\n   configuration, embodied by a pair of Session Description Protocol\n\
    \   (SDP, [RFC4566]) session descriptions.\n   One session description (Figure\
    \ 1) defines how the first party wishes\n   to receive its stream.  The other\
    \ session description (Figure 2)\n   defines how the second party wishes to receive\
    \ its stream.\n   The session description in Figure 1 codes that the first party\n\
    \   intends to receive a MIDI stream on IP4 number 192.0.2.94 (coded in\n   the\
    \ c= line) at UDP port 16112 (coded in the m= line).  Implicit in\n   the SDP\
    \ m= line syntax [RFC4566] is that the first party also intends\n   to receive\
    \ an RTCP stream on 192.0.2.94 at UDP port 16113 (16112 +\n   1).  The receiver\
    \ expects that the PT field of each RTP header in the\n   received stream will\
    \ be set to 96 (coded in the m= line).\n   Likewise, the session description in\
    \ Figure 2 codes that the second\n   party intends to receive a MIDI stream on\
    \ IP4 number 192.0.2.105 at\n   UDP port 5004 and intends to receive an RTCP stream\
    \ on 192.0.2.105 at\n   UDP port 5005 (5004 + 1).  The second party expects that\
    \ the PT RTP\n   header field of received stream will be set to 101.\n"
- title: v=0
  contents:
  - 'v=0

    '
- title: o=first 2520644554 2838152170 IN IP4 first.example.net
  contents:
  - 'o=first 2520644554 2838152170 IN IP4 first.example.net

    '
- title: s=Example
  contents:
  - 's=Example

    '
- title: t=0 0
  contents:
  - 't=0 0

    '
- title: c=IN IP4 192.0.2.94
  contents:
  - 'c=IN IP4 192.0.2.94

    '
- title: m=audio 16112 RTP/AVP 96
  contents:
  - 'm=audio 16112 RTP/AVP 96

    '
- title: b=AS:20
  contents:
  - 'b=AS:20

    '
- title: b=RS:0
  contents:
  - 'b=RS:0

    '
- title: b=RR:400
  contents:
  - 'b=RR:400

    '
- title: a=rtpmap:96 mpeg4-generic/44100
  contents:
  - 'a=rtpmap:96 mpeg4-generic/44100

    '
- title: a=fmtp:96 streamtype=5; mode=rtp-midi; config=""; profile-level-id=12;
  contents:
  - 'a=fmtp:96 streamtype=5; mode=rtp-midi; config=""; profile-level-id=12;

    '
- title: cm_unused=ABFGHJKMQTVXYZ; cm_unused=C120-127; ch_never=ADEFMQTVX;
  contents:
  - 'cm_unused=ABFGHJKMQTVXYZ; cm_unused=C120-127; ch_never=ADEFMQTVX;

    '
- title: tsmode=buffer; linerate=320000; octpos=last; mperiod=44; rtp_ptime=0;
  contents:
  - 'tsmode=buffer; linerate=320000; octpos=last; mperiod=44; rtp_ptime=0;

    '
- title: rtp_maxptime=0; guardtime=44100; render=synthetic; rinit="audio/asc";
  contents:
  - 'rtp_maxptime=0; guardtime=44100; render=synthetic; rinit="audio/asc";

    '
- title: url="http://example.net/sa.asc";
  contents:
  - 'url="http://example.net/sa.asc";

    '
- title: cid="xjflsoeiurvpa09itnvlduihgnvet98pa3w9utnuighbuk"
  contents:
  - "cid=\"xjflsoeiurvpa09itnvlduihgnvet98pa3w9utnuighbuk\"\n   (The a=fmtp line has\
    \ been wrapped to fit the page to accommodate\n    memo formatting restrictions;\
    \ it constitutes a single line in SDP.)\n            Figure 1. Session description\
    \ for first participant\n"
- title: v=0
  contents:
  - 'v=0

    '
- title: o=second 2520644554 2838152170 IN IP4 second.example.net
  contents:
  - 'o=second 2520644554 2838152170 IN IP4 second.example.net

    '
- title: s=Example
  contents:
  - 's=Example

    '
- title: t=0 0
  contents:
  - 't=0 0

    '
- title: c=IN IP4 192.0.2.105
  contents:
  - 'c=IN IP4 192.0.2.105

    '
- title: m=audio 5004 RTP/AVP 101
  contents:
  - 'm=audio 5004 RTP/AVP 101

    '
- title: b=AS:20
  contents:
  - 'b=AS:20

    '
- title: b=RS:0
  contents:
  - 'b=RS:0

    '
- title: b=RR:400
  contents:
  - 'b=RR:400

    '
- title: a=rtpmap:101 mpeg4-generic/44100
  contents:
  - 'a=rtpmap:101 mpeg4-generic/44100

    '
- title: a=fmtp:101 streamtype=5; mode=rtp-midi; config=""; profile-level-id=12;
  contents:
  - 'a=fmtp:101 streamtype=5; mode=rtp-midi; config=""; profile-level-id=12;

    '
- title: cm_unused=ABFGHJKMQTVXYZ; cm_unused=C120-127; ch_never=ADEFMQTVX;
  contents:
  - 'cm_unused=ABFGHJKMQTVXYZ; cm_unused=C120-127; ch_never=ADEFMQTVX;

    '
- title: tsmode=buffer; linerate=320000;octpos=last;mperiod=44; guardtime=44100;
  contents:
  - 'tsmode=buffer; linerate=320000;octpos=last;mperiod=44; guardtime=44100;

    '
- title: rtp_ptime=0; rtp_maxptime=0; render=synthetic; rinit="audio/asc";
  contents:
  - 'rtp_ptime=0; rtp_maxptime=0; render=synthetic; rinit="audio/asc";

    '
- title: url="http://example.net/sa.asc";
  contents:
  - 'url="http://example.net/sa.asc";

    '
- title: cid="xjflsoeiurvpa09itnvlduihgnvet98pa3w9utnuighbuk"
  contents:
  - "cid=\"xjflsoeiurvpa09itnvlduihgnvet98pa3w9utnuighbuk\"\n   (The a=fmtp line has\
    \ been wrapped to fit the page to accommodate\n    memo formatting restrictions;\
    \ it constitutes a single line in SDP.)\n          Figure 2. Session description\
    \ for second participant\n   The session descriptions use the mpeg4-generic media\
    \ type (coded in\n   the a=rtpmap line) to specify the use of the MPEG 4 Structured\
    \ Audio\n   renderer [MPEGSA].  The session descriptions also use parameters to\n\
    \   customize the stream (Appendix C of [RFC4695]).  The parameter values\n  \
    \ are identical for both parties, yielding identical rendering\n   environments\
    \ for the two client hosts.\n   The bandwidth (b=) AS parameter [RFC4566] [RFC3550]\
    \ indicates that\n   the total RTP session bandwidth is 20 kbs.  This value assumes\
    \ that\n   the two players send 10 kbs streams concurrently.  To derive the 10\n\
    \   kbs value, we begin with the analysis of RTP MIDI payload bandwidth\n   in\
    \ Appendix A.4 of [NMP] and add in RTP and IP4 packet overhead and a\n   small\
    \ safety factor.\n   The bandwidth RR parameter [RFC3556] indicates that the shared\
    \ RTCP\n   session bandwidth for the two parties is 400 bps.  We set the\n   bandwidth\
    \ SR parameter to 0 bps, to signal that sending parties and\n   non-sending parties\
    \ equally share the 400 bps of RTCP bandwidth.\n   (Note that in this particular\
    \ example, the guardtime parameter value\n   of 44100 ensures that both parties\
    \ are sending for the duration of\n   the session.)  The 400 bps RTCP bandwidth\
    \ value supports one RTCP\n   packet per 5 seconds from each party, containing\
    \ a Sender Report and\n   CNAME information [RFC3550].\n   We now show an example\
    \ of code that implements the actions the\n   parties take during the session.\
    \  The code is written in C and uses\n   the standard network programming techniques\
    \ described in [STEVENS].\n   We show code for the first party (the second party\
    \ takes a symmetric\n   set of actions).\n   Figure 3 shows how the first party\
    \ initializes a pair of socket\n   descriptors (rtp_fd and rtcp_fd) to send and\
    \ receive UDP packets.\n   After the code in Figure 3 runs, the first party may\
    \ check for new\n   RTP or RTCP packets by calling recv() on rtp_fd or rtcp_fd.\n\
    \   Applications may use recv() to receive UDP packets on a socket using\n   one\
    \ of two general methods: \"blocking\" or \"non-blocking\".\n   A call to recv()\
    \ on a blocking UDP socket puts the calling thread to\n   sleep until a new packet\
    \ arrives.\n   A call to recv() on a non-blocking socket acts to poll the device:\n\
    \   the recv() call returns immediately, with a return value that\n   indicates\
    \ the polling result.  In this case, a positive return value\n   signals the size\
    \ of a new received packet, and a negative return\n   value (coupled with an errno\
    \ value of EAGAIN) indicates that no new\n   packet was available.\n   The choice\
    \ of blocking or non-blocking sockets is a critical\n   application choice.  Blocking\
    \ sockets offer the lowest potential\n   latency (as the OS wakes the caller as\
    \ soon as a packet has arrived).\n   However, audio applications that use blocking\
    \ sockets must adopt a\n   multi-threaded program architecture, so that audio\
    \ samples may be\n   generated on a \"rendering thread\" while the \"network thread\"\
    \ sleeps,\n   awaiting the next packet.  The architecture must also support a\n\
    \   thread communication mechanism, so that the network thread has a\n   mechanism\
    \ to send MIDI commands the rendering thread.\n   In contrast, audio applications\
    \ that use non-blocking sockets may be\n   coded using a single thread, that alternates\
    \ between audio sample\n   generation and network polling.  This architecture\
    \ trades off\n   increased network latency (as a packet may arrive between polls)\
    \ for\n   a simpler program architecture.  For simplicity, our example uses\n\
    \   non-blocking sockets and presumes a single run loop.  Figure 4 shows\n   how\
    \ the example configures its sockets to be non-blocking.\n   Figure 5 shows how\
    \ to use recv() to check a non-blocking socket for\n   new packets.\n   The first\
    \ party also uses rtp_fd and rtcp_fd to send RTP and RTCP\n   packets to the second\
    \ party.  In Figure 6, we show how to initialize\n   socket structures that address\
    \ the second party.  In Figure 7, we\n   show how to use one of these structures\
    \ in a sendto() call to send an\n   RTP packet to the second party.\n   Note that\
    \ the code shown in Figures 3-7 assumes a clear network path\n   between the participants.\
    \  The code may not work if firewalls or\n   Network Address Translation (NAT)\
    \ devices are present in the network\n   path.\n"
- title: '3.  Session Management: Session Housekeeping'
  contents:
  - "3.  Session Management: Session Housekeeping\n   After the two-party interactive\
    \ session is set up, the parties begin\n   to send and receive RTP packets.  In\
    \ Sections 4-7, we discuss RTP\n   MIDI sending and receiving algorithms.  In\
    \ this section, we describe\n   session \"housekeeping\" tasks that the participants\
    \ also perform.\n   One housekeeping task is the maintenance of the 32-bit\n \
    \  Synchronization Source (SSRC) value that uniquely identifies each\n   party.\
    \  Section 8 of [RFC3550] describes SSRC issues in detail, as\n   does Section\
    \ 2.1 in [RFC4695].  Another housekeeping task is the\n   sending and receiving\
    \ of RTCP.  Section 6 of [RFC3550] describes RTCP\n   in detail.\n   Another housekeeping\
    \ task concerns security.  As detailed in the\n   Security Considerations section\
    \ of [RFC4695], per-packet\n   authentication is strongly recommended for use\
    \ with MIDI streams,\n   because the acceptance of rogue packets may lead to the\
    \ execution of\n   arbitrary MIDI commands.\n   A final housekeeping task concerns\
    \ the termination of the session.\n   In our two-party example, the session terminates\
    \ upon the exit of one\n   of the participants.  A clean termination may require\
    \ active effort\n   by a receiver, as a MIDI stream stopped at an arbitrary point\
    \ may\n   cause stuck notes and other indefinite artifacts in the MIDI\n   renderer.\n\
    \   The exit of a party may be signalled in several ways.  Session\n   management\
    \ tools may offer a reliable signal for termination (such as\n   the SIP BYE method\
    \ [RFC3261]).  The (unreliable) RTCP BYE packet\n   [RFC3550] may also signal\
    \ the exit of a party.  Receivers may also\n   sense the lack of RTCP activity\
    \ and timeout a party or may use\n   transport methods to detect an exit.\n"
- title: '4.  Sending Streams: General Considerations'
  contents:
  - "4.  Sending Streams: General Considerations\n   In this section, we discuss sender\
    \ implementation issues.\n   The sender is a real-time data-driven entity.  On\
    \ an ongoing basis,\n   the sender checks to see if the local player has generated\
    \ new MIDI\n   data.  At any time, the sender may transmit a new RTP packet to\
    \ the\n   remote player for the reasons described below:\n   1. New MIDI data\
    \ has been generated by the local player, and the\n      sender decides that it\
    \ is time to issue a packet coding the data.\n   2. The local player has not generated\
    \ new MIDI data, but the sender\n      decides that too much time has elapsed\
    \ since the last RTP packet\n      transmission.  The sender transmits a packet\
    \ in order to relay\n      updated header and recovery journal data.\n   In both\
    \ cases, the sender generates a packet that consists of an RTP\n   header, a MIDI\
    \ command section, and a recovery journal.  In the first\n   case, the MIDI list\
    \ of the MIDI command section codes the new MIDI\n   data.  In the second case,\
    \ the MIDI list is empty.\n   #include <sys/types.h>\n   #include <sys/socket.h>\n\
    \   #include <netinet/in.h>\n     int rtp_fd, rtcp_fd;       /* socket descriptors\
    \ */\n     struct sockaddr_in addr;   /* for bind address   */\n     /*********************************/\n\
    \     /* create the socket descriptors */\n     /*********************************/\n\
    \     if ((rtp_fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n       ERROR_RETURN(\"\
    Couldn't create Internet RTP socket\");\n     if ((rtcp_fd = socket(AF_INET, SOCK_DGRAM,\
    \ 0)) < 0)\n       ERROR_RETURN(\"Couldn't create Internet RTCP socket\");\n \
    \    /**********************************/\n     /* bind the RTP socket descriptor\
    \ */\n     /**********************************/\n     memset(&(addr.sin_zero),\
    \ 0, 8);\n     addr.sin_family = AF_INET;\n     addr.sin_addr.s_addr = htonl(INADDR_ANY);\n\
    \     addr.sin_port = htons(16112); /* port 16112, from SDP */\n     if (bind(rtp_fd,\
    \ (struct sockaddr *)&addr,\n              sizeof(struct sockaddr)) < 0)\n   \
    \     ERROR_RETURN(\"Couldn't bind Internet RTP socket\");\n     /***********************************/\n\
    \     /* bind the RTCP socket descriptor */\n     /***********************************/\n\
    \     memset(&(addr.sin_zero), 0, 8);\n     addr.sin_family = AF_INET;\n     addr.sin_addr.s_addr\
    \ = htonl(INADDR_ANY);\n     addr.sin_port = htons(16113); /* port 16113, from\
    \ SDP */\n     if (bind(rtcp_fd, (struct sockaddr *)&addr,\n              sizeof(struct\
    \ sockaddr)) < 0)\n         ERROR_RETURN(\"Couldn't bind Internet RTCP socket\"\
    );\n           Figure 3. Setup code for listening for RTP/RTCP packets\n   #include\
    \ <unistd.h>\n   #include <fcntl.h>\n     /***************************/\n    \
    \ /* set non-blocking status */\n     /***************************/\n     if (fcntl(rtp_fd,\
    \ F_SETFL, O_NONBLOCK))\n       ERROR_RETURN(\"Couldn't unblock Internet RTP socket\"\
    );\n     if (fcntl(rtcp_fd, F_SETFL, O_NONBLOCK))\n       ERROR_RETURN(\"Couldn't\
    \ unblock Internet RTCP socket\");\n       Figure 4. Code to set socket descriptors\
    \ to be non-blocking\n   #include <errno.h>\n   #define UDPMAXSIZE 1472     /*\
    \ based on Ethernet MTU of 1500 */\n   unsigned char packet[UDPMAXSIZE+1];\n \
    \  int len, normal;\n    while ((len = recv(rtp_fd, packet, UDPMAXSIZE + 1, 0))\
    \ > 0)\n     {\n       /*  process packet[].  If (len == UDPMAXSIZE + 1), recv()\n\
    \        *  may be returning a truncated packet -- process with care\n       \
    \ */\n     }\n     /* line below sets \"normal\" to 1 if the recv() return */\n\
    \     /*   status indicates no packets are left to process  */\n    normal = (len\
    \ < 0) && (errno == EAGAIN);\n    if (!normal)\n     {\n       /*\n        * \
    \ recv() return status indicates an empty UDP payload\n        *  (len == 0) or\
    \ an error condition (coded by (len < 0)\n        *  and (errno != EAGAIN)). \
    \ Examine len and errno, and\n        *  take appropriate recovery action.\n \
    \       */\n     }\n           Figure 5. Code to check rtp_fd for new RTP packets\n\
    \   #include <arpa/inet.h>\n   #include <netinet/in.h>\n   struct sockaddr_in\
    \ * rtp_addr;      /* RTP destination IP/port  */\n   struct sockaddr_in * rtcp_addr;\
    \     /* RTCP destination IP/port */\n     /* set RTP address, as coded in Figure\
    \ 2's SDP */\n     rtp_addr = calloc(1, sizeof(struct sockaddr_in));\n     rtp_addr->sin_family\
    \ = AF_INET;\n     rtp_addr->sin_port = htons(5004);\n     rtp_addr->sin_addr.s_addr\
    \ = inet_addr(\"192.0.2.105\");\n     /* set RTCP address, as coded in Figure\
    \ 2's SDP */\n     rtcp_addr = calloc(1, sizeof(struct sockaddr_in));\n     rtcp_addr->sin_family\
    \ = AF_INET;\n     rtcp_addr->sin_port = htons(5005);   /* 5004 + 1 */\n     rtcp_addr->sin_addr.s_addr\
    \ = rtp_addr->sin_addr.s_addr;\n       Figure 6. Initializing destination addresses\
    \ for RTP and RTCP\n   unsigned char packet[UDPMAXSIZE];  /* RTP packet to send\
    \   */\n   int size;                          /* length of RTP packet */\n   \
    \  /* first fill packet[] and set size ... then: */\n     if (sendto(rtp_fd, packet,\
    \ size, 0, rtp_addr,\n                sizeof(struct sockaddr))  == -1)\n     \
    \  {\n         /*\n          * try again later if errno == EAGAIN or EINTR\n \
    \         *\n          * other errno values --> an operational error\n       \
    \   */\n       }\n              Figure 7. Using sendto() to send an RTP packet\n\
    \   Figure 8 shows the 5 steps a sender takes to issue a packet.  This\n   algorithm\
    \ corresponds to the code fragment for sending RTP packets\n   shown in Figure\
    \ 7 of Section 2.  Steps 1, 2, and 3 occur before the\n   sendto() call in the\
    \ code fragment.  Step 4 corresponds to the\n   sendto() call itself.  Step 5\
    \ may occur once Step 3 completes.\n   The algorithm for Sending a Packet is as\
    \ follows:\n   1. Generate the RTP header for the new packet.  See Section 2.1\
    \ of\n      [RFC4695] for details.\n   2. Generate the MIDI command section for\
    \ the new packet.  See Section\n      3 of [RFC4695] for details.\n   3. Generate\
    \ the recovery journal for the new packet.  We discuss this\n      process in\
    \ Section 5.2.  The generation algorithm examines the\n      Recovery Journal\
    \ Sending Structure (RJSS), a stateful coding of a\n      history of the stream.\n\
    \   4. Send the new packet to the receiver.\n   5. Update the RJSS to include\
    \ the data coded in the MIDI command\n      section of the packet sent in step\
    \ 4.  We discuss the update\n      procedure in Section 5.3.\n             Figure\
    \ 8. A 5 step algorithm for sending a packet\n   In the sections that follow,\
    \ we discuss specific sender\n   implementation issues in detail.\n"
- title: 4.1.  Queuing and Coding Incoming MIDI Data
  contents:
  - "4.1.  Queuing and Coding Incoming MIDI Data\n   Simple senders transmit a new\
    \ packet as soon as the local player\n   generates a complete MIDI command.  The\
    \ system described in [NMP]\n   uses this algorithm.  This algorithm minimizes\
    \ the sender queuing\n   latency, as the sender never delays the transmission\
    \ of a new MIDI\n   command.\n   In a relative sense, this algorithm uses bandwidth\
    \ inefficiently, as\n   it does not amortize the overhead of a packet over several\
    \ commands.\n   This inefficiency may be acceptable for sparse MIDI streams (see\n\
    \   Appendix A.4 of [NMP]).  More sophisticated sending algorithms\n   [GRAME]\
    \ improve efficiency by coding small groups of commands into a\n   single packet,\
    \ at the expense of increasing the sender queuing\n   latency.\n   Senders assign\
    \ a timestamp value to each command issued by the local\n   player (Appendix C.3\
    \ of [RFC4695]).  Senders may code the timestamp\n   value of the first MIDI list\
    \ command in two ways.  The most efficient\n   method is to set the RTP timestamp\
    \ of the packet to the timestamp\n   value of the first command.  In this method,\
    \ the Z bit of the MIDI\n   command section header (Figure 2 of [RFC4695]) is\
    \ set to 0, and the\n   RTP timestamps increment at a non-uniform rate.\n   However,\
    \ in some applications, senders may wish to generate a stream\n   whose RTP timestamps\
    \ increment at a uniform rate.  To do so, senders\n   may use the Delta Time MIDI\
    \ list field to code a timestamp for the\n   first command in the list.  In this\
    \ case, the Z bit of the MIDI\n   command section header is set to 1.\n   Senders\
    \ should strive to maintain a constant relationship between the\n   RTP packet\
    \ timestamp and the packet sending time: if two packets have\n   RTP timestamps\
    \ that differ by 1 second, the second packet should be\n   sent 1 second after\
    \ the first packet.  To the receiver, variance in\n   this relationship is indistinguishable\
    \ from network jitter.  Latency\n   issues are discussed in detail in Section\
    \ 6.\n   Senders may alter the running status coding of the first command in\n\
    \   the MIDI list, in order to comply with the coding rules defined in\n   Section\
    \ 3.2 of [RFC4695].  The P header bit (Figure 2 of [RFC4695])\n   codes this alteration\
    \ of the source command stream.\n"
- title: 4.2.  Sending Packets with Empty MIDI Lists
  contents:
  - "4.2.  Sending Packets with Empty MIDI Lists\n   During a session, musicians might\
    \ refrain from generating MIDI data\n   for extended periods of time (seconds\
    \ or even minutes).  If an RTP\n   stream followed the dynamics of a silent MIDI\
    \ source and stopped\n   sending RTP packets, system behavior might be degraded\
    \ in the\n   following ways:\n   o  The receiver's model of network performance\
    \ may fall out of date.\n   o  Network middleboxes (such as Network Address Translators)\
    \ may\n      \"time-out\" the silent stream and drop the port and IP association\n\
    \      state.\n   o  If the session does not use RTCP, receivers may misinterpret\
    \ the\n      silent stream as a dropped network connection.\n   Senders avoid\
    \ these problems by sending \"keep-alive\" RTP packets\n   during periods of network\
    \ inactivity.  Keep-alive packets have empty\n   MIDI lists.\n   Session participants\
    \ may specify the frequency of keep-alive packets\n   during session configuration\
    \ with the MIME parameter \"guardtime\"\n   (Appendix C.4.2 of [RFC4695]).  The\
    \ session descriptions shown in\n   Figures 1-2 use guardtime to specify a keep-alive\
    \ sending interval of\n   1 second.\n   Senders may also send empty packets to\
    \ improve the performance of the\n   recovery journal system.  As we describe\
    \ in Section 6, the recovery\n   process begins when a receiver detects a break\
    \ in the RTP sequence\n   number pattern of the stream.  The receiver uses the\
    \ recovery journal\n   of the break packet to guide corrective rendering actions,\
    \ such as\n   ending stuck notes and updating out-of-date controller values.\n\
    \   Consider the situation where the local player produces a MIDI NoteOff\n  \
    \ command (which the sender promptly transmits in a packet) but then 5\n   seconds\
    \ pass before the player produces another MIDI command (which\n   the sender transmits\
    \ in a second packet).  If the packet coding the\n   NoteOff is lost, the receiver\
    \ is not aware of the packet loss\n   incident for 5 seconds, and the rendered\
    \ MIDI performance contains a\n   note that sounds for 5 seconds too long.\n \
    \  To handle this situation, senders may transmit empty packets to\n   \"guard\"\
    \ the stream during silent sections.  The guard packet\n   algorithm defined in\
    \ Section 7.3 of [NMP], as applied to the\n   situation described above, sends\
    \ a guard packet after 100 ms of\n   player inactivity, and sends a second guard\
    \ packet 100 ms later.\n   Subsequent guard packets are sent with an exponential\
    \ backoff, with a\n   limiting period of 1 second (set by the \"guardtime\" parameter\
    \ in\n   Figures 1-2).  The algorithm terminates once MIDI activity resumes,\n\
    \   or once RTCP receiver reports indicate that the receiver is up to\n   date.\n\
    \   The perceptual quality of guard packet-sending algorithms is a\n   quality\
    \ of implementation issue for RTP MIDI applications.\n   Sophisticated implementations\
    \ may tailor the guard packet sending\n   rate to the nature of the MIDI commands\
    \ recently sent in the stream,\n   to minimize the perceptual impact of moderate\
    \ packet loss.\n   As an example of this sort of specialization, the guard packet\n\
    \   algorithm described in [NMP] protects against the transient artifacts\n  \
    \ that occur when NoteOn commands are lost.  The algorithm sends a\n   guard packet\
    \ 1 ms after every packet whose MIDI list contains a\n   NoteOn command.  The\
    \ Y bit in Chapter N note logs (Appendix A.6 of\n   [RFC4695]) supports this use\
    \ of guard packets.\n   Congestion control and bandwidth management are key issues\
    \ in guard\n   packet algorithms.  We discuss these issues in the next section.\n"
- title: 4.3.  Congestion Control and Bandwidth Management
  contents:
  - "4.3.  Congestion Control and Bandwidth Management\n   The congestion control\
    \ section of [RFC4695] discusses the importance\n   of congestion control for\
    \ RTP MIDI streams and references the\n   normative text in [RFC3550] and [RFC3551]\
    \ that concerns congestion\n   control.  To comply with the requirements described\
    \ in those\n   normative documents, RTP MIDI senders may use several methods to\n\
    \   control the sending rate:\n   o  As described in Section 4.1, senders may\
    \ pack several MIDI\n      commands into a single packet, thereby reducing stream\
    \ bandwidth\n      (at the expense of increasing sender queuing latency).\n  \
    \ o  Guard packet algorithms (Section 4.2) may be designed in a\n      parametric\
    \ way, so that the tradeoff between artifact reduction\n      and stream bandwidth\
    \ may be tuned dynamically.\n   o  The recovery journal size may be reduced by\
    \ adapting the\n      techniques described in Section 5 of this memo.  Note that\
    \ in all\n      cases, the recovery journal sender must conform to the normative\n\
    \      text in Section 4 of [RFC4695].\n   o  The incoming MIDI stream may be\
    \ modified to reduce the number of\n      MIDI commands without significantly\
    \ altering the performance.\n      Lossy \"MIDI filtering\" algorithms are well\
    \ developed in the MIDI\n      community and may be directly applied to RTP MIDI\
    \ rate management.\n   RTP MIDI senders incorporate these rate control methods\
    \ into feedback\n   systems to implement congestion control and bandwidth management.\n\
    \   Sections 10 and 6.4.4 of [RFC3550] and Section 2 in [RFC3551]\n   describe\
    \ feedback systems for congestion control in RTP, and Section\n   6 of [RFC4566]\
    \ describes bandwidth management in media sessions.\n"
- title: '5.  Sending Streams: The Recovery Journal'
  contents:
  - "5.  Sending Streams: The Recovery Journal\n   In this section, we describe how\
    \ senders implement the recovery\n   journal system.  The implementation we describe\
    \ uses the default\n   \"closed-loop\" recovery journal semantics (Appendix C.2.2.2\
    \ of\n   [RFC4695]).\n   We begin by describing the Recovery Journal Sending Structure\
    \ (RJSS).\n   Senders use the RJSS to generate the recovery journal section for\
    \ RTP\n   MIDI packets.\n   The RJSS is a hierarchical representation of the checkpoint\
    \ history\n   of the stream.  The checkpoint history holds the MIDI commands that\n\
    \   are at risk to packet loss (Appendix A.1 of [RFC4695] precisely\n   defines\
    \ the checkpoint history).  The layout of the RJSS mirrors the\n   hierarchical\
    \ structure of the recovery journal bitfields.\n   Figure 9 shows an RJSS implementation\
    \ for a simple sender.  The leaf\n   level of the RJSS hierarchy (the jsend_chapter\
    \ structures)\n   corresponds to channel chapters (Appendices A.2-9 in [RFC4695]).\
    \  The\n   second level of the hierarchy (jsend_channel) corresponds to the\n\
    \   channel journal header (Figure 9 in [RFC4695]).  The top level of the\n  \
    \ hierarchy (jsend_journal) corresponds to the recovery journal header\n   (Figure\
    \ 8 in [RFC4695]).\n   Each RJSS data structure may code several items:\n   1.\
    \ The current contents of the recovery journal bitfield associated\n      with\
    \ the RJSS structure (jheader[], cheader[], or a chapter\n      bitfield).\n \
    \  2. A seqnum variable.  Seqnum codes the extended RTP sequence number\n    \
    \  of the most recent packet that added information to the RJSS\n      structure.\
    \  If the seqnum of a structure is updated, the seqnums\n      of all structures\
    \ above it in the recovery journal hierarchy are\n      also updated.  Thus, a\
    \ packet that caused an update to a specific\n      jsend_chapter structure would\
    \ update the seqnum values of this\n      structure and of the jsend_channel and\
    \ jsend_journal structures\n      that contain it.\n   3. Ancillary variables\
    \ used by the sending algorithm.\n   A seqnum variable for a level is set to zero\
    \ if the checkpoint\n   history contains no information at the level of the seqnum\
    \ variable,\n   and no information at any level below the level of the seqnum\n\
    \   variable.  This coding scheme assumes that the first sequence number\n   of\
    \ a stream is normalized to 1, and limits the total number of stream\n   packets\
    \ to 2^32 - 1.\n   The cm_unused and ch_never parameters in Figures 1-2 define\
    \ the\n   subset of MIDI commands supported by the sender (see Appendix C.2.3\n\
    \   of [RFC4695] for details).  The sender transmits most voice commands\n   but\
    \ does not transmit system commands.  The sender assumes that the\n   MIDI source\
    \ uses note commands in the typical way.  Thus, the sender\n   does not use the\
    \ Chapter E note resiliency tools (Appendix A.7 of\n   [RFC4695]).  The sender\
    \ does not support Control Change commands for\n   controller numbers with All\
    \ Notes Off (123-127), All Sound Off (120),\n   and Reset All Controllers (121)\
    \ semantics and does not support\n   enhanced Chapter C encoding (Appendix A.3.3\
    \ of [RFC4695]).\n   We chose this subset of MIDI commands to simplify the example.\
    \  In\n   particular, the command restrictions ensure that all commands are\n\
    \   active, that all note commands are N-active, and that all Control\n   Change\
    \ commands are C-active (see Appendix A.1 of [RFC4695] for\n   definitions of\
    \ active, N-active, and C-active).\n   In the sections that follow, we describe\
    \ the tasks a sender performs\n   to manage the recovery journal system.\n"
- title: 5.1.  Initializing the RJSS
  contents:
  - "5.1.  Initializing the RJSS\n   At the start of a stream, the sender initializes\
    \ the RJSS.  All\n   seqnum variables are set to zero, including all elements\
    \ of\n   note_seqnum[] and control_seqnum[].\n   The sender initializes jheader[]\
    \ to form a recovery journal header\n   that codes an empty journal.  The S bit\
    \ of the header is set to 1,\n   and the A, Y, R, and TOTCHAN header fields are\
    \ set to zero.  The\n   checkpoint packet sequence number field is set to the\
    \ sequence number\n   of the upcoming first RTP packet (per Appendix A.1 of [RFC4695]).\n\
    \     typedef unsigned char  uint8;      /* must be 1 octet  */\n     typedef\
    \ unsigned short uint16;     /* must be 2 octet  */\n     typedef unsigned long\
    \  uint32;     /* must be 4 octets */\n     /**************************************************************/\n\
    \     /* leaf level hierarchy: Chapter W, Appendix A.5 of [RFC4695] */\n     /**************************************************************/\n\
    \     typedef struct jsend_chapterw {  /* Pitch Wheel (0xE) */\n      uint8  chapterw[2];\
    \ /* bitfield Figure A.5.1 [RFC4695] */\n      uint32 seqnum;      /* extended\
    \ sequence number, or 0 */\n     } jsend_chapterw;\n     /**************************************************************/\n\
    \     /* leaf level hierarchy: Chapter N, Appendix A.6 of [RFC4695] */\n     /**************************************************************/\n\
    \     typedef struct jsend_chaptern { /* Note commands (0x8, 0x9) */\n      /*\
    \ chapter N maximum size is 274 octets: a 2 octet header, */\n      /* and a maximum\
    \ of 128 2-octet logs and 16 OFFBIT octets  */\n      uint8  chaptern[274];  \
    \   /* bitfield Figure A.6.1 [RFC4695] */\n      uint16 size;              /*\
    \ actual size of chaptern[]     */\n      uint32 seqnum;            /* extended\
    \ seq number, or 0     */\n      uint32 note_seqnum[128];  /* most recent note\
    \ seqnum, or 0 */\n      uint32 note_tstamp[128];  /* NoteOn execution timestamp\
    \    */\n      uint32 bitfield_ptr[128]; /* points to a chapter log, or 0 */\n\
    \     } jsend_chaptern;\n     /**************************************************************/\n\
    \     /* leaf level hierarchy: Chapter C, Appendix A.3 of [RFC4695] */\n     /**************************************************************/\n\
    \     typedef struct jsend_chapterc {     /* Control Change (0xB) */\n      /*\
    \ chapter C maximum size is 257 octets: a 1 octet header */\n      /* and a maximum\
    \ of 128 2-octet logs                      */\n      uint8  chapterc[257];   \
    \ /* bitfield Figure A.3.1 [RFC4695] */\n      uint16 size;             /* actual\
    \ size of chapterc[]      */\n      uint32 seqnum;           /* extended sequence\
    \ number, or 0 */\n      uint32 control_seqnum[128]; /* most recent seqnum, or\
    \ 0    */\n      uint32 bitfield_ptr[128]; /* points to a chapter log, or 0 */\n\
    \     } jsend_chapterc;\n         Figure 9. Recovery Journal Sending Structure\
    \ (part 1)\n     /**************************************************************/\n\
    \     /* leaf level hierarchy: Chapter P, Appendix A.2 of [RFC4695] */\n     /**************************************************************/\n\
    \     typedef struct jsend_chapterp { /* MIDI Program Change (0xC) */\n      uint8\
    \  chapterp[3]; /* bitfield Figure A.2.1 [RFC4695] */\n      uint32 seqnum;  \
    \    /* extended sequence number, or 0 */\n     } jsend_chapterp;\n     /***************************************************/\n\
    \     /* second-level of hierarchy, for channel journals */\n     /***************************************************/\n\
    \     typedef struct jsend_channel {\n      uint8  cheader[3]; /* header Figure\
    \ 9 [RFC4695]) */\n      uint32 seqnum;     /* extended sequence number, or 0\
    \  */\n      jsend_chapterp chapterp;           /* chapter P info  */\n      jsend_chapterc\
    \ chapterc;           /* chapter C info  */\n      jsend_chapterw chapterw;  \
    \         /* chapter W info  */\n      jsend_chaptern chaptern;           /* chapter\
    \ N info  */\n     } jsend_channel;\n     /*******************************************************/\n\
    \     /* top level of hierarchy, for recovery journal header */\n     /*******************************************************/\n\
    \      typedef struct jsend_journal {\n      uint8 jheader[3]; /* header Figure\
    \ 8, [RFC4695] */\n                        /* Note: Empty journal has a header\
    \ */\n      uint32 seqnum;    /* extended sequence number, or 0   */\n       \
    \                 /* seqnum = 0 codes empty journal   */\n      jsend_channel\
    \ channels[16];  /* channel journal state */\n                               \
    \    /* index is MIDI channel */\n      } jsend_journal;\n       Figure 9. Recovery\
    \ Journal Sending Structure (part 2)\n   In jsend_chaptern, elements of note_tstamp[]\
    \ are set to zero.  In\n   jsend_chaptern and jsend_chapterc, elements of bitfield_ptr[]\
    \ are set\n   to the null pointer index value (bitfield_ptr[] is an array whose\n\
    \   elements point to the first octet of the note or control log\n   associated\
    \ with the array index).\n"
- title: 5.2.  Traversing the RJSS
  contents:
  - "5.2.  Traversing the RJSS\n   Whenever an RTP packet is created (Step 3 of the\
    \ algorithm defined in\n   Figure 8), the sender traverses the RJSS to create\
    \ the recovery\n   journal for the packet.  The traversal begins at the top level\
    \ of the\n   RJSS.  The sender copies jheader[] into the packet and then sets\
    \ the\n   S bit of jheader[] to 1.\n   The traversal continues depth-first, visiting\
    \ every jsend_channel\n   whose seqnum variable is non-zero.  The sender copies\
    \ the cheader[]\n   array into the packet and then sets the S bit of cheader[]\
    \ to 1.\n   After each cheader[] copy, the sender visits each leaf-level chapter,\n\
    \   in the order of its appearance in the chapter journal Table of\n   Contents\
    \ (first P, then C, then W, then N, as shown in Figure 9 of\n   [RFC4695]).\n\
    \   If a chapter has a non-zero seqnum, the sender copies the chapter\n   bitfield\
    \ array into the packet and then sets the S bit of the RJSS\n   array to 1.  For\
    \ chaptern[], the B bit is also set to 1.  For the\n   variable-length chapters\
    \ (chaptern[] and chapterc[]), the sender\n   checks the size variable to determine\
    \ the bitfield length.\n   Before copying chaptern[], the sender updates the Y\
    \ bit of each note\n   log to code the onset of the associated NoteOn command\
    \ (Figure A.6.3\n   in [RFC4695]).  To determine the Y bit value, the sender checks\
    \ the\n   note_tstamp[] array for note timing information.\n"
- title: 5.3.  Updating the RJSS
  contents:
  - "5.3.  Updating the RJSS\n   After an RTP packet is sent, the sender updates the\
    \ RJSS to refresh\n   the checkpoint history (Step 5 of the sending algorithm\
    \ defined in\n   Figure 8).  For each command in the MIDI list of the sent packet,\
    \ the\n   sender performs the update procedure we now describe.\n   The update\
    \ procedure begins at the leaf level.  The sender generates\n   a new bitfield\
    \ array for the chapter associated with the MIDI command\n   using the chapter-specific\
    \ semantics defined in Appendix A of\n   [RFC4695].\n   For Chapter N and Chapter\
    \ C, the sender uses the bitfield_ptr[] array\n   to locate and update an existing\
    \ log for a note or controller.  If a\n   log does not exist, the sender adds\
    \ a log to the end of the\n   chaptern[] or chapterc[] bitfield and changes the\
    \ bitfield_ptr[]\n   value to point to the log.  For Chapter N, the sender also\
    \ updates\n   note_tstamp[].\n   The sender also clears the S bit of the chapterp[],\
    \ chapterw[], or\n   chapterc[] bitfield.  For chaptern[], the sender clears the\
    \ S bit or\n   the B bit of the bitfield, as described in Appendix A.6 of [RFC4695].\n\
    \   Next, the sender refreshes the upper levels of the RJSS hierarchy.\n   At\
    \ the second level, the sender updates the cheader[] bitfield of the\n   channel\
    \ associated with the command.  The sender sets the S bit of\n   cheader[] to\
    \ 0.  If the new command forced the addition of a new\n   chapter or channel journal,\
    \ the sender may also update other\n   cheader[] fields.  At the top level, the\
    \ sender updates the top-level\n   jheader[] bitfield in a similar manner.\n \
    \  Finally, the sender updates the seqnum variables associated with the\n   changed\
    \ bitfield arrays.  The sender sets the seqnum variables to the\n   extended sequence\
    \ number of the packet.\n"
- title: 5.4.  Trimming the RJSS
  contents:
  - "5.4.  Trimming the RJSS\n   At regular intervals, receivers send RTCP receiver\
    \ reports to the\n   sender (as described in Section 6.4.2 of [RFC3550]).  These\
    \ reports\n   include the extended highest sequence number received (EHSNR) field.\n\
    \   This field codes the highest sequence number that the receiver has\n   observed\
    \ from the sender, extended to disambiguate sequence number\n   rollover.\n  \
    \ When the sender receives an RTCP receiver report, it runs the RJSS\n   trimming\
    \ algorithm.  The trimming algorithm uses the EHSNR to trim\n   away parts of\
    \ the RJSS.  In this way, the algorithm reduces the size\n   of recovery journals\
    \ sent in subsequent RTP packets.  The algorithm\n   conforms to the closed-loop\
    \ sending policy defined in Appendix\n   C.2.2.2 of [RFC4695].\n   The trimming\
    \ algorithm relies on the following observation: if the\n   EHSNR indicates that\
    \ a packet with sequence number K has been\n   received, MIDI commands sent in\
    \ packets with sequence numbers J <= K\n   may be removed from the RJSS without\
    \ violating the closed-loop\n   policy.\n   To begin the trimming algorithm, the\
    \ sender extracts the EHSNR field\n   from the receiver report and adjusts the\
    \ EHSNR to reflect the\n   sequence number extension prefix of the sender.  Then,\
    \ the sender\n   compares the adjusted EHSNR value with seqnum fields at each\
    \ level of\n   the RJSS, starting at the top level.\n   Levels whose seqnum is\
    \ less than or equal to the adjusted EHSNR are\n   trimmed, by setting the seqnum\
    \ to zero.  If necessary, the jheader[]\n   and cheader[] arrays above the trimmed\
    \ level are adjusted to match\n   the new journal layout.  The checkpoint packet\
    \ sequence number field\n   of jheader[] is updated to match the EHSNR.\n   At\
    \ the leaf level, the sender trims the size of the variable-length\n   chaptern[]\
    \ and chapterc[] bitfields.  The sender loops through the\n   note_seqnum[] or\
    \ control_seqnum[] array and removes chaptern[] or\n   chapterc[] logs whose seqnum\
    \ value is less than or equal to the\n   adjusted EHSNR.  The sender sets the\
    \ associated bitfield_ptr[] to\n   null and updates the LENGTH field of the associated\
    \ cheader[]\n   bitfield.\n   Note that the trimming algorithm does not add information\
    \ to the\n   checkpoint history.  As a consequence, the trimming algorithm does\n\
    \   not clear the S bit (and for chaptern[], the B bit) of any recovery\n   journal\
    \ bitfield.  As a second consequence, the trimming algorithm\n   does not set\
    \ RJSS seqnum variables to the EHSNR value.\n"
- title: 5.5.  Implementation Notes
  contents:
  - "5.5.  Implementation Notes\n   For pedagogical purposes, the recovery journal\
    \ sender we describe has\n   been simplified in several ways.  In practice, an\
    \ implementation\n   would use enhanced versions of the traversing, updating,\
    \ and trimming\n   algorithms presented in Sections 5.2-5.4.\n"
- title: '6.  Receiving Streams: General Considerations'
  contents:
  - "6.  Receiving Streams: General Considerations\n   In this section, we discuss\
    \ receiver implementation issues.\n   To begin, we imagine that an ideal network\
    \ carries the RTP stream.\n   Packets are never lost or reordered, and the end-to-end\
    \ latency is\n   constant.  In addition, we assume that all commands coded in\
    \ the MIDI\n   list of a packet share the same timestamp (an assumption coded\
    \ by the\n   \"rtp_ptime\" and \"rtp_maxptime\" values in Figures 1-2; see Appendix\n\
    \   C.4.1 of [RFC4695] for details).\n   Under these conditions, a simple algorithm\
    \ may be used to render a\n   high-quality performance.  Upon receipt of an RTP\
    \ packet, the\n   receiver immediately executes the commands coded in the MIDI\
    \ command\n   section of the payload.  Commands are executed in the order of their\n\
    \   appearance in the MIDI list.  The command timestamps are ignored.\n   Unfortunately,\
    \ this simple algorithm breaks down once we relax our\n   assumptions about the\
    \ network and the MIDI list:\n   1. If we permit lost and reordered packets to\
    \ occur in the network,\n      the algorithm may produce unrecoverable rendering\
    \ artifacts,\n      violating the mandate defined in Section 4 of [RFC4695].\n\
    \   2. If we permit the network to exhibit variable latency, the\n      algorithm\
    \ modulates the network jitter onto the rendered MIDI\n      command stream.\n\
    \   3. If we permit a MIDI list to code commands with different\n      timestamps,\
    \ the algorithm adds temporal jitter to the rendered\n      performance, as it\
    \ ignores MIDI list timestamps.\n   In this section, we discuss interactive receiver\
    \ design techniques\n   under these relaxed assumptions.  Section 6.1 describes\
    \ a receiver\n   design for high-performance Wide Area Networks (WANs), and Section\n\
    \   6.2 discusses design issues for other types of networks.\n"
- title: 6.1.  The NMP Receiver Design
  contents:
  - "6.1.  The NMP Receiver Design\n   The Network Musical Performance (NMP) system\
    \ [NMP] is an interactive\n   performance application that uses an early version\
    \ of the RTP MIDI\n   payload format.  NMP is designed for use between universities\
    \ within\n   the State of California, which use the high-performance CalREN2\n\
    \   network.\n   In the NMP system, network artifacts may affect how a musician\
    \ hears\n   the performances of remote players.  However, the network does not\n\
    \   affect how a musician hears his own performance.\n   Several aspects of CalREN2\
    \ network behavior (as measured in 2001\n   timeframe, as documented in [NMP])\
    \ guided the NMP system design:\n   o  The median symmetric latency (1/2 the round-trip\
    \ time) of packets\n      sent between network sites is comparable to the acoustic\
    \ latency\n      between two musicians located in the same room.  For example,\
    \ the\n      latency between Berkeley and Stanford is 2.1 ms, corresponding to\n\
    \      an acoustic distance of 2.4 feet (0.72 meters).  These campuses\n     \
    \ are 40 miles (64 km) apart.  Preserving the benefits of the\n      underlying\
    \ network latency at the application level was a key NMP\n      design goal.\n\
    \   o  For most times of day, the nominal temporal jitter is quite short.\n  \
    \    For Berkeley-Stanford, the standard deviation of the round-trip\n      time\
    \ was under 200 microseconds.\n   o  For most times of day, a few percent (0-4%)\
    \ of the packets sent\n      arrive significantly late (> 40 ms), probably due\
    \ to a queuing\n      transient somewhere in the network path.  More rarely (<\
    \ 0.1%), a\n      packet is lost during the transient.\n   o  At predictable times\
    \ during the day (before lunchtime, at the end\n      of the workday, etc.), network\
    \ performance deteriorates (10-20%\n      late packets) in a manner that makes\
    \ the network unsuitable for\n      low-latency interactive use.\n   o  CalREN2\
    \ has deeply over-provisioned bandwidth, relative to MIDI\n      bandwidth usage.\n\
    \   The NMP sender freely uses network bandwidth to improve the\n   performance\
    \ experience.  As soon as a musician generates a MIDI\n   command, an RTP packet\
    \ coding the command is sent to the other\n   players.  This sending algorithm\
    \ reduces latency at the cost of\n   bandwidth.  In addition, guard packets (described\
    \ in Section 4.2) are\n   sent at frequent intervals to minimize the impact of\
    \ packet loss.\n   The NMP receiver maintains a model of the stream and uses this\
    \ model\n   as the basis of its resiliency system.  Upon receipt of a packet,\
    \ the\n   receiver predicts the RTP sequence number and the RTP timestamp (with\n\
    \   error bars) of the packet.  Under normal network conditions, about\n   95%\
    \ of received packets fit the predictions [NMP].  In this common\n   case, the\
    \ receiver immediately executes the MIDI command coded in the\n   packet.\n  \
    \ Note that the NMP receiver does not use a playout buffer; the design\n   is\
    \ optimized for lowest latency at the expense of command jitter.\n   Thus, the\
    \ NMP receiver design does not completely satisfy the\n   interoperability text\
    \ in Appendix C.7.2 of [RFC4695], which requires\n   that receivers in network\
    \ musical performance applications be capable\n   of using a playout buffer.\n\
    \   Occasionally, an incoming packet fits the sequence number prediction,\n  \
    \ but falls outside the timestamp prediction error bars (see Appendix B\n   of\
    \ [NMP] for timestamp model details).  In most cases, the receiver\n   still executes\
    \ the command coded in the packet.  However, the\n   receiver discards NoteOn\
    \ commands with non-zero velocity.  By\n   discarding late commands that sound\
    \ notes, the receiver prevents\n   \"straggler notes\" from disturbing a performance.\
    \  By executing all\n   other late commands, the receiver quiets \"soft stuck\
    \ notes\"\n   immediately and updates the state of the MIDI system.\n   More rarely,\
    \ an incoming packet does not fit the sequence number\n   prediction.  The receiver\
    \ keeps track of the highest sequence number\n   received in the stream and predicts\
    \ that an incoming packet will have\n   a sequence number one greater than this\
    \ value.  If the sequence\n   number of an incoming packet is greater than the\
    \ prediction, a packet\n   loss has occurred.  If the sequence number of the received\
    \ packet is\n   less than the prediction, the packet has been received out of\
    \ order.\n   All sequence number calculations are modulo 2^16 and use standard\n\
    \   methods (described in [RFC3550]) to avoid tracking errors during\n   rollover.\n\
    \   If a packet loss has occurred, the receiver examines the journal\n   section\
    \ of the received packet and uses it to gracefully recover from\n   the loss episode.\
    \  We describe this recovery procedure in Section 7\n   of this memo.  The recovery\
    \ process may result in the execution of\n   one or more MIDI commands.  After\
    \ executing the recovery commands,\n   the receiver processes the MIDI command\
    \ encoded in the packet using\n   the timestamp model test described above.\n\
    \   If a packet is received out of order, the receiver ignores the\n   packet.\
    \  The receiver takes this action because a packet received out\n   of order is\
    \ always preceded by a packet that signalled a loss event.\n   This loss event\
    \ triggered the recovery process, which may have\n   executed recovery commands.\
    \  The MIDI command coded in the out-of-\n   order packet might, if executed,\
    \ duplicate these recovery commands,\n   and this duplication might endanger the\
    \ integrity of the stream.\n   Thus, ignoring the out-of-order packet is the safe\
    \ approach.\n"
- title: 6.2.  High-Jitter Networks, Local Area Networks
  contents:
  - "6.2.  High-Jitter Networks, Local Area Networks\n   The NMP receiver targets\
    \ a network with a particular set of\n   characteristics: low nominal jitter,\
    \ low packet loss, and occasional\n   outlier packets that arrive very late. \
    \ In this section, we consider\n   how networks with different characteristics\
    \ impact receiver design.\n   Networks with significant nominal jitter cannot\
    \ use the buffer-free\n   receiver design described in Section 6.1.  For example,\
    \ the NMP\n   system performs poorly for musicians that use dial-up modem\n  \
    \ connections, because the buffer-free receiver design modulates modem\n   jitter\
    \ onto the performances.  Receivers designed for high-jitter\n   networks should\
    \ use a substantial playout buffer.  References [GRAME]\n   and [CCRMA] describe\
    \ how to use playout buffers in latency-critical\n   applications.\n   Receivers\
    \ intended for use on Local Area Networks (LANs) face a\n   different set of issues.\
    \  A dedicated LAN fabric built with modern\n   hardware is in many ways a predictable\
    \ environment.  The network\n   problems addressed by the NMP receiver design\
    \ (packet loss and\n   outlier late packets) might only occur under extreme network\
    \ overload\n   conditions.\n   Systems designed for this environment may choose\
    \ to configure streams\n   without the recovery journal system (Appendix C.2.1\
    \ of [RFC4695]).\n   Receivers may also wish to forego or simplify the detection\
    \ of\n   outlier late packets.  Receivers should monitor the RTP sequence\n  \
    \ numbers of incoming packets to detect network unreliability.\n   However, in\
    \ some respects, LAN applications may be more demanding\n   than WAN applications.\
    \  In LAN applications, musicians may be\n   receiving performance feedback from\
    \ audio that is rendered from the\n   stream.  The tolerance a musician has for\
    \ latency and jitter in this\n   context may be quite low.\n   To reduce the perceived\
    \ jitter, receivers may use a small playout\n   buffer (in the range of 100us\
    \ to 2ms).  The buffer adds a small\n   amount of latency to the system, which\
    \ may be annoying to some\n   players.  Receiver designs should include buffer\
    \ tuning parameters to\n   let musicians adjust the tradeoff between latency and\
    \ jitter.\n"
- title: '7.  Receiving Streams: The Recovery Journal'
  contents:
  - "7.  Receiving Streams: The Recovery Journal\n   In this section, we describe\
    \ the recovery algorithm used by the NMP\n   receiver [NMP].  In most ways, the\
    \ recovery techniques we describe\n   are generally applicable to interactive\
    \ receiver design.  However, a\n   few aspects of the design are specialized for\
    \ the NMP system:\n   o  The recovery algorithm covers a subset of the MIDI command\
    \ set.\n      MIDI Systems (0xF), Poly Aftertouch (0xA), and Channel Aftertouch\n\
    \      (0xD) commands are not protected, and Control Change (0xB) command\n  \
    \    protection is simplified.  Note commands for a particular note\n      number\
    \ are assumed to follow the typical NoteOn->NoteOff->NoteOn\n      ->NoteOff pattern.\
    \  The cm_unused and ch_never parameters in\n      Figures 1-2 specify this coverage.\n\
    \   o  The NMP system does not use a playout buffer.  Therefore, the\n      recovery\
    \ algorithm does not address interactions with a playout\n      buffer.\n   At\
    \ a high level, the receiver algorithm works as follows.  Upon\n   detection of\
    \ a packet loss, the receiver examines the recovery\n   journal of the packet\
    \ that ends the loss event.  If necessary, the\n   receiver executes one or more\
    \ MIDI commands to recover from the loss.\n   To prepare for recovery, a receiver\
    \ maintains a data structure, the\n   Recovery Journal Receiver Structure (RJRS).\
    \  The RJRS codes\n   information about the MIDI commands the receiver executes\
    \ (both\n   incoming stream commands and self-generated recovery commands).  At\n\
    \   the start of the stream, the RJRS is initialized to code that no\n   commands\
    \ have been executed.  Immediately after executing a MIDI\n   command, the receiver\
    \ updates the RJRS with information about the\n   command.\n   We now describe\
    \ the recovery algorithm in detail.  We begin with two\n   definitions that classify\
    \ loss events.  These definitions assume that\n   the packet that ends the loss\
    \ event has RTP sequence number I.\n   o  Single-packet loss.  A single-packet\
    \ loss occurs if the last\n      packet received before the loss event (excluding\
    \ out-of-order\n      packets) has the sequence number I-2 (modulo 2^16).\n  \
    \ o  Multi-packet loss.  A multi-packet loss occurs if the last packet\n     \
    \ received before the loss event (excluding out-of-order packets)\n      has a\
    \ sequence number less than I-2 (modulo 2^16).\n   Upon detection of a packet\
    \ loss, the recovery algorithm examines the\n   recovery journal header (Figure\
    \ 8 of [RFC4695]) to check for special\n   cases:\n   o  If the header field A\
    \ is 0, the recovery journal has no channel\n      journals, so no action is taken.\n\
    \   o  If a single-packet loss has occurred, and if the header S bit is\n    \
    \  1, the lost packet has a MIDI command section with an empty MIDI\n      list.\
    \  No action is taken.\n   If these checks fail, the algorithm parses the recovery\
    \ journal body.\n   For each channel journal (Figure 9 in [RFC4695]) in the recovery\n\
    \   journal, the receiver compares the data in each chapter journal\n   (Appendix\
    \ A of [RFC4695]) to the RJRS data for the chapter.  If the\n   data are inconsistent,\
    \ the algorithm infers that MIDI commands\n   related to the chapter journal have\
    \ been lost.  The recovery\n   algorithm executes MIDI commands to repair this\
    \ loss and updates the\n   RJRS to reflect the repair.\n   For single-packet losses,\
    \ the receiver skips channel and chapter\n   journals whose S bits are set to\
    \ 1.  For multi-packet losses, the\n   receiver parses each channel and chapter\
    \ journal and checks for\n   inconsistency.\n   In the sections that follow, we\
    \ describe the recovery steps that are\n   specific to each chapter journal. \
    \ We cover 4 chapter journal types:\n   P (Program Change, 0xC), C (Control Change,\
    \ 0xB), W (Pitch Wheel,\n   0xE), and N (Note, 0x8 and 0x9).  Chapters are parsed\
    \ in the order of\n   their appearance in the channel journal (P, then W, then\
    \ N, then C).\n   The sections below reference the C implementation of the RJRS\
    \ shown\n   in Figure 10.  This structure is hierarchical, reflecting the\n  \
    \ recovery journal architecture.  At the leaf level, specialized data\n   structures\
    \ (jrec_chapterw, jrec_chaptern, jrec_chapterc, and\n   jrec_chapterp) code state\
    \ variables for a single chapter journal\n   type.  A mid-level structure (jrec_channel)\
    \ represents a single MIDI\n   channel, and a top-level structure (jrec_stream)\
    \ represents the\n   entire MIDI stream.\n     typedef unsigned char  uint8; \
    \      /* must be 1 octet  */\n     typedef unsigned short uint16;      /* must\
    \ be 2 octets */\n     typedef unsigned long  uint32;      /* must be 4 octets\
    \ */\n     /*****************************************************************/\n\
    \     /* leaf level of hierarchy: Chapter W, Appendix A.5 of [RFC4695] */\n  \
    \   /*****************************************************************/\n    \
    \ typedef struct jrec_chapterw {   /* MIDI Pitch Wheel (0xE) */\n      uint16\
    \ val;           /* most recent 14-bit wheel value   */\n     } jrec_chapterw;\n\
    \     /*****************************************************************/\n  \
    \   /* leaf level of hierarchy: Chapter N, Appendix A.6 of [RFC4695] */\n    \
    \ /*****************************************************************/\n     typedef\
    \ struct jrec_chaptern { /* Note commands (0x8, 0x9) */\n      /* arrays of length\
    \ 128 --> one for each MIDI Note number */\n      uint32 time[128];    /* exec\
    \ time of most recent NoteOn */\n      uint32 extseq[128];  /* extended seqnum\
    \ for that NoteOn */\n      uint8  vel[128];     /* NoteOn velocity (0 for NoteOff)\
    \ */\n     } jrec_chaptern;\n     /*****************************************************************/\n\
    \     /* leaf level of hierarchy: Chapter C, Appendix A.3 of [RFC4695] */\n  \
    \   /*****************************************************************/\n    \
    \ typedef struct jrec_chapterc {     /* Control Change (0xB) */\n      /* array\
    \ of length 128 --> one for each controller number */\n      uint8 value[128];\
    \   /* Chapter C value tool state */\n      uint8 count[128];   /* Chapter C count\
    \ tool state */\n      uint8 toggle[128];  /* Chapter C toggle tool state */\n\
    \     } jrec_chapterc;\n        Figure 10. Recovery Journal Receiving Structure\
    \ (part 1)\n     /*****************************************************************/\n\
    \     /* leaf level of hierarchy: Chapter P, Appendix A.2 of [RFC4695] */\n  \
    \   /*****************************************************************/\n    \
    \ typedef struct jrec_chapterp { /* MIDI Program Change (0xC) */\n      uint8\
    \ prognum;       /* most recent 7-bit program value  */\n      uint8 prognum_qual;\
    \  /* 1 once first 0xC command arrives */\n      uint8 bank_msb;     /* most recent\
    \ Bank Select MSB value */\n      uint8 bank_msb_qual;   /* 1 once first 0xBn\
    \ 0x00 arrives */\n      uint8 bank_lsb;     /* most recent Bank Select LSB value\
    \ */\n      uint8 bank_lsb_qual;   /* 1 once first 0xBn 0x20 arrives */\n    \
    \ } jrec_chapterp;\n     /***************************************************/\n\
    \     /* second-level of hierarchy, for MIDI channels    */\n     /***************************************************/\n\
    \     typedef struct jrec_channel {\n      jrec_chapterp chapterp;  /* Program\
    \ Change (0xC) info  */\n      jrec_chapterc chapterc;  /* Control Change (0xB)\
    \ info  */\n      jrec_chapterw chapterw;  /* Pitch Wheel (0xE) info  */\n   \
    \   jrec_chaptern chaptern;  /* Note (0x8, 0x9) info  */\n     } jrec_channel;\n\
    \     /***********************************************/\n     /* top level of\
    \ hierarchy, for the MIDI stream */\n     /***********************************************/\n\
    \      typedef struct jrec_stream {\n      jrec_channel channels[16];  /* index\
    \ is MIDI channel */\n      } jrec_stream;\n       Figure 10. Recovery Journal\
    \ Receiving Structure (part 2)\n"
- title: '7.1.  Chapter W: MIDI Pitch Wheel (0xE)'
  contents:
  - "7.1.  Chapter W: MIDI Pitch Wheel (0xE)\n   Chapter W of the recovery journal\
    \ protects against the loss of MIDI\n   Pitch Wheel (0xE) commands.  A common\
    \ use of the Pitch Wheel command\n   is to transmit the current position of a\
    \ rotary \"pitch wheel\"\n   controller placed on the side of MIDI piano controllers.\
    \  Players use\n   the pitch wheel to dynamically alter the pitch of all depressed\
    \ keys.\n   The NMP receiver maintains the jrec_chapterw structure (Figure 10)\n\
    \   for each voice channel in jrec_stream to code pitch wheel state\n   information.\
    \  In jrec_chapterw, val holds the 14-bit data value of\n   the most recent Pitch\
    \ Wheel command that has arrived on a channel.\n   At the start of the stream,\
    \ val is initialized to the default pitch\n   wheel value (0x2000).\n   At the\
    \ end of a loss event, a receiver may find a Chapter W (Appendix\n   A.5 in [RFC4695])\
    \ bitfield in a channel journal.  This chapter codes\n   the 14-bit data value\
    \ of the most recent MIDI Pitch Wheel command in\n   the checkpoint history. \
    \ If the Chapter W and jrec_chapterw pitch\n   wheel values do not match, one\
    \ or more commands have been lost.\n   To recover from this loss, the NMP receiver\
    \ immediately executes a\n   MIDI Pitch Wheel command on the channel, using the\
    \ data value coded\n   in the recovery journal.  The receiver then updates the\
    \ jrec_chapterw\n   variables to reflect the executed command.\n"
- title: '7.2.  Chapter N: MIDI NoteOn (0x8) and NoteOff (0x9)'
  contents:
  - "7.2.  Chapter N: MIDI NoteOn (0x8) and NoteOff (0x9)\n   Chapter N of the recovery\
    \ journal protects against the loss of MIDI\n   NoteOn (0x9) and NoteOff (0x8)\
    \ commands.  If a NoteOn command is\n   lost, a note is skipped.  If a NoteOff\
    \ command is lost, a note may\n   sound indefinitely.  Recall that NoteOn commands\
    \ with a velocity\n   value of 0 have the semantics of NoteOff commands.\n   The\
    \ recovery algorithms in this section only work for MIDI sources\n   that produce\
    \ NoteOn->NoteOff->NoteOn->NoteOff patterns for a note\n   number.  Piano keyboard\
    \ and drum pad controllers produce these\n   patterns.  MIDI sources that use\
    \ NoteOn->NoteOn->NoteOff->NoteOff\n   patterns for legato repeated notes, such\
    \ as guitar and wind\n   controllers, require more sophisticated recovery strategies.\
    \  Chapter\n   E (not used in this example) supports recovery algorithms for\n\
    \   atypical note command patterns (see Appendix A.7 of [RFC4695] for\n   details).\n\
    \   The NMP receiver maintains a jrec_chaptern structure (Figure 10) for\n   each\
    \ voice channel in jrec_stream to code note-related state\n   information.  State\
    \ is kept for each of the 128 note numbers on a\n   channel, using three arrays\
    \ of length 128 (vel[], seq[], and time[]).\n   The arrays are initialized to\
    \ zero at the start of a stream.\n   The vel[n] array element holds information\
    \ about the most recent note\n   command for note number n.  If this command is\
    \ a NoteOn command,\n   vel[n] holds the velocity data for the command.  If this\
    \ command is a\n   NoteOff command, vel[n] is set to 0.\n   The time[n] and extseq[n]\
    \ array elements code information about the\n   most recently executed NoteOn\
    \ command.  The time[n] element holds the\n   execution time of the command, referenced\
    \ to the local timebase of\n   the receiver.  The extseq[n] element holds the\
    \ RTP extended sequence\n   number of the packet associated with the command.\
    \  For incoming\n   stream commands, extseq[n] codes the packet of the associated\
    \ MIDI\n   list.  For commands executed to perform loss recovery, extseq[n]\n\
    \   codes the packet of the associated recovery journal.\n   The Chapter N recovery\
    \ journal bitfield (Figure A.6.1 in [RFC4695])\n   consists of two data structures:\
    \ a bit array coding recently sent\n   NoteOff commands that are vulnerable to\
    \ packet loss, and a note log\n   list coding recently sent NoteOn commands that\
    \ are vulnerable to\n   packet loss.\n   At the end of a loss event, Chapter N\
    \ recovery processing begins with\n   the NoteOff bit array.  For each set bit\
    \ in the array, the receiver\n   checks the corresponding vel[n] element in jrec_chaptern.\
    \  If vel[n]\n   is non-zero, a NoteOff command or a NoteOff->NoteOn->NoteOff\
    \ command\n   sequence has been lost.  To recover from this loss, the receiver\n\
    \   immediately executes a NoteOff command for the note number on the\n   channel\
    \ and sets vel[n] to 0.\n   The receiver then parses the note log list, using\
    \ the S bit to skip\n   over \"safe\" logs in the single-packet loss case.  For\
    \ each at-risk\n   note log, the receiver checks the corresponding vel[n] element.\n\
    \   If vel[n] is zero, a NoteOn command or a NoteOn->NoteOff->NoteOn\n   command\
    \ sequence has been lost.  The receiver may execute the most\n   recent lost NoteOn\
    \ (to play the note) or may take no action (to skip\n   the note), based on criteria\
    \ we describe at the end of this section.\n   Whether the note is played or skipped,\
    \ the receiver updates the\n   vel[n], time[n], and extseq[n] elements as if the\
    \ NoteOn executed.\n   If vel[n] is non-zero, the receiver performs several checks\
    \ to test\n   if a NoteOff->NoteOn sequence has been lost.\n   o  If vel[n] does\
    \ not match the note log velocity, the note log must\n      code a different NoteOn\
    \ command, and thus a NoteOff->NoteOn\n      sequence has been lost.\n   o  If\
    \ extseq[n] is less than the (extended) checkpoint packet\n      sequence numbed\
    \ coded in the recovery journal header (Figure 8 of\n      [RFC4695]), the vel[n]\
    \ NoteOn command is not in the checkpoint\n      history, and thus a NoteOff->NoteOn\
    \ sequence has been lost.\n   o  If the Y bit is set to 1, the NoteOn is musically\
    \ \"simultaneous\"\n      with the RTP timestamp of the packet.  If time[n] codes\
    \ a time\n      value that is clearly not recent, a NoteOff->NoteOn sequence has\n\
    \      been lost.\n   If these tests indicate a lost NoteOff->NoteOn sequence,\
    \ the receiver\n   immediately executes a NoteOff command.  The receiver decides\
    \ if the\n   most graceful action is to play or to skip the lost NoteOn, using\
    \ the\n   criteria we describe at the end of this section.  Whether or not the\n\
    \   receiver issues a NoteOn command, the vel[n], time[n], and extseq[n]\n   arrays\
    \ are updated as if it did.\n   Note that the tests above do not catch all lost\
    \ NoteOff->NoteOn\n   commands.  If a fast NoteOn->NoteOff->NoteOn sequence occurs\
    \ on a\n   note number with identical velocity values for both NoteOn commands,\n\
    \   a lost NoteOff->NoteOn does not result in the recovery algorithm\n   generating\
    \ a NoteOff command.  Instead, the first NoteOn continues to\n   sound, to be\
    \ terminated by the future NoteOff command.  In practice,\n   this (rare) outcome\
    \ is not musically objectionable.\n   The number of tests in this resiliency algorithm\
    \ may seem excessive.\n   However, in some common cases, a subset of the tests\
    \ is not useful.\n   For example, MIDI streams that assigns the same velocity\
    \ value to all\n   note events are often produced by inexpensive keyboards.  The\
    \ vel[n]\n   tests are not useful for these streams.\n   Finally, we discuss how\
    \ the receiver decides whether to play or to\n   skip a lost NoteOn command. \
    \ The note log Y bit is set if the NoteOn\n   is \"simultaneous\" with the RTP\
    \ timestamp of the packet holding the\n   note log.  If Y is 0, the receiver does\
    \ not execute a NoteOn command.\n   If Y is 1, and if the packet has not arrived\
    \ late, the receiver\n   immediately executes a NoteOn command for the note number,\
    \ using the\n   velocity coded in the note log.\n"
- title: '7.3.  Chapter C: MIDI Control Change (0xB)'
  contents:
  - "7.3.  Chapter C: MIDI Control Change (0xB)\n   Chapter C (Appendix A.3 in [RFC4695])\
    \ protects against the loss of\n   MIDI Control Change commands.  A Control Change\
    \ command alters the\n   7-bit value of one of the 128 MIDI controllers.\n   Chapter\
    \ C offers three tools for protecting a Control Change command:\n   the value\
    \ tool (for graded controllers such as sliders), the toggle\n   tool (for on/off\
    \ switches), and the count tool (for momentary-contact\n   switches).  Senders\
    \ choose a tool to encode recovery information for\n   a controller and encode\
    \ the tool type along with the data in the\n   journal (Figures A.3.2 and A.3.3\
    \ in [RFC4695]).\n   A few uses of Control Change commands are not solely protected\
    \ by\n   Chapter C.  The protection of controllers 0 and 32 (Bank Select MSB\n\
    \   and Bank Select LSB) is shared between Chapter C and Chapter P\n   (Section\
    \ 7.4).\n   Chapter M (Appendix A.4 of [RFC4695]) also protects the Control\n\
    \   Change command.  However, the NMP system does not use this chapter,\n   because\
    \ MPEG 4 Structured Audio [MPEGSA] does not use the controllers\n   protected\
    \ by this chapter.\n   The Chapter C bitfield consists of a list of controller\
    \ logs.  Each\n   log codes the controller number, the tool type, and the state\
    \ value\n   for the tool.\n   The NMP receiver maintains the jrec_chapterc structure\
    \ (Figure 10)\n   for each voice channel in jrec_stream to code Control Change\
    \ state\n   information.  The value[] array holds the most recent data values\
    \ for\n   each controller number.  At the start of the stream, value[] is\n  \
    \ initialized to the default controller data values specified in\n   [MPEGSA].\n\
    \   The count[] and toggle[] arrays hold the count tool and toggle tool\n   state\
    \ values.  At the start of a stream, these arrays are initialized\n   to zero.\
    \  Whenever a Control Command executes, the receiver updates\n   the count[] and\
    \ toggle[] state values, using the algorithms defined\n   in Appendix A.3 of [RFC4695].\n\
    \   At the end of a loss event, the receiver parses the Chapter C\n   controller\
    \ log list, using the S bit to skip over \"safe\" logs in the\n   single-packet\
    \ loss case.  For each at-risk controller number n, the\n   receiver determines\
    \ the tool type in use (value, toggle, or count)\n   and compares the data in\
    \ the log to the associated jrec_chapterc\n   array element (value[n], toggle[n],\
    \ or count[n]).  If the data do not\n   match, one or more Control Change commands\
    \ have been lost.\n   The method the receiver uses to recover from this loss depends\
    \ on the\n   tool type and the controller number.  For graded controllers\n  \
    \ protected by the value tool, the receiver executes a Control Change\n   command\
    \ using the new data value.\n   For the toggle and count tools, the recovery action\
    \ is more complex.\n   For example, the Damper Pedal (Sustain) controller (number\
    \ 64) is\n   typically used as a sustain pedal for piano-like sounds and is\n\
    \   typically coded using the toggle tool.  If Damper Pedal (Sustain)\n   Control\
    \ Change commands are lost, the receiver takes different\n   actions depending\
    \ on the starting and ending state of the lost\n   sequence, to ensure that \"\
    ringing\" piano notes are \"damped\" to\n   silence.\n   After recovering from\
    \ the loss, the receiver updates the value[],\n   toggle[], and count[] arrays\
    \ to reflect the Chapter C data and the\n   executed commands.\n"
- title: '7.4.  Chapter P: MIDI Program Change (0xC)'
  contents:
  - "7.4.  Chapter P: MIDI Program Change (0xC)\n   Chapter P of the recovery journal\
    \ protects against the loss of MIDI\n   Program Change (0xC) commands.\n   The\
    \ 7-bit data value of the Program Change command selects one of 128\n   possible\
    \ timbres for the channel.  To increase the number of possible\n   timbres, Control\
    \ Change (0xB) commands may be issued prior to the\n   Program Change command\
    \ to select a \"program bank\".  The Bank Select\n   MSB (number 0) and Bank Select\
    \ LSB (number 32) controllers specify\n   the 14-bit bank number that subsequent\
    \ Program Change commands\n   reference.\n   The NMP receiver maintains the jrec_chapterp\
    \ structure (Figure 10)\n   for each voice channel in jrec_stream to code Program\
    \ Change state\n   information.\n   The prognum variable of jrec_chapterp holds\
    \ the data value for the\n   most recent Program Change command that has arrived\
    \ on the stream.\n   The bank_msb and bank_lsb variables of jrec_chapterp code\
    \ the Bank\n   Select MSB and Bank Select LSB controller data values that were\
    \ in\n   effect when that Program Change command arrived.  The prognum_qual,\n\
    \   bank_msb_qual, and bank_lsb_qual variables are initialized to 0 and\n   are\
    \ set to 1 to qualify the associated data values.\n   Chapter P fields code the\
    \ data value for the most recent Program\n   Change command, and the MSB and LSB\
    \ bank values in effect for that\n   command.\n   At the end of a loss event,\
    \ the receiver checks Chapter P to see if\n   the recovery journal fields match\
    \ the data stored in jrec_chapterp.\n   If these checks fail, one or more Program\
    \ Change commands have been\n   lost.\n   To recover from this loss, the receiver\
    \ takes the following steps.\n   If the B bit in Chapter P is set (Figure A.2.1\
    \ in [RFC4695]), Control\n   Change bank commands have preceded the Program Change\
    \ command.  The\n   receiver compares the bank data coded by Chapter P with the\
    \ current\n   bank data for the channel (coded in jrec_channelc).\n   If the bank\
    \ data do not agree, the receiver issues Control Change\n   commands to align\
    \ the stream with Chapter P.  The receiver then\n   updates jrec_channelp and\
    \ jrec_channelc variables to reflect the\n   executed command(s).  Finally, the\
    \ receiver issues a Program Change\n   command that reflects the data in Chapter\
    \ P and updates the prognum\n   and qual_prognum fields in jrec_channelp.\n  \
    \ Note that this method relies on Chapter P recovery to precede Chapter\n   C\
    \ recovery during channel journal processing.  This ordering ensures\n   that\
    \ lost Bank Select Control Change commands that occur after a lost\n   Program\
    \ Change command in a stream are handled correctly.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   Security considerations for the RTP MIDI payload\
    \ format are discussed\n   in the Security Considerations section of [RFC4695].\n"
- title: 9.  IANA Considerations
  contents:
  - "9.  IANA Considerations\n   IANA considerations for the RTP MIDI payload format\
    \ are discussed in\n   the IANA Considerations section of [RFC4695].\n"
- title: 10.  Acknowledgements
  contents:
  - "10.  Acknowledgements\n   This memo was written in conjunction with [RFC4695],\
    \ and the\n   Acknowledgements section of [RFC4695] also applies to this memo.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [RFC4695] Lazzaro, J. and J. Wawrzynek, \"RTP\
    \ Payload Format for\n             MIDI\", RFC 4695, November 2006.\n   [RFC3550]\
    \ Schulzrinne, H., Casner, S., Frederick, R., and V.\n             Jacobson, \"\
    RTP: A Transport Protocol for Real-Time\n             Applications\", STD 64,\
    \ RFC 3550, July 2003.\n   [RFC3551] Schulzrinne, H. and S. Casner, \"RTP Profile\
    \ for Audio and\n             Video Conferences with Minimal Control\", STD 65,\
    \ RFC 3551,\n             July 2003.\n   [RFC4566] Handley, M., Jacobson, V.,\
    \ and C. Perkins, \"SDP: Session\n             Description Protocol\", RFC 4566,\
    \ July 2006.\n   [MIDI]    MIDI Manufacturers Association.  \"The Complete MIDI\
    \ 1.0\n             Detailed Specification\", 1996.\n   [MPEGSA]  International\
    \ Standards Organization.  \"ISO/IEC 14496\n             MPEG-4\", Part 3 (Audio),\
    \ Subpart 5 (Structured Audio),\n             2001.\n   [RFC3556] Casner, S.,\
    \ \"Session Description Protocol (SDP) Bandwidth\n             Modifiers for RTP\
    \ Control Protocol (RTCP) Bandwidth\", RFC\n             3556, July 2003.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [NMP]     Lazzaro, J. and J. Wawrzynek.  \"\
    A Case for Network Musical\n             Performance\", 11th International Workshop\
    \ on Network and\n             Operating Systems Support for Digital Audio and\
    \ Video\n             (NOSSDAV 2001) June 25-26, 2001, Port Jefferson, New York.\n\
    \   [RFC3261] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,\n     \
    \        A., Peterson, J., Sparks, R., Handley, M., and E. Schooler,\n       \
    \      \"SIP: Session Initiation Protocol\", RFC 3261, June 2002.\n   [GRAME]\
    \   Fober, D., Orlarey, Y. and S. Letz.  \"Real Time Musical\n             Events\
    \ Streaming over Internet\", Proceedings of the\n             International Conference\
    \ on WEB Delivering of Music 2001,\n             pages 147-154.\n   [CCRMA]  \
    \ Chafe C., Wilson S., Leistikow R., Chisholm D., and G.\n             Scavone.\
    \  \"A simplified approach to high quality music and\n             sound over\
    \ IP\", COST-G6 Conference on Digital Audio Effects\n             (DAFx-00), Verona,\
    \ Italy, December 2000.\n   [RTPBOOK] Perkins, C.  \"RTP: Audio and Video for\
    \ the Internet\",\n             Addison-Wesley, ISBN 0-672-32249-8, 2003.\n  \
    \ [STEVENS] Stevens, R. W, Fenner, B., and A. Rudoff.  \"Unix Network\n      \
    \       Programming: The Sockets Networking API\", Addison-Wesley,\n         \
    \    2003.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   John Lazzaro (corresponding author)\n   UC Berkeley\n\
    \   CS Division\n   315 Soda Hall\n   Berkeley CA 94720-1776\n   EMail: lazzaro@cs.berkeley.edu\n\
    \   John Wawrzynek\n   UC Berkeley\n   CS Division\n   631 Soda Hall\n   Berkeley\
    \ CA 94720-1776\n   EMail: johnw@cs.berkeley.edu\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2006).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST,\n   AND THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,\n   EXPRESS OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT\n   THE USE OF THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY\n   IMPLIED WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR\n   PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
