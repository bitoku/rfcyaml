- title: __initial_text__
  contents:
  - '         Unicast UDP Usage Guidelines for Application Designers

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet Best Current Practices\
    \ for the\n   Internet Community, and requests discussion and suggestions for\n\
    \   improvements.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2008 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\
    \ (http://trustee.ietf.org/\n   license-info) in effect on the date of publication\
    \ of this document.\n   Please review these documents carefully, as they describe\
    \ your rights\n   and restrictions with respect to this document.\n"
- title: Abstract
  contents:
  - "Abstract\n   The User Datagram Protocol (UDP) provides a minimal message-passing\n\
    \   transport that has no inherent congestion control mechanisms.\n   Because\
    \ congestion control is critical to the stable operation of the\n   Internet,\
    \ applications and upper-layer protocols that choose to use\n   UDP as an Internet\
    \ transport must employ mechanisms to prevent\n   congestion collapse and to establish\
    \ some degree of fairness with\n   concurrent traffic.  This document provides\
    \ guidelines on the use of\n   UDP for the designers of unicast applications and\
    \ upper-layer\n   protocols.  Congestion control guidelines are a primary focus,\
    \ but\n   the document also provides guidance on other topics, including\n   message\
    \ sizes, reliability, checksums, and middlebox traversal.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  3\n   2.  Terminology  . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  5\n   3.  UDP Usage Guidelines . . . . . . . . . . . . . . . . .\
    \ . . . .  5\n     3.1.  Congestion Control Guidelines  . . . . . . . . . . .\
    \ . . .  6\n     3.2.  Message Size Guidelines  . . . . . . . . . . . . . . .\
    \ . . 11\n     3.3.  Reliability Guidelines . . . . . . . . . . . . . . . . .\
    \ . 12\n     3.4.  Checksum Guidelines  . . . . . . . . . . . . . . . . . . .\
    \ 13\n     3.5.  Middlebox Traversal Guidelines . . . . . . . . . . . . . . 15\n\
    \     3.6.  Programming Guidelines . . . . . . . . . . . . . . . . . . 17\n  \
    \   3.7.  ICMP Guidelines  . . . . . . . . . . . . . . . . . . . . . 18\n   4.\
    \  Security Considerations  . . . . . . . . . . . . . . . . . . . 19\n   5.  Summary\
    \  . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n   6.  Acknowledgments\
    \  . . . . . . . . . . . . . . . . . . . . . . . 22\n   7.  References . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . 22\n     7.1.  Normative References\
    \ . . . . . . . . . . . . . . . . . . . 22\n     7.2.  Informative References\
    \ . . . . . . . . . . . . . . . . . . 23\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The User Datagram Protocol (UDP) [RFC0768] provides a minimal,\n\
    \   unreliable, best-effort, message-passing transport to applications\n   and\
    \ upper-layer protocols (both simply called \"applications\" in the\n   remainder\
    \ of this document).  Compared to other transport protocols,\n   UDP and its UDP-Lite\
    \ variant [RFC3828] are unique in that they do not\n   establish end-to-end connections\
    \ between communicating end systems.\n   UDP communication consequently does not\
    \ incur connection\n   establishment and teardown overheads, and there is minimal\
    \ associated\n   end system state.  Because of these characteristics, UDP can\
    \ offer a\n   very efficient communication transport to some applications.\n \
    \  A second unique characteristic of UDP is that it provides no inherent\n   congestion\
    \ control mechanisms.  On many platforms, applications can\n   send UDP datagrams\
    \ at the line rate of the link interface, which is\n   often much greater than\
    \ the available path capacity, and doing so\n   contributes to congestion along\
    \ the path.  [RFC2914] describes the\n   best current practice for congestion\
    \ control in the Internet.  It\n   identifies two major reasons why congestion\
    \ control mechanisms are\n   critical for the stable operation of the Internet:\n\
    \   1.  The prevention of congestion collapse, i.e., a state where an\n      \
    \ increase in network load results in a decrease in useful work\n       done by\
    \ the network.\n   2.  The establishment of a degree of fairness, i.e., allowing\n\
    \       multiple flows to share the capacity of a path reasonably\n       equitably.\n\
    \   Because UDP itself provides no congestion control mechanisms, it is\n   up\
    \ to the applications that use UDP for Internet communication to\n   employ suitable\
    \ mechanisms to prevent congestion collapse and\n   establish a degree of fairness.\
    \  [RFC2309] discusses the dangers of\n   congestion-unresponsive flows and states\
    \ that \"all UDP-based\n   streaming applications should incorporate effective\
    \ congestion\n   avoidance mechanisms\".  This is an important requirement, even\
    \ for\n   applications that do not use UDP for streaming.  In addition,\n   congestion-controlled\
    \ transmission is of benefit to an application\n   itself, because it can reduce\
    \ self-induced packet loss, minimize\n   retransmissions, and hence reduce delays.\
    \  Congestion control is\n   essential even at relatively slow transmission rates.\
    \  For example,\n   an application that generates five 1500-byte UDP datagrams\
    \ in one\n   second can already exceed the capacity of a 56 Kb/s path.  For\n\
    \   applications that can operate at higher, potentially unbounded data\n   rates,\
    \ congestion control becomes vital to prevent congestion\n   collapse and establish\
    \ some degree of fairness.  Section 3 describes\n   a number of simple guidelines\
    \ for the designers of such applications.\n   A UDP datagram is carried in a single\
    \ IP packet and is hence limited\n   to a maximum payload of 65,507 bytes for\
    \ IPv4 and 65,527 bytes for\n   IPv6.  The transmission of large IP packets usually\
    \ requires IP\n   fragmentation.  Fragmentation decreases communication reliability\
    \ and\n   efficiency and should be avoided.  IPv6 allows the option of\n   transmitting\
    \ large packets (\"jumbograms\") without fragmentation when\n   all link layers\
    \ along the path support this [RFC2675].  Some of the\n   guidelines in Section\
    \ 3 describe how applications should determine\n   appropriate message sizes.\
    \  Other sections of this document provide\n   guidance on reliability, checksums,\
    \ and middlebox traversal.\n   This document provides guidelines and recommendations.\
    \  Although most\n   unicast UDP applications are expected to follow these guidelines,\n\
    \   there do exist valid reasons why a specific application may decide\n   not\
    \ to follow a given guideline.  In such cases, it is RECOMMENDED\n   that the\
    \ application designers document the rationale for their\n   design choice in\
    \ the technical specification of their application or\n   protocol.\n   This document\
    \ provides guidelines to designers of applications that\n   use UDP for unicast\
    \ transmission, which is the most common case.\n   Specialized classes of applications\
    \ use UDP for IP multicast\n   [RFC1112], broadcast [RFC0919], or anycast [RFC1546]\
    \ transmissions.\n   The design of such specialized applications requires expertise\
    \ that\n   goes beyond the simple, unicast-specific guidelines given in this\n\
    \   document.  Multicast and broadcast senders may transmit to multiple\n   receivers\
    \ across potentially very heterogeneous paths at the same\n   time, which significantly\
    \ complicates congestion control, flow\n   control, and reliability mechanisms.\
    \  The IETF has defined a reliable\n   multicast framework [RFC3048] and several\
    \ building blocks to aid the\n   designers of multicast applications, such as\
    \ [RFC3738] or [RFC4654].\n   Anycast senders must be aware that successive messages\
    \ sent to the\n   same anycast IP address may be delivered to different anycast\
    \ nodes,\n   i.e., arrive at different locations in the topology.  It is not\n\
    \   intended that the guidelines in this document apply to multicast,\n   broadcast,\
    \ or anycast applications that use UDP.\n   Finally, although this document specifically\
    \ refers to unicast\n   applications that use UDP, the spirit of some of its guidelines\
    \ also\n   applies to other message-passing applications and protocols\n   (specifically\
    \ on the topics of congestion control, message sizes, and\n   reliability).  Examples\
    \ include signaling or control applications\n   that choose to run directly over\
    \ IP by registering their own IP\n   protocol number with IANA.  This document\
    \ may provide useful\n   background reading to the designers of such applications\
    \ and\n   protocols.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in BCP\
    \ 14, RFC 2119\n   [RFC2119].\n"
- title: 3.  UDP Usage Guidelines
  contents:
  - "3.  UDP Usage Guidelines\n   Internet paths can have widely varying characteristics,\
    \ including\n   transmission delays, available bandwidths, congestion levels,\n\
    \   reordering probabilities, supported message sizes, or loss rates.\n   Furthermore,\
    \ the same Internet path can have very different\n   conditions over time.  Consequently,\
    \ applications that may be used on\n   the Internet MUST NOT make assumptions\
    \ about specific path\n   characteristics.  They MUST instead use mechanisms that\
    \ let them\n   operate safely under very different path conditions.  Typically,\
    \ this\n   requires conservatively probing the current conditions of the\n   Internet\
    \ path they communicate over to establish a transmission\n   behavior that it\
    \ can sustain and that is reasonably fair to other\n   traffic sharing the path.\n\
    \   These mechanisms are difficult to implement correctly.  For most\n   applications,\
    \ the use of one of the existing IETF transport protocols\n   is the simplest\
    \ method of acquiring the required mechanisms.\n   Consequently, the RECOMMENDED\
    \ alternative to the UDP usage described\n   in the remainder of this section\
    \ is the use of an IETF transport\n   protocol such as TCP [RFC0793], Stream Control\
    \ Transmission Protocol\n   (SCTP) [RFC4960], and SCTP Partial Reliability Extension\
    \ (SCTP-PR)\n   [RFC3758], or Datagram Congestion Control Protocol (DCCP) [RFC4340]\n\
    \   with its different congestion control types\n   [RFC4341][RFC4342][CCID4].\n\
    \   If used correctly, these more fully-featured transport protocols are\n   not\
    \ as \"heavyweight\" as often claimed.  For example, the TCP\n   algorithms have\
    \ been continuously improved over decades, and have\n   reached a level of efficiency\
    \ and correctness that custom\n   application-layer mechanisms will struggle to\
    \ easily duplicate.  In\n   addition, many TCP implementations allow connections\
    \ to be tuned by\n   an application to its purposes.  For example, TCP's \"Nagle\"\
    \ algorithm\n   [RFC0896] can be disabled, improving communication latency at\
    \ the\n   expense of more frequent -- but still congestion-controlled -- packet\n\
    \   transmissions.  Another example is the TCP SYN cookie mechanism\n   [RFC4987],\
    \ which is available on many platforms.  TCP with SYN\n   cookies does not require\
    \ a server to maintain per-connection state\n   until the connection is established.\
    \  TCP also requires the end that\n   closes a connection to maintain the TIME-WAIT\
    \ state that prevents\n   delayed segments from one connection instance from interfering\
    \ with a\n   later one.  Applications that are aware of and designed for this\n\
    \   behavior can shift maintenance of the TIME-WAIT state to conserve\n   resources\
    \ by controlling which end closes a TCP connection [FABER].\n   Finally, TCP's\
    \ built-in capacity-probing and awareness of the maximum\n   transmission unit\
    \ supported by the path (PMTU) results in efficient\n   data transmission that\
    \ quickly compensates for the initial connection\n   setup delay, in the case\
    \ of transfers that exchange more than a few\n   segments.\n"
- title: 3.1.  Congestion Control Guidelines
  contents:
  - "3.1.  Congestion Control Guidelines\n   If an application or upper-layer protocol\
    \ chooses not to use a\n   congestion-controlled transport protocol, it SHOULD\
    \ control the rate\n   at which it sends UDP datagrams to a destination host,\
    \ in order to\n   fulfill the requirements of [RFC2914].  It is important to stress\n\
    \   that an application SHOULD perform congestion control over all UDP\n   traffic\
    \ it sends to a destination, independently from how it\n   generates this traffic.\
    \  For example, an application that forks\n   multiple worker processes or otherwise\
    \ uses multiple sockets to\n   generate UDP datagrams SHOULD perform congestion\
    \ control over the\n   aggregate traffic.\n   Several approaches to perform congestion\
    \ control are discussed in the\n   remainder of this section.  Not all approaches\
    \ discussed below are\n   appropriate for all UDP-transmitting applications. \
    \ Section 3.1.1\n   discusses congestion control options for applications that\
    \ perform\n   bulk transfers over UDP.  Such applications can employ schemes that\n\
    \   sample the path over several subsequent RTTs during which data is\n   exchanged,\
    \ in order to determine a sending rate that the path at its\n   current load can\
    \ support.  Other applications only exchange a few UDP\n   datagrams with a destination.\
    \  Section 3.1.2 discusses congestion\n   control options for such \"low data-volume\"\
    \ applications.  Because\n   they typically do not transmit enough data to iteratively\
    \ sample the\n   path to determine a safe sending rate, they need to employ different\n\
    \   kinds of congestion control mechanisms.  Section 3.1.3 discusses\n   congestion\
    \ control considerations when UDP is used as a tunneling\n   protocol.\n   It\
    \ is important to note that congestion control should not be viewed\n   as an\
    \ add-on to a finished application.  Many of the mechanisms\n   discussed in the\
    \ guidelines below require application support to\n   operate correctly.  Application\
    \ designers need to consider congestion\n   control throughout the design of their\
    \ application, similar to how\n   they consider security aspects throughout the\
    \ design process.\n   In the past, the IETF has also investigated integrated congestion\n\
    \   control mechanisms that act on the traffic aggregate between two\n   hosts,\
    \ i.e., a framework such as the Congestion Manager [RFC3124],\n   where active\
    \ sessions may share current congestion information in a\n   way that is independent\
    \ of the transport protocol.  Such mechanisms\n   have currently failed to see\
    \ deployment, but would otherwise simplify\n   the design of congestion control\
    \ mechanisms for UDP sessions, so that\n   they fulfill the requirements in [RFC2914].\n"
- title: 3.1.1.  Bulk Transfer Applications
  contents:
  - "3.1.1.  Bulk Transfer Applications\n   Applications that perform bulk transmission\
    \ of data to a peer over\n   UDP, i.e., applications that exchange more than a\
    \ small number of UDP\n   datagrams per RTT, SHOULD implement TCP-Friendly Rate\
    \ Control (TFRC)\n   [RFC5348], window-based, TCP-like congestion control, or\
    \ otherwise\n   ensure that the application complies with the congestion control\n\
    \   principles.\n   TFRC has been designed to provide both congestion control\
    \ and\n   fairness in a way that is compatible with the IETF's other transport\n\
    \   protocols.  If an application implements TFRC, it need not follow the\n  \
    \ remaining guidelines in Section 3.1.1, because TFRC already addresses\n   them,\
    \ but SHOULD still follow the remaining guidelines in the\n   subsequent subsections\
    \ of Section 3.\n   Bulk transfer applications that choose not to implement TFRC\
    \ or TCP-\n   like windowing SHOULD implement a congestion control scheme that\n\
    \   results in bandwidth use that competes fairly with TCP within an\n   order\
    \ of magnitude.  Section 2 of [RFC3551] suggests that\n   applications SHOULD\
    \ monitor the packet loss rate to ensure that it is\n   within acceptable parameters.\
    \  Packet loss is considered acceptable\n   if a TCP flow across the same network\
    \ path under the same network\n   conditions would achieve an average throughput,\
    \ measured on a\n   reasonable timescale, that is not less than that of the UDP\
    \ flow.\n   The comparison to TCP cannot be specified exactly, but is intended\
    \ as\n   an \"order-of-magnitude\" comparison in timescale and throughput.\n \
    \  Finally, some bulk transfer applications may choose not to implement\n   any\
    \ congestion control mechanism and instead rely on transmitting\n   across reserved\
    \ path capacity.  This might be an acceptable choice\n   for a subset of restricted\
    \ networking environments, but is by no\n   means a safe practice for operation\
    \ in the Internet.  When the UDP\n   traffic of such applications leaks out on\
    \ unprovisioned Internet\n   paths, it can significantly degrade the performance\
    \ of other traffic\n   sharing the path and even result in congestion collapse.\n\
    \   Applications that support an uncontrolled or unadaptive transmission\n   behavior\
    \ SHOULD NOT do so by default and SHOULD instead require users\n   to explicitly\
    \ enable this mode of operation.\n"
- title: 3.1.2.  Low Data-Volume Applications
  contents:
  - "3.1.2.  Low Data-Volume Applications\n   When applications that at any time exchange\
    \ only a small number of\n   UDP datagrams with a destination implement TFRC or\
    \ one of the other\n   congestion control schemes in Section 3.1.1, the network\
    \ sees little\n   benefit, because those mechanisms perform congestion control\
    \ in a way\n   that is only effective for longer transmissions.\n   Applications\
    \ that at any time exchange only a small number of UDP\n   datagrams with a destination\
    \ SHOULD still control their transmission\n   behavior by not sending on average\
    \ more than one UDP datagram per\n   round-trip time (RTT) to a destination. \
    \ Similar to the\n   recommendation in [RFC1536], an application SHOULD maintain\
    \ an\n   estimate of the RTT for any destination with which it communicates.\n\
    \   Applications SHOULD implement the algorithm specified in [RFC2988] to\n  \
    \ compute a smoothed RTT (SRTT) estimate.  They SHOULD also detect\n   packet\
    \ loss and exponentially back-off their retransmission timer\n   when a loss event\
    \ occurs.  When implementing this scheme,\n   applications need to choose a sensible\
    \ initial value for the RTT.\n   This value SHOULD generally be as conservative\
    \ as possible for the\n   given application.  TCP uses an initial value of 3 seconds\
    \ [RFC2988],\n   which is also RECOMMENDED as an initial value for UDP applications.\n\
    \   SIP [RFC3261] and GIST [GIST] use an initial value of 500 ms, and\n   initial\
    \ timeouts that are shorter than this are likely problematic in\n   many cases.\
    \  It is also important to note that the initial timeout is\n   not the maximum\
    \ possible timeout -- the RECOMMENDED algorithm in\n   [RFC2988] yields timeout\
    \ values after a series of losses that are\n   much longer than the initial value.\n\
    \   Some applications cannot maintain a reliable RTT estimate for a\n   destination.\
    \  The first case is that of applications that exchange\n   too few UDP datagrams\
    \ with a peer to establish a statistically\n   accurate RTT estimate.  Such applications\
    \ MAY use a predetermined\n   transmission interval that is exponentially backed-off\
    \ when packets\n   are lost.  TCP uses an initial value of 3 seconds [RFC2988],\
    \ which is\n   also RECOMMENDED as an initial value for UDP applications.  SIP\n\
    \   [RFC3261] and GIST [GIST] use an interval of 500 ms, and shorter\n   values\
    \ are likely problematic in many cases.  As in the previous\n   case, note that\
    \ the initial timeout is not the maximum possible\n   timeout.\n   A second class\
    \ of applications cannot maintain an RTT estimate for a\n   destination, because\
    \ the destination does not send return traffic.\n   Such applications SHOULD NOT\
    \ send more than one UDP datagram every 3\n   seconds, and SHOULD use an even\
    \ less aggressive rate when possible.\n   The 3-second interval was chosen based\
    \ on TCP's retransmission\n   timeout when the RTT is unknown [RFC2988], and shorter\
    \ values are\n   likely problematic in many cases.  Note that the sending rate\
    \ in this\n   case must be more conservative than in the two previous cases,\n\
    \   because the lack of return traffic prevents the detection of packet\n   loss,\
    \ i.e., congestion events, and the application therefore cannot\n   perform exponential\
    \ back-off to reduce load.\n   Applications that communicate bidirectionally SHOULD\
    \ employ\n   congestion control for both directions of the communication.  For\n\
    \   example, for a client-server, request-response-style application,\n   clients\
    \ SHOULD congestion-control their request transmission to a\n   server, and the\
    \ server SHOULD congestion-control its responses to the\n   clients.  Congestion\
    \ in the forward and reverse direction is\n   uncorrelated, and an application\
    \ SHOULD either independently detect\n   and respond to congestion along both\
    \ directions, or limit new and\n   retransmitted requests based on acknowledged\
    \ responses across the\n   entire round-trip path.\n"
- title: 3.1.3.  UDP Tunnels
  contents:
  - "3.1.3.  UDP Tunnels\n   One increasingly popular use of UDP is as a tunneling\
    \ protocol, where\n   a tunnel endpoint encapsulates the packets of another protocol\
    \ inside\n   UDP datagrams and transmits them to another tunnel endpoint, which\n\
    \   decapsulates the UDP datagrams and forwards the original packets\n   contained\
    \ in the payload.  Tunnels establish virtual links that\n   appear to directly\
    \ connect locations that are distant in the physical\n   Internet topology and\
    \ can be used to create virtual (private)\n   networks.  Using UDP as a tunneling\
    \ protocol is attractive when the\n   payload protocol is not supported by middleboxes\
    \ that may exist along\n   the path, because many middleboxes support transmission\
    \ using UDP.\n   Well-implemented tunnels are generally invisible to the endpoints\n\
    \   that happen to transmit over a path that includes tunneled links.  On\n  \
    \ the other hand, to the routers along the path of a UDP tunnel, i.e.,\n   the\
    \ routers between the two tunnel endpoints, the traffic that a UDP\n   tunnel\
    \ generates is a regular UDP flow, and the encapsulator and\n   decapsulator appear\
    \ as regular UDP-sending and -receiving\n   applications.  Because other flows\
    \ can share the path with one or\n   more UDP tunnels, congestion control needs\
    \ to be considered.\n   Two factors determine whether a UDP tunnel needs to employ\
    \ specific\n   congestion control mechanisms -- first, whether the payload traffic\n\
    \   is IP-based; second, whether the tunneling scheme generates UDP\n   traffic\
    \ at a volume that corresponds to the volume of payload traffic\n   carried within\
    \ the tunnel.\n   IP-based traffic is generally assumed to be congestion-controlled,\n\
    \   i.e., it is assumed that the transport protocols generating IP-based\n   traffic\
    \ at the sender already employ mechanisms that are sufficient\n   to address congestion\
    \ on the path.  Consequently, a tunnel carrying\n   IP-based traffic should already\
    \ interact appropriately with other\n   traffic sharing the path, and specific\
    \ congestion control mechanisms\n   for the tunnel are not necessary.\n   However,\
    \ if the IP traffic in the tunnel is known to not be\n   congestion-controlled,\
    \ additional measures are RECOMMENDED in order\n   to limit the impact of the\
    \ tunneled traffic on other traffic sharing\n   the path.\n   The following guidelines\
    \ define these possible cases in more detail:\n   1.  A tunnel generates UDP traffic\
    \ at a volume that corresponds to\n       the volume of payload traffic, and the\
    \ payload traffic is IP-\n       based and congestion-controlled.\n       This\
    \ is arguably the most common case for Internet tunnels.  In\n       this case,\
    \ the UDP tunnel SHOULD NOT employ its own congestion\n       control mechanism,\
    \ because congestion losses of tunneled traffic\n       will already trigger an\
    \ appropriate congestion response at the\n       original senders of the tunneled\
    \ traffic.\n       Note that this guideline is built on the assumption that most\
    \ IP-\n       based communication is congestion-controlled.  If a UDP tunnel is\n\
    \       used for IP-based traffic that is known to not be congestion-\n      \
    \ controlled, the next set of guidelines applies.\n   2.  A tunnel generates UDP\
    \ traffic at a volume that corresponds to\n       the volume of payload traffic,\
    \ and the payload traffic is not\n       known to be IP-based, or is known to\
    \ be IP-based but not\n       congestion-controlled.\n       This can be the case,\
    \ for example, when some link-layer protocols\n       are encapsulated within\
    \ UDP (but not all link-layer protocols;\n       some are congestion-controlled).\
    \  Because it is not known that\n       congestion losses of tunneled non-IP traffic\
    \ will trigger an\n       appropriate congestion response at the senders, the\
    \ UDP tunnel\n       SHOULD employ an appropriate congestion control mechanism.\n\
    \       Because tunnels are usually bulk-transfer applications as far as\n   \
    \    the intermediate routers are concerned, the guidelines in\n       Section\
    \ 3.1.1 apply.\n   3.  A tunnel generates UDP traffic at a volume that does not\n\
    \       correspond to the volume of payload traffic, independent of\n       whether\
    \ the payload traffic is IP-based or congestion-controlled.\n       Examples of\
    \ this class include UDP tunnels that send at a\n       constant rate, increase\
    \ their transmission rates under loss, for\n       example, due to increasing\
    \ redundancy when Forward Error\n       Correction is used, or are otherwise constrained\
    \ in their\n       transmission behavior.  These specialized uses of UDP for\n\
    \       tunneling go beyond the scope of the general guidelines given in\n   \
    \    this document.  The implementer of such specialized tunnels\n       SHOULD\
    \ carefully consider congestion control in the design of\n       their tunneling\
    \ mechanism.\n   Designing a tunneling mechanism requires significantly more expertise\n\
    \   than needed for many other UDP applications, because tunnels\n   virtualize\
    \ lower-layer components of the Internet, and the\n   virtualized components need\
    \ to correctly interact with the\n   infrastructure at that layer.  This document\
    \ only touches upon the\n   congestion control considerations for implementing\
    \ UDP tunnels; a\n   discussion of other required tunneling behavior is out of\
    \ scope.\n"
- title: 3.2.  Message Size Guidelines
  contents:
  - "3.2.  Message Size Guidelines\n   IP fragmentation lowers the efficiency and\
    \ reliability of Internet\n   communication.  The loss of a single fragment results\
    \ in the loss of\n   an entire fragmented packet, because even if all other fragments\
    \ are\n   received correctly, the original packet cannot be reassembled and\n\
    \   delivered.  This fundamental issue with fragmentation exists for both\n  \
    \ IPv4 and IPv6.  In addition, some network address translators (NATs)\n   and\
    \ firewalls drop IP fragments.  The network address translation\n   performed\
    \ by a NAT only operates on complete IP packets, and some\n   firewall policies\
    \ also require inspection of complete IP packets.\n   Even with these being the\
    \ case, some NATs and firewalls simply do not\n   implement the necessary reassembly\
    \ functionality, and instead choose\n   to drop all fragments.  Finally, [RFC4963]\
    \ documents other issues\n   specific to IPv4 fragmentation.\n   Due to these\
    \ issues, an application SHOULD NOT send UDP datagrams\n   that result in IP packets\
    \ that exceed the MTU of the path to the\n   destination.  Consequently, an application\
    \ SHOULD either use the path\n   MTU information provided by the IP layer or implement\
    \ path MTU\n   discovery itself [RFC1191][RFC1981][RFC4821] to determine whether\
    \ the\n   path to a destination will support its desired message size without\n\
    \   fragmentation.\n   Applications that do not follow this recommendation to\
    \ do PMTU\n   discovery SHOULD still avoid sending UDP datagrams that would result\n\
    \   in IP packets that exceed the path MTU.  Because the actual path MTU\n   is\
    \ unknown, such applications SHOULD fall back to sending messages\n   that are\
    \ shorter than the default effective MTU for sending (EMTU_S\n   in [RFC1122]).\
    \  For IPv4, EMTU_S is the smaller of 576 bytes and the\n   first-hop MTU [RFC1122].\
    \  For IPv6, EMTU_S is 1280 bytes [RFC2460].\n   The effective PMTU for a directly\
    \ connected destination (with no\n   routers on the path) is the configured interface\
    \ MTU, which could be\n   less than the maximum link payload size.  Transmission\
    \ of minimum-\n   sized UDP datagrams is inefficient over paths that support a\
    \ larger\n   PMTU, which is a second reason to implement PMTU discovery.\n   To\
    \ determine an appropriate UDP payload size, applications MUST\n   subtract the\
    \ size of the IP header (which includes any IPv4 optional\n   headers or IPv6\
    \ extension headers) as well as the length of the UDP\n   header (8 bytes) from\
    \ the PMTU size.  This size, known as the MMS_S,\n   can be obtained from the\
    \ TCP/IP stack [RFC1122].\n   Applications that do not send messages that exceed\
    \ the effective PMTU\n   of IPv4 or IPv6 need not implement any of the above mechanisms.\
    \  Note\n   that the presence of tunnels can cause an additional reduction of\
    \ the\n   effective PMTU, so implementing PMTU discovery may be beneficial.\n\
    \   Applications that fragment an application-layer message into multiple\n  \
    \ UDP datagrams SHOULD perform this fragmentation so that each datagram\n   can\
    \ be received independently, and be independently retransmitted in\n   the case\
    \ where an application implements its own reliability\n   mechanisms.\n"
- title: 3.3.  Reliability Guidelines
  contents:
  - "3.3.  Reliability Guidelines\n   Application designers are generally aware that\
    \ UDP does not provide\n   any reliability, e.g., it does not retransmit any lost\
    \ packets.\n   Often, this is a main reason to consider UDP as a transport.\n\
    \   Applications that do require reliable message delivery MUST implement\n  \
    \ an appropriate mechanism themselves.\n   UDP also does not protect against datagram\
    \ duplication, i.e., an\n   application may receive multiple copies of the same\
    \ UDP datagram.\n   Application designers SHOULD verify that their application\
    \ handles\n   datagram duplication gracefully, and may consequently need to\n\
    \   implement mechanisms to detect duplicates.  Even if UDP datagram\n   reception\
    \ triggers idempotent operations, applications may want to\n   suppress duplicate\
    \ datagrams to reduce load.\n   In addition, the Internet can significantly delay\
    \ some packets with\n   respect to others, e.g., due to routing transients, intermittent\n\
    \   connectivity, or mobility.  This can cause reordering, where UDP\n   datagrams\
    \ arrive at the receiver in an order different from the\n   transmission order.\
    \  Applications that require ordered delivery MUST\n   reestablish datagram ordering\
    \ themselves.\n   Finally, it is important to note that delay spikes can be very\
    \ large.\n   This can cause reordered packets to arrive many seconds after they\n\
    \   were sent.  [RFC0793] defines the maximum delay a TCP segment should\n   experience\
    \ -- the Maximum Segment Lifetime (MSL) -- as 2 minutes.  No\n   other RFC defines\
    \ an MSL for other transport protocols or IP itself.\n   This document clarifies\
    \ that the MSL value to be used for UDP SHOULD\n   be the same 2 minutes as for\
    \ TCP.  Applications SHOULD be robust to\n   the reception of delayed or duplicate\
    \ packets that are received\n   within this 2-minute interval.\n   An application\
    \ that requires reliable and ordered message delivery\n   SHOULD choose an IETF\
    \ standard transport protocol that provides these\n   features.  If this is not\
    \ possible, it will need to implement a set\n   of appropriate mechanisms itself.\n"
- title: 3.4.  Checksum Guidelines
  contents:
  - "3.4.  Checksum Guidelines\n   The UDP header includes an optional, 16-bit one's\
    \ complement checksum\n   that provides an integrity check.  This results in a\
    \ relatively weak\n   protection in terms of coding theory [RFC3819], and application\n\
    \   developers SHOULD implement additional checks where data integrity is\n  \
    \ important, e.g., through a Cyclic Redundancy Check (CRC) included\n   with the\
    \ data to verify the integrity of an entire object/file sent\n   over the UDP\
    \ service.\n   The UDP checksum provides a statistical guarantee that the payload\n\
    \   was not corrupted in transit.  It also allows the receiver to verify\n   that\
    \ it was the intended destination of the packet, because it covers\n   the IP\
    \ addresses, port numbers, and protocol number, and it verifies\n   that the packet\
    \ is not truncated or padded, because it covers the\n   size field.  It therefore\
    \ protects an application against receiving\n   corrupted payload data in place\
    \ of, or in addition to, the data that\n   was sent.  This check is not strong\
    \ from a coding or cryptographic\n   perspective, and is not designed to detect\
    \ physical-layer errors or\n   malicious modification of the datagram [RFC3819].\n\
    \   Applications SHOULD enable UDP checksums, although [RFC0768] permits\n   the\
    \ option to disable their use.  Applications that choose to disable\n   UDP checksums\
    \ when transmitting over IPv4 therefore MUST NOT make\n   assumptions regarding\
    \ the correctness of received data and MUST\n   behave correctly when a UDP datagram\
    \ is received that was originally\n   sent to a different destination or is otherwise\
    \ corrupted.  The use\n   of the UDP checksum is REQUIRED when applications transmit\
    \ UDP over\n   IPv6 [RFC2460].\n"
- title: 3.4.1.  UDP-Lite
  contents:
  - "3.4.1.  UDP-Lite\n   A special class of applications can derive benefit from\
    \ having\n   partially-damaged payloads delivered, rather than discarded, when\n\
    \   using paths that include error-prone links.  Such applications can\n   tolerate\
    \ payload corruption and MAY choose to use the Lightweight\n   User Datagram Protocol\
    \ (UDP-Lite) [RFC3828] variant of UDP instead of\n   basic UDP.  Applications\
    \ that choose to use UDP-Lite instead of UDP\n   should still follow the congestion\
    \ control and other guidelines\n   described for use with UDP in Section 3.\n\
    \   UDP-Lite changes the semantics of the UDP \"payload length\" field to\n  \
    \ that of a \"checksum coverage length\" field.  Otherwise, UDP-Lite is\n   semantically\
    \ identical to UDP.  The interface of UDP-Lite differs\n   from that of UDP by\
    \ the addition of a single (socket) option that\n   communicates a checksum coverage\
    \ length value: at the sender, this\n   specifies the intended checksum coverage,\
    \ with the remaining\n   unprotected part of the payload called the \"error-insensitive\
    \ part\".\n   By default, the UDP-Lite checksum coverage extends across the entire\n\
    \   datagram.  If required, an application may dynamically modify this\n   length\
    \ value, e.g., to offer greater protection to some messages.\n   UDP-Lite always\
    \ verifies that a packet was delivered to the intended\n   destination, i.e.,\
    \ always verifies the header fields.  Errors in the\n   insensitive part will\
    \ not cause a UDP datagram to be discarded by the\n   destination.  Applications\
    \ using UDP-Lite therefore MUST NOT make\n   assumptions regarding the correctness\
    \ of the data received in the\n   insensitive part of the UDP-Lite payload.\n\
    \   The sending application SHOULD select the minimum checksum coverage\n   to\
    \ include all sensitive protocol headers.  For example, applications\n   that\
    \ use the Real-Time Protocol (RTP) [RFC3550] will likely want to\n   protect the\
    \ RTP header against corruption.  Applications, where\n   appropriate, MUST also\
    \ introduce their own appropriate validity\n   checks for protocol information\
    \ carried in the insensitive part of\n   the UDP-Lite payload (e.g., internal\
    \ CRCs).\n   The receiver must set a minimum coverage threshold for incoming\n\
    \   packets that is not smaller than the smallest coverage used by the\n   sender\
    \ [RFC3828].  The receiver SHOULD select a threshold that is\n   sufficiently\
    \ large to block packets with an inappropriately short\n   coverage field.  This\
    \ may be a fixed value, or may be negotiated by\n   an application.  UDP-Lite\
    \ does not provide mechanisms to negotiate\n   the checksum coverage between the\
    \ sender and receiver.\n   Applications may still experience packet loss, rather\
    \ than\n   corruption, when using UDP-Lite.  The enhancements offered by UDP-\n\
    \   Lite rely upon a link being able to intercept the UDP-Lite header to\n   correctly\
    \ identify the partial coverage required.  When tunnels\n   and/or encryption\
    \ are used, this can result in UDP-Lite datagrams\n   being treated the same as\
    \ UDP datagrams, i.e., result in packet loss.\n   Use of IP fragmentation can\
    \ also prevent special treatment for UDP-\n   Lite datagrams, and this is another\
    \ reason why applications SHOULD\n   avoid IP fragmentation (Section 3.2).\n"
- title: 3.5.  Middlebox Traversal Guidelines
  contents:
  - "3.5.  Middlebox Traversal Guidelines\n   Network address translators (NATs) and\
    \ firewalls are examples of\n   intermediary devices (\"middleboxes\") that can\
    \ exist along an end-to-\n   end path.  A middlebox typically performs a function\
    \ that requires it\n   to maintain per-flow state.  For connection-oriented protocols,\
    \ such\n   as TCP, middleboxes snoop and parse the connection-management traffic\n\
    \   and create and destroy per-flow state accordingly.  For a\n   connectionless\
    \ protocol such as UDP, this approach is not possible.\n   Consequently, middleboxes\
    \ may create per-flow state when they see a\n   packet that indicates a new flow,\
    \ and destroy the state after some\n   period of time during which no packets\
    \ belonging to the same flow\n   have arrived.\n   Depending on the specific function\
    \ that the middlebox performs, this\n   behavior can introduce a time-dependency\
    \ that restricts the kinds of\n   UDP traffic exchanges that will be successful\
    \ across the middlebox.\n   For example, NATs and firewalls typically define the\
    \ partial path on\n   one side of them to be interior to the domain they serve,\
    \ whereas the\n   partial path on their other side is defined to be exterior to\
    \ that\n   domain.  Per-flow state is typically created when the first packet\n\
    \   crosses from the interior to the exterior, and while the state is\n   present,\
    \ NATs and firewalls will forward return traffic.  Return\n   traffic that arrives\
    \ after the per-flow state has timed out is\n   dropped, as is other traffic that\
    \ arrives from the exterior.\n   Many applications that use UDP for communication\
    \ operate across\n   middleboxes without needing to employ additional mechanisms.\
    \  One\n   example is the Domain Name System (DNS), which has a strict request-\n\
    \   response communication pattern that typically completes within\n   seconds.\n\
    \   Other applications may experience communication failures when\n   middleboxes\
    \ destroy the per-flow state associated with an application\n   session during\
    \ periods when the application does not exchange any UDP\n   traffic.  Applications\
    \ SHOULD be able to gracefully handle such\n   communication failures and implement\
    \ mechanisms to re-establish\n   application-layer sessions and state.\n   For\
    \ some applications, such as media transmissions, this re-\n   synchronization\
    \ is highly undesirable, because it can cause user-\n   perceivable playback artifacts.\
    \  Such specialized applications MAY\n   send periodic keep-alive messages to\
    \ attempt to refresh middlebox\n   state.  It is important to note that keep-alive\
    \ messages are NOT\n   RECOMMENDED for general use -- they are unnecessary for\
    \ many\n   applications and can consume significant amounts of system and\n  \
    \ network resources.\n   An application that needs to employ keep-alives to deliver\
    \ useful\n   service over UDP in the presence of middleboxes SHOULD NOT transmit\n\
    \   them more frequently than once every 15 seconds and SHOULD use longer\n  \
    \ intervals when possible.  No common timeout has been specified for\n   per-flow\
    \ UDP state for arbitrary middleboxes.  NATs require a state\n   timeout of 2\
    \ minutes or longer [RFC4787].  However, empirical\n   evidence suggests that\
    \ a significant fraction of currently deployed\n   middleboxes unfortunately use\
    \ shorter timeouts.  The timeout of 15\n   seconds originates with the Interactive\
    \ Connectivity Establishment\n   (ICE) protocol [ICE].  When applications are\
    \ deployed in more\n   controlled network environments, the deployers SHOULD investigate\n\
    \   whether the target environment allows applications to use longer\n   intervals,\
    \ or whether it offers mechanisms to explicitly control\n   middlebox state timeout\
    \ durations, for example, using Middlebox\n   Communications (MIDCOM) [RFC3303],\
    \ Next Steps in Signaling (NSIS)\n   [NSLP], or Universal Plug and Play (UPnP)\
    \ [UPnP].  It is RECOMMENDED\n   that applications apply slight random variations\
    \ (\"jitter\") to the\n   timing of keep-alive transmissions, to reduce the potential\
    \ for\n   persistent synchronization between keep-alive transmissions from\n \
    \  different hosts.\n   Sending keep-alives is not a substitute for implementing\
    \ robust\n   connection handling.  Like all UDP datagrams, keep-alives can be\n\
    \   delayed or dropped, causing middlebox state to time out.  In\n   addition,\
    \ the congestion control guidelines in Section 3.1 cover all\n   UDP transmissions\
    \ by an application, including the transmission of\n   middlebox keep-alives.\
    \  Congestion control may thus lead to delays or\n   temporary suspension of keep-alive\
    \ transmission.\n   Keep-alive messages are NOT RECOMMENDED for general use. \
    \ They are\n   unnecessary for many applications and may consume significant\n\
    \   resources.  For example, on battery-powered devices, if an\n   application\
    \ needs to maintain connectivity for long periods with\n   little traffic, the\
    \ frequency at which keep-alives are sent can\n   become the determining factor\
    \ that governs power consumption,\n   depending on the underlying network technology.\
    \  Because many\n   middleboxes are designed to require keep-alives for TCP connections\n\
    \   at a frequency that is much lower than that needed for UDP, this\n   difference\
    \ alone can often be sufficient to prefer TCP over UDP for\n   these deployments.\
    \  On the other hand, there is anecdotal evidence\n   that suggests that direct\
    \ communication through middleboxes, e.g., by\n   using ICE [ICE], does succeed\
    \ less often with TCP than with UDP.  The\n   tradeoffs between different transport\
    \ protocols -- especially when it\n   comes to middlebox traversal -- deserve\
    \ careful analysis.\n"
- title: 3.6.  Programming Guidelines
  contents:
  - "3.6.  Programming Guidelines\n   The de facto standard application programming\
    \ interface (API) for\n   TCP/IP applications is the \"sockets\" interface [POSIX].\
    \  Some\n   platforms also offer applications the ability to directly assemble\n\
    \   and transmit IP packets through \"raw sockets\" or similar facilities.\n \
    \  This is a second, more cumbersome method of using UDP.  The\n   guidelines\
    \ in this document cover all such methods through which an\n   application may\
    \ use UDP.  Because the sockets API is by far the most\n   common method, the\
    \ remainder of this section discusses it in more\n   detail.\n   Although the\
    \ sockets API was developed for UNIX in the early 1980s, a\n   wide variety of\
    \ non-UNIX operating systems also implement this.  The\n   sockets API supports\
    \ both IPv4 and IPv6 [RFC3493].  The UDP sockets\n   API differs from that for\
    \ TCP in several key ways.  Because\n   application programmers are typically\
    \ more familiar with the TCP\n   sockets API, the remainder of this section discusses\
    \ these\n   differences.  [STEVENS] provides usage examples of the UDP sockets\n\
    \   API.\n   UDP datagrams may be directly sent and received, without any\n  \
    \ connection setup.  Using the sockets API, applications can receive\n   packets\
    \ from more than one IP source address on a single UDP socket.\n   Some servers\
    \ use this to exchange data with more than one remote host\n   through a single\
    \ UDP socket at the same time.  Many applications need\n   to ensure that they\
    \ receive packets from a particular source address;\n   these applications MUST\
    \ implement corresponding checks at the\n   application layer or explicitly request\
    \ that the operating system\n   filter the received packets.\n   If a client/server\
    \ application executes on a host with more than one\n   IP interface, the application\
    \ SHOULD send any UDP responses with an\n   IP source address that matches the\
    \ IP destination address of the UDP\n   datagram that carried the request (see\
    \ [RFC1122], Section 4.1.3.5).\n   Many middleboxes expect this transmission behavior\
    \ and drop replies\n   that are sent from a different IP address, as explained\
    \ in\n   Section 3.5.\n   A UDP receiver can receive a valid UDP datagram with\
    \ a zero-length\n   payload.  Note that this is different from a return value\
    \ of zero\n   from a read() socket call, which for TCP indicates the end of the\n\
    \   connection.\n   Many operating systems also allow a UDP socket to be connected,\
    \ i.e.,\n   to bind a UDP socket to a specific pair of addresses and ports.  This\n\
    \   is similar to the corresponding TCP sockets API functionality.\n   However,\
    \ for UDP, this is only a local operation that serves to\n   simplify the local\
    \ send/receive functions and to filter the traffic\n   for the specified addresses\
    \ and ports.  Binding a UDP socket does not\n   establish a connection -- UDP\
    \ does not notify the remote end when a\n   local UDP socket is bound.  Binding\
    \ a socket also allows configuring\n   options that affect the UDP or IP layers,\
    \ for example, use of the UDP\n   checksum or the IP Timestamp option.  On some\
    \ stacks, a bound socket\n   also allows an application to be notified when ICMP\
    \ error messages\n   are received for its transmissions [RFC1122].\n   UDP provides\
    \ no flow-control.  This is another reason why UDP-based\n   applications need\
    \ to be robust in the presence of packet loss.  This\n   loss can also occur within\
    \ the sending host, when an application\n   sends data faster than the line rate\
    \ of the outbound network\n   interface.  It can also occur on the destination,\
    \ where receive calls\n   fail to return all the data that was sent when the application\
    \ issues\n   them too infrequently (i.e., such that the receive buffer overflows).\n\
    \   Robust flow control mechanisms are difficult to implement, which is\n   why\
    \ applications that need this functionality SHOULD consider using a\n   full-featured\
    \ transport protocol.\n   When an application closes a TCP, SCTP or DCCP socket,\
    \ the transport\n   protocol on the receiving host is required to maintain TIME-WAIT\n\
    \   state.  This prevents delayed packets from the closed connection\n   instance\
    \ from being mistakenly associated with a later connection\n   instance that happens\
    \ to reuse the same IP address and port pairs.\n   The UDP protocol does not implement\
    \ such a mechanism.  Therefore,\n   UDP-based applications need to be robust in\
    \ this case.  One\n   application may close a socket or terminate, followed in\
    \ time by\n   another application receiving on the same port.  This later\n  \
    \ application may then receive packets intended for the first\n   application\
    \ that were delayed in the network.\n   The Internet can provide service differentiation\
    \ to applications\n   based on IP-layer packet markings [RFC2475].  This facility\
    \ can be\n   used for UDP traffic.  Different operating systems provide different\n\
    \   interfaces for marking packets to applications.  Differentiated\n   services\
    \ require support from the network, and application deployers\n   need to discuss\
    \ the provisioning of this functionality with their\n   network operator.\n"
- title: 3.7.  ICMP Guidelines
  contents:
  - "3.7.  ICMP Guidelines\n   Applications can utilize information about ICMP error\
    \ messages that\n   the UDP layer passes up for a variety of purposes [RFC1122].\n\
    \   Applications SHOULD validate that the information in the ICMP message\n  \
    \ payload, e.g., a reported error condition, corresponds to a UDP\n   datagram\
    \ that the application actually sent.  Note that not all APIs\n   have the necessary\
    \ functions to support this validation, and some\n   APIs already perform this\
    \ validation internally before passing ICMP\n   information to the application.\n\
    \   Any application response to ICMP error messages SHOULD be robust to\n   temporary\
    \ routing failures, i.e., transient ICMP \"unreachable\"\n   messages should not\
    \ normally cause a communication abort.\n   Applications SHOULD appropriately\
    \ process ICMP messages generated in\n   response to transmitted traffic.  A correct\
    \ response often requires\n   context, such as local state about communication\
    \ instances to each\n   destination, that although readily available in connection-oriented\n\
    \   transport protocols is not always maintained by UDP-based\n   applications.\n"
- title: 4.  Security Considerations
  contents:
  - "4.  Security Considerations\n   UDP does not provide communications security.\
    \  Applications that need\n   to protect their communications against eavesdropping,\
    \ tampering, or\n   message forgery SHOULD employ end-to-end security services\
    \ provided\n   by other IETF protocols.  Applications that respond to short requests\n\
    \   with potentially large responses are vulnerable to amplification\n   attacks,\
    \ and SHOULD authenticate the sender before responding.  The\n   source IP address\
    \ of a request is not a useful authenticator, because\n   it can be spoofed.\n\
    \   One option of securing UDP communications is with IPsec [RFC4301],\n   which\
    \ can provide authentication for flows of IP packets through the\n   Authentication\
    \ Header (AH) [RFC4302] and encryption and/or\n   authentication through the Encapsulating\
    \ Security Payload (ESP)\n   [RFC4303].  Applications use the Internet Key Exchange\
    \ (IKE)\n   [RFC4306] to configure IPsec for their sessions.  Depending on how\n\
    \   IPsec is configured for a flow, it can authenticate or encrypt the\n   UDP\
    \ headers as well as UDP payloads.  If an application only requires\n   authentication,\
    \ ESP with no encryption but with authentication is\n   often a better option\
    \ than AH, because ESP can operate across\n   middleboxes.  An application that\
    \ uses IPsec requires the support of\n   an operating system that implements the\
    \ IPsec protocol suite.\n   Although it is possible to use IPsec to secure UDP\
    \ communications,\n   not all operating systems support IPsec or allow applications\
    \ to\n   easily configure it for their flows.  A second option of securing UDP\n\
    \   communications is through Datagram Transport Layer Security (DTLS)\n   [RFC4347].\
    \  DTLS provides communication privacy by encrypting UDP\n   payloads.  It does\
    \ not protect the UDP headers.  Applications can\n   implement DTLS without relying\
    \ on support from the operating system.\n   Many other options for authenticating\
    \ or encrypting UDP payloads\n   exist.  For example, the GSS-API security framework\
    \ [RFC2743] or\n   Cryptographic Message Syntax (CMS) [RFC3852] could be used\
    \ to protect\n   UDP payloads.  The IETF standard for securing RTP [RFC3550]\n\
    \   communication sessions over UDP is the Secure Real-time Transport\n   Protocol\
    \ (SRTP) [RFC3711].  In some applications, a better solution\n   is to protect\
    \ larger stand-alone objects, such as files or messages,\n   instead of individual\
    \ UDP payloads.  In these situations, CMS\n   [RFC3852], S/MIME [RFC3851] or OpenPGP\
    \ [RFC4880] could be used.  In\n   addition, there are many non-IETF protocols\
    \ in this area.\n   Like congestion control mechanisms, security mechanisms are\
    \ difficult\n   to design and implement correctly.  It is hence RECOMMENDED that\n\
    \   applications employ well-known standard security mechanisms such as\n   DTLS\
    \ or IPsec, rather than inventing their own.\n   The Generalized TTL Security\
    \ Mechanism (GTSM) [RFC5082] may be used\n   with UDP applications (especially\
    \ when the intended endpoint is on\n   the same link as the sender).  This is\
    \ a lightweight mechanism that\n   allows a receiver to filter unwanted packets.\n\
    \   In terms of congestion control, [RFC2309] and [RFC2914] discuss the\n   dangers\
    \ of congestion-unresponsive flows to the Internet.  This\n   document provides\
    \ guidelines to designers of UDP-based applications\n   to congestion-control\
    \ their transmissions, and does not raise any\n   additional security concerns.\n"
- title: 5.  Summary
  contents:
  - "5.  Summary\n   This section summarizes the guidelines made in Sections 3 and\
    \ 4 in a\n   tabular format (Table 1) for easy referencing.\n   +---------------------------------------------------------+---------+\n\
    \   | Recommendation                                          | Section |\n  \
    \ +---------------------------------------------------------+---------+\n   |\
    \ MUST tolerate a wide range of Internet path conditions  | 3       |\n   | SHOULD\
    \ use a full-featured transport (TCP, SCTP, DCCP)  |         |\n   |         \
    \                                                |         |\n   | SHOULD control\
    \ rate of transmission                     | 3.1     |\n   | SHOULD perform congestion\
    \ control over all traffic      |         |\n   |                            \
    \                             |         |\n   | for bulk transfers,          \
    \                           | 3.1.1   |\n   | SHOULD consider implementing TFRC\
    \                       |         |\n   | else, SHOULD in other ways use bandwidth\
    \ similar to TCP |         |\n   |                                           \
    \              |         |\n   | for non-bulk transfers,                     \
    \            | 3.1.2   |\n   | SHOULD measure RTT and transmit max. 1 datagram/RTT\
    \     |         |\n   | else, SHOULD send at most 1 datagram every 3 seconds \
    \   |         |\n   | SHOULD back-off retransmission timers following loss   \
    \ |         |\n   |                                                         |\
    \         |\n   | for tunnels carrying IP Traffic,                        | 3.1.3\
    \   |\n   | SHOULD NOT perform congestion control                   |        \
    \ |\n   |                                                         |         |\n\
    \   | for non-IP tunnels or rate not determined by traffic,   | 3.1.3   |\n  \
    \ | SHOULD perform congestion control                       |         |\n   |\
    \                                                         |         |\n   | SHOULD\
    \ NOT send datagrams that exceed the PMTU, i.e.,   | 3.2     |\n   | SHOULD discover\
    \ PMTU or send datagrams < minimum PMTU   |         |\n   |                  \
    \                                       |         |\n   | SHOULD handle datagram\
    \ loss, duplication, reordering    | 3.3     |\n   | SHOULD be robust to delivery\
    \ delays up to 2 minutes     |         |\n   |                               \
    \                          |         |\n   | SHOULD enable IPv4 UDP checksum \
    \                        | 3.4     |\n   | MUST enable IPv6 UDP checksum     \
    \                      |         |\n   | else, MAY use UDP-Lite with suitable\
    \ checksum coverage  | 3.4.1   |\n   |                                       \
    \                  |         |\n   | SHOULD NOT always send middlebox keep-alives\
    \            | 3.5     |\n   | MAY use keep-alives when needed (min. interval\
    \ 15 sec)  |         |\n   |                                                 \
    \        |         |\n   | MUST check IP source address                      \
    \      | 3.6     |\n   | and, for client/server applications                 \
    \    |         |\n   | SHOULD send responses from src address matching request\
    \ |         |\n   |                                                         |\
    \         |\n   | SHOULD use standard IETF security protocols when needed | 4\
    \       |\n   +---------------------------------------------------------+---------+\n\
    \                    Table 1: Summary of recommendations\n"
- title: 6.  Acknowledgments
  contents:
  - "6.  Acknowledgments\n   Thanks to Paul Aitken, Mark Allman, Francois Audet, Iljitsch\
    \ van\n   Beijnum, Stewart Bryant, Remi Denis-Courmont, Lisa Dusseault, Wesley\n\
    \   Eddy, Pasi Eronen, Sally Floyd, Robert Hancock, Jeffrey Hutzelman,\n   Cullen\
    \ Jennings, Tero Kivinen, Peter Koch, Jukka Manner, Philip\n   Matthews, Joerg\
    \ Ott, Colin Perkins, Tom Petch, Carlos Pignataro, Pasi\n   Sarolahti, Pascal\
    \ Thubert, Joe Touch, Dave Ward, and Magnus\n   Westerlund for their comments\
    \ on this document.\n   The middlebox traversal guidelines in Section 3.5 incorporate\
    \ ideas\n   from Section 5 of [BEHAVE-APP] by Bryan Ford, Pyda Srisuresh, and\
    \ Dan\n   Kegel.\n   Lars Eggert is partly funded by [TRILOGY], a research project\n\
    \   supported by the European Commission under its Seventh Framework\n   Program.\
    \  Gorry Fairhurst was partly funded by the EC SatNEx project.\n"
- title: 7.  References
  contents:
  - '7.  References

    '
- title: 7.1.  Normative References
  contents:
  - "7.1.  Normative References\n   [RFC0768]     Postel, J., \"User Datagram Protocol\"\
    , STD 6, RFC 768,\n                 August 1980.\n   [RFC0793]     Postel, J.,\
    \ \"Transmission Control Protocol\", STD 7,\n                 RFC 793, September\
    \ 1981.\n   [RFC1122]     Braden, R., \"Requirements for Internet Hosts -\n  \
    \               Communication Layers\", STD 3, RFC 1122, October 1989.\n   [RFC1191]\
    \     Mogul, J. and S. Deering, \"Path MTU discovery\",\n                 RFC\
    \ 1191, November 1990.\n   [RFC1981]     McCann, J., Deering, S., and J. Mogul,\
    \ \"Path MTU\n                 Discovery for IP version 6\", RFC 1981, August\
    \ 1996.\n   [RFC2119]     Bradner, S., \"Key words for use in RFCs to Indicate\n\
    \                 Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2460]\
    \     Deering, S. and R. Hinden, \"Internet Protocol, Version\n              \
    \   6 (IPv6) Specification\", RFC 2460, December 1998.\n   [RFC2914]     Floyd,\
    \ S., \"Congestion Control Principles\", BCP 41,\n                 RFC 2914, September\
    \ 2000.\n   [RFC2988]     Paxson, V. and M. Allman, \"Computing TCP's\n      \
    \           Retransmission Timer\", RFC 2988, November 2000.\n   [RFC3828]   \
    \  Larzon, L-A., Degermark, M., Pink, S., Jonsson, L-E.,\n                 and\
    \ G. Fairhurst, \"The Lightweight User Datagram\n                 Protocol (UDP-Lite)\"\
    , RFC 3828, July 2004.\n   [RFC4787]     Audet, F. and C. Jennings, \"Network\
    \ Address Translation\n                 (NAT) Behavioral Requirements for Unicast\
    \ UDP\",\n                 BCP 127, RFC 4787, January 2007.\n   [RFC4821]    \
    \ Mathis, M. and J. Heffner, \"Packetization Layer Path\n                 MTU\
    \ Discovery\", RFC 4821, March 2007.\n   [RFC5348]     Floyd, S., Handley, M.,\
    \ Padhye, J., and J. Widmer, \"TCP\n                 Friendly Rate Control (TFRC):\
    \ Protocol Specification\",\n                 RFC 5348, September 2008.\n"
- title: 7.2.  Informative References
  contents:
  - "7.2.  Informative References\n   [BEHAVE-APP]  Ford, B., \"Application Design\
    \ Guidelines for Traversal\n                 through Network Address Translators\"\
    , Work in Progress,\n                 March 2007.\n   [CCID4]       Floyd, S.\
    \ and E. Kohler, \"Profile for Datagram\n                 Congestion Control Protocol\
    \ (DCCP) Congestion ID 4:\n                 TCP-Friendly Rate Control for Small\
    \ Packets (TFRC-SP)\",\n                 Work in Progress, February 2008.\n  \
    \ [FABER]       Faber, T., Touch, J., and W. Yue, \"The TIME-WAIT State\n    \
    \             in TCP and Its Effect on Busy Servers\", Proc. IEEE\n          \
    \       Infocom, March 1999.\n   [GIST]        Schulzrinne, H. and R. Hancock,\
    \ \"GIST: General Internet\n                 Signalling Transport\", Work in Progress,\
    \ July 2008.\n   [ICE]         Rosenberg, J., \"Interactive Connectivity Establishment\n\
    \                 (ICE): A Protocol for Network Address Translator (NAT)\n   \
    \              Traversal for Offer/Answer Protocols\", Work\n                \
    \ in Progress, October 2007.\n   [NSLP]        Stiemerling, M., Tschofenig, H.,\
    \ Aoun, C., and E.\n                 Davies, \"NAT/Firewall NSIS Signaling Layer\
    \ Protocol\n                 (NSLP)\", Work in Progress, September 2008.\n   [POSIX]\
    \       IEEE Std. 1003.1-2001, \"Standard for Information\n                 Technology\
    \ - Portable Operating System Interface\n                 (POSIX)\", Open Group\
    \ Technical Standard: Base\n                 Specifications Issue 6, ISO/IEC 9945:2002,\n\
    \                 December 2001.\n   [RFC0896]     Nagle, J., \"Congestion control\
    \ in IP/TCP\n                 internetworks\", RFC 896, January 1984.\n   [RFC0919]\
    \     Mogul, J., \"Broadcasting Internet Datagrams\", STD 5,\n               \
    \  RFC 919, October 1984.\n   [RFC1112]     Deering, S., \"Host extensions for\
    \ IP multicasting\",\n                 STD 5, RFC 1112, August 1989.\n   [RFC1536]\
    \     Kumar, A., Postel, J., Neuman, C., Danzig, P., and S.\n                \
    \ Miller, \"Common DNS Implementation Errors and Suggested\n                 Fixes\"\
    , RFC 1536, October 1993.\n   [RFC1546]     Partridge, C., Mendez, T., and W.\
    \ Milliken, \"Host\n                 Anycasting Service\", RFC 1546, November\
    \ 1993.\n   [RFC2309]     Braden, B., Clark, D., Crowcroft, J., Davie, B.,\n \
    \                Deering, S., Estrin, D., Floyd, S., Jacobson, V.,\n         \
    \        Minshall, G., Partridge, C., Peterson, L.,\n                 Ramakrishnan,\
    \ K., Shenker, S., Wroclawski, J., and L.\n                 Zhang, \"Recommendations\
    \ on Queue Management and\n                 Congestion Avoidance in the Internet\"\
    , RFC 2309,\n                 April 1998.\n   [RFC2475]     Blake, S., Black,\
    \ D., Carlson, M., Davies, E., Wang,\n                 Z., and W. Weiss, \"An\
    \ Architecture for Differentiated\n                 Services\", RFC 2475, December\
    \ 1998.\n   [RFC2675]     Borman, D., Deering, S., and R. Hinden, \"IPv6\n   \
    \              Jumbograms\", RFC 2675, August 1999.\n   [RFC2743]     Linn, J.,\
    \ \"Generic Security Service Application Program\n                 Interface Version\
    \ 2, Update 1\", RFC 2743, January 2000.\n   [RFC3048]     Whetten, B., Vicisano,\
    \ L., Kermode, R., Handley, M.,\n                 Floyd, S., and M. Luby, \"Reliable\
    \ Multicast Transport\n                 Building Blocks for One-to-Many Bulk-Data\
    \ Transfer\",\n                 RFC 3048, January 2001.\n   [RFC3124]     Balakrishnan,\
    \ H. and S. Seshan, \"The Congestion\n                 Manager\", RFC 3124, June\
    \ 2001.\n   [RFC3261]     Rosenberg, J., Schulzrinne, H., Camarillo, G.,\n   \
    \              Johnston, A., Peterson, J., Sparks, R., Handley, M.,\n        \
    \         and E. Schooler, \"SIP: Session Initiation Protocol\",\n           \
    \      RFC 3261, June 2002.\n   [RFC3303]     Srisuresh, P., Kuthan, J., Rosenberg,\
    \ J., Molitor, A.,\n                 and A. Rayhan, \"Middlebox communication\
    \ architecture\n                 and framework\", RFC 3303, August 2002.\n   [RFC3493]\
    \     Gilligan, R., Thomson, S., Bound, J., McCann, J., and\n                \
    \ W. Stevens, \"Basic Socket Interface Extensions for\n                 IPv6\"\
    , RFC 3493, February 2003.\n   [RFC3550]     Schulzrinne, H., Casner, S., Frederick,\
    \ R., and V.\n                 Jacobson, \"RTP: A Transport Protocol for Real-Time\n\
    \                 Applications\", STD 64, RFC 3550, July 2003.\n   [RFC3551] \
    \    Schulzrinne, H. and S. Casner, \"RTP Profile for Audio\n                \
    \ and Video Conferences with Minimal Control\", STD 65,\n                 RFC\
    \ 3551, July 2003.\n   [RFC3711]     Baugher, M., McGrew, D., Naslund, M., Carrara,\
    \ E., and\n                 K. Norrman, \"The Secure Real-time Transport Protocol\n\
    \                 (SRTP)\", RFC 3711, March 2004.\n   [RFC3738]     Luby, M. and\
    \ V. Goyal, \"Wave and Equation Based Rate\n                 Control (WEBRC) Building\
    \ Block\", RFC 3738, April 2004.\n   [RFC3758]     Stewart, R., Ramalho, M., Xie,\
    \ Q., Tuexen, M., and P.\n                 Conrad, \"Stream Control Transmission\
    \ Protocol (SCTP)\n                 Partial Reliability Extension\", RFC 3758,\
    \ May 2004.\n   [RFC3819]     Karn, P., Bormann, C., Fairhurst, G., Grossman,\
    \ D.,\n                 Ludwig, R., Mahdavi, J., Montenegro, G., Touch, J., and\n\
    \                 L. Wood, \"Advice for Internet Subnetwork Designers\",\n   \
    \              BCP 89, RFC 3819, July 2004.\n   [RFC3851]     Ramsdell, B., \"\
    Secure/Multipurpose Internet Mail\n                 Extensions (S/MIME) Version\
    \ 3.1 Message Specification\",\n                 RFC 3851, July 2004.\n   [RFC3852]\
    \     Housley, R., \"Cryptographic Message Syntax (CMS)\",\n                 RFC\
    \ 3852, July 2004.\n   [RFC4301]     Kent, S. and K. Seo, \"Security Architecture\
    \ for the\n                 Internet Protocol\", RFC 4301, December 2005.\n  \
    \ [RFC4302]     Kent, S., \"IP Authentication Header\", RFC 4302,\n          \
    \       December 2005.\n   [RFC4303]     Kent, S., \"IP Encapsulating Security\
    \ Payload (ESP)\",\n                 RFC 4303, December 2005.\n   [RFC4306]  \
    \   Kaufman, C., \"Internet Key Exchange (IKEv2) Protocol\",\n               \
    \  RFC 4306, December 2005.\n   [RFC4340]     Kohler, E., Handley, M., and S.\
    \ Floyd, \"Datagram\n                 Congestion Control Protocol (DCCP)\", RFC\
    \ 4340,\n                 March 2006.\n   [RFC4341]     Floyd, S. and E. Kohler,\
    \ \"Profile for Datagram\n                 Congestion Control Protocol (DCCP)\
    \ Congestion Control\n                 ID 2: TCP-like Congestion Control\", RFC\
    \ 4341,\n                 March 2006.\n   [RFC4342]     Floyd, S., Kohler, E.,\
    \ and J. Padhye, \"Profile for\n                 Datagram Congestion Control Protocol\
    \ (DCCP) Congestion\n                 Control ID 3: TCP-Friendly Rate Control\
    \ (TFRC)\",\n                 RFC 4342, March 2006.\n   [RFC4347]     Rescorla,\
    \ E. and N. Modadugu, \"Datagram Transport Layer\n                 Security\"\
    , RFC 4347, April 2006.\n   [RFC4654]     Widmer, J. and M. Handley, \"TCP-Friendly\
    \ Multicast\n                 Congestion Control (TFMCC): Protocol Specification\"\
    ,\n                 RFC 4654, August 2006.\n   [RFC4880]     Callas, J., Donnerhacke,\
    \ L., Finney, H., Shaw, D., and\n                 R. Thayer, \"OpenPGP Message\
    \ Format\", RFC 4880,\n                 November 2007.\n   [RFC4960]     Stewart,\
    \ R., \"Stream Control Transmission Protocol\",\n                 RFC 4960, September\
    \ 2007.\n   [RFC4963]     Heffner, J., Mathis, M., and B. Chandler, \"IPv4\n \
    \                Reassembly Errors at High Data Rates\", RFC 4963,\n         \
    \        July 2007.\n   [RFC4987]     Eddy, W., \"TCP SYN Flooding Attacks and\
    \ Common\n                 Mitigations\", RFC 4987, August 2007.\n   [RFC5082]\
    \     Gill, V., Heasley, J., Meyer, D., Savola, P., and C.\n                 Pignataro,\
    \ \"The Generalized TTL Security Mechanism\n                 (GTSM)\", RFC 5082,\
    \ October 2007.\n   [STEVENS]     Stevens, W., Fenner, B., and A. Rudoff, \"UNIX\
    \ Network\n                 Programming, The sockets Networking API\", Addison-\n\
    \                 Wesley, 2004.\n   [TRILOGY]     \"Trilogy Project\", <http://www.trilogy-project.org>.\n\
    \   [UPnP]        UPnP Forum, \"Internet Gateway Device (IGD) Standardized\n \
    \                Device Control Protocol V 1.0\", November 2001.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Lars Eggert\n   Nokia Research Center\n   P.O. Box 407\n\
    \   Nokia Group  00045\n   Finland\n   Phone: +358 50 48 24461\n   EMail: lars.eggert@nokia.com\n\
    \   URI:   http://people.nokia.net/~lars/\n   Godred Fairhurst\n   University\
    \ of Aberdeen\n   Department of Engineering\n   Fraser Noble Building\n   Aberdeen\
    \  AB24 3UE\n   Scotland\n   EMail: gorry@erg.abdn.ac.uk\n   URI:   http://www.erg.abdn.ac.uk/\n"
