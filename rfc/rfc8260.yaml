- contents:
  - "            Stream Schedulers and User Message Interleaving\n              for
    the Stream Control Transmission Protocol\n"
  title: __initial_text__
- contents:
  - "Abstract\n   The Stream Control Transmission Protocol (SCTP) is a message-oriented\n
    \  transport protocol supporting arbitrarily large user messages.  This\n   document
    adds a new chunk to SCTP for carrying payload data.  This\n   allows a sender
    to interleave different user messages that would\n   otherwise result in head-of-line
    blocking at the sender.  The\n   interleaving of user messages is required for
    WebRTC data channels.\n   Whenever an SCTP sender is allowed to send user data,
    it may choose\n   from multiple outgoing SCTP streams.  Multiple ways for performing\n
    \  this selection, called stream schedulers, are defined in this\n   document.
    \ A stream scheduler can choose to either implement, or not\n   implement, user
    message interleaving.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8260.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2017 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   4\n     1.1.  Overview  . . . . . . . . . . . . . . . . . . . . .
    . . .   4\n     1.2.  Conventions . . . . . . . . . . . . . . . . . . . . . .
    .   6\n   2.  User Message Interleaving . . . . . . . . . . . . . . . . . .   6\n
    \    2.1.  The I-DATA Chunk Supporting User Message Interleaving . .   7\n     2.2.
    \ Procedures  . . . . . . . . . . . . . . . . . . . . . . .   9\n       2.2.1.
    \ Negotiation . . . . . . . . . . . . . . . . . . . . .  10\n       2.2.2.  Sender-Side
    Considerations  . . . . . . . . . . . . .  10\n       2.2.3.  Receiver-Side Considerations
    \ . . . . . . . . . . . .  11\n     2.3.  Interaction with Other SCTP Extensions
    \ . . . . . . . . .  11\n       2.3.1.  SCTP Partial Reliability Extension  .
    . . . . . . . .  11\n       2.3.2.  SCTP Stream Reconfiguration Extension . .
    . . . . . .  13\n   3.  Stream Schedulers . . . . . . . . . . . . . . . . . .
    . . . .  14\n     3.1.  First-Come, First-Served Scheduler (SCTP_SS_FCFS) . .
    . .  14\n     3.2.  Round-Robin Scheduler (SCTP_SS_RR)  . . . . . . . . . . .
    \ 14\n     3.3.  Round-Robin Scheduler per Packet (SCTP_SS_RR_PKT) . . . .  14\n
    \    3.4.  Priority-Based Scheduler (SCTP_SS_PRIO) . . . . . . . . .  14\n     3.5.
    \ Fair Capacity Scheduler (SCTP_SS_FC)  . . . . . . . . . .  15\n     3.6.  Weighted
    Fair Queueing Scheduler (SCTP_SS_WFQ)  . . . . .  15\n   4.  Socket API Considerations
    . . . . . . . . . . . . . . . . . .  15\n     4.1.  Exposure of the Stream Sequence
    Number (SSN)  . . . . . .  15\n     4.2.  SCTP_ASSOC_CHANGE Notification  . .
    . . . . . . . . . . .  16\n     4.3.  Socket Options  . . . . . . . . . . . .
    . . . . . . . . .  16\n       4.3.1.  Enable or Disable the Support of User Message\n
    \              Interleaving (SCTP_INTERLEAVING_SUPPORTED)  . . . . .  16\n       4.3.2.
    \ Get or Set the Stream Scheduler\n               (SCTP_STREAM_SCHEDULER) . .
    . . . . . . . . . . . . .  17\n       4.3.3.  Get or Set the Stream Scheduler
    Parameter\n               (SCTP_STREAM_SCHEDULER_VALUE) . . . . . . . . . . .
    .  18\n     4.4.  Explicit EOR Marking  . . . . . . . . . . . . . . . . . .  19\n
    \  5.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  19\n     5.1.
    \ I-DATA Chunk  . . . . . . . . . . . . . . . . . . . . . .  19\n     5.2.  I-FORWARD-TSN
    Chunk . . . . . . . . . . . . . . . . . . .  20\n   6.  Security Considerations
    . . . . . . . . . . . . . . . . . . .  20\n   7.  References  . . . . . . . .
    . . . . . . . . . . . . . . . . .  21\n     7.1.  Normative References  . . .
    . . . . . . . . . . . . . . .  21\n     7.2.  Informative References  . . . .
    . . . . . . . . . . . . .  22\n   Acknowledgments . . . . . . . . . . . . . .
    . . . . . . . . . . .  22\n   Authors' Addresses  . . . . . . . . . . . . . .
    . . . . . . . . .  23\n"
  title: Table of Contents
- contents:
  - '1.  Introduction

    '
  - contents:
    - "1.1.  Overview\n   When SCTP [RFC4960] was initially designed, it was mainly
      envisioned\n   for the transport of small signaling messages.  Late in the design\n
      \  stage, it was decided to add support for fragmentation and reassembly\n   of
      larger messages with the thought that someday signaling messages\n   in the
      style of Session Initiation Protocol (SIP) [RFC3261] may also\n   need to use
      SCTP, and a message that is a single Maximum Transmission\n   Unit (MTU) would
      be too small.  Unfortunately this design decision,\n   though valid at the time,
      did not account for other applications that\n   might send large messages over
      SCTP.  The sending of such large\n   messages over SCTP, as specified in [RFC4960],
      can result in a form\n   of sender-side head-of-line blocking (e.g., when the
      transmission of\n   a message is blocked from transmission because the sender
      has started\n   the transmission of another, possibly large, message).  This
      head-of-\n   line blocking is caused by the use of the Transmission Sequence\n
      \  Number (TSN) for three different purposes:\n   1.  As an identifier for DATA
      chunks to provide a reliable transfer.\n   2.  As an identifier for the sequence
      of fragments to allow\n       reassembly.\n   3.  As a sequence number allowing
      up to 2**16 - 1 Stream Sequence\n       Numbers (SSNs) outstanding.\n   The
      protocol requires all fragments of a user message to have\n   consecutive TSNs.
      \ This document allows an SCTP sender to interleave\n   different user messages.\n
      \  This document also defines several stream schedulers for general SCTP\n   associations
      allowing different relative stream treatments.  The\n   stream schedulers may
      behave differently depending on whether or not\n   user message interleaving
      has been negotiated for the association.\n   Figure 1 illustrates the behavior
      of a round-robin stream scheduler\n   using DATA chunks when three streams with
      the Stream Identifiers\n   (SIDs) 0, 1, and 2 are used.  Each queue for SID
      0 and SID 2 contains\n   a single user message requiring three chunks.  The
      queue for SID 1\n   contains three user messages each requiring a single chunk.
      \ It is\n   shown how these user messages are encapsulated in chunks using TSN
      0\n   to TSN 8.  Please note that the use of such a scheduler implies late\n
      \  TSN assignment, but it can be used with an implementation that is\n   compliant
      with [RFC4960] and that does not support user message\n   interleaving.  Late
      TSN assignment means that the sender generates\n   chunks from user messages
      and assigns the TSN as late as possible in\n   the process of sending the user
      messages.\n   +---+---+---+\n   |    0/0    |-+\n   +---+---+---+ |\n                 |
      \ +---+---+---+---+---+---+---+---+---+\n   +---+---+---+ +->|1/2|1/1|2/0|2/0|2/0|1/0|0/0|0/0|0/0|\n
      \  |1/2|1/1|1/0|--->|---|---|---|---|---|---|---|---|---|\n   +---+---+---+
      +->| 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\n                 |  +---+---+---+---+---+---+---+---+---+\n
      \  +---+---+---+ |\n   |    2/0    |-+\n   +---+---+---+\n                                  +-------+\n
      \    +-------+                    |SID/SSN|\n     |SID/SSN|                    |-------|\n
      \    +-------+                    |  TSN  |\n                                  +-------+\n
      \    Figure 1: Round-Robin Scheduler without User Message Interleaving\n   This
      document describes a new chunk carrying payload data called\n   I-DATA.  This
      chunk incorporates the properties of the current SCTP\n   DATA chunk, all the
      flags and fields except the Stream Sequence\n   Number (SSN), and also adds
      two new fields in its chunk header -- the\n   Fragment Sequence Number (FSN)
      and the Message Identifier (MID).  The\n   FSN is only used for reassembling
      all fragments that have the same\n   MID and the same ordering property.  The
      TSN is only used for the\n   reliable transfer in combination with Selective
      Acknowledgment (SACK)\n   chunks.\n   In addition, the MID is also used for
      ensuring ordered delivery\n   instead of using the stream sequence number (the
      I-DATA chunk omits\n   an SSN).\n   Figure 2 illustrates the behavior of an
      interleaving round-robin\n   stream scheduler using I-DATA chunks.\n"
    - '+---+---+---+

      '
    - '|    0/0    |-+

      '
    - "+---+---+---+ |\n              |  +-----+-----+-----+-----+-----+-----+-----+-----+-----+\n"
    - '+---+---+---+ +->|2/0/2|1/2/0|0/0/2|2/0/1|1/1/0|0/0/1|2/0/0|1/0/0|0/0/0|

      '
    - '|1/2|1/1|1/0|--->|-----|-----|-----|-----|-----|-----|-----|-----|-----|

      '
    - "+---+---+---+ +->|  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |  0  |\n
      \             |  +-----+-----+-----+-----+-----+-----+-----+-----+-----+\n"
    - '+---+---+---+ |

      '
    - '|    2/0    |-+

      '
    - "+---+---+---+\n                                     +-----------+\n  +-------+
      \                         |SID/MID/FSN|\n  |SID/MID|                          |-----------|\n
      \ +-------+                          |    TSN    |\n                                     +-----------+\n
      \     Figure 2: Round-Robin Scheduler with User Message Interleaving\n   The
      support of the I-DATA chunk is negotiated during the association\n   setup using
      the Supported Extensions Parameter, as defined in\n   [RFC5061].  If I-DATA
      support has been negotiated for an association,\n   I-DATA chunks are used for
      all user messages.  DATA chunks are not\n   permitted when I-DATA support has
      been negotiated.  It should be\n   noted that an SCTP implementation supporting
      I-DATA chunks needs to\n   allow the coexistence of associations using DATA
      chunks and\n   associations using I-DATA chunks.\n   In Section 2, this document
      specifies the user message interleaving\n   by defining the I-DATA chunk, the
      procedures to use it, and its\n   interactions with other SCTP extensions.  Section
      3 defines multiple\n   stream schedulers, and Section 4 describes an extension
      to the socket\n   API for using the mechanism specified in this document.\n"
    title: 1.1.  Overview
  - contents:
    - "1.2.  Conventions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
      \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\",
      \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described
      in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all\n
      \  capitals, as shown here.\n"
    title: 1.2.  Conventions
  title: 1.  Introduction
- contents:
  - "2.  User Message Interleaving\n   The protocol mechanisms described in this document
    allow the\n   interleaving of user messages sent on different streams.  They do
    not\n   support the interleaving of multiple messages (ordered or unordered)\n
    \  sent on the same stream.\n   The interleaving of user messages is required
    for WebRTC data\n   channels, as specified in [DATA-CHAN].\n   An SCTP implementation
    supporting user message interleaving is\n   REQUIRED to support the coexistence
    of associations using DATA chunks\n   and associations using I-DATA chunks.  If
    an SCTP implementation\n   supports user message interleaving and the Partial
    Reliability\n   extension described in [RFC3758] or the Stream Reconfiguration\n
    \  Extension described in [RFC6525], it is REQUIRED to implement the\n   corresponding
    changes specified in Section 2.3.\n"
  - contents:
    - "2.1.  The I-DATA Chunk Supporting User Message Interleaving\n   The following
      Figure 3 shows the new I-DATA chunk allowing user\n   message interleaving.\n
      \   0                   1                   2                   3\n    0 1 2
      3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |   Type = 64   |  Res  |I|U|B|E|       Length = Variable       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                              TSN                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |        Stream Identifier      |           Reserved            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                      Message Identifier                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |    Payload Protocol Identifier / Fragment Sequence Number     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  \\                                                               \\\n   /
      \                          User Data                           /\n   \\                                                               \\\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                       Figure
      3: I-DATA Chunk Format\n   The only differences between the I-DATA chunk in
      Figure 3 and the\n   DATA chunk defined in [RFC4960] and [RFC7053] are the addition
      of the\n   new Message Identifier (MID) and the new Fragment Sequence Number\n
      \  (FSN) and the removal of the Stream Sequence Number (SSN).  The\n   Payload
      Protocol Identifier (PPID), which is already defined for DATA\n   chunks in
      [RFC4960], and the new FSN are stored at the same location\n   of the packet
      using the B bit to determine which value is stored at\n   the location.  The
      length of the I-DATA chunk header is 20 bytes,\n   which is 4 bytes more than
      the length of the DATA chunk header\n   defined in [RFC4960] and [RFC7053].\n
      \  The old fields are:\n   Res: 4 bits\n      These bits are reserved.  They
      MUST be set to 0 by the sender and\n      MUST be ignored by the receiver.\n
      \  I bit: 1 bit\n      The (I)mmediate Bit, if set, indicates that the receiver
      SHOULD\n      NOT delay the sending of the corresponding SACK chunk.  Same as\n
      \     the I bit for DATA chunks, as specified in [RFC7053].\n   U bit: 1 bit\n
      \     The (U)nordered bit, if set, indicates the user message is\n      unordered.
      \ Same as the U bit for DATA chunks, as specified in\n      [RFC4960].\n   B
      bit: 1 bit\n      The (B)eginning fragment bit, if set, indicates the first
      fragment\n      of a user message.  Same as the B bit for DATA chunks, as\n
      \     specified in [RFC4960].\n   E bit: 1 bit\n      The (E)nding fragment
      bit, if set, indicates the last fragment of\n      a user message.  Same as
      the E bit for DATA chunks, as specified\n      in [RFC4960].\n   Length: 16
      bits (unsigned integer)\n      This field indicates the length in bytes of the
      DATA chunk from\n      the beginning of the Type field to the end of the User
      Data field,\n      excluding any padding.  Similar to the Length for DATA chunks,
      as\n      specified in [RFC4960].\n   TSN: 32 bits (unsigned integer)\n      This
      value represents the TSN for this I-DATA chunk.  Same as the\n      TSN for
      DATA chunks, as specified in [RFC4960].\n   Stream Identifier: 16 bits (unsigned
      integer)\n      Identifies the stream to which the user data belongs.  Same
      as the\n      Stream Identifier for DATA chunks, as specified in [RFC4960].\n
      \  The new fields are:\n   Reserved: 16 bits (unsigned integer)\n      This
      field is reserved.  It MUST be set to 0 by the sender and\n      MUST be ignored
      by the receiver.\n   Message Identifier (MID): 32 bits (unsigned integer)\n
      \     The MID is the same for all fragments of a user message; it is\n      used
      to determine which fragments (enumerated by the FSN) belong\n      to the same
      user message.  For ordered user messages, the MID is\n      also used by the
      SCTP receiver to deliver the user messages in the\n      correct order to the
      upper layer (similar to the SSN of the DATA\n      chunk defined in [RFC4960]).
      \ The sender uses two counters for\n      each outgoing stream: one for ordered
      messages and one for\n      unordered messages.  All of these counters are independent
      and\n      initially 0.  They are incremented by 1 for each user message.\n
      \     Please note that the serial number arithmetic defined in [RFC1982]\n      using
      SERIAL_BITS = 32 applies.  Therefore, the sender MUST NOT\n      have more than
      2**31 - 1 ordered messages for each outgoing stream\n      in flight and MUST
      NOT have more than 2**31 - 1 unordered messages\n      for each outgoing stream
      in flight.  A message is considered in\n      flight if at least one of its
      I-DATA chunks is not acknowledged in\n      a way that cannot be reneged (i.e.,
      not acknowledged by the\n      cumulative TSN Ack).  Please note that the MID
      is in \"network byte\n      order\", a.k.a.  Big Endian.\n   Payload Protocol
      Identifier (PPID) / Fragment Sequence Number (FSN):\n      32 bits (unsigned
      integer)\n      If the B bit is set, this field contains the PPID of the user\n
      \     message.  Note that in this case, this field is not touched by an\n      SCTP
      implementation; therefore, its byte order is not necessarily\n      in network
      byte order.  The upper layer is responsible for any\n      byte order conversions
      to this field, similar to the PPID of DATA\n      chunks.  In this case, the
      FSN is implicitly considered to be 0.\n      If the B bit is not set, this field
      contains the FSN.  The FSN is\n      used to enumerate all fragments of a single
      user message, starting\n      from 0 and incremented by 1.  The last fragment
      of a message MUST\n      have the E bit set.  Note that the FSN MAY wrap completely\n
      \     multiple times, thus allowing arbitrarily large user messages.\n      For
      the FSN, the serial number arithmetic defined in [RFC1982]\n      applies with
      SERIAL_BITS = 32.  Therefore, a sender MUST NOT have\n      more than 2**31
      - 1 fragments of a single user message in flight.\n      A fragment is considered
      in flight if it is not acknowledged in a\n      way that cannot be reneged.
      \ Please note that the FSN is in\n      \"network byte order\", a.k.a.  Big
      Endian.\n"
    title: 2.1.  The I-DATA Chunk Supporting User Message Interleaving
  - contents:
    - "2.2.  Procedures\n   This subsection describes how the support of the I-DATA
      chunk is\n   negotiated and how the I-DATA chunk is used by the sender and\n
      \  receiver.\n   The handling of the I bit for the I-DATA chunk corresponds
      to the\n   handling of the I bit for the DATA chunk described in [RFC7053].\n"
    - contents:
      - "2.2.1.  Negotiation\n   An SCTP endpoint indicates user message interleaving
        support by\n   listing the I-DATA chunk within the Supported Extensions Parameter,\n
        \  as defined in [RFC5061].  User message interleaving has been\n   negotiated
        for an association if both endpoints have indicated I-DATA\n   support.\n
        \  If user message interleaving support has been negotiated for an\n   association,
        I-DATA chunks MUST be used for all user messages and\n   DATA chunks MUST
        NOT be used.  If user message interleaving support\n   has not been negotiated
        for an association, DATA chunks MUST be used\n   for all user messages and
        I-DATA chunks MUST NOT be used.\n   An endpoint implementing the socket API
        specified in [RFC6458] MUST\n   NOT indicate user message interleaving support
        unless the user has\n   requested its use (e.g., via the socket API; see Section
        4.3).  This\n   constraint is made since the usage of this chunk requires
        that the\n   application is capable of handling interleaved messages upon\n
        \  reception within an association.  This is not the default choice\n   within
        the socket API (see the SCTP_FRAGMENT_INTERLEAVE socket option\n   in Section
        8.1.20 of [RFC6458]); thus, the user MUST indicate to the\n   SCTP implementation
        its support for receiving completely interleaved\n   messages.\n   Note that
        stacks that do not implement [RFC6458] may use other\n   methods to indicate
        interleaved message support and thus indicate the\n   support of user message
        interleaving.  The crucial point is that the\n   SCTP stack MUST know that
        the application can handle interleaved\n   messages before indicating the
        I-DATA support.\n"
      title: 2.2.1.  Negotiation
    - contents:
      - "2.2.2.  Sender-Side Considerations\n   The sender-side usage of the I-DATA
        chunk is quite simple.  Instead\n   of using the TSN for fragmentation purposes,
        the sender uses the new\n   FSN field to indicate which fragment number is
        being sent.  The first\n   fragment MUST have the B bit set.  The last fragment
        MUST have the E\n   bit set.  All other fragments MUST NOT have the B or E
        bit set.  All\n   other properties of the existing SCTP DATA chunk also apply
        to the\n   I-DATA chunk, i.e., congestion control as well as receiver window\n
        \  conditions MUST be observed, as defined in [RFC4960].\n   Note that the
        usage of this chunk implies the late assignment of the\n   actual TSN to any
        chunk being sent.  Each I-DATA chunk uses a single\n   TSN.  This way messages
        from other streams may be interleaved with\n   the fragmented message.  Please
        note that this is the only form of\n   interleaving support.  For example,
        it is not possible to interleave\n   multiple ordered or unordered user messages
        from the same stream.\n   The sender MUST NOT process (move user data into
        I-DATA chunks and\n   assign a TSN to it) more than one user message in any
        given stream at\n   any time.  At any time, a sender MAY process multiple
        user messages,\n   each of them on different streams.\n   The sender MUST
        assign TSNs to I-DATA chunks in a way that the\n   receiver can make progress.
        \ One way to achieve this is to assign a\n   higher TSN to the later fragments
        of a user message and send out the\n   I-DATA chunks such that the TSNs are
        in sequence.\n"
      title: 2.2.2.  Sender-Side Considerations
    - contents:
      - "2.2.3.  Receiver-Side Considerations\n   Upon reception of an SCTP packet
        containing an I-DATA chunk whose\n   user message needs to be reassembled,
        the receiver MUST first use the\n   SID to identify the stream, consider the
        U bit to determine if it is\n   part of an ordered or unordered message, find
        the user message\n   identified by the MID, and use the FSN for reassembly
        of the message\n   and not the TSN.  The receiver MUST NOT make any assumption
        about the\n   TSN assignments of the sender.  Note that a non-fragmented message
        is\n   indicated by the fact that both the E and B bits are set.  A message\n
        \  (either ordered or unordered) whose E and B bits are not both set may\n
        \  be identified as being fragmented.\n   If I-DATA support has been negotiated
        for an association, the\n   reception of a DATA chunk is a violation of the
        above rules and\n   therefore the receiver of the DATA chunk MUST abort the
        association\n   by sending an ABORT chunk.  The ABORT chunk MAY include the
        'Protocol\n   Violation' error cause.  The same applies if I-DATA support
        has not\n   been negotiated for an association and an I-DATA chunk is received.\n"
      title: 2.2.3.  Receiver-Side Considerations
    title: 2.2.  Procedures
  - contents:
    - "2.3.  Interaction with Other SCTP Extensions\n   The usage of the I-DATA chunk
      might interfere with other SCTP\n   extensions.  Future SCTP extensions MUST
      describe if and how they\n   interfere with the usage of I-DATA chunks.  For
      the SCTP extensions\n   already defined when this document was published, the
      details are\n   given in the following subsections.\n"
    - contents:
      - "2.3.1.  SCTP Partial Reliability Extension\n   When the SCTP extension defined
        in [RFC3758] is used in combination\n   with the user message interleaving
        extension, the new I-FORWARD-TSN\n   chunk MUST be used instead of the FORWARD-TSN
        chunk.  The difference\n   between the FORWARD-TSN and the I-FORWARD-TSN chunk
        is that the\n   16-bit Stream Sequence Number (SSN) has been replaced by the
        32-bit\n   Message Identifier (MID), and the largest skipped MID can also
        be\n   provided for unordered messages.  Therefore, the principle applied
        to\n   ordered messages when using FORWARD-TSN chunks is applied to ordered\n
        \  and unordered messages when using I-FORWARD-TSN chunks.\n    0                   1
        \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |   Type = 194  | Flags = 0x00  |      Length = Variable        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                       New Cumulative TSN                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |       Stream Identifier       |          Reserved           |U|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                       Message Identifier                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  \\                                                               \\\n   /
        \                                                              /\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |       Stream Identifier       |          Reserved           |U|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                       Message Identifier                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \                  Figure 4: I-FORWARD-TSN Chunk Format\n   The old fields
        are:\n   Flags: 8 bits (unsigned integer)\n      These bits are reserved.
        \ They MUST be set to 0 by the sender and\n      MUST be ignored by the receiver.
        \ Same as the Flags for FORWARD\n      TSN chunks, as specified in [RFC3758].\n
        \  Length: 16 bits (unsigned integer)\n      This field holds the length of
        the chunk.  Similar to the Length\n      for FORWARD TSN chunks, as specified
        in [RFC3758].\n   New Cumulative TSN: 32 bits (unsigned integer)\n      This
        indicates the New Cumulative TSN to the data receiver.  Same\n      as the
        New Cumulative TSN for FORWARD TSN chunks, as specified in\n      [RFC3758].\n
        \  The new fields are:\n   Stream Identifier (SID): 16 bits (unsigned integer)\n
        \     This field holds the stream number this entry refers to.\n   Reserved:
        15 bits\n      This field is reserved.  It MUST be set to 0 by the sender
        and\n      MUST be ignored by the receiver.\n   U bit: 1 bit\n      The U
        bit specifies if the Message Identifier of this entry refers\n      to unordered
        messages (U bit is set) or ordered messages (U bit is\n      not set).\n   Message
        Identifier (MID): 32 bits (unsigned integer)\n      This field holds the largest
        Message Identifier for ordered or\n      unordered messages indicated by the
        U bit that was skipped for the\n      stream specified by the Stream Identifier.
        \ For ordered messages,\n      this is similar to the FORWARD-TSN chunk, just
        replacing the\n      16-bit SSN by the 32-bit MID.\n   Support for the I-FORWARD-TSN
        chunk is negotiated during the SCTP\n   association setup via the Supported
        Extensions Parameter, as defined\n   in [RFC5061].  The partial reliability
        extension is negotiated and\n   can be used in combination with user message
        interleaving only if\n   both endpoints indicated their support of user message
        interleaving\n   and the I-FORWARD-TSN chunk.\n   The FORWARD-TSN chunk MUST
        be used in combination with the DATA chunk\n   and MUST NOT be used in combination
        with the I-DATA chunk.  The\n   I-FORWARD-TSN chunk MUST be used in combination
        with the I-DATA chunk\n   and MUST NOT be used in combination with the DATA
        chunk.\n   If I-FORWARD-TSN support has been negotiated for an association,
        the\n   reception of a FORWARD-TSN chunk is a violation of the above rules\n
        \  and therefore the receiver of the FORWARD-TSN chunk MUST abort the\n   association
        by sending an ABORT chunk.  The ABORT chunk MAY include\n   the 'Protocol
        Violation' error cause.  The same applies if\n   I-FORWARD-TSN support has
        not been negotiated for an association and\n   a FORWARD-TSN chunk is received.\n"
      title: 2.3.1.  SCTP Partial Reliability Extension
    - contents:
      - "2.3.2.  SCTP Stream Reconfiguration Extension\n   When an association resets
        the SSN using the SCTP extension defined\n   in [RFC6525], the two counters
        (one for the ordered messages, one for\n   the unordered messages) used for
        the MIDs MUST be reset to 0.\n   Since most schedulers, especially all schedulers
        supporting user\n   message interleaving, require late TSN assignment, it
        should be noted\n   that the implementation of [RFC6525] needs to handle this.\n"
      title: 2.3.2.  SCTP Stream Reconfiguration Extension
    title: 2.3.  Interaction with Other SCTP Extensions
  title: 2.  User Message Interleaving
- contents:
  - "3.  Stream Schedulers\n   This section defines several stream schedulers.  The
    stream\n   schedulers may behave differently depending on whether or not user\n
    \  message interleaving has been negotiated for the association.  An\n   implementation
    MAY implement any subset of them.  If the\n   implementation is used for WebRTC
    data channels, as specified in\n   [DATA-CHAN], it MUST implement the Weighted
    Fair Queueing Scheduler\n   defined in Section 3.6.\n   The selection of the stream
    scheduler is done at the sender side.\n   There is no mechanism provided for signaling
    the stream scheduler\n   being used to the receiver side or even for letting the
    receiver side\n   influence the selection of the stream scheduler used at the
    sender\n   side.\n"
  - contents:
    - "3.1.  First-Come, First-Served Scheduler (SCTP_SS_FCFS)\n   The simple first-come,
      first-served scheduler of user messages is\n   used.  It just passes through
      the messages in the order in which they\n   have been delivered by the application.
      \ No modification of the order\n   is done at all.  The usage of user message
      interleaving does not\n   affect the sending of the chunks, except that I-DATA
      chunks are used\n   instead of DATA chunks.\n"
    title: 3.1.  First-Come, First-Served Scheduler (SCTP_SS_FCFS)
  - contents:
    - "3.2.  Round-Robin Scheduler (SCTP_SS_RR)\n   When not interleaving user messages,
      this scheduler provides a fair\n   scheduling based on the number of user messages
      by cycling around\n   non-empty stream queues.  When interleaving user messages,
      this\n   scheduler provides a fair scheduling based on the number of I-DATA\n
      \  chunks by cycling around non-empty stream queues.\n"
    title: 3.2.  Round-Robin Scheduler (SCTP_SS_RR)
  - contents:
    - "3.3.  Round-Robin Scheduler per Packet (SCTP_SS_RR_PKT)\n   This is a round-robin
      scheduler, which only switches streams when\n   starting to fill a new packet.
      \ It bundles only DATA or I-DATA chunks\n   referring to the same stream in
      a packet.  This scheduler minimizes\n   head-of-line blocking when a packet
      is lost because only a single\n   stream is affected.\n"
    title: 3.3.  Round-Robin Scheduler per Packet (SCTP_SS_RR_PKT)
  - contents:
    - "3.4.  Priority-Based Scheduler (SCTP_SS_PRIO)\n   Scheduling of user messages
      with strict priorities is used.  The\n   priority is configurable per outgoing
      SCTP stream.  Streams having a\n   higher priority will be scheduled first and
      when multiple streams\n   have the same priority, the scheduling between them
      is implementation\n   dependent.  When the scheduler interleaves user messages,
      the sending\n   of large, lower-priority user messages will not delay the sending
      of\n   higher-priority user messages.\n"
    title: 3.4.  Priority-Based Scheduler (SCTP_SS_PRIO)
  - contents:
    - "3.5.  Fair Capacity Scheduler (SCTP_SS_FC)\n   A fair capacity distribution
      between the streams is used.  This\n   scheduler considers the lengths of the
      messages of each stream and\n   schedules them in a specific way to maintain
      an equal capacity for\n   all streams.  The details are implementation dependent.
      \ interleaving\n   user messages allows for a better realization of the fair
      capacity\n   usage.\n"
    title: 3.5.  Fair Capacity Scheduler (SCTP_SS_FC)
  - contents:
    - "3.6.  Weighted Fair Queueing Scheduler (SCTP_SS_WFQ)\n   A Weighted Fair Queueing
      scheduler between the streams is used.  The\n   weight is configurable per outgoing
      SCTP stream.  This scheduler\n   considers the lengths of the messages of each
      stream and schedules\n   them in a specific way to use the capacity according
      to the given\n   weights.  If the weight of stream S1 is n times the weight
      of stream\n   S2, the scheduler should assign to stream S1 n times the capacity
      it\n   assigns to stream S2.  The details are implementation dependent.\n   Interleaving
      user messages allows for a better realization of the\n   capacity usage according
      to the given weights.\n   This scheduler, in combination with user message interleaving,
      is\n   used for WebRTC data channels, as specified in [DATA-CHAN].\n"
    title: 3.6.  Weighted Fair Queueing Scheduler (SCTP_SS_WFQ)
  title: 3.  Stream Schedulers
- contents:
  - "4.  Socket API Considerations\n   This section describes how the socket API defined
    in [RFC6458] is\n   extended to allow applications to use the extension described
    in this\n   document.\n   Please note that this section is informational only.\n"
  - contents:
    - "4.1.  Exposure of the Stream Sequence Number (SSN)\n   The socket API defined
      in [RFC6458] defines several structures in\n   which the SSN of a received user
      message is exposed to the\n   application.  The list of these structures includes:\n
      \  struct sctp_sndrcvinfo\n      Specified in Section 5.3.2 of [RFC6458] and
      marked as deprecated.\n   struct sctp_extrcvinfo\n      Specified in Section
      5.3.3 of [RFC6458] and marked as deprecated.\n   struct sctp_rcvinfo\n      Specified
      in Section 5.3.5 of [RFC6458].\n   If user message interleaving is used, the
      lower-order 16 bits of the\n   MID are used as the SSN when filling out these
      structures.\n"
    title: 4.1.  Exposure of the Stream Sequence Number (SSN)
  - contents:
    - "4.2.  SCTP_ASSOC_CHANGE Notification\n   When an SCTP_ASSOC_CHANGE notification
      (specified in Section 6.1.1 of\n   [RFC6458]) is delivered indicating a sac_state
      of SCTP_COMM_UP or\n   SCTP_RESTART for an SCTP association where both peers
      support the\n   I-DATA chunk, SCTP_ASSOC_SUPPORTS_INTERLEAVING should be listed
      in\n   the sac_info field.\n"
    title: 4.2.  SCTP_ASSOC_CHANGE Notification
  - contents:
    - "4.3.  Socket Options\n   +-----------------------------+-------------------------+-----+-----+\n
      \  | Option Name                 | Data Type               | Get | Set |\n   +-----------------------------+-------------------------+-----+-----+\n
      \  | SCTP_INTERLEAVING_SUPPORTED | struct sctp_assoc_value |  X  |  X  |\n   |
      SCTP_STREAM_SCHEDULER       | struct sctp_assoc_value |  X  |  X  |\n   | SCTP_STREAM_SCHEDULER_VALUE
      | struct                  |  X  |  X  |\n   |                             |
      sctp_stream_value       |     |     |\n   +-----------------------------+-------------------------+-----+-----+\n"
    - contents:
      - "4.3.1.  Enable or Disable the Support of User Message Interleaving\n        (SCTP_INTERLEAVING_SUPPORTED)\n
        \  This socket option allows the enabling or disabling of the\n   negotiation
        of user message interleaving support for future\n   associations.  For existing
        associations, it allows for querying\n   whether or not user message interleaving
        support was negotiated on a\n   particular association.\n   This socket option
        uses IPPROTO_SCTP as its level and\n   SCTP_INTERLEAVING_SUPPORTED as its
        name.  It can be used with\n   getsockopt() and setsockopt().  The socket
        option value uses the\n   following structure defined in [RFC6458]:\n   struct
        sctp_assoc_value {\n     sctp_assoc_t assoc_id;\n     uint32_t assoc_value;\n
        \  };\n   assoc_id:  This parameter is ignored for one-to-one style sockets.\n
        \     For one-to-many style sockets, this parameter indicates upon which\n
        \     association the user is performing an action.  The special\n      sctp_assoc_t
        SCTP_FUTURE_ASSOC can also be used; it is an error to\n      use SCTP_{CURRENT|ALL}_ASSOC
        in assoc_id.\n   assoc_value:  A non-zero value encodes the enabling of user
        message\n      interleaving, whereas a value of zero encodes the disabling
        of\n      user message interleaving.\n   sctp_opt_info() needs to be extended
        to support\n   SCTP_INTERLEAVING_SUPPORTED.\n   An application using user
        message interleaving should also set the\n   fragment interleave level to
        2 by using the SCTP_FRAGMENT_INTERLEAVE\n   socket option specified in Section
        8.1.20 of [RFC6458].  This allows\n   the interleaving of user messages from
        different streams.  Please\n   note that it does not allow the interleaving
        of user messages\n   (ordered or unordered) on the same stream.  Failure to
        set this\n   option can possibly lead to application deadlock.  Some\n   implementations
        might therefore put some restrictions on setting\n   combinations of these
        values.  Setting the interleaving level to at\n   least 2 before enabling
        the negotiation of user message interleaving\n   should work on all platforms.
        \ Since the default fragment interleave\n   level is not 2, user message interleaving
        is disabled per default.\n"
      title: 4.3.1.  Enable or Disable the Support of User Message Interleaving
    - contents:
      - "4.3.2.  Get or Set the Stream Scheduler (SCTP_STREAM_SCHEDULER)\n   A stream
        scheduler can be selected with the SCTP_STREAM_SCHEDULER\n   option for setsockopt().
        \ The struct sctp_assoc_value is used to\n   specify the association for which
        the scheduler should be changed and\n   the value of the desired algorithm.\n
        \  The definition of struct sctp_assoc_value is the same as in\n   [RFC6458]:\n
        \  struct sctp_assoc_value {\n     sctp_assoc_t assoc_id;\n     uint32_t assoc_value;\n
        \  };\n   assoc_id:  Holds the identifier of the association for which the\n
        \     scheduler should be changed.  The special\n      SCTP_{FUTURE|CURRENT|ALL}_ASSOC
        can also be used.  This parameter\n      is ignored for one-to-one style sockets.\n
        \  assoc_value:  This specifies which scheduler is used.  The following\n
        \     constants can be used:\n      SCTP_SS_DEFAULT:  The default scheduler
        used by the SCTP\n         implementation.  Typical values are SCTP_SS_FCFS
        or SCTP_SS_RR.\n      SCTP_SS_FCFS:  Use the scheduler specified in Section
        3.1.\n      SCTP_SS_RR:  Use the scheduler specified in Section 3.2.\n      SCTP_SS_RR_PKT:
        \ Use the scheduler specified in Section 3.3.\n      SCTP_SS_PRIO:  Use the
        scheduler specified in Section 3.4.  The\n         priority can be assigned
        with the sctp_stream_value struct.\n         The higher the assigned value,
        the lower the priority.  That\n         is, the default value 0 is the highest
        priority, and therefore\n         the default scheduling will be used if no
        priorities have been\n         assigned.\n      SCTP_SS_FB:  Use the scheduler
        specified in Section 3.5.\n      SCTP_SS_WFQ:  Use the scheduler specified
        in Section 3.6.  The\n         weight can be assigned with the sctp_stream_value
        struct.\n   sctp_opt_info() needs to be extended to support\n   SCTP_STREAM_SCHEDULER.\n"
      title: 4.3.2.  Get or Set the Stream Scheduler (SCTP_STREAM_SCHEDULER)
    - contents:
      - "4.3.3.  Get or Set the Stream Scheduler Parameter\n        (SCTP_STREAM_SCHEDULER_VALUE)\n
        \  Some schedulers require additional information to be set for\n   individual
        streams as shown in the following table:\n                   +-----------------+-----------------+\n
        \                  | Name            | Per-Stream Info |\n                   +-----------------+-----------------+\n
        \                  | SCTP_SS_DEFAULT |       n/a       |\n                   |
        SCTP_SS_FCFS    |        no       |\n                   | SCTP_SS_RR      |
        \       no       |\n                   | SCTP_SS_RR_PKT  |        no       |\n
        \                  | SCTP_SS_PRIO    |       yes       |\n                   |
        SCTP_SS_FB      |        no       |\n                   | SCTP_SS_WFQ     |
        \      yes       |\n                   +-----------------+-----------------+\n
        \  This is achieved with the SCTP_STREAM_SCHEDULER_VALUE option and the\n
        \  corresponding struct sctp_stream_value.  The definition of struct\n   sctp_stream_value
        is as follows:\n   struct sctp_stream_value {\n     sctp_assoc_t assoc_id;\n
        \    uint16_t stream_id;\n     uint16_t stream_value;\n   };\n   assoc_id:
        \ Holds the identifier of the association for which the\n      scheduler should
        be changed.  The special\n      SCTP_{FUTURE|CURRENT|ALL}_ASSOC can also be
        used.  This parameter\n      is ignored for one-to-one style sockets.\n   stream_id:
        \ Holds the identifier of the stream for which additional\n      information
        has to be provided.\n   stream_value:  The meaning of this field depends on
        the scheduler\n      specified.  It is ignored when the scheduler does not
        need\n      additional information.\n   sctp_opt_info() needs to be extended
        to support\n   SCTP_STREAM_SCHEDULER_VALUE.\n"
      title: 4.3.3.  Get or Set the Stream Scheduler Parameter
    title: 4.3.  Socket Options
  - contents:
    - "4.4.  Explicit EOR Marking\n   Using explicit End of Record (EOR) marking for
      an SCTP association\n   supporting user message interleaving allows the user
      to interleave\n   the sending of user messages on different streams.\n"
    title: 4.4.  Explicit EOR Marking
  title: 4.  Socket API Considerations
- contents:
  - "5.  IANA Considerations\n   Two new chunk types have been assigned by IANA.\n"
  - contents:
    - "5.1.  I-DATA Chunk\n   IANA has assigned the chunk type for this chunk from
      the pool of\n   chunks with the upper two bits set to '01'.  This appears in
      the\n   \"Chunk Types\" registry for SCTP as follows:\n   +----------+--------------------------------------------+-----------+\n
      \  | ID Value | Chunk Type                                 | Reference |\n   +----------+--------------------------------------------+-----------+\n
      \  | 64       | Payload Data supporting Interleaving       | RFC 8260  |\n   |
      \         | (I-DATA)                                   |           |\n   +----------+--------------------------------------------+-----------+\n
      \  The registration table (as defined in [RFC6096]) for the chunk flags\n   of
      this chunk type is initially as follows:\n            +------------------+-----------------+-----------+\n
      \           | Chunk Flag Value | Chunk Flag Name | Reference |\n            +------------------+-----------------+-----------+\n
      \           | 0x01             | E bit           | RFC 8260  |\n            |
      0x02             | B bit           | RFC 8260  |\n            | 0x04             |
      U bit           | RFC 8260  |\n            | 0x08             | I bit           |
      RFC 8260  |\n            | 0x10             | Unassigned      |           |\n
      \           | 0x20             | Unassigned      |           |\n            |
      0x40             | Unassigned      |           |\n            | 0x80             |
      Unassigned      |           |\n            +------------------+-----------------+-----------+\n"
    title: 5.1.  I-DATA Chunk
  - contents:
    - "5.2.  I-FORWARD-TSN Chunk\n   IANA has assigned the chunk type for this chunk
      from the pool of\n   chunks with the upper two bits set to '11'.  This appears
      in the\n   \"Chunk Types\" registry for SCTP as follows:\n                 +----------+---------------+-----------+\n
      \                | ID Value | Chunk Type    | Reference |\n                 +----------+---------------+-----------+\n
      \                | 194      | I-FORWARD-TSN | RFC 8260  |\n                 +----------+---------------+-----------+\n
      \  The registration table (as defined in [RFC6096]) for the chunk flags\n   of
      this chunk type is initially empty.\n"
    title: 5.2.  I-FORWARD-TSN Chunk
  title: 5.  IANA Considerations
- contents:
  - "6.  Security Considerations\n   This document does not add any additional security
    considerations in\n   addition to the ones given in [RFC4960] and [RFC6458].\n
    \  It should be noted that the application has to consent that it is\n   willing
    to do the more complex reassembly support required for user\n   message interleaving.
    \ When doing so, an application has to provide a\n   reassembly buffer for each
    incoming stream.  It has to protect itself\n   against these buffers taking too
    many resources.  If user message\n   interleaving is not used, only a single reassembly
    buffer needs to be\n   provided for each association.  But the application has
    to protect\n   itself for excessive resource usages there too.\n"
  title: 6.  Security Considerations
- contents:
  - '7.  References

    '
  - contents:
    - "7.1.  Normative References\n   [RFC1982]  Elz, R. and R. Bush, \"Serial Number
      Arithmetic\", RFC 1982,\n              DOI 10.17487/RFC1982, August 1996,\n
      \             <https://www.rfc-editor.org/info/rfc1982>.\n   [RFC2119]  Bradner,
      S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\",
      BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n
      \  [RFC3758]  Stewart, R., Ramalho, M., Xie, Q., Tuexen, M., and P.\n              Conrad,
      \"Stream Control Transmission Protocol (SCTP)\n              Partial Reliability
      Extension\", RFC 3758,\n              DOI 10.17487/RFC3758, May 2004,\n              <https://www.rfc-editor.org/info/rfc3758>.\n
      \  [RFC4960]  Stewart, R., Ed., \"Stream Control Transmission Protocol\",\n
      \             RFC 4960, DOI 10.17487/RFC4960, September 2007,\n              <https://www.rfc-editor.org/info/rfc4960>.\n
      \  [RFC5061]  Stewart, R., Xie, Q., Tuexen, M., Maruyama, S., and M.\n              Kozuka,
      \"Stream Control Transmission Protocol (SCTP)\n              Dynamic Address
      Reconfiguration\", RFC 5061,\n              DOI 10.17487/RFC5061, September
      2007,\n              <https://www.rfc-editor.org/info/rfc5061>.\n   [RFC6096]
      \ Tuexen, M. and R. Stewart, \"Stream Control Transmission\n              Protocol
      (SCTP) Chunk Flags Registration\", RFC 6096,\n              DOI 10.17487/RFC6096,
      January 2011,\n              <https://www.rfc-editor.org/info/rfc6096>.\n   [RFC6525]
      \ Stewart, R., Tuexen, M., and P. Lei, \"Stream Control\n              Transmission
      Protocol (SCTP) Stream Reconfiguration\",\n              RFC 6525, DOI 10.17487/RFC6525,
      February 2012,\n              <https://www.rfc-editor.org/info/rfc6525>.\n   [RFC7053]
      \ Tuexen, M., Ruengeler, I., and R. Stewart, \"SACK-\n              IMMEDIATELY
      Extension for the Stream Control Transmission\n              Protocol\", RFC
      7053, DOI 10.17487/RFC7053, November 2013,\n              <https://www.rfc-editor.org/info/rfc7053>.\n
      \  [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119
      Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,
      <https://www.rfc-editor.org/info/rfc8174>.\n"
    title: 7.1.  Normative References
  - contents:
    - "7.2.  Informative References\n   [DATA-CHAN]\n              Jesup, R., Loreto,
      S., and M. Tuexen, \"WebRTC Data\n              Channels\", Work in Progress,\n
      \             draft-ietf-rtcweb-data-channel-13, January 2015.\n   [RFC3261]
      \ Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,\n              A.,
      Peterson, J., Sparks, R., Handley, M., and E.\n              Schooler, \"SIP:
      Session Initiation Protocol\", RFC 3261,\n              DOI 10.17487/RFC3261,
      June 2002,\n              <https://www.rfc-editor.org/info/rfc3261>.\n   [RFC6458]
      \ Stewart, R., Tuexen, M., Poon, K., Lei, P., and V.\n              Yasevich,
      \"Sockets API Extensions for the Stream Control\n              Transmission
      Protocol (SCTP)\", RFC 6458,\n              DOI 10.17487/RFC6458, December 2011,\n
      \             <https://www.rfc-editor.org/info/rfc6458>.\n"
    title: 7.2.  Informative References
  title: 7.  References
- contents:
  - "Acknowledgments\n   The authors wish to thank Benoit Claise, Julian Cordes, Spencer\n
    \  Dawkins, Gorry Fairhurst, Lennart Grahl, Christer Holmberg, Mirja\n   Kuehlewind,
    Marcelo Ricardo Leitner, Karen E. Egede Nielsen, Maksim\n   Proshin, Eric Rescorla,
    Irene Ruengeler, Felix Weinrank, Michael\n   Welzl, Magnus Westerlund, and Lixia
    Zhang for their invaluable\n   comments.\n   This work has received funding from
    the European Union's Horizon 2020\n   research and innovation program under grant
    agreement No. 644334\n   (NEAT).  The views expressed are solely those of the
    authors.\n"
  title: Acknowledgments
- contents:
  - "Authors' Addresses\n   Randall R. Stewart\n   Netflix, Inc.\n   Chapin, SC  29036\n
    \  United States of America\n   Email: randall@lakerest.net\n   Michael Tuexen\n
    \  Muenster University of Applied Sciences\n   Stegerwaldstrasse 39\n   48565
    Steinfurt\n   Germany\n   Email: tuexen@fh-muenster.de\n   Salvatore Loreto\n
    \  Ericsson\n   Torshamnsgatan 21\n   164 80 Stockholm\n   Sweden\n   Email: Salvatore.Loreto@ericsson.com\n
    \  Robin Seggelmann\n   Metafinanz Informationssysteme GmbH\n   Leopoldstrasse
    146\n   80804 Muenchen\n   Germany\n   Email: rfc@robin-seggelmann.com\n"
  title: Authors' Addresses
