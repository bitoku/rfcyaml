- contents:
  - '              Network File System (NFS) Version 4 Protocol

    '
  title: __initial_text__
- contents:
  - "Abstract\n   The Network File System (NFS) version 4 protocol is a distributed\n
    \  file system protocol that builds on the heritage of NFS protocol\n   version
    2 (RFC 1094) and version 3 (RFC 1813).  Unlike earlier\n   versions, the NFS version
    4 protocol supports traditional file access\n   while integrating support for
    file locking and the MOUNT protocol.\n   In addition, support for strong security
    (and its negotiation),\n   COMPOUND operations, client caching, and internationalization
    has\n   been added.  Of course, attention has been applied to making NFS\n   version
    4 operate well in an Internet environment.\n   This document, together with the
    companion External Data\n   Representation (XDR) description document, RFC 7531,
    obsoletes RFC\n   3530 as the definition of the NFS version 4 protocol.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7530.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2015 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................8\n
    \     1.1. Requirements Language ......................................8\n      1.2.
    NFS Version 4 Goals ........................................8\n      1.3. Definitions
    in the Companion Document RFC 7531 Are\n           Authoritative ..............................................9\n
    \     1.4. Overview of NFSv4 Features .................................9\n           1.4.1.
    RPC and Security ....................................9\n           1.4.2. Procedure
    and Operation Structure ..................10\n           1.4.3. File System Model
    ..................................10\n           1.4.4. OPEN and CLOSE .....................................12\n
    \          1.4.5. File Locking .......................................12\n           1.4.6.
    Client Caching and Delegation ......................13\n      1.5. General Definitions
    .......................................14\n      1.6. Changes since RFC 3530 ....................................16\n
    \     1.7. Changes between RFC 3010 and RFC 3530 .....................16\n   2.
    Protocol Data Types ............................................18\n      2.1.
    Basic Data Types ..........................................18\n      2.2. Structured
    Data Types .....................................21\n   3. RPC and Security Flavor
    ........................................25\n      3.1. Ports and Transports ......................................25\n
    \          3.1.1. Client Retransmission Behavior .....................26\n      3.2.
    Security Flavors ..........................................27\n           3.2.1.
    Security Mechanisms for NFSv4 ......................27\n      3.3. Security Negotiation
    ......................................28\n           3.3.1. SECINFO ............................................29\n
    \          3.3.2. Security Error .....................................29\n           3.3.3.
    Callback RPC Authentication ........................29\n   4. Filehandles ....................................................30\n
    \     4.1. Obtaining the First Filehandle ............................30\n           4.1.1.
    Root Filehandle ....................................31\n           4.1.2. Public
    Filehandle ..................................31\n      4.2. Filehandle Types ..........................................31\n
    \          4.2.1. General Properties of a Filehandle .................32\n           4.2.2.
    Persistent Filehandle ..............................32\n           4.2.3. Volatile
    Filehandle ................................33\n           4.2.4. One Method of
    Constructing a Volatile Filehandle ...34\n      4.3. Client Recovery from Filehandle
    Expiration ................35\n   5. Attributes .....................................................35\n
    \     5.1. REQUIRED Attributes .......................................37\n      5.2.
    RECOMMENDED Attributes ....................................37\n      5.3. Named
    Attributes ..........................................37\n      5.4. Classification
    of Attributes ..............................39\n      5.5. Set-Only and Get-Only
    Attributes ..........................40\n      5.6. REQUIRED Attributes - List
    and Definition References ......40\n      5.7. RECOMMENDED Attributes - List and
    Definition References ...41\n      5.8. Attribute Definitions .....................................42\n
    \          5.8.1. Definitions of REQUIRED Attributes .................42\n           5.8.2.
    Definitions of Uncategorized RECOMMENDED\n                  Attributes .........................................45\n
    \     5.9. Interpreting owner and owner_group ........................51\n      5.10.
    Character Case Attributes ................................53\n   6. Access Control
    Attributes ......................................54\n      6.1. Goals .....................................................54\n
    \     6.2. File Attributes Discussion ................................55\n           6.2.1.
    Attribute 12: acl ..................................55\n           6.2.2. Attribute
    33: mode .................................70\n      6.3. Common Methods ............................................71\n
    \          6.3.1. Interpreting an ACL ................................71\n           6.3.2.
    Computing a mode Attribute from an ACL .............72\n      6.4. Requirements
    ..............................................73\n           6.4.1. Setting the
    mode and/or ACL Attributes .............74\n           6.4.2. Retrieving the mode
    and/or ACL Attributes ..........75\n           6.4.3. Creating New Objects ...............................75\n
    \  7. NFS Server Namespace ...........................................77\n      7.1.
    Server Exports ............................................77\n      7.2. Browsing
    Exports ..........................................77\n      7.3. Server Pseudo-File
    System .................................78\n      7.4. Multiple Roots ............................................79\n
    \     7.5. Filehandle Volatility .....................................79\n      7.6.
    Exported Root .............................................79\n      7.7. Mount
    Point Crossing ......................................79\n      7.8. Security Policy
    and Namespace Presentation ................80\n   8. Multi-Server Namespace .........................................81\n
    \     8.1. Location Attributes .......................................81\n      8.2.
    File System Presence or Absence ...........................81\n      8.3. Getting
    Attributes for an Absent File System ..............83\n           8.3.1. GETATTR
    within an Absent File System ...............83\n           8.3.2. READDIR and
    Absent File Systems ....................84\n      8.4. Uses of Location Information
    ..............................84\n           8.4.1. File System Replication ............................85\n
    \          8.4.2. File System Migration ..............................86\n           8.4.3.
    Referrals ..........................................86\n      8.5. Location Entries
    and Server Identity ......................87\n      8.6. Additional Client-Side
    Considerations .....................88\n      8.7. Effecting File System Referrals
    ...........................89\n           8.7.1. Referral Example (LOOKUP) ..........................89\n
    \          8.7.2. Referral Example (READDIR) .........................93\n      8.8.
    The Attribute fs_locations ................................96\n   9. File Locking
    and Share Reservations ............................98\n      9.1. Opens and Byte-Range
    Locks ................................99\n           9.1.1. Client ID ..........................................99\n
    \          9.1.2. Server Release of Client ID .......................102\n           9.1.3.
    Use of Seqids .....................................103\n           9.1.4. Stateid
    Definition ................................104\n           9.1.5. Lock-Owner ........................................110\n
    \          9.1.6. Use of the Stateid and Locking ....................110\n           9.1.7.
    Sequencing of Lock Requests .......................113\n           9.1.8. Recovery
    from Replayed Requests ...................114\n           9.1.9. Interactions
    of Multiple Sequence Values ..........114\n           9.1.10. Releasing State-Owner
    State ......................115\n           9.1.11. Use of Open Confirmation .........................116\n
    \     9.2. Lock Ranges ..............................................117\n      9.3.
    Upgrading and Downgrading Locks ..........................117\n      9.4. Blocking
    Locks ...........................................118\n      9.5. Lease Renewal
    ............................................119\n      9.6. Crash Recovery ...........................................120\n
    \          9.6.1. Client Failure and Recovery .......................120\n           9.6.2.
    Server Failure and Recovery .......................120\n           9.6.3. Network
    Partitions and Recovery ...................122\n      9.7. Recovery from a Lock
    Request Timeout or Abort ............130\n      9.8. Server Revocation of Locks
    ...............................130\n      9.9. Share Reservations .......................................132\n
    \     9.10. OPEN/CLOSE Operations ...................................132\n           9.10.1.
    Close and Retention of State Information .........133\n      9.11. Open Upgrade
    and Downgrade ..............................134\n      9.12. Short and Long Leases
    ...................................135\n      9.13. Clocks, Propagation Delay,
    and Calculating Lease\n            Expiration ..............................................135\n
    \     9.14. Migration, Replication, and State .......................136\n           9.14.1.
    Migration and State ..............................136\n           9.14.2. Replication
    and State ............................137\n           9.14.3. Notification of
    Migrated Lease ...................137\n           9.14.4. Migration and the lease_time
    Attribute ...........138\n   10. Client-Side Caching ..........................................139\n
    \     10.1. Performance Challenges for Client-Side Caching ..........139\n      10.2.
    Delegation and Callbacks ................................140\n           10.2.1.
    Delegation Recovery ..............................142\n      10.3. Data Caching
    ............................................147\n           10.3.1. Data Caching
    and OPENs ...........................147\n           10.3.2. Data Caching and
    File Locking ....................148\n           10.3.3. Data Caching and Mandatory
    File Locking ..........150\n           10.3.4. Data Caching and File Identity
    ...................150\n      10.4. Open Delegation .........................................151\n
    \          10.4.1. Open Delegation and Data Caching .................154\n           10.4.2.
    Open Delegation and File Locks ...................155\n           10.4.3. Handling
    of CB_GETATTR ...........................155\n           10.4.4. Recall of Open
    Delegation ........................158\n           10.4.5. OPEN Delegation Race
    with CB_RECALL ..............160\n           10.4.6. Clients That Fail to Honor
    Delegation Recalls ....161\n           10.4.7. Delegation Revocation ............................162\n
    \     10.5. Data Caching and Revocation .............................162\n           10.5.1.
    Revocation Recovery for Write Open Delegation ....163\n      10.6. Attribute Caching
    .......................................164\n      10.7. Data and Metadata Caching
    and Memory-Mapped Files .......166\n      10.8. Name Caching ............................................168\n
    \     10.9. Directory Caching .......................................169\n   11.
    Minor Versioning .............................................170\n   12. Internationalization
    .........................................170\n      12.1. Introduction ............................................170\n
    \     12.2. Limitations on Internationalization-Related\n            Processing
    in the NFSv4 Context .........................172\n      12.3. Summary of Server
    Behavior Types ........................173\n      12.4. String Encoding .........................................173\n
    \     12.5. Normalization ...........................................174\n      12.6.
    Types with Processing Defined by Other Internet Areas ...175\n      12.7. Errors
    Related to UTF-8 .................................177\n      12.8. Servers That
    Accept File Component Names That\n            Are Not Valid UTF-8 Strings .............................177\n
    \  13. Error Values .................................................178\n      13.1.
    Error Definitions .......................................179\n           13.1.1.
    General Errors ...................................180\n           13.1.2. Filehandle
    Errors ................................181\n           13.1.3. Compound Structure
    Errors ........................183\n           13.1.4. File System Errors ...............................184\n
    \          13.1.5. State Management Errors ..........................186\n           13.1.6.
    Security Errors ..................................187\n           13.1.7. Name
    Errors ......................................187\n           13.1.8. Locking Errors
    ...................................188\n           13.1.9. Reclaim Errors ...................................190\n
    \          13.1.10. Client Management Errors ........................191\n           13.1.11.
    Attribute Handling Errors .......................191\n           13.1.12. Miscellaneous
    Errors ............................191\n      13.2. Operations and Their Valid
    Errors .......................192\n      13.3. Callback Operations and Their Valid
    Errors ..............200\n      13.4. Errors and the Operations That Use Them
    .................201\n   14. NFSv4 Requests ...............................................206\n
    \     14.1. COMPOUND Procedure ......................................207\n      14.2.
    Evaluation of a COMPOUND Request ........................207\n      14.3. Synchronous
    Modifying Operations ........................208\n      14.4. Operation Values
    ........................................208\n   15. NFSv4 Procedures .............................................209\n
    \     15.1. Procedure 0: NULL - No Operation ........................209\n      15.2.
    Procedure 1: COMPOUND - COMPOUND Operations .............210\n   16. NFSv4 Operations
    .............................................214\n      16.1. Operation 3: ACCESS
    - Check Access Rights ...............214\n      16.2. Operation 4: CLOSE - Close
    File .........................217\n      16.3. Operation 5: COMMIT - Commit Cached
    Data ................218\n      16.4. Operation 6: CREATE - Create a Non-regular
    File Object ..221\n      16.5. Operation 7: DELEGPURGE - Purge Delegations\n            Awaiting
    Recovery .......................................224\n      16.6. Operation 8:
    DELEGRETURN - Return Delegation ............226\n      16.7. Operation 9: GETATTR
    - Get Attributes ...................227\n      16.8. Operation 10: GETFH - Get
    Current Filehandle ............229\n      16.9. Operation 11: LINK - Create Link
    to a File ..............230\n      16.10. Operation 12: LOCK - Create Lock .......................232\n
    \     16.11. Operation 13: LOCKT - Test for Lock ....................236\n      16.12.
    Operation 14: LOCKU - Unlock File ......................238\n      16.13. Operation
    15: LOOKUP - Look Up Filename ................240\n      16.14. Operation 16:
    LOOKUPP - Look Up Parent Directory .......242\n      16.15. Operation 17: NVERIFY
    - Verify Difference in\n             Attributes .............................................243\n
    \     16.16. Operation 18: OPEN - Open a Regular File ...............245\n      16.17.
    Operation 19: OPENATTR - Open Named Attribute\n             Directory ..............................................256\n
    \     16.18. Operation 20: OPEN_CONFIRM - Confirm Open ..............257\n      16.19.
    Operation 21: OPEN_DOWNGRADE - Reduce Open File\n             Access .................................................260\n
    \     16.20. Operation 22: PUTFH - Set Current Filehandle ...........262\n      16.21.
    Operation 23: PUTPUBFH - Set Public Filehandle .........263\n      16.22. Operation
    24: PUTROOTFH - Set Root Filehandle ..........265\n      16.23. Operation 25:
    READ - Read from File ....................266\n      16.24. Operation 26: READDIR
    - Read Directory .................269\n      16.25. Operation 27: READLINK - Read
    Symbolic Link ............273\n      16.26. Operation 28: REMOVE - Remove File
    System Object .......274\n      16.27. Operation 29: RENAME - Rename Directory
    Entry ..........276\n      16.28. Operation 30: RENEW - Renew a Lease ....................278\n
    \     16.29. Operation 31: RESTOREFH - Restore Saved Filehandle .....280\n      16.30.
    Operation 32: SAVEFH - Save Current Filehandle .........281\n      16.31. Operation
    33: SECINFO - Obtain Available Security ......282\n      16.32. Operation 34:
    SETATTR - Set Attributes .................286\n      16.33. Operation 35: SETCLIENTID
    - Negotiate Client ID ........289\n      16.34. Operation 36: SETCLIENTID_CONFIRM
    - Confirm Client ID ..293\n      16.35. Operation 37: VERIFY - Verify Same Attributes
    ..........297\n      16.36. Operation 38: WRITE - Write to File ....................299\n
    \     16.37. Operation 39: RELEASE_LOCKOWNER - Release\n             Lock-Owner
    State .......................................304\n      16.38. Operation 10044:
    ILLEGAL - Illegal Operation ...........305\n   17. NFSv4 Callback Procedures ....................................306\n
    \     17.1. Procedure 0: CB_NULL - No Operation .....................306\n      17.2.
    Procedure 1: CB_COMPOUND - COMPOUND Operations ..........307\n   18. NFSv4 Callback
    Operations ....................................309\n      18.1. Operation 3: CB_GETATTR
    - Get Attributes ................309\n      18.2. Operation 4: CB_RECALL - Recall
    an Open Delegation ......310\n      18.3. Operation 10044: CB_ILLEGAL - Illegal
    Callback\n            Operation ...............................................311\n
    \  19. Security Considerations ......................................312\n   20.
    IANA Considerations ..........................................314\n      20.1.
    Named Attribute Definitions .............................314\n           20.1.1.
    Initial Registry .................................315\n           20.1.2. Updating
    Registrations ...........................315\n      20.2. Updates to Existing
    IANA Registries .....................315\n   21. References ...................................................316\n
    \     21.1. Normative References ....................................316\n      21.2.
    Informative References ..................................318\n   Acknowledgments
    ..................................................322\n   Authors' Addresses ...............................................323\n"
  title: Table of Contents
- contents:
  - '1.  Introduction

    '
  - contents:
    - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
      and \"OPTIONAL\" in this\n   document are to be interpreted as described in
      RFC 2119 [RFC2119],\n   except where \"REQUIRED\" and \"RECOMMENDED\" are used
      as qualifiers to\n   distinguish classes of attributes as described in Sections
      1.4.3.2\n   and 5 of this document.\n"
    title: 1.1.  Requirements Language
  - contents:
    - "1.2.  NFS Version 4 Goals\n   The Network File System version 4 (NFSv4) protocol
      is a further\n   revision of the NFS protocol defined already by versions 2
      [RFC1094]\n   and 3 [RFC1813].  It retains the essential characteristics of\n
      \  previous versions: design for easy recovery; independent of transport\n   protocols,
      operating systems, and file systems; simplicity; and good\n   performance.  The
      NFSv4 revision has the following goals:\n   o  Improved access and good performance
      on the Internet.\n      The protocol is designed to transit firewalls easily,
      perform well\n      where latency is high and bandwidth is low, and scale to
      very\n      large numbers of clients per server.\n   o  Strong security with
      negotiation built into the protocol.\n      The protocol builds on the work
      of the Open Network Computing\n      (ONC) Remote Procedure Call (RPC) working
      group in supporting the\n      RPCSEC_GSS protocol (see both [RFC2203] and [RFC5403]).\n
      \     Additionally, the NFSv4 protocol provides a mechanism to allow\n      clients
      and servers the ability to negotiate security and require\n      clients and
      servers to support a minimal set of security schemes.\n   o  Good cross-platform
      interoperability.\n      The protocol features a file system model that provides
      a useful,\n      common set of features that does not unduly favor one file
      system\n      or operating system over another.\n   o  Designed for protocol
      extensions.\n      The protocol is designed to accept standard extensions that
      do not\n      compromise backward compatibility.\n   This document, together
      with the companion External Data\n   Representation (XDR) description document
      [RFC7531], obsoletes\n   [RFC3530] as the authoritative document describing
      NFSv4.  It does\n   not introduce any over-the-wire protocol changes, in the
      sense that\n   previously valid requests remain valid.\n"
    title: 1.2.  NFS Version 4 Goals
  - contents:
    - "1.3.  Definitions in the Companion Document RFC 7531 Are Authoritative\n   The
      \"Network File System (NFS) Version 4 External Data Representation\n   Standard
      (XDR) Description\" [RFC7531] contains the definitions in XDR\n   description
      language of the constructs used by the protocol.  Inside\n   this document,
      several of the constructs are reproduced for purposes\n   of explanation.  The
      reader is warned of the possibility of errors in\n   the reproduced constructs
      outside of [RFC7531].  For any part of the\n   document that is inconsistent
      with [RFC7531], [RFC7531] is to be\n   considered authoritative.\n"
    title: 1.3.  Definitions in the Companion Document RFC 7531 Are Authoritative
  - contents:
    - "1.4.  Overview of NFSv4 Features\n   To provide a reasonable context for the
      reader, the major features of\n   the NFSv4 protocol will be reviewed in brief.
      \ This is done to\n   provide an appropriate context for both the reader who
      is familiar\n   with the previous versions of the NFS protocol and the reader
      who is\n   new to the NFS protocols.  For the reader new to the NFS protocols,\n
      \  some fundamental knowledge is still expected.  The reader should be\n   familiar
      with the XDR and RPC protocols as described in [RFC4506] and\n   [RFC5531].
      \ A basic knowledge of file systems and distributed file\n   systems is expected
      as well.\n"
    - contents:
      - "1.4.1.  RPC and Security\n   As with previous versions of NFS, the XDR and
        RPC mechanisms used for\n   the NFSv4 protocol are those defined in [RFC4506]
        and [RFC5531].  To\n   meet end-to-end security requirements, the RPCSEC_GSS
        framework (both\n   version 1 in [RFC2203] and version 2 in [RFC5403]) will
        be used to\n   extend the basic RPC security.  With the use of RPCSEC_GSS,
        various\n   mechanisms can be provided to offer authentication, integrity,
        and\n   privacy to the NFSv4 protocol.  Kerberos V5 will be used as described\n
        \  in [RFC4121] to provide one security framework.  With the use of\n   RPCSEC_GSS,
        other mechanisms may also be specified and used for NFSv4\n   security.\n
        \  To enable in-band security negotiation, the NFSv4 protocol has added\n
        \  a new operation that provides the client with a method of querying\n   the
        server about its policies regarding which security mechanisms\n   must be
        used for access to the server's file system resources.  With\n   this, the
        client can securely match the security mechanism that meets\n   the policies
        specified at both the client and server.\n"
      title: 1.4.1.  RPC and Security
    - contents:
      - "1.4.2.  Procedure and Operation Structure\n   A significant departure from
        the previous versions of the NFS\n   protocol is the introduction of the COMPOUND
        procedure.  For the\n   NFSv4 protocol, there are two RPC procedures: NULL
        and COMPOUND.  The\n   COMPOUND procedure is defined in terms of operations,
        and these\n   operations correspond more closely to the traditional NFS procedures.\n
        \  With the use of the COMPOUND procedure, the client is able to build\n   simple
        or complex requests.  These COMPOUND requests allow for a\n   reduction in
        the number of RPCs needed for logical file system\n   operations.  For example,
        without previous contact with a server a\n   client will be able to read data
        from a file in one request by\n   combining LOOKUP, OPEN, and READ operations
        in a single COMPOUND RPC.\n   With previous versions of the NFS protocol,
        this type of single\n   request was not possible.\n   The model used for COMPOUND
        is very simple.  There is no logical OR\n   or ANDing of operations.  The
        operations combined within a COMPOUND\n   request are evaluated in order by
        the server.  Once an operation\n   returns a failing result, the evaluation
        ends and the results of all\n   evaluated operations are returned to the client.\n
        \  The NFSv4 protocol continues to have the client refer to a file or\n   directory
        at the server by a \"filehandle\".  The COMPOUND procedure\n   has a method
        of passing a filehandle from one operation to another\n   within the sequence
        of operations.  There is a concept of a current\n   filehandle and a saved
        filehandle.  Most operations use the current\n   filehandle as the file system
        object to operate upon.  The saved\n   filehandle is used as temporary filehandle
        storage within a COMPOUND\n   procedure as well as an additional operand for
        certain operations.\n"
      title: 1.4.2.  Procedure and Operation Structure
    - contents:
      - "1.4.3.  File System Model\n   The general file system model used for the
        NFSv4 protocol is the same\n   as previous versions.  The server file system
        is hierarchical, with\n   the regular files contained within being treated
        as opaque byte\n   streams.  In a slight departure, file and directory names
        are encoded\n   with UTF-8 to deal with the basics of internationalization.\n
        \  The NFSv4 protocol does not require a separate protocol to provide\n   for
        the initial mapping between pathname and filehandle.  Instead of\n   using
        the older MOUNT protocol for this mapping, the server provides\n   a root
        filehandle that represents the logical root or top of the file\n   system
        tree provided by the server.  The server provides multiple\n   file systems
        by gluing them together with pseudo-file systems.  These\n   pseudo-file systems
        provide for potential gaps in the pathnames\n   between real file systems.\n"
      - contents:
        - "1.4.3.1.  Filehandle Types\n   In previous versions of the NFS protocol,
          the filehandle provided by\n   the server was guaranteed to be valid or
          persistent for the lifetime\n   of the file system object to which it referred.
          \ For some server\n   implementations, this persistence requirement has
          been difficult to\n   meet.  For the NFSv4 protocol, this requirement has
          been relaxed by\n   introducing another type of filehandle -- volatile.
          \ With persistent\n   and volatile filehandle types, the server implementation
          can match\n   the abilities of the file system at the server along with
          the\n   operating environment.  The client will have knowledge of the type
          of\n   filehandle being provided by the server and can be prepared to deal\n
          \  with the semantics of each.\n"
        title: 1.4.3.1.  Filehandle Types
      - contents:
        - "1.4.3.2.  Attribute Types\n   The NFSv4 protocol has a rich and extensible
          file object attribute\n   structure, which is divided into REQUIRED, RECOMMENDED,
          and named\n   attributes (see Section 5).\n   Several (but not all) of the
          REQUIRED attributes are derived from the\n   attributes of NFSv3 (see the
          definition of the fattr3 data type in\n   [RFC1813]).  An example of a REQUIRED
          attribute is the file object's\n   type (Section 5.8.1.2) so that regular
          files can be distinguished\n   from directories (also known as folders in
          some operating\n   environments) and other types of objects.  REQUIRED attributes
          are\n   discussed in Section 5.1.\n   An example of the RECOMMENDED attributes
          is an acl (Section 6.2.1).\n   This attribute defines an Access Control
          List (ACL) on a file object.\n   An ACL provides file access control beyond
          the model used in NFSv3.\n   The ACL definition allows for specification
          of specific sets of\n   permissions for individual users and groups.  In
          addition, ACL\n   inheritance allows propagation of access permissions and
          restriction\n   down a directory tree as file system objects are created.\n
          \  RECOMMENDED attributes are discussed in Section 5.2.\n   A named attribute
          is an opaque byte stream that is associated with a\n   directory or file
          and referred to by a string name.  Named attributes\n   are meant to be
          used by client applications as a method to associate\n   application-specific
          data with a regular file or directory.  NFSv4.1\n   modifies named attributes
          relative to NFSv4.0 by tightening the\n   allowed operations in order to
          prevent the development of\n   non-interoperable implementations.  Named
          attributes are discussed in\n   Section 5.3.\n"
        title: 1.4.3.2.  Attribute Types
      - contents:
        - "1.4.3.3.  Multi-Server Namespace\n   A single-server namespace is the file
          system hierarchy that the\n   server presents for remote access.  It is
          a proper subset of all the\n   file systems available locally.  NFSv4 contains
          a number of features\n   to allow implementation of namespaces that cross
          server boundaries\n   and that allow and facilitate a non-disruptive transfer
          of support\n   for individual file systems between servers.  They are all
          based upon\n   attributes that allow one file system to specify alternative
          or new\n   locations for that file system.  That is, just as a client might\n
          \  traverse across local file systems on a single server, it can now\n   traverse
          to a remote file system on a different server.\n   These attributes may
          be used together with the concept of absent file\n   systems, which provide
          specifications for additional locations but no\n   actual file system content.
          \ This allows a number of important\n   facilities:\n   o  Location attributes
          may be used with absent file systems to\n      implement referrals whereby
          one server may direct the client to a\n      file system provided by another
          server.  This allows extensive\n      multi-server namespaces to be constructed.\n
          \  o  Location attributes may be provided for present file systems to\n
          \     provide the locations of alternative file system instances or\n      replicas
          to be used in the event that the current file system\n      instance becomes
          unavailable.\n   o  Location attributes may be provided when a previously
          present file\n      system becomes absent.  This allows non-disruptive migration
          of\n      file systems to alternative servers.\n"
        title: 1.4.3.3.  Multi-Server Namespace
      title: 1.4.3.  File System Model
    - contents:
      - "1.4.4.  OPEN and CLOSE\n   The NFSv4 protocol introduces OPEN and CLOSE operations.
        \ The OPEN\n   operation provides a single point where file lookup, creation,
        and\n   share semantics (see Section 9.9) can be combined.  The CLOSE\n   operation
        also provides for the release of state accumulated by OPEN.\n"
      title: 1.4.4.  OPEN and CLOSE
    - contents:
      - "1.4.5.  File Locking\n   With the NFSv4 protocol, the support for byte-range
        file locking is\n   part of the NFS protocol.  The file locking support is
        structured so\n   that an RPC callback mechanism is not required.  This is
        a departure\n   from the previous versions of the NFS file locking protocol,
        Network\n   Lock Manager (NLM) [RFC1813].  The state associated with file
        locks\n   is maintained at the server under a lease-based model.  The server\n
        \  defines a single lease period for all state held by an NFS client.\n   If
        the client does not renew its lease within the defined period, all\n   state
        associated with the client's lease may be released by the\n   server.  The
        client may renew its lease by use of the RENEW operation\n   or implicitly
        by use of other operations (primarily READ).\n"
      title: 1.4.5.  File Locking
    - contents:
      - "1.4.6.  Client Caching and Delegation\n   The file, attribute, and directory
        caching for the NFSv4 protocol is\n   similar to previous versions.  Attributes
        and directory information\n   are cached for a duration determined by the
        client.  At the end of a\n   predefined timeout, the client will query the
        server to see if the\n   related file system object has been updated.\n   For
        file data, the client checks its cache validity when the file is\n   opened.
        \ A query is sent to the server to determine if the file has\n   been changed.
        \ Based on this information, the client determines if\n   the data cache for
        the file should be kept or released.  Also, when\n   the file is closed, any
        modified data is written to the server.\n   If an application wants to serialize
        access to file data, file\n   locking of the file data ranges in question
        should be used.\n   The major addition to NFSv4 in the area of caching is
        the ability of\n   the server to delegate certain responsibilities to the
        client.  When\n   the server grants a delegation for a file to a client, the
        client is\n   guaranteed certain semantics with respect to the sharing of
        that file\n   with other clients.  At OPEN, the server may provide the client\n
        \  either a read (OPEN_DELEGATE_READ) or a write (OPEN_DELEGATE_WRITE)\n   delegation
        for the file (see Section 10.4).  If the client is granted\n   an OPEN_DELEGATE_READ
        delegation, it is assured that no other client\n   has the ability to write
        to the file for the duration of the\n   delegation.  If the client is granted
        an OPEN_DELEGATE_WRITE\n   delegation, the client is assured that no other
        client has read or\n   write access to the file.\n   Delegations can be recalled
        by the server.  If another client\n   requests access to the file in such
        a way that the access conflicts\n   with the granted delegation, the server
        is able to notify the initial\n   client and recall the delegation.  This
        requires that a callback path\n   exist between the server and client.  If
        this callback path does not\n   exist, then delegations cannot be granted.
        \ The essence of a\n   delegation is that it allows the client to locally
        service operations\n   such as OPEN, CLOSE, LOCK, LOCKU, READ, or WRITE without
        immediate\n   interaction with the server.\n"
      title: 1.4.6.  Client Caching and Delegation
    title: 1.4.  Overview of NFSv4 Features
  - contents:
    - "1.5.  General Definitions\n   The following definitions are provided for the
      purpose of providing\n   an appropriate context for the reader.\n   Absent File
      System:  A file system is \"absent\" when a namespace\n      component does
      not have a backing file system.\n   Anonymous Stateid:  The Anonymous Stateid
      is a special locking object\n      and is defined in Section 9.1.4.3.\n   Byte:
      \ In this document, a byte is an octet, i.e., a datum exactly\n      8 bits
      in length.\n   Client:  The client is the entity that accesses the NFS server's\n
      \     resources.  The client may be an application that contains the\n      logic
      to access the NFS server directly.  The client may also be\n      the traditional
      operating system client that provides remote file\n      system services for
      a set of applications.\n      With reference to byte-range locking, the client
      is also the\n      entity that maintains a set of locks on behalf of one or
      more\n      applications.  This client is responsible for crash or failure\n
      \     recovery for those locks it manages.\n      Note that multiple clients
      may share the same transport and\n      connection, and multiple clients may
      exist on the same network\n      node.\n   Client ID:  The client ID is a 64-bit
      quantity used as a unique,\n      shorthand reference to a client-supplied verifier
      and ID.  The\n      server is responsible for supplying the client ID.\n   File
      System:  The file system is the collection of objects on a\n      server that
      share the same fsid attribute (see Section 5.8.1.9).\n   Lease:  A lease is
      an interval of time defined by the server for\n      which the client is irrevocably
      granted a lock.  At the end of a\n      lease period the lock may be revoked
      if the lease has not been\n      extended.  The lock must be revoked if a conflicting
      lock has been\n      granted after the lease interval.\n      All leases granted
      by a server have the same fixed duration.  Note\n      that the fixed interval
      duration was chosen to alleviate the\n      expense a server would have in maintaining
      state about variable-\n      length leases across server failures.\n   Lock:
      \ The term \"lock\" is used to refer to record (byte-range) locks\n      as
      well as share reservations unless specifically stated\n      otherwise.\n   Lock-Owner:
      \ Each byte-range lock is associated with a specific\n      lock-owner and an
      open-owner.  The lock-owner consists of a\n      client ID and an opaque owner
      string.  The client presents this to\n      the server to establish the ownership
      of the byte-range lock as\n      needed.\n   Open-Owner:  Each open file is
      associated with a specific open-owner,\n      which consists of a client ID
      and an opaque owner string.  The\n      client presents this to the server to
      establish the ownership of\n      the open as needed.\n   READ Bypass Stateid:
      \ The READ Bypass Stateid is a special locking\n      object and is defined
      in Section 9.1.4.3.\n   Server:  The \"server\" is the entity responsible for
      coordinating\n      client access to a set of file systems.\n   Stable Storage:
      \ NFSv4 servers must be able to recover without data\n      loss from multiple
      power failures (including cascading power\n      failures, that is, several
      power failures in quick succession),\n      operating system failures, and hardware
      failure of components\n      other than the storage medium itself (for example,
      disk,\n      non-volatile RAM).\n      Some examples of stable storage that
      are allowable for an NFS\n      server include:\n      (1)  Media commit of
      data.  That is, the modified data has been\n           successfully written
      to the disk media -- for example, the\n           disk platter.\n      (2)  An
      immediate reply disk drive with battery-backed on-drive\n           intermediate
      storage or uninterruptible power system (UPS).\n      (3)  Server commit of
      data with battery-backed intermediate\n           storage and recovery software.\n
      \     (4)  Cache commit with UPS and recovery software.\n   Stateid:  A stateid
      is a 128-bit quantity returned by a server that\n      uniquely identifies the
      open and locking states provided by the\n      server for a specific open-owner
      or lock-owner/open-owner pair for\n      a specific file and type of lock.\n
      \  Verifier:  A verifier is a 64-bit quantity generated by the client\n      that
      the server can use to determine if the client has restarted\n      and lost
      all previous lock state.\n"
    title: 1.5.  General Definitions
  - contents:
    - "1.6.  Changes since RFC 3530\n   The main changes from RFC 3530 [RFC3530] are:\n
      \  o  The XDR definition has been moved to a companion document\n      [RFC7531].\n
      \  o  The IETF intellectual property statements were updated to the\n      latest
      version.\n   o  There is a restructured and more complete explanation of multi-\n
      \     server namespace features.\n   o  The handling of domain names was updated
      to reflect\n      Internationalized Domain Names in Applications (IDNA) [RFC5891].\n
      \  o  The previously required LIPKEY and SPKM-3 security mechanisms have\n      been
      removed.\n   o  Some clarification was provided regarding a client re-establishing\n
      \     callback information to the new server if state has been migrated.\n   o
      \ A third edge case was added for courtesy locks and network\n      partitions.\n
      \  o  The definition of stateid was strengthened.\n"
    title: 1.6.  Changes since RFC 3530
  - contents:
    - "1.7.  Changes between RFC 3010 and RFC 3530\n   The definition of the NFSv4
      protocol in [RFC3530] replaced and\n   obsoleted the definition present in [RFC3010].
      \ While portions of the\n   two documents remained the same, there were substantive
      changes in\n   others.  The changes made between [RFC3010] and [RFC3530] reflect\n
      \  implementation experience and further review of the protocol.\n   The following
      list is not inclusive of all changes but presents some\n   of the most notable
      changes or additions made:\n   o  The state model has added an open_owner4 identifier.
      \ This was\n      done to accommodate POSIX-based clients and the model they
      use for\n      file locking.  For POSIX clients, an open_owner4 would correspond\n
      \     to a file descriptor potentially shared amongst a set of processes\n      and
      the lock_owner4 identifier would correspond to a process that\n      is locking
      a file.\n   o  Added clarifications and error conditions for the handling of
      the\n      owner and group attributes.  Since these attributes are string\n
      \     based (as opposed to the numeric uid/gid of previous versions of\n      NFS),
      translations may not be available and hence the changes\n      made.\n   o  Added
      clarifications for the ACL and mode attributes to address\n      evaluation
      and partial support.\n   o  For identifiers that are defined as XDR opaque,
      set limits on\n      their size.\n   o  Added the mounted_on_fileid attribute
      to allow POSIX clients to\n      correctly construct local mounts.\n   o  Modified
      the SETCLIENTID/SETCLIENTID_CONFIRM operations to deal\n      correctly with
      confirmation details along with adding the ability\n      to specify new client
      callback information.  Also added\n      clarification of the callback information
      itself.\n   o  Added a new operation RELEASE_LOCKOWNER to enable notifying the\n
      \     server that a lock_owner4 will no longer be used by the client.\n   o
      \ Added RENEW operation changes to identify the client correctly and\n      allow
      for additional error returns.\n   o  Verified error return possibilities for
      all operations.\n   o  Removed use of the pathname4 data type from LOOKUP and
      OPEN in\n      favor of having the client construct a sequence of LOOKUP\n      operations
      to achieve the same effect.\n"
    title: 1.7.  Changes between RFC 3010 and RFC 3530
  title: 1.  Introduction
- contents:
  - "2.  Protocol Data Types\n   The syntax and semantics to describe the data types
    of the NFSv4\n   protocol are defined in the XDR [RFC4506] and RPC [RFC5531]\n
    \  documents.  The next sections build upon the XDR data types to define\n   types
    and structures specific to this protocol.  As a reminder, the\n   size constants
    and authoritative definitions can be found in\n   [RFC7531].\n"
  - contents:
    - "2.1.  Basic Data Types\n   Table 1 lists the base NFSv4 data types.\n   +-----------------+-------------------------------------------------+\n
      \  | Data Type       | Definition                                      |\n   +-----------------+-------------------------------------------------+\n
      \  | int32_t         | typedef int int32_t;                            |\n   |
      \                |                                                 |\n   | uint32_t
      \       | typedef unsigned int uint32_t;                  |\n   |                 |
      \                                                |\n   | int64_t         | typedef
      hyper int64_t;                          |\n   |                 |                                                 |\n
      \  | uint64_t        | typedef unsigned hyper uint64_t;                |\n   |
      \                |                                                 |\n   | attrlist4
      \      | typedef opaque attrlist4<>;                     |\n   |                 |
      \                                                |\n   |                 | Used
      for file/directory attributes.             |\n   |                 |                                                 |\n
      \  | bitmap4         | typedef uint32_t bitmap4<>;                     |\n   |
      \                |                                                 |\n   |                 |
      Used in attribute array encoding.               |\n   |                 |                                                 |\n
      \  | changeid4       | typedef uint64_t changeid4;                     |\n   |
      \                |                                                 |\n   |                 |
      Used in the definition of change_info4.         |\n   |                 |                                                 |\n
      \  | clientid4       | typedef uint64_t clientid4;                     |\n   |
      \                |                                                 |\n   |                 |
      Shorthand reference to client identification.   |\n   |                 |                                                 |\n
      \  | count4          | typedef uint32_t count4;                        |\n   |
      \                |                                                 |\n   |                 |
      Various count parameters (READ, WRITE, COMMIT). |\n   |                 |                                                 |\n
      \  | length4         | typedef uint64_t length4;                       |\n   |
      \                |                                                 |\n   |                 |
      Describes LOCK lengths.                         |\n   |                 |                                                 |\n
      \  | mode4           | typedef uint32_t mode4;                         |\n   |
      \                |                                                 |\n   |                 |
      Mode attribute data type.                       |\n   |                 |                                                 |\n
      \  | nfs_cookie4     | typedef uint64_t nfs_cookie4;                   |\n   |
      \                |                                                 |\n   |                 |
      Opaque cookie value for READDIR.                |\n   |                 |                                                 |\n
      \  | nfs_fh4         | typedef opaque nfs_fh4<NFS4_FHSIZE>;            |\n   |
      \                |                                                 |\n   |                 |
      Filehandle definition.                          |\n   |                 |                                                 |\n
      \  | nfs_ftype4      | enum nfs_ftype4;                                |\n   |
      \                |                                                 |\n   |                 |
      Various defined file types.                     |\n   |                 |                                                 |\n
      \  | nfsstat4        | enum nfsstat4;                                  |\n   |
      \                |                                                 |\n   |                 |
      Return value for operations.                    |\n   |                 |                                                 |\n
      \  | nfs_lease4      | typedef uint32_t nfs_lease4;                    |\n   |
      \                |                                                 |\n   |                 |
      Duration of a lease in seconds.                 |\n   |                 |                                                 |\n
      \  | offset4         | typedef uint64_t offset4;                       |\n   |
      \                |                                                 |\n   |                 |
      Various offset designations (READ, WRITE, LOCK, |\n   |                 | COMMIT).
      \                                       |\n   |                 |                                                 |\n
      \  | qop4            | typedef uint32_t qop4;                          |\n   |
      \                |                                                 |\n   |                 |
      Quality of protection designation in SECINFO.   |\n   |                 |                                                 |\n
      \  | sec_oid4        | typedef opaque sec_oid4<>;                      |\n   |
      \                |                                                 |\n   |                 |
      Security Object Identifier.  The sec_oid4 data  |\n   |                 | type
      is not really opaque.  Instead, it         |\n   |                 | contains
      an ASN.1 OBJECT IDENTIFIER as used by  |\n   |                 | GSS-API in
      the mech_type argument to            |\n   |                 | GSS_Init_sec_context.
      \ See [RFC2743] for        |\n   |                 | details.                                        |\n
      \  |                 |                                                 |\n   |
      seqid4          | typedef uint32_t seqid4;                        |\n   |                 |
      \                                                |\n   |                 | Sequence
      identifier used for file locking.      |\n   |                 |                                                 |\n
      \  | utf8string      | typedef opaque utf8string<>;                    |\n   |
      \                |                                                 |\n   |                 |
      UTF-8 encoding for strings.                     |\n   |                 |                                                 |\n
      \  | utf8str_cis     | typedef utf8string utf8str_cis;                 |\n   |
      \                |                                                 |\n   |                 |
      Case-insensitive UTF-8 string.                  |\n   |                 |                                                 |\n
      \  | utf8str_cs      | typedef utf8string utf8str_cs;                  |\n   |
      \                |                                                 |\n   |                 |
      Case-sensitive UTF-8 string.                    |\n   |                 |                                                 |\n
      \  | utf8str_mixed   | typedef utf8string utf8str_mixed;               |\n   |
      \                |                                                 |\n   |                 |
      UTF-8 strings with a case-sensitive prefix and  |\n   |                 | a
      case-insensitive suffix.                      |\n   |                 |                                                 |\n
      \  | component4      | typedef utf8str_cs component4;                  |\n   |
      \                |                                                 |\n   |                 |
      Represents pathname components.                 |\n   |                 |                                                 |\n
      \  | linktext4       | typedef opaque linktext4<>;                     |\n   |
      \                |                                                 |\n   |                 |
      Symbolic link contents (\"symbolic link\" is      |\n   |                 |
      defined in an Open Group [openg_symlink]        |\n   |                 | standard).
      \                                     |\n   |                 |                                                 |\n
      \  | ascii_REQUIRED4 | typedef utf8string ascii_REQUIRED4;             |\n   |
      \                |                                                 |\n   |                 |
      String is sent as ASCII and thus is             |\n   |                 | automatically
      UTF-8.                            |\n   |                 |                                                 |\n
      \  | pathname4       | typedef component4 pathname4<>;                 |\n   |
      \                |                                                 |\n   |                 |
      Represents pathname for fs_locations.           |\n   |                 |                                                 |\n
      \  | nfs_lockid4     | typedef uint64_t nfs_lockid4;                   |\n   |
      \                |                                                 |\n   | verifier4
      \      | typedef opaque verifier4[NFS4_VERIFIER_SIZE];   |\n   |                 |
      \                                                |\n   |                 | Verifier
      used for various operations (COMMIT,   |\n   |                 | CREATE, OPEN,
      READDIR, WRITE)                   |\n   |                 | NFS4_VERIFIER_SIZE
      is defined as 8.             |\n   +-----------------+-------------------------------------------------+\n
      \                     Table 1: Base NFSv4 Data Types\n"
    title: 2.1.  Basic Data Types
  - contents:
    - '2.2.  Structured Data Types

      '
    - contents:
      - "2.2.1.  nfstime4\n   struct nfstime4 {\n           int64_t         seconds;\n
        \          uint32_t        nseconds;\n   };\n   The nfstime4 structure gives
        the number of seconds and nanoseconds\n   since midnight or 0 hour January
        1, 1970 Coordinated Universal Time\n   (UTC).  Values greater than zero for
        the seconds field denote dates\n   after the 0 hour January 1, 1970.  Values
        less than zero for the\n   seconds field denote dates before the 0 hour January
        1, 1970.  In\n   both cases, the nseconds field is to be added to the seconds
        field\n   for the final time representation.  For example, if the time to
        be\n   represented is one-half second before 0 hour January 1, 1970, the\n
        \  seconds field would have a value of negative one (-1) and the\n   nseconds
        fields would have a value of one-half second (500000000).\n   Values greater
        than 999,999,999 for nseconds are considered invalid.\n   This data type is
        used to pass time and date information.  A server\n   converts to and from
        its local representation of time when processing\n   time values, preserving
        as much accuracy as possible.  If the\n   precision of timestamps stored for
        a file system object is less than\n   defined, loss of precision can occur.
        \ An adjunct time maintenance\n   protocol is recommended to reduce client
        and server time skew.\n"
      title: 2.2.1.  nfstime4
    - contents:
      - "2.2.2.  time_how4\n   enum time_how4 {\n           SET_TO_SERVER_TIME4 =
        0,\n           SET_TO_CLIENT_TIME4 = 1\n   };\n"
      title: 2.2.2.  time_how4
    - contents:
      - "2.2.3.  settime4\n   union settime4 switch (time_how4 set_it) {\n    case
        SET_TO_CLIENT_TIME4:\n            nfstime4       time;\n    default:\n            void;\n
        \  };\n   The above definitions are used as the attribute definitions to set\n
        \  time values.  If set_it is SET_TO_SERVER_TIME4, then the server uses\n
        \  its local representation of time for the time value.\n"
      title: 2.2.3.  settime4
    - contents:
      - "2.2.4.  specdata4\n   struct specdata4 {\n           uint32_t specdata1;
        /* major device number */\n           uint32_t specdata2; /* minor device
        number */\n   };\n   This data type represents additional information for
        the device file\n   types NF4CHR and NF4BLK.\n"
      title: 2.2.4.  specdata4
    - contents:
      - "2.2.5.  fsid4\n   struct fsid4 {\n           uint64_t        major;\n           uint64_t
        \       minor;\n   };\n   This type is the file system identifier that is
        used as a REQUIRED\n   attribute.\n"
      title: 2.2.5.  fsid4
    - contents:
      - "2.2.6.  fs_location4\n   struct fs_location4 {\n           utf8str_cis             server<>;\n
        \          pathname4               rootpath;\n   };\n"
      title: 2.2.6.  fs_location4
    - contents:
      - "2.2.7.  fs_locations4\n   struct fs_locations4 {\n           pathname4       fs_root;\n
        \          fs_location4    locations<>;\n   };\n   The fs_location4 and fs_locations4
        data types are used for the\n   fs_locations RECOMMENDED attribute, which
        is used for migration and\n   replication support.\n"
      title: 2.2.7.  fs_locations4
    - contents:
      - "2.2.8.  fattr4\n   struct fattr4 {\n           bitmap4         attrmask;\n
        \          attrlist4       attr_vals;\n   };\n   The fattr4 structure is used
        to represent file and directory\n   attributes.\n   The bitmap is a counted
        array of 32-bit integers used to contain bit\n   values.  The position of
        the integer in the array that contains bit n\n   can be computed from the
        expression (n / 32), and its bit within that\n   integer is (n mod 32).\n
        \                      0            1\n     +-----------+-----------+-----------+--\n
        \    |  count    | 31  ..  0 | 63  .. 32 |\n     +-----------+-----------+-----------+--\n"
      title: 2.2.8.  fattr4
    - contents:
      - "2.2.9.  change_info4\n   struct change_info4 {\n           bool            atomic;\n
        \          changeid4       before;\n           changeid4       after;\n   };\n
        \  This structure is used with the CREATE, LINK, REMOVE, and RENAME\n   operations
        to let the client know the value of the change attribute\n   for the directory
        in which the target file system object resides.\n"
      title: 2.2.9.  change_info4
    - contents:
      - "2.2.10.  clientaddr4\n   struct clientaddr4 {\n           /* see struct rpcb
        in RFC 1833 */\n           string r_netid<>;    /* network id */\n           string
        r_addr<>;     /* universal address */\n   };\n   The clientaddr4 structure
        is used as part of the SETCLIENTID\n   operation, either (1) to specify the
        address of the client that is\n   using a client ID or (2) as part of the
        callback registration.  The\n   r_netid and r_addr fields respectively contain
        a network id and\n   universal address.  The network id and universal address
        concepts,\n   together with formats for TCP over IPv4 and TCP over IPv6, are\n
        \  defined in [RFC5665], specifically Tables 2 and 3 and\n   Sections 5.2.3.3
        and 5.2.3.4.\n"
      title: 2.2.10.  clientaddr4
    - contents:
      - "2.2.11.  cb_client4\n   struct cb_client4 {\n           unsigned int    cb_program;\n
        \          clientaddr4     cb_location;\n   };\n   This structure is used
        by the client to inform the server of its\n   callback address; it includes
        the program number and client address.\n"
      title: 2.2.11.  cb_client4
    - contents:
      - "2.2.12.  nfs_client_id4\n   struct nfs_client_id4 {\n           verifier4
        \      verifier;\n           opaque          id<NFS4_OPAQUE_LIMIT>;\n   };\n
        \  This structure is part of the arguments to the SETCLIENTID operation.\n"
      title: 2.2.12.  nfs_client_id4
    - contents:
      - "2.2.13.  open_owner4\n   struct open_owner4 {\n           clientid4       clientid;\n
        \          opaque          owner<NFS4_OPAQUE_LIMIT>;\n   };\n   This structure
        is used to identify the owner of open state.\n"
      title: 2.2.13.  open_owner4
    - contents:
      - "2.2.14.  lock_owner4\n   struct lock_owner4 {\n           clientid4       clientid;\n
        \          opaque          owner<NFS4_OPAQUE_LIMIT>;\n   };\n   This structure
        is used to identify the owner of file locking state.\n"
      title: 2.2.14.  lock_owner4
    - contents:
      - "2.2.15.  open_to_lock_owner4\n   struct open_to_lock_owner4 {\n           seqid4
        \         open_seqid;\n           stateid4        open_stateid;\n           seqid4
        \         lock_seqid;\n           lock_owner4     lock_owner;\n   };\n   This
        structure is used for the first LOCK operation done for an\n   open_owner4.
        \ It provides both the open_stateid and lock_owner such\n   that the transition
        is made from a valid open_stateid sequence to\n   that of the new lock_stateid
        sequence.  Using this mechanism avoids\n   the confirmation of the lock_owner/lock_seqid
        pair since it is tied\n   to established state in the form of the open_stateid/open_seqid.\n"
      title: 2.2.15.  open_to_lock_owner4
    - contents:
      - "2.2.16.  stateid4\n   struct stateid4 {\n           uint32_t        seqid;\n
        \          opaque          other[NFS4_OTHER_SIZE];\n   };\n   This structure
        is used for the various state-sharing mechanisms\n   between the client and
        server.  For the client, this data structure\n   is read-only.  The server
        is required to increment the seqid field\n   monotonically at each transition
        of the stateid.  This is important\n   since the client will inspect the seqid
        in OPEN stateids to determine\n   the order of OPEN processing done by the
        server.\n"
      title: 2.2.16.  stateid4
    title: 2.2.  Structured Data Types
  title: 2.  Protocol Data Types
- contents:
  - "3.  RPC and Security Flavor\n   The NFSv4 protocol is an RPC application that
    uses RPC version 2 and\n   the XDR as defined in [RFC5531] and [RFC4506].  The
    RPCSEC_GSS\n   security flavors as defined in version 1 ([RFC2203]) and version
    2\n   ([RFC5403]) MUST be implemented as the mechanism to deliver stronger\n   security
    for the NFSv4 protocol.  However, deployment of RPCSEC_GSS\n   is optional.\n"
  - contents:
    - "3.1.  Ports and Transports\n   Historically, NFSv2 and NFSv3 servers have resided
      on port 2049.  The\n   registered port 2049 [RFC3232] for the NFS protocol SHOULD
      be the\n   default configuration.  Using the registered port for NFS services\n
      \  means the NFS client will not need to use the RPC binding protocols\n   as
      described in [RFC1833]; this will allow NFS to transit firewalls.\n   Where
      an NFSv4 implementation supports operation over the IP network\n   protocol,
      the supported transport layer between NFS and IP MUST be an\n   IETF standardized
      transport protocol that is specified to avoid\n   network congestion; such transports
      include TCP and the Stream\n   Control Transmission Protocol (SCTP).  To enhance
      the possibilities\n   for interoperability, an NFSv4 implementation MUST support
      operation\n   over the TCP transport protocol.\n   If TCP is used as the transport,
      the client and server SHOULD use\n   persistent connections.  This will prevent
      the weakening of TCP's\n   congestion control via short-lived connections and
      will improve\n   performance for the Wide Area Network (WAN) environment by\n
      \  eliminating the need for SYN handshakes.\n   As noted in Section 19, the
      authentication model for NFSv4 has moved\n   from machine-based to principal-based.
      \ However, this modification of\n   the authentication model does not imply
      a technical requirement to\n   move the TCP connection management model from
      whole machine-based to\n   one based on a per-user model.  In particular, NFS
      over TCP client\n   implementations have traditionally multiplexed traffic for
      multiple\n   users over a common TCP connection between an NFS client and server.\n
      \  This has been true, regardless of whether the NFS client is using\n   AUTH_SYS,
      AUTH_DH, RPCSEC_GSS, or any other flavor.  Similarly, NFS\n   over TCP server
      implementations have assumed such a model and thus\n   scale the implementation
      of TCP connection management in proportion\n   to the number of expected client
      machines.  It is intended that NFSv4\n   will not modify this connection management
      model.  NFSv4 clients that\n   violate this assumption can expect scaling issues
      on the server and\n   hence reduced service.\n"
    - contents:
      - "3.1.1.  Client Retransmission Behavior\n   When processing an NFSv4 request
        received over a reliable transport\n   such as TCP, the NFSv4 server MUST
        NOT silently drop the request,\n   except if the established transport connection
        has been broken.\n   Given such a contract between NFSv4 clients and servers,
        clients MUST\n   NOT retry a request unless one or both of the following are
        true:\n   o  The transport connection has been broken\n   o  The procedure
        being retried is the NULL procedure\n   Since reliable transports, such as
        TCP, do not always synchronously\n   inform a peer when the other peer has
        broken the connection (for\n   example, when an NFS server reboots), the NFSv4
        client may want to\n   actively \"probe\" the connection to see if has been
        broken.  Use of\n   the NULL procedure is one recommended way to do so.  So,
        when a\n   client experiences a remote procedure call timeout (of some arbitrary\n
        \  implementation-specific amount), rather than retrying the remote\n   procedure
        call, it could instead issue a NULL procedure call to the\n   server.  If
        the server has died, the transport connection break will\n   eventually be
        indicated to the NFSv4 client.  The client can then\n   reconnect, and then
        retry the original request.  If the NULL\n   procedure call gets a response,
        the connection has not broken.  The\n   client can decide to wait longer for
        the original request's response,\n   or it can break the transport connection
        and reconnect before\n   re-sending the original request.\n   For callbacks
        from the server to the client, the same rules apply,\n   but the server doing
        the callback becomes the client, and the client\n   receiving the callback
        becomes the server.\n"
      title: 3.1.1.  Client Retransmission Behavior
    title: 3.1.  Ports and Transports
  - contents:
    - "3.2.  Security Flavors\n   Traditional RPC implementations have included AUTH_NONE,
      AUTH_SYS,\n   AUTH_DH, and AUTH_KRB4 as security flavors.  With [RFC2203], an\n
      \  additional security flavor of RPCSEC_GSS has been introduced, which\n   uses
      the functionality of GSS-API [RFC2743].  This allows for the use\n   of various
      security mechanisms by the RPC layer without the\n   additional implementation
      overhead of adding RPC security flavors.\n   For NFSv4, the RPCSEC_GSS security
      flavor MUST be used to enable the\n   mandatory-to-implement security mechanism.
      \ Other flavors, such as\n   AUTH_NONE, AUTH_SYS, and AUTH_DH, MAY be implemented
      as well.\n"
    - contents:
      - "3.2.1.  Security Mechanisms for NFSv4\n   RPCSEC_GSS, via GSS-API, supports
        multiple mechanisms that provide\n   security services.  For interoperability,
        NFSv4 clients and servers\n   MUST support the Kerberos V5 security mechanism.\n
        \  The use of RPCSEC_GSS requires selection of mechanism, quality of\n   protection
        (QOP), and service (authentication, integrity, privacy).\n   For the mandated
        security mechanisms, NFSv4 specifies that a QOP of\n   zero is used, leaving
        it up to the mechanism or the mechanism's\n   configuration to map QOP zero
        to an appropriate level of protection.\n   Each mandated mechanism specifies
        a minimum set of cryptographic\n   algorithms for implementing integrity and
        privacy.  NFSv4 clients and\n   servers MUST be implemented on operating environments
        that comply\n   with the required cryptographic algorithms of each required\n
        \  mechanism.\n"
      - contents:
        - "3.2.1.1.  Kerberos V5 as a Security Triple\n   The Kerberos V5 GSS-API
          mechanism as described in [RFC4121] MUST be\n   implemented with the RPCSEC_GSS
          services as specified in Table 2.\n   Both client and server MUST support
          each of the pseudo-flavors.\n     +--------+-------+----------------------+-----------------------+\n
          \    | Number | Name  | Mechanism's OID      | RPCSEC_GSS service    |\n
          \    +--------+-------+----------------------+-----------------------+\n
          \    | 390003 | krb5  | 1.2.840.113554.1.2.2 | rpc_gss_svc_none      |\n
          \    | 390004 | krb5i | 1.2.840.113554.1.2.2 | rpc_gss_svc_integrity |\n
          \    | 390005 | krb5p | 1.2.840.113554.1.2.2 | rpc_gss_svc_privacy   |\n
          \    +--------+-------+----------------------+-----------------------+\n
          \                Table 2: Mapping Pseudo-Flavor to Service\n   Note that
          the pseudo-flavor is presented here as a mapping aid to the\n   implementer.
          \ Because this NFS protocol includes a method to\n   negotiate security
          and it understands the GSS-API mechanism, the\n   pseudo-flavor is not needed.
          \ The pseudo-flavor is needed for NFSv3\n   since the security negotiation
          is done via the MOUNT protocol as\n   described in [RFC2623].\n   At the
          time this document was specified, the Advanced Encryption\n   Standard (AES)
          with HMAC-SHA1 was a required algorithm set for\n   Kerberos V5.  In contrast,
          when NFSv4.0 was first specified in\n   [RFC3530], weaker algorithm sets
          were REQUIRED for Kerberos V5, and\n   were REQUIRED in the NFSv4.0 specification,
          because the Kerberos V5\n   specification at the time did not specify stronger
          algorithms.  The\n   NFSv4 specification does not specify required algorithms
          for Kerberos\n   V5, and instead, the implementer is expected to track the
          evolution\n   of the Kerberos V5 standard if and when stronger algorithms
          are\n   specified.\n"
        - contents:
          - "3.2.1.1.1.  Security Considerations for Cryptographic Algorithms in\n
            \           Kerberos V5\n   When deploying NFSv4, the strength of the
            security achieved depends\n   on the existing Kerberos V5 infrastructure.
            \ The algorithms of\n   Kerberos V5 are not directly exposed to or selectable
            by the client\n   or server, so there is some due diligence required by
            the user of\n   NFSv4 to ensure that security is acceptable where needed.
            \ Guidance\n   is provided in [RFC6649] as to why weak algorithms should
            be disabled\n   by default.\n"
          title: 3.2.1.1.1.  Security Considerations for Cryptographic Algorithms
            in
        title: 3.2.1.1.  Kerberos V5 as a Security Triple
      title: 3.2.1.  Security Mechanisms for NFSv4
    title: 3.2.  Security Flavors
  - contents:
    - "3.3.  Security Negotiation\n   With the NFSv4 server potentially offering multiple
      security\n   mechanisms, the client needs a method to determine or negotiate
      which\n   mechanism is to be used for its communication with the server.  The\n
      \  NFS server can have multiple points within its file system namespace\n   that
      are available for use by NFS clients.  In turn, the NFS server\n   can be configured
      such that each of these entry points can have\n   different or multiple security
      mechanisms in use.\n   The security negotiation between client and server SHOULD
      be done\n   with a secure channel to eliminate the possibility of a third party\n
      \  intercepting the negotiation sequence and forcing the client and\n   server
      to choose a lower level of security than required or desired.\n   See Section
      19 for further discussion.\n"
    - contents:
      - "3.3.1.  SECINFO\n   The SECINFO operation will allow the client to determine,
        on a\n   per-filehandle basis, what security triple (see [RFC2743] and\n   Section
        16.31.4) is to be used for server access.  In general, the\n   client will
        not have to use the SECINFO operation, except during\n   initial communication
        with the server or when the client encounters a\n   new security policy as
        the client navigates the namespace.  Either\n   condition will force the client
        to negotiate a new security triple.\n"
      title: 3.3.1.  SECINFO
    - contents:
      - "3.3.2.  Security Error\n   Based on the assumption that each NFSv4 client
        and server MUST\n   support a minimum set of security (i.e., Kerberos V5 under\n
        \  RPCSEC_GSS), the NFS client will start its communication with the\n   server
        with one of the minimal security triples.  During\n   communication with the
        server, the client can receive an NFS error of\n   NFS4ERR_WRONGSEC.  This
        error allows the server to notify the client\n   that the security triple
        currently being used is not appropriate for\n   access to the server's file
        system resources.  The client is then\n   responsible for determining what
        security triples are available at\n   the server and choosing one that is
        appropriate for the client.  See\n   Section 16.31 for further discussion
        of how the client will respond\n   to the NFS4ERR_WRONGSEC error and use SECINFO.\n"
      title: 3.3.2.  Security Error
    - contents:
      - "3.3.3.  Callback RPC Authentication\n   Except as noted elsewhere in this
        section, the callback RPC\n   (described later) MUST mutually authenticate
        the NFS server to the\n   principal that acquired the client ID (also described
        later), using\n   the security flavor of the original SETCLIENTID operation
        used.\n   For AUTH_NONE, there are no principals, so this is a non-issue.\n
        \  AUTH_SYS has no notions of mutual authentication or a server\n   principal,
        so the callback from the server simply uses the AUTH_SYS\n   credential that
        the user used when he set up the delegation.\n   For AUTH_DH, one commonly
        used convention is that the server uses the\n   credential corresponding to
        this AUTH_DH principal:\n     unix.host@domain\n   where host and domain are
        variables corresponding to the name of the\n   server host and directory services
        domain in which it lives, such as\n   a Network Information System domain
        or a DNS domain.\n   Regardless of what security mechanism under RPCSEC_GSS
        is being used,\n   the NFS server MUST identify itself in GSS-API via a\n
        \  GSS_C_NT_HOSTBASED_SERVICE name type.  GSS_C_NT_HOSTBASED_SERVICE\n   names
        are of the form:\n     service@hostname\n   For NFS, the \"service\" element
        is:\n     nfs\n   Implementations of security mechanisms will convert nfs@hostname
        to\n   various different forms.  For Kerberos V5, the following form is\n
        \  RECOMMENDED:\n     nfs/hostname\n   For Kerberos V5, nfs/hostname would
        be a server principal in the\n   Kerberos Key Distribution Center database.
        \ This is the same\n   principal the client acquired a GSS-API context for
        when it issued\n   the SETCLIENTID operation; therefore, the realm name for
        the server\n   principal must be the same for the callback as it was for the\n
        \  SETCLIENTID.\n"
      title: 3.3.3.  Callback RPC Authentication
    title: 3.3.  Security Negotiation
  title: 3.  RPC and Security Flavor
- contents:
  - "4.  Filehandles\n   The filehandle in the NFS protocol is a per-server unique
    identifier\n   for a file system object.  The contents of the filehandle are opaque\n
    \  to the client.  Therefore, the server is responsible for translating\n   the
    filehandle to an internal representation of the file system\n   object.\n"
  - contents:
    - "4.1.  Obtaining the First Filehandle\n   The operations of the NFS protocol
      are defined in terms of one or\n   more filehandles.  Therefore, the client
      needs a filehandle to\n   initiate communication with the server.  With the
      NFSv2 protocol\n   [RFC1094] and the NFSv3 protocol [RFC1813], there exists
      an ancillary\n   protocol to obtain this first filehandle.  The MOUNT protocol,
      RPC\n   program number 100005, provides the mechanism of translating a\n   string-based
      file system pathname to a filehandle that can then be\n   used by the NFS protocols.\n
      \  The MOUNT protocol has deficiencies in the area of security and use\n   via
      firewalls.  This is one reason that the use of the public\n   filehandle was
      introduced in [RFC2054] and [RFC2055].  With the use\n   of the public filehandle
      in combination with the LOOKUP operation in\n   the NFSv2 and NFSv3 protocols,
      it has been demonstrated that the\n   MOUNT protocol is unnecessary for viable
      interaction between the NFS\n   client and server.\n   Therefore, the NFSv4
      protocol will not use an ancillary protocol for\n   translation from string-based
      pathnames to a filehandle.  Two special\n   filehandles will be used as starting
      points for the NFS client.\n"
    - contents:
      - "4.1.1.  Root Filehandle\n   The first of the special filehandles is the root
        filehandle.  The\n   root filehandle is the \"conceptual\" root of the file
        system namespace\n   at the NFS server.  The client uses or starts with the
        root\n   filehandle by employing the PUTROOTFH operation.  The PUTROOTFH\n
        \  operation instructs the server to set the current filehandle to the\n   root
        of the server's file tree.  Once this PUTROOTFH operation is\n   used, the
        client can then traverse the entirety of the server's file\n   tree with the
        LOOKUP operation.  A complete discussion of the server\n   namespace is in
        Section 7.\n"
      title: 4.1.1.  Root Filehandle
    - contents:
      - "4.1.2.  Public Filehandle\n   The second special filehandle is the public
        filehandle.  Unlike the\n   root filehandle, the public filehandle may be
        bound or represent an\n   arbitrary file system object at the server.  The
        server is\n   responsible for this binding.  It may be that the public filehandle\n
        \  and the root filehandle refer to the same file system object.\n   However,
        it is up to the administrative software at the server and\n   the policies
        of the server administrator to define the binding of the\n   public filehandle
        and server file system object.  The client may not\n   make any assumptions
        about this binding.  The client uses the public\n   filehandle via the PUTPUBFH
        operation.\n"
      title: 4.1.2.  Public Filehandle
    title: 4.1.  Obtaining the First Filehandle
  - contents:
    - "4.2.  Filehandle Types\n   In the NFSv2 and NFSv3 protocols, there was one
      type of filehandle\n   with a single set of semantics, of which the primary
      one was that it\n   was persistent across a server reboot.  As such, this type
      of\n   filehandle is termed \"persistent\" in NFSv4.  The semantics of a\n   persistent
      filehandle remain the same as before.  A new type of\n   filehandle introduced
      in NFSv4 is the volatile filehandle, which\n   attempts to accommodate certain
      server environments.\n   The volatile filehandle type was introduced to address
      server\n   functionality or implementation issues that make correct\n   implementation
      of a persistent filehandle infeasible.  Some server\n   environments do not
      provide a file system level invariant that can be\n   used to construct a persistent
      filehandle.  The underlying server\n   file system may not provide the invariant,
      or the server's file\n   system programming interfaces may not provide access
      to the needed\n   invariant.  Volatile filehandles may ease the implementation
      of\n   server functionality, such as hierarchical storage management or file\n
      \  system reorganization or migration.  However, the volatile filehandle\n   increases
      the implementation burden for the client.\n   Since the client will need to
      handle persistent and volatile\n   filehandles differently, a file attribute
      is defined that may be used\n   by the client to determine the filehandle types
      being returned by the\n   server.\n"
    - contents:
      - "4.2.1.  General Properties of a Filehandle\n   The filehandle contains all
        the information the server needs to\n   distinguish an individual file.  To
        the client, the filehandle is\n   opaque.  The client stores filehandles for
        use in a later request and\n   can compare two filehandles from the same server
        for equality by\n   doing a byte-by-byte comparison.  However, the client
        MUST NOT\n   otherwise interpret the contents of filehandles.  If two filehandles\n
        \  from the same server are equal, they MUST refer to the same file.\n   However,
        it is not required that two different filehandles refer to\n   different file
        system objects.  Servers SHOULD try to maintain a\n   one-to-one correspondence
        between filehandles and file system objects\n   but there may be situations
        in which the mapping is not one-to-one.\n   Clients MUST use filehandle comparisons
        only to improve performance,\n   not for correct behavior.  All clients need
        to be prepared for\n   situations in which it cannot be determined whether
        two different\n   filehandles denote the same object and in such cases need
        to avoid\n   assuming that objects denoted are different, as this might cause\n
        \  incorrect behavior.  Further discussion of filehandle and attribute\n   comparison
        in the context of data caching is presented in\n   Section 10.3.4.\n   As
        an example, in the case that two different pathnames when\n   traversed at
        the server terminate at the same file system object, the\n   server SHOULD
        return the same filehandle for each path.  This can\n   occur if a hard link
        is used to create two filenames that refer to\n   the same underlying file
        object and associated data.  For example, if\n   paths /a/b/c and /a/d/c refer
        to the same file, the server SHOULD\n   return the same filehandle for both
        pathname traversals.\n"
      title: 4.2.1.  General Properties of a Filehandle
    - contents:
      - "4.2.2.  Persistent Filehandle\n   A persistent filehandle is defined as having
        a fixed value for the\n   lifetime of the file system object to which it refers.
        \ Once the\n   server creates the filehandle for a file system object, the
        server\n   MUST accept the same filehandle for the object for the lifetime
        of\n   the object.  If the server restarts or reboots, the NFS server must\n
        \  honor the same filehandle value as it did in the server's previous\n   instantiation.
        \ Similarly, if the file system is migrated, the new\n   NFS server must honor
        the same filehandle as the old NFS server.\n   The persistent filehandle will
        become stale or invalid when the file\n   system object is removed.  When
        the server is presented with a\n   persistent filehandle that refers to a
        deleted object, it MUST return\n   an error of NFS4ERR_STALE.  A filehandle
        may become stale when the\n   file system containing the object is no longer
        available.  The file\n   system may become unavailable if it exists on removable
        media and the\n   media is no longer available at the server, or if the file
        system in\n   whole has been destroyed, or if the file system has simply been\n
        \  removed from the server's namespace (i.e., unmounted in a UNIX\n   environment).\n"
      title: 4.2.2.  Persistent Filehandle
    - contents:
      - "4.2.3.  Volatile Filehandle\n   A volatile filehandle does not share the
        same longevity\n   characteristics of a persistent filehandle.  The server
        may determine\n   that a volatile filehandle is no longer valid at many different\n
        \  points in time.  If the server can definitively determine that a\n   volatile
        filehandle refers to an object that has been removed, the\n   server should
        return NFS4ERR_STALE to the client (as is the case for\n   persistent filehandles).
        \ In all other cases where the server\n   determines that a volatile filehandle
        can no longer be used, it\n   should return an error of NFS4ERR_FHEXPIRED.\n
        \  The REQUIRED attribute \"fh_expire_type\" is used by the client to\n   determine
        what type of filehandle the server is providing for a\n   particular file
        system.  This attribute is a bitmask with the\n   following values:\n   FH4_PERSISTENT:
        \ The value of FH4_PERSISTENT is used to indicate a\n      persistent filehandle,
        which is valid until the object is removed\n      from the file system.  The
        server will not return\n      NFS4ERR_FHEXPIRED for this filehandle.  FH4_PERSISTENT
        is defined\n      as a value in which none of the bits specified below are
        set.\n   FH4_VOLATILE_ANY:  The filehandle may expire at any time, except
        as\n      specifically excluded (i.e., FH4_NOEXPIRE_WITH_OPEN).\n   FH4_NOEXPIRE_WITH_OPEN:
        \ May only be set when FH4_VOLATILE_ANY is\n      set.  If this bit is set,
        then the meaning of FH4_VOLATILE_ANY\n      is qualified to exclude any expiration
        of the filehandle when it\n      is open.\n   FH4_VOL_MIGRATION:  The filehandle
        will expire as a result of\n      migration.  If FH4_VOLATILE_ANY is set,
        FH4_VOL_MIGRATION is\n      redundant.\n   FH4_VOL_RENAME:  The filehandle
        will expire during rename.  This\n      includes a rename by the requesting
        client or a rename by any\n      other client.  If FH4_VOLATILE_ANY is set,
        FH4_VOL_RENAME is\n      redundant.\n   Servers that provide volatile filehandles
        that may expire while open\n   (i.e., if FH4_VOL_MIGRATION or FH4_VOL_RENAME
        is set or if\n   FH4_VOLATILE_ANY is set and FH4_NOEXPIRE_WITH_OPEN is not
        set) should\n   deny a RENAME or REMOVE that would affect an OPEN file of
        any of the\n   components leading to the OPEN file.  In addition, the server
        SHOULD\n   deny all RENAME or REMOVE requests during the grace period upon\n
        \  server restart.\n   Note that the bits FH4_VOL_MIGRATION and FH4_VOL_RENAME
        allow the\n   client to determine that expiration has occurred whenever a
        specific\n   event occurs, without an explicit filehandle expiration error
        from\n   the server.  FH4_VOLATILE_ANY does not provide this form of\n   information.
        \ In situations where the server will expire many, but\n   not all, filehandles
        upon migration (e.g., all but those that are\n   open), FH4_VOLATILE_ANY (in
        this case, with FH4_NOEXPIRE_WITH_OPEN)\n   is a better choice since the client
        may not assume that all\n   filehandles will expire when migration occurs,
        and it is likely that\n   additional expirations will occur (as a result of
        file CLOSE) that\n   are separated in time from the migration event itself.\n"
      title: 4.2.3.  Volatile Filehandle
    - contents:
      - "4.2.4.  One Method of Constructing a Volatile Filehandle\n   A volatile filehandle,
        while opaque to the client, could contain:\n     [volatile bit = 1 | server
        boot time | slot | generation number]\n   o  slot is an index in the server
        volatile filehandle table\n   o  generation number is the generation number
        for the table\n      entry/slot\n   When the client presents a volatile filehandle,
        the server makes the\n   following checks, which assume that the check for
        the volatile bit\n   has passed.  If the server boot time is less than the
        current server\n   boot time, return NFS4ERR_FHEXPIRED.  If slot is out of
        range, return\n   NFS4ERR_BADHANDLE.  If the generation number does not match,
        return\n   NFS4ERR_FHEXPIRED.\n   When the server reboots, the table is gone
        (it is volatile).\n   If the volatile bit is 0, then it is a persistent filehandle
        with a\n   different structure following it.\n"
      title: 4.2.4.  One Method of Constructing a Volatile Filehandle
    title: 4.2.  Filehandle Types
  - contents:
    - "4.3.  Client Recovery from Filehandle Expiration\n   If possible, the client
      should recover from the receipt of an\n   NFS4ERR_FHEXPIRED error.  The client
      must take on additional\n   responsibility so that it may prepare itself to
      recover from the\n   expiration of a volatile filehandle.  If the server returns\n
      \  persistent filehandles, the client does not need these additional\n   steps.\n
      \  For volatile filehandles, most commonly the client will need to store\n   the
      component names leading up to and including the file system\n   object in question.
      \ With these names, the client should be able to\n   recover by finding a filehandle
      in the namespace that is still\n   available or by starting at the root of the
      server's file system\n   namespace.\n   If the expired filehandle refers to
      an object that has been removed\n   from the file system, obviously the client
      will not be able to\n   recover from the expired filehandle.\n   It is also
      possible that the expired filehandle refers to a file that\n   has been renamed.
      \ If the file was renamed by another client, again\n   it is possible that the
      original client will not be able to recover.\n   However, in the case that the
      client itself is renaming the file and\n   the file is open, it is possible
      that the client may be able to\n   recover.  The client can determine the new
      pathname based on the\n   processing of the rename request.  The client can
      then regenerate the\n   new filehandle based on the new pathname.  The client
      could also use\n   the COMPOUND operation mechanism to construct a set of operations\n
      \  like:\n     RENAME A B\n     LOOKUP B\n     GETFH\n   Note that the COMPOUND
      procedure does not provide atomicity.  This\n   example only reduces the overhead
      of recovering from an expired\n   filehandle.\n"
    title: 4.3.  Client Recovery from Filehandle Expiration
  title: 4.  Filehandles
- contents:
  - "5.  Attributes\n   To meet the requirements of extensibility and increased\n
    \  interoperability with non-UNIX platforms, attributes need to be\n   handled
    in a flexible manner.  The NFSv3 fattr3 structure contains a\n   fixed list of
    attributes that not all clients and servers are able to\n   support or care about.
    \ The fattr3 structure cannot be extended as\n   new needs arise, and it provides
    no way to indicate non-support.\n   With the NFSv4.0 protocol, the client is able
    to query what\n   attributes the server supports and construct requests with only
    those\n   supported attributes (or a subset thereof).\n   To this end, attributes
    are divided into three groups: REQUIRED,\n   RECOMMENDED, and named.  Both REQUIRED
    and RECOMMENDED attributes are\n   supported in the NFSv4.0 protocol by a specific
    and well-defined\n   encoding and are identified by number.  They are requested
    by setting\n   a bit in the bit vector sent in the GETATTR request; the server\n
    \  response includes a bit vector to list what attributes were returned\n   in
    the response.  New REQUIRED or RECOMMENDED attributes may be added\n   to the
    NFSv4 protocol as part of a new minor version by publishing a\n   Standards Track
    RFC that allocates a new attribute number value and\n   defines the encoding for
    the attribute.  See Section 11 for further\n   discussion.\n   Named attributes
    are accessed by the OPENATTR operation, which\n   accesses a hidden directory
    of attributes associated with a file\n   system object.  OPENATTR takes a filehandle
    for the object and\n   returns the filehandle for the attribute hierarchy.  The
    filehandle\n   for the named attributes is a directory object accessible by LOOKUP\n
    \  or READDIR and contains files whose names represent the named\n   attributes
    and whose data bytes are the value of the attribute.  For\n   example:\n        +----------+-----------+---------------------------------+\n
    \       | LOOKUP   | \"foo\"     | ; look up file                  |\n        |
    GETATTR  | attrbits  |                                 |\n        | OPENATTR |
    \          | ; access foo's named attributes |\n        | LOOKUP   | \"x11icon\"
    | ; look up specific attribute    |\n        | READ     | 0,4096    | ; read stream
    of bytes          |\n        +----------+-----------+---------------------------------+\n
    \  Named attributes are intended for data needed by applications rather\n   than
    by an NFS client implementation.  NFS implementers are strongly\n   encouraged
    to define their new attributes as RECOMMENDED attributes\n   by bringing them
    to the IETF Standards Track process.\n   The set of attributes that are classified
    as REQUIRED is deliberately\n   small since servers need to do whatever it takes
    to support them.  A\n   server should support as many of the RECOMMENDED attributes
    as\n   possible; however, by their definition, the server is not required to\n
    \  support all of them.  Attributes are deemed REQUIRED if the data is\n   both
    needed by a large number of clients and is not otherwise\n   reasonably computable
    by the client when support is not provided on\n   the server.\n   Note that the
    hidden directory returned by OPENATTR is a convenience\n   for protocol processing.
    \ The client should not make any assumptions\n   about the server's implementation
    of named attributes and whether or\n   not the underlying file system at the server
    has a named attribute\n   directory.  Therefore, operations such as SETATTR and
    GETATTR on the\n   named attribute directory are undefined.\n"
  - contents:
    - "5.1.  REQUIRED Attributes\n   These attributes MUST be supported by every NFSv4.0
      client and server\n   in order to ensure a minimum level of interoperability.
      \ The server\n   MUST store and return these attributes, and the client MUST
      be able\n   to function with an attribute set limited to these attributes.  With\n
      \  just the REQUIRED attributes, some client functionality can be\n   impaired
      or limited in some ways.  A client can ask for any of these\n   attributes to
      be returned by setting a bit in the GETATTR request.\n   For each such bit set,
      the server MUST return the corresponding\n   attribute value.\n"
    title: 5.1.  REQUIRED Attributes
  - contents:
    - "5.2.  RECOMMENDED Attributes\n   These attributes are understood well enough
      to warrant support in the\n   NFSv4.0 protocol.  However, they may not be supported
      on all clients\n   and servers.  A client MAY ask for any of these attributes
      to be\n   returned by setting a bit in the GETATTR request but MUST handle the\n
      \  case where the server does not return them.  A client MAY ask for the\n   set
      of attributes the server supports and SHOULD NOT request\n   attributes the
      server does not support.  A server should be tolerant\n   of requests for unsupported
      attributes and simply not return them,\n   rather than considering the request
      an error.  It is expected that\n   servers will support all attributes they
      comfortably can and only\n   fail to support attributes that are difficult to
      support in their\n   operating environments.  A server should provide attributes
      whenever\n   they don't have to \"tell lies\" to the client.  For example, a
      file\n   modification time either should be an accurate time or should not be\n
      \  supported by the server.  At times this will be difficult for\n   clients,
      but a client is better positioned to decide whether and how\n   to fabricate
      or construct an attribute or whether to do without the\n   attribute.\n"
    title: 5.2.  RECOMMENDED Attributes
  - contents:
    - "5.3.  Named Attributes\n   These attributes are not supported by direct encoding
      in the NFSv4\n   protocol but are accessed by string names rather than numbers
      and\n   correspond to an uninterpreted stream of bytes that are stored with\n
      \  the file system object.  The namespace for these attributes may be\n   accessed
      by using the OPENATTR operation.  The OPENATTR operation\n   returns a filehandle
      for a virtual \"named attribute directory\", and\n   further perusal and modification
      of the namespace may be done using\n   operations that work on more typical
      directories.  In particular,\n   READDIR may be used to get a list of such named
      attributes, and\n   LOOKUP and OPEN may select a particular attribute.  Creation
      of a new\n   named attribute may be the result of an OPEN specifying file\n
      \  creation.\n   Once an OPEN is done, named attributes may be examined and
      changed by\n   normal READ and WRITE operations using the filehandles and stateids\n
      \  returned by OPEN.\n   Named attributes and the named attribute directory
      may have their own\n   (non-named) attributes.  Each of these objects must have
      all of the\n   REQUIRED attributes and may have additional RECOMMENDED attributes.\n
      \  However, the set of attributes for named attributes and the named\n   attribute
      directory need not be, and typically will not be, as large\n   as that for other
      objects in that file system.\n   Named attributes might be the target of delegations.
      \ However, since\n   granting of delegations is at the server's discretion,
      a server need\n   not support delegations on named attributes.\n   It is RECOMMENDED
      that servers support arbitrary named attributes.\n   A client should not depend
      on the ability to store any named\n   attributes in the server's file system.
      \ If a server does support\n   named attributes, a client that is also able
      to handle them should be\n   able to copy a file's data and metadata with complete
      transparency\n   from one location to another; this would imply that names allowed
      for\n   regular directory entries are valid for named attribute names\n   as
      well.\n   In NFSv4.0, the structure of named attribute directories is\n   restricted
      in a number of ways, in order to prevent the development\n   of non-interoperable
      implementations in which some servers support a\n   fully general hierarchical
      directory structure for named attributes\n   while others support a limited
      but adequate structure for named\n   attributes.  In such an environment, clients
      or applications might\n   come to depend on non-portable extensions.  The restrictions
      are:\n   o  CREATE is not allowed in a named attribute directory.  Thus, such\n
      \     objects as symbolic links and special files are not allowed to be\n      named
      attributes.  Further, directories may not be created in a\n      named attribute
      directory, so no hierarchical structure of named\n      attributes for a single
      object is allowed.\n   o  If OPENATTR is done on a named attribute directory
      or on a named\n      attribute, the server MUST return an error.\n   o  Doing
      a RENAME of a named attribute to a different named attribute\n      directory
      or to an ordinary (i.e., non-named-attribute) directory\n      is not allowed.\n
      \  o  Creating hard links between named attribute directories or between\n      named
      attribute directories and ordinary directories is not\n      allowed.\n   Names
      of attributes will not be controlled by this document or other\n   IETF Standards
      Track documents.  See Section 20 for further\n   discussion.\n"
    title: 5.3.  Named Attributes
  - contents:
    - "5.4.  Classification of Attributes\n   Each of the attributes accessed using
      SETATTR and GETATTR (i.e.,\n   REQUIRED and RECOMMENDED attributes) can be classified
      in one of\n   three categories:\n   1.  per-server attributes for which the
      value of the attribute will\n       be the same for all file objects that share
      the same server.\n   2.  per-file system attributes for which the value of the
      attribute\n       will be the same for some or all file objects that share the
      same\n       server and fsid attribute (Section 5.8.1.9).  See below for\n       details
      regarding when such sharing is in effect.\n   3.  per-file system object attributes.\n
      \  The handling of per-file system attributes depends on the particular\n   attribute
      and the setting of the homogeneous (Section 5.8.2.12)\n   attribute.  The following
      rules apply:\n   1.  The values of the attributes supported_attrs, fsid, homogeneous,\n
      \      link_support, and symlink_support are always common to all\n       objects
      within the given file system.\n   2.  For other attributes, different values
      may be returned for\n       different file system objects if the attribute homogeneous
      is\n       supported within the file system in question and has the value\n
      \      false.\n   The classification of attributes is as follows.  Note that
      the\n   attributes time_access_set and time_modify_set are not listed in this\n
      \  section, because they are write-only attributes corresponding to\n   time_access
      and time_modify and are used in a special instance of\n   SETATTR.\n   o  The
      per-server attribute is:\n         lease_time\n   o  The per-file system attributes
      are:\n         supported_attrs, fh_expire_type, link_support, symlink_support,\n
      \        unique_handles, aclsupport, cansettime, case_insensitive,\n         case_preserving,
      chown_restricted, files_avail, files_free,\n         files_total, fs_locations,
      homogeneous, maxfilesize, maxname,\n         maxread, maxwrite, no_trunc, space_avail,
      space_free,\n         space_total, and time_delta\n   o  The per-file system
      object attributes are:\n         type, change, size, named_attr, fsid, rdattr_error,
      filehandle,\n         acl, archive, fileid, hidden, maxlink, mimetype, mode,\n
      \        numlinks, owner, owner_group, rawdev, space_used, system,\n         time_access,
      time_backup, time_create, time_metadata,\n         time_modify, and mounted_on_fileid\n
      \  For quota_avail_hard, quota_avail_soft, and quota_used, see their\n   definitions
      below for the appropriate classification.\n"
    title: 5.4.  Classification of Attributes
  - contents:
    - "5.5.  Set-Only and Get-Only Attributes\n   Some REQUIRED and RECOMMENDED attributes
      are set-only; i.e., they can\n   be set via SETATTR but not retrieved via GETATTR.
      \ Similarly, some\n   REQUIRED and RECOMMENDED attributes are get-only; i.e.,
      they can be\n   retrieved via GETATTR but not set via SETATTR.  If a client
      attempts\n   to set a get-only attribute or get a set-only attribute, the server\n
      \  MUST return NFS4ERR_INVAL.\n"
    title: 5.5.  Set-Only and Get-Only Attributes
  - contents:
    - "5.6.  REQUIRED Attributes - List and Definition References\n   The list of
      REQUIRED attributes appears in Table 3.  The meanings of\n   the columns of
      the table are:\n   o  Name: The name of the attribute.\n   o  ID: The number
      assigned to the attribute.  In the event of\n      conflicts between the assigned
      number and [RFC7531], the latter is\n      authoritative, but in such an event,
      it should be resolved with\n      errata to this document and/or [RFC7531].
      \ See [IESG_ERRATA] for\n      the errata process.\n   o  Data Type: The XDR
      data type of the attribute.\n   o  Acc: Access allowed to the attribute.  R
      means read-only (GETATTR\n      may retrieve, SETATTR may not set).  W means
      write-only (SETATTR\n      may set, GETATTR may not retrieve).  R W means read/write
      (GETATTR\n      may retrieve, SETATTR may set).\n   o  Defined in: The section
      of this specification that describes the\n      attribute.\n      +-----------------+----+------------+-----+-------------------+\n
      \     | Name            | ID | Data Type  | Acc | Defined in        |\n      +-----------------+----+------------+-----+-------------------+\n
      \     | supported_attrs | 0  | bitmap4    | R   | Section 5.8.1.1   |\n      |
      type            | 1  | nfs_ftype4 | R   | Section 5.8.1.2   |\n      | fh_expire_type
      \ | 2  | uint32_t   | R   | Section 5.8.1.3   |\n      | change          | 3
      \ | changeid4  | R   | Section 5.8.1.4   |\n      | size            | 4  | uint64_t
      \  | R W | Section 5.8.1.5   |\n      | link_support    | 5  | bool       |
      R   | Section 5.8.1.6   |\n      | symlink_support | 6  | bool       | R   |
      Section 5.8.1.7   |\n      | named_attr      | 7  | bool       | R   | Section
      5.8.1.8   |\n      | fsid            | 8  | fsid4      | R   | Section 5.8.1.9
      \  |\n      | unique_handles  | 9  | bool       | R   | Section 5.8.1.10  |\n
      \     | lease_time      | 10 | nfs_lease4 | R   | Section 5.8.1.11  |\n      |
      rdattr_error    | 11 | nfsstat4   | R   | Section 5.8.1.12  |\n      | filehandle
      \     | 19 | nfs_fh4    | R   | Section 5.8.1.13  |\n      +-----------------+----+------------+-----+-------------------+\n
      \                      Table 3: REQUIRED Attributes\n"
    title: 5.6.  REQUIRED Attributes - List and Definition References
  - contents:
    - "5.7.  RECOMMENDED Attributes - List and Definition References\n   The RECOMMENDED
      attributes are defined in Table 4.  The meanings of\n   the column headers are
      the same as Table 3; see Section 5.6 for the\n   meanings.\n   +-------------------+----+-----------------+-----+------------------+\n
      \  | Name              | ID | Data Type       | Acc | Defined in       |\n   +-------------------+----+-----------------+-----+------------------+\n
      \  | acl               | 12 | nfsace4<>       | R W | Section 6.2.1    |\n   |
      aclsupport        | 13 | uint32_t        | R   | Section 6.2.1.2  |\n   | archive
      \          | 14 | bool            | R W | Section 5.8.2.1  |\n   | cansettime
      \       | 15 | bool            | R   | Section 5.8.2.2  |\n   | case_insensitive
      \ | 16 | bool            | R   | Section 5.8.2.3  |\n   | case_preserving   |
      17 | bool            | R   | Section 5.8.2.4  |\n   | chown_restricted  | 18
      | bool            | R   | Section 5.8.2.5  |\n   | fileid            | 20 |
      uint64_t        | R   | Section 5.8.2.6  |\n   | files_avail       | 21 | uint64_t
      \       | R   | Section 5.8.2.7  |\n   | files_free        | 22 | uint64_t        |
      R   | Section 5.8.2.8  |\n   | files_total       | 23 | uint64_t        | R
      \  | Section 5.8.2.9  |\n   | fs_locations      | 24 | fs_locations4   | R   |
      Section 5.8.2.10 |\n   | hidden            | 25 | bool            | R W | Section
      5.8.2.11 |\n   | homogeneous       | 26 | bool            | R   | Section 5.8.2.12
      |\n   | maxfilesize       | 27 | uint64_t        | R   | Section 5.8.2.13 |\n
      \  | maxlink           | 28 | uint32_t        | R   | Section 5.8.2.14 |\n   |
      maxname           | 29 | uint32_t        | R   | Section 5.8.2.15 |\n   | maxread
      \          | 30 | uint64_t        | R   | Section 5.8.2.16 |\n   | maxwrite
      \         | 31 | uint64_t        | R   | Section 5.8.2.17 |\n   | mimetype          |
      32 | ascii_          | R W | Section 5.8.2.18 |\n   |                   |    |
      \  REQUIRED4<>   |     |                  |\n   | mode              | 33 | mode4
      \          | R W | Section 6.2.2    |\n   | mounted_on_fileid | 55 | uint64_t
      \       | R   | Section 5.8.2.19 |\n   | no_trunc          | 34 | bool            |
      R   | Section 5.8.2.20 |\n   | numlinks          | 35 | uint32_t        | R
      \  | Section 5.8.2.21 |\n   | owner             | 36 | utf8str_mixed   | R W
      | Section 5.8.2.22 |\n   | owner_group       | 37 | utf8str_mixed   | R W |
      Section 5.8.2.23 |\n   | quota_avail_hard  | 38 | uint64_t        | R   | Section
      5.8.2.24 |\n   | quota_avail_soft  | 39 | uint64_t        | R   | Section 5.8.2.25
      |\n   | quota_used        | 40 | uint64_t        | R   | Section 5.8.2.26 |\n
      \  | rawdev            | 41 | specdata4       | R   | Section 5.8.2.27 |\n   |
      space_avail       | 42 | uint64_t        | R   | Section 5.8.2.28 |\n   | space_free
      \       | 43 | uint64_t        | R   | Section 5.8.2.29 |\n   | space_total
      \      | 44 | uint64_t        | R   | Section 5.8.2.30 |\n   | space_used        |
      45 | uint64_t        | R   | Section 5.8.2.31 |\n   | system            | 46
      | bool            | R W | Section 5.8.2.32 |\n   | time_access       | 47 |
      nfstime4        | R   | Section 5.8.2.33 |\n   | time_access_set   | 48 | settime4
      \       | W   | Section 5.8.2.34 |\n   | time_backup       | 49 | nfstime4        |
      R W | Section 5.8.2.35 |\n   | time_create       | 50 | nfstime4        | R
      W | Section 5.8.2.36 |\n   | time_delta        | 51 | nfstime4        | R   |
      Section 5.8.2.37 |\n   | time_metadata     | 52 | nfstime4        | R   | Section
      5.8.2.38 |\n   | time_modify       | 53 | nfstime4        | R   | Section 5.8.2.39
      |\n   | time_modify_set   | 54 | settime4        | W   | Section 5.8.2.40 |\n
      \  +-------------------+----+-----------------+-----+------------------+\n                      Table
      4: RECOMMENDED Attributes\n"
    title: 5.7.  RECOMMENDED Attributes - List and Definition References
  - contents:
    - '5.8.  Attribute Definitions

      '
    - contents:
      - '5.8.1.  Definitions of REQUIRED Attributes

        '
      - contents:
        - "5.8.1.1.  Attribute 0: supported_attrs\n   The bit vector that would retrieve
          all REQUIRED and RECOMMENDED\n   attributes that are supported for this
          object.  The scope of this\n   attribute applies to all objects with a matching
          fsid.\n"
        title: '5.8.1.1.  Attribute 0: supported_attrs'
      - contents:
        - "5.8.1.2.  Attribute 1: type\n   Designates the type of an object in terms
          of one of a number of\n   special constants:\n   o  NF4REG designates a
          regular file.\n   o  NF4DIR designates a directory.\n   o  NF4BLK designates
          a block device special file.\n   o  NF4CHR designates a character device
          special file.\n   o  NF4LNK designates a symbolic link.\n   o  NF4SOCK designates
          a named socket special file.\n   o  NF4FIFO designates a fifo special file.\n
          \  o  NF4ATTRDIR designates a named attribute directory.\n   o  NF4NAMEDATTR
          designates a named attribute.\n   Within the explanatory text and operation
          descriptions, the following\n   phrases will be used with the meanings given
          below:\n   o  The phrase \"is a directory\" means that the object's type
          attribute\n      is NF4DIR or NF4ATTRDIR.\n   o  The phrase \"is a special
          file\" means that the object's type\n      attribute is NF4BLK, NF4CHR,
          NF4SOCK, or NF4FIFO.\n   o  The phrase \"is a regular file\" means that
          the object's type\n      attribute is NF4REG or NF4NAMEDATTR.\n   o  The
          phrase \"is a symbolic link\" means that the object's type\n      attribute
          is NF4LNK.\n"
        title: '5.8.1.2.  Attribute 1: type'
      - contents:
        - "5.8.1.3.  Attribute 2: fh_expire_type\n   The server uses this to specify
          filehandle expiration behavior to the\n   client.  See Section 4 for additional
          description.\n"
        title: '5.8.1.3.  Attribute 2: fh_expire_type'
      - contents:
        - "5.8.1.4.  Attribute 3: change\n   A value created by the server that the
          client can use to determine if\n   file data, directory contents, or attributes
          of the object have been\n   modified.  The server MAY return the object's
          time_metadata attribute\n   for this attribute's value but only if the file
          system object cannot\n   be updated more frequently than the resolution
          of time_metadata.\n"
        title: '5.8.1.4.  Attribute 3: change'
      - contents:
        - "5.8.1.5.  Attribute 4: size\n   The size of the object in bytes.\n"
        title: '5.8.1.5.  Attribute 4: size'
      - contents:
        - "5.8.1.6.  Attribute 5: link_support\n   TRUE, if the object's file system
          supports hard links.\n"
        title: '5.8.1.6.  Attribute 5: link_support'
      - contents:
        - "5.8.1.7.  Attribute 6: symlink_support\n   TRUE, if the object's file system
          supports symbolic links.\n"
        title: '5.8.1.7.  Attribute 6: symlink_support'
      - contents:
        - "5.8.1.8.  Attribute 7: named_attr\n   TRUE, if this object has named attributes.
          \ In other words, this\n   object has a non-empty named attribute directory.\n"
        title: '5.8.1.8.  Attribute 7: named_attr'
      - contents:
        - "5.8.1.9.  Attribute 8: fsid\n   Unique file system identifier for the file
          system holding this\n   object.  The fsid attribute has major and minor
          components, each of\n   which are of data type uint64_t.\n"
        title: '5.8.1.9.  Attribute 8: fsid'
      - contents:
        - "5.8.1.10.  Attribute 9: unique_handles\n   TRUE, if two distinct filehandles
          are guaranteed to refer to two\n   different file system objects.\n"
        title: '5.8.1.10.  Attribute 9: unique_handles'
      - contents:
        - "5.8.1.11.  Attribute 10: lease_time\n   Duration of the lease at the server
          in seconds.\n"
        title: '5.8.1.11.  Attribute 10: lease_time'
      - contents:
        - "5.8.1.12.  Attribute 11: rdattr_error\n   Error returned from an attempt
          to retrieve attributes during a\n   READDIR operation.\n"
        title: '5.8.1.12.  Attribute 11: rdattr_error'
      - contents:
        - "5.8.1.13.  Attribute 19: filehandle\n   The filehandle of this object (primarily
          for READDIR requests).\n"
        title: '5.8.1.13.  Attribute 19: filehandle'
      title: 5.8.1.  Definitions of REQUIRED Attributes
    - contents:
      - "5.8.2.  Definitions of Uncategorized RECOMMENDED Attributes\n   The definitions
        of most of the RECOMMENDED attributes follow.\n   Collections that share a
        common category are defined in other\n   sections.\n"
      - contents:
        - "5.8.2.1.  Attribute 14: archive\n   TRUE, if this file has been archived
          since the time of the last\n   modification (deprecated in favor of time_backup).\n"
        title: '5.8.2.1.  Attribute 14: archive'
      - contents:
        - "5.8.2.2.  Attribute 15: cansettime\n   TRUE, if the server is able to change
          the times for a file system\n   object as specified in a SETATTR operation.\n"
        title: '5.8.2.2.  Attribute 15: cansettime'
      - contents:
        - "5.8.2.3.  Attribute 16: case_insensitive\n   TRUE, if filename comparisons
          on this file system are case\n   insensitive.  This refers only to comparisons,
          and not to the case in\n   which filenames are stored.\n"
        title: '5.8.2.3.  Attribute 16: case_insensitive'
      - contents:
        - "5.8.2.4.  Attribute 17: case_preserving\n   TRUE, if the filename case
          on this file system is preserved.  This\n   refers only to how filenames
          are stored, and not to how they are\n   compared.  Filenames stored in mixed
          case might be compared using\n   either case-insensitive or case-sensitive
          comparisons.\n"
        title: '5.8.2.4.  Attribute 17: case_preserving'
      - contents:
        - "5.8.2.5.  Attribute 18: chown_restricted\n   If TRUE, the server will reject
          any request to change either the\n   owner or the group associated with
          a file if the caller is not a\n   privileged user (for example, \"root\"
          in UNIX operating environments\n   or the \"Take Ownership\" privilege in
          Windows 2000).\n"
        title: '5.8.2.5.  Attribute 18: chown_restricted'
      - contents:
        - "5.8.2.6.  Attribute 20: fileid\n   A number uniquely identifying the file
          within the file system.\n"
        title: '5.8.2.6.  Attribute 20: fileid'
      - contents:
        - "5.8.2.7.  Attribute 21: files_avail\n   File slots available to this user
          on the file system containing this\n   object -- this should be the smallest
          relevant limit.\n"
        title: '5.8.2.7.  Attribute 21: files_avail'
      - contents:
        - "5.8.2.8.  Attribute 22: files_free\n   Free file slots on the file system
          containing this object -- this\n   should be the smallest relevant limit.\n"
        title: '5.8.2.8.  Attribute 22: files_free'
      - contents:
        - "5.8.2.9.  Attribute 23: files_total\n   Total file slots on the file system
          containing this object.\n"
        title: '5.8.2.9.  Attribute 23: files_total'
      - contents:
        - "5.8.2.10.  Attribute 24: fs_locations\n   Locations where this file system
          may be found.  If the server returns\n   NFS4ERR_MOVED as an error, this
          attribute MUST be supported.\n   The server specifies the rootpath for a
          given server by returning a\n   path consisting of zero path components.\n"
        title: '5.8.2.10.  Attribute 24: fs_locations'
      - contents:
        - "5.8.2.11.  Attribute 25: hidden\n   TRUE, if the file is considered hidden
          with respect to the\n   Windows API.\n"
        title: '5.8.2.11.  Attribute 25: hidden'
      - contents:
        - "5.8.2.12.  Attribute 26: homogeneous\n   TRUE, if this object's file system
          is homogeneous, i.e., all objects\n   in the file system (all objects on
          the server with the same fsid)\n   have common values for all per-file system
          attributes.\n"
        title: '5.8.2.12.  Attribute 26: homogeneous'
      - contents:
        - "5.8.2.13.  Attribute 27: maxfilesize\n   Maximum supported file size for
          the file system of this object.\n"
        title: '5.8.2.13.  Attribute 27: maxfilesize'
      - contents:
        - "5.8.2.14.  Attribute 28: maxlink\n   Maximum number of hard links for this
          object.\n"
        title: '5.8.2.14.  Attribute 28: maxlink'
      - contents:
        - "5.8.2.15.  Attribute 29: maxname\n   Maximum filename size supported for
          this object.\n"
        title: '5.8.2.15.  Attribute 29: maxname'
      - contents:
        - "5.8.2.16.  Attribute 30: maxread\n   Maximum amount of data the READ operation
          will return for this\n   object.\n"
        title: '5.8.2.16.  Attribute 30: maxread'
      - contents:
        - "5.8.2.17.  Attribute 31: maxwrite\n   Maximum amount of data the WRITE
          operation will accept for this\n   object.  This attribute SHOULD be supported
          if the file is writable.\n   Lack of this attribute can lead to the client
          either wasting\n   bandwidth or not receiving the best performance.\n"
        title: '5.8.2.17.  Attribute 31: maxwrite'
      - contents:
        - "5.8.2.18.  Attribute 32: mimetype\n   MIME media type/subtype of this object.\n"
        title: '5.8.2.18.  Attribute 32: mimetype'
      - contents:
        - "5.8.2.19.  Attribute 55: mounted_on_fileid\n   Like fileid, but if the
          target filehandle is the root of a file\n   system, this attribute represents
          the fileid of the underlying\n   directory.\n   UNIX-based operating environments
          connect a file system into the\n   namespace by connecting (mounting) the
          file system onto the existing\n   file object (the mount point, usually
          a directory) of an existing\n   file system.  When the mount point's parent
          directory is read via an\n   API such as readdir() [readdir_api], the return
          results are directory\n   entries, each with a component name and a fileid.
          \ The fileid of the\n   mount point's directory entry will be different
          from the fileid that\n   the stat() [stat] system call returns.  The stat()
          system call is\n   returning the fileid of the root of the mounted file
          system, whereas\n   readdir() is returning the fileid that stat() would
          have returned\n   before any file systems were mounted on the mount point.\n
          \  Unlike NFSv3, NFSv4.0 allows a client's LOOKUP request to cross other\n
          \  file systems.  The client detects the file system crossing whenever\n
          \  the filehandle argument of LOOKUP has an fsid attribute different\n   from
          that of the filehandle returned by LOOKUP.  A UNIX-based client\n   will
          consider this a \"mount point crossing\".  UNIX has a legacy\n   scheme
          for allowing a process to determine its current working\n   directory.  This
          relies on readdir() of a mount point's parent and\n   stat() of the mount
          point returning fileids as previously described.\n   The mounted_on_fileid
          attribute corresponds to the fileid that\n   readdir() would have returned,
          as described previously.\n   While the NFSv4.0 client could simply fabricate
          a fileid\n   corresponding to what mounted_on_fileid provides (and if the
          server\n   does not support mounted_on_fileid, the client has no choice),
          there\n   is a risk that the client will generate a fileid that conflicts
          with\n   one that is already assigned to another object in the file system.\n
          \  Instead, if the server can provide the mounted_on_fileid, the\n   potential
          for client operational problems in this area is eliminated.\n   If the server
          detects that there is nothing mounted on top of the\n   target file object,
          then the value for mounted_on_fileid that it\n   returns is the same as
          that of the fileid attribute.\n   The mounted_on_fileid attribute is RECOMMENDED,
          so the server SHOULD\n   provide it if possible, and for a UNIX-based server,
          this is\n   straightforward.  Usually, mounted_on_fileid will be requested
          during\n   a READDIR operation, in which case it is trivial (at least for\n
          \  UNIX-based servers) to return mounted_on_fileid since it is equal to\n
          \  the fileid of a directory entry returned by readdir().  If\n   mounted_on_fileid
          is requested in a GETATTR operation, the server\n   should obey an invariant
          that has it returning a value that is equal\n   to the file object's entry
          in the object's parent directory, i.e.,\n   what readdir() would have returned.
          \ Some operating environments\n   allow a series of two or more file systems
          to be mounted onto a\n   single mount point.  In this case, for the server
          to obey the\n   aforementioned invariant, it will need to find the base
          mount point,\n   and not the intermediate mount points.\n"
        title: '5.8.2.19.  Attribute 55: mounted_on_fileid'
      - contents:
        - "5.8.2.20.  Attribute 34: no_trunc\n   If this attribute is TRUE, then if
          the client uses a filename longer\n   than name_max, an error will be returned
          instead of the name being\n   truncated.\n"
        title: '5.8.2.20.  Attribute 34: no_trunc'
      - contents:
        - "5.8.2.21.  Attribute 35: numlinks\n   Number of hard links to this object.\n"
        title: '5.8.2.21.  Attribute 35: numlinks'
      - contents:
        - "5.8.2.22.  Attribute 36: owner\n   The string name of the owner of this
          object.\n"
        title: '5.8.2.22.  Attribute 36: owner'
      - contents:
        - "5.8.2.23.  Attribute 37: owner_group\n   The string name of the group ownership
          of this object.\n"
        title: '5.8.2.23.  Attribute 37: owner_group'
      - contents:
        - "5.8.2.24.  Attribute 38: quota_avail_hard\n   The value in bytes that represents
          the amount of additional disk\n   space beyond the current allocation that
          can be allocated to this\n   file or directory before further allocations
          will be refused.  It is\n   understood that this space may be consumed by
          allocations to other\n   files or directories.\n"
        title: '5.8.2.24.  Attribute 38: quota_avail_hard'
      - contents:
        - "5.8.2.25.  Attribute 39: quota_avail_soft\n   The value in bytes that represents
          the amount of additional disk\n   space that can be allocated to this file
          or directory before the user\n   may reasonably be warned.  It is understood
          that this space may be\n   consumed by allocations to other files or directories,
          though there\n   may exist server-side rules as to which other files or
          directories.\n"
        title: '5.8.2.25.  Attribute 39: quota_avail_soft'
      - contents:
        - "5.8.2.26.  Attribute 40: quota_used\n   The value in bytes that represents
          the amount of disk space used by\n   this file or directory and possibly
          a number of other similar files\n   or directories, where the set of \"similar\"
          meets at least the\n   criterion that allocating space to any file or directory
          in the set\n   will reduce the \"quota_avail_hard\" of every other file
          or directory\n   in the set.\n   Note that there may be a number of distinct
          but overlapping sets of\n   files or directories for which a quota_used
          value is maintained,\n   e.g., \"all files with a given owner\", \"all files
          with a given group\n   owner\", etc.  The server is at liberty to choose
          any of those sets\n   when providing the content of the quota_used attribute
          but should do\n   so in a repeatable way.  The rule may be configured per
          file system\n   or may be \"choose the set with the smallest quota\".\n"
        title: '5.8.2.26.  Attribute 40: quota_used'
      - contents:
        - "5.8.2.27.  Attribute 41: rawdev\n   Raw device number of file of type NF4BLK
          or NF4CHR.  The device\n   number is split into major and minor numbers.
          \ If the file's type\n   attribute is not NF4BLK or NF4CHR, this attribute
          SHOULD NOT be\n   returned, and any value returned SHOULD NOT be considered
          useful.\n"
        title: '5.8.2.27.  Attribute 41: rawdev'
      - contents:
        - "5.8.2.28.  Attribute 42: space_avail\n   Disk space in bytes available
          to this user on the file system\n   containing this object -- this should
          be the smallest relevant limit.\n"
        title: '5.8.2.28.  Attribute 42: space_avail'
      - contents:
        - "5.8.2.29.  Attribute 43: space_free\n   Free disk space in bytes on the
          file system containing this object --\n   this should be the smallest relevant
          limit.\n"
        title: '5.8.2.29.  Attribute 43: space_free'
      - contents:
        - "5.8.2.30.  Attribute 44: space_total\n   Total disk space in bytes on the
          file system containing this object.\n"
        title: '5.8.2.30.  Attribute 44: space_total'
      - contents:
        - "5.8.2.31.  Attribute 45: space_used\n   Number of file system bytes allocated
          to this object.\n"
        title: '5.8.2.31.  Attribute 45: space_used'
      - contents:
        - "5.8.2.32.  Attribute 46: system\n   TRUE, if this file is a \"system\"
          file with respect to the Windows\n   operating environment.\n"
        title: '5.8.2.32.  Attribute 46: system'
      - contents:
        - "5.8.2.33.  Attribute 47: time_access\n   Represents the time of last access
          to the object by a READ operation\n   sent to the server.  The notion of
          what is an \"access\" depends on the\n   server's operating environment
          and/or the server's file system\n   semantics.  For example, for servers
          obeying Portable Operating\n   System Interface (POSIX) semantics, time_access
          would be updated only\n   by the READ and READDIR operations and not any
          of the operations that\n   modify the content of the object [read_api],
          [readdir_api],\n   [write_api].  Of course, setting the corresponding time_access_set\n
          \  attribute is another way to modify the time_access attribute.\n   Whenever
          the file object resides on a writable file system, the\n   server should
          make its best efforts to record time_access into stable\n   storage.  However,
          to mitigate the performance effects of doing so,\n   and most especially
          whenever the server is satisfying the read of the\n   object's content from
          its cache, the server MAY cache access time\n   updates and lazily write
          them to stable storage.  It is also\n   acceptable to give administrators
          of the server the option to disable\n   time_access updates.\n"
        title: '5.8.2.33.  Attribute 47: time_access'
      - contents:
        - "5.8.2.34.  Attribute 48: time_access_set\n   Sets the time of last access
          to the object.  SETATTR use only.\n"
        title: '5.8.2.34.  Attribute 48: time_access_set'
      - contents:
        - "5.8.2.35.  Attribute 49: time_backup\n   The time of last backup of the
          object.\n"
        title: '5.8.2.35.  Attribute 49: time_backup'
      - contents:
        - "5.8.2.36.  Attribute 50: time_create\n   The time of creation of the object.
          \ This attribute does not have\n   any relation to the traditional UNIX
          file attribute \"ctime\"\n   (\"change time\").\n"
        title: '5.8.2.36.  Attribute 50: time_create'
      - contents:
        - "5.8.2.37.  Attribute 51: time_delta\n   Smallest useful server time granularity.\n"
        title: '5.8.2.37.  Attribute 51: time_delta'
      - contents:
        - "5.8.2.38.  Attribute 52: time_metadata\n   The time of last metadata modification
          of the object.\n"
        title: '5.8.2.38.  Attribute 52: time_metadata'
      - contents:
        - "5.8.2.39.  Attribute 53: time_modify\n   The time of last modification
          to the object.\n"
        title: '5.8.2.39.  Attribute 53: time_modify'
      - contents:
        - "5.8.2.40.  Attribute 54: time_modify_set\n   Sets the time of last modification
          to the object.  SETATTR use only.\n"
        title: '5.8.2.40.  Attribute 54: time_modify_set'
      title: 5.8.2.  Definitions of Uncategorized RECOMMENDED Attributes
    title: 5.8.  Attribute Definitions
  - contents:
    - "5.9.  Interpreting owner and owner_group\n   The RECOMMENDED attributes \"owner\"
      and \"owner_group\" (and also users\n   and groups used as values of the who
      field within nfs4ace structures\n   used in the acl attribute) are represented
      in the form of UTF-8\n   strings.  This format avoids the use of a representation
      that is tied\n   to a particular underlying implementation at the client or
      server.\n   Note that Section 6.1 of [RFC2624] provides additional rationale.
      \ It\n   is expected that the client and server will have their own local\n
      \  representation of owners and groups that is used for local storage or\n   presentation
      to the application via APIs that expect such a\n   representation.  Therefore,
      the protocol requires that when these\n   attributes are transferred between
      the client and server, the local\n   representation is translated to a string
      of the form\n   \"identifier@dns_domain\".  This allows clients and servers
      that do not\n   use the same local representation to effectively interoperate
      since\n   they both use a common syntax that can be interpreted by both.\n   Similarly,
      security principals may be represented in different ways\n   by different security
      mechanisms.  Servers normally translate these\n   representations into a common
      format, generally that used by local\n   storage, to serve as a means of identifying
      the users corresponding\n   to these security principals.  When these local
      identifiers are\n   translated to the form of the owner attribute, associated
      with files\n   created by such principals, they identify, in a common format,
      the\n   users associated with each corresponding set of security principals.\n
      \  The translation used to interpret owner and group strings is not\n   specified
      as part of the protocol.  This allows various solutions to\n   be employed.
      \ For example, a local translation table may be consulted\n   that maps a numeric
      identifier to the user@dns_domain syntax.  A name\n   service may also be used
      to accomplish the translation.  A server may\n   provide a more general service,
      not limited by any particular\n   translation (which would only translate a
      limited set of possible\n   strings) by storing the owner and owner_group attributes
      in local\n   storage without any translation, or it may augment a translation\n
      \  method by storing the entire string for attributes for which no\n   translation
      is available while using the local representation for\n   those cases in which
      a translation is available.\n   Servers that do not provide support for all
      possible values of user\n   and group strings SHOULD return an error (NFS4ERR_BADOWNER)
      when a\n   string is presented that has no translation, as the value to be set\n
      \  for a SETATTR of the owner or owner_group attributes or as part of\n   the
      value of the acl attribute.  When a server does accept a user or\n   group string
      as valid on a SETATTR, it is promising to return that\n   same string (see below)
      when a corresponding GETATTR is done, as long\n   as there has been no further
      change in the corresponding attribute\n   before the GETATTR.  For some internationalization-related
      exceptions\n   where this is not possible, see below.  Configuration changes\n
      \  (including changes from the mapping of the string to the local\n   representation)
      and ill-constructed name translations (those that\n   contain aliasing) may
      make that promise impossible to honor.  Servers\n   should make appropriate
      efforts to avoid a situation in which these\n   attributes have their values
      changed when no real change to either\n   ownership or acls has occurred.\n
      \  The \"dns_domain\" portion of the owner string is meant to be a DNS\n   domain
      name -- for example, \"user@example.org\".  Servers should\n   accept as valid
      a set of users for at least one domain.  A server may\n   treat other domains
      as having no valid translations.  A more general\n   service is provided when
      a server is capable of accepting users for\n   multiple domains, or for all
      domains, subject to security\n   constraints.\n   As an implementation guide,
      both clients and servers may provide a\n   means to configure the \"dns_domain\"
      portion of the owner string.  For\n   example, the DNS domain name of the host
      running the NFS server might\n   be \"lab.example.org\", but the user names
      are defined in\n   \"example.org\".  In the absence of such a configuration,
      or as a\n   default, the current DNS domain name of the server should be the\n
      \  value used for the \"dns_domain\".\n   As mentioned above, it is desirable
      that a server, when accepting a\n   string of the form \"user@domain\" or \"group@domain\"
      in an attribute,\n   return this same string when that corresponding attribute
      is fetched.\n   Internationalization issues make this impossible under certain\n
      \  circumstances, and the client needs to take note of these.  See\n   Section
      12 for a detailed discussion of these issues.\n   In the case where there is
      no translation available to the client or\n   server, the attribute value will
      be constructed without the \"@\".\n   Therefore, the absence of the \"@\" from
      the owner or owner_group\n   attribute signifies that no translation was available
      at the sender\n   and that the receiver of the attribute should not use that
      string as\n   a basis for translation into its own internal format.  Even though\n
      \  the attribute value cannot be translated, it may still be useful.  In\n   the
      case of a client, the attribute string may be used for local\n   display of
      ownership.\n   To provide a greater degree of compatibility with NFSv3, which\n
      \  identified users and groups by 32-bit unsigned user identifiers and\n   group
      identifiers, owner and group strings that consist of ASCII-\n   encoded decimal
      numeric values with no leading zeros can be given a\n   special interpretation
      by clients and servers that choose to provide\n   such support.  The receiver
      may treat such a user or group string as\n   representing the same user as would
      be represented by an NFSv3 uid or\n   gid having the corresponding numeric value.\n
      \  A server SHOULD reject such a numeric value if the security mechanism\n   is
      using Kerberos.  That is, in such a scenario, the client will\n   already need
      to form \"user@domain\" strings.  For any other security\n   mechanism, the
      server SHOULD accept such numeric values.  As an\n   implementation note, the
      server could make such an acceptance be\n   configurable.  If the server does
      not support numeric values or if it\n   is configured off, then it MUST return
      an NFS4ERR_BADOWNER error.  If\n   the security mechanism is using Kerberos
      and the client attempts to\n   use the special form, then the server SHOULD
      return an\n   NFS4ERR_BADOWNER error when there is a valid translation for the
      user\n   or owner designated in this way.  In that case, the client must use\n
      \  the appropriate user@domain string and not the special form for\n   compatibility.\n
      \  The client MUST always accept numeric values if the security\n   mechanism
      is not RPCSEC_GSS.  A client can determine if a server\n   supports numeric
      identifiers by first attempting to provide a numeric\n   identifier.  If this
      attempt is rejected with an NFS4ERR_BADOWNER\n   error, then the client should
      only use named identifiers of the form\n   \"user@dns_domain\".\n   The owner
      string \"nobody\" may be used to designate an anonymous user,\n   which will
      be associated with a file created by a security principal\n   that cannot be
      mapped through normal means to the owner attribute.\n"
    title: 5.9.  Interpreting owner and owner_group
  - contents:
    - "5.10.  Character Case Attributes\n   With respect to the case_insensitive and
      case_preserving attributes,\n   case-insensitive comparisons of Unicode characters
      SHOULD use Unicode\n   Default Case Folding as defined in Chapter 3 of the Unicode
      Standard\n   [UNICODE] and MAY override that behavior for specific selected\n
      \  characters with the case folding defined in the SpecialCasing.txt\n   [SPECIALCASING]
      file; see Section 3.13 of the Unicode Standard.\n   The SpecialCasing.txt file
      replaces the Default Case Folding with\n   locale- and context-dependent case
      folding for specific situations.\n   An example of locale- and context-dependent
      case folding is that\n   LATIN CAPITAL LETTER I (\"I\", U+0049) is default case
      folded to LATIN\n   SMALL LETTER I (\"i\", U+0069).  However, several languages
      (e.g.,\n   Turkish) treat an \"I\" character with a dot as a different letter
      than\n   an \"I\" character without a dot; therefore, in such languages, unless\n
      \  an I is before a dot_above, the \"I\" (U+0049) character should be case\n
      \  folded to a different character, LATIN SMALL LETTER DOTLESS I\n   (U+0131).\n
      \  The [UNICODE] and [SPECIALCASING] references in this RFC are for\n   version
      7.0.0 of the Unicode standard, as that was the latest version\n   of Unicode
      when this RFC was published.  Implementations SHOULD\n   always use the latest
      version of Unicode\n   (<http://www.unicode.org/versions/latest/>).\n"
    title: 5.10.  Character Case Attributes
  title: 5.  Attributes
- contents:
  - "6.  Access Control Attributes\n   Access Control Lists (ACLs) are file attributes
    that specify fine-\n   grained access control.  This section covers the \"acl\",
    \"aclsupport\",\n   and \"mode\" file attributes, and their interactions.  Note
    that file\n   attributes may apply to any file system object.\n"
  - contents:
    - "6.1.  Goals\n   ACLs and modes represent two well-established models for specifying\n
      \  permissions.  This section specifies requirements that attempt to\n   meet
      the following goals:\n   o  If a server supports the mode attribute, it should
      provide\n      reasonable semantics to clients that only set and retrieve the\n
      \     mode attribute.\n   o  If a server supports ACL attributes, it should
      provide reasonable\n      semantics to clients that only set and retrieve those
      attributes.\n   o  On servers that support the mode attribute, if ACL attributes
      have\n      never been set on an object, via inheritance or explicitly, the\n
      \     behavior should be traditional UNIX-like behavior.\n   o  On servers that
      support the mode attribute, if the ACL attributes\n      have been previously
      set on an object, either explicitly or via\n      inheritance:\n      *  Setting
      only the mode attribute should effectively control the\n         traditional
      UNIX-like permissions of read, write, and execute\n         on owner, owner_group,
      and other.\n      *  Setting only the mode attribute should provide reasonable\n
      \        security.  For example, setting a mode of 000 should be enough\n         to
      ensure that future opens for read or write by any principal\n         fail,
      regardless of a previously existing or inherited ACL.\n   o  When a mode attribute
      is set on an object, the ACL attributes may\n      need to be modified so as
      to not conflict with the new mode.  In\n      such cases, it is desirable that
      the ACL keep as much information\n      as possible.  This includes information
      about inheritance, AUDIT\n      and ALARM access control entries (ACEs), and
      permissions granted\n      and denied that do not conflict with the new mode.\n"
    title: 6.1.  Goals
  - contents:
    - "6.2.  File Attributes Discussion\n   Support for each of the ACL attributes
      is RECOMMENDED and not\n   required, since file systems accessed using NFSv4
      might not\n   support ACLs.\n"
    - contents:
      - "6.2.1.  Attribute 12: acl\n   The NFSv4.0 ACL attribute contains an array
        of ACEs that are\n   associated with the file system object.  Although the
        client can read\n   and write the acl attribute, the server is responsible
        for using the\n   ACL to perform access control.  The client can use the OPEN
        or ACCESS\n   operations to check access without modifying or reading data
        or\n   metadata.\n   The NFS ACE structure is defined as follows:\n   typedef
        uint32_t        acetype4;\n   typedef uint32_t        aceflag4;\n   typedef
        uint32_t        acemask4;\n   struct nfsace4 {\n           acetype4                type;\n
        \          aceflag4                flag;\n           acemask4                access_mask;\n
        \          utf8str_mixed           who;\n   };\n   To determine if a request
        succeeds, the server processes each nfsace4\n   entry in order.  Only ACEs
        that have a \"who\" that matches the\n   requester are considered.  Each ACE
        is processed until all of the\n   bits of the requester's access have been
        ALLOWED.  Once a bit (see\n   below) has been ALLOWED by an ACCESS_ALLOWED_ACE,
        it is no longer\n   considered in the processing of later ACEs.  If an ACCESS_DENIED_ACE\n
        \  is encountered where the requester's access still has unALLOWED bits\n
        \  in common with the \"access_mask\" of the ACE, the request is denied.\n
        \  When the ACL is fully processed, if there are bits in the requester's\n
        \  mask that have not been ALLOWED or DENIED, access is denied.\n   Unlike
        the ALLOW and DENY ACE types, the ALARM and AUDIT ACE types do\n   not affect
        a requester's access and instead are for triggering events\n   as a result
        of a requester's access attempt.  Therefore, AUDIT and\n   ALARM ACEs are
        processed only after processing ALLOW and DENY ACEs.\n   The NFSv4.0 ACL model
        is quite rich.  Some server platforms may\n   provide access control functionality
        that goes beyond the UNIX-style\n   mode attribute but that is not as rich
        as the NFS ACL model.  So that\n   users can take advantage of this more limited
        functionality, the\n   server may support the acl attributes by mapping between
        its ACL\n   model and the NFSv4.0 ACL model.  Servers must ensure that the
        ACL\n   they actually store or enforce is at least as strict as the NFSv4
        ACL\n   that was set.  It is tempting to accomplish this by rejecting any
        ACL\n   that falls outside the small set that can be represented accurately.\n
        \  However, such an approach can render ACLs unusable without special\n   client-side
        knowledge of the server's mapping, which defeats the\n   purpose of having
        a common NFSv4 ACL protocol.  Therefore, servers\n   should accept every ACL
        that they can without compromising security.\n   To help accomplish this,
        servers may make a special exception, in the\n   case of unsupported permission
        bits, to the rule that bits not\n   ALLOWED or DENIED by an ACL must be denied.
        \ For example, a UNIX-\n   style server might choose to silently allow read
        attribute\n   permissions even though an ACL does not explicitly allow those\n
        \  permissions.  (An ACL that explicitly denies permission to read\n   attributes
        should still result in a denial.)\n   The situation is complicated by the
        fact that a server may have\n   multiple modules that enforce ACLs.  For example,
        the enforcement for\n   NFSv4.0 access may be different from, but not weaker
        than, the\n   enforcement for local access, and both may be different from
        the\n   enforcement for access through other protocols such as Server Message\n
        \  Block (SMB) [MS-SMB].  So it may be useful for a server to accept an\n
        \  ACL even if not all of its modules are able to support it.\n   The guiding
        principle with regard to NFSv4 access is that the server\n   must not accept
        ACLs that give an appearance of more restricted\n   access to a file than
        what is actually enforced.\n"
      - contents:
        - "6.2.1.1.  ACE Type\n   The constants used for the type field (acetype4)
          are as follows:\n   const ACE4_ACCESS_ALLOWED_ACE_TYPE      = 0x00000000;\n
          \  const ACE4_ACCESS_DENIED_ACE_TYPE       = 0x00000001;\n   const ACE4_SYSTEM_AUDIT_ACE_TYPE
          \       = 0x00000002;\n   const ACE4_SYSTEM_ALARM_ACE_TYPE        = 0x00000003;\n
          \  All four bit types are permitted in the acl attribute.\n   +------------------------------+--------------+---------------------+\n
          \  | Value                        | Abbreviation | Description         |\n
          \  +------------------------------+--------------+---------------------+\n
          \  | ACE4_ACCESS_ALLOWED_ACE_TYPE | ALLOW        | Explicitly grants   |\n
          \  |                              |              | the access defined  |\n
          \  |                              |              | in acemask4 to the  |\n
          \  |                              |              | file or directory.  |\n
          \  |                              |              |                     |\n
          \  | ACE4_ACCESS_DENIED_ACE_TYPE  | DENY         | Explicitly denies   |\n
          \  |                              |              | the access defined  |\n
          \  |                              |              | in acemask4 to the  |\n
          \  |                              |              | file or directory.  |\n
          \  |                              |              |                     |\n
          \  | ACE4_SYSTEM_AUDIT_ACE_TYPE   | AUDIT        | LOG (in a system-   |\n
          \  |                              |              | dependent way) any  |\n
          \  |                              |              | access attempt to a |\n
          \  |                              |              | file or directory   |\n
          \  |                              |              | that uses any of    |\n
          \  |                              |              | the access methods  |\n
          \  |                              |              | specified in        |\n
          \  |                              |              | acemask4.           |\n
          \  |                              |              |                     |\n
          \  | ACE4_SYSTEM_ALARM_ACE_TYPE   | ALARM        | Generate a system   |\n
          \  |                              |              | ALARM (system       |\n
          \  |                              |              | dependent) when any |\n
          \  |                              |              | access attempt is   |\n
          \  |                              |              | made to a file or   |\n
          \  |                              |              | directory for the   |\n
          \  |                              |              | access methods      |\n
          \  |                              |              | specified in        |\n
          \  |                              |              | acemask4.           |\n
          \  +------------------------------+--------------+---------------------+\n
          \   The \"Abbreviation\" column denotes how the types will be referred to\n
          \                  throughout the rest of this section.\n"
        title: 6.2.1.1.  ACE Type
      - contents:
        - "6.2.1.2.  Attribute 13: aclsupport\n   A server need not support all of
          the above ACE types.  This attribute\n   indicates which ACE types are supported
          for the current file system.\n   The bitmask constants used to represent
          the above definitions within\n   the aclsupport attribute are as follows:\n
          \  const ACL4_SUPPORT_ALLOW_ACL    = 0x00000001;\n   const ACL4_SUPPORT_DENY_ACL
          \    = 0x00000002;\n   const ACL4_SUPPORT_AUDIT_ACL    = 0x00000004;\n   const
          ACL4_SUPPORT_ALARM_ACL    = 0x00000008;\n   Servers that support either
          the ALLOW or DENY ACE type SHOULD support\n   both ALLOW and DENY ACE types.\n
          \  Clients should not attempt to set an ACE unless the server claims\n   support
          for that ACE type.  If the server receives a request to set\n   an ACE that
          it cannot store, it MUST reject the request with\n   NFS4ERR_ATTRNOTSUPP.
          \ If the server receives a request to set an ACE\n   that it can store but
          cannot enforce, the server SHOULD reject the\n   request with NFS4ERR_ATTRNOTSUPP.\n"
        title: '6.2.1.2.  Attribute 13: aclsupport'
      - contents:
        - "6.2.1.3.  ACE Access Mask\n   The bitmask constants used for the access
          mask field are as follows:\n   const ACE4_READ_DATA            = 0x00000001;\n
          \  const ACE4_LIST_DIRECTORY       = 0x00000001;\n   const ACE4_WRITE_DATA
          \          = 0x00000002;\n   const ACE4_ADD_FILE             = 0x00000002;\n
          \  const ACE4_APPEND_DATA          = 0x00000004;\n   const ACE4_ADD_SUBDIRECTORY
          \    = 0x00000004;\n   const ACE4_READ_NAMED_ATTRS     = 0x00000008;\n   const
          ACE4_WRITE_NAMED_ATTRS    = 0x00000010;\n   const ACE4_EXECUTE              =
          0x00000020;\n   const ACE4_DELETE_CHILD         = 0x00000040;\n   const
          ACE4_READ_ATTRIBUTES      = 0x00000080;\n   const ACE4_WRITE_ATTRIBUTES
          \    = 0x00000100;\n   const ACE4_DELETE               = 0x00010000;\n   const
          ACE4_READ_ACL             = 0x00020000;\n   const ACE4_WRITE_ACL            =
          0x00040000;\n   const ACE4_WRITE_OWNER          = 0x00080000;\n   const
          ACE4_SYNCHRONIZE          = 0x00100000;\n   Note that some masks have coincident
          values -- for example,\n   ACE4_READ_DATA and ACE4_LIST_DIRECTORY.  The
          mask entries\n   ACE4_LIST_DIRECTORY, ACE4_ADD_FILE, and ACE4_ADD_SUBDIRECTORY
          are\n   intended to be used with directory objects, while ACE4_READ_DATA,\n
          \  ACE4_WRITE_DATA, and ACE4_APPEND_DATA are intended to be used with\n
          \  non-directory objects.\n"
        - contents:
          - "6.2.1.3.1.  Discussion of Mask Attributes\n   ACE4_READ_DATA\n      Operation(s)
            affected:\n         READ\n         OPEN\n      Discussion:\n         Permission
            to read the data of the file.\n         Servers SHOULD allow a user the
            ability to read the data of the\n         file when only the ACE4_EXECUTE
            access mask bit is set.\n   ACE4_LIST_DIRECTORY\n      Operation(s) affected:\n
            \        READDIR\n      Discussion:\n         Permission to list the contents
            of a directory.\n   ACE4_WRITE_DATA\n      Operation(s) affected:\n         WRITE\n
            \        OPEN\n         SETATTR of size\n      Discussion:\n         Permission
            to modify a file's data.\n   ACE4_ADD_FILE\n      Operation(s) affected:\n
            \        CREATE\n         LINK\n         OPEN\n         RENAME\n      Discussion:\n
            \        Permission to add a new file in a directory.  The CREATE\n         operation
            is affected when nfs_ftype4 is NF4LNK, NF4BLK,\n         NF4CHR, NF4SOCK,
            or NF4FIFO.  (NF4DIR is not listed because it\n         is covered by
            ACE4_ADD_SUBDIRECTORY.)  OPEN is affected when\n         used to create
            a regular file.  LINK and RENAME are always\n         affected.\n   ACE4_APPEND_DATA\n
            \     Operation(s) affected:\n         WRITE\n         OPEN\n         SETATTR
            of size\n      Discussion:\n         The ability to modify a file's data,
            but only starting at EOF.\n         This allows for the notion of append-only
            files, by allowing\n         ACE4_APPEND_DATA and denying ACE4_WRITE_DATA
            to the same user\n         or group.  If a file has an ACL such as the
            one described above\n         and a WRITE request is made for somewhere
            other than EOF, the\n         server SHOULD return NFS4ERR_ACCESS.\n   ACE4_ADD_SUBDIRECTORY\n
            \     Operation(s) affected:\n         CREATE\n         RENAME\n      Discussion:\n
            \        Permission to create a subdirectory in a directory.  The CREATE\n
            \        operation is affected when nfs_ftype4 is NF4DIR.  The RENAME\n
            \        operation is always affected.\n   ACE4_READ_NAMED_ATTRS\n      Operation(s)
            affected:\n         OPENATTR\n      Discussion:\n         Permission to
            read the named attributes of a file or to look up\n         the named
            attributes directory.  OPENATTR is affected when it\n         is not used
            to create a named attribute directory.  This is\n         when 1) createdir
            is TRUE but a named attribute directory\n         already exists or 2)
            createdir is FALSE.\n   ACE4_WRITE_NAMED_ATTRS\n      Operation(s) affected:\n
            \        OPENATTR\n      Discussion:\n         Permission to write the
            named attributes of a file or to create\n         a named attribute directory.
            \ OPENATTR is affected when it is\n         used to create a named attribute
            directory.  This is when\n         createdir is TRUE and no named attribute
            directory exists.  The\n         ability to check whether or not a named
            attribute directory\n         exists depends on the ability to look it
            up; therefore, users\n         also need the ACE4_READ_NAMED_ATTRS permission
            in order to\n         create a named attribute directory.\n   ACE4_EXECUTE\n
            \     Operation(s) affected:\n         READ\n      Discussion:\n         Permission
            to execute a file.\n         Servers SHOULD allow a user the ability to
            read the data of the\n         file when only the ACE4_EXECUTE access
            mask bit is set.  This\n         is because there is no way to execute
            a file without reading\n         the contents.  Though a server may treat
            ACE4_EXECUTE and\n         ACE4_READ_DATA bits identically when deciding
            to permit a READ\n         operation, it SHOULD still allow the two bits
            to be set\n         independently in ACLs and MUST distinguish between
            them when\n         replying to ACCESS operations.  In particular, servers
            SHOULD\n         NOT silently turn on one of the two bits when the other
            is set,\n         as that would make it impossible for the client to correctly\n
            \        enforce the distinction between read and execute permissions.\n
            \        As an example, following a SETATTR of the following ACL:\n         nfsuser:ACE4_EXECUTE:ALLOW\n
            \        A subsequent GETATTR of ACL for that file SHOULD return:\n         nfsuser:ACE4_EXECUTE:ALLOW\n
            \        Rather than:\n         nfsuser:ACE4_EXECUTE/ACE4_READ_DATA:ALLOW\n
            \  ACE4_EXECUTE\n      Operation(s) affected:\n         LOOKUP\n         OPEN\n
            \        REMOVE\n         RENAME\n         LINK\n         CREATE\n      Discussion:\n
            \        Permission to traverse/search a directory.\n   ACE4_DELETE_CHILD\n
            \     Operation(s) affected:\n         REMOVE\n         RENAME\n      Discussion:\n
            \        Permission to delete a file or directory within a directory.\n
            \        See Section 6.2.1.3.2 for information on how ACE4_DELETE and\n
            \        ACE4_DELETE_CHILD interact.\n   ACE4_READ_ATTRIBUTES\n      Operation(s)
            affected:\n         GETATTR of file system object attributes\n         VERIFY\n
            \        NVERIFY\n         READDIR\n      Discussion:\n         The ability
            to read basic attributes (non-ACLs) of a file.\n         On a UNIX system,
            basic attributes can be thought of as the\n         stat-level attributes.
            \ Allowing this access mask bit would\n         mean the entity can execute
            \"ls -l\" and stat.  If a READDIR\n         operation requests attributes,
            this mask must be allowed for\n         the READDIR to succeed.\n   ACE4_WRITE_ATTRIBUTES\n
            \     Operation(s) affected:\n         SETATTR of time_access_set, time_backup,
            time_create,\n         time_modify_set, mimetype, hidden, and system\n
            \     Discussion:\n         Permission to change the times associated
            with a file or\n         directory to an arbitrary value.  Also, permission
            to change\n         the mimetype, hidden and system attributes.  A user
            having\n         ACE4_WRITE_DATA or ACE4_WRITE_ATTRIBUTES will be allowed
            to set\n         the times associated with a file to the current server
            time.\n   ACE4_DELETE\n      Operation(s) affected:\n         REMOVE\n
            \     Discussion:\n         Permission to delete the file or directory.
            \ See\n         Section 6.2.1.3.2 for information on ACE4_DELETE and\n
            \        ACE4_DELETE_CHILD interact.\n   ACE4_READ_ACL\n      Operation(s)
            affected:\n         GETATTR of acl\n         NVERIFY\n         VERIFY\n
            \     Discussion:\n         Permission to read the ACL.\n   ACE4_WRITE_ACL\n
            \     Operation(s) affected:\n         SETATTR of acl and mode\n      Discussion:\n
            \        Permission to write the acl and mode attributes.\n   ACE4_WRITE_OWNER\n
            \     Operation(s) affected:\n         SETATTR of owner and owner_group\n
            \     Discussion:\n         Permission to write the owner and owner_group
            attributes.  On\n         UNIX systems, this is the ability to execute
            chown() and\n         chgrp().\n   ACE4_SYNCHRONIZE\n      Operation(s)
            affected:\n         NONE\n      Discussion:\n         Permission to use
            the file object as a synchronization\n         primitive for interprocess
            communication.  This permission is\n         not enforced or interpreted
            by the NFSv4.0 server on behalf of\n         the client.\n         Typically,
            the ACE4_SYNCHRONIZE permission is only meaningful\n         on local
            file systems, i.e., file systems not accessed via\n         NFSv4.0.  The
            reason that the permission bit exists is that\n         some operating
            environments, such as Windows, use\n         ACE4_SYNCHRONIZE.\n         For
            example, if a client copies a file that has\n         ACE4_SYNCHRONIZE
            set from a local file system to an NFSv4.0\n         server, and then
            later copies the file from the NFSv4.0 server\n         to a local file
            system, it is likely that if ACE4_SYNCHRONIZE\n         was set in the
            original file, the client will want it set in\n         the second copy.
            \ The first copy will not have the permission\n         set unless the
            NFSv4.0 server has the means to set the\n         ACE4_SYNCHRONIZE bit.
            \ The second copy will not have the\n         permission set unless the
            NFSv4.0 server has the means to\n         retrieve the ACE4_SYNCHRONIZE
            bit.\n   Server implementations need not provide the granularity of control\n
            \  that is implied by this list of masks.  For example, POSIX-based\n
            \  systems might not distinguish ACE4_APPEND_DATA (the ability to append\n
            \  to a file) from ACE4_WRITE_DATA (the ability to modify existing\n   contents);
            both masks would be tied to a single \"write\" permission.\n   When such
            a server returns attributes to the client, it would show\n   both ACE4_APPEND_DATA
            and ACE4_WRITE_DATA if and only if the write\n   permission is enabled.\n
            \  If a server receives a SETATTR request that it cannot accurately\n
            \  implement, it should err in the direction of more restricted access,\n
            \  except in the previously discussed cases of execute and read.  For\n
            \  example, suppose a server cannot distinguish overwriting data from\n
            \  appending new data, as described in the previous paragraph.  If a\n
            \  client submits an ALLOW ACE where ACE4_APPEND_DATA is set but\n   ACE4_WRITE_DATA
            is not (or vice versa), the server should either turn\n   off ACE4_APPEND_DATA
            or reject the request with NFS4ERR_ATTRNOTSUPP.\n"
          title: 6.2.1.3.1.  Discussion of Mask Attributes
        - contents:
          - "6.2.1.3.2.  ACE4_DELETE versus ACE4_DELETE_CHILD\n   Two access mask
            bits govern the ability to delete a directory entry:\n   ACE4_DELETE on
            the object itself (the \"target\") and ACE4_DELETE_CHILD\n   on the containing
            directory (the \"parent\").\n   Many systems also take the \"sticky bit\"
            (MODE4_SVTX) on a directory\n   to allow unlink only to a user that owns
            either the target or the\n   parent; on some such systems, the decision
            also depends on whether\n   the target is writable.\n   Servers SHOULD
            allow unlink if either ACE4_DELETE is permitted on the\n   target or ACE4_DELETE_CHILD
            is permitted on the parent.  (Note that\n   this is true even if the parent
            or target explicitly denies the other\n   of these permissions.)\n   If
            the ACLs in question neither explicitly ALLOW nor DENY either of\n   the
            above, and if MODE4_SVTX is not set on the parent, then the\n   server
            SHOULD allow the removal if and only if ACE4_ADD_FILE is\n   permitted.
            \ In the case where MODE4_SVTX is set, the server may also\n   require
            the remover to own either the parent or the target, or may\n   require
            the target to be writable.\n   This allows servers to support something
            close to traditional\n   UNIX-like semantics, with ACE4_ADD_FILE taking
            the place of the\n   write bit.\n"
          title: 6.2.1.3.2.  ACE4_DELETE versus ACE4_DELETE_CHILD
        title: 6.2.1.3.  ACE Access Mask
      - contents:
        - "6.2.1.4.  ACE flag\n   The bitmask constants used for the flag field are
          as follows:\n   const ACE4_FILE_INHERIT_ACE             = 0x00000001;\n
          \  const ACE4_DIRECTORY_INHERIT_ACE        = 0x00000002;\n   const ACE4_NO_PROPAGATE_INHERIT_ACE
          \    = 0x00000004;\n   const ACE4_INHERIT_ONLY_ACE             = 0x00000008;\n
          \  const ACE4_SUCCESSFUL_ACCESS_ACE_FLAG   = 0x00000010;\n   const ACE4_FAILED_ACCESS_ACE_FLAG
          \      = 0x00000020;\n   const ACE4_IDENTIFIER_GROUP             = 0x00000040;\n
          \  A server need not support any of these flags.  If the server supports\n
          \  flags that are similar to, but not exactly the same as, these flags,\n
          \  the implementation may define a mapping between the protocol-defined\n
          \  flags and the implementation-defined flags.\n   For example, suppose
          a client tries to set an ACE with\n   ACE4_FILE_INHERIT_ACE set but not
          ACE4_DIRECTORY_INHERIT_ACE.  If the\n   server does not support any form
          of ACL inheritance, the server\n   should reject the request with NFS4ERR_ATTRNOTSUPP.
          \ If the server\n   supports a single \"inherit ACE\" flag that applies
          to both files and\n   directories, the server may reject the request (i.e.,
          requiring the\n   client to set both the file and directory inheritance
          flags).  The\n   server may also accept the request and silently turn on
          the\n   ACE4_DIRECTORY_INHERIT_ACE flag.\n"
        - contents:
          - "6.2.1.4.1.  Discussion of Flag Bits\n   ACE4_FILE_INHERIT_ACE\n      Any
            non-directory file in any subdirectory will get this ACE\n      inherited.\n
            \  ACE4_DIRECTORY_INHERIT_ACE\n      Can be placed on a directory and
            indicates that this ACE should be\n      added to each new directory created.\n
            \     If this flag is set in an ACE in an ACL attribute to be set on a\n
            \     non-directory file system object, the operation attempting to set\n
            \     the ACL SHOULD fail with NFS4ERR_ATTRNOTSUPP.\n   ACE4_INHERIT_ONLY_ACE\n
            \     Can be placed on a directory but does not apply to the directory;\n
            \     ALLOW and DENY ACEs with this bit set do not affect access to the\n
            \     directory, and AUDIT and ALARM ACEs with this bit set do not\n      trigger
            log or alarm events.  Such ACEs only take effect once they\n      are
            applied (with this bit cleared) to newly created files and\n      directories
            as specified by the above two flags.\n      If this flag is present on
            an ACE, but neither\n      ACE4_DIRECTORY_INHERIT_ACE nor ACE4_FILE_INHERIT_ACE
            is present,\n      then an operation attempting to set such an attribute
            SHOULD fail\n      with NFS4ERR_ATTRNOTSUPP.\n   ACE4_NO_PROPAGATE_INHERIT_ACE\n
            \     Can be placed on a directory.  This flag tells the server that\n
            \     inheritance of this ACE should stop at newly created child\n      directories.\n
            \  ACE4_SUCCESSFUL_ACCESS_ACE_FLAG\n   ACE4_FAILED_ACCESS_ACE_FLAG\n      The
            ACE4_SUCCESSFUL_ACCESS_ACE_FLAG (SUCCESS) and\n      ACE4_FAILED_ACCESS_ACE_FLAG
            (FAILED) flag bits may be set only on\n      ACE4_SYSTEM_AUDIT_ACE_TYPE
            (AUDIT) and ACE4_SYSTEM_ALARM_ACE_TYPE\n      (ALARM) ACE types.  If,
            during the processing of the file's ACL,\n      the server encounters
            an AUDIT or ALARM ACE that matches the\n      principal attempting the
            OPEN, the server notes that fact and\n      notes the presence, if any,
            of the SUCCESS and FAILED flags\n      encountered in the AUDIT or ALARM
            ACE.  Once the server completes\n      the ACL processing, it then notes
            if the operation succeeded or\n      failed.  If the operation succeeded,
            and if the SUCCESS flag was\n      set for a matching AUDIT or ALARM ACE,
            then the appropriate AUDIT\n      or ALARM event occurs.  If the operation
            failed, and if the FAILED\n      flag was set for the matching AUDIT or
            ALARM ACE, then the\n      appropriate AUDIT or ALARM event occurs.  Either
            or both of the\n      SUCCESS or FAILED can be set, but if neither is
            set, the AUDIT or\n      ALARM ACE is not useful.\n      The previously
            described processing applies to ACCESS operations\n      even when they
            return NFS4_OK.  For the purposes of AUDIT and\n      ALARM, we consider
            an ACCESS operation to be a \"failure\" if it\n      fails to return a
            bit that was requested and supported.\n   ACE4_IDENTIFIER_GROUP\n      Indicates
            that the \"who\" refers to a GROUP as defined under UNIX\n      or a GROUP
            ACCOUNT as defined under Windows.  Clients and servers\n      MUST ignore
            the ACE4_IDENTIFIER_GROUP flag on ACEs with a who\n      value equal to
            one of the special identifiers outlined in\n      Section 6.2.1.5.\n"
          title: 6.2.1.4.1.  Discussion of Flag Bits
        title: 6.2.1.4.  ACE flag
      - contents:
        - "6.2.1.5.  ACE Who\n   The who field of an ACE is an identifier that specifies
          the principal\n   or principals to whom the ACE applies.  It may refer to
          a user or a\n   group, with the flag bit ACE4_IDENTIFIER_GROUP specifying
          which.\n   There are several special identifiers that need to be understood\n
          \  universally, rather than in the context of a particular DNS domain.\n
          \  Some of these identifiers cannot be understood when an NFS client\n   accesses
          the server but have meaning when a local process accesses\n   the file.
          \ The ability to display and modify these permissions is\n   permitted over
          NFS, even if none of the access methods on the server\n   understand the
          identifiers.\n   +---------------+---------------------------------------------------+\n
          \  | Who           | Description                                       |\n
          \  +---------------+---------------------------------------------------+\n
          \  | OWNER         | The owner of the file.                            |\n
          \  | GROUP         | The group associated with the file.               |\n
          \  | EVERYONE      | The world, including the owner and owning group.  |\n
          \  | INTERACTIVE   | Accessed from an interactive terminal.            |\n
          \  | NETWORK       | Accessed via the network.                         |\n
          \  | DIALUP        | Accessed as a dialup user to the server.          |\n
          \  | BATCH         | Accessed from a batch job.                        |\n
          \  | ANONYMOUS     | Accessed without any authentication.              |\n
          \  | AUTHENTICATED | Any authenticated user (opposite of ANONYMOUS).   |\n
          \  | SERVICE       | Access from a system service.                     |\n
          \  +---------------+---------------------------------------------------+\n
          \                      Table 5: Special Identifiers\n   To avoid conflict,
          these special identifiers are distinguished by an\n   appended \"@\" and
          should appear in the form \"xxxx@\" (with no domain\n   name after the \"@\")
          -- for example, ANONYMOUS@.\n   The ACE4_IDENTIFIER_GROUP flag MUST be ignored
          on entries with these\n   special identifiers.  When encoding entries with
          these special\n   identifiers, the ACE4_IDENTIFIER_GROUP flag SHOULD be
          set to zero.\n"
        - contents:
          - "6.2.1.5.1.  Discussion of EVERYONE@\n   It is important to note that
            \"EVERYONE@\" is not equivalent to the\n   UNIX \"other\" entity.  This
            is because, by definition, UNIX \"other\"\n   does not include the owner
            or owning group of a file.  \"EVERYONE@\"\n   means literally everyone,
            including the owner or owning group.\n"
          title: 6.2.1.5.1.  Discussion of EVERYONE@
        title: 6.2.1.5.  ACE Who
      title: '6.2.1.  Attribute 12: acl'
    - contents:
      - "6.2.2.  Attribute 33: mode\n   The NFSv4.0 mode attribute is based on the
        UNIX mode bits.  The\n   following bits are defined:\n   const MODE4_SUID
        = 0x800;  /* set user id on execution */\n   const MODE4_SGID = 0x400;  /*
        set group id on execution */\n   const MODE4_SVTX = 0x200;  /* save text even
        after use */\n   const MODE4_RUSR = 0x100;  /* read permission: owner */\n
        \  const MODE4_WUSR = 0x080;  /* write permission: owner */\n   const MODE4_XUSR
        = 0x040;  /* execute permission: owner */\n   const MODE4_RGRP = 0x020;  /*
        read permission: group */\n   const MODE4_WGRP = 0x010;  /* write permission:
        group */\n   const MODE4_XGRP = 0x008;  /* execute permission: group */\n
        \  const MODE4_ROTH = 0x004;  /* read permission: other */\n   const MODE4_WOTH
        = 0x002;  /* write permission: other */\n   const MODE4_XOTH = 0x001;  /*
        execute permission: other */\n   Bits MODE4_RUSR, MODE4_WUSR, and MODE4_XUSR
        apply to the principal\n   identified in the owner attribute.  Bits MODE4_RGRP,
        MODE4_WGRP, and\n   MODE4_XGRP apply to principals identified in the owner_group\n
        \  attribute but who are not identified in the owner attribute.  Bits\n   MODE4_ROTH,
        MODE4_WOTH, and MODE4_XOTH apply to any principal that\n   does not match
        that in the owner attribute and does not have a group\n   matching that of
        the owner_group attribute.\n   Bits within the mode other than those specified
        above are not defined\n   by this protocol.  A server MUST NOT return bits
        other than those\n   defined above in a GETATTR or READDIR operation, and
        it MUST return\n   NFS4ERR_INVAL if bits other than those defined above are
        set in a\n   SETATTR, CREATE, OPEN, VERIFY, or NVERIFY operation.\n"
      title: '6.2.2.  Attribute 33: mode'
    title: 6.2.  File Attributes Discussion
  - contents:
    - "6.3.  Common Methods\n   The requirements in this section will be referred
      to in future\n   sections, especially Section 6.4.\n"
    - contents:
      - '6.3.1.  Interpreting an ACL

        '
      - contents:
        - "6.3.1.1.  Server Considerations\n   The server uses the algorithm described
          in Section 6.2.1 to determine\n   whether an ACL allows access to an object.
          \ However, the ACL may not\n   be the sole determiner of access.  For example:\n
          \  o  In the case of a file system exported as read-only, the server may\n
          \     deny write permissions even though an object's ACL grants it.\n   o
          \ Server implementations MAY grant ACE4_WRITE_ACL and ACE4_READ_ACL\n      permissions
          to prevent a situation from arising in which there is\n      no valid way
          to ever modify the ACL.\n   o  All servers will allow a user the ability
          to read the data of the\n      file when only the execute permission is
          granted (i.e., if the ACL\n      denies the user ACE4_READ_DATA access and
          allows the user\n      ACE4_EXECUTE, the server will allow the user to read
          the data of\n      the file).\n   o  Many servers have the notion of owner-override,
          in which the owner\n      of the object is allowed to override accesses
          that are denied by\n      the ACL.  This may be helpful, for example, to
          allow users\n      continued access to open files on which the permissions
          have\n      changed.\n   o  Many servers have the notion of a \"superuser\"
          that has privileges\n      beyond an ordinary user.  The superuser may be
          able to read or\n      write data or metadata in ways that would not be
          permitted by\n      the ACL.\n"
        title: 6.3.1.1.  Server Considerations
      - contents:
        - "6.3.1.2.  Client Considerations\n   Clients SHOULD NOT do their own access
          checks based on their\n   interpretation of the ACL but rather use the OPEN
          and ACCESS\n   operations to do access checks.  This allows the client to
          act on the\n   results of having the server determine whether or not access
          should\n   be granted based on its interpretation of the ACL.\n   Clients
          must be aware of situations in which an object's ACL will\n   define a certain
          access even though the server will not have adequate\n   information to
          enforce it.  For example, the server has no way of\n   determining whether
          a particular OPEN reflects a user's open for read\n   access or is done
          as part of executing the file in question.  In such\n   situations, the
          client needs to do its part in the enforcement of\n   access as defined
          by the ACL.  To do this, the client will send the\n   appropriate ACCESS
          operation (or use a cached previous determination)\n   prior to servicing
          the request of the user or application in order to\n   determine whether
          the user or application should be granted the\n   access requested.  For
          examples in which the ACL may define accesses\n   that the server does not
          enforce, see Section 6.3.1.1.\n"
        title: 6.3.1.2.  Client Considerations
      title: 6.3.1.  Interpreting an ACL
    - contents:
      - "6.3.2.  Computing a mode Attribute from an ACL\n   The following method can
        be used to calculate the MODE4_R*, MODE4_W*,\n   and MODE4_X* bits of a mode
        attribute, based upon an ACL.\n   First, for each of the special identifiers
        OWNER@, GROUP@, and\n   EVERYONE@, evaluate the ACL in order, considering
        only ALLOW and DENY\n   ACEs for the identifier EVERYONE@ and for the identifier
        under\n   consideration.  The result of the evaluation will be an NFSv4 ACL\n
        \  mask showing exactly which bits are permitted to that identifier.\n   Then
        translate the calculated mask for OWNER@, GROUP@, and EVERYONE@\n   into mode
        bits for the user, group, and other, respectively, as\n   follows:\n   1.
        \ Set the read bit (MODE4_RUSR, MODE4_RGRP, or MODE4_ROTH) if and\n       only
        if ACE4_READ_DATA is set in the corresponding mask.\n   2.  Set the write
        bit (MODE4_WUSR, MODE4_WGRP, or MODE4_WOTH) if and\n       only if ACE4_WRITE_DATA
        and ACE4_APPEND_DATA are both set in the\n       corresponding mask.\n   3.
        \ Set the execute bit (MODE4_XUSR, MODE4_XGRP, or MODE4_XOTH), if\n       and
        only if ACE4_EXECUTE is set in the corresponding mask.\n"
      - contents:
        - "6.3.2.1.  Discussion\n   Some server implementations also add bits permitted
          to named users\n   and groups to the group bits (MODE4_RGRP, MODE4_WGRP,
          and\n   MODE4_XGRP).\n   Implementations are discouraged from doing this,
          because it has been\n   found to cause confusion for users who see members
          of a file's group\n   denied access that the mode bits appear to allow.
          \ (The presence of\n   DENY ACEs may also lead to such behavior, but DENY
          ACEs are expected\n   to be more rarely used.)\n   The same user confusion
          seen when fetching the mode also results if\n   setting the mode does not
          effectively control permissions for the\n   owner, group, and other users;
          this motivates some of the\n   requirements that follow.\n"
        title: 6.3.2.1.  Discussion
      title: 6.3.2.  Computing a mode Attribute from an ACL
    title: 6.3.  Common Methods
  - contents:
    - "6.4.  Requirements\n   The server that supports both mode and ACL must take
      care to\n   synchronize the MODE4_*USR, MODE4_*GRP, and MODE4_*OTH bits with
      the\n   ACEs that have respective who fields of \"OWNER@\", \"GROUP@\", and\n
      \  \"EVERYONE@\" so that the client can see that semantically equivalent\n   access
      permissions exist whether the client asks for just the ACL or\n   any of the
      owner, owner_group, and mode attributes.\n   Many requirements refer to Section
      6.3.2, but note that the methods\n   have behaviors specified with \"SHOULD\".
      \ This is intentional, to\n   avoid invalidating existing implementations that
      compute the mode\n   according to the withdrawn POSIX ACL draft ([P1003.1e]),
      rather than\n   by actual permissions on owner, group, and other.\n"
    - contents:
      - '6.4.1.  Setting the mode and/or ACL Attributes

        '
      - contents:
        - "6.4.1.1.  Setting mode and Not ACL\n   When any of the nine low-order mode
          bits are changed because the mode\n   attribute was set, and no ACL attribute
          is explicitly set, the acl\n   attribute must be modified in accordance
          with the updated value of\n   those bits.  This must happen even if the
          value of the low-order bits\n   is the same after the mode is set as before.\n
          \  Note that any AUDIT or ALARM ACEs are unaffected by changes to the\n
          \  mode.\n   In cases in which the permissions bits are subject to change,
          the acl\n   attribute MUST be modified such that the mode computed via the
          method\n   described in Section 6.3.2 yields the low-order nine bits (MODE4_R*,\n
          \  MODE4_W*, MODE4_X*) of the mode attribute as modified by the change\n
          \  attribute.  The ACL attributes SHOULD also be modified such that:\n   1.
          \ If MODE4_RGRP is not set, entities explicitly listed in the ACL\n       other
          than OWNER@ and EVERYONE@ SHOULD NOT be granted\n       ACE4_READ_DATA.\n
          \  2.  If MODE4_WGRP is not set, entities explicitly listed in the ACL\n
          \      other than OWNER@ and EVERYONE@ SHOULD NOT be granted\n       ACE4_WRITE_DATA
          or ACE4_APPEND_DATA.\n   3.  If MODE4_XGRP is not set, entities explicitly
          listed in the ACL\n       other than OWNER@ and EVERYONE@ SHOULD NOT be
          granted\n       ACE4_EXECUTE.\n   Access mask bits other than those listed
          above, appearing in ALLOW\n   ACEs, MAY also be disabled.\n   Note that
          ACEs with the flag ACE4_INHERIT_ONLY_ACE set do not affect\n   the permissions
          of the ACL itself, nor do ACEs of the types AUDIT and\n   ALARM.  As such,
          it is desirable to leave these ACEs unmodified when\n   modifying the ACL
          attributes.\n   Also note that the requirement may be met by discarding
          the acl in\n   favor of an ACL that represents the mode and only the mode.
          \ This is\n   permitted, but it is preferable for a server to preserve as
          much of\n   the ACL as possible without violating the above requirements.\n
          \  Discarding the ACL makes it effectively impossible for a file created\n
          \  with a mode attribute to inherit an ACL (see Section 6.4.3).\n"
        title: 6.4.1.1.  Setting mode and Not ACL
      - contents:
        - "6.4.1.2.  Setting ACL and Not mode\n   When setting the acl and not setting
          the mode attribute, the\n   permission bits of the mode need to be derived
          from the ACL.  In this\n   case, the ACL attribute SHOULD be set as given.
          \ The nine low-order\n   bits of the mode attribute (MODE4_R*, MODE4_W*,
          MODE4_X*) MUST be\n   modified to match the result of the method described
          in\n   Section 6.3.2.  The three high-order bits of the mode (MODE4_SUID,\n
          \  MODE4_SGID, MODE4_SVTX) SHOULD remain unchanged.\n"
        title: 6.4.1.2.  Setting ACL and Not mode
      - contents:
        - "6.4.1.3.  Setting Both ACL and mode\n   When setting both the mode and
          the acl attribute in the same\n   operation, the attributes MUST be applied
          in this order: mode, then\n   ACL.  The mode-related attribute is set as
          given, then the ACL\n   attribute is set as given, possibly changing the
          final mode, as\n   described above in Section 6.4.1.2.\n"
        title: 6.4.1.3.  Setting Both ACL and mode
      title: 6.4.1.  Setting the mode and/or ACL Attributes
    - contents:
      - "6.4.2.  Retrieving the mode and/or ACL Attributes\n   This section applies
        only to servers that support both the mode and\n   ACL attributes.\n   Some
        server implementations may have a concept of \"objects without\n   ACLs\",
        meaning that all permissions are granted and denied according\n   to the mode
        attribute, and that no ACL attribute is stored for that\n   object.  If an
        ACL attribute is requested of such a server, the\n   server SHOULD return
        an ACL that does not conflict with the mode;\n   that is to say, the ACL returned
        SHOULD represent the nine low-order\n   bits of the mode attribute (MODE4_R*,
        MODE4_W*, MODE4_X*) as\n   described in Section 6.3.2.\n   For other server
        implementations, the ACL attribute is always present\n   for every object.
        \ Such servers SHOULD store at least the three\n   high-order bits of the
        mode attribute (MODE4_SUID, MODE4_SGID,\n   MODE4_SVTX).  The server SHOULD
        return a mode attribute if one is\n   requested, and the low-order nine bits
        of the mode (MODE4_R*,\n   MODE4_W*, MODE4_X*) MUST match the result of applying
        the method in\n   Section 6.3.2 to the ACL attribute.\n"
      title: 6.4.2.  Retrieving the mode and/or ACL Attributes
    - contents:
      - "6.4.3.  Creating New Objects\n   If a server supports any ACL attributes,
        it may use the ACL\n   attributes on the parent directory to compute an initial
        ACL\n   attribute for a newly created object.  This will be referred to as\n
        \  the inherited ACL within this section.  The act of adding one or more\n
        \  ACEs to the inherited ACL that are based upon ACEs in the parent\n   directory's
        ACL will be referred to as inheriting an ACE within this\n   section.\n   In
        the presence or absence of the mode and ACL attributes, the\n   behavior of
        CREATE and OPEN SHOULD be:\n   1.  If just the mode is given in the call:\n
        \      In this case, inheritance SHOULD take place, but the mode MUST be\n
        \      applied to the inherited ACL as described in Section 6.4.1.1,\n       thereby
        modifying the ACL.\n   2.  If just the ACL is given in the call:\n       In
        this case, inheritance SHOULD NOT take place, and the ACL as\n       defined
        in the CREATE or OPEN will be set without modification,\n       and the mode
        modified as in Section 6.4.1.2.\n   3.  If both mode and ACL are given in
        the call:\n       In this case, inheritance SHOULD NOT take place, and both\n
        \      attributes will be set as described in Section 6.4.1.3.\n   4.  If
        neither mode nor ACL is given in the call:\n       In the case where an object
        is being created without any initial\n       attributes at all, e.g., an OPEN
        operation with an opentype4 of\n       OPEN4_CREATE and a createmode4 of EXCLUSIVE4,
        inheritance SHOULD\n       NOT take place.  Instead, the server SHOULD set
        permissions to\n       deny all access to the newly created object.  It is
        expected that\n       the appropriate client will set the desired attributes
        in a\n       subsequent SETATTR operation, and the server SHOULD allow that\n
        \      operation to succeed, regardless of what permissions the object\n       is
        created with.  For example, an empty ACL denies all\n       permissions, but
        the server should allow the owner's SETATTR to\n       succeed even though
        WRITE_ACL is implicitly denied.\n       In other cases, inheritance SHOULD
        take place, and no\n       modifications to the ACL will happen.  The mode
        attribute, if\n       supported, MUST be as computed via the method described
        in\n       Section 6.3.2, with the MODE4_SUID, MODE4_SGID, and MODE4_SVTX\n
        \      bits clear.  If no inheritable ACEs exist on the parent\n       directory,
        the rules for creating acl attributes are\n       implementation defined.\n"
      - contents:
        - "6.4.3.1.  The Inherited ACL\n   If the object being created is not a directory,
          the inherited ACL\n   SHOULD NOT inherit ACEs from the parent directory
          ACL unless the\n   ACE4_FILE_INHERIT_FLAG is set.\n   If the object being
          created is a directory, the inherited ACL should\n   inherit all inheritable
          ACEs from the parent directory, i.e., those\n   that have the ACE4_FILE_INHERIT_ACE
          or ACE4_DIRECTORY_INHERIT_ACE\n   flag set.  If the inheritable ACE has
          ACE4_FILE_INHERIT_ACE set, but\n   ACE4_DIRECTORY_INHERIT_ACE is clear,
          the inherited ACE on the newly\n   created directory MUST have the ACE4_INHERIT_ONLY_ACE
          flag set to\n   prevent the directory from being affected by ACEs meant
          for\n   non-directories.\n   When a new directory is created, the server
          MAY split any inherited\n   ACE that is both inheritable and effective (in
          other words, that has\n   neither ACE4_INHERIT_ONLY_ACE nor ACE4_NO_PROPAGATE_INHERIT_ACE
          set)\n   into two ACEs -- one with no inheritance flags, and one with\n
          \  ACE4_INHERIT_ONLY_ACE set.  This makes it simpler to modify the\n   effective
          permissions on the directory without modifying the ACE that\n   is to be
          inherited to the new directory's children.\n"
        title: 6.4.3.1.  The Inherited ACL
      title: 6.4.3.  Creating New Objects
    title: 6.4.  Requirements
  title: 6.  Access Control Attributes
- contents:
  - '7.  NFS Server Namespace

    '
  - contents:
    - "7.1.  Server Exports\n   On a UNIX server, the namespace describes all the
      files reachable by\n   pathnames under the root directory or \"/\".  On a Windows
      server, the\n   namespace constitutes all the files on disks named by mapped
      disk\n   letters.  NFS server administrators rarely make the entire server's\n
      \  file system namespace available to NFS clients.  More often, portions\n   of
      the namespace are made available via an \"export\" feature.  In\n   previous
      versions of the NFS protocol, the root filehandle for each\n   export is obtained
      through the MOUNT protocol; the client sends a\n   string that identifies an
      object in the exported namespace, and the\n   server returns the root filehandle
      for it.  The MOUNT protocol\n   supports an EXPORTS procedure that will enumerate
      the server's\n   exports.\n"
    title: 7.1.  Server Exports
  - contents:
    - "7.2.  Browsing Exports\n   The NFSv4 protocol provides a root filehandle that
      clients can use to\n   obtain filehandles for these exports via a multi-component
      LOOKUP.  A\n   common user experience is to use a graphical user interface (perhaps\n
      \  a file \"Open\" dialog window) to find a file via progressive browsing\n
      \  through a directory tree.  The client must be able to move from one\n   export
      to another export via single-component, progressive LOOKUP\n   operations.\n
      \  This style of browsing is not well supported by the NFSv2 and NFSv3\n   protocols.
      \ The client expects all LOOKUP operations to remain within\n   a single-server
      file system.  For example, the device attribute will\n   not change.  This prevents
      a client from taking namespace paths that\n   span exports.\n   An automounter
      on the client can obtain a snapshot of the server's\n   namespace using the
      EXPORTS procedure of the MOUNT protocol.  If it\n   understands the server's
      pathname syntax, it can create an image of\n   the server's namespace on the
      client.  The parts of the namespace\n   that are not exported by the server
      are filled in with a \"pseudo-file\n   system\" that allows the user to browse
      from one mounted file system\n   to another.  There is a drawback to this representation
      of the\n   server's namespace on the client: it is static.  If the server\n
      \  administrator adds a new export, the client will be unaware of it.\n"
    title: 7.2.  Browsing Exports
  - contents:
    - "7.3.  Server Pseudo-File System\n   NFSv4 servers avoid this namespace inconsistency
      by presenting all\n   the exports within the framework of a single-server namespace.
      \ An\n   NFSv4 client uses LOOKUP and READDIR operations to browse seamlessly\n
      \  from one export to another.  Portions of the server namespace that\n   are
      not exported are bridged via a \"pseudo-file system\" that provides\n   a view
      of exported directories only.  A pseudo-file system has a\n   unique fsid and
      behaves like a normal, read-only file system.\n   Based on the construction
      of the server's namespace, it is possible\n   that multiple pseudo-file systems
      may exist.  For example:\n     /a         pseudo-file system\n     /a/b       real
      file system\n     /a/b/c     pseudo-file system\n     /a/b/c/d   real file system\n
      \  Each of the pseudo-file systems are considered separate entities and\n   therefore
      will have a unique fsid.\n"
    title: 7.3.  Server Pseudo-File System
  - contents:
    - "7.4.  Multiple Roots\n   The DOS and Windows operating environments are sometimes
      described as\n   having \"multiple roots\".  File systems are commonly represented
      as\n   disk letters.  MacOS represents file systems as top-level names.\n   NFSv4
      servers for these platforms can construct a pseudo-file system\n   above these
      root names so that disk letters or volume names are\n   simply directory names
      in the pseudo-root.\n"
    title: 7.4.  Multiple Roots
  - contents:
    - "7.5.  Filehandle Volatility\n   The nature of the server's pseudo-file system
      is that it is a logical\n   representation of file system(s) available from
      the server.\n   Therefore, the pseudo-file system is most likely constructed\n
      \  dynamically when the server is first instantiated.  It is expected\n   that
      the pseudo-file system may not have an on-disk counterpart from\n   which persistent
      filehandles could be constructed.  Even though it is\n   preferable that the
      server provide persistent filehandles for the\n   pseudo-file system, the NFS
      client should expect that pseudo-file\n   system filehandles are volatile.  This
      can be confirmed by checking\n   the associated \"fh_expire_type\" attribute
      for those filehandles in\n   question.  If the filehandles are volatile, the
      NFS client must be\n   prepared to recover a filehandle value (e.g., with a
      multi-component\n   LOOKUP) when receiving an error of NFS4ERR_FHEXPIRED.\n"
    title: 7.5.  Filehandle Volatility
  - contents:
    - "7.6.  Exported Root\n   If the server's root file system is exported, one might
      conclude that\n   a pseudo-file system is not needed.  This would be wrong.
      \ Assume the\n   following file systems on a server:\n     /       disk1  (exported)\n
      \    /a      disk2  (not exported)\n     /a/b    disk3  (exported)\n   Because
      disk2 is not exported, disk3 cannot be reached with simple\n   LOOKUPs.  The
      server must bridge the gap with a pseudo-file system.\n"
    title: 7.6.  Exported Root
  - contents:
    - "7.7.  Mount Point Crossing\n   The server file system environment may be constructed
      in such a way\n   that one file system contains a directory that is 'covered'
      or\n   mounted upon by a second file system.  For example:\n     /a/b            (file
      system 1)\n     /a/b/c/d        (file system 2)\n   The pseudo-file system for
      this server may be constructed to\n   look like:\n     /               (placeholder/not
      exported)\n     /a/b            (file system 1)\n     /a/b/c/d        (file
      system 2)\n   It is the server's responsibility to present the pseudo-file system\n
      \  that is complete to the client.  If the client sends a LOOKUP request\n   for
      the path \"/a/b/c/d\", the server's response is the filehandle of\n   the file
      system \"/a/b/c/d\".  In previous versions of the NFS\n   protocol, the server
      would respond with the filehandle of directory\n   \"/a/b/c/d\" within the file
      system \"/a/b\".\n   The NFS client will be able to determine if it crosses
      a server mount\n   point by a change in the value of the \"fsid\" attribute.\n"
    title: 7.7.  Mount Point Crossing
  - contents:
    - "7.8.  Security Policy and Namespace Presentation\n   Because NFSv4 clients
      possess the ability to change the security\n   mechanisms used, after determining
      what is allowed, by using SECINFO\n   the server SHOULD NOT present a different
      view of the namespace based\n   on the security mechanism being used by a client.
      \ Instead, it should\n   present a consistent view and return NFS4ERR_WRONGSEC
      if an attempt\n   is made to access data with an inappropriate security mechanism.\n
      \  If security considerations make it necessary to hide the existence of\n   a
      particular file system, as opposed to all of the data within it,\n   the server
      can apply the security policy of a shared resource in the\n   server's namespace
      to components of the resource's ancestors.  For\n   example:\n       /                       (placeholder/not
      exported)\n       /a/b                    (file system 1)\n       /a/b/MySecretProject
      \   (file system 2)\n   The /a/b/MySecretProject directory is a real file system
      and is the\n   shared resource.  Suppose the security policy for /a/b/\n   MySecretProject
      is Kerberos with integrity and it is desired to limit\n   knowledge of the existence
      of this file system.  In this case, the\n   server should apply the same security
      policy to /a/b.  This allows\n   for knowledge of the existence of a file system
      to be secured when\n   desirable.\n   For the case of the use of multiple, disjoint
      security mechanisms in\n   the server's resources, applying that sort of policy
      would result in\n   the higher-level file system not being accessible using
      any security\n   flavor.  Therefore, that sort of configuration is not compatible
      with\n   hiding the existence (as opposed to the contents) from clients using\n
      \  multiple disjoint sets of security flavors.\n   In other circumstances, a
      desirable policy is for the security of a\n   particular object in the server's
      namespace to include the union of\n   all security mechanisms of all direct
      descendants.  A common and\n   convenient practice, unless strong security requirements
      dictate\n   otherwise, is to make the entire pseudo-file system accessible by
      all\n   of the valid security mechanisms.\n   Where there is concern about the
      security of data on the network,\n   clients should use strong security mechanisms
      to access the\n   pseudo-file system in order to prevent man-in-the-middle attacks.\n"
    title: 7.8.  Security Policy and Namespace Presentation
  title: 7.  NFS Server Namespace
- contents:
  - "8.  Multi-Server Namespace\n   NFSv4 supports attributes that allow a namespace
    to extend beyond the\n   boundaries of a single server.  It is RECOMMENDED that
    clients and\n   servers support construction of such multi-server namespaces.
    \ Use of\n   such multi-server namespaces is optional, however, and for many\n
    \  purposes, single-server namespaces are perfectly acceptable.  Use of\n   multi-server
    namespaces can provide many advantages, however, by\n   separating a file system's
    logical position in a namespace from the\n   (possibly changing) logistical and
    administrative considerations that\n   result in particular file systems being
    located on particular\n   servers.\n"
  - contents:
    - "8.1.  Location Attributes\n   NFSv4 contains RECOMMENDED attributes that allow
      file systems on one\n   server to be associated with one or more instances of
      that file\n   system on other servers.  These attributes specify such file system\n
      \  instances by specifying a server address target (as either a DNS name\n   representing
      one or more IP addresses, or a literal IP address),\n   together with the path
      of that file system within the associated\n   single-server namespace.\n   The
      fs_locations RECOMMENDED attribute allows specification of the\n   file system
      locations where the data corresponding to a given file\n   system may be found.\n"
    title: 8.1.  Location Attributes
  - contents:
    - "8.2.  File System Presence or Absence\n   A given location in an NFSv4 namespace
      (typically but not necessarily\n   a multi-server namespace) can have a number
      of file system instance\n   locations associated with it via the fs_locations
      attribute.  There\n   may also be an actual current file system at that location,\n
      \  accessible via normal namespace operations (e.g., LOOKUP).  In this\n   case,
      the file system is said to be \"present\" at that position in the\n   namespace,
      and clients will typically use it, reserving use of\n   additional locations
      specified via the location-related attributes to\n   situations in which the
      principal location is no longer available.\n   When there is no actual file
      system at the namespace location in\n   question, the file system is said to
      be \"absent\".  An absent file\n   system contains no files or directories other
      than the root.  Any\n   reference to it, except to access a small set of attributes
      useful in\n   determining alternative locations, will result in an error,\n
      \  NFS4ERR_MOVED.  Note that if the server ever returns the error\n   NFS4ERR_MOVED,
      it MUST support the fs_locations attribute.\n   While the error name suggests
      that we have a case of a file system\n   that once was present, and has only
      become absent later, this is only\n   one possibility.  A position in the namespace
      may be permanently\n   absent with the set of file system(s) designated by the
      location\n   attributes being the only realization.  The name NFS4ERR_MOVED\n
      \  reflects an earlier, more limited conception of its function, but\n   this
      error will be returned whenever the referenced file system is\n   absent, whether
      it has moved or simply never existed.\n   Except in the case of GETATTR-type
      operations (to be discussed\n   later), when the current filehandle at the start
      of an operation is\n   within an absent file system, that operation is not performed
      and the\n   error NFS4ERR_MOVED is returned, to indicate that the file system
      is\n   absent on the current server.\n   Because a GETFH cannot succeed if the
      current filehandle is within an\n   absent file system, filehandles within an
      absent file system cannot\n   be transferred to the client.  When a client does
      have filehandles\n   within an absent file system, it is the result of obtaining
      them when\n   the file system was present, and having the file system become
      absent\n   subsequently.\n   It should be noted that because the check for the
      current filehandle\n   being within an absent file system happens at the start
      of every\n   operation, operations that change the current filehandle so that
      it\n   is within an absent file system will not result in an error.  This\n
      \  allows such combinations as PUTFH-GETATTR and LOOKUP-GETATTR to be\n   used
      to get attribute information, particularly location attribute\n   information,
      as discussed below.\n"
    title: 8.2.  File System Presence or Absence
  - contents:
    - "8.3.  Getting Attributes for an Absent File System\n   When a file system is
      absent, most attributes are not available, but\n   it is necessary to allow
      the client access to the small set of\n   attributes that are available, and
      most particularly that which gives\n   information about the correct current
      locations for this file system,\n   fs_locations.\n"
    - contents:
      - "8.3.1.  GETATTR within an Absent File System\n   As mentioned above, an exception
        is made for GETATTR in that\n   attributes may be obtained for a filehandle
        within an absent file\n   system.  This exception only applies if the attribute
        mask contains\n   at least the fs_locations attribute bit, which indicates
        that the\n   client is interested in a result regarding an absent file system.
        \ If\n   it is not requested, GETATTR will result in an NFS4ERR_MOVED error.\n
        \  When a GETATTR is done on an absent file system, the set of supported\n
        \  attributes is very limited.  Many attributes, including those that\n   are
        normally REQUIRED, will not be available on an absent file\n   system.  In
        addition to the fs_locations attribute, the following\n   attributes SHOULD
        be available on absent file systems.  In the case\n   of RECOMMENDED attributes,
        they should be available at least to the\n   same degree that they are available
        on present file systems.\n   fsid:  This attribute should be provided so that
        the client can\n      determine file system boundaries, including, in particular,
        the\n      boundary between present and absent file systems.  This value must\n
        \     be different from any other fsid on the current server and need\n      have
        no particular relationship to fsids on any particular\n      destination to
        which the client might be directed.\n   mounted_on_fileid:  For objects at
        the top of an absent file system,\n      this attribute needs to be available.
        \ Since the fileid is within\n      the present parent file system, there
        should be no need to\n      reference the absent file system to provide this
        information.\n   Other attributes SHOULD NOT be made available for absent
        file\n   systems, even when it is possible to provide them.  The server should\n
        \  not assume that more information is always better and should avoid\n   gratuitously
        providing additional information.\n   When a GETATTR operation includes a
        bitmask for the attribute\n   fs_locations, but where the bitmask includes
        attributes that are not\n   supported, GETATTR will not return an error but
        will return the mask\n   of the actual attributes supported with the results.\n
        \  Handling of VERIFY/NVERIFY is similar to GETATTR in that if the\n   attribute
        mask does not include fs_locations the error NFS4ERR_MOVED\n   will result.
        \ It differs in that any appearance in the attribute mask\n   of an attribute
        not supported for an absent file system (and note\n   that this will include
        some normally REQUIRED attributes) will also\n   cause an NFS4ERR_MOVED result.\n"
      title: 8.3.1.  GETATTR within an Absent File System
    - contents:
      - "8.3.2.  READDIR and Absent File Systems\n   A READDIR performed when the
        current filehandle is within an absent\n   file system will result in an NFS4ERR_MOVED
        error, since, unlike the\n   case of GETATTR, no such exception is made for
        READDIR.\n   Attributes for an absent file system may be fetched via a READDIR
        for\n   a directory in a present file system, when that directory contains\n
        \  the root directories of one or more absent file systems.  In this\n   case,
        the handling is as follows:\n   o  If the attribute set requested includes
        fs_locations, then the\n      fetching of attributes proceeds normally, and
        no NFS4ERR_MOVED\n      indication is returned even when the rdattr_error
        attribute is\n      requested.\n   o  If the attribute set requested does
        not include fs_locations, then\n      if the rdattr_error attribute is requested,
        each directory entry\n      for the root of an absent file system will report
        NFS4ERR_MOVED as\n      the value of the rdattr_error attribute.\n   o  If
        the attribute set requested does not include either of the\n      attributes
        fs_locations or rdattr_error, then the occurrence of\n      the root of an
        absent file system within the directory will result\n      in the READDIR
        failing with an NFS4ERR_MOVED error.\n   o  The unavailability of an attribute
        because of a file system's\n      absence, even one that is ordinarily REQUIRED,
        does not result in\n      any error indication.  The set of attributes returned
        for the root\n      directory of the absent file system in that case is simply\n
        \     restricted to those actually available.\n"
      title: 8.3.2.  READDIR and Absent File Systems
    title: 8.3.  Getting Attributes for an Absent File System
  - contents:
    - "8.4.  Uses of Location Information\n   The location-bearing attribute of fs_locations
      provides, together\n   with the possibility of absent file systems, a number
      of important\n   facilities in providing reliable, manageable, and scalable
      data\n   access.\n   When a file system is present, these attributes can provide\n
      \  alternative locations, to be used to access the same data, in the\n   event
      of server failures, communications problems, or other\n   difficulties that
      make continued access to the current file system\n   impossible or otherwise
      impractical.  Under some circumstances,\n   multiple alternative locations may
      be used simultaneously to provide\n   higher-performance access to the file
      system in question.  Provision\n   of such alternative locations is referred
      to as \"replication\",\n   although there are cases in which replicated sets
      of data are not in\n   fact present and the replicas are instead different paths
      to the same\n   data.\n   When a file system is present and subsequently becomes
      absent,\n   clients can be given the opportunity to have continued access to\n
      \  their data, at an alternative location.  Transfer of the file system\n   contents
      to the new location is referred to as \"migration\".  See\n   Section 8.4.2
      for details.\n   Alternative locations may be physical replicas of the file
      system\n   data or alternative communication paths to the same server or, in
      the\n   case of various forms of server clustering, another server providing\n
      \  access to the same physical file system.  The client's\n   responsibilities
      in dealing with this transition depend on the\n   specific nature of the new
      access path as well as how and whether\n   data was in fact migrated.  These
      issues will be discussed in detail\n   below.\n   Where a file system was not
      previously present, specification of file\n   system location provides a means
      by which file systems located on one\n   server can be associated with a namespace
      defined by another server,\n   thus allowing a general multi-server namespace
      facility.  A\n   designation of such a location, in place of an absent file
      system, is\n   called a \"referral\".\n   Because client support for location-related
      attributes is OPTIONAL, a\n   server may (but is not required to) take action
      to hide migration and\n   referral events from such clients, by acting as a
      proxy, for example.\n"
    - contents:
      - "8.4.1.  File System Replication\n   The fs_locations attribute provides alternative
        locations, to be used\n   to access data in place of, or in addition to, the
        current file\n   system instance.  On first access to a file system, the client
        should\n   obtain the value of the set of alternative locations by interrogating\n
        \  the fs_locations attribute.\n   In the event that server failures, communications
        problems, or other\n   difficulties make continued access to the current file
        system\n   impossible or otherwise impractical, the client can use the\n   alternative
        locations as a way to get continued access to its data.\n   Multiple locations
        may be used simultaneously, to provide higher\n   performance through the
        exploitation of multiple paths between client\n   and target file system.\n
        \  Multiple server addresses, whether they are derived from a single\n   entry
        with a DNS name representing a set of IP addresses or from\n   multiple entries
        each with its own server address, may correspond to\n   the same actual server.\n"
      title: 8.4.1.  File System Replication
    - contents:
      - "8.4.2.  File System Migration\n   When a file system is present and becomes
        absent, clients can be\n   given the opportunity to have continued access
        to their data, at an\n   alternative location, as specified by the fs_locations
        attribute.\n   Typically, a client will be accessing the file system in question,\n
        \  get an NFS4ERR_MOVED error, and then use the fs_locations attribute\n   to
        determine the new location of the data.\n   Such migration can be helpful
        in providing load balancing or general\n   resource reallocation.  The protocol
        does not specify how the file\n   system will be moved between servers.  It
        is anticipated that a\n   number of different server-to-server transfer mechanisms
        might be\n   used, with the choice left to the server implementer.  The NFSv4\n
        \  protocol specifies the method used to communicate the migration event\n
        \  between client and server.\n   When an alternative location is designated
        as the target for\n   migration, it must designate the same data.  Where file
        systems are\n   writable, a change made on the original file system must be
        visible\n   on all migration targets.  Where a file system is not writable
        but\n   represents a read-only copy (possibly periodically updated) of a\n
        \  writable file system, similar requirements apply to the propagation\n   of
        updates.  Any change visible in the original file system must\n   already
        be effected on all migration targets, to avoid any\n   possibility that a
        client, in effecting a transition to the migration\n   target, will see any
        reversion in file system state.\n"
      title: 8.4.2.  File System Migration
    - contents:
      - "8.4.3.  Referrals\n   Referrals provide a way of placing a file system in
        a location within\n   the namespace essentially without respect to its physical
        location on\n   a given server.  This allows a single server or a set of servers
        to\n   present a multi-server namespace that encompasses file systems\n   located
        on multiple servers.  Some likely uses of this include\n   establishment of
        site-wide or organization-wide namespaces, or even\n   knitting such together
        into a truly global namespace.\n   Referrals occur when a client determines,
        upon first referencing a\n   position in the current namespace, that it is
        part of a new file\n   system and that the file system is absent.  When this
        occurs,\n   typically by receiving the error NFS4ERR_MOVED, the actual location\n
        \  or locations of the file system can be determined by fetching the\n   fs_locations
        attribute.\n   The location-related attribute may designate a single file
        system\n   location or multiple file system locations, to be selected based
        on\n   the needs of the client.\n   Use of multi-server namespaces is enabled
        by NFSv4 but is not\n   required.  The use of multi-server namespaces and
        their scope will\n   depend on the applications used and system administration\n
        \  preferences.\n   Multi-server namespaces can be established by a single
        server\n   providing a large set of referrals to all of the included file\n
        \  systems.  Alternatively, a single multi-server namespace may be\n   administratively
        segmented with separate referral file systems (on\n   separate servers) for
        each separately administered portion of the\n   namespace.  The top-level
        referral file system or any segment may use\n   replicated referral file systems
        for higher availability.\n   Generally, multi-server namespaces are for the
        most part uniform, in\n   that the same data made available to one client
        at a given location\n   in the namespace is made available to all clients
        at that location.\n"
      title: 8.4.3.  Referrals
    title: 8.4.  Uses of Location Information
  - contents:
    - "8.5.  Location Entries and Server Identity\n   As mentioned above, a single
      location entry may have a server address\n   target in the form of a DNS name
      that may represent multiple IP\n   addresses, while multiple location entries
      may have their own server\n   address targets that reference the same server.\n
      \  When multiple addresses for the same server exist, the client may\n   assume
      that for each file system in the namespace of a given server\n   network address,
      there exist file systems at corresponding namespace\n   locations for each of
      the other server network addresses.  It may do\n   this even in the absence
      of explicit listing in fs_locations.  Such\n   corresponding file system locations
      can be used as alternative\n   locations, just as those explicitly specified
      via the fs_locations\n   attribute.\n   If a single location entry designates
      multiple server IP addresses,\n   the client should choose a single one to use.
      \ When two server\n   addresses are designated by a single location entry and
      they\n   correspond to different servers, this normally indicates some sort
      of\n   misconfiguration, and so the client should avoid using such location\n
      \  entries when alternatives are available.  When they are not, clients\n   should
      pick one of the IP addresses and use it, without using others\n   that are not
      directed to the same server.\n"
    title: 8.5.  Location Entries and Server Identity
  - contents:
    - "8.6.  Additional Client-Side Considerations\n   When clients make use of servers
      that implement referrals,\n   replication, and migration, care should be taken
      that a user who\n   mounts a given file system that includes a referral or a
      relocated\n   file system continues to see a coherent picture of that user-side\n
      \  file system despite the fact that it contains a number of server-side\n   file
      systems that may be on different servers.\n   One important issue is upward
      navigation from the root of a\n   server-side file system to its parent (specified
      as \"..\" in UNIX), in\n   the case in which it transitions to that file system
      as a result of\n   referral, migration, or a transition as a result of replication.\n
      \  When the client is at such a point, and it needs to ascend to the\n   parent,
      it must go back to the parent as seen within the multi-server\n   namespace
      rather than sending a LOOKUPP operation to the server,\n   which would result
      in the parent within that server's single-server\n   namespace.  In order to
      do this, the client needs to remember the\n   filehandles that represent such
      file system roots and use these\n   instead of issuing a LOOKUPP operation to
      the current server.  This\n   will allow the client to present to applications
      a consistent\n   namespace, where upward navigation and downward navigation
      are\n   consistent.\n   Another issue concerns refresh of referral locations.
      \ When referrals\n   are used extensively, they may change as server configurations\n
      \  change.  It is expected that clients will cache information related\n   to
      traversing referrals so that future client-side requests are\n   resolved locally
      without server communication.  This is usually\n   rooted in client-side name
      lookup caching.  Clients should\n   periodically purge this data for referral
      points in order to detect\n   changes in location information.\n   A potential
      problem exists if a client were to allow an open-owner to\n   have state on
      multiple file systems on a server, in that it is\n   unclear how the sequence
      numbers associated with open-owners are to\n   be dealt with, in the event of
      transparent state migration.  A client\n   can avoid such a situation if it
      ensures that any use of an\n   open-owner is confined to a single file system.\n
      \  A server MAY decline to migrate state associated with open-owners\n   that
      span multiple file systems.  In cases in which the server\n   chooses not to
      migrate such state, the server MUST return\n   NFS4ERR_BAD_STATEID when the
      client uses those stateids on the new\n   server.\n   The server MUST return
      NFS4ERR_STALE_STATEID when the client uses\n   those stateids on the old server,
      regardless of whether migration has\n   occurred or not.\n"
    title: 8.6.  Additional Client-Side Considerations
  - contents:
    - "8.7.  Effecting File System Referrals\n   Referrals are effected when an absent
      file system is encountered and\n   one or more alternative locations are made
      available by the\n   fs_locations attribute.  The client will typically get
      an\n   NFS4ERR_MOVED error, fetch the appropriate location information, and\n
      \  proceed to access the file system on a different server, even though\n   it
      retains its logical position within the original namespace.\n   Referrals differ
      from migration events in that they happen only when\n   the client has not previously
      referenced the file system in question\n   (so there is nothing to transition).
      \ Referrals can only come into\n   effect when an absent file system is encountered
      at its root.\n   The examples given in the sections below are somewhat artificial
      in\n   that an actual client will not typically do a multi-component lookup\n
      \  but will have cached information regarding the upper levels of the\n   name
      hierarchy.  However, these example are chosen to make the\n   required behavior
      clear and easy to put within the scope of a small\n   number of requests, without
      getting unduly into details of how\n   specific clients might choose to cache
      things.\n"
    - contents:
      - "8.7.1.  Referral Example (LOOKUP)\n   Let us suppose that the following COMPOUND
        is sent in an environment\n   in which /this/is/the/path is absent from the
        target server.  This\n   may be for a number of reasons.  It may be the case
        that the file\n   system has moved, or it may be the case that the target
        server is\n   functioning mainly, or solely, to refer clients to the servers
        on\n   which various file systems are located.\n   o  PUTROOTFH\n   o  LOOKUP
        \"this\"\n   o  LOOKUP \"is\"\n   o  LOOKUP \"the\"\n   o  LOOKUP \"path\"\n
        \  o  GETFH\n   o  GETATTR(fsid, fileid, size, time_modify)\n   Under the
        given circumstances, the following will be the result:\n   o  PUTROOTFH -->
        NFS_OK.  The current fh is now the root of the\n      pseudo-fs.\n   o  LOOKUP
        \"this\" --> NFS_OK.  The current fh is for /this and is\n      within the
        pseudo-fs.\n   o  LOOKUP \"is\" --> NFS_OK.  The current fh is for /this/is
        and is\n      within the pseudo-fs.\n   o  LOOKUP \"the\" --> NFS_OK.  The
        current fh is for /this/is/the and\n      is within the pseudo-fs.\n   o  LOOKUP
        \"path\" --> NFS_OK.  The current fh is for /this/is/the/path\n      and is
        within a new, absent file system, but ... the client will\n      never see
        the value of that fh.\n   o  GETFH --> NFS4ERR_MOVED.  Fails, because the
        current fh is in an\n      absent file system at the start of the operation
        and the\n      specification makes no exception for GETFH.\n   o  GETATTR(fsid,
        fileid, size, time_modify).  Not executed, because\n      the failure of the
        GETFH stops the processing of the COMPOUND.\n   Given the failure of the GETFH,
        the client has the job of determining\n   the root of the absent file system
        and where to find that file\n   system, i.e., the server and path relative
        to that server's root fh.\n   Note here that in this example, the client did
        not obtain filehandles\n   and attribute information (e.g., fsid) for the
        intermediate\n   directories, so that it would not be sure where the absent
        file\n   system starts.  It could be the case, for example, that /this/is/the\n
        \  is the root of the moved file system and that the reason that the\n   lookup
        of \"path\" succeeded is that the file system was not absent on\n   that operation
        but was moved between the last LOOKUP and the GETFH\n   (since COMPOUND is
        not atomic).  Even if we had the fsids for all of\n   the intermediate directories,
        we could have no way of knowing that\n   /this/is/the/path was the root of
        a new file system, since we don't\n   yet have its fsid.\n   In order to get
        the necessary information, let us re-send the chain\n   of LOOKUPs with GETFHs
        and GETATTRs to at least get the fsids so we\n   can be sure where the appropriate
        file system boundaries are.  The\n   client could choose to get fs_locations
        at the same time, but in most\n   cases the client will have a good guess
        as to where the file system\n   boundaries are (because of where NFS4ERR_MOVED
        was, and was not,\n   received), making the fetching of fs_locations unnecessary.\n
        \  OP01:  PUTROOTFH --> NFS_OK\n   -  The current fh is at the root of the
        pseudo-fs.\n   OP02:  GETATTR(fsid) --> NFS_OK\n   -  Just for completeness.
        \ Normally, clients will know the fsid of\n      the pseudo-fs as soon as
        they establish communication with a\n      server.\n   OP03:  LOOKUP \"this\"
        --> NFS_OK\n   OP04:  GETATTR(fsid) --> NFS_OK\n   -  Get the current fsid
        to see where the file system boundaries are.\n      The fsid will be that
        for the pseudo-fs in this example, so no\n      boundary.\n   OP05:  GETFH
        --> NFS_OK\n   -  The current fh is for /this and is within the pseudo-fs.\n
        \  OP06:  LOOKUP \"is\" --> NFS_OK\n   -  The current fh is for /this/is and
        is within the pseudo-fs.\n   OP07:  GETATTR(fsid) --> NFS_OK\n   -  Get the
        current fsid to see where the file system boundaries are.\n      The fsid
        will be that for the pseudo-fs in this example, so no\n      boundary.\n   OP08:
        \ GETFH --> NFS_OK\n   -  The current fh is for /this/is and is within the
        pseudo-fs.\n   OP09:  LOOKUP \"the\" --> NFS_OK\n   -  The current fh is for
        /this/is/the and is within the pseudo-fs.\n   OP10:  GETATTR(fsid) --> NFS_OK\n
        \  -  Get the current fsid to see where the file system boundaries are.\n
        \     The fsid will be that for the pseudo-fs in this example, so no\n      boundary.\n
        \  OP11:  GETFH --> NFS_OK\n   -  The current fh is for /this/is/the and is
        within the pseudo-fs.\n   OP12:  LOOKUP \"path\" --> NFS_OK\n   -  The current
        fh is for /this/is/the/path and is within a new,\n      absent file system,
        but ...\n   -  The client will never see the value of that fh.\n   OP13:  GETATTR(fsid,
        fs_locations) --> NFS_OK\n   -  We are getting the fsid to know where the
        file system boundaries\n      are.  In this operation, the fsid will be different
        than that of\n      the parent directory (which in turn was retrieved in OP10).
        \ Note\n      that the fsid we are given will not necessarily be preserved
        at\n      the new location.  That fsid might be different, and in fact the\n
        \     fsid we have for this file system might be a valid fsid of a\n      different
        file system on that new server.\n   -  In this particular case, we are pretty
        sure anyway that what has\n      moved is /this/is/the/path rather than /this/is/the
        since we have\n      the fsid of the latter and it is that of the pseudo-fs,
        which\n      presumably cannot move.  However, in other examples, we might
        not\n      have this kind of information to rely on (e.g., /this/is/the might\n
        \     be a non-pseudo-file system separate from /this/is/the/path), so\n      we
        need to have other reliable source information on the boundary\n      of the
        file system that is moved.  If, for example, the file\n      system /this/is
        had moved, we would have a case of migration\n      rather than referral,
        and once the boundaries of the migrated file\n      system were clear we could
        fetch fs_locations.\n   -  We are fetching fs_locations because the fact that
        we got an\n      NFS4ERR_MOVED at this point means that this is most likely
        a\n      referral and we need the destination.  Even if it is the case that\n
        \     /this/is/the is a file system that has migrated, we will still\n      need
        the location information for that file system.\n   OP14:  GETFH --> NFS4ERR_MOVED\n
        \  -  Fails because current fh is in an absent file system at the start\n
        \     of the operation, and the specification makes no exception for\n      GETFH.
        \ Note that this means the server will never send the client\n      a filehandle
        from within an absent file system.\n   Given the above, the client knows where
        the root of the absent file\n   system is (/this/is/the/path) by noting where
        the change of fsid\n   occurred (between \"the\" and \"path\").  The fs_locations
        attribute also\n   gives the client the actual location of the absent file
        system so\n   that the referral can proceed.  The server gives the client
        the bare\n   minimum of information about the absent file system so that there\n
        \  will be very little scope for problems of conflict between\n   information
        sent by the referring server and information of the file\n   system's home.
        \ No filehandles and very few attributes are present on\n   the referring
        server, and the client can treat those it receives as\n   transient information
        with the function of enabling the referral.\n"
      title: 8.7.1.  Referral Example (LOOKUP)
    - contents:
      - "8.7.2.  Referral Example (READDIR)\n   Another context in which a client
        may encounter referrals is when it\n   does a READDIR on a directory in which
        some of the subdirectories are\n   the roots of absent file systems.\n   Suppose
        such a directory is read as follows:\n   o  PUTROOTFH\n   o  LOOKUP \"this\"\n
        \  o  LOOKUP \"is\"\n   o  LOOKUP \"the\"\n   o  READDIR(fsid, size, time_modify,
        mounted_on_fileid)\n   In this case, because rdattr_error is not requested,
        fs_locations is\n   not requested, and some of the attributes cannot be provided,
        the\n   result will be an NFS4ERR_MOVED error on the READDIR, with the\n   detailed
        results as follows:\n   o  PUTROOTFH --> NFS_OK.  The current fh is at the
        root of the\n      pseudo-fs.\n   o  LOOKUP \"this\" --> NFS_OK.  The current
        fh is for /this and is\n      within the pseudo-fs.\n   o  LOOKUP \"is\" -->
        NFS_OK.  The current fh is for /this/is and is\n      within the pseudo-fs.\n
        \  o  LOOKUP \"the\" --> NFS_OK.  The current fh is for /this/is/the and\n
        \     is within the pseudo-fs.\n   o  READDIR(fsid, size, time_modify, mounted_on_fileid)
        -->\n      NFS4ERR_MOVED.  Note that the same error would have been returned\n
        \     if /this/is/the had migrated, but it is returned because the\n      directory
        contains the root of an absent file system.\n   So now suppose that we re-send
        with rdattr_error:\n   o  PUTROOTFH\n   o  LOOKUP \"this\"\n   o  LOOKUP \"is\"\n
        \  o  LOOKUP \"the\"\n   o  READDIR(rdattr_error, fsid, size, time_modify,
        mounted_on_fileid)\n   The results will be:\n   o  PUTROOTFH --> NFS_OK.  The
        current fh is at the root of the\n      pseudo-fs.\n   o  LOOKUP \"this\"
        --> NFS_OK.  The current fh is for /this and is\n      within the pseudo-fs.\n
        \  o  LOOKUP \"is\" --> NFS_OK.  The current fh is for /this/is and is\n      within
        the pseudo-fs.\n   o  LOOKUP \"the\" --> NFS_OK.  The current fh is for /this/is/the
        and\n      is within the pseudo-fs.\n   o  READDIR(rdattr_error, fsid, size,
        time_modify, mounted_on_fileid)\n      --> NFS_OK.  The attributes for the
        directory entry with the\n      component named \"path\" will only contain
        rdattr_error with the\n      value NFS4ERR_MOVED, together with an fsid value
        and a value for\n      mounted_on_fileid.\n   So suppose we do another READDIR
        to get fs_locations (although we\n   could have used a GETATTR directly, as
        in Section 8.7.1):\n   o  PUTROOTFH\n   o  LOOKUP \"this\"\n   o  LOOKUP \"is\"\n
        \  o  LOOKUP \"the\"\n   o  READDIR(rdattr_error, fs_locations, mounted_on_fileid,
        fsid, size,\n      time_modify)\n   The results would be:\n   o  PUTROOTFH
        --> NFS_OK.  The current fh is at the root of the\n      pseudo-fs.\n   o
        \ LOOKUP \"this\" --> NFS_OK.  The current fh is for /this and is\n      within
        the pseudo-fs.\n   o  LOOKUP \"is\" --> NFS_OK.  The current fh is for /this/is
        and is\n      within the pseudo-fs.\n   o  LOOKUP \"the\" --> NFS_OK.  The
        current fh is for /this/is/the and\n      is within the pseudo-fs.\n   o  READDIR(rdattr_error,
        fs_locations, mounted_on_fileid, fsid, size,\n      time_modify) --> NFS_OK.
        \ The attributes will be as shown below.\n   The attributes for the directory
        entry with the component named\n   \"path\" will only contain:\n   o  rdattr_error
        (value: NFS_OK)\n   o  fs_locations\n   o  mounted_on_fileid (value: unique
        fileid within referring file\n      system)\n   o  fsid (value: unique value
        within referring server)\n   The attributes for entry \"path\" will not contain
        size or time_modify,\n   because these attributes are not available within
        an absent file\n   system.\n"
      title: 8.7.2.  Referral Example (READDIR)
    title: 8.7.  Effecting File System Referrals
  - contents:
    - "8.8.  The Attribute fs_locations\n   The fs_locations attribute is defined
      by both fs_location4\n   (Section 2.2.6) and fs_locations4 (Section 2.2.7).
      \ It is used to\n   represent the location of a file system by providing a server
      name\n   and the path to the root of the file system within that server's\n
      \  namespace.  When a set of servers have corresponding file systems at\n   the
      same path within their namespaces, an array of server names may\n   be provided.
      \ An entry in the server array is a UTF-8 string and\n   represents one of a
      traditional DNS host name, IPv4 address, IPv6\n   address, or a zero-length
      string.  A zero-length string SHOULD be\n   used to indicate the current address
      being used for the RPC.  It is\n   not a requirement that all servers that share
      the same rootpath be\n   listed in one fs_location4 instance.  The array of
      server names is\n   provided for convenience.  Servers that share the same rootpath
      may\n   also be listed in separate fs_location4 entries in the fs_locations\n
      \  attribute.\n   The fs_locations4 data type and fs_locations attribute contain
      an\n   array of such locations.  Since the namespace of each server may be\n
      \  constructed differently, the fs_root field is provided.  The path\n   represented
      by the fs_root represents the location of the file system\n   in the current
      server's namespace, i.e., that of the server from\n   which the fs_locations
      attribute was obtained.  The fs_root path is\n   meant to aid the client by
      clearly referencing the root of the file\n   system whose locations are being
      reported, no matter what object\n   within the current file system the current
      filehandle designates.\n   The fs_root is simply the pathname the client used
      to reach the\n   object on the current server (i.e., the object to which the\n
      \  fs_locations attribute applies).\n   When the fs_locations attribute is interrogated
      and there are no\n   alternative file system locations, the server SHOULD return
      a\n   zero-length array of fs_location4 structures, together with a\n   valid
      fs_root.\n   As an example, suppose there is a replicated file system located
      at\n   two servers (servA and servB).  At servA, the file system is located\n
      \  at path /a/b/c.  At servB, the file system is located at path /x/y/z.\n   If
      the client were to obtain the fs_locations value for the directory\n   at /a/b/c/d,
      it might not necessarily know that the file system's\n   root is located in
      servA's namespace at /a/b/c.  When the client\n   switches to servB, it will
      need to determine that the directory it\n   first referenced at servA is now
      represented by the path /x/y/z/d\n   on servB.  To facilitate this, the fs_locations
      attribute provided by\n   servA would have an fs_root value of /a/b/c and two
      entries in\n   fs_locations.  One entry in fs_locations will be for itself (servA),\n
      \  and the other will be for servB with a path of /x/y/z.  With this\n   information,
      the client is able to substitute /x/y/z for /a/b/c at\n   the beginning of its
      access path and construct /x/y/z/d to use for\n   the new server.\n   Note that
      there is no requirement that the number of components in\n   each rootpath be
      the same; there is no relation between the number of\n   components in the rootpath
      or fs_root, and none of the components in\n   each rootpath and fs_root have
      to be the same.  In the above example,\n   we could have had a third element
      in the locations array, with server\n   equal to \"servC\" and rootpath equal
      to \"/I/II\", and a fourth element\n   in the locations array, with server equal
      to \"servD\" and rootpath\n   equal to \"/aleph/beth/gimel/daleth/he\".\n   The
      relationship between an fs_root and a rootpath is that the client\n   replaces
      the pathname indicated in the fs_root for the current server\n   for the substitute
      indicated in the rootpath for the new server.\n   For an example of a referred
      or migrated file system, suppose there\n   is a file system located at serv1.
      \ At serv1, the file system is\n   located at /az/buky/vedi/glagoli.  The client
      finds that the object\n   at glagoli has migrated (or is a referral).  The client
      gets the\n   fs_locations attribute, which contains an fs_root of /az/buky/vedi/\n
      \  glagoli, and one element in the locations array, with server equal to\n   serv2,
      and rootpath equal to /izhitsa/fita.  The client replaces\n   /az/buky/vedi/glagoli
      with /izhitsa/fita and uses the latter pathname\n   on serv2.\n   Thus, the
      server MUST return an fs_root that is equal to the path the\n   client used
      to reach the object to which the fs_locations attribute\n   applies.  Otherwise,
      the client cannot determine the new path to use\n   on the new server.\n"
    title: 8.8.  The Attribute fs_locations
  title: 8.  Multi-Server Namespace
- contents:
  - "9.  File Locking and Share Reservations\n   Integrating locking into the NFS
    protocol necessarily causes it to be\n   stateful.  With the inclusion of share
    reservations, the protocol\n   becomes substantially more dependent on state than
    the traditional\n   combination of NFS and NLM (Network Lock Manager) [xnfs].
    \ There are\n   three components to making this state manageable:\n   o  clear
    division between client and server\n   o  ability to reliably detect inconsistency
    in state between client\n      and server\n   o  simple and robust recovery mechanisms\n
    \  In this model, the server owns the state information.  The client\n   requests
    changes in locks, and the server responds with the changes\n   made.  Non-client-initiated
    changes in locking state are infrequent.\n   The client receives prompt notification
    of such changes and can\n   adjust its view of the locking state to reflect the
    server's changes.\n   Individual pieces of state created by the server and passed
    to the\n   client at its request are represented by 128-bit stateids.  These\n
    \  stateids may represent a particular open file, a set of byte-range\n   locks
    held by a particular owner, or a recallable delegation of\n   privileges to access
    a file in particular ways or at a particular\n   location.\n   In all cases, there
    is a transition from the most general information\n   that represents a client
    as a whole to the eventual lightweight\n   stateid used for most client and server
    locking interactions.  The\n   details of this transition will vary with the type
    of object, but it\n   always starts with a client ID.\n   To support Win32 share
    reservations, it is necessary to atomically\n   OPEN or CREATE files and apply
    the appropriate locks in the same\n   operation.  Having a separate share/unshare
    operation would not allow\n   correct implementation of the Win32 OpenFile API.
    \ In order to\n   correctly implement share semantics, the previous NFS protocol\n
    \  mechanisms used when a file is opened or created (LOOKUP, CREATE,\n   ACCESS)
    need to be replaced.  The NFSv4 protocol has an OPEN\n   operation that subsumes
    the NFSv3 methodology of LOOKUP, CREATE, and\n   ACCESS.  However, because many
    operations require a filehandle, the\n   traditional LOOKUP is preserved to map
    a filename to a filehandle\n   without establishing state on the server.  The
    policy of granting\n   access or modifying files is managed by the server based
    on the\n   client's state.  These mechanisms can implement policy ranging from\n
    \  advisory only locking to full mandatory locking.\n"
  - contents:
    - "9.1.  Opens and Byte-Range Locks\n   It is assumed that manipulating a byte-range
      lock is rare when\n   compared to READ and WRITE operations.  It is also assumed
      that\n   server restarts and network partitions are relatively rare.\n   Therefore,
      it is important that the READ and WRITE operations have a\n   lightweight mechanism
      to indicate if they possess a held lock.  A\n   byte-range lock request contains
      the heavyweight information required\n   to establish a lock and uniquely define
      the owner of the lock.\n   The following sections describe the transition from
      the heavyweight\n   information to the eventual stateid used for most client
      and server\n   locking and lease interactions.\n"
    - contents:
      - "9.1.1.  Client ID\n   For each LOCK request, the client must identify itself
        to the server.\n   This is done in such a way as to allow for correct lock\n
        \  identification and crash recovery.  A sequence of a SETCLIENTID\n   operation
        followed by a SETCLIENTID_CONFIRM operation is required to\n   establish the
        identification onto the server.  Establishment of\n   identification by a
        new incarnation of the client also has the effect\n   of immediately breaking
        any leased state that a previous incarnation\n   of the client might have
        had on the server, as opposed to forcing the\n   new client incarnation to
        wait for the leases to expire.  Breaking\n   the lease state amounts to the
        server removing all lock, share\n   reservation, and, where the server is
        not supporting the\n   CLAIM_DELEGATE_PREV claim type, all delegation state
        associated with\n   the same client with the same identity.  For a discussion
        of\n   delegation state recovery, see Section 10.2.1.\n   Owners of opens
        and owners of byte-range locks are separate entities\n   and remain separate
        even if the same opaque arrays are used to\n   designate owners of each.  The
        protocol distinguishes between\n   open-owners (represented by open_owner4
        structures) and lock-owners\n   (represented by lock_owner4 structures).\n
        \  Both sorts of owners consist of a clientid and an opaque owner\n   string.
        \ For each client, the set of distinct owner values used with\n   that client
        constitutes the set of owners of that type, for the given\n   client.\n   Each
        open is associated with a specific open-owner, while each\n   byte-range lock
        is associated with a lock-owner and an open-owner,\n   the latter being the
        open-owner associated with the open file under\n   which the LOCK operation
        was done.\n   Client identification is encapsulated in the following structure:\n
        \  struct nfs_client_id4 {\n           verifier4       verifier;\n           opaque
        \         id<NFS4_OPAQUE_LIMIT>;\n   };\n   The first field, verifier, is
        a client incarnation verifier that is\n   used to detect client reboots.  Only
        if the verifier is different\n   from that which the server has previously
        recorded for the client (as\n   identified by the second field of the structure,
        id) does the server\n   start the process of canceling the client's leased
        state.\n   The second field, id, is a variable-length string that uniquely\n
        \  defines the client.\n   There are several considerations for how the client
        generates the id\n   string:\n   o  The string should be unique so that multiple
        clients do not\n      present the same string.  The consequences of two clients\n
        \     presenting the same string range from one client getting an error\n
        \     to one client having its leased state abruptly and unexpectedly\n      canceled.\n
        \  o  The string should be selected so the subsequent incarnations\n      (e.g.,
        reboots) of the same client cause the client to present the\n      same string.
        \ The implementer is cautioned against an approach\n      that requires the
        string to be recorded in a local file because\n      this precludes the use
        of the implementation in an environment\n      where there is no local disk
        and all file access is from an NFSv4\n      server.\n   o  The string should
        be different for each server network address\n      that the client accesses,
        rather than common to all server network\n      addresses.  The reason is
        that it may not be possible for the\n      client to tell if the same server
        is listening on multiple network\n      addresses.  If the client issues SETCLIENTID
        with the same id\n      string to each network address of such a server, the
        server will\n      think it is the same client, and each successive SETCLIENTID
        will\n      cause the server to begin the process of removing the client's\n
        \     previous leased state.\n   o  The algorithm for generating the string
        should not assume that the\n      client's network address won't change.  This
        includes changes\n      between client incarnations and even changes while
        the client is\n      still running in its current incarnation.  This means
        that if the\n      client includes just the client's and server's network
        address in\n      the id string, there is a real risk, after the client gives
        up the\n      network address, that another client, using a similar algorithm\n
        \     for generating the id string, will generate a conflicting id\n      string.\n
        \  Given the above considerations, an example of a well-generated id\n   string
        is one that includes:\n   o  The server's network address.\n   o  The client's
        network address.\n   o  For a user-level NFSv4 client, it should contain additional\n
        \     information to distinguish the client from other user-level\n      clients
        running on the same host, such as a universally unique\n      identifier (UUID).\n
        \  o  Additional information that tends to be unique, such as one or\n      more
        of:\n      *  The client machine's serial number (for privacy reasons, it
        is\n         best to perform some one-way function on the serial number).\n
        \     *  A MAC address (for privacy reasons, it is best to perform some\n
        \        one-way function on the MAC address).\n      *  The timestamp of
        when the NFSv4 software was first installed on\n         the client (though
        this is subject to the previously mentioned\n         caution about using
        information that is stored in a file,\n         because the file might only
        be accessible over NFSv4).\n      *  A true random number.  However, since
        this number ought to be\n         the same between client incarnations, this
        shares the same\n         problem as that of using the timestamp of the software\n
        \        installation.\n   As a security measure, the server MUST NOT cancel
        a client's leased\n   state if the principal that established the state for
        a given id\n   string is not the same as the principal issuing the SETCLIENTID.\n
        \  Note that SETCLIENTID (Section 16.33) and SETCLIENTID_CONFIRM\n   (Section
        16.34) have a secondary purpose of establishing the\n   information the server
        needs to make callbacks to the client for the\n   purpose of supporting delegations.
        \ It is permitted to change this\n   information via SETCLIENTID and SETCLIENTID_CONFIRM
        within the same\n   incarnation of the client without removing the client's
        leased state.\n   Once a SETCLIENTID and SETCLIENTID_CONFIRM sequence has
        successfully\n   completed, the client uses the shorthand client identifier,
        of type\n   clientid4, instead of the longer and less compact nfs_client_id4\n
        \  structure.  This shorthand client identifier (a client ID) is\n   assigned
        by the server and should be chosen so that it will not\n   conflict with a
        client ID previously assigned by the server.  This\n   applies across server
        restarts or reboots.  When a client ID is\n   presented to a server and that
        client ID is not recognized, as would\n   happen after a server reboot, the
        server will reject the request with\n   the error NFS4ERR_STALE_CLIENTID.
        \ When this happens, the client must\n   obtain a new client ID by use of
        the SETCLIENTID operation and then\n   proceed to any other necessary recovery
        for the server reboot case\n   (see Section 9.6.2).\n   The client must also
        employ the SETCLIENTID operation when it\n   receives an NFS4ERR_STALE_STATEID
        error using a stateid derived from\n   its current client ID, since this also
        indicates a server reboot,\n   which has invalidated the existing client ID
        (see Section 9.6.2 for\n   details).\n   See the detailed descriptions of
        SETCLIENTID (Section 16.33.4) and\n   SETCLIENTID_CONFIRM (Section 16.34.4)
        for a complete specification of\n   the operations.\n"
      title: 9.1.1.  Client ID
    - contents:
      - "9.1.2.  Server Release of Client ID\n   If the server determines that the
        client holds no associated state\n   for its client ID, the server may choose
        to release the client ID.\n   The server may make this choice for an inactive
        client so that\n   resources are not consumed by those intermittently active
        clients.\n   If the client contacts the server after this release, the server
        must\n   ensure that the client receives the appropriate error so that it
        will\n   use the SETCLIENTID/SETCLIENTID_CONFIRM sequence to establish a new\n
        \  identity.  It should be clear that the server must be very hesitant\n   to
        release a client ID since the resulting work on the client to\n   recover
        from such an event will be the same burden as if the server\n   had failed
        and restarted.  Typically, a server would not release a\n   client ID unless
        there had been no activity from that client for many\n   minutes.\n   Note
        that if the id string in a SETCLIENTID request is properly\n   constructed,
        and if the client takes care to use the same principal\n   for each successive
        use of SETCLIENTID, then, barring an active\n   denial-of-service attack,
        NFS4ERR_CLID_INUSE should never be\n   returned.\n   However, client bugs,
        server bugs, or perhaps a deliberate change of\n   the principal owner of
        the id string (such as the case of a client\n   that changes security flavors,
        and under the new flavor there is no\n   mapping to the previous owner) will
        in rare cases result in\n   NFS4ERR_CLID_INUSE.\n   In that event, when the
        server gets a SETCLIENTID for a client ID\n   that currently has no state,
        or it has state but the lease has\n   expired, rather than returning NFS4ERR_CLID_INUSE,
        the server MUST\n   allow the SETCLIENTID and confirm the new client ID if
        followed by\n   the appropriate SETCLIENTID_CONFIRM.\n"
      title: 9.1.2.  Server Release of Client ID
    - contents:
      - "9.1.3.  Use of Seqids\n   In several contexts, 32-bit sequence values called
        \"seqids\" are used\n   as part of managing locking state.  Such values are
        used:\n   o  To provide an ordering of locking-related operations associated\n
        \     with a particular lock-owner or open-owner.  See Section 9.1.7 for\n
        \     a detailed explanation.\n   o  To define an ordered set of instances
        of a set of locks sharing a\n      particular set of ownership characteristics.
        \ See Section 9.1.4.2\n      for a detailed explanation.\n   Successive seqid
        values for the same object are normally arrived at\n   by incrementing the
        current value by one.  This pattern continues\n   until the seqid is incremented
        past NFS4_UINT32_MAX, in which case\n   one (rather than zero) is to be the
        next seqid value.\n   When two seqid values are to be compared to determine
        which of the\n   two is later, the possibility of wraparound needs to be considered.\n
        \  In many cases, the values are such that simple numeric comparisons\n   can
        be used.  For example, if the seqid values to be compared are\n   both less
        than one million, the higher value can be considered the\n   later.  On the
        other hand, if one of the values is at or near\n   NFS_UINT32_MAX and the
        other is less than one million, then\n   implementations can reasonably decide
        that the lower value has had\n   one more wraparound and is thus, while numerically
        lower, actually\n   later.\n   Implementations can compare seqids in the presence
        of potential\n   wraparound by adopting the reasonable assumption that the
        chain of\n   increments from one to the other is shorter than 2**31.  So,
        if the\n   difference between the two seqids is less than 2**31, then the
        lower\n   seqid is to be treated as earlier.  If, however, the difference\n
        \  between the two seqids is greater than or equal to 2**31, then it can\n
        \  be assumed that the lower seqid has encountered one more wraparound\n   and
        can be treated as later.\n"
      title: 9.1.3.  Use of Seqids
    - contents:
      - "9.1.4.  Stateid Definition\n   When the server grants a lock of any type
        (including opens,\n   byte-range locks, and delegations), it responds with
        a unique stateid\n   that represents a set of locks (often a single lock)
        for the same\n   file, of the same type, and sharing the same ownership\n
        \  characteristics.  Thus, opens of the same file by different\n   open-owners
        each have an identifying stateid.  Similarly, each set of\n   byte-range locks
        on a file owned by a specific lock-owner has its own\n   identifying stateid.
        \ Delegations also have associated stateids by\n   which they may be referenced.
        \ The stateid is used as a shorthand\n   reference to a lock or set of locks,
        and given a stateid, the server\n   can determine the associated state-owner
        or state-owners (in the case\n   of an open-owner/lock-owner pair) and the
        associated filehandle.\n   When stateids are used, the current filehandle
        must be the one\n   associated with that stateid.\n   All stateids associated
        with a given client ID are associated with a\n   common lease that represents
        the claim of those stateids and the\n   objects they represent to be maintained
        by the server.  See\n   Section 9.5 for a discussion of the lease.\n   Each
        stateid must be unique to the server.  Many operations take a\n   stateid
        as an argument but not a clientid, so the server must be able\n   to infer
        the client from the stateid.\n"
      - contents:
        - "9.1.4.1.  Stateid Types\n   With the exception of special stateids (see
          Section 9.1.4.3), each\n   stateid represents locking objects of one of
          a set of types defined\n   by the NFSv4 protocol.  Note that in all these
          cases, where we speak\n   of a guarantee, it is understood there are situations
          such as a\n   client restart, or lock revocation, that allow the guarantee
          to be\n   voided.\n   o  Stateids may represent opens of files.\n      Each
          stateid in this case represents the OPEN state for a given\n      client
          ID/open-owner/filehandle triple.  Such stateids are subject\n      to change
          (with consequent incrementing of the stateid's seqid) in\n      response
          to OPENs that result in upgrade and OPEN_DOWNGRADE\n      operations.\n
          \  o  Stateids may represent sets of byte-range locks.\n      All locks
          held on a particular file by a particular owner and all\n      gotten under
          the aegis of a particular open file are associated\n      with a single
          stateid, with the seqid being incremented whenever\n      LOCK and LOCKU
          operations affect that set of locks.\n   o  Stateids may represent file
          delegations, which are recallable\n      guarantees by the server to the
          client that other clients will not\n      reference, or will not modify,
          a particular file until the\n      delegation is returned.\n      A stateid
          represents a single delegation held by a client for a\n      particular
          filehandle.\n"
        title: 9.1.4.1.  Stateid Types
      - contents:
        - "9.1.4.2.  Stateid Structure\n   Stateids are divided into two fields: a
          96-bit \"other\" field\n   identifying the specific set of locks and a 32-bit
          \"seqid\" sequence\n   value.  Except in the case of special stateids (see
          Section 9.1.4.3),\n   a particular value of the \"other\" field denotes
          a set of locks of the\n   same type (for example, byte-range locks, opens,
          or delegations), for\n   a specific file or directory, and sharing the same
          ownership\n   characteristics.  The seqid designates a specific instance
          of such a\n   set of locks, and is incremented to indicate changes in such
          a set of\n   locks, by either the addition or deletion of locks from the
          set, a\n   change in the byte-range they apply to, or an upgrade or downgrade
          in\n   the type of one or more locks.\n   When such a set of locks is first
          created, the server returns a\n   stateid with a seqid value of one.  On
          subsequent operations that\n   modify the set of locks, the server is required
          to advance the\n   seqid field by one whenever it returns a stateid for
          the same\n   state-owner/file/type combination and the operation is one
          that might\n   make some change in the set of locks actually designated.
          \ In this\n   case, the server will return a stateid with an \"other\" field
          the same\n   as previously used for that state-owner/file/type combination,
          with\n   an incremented seqid field.\n   Seqids will be compared, by both
          the client and the server.  The\n   client uses such comparisons to determine
          the order of operations,\n   while the server uses them to determine whether
          the\n   NFS4ERR_OLD_STATEID error is to be returned.  In all cases, the\n
          \  possibility of seqid wraparound needs to be taken into account, as\n
          \  discussed in Section 9.1.3.\n"
        title: 9.1.4.2.  Stateid Structure
      - contents:
        - "9.1.4.3.  Special Stateids\n   Stateid values whose \"other\" field is
          either all zeros or all ones\n   are reserved.  They MUST NOT be assigned
          by the server but have\n   special meanings defined by the protocol.  The
          particular meaning\n   depends on whether the \"other\" field is all zeros
          or all ones and the\n   specific value of the seqid field.\n   The following
          combinations of \"other\" and seqid are defined in NFSv4:\n   Anonymous
          Stateid:  When \"other\" and seqid are both zero, the stateid\n      is
          treated as a special anonymous stateid, which can be used in\n      READ,
          WRITE, and SETATTR requests to indicate the absence of any\n      open state
          associated with the request.  When an anonymous stateid\n      value is
          used, and an existing open denies the form of access\n      requested, then
          access will be denied to the request.\n   READ Bypass Stateid:  When \"other\"
          and seqid are both all ones, the\n      stateid is a special READ bypass
          stateid.  When this value is used\n      in WRITE or SETATTR, it is treated
          like the anonymous value.  When\n      used in READ, the server MAY grant
          access, even if access would\n      normally be denied to READ requests.\n
          \  If a stateid value is used that has all zeros or all ones in the\n   \"other\"
          field but does not match one of the cases above, the server\n   MUST return
          the error NFS4ERR_BAD_STATEID.\n   Special stateids, unlike other stateids,
          are not associated with\n   individual client IDs or filehandles and can
          be used with all valid\n   client IDs and filehandles.\n"
        title: 9.1.4.3.  Special Stateids
      - contents:
        - "9.1.4.4.  Stateid Lifetime and Validation\n   Stateids must remain valid
          until either a client restart or a server\n   restart, or until the client
          returns all of the locks associated with\n   the stateid by means of an
          operation such as CLOSE or DELEGRETURN.\n   If the locks are lost due to
          revocation, as long as the client ID is\n   valid, the stateid remains a
          valid designation of that revoked state.\n   Stateids associated with byte-range
          locks are an exception.  They\n   remain valid even if a LOCKU frees all
          remaining locks, so long as\n   the open file with which they are associated
          remains open.\n   It should be noted that there are situations in which
          the client's\n   locks become invalid, without the client requesting they
          be returned.\n   These include lease expiration and a number of forms of
          lock\n   revocation within the lease period.  It is important to note that
          in\n   these situations, the stateid remains valid and the client can use
          it\n   to determine the disposition of the associated lost locks.\n   An
          \"other\" value must never be reused for a different purpose (i.e.,\n   different
          filehandle, owner, or type of locks) within the context of\n   a single
          client ID.  A server may retain the \"other\" value for the\n   same purpose
          beyond the point where it may otherwise be freed, but if\n   it does so,
          it must maintain seqid continuity with previous values.\n   One mechanism
          that may be used to satisfy the requirement that the\n   server recognize
          invalid and out-of-date stateids is for the server\n   to divide the \"other\"
          field of the stateid into two fields:\n   o  An index into a table of locking-state
          structures.\n   o  A generation number that is incremented on each allocation
          of a\n      table entry for a particular use.\n   And then store the following
          in each table entry:\n   o  The client ID with which the stateid is associated.\n
          \  o  The current generation number for the (at most one) valid stateid\n
          \     sharing this index value.\n   o  The filehandle of the file on which
          the locks are taken.\n   o  An indication of the type of stateid (open,
          byte-range lock, file\n      delegation).\n   o  The last seqid value returned
          corresponding to the current \"other\"\n      value.\n   o  An indication
          of the current status of the locks associated with\n      this stateid --
          in particular, whether these have been revoked\n      and, if so, for what
          reason.\n   With this information, an incoming stateid can be validated
          and the\n   appropriate error returned when necessary.  Special and non-special\n
          \  stateids are handled separately.  (See Section 9.1.4.3 for a\n   discussion
          of special stateids.)\n   When a stateid is being tested, and the \"other\"
          field is all zeros or\n   all ones, a check that the \"other\" and seqid
          fields match a defined\n   combination for a special stateid is done and
          the results determined\n   as follows:\n   o  If the \"other\" and seqid
          fields do not match a defined combination\n      associated with a special
          stateid, the error NFS4ERR_BAD_STATEID\n      is returned.\n   o  If the
          combination is valid in general but is not appropriate to\n      the context
          in which the stateid is used (e.g., an all-zero\n      stateid is used when
          an open stateid is required in a LOCK\n      operation), the error NFS4ERR_BAD_STATEID
          is also returned.\n   o  Otherwise, the check is completed and the special
          stateid is\n      accepted as valid.\n   When a stateid is being tested,
          and the \"other\" field is neither all\n   zeros nor all ones, the following
          procedure could be used to validate\n   an incoming stateid and return an
          appropriate error, when necessary,\n   assuming that the \"other\" field
          would be divided into a table index\n   and an entry generation.  Note that
          the terms \"earlier\" and \"later\"\n   used in connection with seqid comparison
          are to be understood as\n   explained in Section 9.1.3.\n   o  If the table
          index field is outside the range of the associated\n      table, return
          NFS4ERR_BAD_STATEID.\n   o  If the selected table entry is of a different
          generation than that\n      specified in the incoming stateid, return NFS4ERR_BAD_STATEID.\n
          \  o  If the selected table entry does not match the current filehandle,\n
          \     return NFS4ERR_BAD_STATEID.\n   o  If the stateid represents revoked
          state or state lost as a result\n      of lease expiration, then return
          NFS4ERR_EXPIRED,\n      NFS4ERR_BAD_STATEID, or NFS4ERR_ADMIN_REVOKED, as
          appropriate.\n   o  If the stateid type is not valid for the context in
          which the\n      stateid appears, return NFS4ERR_BAD_STATEID.  Note that
          a stateid\n      may be valid in general but invalid for a particular operation,\n
          \     as, for example, when a stateid that doesn't represent byte-range\n
          \     locks is passed to the non-from_open case of LOCK or to LOCKU, or\n
          \     when a stateid that does not represent an open is passed to CLOSE\n
          \     or OPEN_DOWNGRADE.  In such cases, the server MUST return\n      NFS4ERR_BAD_STATEID.\n
          \  o  If the seqid field is not zero and it is later than the current\n
          \     sequence value corresponding to the current \"other\" field, return\n
          \     NFS4ERR_BAD_STATEID.\n   o  If the seqid field is earlier than the
          current sequence value\n      corresponding to the current \"other\" field,
          return\n      NFS4ERR_OLD_STATEID.\n   o  Otherwise, the stateid is valid,
          and the table entry should\n      contain any additional information about
          the type of stateid and\n      information associated with that particular
          type of stateid, such\n      as the associated set of locks (e.g., open-owner
          and lock-owner\n      information), as well as information on the specific
          locks\n      themselves, such as open modes and byte ranges.\n"
        title: 9.1.4.4.  Stateid Lifetime and Validation
      - contents:
        - "9.1.4.5.  Stateid Use for I/O Operations\n   Clients performing Input/Output
          (I/O) operations need to select an\n   appropriate stateid based on the
          locks (including opens and\n   delegations) held by the client and the various
          types of state-owners\n   sending the I/O requests.  SETATTR operations
          that change the file\n   size are treated like I/O operations in this regard.\n
          \  The following rules, applied in order of decreasing priority, govern\n
          \  the selection of the appropriate stateid.  In following these rules,\n
          \  the client will only consider locks of which it has actually received\n
          \  notification by an appropriate operation response or callback.\n   o
          \ If the client holds a delegation for the file in question, the\n      delegation
          stateid SHOULD be used.\n   o  Otherwise, if the entity corresponding to
          the lock-owner (e.g., a\n      process) sending the I/O has a byte-range
          lock stateid for the\n      associated open file, then the byte-range lock
          stateid for that\n      lock-owner and open file SHOULD be used.\n   o  If
          there is no byte-range lock stateid, then the OPEN stateid for\n      the
          current open-owner, i.e., the OPEN stateid for the open file\n      in question,
          SHOULD be used.\n   o  Finally, if none of the above apply, then a special
          stateid SHOULD\n      be used.\n   Ignoring these rules may result in situations
          in which the server\n   does not have information necessary to properly
          process the request.\n   For example, when mandatory byte-range locks are
          in effect, if the\n   stateid does not indicate the proper lock-owner, via
          a lock stateid,\n   a request might be avoidably rejected.\n   The server,
          however, should not try to enforce these ordering rules\n   and should use
          whatever information is available to properly process\n   I/O requests.
          \ In particular, when a client has a delegation for a\n   given file, it
          SHOULD take note of this fact in processing a request,\n   even if it is
          sent with a special stateid.\n"
        title: 9.1.4.5.  Stateid Use for I/O Operations
      - contents:
        - "9.1.4.6.  Stateid Use for SETATTR Operations\n   In the case of SETATTR
          operations, a stateid is present.  In cases\n   other than those that set
          the file size, the client may send either a\n   special stateid or, when
          a delegation is held for the file in\n   question, a delegation stateid.
          \ While the server SHOULD validate the\n   stateid and may use the stateid
          to optimize the determination as to\n   whether a delegation is held, it
          SHOULD note the presence of a\n   delegation even when a special stateid
          is sent, and MUST accept a\n   valid delegation stateid when sent.\n"
        title: 9.1.4.6.  Stateid Use for SETATTR Operations
      title: 9.1.4.  Stateid Definition
    - contents:
      - "9.1.5.  Lock-Owner\n   When requesting a lock, the client must present to
        the server the\n   client ID and an identifier for the owner of the requested
        lock.\n   These two fields comprise the lock-owner and are defined as follows:\n
        \  o  A client ID returned by the server as part of the client's use of\n
        \     the SETCLIENTID operation.\n   o  A variable-length opaque array used
        to uniquely define the owner\n      of a lock managed by the client.\n      This
        may be a thread id, process id, or other unique value.\n   When the server
        grants the lock, it responds with a unique stateid.\n   The stateid is used
        as a shorthand reference to the lock-owner, since\n   the server will be maintaining
        the correspondence between them.\n"
      title: 9.1.5.  Lock-Owner
    - contents:
      - "9.1.6.  Use of the Stateid and Locking\n   All READ, WRITE, and SETATTR operations
        contain a stateid.  For the\n   purposes of this section, SETATTR operations
        that change the size\n   attribute of a file are treated as if they are writing
        the area\n   between the old and new size (i.e., the range truncated or added
        to\n   the file by means of the SETATTR), even where SETATTR is not\n   explicitly
        mentioned in the text.  The stateid passed to one of these\n   operations
        must be one that represents an OPEN (e.g., via the\n   open-owner), a set
        of byte-range locks, or a delegation, or it may be\n   a special stateid representing
        anonymous access or the READ bypass\n   stateid.\n   If the state-owner performs
        a READ or WRITE in a situation in which\n   it has established a lock or share
        reservation on the server (any\n   OPEN constitutes a share reservation),
        the stateid (previously\n   returned by the server) must be used to indicate
        what locks,\n   including both byte-range locks and share reservations, are
        held by\n   the state-owner.  If no state is established by the client --
        either\n   byte-range lock or share reservation -- the anonymous stateid is\n
        \  used.  Regardless of whether an anonymous stateid or a stateid\n   returned
        by the server is used, if there is a conflicting share\n   reservation or
        mandatory byte-range lock held on the file, the server\n   MUST refuse to
        service the READ or WRITE operation.\n   Share reservations are established
        by OPEN operations and by their\n   nature are mandatory in that when the
        OPEN denies READ or WRITE\n   operations, that denial results in such operations
        being rejected\n   with error NFS4ERR_LOCKED.  Byte-range locks may be implemented
        by\n   the server as either mandatory or advisory, or the choice of\n   mandatory
        or advisory behavior may be determined by the server on the\n   basis of the
        file being accessed (for example, some UNIX-based\n   servers support a \"mandatory
        lock bit\" on the mode attribute such\n   that if set, byte-range locks are
        required on the file before I/O is\n   possible).  When byte-range locks are
        advisory, they only prevent the\n   granting of conflicting lock requests
        and have no effect on READs or\n   WRITEs.  Mandatory byte-range locks, however,
        prevent conflicting I/O\n   operations.  When they are attempted, they are
        rejected with\n   NFS4ERR_LOCKED.  When the client gets NFS4ERR_LOCKED on
        a file it\n   knows it has the proper share reservation for, it will need
        to issue\n   a LOCK request on the region of the file that includes the region
        the\n   I/O was to be performed on, with an appropriate locktype (i.e.,\n
        \  READ*_LT for a READ operation, WRITE*_LT for a WRITE operation).\n   With
        NFSv3, there was no notion of a stateid, so there was no way to\n   tell if
        the application process of the client sending the READ or\n   WRITE operation
        had also acquired the appropriate byte-range lock on\n   the file.  Thus,
        there was no way to implement mandatory locking.\n   With the stateid construct,
        this barrier has been removed.\n   Note that for UNIX environments that support
        mandatory file locking,\n   the distinction between advisory and mandatory
        locking is subtle.  In\n   fact, advisory and mandatory byte-range locks are
        exactly the same\n   insofar as the APIs and requirements on implementation
        are concerned.\n   If the mandatory lock attribute is set on the file, the
        server checks\n   to see if the lock-owner has an appropriate shared (read)
        or\n   exclusive (write) byte-range lock on the region it wishes to read or\n
        \  write to.  If there is no appropriate lock, the server checks if\n   there
        is a conflicting lock (which can be done by attempting to\n   acquire the
        conflicting lock on behalf of the lock-owner and, if\n   successful, release
        the lock after the READ or WRITE is done), and if\n   there is, the server
        returns NFS4ERR_LOCKED.\n   For Windows environments, there are no advisory
        byte-range locks, so\n   the server always checks for byte-range locks during
        I/O requests.\n   Thus, the NFSv4 LOCK operation does not need to distinguish
        between\n   advisory and mandatory byte-range locks.  It is the NFSv4 server's\n
        \  processing of the READ and WRITE operations that introduces the\n   distinction.\n
        \  Every stateid other than the special stateid values noted in this\n   section,
        whether returned by an OPEN-type operation (i.e., OPEN,\n   OPEN_DOWNGRADE)
        or by a LOCK-type operation (i.e., LOCK or LOCKU),\n   defines an access mode
        for the file (i.e., READ, WRITE, or\n   READ-WRITE) as established by the
        original OPEN that began the\n   stateid sequence, and as modified by subsequent
        OPENs and\n   OPEN_DOWNGRADEs within that stateid sequence.  When a READ,
        WRITE, or\n   SETATTR that specifies the size attribute is done, the operation
        is\n   subject to checking against the access mode to verify that the\n   operation
        is appropriate given the OPEN with which the operation is\n   associated.\n
        \  In the case of WRITE-type operations (i.e., WRITEs and SETATTRs that\n
        \  set size), the server must verify that the access mode allows writing\n
        \  and return an NFS4ERR_OPENMODE error if it does not.  In the case of\n
        \  READ, the server may perform the corresponding check on the access\n   mode,
        or it may choose to allow READ on opens for WRITE only, to\n   accommodate
        clients whose write implementation may unavoidably do\n   reads (e.g., due
        to buffer cache constraints).  However, even if\n   READs are allowed in these
        circumstances, the server MUST still check\n   for locks that conflict with
        the READ (e.g., another open specifying\n   denial of READs).  Note that a
        server that does enforce the access\n   mode check on READs need not explicitly
        check for conflicting share\n   reservations since the existence of OPEN for
        read access guarantees\n   that no conflicting share reservation can exist.\n
        \  A READ bypass stateid MAY allow READ operations to bypass locking\n   checks
        at the server.  However, WRITE operations with a READ bypass\n   stateid MUST
        NOT bypass locking checks and are treated exactly the\n   same as if an anonymous
        stateid were used.\n   A lock may not be granted while a READ or WRITE operation
        using one\n   of the special stateids is being performed and the range of
        the lock\n   request conflicts with the range of the READ or WRITE operation.
        \ For\n   the purposes of this paragraph, a conflict occurs when a shared
        lock\n   is requested and a WRITE operation is being performed, or an\n   exclusive
        lock is requested and either a READ or a WRITE operation is\n   being performed.
        \ A SETATTR that sets size is treated similarly to a\n   WRITE as discussed
        above.\n"
      title: 9.1.6.  Use of the Stateid and Locking
    - contents:
      - "9.1.7.  Sequencing of Lock Requests\n   Locking is different than most NFS
        operations as it requires\n   \"at-most-one\" semantics that are not provided
        by ONC RPC.  ONC RPC\n   over a reliable transport is not sufficient because
        a sequence of\n   locking requests may span multiple TCP connections.  In
        the face of\n   retransmission or reordering, lock or unlock requests must
        have a\n   well-defined and consistent behavior.  To accomplish this, each
        lock\n   request contains a sequence number that is a consecutively increasing\n
        \  integer.  Different state-owners have different sequences.  The\n   server
        maintains the last sequence number (L) received and the\n   response that
        was returned.  The server SHOULD assign a seqid value\n   of one for the first
        request issued for any given state-owner.\n   Subsequent values are arrived
        at by incrementing the seqid value,\n   subject to wraparound as described
        in Section 9.1.3.\n   Note that for requests that contain a sequence number,
        for each\n   state-owner, there should be no more than one outstanding request.\n
        \  When a request is received, its sequence number (r) is compared to\n   that
        of the last one received (L).  Only if it has the correct next\n   sequence,
        normally L + 1, is the request processed beyond the point\n   of seqid checking.
        \ Given a properly functioning client, the response\n   to (r) must have been
        received before the last request (L) was sent.\n   If a duplicate of last
        request (r == L) is received, the stored\n   response is returned.  If the
        sequence value received is any other\n   value, it is rejected with the return
        of error NFS4ERR_BAD_SEQID.\n   Sequence history is reinitialized whenever
        the SETCLIENTID/\n   SETCLIENTID_CONFIRM sequence changes the client verifier.\n
        \  It is critical that the server maintain the last response sent to the\n
        \  client to provide a more reliable cache of duplicate non-idempotent\n   requests
        than that of the traditional cache described in [Chet].  The\n   traditional
        duplicate request cache uses a least recently used\n   algorithm for removing
        unneeded requests.  However, the last lock\n   request and response on a given
        state-owner must be cached as long as\n   the lock state exists on the server.\n
        \  The client MUST advance the sequence number for the CLOSE, LOCK,\n   LOCKU,
        OPEN, OPEN_CONFIRM, and OPEN_DOWNGRADE operations.  This is\n   true even
        in the event that the previous operation that used the\n   sequence number
        received an error.  The only exception to this rule\n   is if the previous
        operation received one of the following errors:\n   NFS4ERR_STALE_CLIENTID,
        NFS4ERR_STALE_STATEID, NFS4ERR_BAD_STATEID,\n   NFS4ERR_BAD_SEQID, NFS4ERR_BADXDR,
        NFS4ERR_RESOURCE,\n   NFS4ERR_NOFILEHANDLE, or NFS4ERR_MOVED.\n"
      title: 9.1.7.  Sequencing of Lock Requests
    - contents:
      - "9.1.8.  Recovery from Replayed Requests\n   As described above, the sequence
        number is per state-owner.  As long\n   as the server maintains the last sequence
        number received and follows\n   the methods described above, there are no
        risks of a Byzantine router\n   re-sending old requests.  The server need
        only maintain the\n   (state-owner, sequence number) state as long as there
        are open files\n   or closed files with locks outstanding.\n   LOCK, LOCKU,
        OPEN, OPEN_DOWNGRADE, and CLOSE each contain a sequence\n   number, and therefore
        the risk of the replay of these operations\n   resulting in undesired effects
        is non-existent while the server\n   maintains the state-owner state.\n"
      title: 9.1.8.  Recovery from Replayed Requests
    - contents:
      - "9.1.9.  Interactions of Multiple Sequence Values\n   Some operations may
        have multiple sources of data for request\n   sequence checking and retransmission
        determination.  Some operations\n   have multiple sequence values associated
        with multiple types of\n   state-owners.  In addition, such operations may
        also have a stateid\n   with its own seqid value, that will be checked for
        validity.\n   As noted above, there may be multiple sequence values to check.
        \ The\n   following rules should be followed by the server in processing these\n
        \  multiple sequence values within a single operation.\n   o  When a sequence
        value associated with a state-owner is unavailable\n      for checking because
        the state-owner is unknown to the server, it\n      takes no part in the comparison.\n
        \  o  When any of the state-owner sequence values are invalid,\n      NFS4ERR_BAD_SEQID
        is returned.  When a stateid sequence is\n      checked, NFS4ERR_BAD_STATEID
        or NFS4ERR_OLD_STATEID is returned as\n      appropriate, but NFS4ERR_BAD_SEQID
        has priority.\n   o  When any one of the sequence values matches a previous
        request,\n      for a state-owner, it is treated as a retransmission and not\n
        \     re-executed.  When the type of the operation does not match that\n      originally
        used, NFS4ERR_BAD_SEQID is returned.  When the server\n      can determine
        that the request differs from the original, it may\n      return NFS4ERR_BAD_SEQID.\n
        \  o  When multiple sequence values match previous operations but the\n      operations
        are not the same, NFS4ERR_BAD_SEQID is returned.\n   o  When there are no
        sequence values available for comparison and the\n      operation is an OPEN,
        the server indicates to the client that an\n      OPEN_CONFIRM is required,
        unless it can conclusively determine\n      that confirmation is not required
        (e.g., by knowing that no\n      open-owner state has ever been released for
        the current clientid).\n"
      title: 9.1.9.  Interactions of Multiple Sequence Values
    - contents:
      - "9.1.10.  Releasing State-Owner State\n   When a particular state-owner no
        longer holds open or file locking\n   state at the server, the server may
        choose to release the sequence\n   number state associated with the state-owner.
        \ The server may make\n   this choice based on lease expiration, the reclamation
        of server\n   memory, or other implementation-specific details.  Note that
        when\n   this is done, a retransmitted request, normally identified by a\n
        \  matching state-owner sequence, may not be correctly recognized, so\n   that
        the client will not receive the original response that it would\n   have if
        the state-owner state was not released.\n   If the server were able to be
        sure that a given state-owner would\n   never again be used by a client, such
        an issue could not arise.  Even\n   when the state-owner state is released
        and the client subsequently\n   uses that state-owner, retransmitted requests
        will be detected as\n   invalid and the request not executed, although the
        client may have a\n   recovery path that is more complicated than simply getting
        the\n   original response back transparently.\n   In any event, the server
        is able to safely release state-owner state\n   (in the sense that retransmitted
        requests will not be erroneously\n   acted upon) when the state-owner is not
        currently being utilized by\n   the client (i.e., there are no open files
        associated with an\n   open-owner and no lock stateids associated with a lock-owner).
        \ The\n   server may choose to hold the state-owner state in order to simplify\n
        \  the recovery path, in the case in which retransmissions of currently\n
        \  active requests are received.  However, the period for which it\n   chooses
        to hold this state is implementation specific.\n   In the case that a LOCK,
        LOCKU, OPEN_DOWNGRADE, or CLOSE is\n   retransmitted after the server has
        previously released the\n   state-owner state, the server will find that the
        state-owner has no\n   files open and an error will be returned to the client.
        \ If the\n   state-owner does have a file open, the stateid will not match
        and\n   again an error is returned to the client.\n"
      title: 9.1.10.  Releasing State-Owner State
    - contents:
      - "9.1.11.  Use of Open Confirmation\n   In the case that an OPEN is retransmitted
        and the open-owner is being\n   used for the first time or the open-owner
        state has been previously\n   released by the server, the use of the OPEN_CONFIRM
        operation will\n   prevent incorrect behavior.  When the server observes the
        use of the\n   open-owner for the first time, it will direct the client to
        perform\n   the OPEN_CONFIRM for the corresponding OPEN.  This sequence\n
        \  establishes the use of an open-owner and associated sequence number.\n
        \  Since the OPEN_CONFIRM sequence connects a new open-owner on the\n   server
        with an existing open-owner on a client, the sequence number\n   may have
        any valid (i.e., non-zero) value.  The OPEN_CONFIRM step\n   assures the server
        that the value received is the correct one.  (See\n   Section 16.18 for further
        details.)\n   There are a number of situations in which the requirement to
        confirm\n   an OPEN would pose difficulties for the client and server, in
        that\n   they would be prevented from acting in a timely fashion on\n   information
        received, because that information would be provisional,\n   subject to deletion
        upon non-confirmation.  Fortunately, these are\n   situations in which the
        server can avoid the need for confirmation\n   when responding to open requests.
        \ The two constraints are:\n   o  The server must not bestow a delegation
        for any open that would\n      require confirmation.\n   o  The server MUST
        NOT require confirmation on a reclaim-type open\n      (i.e., one specifying
        claim type CLAIM_PREVIOUS or\n      CLAIM_DELEGATE_PREV).\n   These constraints
        are related in that reclaim-type opens are the only\n   ones in which the
        server may be required to send a delegation.  For\n   CLAIM_NULL, sending
        the delegation is optional, while for\n   CLAIM_DELEGATE_CUR, no delegation
        is sent.\n   Delegations being sent with an open requiring confirmation are\n
        \  troublesome because recovering from non-confirmation adds undue\n   complexity
        to the protocol, while requiring confirmation on reclaim-\n   type opens poses
        difficulties in that the inability to resolve the\n   status of the reclaim
        until lease expiration may make it difficult to\n   have timely determination
        of the set of locks being reclaimed (since\n   the grace period may expire).\n
        \  Requiring open confirmation on reclaim-type opens is avoidable\n   because
        of the nature of the environments in which such opens are\n   done.  For CLAIM_PREVIOUS
        opens, this is immediately after server\n   reboot, so there should be no
        time for open-owners to be created,\n   found to be unused, and recycled.
        \ For CLAIM_DELEGATE_PREV opens,\n   we are dealing with either a client reboot
        situation or a network\n   partition resulting in deletion of lease state
        (and returning\n   NFS4ERR_EXPIRED).  A server that supports delegations can
        be sure\n   that no open-owners for that client have been recycled since client\n
        \  initialization or deletion of lease state and thus can be confident\n   that
        confirmation will not be required.\n"
      title: 9.1.11.  Use of Open Confirmation
    title: 9.1.  Opens and Byte-Range Locks
  - contents:
    - "9.2.  Lock Ranges\n   The protocol allows a lock-owner to request a lock with
      a byte range\n   and then either upgrade or unlock a sub-range of the initial
      lock.\n   It is expected that this will be an uncommon type of request.  In
      any\n   case, servers or server file systems may not be able to support\n   sub-range
      lock semantics.  In the event that a server receives a\n   locking request that
      represents a sub-range of current locking state\n   for the lock-owner, the
      server is allowed to return the error\n   NFS4ERR_LOCK_RANGE to signify that
      it does not support sub-range lock\n   operations.  Therefore, the client should
      be prepared to receive this\n   error and, if appropriate, report the error
      to the requesting\n   application.\n   The client is discouraged from combining
      multiple independent locking\n   ranges that happen to be adjacent into a single
      request, since the\n   server may not support sub-range requests, and for reasons
      related to\n   the recovery of file locking state in the event of server failure.\n
      \  As discussed in Section 9.6.2 below, the server may employ certain\n   optimizations
      during recovery that work effectively only when the\n   client's behavior during
      lock recovery is similar to the client's\n   locking behavior prior to server
      failure.\n"
    title: 9.2.  Lock Ranges
  - contents:
    - "9.3.  Upgrading and Downgrading Locks\n   If a client has a write lock on a
      record, it can request an atomic\n   downgrade of the lock to a read lock via
      the LOCK request, by setting\n   the type to READ_LT.  If the server supports
      atomic downgrade, the\n   request will succeed.  If not, it will return NFS4ERR_LOCK_NOTSUPP.\n
      \  The client should be prepared to receive this error and, if\n   appropriate,
      report the error to the requesting application.\n   If a client has a read lock
      on a record, it can request an atomic\n   upgrade of the lock to a write lock
      via the LOCK request by setting\n   the type to WRITE_LT or WRITEW_LT.  If the
      server does not support\n   atomic upgrade, it will return NFS4ERR_LOCK_NOTSUPP.
      \ If the upgrade\n   can be achieved without an existing conflict, the request
      will\n   succeed.  Otherwise, the server will return either NFS4ERR_DENIED or\n
      \  NFS4ERR_DEADLOCK.  The error NFS4ERR_DEADLOCK is returned if the\n   client
      issued the LOCK request with the type set to WRITEW_LT and the\n   server has
      detected a deadlock.  The client should be prepared to\n   receive such errors
      and, if appropriate, report them to the\n   requesting application.\n"
    title: 9.3.  Upgrading and Downgrading Locks
  - contents:
    - "9.4.  Blocking Locks\n   Some clients require the support of blocking locks.
      \ The NFSv4\n   protocol must not rely on a callback mechanism and therefore
      is\n   unable to notify a client when a previously denied lock has been\n   granted.
      \ Clients have no choice but to continually poll for the\n   lock.  This presents
      a fairness problem.  Two new lock types are\n   added, READW and WRITEW, and
      are used to indicate to the server that\n   the client is requesting a blocking
      lock.  The server should maintain\n   an ordered list of pending blocking locks.
      \ When the conflicting lock\n   is released, the server may wait the lease period
      for the first\n   waiting client to re-request the lock.  After the lease period\n
      \  expires, the next waiting client request is allowed the lock.\n   Clients
      are required to poll at an interval sufficiently small that\n   it is likely
      to acquire the lock in a timely manner.  The server is\n   not required to maintain
      a list of pending blocked locks, as it is\n   not used to provide correct operation
      but only to increase fairness.\n   Because of the unordered nature of crash
      recovery, storing of lock\n   state to stable storage would be required to guarantee
      ordered\n   granting of blocking locks.\n   Servers may also note the lock types
      and delay returning denial of\n   the request to allow extra time for a conflicting
      lock to be\n   released, allowing a successful return.  In this way, clients
      can\n   avoid the burden of needlessly frequent polling for blocking locks.\n
      \  The server should take care with the length of delay in the event\n   that
      the client retransmits the request.\n   If a server receives a blocking lock
      request, denies it, and then\n   later receives a non-blocking request for the
      same lock, which is\n   also denied, then it should remove the lock in question
      from its list\n   of pending blocking locks.  Clients should use such a non-blocking\n
      \  request to indicate to the server that this is the last time they\n   intend
      to poll for the lock, as may happen when the process\n   requesting the lock
      is interrupted.  This is a courtesy to the\n   server, to prevent it from unnecessarily
      waiting a lease period\n   before granting other lock requests.  However, clients
      are not\n   required to perform this courtesy, and servers must not depend on\n
      \  them doing so.  Also, clients must be prepared for the possibility\n   that
      this final locking request will be accepted.\n"
    title: 9.4.  Blocking Locks
  - contents:
    - "9.5.  Lease Renewal\n   The purpose of a lease is to allow a server to remove
      stale locks\n   that are held by a client that has crashed or is otherwise\n
      \  unreachable.  It is not a mechanism for cache consistency, and lease\n   renewals
      may not be denied if the lease interval has not expired.\n   The client can
      implicitly provide a positive indication that it is\n   still active and that
      the associated state held at the server, for\n   the client, is still valid.
      \ Any operation made with a valid clientid\n   (DELEGPURGE, LOCK, LOCKT, OPEN,
      RELEASE_LOCKOWNER, or RENEW) or a\n   valid stateid (CLOSE, DELEGRETURN, LOCK,
      LOCKU, OPEN, OPEN_CONFIRM,\n   OPEN_DOWNGRADE, READ, SETATTR, or WRITE) informs
      the server to renew\n   all of the leases for that client (i.e., all those sharing
      a given\n   client ID).  In the latter case, the stateid must not be one of
      the\n   special stateids (anonymous stateid or READ bypass stateid).\n   Note
      that if the client had restarted or rebooted, the client would\n   not be making
      these requests without issuing the SETCLIENTID/\n   SETCLIENTID_CONFIRM sequence.
      \ The use of the SETCLIENTID/\n   SETCLIENTID_CONFIRM sequence (one that changes
      the client verifier)\n   notifies the server to drop the locking state associated
      with the\n   client.  SETCLIENTID/SETCLIENTID_CONFIRM never renews a lease.\n
      \  If the server has rebooted, the stateids (NFS4ERR_STALE_STATEID\n   error)
      or the client ID (NFS4ERR_STALE_CLIENTID error) will not be\n   valid, hence
      preventing spurious renewals.\n   This approach allows for low-overhead lease
      renewal, which scales\n   well.  In the typical case, no extra RPCs are required
      for lease\n   renewal, and in the worst case, one RPC is required every lease\n
      \  period (i.e., a RENEW operation).  The number of locks held by the\n   client
      is not a factor since all state for the client is involved\n   with the lease
      renewal action.\n   Since all operations that create a new lease also renew
      existing\n   leases, the server must maintain a common lease expiration time
      for\n   all valid leases for a given client.  This lease time can then be\n
      \  easily updated upon implicit lease renewal actions.\n"
    title: 9.5.  Lease Renewal
  - contents:
    - "9.6.  Crash Recovery\n   The important requirement in crash recovery is that
      both the client\n   and the server know when the other has failed.  Additionally,
      it is\n   required that a client sees a consistent view of data across server\n
      \  restarts or reboots.  All READ and WRITE operations that may have\n   been
      queued within the client or network buffers must wait until the\n   client has
      successfully recovered the locks protecting the READ and\n   WRITE operations.\n"
    - contents:
      - "9.6.1.  Client Failure and Recovery\n   In the event that a client fails,
        the server may recover the client's\n   locks when the associated leases have
        expired.  Conflicting locks\n   from another client may only be granted after
        this lease expiration.\n   If the client is able to restart or reinitialize
        within the lease\n   period, the client may be forced to wait the remainder
        of the lease\n   period before obtaining new locks.\n   To minimize client
        delay upon restart, open and lock requests are\n   associated with an instance
        of the client by a client-supplied\n   verifier.  This verifier is part of
        the initial SETCLIENTID call made\n   by the client.  The server returns a
        client ID as a result of the\n   SETCLIENTID operation.  The client then confirms
        the use of the\n   client ID with SETCLIENTID_CONFIRM.  The client ID in combination\n
        \  with an opaque owner field is then used by the client to identify the\n
        \  open-owner for OPEN.  This chain of associations is then used to\n   identify
        all locks for a particular client.\n   Since the verifier will be changed
        by the client upon each\n   initialization, the server can compare a new verifier
        to the verifier\n   associated with currently held locks and determine that
        they do not\n   match.  This signifies the client's new instantiation and
        subsequent\n   loss of locking state.  As a result, the server is free to
        release\n   all locks held that are associated with the old client ID that
        was\n   derived from the old verifier.\n   Note that the verifier must have
        the same uniqueness properties of\n   the verifier for the COMMIT operation.\n"
      title: 9.6.1.  Client Failure and Recovery
    - contents:
      - "9.6.2.  Server Failure and Recovery\n   If the server loses locking state
        (usually as a result of a restart\n   or reboot), it must allow clients time
        to discover this fact and\n   re-establish the lost locking state.  The client
        must be able to\n   re-establish the locking state without having the server
        deny valid\n   requests because the server has granted conflicting access
        to another\n   client.  Likewise, if there is the possibility that clients
        have\n   not yet re-established their locking state for a file, the server\n
        \  must disallow READ and WRITE operations for that file.  The duration\n
        \  of this recovery period is equal to the duration of the lease period.\n
        \  A client can determine that server failure (and thus loss of locking\n
        \  state) has occurred, when it receives one of two errors.  The\n   NFS4ERR_STALE_STATEID
        error indicates a stateid invalidated by a\n   reboot or restart.  The NFS4ERR_STALE_CLIENTID
        error indicates a\n   client ID invalidated by reboot or restart.  When either
        of these is\n   received, the client must establish a new client ID (see\n
        \  Section 9.1.1) and re-establish the locking state as discussed below.\n
        \  The period of special handling of locking and READs and WRITEs, equal\n
        \  in duration to the lease period, is referred to as the \"grace\n   period\".
        \ During the grace period, clients recover locks and the\n   associated state
        by reclaim-type locking requests (i.e., LOCK\n   requests with reclaim set
        to TRUE and OPEN operations with a claim\n   type of either CLAIM_PREVIOUS
        or CLAIM_DELEGATE_PREV).  During the\n   grace period, the server must reject
        READ and WRITE operations and\n   non-reclaim locking requests (i.e., other
        LOCK and OPEN operations)\n   with an error of NFS4ERR_GRACE.\n   If the server
        can reliably determine that granting a non-reclaim\n   request will not conflict
        with reclamation of locks by other clients,\n   the NFS4ERR_GRACE error does
        not have to be returned and the\n   non-reclaim client request can be serviced.
        \ For the server to be\n   able to service READ and WRITE operations during
        the grace period, it\n   must again be able to guarantee that no possible
        conflict could arise\n   between an impending reclaim locking request and
        the READ or WRITE\n   operation.  If the server is unable to offer that guarantee,
        the\n   NFS4ERR_GRACE error must be returned to the client.\n   For a server
        to provide simple, valid handling during the grace\n   period, the easiest
        method is to simply reject all non-reclaim\n   locking requests and READ and
        WRITE operations by returning the\n   NFS4ERR_GRACE error.  However, a server
        may keep information about\n   granted locks in stable storage.  With this
        information, the server\n   could determine if a regular lock or READ or WRITE
        operation can be\n   safely processed.\n   For example, if a count of locks
        on a given file is available in\n   stable storage, the server can track reclaimed
        locks for the file,\n   and when all reclaims have been processed, non-reclaim
        locking\n   requests may be processed.  This way, the server can ensure that\n
        \  non-reclaim locking requests will not conflict with potential reclaim\n
        \  requests.  With respect to I/O requests, if the server is able to\n   determine
        that there are no outstanding reclaim requests for a file\n   by information
        from stable storage or another similar mechanism, the\n   processing of I/O
        requests could proceed normally for the file.\n   To reiterate, for a server
        that allows non-reclaim lock and I/O\n   requests to be processed during the
        grace period, it MUST determine\n   that no lock subsequently reclaimed will
        be rejected and that no lock\n   subsequently reclaimed would have prevented
        any I/O operation\n   processed during the grace period.\n   Clients should
        be prepared for the return of NFS4ERR_GRACE errors for\n   non-reclaim lock
        and I/O requests.  In this case, the client should\n   employ a retry mechanism
        for the request.  A delay (on the order of\n   several seconds) between retries
        should be used to avoid overwhelming\n   the server.  Further discussion of
        the general issue is included in\n   [Floyd].  The client must account for
        the server that is able to\n   perform I/O and non-reclaim locking requests
        within the grace period\n   as well as those that cannot do so.\n   A reclaim-type
        locking request outside the server's grace period can\n   only succeed if
        the server can guarantee that no conflicting lock or\n   I/O request has been
        granted since reboot or restart.\n   A server may, upon restart, establish
        a new value for the lease\n   period.  Therefore, clients should, once a new
        client ID is\n   established, refetch the lease_time attribute and use it
        as the basis\n   for lease renewal for the lease associated with that server.\n
        \  However, the server must establish, for this restart event, a grace\n   period
        at least as long as the lease period for the previous server\n   instantiation.
        \ This allows the client state obtained during the\n   previous server instance
        to be reliably re-established.\n"
      title: 9.6.2.  Server Failure and Recovery
    - contents:
      - "9.6.3.  Network Partitions and Recovery\n   If the duration of a network
        partition is greater than the lease\n   period provided by the server, the
        server will have not received a\n   lease renewal from the client.  If this
        occurs, the server may cancel\n   the lease and free all locks held for the
        client.  As a result, all\n   stateids held by the client will become invalid
        or stale.  Once the\n   client is able to reach the server after such a network
        partition,\n   all I/O submitted by the client with the now invalid stateids
        will\n   fail with the server returning the error NFS4ERR_EXPIRED.  Once this\n
        \  error is received, the client will suitably notify the application\n   that
        held the lock.\n"
      - contents:
        - "9.6.3.1.  Courtesy Locks\n   As a courtesy to the client or as an optimization,
          the server may\n   continue to hold locks, including delegations, on behalf
          of a client\n   for which recent communication has extended beyond the lease
          period,\n   delaying the cancellation of the lease.  If the server receives
          a\n   lock or I/O request that conflicts with one of these courtesy locks\n
          \  or if it runs out of resources, the server MAY cause lease\n   cancellation
          to occur at that time and henceforth return\n   NFS4ERR_EXPIRED when any
          of the stateids associated with the freed\n   locks is used.  If lease cancellation
          has not occurred and the server\n   receives a lock or I/O request that
          conflicts with one of the\n   courtesy locks, the requirements are as follows:\n
          \  o  In the case of a courtesy lock that is not a delegation, it MUST\n
          \     free the courtesy lock and grant the new request.\n   o  In the case
          of a lock or an I/O request that conflicts with a\n      delegation that
          is being held as a courtesy lock, the server MAY\n      delay resolution
          of the request but MUST NOT reject the request\n      and MUST free the
          delegation and grant the new request eventually.\n   o  In the case of a
          request for a delegation that conflicts with a\n      delegation that is
          being held as a courtesy lock, the server MAY\n      grant the new request
          or not as it chooses, but if it grants the\n      conflicting request, the
          delegation held as a courtesy lock MUST\n      be freed.\n   If the server
          does not reboot or cancel the lease before the network\n   partition is
          healed, when the original client tries to access a\n   courtesy lock that
          was freed, the server SHOULD send back an\n   NFS4ERR_BAD_STATEID to the
          client.  If the client tries to access a\n   courtesy lock that was not
          freed, then the server SHOULD mark all of\n   the courtesy locks as implicitly
          being renewed.\n"
        title: 9.6.3.1.  Courtesy Locks
      - contents:
        - "9.6.3.2.  Lease Cancellation\n   As a result of lease expiration, leases
          may be canceled, either\n   immediately upon expiration or subsequently,
          depending on the\n   occurrence of a conflicting lock or extension of the
          period of\n   partition beyond what the server will tolerate.\n   When a
          lease is canceled, all locking state associated with it is\n   freed, and
          the use of any of the associated stateids will result in\n   NFS4ERR_EXPIRED
          being returned.  Similarly, the use of the associated\n   clientid will
          result in NFS4ERR_EXPIRED being returned.\n   The client should recover
          from this situation by using SETCLIENTID\n   followed by SETCLIENTID_CONFIRM,
          in order to establish a new\n   clientid.  Once a lock is obtained using
          this clientid, a lease will\n   be established.\n"
        title: 9.6.3.2.  Lease Cancellation
      - contents:
        - "9.6.3.3.  Client's Reaction to a Freed Lock\n   There is no way for a client
          to predetermine how a given server is\n   going to behave during a network
          partition.  When the partition\n   heals, the client still has either all
          of its locks, some of its\n   locks, or none of them.  The client will be
          able to examine the\n   various error return values to determine its response.\n
          \  NFS4ERR_EXPIRED:\n      All locks have been freed as a result of a lease
          cancellation that\n      occurred during the partition.  The client should
          use a\n      SETCLIENTID to recover.\n   NFS4ERR_ADMIN_REVOKED:\n      The
          current lock has been revoked before, during, or after the\n      partition.
          \ The client SHOULD handle this error as it normally\n      would.\n   NFS4ERR_BAD_STATEID:\n
          \     The current lock has been revoked/released during the partition,\n
          \     and the server did not reboot.  Other locks MAY still be renewed.\n
          \     The client need not do a SETCLIENTID and instead SHOULD probe via\n
          \     a RENEW call.\n   NFS4ERR_RECLAIM_BAD:\n      The current lock has
          been revoked during the partition, and the\n      server rebooted.  The
          server might have no information on the\n      other locks.  They may still
          be renewable.\n   NFS4ERR_NO_GRACE:\n      The client's locks have been
          revoked during the partition, and the\n      server rebooted.  None of the
          client's locks will be renewable.\n   NFS4ERR_OLD_STATEID:\n      The server
          has not rebooted.  The client SHOULD handle this error\n      as it normally
          would.\n"
        title: 9.6.3.3.  Client's Reaction to a Freed Lock
      - contents:
        - "9.6.3.4.  Edge Conditions\n   When a network partition is combined with
          a server reboot, then both\n   the server and client have responsibilities
          to ensure that the client\n   does not reclaim a lock that it should no
          longer be able to access.\n   Briefly, those are:\n   o  Client's responsibility:
          A client MUST NOT attempt to reclaim any\n      locks that it did not hold
          at the end of its most recent\n      successfully established client lease.\n
          \  o  Server's responsibility: A server MUST NOT allow a client to\n      reclaim
          a lock unless it knows that it could not have since\n      granted a conflicting
          lock.  However, in deciding whether a\n      conflicting lock could have
          been granted, it is permitted to\n      assume that its clients are responsible,
          as above.\n   A server may consider a client's lease \"successfully established\"\n
          \  once it has received an OPEN operation from that client.\n   The above
          are directed to CLAIM_PREVIOUS reclaims and not to\n   CLAIM_DELEGATE_PREV
          reclaims, which generally do not involve a server\n   reboot.  However,
          when a server persistently stores delegation\n   information to support
          CLAIM_DELEGATE_PREV across a period in which\n   both client and server
          are down at the same time, similar strictures\n   apply.\n   The next sections
          give examples showing what can go wrong if these\n   responsibilities are
          neglected and also provide examples of server\n   implementation strategies
          that could meet a server's\n   responsibilities.\n"
        - contents:
          - "9.6.3.4.1.  First Server Edge Condition\n   The first edge condition
            has the following scenario:\n   1.  Client A acquires a lock.\n   2.  Client
            A and the server experience mutual network partition, such\n       that
            client A is unable to renew its lease.\n   3.  Client A's lease expires,
            so the server releases the lock.\n   4.  Client B acquires a lock that
            would have conflicted with that of\n       client A.\n   5.  Client B
            releases the lock.\n   6.  The server reboots.\n   7.  The network partition
            between client A and the server heals.\n   8.  Client A issues a RENEW
            operation and gets back an\n       NFS4ERR_STALE_CLIENTID.\n   9.  Client
            A reclaims its lock within the server's grace period.\n   Thus, at the
            final step, the server has erroneously granted\n   client A's lock reclaim.
            \ If client B modified the object the lock\n   was protecting, client
            A will experience object corruption.\n"
          title: 9.6.3.4.1.  First Server Edge Condition
        - contents:
          - "9.6.3.4.2.  Second Server Edge Condition\n   The second known edge condition
            follows:\n   1.   Client A acquires a lock.\n   2.   The server reboots.\n
            \  3.   Client A and the server experience mutual network partition,\n
            \       such that client A is unable to reclaim its lock within the\n
            \       grace period.\n   4.   The server's reclaim grace period ends.
            \ Client A has no locks\n        recorded on the server.\n   5.   Client
            B acquires a lock that would have conflicted with that of\n        client
            A.\n   6.   Client B releases the lock.\n   7.   The server reboots a
            second time.\n   8.   The network partition between client A and the server
            heals.\n   9.   Client A issues a RENEW operation and gets back an\n        NFS4ERR_STALE_CLIENTID.\n
            \  10.  Client A reclaims its lock within the server's grace period.\n
            \  As with the first edge condition, the final step of the scenario of\n
            \  the second edge condition has the server erroneously granting\n   client
            A's lock reclaim.\n"
          title: 9.6.3.4.2.  Second Server Edge Condition
        - contents:
          - "9.6.3.4.3.  Handling Server Edge Conditions\n   In both of the above
            examples, the client attempts reclaim of a lock\n   that it held at the
            end of its most recent successfully established\n   lease; thus, it has
            fulfilled its responsibility.\n   The server, however, has failed, by
            granting a reclaim, despite\n   having granted a conflicting lock since
            the reclaimed lock was last\n   held.\n   Solving these edge conditions
            requires that the server either (1)\n   assume after it reboots that an
            edge condition occurs, and thus\n   return NFS4ERR_NO_GRACE for all reclaim
            attempts, or (2) record some\n   information in stable storage.  The amount
            of information the server\n   records in stable storage is in inverse
            proportion to how harsh the\n   server wants to be whenever the edge conditions
            occur.  The server\n   that is completely tolerant of all edge conditions
            will record in\n   stable storage every lock that is acquired, removing
            the lock record\n   from stable storage only when the lock is unlocked
            by the client and\n   the lock's owner advances the sequence number such
            that the lock\n   release is not the last stateful event for the owner's
            sequence.  For\n   the two aforementioned edge conditions, the harshest
            a server can be,\n   and still support a grace period for reclaims, requires
            that the\n   server record in stable storage some minimal information.
            \ For\n   example, a server implementation could, for each client, save
            in\n   stable storage a record containing:\n   o  the client's id string.\n
            \  o  a boolean that indicates if the client's lease expired or if there\n
            \     was administrative intervention (see Section 9.8) to revoke a\n
            \     byte-range lock, share reservation, or delegation.\n   o  a timestamp
            that is updated the first time after a server boot or\n      reboot the
            client acquires byte-range locking, share reservation,\n      or delegation
            state on the server.  The timestamp need not be\n      updated on subsequent
            lock requests until the server reboots.\n   The server implementation
            would also record in stable storage the\n   timestamps from the two most
            recent server reboots.\n   Assuming the above record keeping, for the
            first edge condition,\n   after the server reboots, the record that client
            A's lease expired\n   means that another client could have acquired a
            conflicting record\n   lock, share reservation, or delegation.  Hence,
            the server must\n   reject a reclaim from client A with the error NFS4ERR_NO_GRACE
            or\n   NFS4ERR_RECLAIM_BAD.\n   For the second edge condition, after the
            server reboots for a second\n   time, the record that the client had an
            unexpired record lock, share\n   reservation, or delegation established
            before the server's previous\n   incarnation means that the server must
            reject a reclaim from client A\n   with the error NFS4ERR_NO_GRACE or
            NFS4ERR_RECLAIM_BAD.\n   Regardless of the level and approach to record
            keeping, the server\n   MUST implement one of the following strategies
            (which apply to\n   reclaims of share reservations, byte-range locks,
            and delegations):\n   1.  Reject all reclaims with NFS4ERR_NO_GRACE.  This
            is extremely\n       harsh but is necessary if the server does not want
            to record lock\n       state in stable storage.\n   2.  Record sufficient
            state in stable storage to meet its\n       responsibilities.  In doubt,
            the server should err on the side of\n       being harsh.\n       In the
            event that, after a server reboot, the server determines\n       that
            there is unrecoverable damage or corruption to stable\n       storage,
            then for all clients and/or locks affected, the server\n       MUST return
            NFS4ERR_NO_GRACE.\n"
          title: 9.6.3.4.3.  Handling Server Edge Conditions
        - contents:
          - "9.6.3.4.4.  Client Edge Condition\n   A third edge condition affects
            the client and not the server.  If the\n   server reboots in the middle
            of the client reclaiming some locks and\n   then a network partition is
            established, the client might be in the\n   situation of having reclaimed
            some, but not all, locks.  In that\n   case, a conservative client would
            assume that the non-reclaimed locks\n   were revoked.\n   The third known
            edge condition follows:\n   1.   Client A acquires a lock 1.\n   2.   Client
            A acquires a lock 2.\n   3.   The server reboots.\n   4.   Client A issues
            a RENEW operation and gets back an\n        NFS4ERR_STALE_CLIENTID.\n
            \  5.   Client A reclaims its lock 1 within the server's grace period.\n
            \  6.   Client A and the server experience mutual network partition,\n
            \       such that client A is unable to reclaim its remaining locks\n
            \       within the grace period.\n   7.   The server's reclaim grace period
            ends.\n   8.   Client B acquires a lock that would have conflicted with\n
            \       client A's lock 2.\n   9.   Client B releases the lock.\n   10.
            \ The server reboots a second time.\n   11.  The network partition between
            client A and the server heals.\n   12.  Client A issues a RENEW operation
            and gets back an\n        NFS4ERR_STALE_CLIENTID.\n   13.  Client A reclaims
            both lock 1 and lock 2 within the server's\n        grace period.\n   At
            the last step, the client reclaims lock 2 as if it had held that\n   lock
            continuously, when in fact a conflicting lock was granted to\n   client
            B.\n   This occurs because the client failed its responsibility, by\n
            \  attempting to reclaim lock 2 even though it had not held that lock
            at\n   the end of the lease that was established by the SETCLIENTID after\n
            \  the first server reboot.  (The client did hold lock 2 on a previous\n
            \  lease, but it is only the most recent lease that matters.)\n   A server
            could avoid this situation by rejecting the reclaim of\n   lock 2.  However,
            to do so accurately, it would have to ensure that\n   additional information
            about individual locks held survives a reboot.\n   Server implementations
            are not required to do that, so the client\n   must not assume that the
            server will.\n   Instead, a client MUST reclaim only those locks that
            it successfully\n   acquired from the previous server instance, omitting
            any that it\n   failed to reclaim before a new reboot.  Thus, in the last
            step above,\n   client A should reclaim only lock 1.\n"
          title: 9.6.3.4.4.  Client Edge Condition
        - contents:
          - "9.6.3.4.5.  Client's Handling of Reclaim Errors\n   A mandate for the
            client's handling of the NFS4ERR_NO_GRACE and\n   NFS4ERR_RECLAIM_BAD
            errors is outside the scope of this\n   specification, since the strategies
            for such handling are very\n   dependent on the client's operating environment.
            \ However, one\n   potential approach is described below.\n   When the
            client's reclaim fails, it could examine the change\n   attribute of the
            objects the client is trying to reclaim state for,\n   and use that to
            determine whether to re-establish the state via\n   normal OPEN or LOCK
            requests.  This is acceptable, provided the\n   client's operating environment
            allows it.  In other words, the client\n   implementer is advised to document
            the behavior for his users.  The\n   client could also inform the application
            that its byte-range lock or\n   share reservations (whether they were
            delegated or not) have been\n   lost, such as via a UNIX signal, a GUI
            pop-up window, etc.  See\n   Section 10.5 for a discussion of what the
            client should do for\n   dealing with unreclaimed delegations on client
            state.\n   For further discussion of revocation of locks, see Section
            9.8.\n"
          title: 9.6.3.4.5.  Client's Handling of Reclaim Errors
        title: 9.6.3.4.  Edge Conditions
      title: 9.6.3.  Network Partitions and Recovery
    title: 9.6.  Crash Recovery
  - contents:
    - "9.7.  Recovery from a Lock Request Timeout or Abort\n   In the event a lock
      request times out, a client may decide to not\n   retry the request.  The client
      may also abort the request when the\n   process for which it was issued is terminated
      (e.g., in UNIX due to a\n   signal).  It is possible, though, that the server
      received the\n   request and acted upon it.  This would change the state on
      the server\n   without the client being aware of the change.  It is paramount
      that\n   the client resynchronize state with the server before it attempts any\n
      \  other operation that takes a seqid and/or a stateid with the same\n   state-owner.
      \ This is straightforward to do without a special\n   resynchronize operation.\n
      \  Since the server maintains the last lock request and response\n   received
      on the state-owner, for each state-owner, the client should\n   cache the last
      lock request it sent such that the lock request did\n   not receive a response.
      \ From this, the next time the client does a\n   lock operation for the state-owner,
      it can send the cached request,\n   if there is one, and if the request was
      one that established state\n   (e.g., a LOCK or OPEN operation), the server
      will return the cached\n   result or, if it never saw the request, perform it.
      \ The client can\n   follow up with a request to remove the state (e.g., a LOCKU
      or CLOSE\n   operation).  With this approach, the sequencing and stateid\n   information
      on the client and server for the given state-owner will\n   resynchronize, and
      in turn the lock state will resynchronize.\n"
    title: 9.7.  Recovery from a Lock Request Timeout or Abort
  - contents:
    - "9.8.  Server Revocation of Locks\n   At any point, the server can revoke locks
      held by a client and the\n   client must be prepared for this event.  When the
      client detects that\n   its locks have been or may have been revoked, the client
      is\n   responsible for validating the state information between itself and\n
      \  the server.  Validating locking state for the client means that it\n   must
      verify or reclaim state for each lock currently held.\n   The first instance
      of lock revocation is upon server reboot or\n   re-initialization.  In this
      instance, the client will receive an\n   error (NFS4ERR_STALE_STATEID or NFS4ERR_STALE_CLIENTID)
      and the\n   client will proceed with normal crash recovery as described in the\n
      \  previous section.\n   The second lock revocation event is the inability to
      renew the lease\n   before expiration.  While this is considered a rare or unusual
      event,\n   the client must be prepared to recover.  Both the server and client\n
      \  will be able to detect the failure to renew the lease and are capable\n   of
      recovering without data corruption.  For the server, it tracks the\n   last
      renewal event serviced for the client and knows when the lease\n   will expire.
      \ Similarly, the client must track operations that will\n   renew the lease
      period.  Using the time that each such request was\n   sent and the time that
      the corresponding reply was received, the\n   client should bound the time that
      the corresponding renewal could\n   have occurred on the server and thus determine
      if it is possible that\n   a lease period expiration could have occurred.\n
      \  The third lock revocation event can occur as a result of\n   administrative
      intervention within the lease period.  While this is\n   considered a rare event,
      it is possible that the server's\n   administrator has decided to release or
      revoke a particular lock held\n   by the client.  As a result of revocation,
      the client will receive an\n   error of NFS4ERR_ADMIN_REVOKED.  In this instance,
      the client may\n   assume that only the state-owner's locks have been lost.
      \ The client\n   notifies the lock holder appropriately.  The client cannot
      assume\n   that the lease period has been renewed as a result of a failed\n
      \  operation.\n   When the client determines the lease period may have expired,
      the\n   client must mark all locks held for the associated lease as\n   \"unvalidated\".
      \ This means the client has been unable to re-establish\n   or confirm the appropriate
      lock state with the server.  As described\n   in Section 9.6, there are scenarios
      in which the server may grant\n   conflicting locks after the lease period has
      expired for a client.\n   When it is possible that the lease period has expired,
      the client\n   must validate each lock currently held to ensure that a conflicting\n
      \  lock has not been granted.  The client may accomplish this task by\n   issuing
      an I/O request; if there is no relevant I/O pending, a\n   zero-length read
      specifying the stateid associated with the lock in\n   question can be synthesized
      to trigger the renewal.  If the response\n   to the request is success, the
      client has validated all of the locks\n   governed by that stateid and re-established
      the appropriate state\n   between itself and the server.\n   If the I/O request
      is not successful, then one or more of the locks\n   associated with the stateid
      were revoked by the server, and the\n   client must notify the owner.\n"
    title: 9.8.  Server Revocation of Locks
  - contents:
    - "9.9.  Share Reservations\n   A share reservation is a mechanism to control
      access to a file.  It\n   is a separate and independent mechanism from byte-range
      locking.\n   When a client opens a file, it issues an OPEN operation to the
      server\n   specifying the type of access required (READ, WRITE, or BOTH) and
      the\n   type of access to deny others (OPEN4_SHARE_DENY_NONE,\n   OPEN4_SHARE_DENY_READ,
      OPEN4_SHARE_DENY_WRITE, or\n   OPEN4_SHARE_DENY_BOTH).  If the OPEN fails, the
      client will fail the\n   application's open request.\n   Pseudo-code definition
      of the semantics:\n     if (request.access == 0)\n             return (NFS4ERR_INVAL)\n
      \    else if ((request.access & file_state.deny) ||\n         (request.deny
      & file_state.access))\n             return (NFS4ERR_DENIED)\n   This checking
      of share reservations on OPEN is done with no exception\n   for an existing
      OPEN for the same open-owner.\n   The constants used for the OPEN and OPEN_DOWNGRADE
      operations for the\n   access and deny fields are as follows:\n   const OPEN4_SHARE_ACCESS_READ
      \  = 0x00000001;\n   const OPEN4_SHARE_ACCESS_WRITE  = 0x00000002;\n   const
      OPEN4_SHARE_ACCESS_BOTH   = 0x00000003;\n   const OPEN4_SHARE_DENY_NONE     =
      0x00000000;\n   const OPEN4_SHARE_DENY_READ     = 0x00000001;\n   const OPEN4_SHARE_DENY_WRITE
      \   = 0x00000002;\n   const OPEN4_SHARE_DENY_BOTH     = 0x00000003;\n"
    title: 9.9.  Share Reservations
  - contents:
    - "9.10.  OPEN/CLOSE Operations\n   To provide correct share semantics, a client
      MUST use the OPEN\n   operation to obtain the initial filehandle and indicate
      the desired\n   access and what access, if any, to deny.  Even if the client
      intends\n   to use one of the special stateids (anonymous stateid or READ bypass\n
      \  stateid), it must still obtain the filehandle for the regular file\n   with
      the OPEN operation so the appropriate share semantics can be\n   applied.  Clients
      that do not have a deny mode built into their\n   programming interfaces for
      opening a file should request a deny mode\n   of OPEN4_SHARE_DENY_NONE.\n   The
      OPEN operation with the CREATE flag also subsumes the CREATE\n   operation for
      regular files as used in previous versions of the NFS\n   protocol.  This allows
      a create with a share to be done atomically.\n   The CLOSE operation removes
      all share reservations held by the\n   open-owner on that file.  If byte-range
      locks are held, the client\n   SHOULD release all locks before issuing a CLOSE.
      \ The server MAY free\n   all outstanding locks on CLOSE, but some servers may
      not support the\n   CLOSE of a file that still has byte-range locks held.  The
      server\n   MUST return failure, NFS4ERR_LOCKS_HELD, if any locks would exist\n
      \  after the CLOSE.\n   The LOOKUP operation will return a filehandle without
      establishing\n   any lock state on the server.  Without a valid stateid, the
      server\n   will assume that the client has the least access.  For example, if\n
      \  one client opened a file with OPEN4_SHARE_DENY_BOTH and another\n   client
      accesses the file via a filehandle obtained through LOOKUP,\n   the second client
      could only read the file using the special READ\n   bypass stateid.  The second
      client could not WRITE the file at all\n   because it would not have a valid
      stateid from OPEN and the special\n   anonymous stateid would not be allowed
      access.\n"
    - contents:
      - "9.10.1.  Close and Retention of State Information\n   Since a CLOSE operation
        requests deallocation of a stateid, dealing\n   with retransmission of the
        CLOSE may pose special difficulties, since\n   the state information, which
        normally would be used to determine the\n   state of the open file being designated,
        might be deallocated,\n   resulting in an NFS4ERR_BAD_STATEID error.\n   Servers
        may deal with this problem in a number of ways.  To provide\n   the greatest
        degree of assurance that the protocol is being used\n   properly, a server
        should, rather than deallocate the stateid, mark\n   it as close-pending,
        and retain the stateid with this status, until\n   later deallocation.  In
        this way, a retransmitted CLOSE can be\n   recognized since the stateid points
        to state information with this\n   distinctive status, so that it can be handled
        without error.\n   When adopting this strategy, a server should retain the
        state\n   information until the earliest of:\n   o  Another validly sequenced
        request for the same open-owner, that is\n      not a retransmission.\n   o
        \ The time that an open-owner is freed by the server due to period\n      with
        no activity.\n   o  All locks for the client are freed as a result of a SETCLIENTID.\n
        \  Servers may avoid this complexity, at the cost of less complete\n   protocol
        error checking, by simply responding NFS4_OK in the event of\n   a CLOSE for
        a deallocated stateid, on the assumption that this case\n   must be caused
        by a retransmitted close.  When adopting this\n   approach, it is desirable
        to at least log an error when returning a\n   no-error indication in this
        situation.  If the server maintains a\n   reply-cache mechanism, it can verify
        that the CLOSE is indeed a\n   retransmission and avoid error logging in most
        cases.\n"
      title: 9.10.1.  Close and Retention of State Information
    title: 9.10.  OPEN/CLOSE Operations
  - contents:
    - "9.11.  Open Upgrade and Downgrade\n   When an OPEN is done for a file and the
      open-owner for which the open\n   is being done already has the file open, the
      result is to upgrade the\n   open file status maintained on the server to include
      the access and\n   deny bits specified by the new OPEN as well as those for
      the existing\n   OPEN.  The result is that there is one open file, as far as
      the\n   protocol is concerned, and it includes the union of the access and\n
      \  deny bits for all of the OPEN requests completed.  Only a single\n   CLOSE
      will be done to reset the effects of both OPENs.  Note that the\n   client,
      when issuing the OPEN, may not know that the same file is in\n   fact being
      opened.  The above only applies if both OPENs result in\n   the OPENed object
      being designated by the same filehandle.\n   When the server chooses to export
      multiple filehandles corresponding\n   to the same file object and returns different
      filehandles on two\n   different OPENs of the same file object, the server MUST
      NOT \"OR\"\n   together the access and deny bits and coalesce the two open files.\n
      \  Instead, the server must maintain separate OPENs with separate\n   stateids
      and will require separate CLOSEs to free them.\n   When multiple open files
      on the client are merged into a single open\n   file object on the server, the
      close of one of the open files (on the\n   client) may necessitate change of
      the access and deny status of the\n   open file on the server.  This is because
      the union of the access and\n   deny bits for the remaining opens may be smaller
      (i.e., a proper\n   subset) than previously.  The OPEN_DOWNGRADE operation is
      used to\n   make the necessary change, and the client should use it to update
      the\n   server so that share reservation requests by other clients are\n   handled
      properly.  The stateid returned has the same \"other\" field as\n   that passed
      to the server.  The seqid value in the returned stateid\n   MUST be incremented
      (Section 9.1.4), even in situations in which\n   there has been no change to
      the access and deny bits for the file.\n"
    title: 9.11.  Open Upgrade and Downgrade
  - contents:
    - "9.12.  Short and Long Leases\n   When determining the time period for the server
      lease, the usual\n   lease trade-offs apply.  Short leases are good for fast
      server\n   recovery at a cost of increased RENEW or READ (with zero length)\n
      \  requests.  Longer leases are certainly kinder and gentler to servers\n   trying
      to handle very large numbers of clients.  The number of RENEW\n   requests drops
      in proportion to the lease time.  The disadvantages of\n   long leases are slower
      recovery after server failure (the server must\n   wait for the leases to expire
      and the grace period to elapse before\n   granting new lock requests) and increased
      file contention (if the\n   client fails to transmit an unlock request, then
      the server must wait\n   for lease expiration before granting new locks).\n
      \  Long leases are usable if the server is able to store lease state in\n   non-volatile
      memory.  Upon recovery, the server can reconstruct the\n   lease state from
      its non-volatile memory and continue operation with\n   its clients, and therefore
      long leases would not be an issue.\n"
    title: 9.12.  Short and Long Leases
  - contents:
    - "9.13.  Clocks, Propagation Delay, and Calculating Lease Expiration\n   To avoid
      the need for synchronized clocks, lease times are granted by\n   the server
      as a time delta.  However, there is a requirement that the\n   client and server
      clocks do not drift excessively over the duration\n   of the lock.  There is
      also the issue of propagation delay across the\n   network -- which could easily
      be several hundred milliseconds -- as\n   well as the possibility that requests
      will be lost and need to be\n   retransmitted.\n   To take propagation delay
      into account, the client should subtract it\n   from lease times (e.g., if the
      client estimates the one-way\n   propagation delay as 200 msec, then it can
      assume that the lease is\n   already 200 msec old when it gets it).  In addition,
      it will take\n   another 200 msec to get a response back to the server.  So
      the client\n   must send a lock renewal or write data back to the server 400
      msec\n   before the lease would expire.\n   The server's lease period configuration
      should take into account the\n   network distance of the clients that will be
      accessing the server's\n   resources.  It is expected that the lease period
      will take into\n   account the network propagation delays and other network
      delay\n   factors for the client population.  Since the protocol does not allow\n
      \  for an automatic method to determine an appropriate lease period, the\n   server's
      administrator may have to tune the lease period.\n"
    title: 9.13.  Clocks, Propagation Delay, and Calculating Lease Expiration
  - contents:
    - "9.14.  Migration, Replication, and State\n   When responsibility for handling
      a given file system is transferred\n   to a new server (migration) or the client
      chooses to use an\n   alternative server (e.g., in response to server unresponsiveness)
      in\n   the context of file system replication, the appropriate handling of\n
      \  state shared between the client and server (i.e., locks, leases,\n   stateids,
      and client IDs) is as described below.  The handling\n   differs between migration
      and replication.  For a related discussion\n   of file server state and recovery
      of same, see the subsections of\n   Section 9.6.\n   In cases in which one server
      is expected to accept opaque values from\n   the client that originated from
      another server, the servers SHOULD\n   encode the opaque values in big-endian
      byte order.  If this is done,\n   the new server will be able to parse values
      like stateids, directory\n   cookies, filehandles, etc. even if their native
      byte order is\n   different from that of other servers cooperating in the replication\n
      \  and migration of the file system.\n"
    - contents:
      - "9.14.1.  Migration and State\n   In the case of migration, the servers involved
        in the migration of a\n   file system SHOULD transfer all server state from
        the original server\n   to the new server.  This must be done in a way that
        is transparent to\n   the client.  This state transfer will ease the client's
        transition\n   when a file system migration occurs.  If the servers are successful\n
        \  in transferring all state, the client will continue to use stateids\n   assigned
        by the original server.  Therefore, the new server must\n   recognize these
        stateids as valid.  This holds true for the client ID\n   as well.  Since
        responsibility for an entire file system is\n   transferred with a migration
        event, there is no possibility that\n   conflicts will arise on the new server
        as a result of the transfer of\n   locks.\n   As part of the transfer of information
        between servers, leases would\n   be transferred as well.  The leases being
        transferred to the new\n   server will typically have a different expiration
        time from those for\n   the same client, previously on the old server.  To
        maintain the\n   property that all leases on a given server for a given client
        expire\n   at the same time, the server should advance the expiration time
        to\n   the later of the leases being transferred or the leases already\n   present.
        \ This allows the client to maintain lease renewal of both\n   classes without
        special effort.\n   The servers may choose not to transfer the state information
        upon\n   migration.  However, this choice is discouraged.  In this case, when\n
        \  the client presents state information from the original server (e.g.,\n
        \  in a RENEW operation or a READ operation of zero length), the client\n
        \  must be prepared to receive either NFS4ERR_STALE_CLIENTID or\n   NFS4ERR_STALE_STATEID
        from the new server.  The client should then\n   recover its state information
        as it normally would in response to a\n   server failure.  The new server
        must take care to allow for the\n   recovery of state information as it would
        in the event of server\n   restart.\n   A client SHOULD re-establish new callback
        information with the new\n   server as soon as possible, according to sequences
        described in\n   Sections 16.33 and 16.34.  This ensures that server operations
        are\n   not blocked by the inability to recall delegations.\n"
      title: 9.14.1.  Migration and State
    - contents:
      - "9.14.2.  Replication and State\n   Since client switch-over in the case of
        replication is not under\n   server control, the handling of state is different.
        \ In this case,\n   leases, stateids, and client IDs do not have validity
        across a\n   transition from one server to another.  The client must re-establish\n
        \  its locks on the new server.  This can be compared to the\n   re-establishment
        of locks by means of reclaim-type requests after a\n   server reboot.  The
        difference is that the server has no provision to\n   distinguish requests
        reclaiming locks from those obtaining new locks\n   or to defer the latter.
        \ Thus, a client re-establishing a lock on the\n   new server (by means of
        a LOCK or OPEN request), may have the\n   requests denied due to a conflicting
        lock.  Since replication is\n   intended for read-only use of file systems,
        such denial of locks\n   should not pose large difficulties in practice.  When
        an attempt to\n   re-establish a lock on a new server is denied, the client
        should\n   treat the situation as if its original lock had been revoked.\n"
      title: 9.14.2.  Replication and State
    - contents:
      - "9.14.3.  Notification of Migrated Lease\n   In the case of lease renewal,
        the client may not be submitting\n   requests for a file system that has been
        migrated to another server.\n   This can occur because of the implicit lease
        renewal mechanism.  The\n   client renews leases for all file systems when
        submitting a request\n   to any one file system at the server.\n   In order
        for the client to schedule renewal of leases that may have\n   been relocated
        to the new server, the client must find out about\n   lease relocation before
        those leases expire.  To accomplish this, all\n   operations that implicitly
        renew leases for a client (such as OPEN,\n   CLOSE, READ, WRITE, RENEW, LOCK,
        and others) will return the error\n   NFS4ERR_LEASE_MOVED if responsibility
        for any of the leases to be\n   renewed has been transferred to a new server.
        \ This condition will\n   continue until the client receives an NFS4ERR_MOVED
        error and the\n   server receives the subsequent GETATTR(fs_locations) for
        an access to\n   each file system for which a lease has been moved to a new
        server.\n   By convention, the compound including the GETATTR(fs_locations)\n
        \  SHOULD append a RENEW operation to permit the server to identify the\n
        \  client doing the access.\n   Upon receiving the NFS4ERR_LEASE_MOVED error,
        a client that supports\n   file system migration MUST probe all file systems
        from that server on\n   which it holds open state.  Once the client has successfully
        probed\n   all those file systems that are migrated, the server MUST resume\n
        \  normal handling of stateful requests from that client.\n   In order to
        support legacy clients that do not handle the\n   NFS4ERR_LEASE_MOVED error
        correctly, the server SHOULD time out after\n   a wait of at least two lease
        periods, at which time it will resume\n   normal handling of stateful requests
        from all clients.  If a client\n   attempts to access the migrated files,
        the server MUST reply with\n   NFS4ERR_MOVED.\n   When the client receives
        an NFS4ERR_MOVED error, the client can\n   follow the normal process to obtain
        the new server information\n   (through the fs_locations attribute) and perform
        renewal of those\n   leases on the new server.  If the server has not had
        state\n   transferred to it transparently, the client will receive either\n
        \  NFS4ERR_STALE_CLIENTID or NFS4ERR_STALE_STATEID from the new server,\n
        \  as described above.  The client can then recover state information as\n
        \  it does in the event of server failure.\n"
      title: 9.14.3.  Notification of Migrated Lease
    - contents:
      - "9.14.4.  Migration and the lease_time Attribute\n   In order that the client
        may appropriately manage its leases in the\n   case of migration, the destination
        server must establish proper\n   values for the lease_time attribute.\n   When
        state is transferred transparently, that state should include\n   the correct
        value of the lease_time attribute.  The lease_time\n   attribute on the destination
        server must never be less than that on\n   the source since this would result
        in premature expiration of leases\n   granted by the source server.  Upon
        migration, in which state is\n   transferred transparently, the client is
        under no obligation to\n   refetch the lease_time attribute and may continue
        to use the value\n   previously fetched (on the source server).\n   If state
        has not been transferred transparently (i.e., the client\n   sees a real or
        simulated server reboot), the client should fetch the\n   value of lease_time
        on the new (i.e., destination) server and use it\n   for subsequent locking
        requests.  However, the server must respect a\n   grace period at least as
        long as the lease_time on the source server,\n   in order to ensure that clients
        have ample time to reclaim their\n   locks before potentially conflicting
        non-reclaimed locks are granted.\n   The means by which the new server obtains
        the value of lease_time on\n   the old server is left to the server implementations.
        \ It is not\n   specified by the NFSv4 protocol.\n"
      title: 9.14.4.  Migration and the lease_time Attribute
    title: 9.14.  Migration, Replication, and State
  title: 9.  File Locking and Share Reservations
- contents:
  - "10.  Client-Side Caching\n   Client-side caching of data, file attributes, and
    filenames is\n   essential to providing good performance with the NFS protocol.\n
    \  Providing distributed cache coherence is a difficult problem, and\n   previous
    versions of the NFS protocol have not attempted it.\n   Instead, several NFS client
    implementation techniques have been used\n   to reduce the problems that a lack
    of coherence poses for users.\n   These techniques have not been clearly defined
    by earlier protocol\n   specifications, and it is often unclear what is valid
    or invalid\n   client behavior.\n   The NFSv4 protocol uses many techniques similar
    to those that have\n   been used in previous protocol versions.  The NFSv4 protocol
    does not\n   provide distributed cache coherence.  However, it defines a more\n
    \  limited set of caching guarantees to allow locks and share\n   reservations
    to be used without destructive interference from\n   client-side caching.\n   In
    addition, the NFSv4 protocol introduces a delegation mechanism\n   that allows
    many decisions normally made by the server to be made\n   locally by clients.
    \ This mechanism provides efficient support of the\n   common cases where sharing
    is infrequent or where sharing is\n   read-only.\n"
  - contents:
    - "10.1.  Performance Challenges for Client-Side Caching\n   Caching techniques
      used in previous versions of the NFS protocol have\n   been successful in providing
      good performance.  However, several\n   scalability challenges can arise when
      those techniques are used with\n   very large numbers of clients.  This is particularly
      true when\n   clients are geographically distributed, which classically increases\n
      \  the latency for cache revalidation requests.\n   The previous versions of
      the NFS protocol repeat their file data\n   cache validation requests at the
      time the file is opened.  This\n   behavior can have serious performance drawbacks.
      \ A common case is\n   one in which a file is only accessed by a single client.
      \ Therefore,\n   sharing is infrequent.\n   In this case, repeated reference
      to the server to find that no\n   conflicts exist is expensive.  A better option
      with regards to\n   performance is to allow a client that repeatedly opens a
      file to do\n   so without reference to the server.  This is done until potentially\n
      \  conflicting operations from another client actually occur.\n   A similar
      situation arises in connection with file locking.  Sending\n   file lock and
      unlock requests to the server as well as the READ and\n   WRITE requests necessary
      to make data caching consistent with the\n   locking semantics (see Section
      10.3.2) can severely limit\n   performance.  When locking is used to provide
      protection against\n   infrequent conflicts, a large penalty is incurred.  This
      penalty may\n   discourage the use of file locking by applications.\n   The
      NFSv4 protocol provides more aggressive caching strategies with\n   the following
      design goals:\n   o  Compatibility with a large range of server semantics.\n
      \  o  Providing the same caching benefits as previous versions of the\n      NFS
      protocol when unable to provide the more aggressive model.\n   o  Organizing
      requirements for aggressive caching so that a large\n      portion of the benefit
      can be obtained even when not all of the\n      requirements can be met.\n   The
      appropriate requirements for the server are discussed in later\n   sections,
      in which specific forms of caching are covered (see\n   Section 10.4).\n"
    title: 10.1.  Performance Challenges for Client-Side Caching
  - contents:
    - "10.2.  Delegation and Callbacks\n   Recallable delegation of server responsibilities
      for a file to a\n   client improves performance by avoiding repeated requests
      to the\n   server in the absence of inter-client conflict.  With the use of
      a\n   \"callback\" RPC from server to client, a server recalls delegated\n   responsibilities
      when another client engages in the sharing of a\n   delegated file.\n   A delegation
      is passed from the server to the client, specifying the\n   object of the delegation
      and the type of delegation.  There are\n   different types of delegations, but
      each type contains a stateid to\n   be used to represent the delegation when
      performing operations that\n   depend on the delegation.  This stateid is similar
      to those\n   associated with locks and share reservations but differs in that
      the\n   stateid for a delegation is associated with a client ID and may be\n
      \  used on behalf of all the open-owners for the given client.  A\n   delegation
      is made to the client as a whole and not to any specific\n   process or thread
      of control within it.\n   Because callback RPCs may not work in all environments
      (due to\n   firewalls, for example), correct protocol operation does not depend\n
      \  on them.  Preliminary testing of callback functionality by means of a\n   CB_NULL
      procedure determines whether callbacks can be supported.  The\n   CB_NULL procedure
      checks the continuity of the callback path.  A\n   server makes a preliminary
      assessment of callback availability to a\n   given client and avoids delegating
      responsibilities until it has\n   determined that callbacks are supported.  Because
      the granting of a\n   delegation is always conditional upon the absence of conflicting\n
      \  access, clients must not assume that a delegation will be granted,\n   and
      they must always be prepared for OPENs to be processed without\n   any delegations
      being granted.\n   Once granted, a delegation behaves in most ways like a lock.
      \ There\n   is an associated lease that is subject to renewal, together with
      all\n   of the other leases held by that client.\n   Unlike locks, an operation
      by a second client to a delegated file\n   will cause the server to recall a
      delegation through a callback.\n   On recall, the client holding the delegation
      must flush modified\n   state (such as modified data) to the server and return
      the\n   delegation.  The conflicting request will not be acted on until the\n
      \  recall is complete.  The recall is considered complete when the\n   client
      returns the delegation or the server times out its wait for\n   the delegation
      to be returned and revokes the delegation as a result\n   of the timeout.  In
      the interim, the server will either delay\n   responding to conflicting requests
      or respond to them with\n   NFS4ERR_DELAY.  Following the resolution of the
      recall, the server\n   has the information necessary to grant or deny the second
      client's\n   request.\n   At the time the client receives a delegation recall,
      it may have\n   substantial state that needs to be flushed to the server.  Therefore,\n
      \  the server should allow sufficient time for the delegation to be\n   returned
      since it may involve numerous RPCs to the server.  If the\n   server is able
      to determine that the client is diligently flushing\n   state to the server
      as a result of the recall, the server MAY extend\n   the usual time allowed
      for a recall.  However, the time allowed for\n   recall completion should not
      be unbounded.\n   An example of this is when responsibility to mediate opens
      on a given\n   file is delegated to a client (see Section 10.4).  The server
      will\n   not know what opens are in effect on the client.  Without this\n   knowledge,
      the server will be unable to determine if the access and\n   deny state for
      the file allows any particular open until the\n   delegation for the file has
      been returned.\n   A client failure or a network partition can result in failure
      to\n   respond to a recall callback.  In this case, the server will revoke\n
      \  the delegation; this in turn will render useless any modified state\n   still
      on the client.\n   Clients need to be aware that server implementers may enforce\n
      \  practical limitations on the number of delegations issued.  Further,\n   as
      there is no way to determine which delegations to revoke, the\n   server is
      allowed to revoke any.  If the server is implemented to\n   revoke another delegation
      held by that client, then the client may\n   be able to determine that a limit
      has been reached because each new\n   delegation request results in a revoke.
      \ The client could then\n   determine which delegations it may not need and
      preemptively\n   release them.\n"
    - contents:
      - "10.2.1.  Delegation Recovery\n   There are three situations that delegation
        recovery must deal with:\n   o  Client reboot or restart\n   o  Server reboot
        or restart (see Section 9.6.3.1)\n   o  Network partition (full or callback-only)\n
        \  In the event that the client reboots or restarts, the confirmation of\n
        \  a SETCLIENTID done with an nfs_client_id4 with a new verifier4 value\n
        \  will result in the release of byte-range locks and share\n   reservations.
        \ Delegations, however, may be treated a bit\n   differently.\n   There will
        be situations in which delegations will need to be\n   re-established after
        a client reboots or restarts.  The reason for\n   this is the client may have
        file data stored locally and this data\n   was associated with the previously
        held delegations.  The client will\n   need to re-establish the appropriate
        file state on the server.\n   To allow for this type of client recovery, the
        server MAY allow\n   delegations to be retained after other sorts of locks
        are released.\n   This implies that requests from other clients that conflict
        with\n   these delegations will need to wait.  Because the normal recall\n
        \  process may require significant time for the client to flush changed\n
        \  state to the server, other clients need to be prepared for delays\n   that
        occur because of a conflicting delegation.  In order to give\n   clients a
        chance to get through the reboot process -- during which\n   leases will not
        be renewed -- the server MAY extend the period for\n   delegation recovery
        beyond the typical lease expiration period.  For\n   open delegations, such
        delegations that are not released are\n   reclaimed using OPEN with a claim
        type of CLAIM_DELEGATE_PREV.  (See\n   Sections 10.5 and 16.16 for discussions
        of open delegation and the\n   details of OPEN, respectively.)\n   A server
        MAY support a claim type of CLAIM_DELEGATE_PREV, but if it\n   does, it MUST
        NOT remove delegations upon SETCLIENTID_CONFIRM and\n   instead MUST make
        them available for client reclaim using\n   CLAIM_DELEGATE_PREV.  The server
        MUST NOT remove the delegations\n   until either the client does a DELEGPURGE
        or one lease period has\n   elapsed from the time -- whichever is later --
        of the\n   SETCLIENTID_CONFIRM or the last successful CLAIM_DELEGATE_PREV\n
        \  reclaim.\n   Note that the requirement stated above is not meant to imply
        that,\n   when the server is no longer obliged, as required above, to retain\n
        \  delegation information, it should necessarily dispose of it.  Some\n   specific
        cases are:\n   o  When the period is terminated by the occurrence of DELEGPURGE,\n
        \     deletion of unreclaimed delegations is appropriate and desirable.\n
        \  o  When the period is terminated by a lease period elapsing without a\n
        \     successful CLAIM_DELEGATE_PREV reclaim, and that situation appears\n
        \     to be the result of a network partition (i.e., lease expiration\n      has
        occurred), a server's lease expiration approach, possibly\n      including
        the use of courtesy locks, would normally provide for\n      the retention
        of unreclaimed delegations.  Even in the event that\n      lease cancellation
        occurs, such delegation should be reclaimed\n      using CLAIM_DELEGATE_PREV
        as part of network partition recovery.\n   o  When the period of non-communicating
        is followed by a client\n      reboot, unreclaimed delegations should also
        be reclaimable by use\n      of CLAIM_DELEGATE_PREV as part of client reboot
        recovery.\n   o  When the period is terminated by a lease period elapsing
        without a\n      successful CLAIM_DELEGATE_PREV reclaim, and lease renewal
        is\n      occurring, the server may well conclude that unreclaimed\n      delegations
        have been abandoned and consider the situation as one\n      in which an implied
        DELEGPURGE should be assumed.\n   A server that supports a claim type of CLAIM_DELEGATE_PREV
        MUST\n   support the DELEGPURGE operation, and similarly, a server that\n
        \  supports DELEGPURGE MUST support CLAIM_DELEGATE_PREV.  A server that\n
        \  does not support CLAIM_DELEGATE_PREV MUST return NFS4ERR_NOTSUPP if\n   the
        client attempts to use that feature or performs a DELEGPURGE\n   operation.\n
        \  Support for a claim type of CLAIM_DELEGATE_PREV is often referred to\n
        \  as providing for \"client-persistent delegations\" in that they allow\n
        \  the use of persistent storage on the client to store data written by\n
        \  the client, even across a client restart.  It should be noted that,\n   with
        the optional exception noted below, this feature requires\n   persistent storage
        to be used on the client and does not add to\n   persistent storage requirements
        on the server.\n   One good way to think about client-persistent delegations
        is that for\n   the most part, they function like \"courtesy locks\", with
        special\n   semantic adjustments to allow them to be retained across a client\n
        \  restart, which cause all other sorts of locks to be freed.  Such\n   locks
        are generally not retained across a server restart.  The one\n   exception
        is the case of simultaneous failure of the client and\n   server and is discussed
        below.\n   When the server indicates support of CLAIM_DELEGATE_PREV (implicitly)\n
        \  by returning NFS_OK to DELEGPURGE, a client with a write delegation\n   can
        use write-back caching for data to be written to the server,\n   deferring
        the write-back until such time as the delegation is\n   recalled, possibly
        after intervening client restarts.  Similarly,\n   when the server indicates
        support of CLAIM_DELEGATE_PREV, a client\n   with a read delegation and an
        open-for-write subordinate to that\n   delegation may be sure of the integrity
        of its persistently cached\n   copy of the file after a client restart without
        specific verification\n   of the change attribute.\n   When the server reboots
        or restarts, delegations are reclaimed (using\n   the OPEN operation with
        CLAIM_PREVIOUS) in a similar fashion to\n   byte-range locks and share reservations.
        \ However, there is a slight\n   semantic difference.  In the normal case,
        if the server decides that\n   a delegation should not be granted, it performs
        the requested action\n   (e.g., OPEN) without granting any delegation.  For
        reclaim, the\n   server grants the delegation, but a special designation is
        applied so\n   that the client treats the delegation as having been granted
        but\n   recalled by the server.  Because of this, the client has the duty
        to\n   write all modified state to the server and then return the\n   delegation.
        \ This process of handling delegation reclaim reconciles\n   three principles
        of the NFSv4 protocol:\n   o  Upon reclaim, a client claiming resources assigned
        to it by an\n      earlier server instance must be granted those resources.\n
        \  o  The server has unquestionable authority to determine whether\n      delegations
        are to be granted and, once granted, whether they are\n      to be continued.\n
        \  o  The use of callbacks is not to be depended upon until the client\n      has
        proven its ability to receive them.\n   When a client has more than a single
        open associated with a\n   delegation, state for those additional opens can
        be established using\n   OPEN operations of type CLAIM_DELEGATE_CUR.  When
        these are used to\n   establish opens associated with reclaimed delegations,
        the server\n   MUST allow them when made within the grace period.\n   Situations
        in which there is a series of client and server restarts\n   where there is
        no restart of both at the same time are dealt with via\n   a combination of
        CLAIM_DELEGATE_PREV and CLAIM_PREVIOUS reclaim\n   cycles.  Persistent storage
        is needed only on the client.  For each\n   server failure, a CLAIM_PREVIOUS
        reclaim cycle is done, while for\n   each client restart, a CLAIM_DELEGATE_PREV
        reclaim cycle is done.\n   To deal with the possibility of simultaneous failure
        of client and\n   server (e.g., a data center power outage), the server MAY\n
        \  persistently store delegation information so that it can respond to a\n
        \  CLAIM_DELEGATE_PREV reclaim request that it receives from a\n   restarting
        client.  This is the one case in which persistent\n   delegation state can
        be retained across a server restart.  A server\n   is not required to store
        this information, but if it does do so, it\n   should do so for write delegations
        and for read delegations, during\n   the pendency of which (across multiple
        client and/or server\n   instances), some open-for-write was done as part
        of delegation.  When\n   the space to persistently record such information
        is limited, the\n   server should recall delegations in this class in preference
        to\n   keeping them active without persistent storage recording.\n   When
        a network partition occurs, delegations are subject to freeing\n   by the
        server when the lease renewal period expires.  This is similar\n   to the
        behavior for locks and share reservations, and as for locks\n   and share
        reservations, it may be modified by support for \"courtesy\n   locks\" in
        which locks are not freed in the absence of a conflicting\n   lock request.
        \ Whereas for locks and share reservations the freeing\n   of locks will occur
        immediately upon the appearance of a conflicting\n   request, for delegations,
        the server MAY institute a period during\n   which conflicting requests are
        held off.  Eventually, the occurrence\n   of a conflicting request from another
        client will cause revocation of\n   the delegation.\n   A loss of the callback
        path (e.g., by a later network configuration\n   change) will have a similar
        effect in that it can also result in\n   revocation of a delegation.  A recall
        request will fail, and\n   revocation of the delegation will result.\n   A
        client normally finds out about revocation of a delegation when it\n   uses
        a stateid associated with a delegation and receives one of the\n   errors
        NFS4ERR_EXPIRED, NFS4ERR_BAD_STATEID, or NFS4ERR_ADMIN_REVOKED\n   (NFS4ERR_EXPIRED
        indicates that all lock state associated with the\n   client has been lost).
        \ It also may find out about delegation\n   revocation after a client reboot
        when it attempts to reclaim a\n   delegation and receives NFS4ERR_EXPIRED.
        \ Note that in the case of a\n   revoked OPEN_DELEGATE_WRITE delegation, there
        are issues because data\n   may have been modified by the client whose delegation
        is revoked and,\n   separately, by other clients.  See Section 10.5.1 for
        a discussion of\n   such issues.  Note also that when delegations are revoked,\n
        \  information about the revoked delegation will be written by the\n   server
        to stable storage (as described in Section 9.6).  This is done\n   to deal
        with the case in which a server reboots after revoking a\n   delegation but
        before the client holding the revoked delegation is\n   notified about the
        revocation.\n   Note that when there is a loss of a delegation, due to a network\n
        \  partition in which all locks associated with the lease are lost, the\n
        \  client will also receive the error NFS4ERR_EXPIRED.  This case can be\n
        \  distinguished from other situations in which delegations are revoked\n
        \  by seeing that the associated clientid becomes invalid so that\n   NFS4ERR_STALE_CLIENTID
        is returned when it is used.\n   When NFS4ERR_EXPIRED is returned, the server
        MAY retain information\n   about the delegations held by the client, deleting
        those that are\n   invalidated by a conflicting request.  Retaining such information\n
        \  will allow the client to recover all non-invalidated delegations\n   using
        the claim type CLAIM_DELEGATE_PREV, once the\n   SETCLIENTID_CONFIRM is done
        to recover.  Attempted recovery of a\n   delegation that the client has no
        record of, typically because they\n   were invalidated by conflicting requests,
        will result in the error\n   NFS4ERR_BAD_RECLAIM.  Once a reclaim is attempted
        for all delegations\n   that the client held, it SHOULD do a DELEGPURGE to
        allow any\n   remaining server delegation information to be freed.\n"
      title: 10.2.1.  Delegation Recovery
    title: 10.2.  Delegation and Callbacks
  - contents:
    - "10.3.  Data Caching\n   When applications share access to a set of files, they
      need to be\n   implemented so as to take account of the possibility of conflicting\n
      \  access by another application.  This is true whether the applications\n   in
      question execute on different clients or reside on the same\n   client.\n   Share
      reservations and byte-range locks are the facilities the NFSv4\n   protocol
      provides to allow applications to coordinate access by\n   providing mutual
      exclusion facilities.  The NFSv4 protocol's data\n   caching must be implemented
      such that it does not invalidate the\n   assumptions that those using these
      facilities depend upon.\n"
    - contents:
      - "10.3.1.  Data Caching and OPENs\n   In order to avoid invalidating the sharing
        assumptions that\n   applications rely on, NFSv4 clients should not provide
        cached data to\n   applications or modify it on behalf of an application when
        it would\n   not be valid to obtain or modify that same data via a READ or
        WRITE\n   operation.\n   Furthermore, in the absence of open delegation (see
        Section 10.4),\n   two additional rules apply.  Note that these rules are
        obeyed in\n   practice by many NFSv2 and NFSv3 clients.\n   o  First, cached
        data present on a client must be revalidated after\n      doing an OPEN.  Revalidating
        means that the client fetches the\n      change attribute from the server,
        compares it with the cached\n      change attribute, and, if different, declares
        the cached data (as\n      well as the cached attributes) as invalid.  This
        is to ensure that\n      the data for the OPENed file is still correctly reflected
        in the\n      client's cache.  This validation must be done at least when
        the\n      client's OPEN operation includes DENY=WRITE or BOTH, thus\n      terminating
        a period in which other clients may have had the\n      opportunity to open
        the file with WRITE access.  Clients may\n      choose to do the revalidation
        more often (such as at OPENs\n      specifying DENY=NONE) to parallel the
        NFSv3 protocol's practice\n      for the benefit of users assuming this degree
        of cache\n      revalidation.\n      Since the change attribute is updated
        for data and metadata\n      modifications, some client implementers may be
        tempted to use the\n      time_modify attribute and not the change attribute
        to validate\n      cached data, so that metadata changes do not spuriously
        invalidate\n      clean data.  The implementer is cautioned against this approach.\n
        \     The change attribute is guaranteed to change for each update to\n      the
        file, whereas time_modify is guaranteed to change only at the\n      granularity
        of the time_delta attribute.  Use by the client's data\n      cache validation
        logic of time_modify and not the change attribute\n      runs the risk of
        the client incorrectly marking stale data as\n      valid.\n   o  Second,
        modified data must be flushed to the server before closing\n      a file OPENed
        for write.  This is complementary to the first rule.\n      If the data is
        not flushed at CLOSE, the revalidation done after\n      the client OPENs
        a file is unable to achieve its purpose.  The\n      other aspect to flushing
        the data before close is that the data\n      must be committed to stable
        storage, at the server, before the\n      CLOSE operation is requested by
        the client.  In the case of a\n      server reboot or restart and a CLOSEd
        file, it may not be possible\n      to retransmit the data to be written to
        the file -- hence, this\n      requirement.\n"
      title: 10.3.1.  Data Caching and OPENs
    - contents:
      - "10.3.2.  Data Caching and File Locking\n   For those applications that choose
        to use file locking instead of\n   share reservations to exclude inconsistent
        file access, there is an\n   analogous set of constraints that apply to client-side
        data caching.\n   These rules are effective only if the file locking is used
        in a way\n   that matches in an equivalent way the actual READ and WRITE\n
        \  operations executed.  This is as opposed to file locking that is\n   based
        on pure convention.  For example, it is possible to manipulate\n   a two-megabyte
        file by dividing the file into two one-megabyte\n   regions and protecting
        access to the two regions by file locks on\n   bytes zero and one.  A lock
        for write on byte zero of the file would\n   represent the right to do READ
        and WRITE operations on the first\n   region.  A lock for write on byte one
        of the file would represent the\n   right to do READ and WRITE operations
        on the second region.  As long\n   as all applications manipulating the file
        obey this convention, they\n   will work on a local file system.  However,
        they may not work with\n   the NFSv4 protocol unless clients refrain from
        data caching.\n   The rules for data caching in the file locking environment
        are:\n   o  First, when a client obtains a file lock for a particular region,\n
        \     the data cache corresponding to that region (if any cached data\n      exists)
        must be revalidated.  If the change attribute indicates\n      that the file
        may have been updated since the cached data was\n      obtained, the client
        must flush or invalidate the cached data for\n      the newly locked region.
        \ A client might choose to invalidate all\n      of the non-modified cached
        data that it has for the file, but the\n      only requirement for correct
        operation is to invalidate all of the\n      data in the newly locked region.\n
        \  o  Second, before releasing a write lock for a region, all modified\n      data
        for that region must be flushed to the server.  The modified\n      data must
        also be written to stable storage.\n   Note that flushing data to the server
        and the invalidation of cached\n   data must reflect the actual byte ranges
        locked or unlocked.\n   Rounding these up or down to reflect client cache
        block boundaries\n   will cause problems if not carefully done.  For example,
        writing a\n   modified block when only half of that block is within an area
        being\n   unlocked may cause invalid modification to the region outside the\n
        \  unlocked area.  This, in turn, may be part of a region locked by\n   another
        client.  Clients can avoid this situation by synchronously\n   performing
        portions of WRITE operations that overlap that portion\n   (initial or final)
        that is not a full block.  Similarly, invalidating\n   a locked area that
        is not an integral number of full buffer blocks\n   would require the client
        to read one or two partial blocks from the\n   server if the revalidation
        procedure shows that the data that the\n   client possesses may not be valid.\n
        \  The data that is written to the server as a prerequisite to the\n   unlocking
        of a region must be written, at the server, to stable\n   storage.  The client
        may accomplish this either with synchronous\n   writes or by following asynchronous
        writes with a COMMIT operation.\n   This is required because retransmission
        of the modified data after a\n   server reboot might conflict with a lock
        held by another client.\n   A client implementation may choose to accommodate
        applications that\n   use byte-range locking in non-standard ways (e.g., using
        a byte-range\n   lock as a global semaphore) by flushing to the server more
        data upon\n   a LOCKU than is covered by the locked range.  This may include\n
        \  modified data within files other than the one for which the unlocks\n   are
        being done.  In such cases, the client must not interfere with\n   applications
        whose READs and WRITEs are being done only within the\n   bounds of record
        locks that the application holds.  For example, an\n   application locks a
        single byte of a file and proceeds to write that\n   single byte.  A client
        that chose to handle a LOCKU by flushing all\n   modified data to the server
        could validly write that single byte in\n   response to an unrelated unlock.
        \ However, it would not be valid to\n   write the entire block in which that
        single written byte was located\n   since it includes an area that is not
        locked and might be locked by\n   another client.  Client implementations
        can avoid this problem by\n   dividing files with modified data into those
        for which all\n   modifications are done to areas covered by an appropriate
        byte-range\n   lock and those for which there are modifications not covered
        by a\n   byte-range lock.  Any writes done for the former class of files must\n
        \  not include areas not locked and thus not modified on the client.\n"
      title: 10.3.2.  Data Caching and File Locking
    - contents:
      - "10.3.3.  Data Caching and Mandatory File Locking\n   Client-side data caching
        needs to respect mandatory file locking when\n   it is in effect.  The presence
        of mandatory file locking for a given\n   file is indicated when the client
        gets back NFS4ERR_LOCKED from a\n   READ or WRITE on a file it has an appropriate
        share reservation for.\n   When mandatory locking is in effect for a file,
        the client must check\n   for an appropriate file lock for data being read
        or written.  If a\n   lock exists for the range being read or written, the
        client may\n   satisfy the request using the client's validated cache.  If
        an\n   appropriate file lock is not held for the range of the READ or WRITE,\n
        \  the READ or WRITE request must not be satisfied by the client's cache\n
        \  and the request must be sent to the server for processing.  When a\n   READ
        or WRITE request partially overlaps a locked region, the request\n   should
        be subdivided into multiple pieces with each region (locked or\n   not) treated
        appropriately.\n"
      title: 10.3.3.  Data Caching and Mandatory File Locking
    - contents:
      - "10.3.4.  Data Caching and File Identity\n   When clients cache data, the
        file data needs to be organized\n   according to the file system object to
        which the data belongs.  For\n   NFSv3 clients, the typical practice has been
        to assume for the\n   purpose of caching that distinct filehandles represent
        distinct file\n   system objects.  The client then has the choice to organize
        and\n   maintain the data cache on this basis.\n   In the NFSv4 protocol,
        there is now the possibility of having\n   significant deviations from a \"one
        filehandle per object\" model,\n   because a filehandle may be constructed
        on the basis of the object's\n   pathname.  Therefore, clients need a reliable
        method to determine if\n   two filehandles designate the same file system
        object.  If clients\n   were simply to assume that all distinct filehandles
        denote distinct\n   objects and proceed to do data caching on this basis,
        caching\n   inconsistencies would arise between the distinct client-side objects\n
        \  that mapped to the same server-side object.\n   By providing a method to
        differentiate filehandles, the NFSv4\n   protocol alleviates a potential functional
        regression in comparison\n   with the NFSv3 protocol.  Without this method,
        caching\n   inconsistencies within the same client could occur, and this has
        not\n   been present in previous versions of the NFS protocol.  Note that
        it\n   is possible to have such inconsistencies with applications executing\n
        \  on multiple clients, but that is not the issue being addressed here.\n
        \  For the purposes of data caching, the following steps allow an NFSv4\n
        \  client to determine whether two distinct filehandles denote the same\n
        \  server-side object:\n   o  If GETATTR directed to two filehandles returns
        different values of\n      the fsid attribute, then the filehandles represent
        distinct\n      objects.\n   o  If GETATTR for any file with an fsid that
        matches the fsid of the\n      two filehandles in question returns a unique_handles
        attribute\n      with a value of TRUE, then the two objects are distinct.\n
        \  o  If GETATTR directed to the two filehandles does not return the\n      fileid
        attribute for both of the handles, then it cannot be\n      determined whether
        the two objects are the same.  Therefore,\n      operations that depend on
        that knowledge (e.g., client-side data\n      caching) cannot be done reliably.
        \ Note that if GETATTR does not\n      return the fileid attribute for both
        filehandles, it will return\n      it for neither of the filehandles, since
        the fsid for both\n      filehandles is the same.\n   o  If GETATTR directed
        to the two filehandles returns different\n      values for the fileid attribute,
        then they are distinct objects.\n   o  Otherwise, they are the same object.\n"
      title: 10.3.4.  Data Caching and File Identity
    title: 10.3.  Data Caching
  - contents:
    - "10.4.  Open Delegation\n   When a file is being OPENed, the server may delegate
      further handling\n   of opens and closes for that file to the opening client.
      \ Any such\n   delegation is recallable, since the circumstances that allowed
      for\n   the delegation are subject to change.  In particular, the server may\n
      \  receive a conflicting OPEN from another client; the server must\n   recall
      the delegation before deciding whether the OPEN from the other\n   client may
      be granted.  Making a delegation is up to the server, and\n   clients should
      not assume that any particular OPEN either will or\n   will not result in an
      open delegation.  The following is a typical\n   set of conditions that servers
      might use in deciding whether OPEN\n   should be delegated:\n   o  The client
      must be able to respond to the server's callback\n      requests.  The server
      will use the CB_NULL procedure for a test of\n      callback ability.\n   o
      \ The client must have responded properly to previous recalls.\n   o  There
      must be no current open conflicting with the requested\n      delegation.\n
      \  o  There should be no current delegation that conflicts with the\n      delegation
      being requested.\n   o  The probability of future conflicting open requests
      should be low,\n      based on the recent history of the file.\n   o  The existence
      of any server-specific semantics of OPEN/CLOSE that\n      would make the required
      handling incompatible with the prescribed\n      handling that the delegated
      client would apply (see below).\n   There are two types of open delegations:
      OPEN_DELEGATE_READ and\n   OPEN_DELEGATE_WRITE.  An OPEN_DELEGATE_READ delegation
      allows a\n   client to handle, on its own, requests to open a file for reading\n
      \  that do not deny read access to others.  It MUST, however, continue\n   to
      send all requests to open a file for writing to the server.\n   Multiple OPEN_DELEGATE_READ
      delegations may be outstanding\n   simultaneously and do not conflict.  An OPEN_DELEGATE_WRITE\n
      \  delegation allows the client to handle, on its own, all opens.  Only\n   one
      OPEN_DELEGATE_WRITE delegation may exist for a given file at a\n   given time,
      and it is inconsistent with any OPEN_DELEGATE_READ\n   delegations.\n   When
      a single client holds an OPEN_DELEGATE_READ delegation, it is\n   assured that
      no other client may modify the contents or attributes of\n   the file.  If more
      than one client holds an OPEN_DELEGATE_READ\n   delegation, then the contents
      and attributes of that file are not\n   allowed to change.  When a client has
      an OPEN_DELEGATE_WRITE\n   delegation, it may modify the file data since no
      other client will be\n   accessing the file's data.  The client holding an OPEN_DELEGATE_WRITE\n
      \  delegation may only affect file attributes that are intimately\n   connected
      with the file data: size, time_modify, and change.\n   When a client has an
      open delegation, it does not send OPENs or\n   CLOSEs to the server but updates
      the appropriate status internally.\n   For an OPEN_DELEGATE_READ delegation,
      opens that cannot be handled\n   locally (opens for write or that deny read
      access) must be sent to\n   the server.\n   When an open delegation is made,
      the response to the OPEN contains an\n   open delegation structure that specifies
      the following:\n   o  the type of delegation (read or write)\n   o  space limitation
      information to control flushing of data on close\n      (OPEN_DELEGATE_WRITE
      delegation only; see Section 10.4.1)\n   o  an nfsace4 specifying read and write
      permissions\n   o  a stateid to represent the delegation for READ and WRITE\n
      \  The delegation stateid is separate and distinct from the stateid for\n   the
      OPEN proper.  The standard stateid, unlike the delegation\n   stateid, is associated
      with a particular open-owner and will continue\n   to be valid after the delegation
      is recalled and the file remains\n   open.\n   When a request internal to the
      client is made to open a file and open\n   delegation is in effect, it will
      be accepted or rejected solely on\n   the basis of the following conditions.
      \ Any requirement for other\n   checks to be made by the delegate should result
      in open delegation\n   being denied so that the checks can be made by the server
      itself.\n   o  The access and deny bits for the request and the file, as\n      described
      in Section 9.9.\n   o  The read and write permissions, as determined below.\n
      \  The nfsace4 passed with delegation can be used to avoid frequent\n   ACCESS
      calls.  The permission check should be as follows:\n   o  If the nfsace4 indicates
      that the open may be done, then it should\n      be granted without reference
      to the server.\n   o  If the nfsace4 indicates that the open may not be done,
      then an\n      ACCESS request must be sent to the server to obtain the definitive\n
      \     answer.\n   The server may return an nfsace4 that is more restrictive
      than the\n   actual ACL of the file.  This includes an nfsace4 that specifies\n
      \  denial of all access.  Note that some common practices, such as\n   mapping
      the traditional user \"root\" to the user \"nobody\", may make it\n   incorrect
      to return the actual ACL of the file in the delegation\n   response.\n   The
      use of delegation, together with various other forms of caching,\n   creates
      the possibility that no server authentication will ever be\n   performed for
      a given user since all of the user's requests might be\n   satisfied locally.
      \ Where the client is depending on the server for\n   authentication, the client
      should be sure authentication occurs for\n   each user by use of the ACCESS
      operation.  This should be the case\n   even if an ACCESS operation would not
      be required otherwise.  As\n   mentioned before, the server may enforce frequent
      authentication by\n   returning an nfsace4 denying all access with every open
      delegation.\n"
    - contents:
      - "10.4.1.  Open Delegation and Data Caching\n   OPEN delegation allows much
        of the message overhead associated with\n   the opening and closing files
        to be eliminated.  An open when an open\n   delegation is in effect does not
        require that a validation message be\n   sent to the server unless there exists
        a potential for conflict with\n   the requested share mode.  The continued
        endurance of the\n   \"OPEN_DELEGATE_READ delegation\" provides a guarantee
        that no OPEN for\n   write and thus no write has occurred that did not originate
        from this\n   client.  Similarly, when closing a file opened for write and
        if\n   OPEN_DELEGATE_WRITE delegation is in effect, the data written does\n
        \  not have to be flushed to the server until the open delegation is\n   recalled.
        \ The continued endurance of the open delegation provides a\n   guarantee
        that no open and thus no read or write has been done by\n   another client.\n
        \  For the purposes of open delegation, READs and WRITEs done without an\n
        \  OPEN (anonymous and READ bypass stateids) are treated as the\n   functional
        equivalents of a corresponding type of OPEN.  READs and\n   WRITEs done with
        an anonymous stateid done by another client will\n   force the server to recall
        an OPEN_DELEGATE_WRITE delegation.  A\n   WRITE with an anonymous stateid
        done by another client will force a\n   recall of OPEN_DELEGATE_READ delegations.
        \ The handling of a READ\n   bypass stateid is identical, except that a READ
        done with a READ\n   bypass stateid will not force a recall of an OPEN_DELEGATE_READ\n
        \  delegation.\n   With delegations, a client is able to avoid writing data
        to the\n   server when the CLOSE of a file is serviced.  The file close system\n
        \  call is the usual point at which the client is notified of a lack of\n
        \  stable storage for the modified file data generated by the\n   application.
        \ At the close, file data is written to the server, and\n   through normal
        accounting the server is able to determine if the\n   available file system
        space for the data has been exceeded (i.e., the\n   server returns NFS4ERR_NOSPC
        or NFS4ERR_DQUOT).  This accounting\n   includes quotas.  The introduction
        of delegations requires that an\n   alternative method be in place for the
        same type of communication to\n   occur between client and server.\n   In
        the delegation response, the server provides either the limit of\n   the size
        of the file or the number of modified blocks and associated\n   block size.
        \ The server must ensure that the client will be able to\n   flush to the
        server data of a size equal to that provided in the\n   original delegation.
        \ The server must make this assurance for all\n   outstanding delegations.
        \ Therefore, the server must be careful in\n   its management of available
        space for new or modified data, taking\n   into account available file system
        space and any applicable quotas.\n   The server can recall delegations as
        a result of managing the\n   available file system space.  The client should
        abide by the server's\n   state space limits for delegations.  If the client
        exceeds the stated\n   limits for the delegation, the server's behavior is
        undefined.\n   Based on server conditions, quotas, or available file system
        space,\n   the server may grant OPEN_DELEGATE_WRITE delegations with very\n
        \  restrictive space limitations.  The limitations may be defined in a\n   way
        that will always force modified data to be flushed to the server\n   on close.\n
        \  With respect to authentication, flushing modified data to the server\n
        \  after a CLOSE has occurred may be problematic.  For example, the user\n
        \  of the application may have logged off the client, and unexpired\n   authentication
        credentials may not be present.  In this case, the\n   client may need to
        take special care to ensure that local unexpired\n   credentials will in fact
        be available.  One way that this may be\n   accomplished is by tracking the
        expiration time of credentials and\n   flushing data well in advance of their
        expiration.\n"
      title: 10.4.1.  Open Delegation and Data Caching
    - contents:
      - "10.4.2.  Open Delegation and File Locks\n   When a client holds an OPEN_DELEGATE_WRITE
        delegation, lock\n   operations may be performed locally.  This includes those
        required\n   for mandatory file locking.  This can be done since the delegation\n
        \  implies that there can be no conflicting locks.  Similarly, all of\n   the
        revalidations that would normally be associated with obtaining\n   locks and
        the flushing of data associated with the releasing of locks\n   need not be
        done.\n   When a client holds an OPEN_DELEGATE_READ delegation, lock operations\n
        \  are not performed locally.  All lock operations, including those\n   requesting
        non-exclusive locks, are sent to the server for\n   resolution.\n"
      title: 10.4.2.  Open Delegation and File Locks
    - contents:
      - "10.4.3.  Handling of CB_GETATTR\n   The server needs to employ special handling
        for a GETATTR where the\n   target is a file that has an OPEN_DELEGATE_WRITE
        delegation in\n   effect.  The reason for this is that the client holding
        the\n   OPEN_DELEGATE_WRITE delegation may have modified the data, and the\n
        \  server needs to reflect this change to the second client that\n   submitted
        the GETATTR.  Therefore, the client holding the\n   OPEN_DELEGATE_WRITE delegation
        needs to be interrogated.  The server\n   will use the CB_GETATTR operation.
        \ The only attributes that the\n   server can reliably query via CB_GETATTR
        are size and change.\n   Since CB_GETATTR is being used to satisfy another
        client's GETATTR\n   request, the server only needs to know if the client
        holding the\n   delegation has a modified version of the file.  If the client's
        copy\n   of the delegated file is not modified (data or size), the server
        can\n   satisfy the second client's GETATTR request from the attributes\n
        \  stored locally at the server.  If the file is modified, the server\n   only
        needs to know about this modified state.  If the server\n   determines that
        the file is currently modified, it will respond to\n   the second client's
        GETATTR as if the file had been modified locally\n   at the server.\n   Since
        the form of the change attribute is determined by the server\n   and is opaque
        to the client, the client and server need to agree on a\n   method of communicating
        the modified state of the file.  For the size\n   attribute, the client will
        report its current view of the file size.\n   For the change attribute, the
        handling is more involved.\n   For the client, the following steps will be
        taken when receiving an\n   OPEN_DELEGATE_WRITE delegation:\n   o  The value
        of the change attribute will be obtained from the server\n      and cached.
        \ Let this value be represented by c.\n   o  The client will create a value
        greater than c that will be used\n      for communicating that modified data
        is held at the client.  Let\n      this value be represented by d.\n   o  When
        the client is queried via CB_GETATTR for the change\n      attribute, it checks
        to see if it holds modified data.  If the\n      file is modified, the value
        d is returned for the change attribute\n      value.  If this file is not
        currently modified, the client returns\n      the value c for the change attribute.\n
        \  For simplicity of implementation, the client MAY for each CB_GETATTR\n
        \  return the same value d.  This is true even if, between successive\n   CB_GETATTR
        operations, the client again modifies in the file's data\n   or metadata in
        its cache.  The client can return the same value\n   because the only requirement
        is that the client be able to indicate\n   to the server that the client holds
        modified data.  Therefore, the\n   value of d may always be c + 1.\n   While
        the change attribute is opaque to the client in the sense that\n   it has
        no idea what units of time, if any, the server is counting\n   change with,
        it is not opaque in that the client has to treat it as\n   an unsigned integer,
        and the server has to be able to see the results\n   of the client's changes
        to that integer.  Therefore, the server MUST\n   encode the change attribute
        in network byte order when sending it to\n   the client.  The client MUST
        decode it from network byte order to its\n   native order when receiving it,
        and the client MUST encode it in\n   network byte order when sending it to
        the server.  For this reason,\n   the change attribute is defined as an unsigned
        integer rather than an\n   opaque array of bytes.\n   For the server, the
        following steps will be taken when providing an\n   OPEN_DELEGATE_WRITE delegation:\n
        \  o  Upon providing an OPEN_DELEGATE_WRITE delegation, the server will\n
        \     cache a copy of the change attribute in the data structure it uses\n
        \     to record the delegation.  Let this value be represented by sc.\n   o
        \ When a second client sends a GETATTR operation on the same file to\n      the
        server, the server obtains the change attribute from the first\n      client.
        \ Let this value be cc.\n   o  If the value cc is equal to sc, the file is
        not modified and the\n      server returns the current values for change,
        time_metadata, and\n      time_modify (for example) to the second client.\n
        \  o  If the value cc is NOT equal to sc, the file is currently modified\n
        \     at the first client and most likely will be modified at the server\n
        \     at a future time.  The server then uses its current time to\n      construct
        attribute values for time_metadata and time_modify.  A\n      new value of
        sc, which we will call nsc, is computed by the\n      server, such that nsc
        >= sc + 1.  The server then returns the\n      constructed time_metadata,
        time_modify, and nsc values to the\n      requester.  The server replaces
        sc in the delegation record with\n      nsc.  To prevent the possibility of
        time_modify, time_metadata,\n      and change from appearing to go backward
        (which would happen if\n      the client holding the delegation fails to write
        its modified data\n      to the server before the delegation is revoked or
        returned), the\n      server SHOULD update the file's metadata record with
        the\n      constructed attribute values.  For reasons of reasonable\n      performance,
        committing the constructed attribute values to stable\n      storage is OPTIONAL.\n
        \  As discussed earlier in this section, the client MAY return the same\n
        \  cc value on subsequent CB_GETATTR calls, even if the file was\n   modified
        in the client's cache yet again between successive\n   CB_GETATTR calls.  Therefore,
        the server must assume that the file\n   has been modified yet again and MUST
        take care to ensure that the new\n   nsc it constructs and returns is greater
        than the previous nsc it\n   returned.  An example implementation's delegation
        record would\n   satisfy this mandate by including a boolean field (let us
        call it\n   \"modified\") that is set to FALSE when the delegation is granted,
        and\n   an sc value set at the time of grant to the change attribute value.\n
        \  The modified field would be set to TRUE the first time cc != sc and\n   would
        stay TRUE until the delegation is returned or revoked.  The\n   processing
        for constructing nsc, time_modify, and time_metadata would\n   use this pseudo-code:\n
        \      if (!modified) {\n           do CB_GETATTR for change and size;\n           if
        (cc != sc)\n               modified = TRUE;\n       } else {\n           do
        CB_GETATTR for size;\n       }\n       if (modified) {\n           sc = sc
        + 1;\n           time_modify = time_metadata = current_time;\n           update
        sc, time_modify, time_metadata into file's metadata;\n       }\n   This would
        return to the client (that sent GETATTR) the attributes it\n   requested but
        would make sure that size comes from what CB_GETATTR\n   returned.  The server
        would not update the file's metadata with the\n   client's modified size.\n
        \  In the case that the file attribute size is different than the\n   server's
        current value, the server treats this as a modification\n   regardless of
        the value of the change attribute retrieved via\n   CB_GETATTR and responds
        to the second client as in the last step.\n   This methodology resolves issues
        of clock differences between\n   client and server and other scenarios where
        the use of CB_GETATTR\n   breaks down.\n   It should be noted that the server
        is under no obligation to use\n   CB_GETATTR; therefore, the server MAY simply
        recall the delegation to\n   avoid its use.\n"
      title: 10.4.3.  Handling of CB_GETATTR
    - contents:
      - "10.4.4.  Recall of Open Delegation\n   The following events necessitate the
        recall of an open delegation:\n   o  Potentially conflicting OPEN request
        (or READ/WRITE done with\n      \"special\" stateid)\n   o  SETATTR issued
        by another client\n   o  REMOVE request for the file\n   o  RENAME request
        for the file as either source or target of the\n      RENAME\n   Whether a
        RENAME of a directory in the path leading to the file\n   results in the recall
        of an open delegation depends on the semantics\n   of the server file system.
        \ If that file system denies such RENAMEs\n   when a file is open, the recall
        must be performed to determine\n   whether the file in question is, in fact,
        open.\n   In addition to the situations above, the server may choose to recall\n
        \  open delegations at any time if resource constraints make it\n   advisable
        to do so.  Clients should always be prepared for the\n   possibility of a
        recall.\n   When a client receives a recall for an open delegation, it needs
        to\n   update state on the server before returning the delegation.  These\n
        \  same updates must be done whenever a client chooses to return a\n   delegation
        voluntarily.  The following items of state need to be\n   dealt with:\n   o
        \ If the file associated with the delegation is no longer open and\n      no
        previous CLOSE operation has been sent to the server, a CLOSE\n      operation
        must be sent to the server.\n   o  If a file has other open references at
        the client, then OPEN\n      operations must be sent to the server.  The appropriate
        stateids\n      will be provided by the server for subsequent use by the client\n
        \     since the delegation stateid will not longer be valid.  These OPEN\n
        \     requests are done with the claim type of CLAIM_DELEGATE_CUR.  This\n
        \     will allow the presentation of the delegation stateid so that the\n
        \     client can establish the appropriate rights to perform the OPEN.\n      (See
        Section 16.16 for details.)\n   o  If there are granted file locks, the corresponding
        LOCK operations\n      need to be performed.  This applies to the OPEN_DELEGATE_WRITE\n
        \     delegation case only.\n   o  For an OPEN_DELEGATE_WRITE delegation,
        if at the time of the\n      recall the file is not open for write, all modified
        data for the\n      file must be flushed to the server.  If the delegation
        had not\n      existed, the client would have done this data flush before
        the\n      CLOSE operation.\n   o  For an OPEN_DELEGATE_WRITE delegation,
        when a file is still open\n      at the time of the recall, any modified data
        for the file needs to\n      be flushed to the server.\n   o  With the OPEN_DELEGATE_WRITE
        delegation in place, it is possible\n      that the file was truncated during
        the duration of the delegation.\n      For example, the truncation could have
        occurred as a result of an\n      OPEN UNCHECKED4 with a size attribute value
        of zero.  Therefore,\n      if a truncation of the file has occurred and this
        operation has\n      not been propagated to the server, the truncation must
        occur\n      before any modified data is written to the server.\n   In the
        case of an OPEN_DELEGATE_WRITE delegation, file locking\n   imposes some additional
        requirements.  To precisely maintain the\n   associated invariant, it is required
        to flush any modified data in\n   any region for which a write lock was released
        while the\n   OPEN_DELEGATE_WRITE delegation was in effect.  However, because
        the\n   OPEN_DELEGATE_WRITE delegation implies no other locking by other\n
        \  clients, a simpler implementation is to flush all modified data for\n   the
        file (as described just above) if any write lock has been\n   released while
        the OPEN_DELEGATE_WRITE delegation was in effect.\n   An implementation need
        not wait until delegation recall (or deciding\n   to voluntarily return a
        delegation) to perform any of the above\n   actions, if implementation considerations
        (e.g., resource\n   availability constraints) make that desirable.  Generally,
        however,\n   the fact that the actual open state of the file may continue
        to\n   change makes it not worthwhile to send information about opens and\n
        \  closes to the server, except as part of delegation return.  Only in\n   the
        case of closing the open that resulted in obtaining the\n   delegation would
        clients be likely to do this early, since, in that\n   case, the close once
        done will not be undone.  Regardless of the\n   client's choices on scheduling
        these actions, all must be performed\n   before the delegation is returned,
        including (when applicable) the\n   close that corresponds to the open that
        resulted in the delegation.\n   These actions can be performed either in previous
        requests or in\n   previous operations in the same COMPOUND request.\n"
      title: 10.4.4.  Recall of Open Delegation
    - contents:
      - "10.4.5.  OPEN Delegation Race with CB_RECALL\n   The server informs the client
        of a recall via a CB_RECALL.  A race\n   case that may develop is when the
        delegation is immediately recalled\n   before the COMPOUND that established
        the delegation is returned to\n   the client.  As the CB_RECALL provides both
        a stateid and a\n   filehandle for which the client has no mapping, it cannot
        honor the\n   recall attempt.  At this point, the client has two choices:
        either do\n   not respond or respond with NFS4ERR_BADHANDLE.  If it does not\n
        \  respond, then it runs the risk of the server deciding to not grant it\n
        \  further delegations.\n   If instead it does reply with NFS4ERR_BADHANDLE,
        then both the client\n   and the server might be able to detect that a race
        condition is\n   occurring.  The client can keep a list of pending delegations.
        \ When\n   it receives a CB_RECALL for an unknown delegation, it can cache
        the\n   stateid and filehandle on a list of pending recalls.  When it is\n
        \  provided with a delegation, it would only use it if it was not on the\n
        \  pending recall list.  Upon the next CB_RECALL, it could immediately\n   return
        the delegation.\n   In turn, the server can keep track of when it issues a
        delegation and\n   assume that if a client responds to the CB_RECALL with
        an\n   NFS4ERR_BADHANDLE, then the client has yet to receive the delegation.\n
        \  The server SHOULD give the client a reasonable time both to get this\n
        \  delegation and to return it before revoking the delegation.  Unlike a\n
        \  failed callback path, the server should periodically probe the client\n
        \  with CB_RECALL to see if it has received the delegation and is ready\n
        \  to return it.\n   When the server finally determines that enough time has
        elapsed, it\n   SHOULD revoke the delegation and it SHOULD NOT revoke the
        lease.\n   During this extended recall process, the server SHOULD be renewing\n
        \  the client lease.  The intent here is that the client not pay too\n   onerous
        a burden for a condition caused by the server.\n"
      title: 10.4.5.  OPEN Delegation Race with CB_RECALL
    - contents:
      - "10.4.6.  Clients That Fail to Honor Delegation Recalls\n   A client may fail
        to respond to a recall for various reasons, such as\n   a failure of the callback
        path from the server to the client.  The\n   client may be unaware of a failure
        in the callback path.  This lack\n   of awareness could result in the client
        finding out long after the\n   failure that its delegation has been revoked,
        and another client has\n   modified the data for which the client had a delegation.
        \ This is\n   especially a problem for the client that held an OPEN_DELEGATE_WRITE\n
        \  delegation.\n   The server also has a dilemma in that the client that fails
        to\n   respond to the recall might also be sending other NFS requests,\n   including
        those that renew the lease before the lease expires.\n   Without returning
        an error for those lease-renewing operations, the\n   server leads the client
        to believe that the delegation it has is\n   in force.\n   This difficulty
        is solved by the following rules:\n   o  When the callback path is down, the
        server MUST NOT revoke the\n      delegation if one of the following occurs:\n
        \     *  The client has issued a RENEW operation, and the server has\n         returned
        an NFS4ERR_CB_PATH_DOWN error.  The server MUST renew\n         the lease
        for any byte-range locks and share reservations the\n         client has that
        the server has known about (as opposed to those\n         locks and share
        reservations the client has established but not\n         yet sent to the
        server, due to the delegation).  The server\n         SHOULD give the client
        a reasonable time to return its\n         delegations to the server before
        revoking the client's\n         delegations.\n      *  The client has not
        issued a RENEW operation for some period of\n         time after the server
        attempted to recall the delegation.  This\n         period of time MUST NOT
        be less than the value of the\n         lease_time attribute.\n   o  When
        the client holds a delegation, it cannot rely on operations,\n      except
        for RENEW, that take a stateid, to renew delegation leases\n      across callback
        path failures.  The client that wants to keep\n      delegations in force
        across callback path failures must use RENEW\n      to do so.\n"
      title: 10.4.6.  Clients That Fail to Honor Delegation Recalls
    - contents:
      - "10.4.7.  Delegation Revocation\n   At the point a delegation is revoked,
        if there are associated opens\n   on the client, the applications holding
        these opens need to be\n   notified.  This notification usually occurs by
        returning errors for\n   READ/WRITE operations or when a close is attempted
        for the open file.\n   If no opens exist for the file at the point the delegation
        is\n   revoked, then notification of the revocation is unnecessary.\n   However,
        if there is modified data present at the client for the\n   file, the user
        of the application should be notified.  Unfortunately,\n   it may not be possible
        to notify the user since active applications\n   may not be present at the
        client.  See Section 10.5.1 for additional\n   details.\n"
      title: 10.4.7.  Delegation Revocation
    title: 10.4.  Open Delegation
  - contents:
    - "10.5.  Data Caching and Revocation\n   When locks and delegations are revoked,
      the assumptions upon which\n   successful caching depend are no longer guaranteed.
      \ For any locks or\n   share reservations that have been revoked, the corresponding
      owner\n   needs to be notified.  This notification includes applications with
      a\n   file open that has a corresponding delegation that has been revoked.\n
      \  Cached data associated with the revocation must be removed from the\n   client.
      \ In the case of modified data existing in the client's cache,\n   that data
      must be removed from the client without it being written to\n   the server.
      \ As mentioned, the assumptions made by the client are no\n   longer valid at
      the point when a lock or delegation has been revoked.\n   For example, another
      client may have been granted a conflicting lock\n   after the revocation of
      the lock at the first client.  Therefore, the\n   data within the lock range
      may have been modified by the other\n   client.  Obviously, the first client
      is unable to guarantee to the\n   application what has occurred to the file
      in the case of revocation.\n   Notification to a lock-owner will in many cases
      consist of simply\n   returning an error on the next and all subsequent READs/WRITEs
      to the\n   open file or on the close.  Where the methods available to a client\n
      \  make such notification impossible because errors for certain\n   operations
      may not be returned, more drastic action, such as signals\n   or process termination,
      may be appropriate.  The justification for\n   this is that an invariant on
      which an application depends may be\n   violated.  Depending on how errors are
      typically treated for the\n   client operating environment, further levels of
      notification,\n   including logging, console messages, and GUI pop-ups, may
      be\n   appropriate.\n"
    - contents:
      - "10.5.1.  Revocation Recovery for Write Open Delegation\n   Revocation recovery
        for an OPEN_DELEGATE_WRITE delegation poses the\n   special issue of modified
        data in the client cache while the file is\n   not open.  In this situation,
        any client that does not flush modified\n   data to the server on each close
        must ensure that the user receives\n   appropriate notification of the failure
        as a result of the\n   revocation.  Since such situations may require human
        action to\n   correct problems, notification schemes in which the appropriate
        user\n   or administrator is notified may be necessary.  Logging and console\n
        \  messages are typical examples.\n   If there is modified data on the client,
        it must not be flushed\n   normally to the server.  A client may attempt to
        provide a copy of\n   the file data as modified during the delegation under
        a different\n   name in the file system namespace to ease recovery.  Note
        that when\n   the client can determine that the file has not been modified
        by any\n   other client, or when the client has a complete cached copy of
        the\n   file in question, such a saved copy of the client's view of the file\n
        \  may be of particular value for recovery.  In other cases, recovery\n   using
        a copy of the file, based partially on the client's cached data\n   and partially
        on the server copy as modified by other clients, will\n   be anything but
        straightforward, so clients may avoid saving file\n   contents in these situations
        or mark the results specially to warn\n   users of possible problems.\n   The
        saving of such modified data in delegation revocation situations\n   may be
        limited to files of a certain size or might be used only when\n   sufficient
        disk space is available within the target file system.\n   Such saving may
        also be restricted to situations when the client has\n   sufficient buffering
        resources to keep the cached copy available\n   until it is properly stored
        to the target file system.\n"
      title: 10.5.1.  Revocation Recovery for Write Open Delegation
    title: 10.5.  Data Caching and Revocation
  - contents:
    - "10.6.  Attribute Caching\n   The attributes discussed in this section do not
      include named\n   attributes.  Individual named attributes are analogous to
      files, and\n   caching of the data for these needs to be handled just as data\n
      \  caching is for regular files.  Similarly, LOOKUP results from an\n   OPENATTR
      directory are to be cached on the same basis as any other\n   pathnames and
      similarly for directory contents.\n   Clients may cache file attributes obtained
      from the server and use\n   them to avoid subsequent GETATTR requests.  This
      cache is write\n   through caching in that any modifications to the file attributes
      are\n   always done by means of requests to the server, which means the\n   modifications
      should not be done locally and should not be cached.\n   Exceptions to this
      are modifications to attributes that are\n   intimately connected with data
      caching.  Therefore, extending a file\n   by writing data to the local data
      cache is reflected immediately in\n   the size as seen on the client without
      this change being immediately\n   reflected on the server.  Normally, such changes
      are not propagated\n   directly to the server, but when the modified data is
      flushed to the\n   server, analogous attribute changes are made on the server.
      \ When\n   open delegation is in effect, the modified attributes may be returned\n
      \  to the server in the response to a CB_GETATTR call.\n   The result of local
      caching of attributes is that the attribute\n   caches maintained on individual
      clients will not be coherent.\n   Changes made in one order on the server may
      be seen in a different\n   order on one client and in a third order on a different
      client.\n   The typical file system application programming interfaces do not\n
      \  provide means to atomically modify or interrogate attributes for\n   multiple
      files at the same time.  The following rules provide an\n   environment where
      the potential incoherency mentioned above can be\n   reasonably managed.  These
      rules are derived from the practice of\n   previous NFS protocols.\n   o  All
      attributes for a given file (per-fsid attributes excepted) are\n      cached
      as a unit at the client so that no non-serializability can\n      arise within
      the context of a single file.\n   o  An upper time boundary is maintained on
      how long a client cache\n      entry can be kept without being refreshed from
      the server.\n   o  When operations are performed that modify attributes at the\n
      \     server, the updated attribute set is requested as part of the\n      containing
      RPC.  This includes directory operations that update\n      attributes indirectly.
      \ This is accomplished by following the\n      modifying operation with a GETATTR
      operation and then using the\n      results of the GETATTR to update the client's
      cached attributes.\n   Note that if the full set of attributes to be cached
      is requested by\n   READDIR, the results can be cached by the client on the
      same basis as\n   attributes obtained via GETATTR.\n   A client may validate
      its cached version of attributes for a file by\n   only fetching both the change
      and time_access attributes and assuming\n   that if the change attribute has
      the same value as it did when the\n   attributes were cached, then no attributes
      other than time_access\n   have changed.  The time_access attribute is also
      fetched because many\n   servers operate in environments where the operation
      that updates\n   change does not update time_access.  For example, POSIX file\n
      \  semantics do not update access time when a file is modified by the\n   write
      system call.  Therefore, the client that wants a current\n   time_access value
      should fetch it with change during the attribute\n   cache validation processing
      and update its cached time_access.\n   The client may maintain a cache of modified
      attributes for those\n   attributes intimately connected with data of modified
      regular files\n   (size, time_modify, and change).  Other than those three attributes,\n
      \  the client MUST NOT maintain a cache of modified attributes.\n   Instead,
      attribute changes are immediately sent to the server.\n   In some operating
      environments, the equivalent to time_access is\n   expected to be implicitly
      updated by each read of the content of the\n   file object.  If an NFS client
      is caching the content of a file\n   object, whether it is a regular file, directory,
      or symbolic link,\n   the client SHOULD NOT update the time_access attribute
      (via SETATTR\n   or a small READ or READDIR request) on the server with each
      read that\n   is satisfied from cache.  The reason is that this can defeat the\n
      \  performance benefits of caching content, especially since an explicit\n   SETATTR
      of time_access may alter the change attribute on the server.\n   If the change
      attribute changes, clients that are caching the content\n   will think the content
      has changed and will re-read unmodified data\n   from the server.  Nor is the
      client encouraged to maintain a modified\n   version of time_access in its cache,
      since this would mean that the\n   client either will eventually have to write
      the access time to the\n   server with bad performance effects or would never
      update the\n   server's time_access, thereby resulting in a situation where
      an\n   application that caches access time between a close and open of the\n
      \  same file observes the access time oscillating between the past and\n   present.
      \ The time_access attribute always means the time of last\n   access to a file
      by a READ that was satisfied by the server.  This\n   way, clients will tend
      to see only time_access changes that go\n   forward in time.\n"
    title: 10.6.  Attribute Caching
  - contents:
    - "10.7.  Data and Metadata Caching and Memory-Mapped Files\n   Some operating
      environments include the capability for an application\n   to map a file's content
      into the application's address space.  Each\n   time the application accesses
      a memory location that corresponds to a\n   block that has not been loaded into
      the address space, a page fault\n   occurs and the file is read (or if the block
      does not exist in the\n   file, the block is allocated and then instantiated
      in the\n   application's address space).\n   As long as each memory-mapped access
      to the file requires a page\n   fault, the relevant attributes of the file that
      are used to detect\n   access and modification (time_access, time_metadata,
      time_modify, and\n   change) will be updated.  However, in many operating environments,\n
      \  when page faults are not required, these attributes will not be\n   updated
      on reads or updates to the file via memory access (regardless\n   of whether
      the file is a local file or is being accessed remotely).\n   A client or server
      MAY fail to update attributes of a file that is\n   being accessed via memory-mapped
      I/O.  This has several implications:\n   o  If there is an application on the
      server that has memory mapped a\n      file that a client is also accessing,
      the client may not be able\n      to get a consistent value of the change attribute
      to determine\n      whether its cache is stale or not.  A server that knows
      that the\n      file is memory mapped could always pessimistically return updated\n
      \     values for change so as to force the application to always get the\n      most
      up-to-date data and metadata for the file.  However, due to\n      the negative
      performance implications of this, such behavior is\n      OPTIONAL.\n   o  If
      the memory-mapped file is not being modified on the server and\n      instead
      is just being read by an application via the memory-mapped\n      interface,
      the client will not see an updated time_access\n      attribute.  However, in
      many operating environments, neither will\n      any process running on the
      server.  Thus, NFS clients are at no\n      disadvantage with respect to local
      processes.\n   o  If there is another client that is memory mapping the file
      and if\n      that client is holding an OPEN_DELEGATE_WRITE delegation, the
      same\n      set of issues as discussed in the previous two bullet items apply.\n
      \     So, when a server does a CB_GETATTR to a file that the client has\n      modified
      in its cache, the response from CB_GETATTR will not\n      necessarily be accurate.
      \ As discussed earlier, the client's\n      obligation is to report that the
      file has been modified since the\n      delegation was granted, not whether
      it has been modified again\n      between successive CB_GETATTR calls, and the
      server MUST assume\n      that any file the client has modified in cache has
      been modified\n      again between successive CB_GETATTR calls.  Depending on
      the\n      nature of the client's memory management system, this weak\n      obligation
      may not be possible.  A client MAY return stale\n      information in CB_GETATTR
      whenever the file is memory mapped.\n   o  The mixture of memory mapping and
      file locking on the same file is\n      problematic.  Consider the following
      scenario, where the page size\n      on each client is 8192 bytes.\n      *
      \ Client A memory maps first page (8192 bytes) of file X.\n      *  Client B
      memory maps first page (8192 bytes) of file X.\n      *  Client A write locks
      first 4096 bytes.\n      *  Client B write locks second 4096 bytes.\n      *
      \ Client A, via a STORE instruction, modifies part of its locked\n         region.\n
      \     *  Simultaneous to client A, client B issues a STORE on part of\n         its
      locked region.\n   Here, the challenge is for each client to resynchronize to
      get a\n   correct view of the first page.  In many operating environments, the\n
      \  virtual memory management systems on each client only know a page is\n   modified,
      not that a subset of the page corresponding to the\n   respective lock regions
      has been modified.  So it is not possible for\n   each client to do the right
      thing, which is to only write to the\n   server that portion of the page that
      is locked.  For example, if\n   client A simply writes out the page, and then
      client B writes out the\n   page, client A's data is lost.\n   Moreover, if
      mandatory locking is enabled on the file, then we have a\n   different problem.
      \ When clients A and B issue the STORE\n   instructions, the resulting page
      faults require a byte-range lock on\n   the entire page.  Each client then tries
      to extend their locked range\n   to the entire page, which results in a deadlock.\n
      \  Communicating the NFS4ERR_DEADLOCK error to a STORE instruction is\n   difficult
      at best.\n   If a client is locking the entire memory-mapped file, there is
      no\n   problem with advisory or mandatory byte-range locking, at least until\n
      \  the client unlocks a region in the middle of the file.\n   Given the above
      issues, the following are permitted:\n   o  Clients and servers MAY deny memory
      mapping a file they know there\n      are byte-range locks for.\n   o  Clients
      and servers MAY deny a byte-range lock on a file they know\n      is memory
      mapped.\n   o  A client MAY deny memory mapping a file that it knows requires\n
      \     mandatory locking for I/O.  If mandatory locking is enabled after\n      the
      file is opened and mapped, the client MAY deny the application\n      further
      access to its mapped file.\n"
    title: 10.7.  Data and Metadata Caching and Memory-Mapped Files
  - contents:
    - "10.8.  Name Caching\n   The results of LOOKUP and READDIR operations may be
      cached to avoid\n   the cost of subsequent LOOKUP operations.  Just as in the
      case of\n   attribute caching, inconsistencies may arise among the various client\n
      \  caches.  To mitigate the effects of these inconsistencies and given\n   the
      context of typical file system APIs, an upper time boundary is\n   maintained
      on how long a client name cache entry can be kept without\n   verifying that
      the entry has not been made invalid by a directory\n   change operation performed
      by another client.\n   When a client is not making changes to a directory for
      which there\n   exist name cache entries, the client needs to periodically fetch\n
      \  attributes for that directory to ensure that it is not being\n   modified.
      \ After determining that no modification has occurred, the\n   expiration time
      for the associated name cache entries may be updated\n   to be the current time
      plus the name cache staleness bound.\n   When a client is making changes to
      a given directory, it needs to\n   determine whether there have been changes
      made to the directory by\n   other clients.  It does this by using the change
      attribute as\n   reported before and after the directory operation in the associated\n
      \  change_info4 value returned for the operation.  The server is able to\n   communicate
      to the client whether the change_info4 data is provided\n   atomically with
      respect to the directory operation.  If the change\n   values are provided atomically,
      the client is then able to compare\n   the pre-operation change value with the
      change value in the client's\n   name cache.  If the comparison indicates that
      the directory was\n   updated by another client, the name cache associated with
      the\n   modified directory is purged from the client.  If the comparison\n   indicates
      no modification, the name cache can be updated on the\n   client to reflect
      the directory operation and the associated timeout\n   extended.  The post-operation
      change value needs to be saved as the\n   basis for future change_info4 comparisons.\n
      \  As demonstrated by the scenario above, name caching requires that the\n   client
      revalidate name cache data by inspecting the change attribute\n   of a directory
      at the point when the name cache item was cached.\n   This requires that the
      server update the change attribute for\n   directories when the contents of
      the corresponding directory are\n   modified.  For a client to use the change_info4
      information\n   appropriately and correctly, the server must report the pre-
      and\n   post-operation change attribute values atomically.  When the server\n
      \  is unable to report the before and after values atomically with\n   respect
      to the directory operation, the server must indicate that\n   fact in the change_info4
      return value.  When the information is not\n   atomically reported, the client
      should not assume that other clients\n   have not changed the directory.\n"
    title: 10.8.  Name Caching
  - contents:
    - "10.9.  Directory Caching\n   The results of READDIR operations may be used
      to avoid subsequent\n   READDIR operations.  Just as in the cases of attribute
      and name\n   caching, inconsistencies may arise among the various client caches.\n
      \  To mitigate the effects of these inconsistencies, and given the\n   context
      of typical file system APIs, the following rules should be\n   followed:\n   o
      \ Cached READDIR information for a directory that is not obtained in\n      a
      single READDIR operation must always be a consistent snapshot of\n      directory
      contents.  This is determined by using a GETATTR before\n      the first READDIR
      and after the last READDIR that contributes to\n      the cache.\n   o  An upper
      time boundary is maintained to indicate the length of\n      time a directory
      cache entry is considered valid before the client\n      must revalidate the
      cached information.\n   The revalidation technique parallels that discussed
      in the case of\n   name caching.  When the client is not changing the directory
      in\n   question, checking the change attribute of the directory with GETATTR\n
      \  is adequate.  The lifetime of the cache entry can be extended at\n   these
      checkpoints.  When a client is modifying the directory, the\n   client needs
      to use the change_info4 data to determine whether there\n   are other clients
      modifying the directory.  If it is determined that\n   no other client modifications
      are occurring, the client may update\n   its directory cache to reflect its
      own changes.\n   As demonstrated previously, directory caching requires that
      the\n   client revalidate directory cache data by inspecting the change\n   attribute
      of a directory at the point when the directory was cached.\n   This requires
      that the server update the change attribute for\n   directories when the contents
      of the corresponding directory are\n   modified.  For a client to use the change_info4
      information\n   appropriately and correctly, the server must report the pre-
      and\n   post-operation change attribute values atomically.  When the server\n
      \  is unable to report the before and after values atomically with\n   respect
      to the directory operation, the server must indicate that\n   fact in the change_info4
      return value.  When the information is not\n   atomically reported, the client
      should not assume that other clients\n   have not changed the directory.\n"
    title: 10.9.  Directory Caching
  title: 10.  Client-Side Caching
- contents:
  - "11.  Minor Versioning\n   To address the requirement of an NFS protocol that
    can evolve as the\n   need arises, the NFSv4 protocol contains the rules and framework
    to\n   allow for future minor changes or versioning.\n   The base assumption with
    respect to minor versioning is that any\n   future accepted minor version must
    follow the IETF process and be\n   documented in a Standards Track RFC.  Therefore,
    each minor version\n   number will correspond to an RFC.  Minor version 0 of the
    NFSv4\n   protocol is represented by this RFC.  The COMPOUND and CB_COMPOUND\n
    \  procedures support the encoding of the minor version being requested\n   by
    the client.\n   Future minor versions will extend, rather than replace, the XDR
    for\n   the preceding minor version, as had been done in moving from NFSv2 to\n
    \  NFSv3 and from NFSv3 to NFSv4.0.\n   Specification of detailed rules for the
    construction of minor\n   versions will be addressed in documents defining early
    minor versions\n   or, more desirably, in an RFC establishing a versioning framework
    for\n   NFSv4 as a whole.\n"
  title: 11.  Minor Versioning
- contents:
  - '12.  Internationalization

    '
  - contents:
    - "12.1.  Introduction\n   Internationalization is a complex topic with its own
      set of\n   terminology (see [RFC6365]).  The topic is made more complex in\n
      \  NFSv4.0 by the tangled history and state of NFS implementations.\n   This
      section describes what we might call \"NFSv4.0\n   internationalization\" (i.e.,
      internationalization as implemented by\n   existing clients and servers) as
      the basis upon which NFSv4.0 clients\n   may implement internationalization
      support.\n   This section is based on the behavior of existing implementations.\n
      \  Note that the behaviors described are each demonstrated by a\n   combination
      of an NFSv4 server implementation proper and a\n   server-side physical file
      system.  It is common for servers and\n   physical file systems to be configurable
      as to the behavior shown.\n   In the discussion below, each configuration that
      shows different\n   behavior is considered separately.\n   Note that in this
      section, the key words \"MUST\", \"SHOULD\", and \"MAY\"\n   retain their normal
      meanings.  However, in deriving this\n   specification from implementation patterns,
      we document below how the\n   normative terms used derive from the behavior
      of existing\n   implementations, in those situations in which existing implementation\n
      \  behavior patterns can be determined.\n   o  Behavior implemented by all existing
      clients or servers is\n      described using \"MUST\", since new implementations
      need to follow\n      existing ones to be assured of interoperability.  While
      it is\n      possible that different behavior might be workable, we have found\n
      \     no case where this seems reasonable.\n      The converse holds for \"MUST
      NOT\": if a type of behavior poses\n      interoperability problems, it MUST
      NOT be implemented by any\n      existing clients or servers.\n   o  Behavior
      implemented by most existing clients or servers, where\n      that behavior
      is more desirable than any alternative, is described\n      using \"SHOULD\",
      since new implementations need to follow that\n      existing practice unless
      there are strong reasons to do otherwise.\n      The converse holds for \"SHOULD
      NOT\".\n   o  Behavior implemented by some, but not all, existing clients or\n
      \     servers is described using \"MAY\", indicating that new\n      implementations
      have a choice as to whether they will behave in\n      that way.  Thus, new
      implementations will have the same\n      flexibility that existing ones do.\n
      \  o  Behavior implemented by all existing clients or servers, so far as\n      is
      known -- but where there remains some uncertainty as to details\n      -- is
      described using \"should\".  Such cases primarily concern\n      details of
      error returns.  New implementations should follow\n      existing practice even
      though such situations generally do not\n      affect interoperability.\n   There
      are also cases in which certain server behaviors, while not\n   known to exist,
      cannot be reliably determined not to exist.  In part,\n   this is a consequence
      of the long period of time that has elapsed\n   since the publication of [RFC3530],
      resulting in a situation in which\n   those involved in the implementation may
      no longer be involved in or\n   aware of working group activities.\n   In the
      case of possible server behavior that is neither known to\n   exist nor known
      not to exist, we use \"SHOULD NOT\" and \"MUST NOT\" as\n   follows, and similarly
      for \"SHOULD\" and \"MUST\".\n   o  In some cases, the potential behavior is
      not known to exist but is\n      of such a nature that, if it were in fact implemented,\n
      \     interoperability difficulties would be expected and reported,\n      giving
      us cause to conclude that the potential behavior is not\n      implemented.
      \ For such behavior, we use \"MUST NOT\".  Similarly, we\n      use \"MUST\"
      to apply to the contrary behavior.\n   o  In other cases, potential behavior
      is not known to exist but the\n      behavior, while undesirable, is not of
      such a nature that we are\n      able to draw any conclusions about its potential
      existence.  In\n      such cases, we use \"SHOULD NOT\".  Similarly, we use
      \"SHOULD\" to\n      apply to the contrary behavior.\n   In the case of a \"MAY\",
      \"SHOULD\", or \"SHOULD NOT\" that applies to\n   servers, clients need to be
      aware that there are servers that may or\n   may not take the specified action,
      and they need to be prepared for\n   either eventuality.\n"
    title: 12.1.  Introduction
  - contents:
    - "12.2.  Limitations on Internationalization-Related Processing in the\n       NFSv4
      Context\n   There are a number of noteworthy circumstances that limit the degree\n
      \  to which internationalization-related processing can be made\n   universal
      with regard to NFSv4 clients and servers:\n   o  The NFSv4 client is part of
      an extensive set of client-side\n      software components whose design and
      internal interfaces are not\n      within the IETF's purview, limiting the degree
      to which a\n      particular character encoding may be made standard.\n   o
      \ Server-side handling of file component names is typically\n      implemented
      within a server-side physical file system, whose\n      handling of character
      encoding and normalization is not\n      specifiable by the IETF.\n   o  Typical
      implementation patterns in UNIX systems result in the\n      NFSv4 client having
      no knowledge of the character encoding being\n      used, which may even vary
      between processes on the same client\n      system.\n   o  Users may need access
      to files stored previously with non-UTF-8\n      encodings, or with UTF-8 encodings
      that do not match any\n      particular normalization form.\n"
    title: 12.2.  Limitations on Internationalization-Related Processing in the
  - contents:
    - "12.3.  Summary of Server Behavior Types\n   As mentioned in Section 12.6, servers
      MAY reject component name\n   strings that are not valid UTF-8.  This leads
      to a number of types of\n   valid server behavior, as outlined below.  When
      these are combined\n   with the valid normalization-related behaviors as described
      in\n   Section 12.4, this leads to the combined behaviors outlined below.\n
      \  o  Servers that limit file component names to UTF-8 strings exist\n      with
      normalization-related handling as described in Section 12.4.\n      These are
      best described as \"UTF-8-only servers\".\n   o  Servers that do not limit file
      component names to UTF-8 strings\n      are very common and are necessary to
      deal with clients/\n      applications not oriented to the use of UTF-8.  Such
      servers\n      ignore normalization-related issues, and there is no way for
      them\n      to implement either normalization or representation-independent\n
      \     lookups.  These are best described as \"UTF-8-unaware servers\",\n      since
      they treat file component names as uninterpreted strings of\n      bytes and
      have no knowledge of the characters represented.  See\n      Section 12.7 for
      details.\n   o  It is possible for a server to allow component names that are
      not\n      valid UTF-8, while still being aware of the structure of UTF-8\n
      \     strings.  Such servers could implement either normalization or\n      representation-independent
      lookups but apply those techniques only\n      to valid UTF-8 strings.  Such
      servers are not common, but it is\n      possible to configure at least one
      known server to have this\n      behavior.  This behavior SHOULD NOT be used
      due to the possibility\n      that a filename using one character set may, by
      coincidence,\n      have the appearance of a UTF-8 filename; the results of
      UTF-8\n      normalization or representation-independent lookups are\n      unlikely
      to be correct in all cases with respect to the other\n      character set.\n"
    title: 12.3.  Summary of Server Behavior Types
  - contents:
    - "12.4.  String Encoding\n   Strings that potentially contain characters outside
      the ASCII range\n   [RFC20] are generally represented in NFSv4 using the UTF-8
      encoding\n   [RFC3629] of Unicode [UNICODE].  See [RFC3629] for precise encoding\n
      \  and decoding rules.\n   Some details of the protocol treatment depend on
      the type of string:\n   o  For strings that are component names, the preferred
      encoding for\n      any non-ASCII characters is the UTF-8 representation of
      Unicode.\n      In many cases, clients have no knowledge of the encoding being\n
      \     used, with the encoding done at the user level under the control\n      of
      a per-process locale specification.  As a result, it may be\n      impossible
      for the NFSv4 client to enforce the use of UTF-8.  The\n      use of non-UTF-8
      encodings can be problematic, since it may\n      interfere with access to files
      stored using other forms of name\n      encoding.  Also, normalization-related
      processing (see\n      Section 12.5) of a string not encoded in UTF-8 could
      result in\n      inappropriate name modification or aliasing.  In cases in which\n
      \     one has a non-UTF-8 encoded name that accidentally conforms to\n      UTF-8
      rules, substitution of canonically equivalent strings can\n      change the
      non-UTF-8 encoded name drastically.\n      The kinds of modification and aliasing
      mentioned here can lead to\n      both false negatives and false positives,
      depending on the strings\n      in question, which can result in security issues
      such as elevation\n      of privilege and denial of service (see [RFC6943] for
      further\n      discussion).\n   o  For strings based on domain names, non-ASCII
      characters MUST be\n      represented using the UTF-8 encoding of Unicode, and
      additional\n      string format restrictions apply.  See Section 12.6 for details.\n
      \  o  The contents of symbolic links (of type linktext4 in the XDR) MUST\n      be
      treated as opaque data by NFSv4 servers.  Although UTF-8\n      encoding is
      often used, it need not be.  In this respect, the\n      contents of symbolic
      links are like the contents of regular files\n      in that their encoding is
      not within the scope of this\n      specification.\n   o  For other sorts of
      strings, any non-ASCII characters SHOULD be\n      represented using the UTF-8
      encoding of Unicode.\n"
    title: 12.4.  String Encoding
  - contents:
    - "12.5.  Normalization\n   The client and server operating environments may differ
      in their\n   policies and operational methods with respect to character\n   normalization
      (see [UNICODE] for a discussion of normalization\n   forms).  This difference
      may also exist between applications on the\n   same client.  This adds to the
      difficulty of providing a single\n   normalization policy for the protocol that
      allows for maximal\n   interoperability.  This issue is similar to the issues
      of character\n   case where the server may or may not support case-insensitive\n
      \  filename matching and may or may not preserve the character case when\n   storing
      filenames.  The protocol does not mandate a particular\n   behavior but allows
      for a range of useful behaviors.\n   The NFSv4 protocol does not mandate the
      use of a particular\n   normalization form at this time.  A subsequent minor
      version of the\n   NFSv4 protocol might specify a particular normalization form.\n
      \  Therefore, the server and client can expect that they may receive\n   unnormalized
      characters within protocol requests and responses.  If\n   the operating environment
      requires normalization, then the\n   implementation will need to normalize the
      various UTF-8 encoded\n   strings within the protocol before presenting the
      information to an\n   application (at the client) or local file system (at the
      server).\n   Server implementations MAY normalize filenames to conform to a\n
      \  particular normalization form before using the resulting string when\n   looking
      up or creating a file.  Servers MAY also perform\n   normalization-insensitive
      string comparisons without modifying the\n   names to match a particular normalization
      form.  Except in cases in\n   which component names are excluded from normalization-related\n
      \  handling because they are not valid UTF-8 strings, a server MUST make\n   the
      same choice (as to whether to normalize or not, the target form\n   of normalization,
      and whether to do normalization-insensitive string\n   comparisons) in the same
      way for all accesses to a particular file\n   system.  Servers SHOULD NOT reject
      a filename because it does not\n   conform to a particular normalization form,
      as this may deny access\n   to clients that use a different normalization form.\n"
    title: 12.5.  Normalization
  - contents:
    - "12.6.  Types with Processing Defined by Other Internet Areas\n   There are
      two types of strings that NFSv4 deals with that are based\n   on domain names.
      \ Processing of such strings is defined by other\n   Internet standards, and
      hence the processing behavior for such\n   strings should be consistent across
      all server operating systems and\n   server file systems.\n   These are as follows:\n
      \  o  Server names as they appear in the fs_locations attribute.  Note\n      that
      for most purposes, such server names will only be sent by the\n      server
      to the client.  The exception is the use of the\n      fs_locations attribute
      in a VERIFY or NVERIFY operation.\n   o  Principal suffixes that are used to
      denote sets of users and\n      groups, and are in the form of domain names.\n
      \  The general rules for handling all of these domain-related strings\n   are
      similar and independent of the role of the sender or receiver as\n   client
      or server, although the consequences of failure to obey these\n   rules may
      be different for client or server.  The server can report\n   errors when it
      is sent invalid strings, whereas the client will\n   simply ignore invalid string
      or use a default value in their place.\n   The string sent SHOULD be in the
      form of one or more U-labels as\n   defined by [RFC5890].  If that is impractical,
      it can instead be in\n   the form of one or more LDH labels [RFC5890] or a UTF-8
      domain name\n   that contains labels that are not properly formatted U-labels.
      \ The\n   receiver needs to be able to accept domain and server names in any
      of\n   the formats allowed.  The server MUST reject, using the error\n   NFS4ERR_INVAL,
      a string that is not valid UTF-8, or that contains an\n   ASCII label that is
      not a valid LDH label, or that contains an\n   XN-label (begins with \"xn--\")
      for which the characters after \"xn--\"\n   are not valid output of the Punycode
      algorithm [RFC3492].\n   When a domain string is part of id@domain or group@domain,
      there are\n   two possible approaches:\n   1.  The server treats the domain
      string as a series of U-labels.  In\n       cases where the domain string is
      a series of A-labels or\n       Non-Reserved LDH (NR-LDH) labels, it converts
      them to U-labels\n       using the Punycode algorithm [RFC3492].  In cases where
      the\n       domain string is a series of other sorts of LDH labels, the\n       server
      can use the ToUnicode function defined in [RFC3490] to\n       convert the string
      to a series of labels that generally conform\n       to the U-label syntax.
      \ In cases where the domain string is a\n       UTF-8 string that contains non-U-labels,
      the server can attempt\n       to use the ToASCII function defined in [RFC3490]
      and then the\n       ToUnicode function on the string to convert it to a series
      of\n       labels that generally conform to the U-label syntax.  As a\n       result,
      the domain string returned within a user id on a GETATTR\n       may not match
      that sent when the user id is set using SETATTR,\n       although when this
      happens, the domain will be in the form that\n       generally conforms to the
      U-label syntax.\n   2.  The server does not attempt to treat the domain string
      as a\n       series of U-labels; specifically, it does not map a domain string\n
      \      that is not a U-label into a U-label using the methods described\n       above.
      \ As a result, the domain string returned on a GETATTR of\n       the user id
      MUST be the same as that used when setting the\n       user id by the SETATTR.\n
      \  A server SHOULD use the first method.\n   For VERIFY and NVERIFY, additional
      string processing requirements\n   apply to verification of the owner and owner_group
      attributes; see\n   Section 5.9.\n"
    title: 12.6.  Types with Processing Defined by Other Internet Areas
  - contents:
    - "12.7.  Errors Related to UTF-8\n   Where the client sends an invalid UTF-8
      string, the server MAY return\n   an NFS4ERR_INVAL error.  This includes cases
      in which inappropriate\n   prefixes are detected and where the count includes
      trailing bytes\n   that do not constitute a full Universal Multiple-Octet Coded\n
      \  Character Set (UCS) character.\n   Requirements for server handling of component
      names that are not\n   valid UTF-8, when a server does not return NFS4ERR_INVAL
      in response\n   to receiving them, are described in Section 12.8.\n   Where
      the string supplied by the client is not rejected with\n   NFS4ERR_INVAL but
      contains characters that are not supported by the\n   server as a value for
      that string (e.g., names containing slashes, or\n   characters that do not fit
      into 16 bits when converted from UTF-8 to\n   a Unicode codepoint), the server
      should return an NFS4ERR_BADCHAR\n   error.\n   Where a UTF-8 string is used
      as a filename, and the file system,\n   while supporting all of the characters
      within the name, does not\n   allow that particular name to be used, the server
      should return the\n   error NFS4ERR_BADNAME.  This includes such situations
      as file system\n   prohibitions of \".\" and \"..\" as filenames for certain
      operations, and\n   similar constraints.\n"
    title: 12.7.  Errors Related to UTF-8
  - contents:
    - "12.8.  Servers That Accept File Component Names That Are Not Valid UTF-8\n
      \      Strings\n   As stated previously, servers MAY accept, on all or on some
      subset of\n   the physical file systems exported, component names that are not\n
      \  valid UTF-8 strings.  A typical pattern is for a server to use\n   UTF-8-unaware
      physical file systems that treat component names as\n   uninterpreted strings
      of bytes, rather than having any awareness of\n   the character set being used.\n
      \  Such servers SHOULD NOT change the stored representation of component\n   names
      from those received on the wire and SHOULD use an octet-by-\n   octet comparison
      of component name strings to determine equivalence\n   (as opposed to any broader
      notion of string comparison).  This is\n   because the server has no knowledge
      of the character encoding being\n   used.\n   Nonetheless, when such a server
      uses a broader notion of string\n   equivalence than what is recommended in
      the preceding paragraph, the\n   following considerations apply:\n   o  Outside
      of 7-bit ASCII, string processing that changes string\n      contents is usually
      specific to a character set and hence is\n      generally unsafe when the character
      set is unknown.  This\n      processing could change the filename in an unexpected
      fashion,\n      rendering the file inaccessible to the application or client
      that\n      created or renamed the file and to others expecting the original\n
      \     filename.  Hence, such processing should not be performed, because\n      doing
      so is likely to result in incorrect string modification or\n      aliasing.\n
      \  o  Unicode normalization is particularly dangerous, as such\n      processing
      assumes that the string is UTF-8.  When that assumption\n      is false because
      a different character set was used to create the\n      filename, normalization
      may corrupt the filename with respect to\n      that character set, rendering
      the file inaccessible to the\n      application that created it and others expecting
      the original\n      filename.  Hence, Unicode normalization SHOULD NOT be performed,\n
      \     because it may cause incorrect string modification or aliasing.\n   When
      the above recommendations are not followed, the resulting string\n   modification
      and aliasing can lead to both false negatives and false\n   positives, depending
      on the strings in question, which can result in\n   security issues such as
      elevation of privilege and denial of service\n   (see [RFC6943] for further
      discussion).\n"
    title: 12.8.  Servers That Accept File Component Names That Are Not Valid UTF-8
  title: 12.  Internationalization
- contents:
  - "13.  Error Values\n   NFS error numbers are assigned to failed operations within
    a COMPOUND\n   or CB_COMPOUND request.  A COMPOUND request contains a number of
    NFS\n   operations that have their results encoded in sequence in a COMPOUND\n
    \  reply.  The results of successful operations will consist of an\n   NFS4_OK
    status followed by the encoded results of the operation.  If\n   an NFS operation
    fails, an error status will be entered in the reply,\n   and the COMPOUND request
    will be terminated.\n"
  - contents:
    - "13.1.  Error Definitions\n       +-----------------------------+--------+-------------------+\n
      \      | Error                       | Number | Description       |\n       +-----------------------------+--------+-------------------+\n
      \      | NFS4_OK                     | 0      | Section 13.1.3.1  |\n       |
      NFS4ERR_ACCESS              | 13     | Section 13.1.6.1  |\n       | NFS4ERR_ADMIN_REVOKED
      \      | 10047  | Section 13.1.5.1  |\n       | NFS4ERR_ATTRNOTSUPP         |
      10032  | Section 13.1.11.1 |\n       | NFS4ERR_BADCHAR             | 10040  |
      Section 13.1.7.1  |\n       | NFS4ERR_BADHANDLE           | 10001  | Section
      13.1.2.1  |\n       | NFS4ERR_BADNAME             | 10041  | Section 13.1.7.2
      \ |\n       | NFS4ERR_BADOWNER            | 10039  | Section 13.1.11.2 |\n       |
      NFS4ERR_BADTYPE             | 10007  | Section 13.1.4.1  |\n       | NFS4ERR_BADXDR
      \             | 10036  | Section 13.1.1.1  |\n       | NFS4ERR_BAD_COOKIE          |
      10003  | Section 13.1.1.2  |\n       | NFS4ERR_BAD_RANGE           | 10042  |
      Section 13.1.8.1  |\n       | NFS4ERR_BAD_SEQID           | 10026  | Section
      13.1.8.2  |\n       | NFS4ERR_BAD_STATEID         | 10025  | Section 13.1.5.2
      \ |\n       | NFS4ERR_CB_PATH_DOWN        | 10048  | Section 13.1.12.1 |\n       |
      NFS4ERR_CLID_INUSE          | 10017  | Section 13.1.10.1 |\n       | NFS4ERR_DEADLOCK
      \           | 10045  | Section 13.1.8.3  |\n       | NFS4ERR_DELAY               |
      10008  | Section 13.1.1.3  |\n       | NFS4ERR_DENIED              | 10010  |
      Section 13.1.8.4  |\n       | NFS4ERR_DQUOT               | 69     | Section
      13.1.4.2  |\n       | NFS4ERR_EXIST               | 17     | Section 13.1.4.3
      \ |\n       | NFS4ERR_EXPIRED             | 10011  | Section 13.1.5.3  |\n       |
      NFS4ERR_FBIG                | 27     | Section 13.1.4.4  |\n       | NFS4ERR_FHEXPIRED
      \          | 10014  | Section 13.1.2.2  |\n       | NFS4ERR_FILE_OPEN           |
      10046  | Section 13.1.4.5  |\n       | NFS4ERR_GRACE               | 10013  |
      Section 13.1.9.1  |\n       | NFS4ERR_INVAL               | 22     | Section
      13.1.1.4  |\n       | NFS4ERR_IO                  | 5      | Section 13.1.4.6
      \ |\n       | NFS4ERR_ISDIR               | 21     | Section 13.1.2.3  |\n       |
      NFS4ERR_LEASE_MOVED         | 10031  | Section 13.1.5.4  |\n       | NFS4ERR_LOCKED
      \             | 10012  | Section 13.1.8.5  |\n       | NFS4ERR_LOCKS_HELD          |
      10037  | Section 13.1.8.6  |\n       | NFS4ERR_LOCK_NOTSUPP        | 10043  |
      Section 13.1.8.7  |\n       | NFS4ERR_LOCK_RANGE          | 10028  | Section
      13.1.8.8  |\n       | NFS4ERR_MINOR_VERS_MISMATCH | 10021  | Section 13.1.3.2
      \ |\n       | NFS4ERR_MLINK               | 31     | Section 13.1.4.7  |\n       |
      NFS4ERR_MOVED               | 10019  | Section 13.1.2.4  |\n       | NFS4ERR_NAMETOOLONG
      \        | 63     | Section 13.1.7.3  |\n       | NFS4ERR_NOENT               |
      2      | Section 13.1.4.8  |\n       | NFS4ERR_NOFILEHANDLE        | 10020  |
      Section 13.1.2.5  |\n       | NFS4ERR_NOSPC               | 28     | Section
      13.1.4.9  |\n       | NFS4ERR_NOTDIR              | 20     | Section 13.1.2.6
      \ |\n       | NFS4ERR_NOTEMPTY            | 66     | Section 13.1.4.10 |\n       |
      NFS4ERR_NOTSUPP             | 10004  | Section 13.1.1.5  |\n       | NFS4ERR_NOT_SAME
      \           | 10027  | Section 13.1.11.3 |\n       | NFS4ERR_NO_GRACE            |
      10033  | Section 13.1.9.2  |\n       | NFS4ERR_NXIO                | 6      |
      Section 13.1.4.11 |\n       | NFS4ERR_OLD_STATEID         | 10024  | Section
      13.1.5.5  |\n       | NFS4ERR_OPENMODE            | 10038  | Section 13.1.8.9
      \ |\n       | NFS4ERR_OP_ILLEGAL          | 10044  | Section 13.1.3.3  |\n       |
      NFS4ERR_PERM                | 1      | Section 13.1.6.2  |\n       | NFS4ERR_RECLAIM_BAD
      \        | 10034  | Section 13.1.9.3  |\n       | NFS4ERR_RECLAIM_CONFLICT    |
      10035  | Section 13.1.9.4  |\n       | NFS4ERR_RESOURCE            | 10018  |
      Section 13.1.3.4  |\n       | NFS4ERR_RESTOREFH           | 10030  | Section
      13.1.4.12 |\n       | NFS4ERR_ROFS                | 30     | Section 13.1.4.13
      |\n       | NFS4ERR_SAME                | 10009  | Section 13.1.11.4 |\n       |
      NFS4ERR_SERVERFAULT         | 10006  | Section 13.1.1.6  |\n       | NFS4ERR_SHARE_DENIED
      \       | 10015  | Section 13.1.8.10 |\n       | NFS4ERR_STALE               |
      70     | Section 13.1.2.7  |\n       | NFS4ERR_STALE_CLIENTID      | 10022  |
      Section 13.1.10.2 |\n       | NFS4ERR_STALE_STATEID       | 10023  | Section
      13.1.5.6  |\n       | NFS4ERR_SYMLINK             | 10029  | Section 13.1.2.8
      \ |\n       | NFS4ERR_TOOSMALL            | 10005  | Section 13.1.1.7  |\n       |
      NFS4ERR_WRONGSEC            | 10016  | Section 13.1.6.3  |\n       | NFS4ERR_XDEV
      \               | 18     | Section 13.1.4.14 |\n       +-----------------------------+--------+-------------------+\n
      \                   Table 6: Protocol Error Definitions\n"
    - contents:
      - "13.1.1.  General Errors\n   This section deals with errors that are applicable
        to a broad set of\n   different purposes.\n"
      - contents:
        - "13.1.1.1.  NFS4ERR_BADXDR (Error Code 10036)\n   The arguments for this
          operation do not match those specified in the\n   XDR definition.  This
          includes situations in which the request ends\n   before all the arguments
          have been seen.  Note that this error\n   applies when fixed enumerations
          (these include booleans) have a value\n   within the input stream that is
          not valid for the enum.  A replier\n   may pre-parse all operations for
          a COMPOUND procedure before doing\n   any operation execution and return
          RPC-level XDR errors in that case.\n"
        title: 13.1.1.1.  NFS4ERR_BADXDR (Error Code 10036)
      - contents:
        - "13.1.1.2.  NFS4ERR_BAD_COOKIE (Error Code 10003)\n   This error is used
          for operations that provide a set of information\n   indexed by some quantity
          provided by the client or cookie sent by the\n   server for an earlier invocation.
          \ Where the value cannot be used for\n   its intended purpose, this error
          results.\n"
        title: 13.1.1.2.  NFS4ERR_BAD_COOKIE (Error Code 10003)
      - contents:
        - "13.1.1.3.  NFS4ERR_DELAY (Error Code 10008)\n   For any of a number of
          reasons, the replier could not process this\n   operation in what was deemed
          a reasonable time.  The client should\n   wait and then try the request
          with a new RPC transaction ID.\n   The following are two examples of what
          might lead to this situation:\n   o  A server that supports hierarchical
          storage receives a request to\n      process a file that had been migrated.\n
          \  o  An operation requires a delegation recall to proceed, and waiting\n
          \     for this delegation recall makes processing this request in a\n      timely
          fashion impossible.\n"
        title: 13.1.1.3.  NFS4ERR_DELAY (Error Code 10008)
      - contents:
        - "13.1.1.4.  NFS4ERR_INVAL (Error Code 22)\n   The arguments for this operation
          are not valid for some reason, even\n   though they do match those specified
          in the XDR definition for the\n   request.\n"
        title: 13.1.1.4.  NFS4ERR_INVAL (Error Code 22)
      - contents:
        - "13.1.1.5.  NFS4ERR_NOTSUPP (Error Code 10004)\n   The operation is not
          supported, either because the operation is an\n   OPTIONAL one and is not
          supported by this server or because the\n   operation MUST NOT be implemented
          in the current minor version.\n"
        title: 13.1.1.5.  NFS4ERR_NOTSUPP (Error Code 10004)
      - contents:
        - "13.1.1.6.  NFS4ERR_SERVERFAULT (Error Code 10006)\n   An error that does
          not map to any of the specific legal NFSv4\n   protocol error values occurred
          on the server.  The client should\n   translate this into an appropriate
          error.  UNIX clients may choose to\n   translate this to EIO.\n"
        title: 13.1.1.6.  NFS4ERR_SERVERFAULT (Error Code 10006)
      - contents:
        - "13.1.1.7.  NFS4ERR_TOOSMALL (Error Code 10005)\n   This error is used where
          an operation returns a variable amount of\n   data, with a limit specified
          by the client.  Where the data returned\n   cannot be fitted within the
          limit specified by the client, this error\n   results.\n"
        title: 13.1.1.7.  NFS4ERR_TOOSMALL (Error Code 10005)
      title: 13.1.1.  General Errors
    - contents:
      - "13.1.2.  Filehandle Errors\n   These errors deal with the situation in which
        the current or saved\n   filehandle, or the filehandle passed to PUTFH intended
        to become the\n   current filehandle, is invalid in some way.  This includes
        situations\n   in which the filehandle is a valid filehandle in general but
        is not\n   of the appropriate object type for the current operation.\n   Where
        the error description indicates a problem with the current or\n   saved filehandle,
        it is to be understood that filehandles are only\n   checked for the condition
        if they are implicit arguments of the\n   operation in question.\n"
      - contents:
        - "13.1.2.1.  NFS4ERR_BADHANDLE (Error Code 10001)\n   This error is generated
          for an illegal NFS filehandle for the current\n   server.  The current filehandle
          failed internal consistency checks.\n   Once accepted as valid (by PUTFH),
          no subsequent status change can\n   cause the filehandle to generate this
          error.\n"
        title: 13.1.2.1.  NFS4ERR_BADHANDLE (Error Code 10001)
      - contents:
        - "13.1.2.2.  NFS4ERR_FHEXPIRED (Error Code 10014)\n   A current or saved
          filehandle that is an argument to the current\n   operation is volatile
          and has expired at the server.\n"
        title: 13.1.2.2.  NFS4ERR_FHEXPIRED (Error Code 10014)
      - contents:
        - "13.1.2.3.  NFS4ERR_ISDIR (Error Code 21)\n   The current or saved filehandle
          designates a directory when the\n   current operation does not allow a directory
          to be accepted as the\n   target of this operation.\n"
        title: 13.1.2.3.  NFS4ERR_ISDIR (Error Code 21)
      - contents:
        - "13.1.2.4.  NFS4ERR_MOVED (Error Code 10019)\n   The file system that contains
          the current filehandle object is not\n   present at the server.  It may
          have been relocated or migrated to\n   another server, or may have never
          been present.  The client may\n   obtain the new file system location by
          obtaining the \"fs_locations\"\n   attribute for the current filehandle.
          \ For further discussion, refer\n   to Section 8.\n"
        title: 13.1.2.4.  NFS4ERR_MOVED (Error Code 10019)
      - contents:
        - "13.1.2.5.  NFS4ERR_NOFILEHANDLE (Error Code 10020)\n   The logical current
          or saved filehandle value is required by the\n   current operation and is
          not set.  This may be a result of a\n   malformed COMPOUND operation (i.e.,
          no PUTFH or PUTROOTFH before an\n   operation that requires that the current
          filehandle be set).\n"
        title: 13.1.2.5.  NFS4ERR_NOFILEHANDLE (Error Code 10020)
      - contents:
        - "13.1.2.6.  NFS4ERR_NOTDIR (Error Code 20)\n   The current (or saved) filehandle
          designates an object that is not a\n   directory for an operation in which
          a directory is required.\n"
        title: 13.1.2.6.  NFS4ERR_NOTDIR (Error Code 20)
      - contents:
        - "13.1.2.7.  NFS4ERR_STALE (Error Code 70)\n   The current or saved filehandle
          value designating an argument to the\n   current operation is invalid.  The
          file system object referred to by\n   that filehandle no longer exists,
          or access to it has been revoked.\n"
        title: 13.1.2.7.  NFS4ERR_STALE (Error Code 70)
      - contents:
        - "13.1.2.8.  NFS4ERR_SYMLINK (Error Code 10029)\n   The current filehandle
          designates a symbolic link when the current\n   operation does not allow
          a symbolic link as the target.\n"
        title: 13.1.2.8.  NFS4ERR_SYMLINK (Error Code 10029)
      title: 13.1.2.  Filehandle Errors
    - contents:
      - "13.1.3.  Compound Structure Errors\n   This section deals with errors that
        relate to the overall structure\n   of a COMPOUND request (by which we mean
        to include both COMPOUND and\n   CB_COMPOUND), rather than to particular operations.\n
        \  There are a number of basic constraints on the operations that may\n   appear
        in a COMPOUND request.\n"
      - contents:
        - "13.1.3.1.  NFS_OK (Error Code 0)\n   NFS_OK indicates that the operation
          completed successfully, in that\n   all of the constituent operations completed
          without error.\n"
        title: 13.1.3.1.  NFS_OK (Error Code 0)
      - contents:
        - "13.1.3.2.  NFS4ERR_MINOR_VERS_MISMATCH (Error Code 10021)\n   The minor
          version specified is not one that the current listener\n   supports.  This
          value is returned in the overall status for the\n   COMPOUND procedure but
          is not associated with a specific operation,\n   since the results must
          specify a result count of zero.\n"
        title: 13.1.3.2.  NFS4ERR_MINOR_VERS_MISMATCH (Error Code 10021)
      - contents:
        - "13.1.3.3.  NFS4ERR_OP_ILLEGAL (Error Code 10044)\n   The operation code
          is not a valid one for the current COMPOUND\n   procedure.  The opcode in
          the result stream matched with this error\n   is the ILLEGAL value, although
          the value that appears in the request\n   stream may be different.  Where
          an illegal value appears and the\n   replier pre-parses all operations for
          a COMPOUND procedure before\n   doing any operation execution, an RPC-level
          XDR error may be returned\n   in this case.\n"
        title: 13.1.3.3.  NFS4ERR_OP_ILLEGAL (Error Code 10044)
      - contents:
        - "13.1.3.4.  NFS4ERR_RESOURCE (Error Code 10018)\n   For the processing of
          the COMPOUND procedure, the server may exhaust\n   available resources and
          cannot continue processing operations within\n   the COMPOUND procedure.
          \ This error will be returned from the server\n   in those instances of
          resource exhaustion related to the processing\n   of the COMPOUND procedure.\n"
        title: 13.1.3.4.  NFS4ERR_RESOURCE (Error Code 10018)
      title: 13.1.3.  Compound Structure Errors
    - contents:
      - "13.1.4.  File System Errors\n   These errors describe situations that occurred
        in the underlying file\n   system implementation rather than in the protocol
        or any NFSv4.x\n   feature.\n"
      - contents:
        - "13.1.4.1.  NFS4ERR_BADTYPE (Error Code 10007)\n   An attempt was made to
          create an object with an inappropriate type\n   specified to CREATE.  This
          may be because the type is undefined;\n   because it is a type not supported
          by the server; or because it is a\n   type for which create is not intended,
          such as a regular file or\n   named attribute, for which OPEN is used to
          do the file creation.\n"
        title: 13.1.4.1.  NFS4ERR_BADTYPE (Error Code 10007)
      - contents:
        - "13.1.4.2.  NFS4ERR_DQUOT (Error Code 69)\n   The resource (quota) hard
          limit has been exceeded.  The user's\n   resource limit on the server has
          been exceeded.\n"
        title: 13.1.4.2.  NFS4ERR_DQUOT (Error Code 69)
      - contents:
        - "13.1.4.3.  NFS4ERR_EXIST (Error Code 17)\n   A file system object of the
          specified target name (when creating,\n   renaming, or linking) already
          exists.\n"
        title: 13.1.4.3.  NFS4ERR_EXIST (Error Code 17)
      - contents:
        - "13.1.4.4.  NFS4ERR_FBIG (Error Code 27)\n   The file system object is too
          large.  The operation would have caused\n   a file system object to grow
          beyond the server's limit.\n"
        title: 13.1.4.4.  NFS4ERR_FBIG (Error Code 27)
      - contents:
        - "13.1.4.5.  NFS4ERR_FILE_OPEN (Error Code 10046)\n   The operation is not
          allowed because a file system object involved in\n   the operation is currently
          open.  Servers may, but are not required\n   to, disallow linking to, removing,
          or renaming open file system\n   objects.\n"
        title: 13.1.4.5.  NFS4ERR_FILE_OPEN (Error Code 10046)
      - contents:
        - "13.1.4.6.  NFS4ERR_IO (Error Code 5)\n   This indicates that an I/O error
          occurred for which the file system\n   was unable to provide recovery.\n"
        title: 13.1.4.6.  NFS4ERR_IO (Error Code 5)
      - contents:
        - "13.1.4.7.  NFS4ERR_MLINK (Error Code 31)\n   The request would have caused
          the server's limit for the number of\n   hard links a file system object
          may have to be exceeded.\n"
        title: 13.1.4.7.  NFS4ERR_MLINK (Error Code 31)
      - contents:
        - "13.1.4.8.  NFS4ERR_NOENT (Error Code 2)\n   This indicates no such file
          or directory.  The file system object\n   referenced by the name specified
          does not exist.\n"
        title: 13.1.4.8.  NFS4ERR_NOENT (Error Code 2)
      - contents:
        - "13.1.4.9.  NFS4ERR_NOSPC (Error Code 28)\n   This indicates no space left
          on the device.  The operation would have\n   caused the server's file system
          to exceed its limit.\n"
        title: 13.1.4.9.  NFS4ERR_NOSPC (Error Code 28)
      - contents:
        - "13.1.4.10.  NFS4ERR_NOTEMPTY (Error Code 66)\n   An attempt was made to
          remove a directory that was not empty.\n"
        title: 13.1.4.10.  NFS4ERR_NOTEMPTY (Error Code 66)
      - contents:
        - "13.1.4.11.  NFS4ERR_NXIO (Error Code 6)\n   This indicates an I/O error.
          \ There is no such device or address.\n"
        title: 13.1.4.11.  NFS4ERR_NXIO (Error Code 6)
      - contents:
        - "13.1.4.12.  NFS4ERR_RESTOREFH (Error Code 10030)\n   The RESTOREFH operation
          does not have a saved filehandle (identified\n   by SAVEFH) to operate upon.\n"
        title: 13.1.4.12.  NFS4ERR_RESTOREFH (Error Code 10030)
      - contents:
        - "13.1.4.13.  NFS4ERR_ROFS (Error Code 30)\n   This indicates a read-only
          file system.  A modifying operation was\n   attempted on a read-only file
          system.\n"
        title: 13.1.4.13.  NFS4ERR_ROFS (Error Code 30)
      - contents:
        - "13.1.4.14.  NFS4ERR_XDEV (Error Code 18)\n   This indicates an attempt
          to do an operation, such as linking, that\n   inappropriately crosses a
          boundary.  For example, this may be due to\n   a boundary between:\n   o
          \ File systems (where the fsids are different).\n   o  Different named attribute
          directories, or between a named\n      attribute directory and an ordinary
          directory.\n   o  Regions of a file system that the file system implementation\n
          \     treats as separate (for example, for space accounting purposes),\n
          \     and where cross-connection between the regions is not allowed.\n"
        title: 13.1.4.14.  NFS4ERR_XDEV (Error Code 18)
      title: 13.1.4.  File System Errors
    - contents:
      - "13.1.5.  State Management Errors\n   These errors indicate problems with
        the stateid (or one of the\n   stateids) passed to a given operation.  This
        includes situations in\n   which the stateid is invalid, as well as situations
        in which the\n   stateid is valid but designates revoked locking state.  Depending
        on\n   the operation, the stateid, when valid, may designate opens,\n   byte-range
        locks, or file delegations.\n"
      - contents:
        - "13.1.5.1.  NFS4ERR_ADMIN_REVOKED (Error Code 10047)\n   A stateid designates
          locking state of any type that has been revoked\n   due to administrative
          interaction, possibly while the lease is valid,\n   or because a delegation
          was revoked because of failure to return it,\n   while the lease was valid.\n"
        title: 13.1.5.1.  NFS4ERR_ADMIN_REVOKED (Error Code 10047)
      - contents:
        - "13.1.5.2.  NFS4ERR_BAD_STATEID (Error Code 10025)\n   A stateid generated
          by the current server instance was used that\n   either:\n   o  Does not
          designate any locking state (either current or\n      superseded) for a
          current (state-owner, file) pair.\n   o  Designates locking state that was
          freed after lease expiration but\n      without any lease cancellation,
          as may happen in the handling of\n      \"courtesy locks\".\n"
        title: 13.1.5.2.  NFS4ERR_BAD_STATEID (Error Code 10025)
      - contents:
        - "13.1.5.3.  NFS4ERR_EXPIRED (Error Code 10011)\n   A stateid or clientid
          designates locking state of any type that has\n   been revoked or released
          due to cancellation of the client's lease,\n   either immediately upon lease
          expiration, or following a later\n   request for a conflicting lock.\n"
        title: 13.1.5.3.  NFS4ERR_EXPIRED (Error Code 10011)
      - contents:
        - "13.1.5.4.  NFS4ERR_LEASE_MOVED (Error Code 10031)\n   A lease being renewed
          is associated with a file system that has been\n   migrated to a new server.\n"
        title: 13.1.5.4.  NFS4ERR_LEASE_MOVED (Error Code 10031)
      - contents:
        - "13.1.5.5.  NFS4ERR_OLD_STATEID (Error Code 10024)\n   A stateid is provided
          with a seqid value that is not the most\n   current.\n"
        title: 13.1.5.5.  NFS4ERR_OLD_STATEID (Error Code 10024)
      - contents:
        - "13.1.5.6.  NFS4ERR_STALE_STATEID (Error Code 10023)\n   A stateid generated
          by an earlier server instance was used.\n"
        title: 13.1.5.6.  NFS4ERR_STALE_STATEID (Error Code 10023)
      title: 13.1.5.  State Management Errors
    - contents:
      - "13.1.6.  Security Errors\n   These are the various permission-related errors
        in NFSv4.\n"
      - contents:
        - "13.1.6.1.  NFS4ERR_ACCESS (Error Code 13)\n   This indicates permission
          denied.  The caller does not have the\n   correct permission to perform
          the requested operation.  Contrast this\n   with NFS4ERR_PERM (Section 13.1.6.2),
          which restricts itself to owner\n   or privileged user permission failures.\n"
        title: 13.1.6.1.  NFS4ERR_ACCESS (Error Code 13)
      - contents:
        - "13.1.6.2.  NFS4ERR_PERM (Error Code 1)\n   This indicates that the requester
          is not the owner.  The operation\n   was not allowed because the caller
          is neither a privileged user\n   (root) nor the owner of the target of the
          operation.\n"
        title: 13.1.6.2.  NFS4ERR_PERM (Error Code 1)
      - contents:
        - "13.1.6.3.  NFS4ERR_WRONGSEC (Error Code 10016)\n   This indicates that
          the security mechanism being used by the client\n   for the operation does
          not match the server's security policy.  The\n   client should change the
          security mechanism being used and re-send\n   the operation.  SECINFO can
          be used to determine the appropriate\n   mechanism.\n"
        title: 13.1.6.3.  NFS4ERR_WRONGSEC (Error Code 10016)
      title: 13.1.6.  Security Errors
    - contents:
      - "13.1.7.  Name Errors\n   Names in NFSv4 are UTF-8 strings.  When the strings
        are not of length\n   zero, the error NFS4ERR_INVAL results.  When they are
        not valid\n   UTF-8, the error NFS4ERR_INVAL also results, but servers may\n
        \  accommodate file systems with different character formats and not\n   return
        this error.  Besides this, there are a number of other errors\n   to indicate
        specific problems with names.\n"
      - contents:
        - "13.1.7.1.  NFS4ERR_BADCHAR (Error Code 10040)\n   A UTF-8 string contains
          a character that is not supported by the\n   server in the context in which
          it is being used.\n"
        title: 13.1.7.1.  NFS4ERR_BADCHAR (Error Code 10040)
      - contents:
        - "13.1.7.2.  NFS4ERR_BADNAME (Error Code 10041)\n   A name string in a request
          consisted of valid UTF-8 characters\n   supported by the server, but the
          name is not supported by the server\n   as a valid name for current operation.
          \ An example might be creating\n   a file or directory named \"..\" on a
          server whose file system uses\n   that name for links to parent directories.\n
          \  This error should not be returned due to a normalization issue in a\n
          \  string.  When a file system keeps names in a particular normalization\n
          \  form, it is the server's responsibility to do the appropriate\n   normalization,
          rather than rejecting the name.\n"
        title: 13.1.7.2.  NFS4ERR_BADNAME (Error Code 10041)
      - contents:
        - "13.1.7.3.  NFS4ERR_NAMETOOLONG (Error Code 63)\n   This is returned when
          the filename in an operation exceeds the\n   server's implementation limit.\n"
        title: 13.1.7.3.  NFS4ERR_NAMETOOLONG (Error Code 63)
      title: 13.1.7.  Name Errors
    - contents:
      - "13.1.8.  Locking Errors\n   This section deals with errors related to locking
        -- both share\n   reservations and byte-range locking.  It does not deal with
        errors\n   specific to the process of reclaiming locks.  Those are dealt with
        in\n   the next section.\n"
      - contents:
        - "13.1.8.1.  NFS4ERR_BAD_RANGE (Error Code 10042)\n   The range for a LOCK,
          LOCKT, or LOCKU operation is not appropriate to\n   the allowable range
          of offsets for the server.  For example, this\n   error results when a server
          that only supports 32-bit ranges receives\n   a range that cannot be handled
          by that server.  (See\n   Section 16.10.4.)\n"
        title: 13.1.8.1.  NFS4ERR_BAD_RANGE (Error Code 10042)
      - contents:
        - "13.1.8.2.  NFS4ERR_BAD_SEQID (Error Code 10026)\n   The sequence number
          (seqid) in a locking request is neither the next\n   expected number nor
          the last number processed.\n"
        title: 13.1.8.2.  NFS4ERR_BAD_SEQID (Error Code 10026)
      - contents:
        - "13.1.8.3.  NFS4ERR_DEADLOCK (Error Code 10045)\n   The server has been
          able to determine a file locking deadlock\n   condition for a blocking lock
          request.\n"
        title: 13.1.8.3.  NFS4ERR_DEADLOCK (Error Code 10045)
      - contents:
        - "13.1.8.4.  NFS4ERR_DENIED (Error Code 10010)\n   An attempt to lock a file
          is denied.  Since this may be a temporary\n   condition, the client is encouraged
          to re-send the lock request until\n   the lock is accepted.  See Section
          9.4 for a discussion of the\n   re-send.\n"
        title: 13.1.8.4.  NFS4ERR_DENIED (Error Code 10010)
      - contents:
        - "13.1.8.5.  NFS4ERR_LOCKED (Error Code 10012)\n   A READ or WRITE operation
          was attempted on a file where there was a\n   conflict between the I/O and
          an existing lock:\n   o  There is a share reservation inconsistent with
          the I/O being done.\n   o  The range to be read or written intersects an
          existing mandatory\n      byte-range lock.\n"
        title: 13.1.8.5.  NFS4ERR_LOCKED (Error Code 10012)
      - contents:
        - "13.1.8.6.  NFS4ERR_LOCKS_HELD (Error Code 10037)\n   An operation was prevented
          by the unexpected presence of locks.\n"
        title: 13.1.8.6.  NFS4ERR_LOCKS_HELD (Error Code 10037)
      - contents:
        - "13.1.8.7.  NFS4ERR_LOCK_NOTSUPP (Error Code 10043)\n   A locking request
          was attempted that would require the upgrade or\n   downgrade of a lock
          range already held by the owner when the server\n   does not support atomic
          upgrade or downgrade of locks.\n"
        title: 13.1.8.7.  NFS4ERR_LOCK_NOTSUPP (Error Code 10043)
      - contents:
        - "13.1.8.8.  NFS4ERR_LOCK_RANGE (Error Code 10028)\n   A lock request is
          operating on a range that partially overlaps a\n   currently held lock for
          the current lock-owner and does not precisely\n   match a single such lock,
          where the server does not support this type\n   of request and thus does
          not implement POSIX locking semantics\n   [fcntl].  See Sections 16.10.5,
          16.11.5, and 16.12.5 for a discussion\n   of how this applies to LOCK, LOCKT,
          and LOCKU, respectively.\n"
        title: 13.1.8.8.  NFS4ERR_LOCK_RANGE (Error Code 10028)
      - contents:
        - "13.1.8.9.  NFS4ERR_OPENMODE (Error Code 10038)\n   The client attempted
          a READ, WRITE, LOCK, or other operation not\n   sanctioned by the stateid
          passed (e.g., writing to a file opened only\n   for read).\n"
        title: 13.1.8.9.  NFS4ERR_OPENMODE (Error Code 10038)
      - contents:
        - "13.1.8.10.  NFS4ERR_SHARE_DENIED (Error Code 10015)\n   An attempt to OPEN
          a file with a share reservation has failed because\n   of a share conflict.\n"
        title: 13.1.8.10.  NFS4ERR_SHARE_DENIED (Error Code 10015)
      title: 13.1.8.  Locking Errors
    - contents:
      - "13.1.9.  Reclaim Errors\n   These errors relate to the process of reclaiming
        locks after a server\n   restart.\n"
      - contents:
        - "13.1.9.1.  NFS4ERR_GRACE (Error Code 10013)\n   The server is in its recovery
          or grace period, which should at least\n   match the lease period of the
          server.  A locking request other than a\n   reclaim could not be granted
          during that period.\n"
        title: 13.1.9.1.  NFS4ERR_GRACE (Error Code 10013)
      - contents:
        - "13.1.9.2.  NFS4ERR_NO_GRACE (Error Code 10033)\n   The server cannot guarantee
          that it has not granted state to another\n   client that may conflict with
          this client's state.  No further\n   reclaims from this client will succeed.\n"
        title: 13.1.9.2.  NFS4ERR_NO_GRACE (Error Code 10033)
      - contents:
        - "13.1.9.3.  NFS4ERR_RECLAIM_BAD (Error Code 10034)\n   The server cannot
          guarantee that it has not granted state to another\n   client that may conflict
          with the requested state.  However, this\n   applies only to the state requested
          in this call; further reclaims\n   may succeed.\n   Unlike NFS4ERR_RECLAIM_CONFLICT,
          this can occur between correctly\n   functioning clients and servers: the
          \"edge condition\" scenarios\n   described in Section 9.6.3.4 leave only
          the server knowing whether\n   the client's locks are still valid, and NFS4ERR_RECLAIM_BAD
          is the\n   server's way of informing the client that they are not.\n"
        title: 13.1.9.3.  NFS4ERR_RECLAIM_BAD (Error Code 10034)
      - contents:
        - "13.1.9.4.  NFS4ERR_RECLAIM_CONFLICT (Error Code 10035)\n   The reclaim
          attempted by the client conflicts with a lock already\n   held by another
          client.  Unlike NFS4ERR_RECLAIM_BAD, this can only\n   occur if one of the
          clients misbehaved.\n"
        title: 13.1.9.4.  NFS4ERR_RECLAIM_CONFLICT (Error Code 10035)
      title: 13.1.9.  Reclaim Errors
    - contents:
      - "13.1.10.  Client Management Errors\n   This section deals with errors associated
        with requests used to\n   create and manage client IDs.\n"
      - contents:
        - "13.1.10.1.  NFS4ERR_CLID_INUSE (Error Code 10017)\n   The SETCLIENTID operation
          has found that a clientid is already in use\n   by another client.\n"
        title: 13.1.10.1.  NFS4ERR_CLID_INUSE (Error Code 10017)
      - contents:
        - "13.1.10.2.  NFS4ERR_STALE_CLIENTID (Error Code 10022)\n   A client ID not
          recognized by the server was used in a locking or\n   SETCLIENTID_CONFIRM
          request.\n"
        title: 13.1.10.2.  NFS4ERR_STALE_CLIENTID (Error Code 10022)
      title: 13.1.10.  Client Management Errors
    - contents:
      - "13.1.11.  Attribute Handling Errors\n   This section deals with errors specific
        to attribute handling within\n   NFSv4.\n"
      - contents:
        - "13.1.11.1.  NFS4ERR_ATTRNOTSUPP (Error Code 10032)\n   An attribute specified
          is not supported by the server.  This error\n   MUST NOT be returned by
          the GETATTR operation.\n"
        title: 13.1.11.1.  NFS4ERR_ATTRNOTSUPP (Error Code 10032)
      - contents:
        - "13.1.11.2.  NFS4ERR_BADOWNER (Error Code 10039)\n   This error is returned
          when an owner or owner_group attribute value\n   or the who field of an
          ace within an ACL attribute value cannot be\n   translated to a local representation.\n"
        title: 13.1.11.2.  NFS4ERR_BADOWNER (Error Code 10039)
      - contents:
        - "13.1.11.3.  NFS4ERR_NOT_SAME (Error Code 10027)\n   This error is returned
          by the VERIFY operation to signify that the\n   attributes compared were
          not the same as those provided in the\n   client's request.\n"
        title: 13.1.11.3.  NFS4ERR_NOT_SAME (Error Code 10027)
      - contents:
        - "13.1.11.4.  NFS4ERR_SAME (Error Code 10009)\n   This error is returned
          by the NVERIFY operation to signify that the\n   attributes compared were
          the same as those provided in the client's\n   request.\n"
        title: 13.1.11.4.  NFS4ERR_SAME (Error Code 10009)
      title: 13.1.11.  Attribute Handling Errors
    - contents:
      - '13.1.12.  Miscellaneous Errors

        '
      - contents:
        - "13.1.12.1.  NFS4ERR_CB_PATH_DOWN (Error Code 10048)\n   There is a problem
          contacting the client via the callback path.\n"
        title: 13.1.12.1.  NFS4ERR_CB_PATH_DOWN (Error Code 10048)
      title: 13.1.12.  Miscellaneous Errors
    title: 13.1.  Error Definitions
  - contents:
    - "13.2.  Operations and Their Valid Errors\n   This section contains a table
      that gives the valid error returns for\n   each protocol operation.  The error
      code NFS4_OK (indicating no\n   error) is not listed but should be understood
      to be returnable by all\n   operations except ILLEGAL.\n   +---------------------+---------------------------------------------+\n
      \  | Operation           | Errors                                      |\n   +---------------------+---------------------------------------------+\n
      \  | ACCESS              | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE,          |\n   |
      \                    | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |\n   |                     |
      NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,           |\n   |                     | NFS4ERR_IO,
      NFS4ERR_MOVED,                  |\n   |                     | NFS4ERR_NOFILEHANDLE,
      NFS4ERR_RESOURCE,     |\n   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE
      \         |\n   |                     |                                             |\n
      \  | CLOSE               | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADHANDLE,   |\n   |
      \                    | NFS4ERR_BAD_SEQID, NFS4ERR_BAD_STATEID,     |\n   |                     |
      NFS4ERR_BADXDR, NFS4ERR_DELAY,              |\n   |                     | NFS4ERR_EXPIRED,
      NFS4ERR_FHEXPIRED,         |\n   |                     | NFS4ERR_INVAL, NFS4ERR_ISDIR,
      \              |\n   |                     | NFS4ERR_LEASE_MOVED, NFS4ERR_LOCKS_HELD,
      \   |\n   |                     | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,        |\n
      \  |                     | NFS4ERR_OLD_STATEID, NFS4ERR_RESOURCE,      |\n   |
      \                    | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |\n   |                     |
      NFS4ERR_STALE_STATEID                       |\n   |                     |                                             |\n
      \  | COMMIT              | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE,          |\n   |
      \                    | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |\n   |                     |
      NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,           |\n   |                     | NFS4ERR_IO,
      NFS4ERR_ISDIR, NFS4ERR_MOVED,   |\n   |                     | NFS4ERR_NOFILEHANDLE,
      NFS4ERR_RESOURCE,     |\n   |                     | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,
      \         |\n   |                     | NFS4ERR_STALE, NFS4ERR_SYMLINK              |\n
      \  |                     |                                             |\n   |
      CREATE              | NFS4ERR_ACCESS, NFS4ERR_ATTRNOTSUPP,        |\n   |                     |
      NFS4ERR_BADCHAR, NFS4ERR_BADHANDLE,         |\n   |                     | NFS4ERR_BADNAME,
      NFS4ERR_BADOWNER,          |\n   |                     | NFS4ERR_BADTYPE, NFS4ERR_BADXDR,
      \           |\n   |                     | NFS4ERR_DELAY, NFS4ERR_DQUOT,               |\n
      \  |                     | NFS4ERR_EXIST, NFS4ERR_FHEXPIRED,           |\n   |
      \                    | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED,   |\n   |                     |
      NFS4ERR_NAMETOOLONG, NFS4ERR_NOFILEHANDLE,  |\n   |                     | NFS4ERR_NOSPC,
      NFS4ERR_NOTDIR,              |\n   |                     | NFS4ERR_PERM, NFS4ERR_RESOURCE,
      \            |\n   |                     | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,
      \         |\n   |                     | NFS4ERR_STALE                               |\n
      \  |                     |                                             |\n   |
      DELEGPURGE          | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |\n   |                     |
      NFS4ERR_LEASE_MOVED, NFS4ERR_NOTSUPP,       |\n   |                     | NFS4ERR_RESOURCE,
      NFS4ERR_SERVERFAULT,      |\n   |                     | NFS4ERR_STALE_CLIENTID
      \                     |\n   |                     |                                             |\n
      \  | DELEGRETURN         | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BAD_STATEID, |\n   |
      \                    | NFS4ERR_BADXDR, NFS4ERR_DELAY,              |\n   |                     |
      NFS4ERR_EXPIRED, NFS4ERR_INVAL,             |\n   |                     | NFS4ERR_LEASE_MOVED,
      NFS4ERR_MOVED,         |\n   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTSUPP,
      \     |\n   |                     | NFS4ERR_OLD_STATEID, NFS4ERR_RESOURCE,      |\n
      \  |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |\n   |
      \                    | NFS4ERR_STALE_STATEID                       |\n   |                     |
      \                                            |\n   | GETATTR             | NFS4ERR_ACCESS,
      NFS4ERR_BADHANDLE,          |\n   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,
      \             |\n   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,
      \          |\n   |                     | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED,
      \  |\n   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_RESOURCE,     |\n
      \  |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE          |\n   |
      \                    |                                             |\n   | GETFH
      \              | NFS4ERR_BADHANDLE, NFS4ERR_FHEXPIRED,       |\n   |                     |
      NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,        |\n   |                     | NFS4ERR_RESOURCE,
      NFS4ERR_SERVERFAULT,      |\n   |                     | NFS4ERR_STALE                               |\n
      \  |                     |                                             |\n   |
      ILLEGAL             | NFS4ERR_BADXDR, NFS4ERR_OP_ILLEGAL          |\n   |                     |
      \                                            |\n   | LINK                | NFS4ERR_ACCESS,
      NFS4ERR_BADCHAR,            |\n   |                     | NFS4ERR_BADHANDLE,
      NFS4ERR_BADNAME,         |\n   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,
      \             |\n   |                     | NFS4ERR_DQUOT, NFS4ERR_EXIST,               |\n
      \  |                     | NFS4ERR_FHEXPIRED, NFS4ERR_FILE_OPEN,       |\n   |
      \                    | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_ISDIR,   |\n   |                     |
      NFS4ERR_MLINK, NFS4ERR_MOVED,               |\n   |                     | NFS4ERR_NAMETOOLONG,
      NFS4ERR_NOENT,         |\n   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,
      \       |\n   |                     | NFS4ERR_NOTDIR, NFS4ERR_NOTSUPP,            |\n
      \  |                     | NFS4ERR_RESOURCE, NFS4ERR_ROFS,             |\n   |
      \                    | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |\n   |                     |
      NFS4ERR_WRONGSEC, NFS4ERR_XDEV              |\n   |                     |                                             |\n
      \  | LOCK                | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,      |\n   |
      \                    | NFS4ERR_BADHANDLE, NFS4ERR_BAD_RANGE,       |\n   |                     |
      NFS4ERR_BAD_SEQID, NFS4ERR_BAD_STATEID,     |\n   |                     | NFS4ERR_BADXDR,
      NFS4ERR_DEADLOCK,           |\n   |                     | NFS4ERR_DELAY, NFS4ERR_DENIED,
      \             |\n   |                     | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,
      \        |\n   |                     | NFS4ERR_GRACE, NFS4ERR_INVAL,               |\n
      \  |                     | NFS4ERR_ISDIR, NFS4ERR_LEASE_MOVED,         |\n   |
      \                    | NFS4ERR_LOCK_NOTSUPP, NFS4ERR_LOCK_RANGE,   |\n   |                     |
      NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,        |\n   |                     | NFS4ERR_NO_GRACE,
      NFS4ERR_OLD_STATEID,      |\n   |                     | NFS4ERR_OPENMODE, NFS4ERR_RECLAIM_BAD,
      \     |\n   |                     | NFS4ERR_RECLAIM_CONFLICT, NFS4ERR_RESOURCE,
      |\n   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |\n
      \  |                     | NFS4ERR_STALE_CLIENTID,                     |\n   |
      \                    | NFS4ERR_STALE_STATEID                       |\n   |                     |
      \                                            |\n   | LOCKT               | NFS4ERR_ACCESS,
      NFS4ERR_BADHANDLE,          |\n   |                     | NFS4ERR_BAD_RANGE,
      NFS4ERR_BADXDR,          |\n   |                     | NFS4ERR_DELAY, NFS4ERR_DENIED,
      \             |\n   |                     | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,
      \        |\n   |                     | NFS4ERR_GRACE, NFS4ERR_INVAL,               |\n
      \  |                     | NFS4ERR_ISDIR, NFS4ERR_LEASE_MOVED,         |\n   |
      \                    | NFS4ERR_LOCK_RANGE, NFS4ERR_MOVED,          |\n   |                     |
      NFS4ERR_NOFILEHANDLE, NFS4ERR_RESOURCE,     |\n   |                     | NFS4ERR_SERVERFAULT,
      NFS4ERR_STALE,         |\n   |                     | NFS4ERR_STALE_CLIENTID
      \                     |\n   |                     |                                             |\n
      \  | LOCKU               | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,      |\n   |
      \                    | NFS4ERR_BADHANDLE, NFS4ERR_BAD_RANGE,       |\n   |                     |
      NFS4ERR_BAD_SEQID, NFS4ERR_BAD_STATEID,     |\n   |                     | NFS4ERR_BADXDR,
      NFS4ERR_DELAY,              |\n   |                     | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,
      \        |\n   |                     | NFS4ERR_GRACE, NFS4ERR_INVAL,               |\n
      \  |                     | NFS4ERR_ISDIR, NFS4ERR_LEASE_MOVED,         |\n   |
      \                    | NFS4ERR_LOCK_RANGE, NFS4ERR_MOVED,          |\n   |                     |
      NFS4ERR_NOFILEHANDLE, NFS4ERR_OLD_STATEID,  |\n   |                     | NFS4ERR_RESOURCE,
      NFS4ERR_SERVERFAULT,      |\n   |                     | NFS4ERR_STALE, NFS4ERR_STALE_STATEID
      \       |\n   |                     |                                             |\n
      \  | LOOKUP              | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,            |\n   |
      \                    | NFS4ERR_BADHANDLE, NFS4ERR_BADNAME,         |\n   |                     |
      NFS4ERR_BADXDR, NFS4ERR_DELAY,              |\n   |                     | NFS4ERR_FHEXPIRED,
      NFS4ERR_INVAL,           |\n   |                     | NFS4ERR_IO, NFS4ERR_MOVED,
      \                 |\n   |                     | NFS4ERR_NAMETOOLONG, NFS4ERR_NOENT,
      \        |\n   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR,
      \      |\n   |                     | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT,
      \     |\n   |                     | NFS4ERR_STALE, NFS4ERR_SYMLINK,             |\n
      \  |                     | NFS4ERR_WRONGSEC                            |\n   |
      \                    |                                             |\n   | LOOKUPP
      \            | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE,          |\n   |                     |
      NFS4ERR_DELAY, NFS4ERR_FHEXPIRED,           |\n   |                     | NFS4ERR_IO,
      NFS4ERR_MOVED, NFS4ERR_NOENT,   |\n   |                     | NFS4ERR_NOFILEHANDLE,
      NFS4ERR_NOTDIR,       |\n   |                     | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT,
      \     |\n   |                     | NFS4ERR_STALE, NFS4ERR_SYMLINK,             |\n
      \  |                     | NFS4ERR_WRONGSEC                            |\n   |
      \                    |                                             |\n   | NVERIFY
      \            | NFS4ERR_ACCESS, NFS4ERR_ATTRNOTSUPP,        |\n   |                     |
      NFS4ERR_BADCHAR, NFS4ERR_BADHANDLE,         |\n   |                     | NFS4ERR_BADXDR,
      NFS4ERR_DELAY,              |\n   |                     | NFS4ERR_FHEXPIRED,
      NFS4ERR_GRACE,           |\n   |                     | NFS4ERR_INVAL, NFS4ERR_IO,
      NFS4ERR_MOVED,   |\n   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_SAME,
      \        |\n   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE          |\n
      \  |                     |                                             |\n   |
      OPEN                | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,      |\n   |                     |
      NFS4ERR_ATTRNOTSUPP, NFS4ERR_BADCHAR,       |\n   |                     | NFS4ERR_BADHANDLE,
      NFS4ERR_BADNAME,         |\n   |                     | NFS4ERR_BADOWNER, NFS4ERR_BAD_SEQID,
      \       |\n   |                     | NFS4ERR_BAD_STATEID, NFS4ERR_BADXDR,        |\n
      \  |                     | NFS4ERR_DELAY, NFS4ERR_DQUOT,               |\n   |
      \                    | NFS4ERR_EXIST, NFS4ERR_EXPIRED,             |\n   |                     |
      NFS4ERR_FBIG, NFS4ERR_FHEXPIRED,            |\n   |                     | NFS4ERR_GRACE,
      NFS4ERR_INVAL, NFS4ERR_IO,   |\n   |                     | NFS4ERR_ISDIR, NFS4ERR_MOVED,
      \              |\n   |                     | NFS4ERR_NAMETOOLONG, NFS4ERR_NOENT,
      \        |\n   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_NO_GRACE,
      \    |\n   |                     | NFS4ERR_NOSPC, NFS4ERR_NOTDIR,              |\n
      \  |                     | NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID,       |\n   |
      \                    | NFS4ERR_PERM, NFS4ERR_RECLAIM_BAD,          |\n   |                     |
      NFS4ERR_RECLAIM_CONFLICT, NFS4ERR_RESOURCE, |\n   |                     | NFS4ERR_ROFS,
      NFS4ERR_SERVERFAULT,          |\n   |                     | NFS4ERR_SHARE_DENIED,
      NFS4ERR_STALE,        |\n   |                     | NFS4ERR_STALE_CLIENTID,
      NFS4ERR_SYMLINK,    |\n   |                     | NFS4ERR_WRONGSEC                            |\n
      \  |                     |                                             |\n   |
      OPENATTR            | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE,          |\n   |                     |
      NFS4ERR_BADXDR, NFS4ERR_DELAY,              |\n   |                     | NFS4ERR_DQUOT,
      NFS4ERR_FHEXPIRED,           |\n   |                     | NFS4ERR_IO, NFS4ERR_MOVED,
      NFS4ERR_NOENT,   |\n   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,
      \       |\n   |                     | NFS4ERR_NOTSUPP, NFS4ERR_RESOURCE,          |\n
      \  |                     | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,          |\n   |
      \                    | NFS4ERR_STALE                               |\n   |                     |
      \                                            |\n   | OPEN_CONFIRM        | NFS4ERR_ADMIN_REVOKED,
      NFS4ERR_BADHANDLE,   |\n   |                     | NFS4ERR_BAD_SEQID, NFS4ERR_BAD_STATEID,
      \    |\n   |                     | NFS4ERR_BADXDR, NFS4ERR_EXPIRED,            |\n
      \  |                     | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,           |\n   |
      \                    | NFS4ERR_ISDIR, NFS4ERR_LEASE_MOVED,         |\n   |                     |
      NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,        |\n   |                     | NFS4ERR_OLD_STATEID,
      NFS4ERR_RESOURCE,      |\n   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,
      \        |\n   |                     | NFS4ERR_STALE_STATEID                       |\n
      \  |                     |                                             |\n   |
      OPEN_DOWNGRADE      | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADHANDLE,   |\n   |                     |
      NFS4ERR_BAD_SEQID, NFS4ERR_BAD_STATEID,     |\n   |                     | NFS4ERR_BADXDR,
      NFS4ERR_DELAY,              |\n   |                     | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED,
      \        |\n   |                     | NFS4ERR_INVAL, NFS4ERR_LEASE_MOVED,         |\n
      \  |                     | NFS4ERR_LOCKS_HELD, NFS4ERR_MOVED,          |\n   |
      \                    | NFS4ERR_NOFILEHANDLE, NFS4ERR_OLD_STATEID,  |\n   |                     |
      NFS4ERR_RESOURCE, NFS4ERR_ROFS,             |\n   |                     | NFS4ERR_SERVERFAULT,
      NFS4ERR_STALE,         |\n   |                     | NFS4ERR_STALE_STATEID                       |\n
      \  |                     |                                             |\n   |
      PUTFH               | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,          |\n   |                     |
      NFS4ERR_DELAY, NFS4ERR_FHEXPIRED,           |\n   |                     | NFS4ERR_MOVED,
      NFS4ERR_SERVERFAULT,         |\n   |                     | NFS4ERR_STALE, NFS4ERR_WRONGSEC
      \            |\n   |                     |                                             |\n
      \  | PUTPUBFH            | NFS4ERR_DELAY, NFS4ERR_SERVERFAULT,         |\n   |
      \                    | NFS4ERR_WRONGSEC                            |\n   |                     |
      \                                            |\n   | PUTROOTFH           | NFS4ERR_DELAY,
      NFS4ERR_SERVERFAULT,         |\n   |                     | NFS4ERR_WRONGSEC
      \                           |\n   |                     |                                             |\n
      \  | READ                | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,      |\n   |
      \                    | NFS4ERR_BADHANDLE, NFS4ERR_BAD_STATEID,     |\n   |                     |
      NFS4ERR_BADXDR, NFS4ERR_DELAY,              |\n   |                     | NFS4ERR_EXPIRED,
      NFS4ERR_FHEXPIRED,         |\n   |                     | NFS4ERR_GRACE, NFS4ERR_INVAL,
      NFS4ERR_IO,   |\n   |                     | NFS4ERR_ISDIR, NFS4ERR_LEASE_MOVED,
      \        |\n   |                     | NFS4ERR_LOCKED, NFS4ERR_MOVED,              |\n
      \  |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_OLD_STATEID,  |\n   |
      \                    | NFS4ERR_OPENMODE, NFS4ERR_RESOURCE,         |\n   |                     |
      NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |\n   |                     | NFS4ERR_STALE_STATEID,
      NFS4ERR_SYMLINK      |\n   |                     |                                             |\n
      \  | READDIR             | NFS4ERR_ACCESS, NFS4ERR_BAD_COOKIE,         |\n   |
      \                    | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,          |\n   |                     |
      NFS4ERR_DELAY, NFS4ERR_FHEXPIRED,           |\n   |                     | NFS4ERR_INVAL,
      NFS4ERR_IO, NFS4ERR_MOVED,   |\n   |                     | NFS4ERR_NOFILEHANDLE,
      NFS4ERR_NOTDIR,       |\n   |                     | NFS4ERR_NOT_SAME, NFS4ERR_RESOURCE,
      \        |\n   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,         |\n
      \  |                     | NFS4ERR_TOOSMALL                            |\n   |
      \                    |                                             |\n   | READLINK
      \           | NFS4ERR_ACCESS, NFS4ERR_BADHANDLE,          |\n   |                     |
      NFS4ERR_DELAY, NFS4ERR_FHEXPIRED,           |\n   |                     | NFS4ERR_INVAL,
      NFS4ERR_IO, NFS4ERR_ISDIR,   |\n   |                     | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,
      \       |\n   |                     | NFS4ERR_NOTSUPP, NFS4ERR_RESOURCE,          |\n
      \  |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE          |\n   |
      \                    |                                             |\n   | RELEASE_LOCKOWNER
      \  | NFS4ERR_BADXDR, NFS4ERR_EXPIRED,            |\n   |                     |
      NFS4ERR_LEASE_MOVED, NFS4ERR_LOCKS_HELD,    |\n   |                     | NFS4ERR_RESOURCE,
      NFS4ERR_SERVERFAULT,      |\n   |                     | NFS4ERR_STALE_CLIENTID
      \                     |\n   |                     |                                             |\n
      \  | REMOVE              | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,            |\n   |
      \                    | NFS4ERR_BADHANDLE, NFS4ERR_BADNAME,         |\n   |                     |
      NFS4ERR_BADXDR, NFS4ERR_DELAY,              |\n   |                     | NFS4ERR_FHEXPIRED,
      NFS4ERR_FILE_OPEN,       |\n   |                     | NFS4ERR_GRACE, NFS4ERR_INVAL,
      NFS4ERR_IO,   |\n   |                     | NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG,
      \        |\n   |                     | NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE,
      \       |\n   |                     | NFS4ERR_NOTDIR, NFS4ERR_NOTEMPTY,           |\n
      \  |                     | NFS4ERR_RESOURCE, NFS4ERR_ROFS,             |\n   |
      \                    | NFS4ERR_SERVERFAULT, NFS4ERR_STALE          |\n   |                     |
      \                                            |\n   | RENAME              | NFS4ERR_ACCESS,
      NFS4ERR_BADCHAR,            |\n   |                     | NFS4ERR_BADHANDLE,
      NFS4ERR_BADNAME,         |\n   |                     | NFS4ERR_BADXDR, NFS4ERR_DELAY,
      \             |\n   |                     | NFS4ERR_DQUOT, NFS4ERR_EXIST,               |\n
      \  |                     | NFS4ERR_FHEXPIRED, NFS4ERR_FILE_OPEN,       |\n   |
      \                    | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO,   |\n   |                     |
      NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG,         |\n   |                     | NFS4ERR_NOENT,
      NFS4ERR_NOFILEHANDLE,        |\n   |                     | NFS4ERR_NOSPC, NFS4ERR_NOTDIR,
      \             |\n   |                     | NFS4ERR_NOTEMPTY, NFS4ERR_RESOURCE,
      \        |\n   |                     | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,          |\n
      \  |                     | NFS4ERR_STALE, NFS4ERR_WRONGSEC,            |\n   |
      \                    | NFS4ERR_XDEV                                |\n   |                     |
      \                                            |\n   | RENEW               | NFS4ERR_ACCESS,
      NFS4ERR_BADXDR,             |\n   |                     | NFS4ERR_CB_PATH_DOWN,
      NFS4ERR_EXPIRED,      |\n   |                     | NFS4ERR_LEASE_MOVED, NFS4ERR_RESOURCE,
      \     |\n   |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE_CLIENTID
      |\n   |                     |                                             |\n
      \  | RESTOREFH           | NFS4ERR_BADHANDLE, NFS4ERR_FHEXPIRED,       |\n   |
      \                    | NFS4ERR_MOVED, NFS4ERR_RESOURCE,            |\n   |                     |
      NFS4ERR_RESTOREFH, NFS4ERR_SERVERFAULT,     |\n   |                     | NFS4ERR_STALE,
      NFS4ERR_WRONGSEC             |\n   |                     |                                             |\n
      \  | SAVEFH              | NFS4ERR_BADHANDLE, NFS4ERR_FHEXPIRED,       |\n   |
      \                    | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,        |\n   |                     |
      NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT,      |\n   |                     | NFS4ERR_STALE
      \                              |\n   |                     |                                             |\n
      \  | SECINFO             | NFS4ERR_ACCESS, NFS4ERR_BADCHAR,            |\n   |
      \                    | NFS4ERR_BADHANDLE, NFS4ERR_BADNAME,         |\n   |                     |
      NFS4ERR_BADXDR, NFS4ERR_DELAY,              |\n   |                     | NFS4ERR_FHEXPIRED,
      NFS4ERR_INVAL,           |\n   |                     | NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG,
      \        |\n   |                     | NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE,
      \       |\n   |                     | NFS4ERR_NOTDIR, NFS4ERR_RESOURCE,           |\n
      \  |                     | NFS4ERR_SERVERFAULT, NFS4ERR_STALE          |\n   |
      \                    |                                             |\n   | SETATTR
      \            | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,      |\n   |                     |
      NFS4ERR_ATTRNOTSUPP, NFS4ERR_BADCHAR,       |\n   |                     | NFS4ERR_BADHANDLE,
      NFS4ERR_BADOWNER,        |\n   |                     | NFS4ERR_BAD_STATEID,
      NFS4ERR_BADXDR,        |\n   |                     | NFS4ERR_DELAY, NFS4ERR_DQUOT,
      \              |\n   |                     | NFS4ERR_EXPIRED, NFS4ERR_FBIG,
      \             |\n   |                     | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,
      \          |\n   |                     | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_ISDIR,
      \  |\n   |                     | NFS4ERR_LEASE_MOVED, NFS4ERR_LOCKED,        |\n
      \  |                     | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,        |\n   |
      \                    | NFS4ERR_NOSPC, NFS4ERR_OLD_STATEID,         |\n   |                     |
      NFS4ERR_OPENMODE, NFS4ERR_PERM,             |\n   |                     | NFS4ERR_RESOURCE,
      NFS4ERR_ROFS,             |\n   |                     | NFS4ERR_SERVERFAULT,
      NFS4ERR_STALE,         |\n   |                     | NFS4ERR_STALE_STATEID                       |\n
      \  |                     |                                             |\n   |
      SETCLIENTID         | NFS4ERR_BADXDR, NFS4ERR_CLID_INUSE,         |\n   |                     |
      NFS4ERR_DELAY, NFS4ERR_INVAL,               |\n   |                     | NFS4ERR_RESOURCE,
      NFS4ERR_SERVERFAULT       |\n   |                     |                                             |\n
      \  | SETCLIENTID_CONFIRM | NFS4ERR_BADXDR, NFS4ERR_CLID_INUSE,         |\n   |
      \                    | NFS4ERR_DELAY, NFS4ERR_RESOURCE,            |\n   |                     |
      NFS4ERR_SERVERFAULT, NFS4ERR_STALE_CLIENTID |\n   |                     |                                             |\n
      \  | VERIFY              | NFS4ERR_ACCESS, NFS4ERR_ATTRNOTSUPP,        |\n   |
      \                    | NFS4ERR_BADCHAR, NFS4ERR_BADHANDLE,         |\n   |                     |
      NFS4ERR_BADXDR, NFS4ERR_DELAY,              |\n   |                     | NFS4ERR_FHEXPIRED,
      NFS4ERR_GRACE,           |\n   |                     | NFS4ERR_INVAL, NFS4ERR_IO,
      NFS4ERR_MOVED,   |\n   |                     | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOT_SAME,
      \    |\n   |                     | NFS4ERR_RESOURCE, NFS4ERR_SERVERFAULT,      |\n
      \  |                     | NFS4ERR_STALE                               |\n   |
      \                    |                                             |\n   | WRITE
      \              | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,      |\n   |                     |
      NFS4ERR_BADHANDLE, NFS4ERR_BAD_STATEID,     |\n   |                     | NFS4ERR_BADXDR,
      NFS4ERR_DELAY,              |\n   |                     | NFS4ERR_DQUOT, NFS4ERR_EXPIRED,
      \            |\n   |                     | NFS4ERR_FBIG, NFS4ERR_FHEXPIRED,
      \           |\n   |                     | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO,
      \  |\n   |                     | NFS4ERR_ISDIR, NFS4ERR_LEASE_MOVED,         |\n
      \  |                     | NFS4ERR_LOCKED, NFS4ERR_MOVED,              |\n   |
      \                    | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,        |\n   |                     |
      NFS4ERR_NXIO, NFS4ERR_OLD_STATEID,          |\n   |                     | NFS4ERR_OPENMODE,
      NFS4ERR_RESOURCE,         |\n   |                     | NFS4ERR_ROFS, NFS4ERR_SERVERFAULT,
      \         |\n   |                     | NFS4ERR_STALE, NFS4ERR_STALE_STATEID,
      \      |\n   |                     | NFS4ERR_SYMLINK                             |\n
      \  |                     |                                             |\n   +---------------------+---------------------------------------------+\n
      \        Table 7: Valid Error Returns for Each Protocol Operation\n"
    title: 13.2.  Operations and Their Valid Errors
  - contents:
    - "13.3.  Callback Operations and Their Valid Errors\n   This section contains
      a table that gives the valid error returns for\n   each callback operation.
      \ The error code NFS4_OK (indicating no\n   error) is not listed but should
      be understood to be returnable by all\n   callback operations, with the exception
      of CB_ILLEGAL.\n   +-------------+-----------------------------------------------------+\n
      \  | Callback    | Errors                                              |\n   |
      Operation   |                                                     |\n   +-------------+-----------------------------------------------------+\n
      \  | CB_GETATTR  | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR, NFS4ERR_DELAY,   |\n   |
      \            | NFS4ERR_INVAL, NFS4ERR_SERVERFAULT                  |\n   |             |
      \                                                    |\n   | CB_ILLEGAL  | NFS4ERR_BADXDR,
      NFS4ERR_OP_ILLEGAL                  |\n   |             |                                                     |\n
      \  | CB_RECALL   | NFS4ERR_BADHANDLE, NFS4ERR_BAD_STATEID,             |\n   |
      \            | NFS4ERR_BADXDR, NFS4ERR_DELAY, NFS4ERR_SERVERFAULT  |\n   |             |
      \                                                    |\n   +-------------+-----------------------------------------------------+\n
      \    Table 8: Valid Error Returns for Each Protocol Callback Operation\n"
    title: 13.3.  Callback Operations and Their Valid Errors
  - contents:
    - "13.4.  Errors and the Operations That Use Them\n   +--------------------------+----------------------------------------+\n
      \  | Error                    | Operations                             |\n   +--------------------------+----------------------------------------+\n
      \  | NFS4ERR_ACCESS           | ACCESS, COMMIT, CREATE, GETATTR, LINK, |\n   |
      \                         | LOCK, LOCKT, LOCKU, LOOKUP, LOOKUPP,   |\n   |                          |
      NVERIFY, OPEN, OPENATTR, READ,         |\n   |                          | READDIR,
      READLINK, REMOVE, RENAME,     |\n   |                          | RENEW, SECINFO,
      SETATTR, VERIFY, WRITE |\n   |                          |                                        |\n
      \  | NFS4ERR_ADMIN_REVOKED    | CLOSE, DELEGRETURN, LOCK, LOCKU, OPEN, |\n   |
      \                         | OPEN_CONFIRM, OPEN_DOWNGRADE, READ,    |\n   |                          |
      SETATTR, WRITE                         |\n   |                          |                                        |\n
      \  | NFS4ERR_ATTRNOTSUPP      | CREATE, NVERIFY, OPEN, SETATTR, VERIFY |\n   |
      \                         |                                        |\n   | NFS4ERR_BADCHAR
      \         | CREATE, LINK, LOOKUP, NVERIFY, OPEN,   |\n   |                          |
      REMOVE, RENAME, SECINFO, SETATTR,      |\n   |                          | VERIFY
      \                                |\n   |                          |                                        |\n
      \  | NFS4ERR_BADHANDLE        | ACCESS, CB_GETATTR, CB_RECALL, CLOSE,  |\n   |
      \                         | COMMIT, CREATE, GETATTR, GETFH, LINK,  |\n   |                          |
      LOCK, LOCKT, LOCKU, LOOKUP, LOOKUPP,   |\n   |                          | NVERIFY,
      OPEN, OPENATTR, OPEN_CONFIRM, |\n   |                          | OPEN_DOWNGRADE,
      PUTFH, READ, READDIR,  |\n   |                          | READLINK, REMOVE,
      RENAME, RESTOREFH,   |\n   |                          | SAVEFH, SECINFO, SETATTR,
      VERIFY,      |\n   |                          | WRITE                                  |\n
      \  |                          |                                        |\n   |
      NFS4ERR_BADNAME          | CREATE, LINK, LOOKUP, OPEN, REMOVE,    |\n   |                          |
      RENAME, SECINFO                        |\n   |                          |                                        |\n
      \  | NFS4ERR_BADOWNER         | CREATE, OPEN, SETATTR                  |\n   |
      \                         |                                        |\n   | NFS4ERR_BADTYPE
      \         | CREATE                                 |\n   |                          |
      \                                       |\n   | NFS4ERR_BADXDR           | ACCESS,
      CB_GETATTR, CB_ILLEGAL,        |\n   |                          | CB_RECALL,
      CLOSE, COMMIT, CREATE,      |\n   |                          | DELEGPURGE, DELEGRETURN,
      GETATTR,      |\n   |                          | ILLEGAL, LINK, LOCK, LOCKT,
      LOCKU,     |\n   |                          | LOOKUP, NVERIFY, OPEN, OPENATTR,
      \      |\n   |                          | OPEN_CONFIRM, OPEN_DOWNGRADE, PUTFH,
      \  |\n   |                          | READ, READDIR, RELEASE_LOCKOWNER,      |\n
      \  |                          | REMOVE, RENAME, RENEW, SECINFO,        |\n   |
      \                         | SETATTR, SETCLIENTID,                  |\n   |                          |
      SETCLIENTID_CONFIRM, VERIFY, WRITE     |\n   |                          |                                        |\n
      \  | NFS4ERR_BAD_COOKIE       | READDIR                                |\n   |
      \                         |                                        |\n   | NFS4ERR_BAD_RANGE
      \       | LOCK, LOCKT, LOCKU                     |\n   |                          |
      \                                       |\n   | NFS4ERR_BAD_SEQID        | CLOSE,
      LOCK, LOCKU, OPEN,              |\n   |                          | OPEN_CONFIRM,
      OPEN_DOWNGRADE           |\n   |                          |                                        |\n
      \  | NFS4ERR_BAD_STATEID      | CB_RECALL, CLOSE, DELEGRETURN, LOCK,   |\n   |
      \                         | LOCKU, OPEN, OPEN_CONFIRM,             |\n   |                          |
      OPEN_DOWNGRADE, READ, SETATTR, WRITE   |\n   |                          |                                        |\n
      \  | NFS4ERR_CB_PATH_DOWN     | RENEW                                  |\n   |
      \                         |                                        |\n   | NFS4ERR_CLID_INUSE
      \      | SETCLIENTID, SETCLIENTID_CONFIRM       |\n   |                          |
      \                                       |\n   | NFS4ERR_DEADLOCK         | LOCK
      \                                  |\n   |                          |                                        |\n
      \  | NFS4ERR_DELAY            | ACCESS, CB_GETATTR, CB_RECALL, CLOSE,  |\n   |
      \                         | COMMIT, CREATE, DELEGPURGE,            |\n   |                          |
      DELEGRETURN, GETATTR, LINK, LOCK,      |\n   |                          | LOCKT,
      LOCKU, LOOKUP, LOOKUPP,         |\n   |                          | NVERIFY,
      OPEN, OPENATTR,               |\n   |                          | OPEN_DOWNGRADE,
      PUTFH, PUTPUBFH,       |\n   |                          | PUTROOTFH, READ, READDIR,
      READLINK,    |\n   |                          | REMOVE, RENAME, SECINFO, SETATTR,
      \     |\n   |                          | SETCLIENTID, SETCLIENTID_CONFIRM,      |\n
      \  |                          | VERIFY, WRITE                          |\n   |
      \                         |                                        |\n   | NFS4ERR_DENIED
      \          | LOCK, LOCKT                            |\n   |                          |
      \                                       |\n   | NFS4ERR_DQUOT            | CREATE,
      LINK, OPEN, OPENATTR, RENAME,  |\n   |                          | SETATTR, WRITE
      \                        |\n   |                          |                                        |\n
      \  | NFS4ERR_EXIST            | CREATE, LINK, OPEN, RENAME             |\n   |
      \                         |                                        |\n   | NFS4ERR_EXPIRED
      \         | CLOSE, DELEGRETURN, LOCK, LOCKT,       |\n   |                          |
      LOCKU, OPEN, OPEN_CONFIRM,             |\n   |                          | OPEN_DOWNGRADE,
      READ,                  |\n   |                          | RELEASE_LOCKOWNER,
      RENEW, SETATTR,     |\n   |                          | WRITE                                  |\n
      \  |                          |                                        |\n   |
      NFS4ERR_FBIG             | OPEN, SETATTR, WRITE                   |\n   |                          |
      \                                       |\n   | NFS4ERR_FHEXPIRED        | ACCESS,
      CLOSE, COMMIT, CREATE,         |\n   |                          | GETATTR, GETFH,
      LINK, LOCK, LOCKT,     |\n   |                          | LOCKU, LOOKUP, LOOKUPP,
      NVERIFY, OPEN, |\n   |                          | OPENATTR, OPEN_CONFIRM,                |\n
      \  |                          | OPEN_DOWNGRADE, PUTFH, READ, READDIR,  |\n   |
      \                         | READLINK, REMOVE, RENAME, RESTOREFH,   |\n   |                          |
      SAVEFH, SECINFO, SETATTR, VERIFY,      |\n   |                          | WRITE
      \                                 |\n   |                          |                                        |\n
      \  | NFS4ERR_FILE_OPEN        | LINK, REMOVE, RENAME                   |\n   |
      \                         |                                        |\n   | NFS4ERR_GRACE
      \           | GETATTR, LOCK, LOCKT, LOCKU, NVERIFY,  |\n   |                          |
      OPEN, READ, REMOVE, RENAME, SETATTR,   |\n   |                          | VERIFY,
      WRITE                          |\n   |                          |                                        |\n
      \  | NFS4ERR_INVAL            | ACCESS, CB_GETATTR, CLOSE, COMMIT,     |\n   |
      \                         | CREATE, DELEGRETURN, GETATTR, LINK,    |\n   |                          |
      LOCK, LOCKT, LOCKU, LOOKUP, NVERIFY,   |\n   |                          | OPEN,
      OPEN_CONFIRM, OPEN_DOWNGRADE,    |\n   |                          | READ, READDIR,
      READLINK, REMOVE,       |\n   |                          | RENAME, SECINFO,
      SETATTR, SETCLIENTID, |\n   |                          | VERIFY, WRITE                          |\n
      \  |                          |                                        |\n   |
      NFS4ERR_IO               | ACCESS, COMMIT, CREATE, GETATTR, LINK, |\n   |                          |
      LOOKUP, LOOKUPP, NVERIFY, OPEN,        |\n   |                          | OPENATTR,
      READ, READDIR, READLINK,     |\n   |                          | REMOVE, RENAME,
      SETATTR, VERIFY, WRITE |\n   |                          |                                        |\n
      \  | NFS4ERR_ISDIR            | CLOSE, COMMIT, LINK, LOCK, LOCKT,      |\n   |
      \                         | LOCKU, OPEN, OPEN_CONFIRM, READ,       |\n   |                          |
      READLINK, SETATTR, WRITE               |\n   |                          |                                        |\n
      \  | NFS4ERR_LEASE_MOVED      | CLOSE, DELEGPURGE, DELEGRETURN, LOCK,  |\n   |
      \                         | LOCKT, LOCKU, OPEN_CONFIRM,            |\n   |                          |
      OPEN_DOWNGRADE, READ,                  |\n   |                          | RELEASE_LOCKOWNER,
      RENEW, SETATTR,     |\n   |                          | WRITE                                  |\n
      \  |                          |                                        |\n   |
      NFS4ERR_LOCKED           | READ, SETATTR, WRITE                   |\n   |                          |
      \                                       |\n   | NFS4ERR_LOCKS_HELD       | CLOSE,
      OPEN_DOWNGRADE,                 |\n   |                          | RELEASE_LOCKOWNER
      \                     |\n   |                          |                                        |\n
      \  | NFS4ERR_LOCK_NOTSUPP     | LOCK                                   |\n   |
      \                         |                                        |\n   | NFS4ERR_LOCK_RANGE
      \      | LOCK, LOCKT, LOCKU                     |\n   |                          |
      \                                       |\n   | NFS4ERR_MLINK            | LINK
      \                                  |\n   |                          |                                        |\n
      \  | NFS4ERR_MOVED            | ACCESS, CLOSE, COMMIT, CREATE,         |\n   |
      \                         | DELEGRETURN, GETATTR, GETFH, LINK,     |\n   |                          |
      LOCK, LOCKT, LOCKU, LOOKUP, LOOKUPP,   |\n   |                          | NVERIFY,
      OPEN, OPENATTR, OPEN_CONFIRM, |\n   |                          | OPEN_DOWNGRADE,
      PUTFH, READ, READDIR,  |\n   |                          | READLINK, REMOVE,
      RENAME, RESTOREFH,   |\n   |                          | SAVEFH, SECINFO, SETATTR,
      VERIFY,      |\n   |                          | WRITE                                  |\n
      \  |                          |                                        |\n   |
      NFS4ERR_NAMETOOLONG      | CREATE, LINK, LOOKUP, OPEN, REMOVE,    |\n   |                          |
      RENAME, SECINFO                        |\n   |                          |                                        |\n
      \  | NFS4ERR_NOENT            | LINK, LOOKUP, LOOKUPP, OPEN, OPENATTR, |\n   |
      \                         | REMOVE, RENAME, SECINFO                |\n   |                          |
      \                                       |\n   | NFS4ERR_NOFILEHANDLE     | ACCESS,
      CLOSE, COMMIT, CREATE,         |\n   |                          | DELEGRETURN,
      GETATTR, GETFH, LINK,     |\n   |                          | LOCK, LOCKT, LOCKU,
      LOOKUP, LOOKUPP,   |\n   |                          | NVERIFY, OPEN, OPENATTR,
      OPEN_CONFIRM, |\n   |                          | OPEN_DOWNGRADE, READ, READDIR,
      \        |\n   |                          | READLINK, REMOVE, RENAME, SAVEFH,
      \     |\n   |                          | SECINFO, SETATTR, VERIFY, WRITE        |\n
      \  |                          |                                        |\n   |
      NFS4ERR_NOSPC            | CREATE, LINK, OPEN, OPENATTR, RENAME,  |\n   |                          |
      SETATTR, WRITE                         |\n   |                          |                                        |\n
      \  | NFS4ERR_NOTDIR           | CREATE, LINK, LOOKUP, LOOKUPP, OPEN,   |\n   |
      \                         | READDIR, REMOVE, RENAME, SECINFO       |\n   |                          |
      \                                       |\n   | NFS4ERR_NOTEMPTY         | REMOVE,
      RENAME                         |\n   |                          |                                        |\n
      \  | NFS4ERR_NOTSUPP          | DELEGPURGE, DELEGRETURN, LINK, OPEN,   |\n   |
      \                         | OPENATTR, READLINK                     |\n   |                          |
      \                                       |\n   | NFS4ERR_NOT_SAME         | READDIR,
      VERIFY                        |\n   |                          |                                        |\n
      \  | NFS4ERR_NO_GRACE         | LOCK, OPEN                             |\n   |
      \                         |                                        |\n   | NFS4ERR_NXIO
      \            | WRITE                                  |\n   |                          |
      \                                       |\n   | NFS4ERR_OLD_STATEID      | CLOSE,
      DELEGRETURN, LOCK, LOCKU, OPEN, |\n   |                          | OPEN_CONFIRM,
      OPEN_DOWNGRADE, READ,    |\n   |                          | SETATTR, WRITE                         |\n
      \  |                          |                                        |\n   |
      NFS4ERR_OPENMODE         | LOCK, READ, SETATTR, WRITE             |\n   |                          |
      \                                       |\n   | NFS4ERR_OP_ILLEGAL       | CB_ILLEGAL,
      ILLEGAL                    |\n   |                          |                                        |\n
      \  | NFS4ERR_PERM             | CREATE, OPEN, SETATTR                  |\n   |
      \                         |                                        |\n   | NFS4ERR_RECLAIM_BAD
      \     | LOCK, OPEN                             |\n   |                          |
      \                                       |\n   | NFS4ERR_RECLAIM_CONFLICT | LOCK,
      OPEN                             |\n   |                          |                                        |\n
      \  | NFS4ERR_RESOURCE         | ACCESS, CLOSE, COMMIT, CREATE,         |\n   |
      \                         | DELEGPURGE, DELEGRETURN, GETATTR,      |\n   |                          |
      GETFH, LINK, LOCK, LOCKT, LOCKU,       |\n   |                          | LOOKUP,
      LOOKUPP, OPEN, OPENATTR,       |\n   |                          | OPEN_CONFIRM,
      OPEN_DOWNGRADE, READ,    |\n   |                          | READDIR, READLINK,
      RELEASE_LOCKOWNER,  |\n   |                          | REMOVE, RENAME, RENEW,
      RESTOREFH,      |\n   |                          | SAVEFH, SECINFO, SETATTR,
      SETCLIENTID, |\n   |                          | SETCLIENTID_CONFIRM, VERIFY,
      WRITE     |\n   |                          |                                        |\n
      \  | NFS4ERR_RESTOREFH        | RESTOREFH                              |\n   |
      \                         |                                        |\n   | NFS4ERR_ROFS
      \            | COMMIT, CREATE, LINK, OPEN, OPENATTR,  |\n   |                          |
      OPEN_DOWNGRADE, REMOVE, RENAME,        |\n   |                          | SETATTR,
      WRITE                         |\n   |                          |                                        |\n
      \  | NFS4ERR_SAME             | NVERIFY                                |\n   |
      \                         |                                        |\n   | NFS4ERR_SERVERFAULT
      \     | ACCESS, CB_GETATTR, CB_RECALL, CLOSE,  |\n   |                          |
      COMMIT, CREATE, DELEGPURGE,            |\n   |                          | DELEGRETURN,
      GETATTR, GETFH, LINK,     |\n   |                          | LOCK, LOCKT, LOCKU,
      LOOKUP, LOOKUPP,   |\n   |                          | NVERIFY, OPEN, OPENATTR,
      OPEN_CONFIRM, |\n   |                          | OPEN_DOWNGRADE, PUTFH, PUTPUBFH,
      \      |\n   |                          | PUTROOTFH, READ, READDIR, READLINK,
      \   |\n   |                          | RELEASE_LOCKOWNER, REMOVE, RENAME,     |\n
      \  |                          | RENEW, RESTOREFH, SAVEFH, SECINFO,     |\n   |
      \                         | SETATTR, SETCLIENTID,                  |\n   |                          |
      SETCLIENTID_CONFIRM, VERIFY, WRITE     |\n   |                          |                                        |\n
      \  | NFS4ERR_SHARE_DENIED     | OPEN                                   |\n   |
      \                         |                                        |\n   | NFS4ERR_STALE
      \           | ACCESS, CLOSE, COMMIT, CREATE,         |\n   |                          |
      DELEGRETURN, GETATTR, GETFH, LINK,     |\n   |                          | LOCK,
      LOCKT, LOCKU, LOOKUP, LOOKUPP,   |\n   |                          | NVERIFY,
      OPEN, OPENATTR, OPEN_CONFIRM, |\n   |                          | OPEN_DOWNGRADE,
      PUTFH, READ, READDIR,  |\n   |                          | READLINK, REMOVE,
      RENAME, RESTOREFH,   |\n   |                          | SAVEFH, SECINFO, SETATTR,
      VERIFY,      |\n   |                          | WRITE                                  |\n
      \  |                          |                                        |\n   |
      NFS4ERR_STALE_CLIENTID   | DELEGPURGE, LOCK, LOCKT, OPEN,         |\n   |                          |
      RELEASE_LOCKOWNER, RENEW,              |\n   |                          | SETCLIENTID_CONFIRM
      \                   |\n   |                          |                                        |\n
      \  | NFS4ERR_STALE_STATEID    | CLOSE, DELEGRETURN, LOCK, LOCKU,       |\n   |
      \                         | OPEN_CONFIRM, OPEN_DOWNGRADE, READ,    |\n   |                          |
      SETATTR, WRITE                         |\n   |                          |                                        |\n
      \  | NFS4ERR_SYMLINK          | COMMIT, LOOKUP, LOOKUPP, OPEN, READ,   |\n   |
      \                         | WRITE                                  |\n   |                          |
      \                                       |\n   | NFS4ERR_TOOSMALL         | READDIR
      \                               |\n   |                          |                                        |\n
      \  | NFS4ERR_WRONGSEC         | LINK, LOOKUP, LOOKUPP, OPEN, PUTFH,    |\n   |
      \                         | PUTPUBFH, PUTROOTFH, RENAME, RESTOREFH |\n   |                          |
      \                                       |\n   | NFS4ERR_XDEV             | LINK,
      RENAME                           |\n   |                          |                                        |\n
      \  +--------------------------+----------------------------------------+\n             Table
      9: Errors and the Operations That Use Them\n"
    title: 13.4.  Errors and the Operations That Use Them
  title: 13.  Error Values
- contents:
  - "14.  NFSv4 Requests\n   For the NFSv4 RPC program, there are two traditional
    RPC procedures:\n   NULL and COMPOUND.  All other functionality is defined as
    a set of\n   operations, and these operations are defined in normal XDR/RPC syntax\n
    \  and semantics.  However, these operations are encapsulated within the\n   COMPOUND
    procedure.  This requires that the client combine one or\n   more of the NFSv4
    operations into a single request.\n   The NFS4_CALLBACK program is used to provide
    server-to-client\n   signaling and is constructed in a fashion similar to the
    NFSv4\n   program.  The procedures CB_NULL and CB_COMPOUND are defined in the\n
    \  same way as NULL and COMPOUND are within the NFS program.  The\n   CB_COMPOUND
    request also encapsulates the remaining operations of the\n   NFS4_CALLBACK program.
    \ There is no predefined RPC program number for\n   the NFS4_CALLBACK program.
    \ It is up to the client to specify a\n   program number in the \"transient\"
    program range.  The program and\n   port numbers of the NFS4_CALLBACK program
    are provided by the client\n   as part of the SETCLIENTID/SETCLIENTID_CONFIRM
    sequence.  The program\n   and port can be changed by another SETCLIENTID/SETCLIENTID_CONFIRM\n
    \  sequence, and it is possible to use the sequence to change them\n   within
    a client incarnation without removing relevant leased client\n   state.\n"
  - contents:
    - "14.1.  COMPOUND Procedure\n   The COMPOUND procedure provides the opportunity
      for better\n   performance within high-latency networks.  The client can avoid\n
      \  cumulative latency of multiple RPCs by combining multiple dependent\n   operations
      into a single COMPOUND procedure.  A COMPOUND operation\n   may provide for
      protocol simplification by allowing the client to\n   combine basic procedures
      into a single request that is customized for\n   the client's environment.\n
      \  The CB_COMPOUND procedure precisely parallels the features of\n   COMPOUND
      as described above.\n   The basic structure of the COMPOUND procedure is:\n
      \  +-----+--------------+--------+-----------+-----------+-----------+--\n   |
      tag | minorversion | numops | op + args | op + args | op + args |\n   +-----+--------------+--------+-----------+-----------+-----------+--\n
      \  and the reply's structure is:\n     +------------+-----+--------+-----------------------+--\n
      \    |last status | tag | numres | status + op + results |\n     +------------+-----+--------+-----------------------+--\n
      \  The numops and numres fields, used in the depiction above, represent\n   the
      count for the counted array encoding used to signify the number\n   of arguments
      or results encoded in the request and response.  As per\n   the XDR encoding,
      these counts must match exactly the number of\n   operation arguments or results
      encoded.\n"
    title: 14.1.  COMPOUND Procedure
  - contents:
    - "14.2.  Evaluation of a COMPOUND Request\n   The server will process the COMPOUND
      procedure by evaluating each of\n   the operations within the COMPOUND procedure
      in order.  Each\n   component operation consists of a 32-bit operation code,
      followed by\n   the argument of length determined by the type of operation.
      \ The\n   results of each operation are encoded in sequence into a reply\n   buffer.
      \ The results of each operation are preceded by the opcode and\n   a status
      code (normally zero).  If an operation results in a non-zero\n   status code,
      the status will be encoded, evaluation of the COMPOUND\n   sequence will halt,
      and the reply will be returned.  Note that\n   evaluation stops even in the
      event of \"non-error\" conditions such as\n   NFS4ERR_SAME.\n   There are no
      atomicity requirements for the operations contained\n   within the COMPOUND
      procedure.  The operations being evaluated as\n   part of a COMPOUND request
      may be evaluated simultaneously with other\n   COMPOUND requests that the server
      receives.\n   A COMPOUND is not a transaction, and it is the client's\n   responsibility
      to recover from any partially completed COMPOUND\n   procedure.  These may occur
      at any point due to errors such as\n   NFS4ERR_RESOURCE and NFS4ERR_DELAY.  Note
      that these errors can occur\n   in an otherwise valid operation string.  Further,
      a server reboot\n   that occurs in the middle of processing a COMPOUND procedure
      may\n   leave the client with the difficult task of determining how far\n   COMPOUND
      processing has proceeded.  Therefore, the client should\n   avoid overly complex
      COMPOUND procedures in the event of the failure\n   of an operation within the
      procedure.\n   Each operation assumes a current filehandle and a saved filehandle\n
      \  that are available as part of the execution context of the COMPOUND\n   request.
      \ Operations may set, change, or return the current\n   filehandle.  The saved
      filehandle is used for temporary storage of a\n   filehandle value and as operands
      for the RENAME and LINK operations.\n"
    title: 14.2.  Evaluation of a COMPOUND Request
  - contents:
    - "14.3.  Synchronous Modifying Operations\n   NFSv4 operations that modify the
      file system are synchronous.  When\n   an operation is successfully completed
      at the server, the client can\n   trust that any data associated with the request
      is now in stable\n   storage (the one exception is in the case of the file data
      in a WRITE\n   operation with the UNSTABLE4 option specified).\n   This implies
      that any previous operations within the same COMPOUND\n   request are also reflected
      in stable storage.  This behavior enables\n   the client's ability to recover
      from a partially executed COMPOUND\n   request that may have resulted from the
      failure of the server.  For\n   example, if a COMPOUND request contains operations
      A and B and the\n   server is unable to send a response to the client, then
      depending on\n   the progress the server made in servicing the request, the
      result of\n   both operations may be reflected in stable storage or just\n   operation
      A may be reflected.  The server must not have just the\n   results of operation
      B in stable storage.\n"
    title: 14.3.  Synchronous Modifying Operations
  - contents:
    - "14.4.  Operation Values\n   The operations encoded in the COMPOUND procedure
      are identified by\n   operation values.  To avoid overlap with the RPC procedure
      numbers,\n   operations 0 (zero) and 1 are not defined.  Operation 2 is not\n
      \  defined but is reserved for future use with minor versioning.\n"
    title: 14.4.  Operation Values
  title: 14.  NFSv4 Requests
- contents:
  - '15.  NFSv4 Procedures

    '
  - contents:
    - '15.1.  Procedure 0: NULL - No Operation

      '
    - contents:
      - "15.1.1.  SYNOPSIS\n     <null>\n"
      title: 15.1.1.  SYNOPSIS
    - contents:
      - "15.1.2.  ARGUMENT\n     void;\n"
      title: 15.1.2.  ARGUMENT
    - contents:
      - "15.1.3.  RESULT\n     void;\n"
      title: 15.1.3.  RESULT
    - contents:
      - "15.1.4.  DESCRIPTION\n   Standard NULL procedure.  Void argument, void response.
        \ This\n   procedure has no functionality associated with it.  Because of
        this,\n   it is sometimes used to measure the overhead of processing a service\n
        \  request.  Therefore, the server should ensure that no unnecessary\n   work
        is done in servicing this procedure.\n"
      title: 15.1.4.  DESCRIPTION
    title: '15.1.  Procedure 0: NULL - No Operation'
  - contents:
    - '15.2.  Procedure 1: COMPOUND - COMPOUND Operations

      '
    - contents:
      - "15.2.1.  SYNOPSIS\n     compoundargs -> compoundres\n"
      title: 15.2.1.  SYNOPSIS
    - contents:
      - "15.2.2.  ARGUMENT\n     union nfs_argop4 switch (nfs_opnum4 argop) {\n             case
        <OPCODE>: <argument>;\n             ...\n     };\n   struct COMPOUND4args
        {\n           utf8str_cs      tag;\n           uint32_t        minorversion;\n
        \          nfs_argop4      argarray<>;\n   };\n"
      title: 15.2.2.  ARGUMENT
    - contents:
      - "15.2.3.  RESULT\n     union nfs_resop4 switch (nfs_opnum4 resop) {\n             case
        <OPCODE>: <argument>;\n             ...\n     };\n   struct COMPOUND4res {\n
        \          nfsstat4        status;\n           utf8str_cs      tag;\n           nfs_resop4
        \     resarray<>;\n   };\n"
      title: 15.2.3.  RESULT
    - contents:
      - "15.2.4.  DESCRIPTION\n   The COMPOUND procedure is used to combine one or
        more of the NFS\n   operations into a single RPC request.  The main NFS RPC
        program has\n   two main procedures: NULL and COMPOUND.  All other operations
        use the\n   COMPOUND procedure as a wrapper.\n   The COMPOUND procedure is
        used to combine individual operations into\n   a single RPC request.  The
        server interprets each of the operations\n   in turn.  If an operation is
        executed by the server and the status of\n   that operation is NFS4_OK, then
        the next operation in the COMPOUND\n   procedure is executed.  The server
        continues this process until there\n   are no more operations to be executed
        or one of the operations has a\n   status value other than NFS4_OK.\n   In
        the processing of the COMPOUND procedure, the server may find that\n   it
        does not have the available resources to execute any or all of the\n   operations
        within the COMPOUND sequence.  In this case, the error\n   NFS4ERR_RESOURCE
        will be returned for the particular operation within\n   the COMPOUND procedure
        where the resource exhaustion occurred.  This\n   assumes that all previous
        operations within the COMPOUND sequence\n   have been evaluated successfully.
        \ The results for all of the\n   evaluated operations must be returned to
        the client.\n   The server will generally choose between two methods of decoding
        the\n   client's request.  The first would be the traditional one-pass XDR\n
        \  decode, in which decoding of the entire COMPOUND precedes execution\n   of
        any operation within it.  If there is an XDR decoding error in\n   this case,
        an RPC XDR decode error would be returned.  The second\n   method would be
        to make an initial pass to decode the basic COMPOUND\n   request and then
        to XDR decode each of the individual operations, as\n   the server is ready
        to execute it.  In this case, the server may\n   encounter an XDR decode error
        during such an operation decode, after\n   previous operations within the
        COMPOUND have been executed.  In this\n   case, the server would return the
        error NFS4ERR_BADXDR to signify the\n   decode error.\n   The COMPOUND arguments
        contain a minorversion field.  The initial and\n   default value for this
        field is 0 (zero).  This field will be used by\n   future minor versions such
        that the client can communicate to the\n   server what minor version is being
        requested.  If the server receives\n   a COMPOUND procedure with a minorversion
        field value that it does not\n   support, the server MUST return an error
        of\n   NFS4ERR_MINOR_VERS_MISMATCH and a zero-length resultdata array.\n   Contained
        within the COMPOUND results is a status field.  If the\n   results array length
        is non-zero, this status must be equivalent to\n   the status of the last
        operation that was executed within the\n   COMPOUND procedure.  Therefore,
        if an operation incurred an error,\n   then the status value will be the same
        error value as is being\n   returned for the operation that failed.\n   Note
        that operations 0 (zero), 1 (one), and 2 (two) are not defined\n   for the
        COMPOUND procedure.  It is possible that the server receives\n   a request
        that contains an operation that is less than the first\n   legal operation
        (OP_ACCESS) or greater than the last legal operation\n   (OP_RELEASE_LOCKOWNER).
        \ In this case, the server's response will\n   encode the opcode OP_ILLEGAL
        rather than the illegal opcode of the\n   request.  The status field in the
        ILLEGAL return results will be set\n   to NFS4ERR_OP_ILLEGAL.  The COMPOUND
        procedure's return results will\n   also be NFS4ERR_OP_ILLEGAL.\n   The definition
        of the \"tag\" in the request is left to the\n   implementer.  It may be used
        to summarize the content of the COMPOUND\n   request for the benefit of packet
        sniffers and engineers debugging\n   implementations.  However, the value
        of \"tag\" in the response SHOULD\n   be the same value as the value provided
        in the request.  This applies\n   to the tag field of the CB_COMPOUND procedure
        as well.\n"
      - contents:
        - "15.2.4.1.  Current Filehandle\n   The current filehandle and the saved
          filehandle are used throughout\n   the protocol.  Most operations implicitly
          use the current filehandle\n   as an argument, and many set the current
          filehandle as part of the\n   results.  The combination of client-specified
          sequences of operations\n   and current and saved filehandle arguments and
          results allows for\n   greater protocol flexibility.  The best or easiest
          example of current\n   filehandle usage is a sequence like the following:\n
          \                       PUTFH fh1              {fh1}\n                        LOOKUP
          \"compA\"         {fh2}\n                        GETATTR                {fh2}\n
          \                       LOOKUP \"compB\"         {fh3}\n                        GETATTR
          \               {fh3}\n                        LOOKUP \"compC\"         {fh4}\n
          \                       GETATTR                {fh4}\n                        GETFH\n
          \                   Figure 1: Filehandle Usage Example\n   In this example,
          the PUTFH (Section 16.20) operation explicitly sets\n   the current filehandle
          value, while the result of each LOOKUP\n   operation sets the current filehandle
          value to the resultant file\n   system object.  Also, the client is able
          to insert GETATTR operations\n   using the current filehandle as an argument.\n
          \  The PUTROOTFH (Section 16.22) and PUTPUBFH (Section 16.21) operations\n
          \  also set the current filehandle.  The above example would replace\n   \"PUTFH
          fh1\" with PUTROOTFH or PUTPUBFH with no filehandle argument in\n   order
          to achieve the same effect (on the assumption that \"compA\" is\n   directly
          below the root of the namespace).\n   Along with the current filehandle,
          there is a saved filehandle.\n   While the current filehandle is set as
          the result of operations like\n   LOOKUP, the saved filehandle must be set
          directly with the use of the\n   SAVEFH operation.  The SAVEFH operation
          copies the current filehandle\n   value to the saved value.  The saved filehandle
          value is used in\n   combination with the current filehandle value for the
          LINK and RENAME\n   operations.  The RESTOREFH operation will copy the saved
          filehandle\n   value to the current filehandle value; as a result, the saved\n
          \  filehandle value may be used as a sort of \"scratch\" area for the\n
          \  client's series of operations.\n"
        title: 15.2.4.1.  Current Filehandle
      title: 15.2.4.  DESCRIPTION
    - contents:
      - "15.2.5.  IMPLEMENTATION\n   Since an error of any type may occur after only
        a portion of the\n   operations have been evaluated, the client must be prepared
        to\n   recover from any failure.  If the source of an NFS4ERR_RESOURCE error\n
        \  was a complex or lengthy set of operations, it is likely that if the\n
        \  number of operations were reduced the server would be able to\n   evaluate
        them successfully.  Therefore, the client is responsible for\n   dealing with
        this type of complexity in recovery.\n   A single compound should not contain
        multiple operations that have\n   different values for the clientid field
        used in OPEN, LOCK, or RENEW.\n   This can cause confusion in cases in which
        operations that do not\n   contain clientids have potential interactions with
        operations that\n   do.  When only a single clientid has been used, it is
        clear what\n   client is being referenced.  For a particular example involving
        the\n   interaction of OPEN and GETATTR, see Section 16.16.6.\n"
      title: 15.2.5.  IMPLEMENTATION
    title: '15.2.  Procedure 1: COMPOUND - COMPOUND Operations'
  title: 15.  NFSv4 Procedures
- contents:
  - '16.  NFSv4 Operations

    '
  - contents:
    - '16.1.  Operation 3: ACCESS - Check Access Rights

      '
    - contents:
      - "16.1.1.  SYNOPSIS\n     (cfh), accessreq -> supported, accessrights\n"
      title: 16.1.1.  SYNOPSIS
    - contents:
      - "16.1.2.  ARGUMENT\n   const ACCESS4_READ      = 0x00000001;\n   const ACCESS4_LOOKUP
        \   = 0x00000002;\n   const ACCESS4_MODIFY    = 0x00000004;\n   const ACCESS4_EXTEND
        \   = 0x00000008;\n   const ACCESS4_DELETE    = 0x00000010;\n   const ACCESS4_EXECUTE
        \  = 0x00000020;\n   struct ACCESS4args {\n           /* CURRENT_FH: object
        */\n           uint32_t        access;\n   };\n"
      title: 16.1.2.  ARGUMENT
    - contents:
      - "16.1.3.  RESULT\n   struct ACCESS4resok {\n           uint32_t        supported;\n
        \          uint32_t        access;\n   };\n   union ACCESS4res switch (nfsstat4
        status) {\n    case NFS4_OK:\n            ACCESS4resok   resok4;\n    default:\n
        \           void;\n   };\n"
      title: 16.1.3.  RESULT
    - contents:
      - "16.1.4.  DESCRIPTION\n   ACCESS determines the access rights that a user,
        as identified by the\n   credentials in the RPC request, has with respect
        to the file system\n   object specified by the current filehandle.  The client
        encodes the\n   set of access rights that are to be checked in the bitmask
        \"access\".\n   The server checks the permissions encoded in the bitmask.
        \ If a\n   status of NFS4_OK is returned, two bitmasks are included in the\n
        \  response.  The first, \"supported\", represents the access rights for\n
        \  which the server can verify reliably.  The second, \"access\",\n   represents
        the access rights available to the user for the filehandle\n   provided.  On
        success, the current filehandle retains its value.\n   Note that the supported
        field will contain only as many values as\n   were originally sent in the
        arguments.  For example, if the client\n   sends an ACCESS operation with
        only the ACCESS4_READ value set and\n   the server supports this value, the
        server will return only\n   ACCESS4_READ even if it could have reliably checked
        other values.\n   The results of this operation are necessarily advisory in
        nature.  A\n   return status of NFS4_OK and the appropriate bit set in the
        bitmask\n   do not imply that such access will be allowed to the file system\n
        \  object in the future.  This is because access rights can be revoked\n   by
        the server at any time.\n   The following access permissions may be requested:\n
        \  ACCESS4_READ:  Read data from file or read a directory.\n   ACCESS4_LOOKUP:
        \ Look up a name in a directory (no meaning for\n      non-directory objects).\n
        \  ACCESS4_MODIFY:  Rewrite existing file data or modify existing\n      directory
        entries.\n   ACCESS4_EXTEND:  Write new data or add directory entries.\n   ACCESS4_DELETE:
        \ Delete an existing directory entry.\n   ACCESS4_EXECUTE:  Execute file (no
        meaning for a directory).\n   On success, the current filehandle retains its
        value.\n"
      title: 16.1.4.  DESCRIPTION
    - contents:
      - "16.1.5.  IMPLEMENTATION\n   In general, it is not sufficient for the client
        to attempt to deduce\n   access permissions by inspecting the uid, gid, and
        mode fields in the\n   file attributes or by attempting to interpret the contents
        of the ACL\n   attribute.  This is because the server may perform uid or gid
        mapping\n   or enforce additional access control restrictions.  It is also\n
        \  possible that the server may not be in the same ID space as the\n   client.
        \ In these cases (and perhaps others), the client cannot\n   reliably perform
        an access check with only current file attributes.\n   In the NFSv2 protocol,
        the only reliable way to determine whether an\n   operation was allowed was
        to try it and see if it succeeded or\n   failed.  Using the ACCESS operation
        in the NFSv4 protocol, the client\n   can ask the server to indicate whether
        or not one or more classes of\n   operations are permitted.  The ACCESS operation
        is provided to allow\n   clients to check before doing a series of operations
        that might\n   result in an access failure.  The OPEN operation provides a
        point\n   where the server can verify access to the file object and the method\n
        \  to return that information to the client.  The ACCESS operation is\n   still
        useful for directory operations or for use in the case where\n   the UNIX
        API \"access\" is used on the client.\n   The information returned by the
        server in response to an ACCESS call\n   is not permanent.  It was correct
        at the exact time that the server\n   performed the checks, but not necessarily
        afterward.  The server can\n   revoke access permission at any time.\n   The
        client should use the effective credentials of the user to build\n   the authentication
        information in the ACCESS request used to\n   determine access rights.  It
        is the effective user and group\n   credentials that are used in subsequent
        READ and WRITE operations.\n   Many implementations do not directly support
        the ACCESS4_DELETE\n   permission.  Operating systems like UNIX will ignore
        the\n   ACCESS4_DELETE bit if set on an access request on a non-directory\n
        \  object.  In these systems, delete permission on a file is determined\n
        \  by the access permissions on the directory in which the file resides,\n
        \  instead of being determined by the permissions of the file itself.\n   Therefore,
        the mask returned enumerating which access rights can be\n   supported will
        have the ACCESS4_DELETE value set to 0.  This\n   indicates to the client
        that the server was unable to check that\n   particular access right.  The
        ACCESS4_DELETE bit in the access mask\n   returned will then be ignored by
        the client.\n"
      title: 16.1.5.  IMPLEMENTATION
    title: '16.1.  Operation 3: ACCESS - Check Access Rights'
  - contents:
    - '16.2.  Operation 4: CLOSE - Close File

      '
    - contents:
      - "16.2.1.  SYNOPSIS\n     (cfh), seqid, open_stateid -> open_stateid\n"
      title: 16.2.1.  SYNOPSIS
    - contents:
      - "16.2.2.  ARGUMENT\n   struct CLOSE4args {\n           /* CURRENT_FH: object
        */\n           seqid4          seqid;\n           stateid4        open_stateid;\n
        \  };\n"
      title: 16.2.2.  ARGUMENT
    - contents:
      - "16.2.3.  RESULT\n   union CLOSE4res switch (nfsstat4 status) {\n    case
        NFS4_OK:\n            stateid4       open_stateid;\n    default:\n            void;\n
        \  };\n"
      title: 16.2.3.  RESULT
    - contents:
      - "16.2.4.  DESCRIPTION\n   The CLOSE operation releases share reservations
        for the regular or\n   named attribute file as specified by the current filehandle.
        \ The\n   share reservations and other state information released at the server\n
        \  as a result of this CLOSE are only associated with the supplied\n   stateid.
        \ The sequence id provides for the correct ordering.  State\n   associated
        with other OPENs is not affected.\n   If byte-range locks are held, the client
        SHOULD release all locks\n   before issuing a CLOSE.  The server MAY free
        all outstanding locks on\n   CLOSE, but some servers may not support the CLOSE
        of a file that\n   still has byte-range locks held.  The server MUST return
        failure if\n   any locks would exist after the CLOSE.\n   On success, the
        current filehandle retains its value.\n"
      title: 16.2.4.  DESCRIPTION
    - contents:
      - "16.2.5.  IMPLEMENTATION\n   Even though CLOSE returns a stateid, this stateid
        is not useful to\n   the client and should be treated as deprecated.  CLOSE
        \"shuts down\"\n   the state associated with all OPENs for the file by a single\n
        \  open-owner.  As noted above, CLOSE will either release all file\n   locking
        state or return an error.  Therefore, the stateid returned by\n   CLOSE is
        not useful for the operations that follow.\n"
      title: 16.2.5.  IMPLEMENTATION
    title: '16.2.  Operation 4: CLOSE - Close File'
  - contents:
    - '16.3.  Operation 5: COMMIT - Commit Cached Data

      '
    - contents:
      - "16.3.1.  SYNOPSIS\n     (cfh), offset, count -> verifier\n"
      title: 16.3.1.  SYNOPSIS
    - contents:
      - "16.3.2.  ARGUMENT\n   struct COMMIT4args {\n           /* CURRENT_FH: file
        */\n           offset4         offset;\n           count4          count;\n
        \  };\n"
      title: 16.3.2.  ARGUMENT
    - contents:
      - "16.3.3.  RESULT\n   struct COMMIT4resok {\n           verifier4       writeverf;\n
        \  };\n   union COMMIT4res switch (nfsstat4 status) {\n    case NFS4_OK:\n
        \           COMMIT4resok   resok4;\n    default:\n            void;\n   };\n"
      title: 16.3.3.  RESULT
    - contents:
      - "16.3.4.  DESCRIPTION\n   The COMMIT operation forces or flushes data to stable
        storage for the\n   file specified by the current filehandle.  The flushed
        data is that\n   which was previously written with a WRITE operation that
        had the\n   stable field set to UNSTABLE4.\n   The offset specifies the position
        within the file where the flush is\n   to begin.  An offset value of 0 (zero)
        means to flush data starting\n   at the beginning of the file.  The count
        specifies the number of\n   bytes of data to flush.  If count is 0 (zero),
        a flush from the\n   offset to the end of the file is done.\n   The server
        returns a write verifier upon successful completion of the\n   COMMIT.  The
        write verifier is used by the client to determine if the\n   server has restarted
        or rebooted between the initial WRITE(s) and the\n   COMMIT.  The client does
        this by comparing the write verifier\n   returned from the initial writes
        and the verifier returned by the\n   COMMIT operation.  The server must vary
        the value of the write\n   verifier at each server event or instantiation
        that may lead to a\n   loss of uncommitted data.  Most commonly, this occurs
        when the server\n   is rebooted; however, other events at the server may result
        in\n   uncommitted data loss as well.\n   On success, the current filehandle
        retains its value.\n"
      title: 16.3.4.  DESCRIPTION
    - contents:
      - "16.3.5.  IMPLEMENTATION\n   The COMMIT operation is similar in operation
        and semantics to the\n   POSIX fsync() [fsync] system call that synchronizes
        a file's state\n   with the disk (file data and metadata are flushed to disk
        or stable\n   storage).  COMMIT performs the same operation for a client,
        flushing\n   any unsynchronized data and metadata on the server to the server's\n
        \  disk or stable storage for the specified file.  Like fsync(), it may\n
        \  be that there is some modified data or no modified data to\n   synchronize.
        \ The data may have been synchronized by the server's\n   normal periodic
        buffer synchronization activity.  COMMIT should\n   return NFS4_OK, unless
        there has been an unexpected error.\n   COMMIT differs from fsync() in that
        it is possible for the client to\n   flush a range of the file (most likely
        triggered by a buffer-\n   reclamation scheme on the client before the file
        has been completely\n   written).\n   The server implementation of COMMIT
        is reasonably simple.  If the\n   server receives a full file COMMIT request
        that is starting at offset\n   0 and count 0, it should do the equivalent
        of fsync()'ing the file.\n   Otherwise, it should arrange to have the cached
        data in the range\n   specified by offset and count to be flushed to stable
        storage.  In\n   both cases, any metadata associated with the file must be
        flushed to\n   stable storage before returning.  It is not an error for there
        to be\n   nothing to flush on the server.  This means that the data and\n
        \  metadata that needed to be flushed have already been flushed or lost\n
        \  during the last server failure.\n   The client implementation of COMMIT
        is a little more complex.  There\n   are two reasons for wanting to commit
        a client buffer to stable\n   storage.  The first is that the client wants
        to reuse a buffer.  In\n   this case, the offset and count of the buffer are
        sent to the server\n   in the COMMIT request.  The server then flushes any
        cached data based\n   on the offset and count, and flushes any metadata associated
        with the\n   file.  It then returns the status of the flush and the write\n
        \  verifier.  The other reason for the client to generate a COMMIT is\n   for
        a full file flush, such as may be done at CLOSE.  In this case,\n   the client
        would gather all of the buffers for this file that contain\n   uncommitted
        data, do the COMMIT operation with an offset of 0 and\n   count of 0, and
        then free all of those buffers.  Any other dirty\n   buffers would be sent
        to the server in the normal fashion.\n   After a buffer is written by the
        client with the stable parameter set\n   to UNSTABLE4, the buffer must be
        considered modified by the client\n   until the buffer has been either flushed
        via a COMMIT operation or\n   written via a WRITE operation with the stable
        parameter set to\n   FILE_SYNC4 or DATA_SYNC4.  This is done to prevent the
        buffer from\n   being freed and reused before the data can be flushed to stable\n
        \  storage on the server.\n   When a response is returned from either a WRITE
        or a COMMIT operation\n   and it contains a write verifier that is different
        than previously\n   returned by the server, the client will need to retransmit
        all of the\n   buffers containing uncommitted cached data to the server.  How
        this\n   is to be done is up to the implementer.  If there is only one buffer\n
        \  of interest, then it should probably be sent back over in a WRITE\n   request
        with the appropriate stable parameter.  If there is more than\n   one buffer,
        it might be worthwhile to retransmit all of the buffers\n   in WRITE requests
        with the stable parameter set to UNSTABLE4 and then\n   retransmit the COMMIT
        operation to flush all of the data on the\n   server to stable storage.  The
        timing of these retransmissions is\n   left to the implementer.\n   The above
        description applies to page-cache-based systems as well as\n   buffer-cache-based
        systems.  In those systems, the virtual memory\n   system will need to be
        modified instead of the buffer cache.\n"
      title: 16.3.5.  IMPLEMENTATION
    title: '16.3.  Operation 5: COMMIT - Commit Cached Data'
  - contents:
    - '16.4.  Operation 6: CREATE - Create a Non-regular File Object

      '
    - contents:
      - "16.4.1.  SYNOPSIS\n     (cfh), name, type, attrs -> (cfh), cinfo, attrset\n"
      title: 16.4.1.  SYNOPSIS
    - contents:
      - "16.4.2.  ARGUMENT\n   union createtype4 switch (nfs_ftype4 type) {\n    case
        NF4LNK:\n            linktext4 linkdata;\n    case NF4BLK:\n    case NF4CHR:\n
        \           specdata4 devdata;\n    case NF4SOCK:\n    case NF4FIFO:\n    case
        NF4DIR:\n            void;\n    default:\n            void;  /* server should
        return NFS4ERR_BADTYPE */\n   };\n   struct CREATE4args {\n           /* CURRENT_FH:
        directory for creation */\n           createtype4     objtype;\n           component4
        \     objname;\n           fattr4          createattrs;\n   };\n"
      title: 16.4.2.  ARGUMENT
    - contents:
      - "16.4.3.  RESULT\n   struct CREATE4resok {\n           change_info4    cinfo;\n
        \          bitmap4         attrset;        /* attributes set */\n   };\n   union
        CREATE4res switch (nfsstat4 status) {\n    case NFS4_OK:\n            CREATE4resok
        resok4;\n    default:\n            void;\n   };\n"
      title: 16.4.3.  RESULT
    - contents:
      - "16.4.4.  DESCRIPTION\n   The CREATE operation creates a non-regular file
        object in a directory\n   with a given name.  The OPEN operation is used to
        create a regular\n   file.\n   The objname specifies the name for the new
        object.  The objtype\n   determines the type of object to be created: directory,
        symlink, etc.\n   If an object of the same name already exists in the directory,
        the\n   server will return the error NFS4ERR_EXIST.\n   For the directory
        where the new file object was created, the server\n   returns change_info4
        information in cinfo.  With the atomic field of\n   the change_info4 struct,
        the server will indicate if the before and\n   after change attributes were
        obtained atomically with respect to the\n   file object creation.\n   If the
        objname is of zero length, NFS4ERR_INVAL will be returned.\n   The objname
        is also subject to the normal UTF-8, character support,\n   and name checks.
        \ See Section 12.7 for further discussion.\n   The current filehandle is replaced
        by that of the new object.\n   The createattrs field specifies the initial
        set of attributes for the\n   object.  The set of attributes may include any
        writable attribute\n   valid for the object type.  When the operation is successful,
        the\n   server will return to the client an attribute mask signifying which\n
        \  attributes were successfully set for the object.\n   If createattrs includes
        neither the owner attribute nor an ACL with\n   an ACE for the owner, and
        if the server's file system both supports\n   and requires an owner attribute
        (or an owner ACE), then the server\n   MUST derive the owner (or the owner
        ACE).  This would typically be\n   from the principal indicated in the RPC
        credentials of the call, but\n   the server's operating environment or file
        system semantics may\n   dictate other methods of derivation.  Similarly,
        if createattrs\n   includes neither the group attribute nor a group ACE, and
        if the\n   server's file system both supports and requires the notion of a
        group\n   attribute (or group ACE), the server MUST derive the group attribute\n
        \  (or the corresponding owner ACE) for the file.  This could be from\n   the
        RPC's credentials, such as the group principal if the credentials\n   include
        it (such as with AUTH_SYS), from the group identifier\n   associated with
        the principal in the credentials (e.g., POSIX systems\n   have a user database
        [getpwnam] that has the group identifier for\n   every user identifier), inherited
        from the directory the object is\n   created in, or whatever else the server's
        operating environment\n   or file system semantics dictate.  This applies
        to the OPEN\n   operation too.\n   Conversely, it is possible the client will
        specify in createattrs an\n   owner attribute, group attribute, or ACL that
        the principal indicated\n   the RPC's credentials does not have permissions
        to create files for.\n   The error to be returned in this instance is NFS4ERR_PERM.
        \ This\n   applies to the OPEN operation too.\n"
      title: 16.4.4.  DESCRIPTION
    - contents:
      - "16.4.5.  IMPLEMENTATION\n   If the client desires to set attribute values
        after the create, a\n   SETATTR operation can be added to the COMPOUND request
        so that the\n   appropriate attributes will be set.\n"
      title: 16.4.5.  IMPLEMENTATION
    title: '16.4.  Operation 6: CREATE - Create a Non-regular File Object'
  - contents:
    - '16.5.  Operation 7: DELEGPURGE - Purge Delegations Awaiting Recovery

      '
    - contents:
      - "16.5.1.  SYNOPSIS\n     clientid ->\n"
      title: 16.5.1.  SYNOPSIS
    - contents:
      - "16.5.2.  ARGUMENT\n   struct DELEGPURGE4args {\n           clientid4       clientid;\n
        \  };\n"
      title: 16.5.2.  ARGUMENT
    - contents:
      - "16.5.3.  RESULT\n   struct DELEGPURGE4res {\n           nfsstat4        status;\n
        \  };\n"
      title: 16.5.3.  RESULT
    - contents:
      - "16.5.4.  DESCRIPTION\n   DELEGPURGE purges all of the delegations awaiting
        recovery for a\n   given client.  This is useful for clients that do not commit\n
        \  delegation information to stable storage, to indicate that\n   conflicting
        requests need not be delayed by the server awaiting\n   recovery of delegation
        information.\n   This operation is provided to support clients that record
        delegation\n   information in stable storage on the client.  In this case,\n
        \  DELEGPURGE should be issued immediately after doing delegation\n   recovery
        (using CLAIM_DELEGATE_PREV) on all delegations known to the\n   client.  Doing
        so will notify the server that no additional\n   delegations for the client
        will be recovered, allowing it to free\n   resources and avoid delaying other
        clients who make requests that\n   conflict with the unrecovered delegations.
        \ All clients SHOULD use\n   DELEGPURGE as part of recovery once it is known
        that no further\n   CLAIM_DELEGATE_PREV recovery will be done.  This includes
        clients\n   that do not record delegation information in stable storage, who\n
        \  would then do a DELEGPURGE immediately after SETCLIENTID_CONFIRM.\n   The
        set of delegations known to the server and the client may be\n   different.
        \ The reasons for this include:\n   o  A client may fail after making a request
        that resulted in\n      delegation but before it received the results and
        committed them\n      to the client's stable storage.\n   o  A client may
        fail after deleting its indication that a delegation\n      exists but before
        the delegation return is fully processed by the\n      server.\n   o  In the
        case in which the server and the client restart, the server\n      may have
        limited persistent recording of delegations to a subset\n      of those in
        existence.\n   o  A client may have only persistently recorded information
        about a\n      subset of delegations.\n   The server MAY support DELEGPURGE,
        but its support or non-support\n   should match that of CLAIM_DELEGATE_PREV:\n
        \  o  A server may support both DELEGPURGE and CLAIM_DELEGATE_PREV.\n   o
        \ A server may support neither DELEGPURGE nor CLAIM_DELEGATE_PREV.\n   This
        fact allows a client starting up to determine if the server is\n   prepared
        to support persistent storage of delegation information and\n   thus whether
        it may use write-back caching to local persistent\n   storage, relying on
        CLAIM_DELEGATE_PREV recovery to allow such\n   changed data to be flushed
        safely to the server in the event of\n   client restart.\n"
      title: 16.5.4.  DESCRIPTION
    title: '16.5.  Operation 7: DELEGPURGE - Purge Delegations Awaiting Recovery'
  - contents:
    - '16.6.  Operation 8: DELEGRETURN - Return Delegation

      '
    - contents:
      - "16.6.1.  SYNOPSIS\n     (cfh), stateid ->\n"
      title: 16.6.1.  SYNOPSIS
    - contents:
      - "16.6.2.  ARGUMENT\n   struct DELEGRETURN4args {\n           /* CURRENT_FH:
        delegated file */\n           stateid4        deleg_stateid;\n   };\n"
      title: 16.6.2.  ARGUMENT
    - contents:
      - "16.6.3.  RESULT\n   struct DELEGRETURN4res {\n           nfsstat4        status;\n
        \  };\n"
      title: 16.6.3.  RESULT
    - contents:
      - "16.6.4.  DESCRIPTION\n   DELEGRETURN returns the delegation represented by
        the current\n   filehandle and stateid.\n   Delegations may be returned when
        recalled or voluntarily (i.e.,\n   before the server has recalled them).  In
        either case, the client\n   must properly propagate state changed under the
        context of the\n   delegation to the server before returning the delegation.\n"
      title: 16.6.4.  DESCRIPTION
    title: '16.6.  Operation 8: DELEGRETURN - Return Delegation'
  - contents:
    - '16.7.  Operation 9: GETATTR - Get Attributes

      '
    - contents:
      - "16.7.1.  SYNOPSIS\n     (cfh), attrbits -> attrbits, attrvals\n"
      title: 16.7.1.  SYNOPSIS
    - contents:
      - "16.7.2.  ARGUMENT\n   struct GETATTR4args {\n           /* CURRENT_FH: directory
        or file */\n           bitmap4         attr_request;\n   };\n"
      title: 16.7.2.  ARGUMENT
    - contents:
      - "16.7.3.  RESULT\n   struct GETATTR4resok {\n           fattr4          obj_attributes;\n
        \  };\n   union GETATTR4res switch (nfsstat4 status) {\n    case NFS4_OK:\n
        \           GETATTR4resok  resok4;\n    default:\n            void;\n   };\n"
      title: 16.7.3.  RESULT
    - contents:
      - "16.7.4.  DESCRIPTION\n   The GETATTR operation will obtain attributes for
        the file system\n   object specified by the current filehandle.  The client
        sets a bit in\n   the bitmap argument for each attribute value that it would
        like the\n   server to return.  The server returns an attribute bitmap that\n
        \  indicates the attribute values for which it was able to return\n   values,
        followed by the attribute values ordered lowest attribute\n   number first.\n
        \  The server MUST return a value for each attribute that the client\n   requests
        if the attribute is supported by the server.  If the server\n   does not support
        an attribute or cannot approximate a useful value,\n   then it MUST NOT return
        the attribute value and MUST NOT set the\n   attribute bit in the result bitmap.
        \ The server MUST return an error\n   if it supports an attribute on the target
        but cannot obtain its\n   value.  In that case, no attribute values will be
        returned.\n   File systems that are absent should be treated as having support
        for\n   a very small set of attributes as described in Section 8.3.1 -- even\n
        \  if previously, when the file system was present, more attributes were\n
        \  supported.\n   All servers MUST support the REQUIRED attributes, as specified
        in\n   Section 5, for all file systems, with the exception of absent file\n
        \  systems.\n   On success, the current filehandle retains its value.\n"
      title: 16.7.4.  DESCRIPTION
    - contents:
      - "16.7.5.  IMPLEMENTATION\n   Suppose there is an OPEN_DELEGATE_WRITE delegation
        held by another\n   client for the file in question, and size and/or change
        are among the\n   set of attributes being interrogated.  The server has two
        choices.\n   First, the server can obtain the actual current value of these\n
        \  attributes from the client holding the delegation by using the\n   CB_GETATTR
        callback.  Second, the server, particularly when the\n   delegated client
        is unresponsive, can recall the delegation in\n   question.  The GETATTR MUST
        NOT proceed until one of the following\n   occurs:\n   o  The requested attribute
        values are returned in the response to\n      CB_GETATTR.\n   o  The OPEN_DELEGATE_WRITE
        delegation is returned.\n   o  The OPEN_DELEGATE_WRITE delegation is revoked.\n
        \  Unless one of the above happens very quickly, one or more\n   NFS4ERR_DELAY
        errors will be returned while a delegation is\n   outstanding.\n"
      title: 16.7.5.  IMPLEMENTATION
    title: '16.7.  Operation 9: GETATTR - Get Attributes'
  - contents:
    - '16.8.  Operation 10: GETFH - Get Current Filehandle

      '
    - contents:
      - "16.8.1.  SYNOPSIS\n     (cfh) -> filehandle\n"
      title: 16.8.1.  SYNOPSIS
    - contents:
      - "16.8.2.  ARGUMENT\n     /* CURRENT_FH: */\n     void;\n"
      title: 16.8.2.  ARGUMENT
    - contents:
      - "16.8.3.  RESULT\n   struct GETFH4resok {\n           nfs_fh4         object;\n
        \  };\n   union GETFH4res switch (nfsstat4 status) {\n    case NFS4_OK:\n
        \           GETFH4resok     resok4;\n    default:\n            void;\n   };\n"
      title: 16.8.3.  RESULT
    - contents:
      - "16.8.4.  DESCRIPTION\n   This operation returns the current filehandle value.\n
        \  On success, the current filehandle retains its value.\n"
      title: 16.8.4.  DESCRIPTION
    - contents:
      - "16.8.5.  IMPLEMENTATION\n   Operations that change the current filehandle,
        like LOOKUP or CREATE,\n   do not automatically return the new filehandle
        as a result.  For\n   instance, if a client needs to look up a directory entry
        and obtain\n   its filehandle, then the following request is needed.\n     PUTFH
        \ (directory filehandle)\n     LOOKUP (entry name)\n     GETFH\n"
      title: 16.8.5.  IMPLEMENTATION
    title: '16.8.  Operation 10: GETFH - Get Current Filehandle'
  - contents:
    - '16.9.  Operation 11: LINK - Create Link to a File

      '
    - contents:
      - "16.9.1.  SYNOPSIS\n     (sfh), (cfh), newname -> (cfh), cinfo\n"
      title: 16.9.1.  SYNOPSIS
    - contents:
      - "16.9.2.  ARGUMENT\n   struct LINK4args {\n           /* SAVED_FH: source
        object */\n           /* CURRENT_FH: target directory */\n           component4
        \     newname;\n   };\n"
      title: 16.9.2.  ARGUMENT
    - contents:
      - "16.9.3.  RESULT\n   struct LINK4resok {\n           change_info4    cinfo;\n
        \  };\n   union LINK4res switch (nfsstat4 status) {\n    case NFS4_OK:\n            LINK4resok
        resok4;\n    default:\n            void;\n   };\n"
      title: 16.9.3.  RESULT
    - contents:
      - "16.9.4.  DESCRIPTION\n   The LINK operation creates an additional newname
        for the file\n   represented by the saved filehandle, as set by the SAVEFH
        operation,\n   in the directory represented by the current filehandle.  The
        existing\n   file and the target directory must reside within the same file
        system\n   on the server.  On success, the current filehandle will continue
        to\n   be the target directory.  If an object exists in the target directory\n
        \  with the same name as newname, the server must return NFS4ERR_EXIST.\n
        \  For the target directory, the server returns change_info4 information\n
        \  in cinfo.  With the atomic field of the change_info4 struct, the\n   server
        will indicate if the before and after change attributes were\n   obtained
        atomically with respect to the link creation.\n   If newname has a length
        of 0 (zero), or if newname does not obey the\n   UTF-8 definition, the error
        NFS4ERR_INVAL will be returned.\n"
      title: 16.9.4.  DESCRIPTION
    - contents:
      - "16.9.5.  IMPLEMENTATION\n   Changes to any property of the \"hard\" linked
        files are reflected in\n   all of the linked files.  When a link is made to
        a file, the\n   attributes for the file should have a value for numlinks that
        is one\n   greater than the value before the LINK operation.\n   The statement
        \"file and the target directory must reside within the\n   same file system
        on the server\" means that the fsid fields in the\n   attributes for the objects
        are the same.  If they reside on different\n   file systems, the error NFS4ERR_XDEV
        is returned.  This error may be\n   returned by some servers when there is
        an internal partitioning of a\n   file system that the LINK operation would
        violate.\n   On some servers, \".\" and \"..\" are illegal values for newname,
        and the\n   error NFS4ERR_BADNAME will be returned if they are specified.\n
        \  When the current filehandle designates a named attribute directory\n   and
        the object to be linked (the saved filehandle) is not a named\n   attribute
        for the same object, the error NFS4ERR_XDEV MUST be\n   returned.  When the
        saved filehandle designates a named attribute and\n   the current filehandle
        is not the appropriate named attribute\n   directory, the error NFS4ERR_XDEV
        MUST also be returned.\n   When the current filehandle designates a named
        attribute directory\n   and the object to be linked (the saved filehandle)
        is a named\n   attribute within that directory, the server MAY return the
        error\n   NFS4ERR_NOTSUPP.\n   In the case that newname is already linked
        to the file represented by\n   the saved filehandle, the server will return
        NFS4ERR_EXIST.\n   Note that symbolic links are created with the CREATE operation.\n"
      title: 16.9.5.  IMPLEMENTATION
    title: '16.9.  Operation 11: LINK - Create Link to a File'
  - contents:
    - '16.10.  Operation 12: LOCK - Create Lock

      '
    - contents:
      - "16.10.1.  SYNOPSIS\n     (cfh) locktype, reclaim, offset, length, locker
        -> stateid\n"
      title: 16.10.1.  SYNOPSIS
    - contents:
      - "16.10.2.  ARGUMENT\n   enum nfs_lock_type4 {\n           READ_LT         =
        1,\n           WRITE_LT        = 2,\n           READW_LT        = 3,    /*
        blocking read */\n           WRITEW_LT       = 4     /* blocking write */\n
        \  };\n   /*\n    * For LOCK, transition from open_owner to new lock_owner\n
        \   */\n   struct open_to_lock_owner4 {\n           seqid4          open_seqid;\n
        \          stateid4        open_stateid;\n           seqid4          lock_seqid;\n
        \          lock_owner4     lock_owner;\n   };\n   /*\n    * For LOCK, existing
        lock_owner continues to request file locks\n    */\n   struct exist_lock_owner4
        {\n           stateid4        lock_stateid;\n           seqid4          lock_seqid;\n
        \  };\n   union locker4 switch (bool new_lock_owner) {\n    case TRUE:\n            open_to_lock_owner4
        \    open_owner;\n    case FALSE:\n            exist_lock_owner4       lock_owner;\n
        \  };\n   /*\n    * LOCK/LOCKT/LOCKU: Record lock management\n    */\n   struct
        LOCK4args {\n           /* CURRENT_FH: file */\n           nfs_lock_type4
        \ locktype;\n           bool            reclaim;\n           offset4         offset;\n
        \          length4         length;\n           locker4         locker;\n   };\n"
      title: 16.10.2.  ARGUMENT
    - contents:
      - "16.10.3.  RESULT\n   struct LOCK4denied {\n           offset4         offset;\n
        \          length4         length;\n           nfs_lock_type4  locktype;\n
        \          lock_owner4     owner;\n   };\n   struct LOCK4resok {\n           stateid4
        \       lock_stateid;\n   };\n   union LOCK4res switch (nfsstat4 status) {\n
        \   case NFS4_OK:\n            LOCK4resok     resok4;\n    case NFS4ERR_DENIED:\n
        \           LOCK4denied    denied;\n    default:\n            void;\n   };\n"
      title: 16.10.3.  RESULT
    - contents:
      - "16.10.4.  DESCRIPTION\n   The LOCK operation requests a byte-range lock for
        the byte range\n   specified by the offset and length parameters.  The lock
        type is also\n   specified to be one of the nfs_lock_type4s.  If this is a
        reclaim\n   request, the reclaim parameter will be TRUE.\n   Bytes in a file
        may be locked even if those bytes are not currently\n   allocated to the file.
        \ To lock the file from a specific offset\n   through the end-of-file (no
        matter how long the file actually is),\n   use a length field with all bits
        set to 1 (one).  If the length is\n   zero, or if a length that is not all
        bits set to one is specified,\n   and the length when added to the offset
        exceeds the maximum 64-bit\n   unsigned integer value, the error NFS4ERR_INVAL
        will result.\n   32-bit servers are servers that support locking for byte
        offsets that\n   fit within 32 bits (i.e., less than or equal to NFS4_UINT32_MAX).
        \ If\n   the client specifies a range that overlaps one or more bytes beyond\n
        \  offset NFS4_UINT32_MAX but does not end at offset NFS4_UINT64_MAX,\n   then
        such a 32-bit server MUST return the error NFS4ERR_BAD_RANGE.\n   In the case
        that the lock is denied, the owner, offset, and length of\n   a conflicting
        lock are returned.\n   On success, the current filehandle retains its value.\n"
      title: 16.10.4.  DESCRIPTION
    - contents:
      - "16.10.5.  IMPLEMENTATION\n   If the server is unable to determine the exact
        offset and length of\n   the conflicting lock, the same offset and length
        that were provided\n   in the arguments should be returned in the denied results.
        \ Section 9\n   contains a full description of this and the other file locking\n
        \  operations.\n   LOCK operations are subject to permission checks and to
        checks\n   against the access type of the associated file.  However, the\n
        \  specific rights and modes required for various types of locks\n   reflect
        the semantics of the server-exported file system, and are not\n   specified
        by the protocol.  For example, Windows 2000 allows a write\n   lock of a file
        open for READ, while a POSIX-compliant system\n   does not.\n   When the client
        makes a lock request that corresponds to a range that\n   the lock-owner has
        locked already (with the same or different lock\n   type), or to a sub-region
        of such a range, or to a region that\n   includes multiple locks already granted
        to that lock-owner, in whole\n   or in part, and the server does not support
        such locking operations\n   (i.e., does not support POSIX locking semantics),
        the server will\n   return the error NFS4ERR_LOCK_RANGE.  In that case, the
        client may\n   return an error, or it may emulate the required operations,
        using\n   only LOCK for ranges that do not include any bytes already locked
        by\n   that lock-owner and LOCKU of locks held by that lock-owner\n   (specifying
        an exactly matching range and type).  Similarly, when the\n   client makes
        a lock request that amounts to upgrading (changing from\n   a read lock to
        a write lock) or downgrading (changing from a write\n   lock to a read lock)
        an existing record lock and the server does not\n   support such a lock, the
        server will return NFS4ERR_LOCK_NOTSUPP.\n   Such operations may not perfectly
        reflect the required semantics in\n   the face of conflicting lock requests
        from other clients.\n   When a client holds an OPEN_DELEGATE_WRITE delegation,
        the client\n   holding that delegation is assured that there are no opens
        by other\n   clients.  Thus, there can be no conflicting LOCK operations from
        such\n   clients.  Therefore, the client may be handling locking requests\n
        \  locally, without doing LOCK operations on the server.  If it does\n   that,
        it must be prepared to update the lock status on the server by\n   sending
        appropriate LOCK and LOCKU operations before returning the\n   delegation.\n
        \  When one or more clients hold OPEN_DELEGATE_READ delegations, any\n   LOCK
        operation where the server is implementing mandatory locking\n   semantics
        MUST result in the recall of all such delegations.  The\n   LOCK operation
        may not be granted until all such delegations are\n   returned or revoked.
        \ Except where this happens very quickly, one or\n   more NFS4ERR_DELAY errors
        will be returned to requests made while the\n   delegation remains outstanding.\n
        \  The locker argument specifies the lock-owner that is associated with\n
        \  the LOCK request.  The locker4 structure is a switched union that\n   indicates
        whether the client has already created byte-range locking\n   state associated
        with the current open file and lock-owner.  There\n   are multiple cases to
        be considered, corresponding to possible\n   combinations of whether locking
        state has been created for the\n   current open file and lock-owner, and whether
        the boolean\n   new_lock_owner is set.  In all of the cases, there is a lock_seqid\n
        \  specified, whether the lock-owner is specified explicitly or\n   implicitly.
        \ This seqid value is used for checking lock-owner\n   sequencing/replay issues.
        \ When the given lock-owner is not known to\n   the server, this establishes
        an initial sequence value for the new\n   lock-owner.\n   o  In the case in
        which the state has been created and the boolean is\n      false, the only
        part of the argument other than lock_seqid is just\n      a stateid representing
        the set of locks associated with that open\n      file and lock-owner.\n   o
        \ In the case in which the state has been created and the boolean is\n      true,
        the server rejects the request with the error\n      NFS4ERR_BAD_SEQID.  The
        only exception is where there is a\n      retransmission of a previous request
        in which the boolean was\n      true.  In this case, the lock_seqid will match
        the original\n      request, and the response will reflect the final case,
        below.\n   o  In the case where no byte-range locking state has been established\n
        \     and the boolean is true, the argument contains an\n      open_to_lock_owner
        structure that specifies the stateid of the\n      open file and the lock-owner
        to be used for the lock.  Note that\n      although the open-owner is not
        given explicitly, the open_seqid\n      associated with it is used to check
        for open-owner sequencing\n      issues.  This case provides a method to use
        the established state\n      of the open_stateid to transition to the use
        of a lock stateid.\n"
      title: 16.10.5.  IMPLEMENTATION
    title: '16.10.  Operation 12: LOCK - Create Lock'
  - contents:
    - '16.11.  Operation 13: LOCKT - Test for Lock

      '
    - contents:
      - "16.11.1.  SYNOPSIS\n     (cfh) locktype, offset, length, owner -> {void,
        NFS4ERR_DENIED ->\n     owner}\n"
      title: 16.11.1.  SYNOPSIS
    - contents:
      - "16.11.2.  ARGUMENT\n   struct LOCKT4args {\n           /* CURRENT_FH: file
        */\n           nfs_lock_type4  locktype;\n           offset4         offset;\n
        \          length4         length;\n           lock_owner4     owner;\n   };\n"
      title: 16.11.2.  ARGUMENT
    - contents:
      - "16.11.3.  RESULT\n   union LOCKT4res switch (nfsstat4 status) {\n    case
        NFS4ERR_DENIED:\n            LOCK4denied    denied;\n    case NFS4_OK:\n            void;\n
        \   default:\n            void;\n   };\n"
      title: 16.11.3.  RESULT
    - contents:
      - "16.11.4.  DESCRIPTION\n   The LOCKT operation tests the lock as specified
        in the arguments.  If\n   a conflicting lock exists, the owner, offset, length,
        and type of the\n   conflicting lock are returned; if no lock is held, nothing
        other than\n   NFS4_OK is returned.  Lock types READ_LT and READW_LT are processed\n
        \  in the same way in that a conflicting lock test is done without\n   regard
        to blocking or non-blocking.  The same is true for WRITE_LT\n   and WRITEW_LT.\n
        \  The ranges are specified as for LOCK.  The NFS4ERR_INVAL and\n   NFS4ERR_BAD_RANGE
        errors are returned under the same circumstances as\n   for LOCK.\n   On success,
        the current filehandle retains its value.\n"
      title: 16.11.4.  DESCRIPTION
    - contents:
      - "16.11.5.  IMPLEMENTATION\n   If the server is unable to determine the exact
        offset and length of\n   the conflicting lock, the same offset and length
        that were provided\n   in the arguments should be returned in the denied results.
        \ Section 9\n   contains further discussion of the file locking mechanisms.\n
        \  LOCKT uses a lock_owner4, rather than a stateid4 as is used in LOCK,\n
        \  to identify the owner.  This is because the client does not have to\n   open
        the file to test for the existence of a lock, so a stateid may\n   not be
        available.\n   The test for conflicting locks SHOULD exclude locks for the
        current\n   lock-owner.  Note that since such locks are not examined the possible\n
        \  existence of overlapping ranges may not affect the results of LOCKT.\n
        \  If the server does examine locks that match the lock-owner for the\n   purpose
        of range checking, NFS4ERR_LOCK_RANGE may be returned.  In\n   the event that
        it returns NFS4_OK, clients may do a LOCK and receive\n   NFS4ERR_LOCK_RANGE
        on the LOCK request because of the flexibility\n   provided to the server.\n
        \  When a client holds an OPEN_DELEGATE_WRITE delegation, it may choose\n
        \  (see Section 16.10.5) to handle LOCK requests locally.  In such a\n   case,
        LOCKT requests will similarly be handled locally.\n"
      title: 16.11.5.  IMPLEMENTATION
    title: '16.11.  Operation 13: LOCKT - Test for Lock'
  - contents:
    - '16.12.  Operation 14: LOCKU - Unlock File

      '
    - contents:
      - "16.12.1.  SYNOPSIS\n     (cfh) type, seqid, stateid, offset, length -> stateid\n"
      title: 16.12.1.  SYNOPSIS
    - contents:
      - "16.12.2.  ARGUMENT\n   struct LOCKU4args {\n           /* CURRENT_FH: file
        */\n           nfs_lock_type4  locktype;\n           seqid4          seqid;\n
        \          stateid4        lock_stateid;\n           offset4         offset;\n
        \          length4         length;\n   };\n"
      title: 16.12.2.  ARGUMENT
    - contents:
      - "16.12.3.  RESULT\n   union LOCKU4res switch (nfsstat4 status) {\n    case
        NFS4_OK:\n            stateid4       lock_stateid;\n    default:\n            void;\n
        \  };\n"
      title: 16.12.3.  RESULT
    - contents:
      - "16.12.4.  DESCRIPTION\n   The LOCKU operation unlocks the byte-range lock
        specified by the\n   parameters.  The client may set the locktype field to
        any value that\n   is legal for the nfs_lock_type4 enumerated type, and the
        server MUST\n   accept any legal value for locktype.  Any legal value for
        locktype\n   has no effect on the success or failure of the LOCKU operation.\n
        \  The ranges are specified as for LOCK.  The NFS4ERR_INVAL and\n   NFS4ERR_BAD_RANGE
        errors are returned under the same circumstances as\n   for LOCK.\n   On success,
        the current filehandle retains its value.\n"
      title: 16.12.4.  DESCRIPTION
    - contents:
      - "16.12.5.  IMPLEMENTATION\n   If the area to be unlocked does not correspond
        exactly to a lock\n   actually held by the lock-owner, the server may return
        the error\n   NFS4ERR_LOCK_RANGE.  This includes the cases where (1) the area
        is\n   not locked, (2) the area is a sub-range of the area locked, (3) it\n
        \  overlaps the area locked without matching exactly, or (4) the area\n   specified
        includes multiple locks held by the lock-owner.  In all of\n   these cases,
        allowed by POSIX locking [fcntl] semantics, a client\n   receiving this error
        should, if it desires support for such\n   operations, simulate the operation
        using LOCKU on ranges\n   corresponding to locks it actually holds, possibly
        followed by LOCK\n   requests for the sub-ranges not being unlocked.\n   When
        a client holds an OPEN_DELEGATE_WRITE delegation, it may choose\n   (see Section
        16.10.5) to handle LOCK requests locally.  In such a\n   case, LOCKU requests
        will similarly be handled locally.\n"
      title: 16.12.5.  IMPLEMENTATION
    title: '16.12.  Operation 14: LOCKU - Unlock File'
  - contents:
    - '16.13.  Operation 15: LOOKUP - Look Up Filename

      '
    - contents:
      - "16.13.1.  SYNOPSIS\n     (cfh), component -> (cfh)\n"
      title: 16.13.1.  SYNOPSIS
    - contents:
      - "16.13.2.  ARGUMENT\n   struct LOOKUP4args {\n           /* CURRENT_FH: directory
        */\n           component4      objname;\n   };\n"
      title: 16.13.2.  ARGUMENT
    - contents:
      - "16.13.3.  RESULT\n   struct LOOKUP4res {\n           /* CURRENT_FH: object
        */\n           nfsstat4        status;\n   };\n"
      title: 16.13.3.  RESULT
    - contents:
      - "16.13.4.  DESCRIPTION\n   This operation performs a LOOKUP or finds a file
        system object using\n   the directory specified by the current filehandle.
        \ LOOKUP evaluates\n   the component and if the object exists the current
        filehandle is\n   replaced with the component's filehandle.\n   If the component
        cannot be evaluated because either it does not exist\n   or the client does
        not have permission to evaluate it, then an error\n   will be returned, and
        the current filehandle will be unchanged.\n   If the component is of zero
        length, NFS4ERR_INVAL will be returned.\n   The component is also subject
        to the normal UTF-8, character support,\n   and name checks.  See Section
        12.7 for further discussion.\n"
      title: 16.13.4.  DESCRIPTION
    - contents:
      - "16.13.5.  IMPLEMENTATION\n   If the client wants to achieve the effect of
        a multi-component\n   lookup, it may construct a COMPOUND request such as
        the following\n   (and obtain each filehandle):\n     PUTFH  (directory filehandle)\n
        \    LOOKUP \"pub\"\n     GETFH\n     LOOKUP \"foo\"\n     GETFH\n     LOOKUP
        \"bar\"\n     GETFH\n   NFSv4 servers depart from the semantics of previous
        NFS versions in\n   allowing LOOKUP requests to cross mount points on the
        server.  The\n   client can detect a mount point crossing by comparing the
        fsid\n   attribute of the directory with the fsid attribute of the directory\n
        \  looked up.  If the fsids are different, then the new directory is a\n   server
        mount point.  UNIX clients that detect a mount point crossing\n   will need
        to mount the server's file system.  This needs to be done\n   to maintain
        the file object identity-checking mechanisms common to\n   UNIX clients.\n
        \  Servers that limit NFS access to \"shares\" or \"exported\" file systems\n
        \  should provide a pseudo-file system into which the exported file\n   systems
        can be integrated, so that clients can browse the server's\n   namespace.
        \ The clients' view of a pseudo-file system will be limited\n   to paths that
        lead to exported file systems.\n   Note: Previous versions of the protocol
        assigned special semantics to\n   the names \".\" and \"..\".  NFSv4 assigns
        no special semantics to these\n   names.  The LOOKUPP operator must be used
        to look up a parent\n   directory.\n   Note that this operation does not follow
        symbolic links.  The client\n   is responsible for all parsing of filenames,
        including filenames that\n   are modified by symbolic links encountered during
        the lookup process.\n   If the current filehandle supplied is not a directory
        but a symbolic\n   link, NFS4ERR_SYMLINK is returned as the error.  For all
        other\n   non-directory file types, the error NFS4ERR_NOTDIR is returned.\n"
      title: 16.13.5.  IMPLEMENTATION
    title: '16.13.  Operation 15: LOOKUP - Look Up Filename'
  - contents:
    - '16.14.  Operation 16: LOOKUPP - Look Up Parent Directory

      '
    - contents:
      - "16.14.1.  SYNOPSIS\n     (cfh) -> (cfh)\n"
      title: 16.14.1.  SYNOPSIS
    - contents:
      - "16.14.2.  ARGUMENT\n     /* CURRENT_FH: object */\n     void;\n"
      title: 16.14.2.  ARGUMENT
    - contents:
      - "16.14.3.  RESULT\n   struct LOOKUPP4res {\n           /* CURRENT_FH: directory
        */\n           nfsstat4        status;\n   };\n"
      title: 16.14.3.  RESULT
    - contents:
      - "16.14.4.  DESCRIPTION\n   The current filehandle is assumed to refer to a
        regular directory or\n   a named attribute directory.  LOOKUPP assigns the
        filehandle for its\n   parent directory to be the current filehandle.  If
        there is no parent\n   directory, an NFS4ERR_NOENT error must be returned.
        \ Therefore,\n   NFS4ERR_NOENT will be returned by the server when the current\n
        \  filehandle is at the root or top of the server's file tree.\n"
      title: 16.14.4.  DESCRIPTION
    - contents:
      - "16.14.5.  IMPLEMENTATION\n   As for LOOKUP, LOOKUPP will also cross mount
        points.\n   If the current filehandle is not a directory or named attribute\n
        \  directory, the error NFS4ERR_NOTDIR is returned.\n   If the current filehandle
        is a named attribute directory that is\n   associated with a file system object
        via OPENATTR (i.e., not a\n   subdirectory of a named attribute directory),
        LOOKUPP SHOULD return\n   the filehandle of the associated file system object.\n"
      title: 16.14.5.  IMPLEMENTATION
    title: '16.14.  Operation 16: LOOKUPP - Look Up Parent Directory'
  - contents:
    - '16.15.  Operation 17: NVERIFY - Verify Difference in Attributes

      '
    - contents:
      - "16.15.1.  SYNOPSIS\n     (cfh), fattr -> -\n"
      title: 16.15.1.  SYNOPSIS
    - contents:
      - "16.15.2.  ARGUMENT\n   struct NVERIFY4args {\n           /* CURRENT_FH: object
        */\n           fattr4          obj_attributes;\n   };\n"
      title: 16.15.2.  ARGUMENT
    - contents:
      - "16.15.3.  RESULT\n   struct NVERIFY4res {\n           nfsstat4        status;\n
        \  };\n"
      title: 16.15.3.  RESULT
    - contents:
      - "16.15.4.  DESCRIPTION\n   This operation is used to prefix a sequence of
        operations to be\n   performed if one or more attributes have changed on some
        file system\n   object.  If all the attributes match, then the error NFS4ERR_SAME\n
        \  must be returned.\n   On success, the current filehandle retains its value.\n"
      title: 16.15.4.  DESCRIPTION
    - contents:
      - "16.15.5.  IMPLEMENTATION\n   This operation is useful as a cache validation
        operator.  If the\n   object to which the attributes belong has changed, then
        the following\n   operations may obtain new data associated with that object
        -- for\n   instance, to check if a file has been changed and obtain new data
        if\n   it has:\n     PUTFH  (public)\n     LOOKUP \"foobar\"\n     NVERIFY
        attrbits attrs\n     READ 0 32767\n   In the case that a RECOMMENDED attribute
        is specified in the NVERIFY\n   operation and the server does not support
        that attribute for the file\n   system object, the error NFS4ERR_ATTRNOTSUPP
        is returned to the\n   client.\n   When the attribute rdattr_error or any
        write-only attribute (e.g.,\n   time_modify_set) is specified, the error NFS4ERR_INVAL
        is returned to\n   the client.\n"
      title: 16.15.5.  IMPLEMENTATION
    title: '16.15.  Operation 17: NVERIFY - Verify Difference in Attributes'
  - contents:
    - '16.16.  Operation 18: OPEN - Open a Regular File

      '
    - contents:
      - "16.16.1.  SYNOPSIS\n     (cfh), seqid, share_access, share_deny, owner, openhow,
        claim ->\n     (cfh), stateid, cinfo, rflags, attrset, delegation\n"
      title: 16.16.1.  SYNOPSIS
    - contents:
      - "16.16.2.  ARGUMENT\n   /*\n    * Various definitions for OPEN\n    */\n   enum
        createmode4 {\n           UNCHECKED4      = 0,\n           GUARDED4        =
        1,\n           EXCLUSIVE4      = 2\n   };\n   union createhow4 switch (createmode4
        mode) {\n    case UNCHECKED4:\n    case GUARDED4:\n            fattr4         createattrs;\n
        \   case EXCLUSIVE4:\n            verifier4      createverf;\n   };\n   enum
        opentype4 {\n           OPEN4_NOCREATE  = 0,\n           OPEN4_CREATE    =
        1\n   };\n   union openflag4 switch (opentype4 opentype) {\n    case OPEN4_CREATE:\n
        \           createhow4     how;\n    default:\n            void;\n   };\n
        \  /* Next definitions used for OPEN delegation */\n   enum limit_by4 {\n
        \          NFS_LIMIT_SIZE          = 1,\n           NFS_LIMIT_BLOCKS        =
        2\n           /* others as needed */\n   };\n   struct nfs_modified_limit4
        {\n           uint32_t        num_blocks;\n           uint32_t        bytes_per_block;\n
        \  };\n   union nfs_space_limit4 switch (limit_by4 limitby) {\n    /* limit
        specified as file size */\n    case NFS_LIMIT_SIZE:\n            uint64_t
        \              filesize;\n    /* limit specified by number of blocks */\n
        \   case NFS_LIMIT_BLOCKS:\n            nfs_modified_limit4    mod_blocks;\n
        \  };\n   enum open_delegation_type4 {\n           OPEN_DELEGATE_NONE      =
        0,\n           OPEN_DELEGATE_READ      = 1,\n           OPEN_DELEGATE_WRITE
        \    = 2\n   };\n   enum open_claim_type4 {\n           CLAIM_NULL              =
        0,\n           CLAIM_PREVIOUS          = 1,\n           CLAIM_DELEGATE_CUR
        \     = 2,\n           CLAIM_DELEGATE_PREV     = 3\n   };\n   struct open_claim_delegate_cur4
        {\n           stateid4        delegate_stateid;\n           component4      file;\n
        \  };\n   union open_claim4 switch (open_claim_type4 claim) {\n    /*\n     *
        No special rights to file.\n     * Ordinary OPEN of the specified file.\n
        \    */\n    case CLAIM_NULL:\n            /* CURRENT_FH: directory */\n            component4
        \     file;\n    /*\n     * Right to the file established by an\n     * open
        previous to server reboot.  File\n     * identified by filehandle obtained
        at\n     * that time rather than by name.\n     */\n    case CLAIM_PREVIOUS:\n
        \           /* CURRENT_FH: file being reclaimed */\n            open_delegation_type4
        \  delegate_type;\n    /*\n     * Right to file based on a delegation\n     *
        granted by the server.  File is\n     * specified by name.\n     */\n    case
        CLAIM_DELEGATE_CUR:\n            /* CURRENT_FH: directory */\n            open_claim_delegate_cur4
        \       delegate_cur_info;\n    /*\n     * Right to file based on a delegation\n
        \    * granted to a previous boot instance\n     * of the client.  File is
        specified by name.\n     */\n    case CLAIM_DELEGATE_PREV:\n            /*
        CURRENT_FH: directory */\n            component4      file_delegate_prev;\n
        \  };\n   /*\n    * OPEN: Open a file, potentially receiving an open delegation\n
        \   */\n   struct OPEN4args {\n           seqid4          seqid;\n           uint32_t
        \       share_access;\n           uint32_t        share_deny;\n           open_owner4
        \    owner;\n           openflag4       openhow;\n           open_claim4     claim;\n
        \  };\n"
      title: 16.16.2.  ARGUMENT
    - contents:
      - "16.16.3.  RESULT\n   struct open_read_delegation4 {\n    stateid4 stateid;
        \   /* Stateid for delegation */\n    bool     recall;     /* Pre-recalled
        flag for\n                            delegations obtained\n                            by
        reclaim (CLAIM_PREVIOUS) */\n    nfsace4 permissions; /* Defines users who
        don't\n                            need an ACCESS call to\n                            open
        for read */\n   };\n   struct open_write_delegation4 {\n    stateid4 stateid;
        \     /* Stateid for delegation */\n    bool     recall;       /* Pre-recalled
        flag for\n                              delegations obtained\n                              by
        reclaim\n                              (CLAIM_PREVIOUS) */\n    nfs_space_limit4\n
        \             space_limit; /* Defines condition that\n                              the
        client must check to\n                              determine whether the\n
        \                             file needs to be flushed\n                              to
        the server on close */\n    nfsace4   permissions; /* Defines users who don't\n
        \                             need an ACCESS call as\n                              part
        of a delegated\n                              open */\n   };\n   union open_delegation4
        switch\n      (open_delegation_type4 delegation_type) {\n           case OPEN_DELEGATE_NONE:\n
        \                  void;\n           case OPEN_DELEGATE_READ:\n                   open_read_delegation4
        read;\n           case OPEN_DELEGATE_WRITE:\n                   open_write_delegation4
        write;\n   };\n   /*\n    * Result flags\n    */\n   /* Client must confirm
        open */\n   const OPEN4_RESULT_CONFIRM      = 0x00000002;\n   /* Type of file
        locking behavior at the server */\n   const OPEN4_RESULT_LOCKTYPE_POSIX =
        0x00000004;\n   struct OPEN4resok {\n    stateid4       stateid;      /* Stateid
        for open */\n    change_info4   cinfo;        /* Directory change info */\n
        \   uint32_t       rflags;       /* Result flags */\n    bitmap4        attrset;
        \     /* attribute set for create */\n    open_delegation4 delegation; /*
        Info on any open\n                                    delegation */\n   };\n
        \  union OPEN4res switch (nfsstat4 status) {\n    case NFS4_OK:\n            /*
        CURRENT_FH: opened file */\n            OPEN4resok      resok4;\n    default:\n
        \           void;\n   };\n"
      title: 16.16.3.  RESULT
    - contents:
      - "16.16.4.  Warning to Client Implementers\n   OPEN resembles LOOKUP in that
        it generates a filehandle for the\n   client to use.  Unlike LOOKUP, though,
        OPEN creates server state on\n   the filehandle.  In normal circumstances,
        the client can only release\n   this state with a CLOSE operation.  CLOSE
        uses the current filehandle\n   to determine which file to close.  Therefore,
        the client MUST follow\n   every OPEN operation with a GETFH operation in
        the same COMPOUND\n   procedure.  This will supply the client with the filehandle
        such that\n   CLOSE can be used appropriately.\n   Simply waiting for the
        lease on the file to expire is insufficient\n   because the server may maintain
        the state indefinitely as long as\n   another client does not attempt to make
        a conflicting access to the\n   same file.\n"
      title: 16.16.4.  Warning to Client Implementers
    - contents:
      - "16.16.5.  DESCRIPTION\n   The OPEN operation creates and/or opens a regular
        file in a directory\n   with the provided name.  If the file does not exist
        at the server and\n   creation is desired, specification of the method of
        creation is\n   provided by the openhow parameter.  The client has the choice
        of\n   three creation methods: UNCHECKED4, GUARDED4, or EXCLUSIVE4.\n   If
        the current filehandle is a named attribute directory, OPEN will\n   then
        create or open a named attribute file.  Note that exclusive\n   create of
        a named attribute is not supported.  If the createmode is\n   EXCLUSIVE4 and
        the current filehandle is a named attribute directory,\n   the server will
        return EINVAL.\n   UNCHECKED4 means that the file should be created if a file
        of that\n   name does not exist and encountering an existing regular file
        of that\n   name is not an error.  For this type of create, createattrs specifies\n
        \  the initial set of attributes for the file.  The set of attributes\n   may
        include any writable attribute valid for regular files.  When an\n   UNCHECKED4
        create encounters an existing file, the attributes\n   specified by createattrs
        are not used, except that when a size of\n   zero is specified, the existing
        file is truncated.  If GUARDED4 is\n   specified, the server checks for the
        presence of a duplicate object\n   by name before performing the create.  If
        a duplicate exists, an\n   error of NFS4ERR_EXIST is returned as the status.
        \ If the object does\n   not exist, the request is performed as described
        for UNCHECKED4.  For\n   each of these cases (UNCHECKED4 and GUARDED4), where
        the operation is\n   successful, the server will return to the client an attribute
        mask\n   signifying which attributes were successfully set for the object.\n
        \  EXCLUSIVE4 specifies that the server is to follow exclusive creation\n
        \  semantics, using the verifier to ensure exclusive creation of the\n   target.
        \ The server should check for the presence of a duplicate\n   object by name.
        \ If the object does not exist, the server creates the\n   object and stores
        the verifier with the object.  If the object does\n   exist and the stored
        verifier matches the verifier provided by the\n   client, the server uses
        the existing object as the newly created\n   object.  If the stored verifier
        does not match, then an error of\n   NFS4ERR_EXIST is returned.  No attributes
        may be provided in this\n   case, since the server may use an attribute of
        the target object to\n   store the verifier.  If the server uses an attribute
        to store the\n   exclusive create verifier, it will signify which attribute
        was used\n   by setting the appropriate bit in the attribute mask that is
        returned\n   in the results.\n   For the target directory, the server returns
        change_info4 information\n   in cinfo.  With the atomic field of the change_info4
        struct, the\n   server will indicate if the before and after change attributes
        were\n   obtained atomically with respect to the link creation.\n   Upon successful
        creation, the current filehandle is replaced by that\n   of the new object.\n
        \  The OPEN operation provides for Windows share reservation capability\n
        \  with the use of the share_access and share_deny fields of the OPEN\n   arguments.
        \ The client specifies at OPEN the required share_access\n   and share_deny
        modes.  For clients that do not directly support\n   SHAREs (i.e., UNIX),
        the expected deny value is DENY_NONE.  In the\n   case that there is an existing
        share reservation that conflicts with\n   the OPEN request, the server returns
        the error NFS4ERR_SHARE_DENIED.\n   For a complete SHARE request, the client
        must provide values for the\n   owner and seqid fields for the OPEN argument.
        \ For additional\n   discussion of share semantics, see Section 9.9.\n   In
        the case that the client is recovering state from a server\n   failure, the
        claim field of the OPEN argument is used to signify that\n   the request is
        meant to reclaim state previously held.\n   The claim field of the OPEN argument
        is used to specify the file to\n   be opened and the state information that
        the client claims to\n   possess.  There are four basic claim types that cover
        the various\n   situations for an OPEN.  They are as follows:\n   CLAIM_NULL:
        \ For the client, this is a new OPEN request, and there is\n      no previous
        state associated with the file for the client.\n   CLAIM_PREVIOUS:  The client
        is claiming basic OPEN state for a file\n      that was held previous to a
        server reboot.  This is generally used\n      when a server is returning persistent
        filehandles; the client may\n      not have the filename to reclaim the OPEN.\n
        \  CLAIM_DELEGATE_CUR:  The client is claiming a delegation for OPEN as\n
        \     granted by the server.  This is generally done as part of\n      recalling
        a delegation.\n   CLAIM_DELEGATE_PREV:  The client is claiming a delegation
        granted to\n      a previous client instance.  This claim type is for use
        after a\n      SETCLIENTID_CONFIRM and before the corresponding DELEGPURGE
        in two\n      situations: after a client reboot and after a lease expiration\n
        \     that resulted in loss of all lock state.  The server MAY support\n      CLAIM_DELEGATE_PREV.
        \ If it does support CLAIM_DELEGATE_PREV,\n      SETCLIENTID_CONFIRM MUST
        NOT remove the client's delegation state,\n      and the server MUST support
        the DELEGPURGE operation.\n   The following errors apply to use of the CLAIM_DELEGATE_PREV
        claim\n   type:\n   o  NFS4ERR_NOTSUPP is returned if the server does not
        support this\n      claim type.\n   o  NFS4ERR_INVAL is returned if the reclaim
        is done at an\n      inappropriate time, e.g., after DELEGPURGE has been done.\n
        \  o  NFS4ERR_BAD_RECLAIM is returned if the other error conditions do\n      not
        apply and the server has no record of the delegation whose\n      reclaim
        is being attempted.\n   For OPEN requests whose claim type is other than CLAIM_PREVIOUS\n
        \  (i.e., requests other than those devoted to reclaiming opens after a\n
        \  server reboot) that reach the server during its grace or lease\n   expiration
        period, the server returns an error of NFS4ERR_GRACE.\n   For any OPEN request,
        the server may return an open delegation, which\n   allows further opens and
        closes to be handled locally on the client\n   as described in Section 10.4.
        \ Note that delegation is up to the\n   server to decide.  The client should
        never assume that delegation\n   will or will not be granted in a particular
        instance.  It should\n   always be prepared for either case.  A partial exception
        is the\n   reclaim (CLAIM_PREVIOUS) case, in which a delegation type is claimed.\n
        \  In this case, delegation will always be granted, although the server\n
        \  may specify an immediate recall in the delegation structure.\n   The rflags
        returned by a successful OPEN allow the server to return\n   information governing
        how the open file is to be handled.\n   OPEN4_RESULT_CONFIRM indicates that
        the client MUST execute an\n   OPEN_CONFIRM operation before using the open
        file.\n   OPEN4_RESULT_LOCKTYPE_POSIX indicates that the server's file locking\n
        \  behavior supports the complete set of POSIX locking techniques\n   [fcntl].
        \ From this, the client can choose to manage file locking\n   state in such
        a way as to handle a mismatch of file locking\n   management.\n   If the component
        is of zero length, NFS4ERR_INVAL will be returned.\n   The component is also
        subject to the normal UTF-8, character support,\n   and name checks.  See
        Section 12.7 for further discussion.\n   When an OPEN is done and the specified
        open-owner already has the\n   resulting filehandle open, the result is to
        \"OR\" together the new\n   share and deny status, together with the existing
        status.  In this\n   case, only a single CLOSE need be done, even though multiple
        OPENs\n   were completed.  When such an OPEN is done, checking of share\n
        \  reservations for the new OPEN proceeds normally, with no exception\n   for
        the existing OPEN held by the same owner.  In this case, the\n   stateid returned
        has an \"other\" field that matches that of the\n   previous open, while the
        seqid field is incremented to reflect the\n   changed status due to the new
        open (Section 9.1.4).\n   If the underlying file system at the server is only
        accessible in a\n   read-only mode and the OPEN request has specified\n   OPEN4_SHARE_ACCESS_WRITE
        or OPEN4_SHARE_ACCESS_BOTH, the server will\n   return NFS4ERR_ROFS to indicate
        a read-only file system.\n   As with the CREATE operation, the server MUST
        derive the owner, owner\n   ACE, group, or group ACE if any of the four attributes
        are required\n   and supported by the server's file system.  For an OPEN with
        the\n   EXCLUSIVE4 createmode, the server has no choice, since such OPEN\n
        \  calls do not include the createattrs field.  Conversely, if\n   createattrs
        is specified and includes owner or group (or\n   corresponding ACEs) that
        the principal in the RPC's credentials does\n   not have authorization to
        create files for, then the server may\n   return NFS4ERR_PERM.\n   In the
        case where an OPEN specifies a size of zero (e.g., truncation)\n   and the
        file has named attributes, the named attributes are left as\n   is.  They
        are not removed.\n"
      title: 16.16.5.  DESCRIPTION
    - contents:
      - "16.16.6.  IMPLEMENTATION\n   The OPEN operation contains support for EXCLUSIVE4
        create.  The\n   mechanism is similar to the support in NFSv3 [RFC1813].  As
        in NFSv3,\n   this mechanism provides reliable exclusive creation.  Exclusive\n
        \  create is invoked when the how parameter is EXCLUSIVE4.  In this\n   case,
        the client provides a verifier that can reasonably be expected\n   to be unique.
        \ A combination of a client identifier, perhaps the\n   client network address,
        and a unique number generated by the client,\n   perhaps the RPC transaction
        identifier, may be appropriate.\n   If the object does not exist, the server
        creates the object and\n   stores the verifier in stable storage.  For file
        systems that do not\n   provide a mechanism for the storage of arbitrary file
        attributes, the\n   server may use one or more elements of the object metadata
        to store\n   the verifier.  The verifier must be stored in stable storage
        to\n   prevent erroneous failure on retransmission of the request.  It is\n
        \  assumed that an exclusive create is being performed because exclusive\n
        \  semantics are critical to the application.  Because of the expected\n   usage,
        exclusive create does not rely solely on the normally volatile\n   duplicate
        request cache for storage of the verifier.  The duplicate\n   request cache
        in volatile storage does not survive a crash and may\n   actually flush on
        a long network partition, opening failure windows.\n   In the UNIX local file
        system environment, the expected storage\n   location for the verifier on
        creation is the metadata (timestamps) of\n   the object.  For this reason,
        an exclusive object create may not\n   include initial attributes because
        the server would have nowhere to\n   store the verifier.\n   If the server
        cannot support these exclusive create semantics,\n   possibly because of the
        requirement to commit the verifier to stable\n   storage, it should fail the
        OPEN request with the error\n   NFS4ERR_NOTSUPP.\n   During an exclusive CREATE
        request, if the object already exists, the\n   server reconstructs the object's
        verifier and compares it with the\n   verifier in the request.  If they match,
        the server treats the\n   request as a success.  The request is presumed to
        be a duplicate of\n   an earlier, successful request for which the reply was
        lost and that\n   the server duplicate request cache mechanism did not detect.
        \ If the\n   verifiers do not match, the request is rejected with the status\n
        \  NFS4ERR_EXIST.\n   Once the client has performed a successful exclusive
        create, it must\n   issue a SETATTR to set the correct object attributes.
        \ Until it does\n   so, it should not rely upon any of the object attributes,
        since the\n   server implementation may need to overload object metadata to
        store\n   the verifier.  The subsequent SETATTR must not occur in the same\n
        \  COMPOUND request as the OPEN.  This separation will guarantee that\n   the
        exclusive create mechanism will continue to function properly in\n   the face
        of retransmission of the request.\n   Use of the GUARDED4 attribute does not
        provide \"exactly-once\"\n   semantics.  In particular, if a reply is lost
        and the server does not\n   detect the retransmission of the request, the
        operation can fail with\n   NFS4ERR_EXIST, even though the create was performed
        successfully.\n   The client would use this behavior in the case that the
        application\n   has not requested an exclusive create but has asked to have
        the file\n   truncated when the file is opened.  In the case of the client
        timing\n   out and retransmitting the create request, the client can use\n
        \  GUARDED4 to prevent a sequence such as create, write, create\n   (retransmitted)
        from occurring.\n   For share reservations (see Section 9.9), the client must
        specify a\n   value for share_access that is one of OPEN4_SHARE_ACCESS_READ,\n
        \  OPEN4_SHARE_ACCESS_WRITE, or OPEN4_SHARE_ACCESS_BOTH.  For\n   share_deny,
        the client must specify one of OPEN4_SHARE_DENY_NONE,\n   OPEN4_SHARE_DENY_READ,
        OPEN4_SHARE_DENY_WRITE, or\n   OPEN4_SHARE_DENY_BOTH.  If the client fails
        to do this, the server\n   must return NFS4ERR_INVAL.\n   Based on the share_access
        value (OPEN4_SHARE_ACCESS_READ,\n   OPEN4_SHARE_ACCESS_WRITE, or OPEN4_SHARE_ACCESS_BOTH),
        the client\n   should check that the requester has the proper access rights
        to\n   perform the specified operation.  This would generally be the results\n
        \  of applying the ACL access rules to the file for the current\n   requester.
        \ However, just as with the ACCESS operation, the client\n   should not attempt
        to second-guess the server's decisions, as access\n   rights may change and
        may be subject to server administrative\n   controls outside the ACL framework.
        \ If the requester is not\n   authorized to READ or WRITE (depending on the
        share_access value),\n   the server must return NFS4ERR_ACCESS.  Note that
        since the NFSv4\n   protocol does not impose any requirement that READs and
        WRITEs issued\n   for an open file have the same credentials as the OPEN itself,
        the\n   server still must do appropriate access checking on the READs and\n
        \  WRITEs themselves.\n   If the component provided to OPEN resolves to something
        other than a\n   regular file (or a named attribute), an error will be returned
        to the\n   client.  If it is a directory, NFS4ERR_ISDIR is returned; otherwise,\n
        \  NFS4ERR_SYMLINK is returned.  Note that NFS4ERR_SYMLINK is returned\n   for
        both symlinks and for special files of other types; NFS4ERR_INVAL\n   would
        be inappropriate, since the arguments provided by the client\n   were correct,
        and the client cannot necessarily know at the time it\n   sent the OPEN that
        the component would resolve to a non-regular file.\n   If the current filehandle
        is not a directory, the error\n   NFS4ERR_NOTDIR will be returned.\n   If
        a COMPOUND contains an OPEN that establishes an\n   OPEN_DELEGATE_WRITE delegation,
        then subsequent GETATTRs normally\n   result in a CB_GETATTR being sent to
        the client holding the\n   delegation.  However, in the case in which the
        OPEN and GETATTR are\n   part of the same COMPOUND, the server SHOULD understand
        that the\n   operations are for the same client ID and avoid querying the
        client,\n   which will not be able to respond.  This sequence of OPEN and
        GETATTR\n   SHOULD be understood to be the retrieval of the size and change\n
        \  attributes at the time of OPEN.  Further, as explained in\n   Section 15.2.5,
        the client should not construct a COMPOUND that mixes\n   operations for different
        client IDs.\n"
      title: 16.16.6.  IMPLEMENTATION
    title: '16.16.  Operation 18: OPEN - Open a Regular File'
  - contents:
    - '16.17.  Operation 19: OPENATTR - Open Named Attribute Directory

      '
    - contents:
      - "16.17.1.  SYNOPSIS\n     (cfh) createdir -> (cfh)\n"
      title: 16.17.1.  SYNOPSIS
    - contents:
      - "16.17.2.  ARGUMENT\n   struct OPENATTR4args {\n           /* CURRENT_FH:
        object */\n           bool    createdir;\n   };\n"
      title: 16.17.2.  ARGUMENT
    - contents:
      - "16.17.3.  RESULT\n   struct OPENATTR4res {\n           /* CURRENT_FH: named
        attr directory */\n           nfsstat4        status;\n   };\n"
      title: 16.17.3.  RESULT
    - contents:
      - "16.17.4.  DESCRIPTION\n   The OPENATTR operation is used to obtain the filehandle
        of the named\n   attribute directory associated with the current filehandle.
        \ The\n   result of the OPENATTR will be a filehandle to an object of type\n
        \  NF4ATTRDIR.  From this filehandle, READDIR and LOOKUP operations can\n
        \  be used to obtain filehandles for the various named attributes\n   associated
        with the original file system object.  Filehandles\n   returned within the
        named attribute directory will have a type of\n   NF4NAMEDATTR.\n   The createdir
        argument allows the client to signify if a named\n   attribute directory should
        be created as a result of the OPENATTR\n   operation.  Some clients may use
        the OPENATTR operation with a value\n   of FALSE for createdir to determine
        if any named attributes exist for\n   the object.  If none exist, then NFS4ERR_NOENT
        will be returned.  If\n   createdir has a value of TRUE and no named attribute
        directory\n   exists, one is created.  The creation of a named attribute directory\n
        \  assumes that the server has implemented named attribute support in\n   this
        fashion and is not required to do so by this definition.\n"
      title: 16.17.4.  DESCRIPTION
    - contents:
      - "16.17.5.  IMPLEMENTATION\n   If the server does not support named attributes
        for the current\n   filehandle, an error of NFS4ERR_NOTSUPP will be returned
        to the\n   client.\n"
      title: 16.17.5.  IMPLEMENTATION
    title: '16.17.  Operation 19: OPENATTR - Open Named Attribute Directory'
  - contents:
    - '16.18.  Operation 20: OPEN_CONFIRM - Confirm Open

      '
    - contents:
      - "16.18.1.  SYNOPSIS\n     (cfh), seqid, stateid -> stateid\n"
      title: 16.18.1.  SYNOPSIS
    - contents:
      - "16.18.2.  ARGUMENT\n   struct OPEN_CONFIRM4args {\n           /* CURRENT_FH:
        opened file */\n           stateid4        open_stateid;\n           seqid4
        \         seqid;\n   };\n"
      title: 16.18.2.  ARGUMENT
    - contents:
      - "16.18.3.  RESULT\n   struct OPEN_CONFIRM4resok {\n           stateid4        open_stateid;\n
        \  };\n   union OPEN_CONFIRM4res switch (nfsstat4 status) {\n    case NFS4_OK:\n
        \           OPEN_CONFIRM4resok     resok4;\n    default:\n            void;\n
        \  };\n"
      title: 16.18.3.  RESULT
    - contents:
      - "16.18.4.  DESCRIPTION\n   This operation is used to confirm the sequence
        id usage for the first\n   time that an open-owner is used by a client.  The
        stateid returned\n   from the OPEN operation is used as the argument for this
        operation\n   along with the next sequence id for the open-owner.  The sequence
        id\n   passed to the OPEN_CONFIRM must be 1 (one) greater than the seqid\n
        \  passed to the OPEN operation (Section 9.1.4).  If the server receives\n
        \  an unexpected sequence id with respect to the original OPEN, then the\n
        \  server assumes that the client will not confirm the original OPEN and\n
        \  all state associated with the original OPEN is released by the\n   server.\n
        \  On success, the current filehandle retains its value.\n"
      title: 16.18.4.  DESCRIPTION
    - contents:
      - "16.18.5.  IMPLEMENTATION\n   A given client might generate many open_owner4
        data structures for a\n   given client ID.  The client will periodically either
        dispose of its\n   open_owner4s or stop using them for indefinite periods
        of time.  The\n   latter situation is why the NFSv4 protocol does not have
        an explicit\n   operation to exit an open_owner4: such an operation is of
        no use in\n   that situation.  Instead, to avoid unbounded memory use, the
        server\n   needs to implement a strategy for disposing of open_owner4s that
        have\n   no current open state for any files and have not been used recently.\n
        \  The time period used to determine when to dispose of open_owner4s is\n
        \  an implementation choice.  The time period should certainly be no\n   less
        than the lease time plus any grace period the server wishes to\n   implement
        beyond a lease time.  The OPEN_CONFIRM operation allows the\n   server to
        safely dispose of unused open_owner4 data structures.\n   In the case that
        a client issues an OPEN operation and the server no\n   longer has a record
        of the open_owner4, the server needs to ensure\n   that this is a new OPEN
        and not a replay or retransmission.\n   Servers MUST NOT require confirmation
        on OPENs that grant delegations\n   or are doing reclaim operations.  See
        Section 9.1.11 for details.\n   The server can easily avoid this by noting
        whether it has disposed of\n   one open_owner4 for the given client ID.  If
        the server does not\n   support delegation, it might simply maintain a single
        bit that notes\n   whether any open_owner4 (for any client) has been disposed
        of.\n   The server must hold unconfirmed OPEN state until one of three events\n
        \  occurs.  First, the client sends an OPEN_CONFIRM request with the\n   appropriate
        sequence id and stateid within the lease period.  In this\n   case, the OPEN
        state on the server goes to confirmed, and the\n   open_owner4 on the server
        is fully established.\n   Second, the client sends another OPEN request with
        a sequence id that\n   is incorrect for the open_owner4 (out of sequence).
        \ In this case,\n   the server assumes the second OPEN request is valid and
        the first one\n   is a replay.  The server cancels the OPEN state of the first
        OPEN\n   request, establishes an unconfirmed OPEN state for the second OPEN\n
        \  request, and responds to the second OPEN request with an indication\n   that
        an OPEN_CONFIRM is needed.  The process then repeats itself.\n   While there
        is a potential for a denial-of-service attack on the\n   client, it is mitigated
        if the client and server require the use of a\n   security flavor based on
        Kerberos V5 or some other flavor that uses\n   cryptography.\n   What if the
        server is in the unconfirmed OPEN state for a given\n   open_owner4, and it
        receives an operation on the open_owner4 that has\n   a stateid but the operation
        is not OPEN, or it is OPEN_CONFIRM but\n   with the wrong stateid?  Then,
        even if the seqid is correct, the\n   server returns NFS4ERR_BAD_STATEID,
        because the server assumes the\n   operation is a replay: if the server has
        no established OPEN state,\n   then there is no way, for example, a LOCK operation
        could be valid.\n   Third, neither of the two aforementioned events occurs
        for the\n   open_owner4 within the lease period.  In this case, the OPEN state
        is\n   canceled and disposal of the open_owner4 can occur.\n"
      title: 16.18.5.  IMPLEMENTATION
    title: '16.18.  Operation 20: OPEN_CONFIRM - Confirm Open'
  - contents:
    - '16.19.  Operation 21: OPEN_DOWNGRADE - Reduce Open File Access

      '
    - contents:
      - "16.19.1.  SYNOPSIS\n     (cfh), stateid, seqid, access, deny -> stateid\n"
      title: 16.19.1.  SYNOPSIS
    - contents:
      - "16.19.2.  ARGUMENT\n   struct OPEN_DOWNGRADE4args {\n           /* CURRENT_FH:
        opened file */\n           stateid4        open_stateid;\n           seqid4
        \         seqid;\n           uint32_t        share_access;\n           uint32_t
        \       share_deny;\n   };\n"
      title: 16.19.2.  ARGUMENT
    - contents:
      - "16.19.3.  RESULT\n   struct OPEN_DOWNGRADE4resok {\n           stateid4        open_stateid;\n
        \  };\n   union OPEN_DOWNGRADE4res switch (nfsstat4 status) {\n    case NFS4_OK:\n
        \           OPEN_DOWNGRADE4resok    resok4;\n    default:\n            void;\n
        \  };\n"
      title: 16.19.3.  RESULT
    - contents:
      - "16.19.4.  DESCRIPTION\n   This operation is used to adjust the share_access
        and share_deny bits\n   for a given open.  This is necessary when a given
        open-owner opens\n   the same file multiple times with different share_access
        and\n   share_deny flags.  In this situation, a close of one of the opens
        may\n   change the appropriate share_access and share_deny flags to remove\n
        \  bits associated with opens no longer in effect.\n   The share_access and
        share_deny bits specified in this operation\n   replace the current ones for
        the specified open file.  The\n   share_access and share_deny bits specified
        must be exactly equal to\n   the union of the share_access and share_deny
        bits specified for some\n   subset of the OPENs in effect for the current
        open-owner on the\n   current file.  If that constraint is not respected,
        the error\n   NFS4ERR_INVAL should be returned.  Since share_access and share_deny\n
        \  bits are subsets of those already granted, it is not possible for\n   this
        request to be denied because of conflicting share reservations.\n   As the
        OPEN_DOWNGRADE may change a file to be not-open-for-write and\n   a write
        byte-range lock might be held, the server may have to reject\n   the OPEN_DOWNGRADE
        with an NFS4ERR_LOCKS_HELD.\n   On success, the current filehandle retains
        its value.\n"
      title: 16.19.4.  DESCRIPTION
    title: '16.19.  Operation 21: OPEN_DOWNGRADE - Reduce Open File Access'
  - contents:
    - '16.20.  Operation 22: PUTFH - Set Current Filehandle

      '
    - contents:
      - "16.20.1.  SYNOPSIS\n     filehandle -> (cfh)\n"
      title: 16.20.1.  SYNOPSIS
    - contents:
      - "16.20.2.  ARGUMENT\n   struct PUTFH4args {\n           nfs_fh4         object;\n
        \  };\n"
      title: 16.20.2.  ARGUMENT
    - contents:
      - "16.20.3.  RESULT\n   struct PUTFH4res {\n           /* CURRENT_FH: */\n           nfsstat4
        \       status;\n   };\n"
      title: 16.20.3.  RESULT
    - contents:
      - "16.20.4.  DESCRIPTION\n   PUTFH replaces the current filehandle with the
        filehandle provided as\n   an argument.\n   If the security mechanism used
        by the requester does not meet the\n   requirements of the filehandle provided
        to this operation, the server\n   MUST return NFS4ERR_WRONGSEC.\n   See Section
        15.2.4.1 for more details on the current filehandle.\n"
      title: 16.20.4.  DESCRIPTION
    - contents:
      - "16.20.5.  IMPLEMENTATION\n   PUTFH is commonly used as the first operator
        in an NFS request to set\n   the context for operations that follow it.\n"
      title: 16.20.5.  IMPLEMENTATION
    title: '16.20.  Operation 22: PUTFH - Set Current Filehandle'
  - contents:
    - '16.21.  Operation 23: PUTPUBFH - Set Public Filehandle

      '
    - contents:
      - "16.21.1.  SYNOPSIS\n     - -> (cfh)\n"
      title: 16.21.1.  SYNOPSIS
    - contents:
      - "16.21.2.  ARGUMENT\n     void;\n"
      title: 16.21.2.  ARGUMENT
    - contents:
      - "16.21.3.  RESULT\n   struct PUTPUBFH4res {\n           /* CURRENT_FH: public
        fh */\n           nfsstat4        status;\n   };\n"
      title: 16.21.3.  RESULT
    - contents:
      - "16.21.4.  DESCRIPTION\n   PUTPUBFH replaces the current filehandle with the
        filehandle that\n   represents the public filehandle of the server's namespace.
        \ This\n   filehandle may be different from the root filehandle, which may
        be\n   associated with some other directory on the server.\n   The public
        filehandle concept was introduced in [RFC2054], [RFC2055],\n   and [RFC2224].
        \ The intent for NFSv4 is that the public filehandle\n   (represented by the
        PUTPUBFH operation) be used as a method of\n   providing compatibility with
        the WebNFS server of NFSv2 and NFSv3.\n   The public filehandle and the root
        filehandle (represented by the\n   PUTROOTFH operation) should be equivalent.
        \ If the public and root\n   filehandles are not equivalent, then the public
        filehandle MUST be a\n   descendant of the root filehandle.\n"
      title: 16.21.4.  DESCRIPTION
    - contents:
      - "16.21.5.  IMPLEMENTATION\n   PUTPUBFH is used as the first operator in an
        NFS request to set the\n   context for operations that follow it.\n   With
        the NFSv2 and NFSv3 public filehandle, the client is able to\n   specify whether
        the pathname provided in the LOOKUP should be\n   evaluated as either an absolute
        path relative to the server's root or\n   relative to the public filehandle.
        \ [RFC2224] contains further\n   discussion of the functionality.  With NFSv4,
        that type of\n   specification is not directly available in the LOOKUP operation.
        \ The\n   reason for this is because the component separators needed to specify\n
        \  absolute versus relative are not allowed in NFSv4.  Therefore, the\n   client
        is responsible for constructing its request such that either\n   PUTROOTFH
        or PUTPUBFH is used to signify absolute or relative\n   evaluation of an NFS
        URL, respectively.\n   Note that there are warnings mentioned in [RFC2224]
        with respect to\n   the use of absolute evaluation and the restrictions the
        server may\n   place on that evaluation with respect to how much of its namespace\n
        \  has been made available.  These same warnings apply to NFSv4.  It is\n
        \  likely, therefore, that because of server implementation details an\n   NFSv3
        absolute public filehandle lookup may behave differently than\n   an NFSv4
        absolute resolution.\n   There is a form of security negotiation as described
        in [RFC2755]\n   that uses the public filehandle as a method of employing
        the Simple\n   and Protected GSS-API Negotiation Mechanism (SNEGO) [RFC4178].
        \ This\n   method is not available with NFSv4, as filehandles are not overloaded\n
        \  with special meaning and therefore do not provide the same framework\n
        \  as NFSv2 and NFSv3.  Clients should therefore use the security\n   negotiation
        mechanisms described in this RFC.\n"
      title: 16.21.5.  IMPLEMENTATION
    title: '16.21.  Operation 23: PUTPUBFH - Set Public Filehandle'
  - contents:
    - '16.22.  Operation 24: PUTROOTFH - Set Root Filehandle

      '
    - contents:
      - "16.22.1.  SYNOPSIS\n     - -> (cfh)\n"
      title: 16.22.1.  SYNOPSIS
    - contents:
      - "16.22.2.  ARGUMENT\n     void;\n"
      title: 16.22.2.  ARGUMENT
    - contents:
      - "16.22.3.  RESULT\n   struct PUTROOTFH4res {\n           /* CURRENT_FH: root
        fh */\n           nfsstat4        status;\n   };\n"
      title: 16.22.3.  RESULT
    - contents:
      - "16.22.4.  DESCRIPTION\n   PUTROOTFH replaces the current filehandle with
        the filehandle that\n   represents the root of the server's namespace.  From
        this filehandle,\n   a LOOKUP operation can locate any other filehandle on
        the server.\n   This filehandle may be different from the public filehandle,
        which\n   may be associated with some other directory on the server.\n   See
        Section 15.2.4.1 for more details on the current filehandle.\n"
      title: 16.22.4.  DESCRIPTION
    - contents:
      - "16.22.5.  IMPLEMENTATION\n   PUTROOTFH is commonly used as the first operator
        in an NFS request to\n   set the context for operations that follow it.\n"
      title: 16.22.5.  IMPLEMENTATION
    title: '16.22.  Operation 24: PUTROOTFH - Set Root Filehandle'
  - contents:
    - '16.23.  Operation 25: READ - Read from File

      '
    - contents:
      - "16.23.1.  SYNOPSIS\n     (cfh), stateid, offset, count -> eof, data\n"
      title: 16.23.1.  SYNOPSIS
    - contents:
      - "16.23.2.  ARGUMENT\n   struct READ4args {\n           /* CURRENT_FH: file
        */\n           stateid4        stateid;\n           offset4         offset;\n
        \          count4          count;\n   };\n"
      title: 16.23.2.  ARGUMENT
    - contents:
      - "16.23.3.  RESULT\n   struct READ4resok {\n           bool            eof;\n
        \          opaque          data<>;\n   };\n   union READ4res switch (nfsstat4
        status) {\n    case NFS4_OK:\n            READ4resok     resok4;\n    default:\n
        \           void;\n   };\n"
      title: 16.23.3.  RESULT
    - contents:
      - "16.23.4.  DESCRIPTION\n   The READ operation reads data from the regular
        file identified by the\n   current filehandle.\n   The client provides an
        offset of where the READ is to start and a\n   count of how many bytes are
        to be read.  An offset of 0 (zero) means\n   to read data starting at the
        beginning of the file.  If the offset is\n   greater than or equal to the
        size of the file, the status, NFS4_OK,\n   is returned with a data length
        set to 0 (zero), and eof is set to\n   TRUE.  The READ is subject to access
        permissions checking.\n   If the client specifies a count value of 0 (zero),
        the READ succeeds\n   and returns 0 (zero) bytes of data (subject to access
        permissions\n   checking).  The server may choose to return fewer bytes than\n
        \  specified by the client.  The client needs to check for this\n   condition
        and handle the condition appropriately.\n   The stateid value for a READ request
        represents a value returned from\n   a previous byte-range lock or share reservation
        request, or the\n   stateid associated with a delegation.  The stateid is
        used by the\n   server to verify that the associated share reservation and
        any\n   byte-range locks are still valid and to update lease timeouts for
        the\n   client.\n   If the READ ended at the end-of-file (formally, in a correctly
        formed\n   READ request, if offset + count is equal to the size of the file),
        or\n   the READ request extends beyond the size of the file (if offset +\n
        \  count is greater than the size of the file), eof is returned as TRUE;\n
        \  otherwise, it is FALSE.  A successful READ of an empty file will\n   always
        return eof as TRUE.\n   If the current filehandle is not a regular file, an
        error will be\n   returned to the client.  In the case where the current filehandle\n
        \  represents a directory, NFS4ERR_ISDIR is returned; otherwise,\n   NFS4ERR_INVAL
        is returned.\n   For a READ using the special anonymous stateid, the server
        MAY allow\n   the READ to be serviced subject to mandatory file locks or the\n
        \  current share_deny modes for the file.  For a READ using the special\n
        \  READ bypass stateid, the server MAY allow READ operations to bypass\n   locking
        checks at the server.\n   On success, the current filehandle retains its value.\n"
      title: 16.23.4.  DESCRIPTION
    - contents:
      - "16.23.5.  IMPLEMENTATION\n   If the server returns a \"short read\" (i.e.,
        less data than requested\n   and eof is set to FALSE), the client should send
        another READ to get\n   the remaining data.  A server may return less data
        than requested\n   under several circumstances.  The file may have been truncated
        by\n   another client or perhaps on the server itself, changing the file\n
        \  size from what the requesting client believes to be the case.  This\n   would
        reduce the actual amount of data available to the client.  It\n   is possible
        that the server reduces the transfer size and so returns\n   a short read
        result.  Server resource exhaustion may also result in a\n   short read.\n
        \  If mandatory byte-range locking is in effect for the file, and if the\n
        \  byte range corresponding to the data to be read from the file is\n   WRITE_LT
        locked by an owner not associated with the stateid, the\n   server will return
        the NFS4ERR_LOCKED error.  The client should try\n   to get the appropriate
        READ_LT via the LOCK operation before\n   re-attempting the READ.  When the
        READ completes, the client should\n   release the byte-range lock via LOCKU.\n
        \  If another client has an OPEN_DELEGATE_WRITE delegation for the file\n
        \  being read, the delegation must be recalled, and the operation cannot\n
        \  proceed until that delegation is returned or revoked.  Except where\n   this
        happens very quickly, one or more NFS4ERR_DELAY errors will be\n   returned
        to requests made while the delegation remains outstanding.\n   Normally, delegations
        will not be recalled as a result of a READ\n   operation, since the recall
        will occur as a result of an earlier\n   OPEN.  However, since it is possible
        for a READ to be done with a\n   special stateid, the server needs to check
        for this case even though\n   the client should have done an OPEN previously.\n"
      title: 16.23.5.  IMPLEMENTATION
    title: '16.23.  Operation 25: READ - Read from File'
  - contents:
    - '16.24.  Operation 26: READDIR - Read Directory

      '
    - contents:
      - "16.24.1.  SYNOPSIS\n     (cfh), cookie, cookieverf, dircount, maxcount, attr_request
        ->\n     cookieverf { cookie, name, attrs }\n"
      title: 16.24.1.  SYNOPSIS
    - contents:
      - "16.24.2.  ARGUMENT\n   struct READDIR4args {\n           /* CURRENT_FH: directory
        */\n           nfs_cookie4     cookie;\n           verifier4       cookieverf;\n
        \          count4          dircount;\n           count4          maxcount;\n
        \          bitmap4         attr_request;\n   };\n"
      title: 16.24.2.  ARGUMENT
    - contents:
      - "16.24.3.  RESULT\n   struct entry4 {\n           nfs_cookie4     cookie;\n
        \          component4      name;\n           fattr4          attrs;\n           entry4
        \         *nextentry;\n   };\n   struct dirlist4 {\n           entry4          *entries;\n
        \          bool            eof;\n   };\n   struct READDIR4resok {\n           verifier4
        \      cookieverf;\n           dirlist4        reply;\n   };\n   union READDIR4res
        switch (nfsstat4 status) {\n    case NFS4_OK:\n            READDIR4resok  resok4;\n
        \   default:\n            void;\n   };\n"
      title: 16.24.3.  RESULT
    - contents:
      - "16.24.4.  DESCRIPTION\n   The READDIR operation retrieves a variable number
        of entries from a\n   file system directory and for each entry returns attributes
        that were\n   requested by the client, along with information to allow the
        client\n   to request additional directory entries in a subsequent READDIR.\n
        \  The arguments contain a cookie value that represents where the\n   READDIR
        should start within the directory.  A value of 0 (zero) for\n   the cookie
        is used to start reading at the beginning of the\n   directory.  For subsequent
        READDIR requests, the client specifies a\n   cookie value that is provided
        by the server in a previous READDIR\n   request.\n   The cookieverf value
        should be set to 0 (zero) when the cookie value\n   is 0 (zero) (first directory
        read).  On subsequent requests, it\n   should be a cookieverf as returned
        by the server.  The cookieverf\n   must match that returned by the READDIR
        in which the cookie was\n   acquired.  If the server determines that the cookieverf
        is no longer\n   valid for the directory, the error NFS4ERR_NOT_SAME must
        be returned.\n   The dircount portion of the argument is a hint of the maximum
        number\n   of bytes of directory information that should be returned.  This\n
        \  value represents the length of the names of the directory entries and\n
        \  the cookie value for these entries.  This length represents the XDR\n   encoding
        of the data (names and cookies) and not the length in the\n   native format
        of the server.\n   The maxcount value of the argument is the maximum number
        of bytes for\n   the result.  This maximum size represents all of the data
        being\n   returned within the READDIR4resok structure and includes the XDR\n
        \  overhead.  The server may return less data.  If the server is unable\n
        \  to return a single directory entry within the maxcount limit, the\n   error
        NFS4ERR_TOOSMALL will be returned to the client.\n   Finally, attr_request
        represents the list of attributes to be\n   returned for each directory entry
        supplied by the server.\n   On successful return, the server's response will
        provide a list of\n   directory entries.  Each of these entries contains the
        name of the\n   directory entry, a cookie value for that entry, and the associated\n
        \  attributes as requested.  The \"eof\" flag has a value of TRUE if there\n
        \  are no more entries in the directory.\n   The cookie value is only meaningful
        to the server and is used as a\n   \"bookmark\" for the directory entry.  As
        mentioned, this cookie is\n   used by the client for subsequent READDIR operations
        so that it may\n   continue reading a directory.  The cookie is similar in
        concept to a\n   READ offset but should not be interpreted as such by the
        client.  The\n   server SHOULD try to accept cookie values issued with READDIR\n
        \  responses even if the directory has been modified between the READDIR\n
        \  calls but MAY return NFS4ERR_NOT_VALID if this is not possible, as\n   might
        be the case if the server has rebooted in the interim.\n   In some cases,
        the server may encounter an error while obtaining the\n   attributes for a
        directory entry.  Instead of returning an error for\n   the entire READDIR
        operation, the server can instead return the\n   attribute 'fattr4_rdattr_error'.
        \ With this, the server is able to\n   communicate the failure to the client
        and not fail the entire\n   operation in the instance of what might be a transient
        failure.\n   Obviously, the client must request the fattr4_rdattr_error attribute\n
        \  for this method to work properly.  If the client does not request the\n
        \  attribute, the server has no choice but to return failure for the\n   entire
        READDIR operation.\n   For some file system environments, the directory entries
        \".\" and \"..\"\n   have special meaning, and in other environments, they
        may not.  If\n   the server supports these special entries within a directory,
        they\n   should not be returned to the client as part of the READDIR response.\n
        \  To enable some client environments, the cookie values of 0, 1, and 2\n
        \  are to be considered reserved.  Note that the UNIX client will use\n   these
        values when combining the server's response and local\n   representations
        to enable a fully formed UNIX directory presentation\n   to the application.\n
        \  For READDIR arguments, cookie values of 1 and 2 SHOULD NOT be used,\n   and
        for READDIR results, cookie values of 0, 1, and 2 MUST NOT be\n   returned.\n
        \  On success, the current filehandle retains its value.\n"
      title: 16.24.4.  DESCRIPTION
    - contents:
      - "16.24.5.  IMPLEMENTATION\n   The server's file system directory representations
        can differ\n   greatly.  A client's programming interfaces may also be bound
        to the\n   local operating environment in a way that does not translate well\n
        \  into the NFS protocol.  Therefore, the dircount and maxcount fields\n   are
        provided to allow the client the ability to provide guidelines to\n   the
        server.  If the client is aggressive about attribute collection\n   during
        a READDIR, the server has an idea of how to limit the encoded\n   response.
        \ The dircount field provides a hint on the number of\n   entries based solely
        on the names of the directory entries.  Since it\n   is a hint, it may be
        possible that a dircount value is zero.  In this\n   case, the server is free
        to ignore the dircount value and return\n   directory information based on
        the specified maxcount value.\n   As there is no way for the client to indicate
        that a cookie value,\n   once received, will not be subsequently used, server
        implementations\n   should avoid schemes that allocate memory corresponding
        to a returned\n   cookie.  Such allocation can be avoided if the server bases
        cookie\n   values on a value such as the offset within the directory where
        the\n   scan is to be resumed.\n   Cookies generated by such techniques should
        be designed to remain\n   valid despite modification of the associated directory.
        \ If a server\n   were to invalidate a cookie because of a directory modification,\n
        \  READDIRs of large directories might never finish.\n   If a directory is
        deleted after the client has carried out one or\n   more READDIR operations
        on the directory, the cookies returned will\n   become invalid; however, the
        server does not need to be concerned, as\n   the directory filehandle used
        previously would have become stale and\n   would be reported as such on subsequent
        READDIR operations.  The\n   server would not need to check the cookie verifier
        in this case.\n   However, certain reorganization operations on a directory
        (including\n   directory compaction) may invalidate READDIR cookies previously
        given\n   out.  When such a situation occurs, the server should modify the\n
        \  cookie verifier so as to disallow the use of cookies that would\n   otherwise
        no longer be valid.\n   The cookieverf may be used by the server to help manage
        cookie values\n   that may become stale.  It should be a rare occurrence that
        a server\n   is unable to continue properly reading a directory with the provided\n
        \  cookie/cookieverf pair.  The server should make every effort to avoid\n
        \  this condition since the application at the client may not be able to\n
        \  properly handle this type of failure.\n   The use of the cookieverf will
        also protect the client from using\n   READDIR cookie values that may be stale.
        \ For example, if the file\n   system has been migrated, the server may or
        may not be able to use\n   the same cookie values to service READDIR as the
        previous server\n   used.  With the client providing the cookieverf, the server
        is able\n   to provide the appropriate response to the client.  This prevents
        the\n   case where the server may accept a cookie value but the underlying\n
        \  directory has changed and the response is invalid from the client's\n   context
        of its previous READDIR.\n   Since some servers will not be returning \".\"
        and \"..\" entries as has\n   been done with previous versions of the NFS
        protocol, the client that\n   requires these entries be present in READDIR
        responses must fabricate\n   them.\n"
      title: 16.24.5.  IMPLEMENTATION
    title: '16.24.  Operation 26: READDIR - Read Directory'
  - contents:
    - '16.25.  Operation 27: READLINK - Read Symbolic Link

      '
    - contents:
      - "16.25.1.  SYNOPSIS\n     (cfh) -> linktext\n"
      title: 16.25.1.  SYNOPSIS
    - contents:
      - "16.25.2.  ARGUMENT\n     /* CURRENT_FH: symlink */\n     void;\n"
      title: 16.25.2.  ARGUMENT
    - contents:
      - "16.25.3.  RESULT\n   struct READLINK4resok {\n           linktext4       link;\n
        \  };\n   union READLINK4res switch (nfsstat4 status) {\n    case NFS4_OK:\n
        \           READLINK4resok resok4;\n    default:\n            void;\n   };\n"
      title: 16.25.3.  RESULT
    - contents:
      - "16.25.4.  DESCRIPTION\n   READLINK reads the data associated with a symbolic
        link.  The data is\n   a UTF-8 string that is opaque to the server.  That
        is, whether\n   created by an NFS client or created locally on the server,
        the data\n   in a symbolic link is not interpreted when created but is simply\n
        \  stored.\n   On success, the current filehandle retains its value.\n"
      title: 16.25.4.  DESCRIPTION
    - contents:
      - "16.25.5.  IMPLEMENTATION\n   A symbolic link is nominally a pointer to another
        file.  The data is\n   not necessarily interpreted by the server; it is just
        stored in the\n   file.  It is possible for a client implementation to store
        a pathname\n   that is not meaningful to the server operating system in a
        symbolic\n   link.  A READLINK operation returns the data to the client for\n
        \  interpretation.  If different implementations want to share access to\n
        \  symbolic links, then they must agree on the interpretation of the\n   data
        in the symbolic link.\n   The READLINK operation is only allowed on objects
        of type NF4LNK.\n   The server should return the error NFS4ERR_INVAL if the
        object is not\n   of type NF4LNK.\n"
      title: 16.25.5.  IMPLEMENTATION
    title: '16.25.  Operation 27: READLINK - Read Symbolic Link'
  - contents:
    - '16.26.  Operation 28: REMOVE - Remove File System Object

      '
    - contents:
      - "16.26.1.  SYNOPSIS\n     (cfh), filename -> change_info\n"
      title: 16.26.1.  SYNOPSIS
    - contents:
      - "16.26.2.  ARGUMENT\n   struct REMOVE4args {\n           /* CURRENT_FH: directory
        */\n           component4      target;\n   };\n"
      title: 16.26.2.  ARGUMENT
    - contents:
      - "16.26.3.  RESULT\n   struct REMOVE4resok {\n           change_info4    cinfo;\n
        \  };\n   union REMOVE4res switch (nfsstat4 status) {\n    case NFS4_OK:\n
        \           REMOVE4resok   resok4;\n    default:\n            void;\n   };\n"
      title: 16.26.3.  RESULT
    - contents:
      - "16.26.4.  DESCRIPTION\n   The REMOVE operation removes (deletes) a directory
        entry named by\n   filename from the directory corresponding to the current
        filehandle.\n   If the entry in the directory was the last reference to the\n
        \  corresponding file system object, the object may be destroyed.\n   For
        the directory where the filename was removed, the server returns\n   change_info4
        information in cinfo.  With the atomic field of the\n   change_info4 struct,
        the server will indicate if the before and after\n   change attributes were
        obtained atomically with respect to the\n   removal.\n   If the target is
        of zero length, NFS4ERR_INVAL will be returned.  The\n   target is also subject
        to the normal UTF-8, character support, and\n   name checks.  See Section
        12.7 for further discussion.\n   On success, the current filehandle retains
        its value.\n"
      title: 16.26.4.  DESCRIPTION
    - contents:
      - "16.26.5.  IMPLEMENTATION\n   NFSv3 required a different operator -- RMDIR
        -- for directory\n   removal, and REMOVE for non-directory removal.  This
        allowed clients\n   to skip checking the file type when being passed a non-directory\n
        \  delete system call (e.g., unlink() [unlink] in POSIX) to remove a\n   directory,
        as well as the converse (e.g., a rmdir() on a\n   non-directory), because
        they knew the server would check the file\n   type.  NFSv4 REMOVE can be used
        to delete any directory entry,\n   independent of its file type.  The implementer
        of an NFSv4 client's\n   entry points from the unlink() and rmdir() system
        calls should first\n   check the file type against the types the system call
        is allowed to\n   remove before issuing a REMOVE.  Alternatively, the implementer
        can\n   produce a COMPOUND call that includes a LOOKUP/VERIFY sequence to\n
        \  verify the file type before a REMOVE operation in the same COMPOUND\n   call.\n
        \  The concept of last reference is server specific.  However, if the\n   numlinks
        field in the previous attributes of the object had the value\n   1, the client
        should not rely on referring to the object via a\n   filehandle.  Likewise,
        the client should not rely on the resources\n   (disk space, directory entry,
        and so on) formerly associated with the\n   object becoming immediately available.
        \ Thus, if a client needs to be\n   able to continue to access a file after
        using REMOVE to remove it,\n   the client should take steps to make sure that
        the file will still be\n   accessible.  The usual mechanism used is to RENAME
        the file from its\n   old name to a new hidden name.\n   If the server finds
        that the file is still open when the REMOVE\n   arrives:\n   o  The server
        SHOULD NOT delete the file's directory entry if the\n      file was opened
        with OPEN4_SHARE_DENY_WRITE or\n      OPEN4_SHARE_DENY_BOTH.\n   o  If the
        file was not opened with OPEN4_SHARE_DENY_WRITE or\n      OPEN4_SHARE_DENY_BOTH,
        the server SHOULD delete the file's\n      directory entry.  However, until
        the last CLOSE of the file, the\n      server MAY continue to allow access
        to the file via its\n      filehandle.\n"
      title: 16.26.5.  IMPLEMENTATION
    title: '16.26.  Operation 28: REMOVE - Remove File System Object'
  - contents:
    - '16.27.  Operation 29: RENAME - Rename Directory Entry

      '
    - contents:
      - "16.27.1.  SYNOPSIS\n     (sfh), oldname, (cfh), newname -> source_cinfo,
        target_cinfo\n"
      title: 16.27.1.  SYNOPSIS
    - contents:
      - "16.27.2.  ARGUMENT\n   struct RENAME4args {\n           /* SAVED_FH: source
        directory */\n           component4      oldname;\n           /* CURRENT_FH:
        target directory */\n           component4      newname;\n   };\n"
      title: 16.27.2.  ARGUMENT
    - contents:
      - "16.27.3.  RESULT\n   struct RENAME4resok {\n           change_info4    source_cinfo;\n
        \          change_info4    target_cinfo;\n   };\n   union RENAME4res switch
        (nfsstat4 status) {\n    case NFS4_OK:\n            RENAME4resok    resok4;\n
        \   default:\n            void;\n   };\n"
      title: 16.27.3.  RESULT
    - contents:
      - "16.27.4.  DESCRIPTION\n   The RENAME operation renames the object identified
        by oldname in the\n   source directory corresponding to the saved filehandle,
        as set by the\n   SAVEFH operation, to newname in the target directory corresponding
        to\n   the current filehandle.  The operation is required to be atomic to\n
        \  the client.  Source and target directories must reside on the same\n   file
        system on the server.  On success, the current filehandle will\n   continue
        to be the target directory.\n   If the target directory already contains an
        entry with the name\n   newname, the source object must be compatible with
        the target: either\n   both are non-directories, or both are directories,
        and the target\n   must be empty.  If compatible, the existing target is removed
        before\n   the rename occurs (see Section 16.26 for client and server actions\n
        \  whenever a target is removed).  If they are not compatible or if the\n
        \  target is a directory but not empty, the server will return the error\n
        \  NFS4ERR_EXIST.\n   If oldname and newname both refer to the same file (they
        might be\n   hard links of each other), then RENAME should perform no action
        and\n   return success.\n   For both directories involved in the RENAME, the
        server returns\n   change_info4 information.  With the atomic field of the
        change_info4\n   struct, the server will indicate if the before and after
        change\n   attributes were obtained atomically with respect to the rename.\n
        \  If the oldname refers to a named attribute and the saved and current\n
        \  filehandles refer to the named attribute directories of different\n   file
        system objects, the server will return NFS4ERR_XDEV, just as if\n   the saved
        and current filehandles represented directories on\n   different file systems.\n
        \  If the oldname or newname is of zero length, NFS4ERR_INVAL will be\n   returned.
        \ The oldname and newname are also subject to the normal\n   UTF-8, character
        support, and name checks.  See Section 12.7 for\n   further discussion.\n"
      title: 16.27.4.  DESCRIPTION
    - contents:
      - "16.27.5.  IMPLEMENTATION\n   The RENAME operation must be atomic to the client.
        \ The statement\n   \"source and target directories must reside on the same
        file system on\n   the server\" means that the fsid fields in the attributes
        for the\n   directories are the same.  If they reside on different file systems,\n
        \  the error NFS4ERR_XDEV is returned.\n   Based on the value of the fh_expire_type
        attribute for the object,\n   the filehandle may or may not expire on a RENAME.
        \ However, server\n   implementers are strongly encouraged to attempt to keep
        filehandles\n   from expiring in this fashion.\n   On some servers, the filenames
        \".\" and \"..\" are illegal as either\n   oldname or newname and will result
        in the error NFS4ERR_BADNAME.  In\n   addition, on many servers the case of
        oldname or newname being an\n   alias for the source directory will be checked
        for.  Such servers\n   will return the error NFS4ERR_INVAL in these cases.\n
        \  If either of the source or target filehandles are not directories,\n   the
        server will return NFS4ERR_NOTDIR.\n"
      title: 16.27.5.  IMPLEMENTATION
    title: '16.27.  Operation 29: RENAME - Rename Directory Entry'
  - contents:
    - '16.28.  Operation 30: RENEW - Renew a Lease

      '
    - contents:
      - "16.28.1.  SYNOPSIS\n     clientid -> ()\n"
      title: 16.28.1.  SYNOPSIS
    - contents:
      - "16.28.2.  ARGUMENT\n   struct RENEW4args {\n           clientid4       clientid;\n
        \  };\n"
      title: 16.28.2.  ARGUMENT
    - contents:
      - "16.28.3.  RESULT\n   struct RENEW4res {\n           nfsstat4        status;\n
        \  };\n"
      title: 16.28.3.  RESULT
    - contents:
      - "16.28.4.  DESCRIPTION\n   The RENEW operation is used by the client to renew
        leases that it\n   currently holds at a server.  In processing the RENEW request,
        the\n   server renews all leases associated with the client.  The associated\n
        \  leases are determined by the clientid provided via the SETCLIENTID\n   operation.\n"
      title: 16.28.4.  DESCRIPTION
    - contents:
      - "16.28.5.  IMPLEMENTATION\n   When the client holds delegations, it needs
        to use RENEW to detect\n   when the server has determined that the callback
        path is down.  When\n   the server has made such a determination, only the
        RENEW operation\n   will renew the lease on delegations.  If the server determines
        the\n   callback path is down, it returns NFS4ERR_CB_PATH_DOWN.  Even though\n
        \  it returns NFS4ERR_CB_PATH_DOWN, the server MUST renew the lease on\n   the
        byte-range locks and share reservations that the client has\n   established
        on the server.  If for some reason the lock and share\n   reservation lease
        cannot be renewed, then the server MUST return an\n   error other than NFS4ERR_CB_PATH_DOWN,
        even if the callback path is\n   also down.  In the event that the server
        has conditions such that it\n   could return either NFS4ERR_CB_PATH_DOWN or
        NFS4ERR_LEASE_MOVED,\n   NFS4ERR_LEASE_MOVED MUST be handled first.\n   The
        client that issues RENEW MUST choose the principal, RPC security\n   flavor,
        and, if applicable, GSS-API mechanism and service via one of\n   the following
        algorithms:\n   o  The client uses the same principal, RPC security flavor,
        and -- if\n      the flavor was RPCSEC_GSS -- the same mechanism and service
        that\n      were used when the client ID was established via\n      SETCLIENTID_CONFIRM.\n
        \  o  The client uses any principal, RPC security flavor, mechanism, and\n
        \     service combination that currently has an OPEN file on the server.\n
        \     That is, the same principal had a successful OPEN operation; the\n      file
        is still open by that principal; and the flavor, mechanism,\n      and service
        of RENEW match that of the previous OPEN.\n   The server MUST reject a RENEW
        that does not use one of the\n   aforementioned algorithms, with the error
        NFS4ERR_ACCESS.\n"
      title: 16.28.5.  IMPLEMENTATION
    title: '16.28.  Operation 30: RENEW - Renew a Lease'
  - contents:
    - '16.29.  Operation 31: RESTOREFH - Restore Saved Filehandle

      '
    - contents:
      - "16.29.1.  SYNOPSIS\n     (sfh) -> (cfh)\n"
      title: 16.29.1.  SYNOPSIS
    - contents:
      - "16.29.2.  ARGUMENT\n     /* SAVED_FH: */\n     void;\n"
      title: 16.29.2.  ARGUMENT
    - contents:
      - "16.29.3.  RESULT\n   struct RESTOREFH4res {\n           /* CURRENT_FH: value
        of saved fh */\n           nfsstat4        status;\n   };\n"
      title: 16.29.3.  RESULT
    - contents:
      - "16.29.4.  DESCRIPTION\n   Set the current filehandle to the value in the
        saved filehandle.  If\n   there is no saved filehandle, then return the error\n
        \  NFS4ERR_RESTOREFH.\n"
      title: 16.29.4.  DESCRIPTION
    - contents:
      - "16.29.5.  IMPLEMENTATION\n   Operations like OPEN and LOOKUP use the current
        filehandle to\n   represent a directory and replace it with a new filehandle.
        \ Assuming\n   that the previous filehandle was saved with a SAVEFH operator,
        the\n   previous filehandle can be restored as the current filehandle.  This\n
        \  is commonly used to obtain post-operation attributes for the\n   directory,
        e.g.,\n     PUTFH (directory filehandle)\n     SAVEFH\n     GETATTR attrbits
        \    (pre-op dir attrs)\n     CREATE optbits \"foo\" attrs\n     GETATTR attrbits
        \    (file attributes)\n     RESTOREFH\n     GETATTR attrbits     (post-op
        dir attrs)\n"
      title: 16.29.5.  IMPLEMENTATION
    title: '16.29.  Operation 31: RESTOREFH - Restore Saved Filehandle'
  - contents:
    - '16.30.  Operation 32: SAVEFH - Save Current Filehandle

      '
    - contents:
      - "16.30.1.  SYNOPSIS\n     (cfh) -> (sfh)\n"
      title: 16.30.1.  SYNOPSIS
    - contents:
      - "16.30.2.  ARGUMENT\n     /* CURRENT_FH: */\n     void;\n"
      title: 16.30.2.  ARGUMENT
    - contents:
      - "16.30.3.  RESULT\n   struct SAVEFH4res {\n           /* SAVED_FH: value of
        current fh */\n           nfsstat4        status;\n   };\n"
      title: 16.30.3.  RESULT
    - contents:
      - "16.30.4.  DESCRIPTION\n   Save the current filehandle.  If a previous filehandle
        was saved,\n   then it is no longer accessible.  The saved filehandle can
        be\n   restored as the current filehandle with the RESTOREFH operator.\n   On
        success, the current filehandle retains its value.\n"
      title: 16.30.4.  DESCRIPTION
    - contents:
      - '16.30.5.  IMPLEMENTATION

        '
      title: 16.30.5.  IMPLEMENTATION
    title: '16.30.  Operation 32: SAVEFH - Save Current Filehandle'
  - contents:
    - '16.31.  Operation 33: SECINFO - Obtain Available Security

      '
    - contents:
      - "16.31.1.  SYNOPSIS\n     (cfh), name -> { secinfo }\n"
      title: 16.31.1.  SYNOPSIS
    - contents:
      - "16.31.2.  ARGUMENT\n   struct SECINFO4args {\n           /* CURRENT_FH: directory
        */\n           component4      name;\n   };\n"
      title: 16.31.2.  ARGUMENT
    - contents:
      - "16.31.3.  RESULT\n   /*\n    * From RFC 2203\n    */\n   enum rpc_gss_svc_t
        {\n           RPC_GSS_SVC_NONE        = 1,\n           RPC_GSS_SVC_INTEGRITY
        \  = 2,\n           RPC_GSS_SVC_PRIVACY     = 3\n   };\n   struct rpcsec_gss_info
        {\n           sec_oid4        oid;\n           qop4            qop;\n           rpc_gss_svc_t
        \  service;\n   };\n   /* RPCSEC_GSS has a value of '6'.  See RFC 2203 */\n
        \  union secinfo4 switch (uint32_t flavor) {\n    case RPCSEC_GSS:\n            rpcsec_gss_info
        \       flavor_info;\n    default:\n            void;\n   };\n   typedef secinfo4
        SECINFO4resok<>;\n   union SECINFO4res switch (nfsstat4 status) {\n    case
        NFS4_OK:\n            SECINFO4resok resok4;\n    default:\n            void;\n
        \  };\n"
      title: 16.31.3.  RESULT
    - contents:
      - "16.31.4.  DESCRIPTION\n   The SECINFO operation is used by the client to
        obtain a list of valid\n   RPC authentication flavors for a specific directory
        filehandle,\n   filename pair.  SECINFO should apply the same access methodology
        used\n   for LOOKUP when evaluating the name.  Therefore, if the requester\n
        \  does not have the appropriate access to perform a LOOKUP for the\n   name,
        then SECINFO must behave the same way and return\n   NFS4ERR_ACCESS.\n   The
        result will contain an array that represents the security\n   mechanisms available,
        with an order corresponding to the server's\n   preferences, the most preferred
        being first in the array.  The client\n   is free to pick whatever security
        mechanism it both desires and\n   supports, or to pick -- in the server's
        preference order -- the first\n   one it supports.  The array entries are
        represented by the secinfo4\n   structure.  The field 'flavor' will contain
        a value of AUTH_NONE,\n   AUTH_SYS (as defined in [RFC5531]), or RPCSEC_GSS
        (as defined in\n   [RFC2203]).\n   For the flavors AUTH_NONE and AUTH_SYS,
        no additional security\n   information is returned.  For a return value of
        RPCSEC_GSS, a\n   security triple is returned that contains the mechanism
        object id (as\n   defined in [RFC2743]), the quality of protection (as defined
        in\n   [RFC2743]), and the service type (as defined in [RFC2203]).  It is\n
        \  possible for SECINFO to return multiple entries with flavor equal to\n
        \  RPCSEC_GSS, with different security triple values.\n   On success, the
        current filehandle retains its value.\n   If the name has a length of 0 (zero),
        or if the name does not obey\n   the UTF-8 definition, the error NFS4ERR_INVAL
        will be returned.\n"
      title: 16.31.4.  DESCRIPTION
    - contents:
      - "16.31.5.  IMPLEMENTATION\n   The SECINFO operation is expected to be used
        by the NFS client when\n   the error value of NFS4ERR_WRONGSEC is returned
        from another NFS\n   operation.  This signifies to the client that the server's
        security\n   policy is different from what the client is currently using.
        \ At this\n   point, the client is expected to obtain a list of possible security\n
        \  flavors and choose what best suits its policies.\n   As mentioned, the
        server's security policies will determine when a\n   client request receives
        NFS4ERR_WRONGSEC.  The operations that may\n   receive this error are LINK,
        LOOKUP, LOOKUPP, OPEN, PUTFH, PUTPUBFH,\n   PUTROOTFH, RENAME, RESTOREFH,
        and, indirectly, READDIR.  LINK and\n   RENAME will only receive this error
        if the security used for the\n   operation is inappropriate for the saved
        filehandle.  With the\n   exception of READDIR, these operations represent
        the point at which\n   the client can instantiate a filehandle into the current
        filehandle\n   at the server.  The filehandle is either provided by the client\n
        \  (PUTFH, PUTPUBFH, PUTROOTFH) or generated as a result of a name-to-\n   filehandle
        translation (LOOKUP and OPEN).  RESTOREFH is different\n   because the filehandle
        is a result of a previous SAVEFH.  Even though\n   the filehandle, for RESTOREFH,
        might have previously passed the\n   server's inspection for a security match,
        the server will check it\n   again on RESTOREFH to ensure that the security
        policy has not\n   changed.\n   If the client wants to resolve an error return
        of NFS4ERR_WRONGSEC,\n   the following will occur:\n   o  For LOOKUP and OPEN,
        the client will use SECINFO with the same\n      current filehandle and name
        as provided in the original LOOKUP or\n      OPEN to enumerate the available
        security triples.\n   o  For LINK, PUTFH, RENAME, and RESTOREFH, the client
        will use\n      SECINFO and provide the parent directory filehandle and the
        object\n      name that corresponds to the filehandle originally provided
        by the\n      PUTFH or RESTOREFH, or, for LINK and RENAME, the SAVEFH.\n   o
        \ For LOOKUPP, PUTROOTFH, and PUTPUBFH, the client will be unable to\n      use
        the SECINFO operation since SECINFO requires a current\n      filehandle and
        none exist for these three operations.  Therefore,\n      the client must
        iterate through the security triples available at\n      the client and re-attempt
        the PUTROOTFH or PUTPUBFH operation.  In\n      the unfortunate event that
        none of the MANDATORY security triples\n      are supported by the client
        and server, the client SHOULD try\n      using others that support integrity.
        \ Failing that, the client can\n      try using AUTH_NONE, but because such
        forms lack integrity checks,\n      this puts the client at risk.  Nonetheless,
        the server SHOULD\n      allow the client to use whatever security form the
        client requests\n      and the server supports, since the risks of doing so
        are on the\n      client.\n   The READDIR operation will not directly return
        the NFS4ERR_WRONGSEC\n   error.  However, if the READDIR request included
        a request for\n   attributes, it is possible that the READDIR request's security
        triple\n   does not match that of a directory entry.  If this is the case
        and\n   the client has requested the rdattr_error attribute, the server will\n
        \  return the NFS4ERR_WRONGSEC error in rdattr_error for the entry.\n   Note
        that a server MAY use the AUTH_NONE flavor to signify that the\n   client
        is allowed to attempt to use authentication flavors that are\n   not explicitly
        listed in the SECINFO results.  Instead of using a\n   listed flavor, the
        client might then, for instance, opt to use an\n   otherwise unlisted RPCSEC_GSS
        mechanism instead of AUTH_NONE.  It may\n   wish to do so in order to meet
        an application requirement for data\n   integrity or privacy.  In choosing
        to use an unlisted flavor, the\n   client SHOULD always be prepared to handle
        a failure by falling back\n   to using AUTH_NONE or another listed flavor.
        \ It cannot assume that\n   identity mapping is supported and should be prepared
        for the fact\n   that its identity is squashed.\n   See Section 19 for a discussion
        on the recommendations for security\n   flavors used by SECINFO.\n"
      title: 16.31.5.  IMPLEMENTATION
    title: '16.31.  Operation 33: SECINFO - Obtain Available Security'
  - contents:
    - '16.32.  Operation 34: SETATTR - Set Attributes

      '
    - contents:
      - "16.32.1.  SYNOPSIS\n     (cfh), stateid, attrmask, attr_vals -> attrsset\n"
      title: 16.32.1.  SYNOPSIS
    - contents:
      - "16.32.2.  ARGUMENT\n   struct SETATTR4args {\n           /* CURRENT_FH: target
        object */\n           stateid4        stateid;\n           fattr4          obj_attributes;\n
        \  };\n"
      title: 16.32.2.  ARGUMENT
    - contents:
      - "16.32.3.  RESULT\n   struct SETATTR4res {\n           nfsstat4        status;\n
        \          bitmap4         attrsset;\n   };\n"
      title: 16.32.3.  RESULT
    - contents:
      - "16.32.4.  DESCRIPTION\n   The SETATTR operation changes one or more of the
        attributes of a file\n   system object.  The new attributes are specified
        with a bitmap and\n   the attributes that follow the bitmap in bit order.\n
        \  The stateid argument for SETATTR is used to provide byte-range\n   locking
        context that is necessary for SETATTR requests that set the\n   size attribute.
        \ Since setting the size attribute modifies the file's\n   data, it has the
        same locking requirements as a corresponding WRITE.\n   Any SETATTR that sets
        the size attribute is incompatible with a share\n   reservation that specifies
        OPEN4_SHARE_DENY_WRITE.  The area between\n   the old end-of-file and the
        new end-of-file is considered to be\n   modified just as would have been the
        case had the area in question\n   been specified as the target of WRITE, for
        the purpose of checking\n   conflicts with byte-range locks, for those cases
        in which a server is\n   implementing mandatory byte-range locking behavior.
        \ A valid stateid\n   SHOULD always be specified.  When the file size attribute
        is not set,\n   the special anonymous stateid MAY be passed.\n   On either
        success or failure of the operation, the server will return\n   the attrsset
        bitmask to represent what (if any) attributes were\n   successfully set.  The
        attrsset in the response is a subset of the\n   bitmap4 that is part of the
        obj_attributes in the argument.\n   On success, the current filehandle retains
        its value.\n"
      title: 16.32.4.  DESCRIPTION
    - contents:
      - "16.32.5.  IMPLEMENTATION\n   If the request specifies the owner attribute
        to be set, the server\n   SHOULD allow the operation to succeed if the current
        owner of the\n   object matches the value specified in the request.  Some
        servers may\n   be implemented in such a way as to prohibit the setting of
        the owner\n   attribute unless the requester has the privilege to do so.  If
        the\n   server is lenient in this one case of matching owner values, the\n
        \  client implementation may be simplified in cases of creation of an\n   object
        (e.g., an exclusive create via OPEN) followed by a SETATTR.\n   The file size
        attribute is used to request changes to the size of a\n   file.  A value of
        zero causes the file to be truncated, a value less\n   than the current size
        of the file causes data from the new size to\n   the end of the file to be
        discarded, and a size greater than the\n   current size of the file causes
        logically zeroed data bytes to be\n   added to the end of the file.  Servers
        are free to implement this\n   using holes or actual zero data bytes.  Clients
        should not make any\n   assumptions regarding a server's implementation of
        this feature,\n   beyond that the bytes returned will be zeroed.  Servers
        MUST support\n   extending the file size via SETATTR.\n   SETATTR is not guaranteed
        atomic.  A failed SETATTR may partially\n   change a file's attributes --
        hence, the reason why the reply always\n   includes the status and the list
        of attributes that were set.\n   If the object whose attributes are being
        changed has a file\n   delegation that is held by a client other than the
        one doing the\n   SETATTR, the delegation(s) must be recalled, and the operation
        cannot\n   proceed to actually change an attribute until each such delegation
        is\n   returned or revoked.  In all cases in which delegations are recalled,\n
        \  the server is likely to return one or more NFS4ERR_DELAY errors while\n
        \  the delegation(s) remains outstanding, although it might not do that\n
        \  if the delegations are returned quickly.\n   Changing the size of a file
        with SETATTR indirectly changes the\n   time_modify and change attributes.
        \ A client must account for this,\n   as size changes can result in data deletion.\n
        \  The attributes time_access_set and time_modify_set are write-only\n   attributes
        constructed as a switched union so the client can direct\n   the server in
        setting the time values.  If the switched union\n   specifies SET_TO_CLIENT_TIME4,
        the client has provided an nfstime4 to\n   be used for the operation.  If
        the switch union does not specify\n   SET_TO_CLIENT_TIME4, the server is to
        use its current time for the\n   SETATTR operation.\n   If server and client
        times differ, programs that compare client times\n   to file times can break.
        \ A time maintenance protocol should be used\n   to limit client/server time
        skew.\n   Use of a COMPOUND containing a VERIFY operation specifying only
        the\n   change attribute, immediately followed by a SETATTR, provides a means\n
        \  whereby a client may specify a request that emulates the\n   functionality
        of the SETATTR guard mechanism of NFSv3.  Since the\n   function of the guard
        mechanism is to avoid changes to the file\n   attributes based on stale information,
        delays between checking of the\n   guard condition and the setting of the
        attributes have the potential\n   to compromise this function, as would the
        corresponding delay in the\n   NFSv4 emulation.  Therefore, NFSv4 servers
        should take care to avoid\n   such delays, to the degree possible, when executing
        such a request.\n   If the server does not support an attribute as requested
        by the\n   client, the server should return NFS4ERR_ATTRNOTSUPP.\n   A mask
        of the attributes actually set is returned by SETATTR in all\n   cases.  That
        mask MUST NOT include attribute bits not requested to be\n   set by the client.
        \ If the attribute masks in the request and reply\n   are equal, the status
        field in the reply MUST be NFS4_OK.\n"
      title: 16.32.5.  IMPLEMENTATION
    title: '16.32.  Operation 34: SETATTR - Set Attributes'
  - contents:
    - '16.33.  Operation 35: SETCLIENTID - Negotiate Client ID

      '
    - contents:
      - "16.33.1.  SYNOPSIS\n     client, callback, callback_ident -> clientid, setclientid_confirm\n"
      title: 16.33.1.  SYNOPSIS
    - contents:
      - "16.33.2.  ARGUMENT\n   struct SETCLIENTID4args {\n           nfs_client_id4
        \ client;\n           cb_client4      callback;\n           uint32_t        callback_ident;\n
        \  };\n"
      title: 16.33.2.  ARGUMENT
    - contents:
      - "16.33.3.  RESULT\n   struct SETCLIENTID4resok {\n           clientid4       clientid;\n
        \          verifier4       setclientid_confirm;\n   };\n   union SETCLIENTID4res
        switch (nfsstat4 status) {\n    case NFS4_OK:\n            SETCLIENTID4resok
        \     resok4;\n    case NFS4ERR_CLID_INUSE:\n            clientaddr4    client_using;\n
        \   default:\n            void;\n   };\n"
      title: 16.33.3.  RESULT
    - contents:
      - "16.33.4.  DESCRIPTION\n   The client uses the SETCLIENTID operation to notify
        the server of its\n   intention to use a particular client identifier, callback,
        and\n   callback_ident for subsequent requests that entail creating lock,\n
        \  share reservation, and delegation state on the server.  Upon\n   successful
        completion the server will return a shorthand client ID\n   that, if confirmed
        via a separate step, will be used in subsequent\n   file locking and file
        open requests.  Confirmation of the client ID\n   must be done via the SETCLIENTID_CONFIRM
        operation to return the\n   client ID and setclientid_confirm values, as verifiers,
        to the\n   server.  Two verifiers are necessary because it is possible to
        use\n   SETCLIENTID and SETCLIENTID_CONFIRM to modify the callback and\n   callback_ident
        information but not the shorthand client ID.  In that\n   event, the setclientid_confirm
        value is effectively the only\n   verifier.\n   The callback information provided
        in this operation will be used if\n   the client is provided an open delegation
        at a future point.\n   Therefore, the client must correctly reflect the program
        and port\n   numbers for the callback program at the time SETCLIENTID is used.\n
        \  The callback_ident value is used by the server on the callback.  The\n
        \  client can leverage the callback_ident to eliminate the need for more\n
        \  than one callback RPC program number, while still being able to\n   determine
        which server is initiating the callback.\n"
      title: 16.33.4.  DESCRIPTION
    - contents:
      - "16.33.5.  IMPLEMENTATION\n   To understand how to implement SETCLIENTID,
        make the following\n   notations.  Let:\n   x  be the value of the client.id
        subfield of the SETCLIENTID4args\n      structure.\n   v  be the value of
        the client.verifier subfield of the\n      SETCLIENTID4args structure.\n   c
        \ be the value of the client ID field returned in the\n      SETCLIENTID4resok
        structure.\n   k  represent the value combination of the callback and callback_ident\n
        \     fields of the SETCLIENTID4args structure.\n   s  be the setclientid_confirm
        value returned in the SETCLIENTID4resok\n      structure.\n   { v, x, c, k,
        s }  be a quintuple for a client record.  A client\n      record is confirmed
        if there has been a SETCLIENTID_CONFIRM\n      operation to confirm it.  Otherwise,
        it is unconfirmed.  An\n      unconfirmed record is established by a SETCLIENTID
        call.\n   Since SETCLIENTID is a non-idempotent operation, let us assume that\n
        \  the server is implementing the duplicate request cache (DRC).\n   When
        the server gets a SETCLIENTID { v, x, k } request, it processes\n   it in
        the following manner.\n   o  It first looks up the request in the DRC.  If
        there is a hit, it\n      returns the result cached in the DRC.  The server
        does NOT remove\n      client state (locks, shares, delegations), nor does
        it modify any\n      recorded callback and callback_ident information for
        client { x }.\n      For any DRC miss, the server takes the client ID string
        x, and\n      searches for client records for x that the server may have\n
        \     recorded from previous SETCLIENTID calls.  For any confirmed\n      record
        with the same id string x, if the recorded principal does\n      not match
        that of the SETCLIENTID call, then the server returns an\n      NFS4ERR_CLID_INUSE
        error.\n      For brevity of discussion, the remaining description of the\n
        \     processing assumes that there was a DRC miss, and that where the\n      server
        has previously recorded a confirmed record for client x,\n      the aforementioned
        principal check has successfully passed.\n   o  The server checks if it has
        recorded a confirmed record for { v,\n      x, c, l, s }, where l may or may
        not equal k.  If so, and since\n      the id verifier v of the request matches
        that which is confirmed\n      and recorded, the server treats this as a probable
        callback\n      information update and records an unconfirmed { v, x, c, k,
        t }\n      and leaves the confirmed { v, x, c, l, s } in place, such that\n
        \     t != s.  It does not matter whether k equals l or not.  Any\n      pre-existing
        unconfirmed { v, x, c, *, * } is removed.\n      The server returns { c, t
        }.  It is indeed returning the old\n      clientid4 value c, because the client
        apparently only wants to\n      update callback value k to value l.  It's
        possible this request is\n      one from the Byzantine router that has stale
        callback information,\n      but this is not a problem.  The callback information
        update is\n      only confirmed if followed up by a SETCLIENTID_CONFIRM {
        c, t }.\n      The server awaits confirmation of k via SETCLIENTID_CONFIRM\n
        \     { c, t }.\n      The server does NOT remove client (lock/share/delegation)
        state\n      for x.\n   o  The server has previously recorded a confirmed
        { u, x, c, l, s }\n      record such that v != u, l may or may not equal k,
        and has not\n      recorded any unconfirmed { *, x, *, *, * } record for x.
        \ The\n      server records an unconfirmed { v, x, d, k, t } (d != c, t !=
        s).\n      The server returns { d, t }.\n      The server awaits confirmation
        of { d, k } via SETCLIENTID_CONFIRM\n      { d, t }.\n      The server does
        NOT remove client (lock/share/delegation) state\n      for x.\n   o  The server
        has previously recorded a confirmed { u, x, c, l, s }\n      record such that
        v != u, l may or may not equal k, and recorded an\n      unconfirmed { w,
        x, d, m, t } record such that c != d, t != s, m\n      may or may not equal
        k, m may or may not equal l, and k may or may\n      not equal l.  Whether
        w == v or w != v makes no difference.  The\n      server simply removes the
        unconfirmed { w, x, d, m, t } record and\n      replaces it with an unconfirmed
        { v, x, e, k, r } record, such\n      that e != d, e != c, r != t, r != s.\n
        \     The server returns { e, r }.\n      The server awaits confirmation of
        { e, k } via SETCLIENTID_CONFIRM\n      { e, r }.\n      The server does NOT
        remove client (lock/share/delegation) state\n      for x.\n   o  The server
        has no confirmed { *, x, *, *, * } for x.  It may or\n      may not have recorded
        an unconfirmed { u, x, c, l, s }, where l\n      may or may not equal k, and
        u may or may not equal v.  Any\n      unconfirmed record { u, x, c, l, * },
        regardless of whether u == v\n      or l == k, is replaced with an unconfirmed
        record { v, x, d, k, t\n      } where d != c, t != s.\n      The server returns
        { d, t }.\n      The server awaits confirmation of { d, k } via SETCLIENTID_CONFIRM\n
        \     { d, t }.  The server does NOT remove client (lock/share/\n      delegation)
        state for x.\n   The server generates the clientid and setclientid_confirm
        values and\n   must take care to ensure that these values are extremely unlikely
        to\n   ever be regenerated.\n"
      title: 16.33.5.  IMPLEMENTATION
    title: '16.33.  Operation 35: SETCLIENTID - Negotiate Client ID'
  - contents:
    - '16.34.  Operation 36: SETCLIENTID_CONFIRM - Confirm Client ID

      '
    - contents:
      - "16.34.1.  SYNOPSIS\n     clientid, setclientid_confirm -> -\n"
      title: 16.34.1.  SYNOPSIS
    - contents:
      - "16.34.2.  ARGUMENT\n   struct SETCLIENTID_CONFIRM4args {\n           clientid4
        \      clientid;\n           verifier4       setclientid_confirm;\n   };\n"
      title: 16.34.2.  ARGUMENT
    - contents:
      - "16.34.3.  RESULT\n   struct SETCLIENTID_CONFIRM4res {\n           nfsstat4
        \       status;\n   };\n"
      title: 16.34.3.  RESULT
    - contents:
      - "16.34.4.  DESCRIPTION\n   This operation is used by the client to confirm
        the results from a\n   previous call to SETCLIENTID.  The client provides
        the server-\n   supplied (from a SETCLIENTID response) client ID.  The server\n
        \  responds with a simple status of success or failure.\n"
      title: 16.34.4.  DESCRIPTION
    - contents:
      - "16.34.5.  IMPLEMENTATION\n   The client must use the SETCLIENTID_CONFIRM
        operation to confirm the\n   following two distinct cases:\n   o  The client's
        use of a new shorthand client identifier (as returned\n      from the server
        in the response to SETCLIENTID), a new callback\n      value (as specified
        in the arguments to SETCLIENTID), and a new\n      callback_ident value (as
        specified in the arguments to\n      SETCLIENTID).  The client's use of SETCLIENTID_CONFIRM
        in this\n      case also confirms the removal of any of the client's previous\n
        \     relevant leased state.  Relevant leased client state includes\n      byte-range
        locks, share reservations, and -- where the server does\n      not support
        the CLAIM_DELEGATE_PREV claim type -- delegations.  If\n      the server supports
        CLAIM_DELEGATE_PREV, then SETCLIENTID_CONFIRM\n      MUST NOT remove delegations
        for this client; relevant leased\n      client state would then just include
        byte-range locks and share\n      reservations.\n   o  The client's reuse
        of an old, previously confirmed shorthand\n      client identifier; a new
        callback value; and a new callback_ident\n      value.  The client's use of
        SETCLIENTID_CONFIRM in this case MUST\n      NOT result in the removal of
        any previous leased state (locks,\n      share reservations, and delegations).\n
        \  We use the same notation and definitions for v, x, c, k, s, and\n   unconfirmed
        and confirmed client records as introduced in the\n   description of the SETCLIENTID
        operation.  The arguments to\n   SETCLIENTID_CONFIRM are indicated by the
        notation { c, s }, where c\n   is a value of type clientid4, and s is a value
        of type verifier4\n   corresponding to the setclientid_confirm field.\n   As
        with SETCLIENTID, SETCLIENTID_CONFIRM is a non-idempotent\n   operation, and
        we assume that the server is implementing the\n   duplicate request cache
        (DRC).\n   When the server gets a SETCLIENTID_CONFIRM { c, s } request, it\n
        \  processes it in the following manner.\n   o  It first looks up the request
        in the DRC.  If there is a hit, it\n      returns the result cached in the
        DRC.  The server does not remove\n      any relevant leased client state,
        nor does it modify any recorded\n      callback and callback_ident information
        for client { x } as\n      represented by the shorthand value c.\n   For a
        DRC miss, the server checks for client records that match the\n   shorthand
        value c.  The processing cases are as follows:\n   o  The server has recorded
        an unconfirmed { v, x, c, k, s } record\n      and a confirmed { v, x, c,
        l, t } record, such that s != t.  If\n      the principals of the records
        do not match that of the\n      SETCLIENTID_CONFIRM, the server returns NFS4ERR_CLID_INUSE,
        and no\n      relevant leased client state is removed and no recorded callback\n
        \     and callback_ident information for client { x } is changed.\n      Otherwise,
        the confirmed { v, x, c, l, t } record is removed and\n      the unconfirmed
        { v, x, c, k, s } is marked as confirmed, thereby\n      modifying recorded
        and confirmed callback and callback_ident\n      information for client {
        x }.\n      The server does not remove any relevant leased client state.\n
        \     The server returns NFS4_OK.\n   o  The server has not recorded an unconfirmed
        { v, x, c, *, * } and\n      has recorded a confirmed { v, x, c, *, s }.  If
        the principals of\n      the record and of SETCLIENTID_CONFIRM do not match,
        the server\n      returns NFS4ERR_CLID_INUSE without removing any relevant
        leased\n      client state, and without changing recorded callback and\n      callback_ident
        values for client { x }.\n      If the principals match, then what has likely
        happened is that the\n      client never got the response from the SETCLIENTID_CONFIRM,
        and\n      the DRC entry has been purged.  Whatever the scenario, since the\n
        \     principals match, as well as { c, s } matching a confirmed record,\n
        \     the server leaves client x's relevant leased client state intact,\n
        \     leaves its callback and callback_ident values unmodified, and\n      returns
        NFS4_OK.\n   o  The server has not recorded a confirmed { *, *, c, *, * }
        and has\n      recorded an unconfirmed { *, x, c, k, s }.  Even if this is
        a\n      retry from the client, nonetheless the client's first\n      SETCLIENTID_CONFIRM
        attempt was not received by the server.  Retry\n      or not, the server doesn't
        know, but it processes it as if it were\n      a first try.  If the principal
        of the unconfirmed { *, x, c, k, s\n      } record mismatches that of the
        SETCLIENTID_CONFIRM request, the\n      server returns NFS4ERR_CLID_INUSE
        without removing any relevant\n      leased client state.\n      Otherwise,
        the server records a confirmed { *, x, c, k, s }.  If\n      there is also
        a confirmed { *, x, d, *, t }, the server MUST\n      remove client x's relevant
        leased client state and overwrite the\n      callback state with k.  The confirmed
        record { *, x, d, *, t } is\n      removed.\n      The server returns NFS4_OK.\n
        \  o  The server has no record of a confirmed or unconfirmed { *, *, c,\n
        \     *, s }.  The server returns NFS4ERR_STALE_CLIENTID.  The server\n      does
        not remove any relevant leased client state, nor does it\n      modify any
        recorded callback and callback_ident information for\n      any client.\n
        \  The server needs to cache unconfirmed { v, x, c, k, s } client\n   records
        and await for some time their confirmation.  As should be\n   clear from the
        discussions of record processing for SETCLIENTID and\n   SETCLIENTID_CONFIRM,
        there are cases where the server does not\n   deterministically remove unconfirmed
        client records.  To avoid\n   running out of resources, the server is not
        required to hold\n   unconfirmed records indefinitely.  One strategy the server
        might use\n   is to set a limit on how many unconfirmed client records it
        will\n   maintain and then, when the limit would be exceeded, remove the\n
        \  oldest record.  Another strategy might be to remove an unconfirmed\n   record
        when some amount of time has elapsed.  The choice of the\n   amount of time
        is fairly arbitrary, but it is surely no higher than\n   the server's lease
        time period.  Consider that leases need to be\n   renewed before the lease
        time expires via an operation from the\n   client.  If the client cannot issue
        a SETCLIENTID_CONFIRM after a\n   SETCLIENTID before a period of time equal
        to a lease expiration time,\n   then the client is unlikely to be able to
        maintain state on the\n   server during steady-state operation.\n   If the
        client does send a SETCLIENTID_CONFIRM for an unconfirmed\n   record that
        the server has already deleted, the client will get\n   NFS4ERR_STALE_CLIENTID
        back.  If so, the client should then start\n   over, and send SETCLIENTID
        to re-establish an unconfirmed client\n   record and get back an unconfirmed
        client ID and setclientid_confirm\n   verifier.  The client should then send
        the SETCLIENTID_CONFIRM to\n   confirm the client ID.\n   SETCLIENTID_CONFIRM
        does not establish or renew a lease.  However, if\n   SETCLIENTID_CONFIRM
        removes relevant leased client state, and that\n   state does not include
        existing delegations, the server MUST allow\n   the client a period of time
        no less than the value of the lease_time\n   attribute, to reclaim (via the
        CLAIM_DELEGATE_PREV claim type of the\n   OPEN operation) its delegations
        before removing unreclaimed\n   delegations.\n"
      title: 16.34.5.  IMPLEMENTATION
    title: '16.34.  Operation 36: SETCLIENTID_CONFIRM - Confirm Client ID'
  - contents:
    - '16.35.  Operation 37: VERIFY - Verify Same Attributes

      '
    - contents:
      - "16.35.1.  SYNOPSIS\n     (cfh), fattr -> -\n"
      title: 16.35.1.  SYNOPSIS
    - contents:
      - "16.35.2.  ARGUMENT\n   struct VERIFY4args {\n           /* CURRENT_FH: object
        */\n           fattr4          obj_attributes;\n   };\n"
      title: 16.35.2.  ARGUMENT
    - contents:
      - "16.35.3.  RESULT\n   struct VERIFY4res {\n           nfsstat4        status;\n
        \  };\n"
      title: 16.35.3.  RESULT
    - contents:
      - "16.35.4.  DESCRIPTION\n   The VERIFY operation is used to verify that attributes
        have a value\n   assumed by the client before proceeding with subsequent operations
        in\n   the COMPOUND request.  If any of the attributes do not match, then\n
        \  the error NFS4ERR_NOT_SAME must be returned.  The current filehandle\n
        \  retains its value after successful completion of the operation.\n"
      title: 16.35.4.  DESCRIPTION
    - contents:
      - "16.35.5.  IMPLEMENTATION\n   One possible use of the VERIFY operation is
        the following COMPOUND\n   sequence.  With this, the client is attempting
        to verify that the\n   file being removed will match what the client expects
        to be removed.\n   This sequence can help prevent the unintended deletion
        of a file.\n     PUTFH (directory filehandle)\n     LOOKUP (filename)\n     VERIFY
        (filehandle == fh)\n     PUTFH (directory filehandle)\n     REMOVE (filename)\n
        \  This sequence does not prevent a second client from removing and\n   creating
        a new file in the middle of this sequence, but it does help\n   avoid the
        unintended result.\n   In the case that a RECOMMENDED attribute is specified
        in the VERIFY\n   operation and the server does not support that attribute
        for the file\n   system object, the error NFS4ERR_ATTRNOTSUPP is returned
        to the\n   client.\n   When the attribute rdattr_error or any write-only attribute
        (e.g.,\n   time_modify_set) is specified, the error NFS4ERR_INVAL is returned
        to\n   the client.\n"
      title: 16.35.5.  IMPLEMENTATION
    title: '16.35.  Operation 37: VERIFY - Verify Same Attributes'
  - contents:
    - '16.36.  Operation 38: WRITE - Write to File

      '
    - contents:
      - "16.36.1.  SYNOPSIS\n     (cfh), stateid, offset, stable, data -> count, committed,
        writeverf\n"
      title: 16.36.1.  SYNOPSIS
    - contents:
      - "16.36.2.  ARGUMENT\n   enum stable_how4 {\n           UNSTABLE4       = 0,\n
        \          DATA_SYNC4      = 1,\n           FILE_SYNC4      = 2\n   };\n   struct
        WRITE4args {\n           /* CURRENT_FH: file */\n           stateid4        stateid;\n
        \          offset4         offset;\n           stable_how4     stable;\n           opaque
        \         data<>;\n   };\n"
      title: 16.36.2.  ARGUMENT
    - contents:
      - "16.36.3.  RESULT\n   struct WRITE4resok {\n           count4          count;\n
        \          stable_how4     committed;\n           verifier4       writeverf;\n
        \  };\n   union WRITE4res switch (nfsstat4 status) {\n    case NFS4_OK:\n
        \           WRITE4resok    resok4;\n    default:\n            void;\n   };\n"
      title: 16.36.3.  RESULT
    - contents:
      - "16.36.4.  DESCRIPTION\n   The WRITE operation is used to write data to a
        regular file.  The\n   target file is specified by the current filehandle.
        \ The offset\n   specifies the offset where the data should be written.  An
        offset of\n   0 (zero) specifies that the write should start at the beginning
        of\n   the file.  The count, as encoded as part of the opaque data\n   parameter,
        represents the number of bytes of data that are to be\n   written.  If the
        count is 0 (zero), the WRITE will succeed and return\n   a count of 0 (zero)
        subject to permissions checking.  The server may\n   choose to write fewer
        bytes than requested by the client.\n   Part of the WRITE request is a specification
        of how the WRITE is to\n   be performed.  The client specifies with the stable
        parameter the\n   method of how the data is to be processed by the server.
        \ If stable\n   is FILE_SYNC4, the server must commit the data written plus
        all file\n   system metadata to stable storage before returning results.  This\n
        \  corresponds to the NFSv2 protocol semantics.  Any other behavior\n   constitutes
        a protocol violation.  If stable is DATA_SYNC4, then the\n   server must commit
        all of the data to stable storage and enough of\n   the metadata to retrieve
        the data before returning.  The server\n   implementer is free to implement
        DATA_SYNC4 in the same fashion as\n   FILE_SYNC4, but with a possible performance
        drop.  If stable is\n   UNSTABLE4, the server is free to commit any part of
        the data and the\n   metadata to stable storage, including all or none, before
        returning a\n   reply to the client.  There is no guarantee whether or when
        any\n   uncommitted data will subsequently be committed to stable storage.\n
        \  The only guarantees made by the server are that it will not destroy\n   any
        data without changing the value of verf and that it will not\n   commit the
        data and metadata at a level less than that requested by\n   the client.\n
        \  The stateid value for a WRITE request represents a value returned\n   from
        a previous byte-range lock or share reservation request or the\n   stateid
        associated with a delegation.  The stateid is used by the\n   server to verify
        that the associated share reservation and any\n   byte-range locks are still
        valid and to update lease timeouts for the\n   client.\n   Upon successful
        completion, the following results are returned.  The\n   count result is the
        number of bytes of data written to the file.  The\n   server may write fewer
        bytes than requested.  If so, the actual\n   number of bytes written starting
        at location, offset, is returned.\n   The server also returns an indication
        of the level of commitment of\n   the data and metadata via committed.  If
        the server committed all\n   data and metadata to stable storage, committed
        should be set to\n   FILE_SYNC4.  If the level of commitment was at least
        as strong as\n   DATA_SYNC4, then committed should be set to DATA_SYNC4.  Otherwise,\n
        \  committed must be returned as UNSTABLE4.  If stable was FILE4_SYNC,\n   then
        committed must also be FILE_SYNC4: anything else constitutes a\n   protocol
        violation.  If stable was DATA_SYNC4, then committed may be\n   FILE_SYNC4
        or DATA_SYNC4: anything else constitutes a protocol\n   violation.  If stable
        was UNSTABLE4, then committed may be either\n   FILE_SYNC4, DATA_SYNC4, or
        UNSTABLE4.\n   The final portion of the result is the write verifier.  The
        write\n   verifier is a cookie that the client can use to determine whether
        the\n   server has changed instance (boot) state between a call to WRITE and\n
        \  a subsequent call to either WRITE or COMMIT.  This cookie must be\n   consistent
        during a single instance of the NFSv4 protocol service and\n   must be unique
        between instances of the NFSv4 protocol server, where\n   uncommitted data
        may be lost.\n   If a client writes data to the server with the stable argument
        set to\n   UNSTABLE4 and the reply yields a committed response of DATA_SYNC4
        or\n   UNSTABLE4, the client will follow up at some time in the future with\n
        \  a COMMIT operation to synchronize outstanding asynchronous data and\n   metadata
        with the server's stable storage, barring client error.  It\n   is possible
        that due to client crash or other error a subsequent\n   COMMIT will not be
        received by the server.\n   For a WRITE using the special anonymous stateid,
        the server MAY allow\n   the WRITE to be serviced subject to mandatory file
        locks or the\n   current share deny modes for the file.  For a WRITE using
        the special\n   READ bypass stateid, the server MUST NOT allow the WRITE operation
        to\n   bypass locking checks at the server, and the WRITE is treated exactly\n
        \  the same as if the anonymous stateid were used.\n   On success, the current
        filehandle retains its value.\n"
      title: 16.36.4.  DESCRIPTION
    - contents:
      - "16.36.5.  IMPLEMENTATION\n   It is possible for the server to write fewer
        bytes of data than\n   requested by the client.  In this case, the server
        should not return\n   an error unless no data was written at all.  If the
        server writes\n   less than the number of bytes specified, the client should
        issue\n   another WRITE to write the remaining data.\n   It is assumed that
        the act of writing data to a file will cause the\n   time_modify attribute
        of the file to be updated.  However, the\n   time_modify attribute of the
        file should not be changed unless the\n   contents of the file are changed.
        \ Thus, a WRITE request with count\n   set to 0 should not cause the time_modify
        attribute of the file to be\n   updated.\n   The definition of stable storage
        has been historically a point of\n   contention.  The following expected properties
        of stable storage may\n   help in resolving design issues in the implementation.
        \ Stable\n   storage is persistent storage that survives:\n   1.  Repeated
        power failures.\n   2.  Hardware failures (of any board, power supply, etc.).\n
        \  3.  Repeated software crashes, including reboot cycle.\n   This definition
        does not address failure of the stable storage module\n   itself.\n   The
        verifier is defined to allow a client to detect different\n   instances of
        an NFSv4 protocol server over which cached, uncommitted\n   data may be lost.
        \ In the most likely case, the verifier allows the\n   client to detect server
        reboots.  This information is required so\n   that the client can safely determine
        whether the server could have\n   lost cached data.  If the server fails unexpectedly
        and the client\n   has uncommitted data from previous WRITE requests (done
        with the\n   stable argument set to UNSTABLE4 and in which the result committed\n
        \  was returned as UNSTABLE4 as well), it may not have flushed cached\n   data
        to stable storage.  The burden of recovery is on the client, and\n   the client
        will need to retransmit the data to the server.\n   One suggested way to use
        the verifier would be to use the time that\n   the server was booted or the
        time the server was last started (if\n   restarting the server without a reboot
        results in lost buffers).\n   The committed field in the results allows the
        client to do more\n   effective caching.  If the server is committing all
        WRITE requests to\n   stable storage, then it should return with committed
        set to\n   FILE_SYNC4, regardless of the value of the stable field in the\n
        \  arguments.  A server that uses an NVRAM accelerator may choose to\n   implement
        this policy.  The client can use this to increase the\n   effectiveness of
        the cache by discarding cached data that has already\n   been committed on
        the server.\n   Some implementations may return NFS4ERR_NOSPC instead of\n
        \  NFS4ERR_DQUOT when a user's quota is exceeded.  In the case that the\n
        \  current filehandle is a directory, the server will return\n   NFS4ERR_ISDIR.
        \ If the current filehandle is not a regular file or a\n   directory, the
        server will return NFS4ERR_INVAL.\n   If mandatory file locking is on for
        the file, and a corresponding\n   record of the data to be written to file
        is read or write locked by\n   an owner that is not associated with the stateid,
        the server will\n   return NFS4ERR_LOCKED.  If so, the client must check if
        the owner\n   corresponding to the stateid used with the WRITE operation has
        a\n   conflicting read lock that overlaps with the region that was to be\n
        \  written.  If the stateid's owner has no conflicting read lock, then\n   the
        client should try to get the appropriate write byte-range lock\n   via the
        LOCK operation before re-attempting the WRITE.  When the\n   WRITE completes,
        the client should release the byte-range lock via\n   LOCKU.\n   If the stateid's
        owner had a conflicting read lock, then the client\n   has no choice but to
        return an error to the application that\n   attempted the WRITE.  The reason
        is that since the stateid's owner\n   had a read lock, the server either (1)
        attempted to temporarily\n   effectively upgrade this read lock to a write
        lock or (2) has no\n   upgrade capability.  If the server attempted to upgrade
        the read lock\n   and failed, it is pointless for the client to re-attempt
        the upgrade\n   via the LOCK operation, because there might be another client
        also\n   trying to upgrade.  If two clients are blocked trying to upgrade
        the\n   same lock, the clients deadlock.  If the server has no upgrade\n   capability,
        then it is pointless to try a LOCK operation to upgrade.\n"
      title: 16.36.5.  IMPLEMENTATION
    title: '16.36.  Operation 38: WRITE - Write to File'
  - contents:
    - '16.37.  Operation 39: RELEASE_LOCKOWNER - Release Lock-Owner State

      '
    - contents:
      - "16.37.1.  SYNOPSIS\n     lock-owner -> ()\n"
      title: 16.37.1.  SYNOPSIS
    - contents:
      - "16.37.2.  ARGUMENT\n   struct RELEASE_LOCKOWNER4args {\n           lock_owner4
        \    lock_owner;\n   };\n"
      title: 16.37.2.  ARGUMENT
    - contents:
      - "16.37.3.  RESULT\n   struct RELEASE_LOCKOWNER4res {\n           nfsstat4
        \       status;\n   };\n"
      title: 16.37.3.  RESULT
    - contents:
      - "16.37.4.  DESCRIPTION\n   This operation is used to notify the server that
        the lock_owner is no\n   longer in use by the client and that future client
        requests will not\n   reference this lock_owner.  This allows the server to
        release cached\n   state related to the specified lock_owner.  If file locks
        associated\n   with the lock_owner are held at the server, the error\n   NFS4ERR_LOCKS_HELD
        will be returned and no further action will be\n   taken.\n"
      title: 16.37.4.  DESCRIPTION
    - contents:
      - "16.37.5.  IMPLEMENTATION\n   The client may choose to use this operation
        to ease the amount of\n   server state that is held.  Information that can
        be released when a\n   RELEASE_LOCKOWNER is done includes the specified lock-owner
        string,\n   the seqid associated with the lock-owner, any saved reply for
        the\n   lock-owner, and any lock stateids associated with that lock-owner.\n
        \  Depending on the behavior of applications at the client, it may be\n   important
        for the client to use this operation since the server\n   has certain obligations
        with respect to holding a reference to\n   lock-owner-associated state as
        long as an associated file is open.\n   Therefore, if the client knows for
        certain that the lock_owner will\n   no longer be used to either reference
        existing lock stateids\n   associated with the lock-owner or create new ones,
        it should use\n   RELEASE_LOCKOWNER.\n"
      title: 16.37.5.  IMPLEMENTATION
    title: '16.37.  Operation 39: RELEASE_LOCKOWNER - Release Lock-Owner State'
  - contents:
    - '16.38.  Operation 10044: ILLEGAL - Illegal Operation

      '
    - contents:
      - "16.38.1.  SYNOPSIS\n     <null> -> ()\n"
      title: 16.38.1.  SYNOPSIS
    - contents:
      - "16.38.2.  ARGUMENT\n     void;\n"
      title: 16.38.2.  ARGUMENT
    - contents:
      - "16.38.3.  RESULT\n   struct ILLEGAL4res {\n           nfsstat4        status;\n
        \  };\n"
      title: 16.38.3.  RESULT
    - contents:
      - "16.38.4.  DESCRIPTION\n   This operation is a placeholder for encoding a
        result to handle the\n   case of the client sending an operation code within
        COMPOUND that is\n   not supported.  See Section 15.2.4 for more details.\n
        \  The status field of ILLEGAL4res MUST be set to NFS4ERR_OP_ILLEGAL.\n"
      title: 16.38.4.  DESCRIPTION
    - contents:
      - "16.38.5.  IMPLEMENTATION\n   A client will probably not send an operation
        with code OP_ILLEGAL,\n   but if it does, the response will be ILLEGAL4res,
        just as it would be\n   with any other invalid operation code.  Note that
        if the server gets\n   an illegal operation code that is not OP_ILLEGAL, and
        if the server\n   checks for legal operation codes during the XDR decode phase,
        then\n   the ILLEGAL4res would not be returned.\n"
      title: 16.38.5.  IMPLEMENTATION
    title: '16.38.  Operation 10044: ILLEGAL - Illegal Operation'
  title: 16.  NFSv4 Operations
- contents:
  - "17.  NFSv4 Callback Procedures\n   The procedures used for callbacks are defined
    in the following\n   sections.  In the interest of clarity, the terms \"client\"
    and\n   \"server\" refer to NFS clients and servers, despite the fact that for\n
    \  an individual callback RPC, the sense of these terms would be\n   precisely
    the opposite.\n"
  - contents:
    - '17.1.  Procedure 0: CB_NULL - No Operation

      '
    - contents:
      - "17.1.1.  SYNOPSIS\n     <null>\n"
      title: 17.1.1.  SYNOPSIS
    - contents:
      - "17.1.2.  ARGUMENT\n     void;\n"
      title: 17.1.2.  ARGUMENT
    - contents:
      - "17.1.3.  RESULT\n     void;\n"
      title: 17.1.3.  RESULT
    - contents:
      - "17.1.4.  DESCRIPTION\n   Standard NULL procedure.  Void argument, void response.
        \ Even though\n   there is no direct functionality associated with this procedure,
        the\n   server will use CB_NULL to confirm the existence of a path for RPCs\n
        \  from server to client.\n"
      title: 17.1.4.  DESCRIPTION
    title: '17.1.  Procedure 0: CB_NULL - No Operation'
  - contents:
    - '17.2.  Procedure 1: CB_COMPOUND - COMPOUND Operations

      '
    - contents:
      - "17.2.1.  SYNOPSIS\n     compoundargs -> compoundres\n"
      title: 17.2.1.  SYNOPSIS
    - contents:
      - "17.2.2.  ARGUMENT\n   enum nfs_cb_opnum4 {\n           OP_CB_GETATTR           =
        3,\n           OP_CB_RECALL            = 4,\n           OP_CB_ILLEGAL           =
        10044\n   };\n   union nfs_cb_argop4 switch (unsigned argop) {\n    case OP_CB_GETATTR:\n
        \        CB_GETATTR4args           opcbgetattr;\n    case OP_CB_RECALL:\n
        \        CB_RECALL4args            opcbrecall;\n    case OP_CB_ILLEGAL:            void;\n
        \  };\n   struct CB_COMPOUND4args {\n           utf8str_cs      tag;\n           uint32_t
        \       minorversion;\n           uint32_t        callback_ident;\n           nfs_cb_argop4
        \  argarray<>;\n   };\n"
      title: 17.2.2.  ARGUMENT
    - contents:
      - "17.2.3.  RESULT\n   union nfs_cb_resop4 switch (unsigned resop) {\n    case
        OP_CB_GETATTR:    CB_GETATTR4res  opcbgetattr;\n    case OP_CB_RECALL:     CB_RECALL4res
        \  opcbrecall;\n    case OP_CB_ILLEGAL:    CB_ILLEGAL4res  opcbillegal;\n
        \  };\n   struct CB_COMPOUND4res {\n           nfsstat4        status;\n           utf8str_cs
        \     tag;\n           nfs_cb_resop4   resarray<>;\n   };\n"
      title: 17.2.3.  RESULT
    - contents:
      - "17.2.4.  DESCRIPTION\n   The CB_COMPOUND procedure is used to combine one
        or more of the\n   callback procedures into a single RPC request.  The main
        callback RPC\n   program has two main procedures: CB_NULL and CB_COMPOUND.
        \ All other\n   operations use the CB_COMPOUND procedure as a wrapper.\n   In
        the processing of the CB_COMPOUND procedure, the client may find\n   that
        it does not have the available resources to execute any or all\n   of the
        operations within the CB_COMPOUND sequence.  In this case, the\n   error NFS4ERR_RESOURCE
        will be returned for the particular operation\n   within the CB_COMPOUND procedure
        where the resource exhaustion\n   occurred.  This assumes that all previous
        operations within the\n   CB_COMPOUND sequence have been evaluated successfully.\n
        \  Contained within the CB_COMPOUND results is a status field.  This\n   status
        must be equivalent to the status of the last operation that\n   was executed
        within the CB_COMPOUND procedure.  Therefore, if an\n   operation incurred
        an error, then the status value will be the same\n   error value as is being
        returned for the operation that failed.\n   For the definition of the tag
        field, see Section 15.2.\n   The value of callback_ident is supplied by the
        client during\n   SETCLIENTID.  The server must use the client-supplied callback_ident\n
        \  during the CB_COMPOUND to allow the client to properly identify the\n   server.\n
        \  Illegal operation codes are handled in the same way as they are\n   handled
        for the COMPOUND procedure.\n"
      title: 17.2.4.  DESCRIPTION
    - contents:
      - "17.2.5.  IMPLEMENTATION\n   The CB_COMPOUND procedure is used to combine
        individual operations\n   into a single RPC request.  The client interprets
        each of the\n   operations in turn.  If an operation is executed by the client
        and\n   the status of that operation is NFS4_OK, then the next operation in\n
        \  the CB_COMPOUND procedure is executed.  The client continues this\n   process
        until there are no more operations to be executed or one of\n   the operations
        has a status value other than NFS4_OK.\n"
      title: 17.2.5.  IMPLEMENTATION
    title: '17.2.  Procedure 1: CB_COMPOUND - COMPOUND Operations'
  title: 17.  NFSv4 Callback Procedures
- contents:
  - '18.  NFSv4 Callback Operations

    '
  - contents:
    - '18.1.  Operation 3: CB_GETATTR - Get Attributes

      '
    - contents:
      - "18.1.1.  SYNOPSIS\n     fh, attr_request -> attrmask, attr_vals\n"
      title: 18.1.1.  SYNOPSIS
    - contents:
      - "18.1.2.  ARGUMENT\n   struct CB_GETATTR4args {\n           nfs_fh4 fh;\n
        \          bitmap4 attr_request;\n   };\n"
      title: 18.1.2.  ARGUMENT
    - contents:
      - "18.1.3.  RESULT\n   struct CB_GETATTR4resok {\n           fattr4  obj_attributes;\n
        \  };\n   union CB_GETATTR4res switch (nfsstat4 status) {\n    case NFS4_OK:\n
        \           CB_GETATTR4resok       resok4;\n    default:\n            void;\n
        \  };\n"
      title: 18.1.3.  RESULT
    - contents:
      - "18.1.4.  DESCRIPTION\n   The CB_GETATTR operation is used by the server to
        obtain the current\n   modified state of a file that has been OPEN_DELEGATE_WRITE
        delegated.\n   The size attribute and the change attribute are the only ones\n
        \  guaranteed to be serviced by the client.  See Section 10.4.3 for a\n   full
        description of how the client and server are to interact with\n   the use
        of CB_GETATTR.\n   If the filehandle specified is not one for which the client
        holds an\n   OPEN_DELEGATE_WRITE delegation, an NFS4ERR_BADHANDLE error is\n
        \  returned.\n"
      title: 18.1.4.  DESCRIPTION
    - contents:
      - "18.1.5.  IMPLEMENTATION\n   The client returns attrmask bits and the associated
        attribute values\n   only for the change attribute, and attributes that it
        may change\n   (time_modify and size).\n"
      title: 18.1.5.  IMPLEMENTATION
    title: '18.1.  Operation 3: CB_GETATTR - Get Attributes'
  - contents:
    - '18.2.  Operation 4: CB_RECALL - Recall an Open Delegation

      '
    - contents:
      - "18.2.1.  SYNOPSIS\n     stateid, truncate, fh -> ()\n"
      title: 18.2.1.  SYNOPSIS
    - contents:
      - "18.2.2.  ARGUMENT\n   struct CB_RECALL4args {\n           stateid4        stateid;\n
        \          bool            truncate;\n           nfs_fh4         fh;\n   };\n"
      title: 18.2.2.  ARGUMENT
    - contents:
      - "18.2.3.  RESULT\n   struct CB_RECALL4res {\n           nfsstat4        status;\n
        \  };\n"
      title: 18.2.3.  RESULT
    - contents:
      - "18.2.4.  DESCRIPTION\n   The CB_RECALL operation is used to begin the process
        of recalling an\n   open delegation and returning it to the server.\n   The
        truncate flag is used to optimize a recall for a file that is\n   about to
        be truncated to zero.  When it is set, the client is freed\n   of obligation
        to propagate modified data for the file to the server,\n   since this data
        is irrelevant.\n   If the handle specified is not one for which the client
        holds an open\n   delegation, an NFS4ERR_BADHANDLE error is returned.\n   If
        the stateid specified is not one corresponding to an open\n   delegation for
        the file specified by the filehandle, an\n   NFS4ERR_BAD_STATEID is returned.\n"
      title: 18.2.4.  DESCRIPTION
    - contents:
      - "18.2.5.  IMPLEMENTATION\n   The client should reply to the callback immediately.
        \ Replying does\n   not complete the recall, except when an error was returned.
        \ The\n   recall is not complete until the delegation is returned using a\n
        \  DELEGRETURN.\n"
      title: 18.2.5.  IMPLEMENTATION
    title: '18.2.  Operation 4: CB_RECALL - Recall an Open Delegation'
  - contents:
    - '18.3.  Operation 10044: CB_ILLEGAL - Illegal Callback Operation

      '
    - contents:
      - "18.3.1.  SYNOPSIS\n     <null> -> ()\n"
      title: 18.3.1.  SYNOPSIS
    - contents:
      - "18.3.2.  ARGUMENT\n     void;\n"
      title: 18.3.2.  ARGUMENT
    - contents:
      - "18.3.3.  RESULT\n   /*\n    * CB_ILLEGAL: Response for illegal operation
        numbers\n    */\n   struct CB_ILLEGAL4res {\n           nfsstat4        status;\n
        \  };\n"
      title: 18.3.3.  RESULT
    - contents:
      - "18.3.4.  DESCRIPTION\n   This operation is a placeholder for encoding a result
        to handle the\n   case of the client sending an operation code within COMPOUND
        that is\n   not supported.  See Section 15.2.4 for more details.\n   The status
        field of CB_ILLEGAL4res MUST be set to NFS4ERR_OP_ILLEGAL.\n"
      title: 18.3.4.  DESCRIPTION
    - contents:
      - "18.3.5.  IMPLEMENTATION\n   A server will probably not send an operation
        with code OP_CB_ILLEGAL,\n   but if it does, the response will be CB_ILLEGAL4res,
        just as it would\n   be with any other invalid operation code.  Note that
        if the client\n   gets an illegal operation code that is not OP_ILLEGAL, and
        if the\n   client checks for legal operation codes during the XDR decode phase,\n
        \  then the CB_ILLEGAL4res would not be returned.\n"
      title: 18.3.5.  IMPLEMENTATION
    title: '18.3.  Operation 10044: CB_ILLEGAL - Illegal Callback Operation'
  title: 18.  NFSv4 Callback Operations
- contents:
  - "19.  Security Considerations\n   NFS has historically used a model where, from
    an authentication\n   perspective, the client was the entire machine, or at least
    the\n   source IP address of the machine.  The NFS server relied on the NFS\n
    \  client to make the proper authentication of the end-user.  The NFS\n   server
    in turn shared its files only to specific clients, as\n   identified by the client's
    source IP address.  Given this model, the\n   AUTH_SYS RPC security flavor simply
    identified the end-user using the\n   client to the NFS server.  When processing
    NFS responses, the client\n   ensured that the responses came from the same IP
    address and port\n   number that the request was sent to.  While such a model
    is easy to\n   implement and simple to deploy and use, it is certainly not a safe\n
    \  model.  Thus, NFSv4 mandates that implementations support a security\n   model
    that uses end-to-end authentication, where an end-user on a\n   client mutually
    authenticates (via cryptographic schemes that do not\n   expose passwords or keys
    in the clear on the network) to a principal\n   on an NFS server.  Consideration
    should also be given to the\n   integrity and privacy of NFS requests and responses.
    \ The issues of\n   end-to-end mutual authentication, integrity, and privacy are\n
    \  discussed as part of Section 3.\n   When an NFSv4 mandated security model is
    used and a security\n   principal or an NFSv4 name in user@dns_domain form needs
    to be\n   translated to or from a local representation as described in\n   Section
    5.9, the translation SHOULD be done in a secure manner that\n   preserves the
    integrity of the translation.  For communication with a\n   name service such
    as the Lightweight Directory Access Protocol (LDAP)\n   ([RFC4511]), this means
    employing a security service that uses\n   authentication and data integrity.
    \ Kerberos and Transport Layer\n   Security (TLS) ([RFC5246]) are examples of
    such a security service.\n   Note that being REQUIRED to implement does not mean
    REQUIRED to use;\n   AUTH_SYS can be used by NFSv4 clients and servers.  However,
    AUTH_SYS\n   is merely an OPTIONAL security flavor in NFSv4, and so\n   interoperability
    via AUTH_SYS is not assured.\n   For reasons of reduced administration overhead,
    better performance,\n   and/or reduction of CPU utilization, users of NFSv4 implementations\n
    \  may choose to not use security mechanisms that enable integrity\n   protection
    on each remote procedure call and response.  The use of\n   mechanisms without
    integrity leaves the customer vulnerable to an\n   attacker in between the NFS
    client and server that modifies the RPC\n   request and/or the response.  While
    implementations are free to\n   provide the option to use weaker security mechanisms,
    there are two\n   operations in particular that warrant the implementation overriding\n
    \  user choices.\n   The first such operation is SECINFO.  It is recommended that
    the\n   client issue the SECINFO call such that it is protected with a\n   security
    flavor that has integrity protection, such as RPCSEC_GSS\n   with a security triple
    that uses either rpc_gss_svc_integrity or\n   rpc_gss_svc_privacy (rpc_gss_svc_privacy
    includes integrity\n   protection) service.  Without integrity protection encapsulating\n
    \  SECINFO and therefore its results, an attacker in the middle could\n   modify
    results such that the client might select a weaker algorithm\n   in the set allowed
    by the server, making the client and/or server\n   vulnerable to further attacks.\n
    \  The second operation that SHOULD use integrity protection is any\n   GETATTR
    for the fs_locations attribute.  The attack has two steps.\n   First, the attacker
    modifies the unprotected results of some\n   operation to return NFS4ERR_MOVED.
    \ Second, when the client follows\n   up with a GETATTR for the fs_locations attribute,
    the attacker\n   modifies the results to cause the client to migrate its traffic
    to a\n   server controlled by the attacker.\n   Because the operations SETCLIENTID/SETCLIENTID_CONFIRM
    are\n   responsible for the release of client state, it is imperative that\n   the
    principal used for these operations is checked against and\n   matches with the
    previous use of these operations.  See Section 9.1.1\n   for further discussion.\n
    \  Unicode in the form of UTF-8 is used for file component names (i.e.,\n   both
    directory and file components), as well as the owner and\n   owner_group attributes;
    other character sets may also be allowed for\n   file component names.  String
    processing (e.g., Unicode\n   normalization) raises security concerns for string
    comparison.  See\n   Sections 5.9 and 12 for further discussion, and see [RFC6943]
    for\n   related identifier comparison security considerations.  File\n   component
    names are identifiers with respect to the identifier\n   comparison discussion
    in [RFC6943] because they are used to identify\n   the objects to which ACLs are
    applied; see Section 6.\n"
  title: 19.  Security Considerations
- contents:
  - "20.  IANA Considerations\n   This section uses terms that are defined in [RFC5226].\n"
  - contents:
    - "20.1.  Named Attribute Definitions\n   IANA has created a registry called the
      \"NFSv4 Named Attribute\n   Definitions Registry\" for [RFC3530] and [RFC5661].
      \ This section\n   introduces no new changes, but it does recap the intent.\n
      \  The NFSv4 protocol supports the association of a file with zero or\n   more
      named attributes.  The namespace identifiers for these\n   attributes are defined
      as string names.  The protocol does not define\n   the specific assignment of
      the namespace for these file attributes.\n   The IANA registry promotes interoperability
      where common interests\n   exist.  While application developers are allowed
      to define and use\n   attributes as needed, they are encouraged to register
      the attributes\n   with IANA.\n   Such registered named attributes are presumed
      to apply to all minor\n   versions of NFSv4, including those defined subsequently
      to the\n   registration.  Where the named attribute is intended to be limited\n
      \  with regard to the minor versions for which they are not to be used,\n   the
      assignment in the registry will clearly state the applicable\n   limits.\n   The
      registry is to be maintained using the Specification Required\n   policy as
      defined in Section 4.1 of [RFC5226].\n   Under the NFSv4 specification, the
      name of a named attribute can in\n   theory be up to 2^32 - 1 bytes in length,
      but in practice NFSv4\n   clients and servers will be unable to handle a string
      that long.\n   IANA should reject any assignment request with a named attribute
      that\n   exceeds 128 UTF-8 characters.  To give the IESG the flexibility to\n
      \  set up bases of assignment of Experimental Use and Standards Action,\n   the
      prefixes of \"EXPE\" and \"STDS\" are Reserved.  The zero-length\n   named attribute
      name is Reserved.\n   The prefix \"PRIV\" is allocated for Private Use.  A site
      that wants to\n   make use of unregistered named attributes without risk of
      conflicting\n   with an assignment in IANA's registry should use the prefix
      \"PRIV\" in\n   all of its named attributes.\n   Because some NFSv4 clients
      and servers have case-insensitive\n   semantics, the fifteen additional lowercase
      and mixed-case\n   permutations of each of \"EXPE\", \"PRIV\", and \"STDS\"
      are Reserved\n   (e.g., \"expe\", \"expE\", \"exPe\", etc. are Reserved).  Similarly,
      IANA\n   must not allow two assignments that would conflict if both named\n
      \  attributes were converted to a common case.\n   The registry of named attributes
      is a list of assignments, each\n   containing three fields for each assignment.\n
      \  1.  A US-ASCII string name that is the actual name of the attribute.\n       This
      name must be unique.  This string name can be 1 to 128 UTF-8\n       characters
      long.\n   2.  A reference to the specification of the named attribute.  The\n
      \      reference can consume up to 256 bytes (or more, if IANA permits).\n   3.
      \ The point of contact of the registrant.  The point of contact can\n       consume
      up to 256 bytes (or more, if IANA permits).\n"
    - contents:
      - "20.1.1.  Initial Registry\n   There is no initial registry.\n"
      title: 20.1.1.  Initial Registry
    - contents:
      - "20.1.2.  Updating Registrations\n   The registrant is always permitted to
        update the point of contact\n   field.  To make any other change will require
        Expert Review or IESG\n   Approval.\n"
      title: 20.1.2.  Updating Registrations
    title: 20.1.  Named Attribute Definitions
  - contents:
    - "20.2.  Updates to Existing IANA Registries\n   In addition, because this document
      obsoletes RFC 3530, IANA has\n   o  replaced all references to RFC 3530 in the
      Network Identifier\n      (r_netid) registry with references to this document.\n
      \  o  replaced the reference to the nfs registration's reference to\n      RFC
      3530 in the GSSAPI/Kerberos/SASL Service names registry with a\n      reference
      to this document.\n"
    title: 20.2.  Updates to Existing IANA Registries
  title: 20.  IANA Considerations
- contents:
  - '21.  References

    '
  - contents:
    - "21.1.  Normative References\n   [RFC20]    Cerf, V., \"ASCII format for network
      interchange\", STD 80,\n              RFC 20, October 1969,\n              <http://www.rfc-editor.org/info/rfc20>.\n
      \  [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement
      Levels\", BCP 14, RFC 2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n
      \  [RFC2203]  Eisler, M., Chiu, A., and L. Ling, \"RPCSEC_GSS Protocol\n              Specification\",
      RFC 2203, September 1997,\n              <http://www.rfc-editor.org/info/rfc2203>.\n
      \  [RFC2743]  Linn, J., \"Generic Security Service Application Program\n              Interface
      Version 2, Update 1\", RFC 2743, January 2000,\n              <http://www.rfc-editor.org/info/rfc2743>.\n
      \  [RFC3490]  Faltstrom, P., Hoffman, P., and A. Costello,\n              \"Internationalizing
      Domain Names in Applications (IDNA)\",\n              RFC 3490, March 2003,\n
      \             <http://www.rfc-editor.org/info/rfc3490>.\n   [RFC3492]  Costello,
      A., \"Punycode: A Bootstring encoding of Unicode\n              for Internationalized
      Domain Names in Applications\n              (IDNA)\", RFC 3492, March 2003,\n
      \             <http://www.rfc-editor.org/info/rfc3492>.\n   [RFC3629]  Yergeau,
      F., \"UTF-8, a transformation format of\n              ISO 10646\", STD 63,
      RFC 3629, November 2003,\n              <http://www.rfc-editor.org/info/rfc3629>.\n
      \  [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n              IANA
      Considerations Section in RFCs\", BCP 26, RFC 5226,\n              May 2008,
      <http://www.rfc-editor.org/info/rfc5226>.\n   [RFC5403]  Eisler, M., \"RPCSEC_GSS
      Version 2\", RFC 5403,\n              February 2009, <http://www.rfc-editor.org/info/rfc5403>.\n
      \  [RFC5531]  Thurlow, R., \"RPC: Remote Procedure Call Protocol\n              Specification
      Version 2\", RFC 5531, May 2009,\n              <http://www.rfc-editor.org/info/rfc5531>.\n
      \  [RFC5665]  Eisler, M., \"IANA Considerations for Remote Procedure Call\n
      \             (RPC) Network Identifiers and Universal Address Formats\",\n              RFC
      5665, January 2010,\n              <http://www.rfc-editor.org/info/rfc5665>.\n
      \  [RFC5890]  Klensin, J., \"Internationalized Domain Names for\n              Applications
      (IDNA): Definitions and Document Framework\",\n              RFC 5890, August
      2010,\n              <http://www.rfc-editor.org/info/rfc5890>.\n   [RFC5891]
      \ Klensin, J., \"Internationalized Domain Names in\n              Applications
      (IDNA): Protocol\", RFC 5891, August 2010,\n              <http://www.rfc-editor.org/info/rfc5891>.\n
      \  [RFC6649]  Hornquist Astrand, L. and T. Yu, \"Deprecate DES,\n              RC4-HMAC-EXP,
      and Other Weak Cryptographic Algorithms in\n              Kerberos\", BCP 179,
      RFC 6649, July 2012,\n              <http://www.rfc-editor.org/info/rfc6649>.\n
      \  [RFC7531]  Haynes, T., Ed., and D. Noveck, Ed., \"Network File System\n              (NFS)
      Version 4 External Data Representation Standard\n              (XDR) Description\",
      RFC 7531, March 2015,\n              <http://www.rfc-editor.org/info/rfc7531>.\n
      \  [SPECIALCASING]\n              The Unicode Consortium, \"SpecialCasing-7.0.0.txt\",
      Unicode\n              Character Database, March 2014, <http://www.unicode.org/\n
      \             Public/UCD/latest/ucd/SpecialCasing.txt>.\n   [UNICODE]  The Unicode
      Consortium, \"The Unicode Standard,\n              Version 7.0.0\", (Mountain
      View, CA: The Unicode\n              Consortium, 2014 ISBN 978-1-936213-09-2),
      June 2014,\n              <http://www.unicode.org/versions/latest/>.\n   [openg_symlink]\n
      \             The Open Group, \"Section 3.372 of Chapter 3 of Base\n              Definitions
      of The Open Group Base Specifications\n              Issue 7\", IEEE Std 1003.1,
      2013 Edition (HTML Version),\n              ISBN 1937218287, April 2013, <http://www.opengroup.org/>.\n"
    title: 21.1.  Normative References
  - contents:
    - "21.2.  Informative References\n   [Chet]     Juszczak, C., \"Improving the
      Performance and Correctness\n              of an NFS Server\", USENIX Conference
      Proceedings,\n              June 1990.\n   [Floyd]    Floyd, S. and V. Jacobson,
      \"The Synchronization of\n              Periodic Routing Messages\", IEEE/ACM
      Transactions on\n              Networking 2(2), pp. 122-136, April 1994.\n   [IESG_ERRATA]\n
      \             IESG, \"IESG Processing of RFC Errata for the IETF Stream\",\n
      \             July 2008.\n   [MS-SMB]   Microsoft Corporation, \"Server Message
      Block (SMB)\n              Protocol Specification\", MS-SMB 43.0, May 2014.\n
      \  [P1003.1e]\n              Institute of Electrical and Electronics Engineers,
      Inc.,\n              \"IEEE Draft P1003.1e\", 1997.\n   [RFC1094]  Nowicki,
      B., \"NFS: Network File System Protocol\n              specification\", RFC
      1094, March 1989,\n              <http://www.rfc-editor.org/info/rfc1094>.\n
      \  [RFC1813]  Callaghan, B., Pawlowski, B., and P. Staubach, \"NFS\n              Version
      3 Protocol Specification\", RFC 1813, June 1995,\n              <http://www.rfc-editor.org/info/rfc1813>.\n
      \  [RFC1833]  Srinivasan, R., \"Binding Protocols for ONC RPC Version 2\",\n
      \             RFC 1833, August 1995,\n              <http://www.rfc-editor.org/info/rfc1833>.\n
      \  [RFC2054]  Callaghan, B., \"WebNFS Client Specification\", RFC 2054,\n              October
      1996, <http://www.rfc-editor.org/info/rfc2054>.\n   [RFC2055]  Callaghan, B.,
      \"WebNFS Server Specification\", RFC 2055,\n              October 1996, <http://www.rfc-editor.org/info/rfc2055>.\n
      \  [RFC2224]  Callaghan, B., \"NFS URL Scheme\", RFC 2224, October 1997,\n              <http://www.rfc-editor.org/info/rfc2224>.\n
      \  [RFC2623]  Eisler, M., \"NFS Version 2 and Version 3 Security Issues\n              and
      the NFS Protocol's Use of RPCSEC_GSS and Kerberos V5\",\n              RFC 2623,
      June 1999,\n              <http://www.rfc-editor.org/info/rfc2623>.\n   [RFC2624]
      \ Shepler, S., \"NFS Version 4 Design Considerations\",\n              RFC 2624,
      June 1999,\n              <http://www.rfc-editor.org/info/rfc2624>.\n   [RFC2755]
      \ Chiu, A., Eisler, M., and B. Callaghan, \"Security\n              Negotiation
      for WebNFS\", RFC 2755, January 2000,\n              <http://www.rfc-editor.org/info/rfc2755>.\n
      \  [RFC3010]  Shepler, S., Callaghan, B., Robinson, D., Thurlow, R.,\n              Beame,
      C., Eisler, M., and D. Noveck, \"NFS version 4\n              Protocol\", RFC
      3010, December 2000,\n              <http://www.rfc-editor.org/info/rfc3010>.\n
      \  [RFC3232]  Reynolds, J., Ed., \"Assigned Numbers: RFC 1700 is Replaced\n
      \             by an On-line Database\", RFC 3232, January 2002,\n              <http://www.rfc-editor.org/info/rfc3232>.\n
      \  [RFC3530]  Shepler, S., Callaghan, B., Robinson, D., Thurlow, R.,\n              Beame,
      C., Eisler, M., and D. Noveck, \"Network File System\n              (NFS) version
      4 Protocol\", RFC 3530, April 2003,\n              <http://www.rfc-editor.org/info/rfc3530>.\n
      \  [RFC4121]  Zhu, L., Jaganathan, K., and S. Hartman, \"The Kerberos\n              Version
      5 Generic Security Service Application Program\n              Interface (GSS-API)
      Mechanism: Version 2\", RFC 4121,\n              July 2005, <http://www.rfc-editor.org/info/rfc4121>.\n
      \  [RFC4178]  Zhu, L., Leach, P., Jaganathan, K., and W. Ingersoll, \"The\n
      \             Simple and Protected Generic Security Service Application\n              Program
      Interface (GSS-API) Negotiation Mechanism\",\n              RFC 4178, October
      2005,\n              <http://www.rfc-editor.org/info/rfc4178>.\n   [RFC4506]
      \ Eisler, M., Ed., \"XDR: External Data Representation\n              Standard\",
      STD 67, RFC 4506, May 2006,\n              <http://www.rfc-editor.org/info/rfc4506>.\n
      \  [RFC4511]  Sermersheim, J., Ed., \"Lightweight Directory Access\n              Protocol
      (LDAP): The Protocol\", RFC 4511, June 2006,\n              <http://www.rfc-editor.org/info/rfc4511>.\n
      \  [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)
      Protocol Version 1.2\", RFC 5246, August 2008,\n              <http://www.rfc-editor.org/info/rfc5246>.\n
      \  [RFC5661]  Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed.,\n              \"Network
      File System (NFS) Version 4 Minor Version 1\n              Protocol\", RFC 5661,
      January 2010,\n              <http://www.rfc-editor.org/info/rfc5661>.\n   [RFC6365]
      \ Hoffman, P. and J. Klensin, \"Terminology Used in\n              Internationalization
      in the IETF\", BCP 166, RFC 6365,\n              September 2011, <http://www.rfc-editor.org/info/rfc6365>.\n
      \  [RFC6943]  Thaler, D., Ed., \"Issues in Identifier Comparison for\n              Security
      Purposes\", RFC 6943, May 2013,\n              <http://www.rfc-editor.org/info/rfc6943>.\n
      \  [fcntl]    The Open Group, \"Section 'fcntl()' of System Interfaces of\n
      \             The Open Group Base Specifications Issue 7\", IEEE\n              Std
      1003.1, 2013 Edition (HTML Version), ISBN 1937218287,\n              April 2013,
      <http://www.opengroup.org/>.\n   [fsync]    The Open Group, \"Section 'fsync()'
      of System Interfaces of\n              The Open Group Base Specifications Issue
      7\", IEEE\n              Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287,\n
      \             April 2013, <http://www.opengroup.org/>.\n   [getpwnam]\n              The
      Open Group, \"Section 'getpwnam()' of System Interfaces\n              of The
      Open Group Base Specifications Issue 7\", IEEE\n              Std 1003.1, 2013
      Edition (HTML Version), ISBN 1937218287,\n              April 2013, <http://www.opengroup.org/>.\n
      \  [read_api]\n              The Open Group, \"Section 'read()' of System Interfaces
      of\n              The Open Group Base Specifications Issue 7\", IEEE\n              Std
      1003.1, 2013 Edition (HTML Version), ISBN 1937218287,\n              April 2013,
      <http://www.opengroup.org/>.\n   [readdir_api]\n              The Open Group,
      \"Section 'readdir()' of System Interfaces\n              of The Open Group
      Base Specifications Issue 7\", IEEE\n              Std 1003.1, 2013 Edition
      (HTML Version), ISBN 1937218287,\n              April 2013, <http://www.opengroup.org/>.\n
      \  [stat]     The Open Group, \"Section 'stat()' of System Interfaces of\n              The
      Open Group Base Specifications Issue 7\", IEEE\n              Std 1003.1, 2013
      Edition (HTML Version), ISBN 1937218287,\n              April 2013, <http://www.opengroup.org/>.\n
      \  [unlink]   The Open Group, \"Section 'unlink()' of System Interfaces\n              of
      The Open Group Base Specifications Issue 7\", IEEE\n              Std 1003.1,
      2013 Edition (HTML Version), ISBN 1937218287,\n              April 2013, <http://www.opengroup.org/>.\n
      \  [write_api]\n              The Open Group, \"Section 'write()' of System
      Interfaces of\n              The Open Group Base Specifications Issue 7\", IEEE\n
      \             Std 1003.1, 2013 Edition (HTML Version), ISBN 1937218287,\n              April
      2013, <http://www.opengroup.org/>.\n   [xnfs]     The Open Group, \"Protocols
      for Interworking: XNFS,\n              Version 3W, ISBN 1-85912-184-5\", February
      1998.\n"
    title: 21.2.  Informative References
  title: 21.  References
- contents:
  - "Acknowledgments\n   A bis is certainly built on the shoulders of the first attempt.\n
    \  Spencer Shepler, Brent Callaghan, David Robinson, Robert Thurlow,\n   Carl
    Beame, Mike Eisler, and David Noveck are responsible for a great\n   deal of the
    effort in this work.\n   Tom Haynes would like to thank NetApp, Inc. for its funding
    of his\n   time on this project.\n   Rob Thurlow clarified how a client should
    contact a new server if a\n   migration has occurred.\n   David Black, Nico Williams,
    Mike Eisler, Trond Myklebust, James\n   Lentini, and Mike Kupfer read many earlier
    draft versions of\n   Section 12 and contributed numerous useful suggestions,
    without which\n   the necessary revision of that section for this document would
    not\n   have been possible.\n   Peter Staubach read almost all of the earlier
    draft versions of\n   Section 12, leading to the published result, and his numerous\n
    \  comments were always useful and contributed substantially to\n   improving
    the quality of the final result.\n   Peter Saint-Andre was gracious enough to
    read the most recent draft\n   version of Section 12 and provided some key insight
    as to the\n   concerns of the Internationalization community.\n   James Lentini
    graciously read the rewrite of Section 8, and his\n   comments were vital in improving
    the quality of that effort.\n   Rob Thurlow, Sorin Faibish, James Lentini, Bruce
    Fields, and Trond\n   Myklebust were faithful attendants of the biweekly triage
    meeting and\n   accepted many an action item.\n   Bruce Fields was a good sounding
    board for both the third edge\n   condition and courtesy locks in general.  He
    was also the leading\n   advocate of stamping out backport issues from [RFC5661].\n
    \  Marcel Telka was a champion of straightening out the difference\n   between
    a lock-owner and an open-owner.  He has also been diligent in\n   reviewing the
    final document.\n   Benjamin Kaduk reminded us that DES is dead, and Nico Williams
    helped\n   us close the lid on the coffin.\n   Elwyn Davies provided a very thorough
    and engaging Gen-ART review;\n   thanks!\n"
  title: Acknowledgments
- contents:
  - "Authors' Addresses\n   Thomas Haynes (editor)\n   Primary Data, Inc.\n   4300
    El Camino Real Ste 100\n   Los Altos, CA  94022\n   United States\n   Phone: +1
    408 215 1519\n   EMail: thomas.haynes@primarydata.com\n   David Noveck (editor)\n
    \  Dell\n   300 Innovative Way\n   Nashua, NH  03062\n   United States\n   Phone:
    +1 781 572 8038\n   EMail: dave_noveck@dell.com\n"
  title: Authors' Addresses
