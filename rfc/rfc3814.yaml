- title: __initial_text__
  contents:
  - "      Multiprotocol Label Switching (MPLS) Forwarding Equivalence\n        Class\
    \ To Next Hop Label Forwarding Entry (FEC-To-NHLFE)\n                   Management\
    \ Information Base (MIB)\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2004).\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo defines a portion of the Management Information Base (MIB)\n\
    \   for use with network management protocols in the Internet community.\n   In\
    \ particular, it describes managed objects for defining,\n   configuring, and\
    \ monitoring Forwarding Equivalence Class (FEC) to\n   Next Hop Label Forwarding\
    \ Entry (NHLFE) mappings and corresponding\n   actions for use with Multiprotocol\
    \ Label Switching (MPLS).\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  2\n   2.  Terminology. . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  3\n   3.  Conventions Used In This Document. . . . . . . . . . .\
    \ . . . .  3\n   4.  The Internet-Standard Management Framework . . . . . . .\
    \ . . .  3\n   5.  Outline. . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . .  4\n       5.1.  mplsFTNTable . . . . . . . . . . . . . . . . . . . . .\
    \ .  4\n             5.1.1.  Advantages of Address Ranges Over CIDR Prefixes.\
    \  4\n       5.2.  mplsFTNMapTable. . . . . . . . . . . . . . . . . . . . .  5\n\
    \             5.2.1.  Indexing Requirements. . . . . . . . . . . . . .  5\n  \
    \           5.2.2.  How the Current Indexing Works . . . . . . . . .  5\n    \
    \   5.3.  mplsFTNPerfTable . . . . . . . . . . . . . . . . . . . .  7\n   6. \
    \ Avoiding Retrieval-Modification Interactions . . . . . . . . .  7\n   7.  Example\
    \ Illustrating MIB Module Components . . . . . . . . . .  8\n       7.1.  Sample\
    \ FTN Rules . . . . . . . . . . . . . . . . . . . .  8\n       7.2.  Creating\
    \ FTN Entries and Applying them to Interfaces . .  9\n       7.3.  Mapping an\
    \ FTN Entry to Multiple Interfaces. . . . . . . 10\n       7.4.  Inserting an\
    \ Entry Into Existing List. . . . . . . . . . 11\n       7.5.  Pictorial Tabular\
    \ Relationship . . . . . . . . . . . . . 13\n       7.6.  Deleting an Entry. .\
    \ . . . . . . . . . . . . . . . . . . 14\n   8.  The Use of RowPointer. . . .\
    \ . . . . . . . . . . . . . . . . . 16\n   9.  MPLS-FTN-STD-MIB Definitions .\
    \ . . . . . . . . . . . . . . . . 16\n   10. Security Considerations. . . . .\
    \ . . . . . . . . . . . . . . . 38\n   11. IANA Considerations. . . . . . . .\
    \ . . . . . . . . . . . . . . 39\n       11.1. IANA Considerations for MPLS-FTN-STD-MIB\
    \ . . . . . . . . 39\n   12. References . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . 39\n       12.1. Normative References . . . . . . . . . . . .\
    \ . . . . . . 39\n       12.2. Informative References . . . . . . . . . . . .\
    \ . . . . . 40\n   13. Acknowledgements . . . . . . . . . . . . . . . . . . .\
    \ . . . . 41\n   14. Authors' Addresses . . . . . . . . . . . . . . . . . . .\
    \ . . . 41\n   15. Full Copyright Statement . . . . . . . . . . . . . . . . .\
    \ . . 42\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This memo defines a portion of the Management Information\
    \ Base (MIB)\n   for use with network management protocols in the Internet community.\n\
    \   In particular, it describes managed objects for specifying Forwarding\n  \
    \ Equivalence Class (FEC) to Next Hop Label Forwarding Entry (NHLFE)\n   mappings\
    \ and corresponding actions for Multiprotocol Label Switching\n   (MPLS).\n  \
    \ At the ingress of an MPLS network, packets entering the MPLS domain\n   are\
    \ assigned to an FEC.  Those packets belonging to an FEC are\n   associated with\
    \ an NHLFE (i.e., MPLS label) via the FEC-to-NHLFE\n   (FTN) mapping [RFC3031].\
    \  This relationship defines how ingress LSRs\n   will impose MPLS labels onto\
    \ incoming packets.  It also defines how\n   egress LSRs will decapsulate the\
    \ MPLS shim header from MPLS packets.\n   Conceptually, some of the FTN table\
    \ functionality could be\n   implemented using the Forwarding Information Base\
    \ (FIB) to map all\n   packets destined for a prefix to an LSP.  However, this\
    \ mapping is\n   coarse in nature.\n   Similar functionality is already being\
    \ used in other contexts such as\n   security filters, access filters, and RSVP\
    \ flow identification.  All\n   of these require various combinations of matching\
    \ based on IP header\n   and upper-layer header information to identify packets\
    \ for a\n   particular treatment.  When packets match a particular rule, a\n \
    \  corresponding action is executed on those packets.  For example, two\n   popular\
    \ actions to take when a successful match is identified are\n   allowing the packet\
    \ to be forwarded or to discard it.  However, other\n   actions are possible,\
    \ such as modifying the TOS byte, or redirecting\n   a packet to a particular\
    \ outgoing interface.  In the context of MPLS,\n   the possible actions performed\
    \ by an NHLFE are to redirect packets to\n   either an MPLS Label Switched Path\
    \ (LSP) or an MPLS Traffic\n   Engineered (TE) Tunnel.\n   This document attempts\
    \ to consolidate the various matching\n   requirements and associated action options\
    \ needed for MPLS into a\n   single specification.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   Although all of the terminology used in this document is\
    \ either\n   covered in the MPLS Architecture [RFC3031] or in the SNMP\n   Architecture\
    \ [RFC3411], it is informational to define some\n   immediately pertinent acronyms/terminology\
    \ here.\n      MPLS  Multiprotocol Label Switching\n      FEC   Forwarding Equivalence\
    \ Class\n      NHLFE Next-Hop Label Forwarding Entry\n      FTN   FEC-to-NHLFE\n\
    \      MIB   Management Information Base\n"
- title: 3.  Conventions Used In This Document
  contents:
  - "3.  Conventions Used In This Document\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    ,  \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in BCP 14, RFC 2119\n   [RFC2119].\n"
- title: 4.  The Internet-Standard Management Framework
  contents:
  - "4.  The Internet-Standard Management Framework\n   For a detailed overview of\
    \ the documents that describe the current\n   Internet-Standard Management Framework,\
    \ please refer to section 7 of\n   RFC 3410 [RFC3410].\n   Managed objects are\
    \ accessed via a virtual information store, termed\n   the Management Information\
    \ Base or MIB.  MIB objects are generally\n   accessed through the Simple Network\
    \ Management Protocol (SNMP).\n   Objects in the MIB are defined using the mechanisms\
    \ defined in the\n   Structure of Management Information (SMI).  This memo specifies\
    \ a MIB\n   module that is compliant to the SMIv2, which is described in STD 58,\n\
    \   RFC 2578 [RFC2578], STD 58, RFC 2579 [RFC2579] and STD 58, RFC 2580\n   [RFC2580].\n"
- title: 5.  Outline
  contents:
  - "5.  Outline\n   This MIB module resides on any LSR which does the FEC-to-NHLFE\n\
    \   mapping in order to map traffic into the MPLS domain.  This MIB\n   module\
    \ consists of three tables:\n   -  mplsFTNTable defines the rule base against\
    \ which incoming packets\n      are matched and defines the actions to be taken\
    \ on matching\n      packets;\n   -  mplsFTNMapTable defines the application of\
    \ these rules to specific\n      interfaces;\n   -  mplsFTNPerfTable provides\
    \ performance counters for every entry in\n      mplsFTNTable that is active on\
    \ one or more interfaces, on a per-\n      interface basis.\n"
- title: 5.1.  mplsFTNTable
  contents:
  - "5.1.  mplsFTNTable\n   This table allows FEC to NHLFE mappings to be specified.\
    \  Each entry\n   in this table (also referred to as an \"FTN entry\" in this\
    \ document)\n   defines a rule to be applied to incoming packets (on interfaces\
    \ that\n   the entry is activated on using mplsFTNMapTable as explained in\n \
    \  Section 5.2) and an action to be taken on matching packets.\n   mplsFTNTable\
    \ allows 6-tuple matching rules based on one or more of\n   source address range,\
    \ destination address range, source port range,\n   destination port range, IPv4\
    \ Protocol field [RFC791] or IPv6 next-\n   header field [RFC2460], and the DiffServ\
    \ Code Point (DSCP, [RFC2474])\n   to be specified.  Packet redirection is based\
    \ on an action pointer\n   which points either at an mplsXCEntry in MPLS-LSR-STD-MIB\
    \ [RFC3813]\n   when the NHLFE is a non-TE LSP, or at an mplsTunnelEntry in MPLS-TE-\n\
    \   STD-MIB [RFC3812] when the NHLFE is the origin of a TE tunnel.\n"
- title: 5.1.1.  Advantages of Address Ranges Over CIDR Prefixes
  contents:
  - "5.1.1.  Advantages of Address Ranges Over CIDR Prefixes\n   One possible way\
    \ of specifying a set of addresses as part of an FTN\n   rule is to use CIDR prefixes\
    \ [RFC1519].  We have instead chosen to\n   allow FTN rules to be expressed in\
    \ terms of address ranges in\n   mplsFTNTable because they have the following\
    \ advantages.\n   -  The number of CIDR prefixes needed to represent some address\n\
    \      ranges is very large.  For example, we need the following 6 CIDR\n    \
    \  prefixes to represent the range of addresses [192.0.2.0-\n      192.0.2.62]:\
    \  192.0.2.0/27, 192.0.2.32/28, 192.0.2.48/29,\n      192.0.2.56/30, 192.0.2.60/31,\
    \ and 192.0.2.62/32.  A rule such as\n      \"redirect all packets with a source\
    \ address in the range\n      [192.0.2.0-192.0.2.62] and destination address in\
    \ the range\n      [192.0.2.128-192.0.2.190] to tunnel #2\" would require the\
    \ creation\n      of 36 conceptual rows in mplsFTNTable if the rules were expressed\n\
    \      as CIDR prefixes, but only a single conceptual row would be\n      required\
    \ if we used address ranges instead.\n   -  Every CIDR prefix can be expressed\
    \ as a single equivalent address\n      range.\n   -  A particular implementation\
    \ is free to translate the address\n      ranges specified in mplsFTNTable internally\
    \ to equivalent CIDR\n      prefixes, if it so chooses.  However, given that powerful\
    \ range\n      matching algorithms are available, many implementations may prefer\n\
    \      to implement these directly.\n"
- title: 5.2.  mplsFTNMapTable
  contents:
  - "5.2.  mplsFTNMapTable\n   This table provides the capability to activate or map\
    \ FTN entries\n   defined in mplsFTNTable to specific interfaces in the system.\n\
    \   Packets received on an interface are compared against FTN entries in\n   the\
    \ order in which entries are applied to the interface.\n"
- title: 5.2.1.  Indexing Requirements
  contents:
  - "5.2.1.  Indexing Requirements\n   The indexing structure of mplsFTNMapTable was\
    \ designed to satisfy the\n   following requirements.\n   -  We must be able to\
    \ insert a new entry into an existing list of\n      entries on an interface with\
    \ a single SET operation.  Thus, we\n      must be able to support an insertion\
    \ operation that does not\n      require manual reindexing of existing entries.\n\
    \   -  A management application must be able to traverse entries that\n      have\
    \ been applied to a particular interface in the order of\n      application. \
    \ The number of (non-bulk) retrieval operations to\n      obtain this information\
    \ as dictated by the particular indexing\n      scheme that we choose for mplsFTNMapTable\
    \ must be no more than\n      that dictated by any other indexing scheme.  For\
    \ example, the\n      indexing scheme must not force the Network Management Application\n\
    \      to retrieve all the entries in the table and sift through them\n      offline\
    \ to obtain this information.\n"
- title: 5.2.2.  How the Current Indexing Works
  contents:
  - "5.2.2.  How the Current Indexing Works\n   The natural data-structure for implementing\
    \ constant time insertions\n   between two existing entries and for supporting\
    \ in-order traversals\n   is a linked-list.\n   The chosen indexing structure\
    \ of mplsFTNMapTable makes the entries in\n   the table behave like items in a\
    \ linked-list.  Each conceptual row\n   has an object, mplsFTNMapPrevIndex, which\
    \ is a pointer to the\n   previous entry that is applied to a particular interface.\
    \  This\n   object is self-adjusting, i.e., its value is automatically adjusted\n\
    \   by the agent, if necessary, after an insertion or deletion operation.\n  \
    \ This indexing scheme provides a mechanism to 'insert' an FTN entry\n   between\
    \ two existing entries already applied on an interface.  This\n   is done by specifying\
    \ the entry after which a new entry should be\n   inserted in mplsFTNMapPrevIndex.\n\
    \   Using this linked-list structure, one can retrieve FTN entries in the\n  \
    \ order of application on a per-interface basis as follows:\n   -  To determine\
    \ the first FTN entry on an interface with index\n      ifIndex, perform a GETNEXT\
    \ retrieval operation on\n      mplsFTNMapRowStatus.ifIndex.0.0; the returned\
    \ object, if one\n      exists, is (say) mplsFTNMapRowStatus.ifIndex.0.n\n   \
    \   (mplsFTNMapRowStatus is the first accessible columnar object in\n      the\
    \ conceptual row).  Then, the index of the first FTN entry\n      applied on this\
    \ interface is n.\n   -  To determine the FTN entry applied to an interface after\
    \ the one\n      indexed by n, perform a GETNEXT retrieval operation on\n    \
    \  mplsFTNMapRowStatus.ifIndex.n.0.  If such an entry exists, the\n      returned\
    \ object would be of the form\n      mplsFTNMapRowStatus.ifIndex.n.m.  Then, the\
    \ index of the next FTN\n      entry applied on this interface is m.\n   -  If\
    \ the FTN entry indexed by n is the last entry applied to the\n      interface\
    \ with index ifIndex, then the object returned would\n      either be:\n     \
    \ 1. mplsFTNMapRowStatus.ifIndexNext.0.k, where ifIndexNext is the\n         index\
    \ of the next interface in ifTable to which an FTN entry\n         has been applied,\
    \ in which case k is the index of the first FTN\n         entry applied to the\
    \ interface with index ifIndexNext;\n      or:\n      2. mplsFTNMapStorageType.firstIfIndex.0.p,\
    \ if there are no more\n         entries in mplsFTNMapTable, where firstIfIndex\
    \ is the first\n         entry in ifTable to which an FTN entry has been mapped.\n\
    \   The above steps can be used to retrieve all the applied entries on a\n   per-interface\
    \ basis in application order.  Note that the number of\n   retrieval operations\
    \ is equal to the number of applied FTN entries\n   (i.e., the minimum number\
    \ of GETNEXT operations needed using any\n   indexing scheme).\n   Also note that\
    \ we could not have created this linked-list structure\n   using a 'next' pointer\
    \ object instead of the 'previous' pointer\n   object that we chose because this\
    \ would not allow us to determine the\n   first FTN entry that has been mapped\
    \ to a specific interface using a\n   single SNMP (non-bulk) retrieval operation.\n\
    \   The use of this indexing structure is further illustrated using an\n   example\
    \ in Section 7.\n"
- title: 5.3.  mplsFTNPerfTable
  contents:
  - "5.3.  mplsFTNPerfTable\n   If an FTN entry has been applied to one or more interfaces,\
    \ this\n   table provides high-capacity performance counters to monitor each\n\
    \   such FTN entry on a per-interface basis.\n"
- title: 6.  Avoiding Retrieval-Modification Interactions
  contents:
  - "6.  Avoiding Retrieval-Modification Interactions\n   The problem of an ongoing\
    \ traversal or retrieval operation on an SNMP\n   table being affected by a concurrent\
    \ modification operation on that\n   table is not unique to this MIB module. \
    \ However, it is useful to\n   note that a cautious application can keep track\
    \ of the state of the\n   modifiable tables in this MIB module using the objects\n\
    \   mplsFTNTableLastChanged and mplsFTNMapTableLastChanged.\n   For instance,\
    \ before performing a traversal of mplsFTNMapTable, the\n   application should\
    \ retrieve the value of mplsFTNMapTableLastChanged.\n   Each subsequent GETNEXT\
    \ operation on the table should include this\n   object as well.  For example,\
    \ GETNEXT(mplsFTNMapTableLastChanged.0,\n   mplsFTNMapRowStatus.ifIndex.n.0) can\
    \ be used to:\n   -  Determine the FTN entry after the one indexed by n (in linked-list\n\
    \      order) mapped to the interface with index ifIndex, as explained in\n  \
    \    Section 5.2.2;\n   - Verify that the value of mplsFTNMapTable has not been\
    \ modified\n      during the retrieval process by comparing the value of\n   \
    \   mplsFTNMapTableLastChanged retrieved by this operation with the\n      value\
    \ retrieved before the traversal was begun.\n   Using this technique, an application\
    \ can ensure the validity of the\n   retrieved information with minimal overhead.\
    \  This is particularly\n   important while retrieving information from frequently\
    \ modified\n   tables.\n"
- title: 7.  Example Illustrating MIB Module Components
  contents:
  - "7.  Example Illustrating MIB Module Components\n   In this section, we use an\
    \ example to illustrate how the objects\n   defined in MPLS-FTN-STD-MIB work together\
    \ to perform FEC to NHLFE\n   mapping.\n   Note that for the various table entries\
    \ involved in this example, we\n   only show the objects that help illustrate\
    \ each case.\n"
- title: 7.1.  Sample FTN Rules
  contents:
  - "7.1.  Sample FTN Rules\n   Suppose that we wish to activate the following two\
    \ FTN rules.\n      Rule #1: On interface ifIndex = 1, redirect packets with source\n\
    \      IPv4 address matching 192.0.2.63 to an LSP with outgoing\n      ifIndex\
    \ = 50 and outgoing label = 150 where the specified LSP is\n      represented\
    \ by the following entries in mplsXCTable and\n      mplsOutSegmentTable.\n  \
    \    In mplsXCTable:\n      {\n         mplsXCIndex = 0x02,\n         mplsXCInSegmentIndex\
    \ = 0x00,\n         mplsXCOutSegmentIndex = 0x03,\n         mplsXCLabelStackIndex\
    \ = 0\n      }\n      The value 0x00 for mplsXCInSegmentIndex represents an originating\n\
    \      LSP [RFC3813].\n      In mplsOutSegmentTable:\n      {\n         mplsOutSegmentIndex\
    \ = 0x03,\n         mplsOutSegmentIfIndex = 50,\n         mplsOutSegmentPushTopLabel\
    \ = true,\n         mplsOutSegmentTopLabel = 150\n      }\n      Rule #2: On interface\
    \ ifIndex = 1, redirect packets with\n      destination IPv4 addresses in the\
    \ range [192.0.2.32, 192.0.2.96]\n      to tunnel #4, where the specified tunnel\
    \ is represented by the\n      following entry in mplsTunnelTable:\n      {\n\
    \         mplsTunnelIndex = 4,\n         -- primary tunnel\n         mplsTunnelInstance\
    \ = 0,\n         mplsTunnelIngressLSRID = 192.0.2.1,\n         mplsTunnelEgressLSRID\
    \ = 192.0.2.2\n      }\n"
- title: 7.2.  Creating FTN Entries and Applying them to Interfaces
  contents:
  - "7.2.  Creating FTN Entries and Applying them to Interfaces\n   The action \"\
    redirect packets with source IPv4 address matching\n   192.0.2.63 to an LSP with\
    \ outgoing ifIndex = 50 and outgoing label =\n   150\" in Rule #1 can be implemented\
    \ by the following entry in\n   mplsFTNTable:\n      {\n         mplsFTNIndex\
    \ = 1,\n         mplsFTNDescr = \"Rule #1\",\n         -- source address only\n\
    \         mplsFTNMask = 0x80,\n         mplsFTNAddrType = ipv4,\n         mplsFTNSourceAddrMin\
    \ = 192.0.2.63,\n         mplsFTNSourceAddrMax = 192.0.2.63,\n         mplsFTNActionType\
    \ = redirectLsp(1),\n         mplsFTNActionPointer = mplsXCLspId.1.2.1.0.1.3\n\
    \      }\n   This indicates to which LSP the LSR should redirect packets by\n\
    \   setting mplsFTNActionPointer to the first accessible columnar object\n   instance\
    \ in mplsXCEntry that corresponds of the LSP to use, in this\n   case mplsXCLspId.1.2.1.0.1.3.\n\
    \   This action is then activated on \"interface ifIndex = 1\" by the\n   following\
    \ entry in mplsFTNMapTable to complete the implementation of\n   Rule #1:\n  \
    \    {\n         -- apply rule to interface ifIndex = 1\n         mplsFTNMapIndex\
    \ = 1,\n         -- first FTN entry on this interface\n         mplsFTNPrevIndex\
    \ = 0,\n         -- index of current entry in mplsFTNTable, i.e., Rule #1\n  \
    \       mplsFTNMapCurrIndex = 1\n      }\n   The action \"redirect packets with\
    \ destination IPv4 addresses in the\n   range [192.0.2.32, 192.0.2.96] to tunnel\
    \ #4\" in Rule #2 can be\n   implemented by the following entry in mplsFTNTable:\n\
    \      {\n         mplsFTNIndex = 2,\n         mplsFTNDescr = \"Rule #2\",\n \
    \        -- destination address only\n         mplsFTNMask = 0x40,\n         mplsFTNAddrType\
    \ = ipv4,\n         mplsFTNDestAddrMin = 192.0.2.32,\n         mplsFTNDestAddrMax\
    \ = 192.0.2.96,\n         mplsFTNActionType = redirectTunnel(2),\n         mplsFTNActionPointer\
    \ = mplsTunnelName.4.0.3221225985.3221225986\n      }\n   where 3221225985 and\
    \ 3221225986 are representations of the addresses\n   192.0.2.1 and 192.0.2.2,\
    \ respectively, as Unsigned32 (the underlying\n   data type) entities.\n   This\
    \ rule needs to be activated on \"interface ifIndex = 1\" after Rule\n   #1 which\
    \ was previously activated on this interface.  This is done by\n   the following\
    \ entry in mplsFTNMapTable to complete the implementation\n   of Rule #2:\n  \
    \    {\n         -- apply rule to interface ifIndex = 1\n         mplsFTNMapIndex\
    \ = 1,\n         -- insert after Rule #1 (mplsFTNIndex = 1)\n         mplsFTNPrevIndex\
    \ = 1,\n         -- index of current entry in mplsFTNTable, i.e., Rule #2\n  \
    \       mplsFTNMapCurrIndex = 2\n      }\n"
- title: 7.3.  Mapping an FTN Entry to Multiple Interfaces
  contents:
  - "7.3.  Mapping an FTN Entry to Multiple Interfaces\n   Suppose we now wish to\
    \ activate the following rule:\n      Rule #2b: On interface ifIndex = 2, redirect\
    \ packets with\n      destination IPv4 addresses in the range [192.0.2.32, 192.0.2.96]\n\
    \      to tunnel #4.\n   Notice that the FEC and corresponding action associated\
    \ with this\n   rule (i.e., \"redirect packets with destination IPv4 addresses\
    \ in the\n   range [192.0.2.32, 192.0.2.96] to tunnel #4\") are the same as that\n\
    \   associated with Rule #2.  Hence, we can reuse the existing entry with\n  \
    \ mplsFTNIndex = 2 from mplsFTNTable.\n   However, we have to create the following\
    \ new entry in mplsFTNMapTable\n   to activate this FTN entry as the first one\
    \ on the interface with\n   ifIndex = 2.\n   {\n      -- apply rule to interface\
    \ ifIndex = 2\n      mplsFTNMapIndex = 2,\n      -- first FTN entry on this interface\n\
    \      mplsFTNPrevIndex = 0,\n      -- index of current entry in mplsFTNTable\n\
    \      mplsFTNMapCurrIndex = 2\n   }\n"
- title: 7.4.  Inserting an Entry Into Existing List
  contents:
  - "7.4.  Inserting an Entry Into Existing List\n   At a later point, suppose that\
    \ we wish to introduce the following\n   Rule between Rules #1 and #2.\n     \
    \ Rule #3: On interface ifIndex = 1, redirect all packets with\n      destination\
    \ IPv4 address matching the prefix 192.0.2.32/28 to\n      tunnel #3, where the\
    \ tunnel we wish to redirect traffic to is\n      represented by the following\
    \ entry in mplsTunnelTable:\n      {\n         mplsTunnelIndex = 3,\n        \
    \ -- primary tunnel\n         mplsTunnelInstance = 0,\n         mplsTunnelIngressLSRID\
    \ = 192.0.2.3,\n         mplsTunnelEgressLSRID = 192.0.2.4\n      }\n   Note that\
    \ the ordering of the rules on a particular interface is\n   critical since the\
    \ range of addresses specified in Rule #3 is a\n   subset of the ones specified\
    \ in Rule #2.\n   Without the linked-list style insertion feature supported by\n\
    \   mplsFTNMapTable, we would possibly have had to reindex existing\n   entries\
    \ (or plan for such changes by leaving sufficient gaps between\n   indexes, something\
    \ that only postpones the problem).  With the\n   existing tables, we solve this\
    \ problem by creating the following\n   entries.\n   We implement the phrase \"\
    redirect all packets with destination IPv4\n   address matching the prefix 1.4.0.0/16\
    \ to tunnel #3\" in Rule #3 by\n   creating the following entry in mplsFTNTable:\n\
    \      {\n         mplsFTNIndex = 3,\n         mplsFTNDescr = \"Rule #3\",\n \
    \        -- destination address only\n         mplsFTNMask = 0x40,\n         mplsFTNAddrType\
    \ = ipv4,\n         -- address range equivalent to CIDR prefix 192.0.2.32/28\n\
    \         mplsFTNDestAddrMin = 192.0.2.32,\n         mplsFTNDestAddrMax = 192.0.2.47,\n\
    \         mplsFTNActionType = redirectTunnel,\n         mplsFTNActionPointer =\
    \ mplsTunnelName.3.0.3221225987.3221225988\n      }\n   where 3221225987 and 3221225988\
    \ are representations of the addresses\n   192.0.2.3 and 192.0.2.4, respectively,\
    \ as Unsigned32 (the underlying\n   data type) entities.\n   We next insert this\
    \ rule in mplsFTNMapTable just after Rule #1 as\n   follows:\n      {\n      \
    \   -- apply rule to interface ifIndex = 1\n         mplsFTNMapIndex = 1,\n  \
    \       -- insert after Rule #1 (mplsFTNIndex = 1)\n         mplsFTNPrevIndex\
    \ = 1,\n         -- index of current entry in mplsFTNTable i.e., Rule #3\n   \
    \      mplsFTNMapCurrIndex = 3\n      }\n   After the insertion of Rule #3 in\
    \ mplsFTNMapTable, the 'previous'\n   pointer object mplsFTNMapPrevIndex of the\
    \ next entry (corresponding\n   to Rule #2) adjusts automatically to point to\
    \ this entry.\n   Note that, of the existing entries in the table, the only one\
    \ that is\n   impacted by an insertion operation is the entry on that particular\n\
    \   interface immediately after the newly inserted one, if one exists.\n   None\
    \ of the other entries in mplsFTNMapTable are impacted.  For\n   instance, in\
    \ this particular example, when the entry for Rule #3 was\n   inserted between\
    \ those for Rules #1 and #2, the entries for Rules #1\n   and #2b were not impacted.\n"
- title: 7.5.  Pictorial Tabular Relationship
  contents:
  - "7.5.  Pictorial Tabular Relationship\n   At this point, the relationship between\
    \ different table entries can\n   be represented pictorially as follows.  For\
    \ each conceptual row\n   instance, we show the table that it belongs to, along\
    \ with its\n   indices in parentheses.  (Note that various conceptual rows are\n\
    \   depicted in a way that is convenient for showing the\n   interrelationships\
    \ and are not necessarily in lexicographical order.)\n             ifTable, The\
    \ Interfaces Group MIB [RFC2863]:\n          +-> ifEntry (1)\n          |    (ifIndex\
    \ = 1)\n          |\n          |  mplsFTNMapTable:\n          |   mplsFTNMapEntry\
    \ (1.0.1): <--------------------+\n          +<-- (mplsFTNMapIndex = 1,      \
    \                  |\n          |     mplsFTNMapPrevIndex = 0, ---> (NULL)   \
    \     |\n          |     mplsFTNMapCurrIndex = 1) ------------+      |\n     \
    \     |                                          |      |\n          |   mplsFTNMapEntry\
    \ (1.1.3): <------------------+ |\n          +<-- (mplsFTNMapIndex = 1,      \
    \           |    | |\n          |     mplsFTNMapPrevIndex = 1, ----------->+ \
    \   | |\n          |     mplsFTNMapCurrIndex = 3) ---------+  |    | |\n     \
    \     |                                       |  |    | |\n          |   mplsFTNMapEntry\
    \ (1.3.2): <----------------+ | |\n          +<-- (mplsFTNMapIndex = 1,      \
    \        |  |  | | |\n                mplsFTNMapPrevIndex = 3, -------->+  | \
    \ | | |\n                mplsFTNMapCurrIndex = 2) ----+    |  |  | | |\n     \
    \                                        |    |  |  | | |\n             mplsFTNTable:\
    \                   |    |  |  | | |\n              mplsFTNEntry (2):        \
    \      |    |  |  | | |\n          +--> (mplsFTNIndex = 2) <----------+    | \
    \ |  | | |\n          |                                       |  |  | | |\n  \
    \        |   mplsFTNEntry (3):                   |  |  | | |\n          |    (mplsFTNIndex\
    \ = 3) <---------------+  |  | | |\n          |                              \
    \            |  | | |\n          |   mplsFTNEntry (1):                      |\
    \  | | |\n          |    (mplsFTNIndex = 1) <------------------+  | | |\n    \
    \      |                                             | | |\n          |  mplsFTNPerfTable:\
    \                          | | |\n          |   mplsFTNPerfEntry (1.2):      \
    \             | | |\n          |    (mplsFTNPerfIndex = 1,                   |\
    \ | |\n          |     mplsFTNPerfCurrIndex = 2) --------------+ | |\n       \
    \   |                                               | |\n          |   mplsFTNPerfEntry\
    \ (1.3):                     | |\n          |    (mplsFTNPerfIndex = 1,      \
    \               | |\n          |      mplsFTNPerfCurrIndex = 3) ---------------+\
    \ |\n          |                                                 |\n         \
    \ |   mplsFTNPerfEntry (1.1):                       |\n          |    (mplsFTNPerfIndex\
    \ = 1,                       |\n          |     mplsFTNPerfCurrIndex = 1) ------------------+\n\
    \          |\n          |   mplsFTNPerfEntry (2.2):\n          |    (mplsFTNPerfIndex\
    \ = 2,\n          |     mplsFTNPerfCurrIndex = 2) ------------------+\n      \
    \    |                                                 |\n          |  ifTable,\
    \ The Interfaces Group MIB [RFC2863]:   |\n        +---> ifEntry (2):        \
    \                          |\n        | |    (ifIndex = 2)                   \
    \             |\n        | |                                                 |\n\
    \        | |   mplsFTNMapEntry (2.1.2): <--------------------+\n        +-----\
    \ (mplsFTNMapIndex = 2\n          |     mplsFTNMapPrevIndex = 0 ---> (NULL)\n\
    \          +---- mplsFTNMapCurrIndex = 2)\n"
- title: 7.6.  Deleting an Entry
  contents:
  - "7.6.  Deleting an Entry\n   Let us next look at how we can remove the recently\
    \ applied Rule #3\n   and how the existing conceptual rows behave in this situation.\n\
    \   The conceptual row corresponding to the application of Rule #3 to\n   interface\
    \ ifIndex = 1 has the following index values: mplsFTNMapIndex\n   = 1, mplsFTNMapPrevIndex\
    \ = 1, and mplsFTNMapCurrIndex = 3.  To delete\n   this conceptual row, the Network\
    \ Management Application performs a\n   SET operation setting the object instance\
    \ mplsFTNMapRowStatus.1.1.3\n   to the value destroy(6).  The agent then destroys\
    \ this conceptual\n   row.  It also automatically adjusts the object instance\
    \ of\n   mplsFTNMapPrevIndex corresponding to Rule #2 from the value 3 (i.e.,\n\
    \   pointing to the recently destroyed Rule #3) to the value 1 (i.e., to\n   Rule\
    \ #1).\n   At this point, the rules applied to interface ifIndex = 1 are Rule\
    \ #1\n   and Rule #2, in that order.  The relationship between different table\n\
    \   entries can be represented pictorially as follows.\n             ifTable,\
    \ The Interfaces Group MIB [RFC2863]:\n          +-> ifEntry (1)\n          |\
    \    (ifIndex = 1)\n          |\n          |  mplsFTNMapTable:\n          |  \
    \ mplsFTNMapEntry (1.0.1): <--------------------+\n          +<-- (mplsFTNMapIndex\
    \ = 1,                        |\n          |     mplsFTNMapPrevIndex = 0, --->\
    \ (NULL)        |\n          |     mplsFTNMapCurrIndex = 1) ------------+    \
    \  |\n          |                                          |      |\n        \
    \  |   mplsFTNMapEntry (1.1.2): <----------------+   |\n          +<-- (mplsFTNMapIndex\
    \ = 1,                 |  |   |\n                mplsFTNMapPrevIndex = 1, ------------+\
    \  |   |\n                mplsFTNMapCurrIndex = 2) ----+       |  |   |\n    \
    \                                         |       |  |   |\n             mplsFTNTable:\
    \                   |       |  |   |\n              mplsFTNEntry (2):        \
    \      |       |  |   |\n          +--> (mplsFTNIndex = 2) <----------+      \
    \ |  |   |\n          |                                          |  |   |\n  \
    \        |   mplsFTNEntry (3):                      |  |   |\n          |    (mplsFTNIndex\
    \ = 3)                    |  |   |\n          |                              \
    \            |  |   |\n          |   mplsFTNEntry (1):                      |\
    \  |   |\n          |    (mplsFTNIndex = 1) <------------------+  |   |\n    \
    \      |                                             |   |\n          |  mplsFTNPerfTable:\
    \                          |   |\n          |   mplsFTNPerfEntry (1.2):      \
    \             |   |\n          |    (mplsFTNPerfIndex = 1,                   |\
    \   |\n          |     mplsFTNPerfCurrIndex = 2) --------------+   |\n       \
    \   |                                                 |\n          |   mplsFTNPerfEntry\
    \ (1.1):                       |\n          |    (mplsFTNPerfIndex = 1,      \
    \                 |\n          |     mplsFTNPerfCurrIndex = 1) ------------------+\n\
    \          |\n          |   mplsFTNPerfEntry (2.2):\n          |    (mplsFTNPerfIndex\
    \ = 2,\n          |     mplsFTNPerfCurrIndex = 2) ------------------+\n      \
    \    |                                                 |\n          |  ifTable,\
    \ The Interfaces Group MIB [RFC2863]:   |\n        +---> ifEntry (2):        \
    \                          |\n        | |    (ifIndex = 2)                   \
    \             |\n        | |                                                 |\n\
    \        | |   mplsFTNMapEntry (2.1.2): <--------------------+\n        +-----\
    \ (mplsFTNMapIndex = 2\n          |     mplsFTNMapPrevIndex = 0 ---> (NULL)\n\
    \          +---- mplsFTNMapCurrIndex = 2)\n   Note that the FTN entry for Rule\
    \ #3 still exists in mplsFTNTable at\n   this point but is not referenced by any\
    \ conceptual row in\n   mplsFTNMapTable or mplsFTNPerfTable.\n   Also note that\
    \ the deletion of an entry from mplsFTNMapTable only\n   impacts the entry on\
    \ that particular interface immediately after the\n   deleted entry, if one exists.\
    \  None of the other conceptual rows in\n   mplsFTNMapTable are impacted.  For\
    \ instance, in this particular\n   example, when the entry for Rule #3 was deleted,\
    \ the entries for\n   Rules #1 and #2b were not impacted.\n"
- title: 8.  The Use of RowPointer
  contents:
  - "8.  The Use of RowPointer\n   RowPointer is a textual convention used to identify\
    \ a conceptual row\n   in a conceptual table in a MIB by pointing to the first\
    \ accessible\n   object.  In this MIB module, in mplsFTNTable, the RowPointer\
    \ object\n   mplsFTNActionPointer indicates the LSP or TE Tunnel to redirect\n\
    \   packets matching an FTN entry to.  This object MUST point to the\n   first\
    \ instance of the first accessible columnar object in the\n   appropriate conceptual\
    \ row in order to allow the manager to find the\n   appropriate corresponding\
    \ entry in either MPLS-LSR-STD-MIB [RFC3813]\n   or MPLS-TE-STD-MIB [RFC3812].\
    \  If this object returns zeroDotZerok,\n   it implies that there is no currently\
    \ defined action that is\n   associated with that particular FTN entry.\n"
- title: 9.  MPLS-FTN-STD-MIB Definitions
  contents:
  - "9.  MPLS-FTN-STD-MIB Definitions\n   MPLS-FTN-STD-MIB DEFINITIONS ::= BEGIN\n\
    \   IMPORTS\n      MODULE-IDENTITY, OBJECT-TYPE, Unsigned32, Counter64, Integer32\n\
    \          FROM SNMPv2-SMI                                   -- [RFC2578]\n  \
    \    RowStatus, StorageType, RowPointer,\n      TEXTUAL-CONVENTION, TimeStamp\n\
    \          FROM SNMPv2-TC                                    -- [RFC2579]\n  \
    \    MODULE-COMPLIANCE, OBJECT-GROUP\n          FROM SNMPv2-CONF             \
    \                     -- [RFC2580]\n      InterfaceIndexOrZero,\n      ifGeneralInformationGroup,\
    \ ifCounterDiscontinuityGroup\n          FROM IF-MIB                         \
    \              -- [RFC2863]\n      SnmpAdminString\n          FROM SNMP-FRAMEWORK-MIB\
    \                           -- [RFC3411]\n      Dscp\n          FROM DIFFSERV-DSCP-TC\
    \                             -- [RFC3289]\n      InetAddressType, InetAddress,\
    \ InetPortNumber\n          FROM INET-ADDRESS-MIB                            \
    \ -- [RFC3291]\n      mplsStdMIB\n          FROM MPLS-TC-STD-MIB             \
    \                 -- [RFC3811]\n      ;\n   mplsFTNStdMIB MODULE-IDENTITY\n  \
    \    LAST-UPDATED \"200406030000Z\"  -- June 6, 2004\n      ORGANIZATION \"Multiprotocol\
    \ Label Switching (MPLS) Working Group\"\n      CONTACT-INFO\n          \"\n \
    \                  Thomas D. Nadeau\n           Postal: Cisco Systems, Inc.\n\
    \                   250 Apollo Drive\n                   Chelmsford, MA 01824\n\
    \           Tel:    +1-978-244-3051\n           Email:  tnadeau@cisco.com\n  \
    \                 Cheenu Srinivasan\n           Postal: Bloomberg L.P.\n     \
    \              499 Park Avenue\n                   New York, NY 10022\n      \
    \     Tel:    +1-212-893-3682\n           Email:  cheenu@bloomberg.net\n     \
    \              Arun Viswanathan\n           Postal: Force10 Networks, Inc.\n \
    \                  1440 McCarthy Blvd\n                   Milpitas, CA 95035\n\
    \           Tel:    +1-408-571-3516\n           Email:  arunv@force10networks.com\n\
    \           IETF MPLS Working Group email: mpls@uu.net\"\n      DESCRIPTION\n\
    \           \"Copyright (C) The Internet Society (2004). The\n           initial\
    \ version of this MIB module was published\n           in RFC 3814. For full legal\
    \ notices see the RFC\n           itself or see:\n           http://www.ietf.org/copyrights/ianamib.html\n\
    \           This MIB module contains managed object definitions for\n        \
    \   specifying FEC to NHLFE (FTN) mappings and corresponding\n           performance\
    \ for MPLS.\"\n      -- Revision history.\n      REVISION\n          \"200406030000Z\"\
    \  -- June 3, 2004\n      DESCRIPTION\n          \"Initial version issued as part\
    \ of RFC 3814.\"\n       ::= { mplsStdMIB 8 }\n   -- TEXTUAL-CONVENTIONs used\
    \ in this MIB.\n   MplsFTNEntryIndex ::= TEXTUAL-CONVENTION\n      STATUS    \
    \          current\n      DESCRIPTION\n          \"Index for an entry in mplsFTNTable.\"\
    \n      SYNTAX              Unsigned32 (1..4294967295)\n   MplsFTNEntryIndexOrZero\
    \ ::= TEXTUAL-CONVENTION\n      STATUS              current\n      DESCRIPTION\n\
    \          \"Index for an entry in mplsFTNTable or the special value\n       \
    \    zero. The value zero is object-specific and must\n           therefore be\
    \ defined as part of the description of any\n           object which uses this\
    \ syntax.  Examples of the usage\n           of zero might include situations\
    \ when none or all\n           entries in mplsFTNTable need to be referenced.\"\
    \n      SYNTAX              Unsigned32 (0..4294967295)\n   -- Top-Level Components\
    \ of this MIB.\n   mplsFTNNotifications OBJECT IDENTIFIER ::= { mplsFTNStdMIB\
    \ 0 }\n   mplsFTNObjects       OBJECT IDENTIFIER ::= { mplsFTNStdMIB 1 }\n   mplsFTNConformance\
    \   OBJECT IDENTIFIER ::= { mplsFTNStdMIB 2 }\n   -- Next free index in mplsFTNTable.\n\
    \   mplsFTNIndexNext OBJECT-TYPE\n      SYNTAX              MplsFTNEntryIndexOrZero\n\
    \      MAX-ACCESS          read-only\n      STATUS              current\n    \
    \  DESCRIPTION\n          \"This object contains the next available valid value\
    \ to\n           be used for mplsFTNIndex when creating entries in the\n     \
    \      mplsFTNTable.\n           When creating a new conceptual row (configuration\n\
    \           entry) in mplsFTNTable with an SNMP SET operation the\n          \
    \ command generator (Network Management Application) must\n           first issue\
    \ a management protocol retrieval operation\n           to obtain the current\
    \ value of this object.\n           If the command responder (agent) does not\
    \ wish to allow\n           creation of more entries in mplsFTNTable, possibly\n\
    \           because of resource exhaustion, this object MUST return\n        \
    \   a value of 0.\n           If a non-zero value is returned the Network Management\n\
    \           Application must determine whether the value is indeed\n         \
    \  still unused since two Network Management Applications\n           may attempt\
    \ to create a row simultaneously and use the\n           same value.\n       \
    \    If it is currently unused and the SET succeeds, the\n           agent MUST\
    \ change the value of this object to a\n           currently unused non-zero value\
    \ (according to an\n           implementation specific algorithm) or zero (if\
    \ no\n           further row creation will be permitted).\n           If the value\
    \ is in use, however, the SET fails and the\n           Network Management Application\
    \ must then reread this\n           object to obtain a new usable value.\"\n \
    \     ::= { mplsFTNObjects 1 }\n   -- Last time an object in mplsFTNTable changed.\n\
    \   mplsFTNTableLastChanged OBJECT-TYPE\n      SYNTAX              TimeStamp\n\
    \      MAX-ACCESS          read-only\n      STATUS              current\n    \
    \  DESCRIPTION\n          \"Indicates the last time an entry was added, deleted\
    \ or\n           modified in mplsFTNTable.  Management stations should\n     \
    \      consult this object to determine if mplsFTNTable\n           requires their\
    \ attention.  This object is particularly\n           useful for applications\
    \ performing a retrieval on\n           mplsFTNTable to ensure that the table\
    \ is not modified\n           during the retrieval operation.\"\n      ::=  {\
    \ mplsFTNObjects 2 }\n   -- Table of FTN entries.\n   mplsFTNTable  OBJECT-TYPE\n\
    \      SYNTAX          SEQUENCE OF MplsFTNEntry\n      MAX-ACCESS      not-accessible\n\
    \      STATUS          current\n      DESCRIPTION\n          \"This table contains\
    \ the currently defined FTN entries.\n           This table allows FEC to NHLFE\
    \ mappings to be\n           specified.  Each entry in this table defines a rule\
    \ to\n           be applied to incoming packets (on interfaces that the\n    \
    \       FTN entry is activated on using mplsFTNMapTable) and an\n           action\
    \ to be taken on matching packets\n           (mplsFTNActionPointer).\n      \
    \     This table supports 6-tuple matching rules based on one\n           or more\
    \ of source address range, destination address\n           range, source port\
    \ range, destination port range, IPv4\n           Protocol field or IPv6 next-header\
    \ field and the\n           DiffServ Code Point (DSCP) to be specified.\n    \
    \       The action pointer points either to instance of\n           mplsXCEntry\
    \ in MPLS-LSR-STD-MIB when the NHLFE is a non-\n           TE LSP, or to an instance\
    \ of mplsTunnelEntry in the\n           MPLS-TE-STD-MIB when the NHLFE is an originating\
    \ TE\n           tunnel.\"\n      REFERENCE\n          \"J. Postel, Internet Protocol,\
    \ RFC 791, STD 5, September\n           1981\n           Deering, S., and R. Hinden,\
    \ Internet Protocol, Version\n           6 (IPv6) Specification, RFC 2460, December\
    \ 1998\n           Nichols, K, Blake, S., Baker, F. and D. Black,\n          \
    \ Definition of the Differentiated Services Field (DS\n           Field) in the\
    \ IPv4 and IPv6 Headers, RFC 2474, December\n           1998\n           Srinivasan,\
    \ C., A. Viswanathan, and T. Nadeau, MPLS\n           Label Switch Router Management\
    \ Information Base,\n           RFC 3813\n           Srinivasan, C., A. Viswanathan,\
    \ and T. Nadeau, MPLS\n           Traffic Engineering Management Information Base,\n\
    \           RFC 3812\"\n      ::=  { mplsFTNObjects 3 }\n   mplsFTNEntry  OBJECT-TYPE\n\
    \      SYNTAX          MplsFTNEntry\n      MAX-ACCESS      not-accessible\n  \
    \    STATUS          current\n      DESCRIPTION\n          \"Each entry represents\
    \ one FTN entry which defines a\n           rule to compare incoming packets with\
    \ and an action to\n           be taken on matching packets.\"\n      INDEX {\
    \ mplsFTNIndex }\n      ::=  { mplsFTNTable 1 }\n   MplsFTNEntry  ::=  SEQUENCE\
    \ {\n         mplsFTNIndex               MplsFTNEntryIndex,\n         mplsFTNRowStatus\
    \           RowStatus,\n         mplsFTNDescr               SnmpAdminString,\n\
    \         mplsFTNMask                BITS,\n         mplsFTNAddrType         \
    \   InetAddressType,\n         mplsFTNSourceAddrMin       InetAddress,\n     \
    \    mplsFTNSourceAddrMax       InetAddress,\n         mplsFTNDestAddrMin    \
    \     InetAddress,\n         mplsFTNDestAddrMax         InetAddress,\n       \
    \  mplsFTNSourcePortMin       InetPortNumber,\n         mplsFTNSourcePortMax \
    \      InetPortNumber,\n         mplsFTNDestPortMin         InetPortNumber,\n\
    \         mplsFTNDestPortMax         InetPortNumber,\n         mplsFTNProtocol\
    \            Integer32,\n         mplsFTNDscp                Dscp,\n         mplsFTNActionType\
    \          INTEGER,\n         mplsFTNActionPointer       RowPointer,\n       \
    \  mplsFTNStorageType         StorageType\n      }\n   mplsFTNIndex   OBJECT-TYPE\n\
    \      SYNTAX              MplsFTNEntryIndex\n      MAX-ACCESS          not-accessible\n\
    \      STATUS              current\n      DESCRIPTION\n          \"This is the\
    \ unique index for a conceptual row in\n           mplsFTNTable.\n           To\
    \ create a new conceptual row in mplsFTNTable a\n           Network Management\
    \ Application SHOULD retrieve the\n           current value of mplsFTNIndexNext\
    \ to determine the next\n           valid available value of mplsFTNIndex.\"\n\
    \      ::= { mplsFTNEntry 1 }\n   mplsFTNRowStatus OBJECT-TYPE\n      SYNTAX \
    \             RowStatus\n      MAX-ACCESS          read-create\n      STATUS \
    \             current\n      DESCRIPTION\n          \"Used for controlling the\
    \ creation and deletion of this\n           row. All writeable objects in this\
    \ row may be modified\n           at any time. If a Network Management Application\n\
    \           attempts to delete a conceptual row by setting this\n           object\
    \ to 'destroy' and there are one or more entries\n           in mplsFTNMapTable\
    \ pointing to the row (i.e., when\n           mplsFTNIndex of the conceptual row\
    \ being deleted is\n           equal to mplsFTNMapCurrIndex for one or more entries\
    \ in\n           mplsFTNMapTable), the agent MUST also destroy the\n         \
    \  corresponding entries in mplsFTNMapTable.\"\n      ::= { mplsFTNEntry 2 }\n\
    \   mplsFTNDescr   OBJECT-TYPE\n      SYNTAX              SnmpAdminString\n  \
    \    MAX-ACCESS          read-create\n      STATUS              current\n    \
    \  DESCRIPTION\n          \"The description of this FTN entry. Since the index\
    \ for\n           this table has no particular significance or meaning,\n    \
    \       this object should contain some meaningful text that an\n           operator\
    \ could use to further distinguish entries in\n           this table.\"\n    \
    \  ::= { mplsFTNEntry 3 }\n   mplsFTNMask OBJECT-TYPE\n      SYNTAX          \
    \   BITS {\n                          sourceAddr(0),\n                       \
    \   destAddr(1),\n                          sourcePort(2),\n                 \
    \         destPort(3),\n                          protocol(4),\n             \
    \             dscp(5)\n                         }\n      MAX-ACCESS          read-create\n\
    \      STATUS              current\n      DESCRIPTION\n          \"This bit map\
    \ indicates which of the fields described\n           next, namely source address\
    \ range, destination address\n           range, source port range, destination\
    \ port range, IPv4\n           Protocol field or IPv6 next-header field and\n\
    \           Differentiated Services Code Point (DSCP) is active for\n        \
    \   this FTN entry. If a particular bit is set to zero then\n           the corresponding\
    \ field in the packet MUST be ignored\n           for comparison purposes.\"\n\
    \      ::= { mplsFTNEntry 4 }\n   mplsFTNAddrType OBJECT-TYPE\n      SYNTAX  \
    \           InetAddressType\n      MAX-ACCESS         read-create\n      STATUS\
    \             current\n      DESCRIPTION\n          \"This object determines the\
    \ type of address contained in\n           the source and destination address\
    \ objects\n           (mplsFTNSourceAddrMin, mplsFTNSourceAddrMax,\n         \
    \  mplsFTNDestAddrMin and mplsFTNDestAddrMax) of a\n           conceptual row.\n\
    \           This object MUST NOT be set to unknown(0) when\n           mplsFTNMask\
    \ has bit positions sourceAddr(0) or\n           destAddr(1) set to one.\n   \
    \        When both these bit positions of mplsFTNMask are set to\n           zero\
    \ the value of mplsFTNAddrType SHOULD be set to\n           unknown(0) and the\
    \ corresponding source and destination\n           address objects SHOULD be set\
    \ to zero-length strings.\"\n      ::= { mplsFTNEntry 5 }\n   mplsFTNSourceAddrMin\
    \ OBJECT-TYPE\n      SYNTAX             InetAddress\n      MAX-ACCESS        \
    \ read-create\n      STATUS             current\n      DESCRIPTION\n         \
    \ \"The lower end of the source address range. The type of\n           this object\
    \ is determined by the corresponding\n           mplsFTNAddrType object.\"\n \
    \     ::= { mplsFTNEntry 6 }\n   mplsFTNSourceAddrMax OBJECT-TYPE\n      SYNTAX\
    \             InetAddress\n      MAX-ACCESS         read-create\n      STATUS\
    \             current\n      DESCRIPTION\n          \"The upper end of the source\
    \ address range. The type of\n           this object is determined by the corresponding\n\
    \           mplsFTNAddrType object.\"\n      ::= { mplsFTNEntry 7 }\n   mplsFTNDestAddrMin\
    \ OBJECT-TYPE\n      SYNTAX             InetAddress\n      MAX-ACCESS        \
    \ read-create\n      STATUS             current\n      DESCRIPTION\n         \
    \ \"The lower end of the destination address range. The\n           type of this\
    \ object is determined by the corresponding\n           mplsFTNAddrType object.\"\
    \n      ::= { mplsFTNEntry 8 }\n   mplsFTNDestAddrMax OBJECT-TYPE\n      SYNTAX\
    \             InetAddress\n      MAX-ACCESS         read-create\n      STATUS\
    \             current\n      DESCRIPTION\n          \"The higher end of the destination\
    \ address range. The\n           type of this object is determined by the corresponding\n\
    \           mplsFTNAddrType object.\"\n      ::= { mplsFTNEntry 9 }\n   mplsFTNSourcePortMin\
    \ OBJECT-TYPE\n      SYNTAX             InetPortNumber\n      MAX-ACCESS     \
    \    read-create\n      STATUS             current\n      DESCRIPTION\n      \
    \    \"The lower end of the source port range.\"\n      DEFVAL { 0 }\n      ::=\
    \ { mplsFTNEntry 10 }\n   mplsFTNSourcePortMax OBJECT-TYPE\n      SYNTAX     \
    \        InetPortNumber\n      MAX-ACCESS         read-create\n      STATUS  \
    \           current\n      DESCRIPTION\n          \"The higher end of the source\
    \ port range \"\n      DEFVAL { 65535 }\n      ::= { mplsFTNEntry 11 }\n   mplsFTNDestPortMin\
    \ OBJECT-TYPE\n      SYNTAX             InetPortNumber\n      MAX-ACCESS     \
    \    read-create\n      STATUS             current\n      DESCRIPTION\n      \
    \    \"The lower end of the destination port range.\"\n      DEFVAL { 0 }\n  \
    \    ::= { mplsFTNEntry 12 }\n   mplsFTNDestPortMax OBJECT-TYPE\n      SYNTAX\
    \             InetPortNumber\n      MAX-ACCESS         read-create\n      STATUS\
    \             current\n      DESCRIPTION\n          \"The higher end of the destination\
    \ port range.\"\n      DEFVAL { 65535 }\n      ::= { mplsFTNEntry 13 }\n   mplsFTNProtocol\
    \ OBJECT-TYPE\n      SYNTAX             Integer32 (0..255)\n      MAX-ACCESS \
    \        read-create\n      STATUS             current\n      DESCRIPTION\n  \
    \        \"The IP protocol to match against the IPv4 protocol\n           number\
    \ or IPv6 Next-Header number in the packet. A\n           value of 255 means match\
    \ all.  Note that the protocol\n           number of 255 is reserved by IANA,\
    \ and Next-Header\n           number of 0 is used in IPv6.\"\n      DEFVAL { 255\
    \ }\n      ::= { mplsFTNEntry 14 }\n   mplsFTNDscp OBJECT-TYPE\n      SYNTAX \
    \            Dscp\n      MAX-ACCESS         read-create\n      STATUS        \
    \     current\n      DESCRIPTION\n          \"The contents of the DSCP field.\"\
    \n      REFERENCE\n          \"Nichols, K., Blake, S., Baker, F. and D. Black,\n\
    \           Definition of the Differentiated Services Field (DS\n           Field)\
    \ in the IPv4 and IPv6 Headers, RFC 2474, December\n           1998.\"\n     \
    \ ::= { mplsFTNEntry 15 }\n   mplsFTNActionType OBJECT-TYPE\n      SYNTAX    INTEGER\
    \ {\n                   redirectLsp(1),   -- redirect into LSP\n             \
    \      redirectTunnel(2) -- redirect into tunnel\n                }\n      MAX-ACCESS\
    \         read-create\n      STATUS             current\n      DESCRIPTION\n \
    \         \"The type of action to be taken on packets matching this\n        \
    \   FTN entry.\"\n      ::= { mplsFTNEntry 16 }\n   mplsFTNActionPointer OBJECT-TYPE\n\
    \      SYNTAX             RowPointer\n      MAX-ACCESS         read-create\n \
    \     STATUS             current\n      DESCRIPTION\n          \"If mplsFTNActionType\
    \ is redirectLsp(1), then this\n           object MUST contain zeroDotZero or\
    \ point to a instance\n           of mplsXCEntry indicating the LSP to redirect\
    \ matching\n           packets to.\n           If mplsFTNActionType is redirectTunnel(2),\
    \ then this\n           object MUST contain zeroDotZero or point to a instance\n\
    \           of mplsTunnelEntry indicating the MPLS TE tunnel to\n           redirect\
    \ matching packets to.\n           If this object points to a conceptual row instance\
    \ in a\n           table consistent with mplsFTNActionType but this\n        \
    \   instance does not currently exist then no action will\n           be taken\
    \ on packets matching such an FTN entry till\n           this instance comes into\
    \ existence.\n           If this object contains zeroDotZero then no action will\n\
    \           be taken on packets matching such an FTN entry till it\n         \
    \  is populated with a valid pointer consistent with the\n           value of\
    \ mplsFTNActionType as explained above.\"\n      ::= { mplsFTNEntry 17 }\n   mplsFTNStorageType\
    \ OBJECT-TYPE\n      SYNTAX             StorageType\n      MAX-ACCESS        \
    \ read-create\n      STATUS             current\n      DESCRIPTION\n         \
    \ \"The storage type for this FTN entry. Conceptual rows\n           having the\
    \ value 'permanent' need not allow write-\n           access to any columnar objects\
    \ in the row.\"\n      DEFVAL { nonVolatile }\n      ::= { mplsFTNEntry 18 }\n\
    \   -- End of mplsFTNTable.\n   -- Last time an object in mplsFTNMapTable changed.\n\
    \   mplsFTNMapTableLastChanged OBJECT-TYPE\n      SYNTAX              TimeStamp\n\
    \      MAX-ACCESS          read-only\n      STATUS              current\n    \
    \  DESCRIPTION\n          \"Indicates the last time an entry was added, deleted\
    \ or\n           modified in mplsFTNMapTable. Management stations should\n   \
    \        consult this object to determine if the table requires\n           their\
    \ attention.  This object is particularly useful\n           for applications\
    \ performing a retrieval on\n           mplsFTNMapTable to ensure that the table\
    \ is not\n           modified during the retrieval operation.\"\n      ::=  {\
    \ mplsFTNObjects 4 }\n   -- FTN to interface mapping table.\n   mplsFTNMapTable\
    \ OBJECT-TYPE\n      SYNTAX              SEQUENCE OF MplsFTNMapEntry\n      MAX-ACCESS\
    \          not-accessible\n      STATUS              current\n      DESCRIPTION\n\
    \          \"This table contains objects which provide the\n           capability\
    \ to apply or map FTN rules as defined by\n           entries in mplsFTNTable\
    \ to specific interfaces in the\n           system.  FTN rules are compared with\
    \ incoming packets\n           in the order in which they are applied on an interface.\n\
    \           The indexing structure of mplsFTNMapTable is as\n           follows.\n\
    \           - mplsFTNMapIndex indicates the interface to which the\n         \
    \    rule is being applied.  A value of 0 represents the\n             application\
    \ of the rule to all interfaces.\n           - mplsFTNMapPrevIndex specifies the\
    \ rule on the\n             interface prior to the one being applied.  A value\
    \ of\n             0 specifies that the rule is being inserted at the\n      \
    \       head of the list of rules currently applied to the\n             interface.\n\
    \           - mplsFTNMapCurrIndex is the index in mplsFTNTable\n             corresponding\
    \ to the rule being applied.\n           This indexing structure makes the entries\
    \ in the table\n           behave like items in a linked-list.  The object\n \
    \          mplsFTNMapPrevIndex in each conceptual row is a pointer\n         \
    \  to the previous entry that is applied to a particular\n           interface.\
    \  This allows a new entry to be 'inserted' at\n           an arbitrary position\
    \ in a list of entries currently\n           applied to an interface.  This object\
    \ is self-\n           adjusting, i.e., its value is automatically adjusted by\n\
    \           the agent, if necessary, after an insertion or deletion\n        \
    \   operation.\n           Using this linked-list structure, one can retrieve\
    \ FTN\n           entries in the order of application on a per-interface\n   \
    \        basis as follows:\n           - To determine the first FTN entry on an\
    \ interface\n             with index ifIndex perform a GETNEXT retrieval\n   \
    \          operation on mplsFTNMapRowStatus.ifIndex.0.0; the\n             returned\
    \ object, if one exists, is (say)\n             mplsFTNMapRowStatus.ifIndex.0.n\
    \ (mplsFTNMapRowStatus\n             is the first accessible columnar object in\
    \ the\n             conceptual row). Then the index of the first FTN\n       \
    \      entry applied on this interface is n.\n           - To determine the FTN\
    \ entry applied to an interface\n             after the one indexed by n perform\
    \ a GETNEXT\n             retrieval operation on\n             mplsFTNMapRowStatus.ifIndex.n.0.\
    \  If such an entry\n             exists the returned object would be of the form\n\
    \             mplsFTNMapRowStatus.ifIndex.n.m.  Then the index of\n          \
    \   the next FTN entry applied on this interface is m.\n           - If the FTN\
    \ entry indexed by n is the last entry\n             applied to the interface\
    \ with index ifIndex then the\n             object returned would either be:\n\
    \             1.mplsFTNMapRowStatus.ifIndexNext.0.k, where\n               ifIndexNext\
    \ is the index of the next interface in\n               ifTable to which an FTN\
    \ entry has been applied, in\n               which case k is the index of the\
    \ first FTN entry\n               applied to the interface with index ifIndexNext;\n\
    \             or:\n             2.mplsFTNMapStorageType.firstIfIndex.0.p, if there\n\
    \               are no more entries in mplsFTNMapTable, where\n              \
    \ firstIfIndex is the first entry in ifTable to\n               which an FTN entry\
    \ has been mapped.\n           Use the above steps to retrieve all the applied\
    \ FTN\n           entries on a per-interface basis in application order.\n   \
    \        Note that the number of retrieval operations is the\n           same\
    \ as the number of applied FTN entries (i.e., the\n           minimum number of\
    \ GETNEXT operations needed using any\n           indexing scheme).\n        \
    \   Agents MUST NOT allow the same FTN entry as specified\n           by mplsFTNMapCurrIndex\
    \ to be applied multiple times to\n           the same interface.\n          \
    \ Agents MUST NOT allow the creation of rows in this\n           table until the\
    \ corresponding rows are created in the\n           mplsFTNTable.\n          \
    \ If a row in mplsFTNTable is destroyed, the agent MUST\n           destroy the\
    \ corresponding entries (i.e., ones with a\n           matching value of mplsFTNCurrIndex)\
    \ in this table as\n           well.\"\n      ::=  { mplsFTNObjects 5 }\n   mplsFTNMapEntry\
    \ OBJECT-TYPE\n      SYNTAX              MplsFTNMapEntry\n      MAX-ACCESS   \
    \       not-accessible\n      STATUS              current\n      DESCRIPTION\n\
    \          \"Each conceptual row represents the application of an\n          \
    \ FTN rule at a specific position in the list of FTN\n           rules applied\
    \ on an interface. \"\n      INDEX {\n            mplsFTNMapIndex,\n         \
    \   mplsFTNMapPrevIndex,\n            mplsFTNMapCurrIndex\n      }\n      ::=\
    \  { mplsFTNMapTable 1 }\n   MplsFTNMapEntry  ::=  SEQUENCE {\n         mplsFTNMapIndex\
    \       InterfaceIndexOrZero,\n         mplsFTNMapPrevIndex    MplsFTNEntryIndexOrZero,\n\
    \         mplsFTNMapCurrIndex    MplsFTNEntryIndex,\n         mplsFTNMapRowStatus\
    \    RowStatus,\n         mplsFTNMapStorageType  StorageType\n      }\n   mplsFTNMapIndex\
    \ OBJECT-TYPE\n      SYNTAX              InterfaceIndexOrZero\n      MAX-ACCESS\
    \          not-accessible\n      STATUS              current\n      DESCRIPTION\n\
    \          \"The interface index that this FTN entry is being\n           applied\
    \ to. A value of zero indicates an entry that is\n           applied all interfaces.\n\
    \           Entries mapped to an interface by specifying its (non-\n         \
    \  zero) interface index in mplsFTNMapIndex are applied\n           ahead of entries\
    \ with mplsFTNMapIndex equal to zero.\"\n      ::= { mplsFTNMapEntry 1 }\n   mplsFTNMapPrevIndex\
    \ OBJECT-TYPE\n      SYNTAX              MplsFTNEntryIndexOrZero\n      MAX-ACCESS\
    \          not-accessible\n      STATUS              current\n      DESCRIPTION\n\
    \          \"The index of the previous FTN entry that was applied to\n       \
    \    this interface. The special value zero indicates that\n           this should\
    \ be the first FTN entry in the list.\"\n      ::=  { mplsFTNMapEntry 2 }\n  \
    \ mplsFTNMapCurrIndex OBJECT-TYPE\n      SYNTAX              MplsFTNEntryIndex\n\
    \      MAX-ACCESS          not-accessible\n      STATUS              current\n\
    \      DESCRIPTION\n          \"Index of the current FTN entry that is being applied\
    \ to\n           this interface.\"\n      ::=  { mplsFTNMapEntry 3 }\n   mplsFTNMapRowStatus\
    \ OBJECT-TYPE\n      SYNTAX              RowStatus {\n                       \
    \         active(1),\n                                createAndGo(4),\n      \
    \                          destroy(6)\n                             }\n      MAX-ACCESS\
    \          read-create\n      STATUS              current\n      DESCRIPTION\n\
    \          \"Used for controlling the creation and deletion of this\n        \
    \   row.\n           All writable objects in this row may be modified at any\n\
    \           time.\n           If a conceptual row in mplsFTNMapTable points to\
    \ a\n           conceptual row in mplsFTNTable which is subsequently\n       \
    \    deleted, the corresponding conceptual row in\n           mplsFTNMapTable\
    \ MUST also be deleted by the agent.\"\n      ::=  { mplsFTNMapEntry 4 }\n   mplsFTNMapStorageType\
    \ OBJECT-TYPE\n      SYNTAX              StorageType\n      MAX-ACCESS       \
    \   read-create\n      STATUS              current\n      DESCRIPTION\n      \
    \    \"The storage type for this entry.  Conceptual rows\n           having the\
    \ value 'permanent' need not allow write-\n           access to any columnar objects\
    \ in this row.\"\n      DEFVAL { nonVolatile }\n      ::= { mplsFTNMapEntry 5\
    \ }\n   -- End of mplsFTNMapTable\n   -- FTN entry performance table\n   mplsFTNPerfTable\
    \ OBJECT-TYPE\n      SYNTAX              SEQUENCE OF MplsFTNPerfEntry\n      MAX-ACCESS\
    \          not-accessible\n      STATUS              current\n      DESCRIPTION\n\
    \          \"This table contains performance statistics on FTN\n           entries\
    \ on a per-interface basis.\"\n      ::= { mplsFTNObjects 6 }\n   mplsFTNPerfEntry\
    \ OBJECT-TYPE\n      SYNTAX              MplsFTNPerfEntry\n      MAX-ACCESS  \
    \        not-accessible\n      STATUS              current\n      DESCRIPTION\n\
    \          \"Each entry contains performance information for the\n           specified\
    \ interface and an FTN entry mapped to this\n           interface.\"\n      INDEX\
    \  { mplsFTNPerfIndex, mplsFTNPerfCurrIndex }\n      ::=  { mplsFTNPerfTable 1\
    \ }\n   MplsFTNPerfEntry  ::=  SEQUENCE {\n         mplsFTNPerfIndex         \
    \            InterfaceIndexOrZero,\n         mplsFTNPerfCurrIndex            \
    \     MplsFTNEntryIndex,\n         mplsFTNPerfMatchedPackets            Counter64,\n\
    \         mplsFTNPerfMatchedOctets             Counter64,\n         mplsFTNPerfDiscontinuityTime\
    \         TimeStamp\n      }\n   mplsFTNPerfIndex OBJECT-TYPE\n      SYNTAX  \
    \            InterfaceIndexOrZero\n      MAX-ACCESS          not-accessible\n\
    \      STATUS              current\n      DESCRIPTION\n          \"The interface\
    \ index of an interface that an FTN entry\n           has been applied/mapped\
    \ to.  Each instance of this\n           object corresponds to an instance of\
    \ mplsFTNMapIndex.\"\n      ::= { mplsFTNPerfEntry 1 }\n   mplsFTNPerfCurrIndex\
    \ OBJECT-TYPE\n      SYNTAX              MplsFTNEntryIndex\n      MAX-ACCESS \
    \         not-accessible\n      STATUS              current\n      DESCRIPTION\n\
    \          \"Index of an FTN entry that has been applied/mapped to\n         \
    \  the specified interface.  Each instance of this object\n           corresponds\
    \ to an instance of mplsFTNMapCurrIndex.\"\n      ::=  { mplsFTNPerfEntry 2 }\n\
    \   mplsFTNPerfMatchedPackets OBJECT-TYPE\n      SYNTAX              Counter64\n\
    \      MAX-ACCESS          read-only\n      STATUS              current\n    \
    \  DESCRIPTION\n          \"Number of packets that matched the specified FTN entry\n\
    \           if it is applied/mapped to the specified interface.\n           Discontinuities\
    \ in the value of this counter can occur\n           at re-initialization of the\
    \ management system, and at\n           other times as indicated by the value\
    \ of\n           mplsFTNDiscontinuityTime.\"\n      ::= { mplsFTNPerfEntry 3 }\n\
    \   mplsFTNPerfMatchedOctets OBJECT-TYPE\n      SYNTAX              Counter64\n\
    \      MAX-ACCESS          read-only\n      STATUS              current\n    \
    \  DESCRIPTION\n          \"Number of octets that matched the specified FTN entry\n\
    \           if it is applied/mapped to the specified interface.\n           Discontinuities\
    \ in the value of this counter can occur\n           at re-initialization of the\
    \ management system, and at\n           other times as indicated by the value\
    \ of\n           mplsFTNDiscontinuityTime.\"\n      ::= { mplsFTNPerfEntry 4 }\n\
    \   mplsFTNPerfDiscontinuityTime OBJECT-TYPE\n      SYNTAX              TimeStamp\n\
    \      MAX-ACCESS          read-only\n      STATUS              current\n    \
    \  DESCRIPTION\n          \"The value of sysUpTime on the most recent occasion\
    \ at\n           which any one or more of this entry's counters suffered\n   \
    \        a discontinuity.  If no such discontinuities have\n           occurred\
    \ since the last re-initialization of the local\n           management subsystem,\
    \ then this object contains a zero\n           value.\"\n      ::= { mplsFTNPerfEntry\
    \ 5 }\n   -- End of mplsFTNPerfTable\n   -- Module compliance.\n   -- Top level\
    \ object IDs.\n   mplsFTNGroups\n      OBJECT IDENTIFIER ::= { mplsFTNConformance\
    \ 1 }\n   mplsFTNCompliances\n      OBJECT IDENTIFIER ::= { mplsFTNConformance\
    \ 2 }\n   -- Compliance requirement for fully compliant implementations.\n   mplsFTNModuleFullCompliance\
    \ MODULE-COMPLIANCE\n      STATUS current\n      DESCRIPTION\n          \"Compliance\
    \ statement for agents that provide full\n           support for MPLS-FTN-STD-MIB.\"\
    \n      MODULE IF-MIB -- The Interfaces Group MIB, RFC 2863.\n      MANDATORY-GROUPS\
    \ {\n         ifGeneralInformationGroup,\n         ifCounterDiscontinuityGroup\n\
    \      }\n      MODULE -- This module.\n      MANDATORY-GROUPS {\n         mplsFTNRuleGroup,\n\
    \         mplsFTNMapGroup,\n         mplsFTNPerfGroup\n      }\n      OBJECT mplsFTNAddrType\n\
    \      SYNTAX InetAddressType { ipv4(1), ipv6(2) }\n      DESCRIPTION\n      \
    \    \"An implementation is only required to support IPv4\n           and/or IPv6\
    \ addresses.  An implementation is only\n           required to support the address\
    \ types that are actually\n           supported on the LSR.\"\n      OBJECT mplsFTNSourceAddrMin\n\
    \      SYNTAX       InetAddress (SIZE (4 | 20))\n      DESCRIPTION\n         \
    \ \"An implementation is only required to support IPv4\n           and/or IPv6\
    \ addresses.  An implementation is only\n           required to support the address\
    \ types that are actually\n           supported on the LSR.\"\n      OBJECT mplsFTNSourceAddrMax\n\
    \      SYNTAX       InetAddress (SIZE (4 | 20))\n      DESCRIPTION\n         \
    \ \"An implementation is only required to support IPv4\n           and/or IPv6\
    \ addresses.  An implementation is only\n           required to support the address\
    \ types that are actually\n           supported on the LSR.\"\n      OBJECT mplsFTNDestAddrMin\n\
    \      SYNTAX       InetAddress (SIZE (4 | 20))\n      DESCRIPTION\n         \
    \ \"An implementation is only required to support IPv4\n           and/or IPv6\
    \ addresses.  An implementation is only\n           required to support the address\
    \ types that are actually\n           supported on the LSR.\"\n      OBJECT mplsFTNDestAddrMax\n\
    \      SYNTAX       InetAddress (SIZE (4 | 20))\n      DESCRIPTION\n         \
    \ \"An implementation is only required to support IPv4\n           and/or IPv6\
    \ addresses.  An implementation is only\n           required to support the address\
    \ types that are actually\n           supported on the LSR.\"\n      ::= { mplsFTNCompliances\
    \ 1 }\n   -- Compliance requirement for read-only implementations.\n   mplsFTNModuleReadOnlyCompliance\
    \ MODULE-COMPLIANCE\n      STATUS current\n      DESCRIPTION\n          \"Compliance\
    \ requirement for implementations that only\n           provide read-only support\
    \ for MPLS-FTN-STD-MIB. Such\n           devices can then be monitored but cannot\
    \ be configured\n           using this MIB module.\"\n      MODULE IF-MIB -- The\
    \ interfaces Group MIB, RFC 2863\n      MANDATORY-GROUPS {\n         ifGeneralInformationGroup,\n\
    \         ifCounterDiscontinuityGroup\n      }\n      MODULE -- This module\n\
    \      MANDATORY-GROUPS {\n         mplsFTNRuleGroup,\n         mplsFTNMapGroup,\n\
    \         mplsFTNPerfGroup\n      }\n      OBJECT mplsFTNIndexNext\n      MIN-ACCESS\
    \   not-accessible\n      DESCRIPTION\n          \"This object is not needed when\
    \ mplsFTNTable is\n           implemented as read-only.\"\n      OBJECT mplsFTNRowStatus\n\
    \      SYNTAX       RowStatus { active(1) }\n      MIN-ACCESS   read-only\n  \
    \    DESCRIPTION\n          \"Write access is not required, and active is the\
    \ only\n           status that needs to be supported.\"\n      OBJECT mplsFTNDescr\n\
    \      MIN-ACCESS   read-only\n      DESCRIPTION\n          \"Write access is\
    \ not required.\"\n      OBJECT mplsFTNMask\n      MIN-ACCESS   read-only\n  \
    \    DESCRIPTION\n          \"Write access is not required.\"\n      OBJECT mplsFTNAddrType\n\
    \      SYNTAX       InetAddressType { ipv4(1), ipv6(2) }\n      MIN-ACCESS   read-only\n\
    \      DESCRIPTION\n          \"Write access is not required. An implementation\
    \ is only\n           required to support IPv4 and IPv6 addresses.\"\n      OBJECT\
    \ mplsFTNSourceAddrMin\n      SYNTAX       InetAddress (SIZE (4 | 20))\n     \
    \ MIN-ACCESS   read-only\n      DESCRIPTION\n          \"Write access is not required.\
    \ An implementation is only\n           required to support IPv4 and IPv6 addresses.\"\
    \n      OBJECT mplsFTNSourceAddrMax\n      SYNTAX       InetAddress (SIZE (4 |\
    \ 20))\n      MIN-ACCESS   read-only\n      DESCRIPTION\n          \"Write access\
    \ is not required. An implementation is only\n           required to support IPv4\
    \ and IPv6 addresses.\"\n      OBJECT mplsFTNDestAddrMin\n      SYNTAX       InetAddress\
    \ (SIZE (4 | 20))\n      MIN-ACCESS   read-only\n      DESCRIPTION\n         \
    \ \"Write access is not required. An implementation is only\n           required\
    \ to support IPv4 and IPv6 addresses.\"\n      OBJECT mplsFTNDestAddrMax\n   \
    \   SYNTAX       InetAddress (SIZE (4 | 20))\n      MIN-ACCESS   read-only\n \
    \     DESCRIPTION\n          \"Write access is not required. An implementation\
    \ is only\n           required to support IPv4 and IPv6 addresses.\"\n      OBJECT\
    \ mplsFTNSourcePortMin\n      MIN-ACCESS   read-only\n      DESCRIPTION\n    \
    \      \"Write access is not required.\"\n      OBJECT mplsFTNSourcePortMax\n\
    \      MIN-ACCESS   read-only\n      DESCRIPTION\n          \"Write access is\
    \ not required.\"\n      OBJECT mplsFTNDestPortMin\n      MIN-ACCESS   read-only\n\
    \      DESCRIPTION\n          \"Write access is not required.\"\n      OBJECT\
    \ mplsFTNDestPortMax\n      MIN-ACCESS   read-only\n      DESCRIPTION\n      \
    \    \"Write access is not required.\"\n      OBJECT mplsFTNProtocol\n      MIN-ACCESS\
    \   read-only\n      DESCRIPTION\n          \"Write access is not required.\"\n\
    \      OBJECT mplsFTNActionType\n      MIN-ACCESS   read-only\n      DESCRIPTION\n\
    \          \"Write access is not required.\"\n      OBJECT mplsFTNActionPointer\n\
    \      MIN-ACCESS   read-only\n      DESCRIPTION\n          \"Write access is\
    \ not required.\"\n      OBJECT mplsFTNDscp\n      MIN-ACCESS   read-only\n  \
    \    DESCRIPTION\n          \"Write access is not required.\"\n      OBJECT mplsFTNStorageType\n\
    \      MIN-ACCESS   read-only\n      DESCRIPTION\n          \"Write access is\
    \ not required.\"\n      OBJECT mplsFTNMapRowStatus\n      SYNTAX       RowStatus\
    \ { active(1) }\n      MIN-ACCESS   read-only\n      DESCRIPTION\n          \"\
    Write access is not required, and active(1) is the only\n           status that\
    \ needs to be supported.\"\n      OBJECT mplsFTNMapStorageType\n      MIN-ACCESS\
    \   read-only\n      DESCRIPTION\n          \"Write access is not required.\"\n\
    \      ::= { mplsFTNCompliances 2 }\n   -- Units of conformance.\n   mplsFTNRuleGroup\
    \ OBJECT-GROUP\n      OBJECTS {\n            mplsFTNIndexNext,\n            mplsFTNTableLastChanged,\n\
    \            mplsFTNRowStatus,\n            mplsFTNDescr,\n            mplsFTNMask,\n\
    \            mplsFTNAddrType,\n            mplsFTNSourceAddrMin,\n           \
    \ mplsFTNSourceAddrMax,\n            mplsFTNDestAddrMin,\n            mplsFTNDestAddrMax,\n\
    \            mplsFTNSourcePortMin,\n            mplsFTNSourcePortMax,\n      \
    \      mplsFTNDestPortMin,\n            mplsFTNDestPortMax,\n            mplsFTNProtocol,\n\
    \            mplsFTNActionType,\n            mplsFTNActionPointer,\n         \
    \   mplsFTNDscp,\n            mplsFTNStorageType\n      }\n      STATUS current\n\
    \      DESCRIPTION\n          \"Collection of objects that implement MPLS FTN\
    \ rules.\"\n      ::= { mplsFTNGroups 1 }\n   mplsFTNMapGroup OBJECT-GROUP\n \
    \     OBJECTS {\n            mplsFTNMapTableLastChanged,\n            mplsFTNMapRowStatus,\n\
    \            mplsFTNMapStorageType\n      }\n      STATUS current\n      DESCRIPTION\n\
    \          \"Collection of objects that implement activation of MPLS\n       \
    \    FTN entries on interfaces.\"\n      ::= { mplsFTNGroups 2 }\n   mplsFTNPerfGroup\
    \ OBJECT-GROUP\n      OBJECTS {\n            mplsFTNPerfMatchedPackets,\n    \
    \        mplsFTNPerfMatchedOctets,\n            mplsFTNPerfDiscontinuityTime\n\
    \      }\n      STATUS current\n      DESCRIPTION\n          \"Collection of objects\
    \ providing MPLS FTN performance\n           information.\"\n      ::= { mplsFTNGroups\
    \ 3 }\n   END\n"
- title: 10.  Security Considerations
  contents:
  - "10.  Security Considerations\n   This MIB module can be used to configure LSRs\
    \ to redirect non-MPLS\n   traffic into an MPLS cloud.  As such, improper manipulation\
    \ of the\n   objects represented in this MIB module may result in traffic being\n\
    \   redirected to unintended destinations, potentially resulting in\n   denial\
    \ of service to end-users.\n   There are a number of management objects defined\
    \ in this MIB module\n   with a MAX-ACCESS clause of read-write and/or read-create.\
    \  Such\n   objects may be considered sensitive or vulnerable in some network\n\
    \   environments.  The support for SET operations in a non-secure\n   environment\
    \ without proper protection can have a negative effect on\n   network operations.\
    \  These are the tables and objects and their\n   sensitivity/vulnerability:\n\
    \   -  mplsFTNTable and mplsFTNMapTable can be used to create packet\n      matching\
    \ rules for classifying IPv4 or IPv6 traffic and\n      redirecting matched packets\
    \ into the MPLS cloud.  Modifying\n      objects in these tables can result in\
    \ the misdirection of traffic\n      and potential denial of service to end-users.\
    \  It may also result\n      in traffic which was intended to be redirected into\
    \ the MPLS cloud\n      being routed through the IP network instead, potentially\
    \ resulting\n      in degradation of service quality or outright denial of service.\n\
    \   Some of the readable objects in this MIB module (i.e., objects with a\n  \
    \ MAX-ACCESS other than not-accessible) may be considered sensitive or\n   vulnerable\
    \ in some network environments.  It is thus important to\n   control even GET\
    \ and/or NOTIFY access to these objects and possibly\n   to even encrypt the values\
    \ of these objects when sending them over\n   the network via SNMP.  These are\
    \ the tables and objects and their\n   sensitivity/vulnerability:\n   -  mplsFTNPerfTable\
    \ provides counters for monitoring the performance\n      of packet classification\
    \ rules defined in mplsFTNTable and\n      mplsFTNMapTable.  Unauthorized read\
    \ access to objects in these\n      tables may be used to gain traffic flow information.\n\
    \   SNMP versions prior to SNMPv3 did not include adequate security.\n   Even\
    \ if the network itself is secure (for example by using IPSec),\n   even then,\
    \ there is no control as to who on the secure network is\n   allowed to access\
    \ and GET/SET (read/change/create/delete) the objects\n   in this MIB module.\n\
    \   It is RECOMMENDED that implementers consider the security features as\n  \
    \ provided by the SNMPv3 framework (see [RFC3410], section 8),\n   including full\
    \ support for the SNMPv3 cryptographic mechanisms (for\n   authentication and\
    \ privacy).\n   Further, deployment of SNMP versions prior to SNMPv3 is NOT\n\
    \   RECOMMENDED.  Instead, it is RECOMMENDED that SNMPv3 be deployed and\n   cryptographic\
    \ security be enabled.  It is then a customer/operator\n   responsibility to ensure\
    \ that the SNMP entity giving access to an\n   instance of this MIB module is\
    \ properly configured to give access to\n   the objects to only those principals\
    \ (users) that have legitimate\n   rights to indeed GET or SET (change/create/delete)\
    \ them.\n"
- title: 11.  IANA Considerations
  contents:
  - "11.  IANA Considerations\n   As described in [MPLSMGMT] and as requested in [RFC3811],\
    \ MPLS\n   related standards-track MIB modules should be rooted under the\n  \
    \ mplsStdMIB subtree.  New assignments can only be made by a standards\n   action\
    \ as specified in [RFC2434].\n"
- title: 11.1.  IANA Considerations for MPLS-FTN-STD-MIB
  contents:
  - "11.1.  IANA Considerations for MPLS-FTN-STD-MIB\n   The IANA has assigned mplsStdMIB\
    \ 8 to the MPLS-FTN-STD-MIB module\n   specified in this document.\n"
- title: 12.  References
  contents:
  - '12.  References

    '
- title: 12.1.  Normative References
  contents:
  - "12.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key Words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [RFC2578]  McCloghrie, K., Perkins, D., and J. Schoenwaelder,\n  \
    \            \"Structure of Management Information Version 2 (SMIv2)\",\n    \
    \          STD 58, RFC 2578, April 1999.\n   [RFC2579]  McCloghrie, K., Perkins,\
    \ D., and J. Schoenwaelder,\n              \"Textual Conventions for SMIv2\",\
    \ STD 58, RFC 2579, April\n              1999.\n   [RFC2580]  McCloghrie, K.,\
    \ Perkins, D., and J. Schoenwaelder,\n              \"Conformance Statements for\
    \ SMIv2\", STD 58, RFC 2580,\n              April 1999.\n   [RFC2863]  McCloghrie,\
    \ K. and F. Kastenholz, \"The Interfaces Group\n              MIB\", RFC 2863,\
    \ June 2000.\n   [RFC3031]  Rosen, E., Viswanathan, A., and R. Callon, \"Multiprotocol\n\
    \              Label Switching Architecture\", RFC 3031, January 2001.\n   [RFC3289]\
    \  Baker, F., Chan, K., and A. Smith, \"Management Information\n             \
    \ Base for the Differentiated Services Architecture\", RFC\n              3289,\
    \ May 2002.\n   [RFC3291]  Daniele, M., Haberman, B., Routhier, S., and J.\n \
    \             Schoenwaelder, \"Textual Conventions for Internet Network\n    \
    \          Addresses\", RFC 3291, May 2002.\n   [RFC3411]  Harrington, D., Presuhn,\
    \ R., and B. Wijnen, \"An\n              Architecture for Describing Simple Network\
    \ Management\n              Protocol (SNMP) Management Frameworks\", STD 62, RFC\
    \ 3411,\n              December 2002.\n   [RFC3813]  Srinivasan, C., Viswanathan,\
    \ A., and T. Nadeau,\n              \"Multiprotocol Label Switching (MPLS) Label\
    \ Switching\n              Router (LSR) Management Information Base (MIB)\", RFC\
    \ 3813,\n              June 2004.\n   [RFC3811]  Nadeau, T.,  and J. Cucchiara,\
    \ J., Editors, \"Definition of\n              Textual Conventions (TCs) for Multi-Protocol\
    \ Label\n              Switching (MPLS) Management\", RFC 3811, June 2004.\n \
    \  [RFC3812]  Srinivasan, C., Viswanathan, A., and T. Nadeau,\n              \"\
    Multiprotocol Label Switching (MPLS) Traffic Engineering\n              (TE) Management\
    \ Information Base (MIB)\", RFC 3812, June\n              2004.\n"
- title: 12.2.  Informative References
  contents:
  - "12.2.  Informative References\n   [MPLSMGMT] Nadeau, T., Srinivasan, C., and\
    \ A. Farrel, \"Multiprotocol\n              Label Switching (MPLS) Management\
    \ Overview\", Work in\n              Progress, September 2003.\n   [RFC791]  \
    \ Postel, J., \"Internet Protocol\", STD 5, RFC 791, September\n             \
    \ 1981.\n   [RFC1519]  Fuller, V., Li, T., Yu, J., and K. Varadhan, \"Classless\n\
    \              Inter-Domain Routing (CIDR): an Address Assignment and\n      \
    \        Aggregation Strategy\", RFC 1519, September 1993.\n   [RFC2026]  Bradner,\
    \ S., \"The Internet Standards Process -- Revision\n              3\", BCP 9,\
    \ RFC 2026, October 1996.\n   [RFC2434]  Narten, T. and H. Alvestrand, \"Guidelines\
    \ for Writing an\n              IANA Considerations Section in RFCs\", BCP 26,\
    \ RFC 2434,\n              October 1998.\n   [RFC2460]  Deering, S. and R. Hinden,\
    \ \"Internet Protocol, Version 6\n              (IPv6) Specification\", RFC 2460,\
    \ December 1998.\n   [RFC2474]  Nichols, K., Blake, S., Baker, F., and D. Black,\n\
    \              \"Definition of the Differentiated Services Field (DS\n       \
    \       Field) in the IPv4 and IPv6 Headers\", RFC 2474, December\n          \
    \    1998.\n   [RFC3410]  Case, J., Mundy, R., Partain, D., and B. Stewart,\n\
    \              \"Introduction and Applicability Statements for Internet-\n   \
    \           Standard Management Framework\", RFC 3410, December 2002.\n"
- title: 13.  Acknowledgements
  contents:
  - "13.  Acknowledgements\n   We would particularly like to thank Bert Wijnen for\
    \ the substantial\n   time and effort he spent in helping us improve this document.\
    \  We\n   would also like to thank David Perkins, Joan Cucchiara, Mike Piecuch,\n\
    \   and Adrien Grise for their insightful comments and additions to this\n   document.\n"
- title: 14.  Authors' Addresses
  contents:
  - "14.  Authors' Addresses\n   Thomas D. Nadeau\n   Cisco Systems, Inc.\n   300\
    \ Apollo Drive\n   Chelmsford, MA 01824\n   Phone: +1-978-244-3051\n   EMail:\
    \ tnadeau@cisco.com\n   Cheenu Srinivasan\n   Bloomberg L.P.\n   499 Park Avenue\n\
    \   New York, NY 10022\n   Phone: +1-212-893-3682\n   EMail: cheenu@bloomberg.net\n\
    \   Arun Viswanathan\n   Force10 Networks, Inc.\n   1440 McCarthy Blvd\n   Milpitas,\
    \ CA 95035\n   Phone: +1-408-571-3516\n   EMail: arunv@force10networks.com\n"
- title: 15.  Full Copyright Statement
  contents:
  - "15.  Full Copyright Statement\n   Copyright (C) The Internet Society (2004).\
    \  This document is subject\n   to the rights, licenses and restrictions contained\
    \ in BCP 78, and\n   except as set forth therein, the authors retain all their\
    \ rights.\n   This document and the information contained herein are provided\
    \ on an\n   \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE\n   REPRESENTS\
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE\n   INTERNET ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed\n   to pertain to the implementation or use of the technology\n   described\
    \ in this document or the extent to which any license\n   under such rights might\
    \ or might not be available; nor does it\n   represent that it has made any independent\
    \ effort to identify any\n   such rights.  Information on the procedures with\
    \ respect to\n   rights in RFC documents can be found in BCP 78 and BCP 79.\n\
    \   Copies of IPR disclosures made to the IETF Secretariat and any\n   assurances\
    \ of licenses to be made available, or the result of an\n   attempt made to obtain\
    \ a general license or permission for the use\n   of such proprietary rights by\
    \ implementers or users of this\n   specification can be obtained from the IETF\
    \ on-line IPR repository\n   at http://www.ietf.org/ipr.\n   The IETF invites\
    \ any interested party to bring to its attention\n   any copyrights, patents or\
    \ patent applications, or other\n   proprietary rights that may cover technology\
    \ that may be required\n   to implement this standard.  Please address the information\
    \ to the\n   IETF at ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
