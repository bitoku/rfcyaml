- title: __initial_text__
  contents:
  - "                       Problem Statement for the\n              Datagram Congestion\
    \ Control Protocol (DCCP)\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes for the historical record the motivation\n\
    \   behind the Datagram Congestion Control Protocol (DCCP), an unreliable\n  \
    \ transport protocol incorporating end-to-end congestion control.  DCCP\n   implements\
    \ a congestion-controlled, unreliable flow of datagrams for\n   use by applications\
    \ such as streaming media or on-line games.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................2\n\
    \   2. Problem Space ...................................................3\n  \
    \    2.1. Congestion Control for Unreliable Transfer .................4\n    \
    \  2.2. Overhead ...................................................6\n      2.3.\
    \ Firewall Traversal .........................................6\n      2.4. Parameter\
    \ Negotiation ......................................7\n   3. Solution Space for\
    \ Congestion Control of Unreliable Flows .......7\n      3.1. Providing Congestion\
    \ Control Above UDP .....................8\n           3.1.1. The Burden on the\
    \ Application Designer ..............8\n           3.1.2. Difficulties with ECN\
    \ ...............................8\n           3.1.3. The Evasion of Congestion\
    \ Control ..................10\n      3.2. Providing Congestion Control Below\
    \ UDP ....................10\n           3.2.1. Case 1: Congestion Feedback at\
    \ the Application .....11\n           3.2.2. Case 2: Congestion Feedback at a\
    \ Layer Below UDP ...11\n      3.3. Providing Congestion Control at the Transport\
    \ Layer .......12\n           3.3.1. Modifying TCP? .....................................12\n\
    \           3.3.2. Unreliable Variants of SCTP? .......................13\n  \
    \         3.3.3. Modifying RTP? .....................................14\n    \
    \       3.3.4. Designing a New Transport Protocol .................14\n   4. Selling\
    \ Congestion Control to Reluctant Applications ...........15\n   5. Additional\
    \ Design Considerations ...............................15\n   6. Transport Requirements\
    \ of Request/Response Applications ........16\n   7. Summary of Recommendations\
    \ .....................................17\n   8. Security Considerations ........................................18\n\
    \   9. Acknowledgements ...............................................18\n  \
    \ Informative References ............................................19\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Historically, the great majority of Internet unicast traffic\
    \ has used\n   congestion-controlled TCP, with UDP making up most of the remainder.\n\
    \   UDP has mainly been used for short, request-response transfers, like\n   DNS\
    \ and SNMP, that wish to avoid TCP's three-way handshake,\n   retransmission,\
    \ and/or stateful connections.  UDP also avoids TCP's\n   built-in end-to-end\
    \ congestion control, and UDP applications tended\n   not to implement their own\
    \ congestion control.  However, since UDP\n   traffic volume was small relative\
    \ to congestion-controlled TCP flows,\n   the network didn't collapse.\n   Recent\
    \ years have seen the growth of applications that use UDP in a\n   different way.\
    \  These applications, including streaming audio,\n   Internet telephony, and\
    \ multiplayer and massively multiplayer on-line\n   games, share a preference\
    \ for timeliness over reliability.  TCP can\n   introduce arbitrary delay because\
    \ of its reliability and in-order\n   delivery requirements; thus, the applications\
    \ use UDP instead.  This\n   growth of long-lived non-congestion-controlled traffic,\
    \ relative to\n   congestion-controlled traffic, poses a real threat to the overall\n\
    \   health of the Internet [RFC2914, RFC3714].\n   Applications could implement\
    \ their own congestion control mechanisms\n   on a case-by-case basis, with encouragement\
    \ from the IETF.  Some\n   already do this.  However, experience shows that congestion\
    \ control\n   is difficult to get right, and many application writers would like\
    \ to\n   avoid reinventing this particular wheel.  We believe that a new\n   protocol\
    \ is needed, one that combines unreliable datagram delivery\n   with built-in\
    \ congestion control.  This protocol will act as an\n   enabling technology: existing\
    \ and new applications could easily use\n   it to transfer timely data without\
    \ destabilizing the Internet.\n   This document provides a problem statement for\
    \ such a protocol.  We\n   list the properties the protocol should have, then\
    \ explain why those\n   properties are necessary.  We describe why a new protocol\
    \ is the best\n   solution for the more general problem of bringing congestion\
    \ control\n   to unreliable flows of unicast datagrams, and discuss briefly\n\
    \   subsidiary requirements for mobility, defense against Denial of\n   Service\
    \ (DoS) attacks and spoofing, interoperation with RTP, and\n   interactions with\
    \ Network Address Translators (NATs) and firewalls.\n   One of the design preferences\
    \ that we bring to this question is a\n   preference for a clean, understandable,\
    \ low-overhead, and minimal\n   protocol.  As described later in this document,\
    \ this results in the\n   design decision to leave functionality such as reliability\
    \ or Forward\n   Error Correction (FEC) to be layered on top, rather than provided\
    \ in\n   the transport protocol itself.\n   This document began in 2002 as a formalization\
    \ of the goals of DCCP,\n   the Datagram Congestion Control Protocol [RFC4340].\
    \  We intended DCCP\n   to satisfy this problem statement, and thus the original\
    \ reasoning\n   behind many of DCCP's design choices can be found here.  However,\
    \ we\n   believed, and continue to believe, that the problem should be solved\n\
    \   whether or not DCCP is the chosen solution.\n"
- title: 2.  Problem Space
  contents:
  - "2.  Problem Space\n   We perceive a number of problems related to the use of\
    \ unreliable\n   data flows in the Internet.  The major issues are the following:\n\
    \   o  The potential for non-congestion-controlled datagram flows to\n      cause\
    \ congestion collapse of the network.  (See Section 5 of\n      [RFC2914] and\
    \ Section 2 of [RFC3714].)\n   o  The difficulty of correctly implementing effective\
    \ congestion\n      control mechanisms for unreliable datagram flows.\n   o  The\
    \ lack of a standard solution for reliably transmitting\n      congestion feedback\
    \ for an unreliable data flow.\n   o  The lack of a standard solution for negotiating\
    \ Explicit\n      Congestion Notification (ECN) [RFC3168] usage for unreliable\n\
    \      flows.\n   o  The lack of a choice of TCP-friendly congestion control\n\
    \      mechanisms.\n   We assume that most application writers would use congestion\
    \ control\n   for long-lived unreliable flows if it were available in a standard,\n\
    \   easy-to-use form.\n   More minor issues include the following:\n   o  The\
    \ difficulty of deploying applications using UDP-based flows in\n      the presence\
    \ of firewalls.\n   o  The desire to have a single way to negotiate congestion\
    \ control\n      parameters for unreliable flows, independently of the signalling\n\
    \      protocol used to set up the flow.\n   o  The desire for low per-packet\
    \ byte overhead.\n   The subsections below discuss these problems of providing\
    \ congestion\n   control, traversing firewalls, and negotiating parameters in\
    \ more\n   detail.  A separate subsection also discusses the problem of\n   minimizing\
    \ the overhead of packet headers.\n"
- title: 2.1.  Congestion Control for Unreliable Transfer
  contents:
  - "2.1.  Congestion Control for Unreliable Transfer\n   We aim to bring easy-to-use\
    \ congestion control mechanisms to\n   applications that generate large or long-lived\
    \ flows of unreliable\n   datagrams, such as RealAudio, Internet telephony, and\
    \ multiplayer\n   games.  Our motivation is to avoid congestion collapse.  (The\
    \ short\n   flows generated by request-response applications, such as DNS and\n\
    \   SNMP, don't cause congestion in practice, and any congestion control\n   mechanism\
    \ would take effect between flows, not within a single end-\n   to-end transfer\
    \ of information.)  However, before designing a\n   congestion control mechanism\
    \ for these applications, we must\n   understand why they use unreliable datagrams\
    \ in the first place, lest\n   we destroy the very properties they require.\n\
    \   There are several reasons why protocols currently use UDP instead of\n   TCP,\
    \ among them:\n   o  Startup Delay: they wish to avoid the delay of a three-way\n\
    \      handshake before initiating data transfer.\n   o  Statelessness: they wish\
    \ to avoid holding connection state, and\n      the potential state-holding attacks\
    \ that come with this.\n   o  Trading of Reliability against Timing: the data\
    \ being sent is\n      timely in the sense that if it is not delivered by some\
    \ deadline\n      (typically a small number of RTTs), then the data will not be\n\
    \      useful at the receiver.\n   Of these issues, applications that generate\
    \ large or long-lived flows\n   of datagrams, such as media transfer and games,\
    \ mostly care about\n   controlling the trade-off between timing and reliability.\
    \  Such\n   applications use UDP because when they send a datagram, they wish\
    \ to\n   send the most appropriate data in that datagram.  If the datagram is\n\
    \   lost, they may or may not resend the same data, depending on whether\n   the\
    \ data will still be useful at the receiver.  Data may no longer be\n   useful\
    \ for many reasons:\n   o  In a telephony or streaming video session, data in\
    \ a packet\n      comprises a timeslice of a continuous stream.  Once a timeslice\n\
    \      has been played out, the next timeslice is required immediately.\n    \
    \  If the data comprising that timeslice arrives at some later time,\n      then\
    \ it is no longer useful.  Such applications can cope with\n      masking the\
    \ effects of missing packets to some extent, so when the\n      sender transmits\
    \ its next packet, it is important for it to only\n      send data that has a\
    \ good chance of arriving in time for its\n      playout.\n   o  In an interactive\
    \ game or virtual-reality session, position\n      information is transient. \
    \ If a datagram containing position\n      information is lost, resending the\
    \ old position does not usually\n      make sense -- rather, every position information\
    \ datagram should\n      contain the latest position information.\n   In a congestion-controlled\
    \ flow, the allowed packet sending rate\n   depends on measured network congestion.\
    \  Thus, some control is given\n   up to the congestion control mechanism, which\
    \ determines precisely\n   when packets can be sent.  However, applications could\
    \ still decide,\n   at transmission time, which information to put in a packet.\
    \  TCP\n   doesn't allow control over this; these applications demand it.\n  \
    \ Often, these applications (especially games and telephony\n   applications)\
    \ work on very short playout timescales.  Whilst they are\n   usually able to\
    \ adjust their transmission rate based on congestion\n   feedback, they do have\
    \ constraints on how this adaptation can be\n   performed so that it has minimal\
    \ impact on the quality of the\n   session.  Thus, they tend to need some control\
    \ over the short-term\n   dynamics of the congestion control algorithm, whilst\
    \ being fair to\n   other traffic on medium timescales.  This control includes,\
    \ but is\n   not limited to, some influence on which congestion control algorithm\n\
    \   should be used -- for example, TCP-Friendly Rate Control (TFRC)\n   [RFC3448]\
    \ rather than strict TCP-like congestion control.  (TFRC has\n   been standardized\
    \ in the IETF as a congestion control mechanism that\n   adjusts its sending rate\
    \ more smoothly than TCP does, while\n   maintaining long-term fair bandwidth\
    \ sharing with TCP [RFC3448].)\n"
- title: 2.2.  Overhead
  contents:
  - "2.2.  Overhead\n   The applications we are concerned with often send compressed\
    \ data, or\n   send frequent small packets.  For example, when Internet telephony\
    \ or\n   streaming media are used over low-bandwidth modem links, highly\n   compressing\
    \ the payload data is essential.  For Internet telephony\n   applications and\
    \ for games, the requirement is for low delay, and\n   hence small packets are\
    \ sent frequently.\n   For example, a telephony application sending a 5.6 Kbps\
    \ data stream\n   but wanting moderately low delay may send a packet every 20\
    \ ms,\n   sending only 14 data bytes in each packet.  In addition, 20 bytes is\n\
    \   taken up by the IP header, with additional bytes for transport and/or\n  \
    \ application headers.  Clearly, it is desirable for such an\n   application to\
    \ have a low-overhead transport protocol header.\n   In some cases, the correct\
    \ solution would be to use link-based packet\n   header compression to compress\
    \ the packet headers, although we cannot\n   guarantee the availability of such\
    \ compression schemes on any\n   particular link.\n   The delay of data until\
    \ after the completion of a handshake also\n   represents potentially unnecessary\
    \ overhead.  A new protocol might\n   therefore allow senders to include some\
    \ data on their initial\n   datagrams.\n"
- title: 2.3.  Firewall Traversal
  contents:
  - "2.3.  Firewall Traversal\n   Applications requiring a flow of unreliable datagrams\
    \ currently tend\n   to use signalling protocols such as the Real Time Streaming\
    \ Protocol\n   (RTSP) [RFC2326], SIP [RFC3261], and H.323 in conjunction with\
    \ UDP\n   for the data flow.  The initial setup request uses a signalling\n  \
    \ protocol to locate the correct remote end-system for the data flow,\n   sometimes\
    \ after being redirected or relayed to other machines.\n   As UDP flows contain\
    \ no explicit setup and teardown, it is hard for\n   firewalls to handle them\
    \ correctly.  Typically, the firewall needs to\n   parse RTSP, SIP, and H.323\
    \ to obtain the information necessary to\n   open a hole in the firewall.  Although,\
    \ for bi-directional flows, the\n   firewall can open a bi-directional hole if\
    \ it receives a UDP packet\n   from inside the firewall, in this case the firewall\
    \ can't easily know\n   when to close the hole again.\n   While we do not consider\
    \ these to be major problems, they are\n   nonetheless issues that application\
    \ designers face.  Currently,\n   streaming media players attempt UDP first, and\
    \ then switch to TCP if\n   UDP is not successful.  Streaming media over TCP is\
    \ undesirable and\n   can result in the receiver needing to temporarily halt playout\
    \ while\n   it \"rebuffers\" data.  Telephony applications don't even have this\n\
    \   option.\n"
- title: 2.4.  Parameter Negotiation
  contents:
  - "2.4.  Parameter Negotiation\n   Different applications have different requirements\
    \ for congestion\n   control, which may map into different congestion feedback.\
    \  Examples\n   include ECN capability and desired congestion control dynamics\
    \ (the\n   choice of congestion control algorithm and, therefore, the form of\n\
    \   feedback information required).  Such parameters need to be reliably\n   negotiated\
    \ before congestion control can function correctly.\n   While this negotiation\
    \ could be performed using signalling protocols\n   such as SIP, RTSP, and H.323,\
    \ it would be desirable to have a single\n   standard way of negotiating these\
    \ transport parameters.  This is of\n   particular importance with ECN, where\
    \ sending ECN-marked packets to a\n   non-ECN-capable receiver can cause significant\
    \ congestion problems to\n   other flows.  We discuss the ECN issue in more detail\
    \ below.\n"
- title: 3.  Solution Space for Congestion Control of Unreliable Flows
  contents:
  - "3.  Solution Space for Congestion Control of Unreliable Flows\n   We thus want\
    \ to provide congestion control for unreliable flows,\n   providing both ECN and\
    \ the choice of different forms of congestion\n   control, and providing moderate\
    \ overhead in terms of packet size,\n   state, and CPU processing.  There are\
    \ a number of options for\n   providing end-to-end congestion control for the\
    \ unicast traffic that\n   currently uses UDP, in terms of the layer that provides\
    \ the\n   congestion control mechanism:\n   o  Congestion control above UDP.\n\
    \   o  Congestion control below UDP.\n   o  Congestion control at the transport\
    \ layer in an alternative to\n      UDP.\n   We explore these alternatives in\
    \ the sections below.  The concerns\n   from the discussions below have convinced\
    \ us that the best way to\n   provide congestion control for unreliable flows\
    \ is to provide\n   congestion control at the transport layer, as an alternative\
    \ to the\n   use of UDP and TCP.\n"
- title: 3.1.  Providing Congestion Control Above UDP
  contents:
  - "3.1.  Providing Congestion Control Above UDP\n   One possibility would be to\
    \ provide congestion control at the\n   application layer, or at some other layer\
    \ above UDP.  This would\n   allow the congestion control mechanism to be closely\
    \ integrated with\n   the application itself.\n"
- title: 3.1.1.  The Burden on the Application Designer
  contents:
  - "3.1.1.  The Burden on the Application Designer\n   A key disadvantage of providing\
    \ congestion control above UDP is that\n   it places an unnecessary burden on\
    \ the application-level designer,\n   who might be just as happy to use the congestion\
    \ control provided by\n   a lower layer.  If the application can rely on a lower\
    \ layer that\n   gives a choice between TCP-like or TFRC-like congestion control,\
    \ and\n   that offers ECN, then this might be highly satisfactory to many\n  \
    \ application designers.\n   The long history of debugging TCP implementations\
    \ [RFC2525, PF01]\n   makes the difficulties in implementing end-to-end congestion\
    \ control\n   abundantly clear.  It is clearly more robust for congestion control\n\
    \   to be provided for the application by a lower layer.  In rare cases,\n   there\
    \ might be compelling reasons for the congestion control\n   mechanism to be implemented\
    \ in the application itself, but we do not\n   expect this to be the general case.\
    \  For example, applications that\n   use RTP over UDP might be just as happy\
    \ if RTP itself implemented\n   end-to-end congestion control.  (See Section 3.3.3\
    \ for more\n   discussion of RTP.)\n   In addition to congestion control issues,\
    \ we also note the problems\n   with firewall traversal and parameter negotiation\
    \ discussed in\n   Sections 2.3 and 2.4.  Implementing on top of UDP requires\
    \ that the\n   application designer also address these issues.\n"
- title: 3.1.2.  Difficulties with ECN
  contents:
  - "3.1.2.  Difficulties with ECN\n   There is a second problem with providing congestion\
    \ control above\n   UDP: it would require either giving up the use of ECN or giving\
    \ the\n   application direct control over setting and reading the ECN field in\n\
    \   the IP header.  Giving up the use of ECN would be problematic, since\n   ECN\
    \ can be particularly useful for unreliable flows, where a dropped\n   packet\
    \ will not be retransmitted by the data sender.\n   With the development of the\
    \ ECN nonce, ECN can be useful even in the\n   absence of network support.  The\
    \ data sender can use the ECN nonce,\n   along with feedback from the data receiver,\
    \ to verify that the data\n   receiver is correctly reporting all lost packets.\
    \  This use of ECN\n   can be particularly useful for an application using unreliable\n\
    \   delivery, where the receiver might otherwise have little incentive to\n  \
    \ report lost packets.\n   In order to allow the use of ECN by a layer above UDP,\
    \ the UDP socket\n   would have to allow the application to control the ECN field\
    \ in the\n   IP header.  In particular, the UDP socket would have to allow the\n\
    \   application to specify whether or not the ECN-Capable Transport (ECT)\n  \
    \ codepoints should be set in the ECN field of the IP header.\n   The ECN contract\
    \ is that senders who set the ECT codepoint must\n   respond to Congestion Experienced\
    \ (CE) codepoints by reducing their\n   sending rates.  Therefore, the ECT codepoint\
    \ can only safely be set\n   in the packet header of a UDP packet if the following\
    \ is guaranteed:\n   o  if the CE codepoint is set by a router, the receiving\
    \ IP layer\n      will pass the CE status to the UDP layer, which will pass it\
    \ to\n      the receiving application at the data receiver; and\n   o  upon receiving\
    \ a packet that had the CE codepoint set, the\n      receiving application will\
    \ take the appropriate congestion control\n      action, such as informing the\
    \ data sender.\n   However, the UDP implementation at the data sender has no way\
    \ of\n   knowing if the UDP implementation at the data receiver has been\n   upgraded\
    \ to pass a CE status up to the receiving application, let\n   alone whether or\
    \ not the application will use the conformant end-to-\n   end congestion control\
    \ that goes along with use of ECN.\n   In the absence of the widespread deployment\
    \ of mechanisms in routers\n   to detect flows that are not using conformant congestion\
    \ control,\n   allowing applications arbitrary control of the ECT codepoints for\
    \ UDP\n   packets would seem like an unnecessary opportunity for applications\n\
    \   to use ECN while evading the use of end-to-end congestion control.\n   Thus,\
    \ there is an inherent \"chicken-and-egg\" problem of whether first\n   to deploy\
    \ policing mechanisms in routers, or first to enable the use\n   of ECN by UDP\
    \ flows.  Without the policing mechanisms in routers, we\n   would not advise\
    \ adding ECN-capability to UDP sockets at this time.\n   In the absence of more\
    \ fine-grained mechanisms for dealing with a\n   period of sustained congestion,\
    \ one possibility would be for routers\n   to discontinue using ECN with UDP packets\
    \ during the congested\n   period, and to use ECN only with TCP or DCCP packets.\
    \  This would be\n   a reasonable response, for example, if TCP or DCCP flows\
    \ were found\n   to be more likely to be using conformant end-to-end congestion\n\
    \   control than were UDP flows.  If routers were to adopt such a policy,\n  \
    \ then DCCP flows could be more likely to receive the benefits of ECN\n   in times\
    \ of congestion than would UDP flows.\n"
- title: 3.1.3.  The Evasion of Congestion Control
  contents:
  - "3.1.3.  The Evasion of Congestion Control\n   A third problem of providing congestion\
    \ control above UDP is that\n   relying on congestion control at the application\
    \ level makes it\n   somewhat easier for some users to evade end-to-end congestion\n\
    \   control.  We do not claim that a transport protocol such as DCCP\n   would\
    \ always be implemented in the kernel, and do not attempt to\n   evaluate the\
    \ relative difficulty of modifying code inside the kernel\n   vs. outside the\
    \ kernel in any case.  However, we believe that putting\n   the congestion control\
    \ at the transport level rather than at the\n   application level makes it just\
    \ slightly less likely that users will\n   go to the trouble of modifying the\
    \ code in order to avoid using end-\n   to-end congestion control.\n"
- title: 3.2.  Providing Congestion Control Below UDP
  contents:
  - "3.2.  Providing Congestion Control Below UDP\n   Instead of providing congestion\
    \ control above UDP, a second\n   possibility would be to provide congestion control\
    \ for unreliable\n   applications at a layer below UDP, with applications using\
    \ UDP as\n   their transport protocol.  Given that UDP does not itself provide\n\
    \   sequence numbers or congestion feedback, there are two possible forms\n  \
    \ for this congestion feedback:\n   1) Feedback at the application: The application\
    \ above UDP could\n      provide sequence numbers and feedback to the sender,\
    \ which would\n      then communicate loss information to the congestion control\n\
    \      mechanism.  This is the approach currently standardized by the\n      Congestion\
    \ Manager (CM) [RFC3124].\n   2) Feedback at the layer below UDP: The application\
    \ could use UDP,\n      and a protocol could be implemented using a shim header\
    \ between IP\n      and UDP to provide sequence number information for data packets\n\
    \      and return feedback to the data sender.  The original proposal for\n  \
    \    the Congestion Manager [BRS99] suggested providing this layer for\n     \
    \ applications that did not have their own feedback about dropped\n      packets.\n\
    \   We discuss these two cases separately below.\n"
- title: '3.2.1.  Case 1: Congestion Feedback at the Application'
  contents:
  - "3.2.1.  Case 1: Congestion Feedback at the Application\n   In this case, the\
    \ application provides sequence numbers and\n   congestion feedback above UDP,\
    \ but communicates that feedback to a\n   congestion manager below UDP, which\
    \ regulates when packets can be\n   sent.  This approach suffers from most of\
    \ the problems described in\n   Section 3.1, namely, forcing the application designer\
    \ to reinvent the\n   wheel each time for packet formats and parameter negotiation,\
    \ and\n   problems with ECN usage, firewalls, and evasion.\n   It would avoid\
    \ the application writer needing to implement the\n   control part of the congestion\
    \ control mechanism, but it is unclear\n   how easily multiple congestion control\
    \ algorithms (such as receiver-\n   based TFRC) can be supported, given that the\
    \ form of congestion\n   feedback usually needs to be closely coupled to the congestion\n\
    \   control algorithm being used.  Thus, this design limits the choice of\n  \
    \ congestion control mechanisms available to applications while\n   simultaneously\
    \ burdening the applications with implementations of\n   congestion feedback.\n"
- title: '3.2.2.  Case 2: Congestion Feedback at a Layer Below UDP'
  contents:
  - "3.2.2.  Case 2: Congestion Feedback at a Layer Below UDP\n   Providing feedback\
    \ at a layer below UDP would require an additional\n   packet header below UDP\
    \ to carry sequence numbers in addition to the\n   8-byte header for UDP itself.\
    \  Unless this header were an IP option\n   (which is likely to cause problems\
    \ for many IPv4 routers), its\n   presence would need to be indicated using a\
    \ different IP protocol\n   value from UDP.  Thus, the packets would no longer\
    \ look like UDP on\n   the wire, and the modified protocol would face deployment\
    \ challenges\n   similar to those of an entirely new protocol.\n   To use congestion\
    \ feedback at a layer below UDP most effectively, the\n   semantics of the UDP\
    \ socket Application Programming Interface (API)\n   would also need changing,\
    \ both to support a late decision on what to\n   send and to provide access to\
    \ sequence numbers (so that the\n   application wouldn't need to duplicate them\
    \ for its own purposes).\n   Thus, the socket API would no longer look like UDP\
    \ to end hosts.\n   This would effectively be a new transport protocol.\n   Given\
    \ these complications, it seems cleaner to actually design a new\n   transport\
    \ protocol, which also allows us to address the issues of\n   firewall traversal,\
    \ flow setup, and parameter negotiation.  We note\n   that any new transport protocol\
    \ could also use a Congestion Manager\n   approach to share congestion state between\
    \ flows using the same\n   congestion control algorithm, if this were deemed to\
    \ be desirable.\n"
- title: 3.3.  Providing Congestion Control at the Transport Layer
  contents:
  - "3.3.  Providing Congestion Control at the Transport Layer\n   The concerns from\
    \ the discussions above have convinced us that the\n   best way to provide congestion\
    \ control to applications that currently\n   use UDP is to provide congestion\
    \ control at the transport layer, in a\n   transport protocol used as an alternative\
    \ to UDP.  One advantage of\n   providing end-to-end congestion control in an\
    \ unreliable transport\n   protocol is that it could be used easily by a wide\
    \ range of the\n   applications that currently use UDP, with minimal changes to\
    \ the\n   application itself.  The application itself would not have to provide\n\
    \   the congestion control mechanism, or even the feedback from the data\n   receiver\
    \ to the data sender about lost or marked packets.\n   The question then arises\
    \ of whether to adapt TCP for use by\n   unreliable applications, to use an unreliable\
    \ variant of the Stream\n   Control Transmission Protocol (SCTP) or a version\
    \ of RTP with built-\n   in congestion control, or to design a new transport protocol.\n\
    \   As we argue below, the desire for minimal overhead results in the\n   design\
    \ decision to use a transport protocol containing only the\n   minimal necessary\
    \ functionality, and to leave other functionality\n   such as reliability, semi-reliability,\
    \ or Forward Error Correction\n   (FEC) to be layered on top.\n"
- title: 3.3.1.  Modifying TCP?
  contents:
  - "3.3.1.  Modifying TCP?\n   One alternative might be to create an unreliable variant\
    \ of TCP, with\n   reliability layered on top for applications desiring reliable\n\
    \   delivery.  However, our requirement is not simply for TCP minus in-\n   order\
    \ reliable delivery, but also for the application to be able to\n   choose congestion\
    \ control algorithms.  TCP's feedback mechanism works\n   well for TCP-like congestion\
    \ control, but is inappropriate (or at the\n   very least, inefficient) for TFRC.\
    \  In addition, TCP sequence numbers\n   are in bytes, not datagrams.  This would\
    \ complicate both congestion\n   feedback and any attempt to allow the application\
    \ to decide, at\n   transmission time, what information should go into a packet.\n\
    \   Finally, there is the issue of whether a modified TCP would require a\n  \
    \ new IP protocol number as well; a significantly modified TCP using\n   the same\
    \ IP protocol number could have unwanted interactions with\n   some of the middleboxes\
    \ already deployed in the network.\n   It seems best simply to leave TCP as it\
    \ is, and to create a new\n   congestion control protocol for unreliable transfer.\
    \  This is\n   especially true since any change to TCP, no matter how small, takes\n\
    \   an inordinate amount of time to standardize and deploy, given TCP's\n   importance\
    \ in the current Internet and the historical difficulty of\n   getting TCP implementations\
    \ right.\n"
- title: 3.3.2.  Unreliable Variants of SCTP?
  contents:
  - "3.3.2.  Unreliable Variants of SCTP?\n   SCTP, the Stream Control Transmission\
    \ Protocol [RFC2960], was in part\n   designed to accommodate multiple streams\
    \ within a single end-to-end\n   connection, modifying TCP's semantics of reliable,\
    \ in-order delivery\n   to allow out-of-order delivery.  However, explicit support\
    \ for\n   multiple streams over a single flow at the transport layer is not\n\
    \   necessary for an unreliable transport protocol such as DCCP, which of\n  \
    \ necessity allows out-of-order delivery.  Because an unreliable\n   transport\
    \ does not need streams support, applications should not have\n   to pay the penalties\
    \ in terms of increased header size that accompany\n   the use of streams in SCTP.\n\
    \   The basic underlying structure of the SCTP packet, of a common SCTP\n   header\
    \ followed by chunks for data, SACK information, and so on, is\n   motivated by\
    \ SCTP's goal of accommodating multiple streams.  However,\n   this use of chunks\
    \ comes at the cost of an increased header size for\n   packets, as each chunk\
    \ must be aligned on 32-bit boundaries, and\n   therefore requires a fixed-size\
    \ 4-byte chunk header.  For example,\n   for a connection using ECN, SCTP includes\
    \ separate control chunks for\n   the Explicit Congestion Notification Echo (ECNE)\
    \ and Congestion\n   Window Reduced (CWR) functions, with the ECNE and CWR chunks\
    \ each\n   requiring 8 bytes.  As another example, the common header includes\
    \ a\n   4-byte verification tag to validate the sender.\n   As a second concern,\
    \ SCTP as currently specified uses TCP-like\n   congestion control, and does not\
    \ provide support for alternative\n   congestion control algorithms such as TFRC\
    \ that would be more\n   attractive to some of the applications currently using\
    \ UDP flows.\n   Thus, the current version of SCTP would not meet the requirements\
    \ for\n   a choice between forms of end-to-end congestion control.\n   Finally,\
    \ the SCTP Partial Reliability extension [RFC3758] allows a\n   sender to selectively\
    \ abandon outstanding messages, which ceases\n   retransmissions and allows the\
    \ receiver to deliver any queued\n   messages on the affected streams.  This service\
    \ model, although\n   well-suited for some applications, differs from, and provides\
    \ the\n   application somewhat less flexibility than, UDP's fully unreliable\n\
    \   service.\n   One could suggest adding support for alternative congestion control\n\
    \   mechanisms as an option to SCTP, and adding a fully-unreliable\n   variant\
    \ that does not include the mechanisms for multiple streams.\n   We would argue\
    \ against this.  SCTP is well-suited for applications\n   that desire limited\
    \ retransmission with multistream or multihoming\n   support.  Adding support\
    \ for fully-unreliable variants, multiple\n   congestion control profiles, and\
    \ reduced single-stream headers would\n   risk introducing unforeseen interactions\
    \ and make further\n   modifications ever more difficult.  We have chosen instead\
    \ to\n   implement a minimal protocol, designed for fully-unreliable datagram\n\
    \   service, that provides only end-to-end congestion control and any\n   other\
    \ mechanisms that cannot be provided in a higher layer.\n"
- title: 3.3.3.  Modifying RTP?
  contents:
  - "3.3.3.  Modifying RTP?\n   Several of our target applications currently use RTP\
    \ layered above\n   UDP to transfer their data.  Why not modify RTP to provide\
    \ end-to-end\n   congestion control?\n   When RTP lives above UDP, modifying it\
    \ to support congestion control\n   might create some of the problems described\
    \ in Section 3.1.  In\n   particular, user-level RTP implementations would want\
    \ access to ECN\n   bits in UDP datagrams.  It might be difficult or undesirable\
    \ to allow\n   that access for RTP, but not for other user-level programs.\n \
    \  Kernel implementations of RTP would not suffer from this problem.  In\n   the\
    \ end, the argument against modifying RTP is the same as that\n   against modifying\
    \ SCTP: Some applications, such as the export of flow\n   information from routers,\
    \ need congestion control but don't need much\n   of RTP's functionality.  From\
    \ these applications' point of view, RTP\n   would induce unnecessary overhead.\
    \  Again, we would argue for a clean\n   and minimal protocol focused on end-to-end\
    \ congestion control.\n   RTP would commonly be used as a layer above any new\
    \ transport\n   protocol, however.  The design of that new transport protocol\
    \ should\n   take this into account, either by avoiding undue duplication of\n\
    \   information available in the RTP header, or by suggesting\n   modifications\
    \ to RTP, such as a reduced RTP header that removes any\n   fields redundant with\
    \ the new protocol's headers.\n"
- title: 3.3.4.  Designing a New Transport Protocol
  contents:
  - "3.3.4.  Designing a New Transport Protocol\n   In the first half of this document,\
    \ we have argued for providing\n   congestion control at the transport layer as\
    \ an alternative to UDP,\n   instead of relying on congestion control supplied\
    \ only above or below\n   UDP.  In this section, we have examined the possibilities\
    \ of\n   modifying SCTP, modifying TCP, and designing a new transport\n   protocol.\
    \  In large part because of the requirement for unreliable\n   transport, and\
    \ for accommodating TFRC as well as TCP-like congestion\n   control, we have concluded\
    \ that modifications of SCTP or TCP are not\n   the best answer and that a new\
    \ transport protocol is needed.  Thus,\n   we have argued for the need for a new\
    \ transport protocol that offers\n   unreliable delivery, accommodates TFRC as\
    \ well as TCP-like congestion\n   control, accommodates the use of ECN, and requires\
    \ minimal overhead\n   in packet size and in the state and CPU processing required\
    \ at the\n   data receiver.\n"
- title: 4.  Selling Congestion Control to Reluctant Applications
  contents:
  - "4.  Selling Congestion Control to Reluctant Applications\n   The goal of this\
    \ work is to provide general congestion control\n   mechanisms that will actually\
    \ be used by many of the applications\n   that currently use UDP.  This may include\
    \ applications that are\n   perfectly happy without end-to-end congestion control.\
    \  Several of\n   our design requirements follow from a desire to design and deploy\
    \ a\n   congestion-controlled protocol that is actually attractive to these\n\
    \   \"reluctant\" applications.  These design requirements include a choice\n\
    \   between different forms of congestion control, moderate overhead in\n   the\
    \ size of the packet header, and the use of Explicit Congestion\n   Notification\
    \ (ECN) and the ECN nonce [RFC3540], which provide\n   positive benefit to the\
    \ application itself.\n   There will always be a few flows that are resistant\
    \ to the use of\n   end-to-end congestion control, preferring an environment where\
    \ end-\n   to-end congestion control is used by everyone else, but not by\n  \
    \ themselves.  There has been substantial agreement [RFC2309, FF99]\n   that in\
    \ order to maintain the continued use of end-to-end congestion\n   control, router\
    \ mechanisms are needed to detect and penalize\n   uncontrolled high-bandwidth\
    \ flows in times of high congestion; these\n   router mechanisms are colloquially\
    \ known as \"penalty boxes\".\n   However, before undertaking a concerted effort\
    \ toward the deployment\n   of penalty boxes in the Internet, it seems reasonable,\
    \ and more\n   effective, to first make a concerted effort to make end-to-end\n\
    \   congestion control easily available to applications currently using\n   UDP.\n"
- title: 5.  Additional Design Considerations
  contents:
  - "5.  Additional Design Considerations\n   This section mentions some additional\
    \ design considerations that\n   should be considered in designing a new transport\
    \ protocol.\n   o  Mobility: Mechanisms for multihoming and mobility are one area\
    \ of\n      additional functionality that cannot necessarily be layered\n    \
    \  cleanly and effectively on top of a transport protocol.  Thus, one\n      outstanding\
    \ design decision with any new transport protocol\n      concerns whether to incorporate\
    \ mechanisms for multihoming and\n      mobility into the protocol itself.  The\
    \ current version of DCCP\n      [RFC4340] includes no multihoming or mobility\
    \ support.\n   o  Defense against DoS attacks and spoofing: A reliable handshake\
    \ for\n      connection setup and teardown offers protection against DoS and\n\
    \      spoofing attacks.  Mechanisms allowing a server to avoid holding\n    \
    \  any state for unacknowledged connection attempts or already-\n      finished\
    \ connections offer additional protection against DoS\n      attacks.  Thus, in\
    \ designing a new transport protocol, even one\n      designed to provide minimal\
    \ functionality, the requirements for\n      providing defense against DoS attacks\
    \ and spoofing need to be\n      considered.\n   o  Interoperation with RTP: As\
    \ Section 3.3.3 describes, attention\n      should be paid to any necessary or\
    \ desirable changes in RTP when\n      it is used over the new protocol, such\
    \ as reduced RTP headers.\n   o  API: Some functionality required by the protocol,\
    \ or useful for\n      applications using the protocol, may require the definition\
    \ of new\n      API mechanisms.  Examples include allowing applications to decide\n\
    \      what information to put in a packet at transmission time, and\n      providing\
    \ applications with some information about packet sequence\n      numbers.\n \
    \  o  Interactions with NATs and firewalls: NATs and firewalls don't\n      interact\
    \ well with UDP, with its lack of explicit flow setup and\n      teardown and,\
    \ in practice, the lack of well-known ports for many\n      UDP applications.\
    \  Some of these issues are application specific;\n      others should be addressed\
    \ by the transport protocol itself.\n   o  Consider general experiences with unicast\
    \ transport: A\n      Requirements for Unicast Transport/Sessions (RUTS) BOF was\
    \ held at\n      the IETF meeting in December 1998, with the goal of understanding\n\
    \      the requirements of applications whose needs were not met by TCP\n    \
    \  [RUTS].  Not all of those unmet needs are relevant to or\n      appropriate\
    \ for a unicast, congestion-controlled, unreliable flow\n      of datagrams designed\
    \ for long-lived transfers.  Some are,\n      however, and any new protocol should\
    \ address those needs and other\n      requirements derived from the community's\
    \ experience.  We believe\n      that this document addresses the requirements\
    \ relevant to our\n      problem area that were brought up at the RUTS BOF.\n"
- title: 6.  Transport Requirements of Request/Response Applications
  contents:
  - "6.  Transport Requirements of Request/Response Applications\n   Up until now,\
    \ this document has discussed the transport and\n   congestion control requirements\
    \ of applications that generate long-\n   lived, large flows of unreliable datagrams.\
    \  This section discusses\n   briefly the transport needs of another class of\
    \ applications, those\n   of request/response transfers where the response might\
    \ be a small\n   number of packets, with preferences that include both reliable\n\
    \   delivery and a minimum of state maintained at the ends.  The reliable\n  \
    \ delivery could be accomplished, for example, by having the receiver\n   re-query\
    \ when one or more of the packets in the response is lost.\n   This is a class\
    \ of applications whose needs are not well-met by\n   either UDP or by TCP.\n\
    \   Although there is a legitimate need for a transport protocol for such\n  \
    \ short-lived reliable flows of such request/response applications, we\n   believe\
    \ that the overlap with the requirements of DCCP is almost\n   non-existent and\
    \ that DCCP should not be designed to meet the needs\n   of these request/response\
    \ applications.  Areas of non-compatible\n   requirements include the following:\n\
    \   o  Reliability: DCCP applications don't need reliability (and long-\n    \
    \  lived applications that do require reliability are well-suited to\n      TCP\
    \ or SCTP).  In contrast, these short-lived request/response\n      applications\
    \ do require reliability (possibly client-driven\n      reliability in the form\
    \ of requesting missing segments of a\n      response).\n   o  Connection setup\
    \ and teardown: Because DCCP is aimed at flows\n      whose duration is often\
    \ unknown in advance, it addresses\n      interactions with NATs and firewalls\
    \ by having explicit handshakes\n      for setup and teardown.  In contrast, the\
    \ short-lived\n      request/response applications know the transfer length in\
    \ advance,\n      but cannot tolerate the additional delay of a handshake for\
    \ flow\n      setup.  Thus, mechanisms for interacting with NATs and firewalls\n\
    \      are likely to be completely different for the two sets of\n      applications.\n\
    \   o  Congestion control mechanisms: The styles of congestion control\n     \
    \ mechanisms and negotiations of congestion control features are\n      heavily\
    \ dependent on the flow duration.  In addition, the\n      preference of the request/response\
    \ applications for a stateless\n      server strongly impacts the congestion control\
    \ choices.  Thus,\n      DCCP and the short-lived request/response applications\
    \ have rather\n      different requirements both for congestion control mechanisms\
    \ and\n      for negotiation procedures.\n"
- title: 7.  Summary of Recommendations
  contents:
  - "7.  Summary of Recommendations\n   Our problem statement has discussed the need\
    \ for implementing\n   congestion control for unreliable flows.  Additional problems\
    \ concern\n   the need for low overhead, the problems of firewall traversal, and\n\
    \   the need for reliable parameter negotiation.  Our consideration of\n   the\
    \ problem statement has resulted in the following general\n   recommendations:\n\
    \   o  A unicast transport protocol for unreliable datagrams should be\n     \
    \ developed, including mandatory, built-in congestion control,\n      explicit\
    \ connection setup and teardown, reliable feature\n      negotiation, and reliable\
    \ congestion feedback.\n   o  The protocol must provide a set of congestion control\
    \ mechanisms\n      from which the application may choose.  These mechanisms should\n\
    \      include, at minimum, TCP-like congestion control and a more\n      slowly-responding\
    \ congestion control such as TFRC.\n   o  Important features of the connection,\
    \ such as the congestion\n      control mechanism in use, should be reliably negotiated\
    \ by both\n      endpoints.\n   o  Support for ECN should be included.  (Applications\
    \ could still\n      make the decision not to use ECN for a particular session.)\n\
    \   o  The overhead must be low, in terms of both packet size and\n      protocol\
    \ complexity.\n   o  Some DoS protection for servers must be included.  In particular,\n\
    \      servers can make themselves resistant to spoofed connection\n      attacks\
    \ (\"SYN floods\").\n   o  Connection setup and teardown must use explicit handshakes,\n\
    \      facilitating transmission through stateful firewalls.\n   In 2002, there\
    \ was judged to be a consensus about the need for a new\n   unicast transport\
    \ protocol for unreliable datagrams, and the next\n   step was then the consideration\
    \ of more detailed architectural\n   issues.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   There are no security considerations for this\
    \ document.  It does\n   discuss a number of security issues in the course of\
    \ problem\n   analysis, such as DoS resistance and firewall traversal.  The\n\
    \   security considerations for DCCP are discussed separately in\n   [RFC4340].\n"
- title: 9.  Acknowledgements
  contents:
  - "9.  Acknowledgements\n   We would like to thank Spencer Dawkins, Jiten Goel,\
    \ Jeff Hammond,\n   Lars-Erik Jonsson, John Loughney, Michael Mealling, and Rik\
    \ Wade for\n   feedback on earlier versions of this document.  We would also like\
    \ to\n   thank members of the Transport Area Working Group and of the DCCP\n \
    \  Working Group for discussions of these issues.\n"
- title: Informative References
  contents:
  - "Informative References\n   [BRS99]        Balakrishnan, H., Rahul, H., and S.\
    \ Seshan, \"An\n                  Integrated Congestion Management Architecture\
    \ for\n                  Internet Hosts\", SIGCOMM, Sept. 1999.\n   [FF99]   \
    \      Floyd, S. and K. Fall, \"Promoting the Use of End-to-\n               \
    \   End Congestion Control in the Internet\", IEEE/ACM\n                  Transactions\
    \ on Networking, August 1999.\n   [PF01]         Padhye, J. and S. Floyd, \"Identifying\
    \ the TCP Behavior\n                  of Web Servers\", SIGCOMM 2001.\n   [RFC2309]\
    \      Braden, B., Clark, D., Crowcroft, J., Davie, B.,\n                  Deering,\
    \ S., Estrin, D., Floyd, S., Jacobson, V.,\n                  Minshall, G., Partridge,\
    \ C., Peterson, L.,\n                  Ramakrishnan, K., Shenker, S., Wroclawski,\
    \ J., and L.\n                  Zhang, \"Recommendations on Queue Management and\n\
    \                  Congestion Avoidance in the Internet\", RFC 2309, April\n \
    \                 1998.\n   [RFC2326]      Schulzrinne, H., Rao, A., and R. Lanphier,\
    \ \"Real Time\n                  Streaming Protocol (RTSP)\", RFC 2326, April\
    \ 1998.\n   [RFC2525]      Paxson, V., Allman, M., Dawson, S., Fenner, W.,\n \
    \                 Griner, J., Heavens, I., Lahey, K., Semke, J., and B.\n    \
    \              Volz, \"Known TCP Implementation Problems\", RFC 2525,\n      \
    \            March 1999.\n   [RFC2914]      Floyd, S., \"Congestion Control Principles\"\
    , BCP 41,\n                  RFC 2914, September 2000.\n   [RFC2960]      Stewart,\
    \ R., Xie, Q., Morneault, K., Sharp, C.,\n                  Schwarzbauer, H.,\
    \ Taylor, T., Rytina, I., Kalla, M.,\n                  Zhang, L., and V. Paxson,\
    \ \"Stream Control Transmission\n                  Protocol\", RFC 2960, October\
    \ 2000.\n   [RFC3124]      Balakrishnan, H. and S. Seshan, \"The Congestion\n\
    \                  Manager\", RFC 3124, June 2001.\n   [RFC3168]      Ramakrishnan,\
    \ K., Floyd, S., and D. Black, \"The\n                  Addition of Explicit Congestion\
    \ Notification (ECN) to\n                  IP\", RFC 3168, September 2001.\n \
    \  [RFC3261]      Rosenberg, J., Schulzrinne, H., Camarillo, G.,\n           \
    \       Johnston, A., Peterson, J., Sparks, R., Handley, M.,\n               \
    \   and E. Schooler, \"SIP: Session Initiation Protocol\",\n                 \
    \ RFC 3261, June 2002.\n   [RFC3448]      Handley, M., Floyd, S., Padhye, J.,\
    \ and J. Widmer,\n                  \"TCP Friendly Rate Control (TFRC): Protocol\n\
    \                  Specification\", RFC 3448, January 2003.\n   [RFC3540]    \
    \  Spring, N., Wetherall, D., and D. Ely, \"Robust\n                  Explicit\
    \ Congestion Notification (ECN) Signaling with\n                  Nonces\", RFC\
    \ 3540, June 2003.\n   [RFC3714]      Floyd, S. and J. Kempf, \"IAB Concerns Regarding\n\
    \                  Congestion Control for Voice Traffic in the Internet\",\n \
    \                 RFC 3714, March 2004.\n   [RFC3758]      Stewart, R., Ramalho,\
    \ M., Xie, Q., Tuexen, M., and P.\n                  Conrad, \"Stream Control\
    \ Transmission Protocol (SCTP)\n                  Partial Reliability Extension\"\
    , RFC 3758, May 2004.\n   [RFC4340]      Kohler, E., Handley, M., and S. Floyd,\
    \ \"Datagram\n                  Congestion Control Protocol (DCCP)\", RFC 4340,\
    \ March\n                  2006.\n   [RUTS]         Requirements for Unicast Transport/Sessions\
    \ (RUTS)\n                  BOF, Dec. 7, 1998.  URL\n                  \"http://www.ietf.org/proceedings/98dec/43rd-ietf-\n\
    \                  98dec-142.html\".\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Sally Floyd\n   ICSI Center for Internet Research (ICIR),\n\
    \   International Computer Science Institute,\n   1947 Center Street, Suite 600\n\
    \   Berkeley, CA 94704\n   USA\n   EMail: floyd@icir.org\n   Mark Handley\n  \
    \ Department of Computer Science\n   University College London\n   Gower Street\n\
    \   London WC1E 6BT\n   UK\n   EMail: M.Handley@cs.ucl.ac.uk\n   Eddie Kohler\n\
    \   4531C Boelter Hall\n   UCLA Computer Science Department\n   Los Angeles, CA\
    \ 90095\n   USA\n   EMail: kohler@cs.ucla.edu\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n\
    \   Administrative Support Activity (IASA).\n"
