- contents:
  - '                       Service Location Protocol

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Abstract\n   The Service Location Protocol provides a scalable framework for
    the\n   discovery and selection of network services.  Using this protocol,\n   computers
    using the Internet no longer need so much static\n   configuration of network
    services for network based applications.\n   This is especially important as computers
    become more portable, and\n   users less tolerant or able to fulfill the demands
    of network system\n   administration.\n"
  title: Abstract
- contents:
  - "Table of Contents\n 1. Introduction                                                       3\n
    2. Terminology                                                        3\n     2.1.
    Notation Conventions  . . . . . . . . . . . . . . . . . .    5\n     2.2. Service
    Information and Predicate Representation  . . . .    5\n     2.3. Specification
    Language  . . . . . . . . . . . . . . . . .    6\n 3. Protocol Overview                                                  6\n
    \    3.1. Protocol Transactions . . . . . . . . . . . . . . . . . .    7\n     3.2.
    Schemes . . . . . . . . . . . . . . . . . . . . . . . . .    8\n           3.2.1.
    The \"service:\" URL scheme . . . . . . . . . . . .    9\n     3.3. Standard Attribute
    Definitions  . . . . . . . . . . . . .    9\n     3.4. Naming Authority  . . .
    . . . . . . . . . . . . . . . . .   10\n     3.5. Interpretation of Service Location
    Replies  . . . . . . .   10\n     3.6. Use of TCP, UDP and Multicast in Service
    Location . . . .   10\n           3.6.1. Multicast vs.  Broadcast  . . . . . .
    . . . . . .   11\n           3.6.2. Service-Specific Multicast Address  . . .
    . . . .   11\n     3.7. Service Location Scaling, and Multicast Operating Modes
    .   12\n 4. Service Location General Message Format                           14\n
    \    4.1. Use of Transaction IDs (XIDs) . . . . . . . . . . . . . .   15\n     4.2.
    URL Entries . . . . . . . . . . . . . . . . . . . . . . .   16\n     4.3. Authentication
    Blocks . . . . . . . . . . . . . . . . . .   17\n     4.4. URL Entry Lifetime
    \ . . . . . . . . . . . . . . . . . . .   19\n 5. Service Request Message Format
    \                                   19\n     5.1. Service Request Usage . . .
    . . . . . . . . . . . . . . .   22\n     5.2. Directory Agent Discovery Request
    . . . . . . . . . . . .   23\n     5.3. Explanation of Terms of Predicate Grammar
    . . . . . . . .   24\n     5.4. Service Request Predicate Grammar . . . . . .
    . . . . . .   26\n     5.5. String Matching for Requests  . . . . . . . . . .
    . . . .   27\n 6. Service Reply Message Format                                      28\n
    7. Service Type Request Message Format                               29\n 8. Service
    Type Reply Message Format                                 31\n 9. Service Registration
    Message Format                               32\n"
  - '10. Service Acknowledgement Message Format                            35

    '
  - '11. Service Deregister Message Format                                 37

    '
  - '12. Attribute Request Message Format                                  38

    '
  - '13. Attribute Reply Message Format                                    40

    '
  - '14. Directory Agent Advertisement Message Format                      42

    '
  - "15. Directory Agents                                                  43\n    15.1.
    Introduction  . . . . . . . . . . . . . . . . . . . . . .   43\n    15.2. Finding
    Directory Agents  . . . . . . . . . . . . . . . .   43\n"
  - "16. Scope Discovery and Use                                           45\n    16.1.
    Protected Scopes  . . . . . . . . . . . . . . . . . . . .   46\n"
  - "17. Language and Character Encoding Issues                            47\n    17.1.
    Character Encoding and String Issues  . . . . . . . . . .   48\n          17.1.1.
    Substitution of Character Escape Sequences  . . .   49\n    17.2. Language-Independent
    Strings  . . . . . . . . . . . . . .   49\n"
  - "18. Service Location Transactions                                     50\n    18.1.
    Service Location Connections  . . . . . . . . . . . . . .   50\n    18.2. No Synchronous
    Assumption . . . . . . . . . . . . . . . .   51\n    18.3. Idempotency . . . .
    . . . . . . . . . . . . . . . . . . .   51\n"
  - '19. Security Considerations                                           51

    '
  - "20. String Formats used with Service Location Messages                52\n    20.1.
    Previous Responders' Address Specification  . . . . . . .   53\n    20.2. Formal
    Definition of the \"service:\" Scheme  . . . . . . .   53\n          20.2.1. Service
    Type String . . . . . . . . . . . . . . .   54\n    20.3. Attribute Information
    . . . . . . . . . . . . . . . . . .   54\n    20.4. Address Specification in Service
    Location . . . . . . . .   55\n    20.5. Attribute Value encoding rules  . . .
    . . . . . . . . . .   55\n"
  - "21. Protocol Requirements                                             56\n    21.1.
    User Agent Requirements . . . . . . . . . . . . . . . . .   56\n    21.2. Service
    Agent Requirements  . . . . . . . . . . . . . . .   58\n    21.3. Directory Agent
    Requirements  . . . . . . . . . . . . . .   59\n"
  - "22. Configurable Parameters and Default Values                        61\n    22.1.
    Service Agent:  Use Predefined Directory Agent(s) . . . .   62\n    22.2. Time
    Out Intervals  . . . . . . . . . . . . . . . . . . .   63\n"
  - '23. Non-configurable Parameters                                       63

    '
  - "24. Acknowledgments                                                   64\n A.
    Appendix:  Technical contents of ISO 639:1988 (E/F): \"Code for\n   the representation
    of names of languages\"                          65\n B. SLP Certificates                                                  66\n
    C. Example of deploying SLP security using MD5 and RSA               68\n D. Example
    of use of SLP Certificates by mobile nodes                68\n E. Appendix:  For
    Further Reading                                    69\n"
  title: Table of Contents
- contents:
  - "1. Introduction\n   Traditionally, users find services by using the name of a
    network\n   host (a human readable text string) which is an alias for a network\n
    \  address.  The Service Location Protocol eliminates the need for a\n   user
    to know the name of a network host supporting a service.\n   Rather, the user
    names the service and supplies a set of attributes\n   which describe the service.
    \ The Service Location Protocol allows the\n   user to bind this description to
    the network address of the service.\n   Service Location provides a dynamic configuration
    mechanism for\n   applications in local area networks.  It is not a global resolution\n
    \  system for the entire Internet; rather it is intended to serve\n   enterprise
    networks with shared services.  Applications are modeled\n   as clients that need
    to find servers attached to the enterprise\n   network at a possibly distant location.
    \ For cases where there are\n   many different clients and/or services available,
    the protocol is\n   adapted to make use of nearby Directory Agents that offer
    a\n   centralized repository for advertised services.\n"
  title: 1. Introduction
- contents:
  - "2. Terminology\n      User Agent (UA)\n                A process working on the
    user's behalf to acquire\n                service attributes and configuration.
    \ The User Agent\n                retrieves service information from the Service
    Agents or\n                Directory Agents.\n      Service Agent (SA)\n                A
    process working on the behalf of one or more services\n                to advertise
    service attributes and configuration.\n      Service Information\n                A
    collection of attributes and configuration information\n                associated
    with a single service.  The Service Agents\n                advertise service
    information for a collection of\n                service instances.\n      Service
    \  The service is a process or system providing a facility\n                to
    the network.  The service itself is accessed using a\n                communication
    mechanism external to the the Service\n                Location Protocol.\n      Directory
    Agent (DA)\n                A process which collects information from Service
    Agents\n                to provide a single repository of service information
    in\n                order to centralize it for efficient access by User\n                Agents.
    \ There can only be one DA present per given\n                host.\n      Service
    Type\n                Each type of service has a unique Service Type string.\n
    \               The Service Type defines a template, called a \"service\n                scheme\",
    including expected attributes, values and\n                protocol behavior.\n
    \     Naming Authority\n                The agency or group which catalogues given
    Service Types\n                and Attributes.  The default Naming Authority is
    IANA,\n                the Internet Assigned Numbers Authority.\n      Keyword\n
    \               A string describing a characteristic of a service.\n      Attribute\n
    \               A (class, value-list) pair of strings describing a\n                characteristic
    of a service.  The value string may be\n                interpreted as a boolean,
    integer or opaque value if it\n                takes specific forms (see section
    20.5).\n      Predicate\n                A boolean expression of attributes, relations
    and\n                logical operators.  The predicate is used to find\n                services
    which satisfy particular requirements.  See\n                section 5.3.\n      Alphanumeric\n
    \               A character within the range 'a' to 'z', 'A' to 'Z', or\n      Scope
    \    A collection of services that make up a logical group.\n                See
    sections 3.7 and 16.\n      Site Network\n                All the hosts accessible
    within the Agent's multicast\n                radius, which defaults to a value
    appropriate for\n                reaching all hosts within a site (see section
    22).  If\n                the site does not support multicast, the agent's site\n
    \               network is restricted to a single subnet.\n      URL       A Universal
    Resource Locator - see [6].\n      Address Specification\n                This
    is the network layer protocol dependent mechanism\n                for specifying
    an Agent.  For Internet systems this is\n                part of a URL.\n"
  - contents:
    - "2.1. Notation Conventions\n      CAPS   Strings which appear in all capital
      letters are protocol\n             literal.  All string comparison is case insensitive,\n
      \            however, (see section 5.5).  Some strings are quoted in\n             this
      document to indicate they should be used literally.\n             Single characters
      inside apostrophes are included\n             literally.\n      <>     Values
      set off in this manner are fully described in\n             section 20.  In
      general, all definitions of items in\n             messages are described in
      section 20 or immediately\n             following their first use.\n      |
      \ |\n      \\  \\   Message layouts with this notation indicate a variable\n
      \     |  |   length field.\n"
    title: 2.1. Notation Conventions
  - contents:
    - "2.2. Service Information and Predicate Representation\n   Service information
      is represented in a text format.  The goal is\n   that the format be human readable
      and transmissible via email.  The\n   location of network services is encoded
      as a Universal Resource\n   Locator (URL) which is human readable.  Only the
      datagram headers are\n   encoded in a form which is not human readable.  Strings
      used in the\n   Service Location Protocol are NOT null-terminated.\n   Predicates
      are expressed in a simple boolean notation using keywords,\n   attributes, and
      logical connectives, as described in Section 5.4.\n   The logical connectives
      and subexpressions are presented in prefix-\n   order, so that the connective
      comes first and the expressions it\n   operates on follow afterwards.\n"
    title: 2.2. Service Information and Predicate Representation
  - contents:
    - "2.3. Specification Language\n   In this document, several words are used to
      signify the requirements\n   of the specification [8].  These words are often
      capitalized.\n      MUST       This word, or the adjective \"required\", means
      that\n                 the definition is an absolute requirement of the\n                 specification.\n
      \     MUST NOT   This phrase means that the definition is an absolute\n                 prohibition
      of the specification.\n      SHOULD     This word, or the adjective \"recommended\",
      means\n                 that, in some circumstances, valid reasons may exist
      to\n                 ignore this item, but the full implications must be\n                 understood
      and carefully weighed before choosing a\n                 different course.
      \ Unexpected results may result\n                 otherwise.\n      MAY        This
      word, or the adjective \"optional\", means that this\n                 item
      is one of an allowed set of alternatives.  An\n                 implementation
      which does not include this option MUST\n                 be prepared to interoperate
      with another implementation\n                 which does include the option.\n
      \     silently discard\n                 The implementation discards the datagram
      without\n                 further processing, and without indicating an error
      to\n                 the sender.  The implementation SHOULD provide the\n                 capability
      of logging the error, including the contents\n                 of the discarded
      datagram, and SHOULD record the event\n                 in a statistics counter.\n"
    title: 2.3. Specification Language
  title: 2. Terminology
- contents:
  - "3. Protocol Overview\n   The basic operation in Service Location is that a client
    attempts to\n   discover the location of a Service.  In smaller installations,
    each\n   service will be configured to respond individually to each client.\n
    \  In larger installations, services will register their services with\n   one
    or more Directory Agents, and clients will contact the Directory\n   Agent to
    fulfill requests for Service Location information.  Clients\n   may discover the
    whereabouts of a Directory Agent by\n   preconfiguration, DHCP [2, 11], or by
    issuing queries to the\n   Directory Agent Discovery multicast address.\n"
  - contents:
    - "3.1. Protocol Transactions\n   The diagram below illustrates the relationships
      described below:\n      +---------------+   we want this info:     +-----------+\n
      \     |  Application  | - - - - - - - - - - - -> |  Service  |\n      +---------------+
      \                         +-----------+\n           /|\\                                      |
      \    |\n            |                         +-------------+     |\n            |
      \                        |                   |\n           \\|/                       \\|/
      \                \\|/\n      +---------------+          +-----------+      +----------------+\n
      \     |   User Agent  |<-------->|  Service  |      |    Service     |\n      +---------------+
      \         |   Agent   |      | Agent which    |\n            |                    +-----------+
      \     | does not reply |\n            |                         |             |
      to UA requests |\n            |                        \\|/            +----------------+\n
      \           |                   +-------------+           |\n            +------------------>|
      \ Directory  |<----------+\n                                |    Agent    |\n
      \                               +-------------+      ___________\n                                     /|\\
      \           / Many other\\\n                                      +------------>|
      \  SA's    |\n                                                    \\___________/\n
      \  The following describes the operations a User Agent would employ to\n   find
      services on the site's network.  The User Agent needs no\n   configuration to
      begin network interaction.  The User Agent can\n   acquire information to construct
      predicates which describe the\n   services that match the user's needs.  The
      User Agent may build on\n   the information received in earlier network requests
      to find the\n   Service Agents advertising service information.\n   A User Agent
      will operate two ways:  If the User Agent has already\n   obtained the location
      of a Directory Agent, the User Agent will\n   unicast a request to it in order
      to resolve a particular request.\n   The Directory Agent will unicast a reply
      to the User Agent.  The User\n   Agent will retry a request to a Directory Agent
      until it gets a\n   reply, so if the Directory Agent cannot service the request
      (say it\n   has no information) it must return an response with zero values,\n
      \  possibly with an error code set.\n   If the User Agent does not have knowledge
      of a Directory Agent or if\n   there are no Directory Agents available on the
      site network, a second\n   mode of discovery may be used.  The User Agent multicasts
      a request\n   to the service-specific multicast address, to which the service
      it\n   wishes to locate will respond.  All the Service Agents which are\n   listening
      to this multicast address will respond, provided they can\n   satisfy the User
      Agent's request.  A similar mechanism is used for\n   Directory Agent discovery;
      see section 5.2.  Service Agents which\n   have no information for the User
      Agent MUST NOT respond.\n   When a User Agent wishes to obtain an enumeration
      of ALL services\n   which satisfy the query, a retransmission/convergence algorithm
      is\n   used.  The User Agent resends the request, together with a list of\n
      \  previous responders.  Only those Service Agents which are not on the\n   list
      respond.  Once there are no new responses to the request the\n   accumulation
      of responses is deemed complete.  Depending on the\n   length of the request,
      around 60 previous responders may be listed in\n   a single datagram.  If there
      are more responders than this, the\n   scaling mechanisms described in section
      3.7 should be used.\n   While the multicast/convergence model may be important
      for\n   discovering services (such as Directory Agents) it is the exception\n
      \  rather than the rule.  Once a User Agent knows of the location of a\n   Directory
      Agent, it will use a unicast request/response transaction.\n   The Service Agent
      SHOULD listen for multicast requests on the\n   service-specific multicast address,
      and MUST register with an\n   available Directory Agent.  This Directory Agent
      will resolve\n   requests from User Agents which are unicasted using TCP or
      UDP. This\n   means that a Directory Agent must first be discovered, using DHCP,\n
      \  the DA Discovery Multicast address, the multicast mechanism described\n   above,
      or manual configuration.  See section 5.2.\n   A Service Agent which does not
      respond to multicast requests will not\n   be useful in the absence of Directory
      Agents.  Some Service Agents\n   may not include this functionality, if an especially
      lightweight\n   implementation is required.\n   If the service is to become
      unavailable, it should be deregistered\n   with the Directory Agent.  The Directory
      Agent responds with an\n   acknowledgment to either a registration or deregistration.
      \ Service\n   Registrations include a lifetime, and will eventually expire.\n
      \  Service Registrations need to be refreshed by the Service Agent\n   before
      their Lifetime runs out.  If need be, Service Agents can\n   advertise signed
      URLs to prove that they are authorized to provide\n   the service.\n"
    title: 3.1. Protocol Transactions
  - contents:
    - "3.2. Schemes\n   The Service Location Protocol, designed as a way for clients
      to\n   access resources on the network, is a natural application for\n   Universal
      Resource Locators (URLs).  It is intended that by re-using\n   URL specification
      and technology from the World Wide Web, clients and\n   servers will be more
      flexible and able to be written using already\n   existing code.  Moreover,
      it is hoped that browsers will be written\n   to take advantage of the similarity
      in locator format, so that a\n   client can dynamically formulate requests for
      services that are\n   resolved differently depending upon the circumstances.\n"
    - contents:
      - "3.2.1. The \"service:\"  URL scheme\n   The service URL scheme is used by
        Service Location.  It is used to\n   specify a Service Location.  Many Service
        Types will be named by\n   including a scheme name after the \"service:\"
        \ scheme name.  Service\n   Types are used by SAs to register and deregister
        Services with DAs.\n   It is also used by SAs and DAs to return Service Replies
        to UAs.  The\n   formal definition of the \"service:\" URL scheme is in section
        20.2.\n   The format of the information which follows the \"service:\"  scheme\n
        \  should as closely as possible follow the URL structure and semantics\n
        \  as formalized by the IETF standardization process.\n   Well known Service
        Types are registered with the IANA and templates\n   are available as RFCs.
        \ Private Service Types may also be supported.\n"
      title: 3.2.1. The "service:"  URL scheme
    title: 3.2. Schemes
  - contents:
    - "3.3. Standard Attribute Definitions\n   Service Types used with the Service
      Location Protocol must describe\n   the following:\n         Service Type string
      of the service\n         Attributes and Keywords\n         Attribute Descriptions
      and interpretations\n   Service Types not registered with IANA will use their
      own Naming\n   Authority string.  The registration process for new Service Types
      is\n   defined in [13].\n   Services which advertise a particular Service Type
      must support the\n   complete set of standardized attributes.  They may support
      additional\n   attributes, beyond the standardized set.  Unrecognized attributes\n
      \  MUST be ignored by User Agents.\n   Service Type names which begin with \"x-\"
      are guaranteed not to\n   conflict with any officially registered Service Type
      names.  It is\n   suggested that this prefix be used for experimental or private\n
      \  Service Type names.  Similarly, attribute names which begin with \"x-\"\n
      \  are guaranteed not to be used for any officially registered attribute\n   names.\n
      \  A service of a given Service Type should accept the networking\n   protocol
      which is implied in its definition.  If a Service Type can\n   accept multiple
      protocols, configuration information SHOULD be\n   included in the Service Type
      attribute information.  This\n   configuration information will enable an application
      to use the\n   results of a Service Request and Attribute Request to directly\n
      \  connect to a service.\n   See section 20.2.1 for the format of a Service
      Type String as used in\n   the Service Location Protocol.\n"
    title: 3.3. Standard Attribute Definitions
  - contents:
    - "3.4. Naming Authority\n   The Naming Authority of a service defines the meaning
      of the Service\n   Types and attributes registered with and provided by Service\n
      \  Location.  The Naming Authority itself is a string which uniquely\n   identifies
      an organization.  If no string is provided IANA is the\n   default.  IANA stands
      for the Internet Assigned Numbers Authority.\n   Naming Authorities may define
      Service Types which are experimental,\n   proprietary or for private use.  The
      procedure to use is to create a\n   'unique' Naming Authority string and then
      specify the Standard\n   Attribute Definitions as described above.  This Naming
      Authority will\n   accompany registration and queries, as described in sections
      5 and 9.\n"
    title: 3.4. Naming Authority
  - contents:
    - "3.5. Interpretation of Service Location Replies\n   Replies should be considered
      to be valid at the time of delivery.\n   The service may, however, fail or change
      between the time of the\n   reply and the moment an application seeks to make
      use of the service.\n   The application making use of Service Location MUST
      be prepared for\n   the possibility that the service information provided is
      either stale\n   or incomplete.  In the case where the service information provided\n
      \  does not allow a User Agent to connect to a service as desired, the\n   Service
      Request and/or Attribute Request may be resubmitted.\n   Service specific configuration
      information (such as which protocol to\n   use) should be included as attribute
      information in Service\n   Registrations.  These configuration attributes will
      be used by\n   applications which interpret the Service Location Reply.\n"
    title: 3.5. Interpretation of Service Location Replies
  - contents:
    - "3.6. Use of TCP, UDP and Multicast in Service Location\n   The Service Location
      Protocol requires the implementation of UDP\n   (connectionless) and TCP (connection
      oriented) transport protocols.\n   The latter is used for bulk transfer, only
      when necessary.\n   Connections are always initiated by an agent request or
      registration,\n   not by a replying Directory Agent.  Service Agents and User
      Agents\n   use ephemeral ports for transmitting information to the service\n
      \  location port, which is 427.\n   The Service Location discovery mechanisms
      typically multicast\n   messages to as many enterprise networks as needed to
      establish\n   service availability.  The protocol will operate in a broadcast\n
      \  environment with limitations detailed in section 3.6.1.\n"
    - contents:
      - "3.6.1. Multicast vs.  Broadcast\n   The Service Location Protocol was designed
        for use in networks where\n   DHCP is available, or multicast is supported
        at the network layer.\n   To support this protocol when only network layer
        broadcast is\n   supported, the following procedures may be followed.\n"
      - contents:
        - "3.6.1.1. Single Subnet\n   If a network is not connected to any other networks
          simple network\n   layer broadcasts will work in place of multicast.\n   Service
          Agents SHOULD and Directory Agents MUST listen for broadcast\n   Service
          Location request messages to the Service Location port.  This\n   allows
          UAs which lack multicast capabilities to still make use of\n   Service Location
          on a single subnet.\n"
        title: 3.6.1.1. Single Subnet
      - contents:
        - "3.6.1.2. Multiple Subnets\n   The Directory Agent provides a central clearing
          house of information\n   for User Agents.  If the network is designed so
          that a Directory\n   Agent address is statically configured with each User
          Agent and\n   Service Agent, the Directory Agent will act as a bridge for\n
          \  information that resides on different subnets.  The Directory Agent\n
          \  address can be dynamically configured with Agents using DHCP. The\n   address
          can also be determined by static configuration.\n   As dynamic discovery
          is not feasible in a broadcast environment with\n   multiple subnets and
          manual configuration is difficult, deploying DAs\n   to serve enterprises
          with multiple subnets will require use of\n   multicast discovery with multiple
          hops (i.e., TTL > 1 in the IP\n   header).\n"
        title: 3.6.1.2. Multiple Subnets
      title: 3.6.1. Multicast vs.  Broadcast
    - contents:
      - "3.6.2. Service-Specific Multicast Address\n   This mechanism is used so that
        the number of datagrams any one\n   service agent receives is minimized.  The
        Service Location General\n   Multicast Address MAY be used to query for any
        service, though one\n   SHOULD use the service-specific multicast address
        if it exists.\n   If the site network does not support multicast then the
        query SHOULD\n   be broadcast to the Service Location port.  If, on the other
        hand,\n   the underlying hardware will not support the number of needed\n
        \  multicast addresses the Service Location General Multicast Address\n   MAY
        be used.  Service Agents MUST listen on this multicast address as\n   well
        as the service-specific multicast addresses for the service\n   types they
        advertise.\n   Service-Specific Multicast Addresses are computed by calculating
        a\n   string hash on the Service Type string.  The Service Type string MUST\n
        \  first be converted to an ASCII string from whatever character set it\n
        \  is represented in, so the hash will have well-defined results.\n   The
        string hash function is modified from a code fragment attributed\n   to Chris
        Torek:\n        /*\n         *  SLPhash returns a hash value in the range
        0-1023 for a\n         *  string of single-byte characters, of specified length.\n
        \        */\n        unsigned long SLPhash (const char *pc, unsigned int length)\n
        \           unsigned long h = 0;\n    while (length-- != 0) {\n                h
        *= 33;\n                h += *pc++;\n            }\n            return (0x3FF
        & h);  /* round to a range of 0-1023 */\n        }\n   This value is added
        to the base range of Service Specific Discovery\n   Addresses, to be assigned
        by IANA. These will be 1024 contiguous\n   multicast addresses.\n"
      title: 3.6.2. Service-Specific Multicast Address
    title: 3.6. Use of TCP, UDP and Multicast in Service Location
  - contents:
    - "3.7. Service Location Scaling, and Multicast Operating Modes\n   In a very
      small network, with few nodes, no DA is required.  A user\n   agent can detect
      services by multicasting requests.  Service Agents\n   will then reply to them.
      \ Further, Service Agents which respond to\n   user requests must be used to
      make service information available.\n   This does not scale to environments
      with many hosts and services.\n   When scaling Service Location systems to intermediate
      sized networks,\n   a central repository (Directory Agent) may be added to reduce
      the\n   number of Service Location messages transmitted in the network\n   infrastructure.
      \ Since the central repository can respond to all\n   Service and Attribute
      Requests, fewer Service and Attribute Replies\n   will be needed; for the same
      reason, there is no need to\n   differentiate between Directory Agents.\n   A
      site may also grow to such a size that it is not feasible to\n   maintain only
      one central repository of service information.  In this\n   case more Directory
      Agents are needed.  The services (and service\n   agents) advertised by the
      several Directory Agents are collected\n   together into logical groupings called
      \"Scopes\".\n   All Service Registrations that have a scope must be registered
      with\n   all DAs (within the appropriate multicast radius) of that scope which\n
      \  have been or are subsequently discovered.  Service Registrations\n   which
      have no scope are only registered with unscoped DAs.  User\n   Agents make requests
      of DAs whose scope they are configured to use.\n   Service Agents MUST register
      with unscoped DAs even if they are\n   configured to specifically register with
      DAs which have a specific\n   scope or set of scopes.  User Agents MAY query
      DAs without scopes,\n   even if they are configured to use DAs with a certain
      scope.  This is\n   because any DA with no scope will have all the available
      service\n   information.\n   Scoped user agents SHOULD always use a DA which
      supports their\n   configured scope when possible instead of an unscoped DA.
      This will\n   prevent the unscoped DAs from becoming overused and thus a scaling\n
      \  problem.\n   It is possible to specially configure Service Agents to register
      only\n   with a specific set of DAs (see Section 22.1).  In that case,\n   services
      may not be available to User Agents via all Directory\n   Agents, but some network
      administrators may deem this appropriate.\n   There are thus 3 distinct operating
      modes.  The first requires no\n   administrative intervention.  The second requires
      only that a DA be\n   run.  The last requires that all DAs be configured to
      have scope and\n   that a coherent strategy of assigning scopes to services
      be followed.\n   Users must be instructed which scopes are appropriate for them
      to\n   use.  This administrative effort will allow users and applications to\n
      \  subsequently dynamically discover services without assistance.\n   The first
      mode (no DAs) is intended for a LAN. The second mode (using\n   a DA or DAs,
      but not using scopes) scales well to a group of\n   interconnected LANs with
      a limited number of hosts.  The third mode\n   (with DAs and scopes) allows
      the SLP protocol to be used in an\n   internetworked campus environment.\n   If
      scoped DAs are used, they will not accept unscoped registrations\n   or requests.
      \ UAs which issue unscoped requests will discover only\n   unscoped services.
      \ They SHOULD use a scope in their requests if\n   possible and SHOULD use a
      DA with their scope in preference to an\n   unscoped DA. In a large campus environment
      it would be a bad idea to\n   have ANY unscoped DAs:  They attract ALL registrations
      and will thus\n   present a scaling problem eventually.\n   A subsequent protocol
      document will describe mechanisms for\n   supporting a service discovery protocol
      for the global Internet.\n"
    title: 3.7. Service Location Scaling, and Multicast Operating Modes
  title: 3. Protocol Overview
- contents:
  - "4. Service Location General Message Format\n   The following header is used in
    all of the message descriptions below\n   and is abbreviated by using \"Service
    Location header =\" followed by\n   the function being used.\n      0                   1
    \                  2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
    5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |    Version    |    Function   |            Length             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |O|M|U|A|F| rsvd|    Dialect    |        Language Code          |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |        Char Encoding          |              XID              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \     Version  This protocol document defines version 1 of the Service\n               Location
    protocol.\n      Function Service Location datagrams can be identified as to their\n
    \              operation by the function field.  The following are the\n               defined
    operations:\n               Message Type             Abbreviation     Function
    Value\n               Service Request          SrvReq               1\n               Service
    Reply            SrvRply              2\n               Service Registration     SrvReg
    \              3\n               Service Deregister       SrvDereg             4\n
    \              Service Acknowledge      SrvAck               5\n               Attribute
    Request        AttrRqst             6\n               Attribute Reply          AttrRply
    \            7\n               DA Advertisement         DAAdvert             8\n
    \              Service Type Request     SrvTypeRqst          9\n               Service
    Type Reply       SrvTypeRply          10\n      Length   The number of bytes in
    the message, including the Service\n               Location Header.\n      O        The
    'Overflow' bit.  See Section 18 for the use of this\n               field.\n      M
    \       The 'Monolingual' bit.  Requests with this bit set\n               indicate
    the User Agent will only accept responses in the\n               language (see
    section 17) that is indicated by the\n               Service or Attribute Request.\n
    \     U        The 'URL Authentication Present' bit.  See sections 4.2,\n               4.3,
    9, and 11 for the use of this field.\n      A        The 'Attribute Authentication
    Present' bit.  See\n               sections 4.2, 4.3, and 13 for the use of this
    field.\n      F        If the 'F' bit is set in a Service Acknowledgement, the\n
    \              directory agent has registered the service as a new\n               entry,
    not as an updated entry.\n      rsvd     MUST be zero.\n      Dialect  Dialect
    tags will be used by future versions of the\n               Service Location Protocol
    to indicate a variant of\n               vocabulary used.  This field is reserved
    and MUST be set\n               to 0 for compatibility with future versions of
    the\n               Service Location Protocol.\n      Language Code\n               Strings
    within the remainder of the message which follows\n               are to be interpreted
    in the language encoded (see\n               section 17 and appendix A) in this
    field.\n      Character Encoding\n               The characters making up strings
    within the remainder of\n               the message may be encoded in any standardized
    encoding\n               (see section 17.1).\n      Transaction Identifier (XID)\n
    \              The XID (transaction ID) field allows the requester to\n               match
    replies to individual requests (see section 4.1).\n               Note that, whenever
    there is an Attribute Authentication\n               block, there will also be
    a URL Authentication block.\n               Thus, it is an error to have the 'A'
    bit set without also\n               having the 'U' bit set.\n"
  - contents:
    - "4.1. Use of Transaction IDs (XIDs)\n   Retransmission is used to ensure reliable
      transactions in the Service\n   Location Protocol.  If a User Agent or Service
      Agent sends a message\n   and fails to receive an expected response, the message
      will be sent\n   again.  Retransmission of the same Service Location datagram
      should\n   not contain an updated XID. It is quite possible the original request\n
      \  reached the DA or SA, but reply failed to reach the requester.  Using\n   the
      same XID allows the DA or SA to cache its reply to the original\n   request
      and then send it again, should a duplicate request arrive.\n   This cached information
      should only be held very briefly\n   (CONFIG_INTERVAL_0.)  Any registration
      or deregistration at a\n   Directory Agent, or change of service information
      at a SA should\n   flush this cache so that the information returned to the
      client is\n   always valid.\n   The requester creates the XID from an initial
      random seed and\n   increments it by one for each request it makes.  The XIDs
      will\n   eventually wrap back to zero and continue incrementing from there.\n
      \  Directory Agents use XID values in their DA Advertisements to\n   indicate
      their state (see section 15.2).\n"
    title: 4.1. Use of Transaction IDs (XIDs)
  - contents:
    - "4.2. URL Entries\n   When URLs are registered, they have lifetimes and lengths,
      and may be\n   authenticated.  These values are associated with the URL for
      the\n   duration of the registration.  The association is known as a \"URL-\n
      \  entry\", and has the following format:\n      0                   1                   2
      \                  3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |           Lifetime            |        Length of URL          |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     \\
      \                             URL                              \\\n     |                                                               |\n
      \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
      \             (if present) URL Authentication Block .....\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     Lifetime   The length of time that the registration is valid, in\n               the
      absence of later registrations or deregistration.\n      Length of URL\n               The
      length of the URL, measured in bytes and < 32768.\n      URL Authentication
      Block\n               (if present) A timestamped authenticator (section 4.3)\n
      \  The URL conforms to RFC 1738 [6].  If the 'U' bit is set in the\n   message
      header, the URL is followed by an URL Authentication Block.\n   If the scheme
      used in the URL does not have a standardized\n   representation, the minimal
      requirement is:\n      service:<srvtype>://<addr-spec>\n   \"service\" is the
      URL scheme of all Service Location Information\n   included in service registrations
      and service replies.  Each URL\n   entry contains the service:<srvtype> scheme
      name.  It may also\n   include an <addr-spec> except in the case of a reply
      to a Service\n   Type request (see section 7).\n"
    title: 4.2. URL Entries
  - contents:
    - "4.3. Authentication Blocks\n   Authentication blocks are used to authenticate
      service registrations\n   and deregistrations.  URLs are registered along with
      an URL\n   Authentication block to retain the authentication information in
      the\n   URL entry for subsequent use by User Agents who receive a Service\n
      \  Reply containing the URL entry.  Service attributes are registered\n   along
      with an Attribute Authentication block.  Both authentication\n   blocks have
      the format illustrated below.\n   If a service registration is accompanied by
      authentication which can\n   be validated by the DA, the DA MUST validate any
      subsequent service\n   deregistrations, so that unauthorized entities cannot
      invalidate such\n   registered services.  Likewise, if a service registration
      is\n   accompanied by an Attribute Authentication block which can be\n   validated
      by the DA, the DA MUST validate any subsequent attribute\n   registrations,
      so that unauthorized entities cannot invalidate such\n   registered attributes.\n
      \  To avoid replay attacks which use previously validated\n   deregistrations,
      the deregistration or attribute registration message\n   must contain a timestamp
      for use by the DA. To avoid replay attacks\n   which use previously validated
      registrations to nullify a valid\n   deregistration, registrations must also
      contain a timestamp.\n   An authentication block has the following format:\n
      \     0                   1                   2                   3\n      0
      1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                                                               |\n     +
      \                          Timestamp                           +\n     |                                                               |\n
      \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
      \ Block Structure Descriptor   |            Length             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |            Structured Authenticator ...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     Timestamp A 64-bit value formatted as specified by the Network\n               Time
      Protocol (NTP) [16].\n      Block Structure Descriptor (BSD)\n               A
      value describing the structure of the Authenticator.\n               The only
      value currently defined is 1, for\n               Object-Identifier.\n      Length
      \  The length of the Authenticator\n      Structured Authenticator\n               An
      algorithm specification, and the authentication data\n               produced
      by the algorithm.\n   The Structured Authenticator contains a digital signature
      of the\n   information being authenticated.  It contains sufficient information\n
      \  to determine the algorithm to be used and the keys to be selected to\n   verify
      the digital signature.\n   The digital signature is computed over the following
      ordered stream\n   of data:\n       CHARACTER ENCODING OF URL   (2 bytes in
      network byte order)\n       LIFETIME                    (2 bytes in network
      byte order)\n       LENGTH OF URL               (2 bytes in network byte order)\n
      \      URL                         (n bytes)\n       TIMESTAMP                   (8
      bytes in SNTP format [16])\n   When producing a URL Authentication block, the
      authentication data\n   produced by the algorithm identified within the Structured\n
      \  Authenticator calculated over the following ordered stream of data:\n       ATTRIBUTE
      CHARACTER ENCODING   (2 bytes in network byte order)\n       LENGTH OF ATTRIBUTES
      \          (2 bytes in network byte order)\n       ATTRIBUTES                     (n
      bytes)\n       TIMESTAMP                      (8 bytes in SNTP format [16])\n
      \  Every Service Location Protocol entity (User Agent, Service Agent, or\n   Directory
      Agent) which is configured for use with protected scopes\n   SHOULD implement
      \"md5WithRSAEncryption\" [4] and be able to associate\n   it with BSD value
      == 1.\n   In the case where BSD value == 1 and the OID \"md5WithRSAEncryption\"\n
      \  is selected, the Structured Authenticator will start with the ASN.1\n   Distinguished
      Encoding (DER) [9] for \"md5WithRSAEncryption\", which\n   has the as its value
      the bytes (MSB first in hex):\n      \"30 0d 06 09 2a 86 48 86 f7 0d 01 01 04
      05 00\"\n   This is then immediately followed by an ASN.1 Distinguished Encoding\n
      \  (as a \"Bitstring\") of the RSA encryption (using the Scope's private\n   key)
      of a bitstring consisting of the OID for \"MD5\" concatenated by\n   the MD5
      [22] message digest computed over the fields above.  The\n   exact construction
      of the MD5 OID and digest can be found in RFC 1423\n   [4].\n"
    title: 4.3. Authentication Blocks
  - contents:
    - "4.4. URL Entry Lifetime\n   The Lifetime field is set to the number of seconds
      the reply can be\n   cached by any agent.  A value of 0 means the information
      must not be\n   cached.  User Agents MAY cache service information, but if they
      do,\n   they must provide a way for applications to flush this cached\n   information
      and issue the request directly onto the network.\n   Services should be registered
      with DAs with a Lifetime, the suggested\n   value being CONFIG_INTERVAL_1.  The
      service must be reregistered\n   before this interval elapses, or the service
      advertisement will no\n   longer be available.  Thus, services which vanish
      and fail to\n   deregister eventually become automatically deregistered.\n"
    title: 4.4. URL Entry Lifetime
  title: 4. Service Location General Message Format
- contents:
  - "5. Service Request Message Format\n   The Service Request is used to obtain URLs
    from a Directory Agent or\n   Service Agents.\n   The format of the Service Request
    is as follows:\n      0                   1                   2                   3\n
    \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |         Service Location header (function = SrvReq)           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |length of prev resp list string|<Previous Responders Addr Spec>|\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |                                                               |\n     \\
    \                 <Previous Responders Addr Spec>              \\\n     |                                                               |\n
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
    \ length of predicate string   |  Service Request <predicate>  |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |                                                               |\n     \\
    \              Service Request <predicate>, contd.             \\\n     |                                                               |\n
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   If
    a UA issues a request which will result in a reply which is too\n   large, the
    SA or DA will return an abbreviated response (in a\n   datagram the size of the
    site's MTU) which has the 'Overflow' bit\n   flag set.  The UA must then issue
    the request again using TCP.\n   The <Previous Responders Addr Spec> is described
    in sections 7 and\n   20.1.\n   After a User Agent restarts (say, after rebooting
    of a system,\n   loading of the network kernel), Service Requests should be delayed\n
    \  for some random time uniformly distributed within a one second\n   interval
    centered about a configured delay value (by default,\n   CONFIG_INTERVAL_4).\n
    \  The Service Request allows the User Agent to specify the Service Type\n   of
    the service and a Predicate in a specific language.  The general\n   form of a
    Service Request is shown below:\n      <srvtype>[.<na>]/[<scope>]/[<where>]/\n
    \  The punctuation is necessary even where the fields are omitted.\n    -  The
    <srvtype> refers to the Service Type.  For each type of\n       service available,
    there is a unique Service type name string.\n       See section 20.2.1.\n    -
    \ The <na> is the Naming Authority.  This string determines the\n       semantic
    interpretation of the attribute information in the\n       <where> part of the
    Service Request.\n    -  The <scope> is a string used to restrict the range of
    the query.\n       Scope is determined administratively, at a given site.  It
    is not\n       necessarily related to network topology (see Section 16).\n       Leaving
    this field out means that the request can be satisfied\n       only by unscoped
    service advertisements.\n    -  The <where> string is the Where Clause of the
    request.  It\n       contains a query which allows the selection of those service\n
    \      instances which the User Agent is interested in.  The query\n       includes
    attributes, boolean operators and relations.  (See\n       section 5.3.)\n   In
    the case of a multicast service request, a list of previous\n   responders is
    sent.  This list will prevent those in the list from\n   responding, to be sure
    that responses from other sources are not\n   drowned out.  The request is multicast
    repeatedly (with a recommended\n   wait interval of CONFIG_INTERVAL_2) until there
    are no new responses,\n   or a certain time (CONFIG_INTERVAL_3) has elapsed.  Different
    timing\n   values are applied to a Service Request used for Directory Agent\n
    \  Discovery, see Section 5.2.\n   In order for a request to succeed in matching
    registered information,\n   the following conditions must be met:\n    1. The
    result must have the same Service Type as the request.\n    2. It must have the
    same Naming Authority.\n    3. It must have the same scope.  (If the scope of
    the request\n       as omitted, the request will only match services which were\n
    \      registered with no scope.  Note that a scoped request WILL match\n       all
    unscoped Services).\n    4. The conditions specified in the Where Clause must
    match the\n       attributes and keywords registered for the service.\n"
  - contents:
    - "5.1. Service Request Usage\n   The User Agent may form Service Requests using
      preconfigured\n   knowledge of a Service Type's attributes.  It may also issue\n
      \  Attribute Requests to obtain the attribute values for a Service Type\n   before
      issuing Service Requests (see Section 13).  Having obtained\n   the attributes
      which describe a particular kind of service from an\n   Attribute Request, or
      using configured knowledge of a service's\n   attributes, the User Agent can
      build a predicate that describes the\n   service needs of the user.\n   Service
      Requests may be sent directly to a Directory Agent.  Suppose\n   a printer supporting
      the lpr protocol is needed on the 12th floor\n   which has UNRESTRICTED_ACCESS
      and prints 12 pages per minute.\n   Suppose further that a Attribute Request
      indicates that there is a\n   printer on the 12th floor, a printer that prints
      12 pages per minute,\n   and a printer that offers UNRESTRICTED_ACCESS. To check
      whether they\n   are same printer, issue the following request:\n      lpr//(&
      (PAGES PER MINUTE==12)\n               (UNRESTRICTED_ACCESS)\n               (LOCATION==12th
      FLOOR))/\n   Suppose there is no such printer.  The Directory Agent responds
      with\n   a Service Reply with 0 in the number of responses and no reply\n   values.\n
      \  The User Agent then tries a less restrictive query to find a printer,\n   using
      the 12th floor as \"where\" criteria.\n      lpr//(LOCATION==12th FLOOR)/\n
      \  In this case, there is now only one reply:\n      Returned URL:   service:lpr://igore.wco.ftp.com:515/draft\n
      \  The Address Specification for the printer is:  igore.wco.ftp.com:515,\n   containing
      the name of the host managing the requested printer.\n   Files would be printed
      by spooling to that port on that host.  The\n   word 'draft' refers to the name
      of the print queue the lpr server\n   supports.\n   In the absence of a Directory
      Agent, the request above could be\n   multicast.  In this case it would be sent
      to the Service Specific\n   Multicast Address for \"service:printer\" and not
      to the Directory\n   Agent.  Service Agents that can satisfy the predicate will
      reply.\n   Service Agents which cannot support the character set of the request\n
      \  MUST return CHARSET_NOT_UNDERSTOOD in the SrvRply.  In all other\n   circumstances,
      Service Agents which cannot satisfy the reply do not\n   send any reply at all.\n
      \  The only way a User Agent can be sure there are no services which\n   match
      the query is by retrying the request (CONFIG_INTERVAL_8).  If\n   no response
      comes, the User Agent gives up and assumes there are no\n   such printers.\n
      \  Another form of query is a simpler 'join' query.  Its syntax has no\n   parentheses
      or logical operators.  Each term is conjoined (AND-ed\n   together.)  Rewriting
      the initial query provides an example:\n      lpr//PAGES PER MINUTE==12,\n           UNRESTRICTED_ACCESS,\n
      \          LOCATION==12th FLOOR/\n"
    title: 5.1. Service Request Usage
  - contents:
    - "5.2. Directory Agent Discovery Request\n   Normally a Service Request returns
      a Service Reply.  The sole\n   exception to this is a Service Request for the
      Service Type\n   \"directory-agent\".  This Service Request is answered with
      a DA\n   Advertisement.\n   Without configured knowledge of a Directory Agent
      (DA), a User Agent\n   or Service Agent uses a Service Request to discover a
      DA. (See\n   section 15.1 for mechanisms by which a client may be configured
      to\n   have knowledge of a DA.) Such a Service Request used for Directory\n
      \  Agent Discovery includes a predicate of the form:\n      directory-agent///\n
      \  This query is always sent to the Directory Agent Discovery multicast\n   address.
      \ The Service Type of a Directory Agent is \"directory-agent\",\n   hence it
      is the Service Type used in the request.  No scope is\n   included in the request,
      so all Directory Agents will reply.  This is\n   the only request which omits
      a scope which all Directory Agents MUST\n   respond to.  Normally, a Directory
      Agent with a scope ONLY responds\n   to requests with that scope.  No Naming
      Authority is included, so\n   \"IANA\" is assumed.  We want to reach all the
      available directory\n   agents.  If the scope were supplied, only DAs supporting
      that scope\n   would reply.\n   DA Advertisement Replies may arrive from different
      sources, similar\n   in form to:\n     URL returned:   service:directory-agent://slp-resolver.catch22.com\n
      \    Scope returned: ACCOUNTING\n     URL returned:   service:directory-agent://204.182.15.66
      Scope\n     returned: JANITORIAL SERVICES\n   The DA Advertisement format is
      defined in Section 14.\n   If the goal is merely to discover any Directory Agent,
      the first\n   reply will do.  If the goal, however, is to discover all reachable\n
      \  DAs, the request must be retransmitted after an interval (the\n   recommended
      time is CONFIG_INTERVAL_5).  This retransmitted request\n   will include a list
      of DAs which have already responded.  See\n   sections 7 and 20.1.  Directory
      Agents which receive the request will\n   only respond if they are not on this
      list.  After there are no new\n   replies, all DAs are presumed to have been
      discovered.\n   If a DA fails to respond after CONFIG_INTERVAL_6 seconds, the
      UA or\n   Service Agent should use a different DA. DA addresses may be cached\n
      \  from previous discovery attempts, preconfigured, or by use of DHCP\n   (see
      section 15.2).  If no such DA responds, DA discovery should be\n   used to find
      a new DA. Only after CONFIG_INTERVAL_7 seconds should it\n   be assumed that
      no DA exists and multicast based Service Requests\n   should be used.\n"
    title: 5.2. Directory Agent Discovery Request
  - contents:
    - "5.3. Explanation of Terms of Predicate Grammar\n   A predicate has a simple
      structure, which depends on parentheses,\n   commas and slashes to delimit the
      elements.  Examples of proper usage\n   are given throughout this document.
      \ The terms used in the grammar\n   are as follows:\n      predicate:\n         Placed
      in a Service Request, this is interpreted by a Service\n         Agent or Directory
      Agent to determine what information to\n         return.\n      scope:\n         If
      this is absent in a Service Request, the request will match\n         only services
      registered without a scope.  If it is present,\n         only services registered
      under that scope or are unscoped will\n         match the request.\n      where-clause:\n
      \        This determines which services the request matches.  An empty\n         where-clause
      will match all services.  The request will be\n         limited to services
      which have the specified Service Type, so\n         the where-clause is not
      the sole factor in picking out which\n         services match the request.\n
      \     where-list:\n         The where-list is a logical expression.  It can
      be a single\n         expression, a disjunction or a conjunction.  A single\n
      \        expression must apply for the where-clause to match.  A\n         disjunction
      matches if any expression in the OR list matches.\n         A conjunction matches
      only if all elements in the AND list\n         match.\n         Note that there
      is no logical negation operator:  This is\n         because there is no notion
      of returning \"everything except\"\n         what matches a given criteria.\n
      \        A where-list can be nested and complex.  For example, the\n         following
      requires that three subexpressions must all be true:\n                (& (|
      <query-item> <query-item>)\n                   <query-item>\n                   (&
      <query-item> <query-item> <query-item>)\n                )\n         Notice
      that white space, tabs or carriage returns can be added\n         anywhere outside
      query-items.  Each list has 2 or more items in\n         it, and lists can be
      nested.  Services which fulfill the entire\n         logical expression match
      the where-clause.\n         degenerate expressions but they should be tolerated.
      \ They are\n         equivalent to <query-item>.\n      query-item:\n         A
      query item has the form:\n               '(' <attr-tag> <comp-op> <attr-val>
      ')'\n         or\n               '(' <keyword> ')'\n         Examples of this
      would be:\n            (SOME ATTRIBUTE == SOME VALUE)\n            (RESERVED)\n
      \           (QUEUE LENGTH <= 234)\n      query-join:\n         The query-join
      is a comma delimited list of conditions which\n         the service must satisfy
      in order to match the query.  The\n         items are considered to be logically
      conjoined.  Thus the\n         query-join:\n               ATTR1=VALUE1, KEYWORD1,
      KEYWORD2, ATTR2>=34\n         is equivalent to the where-list:\n               (&
      (ATTR1=VALUE1) (KEYWORD1) (KEYWORD2) (ATTR2>=34))\n         The query-join cannot
      be mixed with a where-list.  It is\n         provided as a convenient mechanism
      to provide a statement of\n         necessary conditions without building a
      logical expression.\n"
    title: 5.3. Explanation of Terms of Predicate Grammar
  - contents:
    - "5.4. Service Request Predicate Grammar\n   Service Requests can precisely describe
      the services they need by\n   including a Predicate the body of the Request.
      \ This Predicate must\n   be constructed according to the grammar below.\n   <predicate>
      \ ::= <srvtype>['.'<na>]'/'<scope>'/'<where>'/'\n   <srvtype>    ::= string
      representing type of service.  Only\n                    alphanumeric characters,
      '+', and '-' are allowed.\n   <na>         ::= string representing the Naming
      Authority.\n                    Only alphanumeric characters, '+',\n                    and
      '-' are allowed.  If this field is\n                    omitted then \"IANA\"
      is assumed.\n   <scope>      ::= string representing the directory agent scope.\n
      \                   '/', ',' (comma) and ':'  are not allowed in\n                    this
      string.  The scopes \"LOCAL\" and \"REMOTE\"\n                    are reserved.\n
      \  <attr-tag>   ::= class name of an attribute of a given Service\n                    Type.
      \ This tag cannot include the following\n                     characters:  '(',
      ')', ',', '=', '!', '>',\n                     '<', '/', '*', except where escaped
      (see 17.1.)\n   <keyword>    ::= a class name of an attribute which will have\n
      \                   no values.  This string has the same limits\n                    as
      the <attr-tag>, except that white space\n                    internal to the
      keyword is illegal.\n   <where>      ::= <where-any> |\n                    <where-list>
      |\n                    <query-join>\n   <where-any>  ::=\n                    That
      is NOTHING, or white space.\n   <where-list> ::= '(' '&' <where-list> <query-list>
      ')' |\n                    '(' '|' <where-list> <query-list> ')' |\n                    '('
      <keyword> ')'\n                    '(' <attr-tag> <comp-op> <attr-val> ')'\n
      \  <query-list> ::= <where-list> |\n                    <where-list> <query-list>\n
      \  <query-join> ::= <keyword> |\n                    <join-item> |\n                    <query-join>
      ',' <keyword> |\n                    <query-join> ',' <join-item>\n   <join-item>
      \ ::= <attr-tag> <comp-op> <attr-val>\n   <comp-op>    ::= \"!=\" | \"==\" |
      '<' | \"<=\" | '>' | \">=\"\n   <attr-val>   ::= any string (see Section 20.5
      for the ways\n                    in which attr-vals are interpreted.)\n                    Value
      strings may not contain '/', ','\n                    '=', '<', '>', or '*'
      except where escaped\n                    (see 17.1.).\n                    '('
      and ')' may be used in attribute values\n                     for the purpose
      of encoding a binary values.\n                     Binary encodings (See 20.5)
      may\n                     include the above reserved characters.\n"
    title: 5.4. Service Request Predicate Grammar
  - contents:
    - "5.5. String Matching for Requests\n   All strings are case insensitive, with
      respect to string matching on\n   queries.  All preceding or trailing blanks
      should not be considered\n   for a match, but blanks internal to a string are
      relevant.\n   For example, \"  Some String  \" matches \"SOME STRING\", but
      not \"some\n   string\".\n   String matching may only be performed over the
      same character sets.\n   If a request cannot be satisfied due to a lack of support
      for the\n   character set of the request a CHARSET_NOT_UNDERSTOOD error is\n
      \  returned.\n   String comparisons (using comparison operators such as '<'
      or\n   registration, not using any language specific rules.  The ordering is\n
      \  strictly by the character value, i.e.  \"0\" < \"A\" is true when the\n   character
      set is US-ASCII, since \"0\" has the value of 48 and \"A\" has\n   the value
      65.\n   The special character '*' may precede or follow a string in order to\n
      \  allow substring matching.  If the '*' precedes a string, it matches\n   any
      attribute value which ends with the string.  If the string ends\n   with a '*',
      it matches any attribute value which begins with the\n   string.  Finally, if
      a string begins and ends with a '*', the string\n   will match any attribute
      value which contains the string.\n   Examples:\n        \"bob*\" matches \"bob\",
      \"bobcat\", and \"bob and sue\" \"*bob\" matches\n        \"bob\", \"bigbob\",
      and \"sue and bob\" \"*bob*\" matches \"bob\",\n        \"bobcat\", \"bigbob\",
      and \"a bob I know\"\n   String matching is done after escape sequences have
      been substituted.\n   See sections 17, 5.3, 17.1.\n"
    title: 5.5. String Matching for Requests
  title: 5. Service Request Message Format
- contents:
  - "6. Service Reply Message Format\n   The format of the Service Reply Message is:\n
    \     0                   1                   2                   3\n      0 1
    2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |          Service Location header (function = SrvRply)         |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |         Error Code            |         URL Entry count       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |                         <URL Entry 1> ...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |                              .                                |\n     \\
    \                             .                                \\\n     |                              .
    \                               |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |                         <URL Entry N> ...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  Each Service Reply message is composed of a list of URL Entries.\n   The Error
    Code may have one of the following values:\n      0        Success\n      LANGUAGE_NOT_SUPPORTED\n
    \              A SA or DA returns this when a request is received from a\n               UA
    which is in a language for which there is no\n               registered Service
    Information and the request arrived\n               with the Monolingual bit set.
    \ See Section 17.\n      PROTOCOL_PARSE_ERROR\n               A SA or DA returns
    this error when a SrvRply is received\n               which cannot be parsed or
    the declared string lengths\n               overrun the message.\n      SCOPE_NOT_SUPPORTED\n
    \              A DA will return this error if it receives a request\n               which
    has a scope not supported by the DA. An SA will not\n               return this
    error; it will simply not reply to the\n               multicast request.\n      CHARSET_NOT_UNDERSTOOD\n
    \              If the DA or SA receives a request or registration in a\n               character
    set which it does not support, it will return\n               this error.\n   Each
    <URL Entry> in the list has the form defined in Section 4.2.\n   The URL entries
    in the reply have no delimiters between them, other\n   than the length fields.
    \ The URL length fields indicate where the URL\n   strings end.  If the presence
    of an URL Authenticator block is\n   signalled by the 'U' bit, the length of the
    authenticator block is\n   determined by information within the block as discussed
    in section\n   4.3.  A User Agent MAY use the authentication block to determine\n
    \  whether the Service Agent advertising the URL is, in fact, authorized\n   to
    offer the indicated service.  If, in a list of URL entries, some\n   of the URLs
    indicate services which are in protected scopes (see\n   section 16.1) while other
    URLs in the list indicate services which\n   are not in protected scopes, the
    latter must still have\n   Authentication Blocks, but the length of the authentcitor
    is shown as\n   zero, and no authentication need be done.\n"
  title: 6. Service Reply Message Format
- contents:
  - "7. Service Type Request Message Format\n   The Service Type Request is used to
    determine all the types of\n   services supported on a network.\n   The request
    should be sent directly to a DA (though it may also be\n   sent to the Service
    Location General Multicast Address), in order to\n   find out all services available
    on the site network (which are\n   advertised by Directory Agents and Service
    Agents.)  If no DA is\n   available, a User Agent MAY issue more than one request
    to insure\n   that all replies have been received.  In each subsequent request,
    a\n   User Agent includes those Service Types that it is aware of.  When no\n
    \  new replies arrive within CONFIG_INTERVAL_3 from a request, the User\n   Agent
    can presume that it has acquired a complete set of available\n   Service Types.\n
    \  The format of a Service Type Request is:\n      0                   1                   2
    \                  3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
    5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |        Service Location header (function = SrvTypeRqst)       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |  length of prev resp string   |<Previous Responders Addr Spec>|\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |                                                               |\n     \\
    \                 <Previous Responders Addr Spec>              \\\n     |                                                               |\n
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
    \  length of naming authority  |   <Naming Authority String>   |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |                                                               |\n     \\
    \           <Naming Authority String>, continued               \\\n     |                                                               |\n
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
    \    length of Scope String    |         <Scope String>        |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |                                                               |\n     \\
    \                  <Scope String>, continued                   \\\n     |                                                               |\n
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Note
    that the <Previous Responders Addr Spec> is a comma delimited\n   list.  (See
    section 20.1.)  The 'length of prev responder list' field\n   indicates the length
    of the comma delimited list string.  A previous\n   responder list with 3 elements
    takes this form:\n         <addr-spec>,<addr-spec>,<addr-spec>\n   The Naming
    Authority, if included, will limit the replies to Service\n   Type Requests to
    Service Types which have the specified Naming\n   Authority.  If this field is
    omitted (i.e., the length field is\n   zero), the default Naming Authority (\"IANA\")
    is assumed.  If the\n   length field is -1, service types from all naming authorities
    are\n   requested.\n   The Scope String Field, if included, will limit replies
    to Service\n   Types which have the specified scope or are unscoped.  If this
    field\n   is omitted, all Service Types (from the specified Naming Authority)\n
    \  are returned.\n"
  title: 7. Service Type Request Message Format
- contents:
  - "8. Service Type Reply Message Format\n   The Service Type Reply has the following
    format:\n      0                   1                   2                   3\n
    \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |        Service Location header (function = SrvTypeRply)       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |          Error Code           |    number of service types    |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |                                                               |\n     \\
    \                    <Service Type Item 1>                     \\\n     |                                                               |\n
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
    \                            . . .                             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |                                                               |\n     \\
    \                    <Service Type Item N>                     \\\n     |                                                               |\n
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   The
    format of a Service Type Item is as follows:\n      0                   1                   2
    \                  3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
    5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    | length of Service Type String |     <Service Type String>     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |                                                               |\n     \\
    \                <Service Type String>, continued              \\\n     |                                                               |\n
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   The
    Error Code may have one of the following values:\n      0        Success\n      PROTOCOL_PARSE_ERROR\n
    \              A SA or DA returns this error when a SrvTypeRqst is\n               received
    which cannot be parsed.\n      SCOPE_NOT_SUPPORTED\n               A DA which
    is configured to have a scope will return this\n               error if it receives
    a SrvTypeRqst which is set to have a\n               scope which it does not support.
    \ An SA will not return\n               this error, it will simply silently discard
    the multicast\n               request.\n      CHARSET_NOT_UNDERSTOOD\n               If
    the DA receives a SrvTypeRqst in a character set which\n               it does
    not support, it MUST use this error.\n   The service type's name is provided in
    the <Service Type String>.  If\n   the service type has a naming authority other
    than \"IANA\" it should\n   be returned following the service type string and
    a \".\" character.\n   See section 20.2.1 for the formal definition of this field.
    \ User\n   Agents calculate Service Specific Multicast addresses based on a hash\n
    \  of the Service Type (see Section 3.6.2).  This multicast address may\n   then
    be used for issuing Service and Attribute Requests directly to\n   SAs.\n   The
    following are examples of Service Type Strings which might be\n   found in Service
    Type Replies:\n         service:lpr://\n         service:http://\n         service:nfs://\n"
  title: 8. Service Type Reply Message Format
- contents:
  - "9. Service Registration Message Format\n   After a Service Agent has found a
    Directory Agent, it begins to\n   register its advertised services one at a time.
    \ A Service Agent must\n   wait for some random time uniformly distributed within
    the range\n   specified by CONFIG_INTERVAL_11 before registering again.\n   Registration
    is done using the Service Registration message\n   specifying all attributes for
    a service.  If the service registration\n   in a protected scope 16.1, then the
    service MUST include both a URL\n   Authentication block and an Attribute Authentication
    block (see\n   section 4.3).  In that case, the service agent MUST set both the
    'U'\n   bit and the 'A' bit (see section 4).\n   A Directory Agent must acknowledge
    each service registration request.\n   If authentication blocks are included,
    the Directory Agent MUST\n   verify the authentication before registering the
    service.  This\n   requires obtaining key information, either by preconfiguration,\n
    \  maintenance of a security association with the service agent, or\n   acquiring
    the appropriate certificate.\n   The format of a Service Registration is:\n      0
    \                  1                   2                   3\n      0 1 2 3 4
    5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |           Service Location header (function = SrvReg)         |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |                                                               |\n     \\
    \                         <URL-Entry>                          \\\n     |                                                               |\n
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
    \ Length of Attr List String   |          <attr-list>          |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |                                                               |\n     \\
    \                   <attr-list>, Continued.                    \\\n     |                                                               |\n
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
    \   (if present) Attribute Authentication Block ...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  The <URL-Entry> is defined at the end of Section 4.2.  The <attr-\n   list>
    is defined in Section 20.3.  The Attribute Authentication\n   Block, which is
    only present if the 'A' bit is set in the message\n   header, is defined in section
    4.3.\n   Service registration may use a connectionless protocol (e.g.  UDP),\n
    \  or a connection oriented protocol (e.g.  TCP). If the registration\n   operation
    may contain more information than can be sent in one\n   datagram, the Service
    Agent MUST use a connection oriented protocol\n   to register itself with the
    DA. When a Service Agent registers the\n   same attribute class more than once
    for a service instance, the\n   Directory Agent overwrites the all the values
    associated with that\n   attribute class for that service instance.  Separate
    registrations\n   must be made for each language that the service is to be advertised\n
    \  in.\n   If a SA attempts to register a service with a DA and the registration\n
    \  is larger than the site path MTU, then the DA will reply with a\n   SrvAck,
    with the error set to INVALID_REGISTRATION and the 'Overflow'\n   byte set.\n
    \  An example of Service Registration information is:\n      Lifetime (seconds):
    \  16-bit unsigned integer\n      URL (at least):       service:<srvtype>://<addr-spec>\n
    \     Attributes (if any):  (ATTR1=VALUE),KEYWORD,(ATTR2 = VAL1, VAL2)\n   In
    order to offer continuously advertised services, Service Agents\n   should start
    the reregistration process before the Lifetime they used\n   in the registration
    expires.\n   An example of a service registration (valid for 3 hours) is as\n
    \  follows:\n      Lifetime:   10800\n      URL:        service:lpr://igore.wco.ftp.com:515/draft\n
    \     Attributes: (SCOPE=DEVELOPMENT),\n                  (PAPER COLOR=WHITE),\n
    \                 (PAPER SIZE=LETTER),\n                  UNRESTRICTED_ACCESS,\n
    \                 (LANGUAGE=POSTSCRIPT, HPGCL),\n                  (LOCATION=12
    FLOOR)\n   The same registration could be done again, as shown below, in German;\n
    \  however, note that \"lpr\", \"service\", and \"SCOPE\" are reserved terms\n
    \  and will remain in the language they were originally registered\n   (English).\n
    \     Lifetime:   10800\n      URL:        service:lpr://igore.wco.ftp.com:515/draft\n
    \     Attributes: (SCOPE=ENTWICKLUNG),\n                  (PAPIERFARBE=WEISS),\n
    \                 (PAPIERFORMAT=BRIEF),\n                  UNBEGRENTZTER_ZUGANG,\n
    \                 (DRUECKERSPRACHE=POSTSCRIPT,HPGCL),\n                  (STANDORT=11
    ETAGE)\n   Scoped registrations must contain the SCOPE attribute.  Unscoped\n
    \  registrations must be registered with all unscoped Directory Agents.\n   Registrations
    of a previously registered service are considered an\n   update.  If such an attribute
    registration is performed in a\n   protected scope (see section 16.1), a new Attribute
    Authentication\n   block must also be included, and the 'A' bit set in the registration\n
    \  message header.\n   The new registration's attributes replace the previous\n
    \  registration's, but do not effect attributes which were included\n   previously
    and are not present in the update.\n   For example, suppose service:x://a.org
    has been registered with\n   attributes A=1, B=2, C=3.  If a new registration
    comes for\n   service:x://a.org with attributes C=30, D=40, then the attributes
    for\n   the service after the update are A=1, B=2, C=30, D=40.\n   In the example
    above, the SCOPE is set to DEVELOPMENT (in English)\n   and ENTWICKLUNG (in German).
    \ Recall that all strings in a message\n   must be in one language, which is specified
    in the header.  The\n   string SCOPE is *not* translated, as it is one of the
    reserved\n   strings in the Service Location Protocol (see section 17.2.)\n   The
    Directory Agent may return a server error in the acknowledgment.\n   This error
    is carried in the Error Codes field of the service\n   location message header.
    \ A Directory Agent MUST decline to register\n   a service if it is specified
    with an unsupported scope.  In this case\n   a SCOPE_NOT_SUPPORTED error is returned
    in the SrvAck.  A Directory\n   Agent MUST NOT accept Service Registrations which
    have an unsupported\n   scope unless it is an unscoped Directory Agent, in which
    case it MUST\n   accept all Service Registrations.\n   An unscoped Service Registration
    will match all requests.  A request\n   which specifies a certain scope will therefore
    return services which\n   have that scope and services which are unscoped.  It
    is strongly\n   suggested that one should use scopes in all registrations or none.\n
    \  See Sections 16 and 3.7 for details.\n   When the URL entry accompanying a
    registration also contains an\n   authentication block (section 4.3), the DA MUST
    perform the indicated\n   authentication, and subsequently indicate the results
    in the Service\n   Acknowledgement message.\n"
  title: 9. Service Registration Message Format
- contents:
  - "10. Service Acknowledgement Message Format\n   A Service Acknowledgement is sent
    as the result of a DA receiving and\n   processing a Service Registration or Service
    Deregistration.  An\n   acknowledgment indicating success must have the error
    code set to\n   zero.  Once a DA acknowledges a service registration it makes
    the\n   information available to clients.\n      0                   1                   2
    \                  3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
    5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |            Service Location header (function = SrvAck)        |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |          Error Code           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  The Error Code may have one of the following values:\n      0        Success\n
    \     PROTOCOL_PARSE_ERROR\n               A DA returns this error when the SrvReg
    or SrvDereg is\n               received which cannot be parsed or the declared
    string\n               lengths overrun the message.\n      INVALID_REGISTRATION\n
    \              A DA returns this error when a SrvReg or SrvDeReg is\n               invalid.
    \ For instance, an invalid URL, unknown or\n               malformed attributes,
    or deregistering an unregistered\n               service all cause this error
    to be reported.\n      SCOPE_NOT_SUPPORTED\n               A DA which is configured
    to have a scope will return this\n               error if it receives a SrvReq
    which is set to have a\n               scope which it does not support.\n      CHARSET_NOT_UNDERSTOOD\n
    \              If the DA receives a SrvReg or SrvDereg in a character\n               set
    which it does not support, it will return this error.\n      AUTHENTICATION_ABSENT\n
    \              If DA has been configured to require an authentication\n               for
    any service registered in the requested scope, and\n               there are no
    authentication blocks in the registration,\n               the DA will return
    this error.\n      AUTHENTICATION_FAILED\n               If the registration contains
    an authentication block\n               which fails to match the correct result
    as calculated\n               (see section 4.3) over the URL or attribute data
    to be\n               authenticated, the DA will return this error.\n   If the
    Directory Agent accpets a Service Registration, and already\n   has an existing
    entry, it updates the existing entry with the new\n   lifetime information and
    possibly new attributes and new attribute\n   values.  Otherwise, if the registration
    is acceptable (including all\n   necessary authentication checks) the Directory
    Agent creates a new\n   entry, and sets the 'F' bit in the Service Acknowledgement
    returned\n   to the Service Agent.\n"
  title: 10. Service Acknowledgement Message Format
- contents:
  - "11. Service Deregister Message Format\n   When a service is no longer available
    for use, the Service Agent must\n   deregister itself from Directory Agents that
    it has been registered\n   with.  A service uses the following PDU to deregister
    itself.\n      0                   1                   2                   3\n
    \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |           Service Location header (function = SrvDereg)       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |         length of URL         |              URL              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |                                                               |\n     \\
    \             URL of Service to Deregister, contd.             \\\n     |                                                               |\n
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
    \            (if present) authentication block .....\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |  length of <tag spec> string  |            <tag spec>         |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |                                                               |\n     \\
    \                    <tag spec>, continued                     \\\n     |                                                               |\n
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   The
    Service Agent should retry this operation if there is no response\n   from the
    Directory Agent.  The Directory Agent acknowledges this\n   operation with a Service
    Acknowledgment message.  Once the Service\n   Agent receives an acknowledgment
    indicating success, it can assume\n   that the service is no longer advertised
    by the Directory Agent.  The\n   Error Code in the Acknowledgment of the Service
    Deregistration may\n   have the same values as described in section 10.\n   The
    Service Deregister Information sent to the directory agent has\n   the following
    form:\n        service:<srvtype>://<addr-spec>\n        Attribute tags (if any):
    \ ATTR1,KEYWORD,ATTR2\n   This will deregister the specified attributes from the
    service\n   information from the directory agent.  If no attribute tags are\n
    \  included, the entire service information is deregistered in every\n   language
    and every scope it was registered in.  To deregister the\n   printer from the
    preceding example, use:\n         service:lpr://igore.wco.ftp.com:515/draft\n
    \  If the service was originally registered with a URL entry containing\n   a
    URL authentication block, then the Service Deregistration message\n   header MUST
    have the 'U' bit set, and the URL entry is then followed\n   by the authentication
    block, with the authenticator calculated over\n   the URL data, the timestamp,
    and the length of the authenticator as\n   explained in section 4.3.  In this
    calculation, the lifetime of the\n   URL data is considered to be zero, no matter
    what the current value\n   for the remaining lifetime of the registered URL.\n"
  title: 11. Service Deregister Message Format
- contents:
  - "12. Attribute Request Message Format\n   The Attribute Request is used to obtain
    attribute information.  The\n   UA supplies a request and the appropriate attribute
    information is\n   returned.\n   If the UA supplies only a Service Type, then
    the reply includes all\n   attributes and all values for that Service Type.  The
    reply includes\n   only those attributes for which services exist and are advertised
    by\n   the DA or SA which received the Attribute Request.  Since different\n   instances
    of a given service can, and very likely will, have\n   different values for the
    attributes defined by the Service Type, the\n   User Agent must form a union of
    all attributes returned by all\n   service Agents.  The Attribute information
    will be used to form\n   Service Requests.\n   If the UA supplies a URL, the reply
    will contain service information\n   corresponding to that URL.\n   Attribute
    Requests include a 'select clause'.  This may be used to\n   limit the amount
    of information returned.  If the select clause is\n   empty, all information is
    returned.  Otherwise, the UA supplies a\n   comma delimited list of attribute
    tags and keywords.  If the\n   attribute or keyword is defined for a service,
    it will be returned in\n   the Attribute Reply, along with all registered values
    for that\n   attribute.  If the attribute selected has not been registered for\n
    \  that URL or Service Type, the attribute or keyword information is\n   simply
    not returned.\n   The Attribute Request message has the following form:\n      0
    \                  1                   2                   3\n      0 1 2 3 4
    5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |         Service Location header (function = AttrRqst)         |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |length of prev resp list string|<Previous Responders Addr Spec>|\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |                                                               |\n     \\
    \        <Previous Responders Addr Spec>, continued            \\\n     |                                                               |\n
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
    \        length of URL         |              URL              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |                                                               |\n     \\
    \                        URL, continued                        \\\n     |                                                               |\n
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
    \       length of <Scope>      |           <Scope>             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |                                                               |\n     \\
    \                     <Scope>, continued                       \\\n     |                                                               |\n
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
    \  length of <select-list>     |        <select-list>          |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |                                                               |\n     \\
    \                  <select-list>, continued                    \\\n     |                                                               |\n
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   The
    <Previous Responder Address List> functions exactly as introduced\n   in Section
    7.  See also Section 20.1.\n   The URL can take two forms:  Either it is simply
    a Service Type, such\n   as \"service:http:\", or it can be a URL, such as\n   \"service:lpr://igore.wco.ftp.com:515/draft\".
    \ In the former case, all\n   attributes and the full range of values for each
    attribute for the\n   Service Type is returned.  In the latter case, only the
    attributes\n   for the service whose URL is defined are returned.\n   The Scope
    String is provided so that Attribute Requests for Service\n   Types can be made
    so that only the Attribute information pertaining\n   to a specific scope will
    be returned.  This field is ignored in the\n   case when a full URL is sent in
    the Attribute Request.  The rules for\n   encoding of the Scope String are given
    in Section 5.4.\n   The select list takes the form:\n    <select-list>  ::= <select-item>
    |\n                       <select-item> ',' <select-list>\n    <select-item>  ::=
    <keyword> | <attr-tag> | <partial-tag> '*'\n    <partial-tag>  ::= the partial
    class name of an attribute\n                       If followed by an '*', it matches
    all class names\n                       which begin with the partial tag.  If
    preceded by\n                       a partial tag.  If both preceded and followed
    by\n                       '*' it matches all class names which contain the\n
    \                      partial tag.\n   For definitions of <attr-tag> and <keyword>
    see 5.4.\n   An example of a select-list following the printer example is:\n   PAGES
    PER MINUTE, UNRESTRICTED_ACCESS, LOCATION\n   If sent to a Directory Agent, the
    number of previous responders is\n   zero and there are no Previous Responder
    Address Specification.\n   These fields are only used for repeated multicasting,
    exactly as for\n   the Service Request.\n"
  title: 12. Attribute Request Message Format
- contents:
  - "13. Attribute Reply Message Format\n   An Attribute Reply Message takes the form:\n
    \     0                   1                   2                   3\n      0 1
    2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |         Service Location header (function = AttrRply)         |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |         Error Code            |  length of <attr-list> string |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |                                                               |\n     \\
    \                         <attr-list>                          \\\n     |                                                               |\n
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   The
    Error Code may have the following values:\n      0        Success\n      LANGUAGE_NOT_SUPPORTED\n
    \              A SA or DA returns this when a request is received from a\n               UA
    which is in a language for which there is no\n               registered Service
    Information and the request arrived\n               with the Monolingual bit set.
    \ See Section 17.\n      PROTOCOL_PARSE_ERROR\n               A DA or SA returns
    this error when a AttrRqst is received\n               which cannot be parsed
    or the declared string lengths\n               overrun the message.\n      SCOPE_NOT_SUPPORTED\n
    \              A DA which is configured to have a scope will return this\n               error
    if it receives an AttrRqst which is set to have a\n               scope which
    it does not support.  SAs will silently\n               discard multicast AttrRqst
    messages for scopes they do\n               not support.\n      CHARSET_NOT_UNDERSTOOD\n
    \              If the DA receives an AttrRqst in a character set which\n               it
    does not support, it will return this error.  SAs will\n               silently
    discard multicast AttrRqst messages which arrive\n               using character
    sets they do not support.\n   The <attr-list> (attribute list) has the same form
    as the attribute\n   list in a Service Registration, see Section 20.3 for a formal\n
    \  definition of this field.\n   An Attribute Request for \"lpr\" might elicit
    the following reply\n   (UNRESTRICTED_ACCESS is a keyword):\n         (PAPER COLOR=WHITE,BLUE),\n
    \        (PAPER SIZE=LEGAL,LETTER,ENVELOPE,TRACTOR FEED),\n         UNRESTRICTED_ACCESS,\n
    \        (PAGES PER MINUTE=1,3,12),\n         (LOCATION=12th, NEAR ARUNA'S OFFICE),\n
    \        (QUEUES=LEGAL,LETTER,ENVELOPE,LETTER HEAD)\n   If the message header
    has the 'A' bit set, the Attribute Reply will\n   have an Attribute Authentication
    block set.  In this case, the\n   Attribute Authenticator must be returned with
    the entire list of\n   attributes, exactly as it was registered by an SA in a
    protected\n   scope.  In this case, the URL was registered in a protected scope
    and\n   the UA included a URL but not a select clause.  If the AttrRqst\n   specifies
    that only certain attributes are to be returned, the DA\n   does not (typically
    cannot) compute a new Authenticator so it simply\n   returns the attributes without
    an authenticator block.\n   A UA which wishes to obtain authenticated attributes
    for a service in\n   a protected scope MUST therefore must include a particular
    URL and no\n   select list with the AttrRqst.\n"
  title: 13. Attribute Reply Message Format
- contents:
  - "14. Directory Agent Advertisement Message Format\n   Directory Agent Advertisement
    Messages have the following format:\n      0                   1                   2
    \                  3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
    5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |          Service Location header (function = DAAdvert)        |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |           Error Code          |         Length of URL         |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |                                                               |\n     \\
    \                             URL                              \\\n     |                                                               |\n
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |
    \    Length of <Scope-list>    |          <Scope-list>         |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |                                                               |\n     \\
    \                   <Scope-list>, continued                    \\\n     |                                                               |\n
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   The
    Error Code is set when a DA Advertisement is returned as the\n   result of a Service
    Request.  It will always be set to 0 in the case\n   of an unsolicited DA Advertisement.
    \ The Error Code may take the\n   values specified in Section 6.\n   The URL corresponds
    to the Directory Agent's location.  The <Scope-\n   list> is a comma delimited
    list of scopes which the DA supports, in\n   the following format:\n         <Scope-list>
    \   ::=    <Scope> | <Scope-list> ',' <Scope>\n         <Scope>         ::=    String
    representing a scope\n   See Section 5.4 for the lexical rules regarding <Scope>.\n
    \  DA Advertisements sent in reply to a Directory Agent Discovery\n   Request
    has the same format as the unsolicited DA Advertisement, for\n   example:\n      URL:
    \       service:directory-agent://SLP-RESOLVER.CATCH22.COM\n      SCOPE List:
    ADMIN\n   The Directory Agent can be reached at the Address Specification\n   returned,
    and supports the SCOPE called \"ADMIN\".\n"
  title: 14. Directory Agent Advertisement Message Format
- contents:
  - '15. Directory Agents

    '
  - contents:
    - "15.1. Introduction\n   A Directory Agent acts on behalf of many Service Agents.
      \ It acquires\n   information from them and acts as a single point of contact
      to supply\n   that information to User Agents.\n   The queries that a User Agent
      multicasts to Service Agents (in an\n   environment without a Directory Agent)
      are the same as queries that\n   the User Agent might unicast to a Directory
      Agent.  A User Agent may\n   cache information about the presence of alternate
      Directory Agents to\n   use in case a selected Directory Agent fails.\n   Aside
      from enhancing the scalability of the protocol (see section\n   3.7), running
      multiple DAs provides robustness of operation.  The DAs\n   may have replicated
      service information which remain accessible even\n   when one of the DAs fail.
      \ Directory Agents, in the future, may use\n   mechanisms outside of this protocol
      to coordinate the maintenance of\n   a distributed database of Service Location
      information, and thus\n   scale to enterprise networks or larger administrative
      domains.\n   Each Service Agent must register with all DAs they are configured
      to\n   use.  UAs may choose among DAs they are configured to use.\n   Locally,
      Directory Agent consistency is guaranteed using mechanisms\n   in the protocol.
      \ There isn't any Directory to Directory Agent\n   protocol yet.  Rather, passive
      detection of DAs by SAs ensures that\n   eventually service information will
      be registered consistently\n   between DAs.  Invalid data will age out of the
      Directory Agents\n   leaving only transient stale registrations even in the
      case of a\n   failure of a Service Agent.\n"
    title: 15.1. Introduction
  - contents:
    - "15.2. Finding Directory Agents\n   A User or Service Agent may be statically
      configured to use a\n   particular DA. This is discouraged unless the application
      resides on\n   a network where any form of multicast or broadcast is impossible.\n
      \  Alternatively, a host which uses DHCP [2, 11] may use it to obtain a\n   Directory
      Agent's address.  DHCP options 78 and 79 have been assigned\n   for this purpose
      [21].\n   The third way to discover DAs is dynamically.  This is done by\n   sending
      out a Directory Agent Discovery request (see Section 5.2).\n   Lastly, the agent
      may be informed passively as follows:\n   When a Directory Agent first comes
      on-line it sends an unsolicited DA\n   Advertisement to the Service Location
      general multicast address.  If\n   a DA supports a particular scope or set of
      scopes these are placed in\n   the reply.  The class for this attribute is 'SCOPE'.\n
      \  Every CONFIG_INTERVAL_9 a Directory Agent will send an unsolicited DA\n   Advertisement.
      \ This will ensure that eventually it will be\n   discovered by all applications
      which are concerned.\n   When a Directory Agent first comes up it begins with
      0 as its XID,\n   and increments this by one each time it sends an unsolicited
      DA\n   Advertisement.  When the counter wraps, it should go from 0xFFFF to\n
      \  0x0100, not 0.\n   If the Directory Agent has stored all of the service information
      in a\n   nonvolatile store, it should initially set the XID to 0x100, as it
      is\n   not coming up 'stateless.'  If it stores service registrations in\n   memory
      only, it will restart without any state.  It should indicate\n   this by resetting
      its XID to 0.\n   All Service Agents which receive the unsolicited DA Advertisement\n
      \  should examine its XID. If the Directory Agent has never before been\n   heard
      from or if the XID is less than it was previously and less than\n   256, the
      Service Agent should assume the DA does not have its service\n   registration,
      even if it once did.  If this is the case and the DA\n   has the proper scope,
      the SA should register all service information\n   with the Directory Agent,
      after waiting a random interval\n   CONFIG_INTERVAL_10.\n   When a Service Agent
      or User Agent first comes on-line it must issue\n   a Directory Agent Discovery
      Request unless it is using static or DHCP\n   configuration, as described in
      5.2.\n   A Service Agent registers information with ALL newly discovered\n   Directory
      Agents when either of the above two events take place.\n   When scopes are being
      used, a Service Agent SHOULD choose a set of\n   scopes to be advertised in
      and need only register with Directory\n   Agents that support the scopes in
      which they wish to be registered.\n   Services MUST be registered with DAs that
      support their scope and\n   those which have no scope, unless specifically configured
      not to do\n   so (see section 22.1.)\n   Once a User Agent becomes aware of
      a Directory Agent it will unicast\n   its queries there.  In the event that
      more than one Directory Agent\n   is detected, it will select one to communicate
      with.  When scopes are\n   supported, the User Agent will direct its queries
      to different\n   Directory Agents depending on which scopes are appropriate
      domains\n   for the query to be answered in.\n   The protocol will cause all
      DAs (of the same scope) to eventually\n   obtain consistent information.  Thus
      one DA should be as good as any\n   other for obtaining service information.
      \ There may be temporary\n   inconsistencies between DAs.\n"
    title: 15.2. Finding Directory Agents
  title: 15. Directory Agents
- contents:
  - "16. Scope Discovery and Use\n   The scope mechanism in the Service Location Protocol
    enhances its\n   scalability.  The primary use of scopes is to provide the capability\n
    \  to organize a site network along administrative lines.  A set of\n   services
    can be assigned to a given department of an organization, to\n   a certain building
    or geographical area or for a certain purpose.\n   The users of the system can
    be presented with these organizational\n   elements as a top level selection,
    before services within this domain\n   are sought.\n   A site network that has
    grown beyond a size that can be reasonably\n   serviced by a few DAs can use the
    scope mechanism.  DAs have the\n   attribute class \"SCOPE\".  The values for
    this attribute are a list of\n   strings that represent the administrative areas
    for which this\n   Directory Agent is configured.  The semantics and language
    of the\n   strings used to describe the scope are almost entirely the choice of\n
    \  the administrative entity of the particular domain in which these\n   scopes
    exist.  The values of SCOPE should be configurable, so the\n   system administrator
    can set its value.  The scopes \"LOCAL\" and\n   \"REMOTE\" are reserved and SHOULD
    NOT be used.  Use of these reserved\n   values is to be defined in a future protocol
    document.\n   Services with the attribute SCOPE should only be registered with
    DAs\n   which support the same scope or DAs which have no scope.\n   Directory
    Agents advertise their available scopes.  A Service Agent\n   may then choose
    a scope in which to register, and SHOULD register\n   with all Directory Agents
    in that scope, as well as all DAs which\n   have no scope.  Failure to be comprehensive
    in registration according\n   to this rule will mean that the service advertisement
    may not be\n   available to all User Agents.\n   A Directory Agent which has a
    scope will return advertisements in\n   response to Directory Agent Discovery
    requests with the scope\n   information included.  Note that the \"service:directory-agent\"
    scheme\n   is registered with the IANA naming authority (which is automatically\n
    \  selected by leaving the Naming Authority field empty.)\n   The query:\n         directory-agent/MATH
    DEPT//\n   Could receive the following DA Advertisement:\n      Returned URL:
    \       service:directory-agent://diragent.blah.edu\n      Returned SCOPE:      MATH
    DEPT\n   The same Directory Agent if it had no scope value would reply:\n      Returned
    URL:        service:directory-agent://diragent.void.com\n      Returned SCOPE:\n
    \  If a Directory Agent supported more than one scope it would reply as:\n      Returned
    URL:        service:directory-agent://srv.domain.org\n      Returned SCOPE:      MATH
    DEPT,ENGLISH DEPT,CS DEPT\n   A DA which has no scope will reply to any Directory
    Agent Discovery\n   Request.\n   Being a member of a scope means that an agent
    SHOULD use those\n   Directory Agents that support its scope.  User Agents send
    all\n   requests to DAs which support the indicated scope.  Services are\n   registered
    with the DA(s) in their scope.  For a UA to find a service\n   that is registered
    in a particular scope it must send requests to a\n   DA which supports the indicated
    scope.  There is no limitation on\n   scope membership built into the protocol;
    that is to say, a User\n   Agent or Service Agent may be a member of more than
    one scope.\n   Membership is open to all, unless some external authorization\n
    \  mechanism is added to limit access.\n"
  - contents:
    - "16.1. Protected Scopes\n   Scope membership MAY also define the security access
      and\n   authorization for services in the scope; such scopes are called\n   protected
      scopes.  If a User Agent wishes to be sure that Service\n   Agents are authorized
      to provide the service they advertise, then the\n   User Agent should request
      services from a protected scope which has\n   been configured to have the necessary
      authentication mechanism and\n   keys distributed to the Service Agents within
      the scope.  A directory\n   agent distributing URLs for services in a protected
      scope will reject\n   any registrations or deregistrations for service agents
      which cannot\n   provide cryptographically strong authentication to prove their\n
      \  authorization to provide the services.\n   For instance, if a campus registrar
      wishes to find a working printer\n   to produce student grade information for
      mailing, the registrar would\n   require the printing user agent to transmit
      the printable output only\n   to those printing Service Agents which have been
      registered in the\n   appropriate protected scope.  Notice that each service
      agent is,\n   under normal circumstances, validated two times:  once when\n
      \  registering with the directory agent, and once when the user agent\n   validates
      the URL received with the Service Reply.  This protects\n   against the possibilities
      of malicious Directory Agents as well as\n   malicious Service Agents.\n   Note
      that services in protected scopes provide separate\n   authentication for their
      URL entry, and for their attributes.  This\n   follows naturally from the needs
      of the protocol operation.  User\n   Agents which specify a service type and
      attributes needed for service\n   in that service type will not receive attribute
      information from the\n   directory agent; they will only receive the appropriate
      URL entries.\n   Only the information returned needs to be authenticated.\n
      \  User agents which receive attribute information for a particular URL\n   (see
      section 12), on the other hand, need to authenticate the\n   attributes when
      they are returned (see section 13).  In this case,\n   there may be much more
      data to authenticate, but this operation is\n   also performed much less often,
      usually only while the user is\n   browsing the available network resources.\n"
    title: 16.1. Protected Scopes
  title: 16. Scope Discovery and Use
- contents:
  - "17. Language and Character Encoding Issues\n   All Service Registrations declare
    the language in which the strings\n   in the service attributes are written by
    specifying the appropriate\n   code in the message header.  For each language
    the Service advertises\n   a separate registration takes place.  Each of these
    registrations\n   uses the same URL to indicate that they refer to the same service.\n
    \  If a Service is fully deregistered (the URL is given in the Service\n   Deregister
    request, without any attribute information) then the\n   Service needs to be deregistered
    only once.  This will effectively\n   deregister the service in all languages
    it has been registered in.\n   If, on the other hand, attribute information is
    included in the\n   Service Deregistration request, a separate Service Deregistration
    of\n   selected attributes must be undertaken in each language in which\n   service
    information has been provided to the DA by a Service Agent.\n   Service Registrations
    in different languages are mutually\n   unintelligible.  They share no information
    except for their service\n   type and URL with which they were registered.  No
    attempt is made to\n   match queries with \"language independence.\" Instead,
    queries are\n   handled using string matching against registrations in the same\n
    \  language as the query.\n   Service Types which are standardized will have definitions
    for all\n   attributes and value strings.  Official translations to other\n   languages
    of the attribute tags and values may be created and\n   submitted as part of the
    standard; this is not feasible for all\n   languages.  For those languages which
    are not defined as part of the\n   Service Type, a best effort translation of
    the standard definitions\n   of the Service type's attribute strings MAY be used.\n
    \  All Service Requests specify a requested language in the message\n   header.
    \ The Directory Agent or Service Agent will respond in the\n   same language as
    the request, if it has a registration in the same\n   language as the request.
    \ If this language is not supported, and the\n   Monolingual bit is not specified,
    a reply can be sent in the default\n   language (which is English.)  If the 'monolingual
    bit' flag in the\n   header is set and the requested language is not supported,
    a SrvRply\n   is returned with the error field set to LANGUAGE_NOT_SUPPORTED.\n
    \  If a query is in a supported language on a SA or DA, but has a\n   different
    dialect than the available service information, the query\n   MUST be serviced
    on a best-effort basis.  If possible, the query\n   should be matched against
    the same dialect.  If that is not possible,\n   it MAY be matched against any
    dialect of the same language.\n"
  - contents:
    - "17.1. Character Encoding and String Issues\n   Values for character encoding
      can be found in IANA's database\n         http://www.isi.edu/in-notes/iana/assignments/character-sets\n
      \  and have the values referred by the MIBEnum value.\n   The encoding will
      determine the interpretation of all character data\n   which follows the Service
      Location Protocol header.  There is no way\n   to mix ASCII and UNICODE, for
      example.  All responses must be in the\n   character set of the request, or
      use US-ASCII. If a request is sent\n   to a DA or SA or a registration is sent
      to a DA, which is unable to\n   manipulate or store the character set of the
      incoming message, the\n   request will fail.  The SA or DA returns a CHARSET_NOT_UNDERSTOOD\n
      \  error in a SrvAck message in this case.  Requests using US-ASCII will\n   never
      fail for this reason, since all SAs and DAs must be able to\n   accept this
      character set.\n   Certain characters are illegal in certain contexts of the
      protocol.\n   Since the protocol is largely character string based, in some\n
      \  contexts characters are used as protocol delimiters.  In these cases\n   the
      delimiting characters must not be used as 'data text.'\n"
    - contents:
      - "17.1.1. Substitution of Character Escape Sequences\n   The Service Location
        Protocol has an 'escape mechanism' which is\n   consistent with HTTP 2.0 [5]
        and SGML [15].  If the character\n   sequence \"&#\" is followed by one or
        more digits, followed by a\n   semicolon ';' the entire sequence is interpreted
        as a single\n   character.  The digits are interpreted as a decimal value
        in the\n   character set of the request, as specified by the header.  Thus,
        in\n   US-ASCII &#44; would be interpreted as a comma.  Substitution of\n
        \  these escape strings must be done in all <attr-list> and strings\n   present
        in SrvReq and AttrRqst messages.  Only numerical character\n   references
        are accepted, not 'Entity References,' as defined in HTML.\n   These escape
        values should only be used to provide a mechanism for\n   including reserved
        characters in attribute tag and value strings.\n   The interpretation of these
        escape values is different than in HTML\n   in one respect:  In HTML the escape
        values are considered to be in\n   the ISO Latin-1 character set.  In Service
        Location they are\n   interpreted in the character set defined in the header
        of the\n   message.\n   This escape mechanism allows characters like commas
        to be included in\n   attribute tags and values, which would otherwise be
        illegal as the\n   comma is a protocol delimiter.\n   Attribute tags and values
        of different languages are considered to be\n   mutually unintelligible.  A
        query in one language SHOULD use service\n   information registered in that
        language.\n"
      title: 17.1.1. Substitution of Character Escape Sequences
    title: 17.1. Character Encoding and String Issues
  - contents:
    - "17.2. Language-Independent Strings\n   Some strings, such as Service Type names,
      have standard definitions.\n   These strings should be considered as tokens
      and not as words in a\n   language to be translated.\n    Reserved String Section
      xDefinition\n    --------------- ------- --------------------------------------\n
      \   SCOPE           3, 15   Used to limit the matching of requests.\n    SERVICE
      \        6, 9    The URL scheme of all Service Location\n                            information
      registered with a DA or\n                            returned from a Service
      Request.\n    <srvtype>       20.2.1  Used in all service registrations\n                            and
      replies.\n    domain names    20.4    A fully qualified domain name, used\n
      \                           in registrations and replies.\n    IANA            3.3
      \    The default naming authority.\n    LOCAL           16      Reserved.\n
      \   REMOTE          16      Reserved.\n    TRUE            20.5    Boolean true.\n
      \   FALSE           20.5    Boolean false.\n"
    title: 17.2. Language-Independent Strings
  title: 17. Language and Character Encoding Issues
- contents:
  - '18. Service Location Transactions

    '
  - contents:
    - "18.1. Service Location Connections\n   When a Service Location Request or Attribute
      Request results in a UDP\n   reply from a Service or Directory Agent that will
      overflow a\n   datagram, the User Agent can open a connection to the Agent and\n
      \  reissue the request over the connection.  The reply will be returned\n   with
      the overflow bit set (see section 4).  The reply will contain as\n   much data
      as will fit into a single datagram.  If no MTU information\n   is available
      for the route, assume that the MTU is 1400; this value\n   is configurable (see
      section 22).\n   When a request results in overflowed data that cannot be correctly\n
      \  parsed (say, because of duplicate or dropped IP datagrams), a User\n   Agent
      that wishes to reliably obtain the overflowed data must\n   establish a TCP
      connection with the Directory Agent or Service Agent\n   with the data.  When
      the request is sent again with a new XID, the\n   reply is returned over the
      connection.\n   When registration data exceeds one datagram in length, the Service\n
      \  Registration should be made by establishing a connection with a\n   Directory
      Agent and sending the registration over the connection\n   stream.\n   Directory
      Agents and Service Agents must respond to connection\n   requests; services
      whose registration data can overflow a datagram\n   must be able to use TCP
      to send the registration.  User Agents should\n   be able to make Service and
      Attribute Requests using TCP. If they\n   fail to implement this, they must
      be able to interpret partial\n   replies and/or reissue requests with more selective
      criteria to\n   reduce the size of the replies.\n   A connection initiated by
      an Agent may be used for a single\n   transaction.  It may also be used for
      multiple transactions.  Since\n   there are length fields in the message headers,
      the Agents may send\n   multiple requests along a connection and read the return
      stream for\n   acknowledgments and replies.\n   The initiating agent is responsible
      for closing the TCP connection.\n   The DA should wait at least CONFIG_INTERVAL_12
      before closing an idle\n   connection.  DAs and SAs SHOULD eventually close
      idle connections to\n   ensure robust operation, even when the agent which opened
      a\n   connection neglects to close it.\n"
    title: 18.1. Service Location Connections
  - contents:
    - "18.2. No Synchronous Assumption\n   There is no requirement that one transaction
      complete before a given\n   host begins another.  An agent may have multiple
      outstanding\n   transactions, initiated either using UDP or TCP.\n"
    title: 18.2. No Synchronous Assumption
  - contents:
    - "18.3. Idempotency\n   All Service Location actions are idempotent.  Of course
      registration\n   and deregistration will change the state of a DA, but repeating
      these\n   actions with the same XID will have exactly the same effect each\n
      \  time.  Repeating a registration with a new XID has the effect of\n   extending
      the lifetime of the registration.\n"
    title: 18.3. Idempotency
  title: 18. Service Location Transactions
- contents:
  - "19. Security Considerations\n   The Service Location Protocol provides for authentication
    of Service\n   Agents as part of the scope mechanism, and consequently, integrity
    of\n   the data received as part of such registrations.  Service Location\n   does
    not provide confidentiality.  Because the objective of this\n   protocol is to
    advertise services to a community of users,\n   confidentiality might not generally
    be needed when this protocol is\n   used in non-sensitive environments.  Specialized
    schemes might be\n   able to provide confidentiality, if needed in the future.
    \ Sites\n   requiring confidentiality should implement the IP Encapsulating\n
    \  Security Payload (ESP) [3] to provide confidentiality for Service\n   Location
    messages.\n   Using unprotected scopes, an adversary might easily use this protocol\n
    \  to advertise services on servers controlled by the adversary and\n   thereby
    gain access to users' private information.  Further, an\n   adversary using this
    protocol will find it much easier to engage in\n   selective denial of service
    attacks.  Sites that are in potentially\n   hostile environments (e.g.  are directly
    connected to the Internet)\n   should consider the advantages of distributing
    keys associated with\n   protected scopes prior to deploying the sensitive directory
    agents or\n   service agents.\n   Service Location is useful as a bootstrap protocol.
    \ It may be used\n   in environments in which no preconfiguration is possible.
    \ In such\n   situations, a certain amount of \"blind faith\" is required:  Without\n
    \  any prior configuration it is impossible to use any of the security\n   mechanisms
    described above.  Service Location will make use of the\n   mechanisms provided
    by the Security Area of the IETF for key\n   distribution as they become available.
    \ At this point it would only\n   be possible to gain the benefits associated
    with the use of protected\n   scopes if some cryptographic information can be
    preconfigured with\n   the end systems before they use Service Location.  For
    User Agents,\n   this could be as simple as supplying the public key of a Certificate\n
    \  Authority.  See Appendix B.\n"
  title: 19. Security Considerations
- contents:
  - "20. String Formats used with Service Location Messages\n   The following section
    supplies formal definitions for fields and\n   protocol elements introduced in
    the sections indicated.\n      Protocol Element                      Defined in
    \        Used in\n      -----------------------------------   ------------     ------------\n
    \     <Previous Responders' Addr Spec>      20.1             SrvReq\n      Service
    Request <predicate>           5.4              SrvReq\n      URL                                   20.2
    \            SrvReg,\n                                                               SrvDereg,\n
    \                                                              SrvRply\n      <attr-list>
    \                          20.3             SrvReg,\n                                                               SrvRply,\n
    \                                                              AttrRply\n      <Service
    Registration Information>    9                SrvReg\n      <Service Deregister
    Information>      11               SrvDereg\n      <Service Type String>                 20.2.1
    \          AttrRqst\n"
  - contents:
    - "20.1. Previous Responders' Address Specification\n   The previous responders'
      Address Specification is specified as\n      <Previous Responders' Address Specification>
      ::=\n             <addr-spec> |\n             <addr-spec>, <Previous Responders'
      Address Specification>\n   i.e., a list separated by commas with no intervening
      white space.\n   The Address Specification is the address of the Directory Agent
      or\n   Service Agent which supplied the previous response.  The format for\n
      \  Address Specifications in Service Location is defined in section\n   20.4.
      \ The comma delimiter is required between each <addr-spec>.  The\n   use of
      dotted decimal IP address notation should only be used in\n   environments which
      have no Domain Name Service.\n   Example:\n         RESOLVO.NEATO.ORG,128.127.203.63\n"
    title: 20.1. Previous Responders' Address Specification
  - contents:
    - "20.2. Formal Definition of the \"service:\"  Scheme\n   A URL with a \"service:\"
      \ scheme is used in the SrvReg, SrvDereg,\n   SrvRply and AttrRqst messages
      in Service Location.  URLs are defined\n   in RFC 1738 [6].  A URL with the
      \"service:\"  scheme must contain at\n   least:\n   <url> ::= service:<srvtype>://<addr-spec>\n
      \  where:\n      service       the URL scheme for Service Location, to return\n
      \                   Replies.\n      <srvtype>     a string; Service Types may
      be standardized\n                    by developing a specification for the \"service\n
      \                   type\"-specific part and registering it with IANA.\n                    See
      sections 20.2.1 and 3.3.\n      <addr-spec>   the service access point of the
      service.  It is the\n                    network address or domain name where
      the service can\n                    be accessed.  See section 20.4.\n   The
      \"service:\"  scheme may be followed by any legal URL. The a\n   particular
      service.  The protocol used to access the service at the\n   given service access
      <addr-spec> may be implicit in the Service Type\n   name.  If this is not the
      case, the Service Type MUST be defined in\n   such a way that attribute information
      will include all necessary\n   configuration and protocol information.  A User
      Agent MUST therefore\n   be able to use either a \"service:\"  URL alone or
      a \"service:\"  URL in\n   conjunction with service attributes to make use of
      a service.\n"
    - contents:
      - "20.2.1. Service Type String\n   The Service Type is a string describing the
        type of service.  These\n   strings may only be comprised of alphanumeric
        characters, '+', and\n   Type names.\n   If the Service Type name is followed
        by a '.'  and a string (which\n   has the same limitations) the 'suffix' is
        considered to be the Naming\n   Authority of the service.  If the Naming Authority
        is omitted, IANA\n   is assumed to be the Naming Authority.\n   Service Types
        developed for in-house or experimental use may have any\n   name and attribute
        semantics provided that they do not conflict with\n   the standardized Service
        Types.\n"
      title: 20.2.1. Service Type String
    title: 20.2. Formal Definition of the "service:"  Scheme
  - contents:
    - "20.3. Attribute Information\n   The <attr-list> is returned in the Attribute
      Reply if the Attribute\n   Request does not result in an empty result.\n   <attr-list>
      ::= <attribute> | <attribute>, <attr-list>\n   <attribute> ::= (<attr-tag>=<attr-val-list>)
      | <keyword>\n   <attr-val-list> ::= <attr-val> | <attr-val>, <attr-val-list>\n
      \  An <attr-list> must be scanned prior to evaluation for all\n   occurrences
      of the string \"&#\" followed by one or more digit followed\n   by ';'.  See
      Section 17.1.1.\n   A keyword has only an <attr-tag>, and no values.\n   A comma
      cannot appear in an <attr-val>, as the comma is used as the\n   multiple value
      delimiter.  Examples of an <attr-list> are:\n         (SCOPE=ADMINISTRATION)\n
      \        (COLOR=RED, WHITE, BLUE)\n         (DELAY=10 MINS),BUSY,(LATEST BUILD=10-5-95),(PRIORITY=L,M,H)\n
      \  The third example has three attributes in the list.  Color can take\n   on
      the values red, white and blue.  There are several other examples\n   of replies
      throughout the document.\n"
    title: 20.3. Attribute Information
  - contents:
    - "20.4. Address Specification in Service Location\n   The address specification
      used in Service Location is:\n     <addr-spec> ::= [<user>:<password>@]<host>[:<port>]\n
      \    <host>      ::= Fully qualified domain name |\n                     dotted
      decimal IP address notation\n   When no Domain Name Server is available, SAs
      and DAs must use dotted\n   decimal conventions for IP addresses.  Otherwise,
      it is preferable to\n   use a fully qualified domain name wherever possible
      as renumbering of\n   host addresses will make IP addresses invalid over time.\n
      \  Generally, just the host domain name (or address) is returned.  When\n   there
      is a non-standard port for the protocol, that should be\n   returned as well.
      \ Some applications may make use of the\n   <user>:<password>@ syntax, but its
      use is not encouraged in this\n   context until mechanisms are established to
      maintain confidentiality.\n   Address specification in Service Location is consistent
      with standard\n   URL format [6].\n"
    title: 20.4. Address Specification in Service Location
  - contents:
    - "20.5. Attribute Value encoding rules\n   Attribute values, and attribute tags
      are CASE INSENSITIVE for\n   purposes of lexical comparison.\n   Attribute values
      are strings containing any characters with the\n   exception of '(', ')', '=',
      '>', '<', '/', '*', and ',' (the comma)\n   except in the case described below
      where opaque values are encoded.\n   These characters may be included using
      the character value escape\n   mechanism described in section 17.1.1.\n   While
      an attribute can take any value, there are three types of\n   values which differentiate
      themselves from general strings:\n   Booleans, Integers and Opaque values.\n
      \   -  Boolean values are either \"TRUE\" or \"FALSE\".  This is the case\n
      \      regardless of the language (i.e.  in French or Telugu, Boolean\n       TRUE
      is \"TRUE\", as well as in English.)  Boolean attributes can\n       take only
      one value.\n    -  Integer values are expressed as a sequence of numbers.  The\n
      \      range of allowable values for integers is \"-2147483648\" to\n       \"2147483647\".
      \ No other form of numeric representation is\n       interpreted as such except
      integers.  For example, hexadecimal\n       numbers such as \"0x342\" are not
      interpreted as integers, but as\n       strings.\n    -  Opaque values (i.e.
      \ binary values) are expressed in radix-64\n       notation.  The syntax is:\n
      \           <opaque-val>    ::=  (<len>:<radix-64-data>)\n            <len>
      \          ::=  number of bytes of the original data\n            <radix-64-data>
      ::=  radix-64 encoding of the original data\n       <len> is a 16-bit binary
      number.  Radix-64 encodes every 3 bytes\n       of binary data into 4 bytes
      of ASCII data which is in the range\n       of characters which are fully printable
      and transferable by mail.\n       For a formal definition of the Radix-64 format
      see RFC 1521 [7],\n       MIME Part One, Section 5.2 Base64 Content Transfer
      Encoding, page\n       21.\n"
    title: 20.5. Attribute Value encoding rules
  title: 20. String Formats used with Service Location Messages
- contents:
  - "21. Protocol Requirements\n   In this section are listed various protocol requirements
    for User\n   Agents, Service Agents, and Directory Agents.\n"
  - contents:
    - "21.1. User Agent Requirements\n   A User Agent MAY:\n    -  Provide a way for
      the application to configure the default DA, so\n       that it can be used
      without needing to find it each initially.\n    -  Be able to request the address
      of a DA from DHCP, if configured\n       to do so.\n    -  Ignore any unauthenticated
      Service Reply.\n    -  Be able to issue requests in any language or character
      set\n       provided that it can switch to the default language and character\n
      \      set if the request can not be serviced by DAs and SAs at the\n       site.\n
      \   -  Require an authentication block in any URL entry returned as\n       part
      of a Service Request, before making use of the advertised\n       service.\n
      \  A User Agent SHOULD:\n    -  Try to contact DHCP to obtain the address of
      a DA.\n    -  Use a scope in all requests, if possible.\n    -  Issue requests
      to scoped DAs if the UA has been configured with a\n       scope.\n    -  Listen
      on the Service Location General Multicast address for\n       unsolicited DA
      Advertisements.  This will increase the set of\n       Directory Agents available
      to it for making requests.  See\n       Section 15.2.\n    -  Be able to be
      configured to require an authentication block in\n       any received URL entry
      advertised as belonging to a protected\n       scope, before making use of the
      service.\n   If the UA does not listen for DA Advertisements, new DAs will not
      be\n   passively detected.  A UA which does not have a configured DA and has\n
      \  not yet discovered one and is not listening for unsolicited DA\n   Advertisements
      will remain ignorant of DAs.  It may then do a DA\n   discovery before each
      query performed or it may simply use multicast\n   queries to Service Agents.\n
      \  A User Agent MUST:\n    -  Be able to unicast requests and receive replies
      from a DA.\n       Transactions should be made reliable by using retransmission
      of\n       the request if the reply does not arrive within a timeout\n       interval.\n
      \   -  Be able to detect DAs using a Directory Agent Discovery request\n       issued
      when the UA starts up.\n    -  Be able to send requests to a multicast address.
      \ Service\n       Specific Multicast addresses are computed based on a hash
      of the\n       Service Type.  See Section 3.6.2.\n    -  Be able to handle numerous
      replies after a multicast request.\n       The implementation may be configurable
      so it will either return\n       the first reply, all replies until a timeout
      or keep trying till\n       the results converge.\n    -  Ignore any unauthenticated
      Service Reply or Attribute Reply when\n       an appropriate IPSec Security
      Association for that Reply exists.\n    -  Whenever it obtains its IP address
      from DHCP in the first place,\n       also attempt to obtain scope information,
      and the address of a\n       DA, from DHCP.\n    -  Use the IP Authentication
      Header or IP Encapsulating Payload in\n       all Service Location messages,
      whenever an appropriate IPSec\n       Security Association exists.\n    -  Be
      able to issue requests using the US-ASCII character set.\n    -  If configured
      to use a protected scope, be able to use\n       \"md5WithRSAEncryption\" [4]
      to verify the signed data.\n"
    title: 21.1. User Agent Requirements
  - contents:
    - "21.2. Service Agent Requirements\n   A Service Agent MAY be able to:\n    -
      \ Get the address of a local Directory Agent by way of DHCP.\n    -  Accept
      requests in non-US-ASCII character encodings.  This is\n       encouraged, especially
      for UNICODE [1] and UTF-8 [24] encodings.\n    -  Register services with a DA
      in non-US-ASCII character encodings.\n       This is encouraged, especially
      for UNICODE [1] and UTF-8 [24]\n       encodings.\n   A Service Agent SHOULD
      be able to:\n     -  Listen to the service-specific multicast address of the
      service\n       it is advertising.  The incoming requests should be filtered:
      \ If\n       the Address Specification of the SA is in the Previous Responders\n
      \      Address Specification list, the SA SHOULD NOT respond.\n       Otherwise,
      a response to the multicast query SHOULD be unicast to\n       the UA which
      sent the request.\n    -  Listen for and respond to broadcast requests and TCP
      connection\n       requests, to the Service Location port.\n    -  Be configurable
      to calculate authentication blocks and thereby\n    be enabled to register in
      protected scopes.  This requires that the\n    service agent be configured to
      possess the necessary keys to\n    calculate the authenticator.\n   A Service
      Agent MUST be able to:\n    -  Listen to the Service Location General Multicast
      address for\n       queries (e.g., Service Type Requests).  If the query can
      be\n       replied to by the Service Agent, the Service Agent MUST do so.\n
      \      It MUST check first to make sure it is not on the list of\n       'previous
      responders.'\n    -  Listen to the Service Location General Multicast address
      for\n       unsolicited DA Advertisements.  If one is detected, and the DA\n
      \      has the right scope, (or has no scope), all services which are\n       currently
      being advertised MUST be registered with the DA (unless\n       configured to
      only use a single DA (see section 22.1), or the DA\n       has already been
      detected, subject to certain rules (see section\n       15.2)).\n    -  Whenever
      it obtains its IP address from DHCP in the first place,\n       also attempt
      to obtain scope information, and the address of a\n       DA, from DHCP.\n    -
      \ Unicast registrations and deregistrations to a DA. Transactions\n       should
      be made reliable by using retransmission of the request if\n       the reply
      does not arrive within a timeout interval.\n    -  Be able to detect DAs using
      a Directory Agent Discovery request\n       issued when the SA starts up (unless
      configured to only use a\n       single DA, see section 22.1.)\n    -  Use the
      IP Authentication Header or IP Encapsulating Payload in\n       all Service
      Location messages, whenever an appropriate IPSec\n       Security Association
      exists.\n    -  Be able to register service information with a DA using US-ASCII\n
      \      character encoding.  It must also be able to reply to requests\n       from
      UAs which use US-ASCII character encoding.\n    -  Reregister with a DA before
      the Lifetime of registered service\n       information elapses.\n    -  If configured
      to use a protected scope, be able to use\n       \"md5WithRSAEncryption\" [4]
      to produce the signed data.\n"
    title: 21.2. Service Agent Requirements
  - contents:
    - "21.3. Directory Agent Requirements\n   A Directory Agent MAY:\n    -  Accept
      registrations and requests in non-US-ASCII character\n       encodings.  This
      is encouraged, especially for UNICODE [1] and\n       UTF-8 [24] encodings.\n
      \  A Directory Agent SHOULD:\n    -  Be able to configure certain scopes as
      protected scopes, so that\n       registrations within those scopes require
      the calculation of\n       cryptographically strong authenticators.  This requires
      that the\n       DA be able to possess the keys needed for the authentication,
      or\n       that the DA be able to acquire a certificate generated by a\n       trusted
      Certificate Authority [23], before completing Service\n       Registrations
      for protected scopes.\n   A Directory Agent MUST be able to:\n    -  Send an
      unsolicited DA Advertisements to the Service Location\n       General Multicast
      address on startup and repeat it periodically.\n       This reply has an XID
      which is incremented by one each time.  If\n       the DA starts with state,
      it initializes the XID to 0x0100.  If\n       it starts up stateless, it initializes
      the XID to 0x0000.\n    -  Ignore any unauthenticated Service Registration or
      Service\n       Deregistration from an entity with which it maintains a security\n
      \      association.\n    -  Listen on the Directory Agent Discovery Multicast
      Address for\n       Directory Agent Discovery requests.  Filter these requests
      if the\n       Previous Responder Address Specification list includes the DA's\n
      \      Address Specification.\n    -  Listen for broadcast requests to the Service
      Location port.\n    -  Listen on the TCP and UDP Service Location Ports for
      unicast\n       requests, registrations and deregistrations and service them.\n
      \   -  Provide a way in which scope information can be used to configure\n       the
      Directory Agent.\n    -  Expire registrations when the service registration's
      lifetime\n       expires.\n    -  When a Directory Agent has been configured
      with a scope, it MUST\n       refuse all requests and registrations which do
      not have this\n       scope.  The DA replies with a SCOPE_NOT_SUPPORTED error.
      \ There\n       is one exception:  All DAs MUST respond to DA discovery requests\n
      \      which have no scope.\n    -  When a Directory Agent has been configured
      without a scope, it\n       MUST accept ALL registrations and requests.\n    -
      \ Ignore any unauthenticated Service Location messages when an\n       appropriate
      IPSec Security Association exists for that request.\n    -  Use the IP Authentication
      and IP Encapsulating Security Payload\n       in Service Location messages whenever
      an appropriate IPSec\n       Security Association exists.\n    -  Accept requests
      and registrations in US-ASCII.\n    -  If configured with a protected scope,
      be able to authenticate (at\n       least by using \"md5WithRSAEncryption\"
      [4]) Service Registrations\n       advertising services purporting to belong
      to such configured\n       protected scopes.\n"
    title: 21.3. Directory Agent Requirements
  title: 21. Protocol Requirements
- contents:
  - "22. Configurable Parameters and Default Values\n   There are several configuration
    parameters for Service Location.\n   Default values are chosen to allow protocol
    operation without the\n   need for selection of these configuration parameters,
    but other\n   values may be selected by the site administrator.  The configurable\n
    \  parameters will allow an implementation of Service Location to be\n   more
    useful in a variety of scenarios.\n      Multicast vs.  Broadcast\n               All
    Service Location entities must use multicast by\n               default.  The
    ability to use broadcast messages must be\n               configurable for UAs
    and SAs.  Broadcast messages are to\n               be used in environments where
    not all Service Location\n               entities have hardware or software which
    supports\n               multicast.\n      Multicast Radius\n               Multicast
    requests should be sent to all subnets in a\n               site.  The default
    multicast radius for a site is 32.\n               This value must be configurable.
    \ The value for the\n               site's multicast TTL may be obtained from
    DHCP using an\n               option which is currently unassigned.\n      Directory
    Agent Address\n               The Directory Agent address discovery mechanism
    must be\n               configurable.  There are three possibilities for this\n
    \              configuration:  A default address, no default address and\n               the
    use of DHCP to locate a DA as described in section\n               15.2.  The
    default value should be use of DHCP, with \"no\n               default address\"
    used if DHCP does not respond.  In this\n               case the UA or SA must
    do a Directory Agent Discovery\n               query.\n      Directory Agent Scope
    Assignment\n               The scope or scopes of a DA must be configurable.  The\n
    \              default value for a DA is to have no scope if not\n               otherwise
    configured.\n      Path MTU\n               The default path MTU is assumed to
    be 1400.  This value\n               may be too large for the infrastructure of
    some sites.\n               For this reason this value MUST be configurable for
    all\n               SAs and DAs.\n      Keys for Protected Scopes\n               If
    the local administration designates certain scopes as\n               \"protected
    scopes\", the agents making use of those scopes\n               have to be able
    to acquire keys to authenticate data sent\n               by services along with
    their advertised URLs for services\n               within the protected scope.
    \ For instance, service agents\n               would use a private key to produce
    authentication data.\n               By default, service agents use \"md5WithRSAEncryption\"
    [4]\n               to produce the signed data, to be be included with\n               service
    registrations and deregistrations (see appendix\n               B, 4.3).  This
    authentication data could be verified by\n               user agents and directory
    agents that possess the\n               corresponding public key.\n"
  - contents:
    - "22.1. Service Agent:  Use Predefined Directory Agent(s)\n   A Service Agent's
      default configuration is to do passive and active\n   DA discovery and to register
      with all DAs which are properly scoped.\n   A Service Agent SHOULD be configurable
      to allow a special mode of\n   operation:  They will use only preconfigured
      DAs.  This means they\n   will *NOT* actively or passively detect DAs.\n   If
      a Service Agent is configured this way, knowledge of the DA must\n   come through
      another channel, either static configuration or by the\n   use of DHCP.\n   The
      availability of the Service information will not be consistent\n   between DAs.
      \ The mechanisms which achieve eventual consistency\n   between DAs are ignored
      by the SA, so their service information will\n   not be distributed.  This leaves
      the SA open to failure if the DA\n   they are configured to use fails.\n"
    title: '22.1. Service Agent:  Use Predefined Directory Agent(s)'
  - contents:
    - "22.2. Time Out Intervals\n   These values should be configurable in case the
      site deploying\n   Service Location has special requirements (such as very slow
      links.)\n   Interval name       Section Default Value Meaning\n   -----------------
      \  ------- ------------- -----------------------\n   CONFIG_INTERVAL_0   4.1
      \    1 minute      Cache replies by XID.\n   CONFIG_INTERVAL_1   4.4     10800
      seconds registration Lifetime,\n                               (ie.  3 hours)after
      which ad expires\n   CONFIG_INTERVAL_2   5       each second,  Retry multicast
      query\n                               backing off   until no new values\n                               gradually
      \    arrive.\n   CONFIG_INTERVAL_3   5       15 seconds    Max time to wait
      for a\n                                             complete multicast query\n
      \                                            response (all values.)\n   CONFIG_INTERVAL_4
      \  9       3 seconds     Wait to register on\n                                             reboot.\n
      \  CONFIG_INTERVAL_5   5.2     3 seconds     Retransmit DA discovery,\n                                             try
      it 3 times.\n   CONFIG_INTERVAL_6   5.2     5 seconds     Give up on requests
      sent\n                                             to a DA.\n   CONFIG_INTERVAL_7
      \  5.2     15 seconds    Give up on DA discovery\n   CONFIG_INTERVAL_8   5.1
      \    15 seconds    Give up on requests\n                                             sent
      to SAs.\n   CONFIG_INTERVAL_9   15.2    3 hours       DA Heartbeat, so that
      SAs\n                                             passively detect new DAs.\n
      \  CONFIG_INTERVAL_10  15.2    1-3 seconds   Wait to register services\n                                             on
      passive DA discovery.\n   CONFIG_INTERVAL_11  9       1-3 seconds   Wait to
      register services\n                                             on active DA
      discovery.\n   CONFIG_INTERVAL_12  18.1    5 minutes     DAs and SAs close idle\n
      \                                            connections.\n   A note on CONFIG_INTERVAL_9:
      \ While it might seem advantageous to\n   have frequent heartbeats, this poses
      a significant risk of generating\n   a lot of overhead traffic.  This value
      should be kept high to prevent\n   routine protocol operations from using any
      significant bandwidth.\n"
    title: 22.2. Time Out Intervals
  title: 22. Configurable Parameters and Default Values
- contents:
  - "23. Non-configurable Parameters\n   IP Port number for unicast requests to Directory
    Agents:\n         UDP and TCP Port Number:                          427\n   Multicast
    Addresses\n         Service Location General Multicast Address:       224.0.1.22\n
    \        Directory Agent Discovery Multicast Address:      224.0.1.35\n   A range
    of 1024 contiguous multicast addresses for use as Service\n   Specific Discovery
    Multicast Addresses will be assigned by IANA.\n   Error Codes:\n         No Error
    \                  0\n         LANGUAGE_NOT_SUPPORTED     1\n         PROTOCOL_PARSE_ERROR
    \      2\n         INVALID_REGISTRATION       3\n         SCOPE_NOT_SUPPORTED
    \       4\n         CHARSET_NOT_UNDERSTOOD     5\n         AUTHENTICATION_ABSENT
    \     6\n         AUTHENTICATION_FAILED      7\n"
  title: 23. Non-configurable Parameters
- contents:
  - "24. Acknowledgments\n   This protocol owes some of the original ideas to other
    service\n   location protocols found in many other networking protocols.  Leo\n
    \  McLaughlin and Mike Ritter (Metricom) provided much input into early\n   version
    of this document.  Thanks also to Steve Deering (Xerox) for\n   providing his
    insight into distributed multicast protocols.  Harry\n   Harjono and Charlie Perkins
    supplied the basis for the URL based wire\n   protocol in their Resource Discovery
    Protocol.  Thanks also to\n   Peerlogic, Inc.  for supporting this work.  Lastly,
    thanks to Jeff\n   Schiller for his help in shaping the security architecture
    specified\n   in this document.\n  A. Appendix:  Technical contents of ISO 639:1988
    (E/F): \"Code for the\n   representation of names of languages\"\n   Two-letter
    lower-case symbols are used.  The Registration Authority\n   for ISO 639 [14]
    is Infoterm, Osterreiches Normungsinstitut (ON),\n   Postfach 130, A-1021 Vienna,
    Austria.  Contains additions from ISO\n   639/RA Newsletter No.1/1989. See also
    RFC 1766.\n    aa Afar               ga Irish               mg Malagasy\n    ab
    Abkhazian          gd Scots Gaelic        mi Maori\n    af Afrikaans          gl
    Galician            mk Macedonian\n    am Amharic            gn Guarani             ml
    Malayalam\n    ar Arabic             gu Gujarati            mn Mongolian\n    as
    Assamese                                  mo Moldavian\n    ay Aymara             ha
    Hausa               mr Marathi\n    az Azerbaijani        he Hebrew              ms
    Malay\n                          hi Hindi               mt Maltese\n    ba Bashkir
    \           hr Croatian            my Burmese\n    be Byelorussian       hu Hungarian\n
    \   bg Bulgarian          hy Armenian            na Nauru\n    bh Bihari                                    ne
    Nepali\n    bi Bislama            ia Interlingua         nl Dutch\n    bn Bengali;
    Bangla    in Indonesian          no Norwegian\n    bo Tibetan            ie Interlingue\n
    \   br Breton             ik Inupiak             oc Occitan\n                          is
    Icelandic           om (Afan) Oromo\n    ca Catalan            it Italian             or
    Oriya\n    co Corsican           ja Japanese\n    cs Czech              jw Javanese
    \           pa Punjabi\n    cy Welsh                                     pl Polish\n
    \                         ka Georgian            ps Pashto, Pushto\n    da Danish
    \            kk Kazakh              pt Portuguese\n    de German             kl
    Greenlandic\n    dz Bhutani            km Cambodian           qu Quechua\n                          rw
    Kinyarwanda\n    el Greek              kn Kannada             rm Rhaeto-Romance\n
    \   en English            ko Korean              rn Kirundi\n    eo Esperanto
    \         ks Kashmiri            ro Romanian\n    es Spanish            ku Kurdish
    \            ru Russian\n    et Estonian           ky Kirghiz\n    eu Basque\n
    \                         la Latin\n    fa Persian            ln Lingala\n    fi
    Finnish            lo Laothian\n    fj Fiji               lt Lithuanian\n    fo
    Faeroese           lv Latvian, Lettish\n    fr French\n    fy Frisian\n    sa
    Sanskrit           ta Tamil               ug Uigar\n    sd Sindhi             te
    Telugu              uk Ukrainian\n    sg Sangro             tg Tajik               ur
    Urdu\n    sh Serbo-Croatian     th Thai                uz Uzbek\n    si Singhalese
    \        ti Tigrinya\n    sk Slovak             tk Turkmen             vi Vietnamese\n
    \   sl Slovenian          tl Tagalog             vo Volapuk\n    sm Samoan             tn
    Setswana\n    sn Shona              to Tonga               wo Wolof\n    so Somali
    \            tr Turkish\n    sq Albanian           ts Tsonga              xh Xhosa\n
    \   sr Serbian            tt Tatar\n    ss Siswati            tw Twi                 yi
    Yiddish\n    st Sesotho                                   yo Yoruba\n    su Sundanese\n
    \   sv Swedish                                   za Zhuang\n    sw Swahili                                   zh
    Chinese\n                                                 zu Zulu\n"
  title: 24. Acknowledgments
- contents:
  - "B. SLP Certificates\n   Certificates may be used in SLP in order to distribute
    the public\n   keys of trusted protected scopes.  Assuming public keys, this\n
    \  appendix discusses the use of such certificates in the Service\n   Location
    Protocol.\n   Possession of the private key of a protected scope is equivalent
    to\n   being a trusted SA. The trustworthiness of the protected scope\n   depends
    upon all of these private keys being held by trusted hosts,\n   and used only
    for legitimate service registrations and\n   deregistrations.\n   With access
    to the proper Certificate Authority (CA), DAs and UAs do\n   not need (in advance)
    hold public keys which correspond to these\n   protected scopes.  They do require
    the public key of the CA. The CA\n   produces certificates using its unique private
    key.  This private key\n   is not shared with any other system, and must remain
    secure.  The\n   certificates declare that a given protected scope has a given
    public\n   key, as well as the expiration date of the certificate.\n   The ASCII
    (mail-safe) string format for the certificate is the\n   following list of tag
    and value pairs:\n      \"certificate-alg=\" 1*ASN1CHAR       CRLF\n      \"scope-charset=\"
    \  1*DIGIT          CRLF\n      \"scope=\"           1*RADIX-64-CHAR  CRLF\n      \"timestamp=\"
    \      16HEXDIGIT       CRLF\n      \"public-key=\"      1*RADIX-64-CHAR  CRLF\n
    \     \"cert-digest=\"     1*RADIX-64-CHAR  CRLF\n      ASN1CHAR          = DIGIT
    | '.'\n      HEXDIGIT          = DIGIT | 'a'..'f' | 'A'..'F'\n      RADIX-64-CHAR
    \    = DIGIT | 'a'..'z' | 'A'..'Z' | '+' | '/' | '='\n   The radix-64 notation
    is described in RFC 1521 [7].  Spaces are\n   ignored in the computation of the
    binary value corresponding to a\n   Radix-64 string.  If the value for scope,
    public-key or cert-digest\n   is greater than 72 characters, the Radix-64 notation
    may be broken up\n   on to separate lines.  The continuation lines must be preceded
    by one\n   or more spaces.  Only the tags listed above may start in the first\n
    \  column of the certificate string.  This removes ambiguity in parsing\n   the
    Radix-64 values (since the tags consist of legal Radix-64\n   values.)\n   The
    certificate-alg is the ASN.1 string for the Object Identifier\n   value of the
    algorithm used to produce the \"cert-digest\".  The\n   scope-charset is a decimal
    representation of the MIBEnum value for\n   the character set in which the scope
    is represented.\n   The radix-64 encoding of the scope string will allow the ASCII\n
    \  rendering of a scope string any character set.\n   The 8 byte NTP format timestamp
    is represented as 16 hex digits.\n   This timestamp is the time at which the certificate
    will expire.\n   The format for the public key will depend on the type of cryptosystem\n
    \  used, which is identified by the certificate-alg.  When the CA\n   generated
    the certificate holding the public key being obtained, it\n   used the message
    digest algorithm identified by certificate-alg to\n   calculate a digest D on
    the string encoding of the certificate,\n   excepting the cert-digest.  The CA
    then encrypted this value using\n   the CA's private key to produce the cert-digest,
    which is included in\n   the certificate.\n   The CA generates the certificate
    off-line.  The mechanism to\n   distibute certificates is not specified in the
    Service Location\n   Protocol, but may be in the future.  The CA specifies the
    algorithms\n   to use for message digest and public key decryption.  The DA or
    SA\n   need only obtain the certificate, have a preconfigured public key for\n
    \  the CA and support the algorithm specified in the certificate-alg in\n   order
    to obtain certified new public keys for protected scopes.\n   The DA or UA may
    confirm the certificate by calculating the message\n   digest D, using the message
    digest algorithm identified by the\n   certificate-alg.  The input to the message
    digest algorithm is the\n   string encoding of the certificate, excepting the
    cert-digest.  The\n   cert-digest is decrypted using the CA's public key to produce
    D'. If\n   D is the same as D', the certificate is legitimate.  The public-key\n
    \  for the protected scope may be used until the expiration date\n   indicated
    by the certificate timestamp.\n   The certificate may be distributed along untrusted
    channels, such as\n   email or through file transfer, as it must be verified anyhow.
    \ The\n   CA's public key must be delivered using a trusted channel.\n"
  title: B. SLP Certificates
- contents:
  - "C. Example of deploying SLP security using MD5 and RSA\n   In our site, we have
    a protected scope \"CONTROLLED\".  We generate a\n   private key - public key
    pair for the scope, using RSA. The private\n   key is maintained on a secret key
    ring by all SAs in the protected\n   scope.  The public key is available to all
    DAs which support the\n   protected scope and to all UAs which will use it.\n
    \  In order to register or deregister a URL, the data required to be\n   authenticated
    (as described in section 4.3) is digestified using MD5\n   [22] to create a digital
    signature, then encrypted by RSA with the\n   protected scope's private key.  The
    output of RSA is used in the\n    authenticator data field of the authenticator
    block.\n   The DA or UA discovers the appropriate method for verifying the\n   authentication
    by looking inside the authentication block.  Suppose\n   that the \"md5WithRSAEncryption\"
    [4] algorithm has to be used to\n   verify the signed data.  The DA or UA calculates
    the message digest\n   of the URL Entry by using md5, exactly as the SA did.  The\n
    \  authenticator block is decrypted using the public key for the\n   \"CONTROLLED\"
    scope, which is stored in the public key ring of the UA\n   or DA under the name
    \"CONTROLLED\".  If the digest calculated by the\n   UA or DA matches that of
    the SA, the URL Entry has been validated.\n"
  title: C. Example of deploying SLP security using MD5 and RSA
- contents:
  - "D. Example of use of SLP Certificates by mobile nodes\n   Say a mobile node needs
    to make use of protected scopes.  The mobile\n   node is first preconfigured by
    adding a single public key to its\n   public key ring:  We will call it the CA-Key.
    \ This key will be used\n   to obtain SLP certificates in the format described
    in Appendix B.\n   The corresponding private key will be used by the CA to create
    the\n   certificates in the necessary format.\n   The CA might be operated by
    a system administrator using a computer\n   which is not connected to any networks.
    \ The certificate's duration\n   will depend on the policy of the site.  The duration,
    scope, and\n   public key for the protected scope, are used as input to 'md5sum'.\n
    \  This sum is then encrypted with RSA using the CA's private key.  The\n   radix
    64 encoding of this is added to the mail-safe string based\n   certificate encoding
    defined in Appendix B.\n   The certificate, say for the protected scope \"CONTROLLED\"
    could be\n   made available to the mobile node.  For example, it might be on a
    web\n   page.  The mobile node could then process the certificate in order to\n
    \  obtain the public key for the CONTROLLED scope.  There is still no\n   reason
    to *trust* this key is really the one to use (as in Appendix\n   C).  To trust
    it, calculate the md5 checksum of the ascii encoded\n   certificate, excluding
    the cert-digest.  Next, decrypt the cert-\n   digest using the CA's public key
    and RSA. If the cert-digest matches\n   the output of MD5, the certificate may
    be trusted (until it expires).\n   The mobile node requires only one key (CA-key)
    in order to obtain\n   others dynamically and make use of protected scopes.  Notice
    that we\n   do not define any method for access control by arbitrary UAs to SAs\n
    \  in protected scopes.\n"
  title: D. Example of use of SLP Certificates by mobile nodes
- contents:
  - "E. Appendix:  For Further Reading\n   Three related resource discovery protocols
    are NBP and ZIP which are\n   part of the AppleTalk protocol family [12], the
    Legato Resource\n   Administration Platform [25], and the Xerox Clearinghouse
    system\n   [20].  Domain names and representation of addresses are used\n   extensively
    in the Service Location Protocol.  The references for\n   these are RFCs 1034
    and 1035 [17, 18].  Example of a discovery\n   protocol for routers include Router
    Discovery [10] and Neighbor\n   Discovery [19].\n"
  title: 'E. Appendix:  For Further Reading'
- contents:
  - "References\n   [1] Unicode Technical Report #4.  The unicode standard, version
    1.1\n       (volumes 1 and 2).  Technical Report (ISBN 0-201-56788-1) and\n       (ISBN
    0-201-60845-6), Unicode Consortium, 1994.\n   [2] Alexander, S. and R. Droms.
    \ DHCP Options and BOOTP Vendor\n       Extensions.  RFC 2131, March 1997.\n   [3]
    Atkinson, R.  IP Encapsulating Security Payload.  RFC 1827,\n       August 1995.\n
    \  [4] Balenson, D.  Privacy Enhancement for Internet Electronic\n       Mail:
    \ Part III: Algorithms, Modes, and Identifiers.  RFC 1423,\n       February 1993.\n
    \  [5] Berners-Lee, T. and D. Connolly.  Hypertext Markup Language -\n       2.0.
    \ RFC 1866, November 1995.\n   [6] Berners-Lee, T., L. Masinter, and M. McCahill.
    \ Uniform Resource\n       Locators (URL).  RFC 1738, December 1994.\n   [7] Borenstein,
    N. and N. Freed.  MIME (Multipurpose Internet Mail\n       Extensions) Part One:
    \ Mechanisms for Specifying and Describing\n       the Format of Internet Message
    Bodies.  RFC 2045, November 1996.\n   [8] Bradner, Scott.  Key words for use in
    RFCs to Indicate\n       Requirement Levels. BCP 14, RFC 2119, March 1997.\n   [9]
    CCITT.  Specification of the Abstract Syntax Notation One\n       (ASN.1).  Recommendation
    X.208, 1988.\n   [10] Deering, Stephen E., editor.  ICMP Router Discovery Messages.\n
    \       RFC 1256, September 1991.\n   [11] Droms, Ralph.  Dynamic Host Configuration
    Protocol.  RFC 2131,\n        March 1997.\n   [12] Gursharan, S., R. Andrews,
    and A. Oppenheimer.  Inside\n        AppleTalk. Addison-Wesley, 1990.\n   [13]
    Guttman, E.  The service:  URL scheme, November 1996.\n        Work In Progress.\n
    \  [14] Geneva ISO.  Code for the representation of names of languages.\n        ISO
    639:1988 (E/F), 1988.\n   [15] ISO 8879, Geneva.  Information Processing -- Text
    and Office\n        Systems - Standard Generalized Markup Language (SGML).\n        <URL:http://www.iso.ch/cate/d16387.html>,
    1986.\n   [16] Mills, D.  Simple Network Time Protocol (SNTP) Version 4 for\n
    \       IPv4, IPv6 and OSI.  RFC 2030, October 1996.\n   [17] Mockapetris, P.
    \ Domain Names - Concepts and Facilities. STD 13,\n        RFC 1034, November
    1987.\n   [18] Mockapetris, P.  DOMAIN NAMES - IMPLEMENTATION AND\n        SPECIFICATION.
    \ STD 13, RFC 1035, November 1987.\n   [19] Narten, T., E. Nordmark, and W. Simpson.
    \ Neighbor Discovery for\n        IP version 6 (IPv6).  RFC 1970, August 1996.\n
    \  [20] Oppen, D. and Y. Dalal.  The clearinghouse:  A decentralized\n        agent
    for locating named objects in a distributed environment.\n        Technical Report
    Tech. Rep. OPD-78103, Xerox Office Products\n        Division, 1981.\n   [21]
    Perkins, C.  DHCP Options for Service Location Protocol, August\n        1996.
    Work In Progress.\n   [22] Rivest, Ronald.  The MD5 Message-Digest Algorithm.
    \ RFC 1321,\n        April 1992.\n   [23] Schneier, Bruce.  Applied Cryptography:
    \ Protocols, Algorithms,\n        and Source Code in C.  John Wiley, New York,
    NY, USA, 1994.\n   [24] X/Open Preliminary Specification.  File System Safe UCS\n
    \       Transformation Format (FSS_UTF).  Technical Report Document\n        Number:
    \ P316, X/Open Company Ltd., 1994.\n   [25] Legato Systems.  The Legato Resource
    Administration Platform.\n        Legato Systems, 1991.\n"
  title: References
- contents:
  - "Authors' Addresses\n   Questions about this memo can be directed to:\n   John
    Veizades                       Erik Guttman\n   @Home Network                       Sun
    Microsystems\n   385 Ravendale Dr.                   Gaisbergstr. 6\n   Mountain
    View, CA 94043             69115 Heidelberg Germany\n   Phone: +1 415 944 7332
    \             Phone: +1 415 336 6697\n   Fax:   +1 415 944 8500\n   Email: veizades@home.com
    \           Email: Erik.Guttman@eng.sun.com\n   Charles E. Perkins                  Scott
    Kaplan\n   Sun Microsystems\n   2550 Garcia Avenue                  346 Fair Oaks
    St.\n   Mountain View, CA  94043            San Francisco, CA 94110\n   Phone:
    +1 415 336 7153              Phone: +1 415 285 4526\n   Fax:   +1 415 336 0670\n
    \  EMail: cperkins@Corp.sun.com        Email: scott@catch22.com\n"
  title: Authors' Addresses
