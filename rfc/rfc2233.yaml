- title: __initial_text__
  contents:
  - '                  The Interfaces Group MIB using SMIv2

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1997).  All Rights Reserved.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   5 Overview ..................................................\
    \   26\n   6 Interfaces Group Definitions ..............................   26\n\
    \   7 Acknowledgements ..........................................   64\n   8 References\
    \ ................................................   64\n   9 Security Considerations\
    \ ...................................   65\n   10 Authors' Addresses .......................................\
    \   65\n   11 Full Copyright Statement .................................   66\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This memo defines a portion of the Management Information\
    \ Base\n   (MIB) for use with network management protocols in the Internet\n \
    \  community.  In particular, it describes managed objects used for\n   managing\
    \ Network Interfaces.\n   This memo discusses the 'interfaces' group of MIB-II,\
    \ especially the\n   experience gained from the definition of numerous media-\
    \ specific MIB\n   modules for use in conjunction with the 'interfaces' group\
    \ for\n   managing various sub-layers beneath the internetwork- layer.  It\n \
    \  specifies clarifications to, and extensions of, the architectural\n   issues\
    \ within the previous model used for the 'interfaces' group.\n   This memo also\
    \ includes a MIB module.  As well as including new\n   MIB definitions to support\
    \ the architectural extensions, this MIB\n   module also re-specifies the 'interfaces'\
    \ group of MIB-II in a\n   manner that is both compliant to the SNMPv2 SMI and\
    \ semantically-\n   identical to the existing SNMPv1-based definitions.\n   The\
    \ key words \"MUST\" and \"MUST NOT\" in this document are to be\n   interpreted\
    \ as described in RFC 2119 [10].\n"
- title: 2.  The SNMP Network Management Framework
  contents:
  - "2.  The SNMP Network Management Framework\n   The SNMP Network Management Framework\
    \ presently consists of three\n   major components.  They are:\n   o    RFC 1902\
    \ which defines the SMI, the mechanisms used for\n        describing and naming\
    \ objects for the purpose of management.\n   o    STD 17, RFC 1213 defines MIB-II,\
    \ the core set of managed\n        objects for the Internet suite of protocols.\n\
    \   o    STD 15, RFC 1157 and RFC 1905 which define two versions of\n        the\
    \ protocol used for network access to managed objects.\n   The Framework permits\
    \ new objects to be defined for the purpose of\n   experimentation and evaluation.\n"
- title: 2.1.  Object Definitions
  contents:
  - "2.1.  Object Definitions\n   Managed objects are accessed via a virtual information\
    \ store,\n   termed the Management Information Base or MIB.  Objects in the MIB\n\
    \   are defined using the subset of Abstract Syntax Notation One\n   (ASN.1) defined\
    \ in the SMI.  In particular, each object object\n   type is named by an OBJECT\
    \ IDENTIFIER, an administratively\n   assigned name.  The object type together\
    \ with an object instance\n   serves to uniquely identify a specific instantiation\
    \ of the\n   object.  For human convenience, we often use a textual string,\n\
    \   termed the descriptor, to refer to the object type.\n"
- title: 3.  Experience with the Interfaces Group
  contents:
  - "3.  Experience with the Interfaces Group\n   One of the strengths of internetwork-layer\
    \ protocols such as IP\n   [6] is that they are designed to run over any network\
    \ interface.\n   In achieving this, IP considers any and all protocols it runs\
    \ over\n   as a single \"network interface\" layer.  A similar view is taken by\n\
    \   other internetwork-layer protocols.  This concept is represented\n   in MIB-II\
    \ by the 'interfaces' group which defines a generic set of\n   managed objects\
    \ such that any network interface can be managed in\n   an interface-independent\
    \ manner through these managed objects.\n   The 'interfaces' group provides the\
    \ means for additional managed\n   objects specific to particular types of network\
    \ interface (e.g., a\n   specific medium such as Ethernet) to be defined as extensions\
    \ to\n   the 'interfaces' group for media-specific management.  Since the\n  \
    \ standardization of MIB-II, many such media-specific MIB modules\n   have been\
    \ defined.\n   Experience in defining these media-specific MIB modules has shown\n\
    \   that the model defined by MIB-II is too simplistic and/or static\n   for some\
    \ types of media-specific management.  As a result, some of\n   these media-specific\
    \ MIB modules assume an evolution or loosening\n   of the model.  This memo documents\
    \ and standardizes that evolution\n   of the model and fills in the gaps caused\
    \ by that evolution.  This\n   memo also incorporates the interfaces group extensions\
    \ documented\n   in RFC 1229 [7].\n"
- title: 3.1.  Clarifications/Revisions
  contents:
  - "3.1.  Clarifications/Revisions\n   There are several areas for which experience\
    \ has indicated that\n   clarification, revision, or extension of the model would\
    \ be\n   helpful.  The following sections discuss the changes in the\n   interfaces\
    \ group adopted by this memo in each of these areas.\n   In some sections, one\
    \ or more paragraphs contain discussion of\n   rejected alternatives to the model\
    \ adopted in this memo.  Readers\n   not familiar with the MIB-II model and not\
    \ interested in the\n   rationale behind the new model may want to skip these\
    \ paragraphs.\n"
- title: 3.1.1.  Interface Sub-Layers
  contents:
  - "3.1.1.  Interface Sub-Layers\n   Experience in defining media-specific management\
    \ information has\n   shown the need to distinguish between the multiple sub-layers\n\
    \   beneath the internetwork-layer.  In addition, there is a need to\n   manage\
    \ these sub-layers in devices (e.g., MAC-layer bridges) which\n   are unaware\
    \ of which, if any, internetwork protocols run over\n   these sub-layers.  As\
    \ such, a model of having a single conceptual\n   row in the interfaces table\
    \ (MIB-II's ifTable) represent a whole\n   interface underneath the internetwork-layer,\
    \ and having a single\n   associated media-specific MIB module (referenced via\
    \ the ifType\n   object) is too simplistic.  A further problem arises with the\n\
    \   value of the ifType object which has enumerated values for each\n   type of\
    \ interface.\n   Consider, for example, an interface with PPP running over an\
    \ HDLC\n   link which uses a RS232-like connector.  Each of these sub-layers\n\
    \   has its own media-specific MIB module.  If all of this is\n   represented\
    \ by a single conceptual row in the ifTable, then an\n   enumerated value for\
    \ ifType is needed for that specific\n   combination which maps to the specific\
    \ combination of media-\n   specific MIBs.  Furthermore, such a model still lacks\
    \ a method to\n   describe the relationship of all the sub-layers of the MIB stack.\n\
    \   An associated problem is that of upward and downward multiplexing\n   of the\
    \ sub-layers.  An example of upward multiplexing is MLP\n   (Multi-Link-Procedure)\
    \ which provides load-sharing over several\n   serial lines by appearing as a\
    \ single point-to-point link to the\n   sub-layer(s) above.  An example of downward\
    \ multiplexing would be\n   several instances of PPP, each framed within a separate\
    \ X.25\n   virtual circuit, all of which run over one fractional T1 channel,\n\
    \   concurrently with other uses of the T1 link.  The MIB structure\n   must allow\
    \ these sorts of relationships to be described.\n   Several solutions for representing\
    \ multiple sub-layers were\n   rejected.  One was to retain the concept of one\
    \ conceptual row for\n   all the sub-layers of an interface and have each media-specific\n\
    \   MIB module identify its \"superior\" and \"subordinate\" sub-layers\n   through\
    \ OBJECT IDENTIFIER \"pointers\".  This scheme would have\n   several drawbacks:\
    \ the superior/subordinate pointers would be\n   contained in the media-specific\
    \ MIB modules; thus, a manager could\n   not learn the structure of an interface\
    \ without inspecting\n   multiple pointers in different MIB modules; this would\
    \ be overly\n   complex and only possible if the manager had knowledge of all\
    \ the\n   relevant media-specific MIB modules; MIB modules would all need to\n\
    \   be retrofitted with these new \"pointers\"; this scheme would not\n   adequately\
    \ address the problem of upward and downward\n   multiplexing; and finally, enumerated\
    \ values of ifType would be\n   needed for each combination of sub-layers.  Another\
    \ rejected\n   solution also retained the concept of one conceptual row for all\n\
    \   the sub-layers of an interface but had a new separate MIB table to\n   identify\
    \ the \"superior\" and \"subordinate\" sub-layers and to\n   contain OBJECT IDENTIFIER\
    \ \"pointers\" to the media-specific MIB\n   module for each sub-layer.  Effectively,\
    \ one conceptual row in the\n   ifTable would represent each combination of sub-layers\
    \ between the\n   internetwork-layer and the wire.  While this scheme has fewer\n\
    \   drawbacks, it still would not support downward multiplexing, such\n   as PPP\
    \ over MLP: observe that MLP makes two (or more) serial\n   lines appear to the\
    \ layers above as a single physical interface,\n   and thus PPP over MLP should\
    \ appear to the internetwork-layer as a\n   single interface; in contrast, this\
    \ scheme would result in two (or\n   more) conceptual rows in the ifTable, both\
    \ of which the\n   internetwork-layer would run over.  This scheme would also\
    \ require\n   enumerated values of ifType for each combination of sub-layers.\n\
    \   The solution adopted by this memo is to have an individual\n   conceptual\
    \ row in the ifTable to represent each sub-layer, and\n   have a new separate\
    \ MIB table (the ifStackTable, see section 6\n   below) to identify the \"superior\"\
    \ and \"subordinate\" sub-layers\n   through INTEGER \"pointers\" to the appropriate\
    \ conceptual rows in\n   the ifTable.  This solution supports both upward and\
    \ downward\n   multiplexing, allows the IANAifType to Media-Specific MIB mapping\n\
    \   to identify the media-specific MIB module for that sub-layer, such\n   that\
    \ the new table need only be referenced to obtain information\n   about layering,\
    \ and it only requires enumerated values of ifType\n   for each sub-layer, not\
    \ for combinations of them.  However, it\n   does require that the descriptions\
    \ of some objects in the ifTable\n   (specifically, ifType, ifPhysAddress, ifInUcastPkts,\
    \ and\n   ifOutUcastPkts) be generalized so as to apply to any sub-layer\n   (rather\
    \ than only to a sub-layer immediately beneath the network\n   layer as previously),\
    \ plus some (specifically, ifSpeed) which need\n   to have appropriate values\
    \ identified for use when a generalized\n   definition does not apply to a particular\
    \ sub-layer.\n   In addition, this adopted solution makes no requirement that\
    \ a\n   device, in which a sub-layer is instrumented by a conceptual row\n   of\
    \ the ifTable, be aware of whether an internetwork protocol runs\n   on top of\
    \ (i.e., at some layer above) that sub-layer.  In fact,\n   the counters of packets\
    \ received on an interface are defined as\n   counting the number \"delivered\
    \ to a higher-layer protocol\".  This\n   meaning of \"higher-layer\" includes:\n\
    \   (1)  Delivery to a forwarding module which accepts\n        packets/frames/octets\
    \ and forwards them on at the same\n        protocol layer.  For example, for\
    \ the purposes of this\n        definition, the forwarding module of a MAC-layer\
    \ bridge is\n        considered as a \"higher-layer\" to the MAC-layer of each\
    \ port\n        on the bridge.\n   (2)  Delivery to a higher sub-layer within\
    \ a interface stack.  For\n        example, for the purposes of this definition,\
    \ if a PPP module\n        operated directly over a serial interface, the PPP\
    \ module\n        would be considered the higher sub-layer to the serial\n   \
    \     interface.\n   (3)  Delivery to a higher protocol layer which does not do\
    \ packet\n        forwarding for sub-layers that are \"at the top of\" the\n \
    \       interface stack.  For example, for the purposes of this\n        definition,\
    \ the local IP module would be considered the\n        higher layer to a SLIP\
    \ serial interface.\n   Similarly, for output, the counters of packets transmitted\
    \ out an\n   interface are defined as counting the number \"that higher-level\n\
    \   protocols requested to be transmitted\".  This meaning of \"higher-\n   layer\"\
    \ includes:\n   (1)  A forwarding module, at the same protocol layer, which\n\
    \        transmits packets/frames/octets that were received on an\n        different\
    \ interface.  For example, for the purposes of this\n        definition, the forwarding\
    \ module of a MAC-layer bridge is\n        considered as a \"higher-layer\" to\
    \ the MAC-layer of each port\n        on the bridge.\n   (2)  The next higher\
    \ sub-layer within an interface stack.  For\n        example, for the purposes\
    \ of this definition, if a PPP module\n        operated directly over a serial\
    \ interface, the PPP module\n        would be a \"higher layer\" to the serial\
    \ interface.\n   (3)  For sub-layers that are \"at the top of\" the interface\
    \ stack,\n        a higher element in the network protocol stack.  For example,\n\
    \        for the purposes of this definition, the local IP module\n        would\
    \ be considered the higher layer to an Ethernet\n        interface.\n"
- title: 3.1.2.  Guidance on Defining Sub-layers
  contents:
  - "3.1.2.  Guidance on Defining Sub-layers\n   The designer of a media-specific\
    \ MIB must decide whether to divide\n   the interface into sub-layers or not,\
    \ and if so, how to make the\n   divisions.  The following guidance is offered\
    \ to assist the\n   media-specific MIB designer in these decisions.\n   In general,\
    \ the number of entries in the ifTable should be kept to\n   the minimum required\
    \ for network management.  In particular, a\n   group of related interfaces should\
    \ be treated as a single\n   interface with one entry in the ifTable providing\
    \ that:\n   (1)  None of the group of interfaces performs multiplexing for any\n\
    \        other interface in the agent,\n   (2)  There is a meaningful and useful\
    \ way for all of the ifTable's\n        information (e.g., the counters, and the\
    \ status variables),\n        and all of the ifTable's capabilities (e.g., write\
    \ access to\n        ifAdminStatus), to apply to the group of interfaces as a\n\
    \        whole.\n   Under these circumstances, there should be one entry in the\n\
    \   ifTable for such a group of interfaces, and any internal structure\n   which\
    \ needs to be represented to network management should be\n   captured in a MIB\
    \ module specific to the particular type of\n   interface.\n   Note that application\
    \ of bullet 2 above to the ifTable's ifType\n   object requires that there is\
    \ a meaningful media-specific MIB and\n   a meaningful ifType value which apply\
    \ to the group of interfaces\n   as a whole.  For example, it is not appropriate\
    \ to treat an HDLC\n   sub-layer and an RS-232 sub-layer as a single ifTable entry\
    \ when\n   the media-specific MIBs and the ifType values for HDLC and RS-232\n\
    \   are separate (rather than combined).\n   Subject to the above, it is appropriate\
    \ to assign an ifIndex value\n   to any interface that can occur in an interface\
    \ stack (in the\n   ifStackTable) where the bottom of the stack is a physical\n\
    \   interface (ifConnectorPresent has the value 'true') and there is a\n   layer-3\
    \ or other application that \"points down\" to the top of this\n   stack.  An\
    \ example of an application that points down to the top\n   of the stack is the\
    \ Character MIB [9].\n   Note that the sub-layers of an interface on one device\
    \ will\n   sometimes be different from the sub-layers of the interconnected\n\
    \   interface of another device; for example, for a frame-relay DTE\n   interface\
    \ connected a frameRelayService interface, the inter-\n   connected DTE and DCE\
    \ interfaces have different ifType values and\n   media-specific MIBs.\n   These\
    \ guidelines are just that, guidelines.  The designer of a\n   media-specific\
    \ MIB is free to lay out the MIB in whatever SMI\n   conformant manner is desired.\
    \  However, in doing so, the media-\n   specific MIB MUST completely specify the\
    \ sub-layering model used\n   for the MIB, and provide the assumptions, reasoning,\
    \ and rationale\n   used to develop that model.\n"
- title: 3.1.3.  Virtual Circuits
  contents:
  - "3.1.3.  Virtual Circuits\n   Several of the sub-layers for which media-specific\
    \ MIB modules\n   have been defined are connection oriented (e.g., Frame Relay,\n\
    \   X.25).  Experience has shown that each effort to define such a MIB\n   module\
    \ revisits the question of whether separate conceptual rows\n   in the ifTable\
    \ are needed for each virtual circuit.  Most, if not\n   all, of these efforts\
    \ to date have decided to have all virtual\n   circuits reference a single conceptual\
    \ row in the ifTable.\n   This memo strongly recommends that connection-oriented\
    \ sub-layers\n   do not have a conceptual row in the ifTable for each virtual\n\
    \   circuit.  This avoids the proliferation of conceptual rows,\n   especially\
    \ those which have considerable redundant information.\n   (Note, as a comparison,\
    \ that connection-less sub-layers do not\n   have conceptual rows for each remote\
    \ address.)  There may,\n   however, be circumstances under which it is appropriate\
    \ for a\n   virtual circuit of a connection-oriented sub-layer to have its own\n\
    \   conceptual row in the ifTable; an example of this might be PPP\n   over an\
    \ X.25 virtual circuit.  The MIB in section 6 of this memo\n   supports such circumstances.\n\
    \   If a media-specific MIB wishes to assign an entry in the ifTable\n   to each\
    \ virtual circuit, the MIB designer must present the\n   rationale for this decision\
    \ in the media-specific MIB's\n   specification.\n"
- title: 3.1.4.  Bit, Character, and Fixed-Length Interfaces
  contents:
  - "3.1.4.  Bit, Character, and Fixed-Length Interfaces\n   RS-232 is an example\
    \ of a character-oriented sub-layer over which\n   (e.g., through use of PPP)\
    \ IP datagrams can be sent.  Due to the\n   packet-based nature of many of the\
    \ objects in the ifTable,\n   experience has shown that it is not appropriate\
    \ to have a\n   character-oriented sub-layer represented by a whole conceptual\
    \ row\n   in the ifTable.\n   Experience has also shown that it is sometimes desirable\
    \ to have\n   some management information for bit-oriented interfaces, which are\n\
    \   similarly difficult to represent by a whole conceptual row in the\n   ifTable.\
    \  For example, to manage the channels of a DS1 circuit,\n   where only some of\
    \ the channels are carrying packet-based data.\n   A further complication is that\
    \ some subnetwork technologies\n   transmit data in fixed length transmission\
    \ units.  One example of\n   such a technology is cell relay, and in particular\
    \ Asynchronous\n   Transfer Mode (ATM), which transmits data in fixed-length cells.\n\
    \   Representing such a interface as a packet-based interface produces\n   redundant\
    \ objects if the relationship between the number of\n   packets and the number\
    \ of octets in either direction is fixed by\n   the size of the transmission unit\
    \ (e.g., the size of a cell).\n   About half the objects in the ifTable are applicable\
    \ to every type\n   of interface: packet-oriented, character-oriented, and bit-\n\
    \   oriented.  Of the other half, two are applicable to both\n   character-oriented\
    \ and packet-oriented interfaces, and the rest\n   are applicable only to packet-oriented\
    \ interfaces.  Thus, while it\n   is desirable for consistency to be able to represent\
    \ any/all types\n   of interfaces in the ifTable, it is not possible to implement\
    \ the\n   full ifTable for bit- and character-oriented sub-layers.\n   A rejected\
    \ solution to this problem would be to split the ifTable\n   into two (or more)\
    \ new MIB tables, one of which would contain\n   objects that are relevant only\
    \ to packet-oriented interfaces\n   (e.g., PPP), and another that may be used\
    \ by all interfaces.  This\n   is highly undesirable since it would require changes\
    \ in every\n   agent implementing the ifTable (i.e., just about every existing\n\
    \   SNMP agent).\n   The solution adopted in this memo builds upon the fact that\n\
    \   compliance statements in SNMPv2 (in contrast to SNMPv1) refer to\n   object\
    \ groups, where object groups are explicitly defined by\n   listing the objects\
    \ they contain.  Thus, in SNMPv2, multiple\n   compliance statements can be specified,\
    \ one for all interfaces and\n   additional ones for specific types of interfaces.\
    \  The separate\n   compliance statements can be based on separate object groups,\n\
    \   where the object group for all interfaces can contain only those\n   objects\
    \ from the ifTable which are appropriate for every type of\n   interfaces.  Using\
    \ this solution, every sub-layer can have its own\n   conceptual row in the ifTable.\n\
    \   Thus, section 6 of this memo contains definitions of the objects\n   of the\
    \ existing 'interfaces' group of MIB-II, in a manner which is\n   both SNMPv2-compliant\
    \ and semantically-equivalent to the existing\n   MIB-II definitions.  With equivalent\
    \ semantics, and with the BER\n   (\"on the wire\") encodings unchanged, these\
    \ definitions retain the\n   same OBJECT IDENTIFIER values as assigned by MIB-II.\
    \  Thus, in\n   general, no rewrite of existing agents which conform to MIB-II\
    \ and\n   the ifExtensions MIB is required.\n   In addition, this memo defines\
    \ several object groups for the\n   purposes of defining which objects apply to\
    \ which types of\n   interface:\n   (1)  the ifGeneralInformationGroup.  This\
    \ group contains those\n        objects applicable to all types of network interfaces,\n\
    \        including bit-oriented interfaces.\n   (2)  the ifPacketGroup.  This\
    \ group contains those objects\n        applicable to packet-oriented network\
    \ interfaces.\n   (3)  the ifFixedLengthGroup.  This group contains the objects\n\
    \        applicable not only to character-oriented interfaces, such as\n     \
    \   RS-232, but also to those subnetwork technologies, such as\n        cell-relay/ATM,\
    \ which transmit data in fixed length\n        transmission units.  As well as\
    \ the octet counters, there are\n        also a few other counters (e.g., the\
    \ error counters) which\n        are useful for this type of interface, but are\
    \ currently\n        defined as being packet-oriented.  To accommodate this, the\n\
    \        definitions of these counters are generalized to apply to\n        character-oriented\
    \ interfaces and fixed-length-transmission\n        interfaces.\n   It should\
    \ be noted that the octet counters in the ifTable\n   aggregate octet counts for\
    \ unicast and non-unicast packets into a\n   single octet counter per direction\
    \ (received/transmitted).  Thus,\n   with the above definition of fixed-length-transmission\
    \ interfaces,\n   where such interfaces which support non-unicast packets, separate\n\
    \   counts of unicast and multicast/broadcast transmissions can only\n   be maintained\
    \ in a media-specific MIB module.\n"
- title: 3.1.5.  Interface Numbering
  contents:
  - "3.1.5.  Interface Numbering\n   MIB-II defines an object, ifNumber, whose value\
    \ represents:\n        \"The number of network interfaces (regardless of their\n\
    \        current state) present on this system.\"\n   Each interface is identified\
    \ by a unique value of the ifIndex\n   object, and the description of ifIndex\
    \ constrains its value as\n   follows:\n        \"Its value ranges between 1 and\
    \ the value of ifNumber.  The\n        value for each interface must remain constant\
    \ at least from\n        one re-initialization of the entity's network management\n\
    \        system to the next re-initialization.\"\n   This constancy requirement\
    \ on the value of ifIndex for a\n   particular interface is vital for efficient\
    \ management.  However,\n   an increasing number of devices allow for the dynamic\n\
    \   addition/removal of network interfaces.  One example of this is a\n   dynamic\
    \ ability to configure the use of SLIP/PPP over a\n   character-oriented port.\
    \  For such dynamic additions/removals, the\n   combination of the constancy requirement\
    \ and the restriction that\n   the value of ifIndex is less than ifNumber is problematic.\n\
    \   Redefining ifNumber to be the largest value of ifIndex was\n   rejected since\
    \ it would not help.  Such a re-definition would\n   require ifNumber to be deprecated\
    \ and the utility of the redefined\n   object would be questionable.  Alternatively,\
    \ ifNumber could be\n   deprecated and not replaced.  However, the deprecation\
    \ of ifNumber\n   would require a change to that portion of ifIndex's definition\n\
    \   which refers to ifNumber.  So, since the definition of ifIndex\n   must be\
    \ changed anyway in order to solve the problem, changes to\n   ifNumber do not\
    \ benefit the solution.\n   The solution adopted in this memo is just to delete\
    \ the\n   requirement that the value of ifIndex must be less than the value\n\
    \   of ifNumber, and to retain ifNumber with its current definition.\n   This\
    \ is a minor change in the semantics of ifIndex; however, all\n   existing agent\
    \ implementations conform to this new definition, and\n   in the interests of\
    \ not requiring changes to existing agent\n   implementations and to the many\
    \ existing media-specific MIBs, this\n   memo assumes that this change does not\
    \ require ifIndex to be\n   deprecated.  Experience indicates that this assumption\
    \ does\n   \"break\" a few management applications, but this is considered\n \
    \  preferable to breaking all agent implementations.\n   This solution also results\
    \ in the possibility of \"holes\" in the\n   ifTable, i.e., the ifIndex values\
    \ of conceptual rows in the\n   ifTable are not necessarily contiguous, but SNMP's\
    \ GetNext (and\n   SNMPv2's GetBulk) operation easily deals with such holes. \
    \ The\n   value of ifNumber still represents the number of conceptual rows,\n\
    \   which increases/decreases as new interfaces are dynamically\n   added/removed.\n\
    \   The requirement for constancy (between re-initializations) of an\n   interface's\
    \ ifIndex value is met by requiring that after an\n   interface is dynamically\
    \ removed, its ifIndex value is not re-used\n   by a *different* dynamically added\
    \ interface until after the\n   following re-initialization of the network management\
    \ system.\n   This avoids the need for assignment (in advance) of ifIndex values\n\
    \   for all possible interfaces that might be added dynamically.  The\n   exact\
    \ meaning of a \"different\" interface is hard to define, and\n   there will be\
    \ gray areas.  Any firm definition in this document\n   would likely to turn out\
    \ to be inadequate.  Instead, implementors\n   must choose what it means in their\
    \ particular situation, subject\n   to the following rules:\n   (1)  a previously-unused\
    \ value of ifIndex must be assigned to a\n        dynamically added interface\
    \ if an agent has no knowledge of\n        whether the interface is the \"same\"\
    \ or \"different\" to a\n        previously incarnated interface.\n   (2)  a management\
    \ station, not noticing that an interface has gone\n        away and another has\
    \ come into existence, must not be\n        confused when calculating the difference\
    \ between the counter\n        values retrieved on successive polls for a particular\
    \ ifIndex\n        value.\n   When the new interface is the same as an old interface,\
    \ but a\n   discontinuity in the value of the interface's counters cannot be\n\
    \   avoided, the ifTable has (until now) required that a new ifIndex\n   value\
    \ be assigned to the returning interface.  That is, either all\n   counter values\
    \ have had to be retained during the absence of an\n   interface in order to use\
    \ the same ifIndex value on that\n   interface's return, or else a new ifIndex\
    \ value has had to be\n   assigned to the returning interface.  Both alternatives\
    \ have\n   proved to be burdensome to some implementations:\n   (1)  maintaining\
    \ the counter values may not be possible (e.g., if\n        they are maintained\
    \ on removable hardware),\n   (2)  using a new ifIndex value presents extra work\
    \ for management\n        applications.  While the potential need for such extra\
    \ work\n        is unavoidable on agent re-initializations, it is desirable\n\
    \        to avoid it between re-initializations.\n   To address this, a new object,\
    \ ifCounterDiscontinuityTime, has\n   been defined to record the time of the last\
    \ discontinuity in an\n   interface's counters.  By monitoring the value of this\
    \ new object,\n   a management application can now detect counter discontinuities\n\
    \   without the ifIndex value of the interface being changed.  Thus,\n   an agent\
    \ which implements this new object should, when a new\n   interface is the same\
    \ as an old interface, retain that interface's\n   ifIndex value and update if\
    \ necessary the interface's value of\n   ifCounterDiscontinuityTime.  With this\
    \ new object, a management\n   application must, when calculating differences\
    \ between counter\n   values retrieved on successive polls, discard any calculated\n\
    \   difference for which the value of ifCounterDiscontinuityTime is\n   different\
    \ for the two polls.  (Note that this test must be\n   performed in addition to\
    \ the normal checking of sysUpTime to\n   detect an agent re-initialization.)\
    \  Since such discards are a\n   waste of network management processing and bandwidth,\
    \ an agent\n   should not update the value of ifCounterDiscontinuityTime unless\n\
    \   absolutely necessary.\n   While defining this new object is a change in the\
    \ semantics of the\n   ifTable counter objects, it is impractical to deprecate\
    \ and\n   redefine all these counters because of their wide deployment and\n \
    \  importance.  Also, a survey of implementations indicates that many\n   agents\
    \ and management applications do not correctly implement this\n   aspect of the\
    \ current semantics (because of the burdensome issues\n   mentioned above), such\
    \ that the practical implications of such a\n   change is small.  Thus, this breach\
    \ of the SMI's rules is\n   considered to be acceptable.\n   Note, however, that\
    \ the addition of ifCounterDiscontinuityTime\n   does not change the fact that:\n\
    \        It is necessary at certain times for the assignment of ifIndex\n    \
    \    values to change on a reinitialization of the agent (such as a\n        reboot).\n\
    \   The possibility of ifIndex value re-assignment must be\n   accommodated by\
    \ a management application whenever the value of\n   sysUpTime is reset to zero.\n\
    \   Note also that some agents support multiple \"naming scopes\", e.g.,\n   for\
    \ an SNMPv1 agent, multiple values of the SNMPv1 community\n   string.  For such\
    \ an agent (e.g., a CNM agent which supports a\n   different subset of interfaces\
    \ for different customers), there is\n   no required relationship between the\
    \ ifIndex values which identify\n   interfaces in one naming scope and those which\
    \ identify interfaces\n   in another naming scope.  It is the agent's choice as\
    \ to whether\n   the same or different ifIndex values identify the same or\n \
    \  different interfaces in different naming scopes.\n   Because of the restriction\
    \ of the value of ifIndex to be less than\n   ifNumber, interfaces have been numbered\
    \ with small integer values.\n   This has led to the ability by humans to use\
    \ the ifIndex values as\n   (somewhat) user-friendly names for network interfaces\
    \ (e.g.,\n   \"interface number 3\").  With the relaxation of the restriction\
    \ on\n   the value of ifIndex, there is now the possibility that ifIndex\n   values\
    \ could be assigned as very large numbers (e.g., memory\n   addresses).  Such\
    \ numbers would be much less user-friendly.\n   Therefore, this memo recommends\
    \ that ifIndex values still be\n   assigned as (relatively) small integer values\
    \ starting at 1, even\n   though the values in use at any one time are not necessarily\n\
    \   contiguous.  (Note that this makes remembering which values have\n   been\
    \ assigned easy for agents which dynamically add new\n   interfaces).\n   A new\
    \ problem is introduced by representing each sub-layer as an\n   ifTable entry.\
    \  Previously, there usually was a simple, direct,\n   mapping of interfaces to\
    \ the physical ports on systems.  This\n   mapping would be based on the ifIndex\
    \ value.  However, by having\n   an ifTable entry for each interface sub-layer,\
    \ mapping from\n   interfaces to physical ports becomes increasingly problematic.\n\
    \   To address this issue, a new object, ifName, is added to the MIB.\n   This\
    \ object contains the device's local name (e.g., the name used\n   at the device's\
    \ local console) for the interface of which the\n   relevant entry in the ifTable\
    \ is a component.  For example,\n   consider a router having an interface composed\
    \ of PPP running over\n   an RS-232 port.  If the router uses the name \"wan1\"\
    \ for the\n   (combined) interface, then the ifName objects for the\n   corresponding\
    \ PPP and RS-232 entries in the ifTable would both\n   have the value \"wan1\"\
    .  On the other hand, if the router uses the\n   name \"wan1.1\" for the PPP interface\
    \ and \"wan1.2\" for the RS-232\n   port, then the ifName objects for the corresponding\
    \ PPP and RS-232\n   entries in the ifTable would have the values \"wan1.1\" and\n\
    \   \"wan1.2\", respectively.  As an another example, consider an agent\n   which\
    \ responds to SNMP queries concerning an interface on some\n   other (proxied)\
    \ device: if such a proxied device associates a\n   particular identifier with\
    \ an interface, then it is appropriate to\n   use this identifier as the value\
    \ of the interface's ifName, since\n   the local console in this case is that\
    \ of the proxied device.\n   In contrast, the existing ifDescr object is intended\
    \ to contain a\n   description of an interface, whereas another new object, ifAlias,\n\
    \   provides a location in which a network management application can\n   store\
    \ a non-volatile interface-naming value of its own choice.\n   The ifAlias object\
    \ allows a network manager to give one or more\n   interfaces their own unique\
    \ names, irrespective of any interface-\n   stack relationship.  Further, the\
    \ ifAlias name is non-volatile,\n   and thus an interface must retain its assigned\
    \ ifAlias value\n   across reboots, even if an agent chooses a new ifIndex value\
    \ for\n   the interface.\n"
- title: 3.1.6.  Counter Size
  contents:
  - "3.1.6.  Counter Size\n   As the speed of network media increase, the minimum\
    \ time in which\n   a 32 bit counter will wrap decreases.  For example, a 10Mbs\
    \ stream\n   of back-to-back, full-size packets causes ifInOctets to wrap in\n\
    \   just over 57 minutes; at 100Mbs, the minimum wrap time is 5.7\n   minutes,\
    \ and at 1Gbs, the minimum is 34 seconds.  Requiring that\n   interfaces be polled\
    \ frequently enough not to miss a counter wrap\n   is increasingly problematic.\n\
    \   A rejected solution to this problem was to scale the counters; for\n   example,\
    \ ifInOctets could be changed to count received octets in,\n   say, 1024 byte\
    \ blocks.  While it would provide acceptable\n   functionality at high rates of\
    \ the counted-events, at low rates it\n   suffers.  If there is little traffic\
    \ on an interface, there might\n   be a significant interval before enough of\
    \ the counted-events\n   occur to cause the scaled counter to be incremented.\
    \  Traffic\n   would then appear to be very bursty, leading to incorrect\n   conclusions\
    \ of the network's performance.\n   Instead, this memo adopts expanded, 64 bit,\
    \ counters.  These\n   counters are provided in new \"high capacity\" groups.\
    \  The old,\n   32-bit, counters have not been deprecated.  The 64-bit counters\n\
    \   are to be used only when the 32-bit counters do not provide enough\n   capacity;\
    \ that is, when the 32 bit counters could wrap too fast.\n   For interfaces that\
    \ operate at 20,000,000 (20 million) bits per\n   second or less, 32-bit byte\
    \ and packet counters MUST be used.  For\n   interfaces that operate faster than\
    \ 20,000,000 bits/second, and\n   slower than 650,000,000 bits/second, 32-bit\
    \ packet counters MUST\n   be used and 64-bit octet counters MUST be used.  For\
    \ interfaces\n   that operate at 650,000,000 bits/second or faster, 64-bit packet\n\
    \   counters AND 64-bit octet counters MUST be used.\n   These speed thresholds\
    \ were chosen as reasonable compromises based\n   on the following:\n   (1)  The\
    \ cost of maintaining 64-bit counters is relatively high,\n        so minimizing\
    \ the number of agents which must support them is\n        desirable.  Common\
    \ interfaces (such as 10Mbs Ethernet) should\n        not require them.\n   (2)\
    \  64-bit counters are a new feature, introduced in SNMPv2.  It\n        is reasonable\
    \ to expect that support for them will be spotty\n        for the immediate future.\
    \  Thus, we wish to limit them to as\n        few systems as possible.  This,\
    \ in effect, means that 64-bit\n        counters should be limited to higher speed\
    \ interfaces.\n        Ethernet (10,000,000 bps) and Token Ring (16,000,000 bps)\
    \ are\n        fairly wide-spread so it seems reasonable to not require 64-\n\
    \        bit counters for these interfaces.\n   (3)  The 32-bit octet counters\
    \ will wrap in the following times,\n        for the following interfaces (when\
    \ transmitting maximum-sized\n        packets back-to-back):\n        -   10Mbs\
    \ Ethernet: 57 minutes,\n        -   16Mbs Token Ring: 36 minutes,\n        -\
    \   a US T3 line (45 megabits): 12 minutes,\n        -   FDDI: 5.7 minutes\n \
    \  (4)  The 32-bit packet counters wrap in about 57 minutes when 64-\n       \
    \ byte packets are transmitted back-to-back on a 650,000,000\n        bit/second\
    \ link.\n   As an aside, a 1-terabit/second (1,000 Gbs) link will cause a 64 bit\n\
    \   octet counter to wrap in just under 5 years.  Conversely, an\n   81,000,000\
    \ terabit/second link is required to cause a 64-bit counter\n   to wrap in 30\
    \ minutes.  We believe that, while technology rapidly\n   marches forward, this\
    \ link speed will not be achieved for at least\n   several years, leaving sufficient\
    \ time to evaluate the introduction\n   of 96 bit counters.\n   When 64-bit counters\
    \ are in use, the 32-bit counters MUST still be\n   available.  They will report\
    \ the low 32-bits of the associated 64-bit\n   count (e.g., ifInOctets will report\
    \ the least significant 32 bits of\n   ifHCInOctets).  This enhances inter-operability\
    \ with existing\n   implementations at a very minimal cost to agents.\n   The\
    \ new \"high capacity\" groups are:\n   (1)  the ifHCFixedLengthGroup for character-oriented/fixed-length\n\
    \        interfaces, and the ifHCPacketGroup for packet-based interfaces;\n  \
    \      both of these groups include 64 bit counters for octets, and\n   (2)  the\
    \ ifVHCPacketGroup for packet-based interfaces; this group\n        includes 64\
    \ bit counters for octets and packets.\n"
- title: 3.1.7.  Interface Speed
  contents:
  - "3.1.7.  Interface Speed\n   Network speeds are increasing.  The range of ifSpeed\
    \ is limited to\n   reporting a maximum speed of (2**31)-1 bits/second, or approximately\n\
    \   2.2Gbs.  SONET defines an OC-48 interface, which is defined at\n   operating\
    \ at 48 times 51 Mbs, which is a speed in excess of 2.4Gbs.\n   Thus, ifSpeed\
    \ is insufficient for the future, and this memo defines\n   an additional object:\
    \ ifHighSpeed.\n   The ifHighSpeed object reports the speed of the interface in\n\
    \   1,000,000 (1 million) bits/second units.  Thus, the true speed of the\n  \
    \ interface will be the value reported by this object, plus or minus\n   500,000\
    \ bits/second.\n   Other alternatives considered (but rejected) were:\n   (1)\
    \  Making the interface speed a 64-bit gauge.  This was rejected\n        since\
    \ the current SMI does not allow such a syntax.\n        Furthermore, even if\
    \ 64-bit gauges were available, their use\n        would require additional complexity\
    \ in agents due to an\n        increased requirement for 64-bit operations.\n\
    \   (2)  We also considered making \"high-32 bit\" and \"low-32-bit\"\n      \
    \  objects which, when combined, would be a 64-bit value.  This\n        simply\
    \ seemed overly complex for what we are trying to do.\n        Furthermore, a\
    \ full 64-bits of precision does not seem\n        necessary.  The value of ifHighSpeed\
    \ will be the only report of\n        interface speed for interfaces that are\
    \ faster than\n        4,294,967,295 bits per second.  At this speed, the granularity\n\
    \        of ifHighSpeed will be 1,000,000 bits per second, thus the error\n  \
    \      will be 1/4294, or about 0.02%.  This seems reasonable.\n   (3)  Adding\
    \ a \"scale\" object, which would define the units which\n        ifSpeed's value\
    \ is.\n        This would require two additional objects; one for the scaling\n\
    \        object, and one to replace the current ifSpeed.  This later\n       \
    \ object is required since the semantics of ifSpeed would be\n        significantly\
    \ altered, and manager stations which do not\n        understand the new semantics\
    \ would be confused.\n"
- title: 3.1.8.  Multicast/Broadcast Counters
  contents:
  - "3.1.8.  Multicast/Broadcast Counters\n   In MIB-II, the ifTable counters for\
    \ multicast and broadcast packets\n   are combined as counters of non-unicast\
    \ packets.  In contrast, the\n   ifExtensions MIB [7] defined one set of counters\
    \ for multicast, and a\n   separate set for broadcast packets.  With the separate\
    \ counters, the\n   original combined counters become redundant.  To avoid this\n\
    \   redundancy, the non-unicast counters are deprecated.\n   For the output broadcast\
    \ and multicast counters defined in RFC 1229,\n   their definitions varied slightly\
    \ from the packet counters in the\n   ifTable, in that they did not count errors/discarded\
    \ packets.  Thus,\n   this memo defines new objects with better aligned definitions.\n\
    \   Counters with 64 bits of range are also needed, as explained above.\n"
- title: 3.1.9.  Trap Enable
  contents:
  - "3.1.9.  Trap Enable\n   In the multi-layer interface model, each sub-layer for\
    \ which there is\n   an entry in the ifTable can generate linkUp/Down Traps. \
    \ Since\n   interface state changes would tend to propagate through the interface\n\
    \   (from top to bottom, or bottom to top), it is likely that several\n   traps\
    \ would be generated for each linkUp/Down occurrence.\n   It is desirable to provide\
    \ a mechanism for manager stations to\n   control the generation of these traps.\
    \  To this end, the\n   ifLinkUpDownTrapEnable object has been added.  This object\
    \ allows\n   managers to limit generation of traps to just the sub-layers of\n\
    \   interest.\n   The default setting should limit the number of traps generated\
    \ to one\n   per interface per linkUp/Down event.  Furthermore, it seems that\
    \ the\n   state changes of most interest to network managers occur at the\n  \
    \ lowest level of an interface stack.  Therefore we specify that by\n   default,\
    \ only the lowest sub-layer of the interface generate traps.\n"
- title: 3.1.10.  Addition of New ifType values
  contents:
  - "3.1.10.  Addition of New ifType values\n   Over time, there is the need to add\
    \ new ifType enumerated values for\n   new interface types.  If the syntax of\
    \ ifType were defined in the MIB\n   in section 6, then a new version of this\
    \ MIB would have to be re-\n   issued in order to define new values.  In the past,\
    \ re- issuing of a\n   MIB has occurred only after several years.\n   Therefore,\
    \ the syntax of ifType is changed to be a textual\n   convention, such that the\
    \ enumerated integer values are now defined\n   in the textual convention, IANAifType,\
    \ defined in a different\n   document.  This allows additional values to be documented\
    \ without\n   having to re-issue a new version of this document.  The Internet\n\
    \   Assigned Number Authority (IANA) is responsible for the assignment of\n  \
    \ all Internet numbers, including various SNMP-related numbers, and\n   specifically,\
    \ new ifType values.\n"
- title: 3.1.11.  InterfaceIndex Textual Convention
  contents:
  - "3.1.11.  InterfaceIndex Textual Convention\n   A new textual convention, InterfaceIndex,\
    \ has been defined.  This\n   textual convention \"contains\" all of the semantics\
    \ of the ifIndex\n   object.  This allows other mib modules to easily import the\
    \ semantics\n   of ifIndex.\n"
- title: 3.1.12.  New states for IfOperStatus
  contents:
  - "3.1.12.  New states for IfOperStatus\n   Three new states have been added to\
    \ ifOperStatus: 'dormant', \n   'notPresent', and 'lowerLayerDown'.\n   The dormant\
    \ state indicates that the relevant interface is not\n   actually in a condition\
    \ to pass packets (i.e., it is not \"up\") but is\n   in a \"pending\" state,\
    \ waiting for some external event.  For \"on-\n   demand\" interfaces, this new\
    \ state identifies the situation where the\n   interface is waiting for events\
    \ to place it in the up state.\n   Examples of such events might be:\n   (1) \
    \ having packets to transmit before establishing a connection\n        to a remote\
    \ system;\n   (2)  having a remote system establish a connection to the\n    \
    \    interface (e.g. dialing up to a slip-server).\n   The notPresent state is\
    \ a refinement on the down state which\n   indicates that the relevant interface\
    \ is down specifically because\n   some component (typically, a hardware component)\
    \ is not present in\n   the managed system.  Examples of use of the notPresent\
    \ state are:\n   (1)  to allow an interface's conceptual row including its counter\n\
    \        values to be retained across a \"hot swap\" of a card/module,\n     \
    \   and/or\n   (2)  to allow an interface's conceptual row to be created, and\n\
    \        thereby enable interfaces to be pre-configured prior to\n        installation\
    \ of the hardware needed to make the interface\n        operational.\n   Agents\
    \ are not required to support interfaces in the notPresent\n   state.  However,\
    \ from a conceptual viewpoint, when a row in the\n   ifTable is created, it first\
    \ enters the notPresent state and then\n   subsequently transitions into the down\
    \ state; similarly, when a row\n   in the ifTable is deleted, it first enters\
    \ the notPresent state and\n   then subsequently the object instances are deleted.\
    \  For an agent\n   with no support for notPresent, both of these transitions\
    \ (from the\n   notPresent state to the down state, and from the notPresent state\
    \ to\n   the instances being removed) are immediate, i.e., the transition does\n\
    \   not last long enough to be recorded by ifOperStatus.  Even for those\n   agents\
    \ which do support interfaces in the notPresent state, the\n   length of time\
    \ and conditions under which an interface stays in the\n   notPresent state is\
    \ implementation-specific.\n   The lowerLayerDown state is also a refinement on\
    \ the down state.\n   This new state indicates that this interface runs \"on top\
    \ of\" one or\n   more other interfaces (see ifStackTable) and that this interface\
    \ is\n   down specifically because one or more of these lower-layer interfaces\n\
    \   are down.\n"
- title: 3.1.13.  IfAdminStatus and IfOperStatus
  contents:
  - "3.1.13.  IfAdminStatus and IfOperStatus\n   The down state of ifOperStatus now\
    \ has two meanings, depending on the\n   value of ifAdminStatus.\n   (1)  if ifAdminStatus\
    \ is not down and ifOperStatus is down then a\n        fault condition is presumed\
    \ to exist on the interface.\n   (2)  if ifAdminStatus is down, then ifOperStatus\
    \ will normally\n        also be down (or notPresent) i.e., there is not (necessarily)\
    \ a\n        fault condition on the interface.\n   Note that when ifAdminStatus\
    \ transitions to down, ifOperStatus will\n   normally also transition to down.\
    \  In this situation, it is possible\n   that ifOperStatus's transition will not\
    \ occur immediately, but rather\n   after a small time lag to complete certain\
    \ operations before going\n   \"down\"; for example, it might need to finish transmitting\
    \ a packet.\n   If a manager station finds that ifAdminStatus is down and\n  \
    \ ifOperStatus is not down for a particular interface, the manager\n   station\
    \ should wait a short while and check again.  If the condition\n   still exists,\
    \ only then should it raise an error indication.\n   Naturally, it should also\
    \ ensure that ifLastChange has not changed\n   during this interval.\n   Whenever\
    \ an interface table entry is created (usually as a result of\n   system initialization),\
    \ the relevant instance of ifAdminStatus is set\n   to down, and presumably ifOperStatus\
    \ will be down or notPresent.\n   An interface may be enabled in two ways: either\
    \ as a result of\n   explicit management action (e.g. setting ifAdminStatus to\
    \ up) or as a\n   result of the managed system's initialization process.  When\n\
    \   ifAdminStatus changes to the up state, the related ifOperStatus\n   should\
    \ do one of the following:\n   (1)  Change to the up state if and only if the\
    \ interface is able\n        to send and receive packets.\n   (2)  Change to the\
    \ lowerLayerDown state if and only if the\n        interface is prevented from\
    \ entering the up state because of the\n        state of one or more of the interfaces\
    \ beneath it in the\n        interface stack.\n   (3)  Change to the dormant state\
    \ if and only if the interface is\n        found to be operable, but the interface\
    \ is waiting for other,\n        external, events to occur before it can transmit\
    \ or receive\n        packets.  Presumably when the expected events occur, the\n\
    \        interface will then change to the up state.\n   (4)  Remain in the down\
    \ state if an error or other fault condition\n        is detected on the interface.\n\
    \   (5)  Change to the unknown state if, for some reason, the state of\n     \
    \   the interface can not be ascertained.\n   (6)  Change to the testing state\
    \ if some test(s) must be performed\n        on the interface. Presumably after\
    \ completion of the test, the\n        interface's state will change to up, dormant,\
    \ or down, as\n        appropriate.\n   (7)  Remain in the notPresent state if\
    \ interface components are\n        missing.\n"
- title: 3.1.14.  IfOperStatus in an Interface Stack
  contents:
  - "3.1.14.  IfOperStatus in an Interface Stack\n   When an interface is a part of\
    \ an interface-stack, but is not the\n   lowest interface in the stack, then:\n\
    \   (1)  ifOperStatus has the value 'up' if it is able to pass packets\n     \
    \   due to one or more interfaces below it in the stack being 'up',\n        irrespective\
    \ of whether other interfaces below it are 'down', \n        'dormant', 'notPresent',\
    \ 'lowerLayerDown', 'unknown' or\n        'testing'.\n   (2)  ifOperStatus may\
    \ have the value 'up' or 'dormant' if one or\n        more interfaces below it\
    \ in the stack are 'dormant', and all\n        others below it are either 'down',\
    \ 'dormant', 'notPresent',\n        'lowerLayerDown', 'unknown' or 'testing'.\n\
    \   (3)  ifOperStatus has the value 'lowerLayerDown' while all\n        interfaces\
    \ below it in the stack are either 'down',\n        'notPresent', 'lowerLayerDown',\
    \ or 'testing'.\n"
- title: 3.1.15.  Traps
  contents:
  - "3.1.15.  Traps\n   The exact definition of when linkUp and linkDown traps are\
    \ generated\n   has been changed to reflect the changes to ifAdminStatus and\n\
    \   ifOperStatus.\n   Operational experience indicates that management stations\
    \ are most\n   concerned with an interface being in the down state and the fact\
    \ that\n   this state may indicate a failure.  Thus, it is most useful to\n  \
    \ instrument transitions into/out of either the up state or the down\n   state.\n\
    \   Instrumenting transitions into or out of the up state was rejected\n   since\
    \ it would have the drawback that a demand interface might have\n   many transitions\
    \ between up and dormant, leading to many linkUp traps\n   and no linkDown traps.\
    \  Furthermore, if a node's only interface is\n   the demand interface, then a\
    \ transition to dormant would entail\n   generation of a linkDown trap, necessitating\
    \ bringing the link to the\n   up state (and a linkUp trap)!!\n   On the other\
    \ hand, instrumenting transitions into or out of the down\n   state (to/from all\
    \ other states except notPresent) has the\n   advantages:\n   (1)  A transition\
    \ into the down state (from a state other than\n        notPresent) will occur\
    \ when an error is detected on an\n        interface.  Error conditions are presumably\
    \ of great interest to\n        network managers.\n   (2)  Departing the down\
    \ state (to a state other than the\n        notPresent state) generally indicates\
    \ that the interface is\n        going to either up or dormant, both of which\
    \ are considered\n        \"healthy\" states.\n   Furthermore, it is believed\
    \ that generating traps on transitions into\n   or out of the down state (except\
    \ to/from the notPresent state) is\n   generally consistent with current usage\
    \ and interpretation of these\n   traps by manager stations.\n   Transitions to/from\
    \ the notPresent state are concerned with the\n   insertion and removal of hardware,\
    \ and are outside the scope of these\n   traps.\n   Therefore, this memo defines\
    \ that LinkUp and linkDown traps are\n   generated on just after ifOperStatus\
    \ leaves, or just before it\n   enters, the down state, respectively; except that\
    \ LinkUp and linkDown\n   traps never generated on transitions to/from the notPresent\
    \ state.\n   Note that this definition allows a node with only one interface to\n\
    \   transmit a linkDown trap before that interface goes down.  (Of\n   course,\
    \ when the interface is going down because of a failure\n   condition, the linkDown\
    \ trap probably cannot be successfully\n   transmitted anyway.)\n   Some interfaces\
    \ perform a link \"training\" function when trying to\n   bring the interface\
    \ up.  In the event that such an interface were\n   defective, then the training\
    \ function would fail and the interface\n   would remain down, and the training\
    \ function might be repeated at\n   appropriate intervals.  If the interface,\
    \ while performing this\n   training function, were considered to the in the testing\
    \ state, then\n   linkUp and linkDown traps would be generated for each start\
    \ and end\n   of the training function.  This is not the intent of the linkUp\
    \ and\n   linkDown traps, and therefore, while performing such a training\n  \
    \ function, the interface's state should be represented as down.\n   An exception\
    \ to the above generation of linkUp/linkDown traps on\n   changes in ifOperStatus,\
    \ occurs when an interface is \"flapping\",\n   i.e., when it is rapidly oscillating\
    \ between the up and down states.\n   If traps were generated for each such oscillation,\
    \ the network and\n   the network management system would be flooded with unnecessary\n\
    \   traps.  In such a situation, the agent should rate- limit its\n   generation\
    \ of traps.\n"
- title: 3.1.16.  ifSpecific
  contents:
  - "3.1.16.  ifSpecific\n   The original definition of the OBJECT IDENTIFIER value\
    \ of ifSpecific\n   was not sufficiently clear.  As a result, different implementors\
    \ used\n   it differently, and confusion resulted.  Some implementations set the\n\
    \   value of ifSpecific to the OBJECT IDENTIFIER that defines the media-\n   specific\
    \ MIB, i.e., the \"foo\" of:\n              foo OBJECT IDENTIFIER ::= { transmission\
    \ xxx }\n   while others set it to be OBJECT IDENTIFIER of the specific table\
    \ or\n   entry in the appropriate media-specific MIB (i.e., fooTable or\n   fooEntry),\
    \ while still others set it be the OBJECT IDENTIFIER of the\n   index object of\
    \ the table's row, including instance identifier,\n   (i.e., fooIfIndex.ifIndex).\
    \  A definition based on the latter would\n   not be sufficient unless it also\
    \ allowed for media- specific MIBs\n   which include several tables, where each\
    \ table has its own\n   (different) indexing.\n   The only definition that can\
    \ both be made explicit and can cover all\n   the useful situations is to have\
    \ ifSpecific be the most general value\n   for the media-specific MIB module (the\
    \ first example given above).\n   This effectively makes it redundant because\
    \ it contains no more\n   information than is provided by ifType.  Thus, ifSpecific\
    \ has been\n   deprecated.\n"
- title: 3.1.17.  Creation/Deletion of Interfaces
  contents:
  - "3.1.17.  Creation/Deletion of Interfaces\n   While some interfaces, for example,\
    \ most physical interfaces, cannot\n   be created via network management, other\
    \ interfaces such as logical\n   interfaces sometimes can be.  The ifTable contains\
    \ only generic\n   information about an interface.  Almost all 'create-able' interfaces\n\
    \   have other, media-specific, information through which configuration\n   parameters\
    \ may be supplied prior to creating such an interface.\n   Thus, the ifTable does\
    \ not itself support the creation or deletion of\n   an interface (specifically,\
    \ it has no RowStatus [2] column).  Rather,\n   if a particular interface type\
    \ supports the dynamic creation and/or\n   deletion of an interface of that type,\
    \ then that media-specific MIB\n   should include an appropriate RowStatus object\
    \ (see the ATM LAN-\n   Emulation Client MIB [8] for an example of a MIB which\
    \ does this).\n   Typically, when such a RowStatus object is created/deleted,\
    \ then the\n   conceptual row in the ifTable appears/disappears as a by-product,\
    \ and\n   an ifIndex value (chosen by the agent) is stored in an appropriate\n\
    \   object in the media-specific MIB.\n"
- title: 3.1.18.  All Values Must be Known
  contents:
  - "3.1.18.  All Values Must be Known\n   There are a number of situations where\
    \ an agent does not know the\n   value of one or more objects for a particular\
    \ interface.  In all such\n   circumstances, an agent MUST NOT instantiate an\
    \ object with an\n   incorrect value; rather, it MUST respond with the appropriate\n\
    \   error/exception condition (e.g., noSuchInstance for SNMPv2).\n   One example\
    \ is where an agent is unable to count the occurrences\n   defined by one (or\
    \ more) of the ifTable counters.  In this\n   circumstance, the agent MUST NOT\
    \ instantiate the particular counter\n   with a value of, say, zero.  To do so\
    \ would be to provide mis-\n   information to a network management application\
    \ reading the zero\n   value, and thereby assuming that there have been no occurrences\
    \ of\n   the event (e.g., no input errors because ifInErrors is always zero).\n\
    \   Sometimes the lack of knowledge of an object's value is temporary.\n   For\
    \ example, when the MTU of an interface is a configured value and a\n   device\
    \ dynamically learns the configured value through (after)\n   exchanging messages\
    \ over the interface (e.g., ATM LAN- Emulation\n   [8]).  In such a case, the\
    \ value is not known until after the ifTable\n   entry has already been created.\
    \  In such a case, the ifTable entry\n   should be created without an instance\
    \ of the object whose value is\n   unknown; later, when the value becomes known,\
    \ the missing object can\n   then be instantiated (e.g., the instance of ifMtu\
    \ is only\n   instantiated once the interface's MTU becomes known).\n   As a result\
    \ of this \"known values\" rule, management applications MUST\n   be able to cope\
    \ with the responses to retrieving the object instances\n   within a conceptual\
    \ row of the ifTable revealing that some of the\n   row's columnar objects are\
    \ missing/not available.\n"
- title: 4.  Media-Specific MIB Applicability
  contents:
  - "4.  Media-Specific MIB Applicability\n   The exact use and semantics of many\
    \ objects in this MIB are open to\n   some interpretation.  This is a result of\
    \ the generic nature of this\n   MIB.  It is not always possible to come up with\
    \ specific,\n   unambiguous, text that covers all cases and yet preserves the\
    \ generic\n   nature of the MIB.\n   Therefore, it is incumbent upon a media-specific\
    \ MIB designer to,\n   wherever necessary, clarify the use of the objects in this\
    \ MIB with\n   respect to the media-specific MIB.\n   Specific areas of clarification\
    \ include\n   Layering Model\n        The media-specific MIB designer MUST completely\
    \ and\n        unambiguously specify the layering model used.  Each individual\n\
    \        sub-layer must be identified, as must the ifStackTable's\n        portrayal\
    \ of the relationship(s) between the sub-layers.\n   Virtual Circuits\n      \
    \  The media-specific MIB designer MUST specify whether virtual\n        circuits\
    \ are assigned entries in the ifTable or not.  If they\n        are, compelling\
    \ rationale must be presented.\n   ifRcvAddressTable\n        The media-specific\
    \ MIB designer MUST specify the applicability\n        of the ifRcvAddressTable.\n\
    \   ifType\n        For each of the ifType values to which the media-specific\
    \ MIB\n        applies, it must specify the mapping of ifType values to media-\n\
    \        specific MIB module(s) and instances of MIB objects within those\n  \
    \      modules.\n   However, wherever this interface MIB is specific in the semantics,\n\
    \   DESCRIPTION, or applicability of objects, the media-specific MIB\n   designer\
    \ MUST NOT change said semantics, DESCRIPTION, or\n   applicability.\n"
- title: 5.  Overview
  contents:
  - "5.  Overview\n   This MIB consists of 4 tables:\n   ifTable\n        This table\
    \ is the ifTable from MIB-II.\n        ifXTable\n        This table contains objects\
    \ that have been added to the\n        Interface MIB as a result of the Interface\
    \ Evolution effort, or\n        replacements for objects of the original (MIB-II)\
    \ ifTable that\n        were deprecated because the semantics of said objects\
    \ have\n        significantly changed.  This table also contains objects that\n\
    \        were previously in the ifExtnsTable.\n   ifStackTable\n        This table\
    \ contains objects that define the relationships among\n        the sub-layers\
    \ of an interface.\n   ifRcvAddressTable\n        This table contains objects\
    \ that are used to define the media-\n        level addresses which this interface\
    \ will receive.  This table\n        is a generic table.  The designers of media-\
    \ specific MIBs must\n        define exactly how this table applies to their specific\
    \ MIB.\n"
- title: 6.  Interfaces Group Definitions
  contents:
  - "6.  Interfaces Group Definitions\n   IF-MIB DEFINITIONS ::= BEGIN\n   IMPORTS\n\
    \       MODULE-IDENTITY, OBJECT-TYPE, Counter32, Gauge32, Counter64,\n       Integer32,\
    \ TimeTicks, mib-2,\n       NOTIFICATION-TYPE                        FROM SNMPv2-SMI\n\
    \       TEXTUAL-CONVENTION, DisplayString,\n       PhysAddress, TruthValue, RowStatus,\n\
    \       TimeStamp, AutonomousType, TestAndIncr   FROM SNMPv2-TC\n       MODULE-COMPLIANCE,\
    \ OBJECT-GROUP          FROM SNMPv2-CONF\n       snmpTraps                   \
    \             FROM SNMPv2-MIB\n       IANAifType                             \
    \  FROM IANAifType-MIB;\n   ifMIB MODULE-IDENTITY\n       LAST-UPDATED \"9611031355Z\"\
    \n       ORGANIZATION \"IETF Interfaces MIB Working Group\"\n       CONTACT-INFO\n\
    \               \"   Keith McCloghrie\n                   Cisco Systems, Inc.\n\
    \                   170 West Tasman Drive\n                   San Jose, CA  95134-1706\n\
    \                   US\n                   408-526-5260\n                   kzm@cisco.com\"\
    \n       DESCRIPTION\n               \"The MIB module to describe generic objects\
    \ for\n               network interface sub-layers.  This MIB is an updated\n\
    \               version of MIB-II's ifTable, and incorporates the\n          \
    \     extensions defined in RFC 1229.\"\n       REVISION      \"9602282155Z\"\n\
    \       DESCRIPTION\n               \"Revisions made by the Interfaces MIB WG.\"\
    \n       REVISION      \"9311082155Z\"\n       DESCRIPTION\n               \"\
    Initial revision, published as part of RFC 1573.\"\n       ::= { mib-2 31 }\n\
    \   ifMIBObjects OBJECT IDENTIFIER ::= { ifMIB 1 }\n   interfaces   OBJECT IDENTIFIER\
    \ ::= { mib-2 2 }\n   OwnerString ::= TEXTUAL-CONVENTION\n       DISPLAY-HINT\
    \ \"255a\"\n       STATUS       current\n       DESCRIPTION\n               \"\
    This data type is used to model an administratively\n               assigned name\
    \ of the owner of a resource.  This\n               information is taken from\
    \ the NVT ASCII character set.\n               It is suggested that this name\
    \ contain one or more of\n               the following: ASCII form of the manager\
    \ station's\n               transport address, management station name (e.g.,\n\
    \               domain name), network management personnel's name,\n         \
    \      location, or phone number.  In some cases the agent\n               itself\
    \ will be the owner of an entry.  In these cases,\n               this string\
    \ shall be set to a string starting with\n               'agent'.\"\n       SYNTAX\
    \       OCTET STRING (SIZE(0..255))\n   -- InterfaceIndex contains the semantics\
    \ of ifIndex and\n   -- should be used for any objects defined on other mib\n\
    \   -- modules that need these semantics.\n   InterfaceIndex ::= TEXTUAL-CONVENTION\n\
    \       DISPLAY-HINT \"d\"\n       STATUS       current\n       DESCRIPTION\n\
    \               \"A unique value, greater than zero, for each interface\n    \
    \           or interface sub-layer in the managed system.  It is\n           \
    \    recommended that values are assigned contiguously\n               starting\
    \ from 1.  The value for each interface sub-\n               layer must remain\
    \ constant at least from one re-\n               initialization of the entity's\
    \ network management\n               system to the next re-initialization.\"\n\
    \       SYNTAX       Integer32 (1..2147483647)\n   InterfaceIndexOrZero ::= TEXTUAL-CONVENTION\n\
    \       DISPLAY-HINT \"d\"\n       STATUS       current\n       DESCRIPTION\n\
    \               \"This textual convention is an extension of the\n           \
    \    InterfaceIndex convention.  The latter defines a\n               greater\
    \ than zero value used to identify an interface\n               or interface sub-layer\
    \ in the managed system.  This\n               extension permits the additional\
    \ value of zero.  the\n               value zero is object-specific and must therefore\
    \ be\n               defined as part of the description of any object which\n\
    \               uses this syntax.  Examples of the usage of zero might\n     \
    \          include situations where interface was unknown, or\n              \
    \ when none or all interfaces need to be referenced.\"\n       SYNTAX       Integer32\
    \ (0..2147483647)\n   ifNumber  OBJECT-TYPE\n       SYNTAX      Integer32\n  \
    \     MAX-ACCESS  read-only\n       STATUS      current\n       DESCRIPTION\n\
    \               \"The number of network interfaces (regardless of their\n    \
    \           current state) present on this system.\"\n       ::= { interfaces\
    \ 1 }\n   ifTableLastChange  OBJECT-TYPE\n       SYNTAX      TimeTicks\n     \
    \  MAX-ACCESS  read-only\n       STATUS      current\n       DESCRIPTION\n   \
    \            \"The value of sysUpTime at the time of the last\n              \
    \ creation or deletion of an entry in the ifTable.  If\n               the number\
    \ of entries has been unchanged since the\n               last re-initialization\
    \ of the local network management\n               subsystem, then this object\
    \ contains a zero value.\"\n       ::= { ifMIBObjects 5 }\n   -- the Interfaces\
    \ table\n   -- The Interfaces table contains information on the entity's\n   --\
    \ interfaces.  Each sub-layer below the internetwork-layer\n   -- of a network\
    \ interface is considered to be an interface.\n   ifTable OBJECT-TYPE\n      \
    \ SYNTAX      SEQUENCE OF IfEntry\n       MAX-ACCESS  not-accessible\n       STATUS\
    \      current\n       DESCRIPTION\n               \"A list of interface entries.\
    \  The number of entries\n               is given by the value of ifNumber.\"\n\
    \       ::= { interfaces 2 }\n   ifEntry OBJECT-TYPE\n       SYNTAX      IfEntry\n\
    \       MAX-ACCESS  not-accessible\n       STATUS      current\n       DESCRIPTION\n\
    \               \"An entry containing management information applicable\n    \
    \           to a particular interface.\"\n       INDEX   { ifIndex }\n       ::=\
    \ { ifTable 1 }\n   IfEntry ::=\n       SEQUENCE {\n           ifIndex       \
    \          InterfaceIndex,\n           ifDescr                 DisplayString,\n\
    \           ifType                  IANAifType,\n           ifMtu            \
    \       Integer32,\n           ifSpeed                 Gauge32,\n           ifPhysAddress\
    \           PhysAddress,\n           ifAdminStatus           INTEGER,\n      \
    \     ifOperStatus            INTEGER,\n           ifLastChange            TimeTicks,\n\
    \           ifInOctets              Counter32,\n           ifInUcastPkts     \
    \      Counter32,\n           ifInNUcastPkts          Counter32,  -- deprecated\n\
    \           ifInDiscards            Counter32,\n           ifInErrors        \
    \      Counter32,\n           ifInUnknownProtos       Counter32,\n           ifOutOctets\
    \             Counter32,\n           ifOutUcastPkts          Counter32,\n    \
    \       ifOutNUcastPkts         Counter32,  -- deprecated\n           ifOutDiscards\
    \           Counter32,\n           ifOutErrors             Counter32,\n      \
    \     ifOutQLen               Gauge32,    -- deprecated\n           ifSpecific\
    \              OBJECT IDENTIFIER -- deprecated\n       }\n   ifIndex OBJECT-TYPE\n\
    \       SYNTAX      InterfaceIndex\n       MAX-ACCESS  read-only\n       STATUS\
    \      current\n       DESCRIPTION\n               \"A unique value, greater than\
    \ zero, for each\n               interface.  It is recommended that values are\
    \ assigned\n               contiguously starting from 1.  The value for each\n\
    \               interface sub-layer must remain constant at least from\n     \
    \          one re-initialization of the entity's network\n               management\
    \ system to the next re-initialization.\"\n       ::= { ifEntry 1 }\n   ifDescr\
    \ OBJECT-TYPE\n       SYNTAX      DisplayString (SIZE (0..255))\n       MAX-ACCESS\
    \  read-only\n       STATUS      current\n       DESCRIPTION\n               \"\
    A textual string containing information about the\n               interface. \
    \ This string should include the name of the\n               manufacturer, the\
    \ product name and the version of the\n               interface hardware/software.\"\
    \n       ::= { ifEntry 2 }\n   ifType OBJECT-TYPE\n       SYNTAX      IANAifType\n\
    \       MAX-ACCESS  read-only\n       STATUS      current\n       DESCRIPTION\n\
    \               \"The type of interface.  Additional values for ifType\n     \
    \          are assigned by the Internet Assigned Numbers\n               Authority\
    \ (IANA), through updating the syntax of the\n               IANAifType textual\
    \ convention.\"\n       ::= { ifEntry 3 }\n   ifMtu OBJECT-TYPE\n       SYNTAX\
    \      Integer32\n       MAX-ACCESS  read-only\n       STATUS      current\n \
    \      DESCRIPTION\n               \"The size of the largest packet which can\
    \ be\n               sent/received on the interface, specified in octets.\n  \
    \             For interfaces that are used for transmitting network\n        \
    \       datagrams, this is the size of the largest network\n               datagram\
    \ that can be sent on the interface.\"\n       ::= { ifEntry 4 }\n   ifSpeed OBJECT-TYPE\n\
    \       SYNTAX      Gauge32\n       MAX-ACCESS  read-only\n       STATUS     \
    \ current\n       DESCRIPTION\n               \"An estimate of the interface's\
    \ current bandwidth in\n               bits per second.  For interfaces which\
    \ do not vary in\n               bandwidth or for those where no accurate estimation\n\
    \               can be made, this object should contain the nominal\n        \
    \       bandwidth.  If the bandwidth of the interface is\n               greater\
    \ than the maximum value reportable by this\n               object then this object\
    \ should report its maximum\n               value (4,294,967,295) and ifHighSpeed\
    \ must be used to\n               report the interace's speed.  For a sub-layer\
    \ which\n               has no concept of bandwidth, this object should be\n \
    \              zero.\"\n       ::= { ifEntry 5 }\n   ifPhysAddress OBJECT-TYPE\n\
    \       SYNTAX      PhysAddress\n       MAX-ACCESS  read-only\n       STATUS \
    \     current\n       DESCRIPTION\n               \"The interface's address at\
    \ its protocol sub-layer.\n               For example, for an 802.x interface,\
    \ this object\n               normally contains a MAC address.  The interface's\n\
    \               media-specific MIB must define the bit and byte\n            \
    \   ordering and the format of the value of this object.\n               For interfaces\
    \ which do not have such an address\n               (e.g., a serial line), this\
    \ object should contain an\n               octet string of zero length.\"\n  \
    \     ::= { ifEntry 6 }\n   ifAdminStatus OBJECT-TYPE\n       SYNTAX  INTEGER\
    \ {\n                   up(1),       -- ready to pass packets\n              \
    \     down(2),\n                   testing(3)   -- in some test mode\n       \
    \        }\n       MAX-ACCESS  read-write\n       STATUS      current\n      \
    \ DESCRIPTION\n               \"The desired state of the interface.  The testing(3)\n\
    \               state indicates that no operational packets can be\n         \
    \      passed.  When a managed system initializes, all\n               interfaces\
    \ start with ifAdminStatus in the down(2)\n               state.  As a result\
    \ of either explicit management\n               action or per configuration information\
    \ retained by\n               the managed system, ifAdminStatus is then changed\
    \ to\n               either the up(1) or testing(3) states (or remains in\n  \
    \             the down(2) state).\"\n       ::= { ifEntry 7 }\n   ifOperStatus\
    \ OBJECT-TYPE\n       SYNTAX  INTEGER {\n                   up(1),        -- ready\
    \ to pass packets\n                   down(2),\n                   testing(3),\
    \   -- in some test mode\n                   unknown(4),   -- status can not be\
    \ determined\n                                 -- for some reason.\n         \
    \          dormant(5),\n                   notPresent(6),    -- some component\
    \ is missing\n                   lowerLayerDown(7) -- down due to state of\n \
    \                                    -- lower-layer interface(s)\n           \
    \    }\n       MAX-ACCESS  read-only\n       STATUS      current\n       DESCRIPTION\n\
    \               \"The current operational state of the interface.  The\n     \
    \          testing(3) state indicates that no operational packets\n          \
    \     can be passed.  If ifAdminStatus is down(2) then\n               ifOperStatus\
    \ should be down(2).  If ifAdminStatus is\n               changed to up(1) then\
    \ ifOperStatus should change to\n               up(1) if the interface is ready\
    \ to transmit and\n               receive network traffic; it should change to\n\
    \               dormant(5) if the interface is waiting for external\n        \
    \       actions (such as a serial line waiting for an incoming\n             \
    \  connection); it should remain in the down(2) state if\n               and only\
    \ if there is a fault that prevents it from\n               going to the up(1)\
    \ state; it should remain in the\n               notPresent(6) state if the interface\
    \ has missing\n               (typically, hardware) components.\"\n       ::=\
    \ { ifEntry 8 }\n   ifLastChange OBJECT-TYPE\n       SYNTAX      TimeTicks\n \
    \      MAX-ACCESS  read-only\n       STATUS      current\n       DESCRIPTION\n\
    \               \"The value of sysUpTime at the time the interface\n         \
    \      entered its current operational state.  If the current\n              \
    \ state was entered prior to the last re-initialization\n               of the\
    \ local network management subsystem, then this\n               object contains\
    \ a zero value.\"\n       ::= { ifEntry 9 }\n   ifInOctets OBJECT-TYPE\n     \
    \  SYNTAX      Counter32\n       MAX-ACCESS  read-only\n       STATUS      current\n\
    \       DESCRIPTION\n               \"The total number of octets received on the\
    \ interface,\n               including framing characters.\n               Discontinuities\
    \ in the value of this counter can occur\n               at re-initialization\
    \ of the management system, and at\n               other times as indicated by\
    \ the value of\n               ifCounterDiscontinuityTime.\"\n       ::= { ifEntry\
    \ 10 }\n   ifInUcastPkts OBJECT-TYPE\n       SYNTAX      Counter32\n       MAX-ACCESS\
    \  read-only\n       STATUS      current\n       DESCRIPTION\n               \"\
    The number of packets, delivered by this sub-layer to\n               a higher\
    \ (sub-)layer, which were not addressed to a\n               multicast or broadcast\
    \ address at this sub-layer.\n               Discontinuities in the value of this\
    \ counter can occur\n               at re-initialization of the management system,\
    \ and at\n               other times as indicated by the value of\n          \
    \     ifCounterDiscontinuityTime.\"\n       ::= { ifEntry 11 }\n   ifInNUcastPkts\
    \ OBJECT-TYPE\n       SYNTAX  Counter32\n       MAX-ACCESS  read-only\n      \
    \ STATUS      deprecated\n       DESCRIPTION\n               \"The number of packets,\
    \ delivered by this sub-layer to\n               a higher (sub-)layer, which were\
    \ addressed to a\n               multicast or broadcast address at this sub-layer.\n\
    \               Discontinuities in the value of this counter can occur\n     \
    \          at re-initialization of the management system, and at\n           \
    \    other times as indicated by the value of\n               ifCounterDiscontinuityTime.\n\
    \               This object is deprecated in favour of\n               ifInMulticastPkts\
    \ and ifInBroadcastPkts.\"\n       ::= { ifEntry 12 }\n   ifInDiscards OBJECT-TYPE\n\
    \       SYNTAX      Counter32\n       MAX-ACCESS  read-only\n       STATUS   \
    \   current\n       DESCRIPTION\n               \"The number of inbound packets\
    \ which were chosen to be\n               discarded even though no errors had\
    \ been detected to\n               prevent their being deliverable to a higher-layer\n\
    \               protocol.  One possible reason for discarding such a\n       \
    \        packet could be to free up buffer space.\n               Discontinuities\
    \ in the value of this counter can occur\n               at re-initialization\
    \ of the management system, and at\n               other times as indicated by\
    \ the value of\n               ifCounterDiscontinuityTime.\"\n       ::= { ifEntry\
    \ 13 }\n   ifInErrors OBJECT-TYPE\n       SYNTAX      Counter32\n       MAX-ACCESS\
    \  read-only\n       STATUS      current\n       DESCRIPTION\n               \"\
    For packet-oriented interfaces, the number of inbound\n               packets\
    \ that contained errors preventing them from\n               being deliverable\
    \ to a higher-layer protocol.  For\n               character-oriented or fixed-length\
    \ interfaces, the\n               number of inbound transmission units that contained\n\
    \               errors preventing them from being deliverable to a\n         \
    \      higher-layer protocol.\n               Discontinuities in the value of\
    \ this counter can occur\n               at re-initialization of the management\
    \ system, and at\n               other times as indicated by the value of\n  \
    \             ifCounterDiscontinuityTime.\"\n       ::= { ifEntry 14 }\n   ifInUnknownProtos\
    \ OBJECT-TYPE\n       SYNTAX      Counter32\n       MAX-ACCESS  read-only\n  \
    \     STATUS      current\n       DESCRIPTION\n               \"For packet-oriented\
    \ interfaces, the number of packets\n               received via the interface\
    \ which were discarded\n               because of an unknown or unsupported protocol.\
    \  For\n               character-oriented or fixed-length interfaces that\n  \
    \             support protocol multiplexing the number of\n               transmission\
    \ units received via the interface which\n               were discarded because\
    \ of an unknown or unsupported\n               protocol.  For any interface that\
    \ does not support\n               protocol multiplexing, this counter will always\
    \ be 0.\n               Discontinuities in the value of this counter can occur\n\
    \               at re-initialization of the management system, and at\n      \
    \         other times as indicated by the value of\n               ifCounterDiscontinuityTime.\"\
    \n       ::= { ifEntry 15 }\n   ifOutOctets OBJECT-TYPE\n       SYNTAX      Counter32\n\
    \       MAX-ACCESS  read-only\n       STATUS      current\n       DESCRIPTION\n\
    \               \"The total number of octets transmitted out of the\n        \
    \       interface, including framing characters.\n               Discontinuities\
    \ in the value of this counter can occur\n               at re-initialization\
    \ of the management system, and at\n               other times as indicated by\
    \ the value of\n               ifCounterDiscontinuityTime.\"\n       ::= { ifEntry\
    \ 16 }\n   ifOutUcastPkts OBJECT-TYPE\n       SYNTAX      Counter32\n       MAX-ACCESS\
    \  read-only\n       STATUS      current\n       DESCRIPTION\n               \"\
    The total number of packets that higher-level\n               protocols requested\
    \ be transmitted, and which were not\n               addressed to a multicast\
    \ or broadcast address at this\n               sub-layer, including those that\
    \ were discarded or not\n               sent.\n               Discontinuities\
    \ in the value of this counter can occur\n               at re-initialization\
    \ of the management system, and at\n               other times as indicated by\
    \ the value of\n               ifCounterDiscontinuityTime.\"\n       ::= { ifEntry\
    \ 17 }\n   ifOutNUcastPkts OBJECT-TYPE\n       SYNTAX      Counter32\n       MAX-ACCESS\
    \  read-only\n       STATUS      deprecated\n       DESCRIPTION\n            \
    \   \"The total number of packets that higher-level\n               protocols\
    \ requested be transmitted, and which were\n               addressed to a multicast\
    \ or broadcast address at this\n               sub-layer, including those that\
    \ were discarded or not\n               sent.\n               Discontinuities\
    \ in the value of this counter can occur\n               at re-initialization\
    \ of the management system, and at\n               other times as indicated by\
    \ the value of\n               ifCounterDiscontinuityTime.\n               This\
    \ object is deprecated in favour of\n               ifOutMulticastPkts and ifOutBroadcastPkts.\"\
    \n       ::= { ifEntry 18 }\n   ifOutDiscards OBJECT-TYPE\n       SYNTAX     \
    \ Counter32\n       MAX-ACCESS  read-only\n       STATUS      current\n      \
    \ DESCRIPTION\n               \"The number of outbound packets which were chosen\
    \ to\n               be discarded even though no errors had been detected\n  \
    \             to prevent their being transmitted.  One possible\n            \
    \   reason for discarding such a packet could be to free\n               up buffer\
    \ space.\n               Discontinuities in the value of this counter can occur\n\
    \               at re-initialization of the management system, and at\n      \
    \         other times as indicated by the value of\n               ifCounterDiscontinuityTime.\"\
    \n       ::= { ifEntry 19 }\n   ifOutErrors OBJECT-TYPE\n       SYNTAX      Counter32\n\
    \       MAX-ACCESS  read-only\n       STATUS      current\n       DESCRIPTION\n\
    \               \"For packet-oriented interfaces, the number of\n            \
    \   outbound packets that could not be transmitted because\n               of\
    \ errors.  For character-oriented or fixed-length\n               interfaces,\
    \ the number of outbound transmission units\n               that could not be\
    \ transmitted because of errors.\n               Discontinuities in the value\
    \ of this counter can occur\n               at re-initialization of the management\
    \ system, and at\n               other times as indicated by the value of\n  \
    \             ifCounterDiscontinuityTime.\"\n       ::= { ifEntry 20 }\n   ifOutQLen\
    \ OBJECT-TYPE\n       SYNTAX      Gauge32\n       MAX-ACCESS  read-only\n    \
    \   STATUS      deprecated\n       DESCRIPTION\n               \"The length of\
    \ the output packet queue (in packets).\"\n       ::= { ifEntry 21 }\n   ifSpecific\
    \ OBJECT-TYPE\n       SYNTAX      OBJECT IDENTIFIER\n       MAX-ACCESS  read-only\n\
    \       STATUS      deprecated\n       DESCRIPTION\n               \"A reference\
    \ to MIB definitions specific to the\n               particular media being used\
    \ to realize the interface.\n               It is recommended that this value\
    \ point to an instance\n               of a MIB object in the media-specific MIB,\
    \ i.e., that\n               this object have the semantics associated with the\n\
    \               InstancePointer textual convention defined in RFC\n          \
    \     1903.  In fact, it is recommended that the media-\n               specific\
    \ MIB specify what value ifSpecific should/can\n               take for values\
    \ of ifType.  If no MIB definitions\n               specific to the particular\
    \ media are available, the\n               value should be set to the OBJECT IDENTIFIER\
    \ { 0 0 }.\"\n       ::= { ifEntry 22 }\n   --\n   --   Extension to the interface\
    \ table\n   --\n   -- This table replaces the ifExtnsTable table.\n   --\n   ifXTable\
    \        OBJECT-TYPE\n       SYNTAX      SEQUENCE OF IfXEntry\n       MAX-ACCESS\
    \  not-accessible\n       STATUS      current\n       DESCRIPTION\n          \
    \     \"A list of interface entries.  The number of entries\n               is\
    \ given by the value of ifNumber.  This table\n               contains additional\
    \ objects for the interface table.\"\n       ::= { ifMIBObjects 1 }\n   ifXEntry\
    \        OBJECT-TYPE\n       SYNTAX      IfXEntry\n       MAX-ACCESS  not-accessible\n\
    \       STATUS      current\n       DESCRIPTION\n               \"An entry containing\
    \ additional management information\n               applicable to a particular\
    \ interface.\"\n       AUGMENTS    { ifEntry }\n       ::= { ifXTable 1 }\n  \
    \ IfXEntry ::=\n       SEQUENCE {\n           ifName                  DisplayString,\n\
    \           ifInMulticastPkts       Counter32,\n           ifInBroadcastPkts \
    \      Counter32,\n           ifOutMulticastPkts      Counter32,\n           ifOutBroadcastPkts\
    \      Counter32,\n           ifHCInOctets            Counter64,\n           ifHCInUcastPkts\
    \         Counter64,\n           ifHCInMulticastPkts     Counter64,\n        \
    \   ifHCInBroadcastPkts     Counter64,\n           ifHCOutOctets           Counter64,\n\
    \           ifHCOutUcastPkts        Counter64,\n           ifHCOutMulticastPkts\
    \    Counter64,\n           ifHCOutBroadcastPkts    Counter64,\n           ifLinkUpDownTrapEnable\
    \  INTEGER,\n           ifHighSpeed             Gauge32,\n           ifPromiscuousMode\
    \       TruthValue,\n           ifConnectorPresent      TruthValue,\n        \
    \   ifAlias                 DisplayString,\n           ifCounterDiscontinuityTime\
    \ TimeStamp\n       }\n   ifName OBJECT-TYPE\n       SYNTAX      DisplayString\n\
    \       MAX-ACCESS  read-only\n       STATUS      current\n       DESCRIPTION\n\
    \               \"The textual name of the interface.  The value of this\n    \
    \           object should be the name of the interface as assigned\n         \
    \      by the local device and should be suitable for use in\n               commands\
    \ entered at the device's `console'.  This\n               might be a text name,\
    \ such as `le0' or a simple port\n               number, such as `1', depending\
    \ on the interface naming\n               syntax of the device.  If several entries\
    \ in the\n               ifTable together represent a single interface as named\n\
    \               by the device, then each will have the same value of\n       \
    \        ifName.  Note that for an agent which responds to SNMP\n            \
    \   queries concerning an interface on some other\n               (proxied) device,\
    \ then the value of ifName for such an\n               interface is the proxied\
    \ device's local name for it.\n               If there is no local name, or this\
    \ object is otherwise\n               not applicable, then this object contains\
    \ a zero-\n               length string.\"\n       ::= { ifXEntry 1 }\n   ifInMulticastPkts\
    \ OBJECT-TYPE\n       SYNTAX      Counter32\n       MAX-ACCESS  read-only\n  \
    \     STATUS      current\n       DESCRIPTION\n               \"The number of\
    \ packets, delivered by this sub-layer to\n               a higher (sub-)layer,\
    \ which were addressed to a\n               multicast address at this sub-layer.\
    \  For a MAC layer\n               protocol, this includes both Group and Functional\n\
    \               addresses.\n               Discontinuities in the value of this\
    \ counter can occur\n               at re-initialization of the management system,\
    \ and at\n               other times as indicated by the value of\n          \
    \     ifCounterDiscontinuityTime.\"\n       ::= { ifXEntry 2 }\n   ifInBroadcastPkts\
    \ OBJECT-TYPE\n       SYNTAX      Counter32\n       MAX-ACCESS  read-only\n  \
    \     STATUS      current\n       DESCRIPTION\n               \"The number of\
    \ packets, delivered by this sub-layer to\n               a higher (sub-)layer,\
    \ which were addressed to a\n               broadcast address at this sub-layer.\n\
    \               Discontinuities in the value of this counter can occur\n     \
    \          at re-initialization of the management system, and at\n           \
    \    other times as indicated by the value of\n               ifCounterDiscontinuityTime.\"\
    \n       ::= { ifXEntry 3 }\n   ifOutMulticastPkts OBJECT-TYPE\n       SYNTAX\
    \      Counter32\n       MAX-ACCESS  read-only\n       STATUS      current\n \
    \      DESCRIPTION\n               \"The total number of packets that higher-level\n\
    \               protocols requested be transmitted, and which were\n         \
    \      addressed to a multicast address at this sub-layer,\n               including\
    \ those that were discarded or not sent.  For\n               a MAC layer protocol,\
    \ this includes both Group and\n               Functional addresses.\n       \
    \        Discontinuities in the value of this counter can occur\n            \
    \   at re-initialization of the management system, and at\n               other\
    \ times as indicated by the value of\n               ifCounterDiscontinuityTime.\"\
    \n       ::= { ifXEntry 4 }\n   ifOutBroadcastPkts OBJECT-TYPE\n       SYNTAX\
    \      Counter32\n       MAX-ACCESS  read-only\n       STATUS      current\n \
    \      DESCRIPTION\n               \"The total number of packets that higher-level\n\
    \               protocols requested be transmitted, and which were\n         \
    \      addressed to a broadcast address at this sub-layer,\n               including\
    \ those that were discarded or not sent.\n               Discontinuities in the\
    \ value of this counter can occur\n               at re-initialization of the\
    \ management system, and at\n               other times as indicated by the value\
    \ of\n               ifCounterDiscontinuityTime.\"\n       ::= { ifXEntry 5 }\n\
    \   --\n   -- High Capacity Counter objects.  These objects are all\n   -- 64\
    \ bit versions of the \"basic\" ifTable counters.  These\n   -- objects all have\
    \ the same basic semantics as their 32-bit\n   -- counterparts, however, their\
    \ syntax has been extended\n   -- to 64 bits.\n   --\n   ifHCInOctets OBJECT-TYPE\n\
    \       SYNTAX      Counter64\n       MAX-ACCESS  read-only\n       STATUS   \
    \   current\n       DESCRIPTION\n               \"The total number of octets received\
    \ on the interface,\n               including framing characters.  This object\
    \ is a 64-bit\n               version of ifInOctets.\n               Discontinuities\
    \ in the value of this counter can occur\n               at re-initialization\
    \ of the management system, and at\n               other times as indicated by\
    \ the value of\n               ifCounterDiscontinuityTime.\"\n       ::= { ifXEntry\
    \ 6 }\n   ifHCInUcastPkts OBJECT-TYPE\n       SYNTAX      Counter64\n       MAX-ACCESS\
    \  read-only\n       STATUS      current\n       DESCRIPTION\n               \"\
    The number of packets, delivered by this sub-layer to\n               a higher\
    \ (sub-)layer, which were not addressed to a\n               multicast or broadcast\
    \ address at this sub-layer.\n               This object is a 64-bit version of\
    \ ifInUcastPkts.\n               Discontinuities in the value of this counter\
    \ can occur\n               at re-initialization of the management system, and\
    \ at\n               other times as indicated by the value of\n              \
    \ ifCounterDiscontinuityTime.\"\n       ::= { ifXEntry 7 }\n   ifHCInMulticastPkts\
    \ OBJECT-TYPE\n       SYNTAX      Counter64\n       MAX-ACCESS  read-only\n  \
    \     STATUS      current\n       DESCRIPTION\n               \"The number of\
    \ packets, delivered by this sub-layer to\n               a higher (sub-)layer,\
    \ which were addressed to a\n               multicast address at this sub-layer.\
    \  For a MAC layer\n               protocol, this includes both Group and Functional\n\
    \               addresses.  This object is a 64-bit version of\n             \
    \  ifInMulticastPkts.\n               Discontinuities in the value of this counter\
    \ can occur\n               at re-initialization of the management system, and\
    \ at\n               other times as indicated by the value of\n              \
    \ ifCounterDiscontinuityTime.\"\n       ::= { ifXEntry 8 }\n   ifHCInBroadcastPkts\
    \ OBJECT-TYPE\n       SYNTAX      Counter64\n       MAX-ACCESS  read-only\n  \
    \     STATUS      current\n       DESCRIPTION\n               \"The number of\
    \ packets, delivered by this sub-layer to\n               a higher (sub-)layer,\
    \ which were addressed to a\n               broadcast address at this sub-layer.\
    \  This object is a\n               64-bit version of ifInBroadcastPkts.\n   \
    \            Discontinuities in the value of this counter can occur\n        \
    \       at re-initialization of the management system, and at\n              \
    \ other times as indicated by the value of\n               ifCounterDiscontinuityTime.\"\
    \n       ::= { ifXEntry 9 }\n   ifHCOutOctets OBJECT-TYPE\n       SYNTAX     \
    \ Counter64\n       MAX-ACCESS  read-only\n       STATUS      current\n      \
    \ DESCRIPTION\n               \"The total number of octets transmitted out of\
    \ the\n               interface, including framing characters.  This object\n\
    \               is a 64-bit version of ifOutOctets.\n               Discontinuities\
    \ in the value of this counter can occur\n               at re-initialization\
    \ of the management system, and at\n               other times as indicated by\
    \ the value of\n               ifCounterDiscontinuityTime.\"\n       ::= { ifXEntry\
    \ 10 }\n   ifHCOutUcastPkts OBJECT-TYPE\n       SYNTAX      Counter64\n      \
    \ MAX-ACCESS  read-only\n       STATUS      current\n       DESCRIPTION\n    \
    \           \"The total number of packets that higher-level\n               protocols\
    \ requested be transmitted, and which were not\n               addressed to a\
    \ multicast or broadcast address at this\n               sub-layer, including\
    \ those that were discarded or not\n               sent.  This object is a 64-bit\
    \ version of\n               ifOutUcastPkts.\n               Discontinuities in\
    \ the value of this counter can occur\n               at re-initialization of\
    \ the management system, and at\n               other times as indicated by the\
    \ value of\n               ifCounterDiscontinuityTime.\"\n       ::= { ifXEntry\
    \ 11 }\n   ifHCOutMulticastPkts OBJECT-TYPE\n       SYNTAX      Counter64\n  \
    \     MAX-ACCESS  read-only\n       STATUS      current\n       DESCRIPTION\n\
    \               \"The total number of packets that higher-level\n            \
    \   protocols requested be transmitted, and which were\n               addressed\
    \ to a multicast address at this sub-layer,\n               including those that\
    \ were discarded or not sent.  For\n               a MAC layer protocol, this\
    \ includes both Group and\n               Functional addresses.  This object is\
    \ a 64-bit version\n               of ifOutMulticastPkts.\n               Discontinuities\
    \ in the value of this counter can occur\n               at re-initialization\
    \ of the management system, and at\n               other times as indicated by\
    \ the value of\n               ifCounterDiscontinuityTime.\"\n       ::= { ifXEntry\
    \ 12 }\n   ifHCOutBroadcastPkts OBJECT-TYPE\n       SYNTAX      Counter64\n  \
    \     MAX-ACCESS  read-only\n       STATUS      current\n       DESCRIPTION\n\
    \               \"The total number of packets that higher-level\n            \
    \   protocols requested be transmitted, and which were\n               addressed\
    \ to a broadcast address at this sub-layer,\n               including those that\
    \ were discarded or not sent.  This\n               object is a 64-bit version\
    \ of ifOutBroadcastPkts.\n               Discontinuities in the value of this\
    \ counter can occur\n               at re-initialization of the management system,\
    \ and at\n               other times as indicated by the value of\n          \
    \     ifCounterDiscontinuityTime.\"\n       ::= { ifXEntry 13 }\n   ifLinkUpDownTrapEnable\
    \  OBJECT-TYPE\n       SYNTAX      INTEGER { enabled(1), disabled(2) }\n     \
    \  MAX-ACCESS  read-write\n       STATUS      current\n       DESCRIPTION\n  \
    \             \"Indicates whether linkUp/linkDown traps should be\n          \
    \     generated for this interface.\n               By default, this object should\
    \ have the value\n               enabled(1) for interfaces which do not operate\
    \ on\n               'top' of any other interface (as defined in the\n       \
    \        ifStackTable), and disabled(2) otherwise.\"\n       ::= { ifXEntry 14\
    \ }\n   ifHighSpeed OBJECT-TYPE\n       SYNTAX      Gauge32\n       MAX-ACCESS\
    \  read-only\n       STATUS      current\n       DESCRIPTION\n               \"\
    An estimate of the interface's current bandwidth in\n               units of 1,000,000\
    \ bits per second.  If this object\n               reports a value of `n' then\
    \ the speed of the interface\n               is somewhere in the range of `n-500,000'\
    \ to\n               `n+499,999'.  For interfaces which do not vary in\n     \
    \          bandwidth or for those where no accurate estimation\n             \
    \  can be made, this object should contain the nominal\n               bandwidth.\
    \  For a sub-layer which has no concept of\n               bandwidth, this object\
    \ should be zero.\"\n       ::= { ifXEntry 15 }\n   ifPromiscuousMode  OBJECT-TYPE\n\
    \       SYNTAX      TruthValue\n       MAX-ACCESS  read-write\n       STATUS \
    \     current\n       DESCRIPTION\n               \"This object has a value of\
    \ false(2) if this interface\n               only accepts packets/frames that\
    \ are addressed to this\n               station.  This object has a value of true(1)\
    \ when the\n               station accepts all packets/frames transmitted on the\n\
    \               media.  The value true(1) is only legal on certain\n         \
    \      types of media.  If legal, setting this object to a\n               value\
    \ of true(1) may require the interface to be reset\n               before becoming\
    \ effective.\n               The value of ifPromiscuousMode does not affect the\n\
    \               reception of broadcast and multicast packets/frames by\n     \
    \          the interface.\"\n       ::= { ifXEntry 16 }\n   ifConnectorPresent\
    \   OBJECT-TYPE\n       SYNTAX      TruthValue\n       MAX-ACCESS  read-only\n\
    \       STATUS      current\n       DESCRIPTION\n               \"This object\
    \ has the value 'true(1)' if the interface\n               sublayer has a physical\
    \ connector and the value\n               'false(2)' otherwise.\"\n       ::=\
    \ { ifXEntry 17 }\n   ifAlias   OBJECT-TYPE\n       SYNTAX      DisplayString\
    \ (SIZE(0..64))\n       MAX-ACCESS  read-write\n       STATUS      current\n \
    \      DESCRIPTION\n               \"This object is an 'alias' name for the interface\
    \ as\n               specified by a network manager, and provides a non-\n   \
    \            volatile 'handle' for the interface.\n               On the first\
    \ instantiation of an interface, the value\n               of ifAlias associated\
    \ with that interface is the\n               zero-length string.  As and when\
    \ a value is written\n               into an instance of ifAlias through a network\n\
    \               management set operation, then the agent must retain\n       \
    \        the supplied value in the ifAlias instance associated\n             \
    \  with the same interface for as long as that interface\n               remains\
    \ instantiated, including across all re-\n               initializations/reboots\
    \ of the network management\n               system, including those which result\
    \ in a change of\n               the interface's ifIndex value.\n            \
    \   An example of the value which a network manager might\n               store\
    \ in this object for a WAN interface is the\n               (Telco's) circuit\
    \ number/identifier of the interface.\n               Some agents may support\
    \ write-access only for\n               interfaces having particular values of\
    \ ifType.  An\n               agent which supports write access to this object\
    \ is\n               required to keep the value in non-volatile storage,\n   \
    \            but it may limit the length of new values depending on\n        \
    \       how much storage is already occupied by the current\n               values\
    \ for other interfaces.\"\n       ::= { ifXEntry 18 }\n   ifCounterDiscontinuityTime\
    \ OBJECT-TYPE\n       SYNTAX      TimeStamp\n       MAX-ACCESS  read-only\n  \
    \     STATUS      current\n       DESCRIPTION\n               \"The value of sysUpTime\
    \ on the most recent occasion at\n               which any one or more of this\
    \ interface's counters\n               suffered a discontinuity.  The relevant\
    \ counters are\n               the specific instances associated with this interface\n\
    \               of any Counter32 or Counter64 object contained in the\n      \
    \         ifTable or ifXTable.  If no such discontinuities have\n            \
    \   occurred since the last re-initialization of the local\n               management\
    \ subsystem, then this object contains a zero\n               value.\"\n     \
    \  ::= { ifXEntry 19 }\n   --           The Interface Stack Group\n   --\n   --\
    \ Implementation of this group is mandatory for all systems\n   --\n   ifStackTable\
    \  OBJECT-TYPE\n        SYNTAX        SEQUENCE OF IfStackEntry\n        MAX-ACCESS\
    \    not-accessible\n        STATUS        current\n        DESCRIPTION\n    \
    \           \"The table containing information on the relationships\n        \
    \       between the multiple sub-layers of network interfaces.\n             \
    \  In particular, it contains information on which sub-\n               layers\
    \ run 'on top of' which other sub-layers, where\n               each sub-layer\
    \ corresponds to a conceptual row in the\n               ifTable.  For example,\
    \ when the sub-layer with ifIndex\n               value x runs over the sub-layer\
    \ with ifIndex value y,\n               then this table contains:\n          \
    \       ifStackStatus.x.y=active\n               For each ifIndex value, I, which\
    \ identifies an active\n               interface, there are always at least two\
    \ instantiated\n               rows in this table associated with I.  For one\
    \ of\n               these rows, I is the value of ifStackHigherLayer; for\n \
    \              the other, I is the value of ifStackLowerLayer.  (If I\n      \
    \         is not involved in multiplexing, then these are the\n              \
    \ only two rows associated with I.)\n               For example, two rows exist\
    \ even for an interface\n               which has no others stacked on top or\
    \ below it:\n                 ifStackStatus.0.x=active\n                 ifStackStatus.x.0=active\
    \ \"\n        ::= { ifMIBObjects 2 }\n   ifStackEntry  OBJECT-TYPE\n        SYNTAX\
    \        IfStackEntry\n        MAX-ACCESS    not-accessible\n        STATUS  \
    \      current\n        DESCRIPTION\n               \"Information on a particular\
    \ relationship between two\n               sub-layers, specifying that one sub-layer\
    \ runs on\n               'top' of the other sub-layer.  Each sub-layer\n    \
    \           corresponds to a conceptual row in the ifTable.\"\n        INDEX {\
    \ ifStackHigherLayer, ifStackLowerLayer }\n        ::= { ifStackTable 1 }\n  \
    \ IfStackEntry ::=\n       SEQUENCE {\n           ifStackHigherLayer  Integer32,\n\
    \           ifStackLowerLayer   Integer32,\n           ifStackStatus       RowStatus\n\
    \        }\n   ifStackHigherLayer  OBJECT-TYPE\n        SYNTAX        Integer32\n\
    \        MAX-ACCESS    not-accessible\n        STATUS        current\n       \
    \ DESCRIPTION\n               \"The value of ifIndex corresponding to the higher\n\
    \               sub-layer of the relationship, i.e., the sub-layer\n         \
    \      which runs on 'top' of the sub-layer identified by the\n              \
    \ corresponding instance of ifStackLowerLayer.  If there\n               is no\
    \ higher sub-layer (below the internetwork layer),\n               then this object\
    \ has the value 0.\"\n        ::= { ifStackEntry 1 }\n   ifStackLowerLayer  OBJECT-TYPE\n\
    \        SYNTAX        Integer32\n        MAX-ACCESS    not-accessible\n     \
    \   STATUS        current\n        DESCRIPTION\n               \"The value of\
    \ ifIndex corresponding to the lower sub-\n               layer of the relationship,\
    \ i.e., the sub-layer which\n               runs 'below' the sub-layer identified\
    \ by the\n               corresponding instance of ifStackHigherLayer.  If\n \
    \              there is no lower sub-layer, then this object has the\n       \
    \        value 0.\"\n        ::= { ifStackEntry 2 }\n   ifStackStatus  OBJECT-TYPE\n\
    \       SYNTAX         RowStatus\n       MAX-ACCESS     read-create\n       STATUS\
    \         current\n       DESCRIPTION\n               \"The status of the relationship\
    \ between two sub-\n               layers.\n               Changing the value\
    \ of this object from 'active' to\n               'notInService' or 'destroy'\
    \ will likely have\n               consequences up and down the interface stack.\
    \  Thus,\n               write access to this object is likely to be\n       \
    \        inappropriate for some types of interfaces, and many\n              \
    \ implementations will choose not to support write-\n               access for\
    \ any type of interface.\"\n       ::= { ifStackEntry 3 }\n   ifStackLastChange\
    \ OBJECT-TYPE\n       SYNTAX         TimeTicks\n       MAX-ACCESS     read-only\n\
    \       STATUS         current\n       DESCRIPTION\n               \"The value\
    \ of sysUpTime at the time of the last change\n               of the (whole) interface\
    \ stack.  A change of the\n               interface stack is defined to be any\
    \ creation,\n               deletion, or change in value of any instance of\n\
    \               ifStackStatus.  If the interface stack has been\n            \
    \   unchanged since the last re-initialization of the\n               local network\
    \ management subsystem, then this object\n               contains a zero value.\"\
    \n       ::= { ifMIBObjects 6 }\n   --   Generic Receive Address Table\n   --\n\
    \   -- This group of objects is mandatory for all types of\n   -- interfaces which\
    \ can receive packets/frames addressed to\n   -- more than one address.\n   --\n\
    \   -- This table replaces the ifExtnsRcvAddr table.  The main\n   -- difference\
    \ is that this table makes use of the RowStatus\n   -- textual convention, while\
    \ ifExtnsRcvAddr did not.\n   ifRcvAddressTable  OBJECT-TYPE\n       SYNTAX  \
    \    SEQUENCE OF IfRcvAddressEntry\n       MAX-ACCESS  not-accessible\n      \
    \ STATUS      current\n       DESCRIPTION\n               \"This table contains\
    \ an entry for each address\n               (broadcast, multicast, or uni-cast)\
    \ for which the\n               system will receive packets/frames on a particular\n\
    \               interface, except as follows:\n               - for an interface\
    \ operating in promiscuous mode,\n               entries are only required for\
    \ those addresses for\n               which the system would receive frames were\
    \ it not\n               operating in promiscuous mode.\n               - for\
    \ 802.5 functional addresses, only one entry is\n               required, for\
    \ the address which has the functional\n               address bit ANDed with\
    \ the bit mask of all functional\n               addresses for which the interface\
    \ will accept frames.\n               A system is normally able to use any unicast\
    \ address\n               which corresponds to an entry in this table as a\n \
    \              source address.\"\n       ::= { ifMIBObjects 4 }\n   ifRcvAddressEntry\
    \  OBJECT-TYPE\n       SYNTAX      IfRcvAddressEntry\n       MAX-ACCESS  not-accessible\n\
    \       STATUS      current\n       DESCRIPTION\n               \"A list of objects\
    \ identifying an address for which\n               the system will accept packets/frames\
    \ on the\n               particular interface identified by the index value\n\
    \               ifIndex.\"\n       INDEX  { ifIndex, ifRcvAddressAddress }\n \
    \      ::= { ifRcvAddressTable 1 }\n   IfRcvAddressEntry ::=\n       SEQUENCE\
    \ {\n           ifRcvAddressAddress   PhysAddress,\n           ifRcvAddressStatus\
    \    RowStatus,\n           ifRcvAddressType      INTEGER\n       }\n   ifRcvAddressAddress\
    \ OBJECT-TYPE\n       SYNTAX      PhysAddress\n       MAX-ACCESS  not-accessible\n\
    \       STATUS      current\n       DESCRIPTION\n               \"An address for\
    \ which the system will accept\n               packets/frames on this entry's\
    \ interface.\"\n       ::= { ifRcvAddressEntry 1 }\n   ifRcvAddressStatus OBJECT-TYPE\n\
    \       SYNTAX      RowStatus\n       MAX-ACCESS  read-create\n       STATUS \
    \     current\n       DESCRIPTION\n               \"This object is used to create\
    \ and delete rows in the\n               ifRcvAddressTable.\"\n       ::= { ifRcvAddressEntry\
    \ 2 }\n   ifRcvAddressType OBJECT-TYPE\n       SYNTAX      INTEGER {\n       \
    \                other(1),\n                       volatile(2),\n            \
    \           nonVolatile(3)\n                   }\n       MAX-ACCESS  read-create\n\
    \       STATUS      current\n       DESCRIPTION\n               \"This object\
    \ has the value nonVolatile(3) for those\n               entries in the table\
    \ which are valid and will not be\n               deleted by the next restart\
    \ of the managed system.\n               Entries having the value volatile(2)\
    \ are valid and\n               exist, but have not been saved, so that will not\
    \ exist\n               after the next restart of the managed system.  Entries\n\
    \               having the value other(1) are valid and exist but are\n      \
    \         not classified as to whether they will continue to\n               exist\
    \ after the next restart.\"\n       DEFVAL  { volatile }\n       ::= { ifRcvAddressEntry\
    \ 3 }\n   -- definition of interface-related traps.\n   linkDown NOTIFICATION-TYPE\n\
    \           OBJECTS { ifIndex, ifAdminStatus, ifOperStatus }\n           STATUS\
    \  current\n           DESCRIPTION\n               \"A linkDown trap signifies\
    \ that the SNMPv2 entity,\n               acting in an agent role, has detected\
    \ that the\n               ifOperStatus object for one of its communication links\n\
    \               is about to enter the down state from some other state\n     \
    \          (but not from the notPresent state).  This other state\n          \
    \     is indicated by the included value of ifOperStatus.\"\n       ::= { snmpTraps\
    \ 3 }\n   linkUp NOTIFICATION-TYPE\n           OBJECTS { ifIndex, ifAdminStatus,\
    \ ifOperStatus }\n           STATUS  current\n           DESCRIPTION\n       \
    \        \"A linkDown trap signifies that the SNMPv2 entity,\n               acting\
    \ in an agent role, has detected that the\n               ifOperStatus object\
    \ for one of its communication links\n               left the down state and transitioned\
    \ into some other\n               state (but not into the notPresent state). \
    \ This other\n               state is indicated by the included value of\n   \
    \            ifOperStatus.\"\n       ::= { snmpTraps 4 }\n   -- conformance information\n\
    \   ifConformance OBJECT IDENTIFIER ::= { ifMIB 2 }\n   ifGroups      OBJECT IDENTIFIER\
    \ ::= { ifConformance 1 }\n   ifCompliances OBJECT IDENTIFIER ::= { ifConformance\
    \ 2 }\n   -- compliance statements\n   ifCompliance2 MODULE-COMPLIANCE\n     \
    \  STATUS  current\n       DESCRIPTION\n               \"The compliance statement\
    \ for SNMPv2 entities which\n               have network interfaces.\"\n     \
    \  MODULE  -- this module\n           MANDATORY-GROUPS { ifGeneralInformationGroup,\
    \ ifStackGroup2,\n                              ifCounterDiscontinuityGroup }\n\
    \           GROUP       ifFixedLengthGroup\n           DESCRIPTION\n         \
    \      \"This group is mandatory for all network interfaces\n               which\
    \ are character-oriented or transmit data in\n               fixed-length transmission\
    \ units.\"\n           GROUP       ifHCFixedLengthGroup\n           DESCRIPTION\n\
    \               \"This group is mandatory only for those network\n           \
    \    interfaces which are character-oriented or transmit\n               data\
    \ in fixed-length transmission units, and for which\n               the value\
    \ of the corresponding instance of ifSpeed is\n               greater than 20,000,000\
    \ bits/second.\"\n           GROUP       ifPacketGroup\n           DESCRIPTION\n\
    \               \"This group is mandatory for all network interfaces\n       \
    \        which are packet-oriented.\"\n           GROUP       ifHCPacketGroup\n\
    \           DESCRIPTION\n               \"This group is mandatory only for those\
    \ network\n               interfaces which are packet-oriented and for which the\n\
    \               value of the corresponding instance of ifSpeed is\n          \
    \     greater than 650,000,000 bits/second.\"\n           GROUP       ifRcvAddressGroup\n\
    \           DESCRIPTION\n               \"The applicability of this group MUST\
    \ be defined by\n               the media-specific MIBs.  Media-specific MIBs\
    \ must\n               define the exact meaning, use, and semantics of the\n \
    \              addresses in this group.\"\n           OBJECT      ifLinkUpDownTrapEnable\n\
    \           MIN-ACCESS  read-only\n           DESCRIPTION\n               \"Write\
    \ access is not required.\"\n           OBJECT      ifPromiscuousMode\n      \
    \     MIN-ACCESS  read-only\n           DESCRIPTION\n               \"Write access\
    \ is not required.\"\n           OBJECT      ifStackStatus\n           SYNTAX\
    \      INTEGER { active(1) } -- subset of RowStatus\n           MIN-ACCESS  read-only\n\
    \           DESCRIPTION\n               \"Write access is not required, and only\
    \ one of the six\n               enumerated values for the RowStatus textual convention\n\
    \               need be supported, specifically: active(1).\"\n           OBJECT\
    \       ifAdminStatus\n           SYNTAX       INTEGER { up(1), down(2) }\n  \
    \         MIN-ACCESS   read-only\n           DESCRIPTION\n               \"Write\
    \ access is not required, nor is support for the\n               value testing(3).\"\
    \n           OBJECT       ifAlias\n           MIN-ACCESS   read-only\n       \
    \    DESCRIPTION\n               \"Write access is not required.\"\n       ::=\
    \ { ifCompliances 2 }\n   -- units of conformance\n   ifGeneralInformationGroup\
    \    OBJECT-GROUP\n       OBJECTS { ifIndex, ifDescr, ifType, ifSpeed, ifPhysAddress,\n\
    \                 ifAdminStatus, ifOperStatus, ifLastChange,\n               \
    \  ifLinkUpDownTrapEnable, ifConnectorPresent,\n                 ifHighSpeed,\
    \ ifName, ifNumber, ifAlias,\n                 ifTableLastChange }\n       STATUS\
    \  current\n       DESCRIPTION\n               \"A collection of objects providing\
    \ information\n               applicable to all network interfaces.\"\n      \
    \ ::= { ifGroups 10 }\n   -- the following five groups are mutually exclusive;\
    \ at most\n   -- one of these groups is implemented for any interface\n   ifFixedLengthGroup\
    \    OBJECT-GROUP\n       OBJECTS { ifInOctets, ifOutOctets, ifInUnknownProtos,\n\
    \                 ifInErrors, ifOutErrors }\n       STATUS  current\n       DESCRIPTION\n\
    \               \"A collection of objects providing information\n            \
    \   specific to non-high speed (non-high speed interfaces\n               transmit\
    \ and receive at speeds less than or equal to\n               20,000,000 bits/second)\
    \ character-oriented or fixed-\n               length-transmission network interfaces.\"\
    \n       ::= { ifGroups 2 }\n   ifHCFixedLengthGroup    OBJECT-GROUP\n       OBJECTS\
    \ { ifHCInOctets, ifHCOutOctets,\n                 ifInOctets, ifOutOctets, ifInUnknownProtos,\n\
    \                 ifInErrors, ifOutErrors }\n       STATUS  current\n       DESCRIPTION\n\
    \               \"A collection of objects providing information\n            \
    \   specific to high speed (greater than 20,000,000\n               bits/second)\
    \ character-oriented or fixed-length-\n               transmission network interfaces.\"\
    \n       ::= { ifGroups 3 }\n   ifPacketGroup    OBJECT-GROUP\n       OBJECTS\
    \ { ifInOctets, ifOutOctets, ifInUnknownProtos,\n                 ifInErrors,\
    \ ifOutErrors,\n                 ifMtu, ifInUcastPkts, ifInMulticastPkts,\n  \
    \               ifInBroadcastPkts, ifInDiscards,\n                 ifOutUcastPkts,\
    \ ifOutMulticastPkts,\n                 ifOutBroadcastPkts, ifOutDiscards,\n \
    \                ifPromiscuousMode }\n       STATUS  current\n       DESCRIPTION\n\
    \               \"A collection of objects providing information\n            \
    \   specific to non-high speed (non-high speed interfaces\n               transmit\
    \ and receive at speeds less than or equal to\n               20,000,000 bits/second)\
    \ packet-oriented network\n               interfaces.\"\n       ::= { ifGroups\
    \ 4 }\n   ifHCPacketGroup    OBJECT-GROUP\n       OBJECTS { ifHCInOctets, ifHCOutOctets,\n\
    \                 ifInOctets, ifOutOctets, ifInUnknownProtos,\n              \
    \   ifInErrors, ifOutErrors,\n                 ifMtu, ifInUcastPkts, ifInMulticastPkts,\n\
    \                 ifInBroadcastPkts, ifInDiscards,\n                 ifOutUcastPkts,\
    \ ifOutMulticastPkts,\n                 ifOutBroadcastPkts, ifOutDiscards,\n \
    \                ifPromiscuousMode }\n       STATUS  current\n       DESCRIPTION\n\
    \               \"A collection of objects providing information\n            \
    \   specific to high speed (greater than 20,000,000\n               bits/second\
    \ but less than or equal to 650,000,000\n               bits/second) packet-oriented\
    \ network interfaces.\"\n       ::= { ifGroups 5 }\n   ifVHCPacketGroup    OBJECT-GROUP\n\
    \       OBJECTS { ifHCInUcastPkts, ifHCInMulticastPkts,\n                 ifHCInBroadcastPkts,\
    \ ifHCOutUcastPkts,\n                 ifHCOutMulticastPkts, ifHCOutBroadcastPkts,\n\
    \                 ifHCInOctets, ifHCOutOctets,\n                 ifInOctets, ifOutOctets,\
    \ ifInUnknownProtos,\n                 ifInErrors, ifOutErrors,\n            \
    \     ifMtu, ifInUcastPkts, ifInMulticastPkts,\n                 ifInBroadcastPkts,\
    \ ifInDiscards,\n                 ifOutUcastPkts, ifOutMulticastPkts,\n      \
    \           ifOutBroadcastPkts, ifOutDiscards,\n                 ifPromiscuousMode\
    \ }\n       STATUS  current\n       DESCRIPTION\n               \"A collection\
    \ of objects providing information\n               specific to higher speed (greater\
    \ than 650,000,000\n               bits/second) packet-oriented network interfaces.\"\
    \n       ::= { ifGroups 6 }\n   ifRcvAddressGroup    OBJECT-GROUP\n       OBJECTS\
    \ { ifRcvAddressStatus, ifRcvAddressType }\n       STATUS  current\n       DESCRIPTION\n\
    \               \"A collection of objects providing information on the\n     \
    \          multiple addresses which an interface receives.\"\n       ::= { ifGroups\
    \ 7 }\n   ifStackGroup2    OBJECT-GROUP\n       OBJECTS { ifStackStatus, ifStackLastChange\
    \ }\n       STATUS  current\n       DESCRIPTION\n               \"A collection\
    \ of objects providing information on the\n               layering of MIB-II interfaces.\"\
    \n       ::= { ifGroups 11 }\n   ifCounterDiscontinuityGroup  OBJECT-GROUP\n \
    \      OBJECTS { ifCounterDiscontinuityTime }\n       STATUS  current\n      \
    \ DESCRIPTION\n               \"A collection of objects providing information\n\
    \               specific to interface counter discontinuities.\"\n       ::= {\
    \ ifGroups 13 }\n   -- Deprecated Definitions - Objects\n   --\n   --    The Interface\
    \ Test Table\n   --\n   -- This group of objects is optional.  However, a media-specific\n\
    \   -- MIB may make implementation of this group mandatory.\n   --\n   -- This\
    \ table replaces the ifExtnsTestTable\n   --\n   ifTestTable   OBJECT-TYPE\n \
    \      SYNTAX      SEQUENCE OF IfTestEntry\n       MAX-ACCESS  not-accessible\n\
    \       STATUS      deprecated\n       DESCRIPTION\n               \"This table\
    \ contains one entry per interface.  It\n               defines objects which\
    \ allow a network manager to\n               instruct an agent to test an interface\
    \ for various\n               faults.  Tests for an interface are defined in the\n\
    \               media-specific MIB for that interface.  After invoking\n     \
    \          a test, the object ifTestResult can be read to\n               determine\
    \ the outcome.  If an agent can not perform\n               the test, ifTestResult\
    \ is set to so indicate.  The\n               object ifTestCode can be used to\
    \ provide further\n               test-specific or interface-specific (or even\n\
    \               enterprise-specific) information concerning the\n            \
    \   outcome of the test.  Only one test can be in progress\n               on\
    \ each interface at any one time.  If one test is in\n               progress\
    \ when another test is invoked, the second test\n               is rejected. \
    \ Some agents may reject a test when a\n               prior test is active on\
    \ another interface.\n               Before starting a test, a manager-station\
    \ must first\n               obtain 'ownership' of the entry in the ifTestTable\
    \ for\n               the interface to be tested.  This is accomplished with\n\
    \               the ifTestId and ifTestStatus objects as follows:\n          \
    \  try_again:\n                get (ifTestId, ifTestStatus)\n                while\
    \ (ifTestStatus != notInUse)\n                    /*\n                     * Loop\
    \ while a test is running or some other\n                     * manager is configuring\
    \ a test.\n                     */\n                    short delay\n        \
    \            get (ifTestId, ifTestStatus)\n                }\n               \
    \ /*\n                 * Is not being used right now -- let's compete\n      \
    \           * to see who gets it.\n                 */\n                lock_value\
    \ = ifTestId\n                if ( set(ifTestId = lock_value, ifTestStatus = inUse,\n\
    \                         ifTestOwner = 'my-IP-address') == FAILURE)\n       \
    \             /*\n                     * Another manager got the ifTestEntry --\
    \ go\n                     * try again\n                     */\n            \
    \        goto try_again;\n                /*\n                 * I have the lock\n\
    \                 */\n                set up any test parameters.\n          \
    \      /*\n                 * This starts the test\n                 */\n    \
    \            set(ifTestType = test_to_run);\n                wait for test completion\
    \ by polling ifTestResult\n                when test completes, agent sets ifTestResult\n\
    \                     agent also sets ifTestStatus = 'notInUse'\n            \
    \    retrieve any additional test results, and ifTestId\n                if (ifTestId\
    \ == lock_value+1) results are valid\n              A manager station first retrieves\
    \ the value of the\n              appropriate ifTestId and ifTestStatus objects,\n\
    \              periodically repeating the retrieval if necessary,\n          \
    \    until the value of ifTestStatus is 'notInUse'.  The\n              manager\
    \ station then tries to set the same ifTestId\n              object to the value\
    \ it just retrieved, the same\n              ifTestStatus object to 'inUse', and\
    \ the corresponding\n              ifTestOwner object to a value indicating itself.\
    \  If\n              the set operation succeeds then the manager has\n       \
    \       obtained ownership of the ifTestEntry, and the value of\n            \
    \  the ifTestId object is incremented by the agent (per\n              the semantics\
    \ of TestAndIncr).  Failure of the set\n              operation indicates that\
    \ some other manager has\n              obtained ownership of the ifTestEntry.\n\
    \              Once ownership is obtained, any test parameters can be\n      \
    \        setup, and then the test is initiated by setting\n              ifTestType.\
    \  On completion of the test, the agent sets\n              ifTestStatus to 'notInUse'.\
    \  Once this occurs, the\n              manager can retrieve the results.  In\
    \ the (rare) event\n              that the invocation of tests by two network\
    \ managers\n              were to overlap, then there would be a possibility that\n\
    \              the first test's results might be overwritten by the\n        \
    \      second test's results prior to the first results being\n              read.\
    \  This unlikely circumstance can be detected by a\n              network manager\
    \ retrieving ifTestId at the same time as\n              retrieving the test results,\
    \ and ensuring that the\n              results are for the desired request.\n\
    \              If ifTestType is not set within an abnormally long\n          \
    \    period of time after ownership is obtained, the agent\n              should\
    \ time-out the manager, and reset the value of the\n              ifTestStatus\
    \ object back to 'notInUse'.  It is\n              suggested that this time-out\
    \ period be 5 minutes.\n              In general, a management station must not\
    \ retransmit a\n              request to invoke a test for which it does not receive\n\
    \              a response; instead, it properly inspects an agent's\n        \
    \      MIB to determine if the invocation was successful.\n              Only\
    \ if the invocation was unsuccessful, is the\n              invocation request\
    \ retransmitted.\n              Some tests may require the interface to be taken\
    \ off-\n              line in order to execute them, or may even require the\n\
    \              agent to reboot after completion of the test.  In these\n     \
    \         circumstances, communication with the management\n              station\
    \ invoking the test may be lost until after\n              completion of the test.\
    \  An agent is not required to\n              support such tests.  However, if\
    \ such tests are\n              supported, then the agent should make every effort\
    \ to\n              transmit a response to the request which invoked the\n   \
    \           test prior to losing communication.  When the agent is\n         \
    \     restored to normal service, the results of the test are\n              properly\
    \ made available in the appropriate objects.\n              Note that this requires\
    \ that the ifIndex value assigned\n              to an interface must be unchanged\
    \ even if the test\n              causes a reboot.  An agent must reject any test\
    \ for\n              which it cannot, perhaps due to resource constraints,\n \
    \             make available at least the minimum amount of\n              information\
    \ after that test completes.\"\n       ::= { ifMIBObjects 3 }\n   ifTestEntry\
    \ OBJECT-TYPE\n       SYNTAX       IfTestEntry\n       MAX-ACCESS   not-accessible\n\
    \       STATUS       deprecated\n       DESCRIPTION\n               \"An entry\
    \ containing objects for invoking tests on an\n               interface.\"\n \
    \      AUGMENTS  { ifEntry }\n       ::= { ifTestTable 1 }\n   IfTestEntry ::=\n\
    \       SEQUENCE {\n           ifTestId           TestAndIncr,\n           ifTestStatus\
    \       INTEGER,\n           ifTestType         AutonomousType,\n           ifTestResult\
    \       INTEGER,\n           ifTestCode         OBJECT IDENTIFIER,\n         \
    \  ifTestOwner        OwnerString\n       }\n   ifTestId         OBJECT-TYPE\n\
    \       SYNTAX       TestAndIncr\n       MAX-ACCESS   read-write\n       STATUS\
    \       deprecated\n       DESCRIPTION\n               \"This object identifies\
    \ the current invocation of the\n               interface's test.\"\n       ::=\
    \ { ifTestEntry 1 }\n   ifTestStatus     OBJECT-TYPE\n       SYNTAX       INTEGER\
    \ { notInUse(1), inUse(2) }\n       MAX-ACCESS   read-write\n       STATUS   \
    \    deprecated\n       DESCRIPTION\n               \"This object indicates whether\
    \ or not some manager\n               currently has the necessary 'ownership'\
    \ required to\n               invoke a test on this interface.  A write to this\n\
    \               object is only successful when it changes its value\n        \
    \       from 'notInUse(1)' to 'inUse(2)'.  After completion of\n             \
    \  a test, the agent resets the value back to\n               'notInUse(1)'.\"\
    \n       ::= { ifTestEntry 2 }\n   ifTestType       OBJECT-TYPE\n       SYNTAX\
    \       AutonomousType\n       MAX-ACCESS   read-write\n       STATUS       deprecated\n\
    \       DESCRIPTION\n               \"A control variable used to start and stop\
    \ operator-\n               initiated interface tests.  Most OBJECT IDENTIFIER\n\
    \               values assigned to tests are defined elsewhere, in\n         \
    \      association with specific types of interface.\n               However,\
    \ this document assigns a value for a full-\n               duplex loopback test,\
    \ and defines the special meanings\n               of the subject identifier:\n\
    \                   noTest  OBJECT IDENTIFIER ::= { 0 0 }\n               When\
    \ the value noTest is written to this object, no\n               action is taken\
    \ unless a test is in progress, in which\n               case the test is aborted.\
    \  Writing any other value to\n               this object is only valid when no\
    \ test is currently in\n               progress, in which case the indicated test\
    \ is\n               initiated.\n               When read, this object always\
    \ returns the most recent\n               value that ifTestType was set to.  If\
    \ it has not been\n               set since the last initialization of the network\n\
    \               management subsystem on the agent, a value of noTest\n       \
    \        is returned.\"\n       ::= { ifTestEntry 3 }\n   ifTestResult  OBJECT-TYPE\n\
    \       SYNTAX       INTEGER {\n                        none(1),          -- no\
    \ test yet requested\n                        success(2),\n                  \
    \      inProgress(3),\n                        notSupported(4),\n            \
    \            unAbleToRun(5),   -- due to state of system\n                   \
    \     aborted(6),\n                        failed(7)\n                    }\n\
    \       MAX-ACCESS   read-only\n       STATUS       deprecated\n       DESCRIPTION\n\
    \               \"This object contains the result of the most recently\n     \
    \          requested test, or the value none(1) if no tests have\n           \
    \    been requested since the last reset.  Note that this\n               facility\
    \ provides no provision for saving the results\n               of one test when\
    \ starting another, as could be\n               required if used by multiple managers\
    \ concurrently.\"\n       ::= { ifTestEntry 4 }\n   ifTestCode  OBJECT-TYPE\n\
    \       SYNTAX       OBJECT IDENTIFIER\n       MAX-ACCESS   read-only\n      \
    \ STATUS       deprecated\n       DESCRIPTION\n               \"This object contains\
    \ a code which contains more\n               specific information on the test\
    \ result, for example\n               an error-code after a failed test.  Error\
    \ codes and\n               other values this object may take are specific to\
    \ the\n               type of interface and/or test.  The value may have the\n\
    \               semantics of either the AutonomousType or\n               InstancePointer\
    \ textual conventions as defined in RFC\n               1903.  The identifier:\n\
    \                   testCodeUnknown  OBJECT IDENTIFIER ::= { 0 0 }\n         \
    \      is defined for use if no additional result code is\n               available.\"\
    \n       ::= { ifTestEntry 5 }\n   ifTestOwner      OBJECT-TYPE\n       SYNTAX\
    \       OwnerString\n       MAX-ACCESS   read-write\n       STATUS       deprecated\n\
    \       DESCRIPTION\n               \"The entity which currently has the 'ownership'\n\
    \               required to invoke a test on this interface.\"\n       ::= { ifTestEntry\
    \ 6 }\n   -- Deprecated Definitions - Groups\n   ifGeneralGroup    OBJECT-GROUP\n\
    \       OBJECTS { ifDescr, ifType, ifSpeed, ifPhysAddress,\n                 ifAdminStatus,\
    \ ifOperStatus, ifLastChange,\n                 ifLinkUpDownTrapEnable, ifConnectorPresent,\n\
    \                 ifHighSpeed, ifName }\n       STATUS  deprecated\n       DESCRIPTION\n\
    \               \"A collection of objects deprecated in favour of\n          \
    \     ifGeneralInformationGroup.\"\n       ::= { ifGroups 1 }\n   ifTestGroup\
    \    OBJECT-GROUP\n       OBJECTS { ifTestId, ifTestStatus, ifTestType,\n    \
    \             ifTestResult, ifTestCode, ifTestOwner }\n       STATUS  deprecated\n\
    \       DESCRIPTION\n               \"A collection of objects providing the ability\
    \ to\n               invoke tests on an interface.\"\n       ::= { ifGroups 8\
    \ }\n   ifStackGroup    OBJECT-GROUP\n       OBJECTS { ifStackStatus }\n     \
    \  STATUS  deprecated\n       DESCRIPTION\n               \"The previous collection\
    \ of objects providing\n               information on the layering of MIB-II interfaces.\"\
    \n       ::= { ifGroups 9 }\n   ifOldObjectsGroup    OBJECT-GROUP\n       OBJECTS\
    \ { ifInNUcastPkts, ifOutNUcastPkts,\n                 ifOutQLen, ifSpecific }\n\
    \       STATUS  deprecated\n       DESCRIPTION\n               \"The collection\
    \ of objects deprecated from the\n               original MIB-II interfaces group.\"\
    \n       ::= { ifGroups 12 }\n   -- Deprecated Definitions - Compliance\n   ifCompliance\
    \ MODULE-COMPLIANCE\n       STATUS  deprecated\n       DESCRIPTION\n         \
    \      \"The previous compliance statement for SNMPv2 entities\n             \
    \  which have network interfaces.\"\n       MODULE  -- this module\n         \
    \  MANDATORY-GROUPS { ifGeneralGroup, ifStackGroup }\n           GROUP       ifFixedLengthGroup\n\
    \           DESCRIPTION\n               \"This group is mandatory for all network\
    \ interfaces\n               which are character-oriented or transmit data in\n\
    \               fixed-length transmission units.\"\n           GROUP       ifHCFixedLengthGroup\n\
    \           DESCRIPTION\n               \"This group is mandatory only for those\
    \ network\n               interfaces which are character-oriented or transmit\n\
    \               data in fixed-length transmission units, and for which\n     \
    \          the value of the corresponding instance of ifSpeed is\n           \
    \    greater than 20,000,000 bits/second.\"\n           GROUP       ifPacketGroup\n\
    \           DESCRIPTION\n               \"This group is mandatory for all network\
    \ interfaces\n               which are packet-oriented.\"\n           GROUP  \
    \     ifHCPacketGroup\n           DESCRIPTION\n               \"This group is\
    \ mandatory only for those network\n               interfaces which are packet-oriented\
    \ and for which the\n               value of the corresponding instance of ifSpeed\
    \ is\n               greater than 650,000,000 bits/second.\"\n           GROUP\
    \       ifTestGroup\n           DESCRIPTION\n               \"This group is optional.\
    \  Media-specific MIBs which\n               require interface tests are strongly\
    \ encouraged to use\n               this group for invoking tests and reporting\
    \ results.\n               A medium specific MIB which has mandatory tests may\n\
    \               make implementation of this group mandatory.\"\n           GROUP\
    \       ifRcvAddressGroup\n           DESCRIPTION\n               \"The applicability\
    \ of this group MUST be defined by\n               the media-specific MIBs.  Media-specific\
    \ MIBs must\n               define the exact meaning, use, and semantics of the\n\
    \               addresses in this group.\"\n           OBJECT      ifLinkUpDownTrapEnable\n\
    \           MIN-ACCESS  read-only\n           DESCRIPTION\n               \"Write\
    \ access is not required.\"\n           OBJECT      ifPromiscuousMode\n      \
    \     MIN-ACCESS  read-only\n           DESCRIPTION\n               \"Write access\
    \ is not required.\"\n           OBJECT      ifStackStatus\n           SYNTAX\
    \      INTEGER { active(1) } -- subset of RowStatus\n           MIN-ACCESS  read-only\n\
    \           DESCRIPTION\n               \"Write access is not required, and only\
    \ one of the six\n               enumerated values for the RowStatus textual convention\n\
    \               need be supported, specifically: active(1).\"\n           OBJECT\
    \       ifAdminStatus\n           SYNTAX       INTEGER { up(1), down(2) }\n  \
    \         MIN-ACCESS   read-only\n           DESCRIPTION\n               \"Write\
    \ access is not required, nor is support for the\n               value testing(3).\"\
    \n       ::= { ifCompliances 1 }\n   END\n"
- title: 7.  Acknowledgements
  contents:
  - "7.  Acknowledgements\n   This memo has been produced by the IETF's Interfaces\
    \ MIB working-\n   group.\n   The original proposal evolved from conversations\
    \ and discussions with\n   many people, including at least the following: Fred\
    \ Baker, Ted\n   Brunner, Chuck Davin, Jeremy Greene, Marshall Rose, Kaj Tesink,\
    \ and\n   Dean Throop.\n"
- title: 8.  References
  contents:
  - "8.  References\n   [1]  Case, J., McCloghrie, K., Rose, M., and\n        S. Waldbusser,\
    \ \"Structure of Management Information for\n        version 2 of the Simple Network\
    \ Management Protocol\n        (SNMPv2)\", RFC 1902, January 1996.\n   [2]  Case,\
    \ J., McCloghrie, K., Rose, M., and\n        S. Waldbusser, \"Textual Conventions\
    \ for version 2 of the\n        Simple Network Management Protocol (SNMPv2)\"\
    , RFC 1903,\n        January 1996.\n   [3]  Case, J., McCloghrie, K., Rose, M.,\
    \ and\n        S. Waldbusser, \"Protocol Operations for version 2 of the\n   \
    \     Simple Network Management Protocol (SNMPv2)\", RFC 1905,\n        January\
    \ 1996.\n   [4]  McCloghrie, K., and M. Rose, \"Management Information Base for\n\
    \        Network Management of TCP/IP-based internets - MIB-II\", STD\n      \
    \  17, RFC 1213, March 1991.\n   [5]  Case, J., Fedor, M., Schoffstall, M., and\
    \ J. Davin, \"Simple\n        Network Management Protocol\", STD 15, RFC 1157,\
    \ May 1990.\n   [6]  Postel, J., \"Internet Protocol\", STD 5, RFC 791, September\
    \ 1981.\n   [7]  McCloghrie, K., \"Extensions to the Generic-Interface MIB\",\
    \ RFC\n        1229, May 1991.\n   [8]  ATM Forum Technical Committee, \"LAN Emulation\
    \ Client\n        Management: Version 1.0 Specification\", af-lane-0044.000, ATM\n\
    \        Forum, September 1995.\n   [9]  Stewart, B., \"Definitions of Managed\
    \ Objects for Character\n        Stream Devices using SMIv2\", RFC 1658, July\
    \ 1994.\n   [10] Bradner, S., \"Key words for use in RFCs to Indicate\n      \
    \  Requirements Levels\", RFC 2119, March 1997.\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   This MIB contains both readable objects whose\
    \ values provide the\n   number and status of a device's network interfaces, and\
    \ write-able\n   objects which allow an administrator to control the interfaces\
    \ and to\n   perform tests on the interfaces.  Unauthorized access to the readable\n\
    \   objects is relatively innocuous.  Unauthorized access to the write-\n   able\
    \ objects could cause a denial of service, or in combination with\n   other (e.g.,\
    \ physical) security breaches, could cause unauthorized\n   connectivity to a\
    \ device.\n"
- title: 10.  Authors' Addresses
  contents:
  - "10.  Authors' Addresses\n   Keith McCloghrie\n   Cisco Systems, Inc.\n   170\
    \ West Tasman Drive\n   San Jose, CA  95134-1706\n   Phone: 408-526-5260\n   EMail:\
    \ kzm@cisco.com\n   Frank Kastenholz\n   FTP Software\n   2 High Street\n   North\
    \ Andover, Mass. USA 01845\n   Phone: 508-685-4000\n   EMail: kasten@ftp.com\n"
- title: 11.  Full Copyright Statement
  contents:
  - "11.  Full Copyright Statement\n   Copyright (C) The Internet Society (1997).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
