- contents:
  - '        GSAKMP: Group Secure Association Key Management Protocol

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document specifies the Group Secure Association Key Management\n
    \  Protocol (GSAKMP).  The GSAKMP provides a security framework for\n   creating
    and managing cryptographic groups on a network.  It provides\n   mechanisms to
    disseminate group policy and authenticate users, rules\n   to perform access control
    decisions during group establishment and\n   recovery, capabilities to recover
    from the compromise of group\n   members, delegation of group security functions,
    and capabilities to\n   destroy the group.  It also generates group keys.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................7\n
    \     1.1. GSAKMP Overview ............................................7\n      1.2.
    Document Organization ......................................9\n   2. Terminology
    .....................................................9\n   3. Security Considerations
    ........................................12\n      3.1. Security Assumptions ......................................12\n
    \     3.2. Related Protocols .........................................13\n           3.2.1.
    ISAKMP .............................................13\n           3.2.2. FIPS
    Pub 196 .......................................13\n           3.2.3. LKH ................................................13\n
    \          3.2.4. Diffie-Hellman .....................................14\n      3.3.
    Denial of Service (DoS) Attack ............................14\n      3.4. Rekey
    Availability ........................................14\n      3.5. Proof of Trust
    Hierarchy ..................................15\n   4. Architecture ...................................................15\n
    \     4.1. Trust Model ...............................................15\n           4.1.1.
    Components .........................................15\n           4.1.2. GO .................................................16\n
    \          4.1.3. GC/KS ..............................................16\n           4.1.4.
    Subordinate GC/KS ..................................17\n           4.1.5. GM .................................................17\n
    \          4.1.6. Assumptions ........................................18\n      4.2.
    Rule-Based Security Policy ................................18\n           4.2.1.
    Access Control .....................................19\n           4.2.2. Authorizations
    for Security-Relevant Actions .......20\n      4.3. Distributed Operation .....................................20\n
    \     4.4. Concept of Operation ......................................22\n           4.4.1.
    Assumptions ........................................22\n           4.4.2. Creation
    of a Policy Token .........................22\n           4.4.3. Creation of a
    Group ................................23\n           4.4.4. Discovery of GC/KS
    .................................24\n           4.4.5. GC/KS Registration Policy
    Enforcement ..............24\n           4.4.6. GM Registration Policy Enforcement
    .................24\n           4.4.7. Autonomous Distributed GSAKMP Operations
    ...........24\n   5. Group Life Cycle ...............................................27\n
    \     5.1. Group Definition ..........................................27\n      5.2.
    Group Establishment .......................................27\n           5.2.1.
    Standard Group Establishment .......................28\n                  5.2.1.1.
    Request to Join ...........................30\n                  5.2.1.2. Key
    Download ..............................31\n                  5.2.1.3. Request
    to Join Error .....................33\n                  5.2.1.4. Key Download
    - Ack/Failure ................34\n                  5.2.1.5. Lack of Ack ...............................35\n
    \          5.2.2. Cookies: Group Establishment with Denial of\n                  Service
    Protection .................................36\n           5.2.3. Group Establishment
    for Receive-Only Members .......39\n      5.3. Group Maintenance .........................................39\n
    \          5.3.1. Group Management ...................................39\n                  5.3.1.1.
    Rekey Events ..............................39\n                  5.3.1.2. Policy
    Updates ............................40\n                  5.3.1.3. Group Destruction
    .........................40\n           5.3.2. Leaving a Group ....................................41\n
    \                 5.3.2.1. Eviction ..................................41\n                  5.3.2.2.
    Voluntary Departure without Notice ........41\n                  5.3.2.3. De-Registration
    ...........................41\n                           5.3.2.3.1. Request to
    Depart ..............41\n                           5.3.2.3.2. Departure_Response
    .............43\n                           5.3.2.3.3. Departure_ACK ..................44\n
    \  6. Security Suite .................................................45\n      6.1.
    Assumptions ...............................................45\n      6.2. Definition
    Suite 1 ........................................45\n   7. GSAKMP Payload Structure
    .......................................47\n      7.1. GSAKMP Header .............................................47\n
    \          7.1.1. GSAKMP Header Structure ............................47\n                  7.1.1.1.
    GroupID Structure .........................51\n                           7.1.1.1.1.
    UTF-8 ..........................51\n                           7.1.1.1.2. Octet
    String ...................52\n                           7.1.1.1.3. IPv4 Group
    Identifier ..........52\n                           7.1.1.1.4. IPv6 Group Identifier
    ..........53\n           7.1.2. GSAKMP Header Processing ...........................53\n
    \     7.2. Generic Payload Header ....................................55\n           7.2.1.
    Generic Payload Header Structure ...................55\n           7.2.2. Generic
    Payload Header Processing ..................56\n      7.3. Policy Token Payload
    ......................................56\n           7.3.1. Policy Token Payload
    Structure .....................56\n           7.3.2. Policy Token Payload Processing
    ....................57\n      7.4. Key Download Payload ......................................58\n
    \          7.4.1. Key Download Payload Structure .....................58\n                  7.4.1.1.
    Key Datum Structure .......................61\n                  7.4.1.2. Rekey
    Array Structure .....................63\n           7.4.2. Key Download Payload
    Processing ....................63\n      7.5. Rekey Event Payload .......................................64\n
    \          7.5.1. Rekey Event Payload Structure ......................64\n                  7.5.1.1.
    \ Rekey Event Header Structure .............66\n                  7.5.1.2.  Rekey
    Event Data Structure ...............67\n                           7.5.1.2.1.
    Key Package Structure ..........68\n           7.5.2. Rekey Event Payload Processing
    .....................69\n      7.6. Identification Payload ....................................71\n
    \          7.6.1. Identification Payload Structure ...................71\n                  7.6.1.1.
    ID_U_NAME Structure .......................74\n           7.6.2. Identification
    Payload Processing ..................74\n                  7.6.2.1. ID_U_NAME
    Processing ......................75\n      7.7. Certificate Payload .......................................75\n
    \          7.7.1. Certificate Payload Structure ......................75\n           7.7.2.
    Certificate Payload Processing .....................77\n      7.8. Signature Payload
    .........................................78\n           7.8.1. Signature Payload
    Structure ........................78\n           7.8.2. Signature Payload Processing
    .......................80\n      7.9. Notification Payload ......................................81\n
    \          7.9.1. Notification Payload Structure .....................81\n                  7.9.1.1.
    Notification Data - Acknowledgement\n                           (ACK) Payload
    Type ........................83\n                  7.9.1.2. Notification Data
    -\n                           Cookie_Required and Cookie Payload Type ...83\n
    \                 7.9.1.3. Notification Data - Mechanism\n                           Choices
    Payload Type ......................84\n                  7.9.1.4. Notification
    Data - IPv4 and IPv6\n                           Value Payload Types .......................85\n
    \          7.9.2. Notification Payload Processing ....................85\n      7.10.
    Vendor ID Payload ........................................86\n           7.10.1.
    Vendor ID Payload Structure .......................86\n           7.10.2. Vendor
    ID Payload Processing ......................87\n      7.11. Key Creation Payload
    .....................................88\n           7.11.1. Key Creation Payload
    Structure ....................88\n           7.11.2. Key Creation Payload Processing
    ...................89\n      7.12. Nonce Payload ............................................90\n
    \          7.12.1. Nonce Payload Structure ...........................90\n           7.12.2.
    Nonce Payload Processing ..........................91\n   8. GSAKMP State Diagram
    ...........................................92\n   9. IANA Considerations ............................................95\n
    \     9.1. IANA Port Number Assignment ...............................95\n      9.2.
    Initial IANA Registry Contents ............................95\n   10. Acknowledgements
    ..............................................96\n   11. References ....................................................97\n
    \     11.1. Normative References .....................................97\n      11.2.
    Informative References ...................................98\n   Appendix A. LKH
    Information ......................................100\n      A.1. LKH Overview
    .............................................100\n      A.2. LKH and GSAKMP ...........................................101\n
    \     A.3. LKH Examples .............................................102\n           A.3.1.
    LKH Key Download Example ..........................102\n           A.3.2. LKH
    Rekey Event Example  ..........................103\n"
  title: Table of Contents
- contents:
  - "List of Figures\n   1   GSAKMP Ladder Diagram .........................................28\n
    \  2   GSAKMP Ladder Diagram with Cookies ............................37\n   3
    \  GSAKMP Header Format ..........................................47\n   4   GroupID
    UTF-8 Format ..........................................51\n   5   GroupID Octet
    String Format ...................................52\n   6   GroupID IPv4 Format
    ...........................................52\n   7   GroupID IPv6 Format ...........................................53\n
    \  8   Generic Payload Header ........................................55\n   9
    \  Policy Token Payload Format ...................................56\n   10  Key
    Download Payload Format ...................................58\n   11  Key Download
    Data Item Format .................................59\n   12  Key Datum Format
    ..............................................61\n   13  Rekey Array Structure
    Format ..................................63\n   14  Rekey Event Payload Format
    ....................................64\n   15  Rekey Event Header Format .....................................66\n
    \  16  Rekey Event Data Format .......................................68\n   17
    \ Key Package Format ............................................68\n   18  Identification
    Payload Format .................................72\n   19  Unencoded Name (ID-U-NAME)
    Format .............................74\n   20  Certificate Payload Format ....................................76\n
    \  21  Signature Payload Format ......................................78\n   22
    \ Notification Payload Format ...................................81\n   23  Notification
    Data - Acknowledge Payload Type Format ...........83\n   24  Notification Data
    - Mechanism Choices Payload Type Format......84\n   25  Vendor ID Payload Format
    ......................................86\n   26  Key Creation Payload Format ...................................88\n
    \  27  Nonce Payload Format ..........................................90\n   28
    \ GSAKMP State Diagram ..........................................92\n   29  LKH
    Tree .....................................................100\n   30  GSAKMP LKH
    Tree ..............................................101\n"
  title: List of Figures
- contents:
  - "List of Tables\n   1   Request to Join (RTJ) Message Definition ......................30\n
    \  2   Key Download (KeyDL) Message Definition .......................31\n   3
    \  Request to Join Error (RTJ-Err) Message Definition ............33\n   4   Key
    Download - Ack/Failure (KeyDL-A/F) Message Definition .....34\n   5   Lack of
    Ack (LOA) Message Definition ..........................35\n   6   Cookie Download
    Message Definition ............................37\n   7   Rekey Event Message
    Definition ................................40\n   8   Request_to_Depart (RTD)
    Message Definition ....................42\n   9   Departure_Response (DR) Message
    Definition ....................43\n   10  Departure_ACK (DA) Message Definition
    .........................44\n   11  Group Identification Types ....................................48\n
    \  12  Payload Types .................................................49\n   13
    \ Exchange Types ................................................49\n   14  Policy
    Token Types ............................................57\n   15  Key Download
    Data Item Types ..................................60\n   16  Cryptographic Key
    Types .......................................62\n   17  Rekey Event Types .............................................66\n
    \  18  Identification Classification .................................72\n   19
    \ Identification Types ..........................................73\n   20  Certificate
    Payload Types .....................................77\n   21  Signature Types
    ...............................................79\n   22  Notification Types ............................................82\n
    \  23  Acknowledgement Types .........................................83\n   24
    \ Mechanism Types ...............................................84\n   25  Nonce
    Hash Types ..............................................85\n   26  Types Of Key
    Creation Information .............................89\n   27  Nonce Types ...................................................91\n
    \  28  GSAKMP States .................................................93\n   29
    \ State Transition Events .......................................94\n"
  title: List of Tables
- contents:
  - "1.  Introduction\n   GSAKMP provides policy distribution, policy enforcement,
    key\n   distribution, and key management for cryptographic groups.\n   Cryptographic
    groups all share a common key (or set of keys) for data\n   processing.  These
    keys all support a system-level security policy so\n   that the cryptographic
    group can be trusted to perform security-\n   relevant services.\n   The ability
    of a group of entities to perform security services\n   requires that a Group
    Secure Association (GSA) be established.  A GSA\n   ensures that there is a common
    \"group-level\" definition of security\n   policy and enforcement of that policy.
    \ The distribution of\n   cryptographic keys is a mechanism utilizing the group-level
    policy\n   enforcements.\n"
  - contents:
    - "1.1.  GSAKMP Overview\n   Protecting group information requires the definition
      of a security\n   policy and the enforcement of that policy by all participating\n
      \  parties.  Controlling dissemination of cryptographic key is the\n   primary
      mechanism to enforce the access control policy.  It is the\n   primary purpose
      of GSAKMP to generate and disseminate a group key in\n   a secure fashion.\n
      \  GSAKMP separates group security management functions and\n   responsibilities
      into three major roles:1) Group Owner, 2) Group\n   Controller Key Server, and
      3) Group Member.  The Group Owner is\n   responsible for creating the security
      policy rules for a group and\n   expressing these in the policy token.  The
      Group Controller Key\n   Server (GC/KS) is responsible for creating and maintaining
      the keys\n   and enforcing the group policy by granting access to potential
      Group\n   Members (GMs) in accordance with the policy token.  To enforce a\n
      \  group's policy, the potential Group Members need to have knowledge of\n   the
      access control policy for the group, an unambiguous\n   identification of any
      party downloading keys to them, and verifiable\n   chains of authority for key
      download.  In other words, the Group\n   Members need to know who potentially
      will be in the group and to\n   verify that the key disseminator is authorized
      to act in that\n   capacity.\n   In order to establish a Group Secure Association
      (GSA) to support\n   these activities, the identity of each party in the process
      MUST be\n   unambiguously asserted and authenticated.  It MUST also be verified\n
      \  that each party is authorized, as defined by the policy token, to\n   function
      in his role in the protocol (e.g., GM or GC/KS).\n   The security features of
      the establishment protocol for the GSA\n   include\n   -  Group policy identification\n
      \  -  Group policy dissemination\n   -  GM to GC/KS SA establishment to protect
      data\n   -  Access control checking\n   GSAKMP provides mechanisms for cryptographic
      group creation and\n   management.  Other protocols may be used in conjunction
      with GSAKMP\n   to allow various applications to create functional groups according\n
      \  to their application-specific requirements.  For example, in a\n   small-scale
      video conference, the organizer might use a session\n   invitation protocol
      like SIP [RFC3261] to transmit information about\n   the time of the conference,
      the address of the session, and the\n   formats to be used.  For a large-scale
      video transmission, the\n   organizer might use a multicast announcement protocol
      like SAP\n   [RFC2974].\n   This document describes a useful default set of
      security algorithms\n   and configurations, Security Suite 1.  This suite allows
      an entire\n   set of algorithms and settings to be described to prospective
      group\n   members in a concise manner.  Other security suites MAY be defined
      as\n   needed and MAY be disseminated during the out-of-band announcement of\n
      \  a group.\n   Distributed architectures support large-scale cryptographic
      groups.\n   Secure distributed architectures require authorized delegation of
      GSA\n   actions to network resources.  The fully specified policy token is\n
      \  the mechanism to facilitate this authorization.  Transmission of this\n   policy
      token to all joining GMs allows GSAKMP to securely support\n   distributed architectures
      and multiple data sources.\n   Many-to-many group communications require multiple
      data sources.\n   Multiple data sources are supported because the inclusion
      of a policy\n   token and policy payloads allow group members to review the
      group\n   access control and authorization parameters.  This member review\n
      \  process gives each member (each potential source of data) the ability\n   to
      determine if the group provides adequate protection for member\n   data.\n"
    title: 1.1.  GSAKMP Overview
  - contents:
    - "1.2.  Document Organization\n   The remainder of this document is organized
      as follows:Section 2\n   presents the terminology and concepts used to present
      the\n   requirements of this protocol.  Section 3 outlines the security\n   considerations
      with respect to GSAKMP.  Section 4 defines the\n   architecture of GSAKMP.  Section
      5 describes the group management\n   life cycle.  Section 6 describes the Security
      Suite Definition.\n   Section 7 presents the message types and formats used
      during each\n   phase of the life cycle.  Section 8 defines the state diagram
      for the\n   protocol.\n"
    title: 1.2.  Document Organization
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   The following terminology is used throughout this document.\n
    \  Requirements Terminology: Keywords \"MUST\", \"MUST NOT\", \"REQUIRED\",\n
    \  \"SHOULD\", \"SHOULD NOT\" and \"MAY\" that appear in this document are to\n
    \  be interpreted as described in [RFC2119].\n   Certificate: A data structure
    used to verifiably bind an identity to\n      a cryptographic key (e.g., X.509v3).\n
    \  Compromise Recovery: The act of recovering a secure operating state\n      after
    detecting that a group member cannot be trusted.  This can\n      be accomplished
    by rekey.\n   Cryptographic Group: A set of entities sharing or desiring to share
    a\n      GSA.\n   Group Controller Key Server (GC/KS): A group member with authority
    to\n      perform critical protocol actions including creating and\n      distributing
    keys and building and maintaining the rekey\n      structures.  As the group evolves,
    it MAY become desirable to have\n      multiple controllers perform these functions.\n
    \  Group Member (GM): A Group Member is any entity with access to the\n      group
    keys.  Regardless of how a member becomes a part of the\n      group or how the
    group is structured, GMs will perform the\n      following actions:\n      -  Authenticate
    and validate the identities and the authorizations\n         of entities performing
    security-relevant actions\n      -  Accept group keys from the GC/KS\n      -
    \ Request group keys from the GC/KS\n      -  Enforce the cooperative group policies
    as stated in the group\n         policy token\n      -  Perform peer review of
    key management actions\n      -  Manage local key\n   Group Owner (GO): A Group
    Owner is the entity authorized for\n      generating and modifying an authenticatable
    policy token for the\n      group, and notifying the GC/KS to start the group.\n
    \  Group Policy: The Group Policy completely describes the protection\n      mechanisms
    and security-relevant behaviors of the group.  This\n      policy MUST be commonly
    understood and enforced by the group for\n      coherent secure operations.\n
    \  Group Secure Association (GSA): A GSA is a logical association of\n      users
    or hosts that share cryptographic key(s).  This group may be\n      established
    to support associations between applications or\n      communication protocols.\n
    \  Group Traffic Protection Key (GTPK): The key or keys created for\n      protecting
    the group data.\n   Key Datum: A single key and its associated attributes for
    its usage.\n   Key Encryption Key (KEK): Key used in an encryption mechanism for\n
    \     wrapping another key.\n   Key Handle: The identifier of a particular instance
    or version of a\n      key.\n   Key ID: The identifier for a key that MUST stay
    static throughout the\n      life cycle of this key.\n   Key Package: Type/Length/Data
    format containing a Key Datum.\n   Logical Key Hierarchy (LKH) Array: The group
    of keys created to\n      facilitate the LKH compromise recovery methodology.\n
    \  Policy Token (PT): The policy token is a data structure used to\n      disseminate
    group policy and the mechanisms to enforce it.  The\n      policy token is issued
    and signed by an authorized Group Owner.\n      Each member of the group MUST
    verify the token, meet the group\n      join policy, and enforce the policy of
    the group (e.g., encrypt\n      application data with a specific algorithm).  The
    group policy\n      token will contain a variety of information including:\n         -
    \ GSAKMP protocol version\n         -  Key creation method\n         -  Key dissemination
    policy\n         -  Access control policy\n         -  Group authorization policy\n
    \        -  Compromise recovery policy\n         -  Data protection mechanisms\n
    \  Rekey: The act of changing keys within a group as defined by policy.\n   Rekey
    Array: The construct that contains all the rekey information\n      for a particular
    member.\n   Rekey Key: The KEK used to encrypt keys for a subset of the group.\n
    \  Subordinate Group Controller Key Server (S-GC/KS): Any group member\n      having
    the appropriate processing and trust characteristics, as\n      defined in the
    group policy, that has the potential to act as a\n      S-GC/KS.  This will allow
    the group processing and communication\n      requirements to be distributed equitably
    throughout the network\n      (e.g., distribute group key).  The optional use
    of GSAKMP with\n      Subordinate Group Controller Key Servers will be documented
    in a\n      separate paper.\n   Wrapping KeyID: The Key ID of the key used to
    wrap a Key Package.\n   Wrapping Key Handle: The key handle of the key used to
    wrap the Key\n      Package.\n"
  title: 2.  Terminology
- contents:
  - "3.  Security Considerations\n      In addition to the specification of GSAKMP
    itself, the security of\n      an implemented GSAKMP system is affected by supporting
    factors.\n      These are discussed here.\n"
  - contents:
    - "3.1.  Security Assumptions\n      The following assumptions are made as the
      basis for the security\n      discussion:\n   1.  GSAKMP assumes its supporting
      platform can provide the process\n       and data separation services at the
      appropriate assurance level\n       to support its groups.\n   2.  The key generation
      function of the cryptographic engine will only\n       generate strong keys.\n
      \  3.  The security of this protocol is critically dependent on the\n       randomness
      of the randomly chosen parameters.  These should be\n       generated by a strong
      random or properly seeded pseudo-random\n       source [RFC4086].\n   4.  The
      security of a group can be affected by the accuracy of the\n       system clock.
      \ Therefore, GSAKMP assumes that the system clock is\n       close to correct
      time.  If a GSAKMP host relies on a network time\n       service to set its
      local clock, then that protocol must be secure\n       against attackers.  The
      maximum allowable clock skew across the\n       group membership is policy configurable,
      with a default of 5\n       minutes.\n   5.  As described in the message processing
      section, the use of the\n       nonce value used for freshness along with a
      signature is the\n       mechanism used to foil replay attacks.  In any use
      of nonces, a\n       core requirement is unpredictability of the nonce, from
      an\n       attacker's viewpoint.  The utility of the nonce relies on the\n       inability
      of an attacker either to reuse old nonces or to predict\n       the nonce value.\n
      \  6.  GSAKMP does not provide identity protection.\n   7.  The group's multicast
      routing infrastructure is not secured by\n       GSAKMP, and therefore it may
      be possible to create a multicast\n       flooding denial of service attack
      using the multicast\n       application's data stream.  Either an insider (i.e.,
      a rogue GM)\n       or a non-member could direct the multicast routers to spray
      data\n       at a victim system.\n   8.  The compromise of a S-GC/KS forces
      the re-registration of all GMs\n       under its control.  The GM recognizes
      this situation by finding\n       the S-GC/KS's certificate on a CRL as supplied
      by a service such\n       as LDAP.\n   9.  The compromise of the GO forces termination
      of the group.  The GM\n       recognizes this situation by finding the GO's
      certificate on a\n       Certificate Revocation List (CRL) as supplied by a
      service such\n       as LDAP.\n"
    title: 3.1.  Security Assumptions
  - contents:
    - "3.2.  Related Protocols\n   GSAKMP derives from two (2) existing protocols:
      ISAKMP [RFC2408] and\n   FIPS Pub 196 [FIPS196].  In accordance with Security
      Suite 1, GSAKMP\n   implementations MUST support the use of Diffie-Hellman key
      exchange\n   [DH77] for two-party key creation and MAY use Logical Key Hierarchy\n
      \  (LKH) [RFC2627] for rekey capability.  The GSAKMP design was also\n   influenced
      by the following protocols: [HHMCD01], [RFC2093],\n   [RFC2094], [BMS], and
      [RFC2412].\n"
    - contents:
      - "3.2.1.  ISAKMP\n   ISAKMP provides a flexible structure of chained payloads
        in support\n   of authenticated key exchange and security association management
        for\n   pairwise communications.  GSAKMP builds upon these features to\n   provide
        policy enforcement features in support of diverse group\n   communications.\n"
      title: 3.2.1.  ISAKMP
    - contents:
      - "3.2.2.  FIPS Pub 196\n   FIPS Pub 196 provides a mutual authentication protocol.\n"
      title: 3.2.2.  FIPS Pub 196
    - contents:
      - "3.2.3.  LKH\n   When group policy dictates that a recovery of the group security
        is\n   necessary after the discovery of the compromise of a GM, then GSAKMP\n
        \  relies upon a rekey capability (i.e., LKH) to enable group recovery\n   after
        a compromise [RFC2627].  This is optional since in many\n   instances it may
        be better to destroy the compromised group and\n   rebuild a secure group.\n"
      title: 3.2.3.  LKH
    - contents:
      - "3.2.4.  Diffie-Hellman\n   A Group may rely upon two-party key creation mechanisms,
        i.e.,\n   Diffie-Hellman, to protect sensitive data during download.\n   The
        information in this section borrows heavily from [IKEv2], as this\n   protocol
        has already worked through similar issues and GSAKMP is\n   using the same
        security considerations for its purposes.  This\n   section will contain paraphrased
        sections of [IKEv2] modified for\n   GSAKMP as appropriate.\n   The strength
        of a key derived from a Diffie-Hellman exchange using\n   specific p and g
        values depends on the inherent strength of the\n   values, the size of the
        exponent used, and the entropy provided by\n   the random number generator
        used.  A strong random number generator\n   combined with the recommendations
        from [RFC3526] on Diffie-Hellman\n   exponent size is recommended as sufficient.
        \ An implementation should\n   make note of this conservative estimate when
        establishing policy and\n   negotiating security parameters.\n   Note that
        these limitations are on the Diffie-Hellman values\n   themselves.  There
        is nothing in GSAKMP that prohibits using stronger\n   values, nor is there
        anything that will dilute the strength obtained\n   from stronger values.
        \ In fact, the extensible framework of GSAKMP\n   encourages the definition
        of more Security Suites.\n   It is assumed that the Diffie-Hellman exponents
        in this exchange are\n   erased from memory after use.  In particular, these
        exponents MUST\n   NOT be derived from long-lived secrets such as the seed
        to a pseudo-\n   random generator that is not erased after use.\n"
      title: 3.2.4.  Diffie-Hellman
    title: 3.2.  Related Protocols
  - contents:
    - "3.3.  Denial of Service (DoS) Attack\n   This GSAKMP specification addresses
      the mitigation for a distributed\n   IP spoofing attack (a subset of possible
      DoS attacks) in Section\n   5.2.2, \"Cookies: Group Establishment with Denial
      of Service\n   Protection\".\n"
    title: 3.3.  Denial of Service (DoS) Attack
  - contents:
    - "3.4.  Rekey Availability\n   In addition to GSAKMP's capability to do rekey
      operations, GSAKMP\n   MUST also have the capability to make this rekey information
      highly\n   available to GMs.  The necessity of GMs receiving rekey messages\n
      \  requires the use of methods to increase the likelihood of receipt of\n   rekey
      messages.  These methods MAY include multiple transmissions of\n   the rekey
      message, posting of the rekey message on a bulletin board,\n   etc.  Compliant
      GSAKMP implementations supporting the optional rekey\n   capability MUST support
      retransmission of rekey messages.\n"
    title: 3.4.  Rekey Availability
  - contents:
    - "3.5.  Proof of Trust Hierarchy\n   As defined by [HCM], security group policy
      MUST be defined in a\n   verifiable manner.  GSAKMP anchors its trust in the
      creator of the\n   group, the GO.\n   The policy token explicitly defines all
      the parameters that create a\n   secure verifiable infrastructure.  The GSAKMP
      Policy Token is issued\n   and signed by the GO.  The GC/KS will verify it and
      grant access to\n   GMs only if they meet the rules of the policy token.  The
      new GMs\n   will accept access only if 1) the token verifies, 2) the GC/KS is
      an\n   authorized disseminator, and 3) the group mechanisms are acceptable\n
      \  for protecting the GMs data.\n"
    title: 3.5.  Proof of Trust Hierarchy
  title: 3.  Security Considerations
- contents:
  - "4.  Architecture\n   This architecture presents a trust model for GSAKMP and
    a concept of\n   operations for establishing a trusted distributed infrastructure
    for\n   group key and policy distribution.\n   GSAKMP conforms to the IETF MSEC
    architectural concepts as specified\n   in the MSEC Architecture document [RFC3740].
    \ GSAKMP uses the MSEC\n   components to create a trust model for operations that
    implement the\n   security principles of mutual suspicion and trusted policy creation\n
    \  authorities.\n"
  - contents:
    - '4.1.  Trust Model

      '
    - contents:
      - "4.1.1.  Components\n   The trust model contains four key components:\n   -
        \ Group Owner (GO),\n   -  Group Controller Key Server (GC/KS),\n   -  Subordinate
        GC/KS (S-GC/KS), and\n   -  Group Member (GM).\n   The goal of the GSAKMP
        trust model is to derive trust from a common\n   trusted policy creation authority
        for a group.  All security-relevant\n   decisions and actions implemented
        by GSAKMP are based on information\n   that ultimately is traceable to and
        verified by the trusted policy\n   creation authority.  There are two trusted
        policy creation\n   authorities for GSAKMP: the GO (policy creation authority)
        and the\n   PKI root that allows us to verify the GO.\n"
      title: 4.1.1.  Components
    - contents:
      - "4.1.2.  GO\n   The GO is the policy creation authority for the group.  The
        GO has a\n   well-defined identity that is relevant to the group.  That identity\n
        \  can be of a person or of a group-trusted component.  All potential\n   entities
        in the group have to recognize the GO as the individual with\n   authority
        to specify policy for the group.\n   The policy reflects the protection requirements
        of the data in a\n   group.  Ultimately, the data and the application environment
        drives\n   the security policy for the group.\n   The GO has to determine
        the security rules and mechanisms that are\n   appropriate for the data being
        protected by the group keys.  All this\n   information is captured in a policy
        token (PT).  The GO creates the\n   PT and signs it.\n"
      title: 4.1.2.  GO
    - contents:
      - "4.1.3.  GC/KS\n   The GC/KS is authorized to perform several functions: key
        creation,\n   key distribution, rekey, and group membership management.\n
        \  As the key creation authority, the GC/KS will create the set of keys\n
        \  for the group.  These keys include the Group Traffic Protection Keys\n
        \  (GTPKs) and first-tier rekey keys.  There may be second-tier rekey\n   trees
        if a distributed rekey management structure is required for the\n   group.\n
        \  As the key distribution (registration) authority, it has to notify\n   the
        group of its location for registration services.  The GC/KS will\n   have
        to enforce key access control as part of the key distribution\n   and registration
        processes.\n   As the group rekey authority, it performs rekey in order to
        change\n   the group's GTPK.  Change of the GTPK limits the exposure of data\n
        \  encrypted with any single GTPK.\n   Finally, as the group membership management
        authority, the GC/KS can\n   manage the group membership (registration, eviction,
        de-registration,\n   etc.).  This may be done in part by using a key tree
        approach, such\n   as Logical Key Hierarchies (LKH), as an optional approach.\n"
      title: 4.1.3.  GC/KS
    - contents:
      - "4.1.4.  Subordinate GC/KS\n   A subordinate GC/KS is used to distribute the
        GC/KS functionality\n   across multiple entities.  The S-GC/KS will have all
        the authorities\n   of the GC/KS except one: it will not create the GTPK.
        \ It is assumed\n   here that the group will transmit data with a single GTPK
        at any one\n   time.  This GTPK comes from the GC/KS.\n   Note that relative
        to the GC/KS, the S-GC/KS is responsible for an\n   additional security check:
        the S-GC/KS must register as a member with\n   the GC/KS, and during that
        process it has to verify the authority of\n   the GC/KS.\n"
      title: 4.1.4.  Subordinate GC/KS
    - contents:
      - "4.1.5.  GM\n   The GM has two jobs: to make sure all security-relevant actions
        are\n   authorized and to use the group keys properly.  During the\n   registration
        process, the GM will verify that the PT is signed by a\n   recognized GO.
        \ In addition, it will verify that the GC/KS or S-GC/KS\n   engaged in the
        registration process is authorized, as specified in\n   the PT.  If rekey
        and new PTs are distributed to the group, the GM\n   will verify that they
        are proper and all actions are authorized.\n   The GM is granted access to
        group data through receipt of the group\n   keys This carries along with it
        a responsibility to protect the key\n   from unauthorized disclosure.\n   GSAKMP
        does not offer any enforcement mechanisms to control which GMs\n   are multicast
        speakers at a given moment.  This policy and its\n   enforcement depend on
        the multicast application and its protocols.\n   However, GSAKMP does allow
        a group to have one of three Group\n   Security Association multicast speaker
        configurations:\n   -  There is a single GM authorized to be the group's speaker.
        \ There\n      is one multicast application SA allocated by the GO in support
        of\n      that speaker.  The PT initializes this multicast application SA\n
        \     and identifies the GM that has been authorized to be speaker.  All\n
        \     GMs share a single TPK with that GM speaker.  Sequence number\n      checking
        for anti-replay protection is feasible and enabled by\n      default.  This
        is the default group configuration.  GSAKMP\n      implementations MUST support
        this configuration.\n   -  The GO authorizes all of the GMs to be group speakers.
        \ The GO\n      allocates one multicast application SA in support of these\n
        \     speakers.  The PT initializes this multicast application SA and\n      indicates
        that any GM can be a speaker.  All of the GMs share a\n      single GTPK and
        other SA state information.  Consequently, some SA\n      security features
        such as sequence number checking for anti-replay\n      protection cannot
        be supported by this configuration.  GSAKMP\n      implementations MUST support
        this group configuration.\n   -  The GO authorizes a subset of the GMs to
        be group speakers (which\n      may be the subset composed of all GMs).  The
        GO allocates a\n      distinct multicast application SA for each of these
        speakers.  The\n      PT identifies the authorized speakers and initializes
        each of\n      their multicast application Security Associations.  The speakers\n
        \     still share a common TPK across their SA, but each speaker has a\n      separate
        SA state information instance at every peer GM.\n      Consequently, this
        configuration supports SA security features,\n      such as sequence number
        checking for anti-replay protection, or\n      source authentication mechanisms
        that require per-speaker state at\n      the receiver.  The drawback of this
        configuration is that it does\n      not scale to a large number of speakers.
        \ GSAKMP implementations\n      MAY support this group configuration.\n"
      title: 4.1.5.  GM
    - contents:
      - "4.1.6.  Assumptions\n   The assumptions for this trust model are that:\n
        \  -  the GCKS is never compromised,\n   -  the GO is never compromised,\n
        \  -  the PKI, subject to certificate validation, is trustworthy,\n   -  The
        GO is capable of creating a security policy to meet the\n      demands of
        the group,\n   -  the compromises of a group member will be detectable and
        reported\n      to the GO in a trusted manner,\n   -  the subsequent recovery
        from a compromise will deny inappropriate\n      access to protected data
        to the compromised member,\n   -  no security-relevant actions depend on a
        precise network time,\n   -  there are confidentiality, integrity, multicast
        source\n      authentication, and anti-replay protection mechanisms for all\n
        \     GSAKMP control messages.\n"
      title: 4.1.6.  Assumptions
    title: 4.1.  Trust Model
  - contents:
    - "4.2.  Rule-Based Security Policy\n   The trust model for GSAKMP revolves around
      the definition and\n   enforcement of the security policy.  In fact, the use
      of the key is\n   only relevant, in a security sense, if it represents the successful\n
      \  enforcement of the group security policy.\n   Group operations lend themselves
      to rule-based security policy.  The\n   need for distribution of data to many
      endpoints often leads to the\n   defining of those authorized endpoints based
      on rules.  For example,\n   all IETF attendees at a given conference could be
      defined as a single\n   group.\n   If the security policy rules are to be relevant,
      they must be coupled\n   with validation mechanisms.  The core principle here
      is that the\n   level of trust one can afford a security policy is exactly equal
      to\n   the level of trust one has in the validation mechanism used to prove\n
      \  that policy.  For example, if all IETF attendees are allowed in, then\n   they
      could register their identity from their certificate upon\n   check-in to the
      meetings.  That certificate is issued by a trusted\n   policy creation authority
      (PKI root) that is authorized to identify\n   someone as an IETF attendee.  The
      GO could make admittance rules to\n   the IETF group based on the identity certificates
      issued from trusted\n   PKIs.\n   In GSAKMP, every security policy rule is coupled
      with an explicit\n   validation mechanism.  For interoperability considerations,
      GSAKMP\n   requires that its supporting PKI implementations MUST be compliant
      to\n   RFC 3280.\n   If a GM's public key certificate is revoked, then the entity
      that\n   issues that revocation SHOULD signal the GO, so that the GO can expel\n
      \  that GM.  The method that signals this event to the GO is not\n   standardized
      by this specification.\n   A direct mapping of rule to validation mechanism
      allows the use of\n   multiple rules and PKIs to create groups.  This allows
      a GO to define\n   a group security policy that spans multiple PKI domains,
      each with\n   its own Certificate Authority public key certificate.\n"
    - contents:
      - "4.2.1.  Access Control\n   The access control policy for the group keys is
        equivalent to the\n   access control policy for the multicast application
        data the keys are\n   protecting.\n   In a group, each data source is responsible
        for ensuring that the\n   access to the source's data is appropriate.  This
        implies that every\n   data source should have knowledge of the access control
        policy for\n   the group keys.\n   In the general case, GSAKMP offers a suite
        of security services to\n   its applications and does not prescribe how they
        use those services.\n   GSAKMP supports the creation of GSAs with multiple
        data sources.  It\n   also supports architectures where the GC/KS is not itself
        a data\n   source.  In the multiple data source architectures GSAKMP requires\n
        \  that the access control policy is precisely defined and distributed\n   to
        each data source.  The reference for this data structure is the\n   GSAKMP
        Policy Token [RFC4534].\n"
      title: 4.2.1.  Access Control
    - contents:
      - "4.2.2.  Authorizations for Security-Relevant Actions\n   A critical aspect
        of the GSAKMP trust model is the authorization of\n   security-relevant actions.
        \ These include download of group key,\n   rekey, and PT creation and updates.
        \ These actions could be used to\n   disrupt the secure group, and all entities
        in the group must verify\n   that they were instigated by authorized entities
        within the group.\n"
      title: 4.2.2.  Authorizations for Security-Relevant Actions
    title: 4.2.  Rule-Based Security Policy
  - contents:
    - "4.3.  Distributed Operation\n   Scalability is a core feature of GSAKMP.  GSAKMP's
      approach to\n   scalable operations is the establishment of S-GC/KSes.  This
      allows\n   the GSAKMP systems to distribute the workload of setting up and\n
      \  managing very large groups.\n   Another aspect of distributed S-GC/KS operations
      is the enabling of\n   local management authorities.  In very large groups,
      subordinate\n   enclaves may be best suited to provide local management of the\n
      \  enclaves' group membership, due to a direct knowledge of the group\n   members.\n
      \  One of the critical issues involved with distributed operation is the\n   discovery
      of the security infrastructure location and security suite.\n   Many group applications
      that have dynamic interactions must \"find\"\n   each other to operate.  The
      discovery of the security infrastructure\n   is just another piece of information
      that has to be known by the\n   group in order to operate securely.\n   There
      are several methods for infrastructure discovery:\n   -  Announcements\n   -
      \ Anycast\n   -  Rendezvous points / Registration\n   One method for distributing
      the security infrastructure location is\n   to use announcements.  The SAP is
      commonly used to announce the\n   existence of a new multicast application or
      service.  If an\n   application uses SAP [RFC2974] to announce the existence
      of a service\n   on a multicast channel, that service could be extended to include
      the\n   security infrastructure location for a particular group.\n   Announcements
      can also be used by GSAKMP in one of two modes:\n   expanding ring searches
      (ERSes) of security infrastructure and ERSes\n   for infrastructure discovery.
      \ In either case, the GSAKMP would use a\n   multicast broadcast that would
      slowly increase in its range by\n   incremental multicast hops.  The multicast
      source controls the\n   packet's multicast range by explicitly setting its Time
      To Live\n   count.\n   An expanding ring announcement operates by the GC/KS
      announcing its\n   existence for a particular group.  The number of hops this\n
      \  announcement would travel would be a locally configured number.  The\n   GMs
      would listen on a well-known multicast address for GC/KSes that\n   provide
      service for groups of interest.  If multiple GC/KSes are\n   found that provide
      service, then the GM would pick the closest one\n   (in terms of multicast hops).
      \ The GM would then send a GSAKMP\n   Request to Join message (RTJ) to the announced
      GC/KS.  If the\n   announcement is found to be spurious, then that is reported
      to the\n   appropriate management authorities.  The ERA concept is slightly\n
      \  different from SAP in that it could occur over the data channel\n   multicast
      address, instead of a special multicast address dedicated\n   for the SAP service.\n
      \  An expanding ring search operates in the reverse order of the ERA.\n   In
      this case, the GM is the announcing entity.  The (S-)GC/KSes\n   listen for
      the requests for service, specifically the RTJ.  The\n   (S-)GC/KS responds
      to the RTJ.  If the GM receives more than one\n   response, it would either
      ignore the responses or send NACKs based on\n   local configuration.\n   Anycast
      is a service that is very similar to ERS.  It also can be\n   used to provide
      connection to the security infrastructure.  In this\n   case, the GM would send
      the RTJ to a well-known service request\n   address.  This anycast service would
      route the RTJ to an appropriate\n   GC/KS.  The anycast service would have security
      infrastructure and\n   network connectivity knowledge to facilitate this connection.\n
      \  Registration points can be used to distribute many group-relevant\n   data,
      including security infrastructure.  Many group applications\n   rely on well-known
      registration points to advertise the availability\n   of groups.  There is no
      reason that GSAKMP could not use the same\n   approach for advertising the existence
      and location of the security\n   infrastructure.  This is a simple process if
      the application being\n   supported already supports registration.  The GSAKMP
      infrastructure\n   can always provide a registration site if the existence of
      this\n   security infrastructure discovery hub is needed.  The registration
      of\n   S-GC/KSes at this site could be an efficient way to allow GM\n   registration.\n
      \  GSAKMP infrastructure discovery can use whatever mechanism suits a\n   particular
      multicast application's requirements, including mechanisms\n   that have not
      been discussed by this architecture.  However, GSAKMP\n   infrastructure discovery
      is not standardized by this version of the\n   GSAKMP specification.\n"
    title: 4.3.  Distributed Operation
  - contents:
    - "4.4.  Concept of Operation\n   This concept of operation shows how the different
      roles in GSAKMP\n   interact to set up a secure group.  This particular concept
      of\n   operation focuses on a secure group that utilizes the distributed key\n
      \  dissemination services of the S-GC/KS.\n"
    - contents:
      - "4.4.1.  Assumptions\n   The most basic assumption here is that there is one
        or more\n   trustworthy PKIs for the group.  That trusted PKI will be used
        to\n   create and verify security policy rules.\n   There is a GO that all
        GMs recognize as having group policy creation\n   authority.  All GM must
        be securely pre-configured to know the GO\n   public key.\n   All GMs have
        access to the GO PKI information, both the trusted\n   anchor public keys
        and the certificate path validation rules.\n   There is sufficient connectivity
        between the GSAKMP entities.\n   -  The registration SA requires that GM can
        connect to the GC/KS or\n      S-GC/KS using either TCP or UDP.\n   -  The
        Rekey SA requires that the data-layer multicast communication\n      service
        be available.  This can be multicast IP, overlay networks\n      using TCP,
        or NAT tunnels.\n   -  GSAKMP can support many different data-layer secure
        applications,\n      each with unique connectivity requirements.\n"
      title: 4.4.1.  Assumptions
    - contents:
      - "4.4.2.  Creation of a Policy Token\n   The GO creates and signs the policy
        token for a group.  The policy\n   token contains the rules for access control
        and authorizations for a\n   particular group.\n   The PT consists of the
        following information:\n   -  Identification: This allows an unambiguous identification
        of the\n      PT and the group.\n   -  Access Control Rules: These rules specify
        who can have access to\n      the group keys.\n   -  Authorization Rules:
        These rules specify who can be a S-GC/KS.\n   -  Mechanisms: These rules specify
        the security mechanisms that will\n      be used by the group.  This is necessary
        to ensure there is no\n      weak link in the group security profile.  For
        example, for IPsec,\n      this could include SPD/SAD configuration data.\n
        \  -  Source authentication of the PT to the GO: The PT is a CMS signed\n
        \     object, and this allows all GMs to verify the PT.\n"
      title: 4.4.2.  Creation of a Policy Token
    - contents:
      - "4.4.3.  Creation of a Group\n   The PT is sent to a potential GC/KS.  This
        can occur in several ways,\n   and the method of transmittal is outside the
        scope of GSAKMP.  The\n   potential GC/KS will verify the GO signature on
        the PT to ensure that\n   it comes from a trusted GO.  Next, the GC/KS will
        verify that it is\n   authorized to become the GC/KS, based on the authorization
        rules in\n   the PT.  Assuming that the GC/KS trusts the PT, is authorized
        to be a\n   GC/KS, and is locally configured to become a GC/KS for a given
        group\n   and the GO, then the GC/KS will create the keys necessary to start\n
        \  the group.  The GC/KS will take whatever action is necessary (if any)\n
        \  to advertise its ability to distribute key for the group.  The GC/KS\n
        \  will then listen for RTJs.\n   The PT has a sequence number.  Every time
        a PT is distributed to the\n   group, the group members verify that the sequence
        number on the PT is\n   increasing.  The PT lifetime is not limited to a particular
        time\n   interval, other than by the lifetimes imposed by some of its\n   attributes
        (e.g., signature key lifetime).  The current PT sequence\n   number is downloaded
        to the GM in the \"Key Download\" message.  Also,\n   to avoid replay attacks,
        this sequence number is never reset to a\n   lower value (i.e., rollover to
        zero) as long as the group identifier\n   remains valid and in use.  The GO
        MUST preserve this sequence number\n   across re-boots.\n"
      title: 4.4.3.  Creation of a Group
    - contents:
      - "4.4.4.  Discovery of GC/KS\n   Potential GMs will receive notice of the new
        group via some\n   mechanism: announcement, Anycast, or registration look-up.
        \ The GM\n   will send an RTJ to the GC/KS.\n"
      title: 4.4.4.  Discovery of GC/KS
    - contents:
      - "4.4.5.  GC/KS Registration Policy Enforcement\n   The GC/KS may or may not
        require cookies, depending on the DoS\n   environment and the local configuration.\n
        \  Once the RTJ has been received, the GC/KS will verify that the GM is\n
        \  allowed to have access to the group keys.  The GC/KS will then verify\n
        \  the signature on the RTJ to ensure it was sent by the claimed\n   identity.
        \ If the checks succeed, the GC/KS will ready a Key Download\n   message for
        the GM.  If not, the GC/KS can notify the GM of a non-\n   security-relevant
        problem.\n"
      title: 4.4.5.  GC/KS Registration Policy Enforcement
    - contents:
      - "4.4.6.  GM Registration Policy Enforcement\n   Upon receipt of the Key Download
        message, the GM will verify the\n   signature on the message.  Then the GM
        will retrieve the PT from the\n   Key Download message and verify that the
        GO created and signed the\n   PT.  Once the PT is verified as valid, the GM
        will verify that the\n   GC/KS is authorized to distribute key for this group.
        \ Then the GM\n   will verify that the mechanisms used in the group are available
        and\n   acceptable for protection of the GMs data (assuming the GM is a data\n
        \  source).  The GM will then accept membership in this group.\n   The GM
        will then check to see if it is allowed to be a S-GC/KS for\n   this group.
        \ If the GM is allowed to be a S-GC/KS AND the local GM\n   configuration
        allows the GM to act as a S-GC/KS for this group, then\n   the GM changes
        its operating state to S-GC/KS.  The GO needs to\n   assign the authority
        to become a S-GC/KS in a manner that supports\n   the overall group integrity
        and operations.\n"
      title: 4.4.6.  GM Registration Policy Enforcement
    - contents:
      - "4.4.7.  Autonomous Distributed GSAKMP Operations\n   In autonomous mode,
        each S-GC/KS operates a largely self-contained\n   sub-group for which the
        Primary-GC/KS delegates the sub-group's\n   membership management responsibility
        to the S-GC/KS.  In general, the\n   S-GC/KS locally handles each Group Member's
        registration and\n   de-registration without any interaction with the Primary-GC/KS.\n
        \  Periodically, the Primary-GC/KS multicasts a Rekey Event message\n   addressed
        only to its one or more S-GC/KS.\n   After a S-GC/KS successfully processes
        a Rekey Event message from the\n   Primary-GC/KS, the S-GC/KS transmits to
        its sub-group its own Rekey\n   Event message containing a copy of the group's
        new GTPK and policy\n   token.  The S-GC/KS encrypts its Rekey Event message's
        sub-group key\n   management information using Logical Key Hierarchy or a
        comparable\n   rekey protocol.  The S-GC/KS uses the rekey protocol to realize\n
        \  forward and backward secrecy, such that only the authorized sub-group\n
        \  members can decrypt and acquire access to the new GTPK and policy\n   token.
        \ The frequency at which the Primary-GC/KS transmits a Rekey\n   Event message
        is a policy token parameter.\n   For the special case of a S-GC/KS detecting
        an expelled or\n   compromised group member, a mechanism is defined to trigger
        an\n   immediate group rekey rather than wait for the group's rekey period\n
        \  to elapse.  See below for details.\n   Each S-GC/KS will be registered
        by the GC/KS as a management node\n   with responsibility for GTPK distribution,
        access control policy\n   enforcement, LKH tree creation, and distribution
        of LKH key arrays.\n   The S-GC/KS will be registered into the primary LKH
        tree as an\n   endpoint.  Each S-GC/KS will hold an entire LKH key array for
        the\n   GC's LKH key tree.\n   For the purpose of clarity, the process of
        creating a distributed\n   GSAKMP group will be explained in chronological
        order.\n   First, the Group Owner will create a policy token that authorizes
        a\n   subset of the group's membership to assume the role of S-GC/KS.\n   The
        GO needs to ensure that the S-GC/KS rules in the policy token\n   will be
        stringent enough to ensure trust in the S-GC/KSes.  This\n   policy token
        is handed off to the primary GC.\n   The GC will create the GTPK and initial
        LKH key tree.  The GC will\n   then wait for a potential S-GC/KS to send a
        Request to Join (RTJ)\n   message.\n   A potential S-GC/KS will eventually
        send an RTJ.  The GC will enforce\n   the access control policy as defined
        in the policy token.  The\n   S-GC/KS will accept the role of S-GC/KS and
        create its own LKH key\n   tree for its sub-group membership.\n   The S-GC/KS
        will then offer registration services for the group.\n   There are local management
        decisions that are optional to control the\n   scope of group members that
        can be served by a S-GC/KS.  These are\n   truly local management issues that
        allow the administrators of an\n   S-GC/KS to restrict service to potential
        GMs.  These local controls\n   do not affect the overall group security policy,
        as defined in the\n   policy token.\n   A potential Group Member will send
        an RTJ to the S-GC/KS.  The\n   S-GC/KS will enforce the entire access control
        policy as defined in\n   the PT.  The GM will receive an LKH key array that
        corresponds to the\n   LKH tree of the S-GC/KS.  The key tree generated by
        the S-GC/KS is\n   independent of the key tree generated by the GC/KS; they
        share no\n   common keys.\n   The GM then has the keys it needs to receive
        group traffic and be\n   subject to rekey from the S-GC/KS.  For the sake
        of this discussion,\n   let's assume the GM is to be expelled from the group
        membership.\n   The S-GC/KS will receive notification that the GM is to be
        expelled.\n   This mechanism is outside the scope of this protocol.\n   Upon
        notification that a GM that holds a key array within its LKH\n   tree is to
        be expelled, the S-GC/KS does two things.  First, the\n   S-GC/KS initiates
        a de-registration exchange with the GC/KS\n   identifying the member to be
        expelled.  (The S-GC/KS proxies a Group\n   Member's de-registration informing
        the GC/KS that the Group Member\n   has been expelled from the group.)  Second,
        the S-GC/KS will wait for\n   a rekey action by the GC/KS.  The immediacy
        of the rekey action by\n   the GC/KS is a management decision at the GC/KS.
        \ Security is best\n   served by quick expulsion of untrusted members.\n   Upon
        receipt of the de-registration notification from the S-GC/KS,\n   the GC/KS
        will register the member to be expelled.  The GC/KS will\n   then follow group
        procedure for initiating a rekey action (outside\n   the scope of this protocol).
        \ The GC/KS will communicate to the GO\n   the expelled member's information
        (outside the scope of this\n   protocol).  With this information, the GO will
        create a new PT for\n   the group with the expelled GM identity added to the
        excluded list in\n   the group's access control rules.  The GO provides this
        new PT to the\n   GC/KS for distribution with the Rekey Event Message.\n   The
        GC/KS will send out a rekey operation with a new PT.  The S-GC/KS\n   will
        receive the rekey and process it.  At the same time, all other\n   S-GC/KSes
        will receive the rekey and note the excluded GM identity.\n   All S-GC/KSes
        will review local identities to ensure that the\n   excluded GM is not a local
        member.  If it is, then the S-GC/KS will\n   create a rekey message.  The
        S-GC/KSes must always create a rekey\n   message, whether or not the expelled
        Group Member is a member of\n   their subtrees.\n   The S-GC/KS will then
        create a local rekey message.  The S-GC/KS will\n   send the wrapped Group
        TPK to all members of its local LKH tree,\n   except the excluded member(s).\n"
      title: 4.4.7.  Autonomous Distributed GSAKMP Operations
    title: 4.4.  Concept of Operation
  title: 4.  Architecture
- contents:
  - "5.  Group Life Cycle\n   The management of a cryptographic group follows a life
    cycle:  group\n   definition, group establishment, and security-relevant group\n
    \  maintenance.  Group definition involves defining the parameters\n   necessary
    to support a secure group, including its policy token.\n   Group establishment
    is the process of granting access to new members.\n   Security-relevant group
    maintenance messages include rekey, policy\n   changes, member deletions, and
    group destruction.  Each of these life\n   cycle phases is discussed in the following
    sections.\n   The use and processing of the optional Vendor ID payload for all\n
    \  messages can be found in Section 7.10.\n"
  - contents:
    - "5.1.  Group Definition\n   A cryptographic group is established to support
      secure communications\n   among a group of individuals.  The activities necessary
      to create a\n   policy token in support of a cryptographic group include:\n
      \  -  Determine Access Policy: identify the entities that are authorized\n      to
      receive the group key.\n   -  Determine Authorization Policy: identify which
      entities are\n      authorized to perform security-relevant actions, including
      key\n      dissemination, policy creation, and initiation of security-\n      management
      actions.\n   -  Determine Mechanisms: define the algorithms and protocols used
      by\n      GSAKMP to secure the group.\n   -  Create Group Policy Token: format
      the policies and mechanisms into\n      a policy token, and apply the GO signature.\n"
    title: 5.1.  Group Definition
  - contents:
    - "5.2.  Group Establishment\n   GSAKMP Group Establishment consists of three
      mandatory-to-implement\n   messages: the Request to Join, the Key Download,
      and the Key Download\n   Ack/Failure.  The exchange may also include two OPTIONAL
      error\n   messages: the Request to Join Error and the Lack_of_Ack messages.\n
      \  Operation using the mandatory messages only is referred to as \"Terse\n   Mode\",
      while inclusion of the error messaging is referred to as\n   \"Verbose Mode\".
      \ GSAKMP implementations MUST support Terse Mode and\n   MAY support Verbose
      Mode.  Group Establishment is discussed in\n   Section 5.2.1.\n   A group is
      set in Terse or Verbose Mode by a policy token parameter.\n   All (S-)GC/KSes
      in a Verbose Mode group MUST support Verbose Mode.\n   GSAKMP allows Verbose
      Mode groups to have GMs that do not support\n   Verbose Mode.  Candidate GMs
      that do not support Verbose Mode and\n   receive a RTJ-Error or Lack-of-Ack
      message must handle these messages\n   gracefully.  Additionally, a GM will
      not know ahead of time that it\n   is interacting with the (S-)GC/KS in Verbose
      or Terse Mode until the\n   policy token is received.\n   For denial of service
      protection, a Cookie Exchange MAY precede the\n   Group Establishment exchange.
      \ The Cookie Exchange is described in\n   Section 5.2.2.\n   Regardless of mode,
      any error message sent between component members\n   indicates the first error
      encountered while processing the message.\n"
    - contents:
      - "5.2.1.  Standard Group Establishment\n   After the out-of-band receipt of
        a policy token, a potential Group\n   Controller Key Server (GC/KS) verifies
        the token and its eligibility\n   to perform GC/KS functionality.  It is then
        permitted to create any\n   needed group keys and begin to establish the group.\n
        \  The GSAKMP Ladder Diagram, Figure 1, illustrates the process of\n   establishing
        a cryptographic group.  The left side of the diagram\n   represents the actions
        of the GC/KS.  The right side of the diagram\n   represents the actions of
        the GMs.  The components of each message\n   shown in the diagram are presented
        in Sections 5.2.1.1 through\n   5.2.1.5.\n    CONTROLLER   Mandatory/     MESSAGE
        \                 MEMBER\n                 Optional\n              !<-M----------Request
        to Join-------------!\n    <Process> !                                         !\n
        \   <RTJ>     !                                         !\n              !--M----------Key
        Download--------------->!\n              !                                         !<Process
        KeyDL>\n              !--O-------Request to Join Error--------->! or\n              !
        \                                        ! <Proc RTJ-Err>\n              !<-M----Key
        Download - Ack/Failure--------!\n   <Process  >!                                         !\n
        \  <KeyDL-A/F>!                                         !\n              !--O------Lack
        of Acknowledgement-------->!\n              !                                         !
        <Proc LOA>\n              !<=======SHARED KEYED GROUP SESSION======>!\n                  Figure
        1: GSAKMP Ladder Diagram\n   The Request to Join message is sent from a potential
        GM to the GC/KS\n   to request admission to the cryptographic group.  The
        message\n   contains key creation material, freshness data, an optional selection\n
        \  of mechanisms, and the signature of the GM.\n   The Key Download message
        is sent from the GC/KS to the GM in response\n   to an accepted Request to
        Join.  This GC/KS-signed message contains\n   the identifier of the GM, freshness
        data, key creation material,\n   encrypted keys, and the encrypted policy
        token.  The policy token is\n   used to facilitate well-ordered group creation
        and MUST include the\n   group's identification, group permissions, group
        join policy, group\n   controller key server identity, group management information,
        and\n   digital signature of the GO.  This will allow the GM to determine\n
        \  whether group policy is compatible with local policy.\n   The Request to
        Join Error message is sent from the GC/KS to the GM in\n   response to an
        unaccepted Request to Join.  This message is not\n   signed by the GC/KS for
        two reasons: 1) the GM, at this point, has no\n   knowledge of who is authorized
        to act as a GC/KS, and so the\n   signature would thus be meaningless to the
        GM, and 2) signing\n   responses to denied join requests would provide a denial
        of service\n   potential.  The message contains an indication of the error\n
        \  condition.  The possible values for this error condition are:\n   Invalid-Payload-Type,
        Invalid-Version, Invalid-Group-ID, Invalid-\n   Sequence-ID, Payload-Malformed,
        Invalid-ID-Information, Invalid-\n   Certificate, Cert-Type-Unsupported, Invalid-Cert-Authority,\n
        \  Authentication-Failed, Certificate-Unavailable, Unauthorized-Request,\n
        \  Prohibited-by-Group-Policy, and Prohibited-by-Locally-Configured-\n   Policy.\n
        \  The Key Download Ack/Failure message indicates Key Download receipt\n   status
        at the GM.  It is a GM-signed message containing freshness\n   data and status.\n
        \  The Lack_of_Ack message is sent from the GC/KS to the GM in response\n
        \  to an invalid or absent Key Download Ack/Failure message.  The signed\n
        \  message contains freshness and status data and is used to warn the GM\n
        \  of impending eviction from the group if a valid Key Download\n   Ack/Failure
        is not sent.  Eviction means that the member will be\n   excluded from the
        group after the next Rekey Event.  The policy of\n   when a particular group
        needs to rekey itself is stated in the policy\n   token.  Eviction is discussed
        further in Section 5.3.2.1.\n   For the following message structure sections,
        details about payload\n   format and processing can be found in Section 7.
        \ Each message is\n   identified by its exchange type in the header of the
        message.  Nonces\n   MUST be present in the messages unless synchronization
        time is\n   available to the system.\n"
      - contents:
        - "5.2.1.1.  Request to Join\n   The exchange type for Request to Join is
          eight (8).\n   The components of a Request to Join Message are shown in
          Table 1.\n              Table 1: Request to Join (RTJ) Message Definition\n
          \     Message Name  : Request to Join (RTJ)\n      Dissection    : {HDR-GrpID,
          Key Creation, Nonce_I, [VendorID],\n                    : [Notif_Mechanism_Choices],
          [Notif_Cookie],\n                    : [Notif_IPValue]} SigM, [Cert]\n      Payload
          Types : GSAKMP Header, Key Creation, [Nonce], [Vendor\n                      ID],
          Signature, [Certificate], [Notifications]\n        SigM        : Signature
          of Group Member\n        Cert        : Necessary Certificates, zero or more\n
          \       {}SigX      : Indicates fields used in Signature\n        []          :
          Indicate an optional data item\n   As shown by Figure 1, a potential GM
          MUST generate and send an RTJ\n   message to request permission to join
          the group.  At a minimum, the\n   GM MUST be able to manually configure
          the destination for the RTJ.\n   As defined in the dissection of the RTJ
          message, this message MUST\n   contain a Key Creation payload for KEK determination.
          \ A Nonce\n   payload MUST be included for freshness and the Nonce_I value
          MUST be\n   saved for potential later use.  The GC/KS will use this supplied\n
          \  nonce only if the policy token for this group defines the use of\n   nonces
          versus synchronization time.  An OPTIONAL Notification payload\n   of type
          Mechanism Choices MAY be included to identify the mechanisms\n   the GM
          wants to use.  Absence of this payload will cause the GC/KS to\n   select
          appropriate default policy-token-specified mechanisms for the\n   Key Download.\n
          \  In response, the GC/KS accepts or denies the request based on local\n
          \  configuration.  <Process RTJ> indicates the GC/KS actions that will\n
          \  determine if the RTJ will be acted upon.  The following checks SHOULD\n
          \  be performed in the order presented.\n   In this procedure, the GC/KS
          MUST verify that the message header is\n   properly formed and confirm that
          this message is for this group by\n   checking the value of the GroupID.
          \ If the header checks pass, then\n   the identity of the sender is extracted
          from the Signature payload.\n   This identity MUST be used to perform access
          control checks and find\n   the GMs credentials (e.g., certificate) for
          message verification.  It\n   MUST also be used in the Key Download message.
          \ Then, the GC/KS will\n   verify the signature on the message to ensure
          its authenticity.  The\n   GC/KS MUST use verified and trusted authentication
          material from a\n   known root.  If the message signature verifies, the
          GC/KS then\n   confirms that all required payloads are present and properly\n
          \  formatted based upon the mechanisms announced and/or requested.  If\n
          \  all checks pass, the GC/KS will create and send the Key Download\n   message
          as described in Section 5.2.1.2.\n   If the GM receives no response to the
          RTJ within the GM's locally\n   configured timeout value, the GM SHOULD
          resend the RTJ message up to\n   three (3) times.\n   NOTE: At any one time,
          a GC/KS MUST process no more than one (1)\n   valid RTJ message from a given
          GM per group until its pending\n   registration protocol exchange concludes.\n
          \  If any error occurs during RTJ message processing, and the GC/KS is\n
          \  running in Terse Mode, the registration session MUST be terminated,\n
          \  and all saved state information MUST be cleared.\n   The OPTIONAL Notification
          payload of type Cookie is discussed in\n   Section 5.2.2.\n   The OPTIONAL
          Notification payload of type IPValue may be used for the\n   GM to convey
          a specific IP value to the GC/KS.\n"
        title: 5.2.1.1.  Request to Join
      - contents:
        - "5.2.1.2.  Key Download\n   The exchange type for Key Download is nine (9).\n
          \  The components of a Key Download Message are shown in Table 2:\n               Table
          2: Key Download (KeyDL) Message Definition\n      Message Name  : Key Download
          (KeyDL)\n      Dissection    : {HDR-GrpID, Member ID, [Nonce_R, Nonce_C],
          Key\n                      Creation, (Policy Token)*, (Key Download)*,\n
          \                     [VendorID]} SigC, [Cert]\n      Payload Types : GSAKMP
          Header, Identification, [Nonce], Key\n                      Creation, Policy
          Token, Key Download, [Vendor\n                      ID], Signature, [Certificate]\n
          \       SigC        : Signature of Group Controller Key Server\n        Cert
          \       : Necessary Certificates, zero or more\n        {}SigX      : Indicates
          fields used in Signature\n        []          : Indicate an optional data
          item\n        (data)*     : Indicates encrypted information\n   In response
          to a properly formed and verified RTJ message, the GC/KS\n   creates and
          sends the KeyDL message.  As defined in the dissection of\n   the message,
          this message MUST contain payloads to hold the following\n   information:
          GM identification, Key Creation material, encrypted\n   policy token, encrypted
          key information, and signature information.\n   If synchronized time is
          not available, the Nonce payloads MUST be\n   included in the message for
          freshness.\n   If present, the nonce values transmitted MUST be the GC/KS's\n
          \  generated Nonce_R value and the combined Nonce_C value that was\n   generated
          by using the GC/KS's Nonce_R value and the Nonce_I value\n   received from
          the GM in the RTJ.\n   If two-party key determination is used, the key creation
          material\n   supplied by the GM and/or the GC/KS will be used to generate
          the key.\n   Generation of this key is dependent on the key exchange, as
          defined\n   in Section 7.11, \"Key Creation Payload\".  The policy token
          and key\n   material are encrypted in the generated key.\n   The GM MUST
          be able to process the Key Download message.  <Process\n   KeyDL> indicates
          the GM actions that will determine how the Key\n   Download message will
          be acted upon.  The following checks SHOULD be\n   performed in the order
          presented.\n   In this procedure, the GM will verify that the message header
          is\n   properly formed and confirm that this message is for this group by\n
          \  checking the value of the GroupID.  If the header checks pass, the GM\n
          \  MUST confirm that this message was intended for itself by comparing\n
          \  the Member ID in the Identification payload to its identity.\n   After
          identification confirmation, the freshness values are checked.\n   If using
          nonces, the GM MUST use its saved Nonce_I value, extract the\n   received
          GC/KS Nonce_R value, compute the combined Nonce_C value, and\n   compare
          it to the received Nonce_C value.  If not using nonces, the\n   GM MUST
          check the timestamp in the Signature payload to determine if\n   the message
          is new.\n   After freshness is confirmed, the signature MUST be verified
          to\n   ensure its authenticity.  The GM MUST use verified and trusted\n
          \  authentication material from a known root.  If the message signature\n
          \  verifies, the key creation material is extracted from the Key\n   Creation
          payload to generate the KEK.  This KEK is then used to\n   decrypt the policy
          token data.  The signature on the policy token\n   MUST be verified.  Access
          control checks MUST be performed on both\n   the GO and the GC/KS to determine
          both their authorities within this\n   group.  After all these checks pass,
          the KEK can then be used to\n   decrypt and process the key material from
          the Key Download payload.\n   If all is successful, the GM will create and
          send the Key Download -\n   Ack/Failure message as described in Section
          5.2.1.4.\n   The Policy Token and Key Download Payloads are sent encrypted
          in the\n   KEK generated by the Key Creation Payload information using the\n
          \  mechanisms defined in the group announcement.  This guarantees that\n
          \  the sensitive policy and key data for the group and potential rekey\n
          \  data for this individual cannot be read by anyone but the intended\n
          \  recipient.\n   If any error occurs during KeyDL message processing, regardless
          of\n   whether the GM is in Terse or Verbose Mode, the registration session\n
          \  MUST be terminated, the GM MUST send a Key Download - Ack/Failure\n   message,
          and all saved state information MUST be cleared.  If in\n   Terse Mode,
          the Notification Payload will be of type NACK to indicate\n   termination.
          \ If in Verbose Mode, the Notification Payload will\n   contain the type
          of error encountered.\n"
        title: 5.2.1.2.  Key Download
      - contents:
        - "5.2.1.3.  Request to Join Error\n   The exchange type for Request to Join
          Error is eleven (11).\n   The components of the Request to Join Error Message
          are shown in\n   Table 3:\n         Table 3: Request to Join Error (RTJ-Err)
          Message Definition\n      Message Name  : Request to Join Error (RTJ-Err)\n
          \     Dissection    : {HDR-GrpID, [Nonce_I], Notification, [VendorID]}\n
          \     Payload Types : GSAKMP Header, [Nonce] Notification, [Vendor ID]\n
          \  In response to an unacceptable RTJ, the GC/KS MAY send a Request to\n
          \  Join Error (RTJ-Err) message containing an appropriate Notification\n
          \  payload.  Note that the RTJ-Err message is not a signed message for\n
          \  the following reasons: the lack of awareness on the GM's perspective\n
          \  of who is a valid GC/KS as well as the need to protect the GC/KS from\n
          \  signing messages and using valuable resources.  Following the sending\n
          \  of an RTJ-Err, the GC/KS MUST terminate the session, and all saved\n
          \  state information MUST be cleared.\n   Upon receipt of an RTJ-Err message,
          the GM will validate the\n   following: the GroupID in the header belongs
          to a group to which the\n   GM has sent an RTJ, and, if present, the Nonce_I
          matches a Nonce_I\n   sent in an RTJ to that group.  If the above checks
          are successful,\n   the GM MAY terminate the state associated with that
          GroupID and\n   nonce.  The GM SHOULD be capable of receiving a valid KeyDownload\n
          \  message for that GroupID and nonce after receiving an RTJ-Err for a\n
          \  locally configured amount of time.\n"
        title: 5.2.1.3.  Request to Join Error
      - contents:
        - "5.2.1.4.  Key Download - Ack/Failure\n   The exchange type for Key Download
          - Ack/Failure is four (4).\n   The components of the Key Download - Ack/Failure
          Message are shown in\n   Table 4:\n      Table 4: Key Download - Ack/Failure
          (KeyDL-A/F) Message Definition\n      Message Name  : Key Download - Ack/Failure
          (KeyDL-A/F)\n      Dissection    : {HDR-GrpID, [Nonce_C], Notif_Ack, [VendorID]}SigM\n
          \     Payload Types : GSAKMP Header, [Nonce], Notification, [Vendor\n                      ID],
          Signature\n        SigM        : Signature of Group Member\n        {}SigX
          \     : Indicates fields used in Signature\n   In response to a properly
          processed KeyDL message, the GM creates and\n   sends the KeyDL-A/F message.
          \ As defined in the dissection of the\n   message, this message MUST contain
          payloads to hold the following\n   information: Notification payload of
          type Acknowledgement (ACK) and\n   signature information.  If synchronized
          time is not available, the\n   Nonce payload MUST be present for freshness,
          and the nonce value\n   transmitted MUST be the GM's generated Nonce_C value.
          \ If the GM does\n   not receive a KeyDL message within a locally configured
          amount of\n   time, the GM MAY send a new RTJ.  If the GM receives a valid
          LOA (see\n   Section 5.2.1.5) message from the GC/KS before receipt of a
          KeyDL\n   message, the GM SHOULD send a KeyDL-A/F message of type NACK followed\n
          \  by a new RTJ.\n   The GC/KS MUST be able to process the KeyDL-A/F message.
          \ <Process\n   KeyDL-A/F> indicates the GC/KS actions that will determine
          how the\n   KeyDL-A/F message will be acted upon.  The following checks
          SHOULD be\n   performed in the order presented.\n   In this procedure, the
          GC/KS will verify that the message header is\n   properly formed and confirm
          that this message is for this group by\n   checking the value of the GroupID.
          \ If the header checks pass, the\n   GC/KS MUST check the message for freshness.
          \ If using nonces, the\n   GC/KS MUST use its saved Nonce_C value and compare
          it for equality\n   with the received Nonce_C value.  If not using nonces,
          the GC/KS MUST\n   check the timestamp in the Signature payload to determine
          if the\n   message is new.  After freshness is confirmed, the signature
          MUST be\n   verified to ensure its authenticity.  The GC/KS MUST use verified
          and\n   trusted authentication material from a known root.  If the message\n
          \  signature verifies, the GC/KS processes the Notification payload.  If\n
          \  the notification type is of type ACK, then the registration has\n   completed
          successfully, and both parties SHOULD remove state\n   information associated
          with this GM's registration.\n   If the GC/KS does not receive a KeyDL-A/F
          message of proper form or\n   is unable to correctly process the KeyDL-A/F
          message, the\n   Notification payload type is any value except ACK; or if
          no KeyDL-A/F\n   message is received within the locally configured timeout,
          the GC/KS\n   MUST evict this GM from the group in the next policy-defined
          Rekey\n   Event.  The GC/KS MAY send the OPTIONAL Lack_of_Ack message if\n
          \  running in Verbose Mode as defined in Section 5.2.1.5.\n"
        title: 5.2.1.4.  Key Download - Ack/Failure
      - contents:
        - "5.2.1.5.  Lack of Ack\n   The exchange type for Lack of Ack is twelve (12).\n
          \  The components of a Lack of Ack Message are shown in Table 5:\n                Table
          5: Lack of Ack (LOA) Message Definition\n      Message Name  : Lack of Ack
          (LOA)\n      Dissection    : {HDR-GrpID, Member ID, [Nonce_R, Nonce_C],\n
          \                     Notification, [VendorID]} SigC, [Cert]\n      Payload
          Types : GSAKMP Header, Identification, [Nonce],\n                      Notification,
          [Vendor ID], Signature,\n                      [Certificate]\n        SigC
          \       : Signature of Group Controller Key Server\n        Cert        :
          Necessary Certificates, zero or more\n        {}SigX      : Indicates fields
          used in Signature\n        []          : Indicate an optional data item\n
          \  If the GC/KS's local timeout value expires prior to receiving a\n   KeyDL-A/F
          from the GM, the GC/KS MAY create and send a LOA message to\n   the GM.
          \ As defined in the dissection of the message, this message\n   MUST contain
          payloads to hold the following information: GM\n   identification, Notification
          of error, and signature information.\n   If synchronized time is not available,
          the Nonce payloads MUST be\n   present for freshness, and the nonce values
          transmitted MUST be the\n   GC/KS's generated Nonce_R value and the combined
          Nonce_C value which\n   was generated by using the GC/KS's Nonce_R value
          and the Nonce_I\n   value received from the GM in the RTJ.  These values
          were already\n   generated during the Key Download message phase.\n   The
          GM MAY be able to process the LOA message based upon local\n   configuration.
          \ <Process LOA> indicates the GM actions that will\n   determine how the
          LOA message will be acted upon.  The following\n   checks SHOULD be performed
          in the order presented.\n   In this procedure, the GM MUST verify that the
          message header is\n   properly formed and confirm that this message is for
          this group by\n   checking the value of the GroupID.  If the header checks
          pass, the GM\n   MUST confirm that this message was intended for itself
          by comparing\n   the Member ID in the Identification payload to its identity.
          \ After\n   identification confirmation, the freshness values are checked.
          \ If\n   using nonces, the GM MUST use its save Nonce_I value, extract the\n
          \  received GC/KS Nonce_R value, compute the combined Nonce_C value, and\n
          \  compare it to the received Nonce_C value.  If not using nonces, the\n
          \  GM MUST check the timestamp in the Signature payload to determine if\n
          \  the message is new.  After freshness is confirmed, access control\n   checks
          MUST be performed on the GC/KS to determine its authority\n   within this
          group.  Then signature MUST be verified to ensure its\n   authenticity,
          The GM MUST use verified and trusted authentication\n   material from a
          known root.\n   If the checks succeed, the GM SHOULD resend a KeyDL-A/F
          for that\n   session.\n"
        title: 5.2.1.5.  Lack of Ack
      title: 5.2.1.  Standard Group Establishment
    - contents:
      - "5.2.2.  Cookies: Group Establishment with Denial of Service Protection\n
        \  This section defines an OPTIONAL capability that MAY be implemented\n   into
        GSAKMP when using IP-based groups.  The information in this\n   section borrows
        heavily from [IKEv2] as this protocol has already\n   worked through this
        issue and GSAKMP is copying this concept.  This\n   section will contain paraphrased
        sections of [IKEv2] modified for\n   GSAKMP to define the purpose of Cookies.\n
        \  An optional Cookie mode is being defined for the GSAKMP to help\n   against
        DoS attacks.\n   The term \"cookies\" originates with Karn and Simpson [RFC2522]
        in\n   Photuris, an early proposal for key management with IPSec.  The\n   ISAKMP
        fixed message header includes two eight-octet fields titled\n   \"cookies\".
        \ Instead of placing this cookie data in the header, in\n   GSAKMP this data
        is moved into a Notification payload.\n   An expected attack against GSAKMP
        is state and CPU exhaustion, where\n   the target GC/KS is flooded with Request
        to Join requests from forged\n   IP addresses.  This attack can be made less
        effective if a GC/KS\n   implementation uses minimal CPU and commits no state
        to the\n   communication until it knows the initiator potential GM can receive\n
        \  packets at the address from which it claims to be sending them.  To\n   accomplish
        this, the GC/KS (when operating in Cookie mode) SHOULD\n   reject initial
        Request to Join messages unless they contain a\n   Notification payload of
        type \"cookie\".  It SHOULD instead send a\n   Cookie Download message as
        a response to the RTJ and include a cookie\n   in a notify payload of type
        Cookie_Required.  Potential GMs who\n   receive such responses MUST retry
        the Request to Join message with\n   the responder-GC/KS-supplied cookie in
        its notification payload of\n   type Cookie, as defined by the optional Notification
        payload of the\n   Request to Join Msg in Section 5.2.1.1.  This initial exchange
        will\n   then be as shown in Figure 2 with the components of the new message\n
        \  Cookie Download shown in Table 6.  The exchange type for Cookie\n   Download
        is ten (10).\n     CONTROLLER                  MESSAGE                  MEMBER\n
        \    in Cookie Mode\n               !<--Request to Join without Cookie Info---!\n
        \  <Gen Cookie>!                                         !\n   <Response  >!
        \                                        !\n               !----------Cookie
        Download--------------->!\n               !                                         !
        <Process CD>\n               !<----Request to Join with Cookie Info----!\n
        \    <Process> !                                         !\n     <RTJ    >
        !                                         !\n               !-------------Key
        Download--------------->!\n               !                                         !
        <Proc KeyDL>\n               !<-----Key Download -  Ack/Failure--------!\n
        \   <Process  >!                                         !\n    <KeyDL-A/F>!
        \                                        !\n               !<=======SHARED
        KEYED GROUP SESSION======>!\n               Figure 2: GSAKMP Ladder Diagram
        with Cookies\n                 Table 6: Cookie Download Message Definition\n
        \     Message Name  : Cookie Download\n      Dissection    : {HDR-GrpID, Notif_COOKIE_REQUIRED,
        [VendorID]}\n      Payload Types : GSAKMP Header, Notification, [Vendor ID]\n
        \  The first two messages do not affect any GM or GC/KS state except for\n
        \  communicating the cookie.\n   A GSAKMP implementation SHOULD implement
        its GC/KS cookie generation\n   in such a way as not to require any saved
        state to recognize its\n   valid cookie when the second Request to Join message
        arrives.  The\n   exact algorithms and syntax they use to generate cookies
        does not\n   affect interoperability and hence is not specified here.\n   The
        following is an example of how an endpoint could use cookies to\n   implement
        limited DoS protection.\n   A good way to do this is to set the cookie to
        be:\n   Cookie = <SecretVersionNumber> | Hash(Ni | IPi | <secret>)\n   where
        <secret> is a randomly generated secret known only to the\n   responder GC/KS
        and periodically changed, Ni is the nonce value taken\n   from the initiator
        potential GM, and IPi is the asserted IP address\n   of the candidate GM.
        \ The IP address is either the IP header's source\n   IP address or else the
        IP address contained in the optional\n   Notification \"IPvalue\" payload
        (if it is present).\n   <SecretVersionNumber> should be changed whenever <secret>
        is\n   regenerated.  The cookie can be recomputed when the \"Request to Join\n
        \  with Cookie Info\" arrives and compared to the cookie in the received\n
        \  message.  If it matches, the responder GC/KS knows that all values\n   have
        been computed since the last change to <secret> and that IPi\n   MUST be the
        same as the source address it saw the first time.\n   Incorporating Ni into
        the hash assures that an attacker who sees only\n   the Cookie_Download message
        cannot successfully forge a \"Request to\n   Join with Cookie Info\" message.
        \ This Ni value MUST be the same Ni\n   value from the original \"Request
        to Join\" message for the calculation\n   to be successful.\n   If a new value
        for <secret> is chosen while connections are in the\n   process of being initialized,
        a \"Request to Join with Cookie Info\"\n   might be returned with a <SecretVersionNumber>
        other than the current\n   one.  The responder GC/KS in that case MAY reject
        the message by\n   sending another response with a new cookie, or it MAY keep
        the old\n   value of <secret> around for a short time and accept cookies computed\n
        \  from either one.  The responder GC/KS SHOULD NOT accept cookies\n   indefinitely
        after <secret> is changed, since that would defeat part\n   of the denial
        of service protection.  The responder GC/KS SHOULD\n   change the value of
        <secret> frequently, especially if under attack.\n   An alternative example
        for Cookie value generation in a NAT\n   environment is to substitute the
        IPi value with the IPValue received\n   in the Notification payload in the
        RTJ message.  This scenario is\n   indicated by the presence of the Notification
        payload of type\n   IPValue.  With this substitution, a calculation similar
        to that\n   described above can be used.\n"
      title: '5.2.2.  Cookies: Group Establishment with Denial of Service Protection'
    - contents:
      - "5.2.3.  Group Establishment for Receive-Only Members\n   This section describes
        an OPTIONAL capability that may be implemented\n   in a structured system
        where the authorized (S-)GC/KS is known in\n   advance through out-of-band
        means and where synchronized time is\n   available.\n   Unlike Standard Group
        Establishment, in the Receive-Only system, the\n   GMs and (S-)GC/KSes operate
        in Terse Mode and exchange one message\n   only: the Key Download.  Potential
        new GMs do not send an RTJ.\n   (S-)GC/KSes do not expect Key Download - ACK/Failure
        messages and do\n   not remove GMs for lack or receipt of the message.\n   Operation
        is as follows: upon notification via an authorized out-of-\n   band event,
        the (S-)GC/KS forms and sends a Key Download message to\n   the new member
        with the Nonce payloads ABSENT.  The GM verifies\n   -  the ID payload identifies
        that GM\n   -  the timestamp in the message is fresh\n   -  the message is
        signed by an authorized (S-)GC/KS\n   -  the signature on the message verifies\n
        \  When using a Diffie-Hellman Key Creation Type for receive-only\n   members,
        a static-ephemeral model is assumed: the Key Creation\n   payload in the Key
        Download message contains the (S-)GC/KS's public\n   component.  The member's
        public component is assumed to be obtained\n   through secure out-of-band
        means.\n"
      title: 5.2.3.  Group Establishment for Receive-Only Members
    title: 5.2.  Group Establishment
  - contents:
    - "5.3.  Group Maintenance\n   The Group Maintenance phase includes member joins
      and leaves, group\n   rekey activities, policy updates, and group destruction.
      \ These\n   activities are presented in the following sections.\n"
    - contents:
      - '5.3.1.  Group Management

        '
      - contents:
        - "5.3.1.1.  Rekey Events\n   A Rekey Event is any action, including a compromise
          report or key\n   expiration, that requires the creation of a new group
          key and/or\n   rekey information.\n   Once an event has been identified
          (as defined in the group security\n   policy token), the GC/KS MUST create
          and provide a signed message\n   containing the GTPK and rekey information
          to the group.\n   Each GM who receives this message MUST verify the signature
          on the\n   message to ensure its authenticity.  If the message signature
          does\n   not verify, the message MUST be discarded.  Upon verification,
          the GM\n   will find the appropriate rekey download packet and decrypt the\n
          \  information with a stored rekey key(s).  If a new Policy Token is\n   distributed
          with the message, it MUST be encrypted in the old GTPK.\n   The exchange
          type for Rekey Event is five (5).\n   The components of a Rekey Event message
          are shown in Table 7:\n                   Table 7: Rekey Event Message Definition\n
          \     Message Name  : Rekey Event\n      Dissection    : {HDR-GrpID, ([Policy
          Token])*, Rekey Array,\n                      [VendorID]}SigC, [Cert]\n
          \     Payload Types : GSAKMP Header, [Policy Token], Rekey Event,\n                      [Vendor
          ID], Signature, [Certificate],\n        SigC        : Signature of Group
          Controller Key Server\n        Cert        : Necessary Certificates, zero
          or more\n        {}SigX      : Indicates fields used in Signature\n        (data)*
          \    : Indicates encrypted information\n        []          : Indicate an
          optional data item\n"
        title: 5.3.1.1.  Rekey Events
      - contents:
        - "5.3.1.2.  Policy Updates\n   New policy tokens are sent via the Rekey Event
          message.  These policy\n   updates may be coupled with an existing rekey
          event or may be sent in\n   a message with the Rekey Event Type of the Rekey
          Event Payload set to\n   None(0) (see Section 7.5.1).\n   A policy token
          MUST NOT be processed if the processing of the Rekey\n   Event message carrying
          it fails.  Policy token processing is type\n   dependent and is beyond the
          scope of this document.\n"
        title: 5.3.1.2.  Policy Updates
      - contents:
        - "5.3.1.3.  Group Destruction\n   Group destruction is also accomplished
          via the Rekey Event message.\n   In a Rekey Event message for group destruction,
          the Sequence ID is\n   set to 0xFFFFFFFF.  Upon receipt of this authenticated
          Rekey Event\n   message, group components MUST terminate processing of information\n
          \  associated with the indicated group.\n"
        title: 5.3.1.3.  Group Destruction
      title: 5.3.1.  Group Management
    - contents:
      - "5.3.2.  Leaving a Group\n   There are several conditions under which a member
        will leave a group:\n   eviction, voluntary departure without notice, and
        voluntary departure\n   with notice (de-registration).  Each of these is discussed
        in this\n   section.\n"
      - contents:
        - "5.3.2.1.  Eviction\n   At some point in the group's lifetime, it may be
          desirable to evict\n   one or more members from a group.  From a key management
          viewpoint,\n   this involves revoking access to the group's protected data
          by\n   \"disabling\" the departing members' keys.  This is accomplished
          with a\n   Rekey Event, which is discussed in more detail in Section 5.3.1.1.\n
          \  If future access to the group is also to be denied, the members MUST\n
          \  be added to a denied access control list, and the policy token's\n   authorization
          rules MUST be appropriately updated so that they will\n   exclude the expelled
          GM(s).  After receipt of a new PT, GMs SHOULD\n   evaluate the trustworthiness
          of any recent application data\n   originating from the expelled GM(s).\n"
        title: 5.3.2.1.  Eviction
      - contents:
        - "5.3.2.2.  Voluntary Departure without Notice\n   If a member wishes to
          leave a group for which membership imposes no\n   cost or responsibility
          to that member, then the member MAY merely\n   delete local copies of group
          keys and cease group activities.\n"
        title: 5.3.2.2.  Voluntary Departure without Notice
      - contents:
        - "5.3.2.3.  De-Registration\n   If the membership in the group does impose
          cost or responsibility to\n   the departing member, then the member SHOULD
          de-register from the\n   group when that member wishes to leave.  De-registration
          consists of\n   a three-message exchange between the GM and the member's
          GC/KS:  the\n   Request_to_Depart, Departure_Response, and the Departure_Ack.\n
          \  Compliant GSAKMP implementations for GMs SHOULD support the de-\n   registration
          messages.  Compliant GSAKMP implementations for GC/KSes\n   MUST support
          the de-registration messages.\n"
        - contents:
          - "5.3.2.3.1.  Request to Depart\n   The Exchange Type for a Request_to_Depart
            Message is thirteen (13).\n   The components of a Request_to_Depart Message
            are shown in Table 8.\n   Any GM desiring to initiate the de-registration
            process MUST generate\n   and send an RTD message to notify the GC/KS
            of its intent.  As\n   defined in the dissection of the RTD message, this
            message MUST\n   contain payloads to hold the following information: the
            GC/KS\n   identification and Notification of the desire to leave the group.\n
            \  When synchronization time is not available to the system as defined\n
            \  by the Policy Token, a Nonce payload MUST be included for freshness,\n
            \  and the Nonce_I value MUST be saved for later use.  This message MUST\n
            \  then be signed by the GM.\n             Table 8: Request_to_Depart
            (RTD) Message Definition\n     Message Name  : Request_to_Depart (RTD)\n
            \    Dissection    : {HDR-GrpID, GC/KS_ID, [Nonce_I], Notif_Leave_Group,\n
            \                    [VendorID]} SigM, [Cert]\n     Payload Types : GSAKMP
            Header, Identification, [Nonce],\n                     Notification, [Vendor
            ID], Signature,\n                     [Certificate]\n       SigM        :
            Signature of Group Member\n       Cert        : Necessary Certificates,
            zero or more\n       {}SigX      : Indicates fields used in Signature\n
            \      []          : Indicate an optional data item\n   Upon receipt of
            the RTD message, the GC/KS MUST verify that the\n   message header is
            properly formed and confirm that this message is\n   for this group by
            checking the value of the GroupID.  If the header\n   checks pass, then
            the identifier value in Identification payload is\n   compared to its
            own, the GC/KS's identity, to confirm that the GM\n   intended to converse
            with this GC/KS, the GC/KS who registered this\n   member into the group.
            \ Then the identity of the sender is extracted\n   from the Signature
            payload.  This identity MUST be used to confirm\n   that this GM is a
            member of the group serviced by this GC/KS.  Then\n   the GC/KS will confirm
            from the Notification payload that the GM is\n   requesting to leave the
            group.  Then the GC/KS will verify the\n   signature on the message to
            ensure its authenticity.  The GC/KS MUST\n   use verified and trusted
            authentication material from a known root.\n   If all checks pass and
            the message is successfully processed, then\n   the GC/KS MUST form a
            Departure_Response message as defined in\n   Section 5.3.2.3.2.\n   If
            the processing of the message fails, the de-registration session\n   MUST
            be terminated, and all state associated with this session is\n   removed.
            \ If the GC/KS is operating in Terse Mode, then no error\n   message is
            sent to the GM.  If the GC/KS is operating in Verbose\n   Mode, then the
            GC/KS sends a Departure_Response Message with a\n   Notification Payload
            of type Request_to_Depart_Error.\n"
          title: 5.3.2.3.1.  Request to Depart
        - contents:
          - "5.3.2.3.2.  Departure_Response\n   The Exchange Type for a Departure_Response
            Message is fourteen (14).\n   The components of a Departure_Response Message
            are shown in Table 9.\n   In response to a properly formed and verified
            RTD message, the GC/KS\n   MUST create and send the DR message.  As defined
            in the dissection of\n   the message, this message MUST contain payloads
            to hold the following\n   information: GM identification, Notification
            for acceptance of\n   departure, and signature information.  If synchronization
            time is not\n   available, the Nonce payloads MUST be included in the
            message for\n   freshness.\n             Table 9: Departure_Response (DR)
            Message Definition\n      Message Name  : Departure_Response (DR)\n      Dissection
            \   : {HDR-GrpID, Member_ID, [Nonce_R, Nonce_C],\n                      Notification,
            [VendorID]} SigC, [Cert]\n      Payload Types : GSAKMP Header, Identification,
            [Nonce],\n                      Notification, [Vendor ID], Signature,\n
            \                     [Certificate]\n        SigC        : Signature of
            Group Member\n        Cert        : Necessary Certificates, zero or more\n
            \       {}SigX      : Indicates fields used in Signature\n        []          :
            Indicate an optional data item\n   If present, the nonce values transmitted
            MUST be the GC/KS's\n   generated Nonce_R value and the combined Nonce_C
            value that was\n   generated by using the GC/KS's Nonce_R value and the
            Nonce_I value\n   received from the GM in the RTD.  This Nonce_C value
            MUST be saved\n   relative to this departing GM's ID.\n   The GM MUST
            be able to process the Departure_Response message.  The\n   following
            checks SHOULD be performed in the order presented.\n   The GM MUST verify
            that the message header is properly formed and\n   confirm that this message
            is for this group by checking the value of\n   the GroupID.  If the header
            checks pass, the GM MUST confirm that\n   this message was intended for
            itself by comparing the Member ID in\n   the Identification payload to
            its identity.  After identification\n   confirmation, the freshness values
            are checked.  If using nonces, the\n   GM MUST use its saved Nonce_I value,
            extract the received GC/KS\n   Nonce_R value, compute the combined Nonce_C
            value, and compare it for\n   equality with the received Nonce_C value.
            \ If not using nonces, the\n   GM MUST check the timestamp in the signature
            payload to determine if\n   the message is new.  After freshness is confirmed,
            confirmation of\n   the identity of the signer of the DR message is the
            GMs authorized\n   GC/KS is performed.  Then, the signature MUST be verified
            to ensure\n   its authenticity.  The GM MUST use verified and trusted\n
            \  authentication material from a known root.  If the message signature\n
            \  verifies, then the GM MUST verify that the Notification is of Type\n
            \  Departure_Accepted or Request_to_Depart_Error.\n   If the processing
            is successful, and the Notification payload is of\n   type Departure_Accepted,
            the member MUST form the Departure_ACK\n   message as defined in Section
            5.3.2.3.3.  If the processing is\n   successful, and the Notification
            payload is of type\n   Request_to_Depart_Error, the member MUST remove
            all state associated\n   with the de-registration session.  If the member
            still desires to\n   De-Register from the group, the member MUST restart
            the de-\n   registration process.\n   If the processing of the message
            fails, the de-registration session\n   MUST be terminated, and all state
            associated with this session is\n   removed.  If the GM is operating in
            Terse Mode, then a Departure_Ack\n   Message with Notification Payload
            of type NACK is sent to the GC/KS.\n   If the GM is operating in Verbose
            Mode, then the GM sends a\n   Departure_Ack Message with a Notification
            Payload of the appropriate\n   failure type.\n"
          title: 5.3.2.3.2.  Departure_Response
        - contents:
          - "5.3.2.3.3.  Departure_ACK\n   The Exchange Type for a Departure_ACK Message
            is fifteen (15).  The\n   components of the Departure_ACK Message are
            shown in Table 10:\n               Table 10: Departure_ACK (DA) Message
            Definition\n      Message Name  : Departure_ACK (DA)\n      Dissection
            \   : {HDR-GrpID, [Nonce_C], Notif_Ack, [VendorID]}SigM\n      Payload
            Types : GSAKMP Header, [Nonce], Notification, [Vendor\n                      ID],
            Signature\n        SigM        : Signature of Group Member\n        {}SigX
            \     : Indicates fields used in Signature\n   In response to a properly
            processed Departure_Response message, the\n   GM MUST create and send
            the Departure_ACK message.  As defined in the\n   dissection of the message,
            this message MUST contain payloads to hold\n   the following information:
            Notification payload of type\n   Acknowledgement (ACK) and signature information.
            \ If synchronization\n   time is not available, the Nonce payload MUST
            be present for\n   freshness, and the nonce value transmitted MUST be
            the GM's generated\n   Nonce_C value.\n   Upon receipt of the Departure_ACK,
            the GC/KS MUST perform the\n   following checks.  These checks SHOULD
            be performed in the order\n   presented.\n   In this procedure, the GC/KS
            MUST verify that the message header is\n   properly formed and confirm
            that this message is for this group by\n   checking the value of the GroupID.
            \ If the header checks pass, the\n   GC/KS MUST check the message for
            freshness.  If using nonces, the\n   GC/KS MUST use its saved Nonce_C
            value and compare it to the received\n   Nonce_C value.  If not using
            nonces, the GC/KS MUST check the\n   timestamp in the signature payload
            to determine if the message is\n   new.  After freshness is confirmed,
            the signature MUST be verified to\n   ensure its authenticity.  The GC/KS
            MUST use verified and trusted\n   authentication material from a known
            root.  If the message signature\n   verifies, the GC/KS processes the
            Notification payload.  If the\n   notification type is of type ACK, this
            is considered a successful\n   processing of this message.\n   If the
            processing of the message is successful, the GC/KS MUST remove\n   the
            member from the group.  This MAY involve initiating a Rekey Event\n   for
            the group.\n   If the processing of the message fails or if no Departure_Ack
            is\n   received, the GC/KS MAY issue a LOA message.\n"
          title: 5.3.2.3.3.  Departure_ACK
        title: 5.3.2.3.  De-Registration
      title: 5.3.2.  Leaving a Group
    title: 5.3.  Group Maintenance
  title: 5.  Group Life Cycle
- contents:
  - "6.  Security Suite\n   The Security Definition Suite 1 MUST be supported.  Other
    security\n   suite definitions MAY be defined in other Internet specifications.\n"
  - contents:
    - "6.1.  Assumptions\n   All potential GMs will have enough information available
      to them to\n   use the correct Security Suite to join the group.  This can be\n
      \  accomplished by a well-known default suite, 'Security Suite 1', or by\n   announcing/posting
      another suite.\n"
    title: 6.1.  Assumptions
  - contents:
    - "6.2.  Definition Suite 1\n   GSAKMP implementations MUST support the following
      suite of algorithms\n   and configurations.  The following definition of Suite
      1 borrows\n   heavily from IKE's Oakley group 2 definition and Oakley itself.\n
      \  The GSAKMP Suite 1 definition gives all the algorithm and\n   cryptographic
      definitions required to process group establishment\n   messages.  It is important
      to note that GSAKMP does not negotiate\n   these cryptographic mechanisms.  This
      definition is set by the Group\n   Owner via the Policy Token (passed during
      the GSAKMP exchange for\n   member verification purposes).\n   The GSAKMP Suite
      1 definition is:\n     Key download and Policy Token encryption algorithm definition:\n
      \    Algorithm:  AES\n     Mode:       CBC\n     Key Length: 128 bits\n     Policy
      Token digital signature algorithm is:\n       DSS-ASN1-DER\n       Hash algorithm
      is:\n       SHA-1\n     Nonce Hash algorithm is:\n       SHA-1\n     The Key
      Creation definition is:\n     Algorithm type is Diffie Hellman\n     MODP group
      definition\n     g:   2\n     p:   \"FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B
      80DC1CD1\"\n          \"29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD\"\n
      \         \"EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245\"\n          \"E485B576
      625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED\"\n          \"EE386BFB 5A899FA5
      AE9F2411 7C4B1FE6 49286651 ECE65381\"\n          \"FFFFFFFF FFFFFFFF\"\n     NOTE:
      The p and g values come from IKE [RFC2409], Section 6.2,\n           \"Second
      Oakley Group\", and p is 1024 bits long.\n     The GSAKMP message digital signature
      algorithm is:\n     DSS-SHA1-ASN1-DER\n     The digital signature ID type is:\n
      \    ID-DN-STRING\n"
    title: 6.2.  Definition Suite 1
  title: 6.  Security Suite
- contents:
  - "7.  GSAKMP Payload Structure\n   A GSAKMP Message is composed of a GSAKMP Header
    (Section 7.1)\n   followed by at least one GSAKMP Payload.  All GSAKMP Payloads
    are\n   composed of the Generic Payload Header (Section 7.2) followed by the\n
    \  specific payload data.  The message is chained by a preceding payload\n   defining
    its succeeding payload.  Payloads are not required to be in\n   the exact order
    shown in the message dissection in Section 5,\n   provided that all required payloads
    are present.  Unless it is\n   explicitly stated in a dissection that multiple
    payloads of a single\n   type may be present, no more than one payload of each
    type allowed by\n   the message may appear.  The final payload in a message will
    point to\n   no succeeding payload.\n   All fields of type integer in the Header
    and Payload structure that\n   are larger than one octet MUST be converted into
    Network Byte Order\n   prior to data transmission.\n   Padding of fields MUST
    NOT be done as this leads to processing\n   errors.\n   When a message contains
    a Vendor ID payload, the processing of the\n   payloads of that message is modified
    as defined in Section 7.10.\n"
  - contents:
    - '7.1.  GSAKMP Header

      '
    - contents:
      - "7.1.1.  GSAKMP Header Structure\n   The GSAKMP Header fields are shown in
        Figure 3 and defined as:\n    0                   1                   2                   3\n
        \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! GroupID Type  ! GroupID Length!      Group ID Value           ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ~                                                               ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ~               ! Next Payload  !   Version     ! Exchange Type !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! Sequence ID                                                   !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! Length                                                        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \                 Figure 3: GSAKMP Header Format\n   Group Identification
        Type (1 octet) - Table 11 presents the group\n       identification types.
        \ This field is treated as an unsigned\n       value.\n                     Table
        11:  Group Identification Types\n   Grp ID Type          Value       Description\n
        \  _____________________________________________________________________\n
        \  Reserved               0\n   UTF-8                  1         Format defined
        in Section 7.1.1.1.1.\n   Octet String           2         This type MUST
        be implemented.\n                                    Format defined in Section
        7.1.1.1.2.\n   IPv4                   3         Format defined in Section
        7.1.1.1.3.\n   IPv6                   4         Format defined in Section
        7.1.1.1.4.\n   Reserved to IANA    5 - 192\n   Private Use        193 - 255\n
        \  Group Identification Length (1 octet)  - Length of the Group\n       Identification
        Value field in octets.  This value MUST NOT be\n       zero (0).  This field
        is treated as an unsigned value.\n   Group Identification Value (variable
        length)  - Indicates the\n       name/title of the group.  All GroupID types
        should provide unique\n       naming across groups.  GroupID types SHOULD
        provide this\n       capability by including a random element generated by
        the creator\n       (owner) of the group of at least eight (8) octets, providing\n
        \      extremely low probability of collision in group names.  The\n       GroupID
        value is static throughout the life of the group.\n   Next Payload (1 octet)
        \ - Indicates the type of the next payload in\n       the message.  The format
        for each payload is defined in the\n       following sections.  Table 12 presents
        the payload types.  This\n       field is treated as an unsigned value.\n
        \                          Table 12: Payload Types\n                      Next_Payload_Type
        \       Value\n                     ___________________________________\n
        \                     None                       0\n                      Policy
        Token               1\n                      Key Download Packet        2\n
        \                     Rekey Event                3\n                      Identification
        \            4\n                      Reserved                   5\n                      Certificate
        \               6\n                      Reserved                   7\n                      Signature
        \                 8\n                      Notification               9\n
        \                     Vendor ID                  10\n                      Key
        Creation               11\n                      Nonce                      12\n
        \                     Reserved to IANA        13 - 192\n                      Private
        Use            193 - 255\n   Version (1 octet) - Indicates the version of
        the GSAKMP protocol in\n       use.  The current value is one (1).  This field
        is treated as an\n       unsigned value.\n   Exchange Type (1 octet) - Indicates
        the type of exchange (also known\n       as the message type).  Table 13 presents
        the exchange type\n       values.  This field is treated as an unsigned value.\n
        \                          Table 13: Exchange Types\n                    Exchange_Type
        \                Value\n                   ________________________________________\n
        \                   Reserved                      0 - 3\n                    Key
        Download Ack/Failure        4\n                    Rekey Event                     5\n
        \                   Reserved                      6 - 7\n                    Request
        to Join                 8\n                    Key Download                    9\n
        \                   Cookie Download                10\n                    Request
        to Join Error          11\n                    Lack of Ack                    12\n
        \                   Request to Depart              13\n                    Departure
        Response             14\n                    Departure Ack                  15\n
        \                   Reserved to IANA            16 - 192\n                    Private
        Use                193 - 255\n   Sequence ID (4 octets) - The Sequence ID
        is used for replay\n       protection of group management messages.  If the
        message is not a\n       group management message, this value MUST be set
        to zero (0).\n       The first value used by a (S-)GC/KS MUST be one (1).
        \ For each\n       distinct group management message that this (S-)GC/KS transmits,\n
        \      this value MUST be incremented by one (1).  Receivers of this\n       group
        management message MUST confirm that the value received is\n       greater
        than the value of the sequence ID received with the last\n       group management
        message from this (S-)GC/KS.  Group Components\n       (e.g., GMs, S-GC/KSes)
        MUST terminate processing upon receipt of\n       an authenticated group management
        message containing a Sequence\n       ID of 0xFFFFFFFF.  This field is treated
        as an unsigned integer\n       in network byte order.\n   Length (4 octets)
        - Length of total message (header + payloads) in\n       octets.  This field
        is treated as an unsigned integer in network\n       byte order.\n"
      - contents:
        - "7.1.1.1.  GroupID Structure\n   This section defines the formats for the
          defined GroupID types.\n"
        - contents:
          - "7.1.1.1.1.  UTF-8\n   The format for type UTF-8 [RFC3629] is shown in
            Figure 4.\n    0                   1                   2                   3\n
            \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n
            \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
            \  ! Random Value                                                  ~\n
            \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
            \  ~                                                               ~\n
            \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
            \  ~                                                               ~\n
            \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
            \  ~                                                               !\n
            \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
            \  ! UTF-8 String                                                  ~\n
            \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
            \                 Figure 4: GroupID UTF-8 Format\n   Random Value (16
            octets) - For the UTF-8 GroupID type, the Random\n       Value is represented
            as a string of exactly 16 hexadecimal digits\n       converted from its
            octet values in network-byte order.  The\n       leading zero hexadecimal
            digits and the trailing zero hexadecimal\n       digits are always included
            in the string, rather than being\n       truncated.\n   UTF-8 String (variable
            length) - This field contains the human\n       readable portion of the
            GroupID in UTF-8 format.  Its length is\n       calculated as the (GroupID
            Length - 16) for the Random Value\n       field.  The minimum length for
            this field is one (1) octet.\n"
          title: 7.1.1.1.1.  UTF-8
        - contents:
          - "7.1.1.1.2.  Octet String\n   The format for type Octet String is shown
            in Figure 5.\n    0                   1                   2                   3\n
            \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n
            \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
            \  ! Random Value                                                  ~\n
            \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
            \  ~                                                               !\n
            \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
            \  ! Octet String                                                  ~\n
            \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
            \             Figure 5:  GroupID Octet String Format\n   Random Value
            (8 octets) - The 8-octet unsigned random value in\n       network byte
            order format.\n   Octet String (variable length) - This field contains
            the Octet String\n       portion of the GroupID.  Its length is calculated
            as the (GroupID\n       Length - 8) for the Random Value field.  The minimum
            length for\n       this field is one (1) octet.\n"
          title: 7.1.1.1.2.  Octet String
        - contents:
          - "7.1.1.1.3.  IPv4 Group Identifier\n   The format for type IPv4 Group
            Identifier is shown in Figure 6.\n    0                   1                   2
            \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
            2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
            \  ! Random Value                                                  ~\n
            \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
            \  ~                                                               !\n
            \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
            \  ! IPv4 Value                                                    !\n
            \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
            \                 Figure 6: GroupID IPv4 Format\n   Random Value (8 octets)
            - The 8-octet unsigned random value in\n       network byte order format.\n
            \  IPv4 Value (4 octets) - The IPv4 value in network byte order format.\n
            \      This value MAY contain the multicast address of the group.\n"
          title: 7.1.1.1.3.  IPv4 Group Identifier
        - contents:
          - "7.1.1.1.4.  IPv6 Group Identifier\n   The format for type IPv6 Group
            Identifier is shown in Figure 7.\n    0                   1                   2
            \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
            2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
            \  ! Random Value                                                  ~\n
            \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
            \  ~                                                               !\n
            \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
            \  ! IPv6 Value                                                    ~\n
            \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
            \  ~                                                               ~\n
            \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
            \  ~                                                               ~\n
            \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
            \  ~                                                               !\n
            \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
            \                 Figure 7: GroupID IPv6 Format\n   Random Value (8 octets)
            - The 8-octet unsigned random value in\n       network byte order format.\n
            \  IPv6 Value (16 octets) - The IPv6 value in network byte order format.\n
            \      This value MAY contain the multicast address of the group.\n"
          title: 7.1.1.1.4.  IPv6 Group Identifier
        title: 7.1.1.1.  GroupID Structure
      title: 7.1.1.  GSAKMP Header Structure
    - contents:
      - "7.1.2.  GSAKMP Header Processing\n   When processing the GSAKMP Header, the
        following fields MUST be\n   checked for correct values:\n   1.  Group ID
        Type - The Group ID Type value MUST be checked to be a\n       valid group
        identification payload type as defined by Table 11.\n       If the value is
        not valid, then an error is logged.  If in\n       Verbose Mode, an appropriate
        message containing notification\n       value Payload-Malformed will be sent.\n
        \  2.  GroupID - The GroupID of the received message MUST be checked\n       against
        the valid GroupIDs of the Group Component.  If no match\n       is found,
        then an error is logged; in addition, if in Verbose\n       Mode, an appropriate
        message containing notification value\n       Invalid-Group-ID will be sent.\n
        \  3.  Next Payload - The Next Payload value MUST be checked to be a\n       valid
        payload type as defined by Table 12.  If the value is not\n       valid, then
        an error is logged.  If in Verbose Mode, an\n       appropriate message containing
        notification value Invalid-\n       Payload-Type will be sent.\n   4.  Version
        - The GSAKMP version number MUST be checked that its\n       value is one
        (1).  For other values, see below for processing.\n       The GSAKMP version
        number MUST be checked that it is consistent\n       with the group's policy
        as specified in its Policy Token.  If the\n       version is not supported
        or authorized, then an error is logged.\n       If in Verbose Mode, an appropriate
        message containing\n       notification value Invalid-Version will be sent.\n
        \  5.  Exchange Type - The Exchange Type MUST be checked to be a valid\n       exchange
        type as defined by Table 13 and MUST be of the type\n       expected to be
        received by the GSAKMP state machine.  If the\n       exchange type is not
        valid, then an error is logged.  If in\n       Verbose Mode, an appropriate
        message containing notification\n       value Invalid-Exchange-Type will be
        sent.\n   6.  Sequence ID - The Sequence ID value MUST be checked for\n       correctness.
        \ For negotiation messages, this value MUST be zero\n       (0).  For group
        management messages, this value MUST be greater\n       than the last sequence
        ID received from this (S-)GC/KS.  Receipt\n       of incorrect Sequence ID
        on group management messages MUST NOT\n       cause a reply message to be
        generated.  Upon receipt of incorrect\n       Sequence ID on non-group management
        messages, an error is logged.\n       If in Verbose Mode, an appropriate message
        containing\n       notification value Invalid-Sequence-ID will be sent.\n
        \  The length fields in the GSAKMP Header (Group ID Length and Length)\n   are
        used to help process the message.  If any field is found to be\n   incorrect,
        then an error is logged.  If in Verbose Mode, an\n   appropriate message containing
        notification value Payload-Malformed\n   will be sent.\n   In order to allow
        a GSAKMP version one (v1) implementation to\n   interoperate with future versions
        of the protocol, some ideas will be\n   discussed here to this effect.\n   A
        (S-)GC/KS that is operating in a multi-versioned group as defined\n   by the
        Policy Token can take many approaches on how to interact with\n   the GMs
        in this group for a rekey message.\n   One possible solution is for the (S-)GC/KS
        to send out multiple rekey\n   messages, one per version level that it supports.
        \ Then each GM would\n   only process the message that has the version at
        which it is\n   operating.\n   An alternative approach that all GM v1 implementations
        MUST support\n   is the embedding of a v1 message inside a version two (v2)
        message.\n   If a GM running at v1 receives a GSAKMP message that has a version\n
        \  value greater than one (1), the GM will attempt to process the\n   information
        immediately after the Group Header as a Group Header for\n   v1 of the protocol.
        \ If this is in fact a v1 Group Header, then the\n   remainder of this v1
        message will be processed in place.  After\n   processing this v1 embedded
        message, the data following the v1\n   message should be the payload as identified
        by the Next Payload field\n   in the original header of the message and will
        be ignored by the v1\n   member.  However, if the payload following the initial
        header is not\n   a v1 Group Header, then the GM will gracefully handle the\n
        \  unrecognized message.\n"
      title: 7.1.2.  GSAKMP Header Processing
    title: 7.1.  GSAKMP Header
  - contents:
    - '7.2.  Generic Payload Header

      '
    - contents:
      - "7.2.1.  Generic Payload Header Structure\n   Each GSAKMP payload defined
        in the following sections begins with a\n   generic header, shown in Figure
        8, that provides a payload \"chaining\"\n   capability and clearly defines
        the boundaries of a payload.  The\n   Generic Payload Header fields are defined
        as follows:\n    0                   1                   2                   3\n
        \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! Next Payload  !   RESERVED    !         Payload Length        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \                Figure 8: Generic Payload Header\n   Next Payload (1 octet)
        - Identifier for the payload type of the next\n       payload in the message.
        \ If the current payload is the last in\n       the message, then this field
        will be 0.  This field provides the\n       \"chaining\" capability.  Table
        12 identifies the payload types.\n       This field is treated as an unsigned
        value.\n   RESERVED (1 octet) - Unused, set to 0.\n   Payload Length (2 octets)
        - Length in octets of the current payload,\n       including the generic payload
        header.  This field is treated as\n       an unsigned integer in network byte
        order format.\n"
      title: 7.2.1.  Generic Payload Header Structure
    - contents:
      - "7.2.2.  Generic Payload Header Processing\n   When processing the Generic
        Payload Header, the following fields MUST\n   be checked for correct values:\n
        \  1.  Next Payload - The Next Payload value MUST be checked to be a\n       valid
        payload type as defined by Table 12.  If the payload type\n       is not valid,
        then an error is logged.  If in Verbose Mode, an\n       appropriate message
        containing notification value Invalid-\n       Payload-Type will be sent.\n
        \  2.  RESERVED - This field MUST contain the value zero (0).  If the\n       value
        of this field is not zero (0), then an error is logged.  If\n       in Verbose
        Mode, an appropriate message containing notification\n       value Payload-Malformed
        will be sent.\n   The length field in the Generic Payload Header is used to
        process the\n   remainder of the payload.  If this field is found to be incorrect,\n
        \  then an error is logged.  If in Verbose Mode, an appropriate message\n
        \  containing notification value Payload-Malformed will be sent.\n"
      title: 7.2.2.  Generic Payload Header Processing
    title: 7.2.  Generic Payload Header
  - contents:
    - '7.3.  Policy Token Payload

      '
    - contents:
      - "7.3.1.  Policy Token Payload Structure\n   The Policy Token Payload contains
        authenticatable group-specific\n   information that describes the group security-relevant
        behaviors,\n   access control parameters, and security mechanisms.  Figure
        9 shows\n   the format of the payload.\n    0                   1                   2
        \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! Next Payload  !   RESERVED    !         Payload Length        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! Policy Token Type             ! Policy Token Data             ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \             Figure 9: Policy Token Payload Format\n   The Policy Token Payload
        fields are defined as follows:\n   Next Payload (1 octet) - Identifier for
        the payload type of the next\n       payload in the message.  If the current
        payload is the last in\n       the message, then this field will be 0.  This
        field provides the\n       \"chaining\" capability.  Table 12 identifies the
        payload types.\n       This field is treated as an unsigned value.\n   RESERVED
        (1 octet) - Unused, set to 0.\n   Payload Length (2 octets) - Length in octets
        of the current payload,\n       including the generic payload header.  This
        field is treated as\n       an unsigned integer in network byte order format.\n
        \  Policy Token Type (2 octets) - Specifies the type of Policy Token\n       being
        used.  Table 14 identifies the types of policy tokens.\n       This field
        is treated as an unsigned integer in network byte\n       order format.\n
        \                      Table 14: Policy Token Types\n    Policy_Token_Type
        \     Value         Definition/Defined In\n   ____________________________________________________________________\n
        \  Reserved                  0\n   GSAKMP_ASN.1_PT_V1        1          All
        implementations of GSAKMP\n                                        MUST support
        this PT format.\n                                        Format specified
        in [RFC4534].\n   Reserved to IANA      2 - 49152\n   Private Use         49153
        - 65535\n   Policy Token Data (variable length) - Contains Policy Token\n
        \      information.  The values for this field are token specific, and\n       the
        format is specified by the PT Type field.\n   If this payload is encrypted,
        only the Policy Token Data field is\n   encrypted.\n   The payload type for
        the Policy Token Payload is one (1).\n"
      title: 7.3.1.  Policy Token Payload Structure
    - contents:
      - "7.3.2.  Policy Token Payload Processing\n   When processing the Policy Token
        Payload, the following fields MUST\n   be checked for correct values:\n   1.
        \ Next Payload, RESERVED, Payload Length - These fields are\n       processed
        as defined in Section 7.2.2, \"Generic Payload Header\n       Processing\".\n
        \  2.  Policy Token Type - The Policy Token Type value MUST be checked\n       to
        be a valid policy token type as defined by Table 14.  If the\n       value
        is not valid, then an error is logged.  If in Verbose Mode,\n       an appropriate
        message containing notification value Payload-\n       Malformed will be sent.\n
        \  3.  Policy Token Data - This Policy Token Data MUST be processed\n       according
        to the Policy Token Type specified.  The type will\n       define the format
        of the data.\n"
      title: 7.3.2.  Policy Token Payload Processing
    title: 7.3.  Policy Token Payload
  - contents:
    - "7.4.  Key Download Payload\n   Refer to the terminology section for the different
      terms relating to\n   keys used within this section.\n"
    - contents:
      - "7.4.1.  Key Download Payload Structure\n   The Key Download Payload contains
        group keys (e.g., group keys,\n   initial rekey keys, etc.).  These key download
        payloads can have\n   several security attributes applied to them based upon
        the security\n   policy of the group.  Figure 10 shows the format of the payload.\n
        \  The security policy of the group dictates that the key download\n   payload
        MUST be encrypted with a key encryption key (KEK).  The\n   encryption mechanism
        used is specified in the Policy Token.  The\n   group members MUST create
        the KEK using the key creation method\n   identified in the Key Creation Payload.\n
        \   0                   1                   2                   3\n    0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! Next Payload  !   RESERVED    !         Payload Length        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! Number of Items               ! Key Download Data Items       ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \             Figure 10: Key Download Payload Format\n   The Key Download
        Payload fields are defined as follows:\n   Next Payload (1 octet) - Identifier
        for the payload type of the next\n       payload in the message.  If the current
        payload is the last in\n       the message, then this field will be 0.  This
        field provides the\n       \"chaining\" capability.  Table 12 identifies the
        payload types.\n       This field is treated as an unsigned value.\n   RESERVED
        (1 octet) - Unused, set to 0.\n   Payload Length (2 octets) - Length in octets
        of the current payload,\n       including the generic payload header.  This
        field is treated as\n       an unsigned integer in network byte order format.\n
        \  Number of Items (2 octets) - Contains the total number of group\n       traffic
        protection keys and Rekey Arrays being passed in this\n       data block.
        \ This field is treated as an unsigned integer in\n       network byte order
        format.\n   Key Download Data Items (variable length) - Contains Key Download\n
        \      information.  The Key Download Data is a sequence of\n       Type/Length/Data
        of the Number of Items.  The format for each\n       item is defined in Figure
        11.\n    0                   1                   2                   3\n    0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! KDD Item Type !  Key Download Data Item Length!               ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ~ Data for Key Download Data Item (Key Datum/Rekey Array)       ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \            Figure 11: Key Download Data Item Format\n   For each Key Download
        Data Item, the data format is as follows:\n       Key Download Data (KDD)
        Item Type (1 octet) - Identifier for the\n           type of data contained
        in this Key Download Data Item.  See\n           Table 15 for the possible
        values of this field.  This field\n           is treated as an unsigned value.\n
        \      Key Download Data Item Length (2 octets) - Length in octets of\n           the
        Data for the Key Download Data Item following this field.\n           This
        field is treated as an unsigned integer in network byte\n           order
        format.\n       Data for Key Download Data Item (variable length) - Contains
        Keys\n           and related information.  The format of this field is\n           specific
        depending on the value of the Key Download Data Item\n           Type field.
        \ For KDD Item Type of GTPK, this field will\n           contain a Key Datum
        as defined in Section 7.4.1.1.  For KDD\n           Item Type Rekey - LKH,
        this field will contain a Rekey Array\n           as defined in Section 7.4.1.2.\n
        \                Table 15: Key Download Data Item Types\n   Key Download Data
        \    Value      Definition\n   Item Type\n   _________________________________________________________________\n
        \  GTPK                    0        This type MUST be implemented.\n                                    This
        type identifies that the\n                                    data contains
        group traffic\n                                    protection key information.\n
        \  Rekey - LKH             1        Optional\n   Reserved to IANA     2 -
        192\n   Private Use         193 - 255\n   The encryption of this payload only
        covers the data subsequent to the\n   Generic Payload header (Number of Items
        and Key Download Data Items\n   fields).\n   The payload type for the Key
        Download Packet is two (2).\n"
      - contents:
        - "7.4.1.1.  Key Datum Structure\n   A Key Datum contains all the information
          for a key.  Figure 12 shows\n   the format for this structure.\n    0                   1
          \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2
          3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ! Key Type                      ! Key ID                        ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ~                               ! Key Handle                    ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ~                               ! Key Creation Date             ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ~                                                               ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ~                                                               ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ~                                                               ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  !               ! Key Expiration Date                           ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ~                                                               !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ~                                                               !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ~                                               !               ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ~ Key Data                                                      ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \                  Figure 12: Key Datum Format\n   Key Type (2 octets) -
          This is the cryptographic algorithm for which\n       this key data is to
          be used.  This value is specified in the\n       Policy Token.  See Table
          16 for the possible values of this\n       field.  This field is treated
          as an unsigned value.\n                    Table 16: Cryptographic Key Types\n
          \   Cryptographic_Key_Types     Value         Description/Defined In\n   ____________________________________________________________________\n
          \  Reserved                     0 - 2\n   3DES_CBC64_192                 3
          \          See [RFC2451].\n   Reserved                     4 - 11\n   AES_CBC_128
          \                   12          This type MUST be\n                                              supported.
          \ See [IKEv2].\n   AES_CTR                        13          See [IKEv2].\n
          \  Reserved to IANA           14 - 49152\n   Private Use              49153
          - 65535\n   Key ID (4 octets) - This is the permanent ID of all versions
          of the\n       key.  This value MAY be defined by the Policy Token.  This
          field\n       is treated as an octet string.\n   Key Handle (4 octets) -
          This is the value to uniquely identify a\n       version (particular instance)
          of a key.  This field is treated as\n       an octet string.\n   Key Creation
          Date (15 octets) - This is the time value of when this\n       key data
          was originally generated.  This field contains the\n       timestamp in
          UTF-8 format YYYYMMDDHHMMSSZ, where YYYY is the year\n       (0000 - 9999),
          MM is the numerical value of the month (01 - 12),\n       DD is the day
          of the month (01 - 31), HH is the hour of the day\n       (00 - 23), MM
          is the minute within the hour (00 - 59), SS is the\n       seconds within
          the minute (00 - 59), and the letter Z indicates\n       that this is Zulu
          time.  This format is loosely based on\n       [RFC3161].\n   Key Expiration
          Date (15 octets) - This is the time value of when this\n       key is no
          longer valid for use.  This field contains the\n       timestamp in UTF-8
          format YYYYMMDDHHMMSSZ, where YYYY is the year\n       (0000 - 9999), MM
          is the numerical value of the month (01 - 12),\n       DD is the day of
          the month (01 - 31), HH is the hour of the day\n       (00 - 23), MM is
          the minute within the hour (00 - 59), SS is the\n       seconds within the
          minute (00 - 59), and the letter Z indicates\n       that this is Zulu time.
          \ This format is loosely based on\n       [RFC3161].\n   Key Data (variable
          length) - This is the actual key data, which is\n       dependent on the
          Key Type algorithm for its format.\n   NOTE: The combination of the Key
          ID and the Key Handle MUST be unique\n   within the group.  This combination
          will be used to uniquely identify\n   a key.\n"
        title: 7.4.1.1.  Key Datum Structure
      - contents:
        - "7.4.1.2.  Rekey Array Structure\n   A Rekey Array contains the information
          for the set of KEKs that is\n   associated with a Group Member.  Figure
          13 shows the format for this\n   structure.\n    0                   1                   2
          \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
          3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ! Rekey Version#! Member ID                                     ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ~               ! Number of KEK Keys            !               ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ~ Key Datum(s)                                                  ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \            Figure 13: Rekey Array Structure Format\n   Rekey Version (1
          octet) - Contains the version of the Rekey protocol\n       in which the
          data is formatted.  For Key Download Data Item Type\n       of Rekey - LKH,
          refer to Section A.2 for a description of this\n       value.  This field
          is treated as an unsigned value.\n   Member ID (4 octets) - This is the
          Member ID of the Rekey sequence\n       contained in this Rekey Array.  This
          field is treated as an octet\n       string.  For Key Download Data Item
          Type of Rekey - LKH, refer to\n       Section A.2 for a description of this
          value.\n   Number of KEK Keys (2 octets) - This value is the number of distinct\n
          \      KEK keys in this sequence.  This value is treated as an unsigned\n
          \      integer in network byte order format.\n   Key Datum(s) (variable
          length) - The sequence of KEKs in Key Datum\n       format.  The format
          for each Key Datum in this sequence is\n       defined in section 7.4.1.1.\n
          \  Key ID (for Key ID within the Rekey) - LKH space, refer to Section\n
          \      A.2 for a description of this value.\n"
        title: 7.4.1.2.  Rekey Array Structure
      title: 7.4.1.  Key Download Payload Structure
    - contents:
      - "7.4.2.  Key Download Payload Processing\n   Prior to processing its data,
        the payload contents MUST be decrypted.\n   When processing the Key Download
        Payload, the following fields MUST\n   be checked for correct values:\n   1.
        \ Next Payload, RESERVED, Payload Length - These fields are\n       processed
        as defined in Section 7.2.2, \"Generic Payload Header\n       Processing\".\n
        \  2.  KDD Item Type - All KDD Item Type fields MUST be checked to be a\n
        \      valid Key Download Data Item type as defined by Table 15.  If the\n
        \      value is not valid, then an error is logged.  If in Verbose Mode,\n
        \      an appropriate message containing notification value Payload-\n       Malformed
        will be sent.\n   3.  Key Type - All Key Type fields MUST be checked to be
        a valid\n       encryption type as defined by Table 16.  If the value is not\n
        \      valid, then an error is logged.  If in Verbose Mode, an\n       appropriate
        message containing notification value Invalid-Key-\n       Information will
        be sent.\n   4.  Key Expiration Date - All Key Expiration Date fields MUST
        be\n       checked confirm that their values represent a future and not a\n
        \      past time value.  If the value is not valid, then an error is\n       logged.
        \ If in Verbose Mode, an appropriate message containing\n       notification
        value Invalid-Key-Information will be sent.\n   The length and counter fields
        in the payload are used to help process\n   the payload.  If any field is
        found to be incorrect, then an error is\n   logged.  If in Verbose Mode, an
        appropriate message containing\n   notification value Payload-Malformed will
        be sent.\n"
      title: 7.4.2.  Key Download Payload Processing
    title: 7.4.  Key Download Payload
  - contents:
    - "7.5.  Rekey Event Payload\n   Refer to the terminology section for the different
      terms relating to\n   keys used within this section.\n"
    - contents:
      - "7.5.1.  Rekey Event Payload Structure\n   The Rekey Event Payload MAY contain
        multiple keys encrypted in\n   Wrapping KEKs.  Figure 14 shows the format
        of the payload.  If the\n   data to be contained within a Rekey Event Payload
        is too large for\n   the payload, the sequence can be split across multiple
        Rekey Event\n   Payloads at a Rekey Event Data boundary.\n    0                   1
        \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! Next Payload  !   RESERVED    !         Payload Length        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! RekeyEvnt Type!  Rekey Event Header                           ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ~ Rekey Event Data(s)                                           ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \             Figure 14: Rekey Event Payload Format\n   The Rekey Event Payload
        fields are defined as follows:\n   Next Payload (1 octet) - Identifier for
        the payload type of the next\n       payload in the message.  If the current
        payload is the last in\n       the message, then this field will be 0.  This
        field provides the\n       \"chaining\" capability.  Table 12 identifies the
        payload types.\n       This field is treated as an unsigned value.\n   RESERVED
        (1 octet) - Unused, set to 0.\n   Payload Length (2 octets) - Length in octets
        of the current payload,\n       including the generic payload header.  This
        field is treated as\n       an unsigned integer in network byte order format.\n
        \  Rekey Event Type (1 octet) - Specifies the type of Rekey Event being\n
        \      used.  Table 17 presents the types of Rekey events.  This field\n       is
        treated as an unsigned value.\n   Rekey Event Header (variable length) - This
        is the header information\n       for the Rekey Event.  The format for this
        is defined in Section\n       7.5.1.1, \"Rekey Event Header Structure\".\n
        \  Rekey Event Data(s) (variable length) - This is the rekey information\n
        \      for the Rekey Event.  The format for this is defined in Section\n       7.5.1.2,
        \"Rekey Event Data Structure\".\n   The Rekey Event payload type is three
        (3).\n                       Table 17: Rekey Event Types\n   Rekey_Event_Type
        \    Value       Definition/Defined In\n   _____________________________________________________________________\n
        \  None                   0         This type MUST be implemented.\n                                    In
        this case, the size of the Rekey\n                                    Event
        Data field will be zero bytes\n                                    long.  The
        purpose of a Rekey Event\n                                    Payload with
        type None is when it is\n                                    necessary to
        send out a new token\n                                    with no rekey information.
        \ GSAKMP\n                                    rekey msg requires a Rekey Event\n
        \                                   Payload, and in this instance it\n                                    would
        have rekey data of type None.\n   GSAKMP_LKH             1         The rekey
        data will be of\n                                    type LKH formatted according
        to\n                                    GSAKMP.  The format for this field\n
        \                                   is defined in Section 7.5.1.2.\n   Reserved
        to IANA    2 - 192\n   Private Use        193 - 255\n"
      - contents:
        - "7.5.1.1.  Rekey Event Header Structure\n   The format for the Rekey Event
          Header is shown in Figure 15.\n    0                   1                   2
          \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
          3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  !                    Group ID Value                             ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ~                    Group ID Value                             !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ! Time/Date Stamp                                               ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ~                                                               ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ~                                                               ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ~                                               ! RekeyEnt Type ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ! Algorithm Ver ! # of Rekey Event Data(s)      !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \              Figure 15: Rekey Event Header Format\n   Group Identification
          Value (variable length) - Indicates the\n       name/title of the group
          to be rekeyed.  This is the same format,\n       length, and value as the
          Group Identification Value in Section\n       7.1, \"GSAKMP Header\".\n
          \  Time/Date Stamp (15 octets) - This is the time value when the Rekey\n
          \      Event Data was generated.  This field contains the timestamp in\n
          \      UTF-8 format YYYYMMDDHHMMSSZ, where YYYY is the year (0000 -\n       9999),
          MM is the numerical value of the month (01 - 12), DD is\n       the day
          of the month (01 - 31), HH is the hour of the day (00 -\n       23), MM
          is the minute within the hour (00 - 59), SS is the\n       seconds within
          the minute (00 - 59), and the letter Z indicates\n       that this is Zulu
          time.  This format is loosely based on\n       [RFC3161].\n   Rekey Event
          Type (1 octet) - This is the Rekey algorithm being used\n       for this
          group.  The values for this field can be found in Table\n       17.  This
          field is treated as an unsigned value.\n   Algorithm Version (1 octet) -
          Indicates the version of the Rekey Type\n       being used.  For Rekey Event
          Type of GSAKMP_LKH, refer to Section\n       A.2 for a description of this
          value.  This field is treated as an\n       unsigned value.\n   # of Rekey
          Event Data(s) (2 octets) - The number of Rekey Event\n       Data(s) contained
          in the Rekey Data.  This value is treated as an\n       unsigned integer
          in network byte order.\n"
        title: 7.5.1.1.  Rekey Event Header Structure
      - contents:
        - "7.5.1.2.  Rekey Event Data Structure\n   As defined in the Rekey Event
          Header, # of Rekey Data(s) field,\n   multiple pieces of information are
          sent in a Rekey Event Data.  Each\n   end user, will be interested in only
          one Rekey Event Data among all\n   of the information sent.  Each Rekey
          Event Data will contain all the\n   Key Packages that a user requires.  For
          each Rekey Event Data, the\n   data following the Wrapping fields is encrypted
          with the key\n   identified in the Wrapping Header.  Figure 16 shows the
          format of\n   each Rekey Event Data.\n    0                   1                   2
          \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
          3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ! Packet Length                 ! Wrapping KeyID                ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ~                               ! Wrapping Key Handle           ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ~                               ! # of Key Packages             !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ! Key Packages(s)                                               ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \               Figure 16: Rekey Event Data Format\n   Packet Length (2
          octets) - Length in octets of the Rekey Event Data,\n       which consists
          of the # of Key Packages and the Key Packages(s).\n       This value is
          treated as an unsigned integer in network byte\n       order.\n   Wrapping
          KeyID (4 octets) - This is the Key ID of the KEK that is\n       being used
          for encryption/decryption of the new (rekeyed) keys.\n       For Rekey Event
          Type of Rekey - LKH, refer to Section A.2 for a\n       description of this
          value.\n   Wrapping Key Handle (4 octets) - This is a Key Handle of the
          KEK that\n       is being used for encryption/decryption of the new (rekeyed)\n
          \      keys.  Refer to Section 7.4.1.1 for the values of this field.\n   #
          of Key Packages (2 octets) - The number of key packages contained\n       in
          this Rekey Event Data.  This value is treated as an unsigned\n       integer
          in network byte order.\n   Key Package(s) (variable length) - The type/length/value
          format of a\n       Key Datum.  The format for this is defined in Section
          7.5.1.2.1.\n"
        - contents:
          - "7.5.1.2.1.  Key Package Structure\n   Each Key Package contains all the
            information about the key.  Figure\n   17 shows the format for a Key Package.\n
            \   0                   1                   2                   3\n    0
            1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
            \  ! KeyPkg Type   ! Key Package Length            ! Key Datum     ~\n
            \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
            \                 Figure 17: Key Package Format\n   Key Package Type (1
            octet) - The type of key in this key package.\n       Legal values for
            this field are defined in Table 15, Key Download\n       Data Types.  This
            field is treated as an unsigned value.\n   Key Package Length (2 octets)
            - The length of the Key Datum.  This\n       field is treated as an unsigned
            integer in network byte order\n       format.\n   Key Datum (variable
            length) - The actual data of the key.  The format\n       for this field
            is defined in Section 7.4.1.1, \"Key Datum\n       Structure\".\n"
          title: 7.5.1.2.1.  Key Package Structure
        title: 7.5.1.2.  Rekey Event Data Structure
      title: 7.5.1.  Rekey Event Payload Structure
    - contents:
      - "7.5.2.  Rekey Event Payload Processing\n   When processing the Rekey Event
        Payload, the following fields MUST be\n   checked for correct values:\n   1.
        \ Next Payload, RESERVED, Payload Length - These fields are\n       processed
        as defined in Section 7.2.2, \"Generic Payload Header\n       Processing\".\n
        \  2.  Rekey Event Type field within \"Rekey Event\" payload header - The\n
        \      Rekey Event Type MUST be checked to be a valid rekey event type\n       as
        defined by Table 17.  If the Rekey Event Type is not valid,\n       then regardless
        of mode (e.g., Terse or Verbose) an error is\n       logged.  No response
        error message is generated for receipt of a\n       Group Management Message.\n
        \  3.  Group ID Value - The Group ID value of the Rekey Event Header\n       received
        message MUST be checked against the GroupID of the Group\n       Component.
        \ If no match is found, the payload is discarded, then\n       regardless
        of mode (e.g., Terse or Verbose) an error is logged.\n       No response error
        message is generated for receipt of a Group\n       Management Message.\n
        \  4.  Date/Time Stamp - The Date/Time Stamp value of the Rekey Event\n       Header
        MAY be checked to determine if the Rekey Event generation\n       time is
        recent relative to network delay and processing times.\n       If the TimeStamp
        is judged not to be recent, an error is logged.\n       No response error
        message is generated for receipt of a Group\n       Management Message.\n
        \  5.  Rekey Event Type field within the \"Rekey Event Header\" - The\n       Rekey
        Event Type of the Rekey Event Header received message MUST\n       be checked
        to be a valid rekey event type, as defined by Table\n       17, and the same
        value of the Rekey Event Type earlier in this\n       payload.  If the Rekey
        Event Type is not valid or not equal to\n       the previous value of the
        Rekey Event Type, then regardless of\n       mode (e.g., Terse or Verbose)
        an error is logged.  No response\n       error message is generated for receipt
        of a Group Management\n       Message.\n   6.  Algorithm Version - The Rekey
        Algorithm Version number MUST be\n       checked to ensure that the version
        indicated is supported.  If it\n       is not supported, then regardless of
        mode (e.g., Terse or\n       Verbose) an error is logged.  No response error
        message is\n       generated for receipt of a Group Management Message.\n
        \  The length and counter fields are used to help process the message.\n   If
        any field is found to be incorrect, then termination processing\n   MUST be
        initiated.\n   A GM MUST process all the Rekey Event Datas as based on the
        rekey\n   method used there is a potential that multiple Rekey Event Datas
        are\n   for this GM.  The Rekey Event Datas are processed in order until all\n
        \  Rekey Event Datas are consumed.\n   1.  Wrapping KeyID - The Wrapping KeyID
        MUST be checked against the\n       list of stored KEKs that this GM holds.
        \ If a match is found,\n       then continue processing this Rekey Event Data.
        \ Otherwise, skip\n       to the next Rekey Event Data.\n   2.  Wrapping Handle
        - If a matching Wrapping KeyID was found, then\n       the Wrapping Handle
        MUST be checked against the handle of the KEK\n       for which the KeyID
        was a match.  If the handles match, then the\n       GM will process the Key
        Packages associated with this Rekey Event\n       Data.  Otherwise, skip to
        the next Rekey Event Data.\n   If a GM has found a matching Wrapping KeyID
        and Wrapping Handle, the\n   GM decrypts the remaining data in this Rekey
        Event Data according to\n   policy using the KEK defined by the Wrapping KeyID
        and Handle.  After\n   decrypting the data, the GM extracts the # of Key Packages
        field to\n   help process the subsequent Key Packages.  The Key Packages are\n
        \  processed as follows:\n   1.  Key Package Type - The Key Package Type MUST
        be checked to be a\n       valid key package type as defined by Table 15.
        \ If the Key\n       Package Type is not valid, then regardless of mode (e.g.,
        Terse\n       or Verbose) an error is logged.  No response error message is\n
        \      generated for receipt of a Group Management Message.\n   2.  Key Package
        Length - The Key Package Length is used to process\n       the subsequent
        Key Datum information.\n   3.  Key Type - The Key Type MUST be checked to
        be a valid key type as\n       defined by Table 16.  If the Key Package Type
        is not valid, then\n       regardless of mode (e.g., Terse or Verbose) an
        error is logged.\n       No response error message is generated for receipt
        of a Group\n       Management Message.\n   4.  Key ID - The Key ID MUST be
        checked against the set of Key IDs\n       that this user maintains for this
        Key Type.  If no match is\n       found, then regardless of mode (e.g., Terse
        or Verbose) an error\n       is logged.  No response error message is generated
        for receipt of\n       a Group Management Message.\n   5.  Key Handle - The
        Key Handle is extracted as is and is used to be\n       the new Key Handle
        for the Key currently associated with the Key\n       Package's Key ID.\n
        \  6.  Key Creation Date - The Key Creation Date MUST be checked that it\n
        \      is subsequent to the Key Creation Date for the currently held\n       key.
        \ If this date is prior to the currently held key, then\n       regardless
        of mode (e.g., Terse or Verbose) an error is logged.\n       No response error
        message is generated for receipt of a Group\n       Management Message.\n
        \  7.  Key Expiration Date - The Key Expiration Date MUST be checked\n       that
        it is subsequent to the Key Creation Date just received and\n       that the
        time rules conform with policy.  If the expiration date\n       is not subsequent
        to the creation date or does not conform with\n       policy, then regardless
        of mode (e.g., Terse or Verbose) an error\n       is logged.  No response
        error message is generated for receipt of\n       a Group Management Message.\n
        \  8.  Key Data - The Key Data is extracted based on the length\n       information
        in the key package.\n   If there were no errors when processing the Key Package,
        the key\n   represented by the KeyID will have all of its data updated based
        upon\n   the received information.\n"
      title: 7.5.2.  Rekey Event Payload Processing
    title: 7.5.  Rekey Event Payload
  - contents:
    - '7.6.  Identification Payload

      '
    - contents:
      - "7.6.1.  Identification Payload Structure\n   The Identification Payload contains
        entity-specific data used to\n   exchange identification information.  This
        information is used to\n   verify the identities of members.  Figure 18 shows
        the format of the\n   Identification Payload.\n    0                   1                   2
        \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! Next Payload  !   RESERVED    !         Payload Length        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! ID Classif    !  ID Type      !      Identification Data      ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \            Figure 18: Identification Payload Format\n   The Identification
        Payload fields are defined as follows:\n   Next Payload (1 octet) - Identifier
        for the payload type of the next\n       payload in the message.  If the current
        payload is the last in\n       the message, then this field will be 0.  This
        field provides the\n       \"chaining\" capability.  Table 12 identifies the
        payload types.\n       This field is treated as an unsigned value.\n   RESERVED
        (1 octet) - Unused, set to 0.\n   Payload Length (2 octets) - Length in octets
        of the current payload,\n       including the generic payload header.  This
        field is treated as\n       an unsigned integer in network byte order format.\n
        \  Identification (ID) Classification (1 octet) - Classifies the\n       ownership
        of the Identification Data.  Table 18 identifies\n       possible values for
        this field.  This field is treated as an\n       unsigned value.\n                   Table
        18: Identification Classification\n                        ID_Classification
        \    Value\n                       _______________________________\n                        Sender
        \                 0\n                        Receiver                1\n                        Third
        Party             2\n                        Reserved to IANA     3 - 192\n
        \                       Private Use         193 - 255\n   Identification (ID)
        Type (1 octet) - Specifies the type of\n       Identification being used.
        \ Table 19 identifies possible values\n       for this type.  This field is
        treated as an unsigned value.  All\n       defined types are OPTIONAL unless
        otherwise stated.\n   Identification Data (variable length) - Contains identity\n
        \      information.  The values for this field are group specific, and\n       the
        format is specified by the ID Type field.  The format for\n       this field
        is stated in conjunction with the type in Table 19.\n   The payload type for
        the Identification Payload is four (4).\n                      Table 19: Identification
        Types\n   ID_Type              Value       PKIX Cert           Description\n
        \                                   Field               Defined In\n   _____________________________________________________________________\n
        \  Reserved               0\n   ID_IPV4_ADDR           1         SubjAltName
        \        See [IKEv2]\n                                    iPAddress           Section
        3.5.\n   ID_FQDN                2         SubjAltName         See [IKEv2]\n
        \                                   dNSName             Section 3.5.\n   ID_RFC822_ADDR
        \        3         SubjAltName         See [IKEv2]\n                                    rfc822Name
        \         Section 3.5.\n   Reserved               4\n   ID_IPV6_ADDR           5
        \        SubjAltName         See [IKEv2]\n                                    iPAddress
        \          Section 3.5.\n   Reserved             6 - 8\n   ID_DER_ASN1_DN
        \        9         Entire Subject,     See [IKEv2]\n                                    bitwise
        Compare     Section 3.5.\n   Reserved               10\n   ID_KEY_ID              11
        \       N/A                 See [IKEv2]\n   Reserved            12 - 29                          Section
        3.5.\n   Unencoded Name         30        Subject             The format for\n
        \   (ID_U_NAME)                                         this type is\n                                                        defined
        in\n                                                        Section 7.6.1.1.\n
        \  ID_DN_STRING           31        Subject             See [RFC4514].\n                                                        This
        type MUST\n                                                        be implemented.\n
        \  Reserved to IANA    32 - 192\n   Private Use        193 - 255\n"
      - contents:
        - "7.6.1.1.  ID_U_NAME Structure\n   The format for type Unencoded Name (ID_U_NAME)
          is shown in Figure 19.\n    0                   1                   2                   3\n
          \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ! Serial Number                                                 ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ~                                                               ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ~                                                               ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ~                                                               ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ~                                                               !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ! Length                                                        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ! DN Data                                                       ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \          Figure 19: Unencoded Name (ID-U-NAME) Format\n   Serial Number
          (20 octets) - The certificate serial number.  This\n       field is treated
          as an unsigned integer in network byte order\n       format.\n   Length
          (4 octets) - Length in octets of the DN Data field.  This\n       field
          is treated as an unsigned integer in network byte order\n       format.\n
          \  DN Data (variable length) - The actual UTF-8 DN value (Subject field)\n
          \      using the slash (/) character for field delimiters (e.g.,\n       \"/C=US/ST=MD/L=Somewhere/O=ACME,
          Inc./OU=DIV1/CN=user1/\n       Email=user1@acme.com\" without the surrounding
          quotes).\n"
        title: 7.6.1.1.  ID_U_NAME Structure
      title: 7.6.1.  Identification Payload Structure
    - contents:
      - "7.6.2.  Identification Payload Processing\n   When processing the Identification
        Payload, the following fields MUST\n   be checked for correct values:\n   1.
        \ Next Payload, RESERVED, Payload Length - These fields are\n       processed
        as defined in Section 7.2.2, \"Generic Payload Header\n       Processing\".\n
        \  2.  Identification Classification - The Identification Classification\n
        \      value MUST be checked to be a valid identification classification\n
        \      type as defined by Table 18.  If the value is not valid, then an\n
        \      error is logged.  If in Verbose Mode, an appropriate message\n       containing
        notification value Payload-Malformed will be sent.\n   3.  Identification
        Type - The Identification Type value MUST be\n       checked to be a valid
        identification type as defined by Table 19.\n       If the value is not valid,
        then an error is logged.  If in\n       Verbose Mode, an appropriate message
        containing notification\n       value Payload-Malformed will be sent.\n   4.
        \ Identification Data - This Identification Data MUST be processed\n       according
        to the identification type specified.  The type will\n       define the format
        of the data.  If the identification data is\n       being used to find a match
        and no match is found, then an error\n       is logged.  If in Verbose Mode,
        an appropriate message containing\n       notification value Invalid-ID-Information
        will be sent.\n"
      - contents:
        - "7.6.2.1.  ID_U_NAME Processing\n   When processing the Identification Data
          of type ID_U_NAME, the\n   following fields MUST be checked for correct
          values:\n   1.  Serial Number - The serial number MUST be a greater than
          or equal\n       to one (1) to be a valid serial number from a conforming
          CA\n       [RFC3280].  If the value is not valid, then an error is logged.\n
          \      If in Verbose Mode, an appropriate message containing\n       notification
          value Payload-Malformed will be sent.\n   2.  DN Data - The DN data is processed
          as a UTF-8 string.\n   3.  The CA MUST be a valid trusted policy creation
          authority as\n       defined by the Policy Token.\n   These 2 pieces of
          information, Serial Number and DN Data, in\n   conjunction, will then be
          used for party identification.  These\n   values are also used to help identify
          the certificate when necessary.\n"
        title: 7.6.2.1.  ID_U_NAME Processing
      title: 7.6.2.  Identification Payload Processing
    title: 7.6.  Identification Payload
  - contents:
    - '7.7.  Certificate Payload

      '
    - contents:
      - "7.7.1.  Certificate Payload Structure\n   The Certificate Payload provides
        a means to transport certificates or\n   other certificate-related information
        via GSAKMP and can appear in\n   any GSAKMP message.  Certificate payloads
        SHOULD be included in an\n   exchange whenever an appropriate directory service
        (e.g., LDAP\n   [RFC4523]) is not available to distribute certificates.  Multiple\n
        \  certificate payloads MAY be sent to enable verification of\n   certificate
        chains.  Conversely, zero (0) certificate payloads may be\n   sent, and the
        receiving GSAKMP MUST rely on some other mechanism to\n   retrieve certificates
        for verification purposes.  Figure 20 shows the\n   format of the Certificate
        Payload.\n    0                   1                   2                   3\n
        \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! Next Payload  !   RESERVED    !         Payload Length        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! Cert Type                     !    Certificate Data           ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \             Figure 20: Certificate Payload Format\n   The Certificate Payload
        fields are defined as follows:\n   Next Payload (1 octet) - Identifier for
        the payload type of the next\n       payload in the message.  If the current
        payload is the last in\n       the message, then this field will be 0.  This
        field provides the\n       \"chaining\" capability.  Table 12 identifies the
        payload types.\n       This field is treated as an unsigned value.\n   RESERVED
        (1 octet) - Unused, set to 0.\n   Payload Length (2 octets) - Length in octets
        of the current payload,\n       including the generic payload header.  This
        field is treated as\n       an unsigned integer in network byte order format.\n
        \  Certificate Type (2 octets) - This field indicates the type of\n       certificate
        or certificate-related information contained in the\n       Certificate Data
        field.  Table 20 presents the types of\n       certificate payloads.  This
        field is treated as an unsigned\n       integer in network byte order format.\n
        \  Certificate Data (variable length) - Actual encoding of certificate\n       data.
        \ The type of certificate is indicated by the Certificate\n       Type/Encoding
        field.\n   The payload type for the Certificate Payload is six (6).\n                   Table
        20: Certificate Payload Types\n   Certificate_Type                   Value
        \       Description/\n                                                   Defined
        In\n   _____________________________________________________________________\n
        \  None                                 0\n   Reserved                           1
        - 3\n   X.509v3 Certificate                  4          This type MUST be\n
        \    -- Signature                                  implemented.\n     -- DER
        Encoding                               Contains a DER\n                                                   encoded
        X.509\n                                                   certificate.\n   Reserved
        \                          5 - 6\n   Certificate Revocation List          7
        \         Contains a BER\n     (CRL)                                         encoded
        X.509 CRL.\n   Reserved                           8 - 9\n   X.509 Certificate
        \                  10          See [IKEv2], Sec 3.6.\n     -- Attribute\n
        \  Raw RSA Key                         11          See [IKEv2], Sec 3.6.\n
        \  Hash and URL of X.509               12          See [IKEv2], Sec 3.6.\n
        \   Certificate\n   Hash and URL of X.509               13          See [IKEv2],
        Sec 3.6.\n    bundle\n   Reserved to IANA                14 -- 49152\n   Private
        Use                   49153 -- 65535\n"
      title: 7.7.1.  Certificate Payload Structure
    - contents:
      - "7.7.2.  Certificate Payload Processing\n   When processing the Certificate
        Payload, the following fields MUST be\n   checked for correct values:\n   1.
        \ Next Payload, RESERVED, Payload Length - These fields are\n       processed
        as defined in Section 7.2.2, \"Generic Payload Header\n       Processing\".\n
        \  2.  Certificate Type - The Certificate Type value MUST be checked to\n
        \      be a valid certificate type as defined by Table 20.  If the value\n
        \      is not valid, then an error is logged.  If in Verbose Mode, an\n       appropriate
        message containing notification value Cert-Type-\n       Unsupported will
        be sent.\n   3.  Certificate Data - This Certificate Data MUST be processed\n
        \      according to the certificate type specified.  The type will\n       define
        the format of the data.  Receipt of a certificate of the\n       trusted policy
        creation authority in a Certificate payload causes\n       the payload to
        be discarded.  This received certificate MUST NOT\n       be used to verify
        the message.  The certificate of the trusted\n       policy creation authority
        MUST be retrieved by other means.\n"
      title: 7.7.2.  Certificate Payload Processing
    title: 7.7.  Certificate Payload
  - contents:
    - '7.8.  Signature Payload

      '
    - contents:
      - "7.8.1.  Signature Payload Structure\n       The Signature Payload contains
        data generated by the digital\n       signature function.  The digital signature,
        as defined by the\n       dissection of each message, covers the message from
        the GSAKMP\n       Message Header through the Signature Payload, up to but
        not\n       including the Signature Data Length.  Figure 21 shows the format\n
        \      of the Signature Payload.\n    0                   1                   2
        \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! Next Payload  !   RESERVED    !         Payload Length        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! Signature Type                ! Sig ID Type   !               ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ~ Signature Timestamp                                           ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ~                                                               ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ~                                                               ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ~                               ! Signer ID Length              !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  !                    Signer ID Data                             ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  !     Signature Length          !     Signature Data            ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ~                                                               ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \              Figure 21: Signature Payload Format\n   The Signature Payload
        fields are defined as follows:\n   Next Payload (1 octet) - Identifier for
        the payload type of the next\n       payload in the message.  If the current
        payload is the last in\n       the message, then this field will be 0.  This
        field provides the\n       \"chaining\" capability.  Table 12 identifies the
        payload types.\n       This field is treated as an unsigned value.\n   RESERVED
        (1 octet) - Unused, set to 0.\n   Payload Length (2 octets) - Length in octets
        of the current payload,\n       including the generic payload header.  This
        field is treated as\n       an unsigned integer in network byte order format.\n
        \  Signature Type (2 octets) - Indicates the type of signature.  Table\n       21
        presents the allowable signature types.  This field is treated\n       as
        an unsigned integer in network byte order format.\n                        Table
        21: Signature Types\n   Signature Type                         Value         Description/\n
        \                                                       Defined In\n   _____________________________________________________________________\n
        \  DSS/SHA1 with ASN.1/DER encoding         0           This type MUST\n   (DSS-SHA1-ASN1-DER)
        \                                 be supported.\n   RSA1024-MD5                              1
        \          See [RFC3447].\n   ECDSA-P384-SHA3                          2           See
        [FIPS186-2].\n   Reserved to IANA                       3 - 41952\n   Private
        Use                        41953 - 65536\n   Signature ID Type (1 octet) -
        Indicates the format for the Signature\n       ID Data.  These values are
        the same as those defined for the\n       Identification Payload Identification
        types, which can be found\n       in Table 19.  This field is treated as an
        unsigned value.\n   Signature Timestamp (15 octets) - This is the time value
        when the\n       digital signature was applied.  This field contains the timestamp\n
        \      in UTF-8 format YYYYMMDDHHMMSSZ, where YYYY is the year (0000 -\n       9999),
        MM is the numerical value of the month (01 - 12), DD is\n       the day of
        the month (01 - 31), HH is the hour of the day (00 -\n       23), MM is the
        minute within the hour (00 - 59), SS is the\n       seconds within the minute
        (00 - 59), and the letter Z indicates\n       that this is Zulu time.  This
        format is loosely based on\n       [RFC3161].\n   Signer ID Length (2 octets)
        - Length in octets of the Signer's ID.\n       This field is treated as an
        unsigned integer in network byte\n       order format.\n   Signer ID Data
        (variable length) - Data identifying the Signer's ID\n       (e.g., DN).  The
        format for this field is based on the Signature\n       ID Type field and
        is shown where that type is defined.  The\n       contents of this field MUST
        be checked against the Policy Token\n       to determine the authority and
        access of the Signer within the\n       context of the group.\n   Signature
        Length (2 octets) - Length in octets of the Signature Data.\n       This field
        is treated as an unsigned integer in network byte\n       order format.\n
        \  Signature Data (variable length) - Data that results from applying\n       the
        digital signature function to the GSAKMP message and/or\n       payload.\n
        \  The payload type for the Signature Payload is eight (8).\n"
      title: 7.8.1.  Signature Payload Structure
    - contents:
      - "7.8.2.  Signature Payload Processing\n   When processing the Signature Payload,
        the following fields MUST be\n   checked for correct values:\n   1.  Next
        Payload, RESERVED, Payload Length - These fields are\n       processed as
        defined in Section 7.2.2, \"Generic Payload Header\n       Processing\".\n
        \  2.  Signature Type - The Signature Type value MUST be checked to be a\n
        \      valid signature type as defined by Table 21.  If the value is not\n
        \      valid, then an error is logged.  If in Verbose Mode, an\n       appropriate
        message containing notification value Payload-\n       Malformed will be sent.\n
        \  3.  Signature ID Type - The Signature ID Type value MUST be checked\n       to
        be a valid signature ID type as defined by Table 19.  If the\n       value
        is not valid, then an error is logged.  If in Verbose Mode,\n       an appropriate
        message containing notification value Payload-\n       Malformed will be sent.\n
        \  4.  Signature Timestamp - This field MAY be checked to determine if\n       the
        transaction signing time is fresh relative to expected\n       network delays.
        \ Such a check is appropriate for systems in which\n       archived sequences
        of events are desired.\n       NOTE: The maximum acceptable age of a signature
        timestamp\n       relative to the local system clock is a locally configured\n
        \      parameter that can be tuned by its GSAKMP management interface.\n   5.
        \ Signature ID Data - This field will be used to identify the\n       sending
        party.  This information MUST then be used to confirm\n       that the correct
        party sent this information.  This field is also\n       used to retrieve
        the appropriate public key of the certificate to\n       verify the message.\n
        \  6.  Signature Data - This value MUST be compared to the recomputed\n       signature
        to verify the message.  Information on how to verify\n       certificates
        used to ascertain the validity of the signature can\n       be found in [RFC3280].
        \ Only after the certificate identified by\n       the Signature ID Data is
        verified can the signature be computed\n       to compare to the signature
        data for signature verification.  A\n       potential error that can occur
        during signature verification is\n       Authentication-Failed.  Potential
        errors that can occur while\n       processing certificates for signature
        verification are: Invalid-\n       Certificate, Invalid-Cert-Authority, Cert-Type-Unsupported,
        and\n       Certificate-Unavailable.\n   The length fields in the Signature
        Payload are used to process the\n   remainder of the payload.  If any field
        is found to be incorrect,\n   then termination processing MUST be initiated.\n"
      title: 7.8.2.  Signature Payload Processing
    title: 7.8.  Signature Payload
  - contents:
    - '7.9.  Notification Payload

      '
    - contents:
      - "7.9.1.  Notification Payload Structure\n   The Notification Payload can contain
        both GSAKMP and group-specific\n   data and is used to transmit informational
        data, such as error\n   conditions, to a GSAKMP peer.  It is possible to send
        multiple\n   independent Notification payloads in a single GSAKMP message.
        \ Figure\n   22 shows the format of the Notification Payload.\n    0                   1
        \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! Next Payload  !   RESERVED    !        Payload Length         !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! Notification Type             !  Notification Data            ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \             Figure 22: Notification Payload Format\n   The Notification
        Payload fields are defined as follows:\n   Next Payload (1 octet) - Identifier
        for the payload type of the next\n       payload in the message.  If the current
        payload is the last in\n       the message, then this field will be 0.  This
        field provides the\n       \"chaining\" capability.  Table 12 identifies the
        payload types.\n       This field is treated as an unsigned value.\n   RESERVED
        (1 octet) - Unused, set to 0.\n   Payload Length (2 octets) - Length in octets
        of the current payload,\n       including the generic payload header.  This
        field is treated as\n       an unsigned integer in network byte order format.\n
        \  Notification Type (2 octets) - Specifies the type of notification\n       message.
        \ Table 22 presents the Notify Payload Types.  This field\n       is treated
        as an unsigned integer in network byte order format.\n   Notification Data
        (variable length) - Informational or error data\n       transmitted in addition
        to the Notify Payload Type.  Values for\n       this field are Domain of Interpretation
        (DOI) specific.\n   The payload type for the Notification Payload is nine
        (9).\n                    Table 22: Notification Types\n      Notification
        Type                             Value\n     __________________________________________________________\n
        \     None                                            0\n      Invalid-Payload-Type
        \                           1\n      Reserved                                      2
        - 3\n      Invalid-Version                                 4\n      Invalid-Group-ID
        \                               5\n      Invalid-Sequence-ID                             6\n
        \     Payload-Malformed                               7\n      Invalid-Key-Information
        \                        8\n      Invalid-ID-Information                          9\n
        \     Reserved                                     10 - 11\n      Cert-Type-Unsupported
        \                          12\n      Invalid-Cert-Authority                          13\n
        \     Authentication-Failed                           14\n      Reserved                                     15
        - 16\n      Certificate-Unavailable                         17\n      Reserved
        \                                       18\n      Unauthorized-Request                            19\n
        \     Reserved                                     20 - 22\n      Acknowledgement
        \                                23\n      Reserved                                     24
        - 25\n      Nack                                            26\n      Cookie-Required
        \                                27\n      Cookie                                          28\n
        \     Mechanism Choices                               29\n      Leave Group
        \                                    30\n      Departure Accepted                              31\n
        \     Request to Depart Error                         32\n      Invalid Exchange
        Type                           33\n      IPv4 Value                                      34\n
        \     IPv6 Value                                      35\n      Prohibited
        by Group Policy                      36\n      Prohibited by Locally Configured
        Policy         37\n      Reserved to IANA                            38 -
        49152\n      Private Use                               49153 -- 65535\n"
      - contents:
        - "7.9.1.1.  Notification Data - Acknowledgement (ACK) Payload Type\n   The
          data portion of the Notification payload of type ACK either\n   serves as
          confirmation of correct receipt of the Key Download message\n   or, when
          needed, provides other receipt information when included in\n   a signed
          message.  Figure 23 shows the format of the Notification\n   Data - Acknowledge
          Payload Type.\n    0                   1                   2                   3\n
          \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ! Ack Type      !       Acknowledgement Data                    ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \    Figure 23: Notification Data - Acknowledge Payload Type Format\n   The
          Notification Data - Acknowledgement Payload Type data fields are\n   defined
          as follows:\n   Ack Type (1 octet) - Specifies the type of acknowledgement.
          \ Table 23\n       presents the Notify Acknowledgement Payload Types.  This
          field is\n       treated as an unsigned value.\n                        Table
          23: Acknowledgement Types\n             ACK_Type             Value       Definition\n
          \           _____________________________________________________\n             Simple
          \                0         Data portion null.\n             Reserved to
          IANA     1 - 192\n             Private Use        193 - 255\n"
        title: 7.9.1.1.  Notification Data - Acknowledgement (ACK) Payload Type
      - contents:
        - "7.9.1.2.  Notification Data - Cookie_Required and Cookie Payload Type\n
          \  The data portion of the Notification payload of types Cookie_Required\n
          \  and Cookie contain the Cookie value.  The value for this field will\n
          \  have been computed by the responder GC/KS and sent to the GM.  The GM\n
          \  will take the value received and copy it into the Notification\n   payload
          Notification Data field of type Cookie that is transmitted in\n   the \"Request
          to Join with Cookie Info\" back to the GC/KS.  The cookie\n   value MUST
          NOT be modified.\n   The format for this is already described in the discussion
          on cookies\n   in Section 5.2.2.\n"
        title: 7.9.1.2.  Notification Data - Cookie_Required and Cookie Payload Type
      - contents:
        - "7.9.1.3.  Notification Data - Mechanism Choices Payload Type\n   The data
          portion of the Notification payload of type Mechanism\n   Choices contains
          the mechanisms the GM is requesting to use for the\n   negotiation with
          the GC/KS.  This information will be supplied by the\n   GM in a RTJ message.
          \ Figure 24 shows the format of the Notification\n   Data - Mechanism Choices
          Payload Type.  Multiple type|length|data\n   choices are strung together
          in one notification payload to allow a\n   user to transmit all relevant
          information within one Notification\n   Payload.  The length of the payload
          will control the parsing of the\n   Notification Data Mechanism Choices
          field.\n    0                   1                   2                   3\n
          \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \  ! Mech Type     ! Mechanism Choice Data         !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+..\n
          \  Figure 24: Notification Data - Mechanism Choices Payload Type Format\n
          \  The Notification Data - Mechanism Choices Payload Type data fields\n
          \  are defined as follows:\n   Mechanism Type (1 octet) - Specifies the
          type of mechanism.  Table 24\n       presents the Notify Mechanism Choices
          Mechanism Types.  This\n       field is treated as an unsigned value.\n
          \                         Table 24: Mechanism Types\n      Mechanism_Type
          \            Value       Mechanism Choice\n                                             Data
          Value Table Reference\n     ___________________________________________________________________\n
          \     Key Creation Algorithm       0         Table 26\n      Encryption
          Algorithm         1         Table 16\n      Nonce Hash Algorithm         2
          \        Table 25\n      Reserved to IANA          3 - 192\n      Private
          Use              193 - 255\n   Mechanism Choice Data (2 octets) - The data
          value for the mechanism\n       type being selected.  The values are specific
          to each Mechanism\n       Type defined.  All tables necessary to define
          the values that are\n       not defined elsewhere (in this specification
          or others) are\n       defined here.  This field is treated as an unsigned
          integer in\n       network byte order format.\n                       Table
          25: Nonce Hash Types\n   Nonce_Hash_Type        Value         Description\n
          \  __________________________________________________________________\n
          \  Reserved                 0\n   SHA-1                    1           This
          type MUST be supported.\n   Reserved to IANA     2 - 49152\n   Private Use
          \       49153 - 65535\n"
        title: 7.9.1.3.  Notification Data - Mechanism Choices Payload Type
      - contents:
        - "7.9.1.4.  Notification Data - IPv4 and IPv6 Value Payload Types\n   The
          data portion of the Notification payload of type IPv4 and IPv6\n   value
          contains the appropriate IP value in network byte order.  This\n   value
          will be set by the creator of the message for consumption by\n   the receiver
          of the message.\n"
        title: 7.9.1.4.  Notification Data - IPv4 and IPv6 Value Payload Types
      title: 7.9.1.  Notification Payload Structure
    - contents:
      - "7.9.2.  Notification Payload Processing\n   When processing the Notification
        Payload, the following fields MUST\n   be checked for correct values:\n   1.
        \ Next Payload, RESERVED, Payload Length - These fields are\n       processed
        as defined in Section 7.2.2, \"Generic Payload Header\n       Processing\".\n
        \  2.  Notification Type - The Notification type value MUST be checked\n       to
        be a notification type as defined by Table 22.  If the value\n       is not
        valid, then an error is logged.  If in Verbose Mode, an\n       appropriate
        message containing notification value Payload-\n       Malformed will be sent.\n
        \  3.  Notification Data - This Notification Data MUST be processed\n       according
        to the notification type specified.  The type will\n       define the format
        of the data.  When processing this data, any\n       type field MUST be checked
        against the appropriate table for\n       correct values.  If the contents
        of the Notification Data are not\n       valid, then an error is logged.  If
        in Verbose Mode, an\n       appropriate message containing notification value
        Payload-\n       Malformed will be sent.\n"
      title: 7.9.2.  Notification Payload Processing
    title: 7.9.  Notification Payload
  - contents:
    - '7.10.  Vendor ID Payload

      '
    - contents:
      - "7.10.1.  Vendor ID Payload Structure\n       The Vendor ID Payload contains
        a vendor-defined constant.  The\n       constant is used by vendors to identify
        and recognize remote\n       instances of their implementations.  This mechanism
        allows a\n       vendor to experiment with new features while maintaining\n
        \      backwards compatibility.  Figure 25 shows the format of the\n       payload.\n
        \   0                   1                   2                   3\n    0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! Next Payload  !   RESERVED    !         Payload Length        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  !                         Vendor ID (VID)                       ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \              Figure 25: Vendor ID Payload Format\n   A Vendor ID payload
        MAY announce that the sender is capable of\n   accepting certain extensions
        to the protocol, or it MAY simply\n   identify the implementation as an aid
        in debugging.  A Vendor ID\n   payload MUST NOT change the interpretation
        of any information defined\n   in this specification.  Multiple Vendor ID
        payloads MAY be sent.  An\n   implementation is NOT REQUIRED to send any Vendor
        ID payload at all.\n   A Vendor ID payload may be sent as part of any message.
        \ Receipt of a\n   familiar Vendor ID payload allows an implementation to
        make use of\n   Private Use numbers described throughout this specification
        --\n   private payloads, private exchanges, private notifications, etc.\n
        \  This implies that all the processing rules defined for all the\n   payloads
        are now modified to recognize all values defined by this\n   Vendor ID for
        all fields of all payloads.  Unfamiliar Vendor IDs MUST\n   be ignored.\n
        \  Writers of Internet-Drafts who wish to extend this protocol MUST\n   define
        a Vendor ID payload to announce the ability to implement the\n   extension
        in the Internet-Draft.  It is expected that Internet-Drafts\n   that gain
        acceptance and are standardized will be given assigned\n   values out of the
        Reserved to IANA range, and the requirement to use\n   a Vendor ID payload
        will go away.\n   The Vendor ID payload fields are defined as follows:\n   Next
        Payload (1 octet) - Identifier for the payload type of the next\n       payload
        in the message.  If the current payload is the last in\n       the message,
        then this field will be 0.  This field provides the\n       \"chaining\" capability.
        \ Table 12 identifies the payload types.\n       This field is treated as
        an unsigned value.\n   RESERVED (1 octet) - Unused, set to 0.\n   Payload
        Length (2 octets) - Length in octets of the current payload,\n       including
        the generic payload header.  This field is treated as\n       an unsigned
        integer in network byte order format.\n   Vendor ID (variable length) - The
        Vendor ID value.  The minimum\n       length for this field is four (4) octets.
        \ It is the\n       responsibility of the person choosing the Vendor ID to
        assure its\n       uniqueness in spite of the absence of any central registry
        for\n       IDs.  Good practice is to include a company name, a person name,\n
        \      or similar type data.  A message digest of a long unique string\n       is
        preferable to the long unique string itself.\n   The payload type for the
        Vendor ID Payload is ten (10).\n"
      title: 7.10.1.  Vendor ID Payload Structure
    - contents:
      - "7.10.2.  Vendor ID Payload Processing\n   When processing the Vendor ID Payload,
        the following fields MUST be\n   checked for correct values:\n   1.  Next
        Payload, RESERVED, Payload Length - These fields are\n       processed as
        defined in Section 7.2.2, \"Generic Payload Header\n       Processing\".\n
        \  2.  Vendor ID - The Vendor ID Data MUST be processed to determine if\n
        \      the Vendor ID value is recognized by the implementation.  If the\n
        \      Vendor ID value is not recognized, then regardless of mode (e.g.,\n
        \      Terse or Verbose) this information is logged.  Processing of the\n
        \      message MUST continue regardless of recognition of this value.\n   It
        is recommended that implementations that want to use Vendor-ID-\n   specific
        information attempt to process the Vendor ID payloads of an\n   incoming message
        prior to the remainder of the message processing.\n   This will allow the
        implementation to recognize that when processing\n   other payloads it can
        use the larger set of values for payload fields\n   (Private Use values, etc.)
        as defined by the recognized Vendor IDs.\n"
      title: 7.10.2.  Vendor ID Payload Processing
    title: 7.10.  Vendor ID Payload
  - contents:
    - '7.11.  Key Creation Payload

      '
    - contents:
      - "7.11.1.  Key Creation Payload Structure\n   The Key Creation Payload contains
        information used to create key\n   encryption keys.  The security attributes
        for this payload are\n   provided in the Policy Token.  Figure 26 shows the
        format of the\n   payload.\n    0                   1                   2
        \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! Next Payload  !   RESERVED    !         Payload Length        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! Key Creation Type             ! Key Creation Data             ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \             Figure 26: Key Creation Payload Format\n   The Key Creation
        Payload fields are defined as follows:\n   Next Payload (1 octet) - Identifier
        for the payload type of the next\n       payload in the message.  If the current
        payload is the last in\n       the message, then this field will be 0.  This
        field provides the\n       \"chaining\" capability.  Table 12 identifies the
        payload types.\n       This field is treated as an unsigned value.\n   RESERVED
        (1 octet) - Unused, set to 0.\n   Payload Length (2 octets) - Length in octets
        of the current payload,\n       including the generic payload header.  This
        field is treated as\n       an unsigned integer in network byte order format.\n
        \  Key Creation Type (2 octets) - Specifies the type of Key Creation\n       being
        used.  Table 26 identifies the types of key creation\n       information.
        \ This field is treated as an unsigned integer in\n       network byte order
        format.\n   Key Creation Data (variable length) - Contains Key Creation\n
        \      information.  The values for this field are group specific, and\n       the
        format is specified by the key creation type field.\n   The payload type for
        the Key Creation Packet is eleven (11).\n               Table 26: Types of
        Key Creation Information\n   Key Creation Type           Value        Definition/Defined
        In\n   _____________________________________________________________________\n
        \  Reserved                    0 - 1\n   Diffie-Hellman                2          This
        type MUST be supported.\n     1024-bit MODP Group                    Defined
        in [IKEv2] B.2.\n     Truncated                              If the output
        of the process\n                                            is longer than
        needed for\n                                            the defined mechanism,
        use\n                                            the first X low order bits\n
        \                                           and truncate the remainder.\n
        \  Reserved                   3 - 13\n   Diffie-Hellman               14          Defined
        in [RFC3526].\n     2048-bit MODP Group                    If the output of
        the process\n     Truncated                              is longer than needed
        for\n                                            the defined mechanism, use\n
        \                                           the first X low order bits\n                                            and
        truncate the remainder.\n   Reserved to IANA         15 - 49152\n   Private
        Use             49153 - 65535\n"
      title: 7.11.1.  Key Creation Payload Structure
    - contents:
      - "7.11.2.  Key Creation Payload Processing\n   The specifics of the Key Creation
        Payload are defined in Section\n   7.11.\n   When processing the Key Creation
        Payload, the following fields MUST\n   be checked for correct values:\n   1.
        \ Next Payload, RESERVED, Payload Length - These fields are\n       processed
        as defined in Section 7.2.2, \"Generic Payload Header\n       Processing\".\n
        \  2.  Key Creation Type - The Key Creation Type value MUST be checked\n       to
        be a valid key creation type as defined by Table 26.  If the\n       value
        is not valid, then an error is logged.  If in Verbose Mode,\n       an appropriate
        message containing notification value Payload-\n       Malformed will be sent.\n
        \  3.  Key Creation Data - This Key Creation Data MUST be processed\n       according
        to the key creation type specified to generate the KEK\n       to protect
        the information to be sent in the appropriate message.\n       The type will
        define the format of the data.\n   Implementations that want to derive other
        keys from the initial Key\n   Creation keying material (for example, DH Secret
        keying material)\n   MUST define a Key Creation Type other than one of those
        shown in\n   Table 26.  The new Key Creation Type must specify that derivation's\n
        \  algorithm, for which the KEK MAY be one of the keys derived.\n"
      title: 7.11.2.  Key Creation Payload Processing
    title: 7.11.  Key Creation Payload
  - contents:
    - '7.12.  Nonce Payload

      '
    - contents:
      - "7.12.1.  Nonce Payload Structure\n   The Nonce Payload contains random data
        used to guarantee freshness\n   during an exchange and protect against replay
        attacks.  Figure 27\n   shows the format of the Nonce Payload.\n    0                   1
        \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! Next Payload  !   RESERVED    !         Payload Length        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  ! Nonce Type    !            Nonce Data                         ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \                Figure 27: Nonce Payload Format\n   The Nonce Payload fields
        are defined as follows:\n   Next Payload (1 octet) - Identifier for the payload
        type of the next\n       payload in the message.  If the current payload is
        the last in\n       the message, then this field will be 0.  This field provides
        the\n       \"chaining\" capability.  Table 12 identifies the payload types.\n
        \      This field is treated as an unsigned value.\n   RESERVED (1 octet)
        - Unused, set to 0.\n   Payload Length (2 octets) - Length in octets of the
        current payload,\n       including the generic payload header.  This field
        is treated as\n       an unsigned integer in network byte order format.\n
        \  Nonce Type (1 octet) - Specifies the type of nonce being used.  Table\n
        \      27 identifies the types of nonces.  This field is treated as an\n       unsigned
        value.\n                          Table 27: Nonce Types\n   Nonce_Type              Value
        \     Definition\n   _____________________________________________________________________\n
        \  None                      0\n   Initiator (Nonce_I)       1\n   Responder
        (Nonce_R)       2\n   Combined (Nonce_C)        3        Hash (Append\n                                      (Initiator_Value,Responder_Value))\n
        \                                     The hash type comes from the\n                                      Policy
        (e.g., Security Suite\n                                      Definition of
        Policy Token).\n   Reserved to IANA       4 - 192\n   Private Use           192
        - 255\n   Nonce Data (variable length) - Contains the nonce information.  The\n
        \      values for this field are group specific, and the format is\n       specified
        by the Nonce Type field.  If no group-specific\n       information is provided,
        the minimum length for this field is 4\n       bytes.\n   The payload type
        for the Nonce Payload is twelve (12).\n"
      title: 7.12.1.  Nonce Payload Structure
    - contents:
      - "7.12.2.  Nonce Payload Processing\n   When processing the Nonce Payload,
        the following fields MUST be\n   checked for correct values:\n   1.  Next
        Payload, RESERVED, Payload Length - These fields are\n       processed as
        defined in Section 7.2.2, \"Generic Payload Header\n       Processing\".\n
        \  2.  Nonce Type - The Nonce Type value MUST be checked to be a valid\n       nonce
        type as defined by Table 27.  If the value is not valid,\n       then an error
        is logged.  If in Verbose Mode, an appropriate\n       message containing
        notification value Payload-Malformed will be\n       sent.\n   3.  Nonce Data
        - This is the nonce data and it must be checked\n       according to its content.
        \ The size of this field is defined in\n       Section 7.12, \"Nonce Payload\".
        \ Refer to Section 5.2, \"Group\n       Establishment\", for interpretation
        of this field.\n"
      title: 7.12.2.  Nonce Payload Processing
    title: 7.12.  Nonce Payload
  title: 7.  GSAKMP Payload Structure
- contents:
  - "8.  GSAKMP State Diagram\n   Figure 28 presents the states encountered in the
    use of this\n   protocol.  Table 28 defines the states.  Table 29 defines the\n
    \  transitions.\n         !-----------------> (                  )\n         !
    \  !-------------> (       Idle       ) <------------------!\n         !   !               (
    \                 )                    !\n         !   !                !                !
    \                    !\n         !   !                !                !                     !\n
    \        !   !               (1a)             (1)                    !\n         !
    \  !                !                !                     !\n         !   !                !
    \               !                     !\n         !   !                V                V
    \                    !\n         !   !---(5a)--- (Wait for  )       (Wait for
    \ ) ----(5)-----!\n         !               (Group     )       (GC/KS Event) <---\n
    \        !               (Membership)        ^  !   \\        \\\n         !                    !
    \             !  !    \\        \\\n         !                    !              !
    \ !     \\--(2)---\\\n         !                   (2a)           (4)(3)\n         !
    \                   !              !  !\n         !                    !              !
    \ !\n         !                    V              !  V\n         !-------(4a)---
    (Wait for  )       (Wait for  )\n                         (Group     )       (Response
    \ )\n                         (Membership)       (from Key  )\n                    /-->
    (Event     )       (Download  )\n                   /         /\n                  /
    \        /\n                 /--(3a)---/\n                    Figure 28: GSAKMP
    State Diagram\n                        Table 28: GSAKMP States\n  ______________________________________________________________________\n
    \ Idle                 : GSAKMP Application waiting for input\n  ______________________________________________________________________\n
    \ Wait for GC/KS Event : GC/KS up and running, waiting for events\n  ______________________________________________________________________\n
    \ Wait for Response    : GC/KS has sent Key Download,\n   from Key Download   :
    \ waiting for response from GM\n  ______________________________________________________________________\n
    \ Wait for Group       : GM in process of joining group\n   Membership          :\n
    \ ______________________________________________________________________\n  Wait
    for Group       : GM has group key, waiting for\n   Membership Event    :  group
    management messages.\n  ______________________________________________________________________\n
    \                  Table 29: State Transition Events\n  ____________________________________________________________________\n
    \ Transition 1  : Create group command\n  ______________:_____________________________________________________\n
    \               :\n  Transition 2  : Receive bad RTJ\n                : Receive
    valid command to change group membership\n                : Send Compromise message
    x times\n                : Member Deregistration\n  ______________:_____________________________________________________\n
    \               :\n  Transition 3  : Receive valid RTJ\n  ______________:_____________________________________________________\n
    \               :\n  Transition 4  : Timeout\n                : Receive Ack\n
    \               : Receive Nack\n  ______________:_____________________________________________________\n
    \               :\n  Transition 5  : Delete group command\n  ______________:_____________________________________________________\n
    \               :\n  Transition 1a : Join group command\n  ______________:_____________________________________________________\n
    \               :\n  Transition 2a : Send Ack\n  ______________:_____________________________________________________\n
    \               :\n  Transition 3a : Receipt of group management messages\n  ______________:_____________________________________________________\n
    \               :\n  Transition 4a : Delete group command\n                : Deregistration
    command\n  ______________:_____________________________________________________\n
    \               :\n  Transition 5a : Time out\n                : Msg failure\n
    \               : errors\n                :\n  ____________________________________________________________________\n"
  title: 8.  GSAKMP State Diagram
- contents:
  - '9.  IANA Considerations

    '
  - contents:
    - "9.1.  IANA Port Number Assignment\n   IANA has provided GSAKMP port number
      3761 in both the UDP and TCP\n   spaces.  All implementations MUST use this
      port assignment in the\n   appropriate manner.\n"
    title: 9.1.  IANA Port Number Assignment
  - contents:
    - "9.2.  Initial IANA Registry Contents\n   The following registry entries have
      been created:\n   GSAKMP Group Identification Types (Section 7.1.1)\n   GSAKMP
      Payload Types (Section 7.1.1)\n   GSAKMP Exchange Types (Section 7.1.1)\n   GSAKMP
      Policy Token Types (Section 7.3.1)\n   GSAKMP Key Download Data Item Types (Section
      7.4.1)\n   GSAKMP Cryptographic Key Types (Section 7.4.1.1)\n   GSAKMP Rekey
      Event Types (Section 7.5.1)\n   GSAKMP Identification Classification (Section
      7.6.1)\n   GSAKMP Identification Types (Section 7.6.1)\n   GSAKMP Certificate
      Types (Section 7.7.1)\n   GSAKMP Signature Types (Section 7.8.1)\n   GSAKMP
      Notification Types (Section 7.9.1)\n   GSAKMP Acknowledgement Types (Section
      7.9.1.1)\n   GSAKMP Mechanism Types (Section 7.9.1.3)\n   GSAKMP Nonce Hash
      Types (Section 7.9.1.3)\n   GSAKMP Key Creation Types (Section 7.11.1)\n   GSAKMP
      Nonce Types (Section 7.12.1)\n   Changes and additions to the following registries
      are by IETF\n   Standards Action:\n   GSAKMP Group Identification Types\n   GSAKMP
      Payload Types\n   GSAKMP Exchange Types\n   GSAKMP Policy Token Types\n   GSAKMP
      Key Download Data Item Types\n   GSAKMP Rekey Event Types\n   GSAKMP Identification
      Classification\n   GSAKMP Notification Types\n   GSAKMP Acknowledgement Types\n
      \  GSAKMP Mechanism Types\n   GSAKMP Nonce Types\n   Changes and additions to
      the following registries are by Expert\n   Review:\n   GSAKMP Cryptographic
      Key Types\n   GSAKMP Identification Types\n   GSAKMP Certificate Types\n   GSAKMP
      Signature Types\n   GSAKMP Nonce Hash Types\n   GSAKMP Key Creation Types\n"
    title: 9.2.  Initial IANA Registry Contents
  title: 9.  IANA Considerations
- contents:
  - "10.  Acknowledgements\n   This document is the collaborative effort of many individuals.
    \ If\n   there were no limit to the number of authors that could appear on an\n
    \  RFC, the following, in alphabetical order, would have been listed:\n   Haitham
    S. Cruickshank of University of Surrey, Sunil Iyengar of\n   University Of Surrey
    Gavin Kenny of LogicaCMG, Patrick McDaniel of\n   AT&T Labs Research, and Angela
    Schuett of NSA.\n   The following individuals deserve recognition and thanks for
    their\n   contributions, which have greatly improved this protocol: Eric Harder\n
    \  is an author to the Tunneled-GSAKMP, whose concepts are found in\n   GSAKMP
    as well.  Rod Fleischer, also a Tunneled-GSAKMP author, and\n   Peter Lough were
    both instrumental in coding a prototype of the\n   GSAKMP software and helped
    define many areas of the protocol that\n   were vague at best.  Andrew McFarland
    and Gregory Bergren provided\n   critical analysis of early versions of the specification.
    \ Ran\n   Canetti analyzed the security of the protocol and provided denial of\n
    \  service suggestions leading to optional \"cookie protection\".\n"
  title: 10.  Acknowledgements
- contents:
  - '11.  References

    '
  - contents:
    - "11.1.  Normative References\n   [DH77]      Diffie, W., and M. Hellman, \"New
      Directions in\n               Cryptography\", IEEE Transactions on Information
      Theory,\n               June 1977.\n   [FIPS186-2] NIST, \"Digital Signature
      Standard\", FIPS PUB 186-2,\n               National Institute of Standards
      and Technology, U.S.\n               Department of Commerce, January 2000.\n
      \  [FIPS196]   \"Entity Authentication Using Public Key Cryptography,\"\n               Federal
      Information Processing Standards Publication 196,\n               NIST, February
      1997.\n   [IKEv2]     Kaufman, C., \"Internet Key Exchange (IKEv2) Protocol\",\n
      \              RFC 4306, December 2005.\n   [RFC2119]   Bradner, S., \"Key words
      for use in RFCs to Indicate\n               Requirement Levels\", BCP 14, RFC
      2119, March 1997.\n   [RFC2409]   Harkins, D. and D. Carrel, \"The Internet
      Key Exchange\n               (IKE)\", RFC 2409, November 1998.\n   [RFC2412]
      \  Orman, H., \"The OAKLEY Key Determination Protocol\", RFC\n               2412,
      November 1998.\n   [RFC2627]   Wallner, D., Harder, E., and R. Agee, \"Key Management
      for\n               Multicast: Issues and Architectures\", RFC 2627, June\n
      \              1999.\n   [RFC3280]   Housley, R., Polk, W., Ford, W., and D.
      Solo, \"Internet\n               X.509 Public Key Infrastructure Certificate
      and\n               Certificate Revocation List (CRL) Profile\", RFC 3280,\n
      \              April 2002.\n   [RFC3629]   Yergeau, F., \"UTF-8, a transformation
      format of ISO\n               10646\", STD 63, RFC 3629, November 2003.\n   [RFC4514]
      \  Zeilenga, K., Ed., \"Lightweight Directory Access Protocol\n               (LDAP):
      String Representation of Distinguished Names\",\n               RFC 4514, June
      2006.\n   [RFC4534]   Colegrove, A. and H. Harney, \"Group Security Policy Token\n
      \              v1\", RFC 4534, June 2006.\n"
    title: 11.1.  Normative References
  - contents:
    - "11.2.  Informative References\n   [BMS]       Balenson, D., McGrew, D., and
      A. Sherman, \"Key Management\n               for Large Dynamic Groups:  One-Way
      Function Trees and\n               Amortized Initialization\", Work in Progress,
      February\n               1999.\n   [HCM]       H. Harney, A. Colegrove, P. McDaniel,
      \"Principles of\n               Policy in Secure Groups\", Proceedings of Network
      and\n               Distributed Systems Security 2001 Internet Society, San\n
      \              Diego, CA, February 2001.\n   [HHMCD01]   Hardjono, T., Harney,
      H., McDaniel, P., Colegrove, A.,\n               and P. Dinsmore, \"Group Security
      Policy Token:\n               Definition and Payloads\", Work in Progress, August
      2003.\n   [RFC2093]   Harney, H. and C. Muckenhirn, \"Group Key Management\n
      \              Protocol (GKMP) Specification\", RFC 2093, July 1997.\n   [RFC2094]
      \  Harney, H. and C. Muckenhirn, \"Group Key Management\n               Protocol
      (GKMP) Architecture\", RFC 2094, July 1997.\n   [RFC2408]   Maughan D., Schertler
      M., Schneider M., and Turner J.,\n               \"Internet Security Association
      and Key Management\n               Protocol (ISAKMP)\", RFC 2408, Proposed Standard,
      November\n               1998\n   [RFC2451]   Pereira, R. and R. Adams, \"The
      ESP CBC-Mode Cipher\n               Algorithms\", RFC 2451, November 1998.\n
      \  [RFC2522]   Karn, P. and W. Simpson, \"Photuris: Session-Key\n               Management
      Protocol\", RFC 2522, March 1999.\n   [RFC4523]   Zeilenga, K., \"Lightweight
      Directory Access Protocol\n               (LDAP) Schema Definitions for X.509
      Certificates\", RFC\n               4523, June 2006.\n   [RFC2974]   Handley,
      M., Perkins, C., and E. Whelan, \"Session\n               Announcement Protocol\",
      RFC 2974, October 2000.\n   [RFC3161]   Adams, C., Cain, P., Pinkas, D., and
      R. Zuccherato,\n               \"Internet X.509 Public Key Infrastructure Time-Stamp\n
      \              Protocol (TSP)\", RFC 3161, August 2001.\n   [RFC3261]   Rosenberg,
      J., Schulzrinne, H., Camarillo, G., Johnston,\n               A., Peterson,
      J., Sparks, R., Handley, M., and E.\n               Schooler, \"SIP: Session
      Initiation Protocol\", RFC 3261,\n               June 2002.\n   [RFC3447]   Jonsson,
      J. and B. Kaliski, \"Public-Key Cryptography\n               Standards (PKCS)
      #1: RSA Cryptography Specifications\n               Version 2.1\", RFC 3447,
      February 2003.\n   [RFC3526]   Kivinen, T. and M. Kojo, \"More Modular Exponential
      (MODP)\n               Diffie-Hellman groups for Internet Key Exchange (IKE)\",\n
      \              RFC 3526, May 2003.\n   [RFC3740]   Hardjono, T. and B. Weis,
      \"The Multicast Group Security\n               Architecture\", RFC 3740, March
      2004.\n   [RFC4086]   Eastlake, D., 3rd, Schiller, J., and S. Crocker,\n               \"Randomness
      Requirements for Security\", BCP 106, RFC\n               4086, June 2005.\n"
    title: 11.2.  Informative References
  title: 11.  References
- contents:
  - "Appendix A.  LKH Information\n   This appendix will give an overview of LKH,
    define the values for\n   fields within GSAKMP messages that are specific to LKH,
    and give an\n   example of a Rekey Event Message using the LKH scheme.\n"
  - contents:
    - "A.1.  LKH Overview\n   LKH provides a topology for handling key distribution
      for a group\n   rekey.  It rekeys a group based upon a tree structure and subgroup\n
      \  keys.  In the LKH tree shown in Figure 29, members are represented by\n   the
      leaf nodes on the tree, while intermediate tree nodes represent\n   abstract
      key groups.  A member will possess multiple keys: the group\n   traffic protection
      key (GTPK), subgroup keys for every node on its\n   path to the root of the
      tree, and a personal key.  For example, the\n   member labeled as #3 will have
      the GTPK, Key A, Key D, and Key 3.\n                              root\n                    /
      \                     \\\n                   /                        \\\n                A
      \                              B\n            /      \\                        /
      \     \\\n           /        \\                      /        \\\n        C
      \              D               E               F\n      /   \\           /   \\
      \          /   \\           /   \\\n     /     \\         /     \\         /
      \    \\         /     \\\n   1         2     3         4     5         6     7
      \        8\n                      Figure 29: LKH Tree\n   This keying topology
      provides for a rapid rekey to all but a\n   compromised member of the group.
      \ If Member 3 were compromised, the\n   new GTPK (GTPK') would need to be distributed
      to the group under a\n   key not possessed by Member 3.  Additionally, new Keys
      A and D (Key\n   A' and Key D') would also need to be securely distributed to
      the\n   other members of those subtrees.  Encrypting the GTPK' with Key B\n
      \  would securely distribute that key to Members 5, 6, 7, and 8.  Key C\n   can
      be used to encrypt both the GTPK' and Key A' for Members 1 and 2.\n   Member
      3's nearest neighbor, Member 4, can obtain GTPK', Key D', and\n   Key A' encrypted
      under its personal key, Key 4.  At the end of this\n   process, the group is
      securely rekeyed with Member 3 fully excluded.\n"
    title: A.1.  LKH Overview
  - contents:
    - "A.2.  LKH and GSAKMP\n   When using LKH with GSAKMP, the following issues require
      attention:\n   1.  Rekey Version # - The Rekey Version # in the Rekey Array
      of the\n       Key Download Payload MUST contain the value one (1).\n   2.  Algorithm
      Version - The Algorithm Version in the Rekey Event\n       Payload MUST contain
      the value one (1).\n   3.  Degree of Tree - The LKH tree used can be of any
      degree; it need\n       not be binary.\n   4.  Node Identification - Each node
      in the tree is treated as a KEK.\n       A KEK is just a special key.  As the
      rule stated for all keys in\n       GSAKMP, the set of the KeyID and the KeyHandle
      MUST be unique.  A\n       suggestion on how to do this will be given in this
      section.\n   5.  Wrapping KeyID and Handle - This is the KeyID and Handle of
      the\n       LKH node used to wrap/encrypt the data in a Rekey Event Data.\n
      \  For the following discussion, refer to Figure 30.\n   Key:\n   o: a node
      in the LKH tree\n   N: this line contains the KeyID node number\n   L: this
      line contains the MemberID number for all leaves ONLY\n       LEVEL\n       ----\n
      \      root                          o\n   N:                         /      1
      \    \\\n                             /              \\\n       1              o
      \                            o\n   N:              /  2  \\                       /
      \ 3  \\\n                  /       \\                     /       \\\n       2
      \     o               o             o               o\n   N:        /4\\             /5\\
      \          /6\\             /7\\\n            /   \\           /   \\         /
      \  \\           /   \\\n       3  o       o       o       o     o       o       o
      \      o\n   N:     8       9      10      11    12      13      14      15\n
      \  L:     1       2       3       4     5       6       7       8\n                        Figure
      30: GSAKMP LKH Tree\n   To guarantee uniqueness of KeyID, the Rekey Controller
      SHOULD build a\n   virtual tree and label the KeyID of each node, doing a breadth-first\n
      \  search of a fully populated tree regardless of whether or not the\n   tree
      is actually full.  For simplicity of this example, the root of\n   the tree
      was given KeyID value of one (1).  These KeyID values will\n   be static throughout
      the life of this tree.  Additionally, the rekey\n   arrays distributed to GMs
      requires a MemberID value associated with\n   them to be distributed with the
      KeyDownload Payload.  These MemberID\n   values MUST be unique.  Therefore,
      the set associated with each leaf\n   node (the nodes from that leaf back to
      the root) are given a\n   MemberID.  In this example, the leftmost leaf node
      is given MemberID\n   value of one (1).  These 2 sets of values, the KeyIDs
      (represented on\n   lines N) and the MemberIDs (represented on line L), will
      give\n   sufficient information in the KeyDownload and RekeyEvent Payloads to\n
      \  disseminate information.  The KeyHandle associated with these keys is\n   regenerated
      each time the key is replaced in the tree due to\n   compromise.\n"
    title: A.2.  LKH and GSAKMP
  - contents:
    - "A.3.  LKH Examples\n   Definition of values:\n   0xLLLL          - length value\n
      \  0xHHHHHHH#      - handle value\n   YYYYMMDDHHMMSSZ - time value\n"
    - contents:
      - "A.3.1.  LKH Key Download Example\n   This section will give an example of
        the data for the Key Download\n   payload.  The GM will be given MemberID
        1 and its associated keys.\n   The data shown will be subsequent to the Generic
        Payload Header.\n   | GTPK | MemberID 1 | KeyID 2 | KeyID 4 | KeyID 8\n   Number
        of Items                   - 0x0002\n     Item #1:\n       Key Download Data
        Item Type   - 0x00 (GTPK)\n       Key Download Data Item Length - 0xLLLL\n
        \        Key Type                    - 0x03 (3DES`CBC64`192)\n         Key
        ID                      - KEY1\n         Key Handle                  - 0xHHHHHHH0\n
        \        Key Creation Date           - YYYYMMDDHHMMSSZ\n         Key Expiration
        Date         - YYYYMMDDHHMMSSZ\n         Key Data                    - variable,
        based on key definition\n     Item #2:\n       Key Download Data Item Type
        \  - 0x01 (Rekey - LKH)\n       Key Download Data Item Length - 0xLLLL\n       Rekey
        Version Number          - 0x01\n       Member ID                     - 0x00000001\n
        \      Number of KEK Keys            - 0x0003\n         KEK #1:\n           Key
        Type                  - 0x03 (3DES`CBC64`192)\n           Key ID                    -
        0x00000002\n           Key Handle                - 0xHHHHHHH2\n           Key
        Creation Date         - YYYYMMDDHHMMSSZ\n           Key Expiration Date       -
        YYYYMMDDHHMMSSZ\n           Key Data                  - variable, based on
        key definition\n         KEK #2:\n           Key Type                  - 0x03
        (3DES`CBC64`192)\n           Key ID                    - 0x00000004\n           Key
        Handle                - 0xHHHHHHH4\n           Key Creation Date         -
        YYYYMMDDHHMMSSZ\n           Key Expiration Date       - YYYYMMDDHHMMSSZ\n
        \          Key Data                  - variable, based on key definition\n
        \        KEK #3:\n           Key Type                  - 0x03 (3DES`CBC64`192)\n
        \          Key ID                    - 0x00000008\n           Key Handle                -
        0xHHHHHHH8\n           Key Creation Date         - YYYYMMDDHHMMSSZ\n           Key
        Expiration Date       - YYYYMMDDHHMMSSZ\n           Key Data                  -
        variable, based on key definition\n"
      title: A.3.1.  LKH Key Download Example
    - contents:
      - "A.3.2.  LKH Rekey Event Example\n   This section will give an example of
        the data for the Rekey Event\n   payload.  The GM with MemberID 6 will be
        keyed out of the group.  The\n   data shown will be subsequent to the Generic
        Payload Header.\n   | Rekey Event Type | GroupID | Date/Time | Rekey Type
        |\n   Algorithm Ver | # of Packets |\n   { (GTPK)2, (GTPK, 3', 6')12, (GTPK,
        3')7 }\n   This data shows that three packets are being transmitted.  Read
        each\n   packet as:\n   a) GTPK wrapped in LKH KeyID 2\n   b) GTPK, LKH KeyIDs
        3' & 6', all wrapped in LKH KeyID 12\n   c) GTPK and LKH KeyID 3', all wrapped
        in LKH KeyID 7\n   NOTE: Although in this example multiple keys are encrypted
        under one\n   key, alternative pairings are legal (e.g., (GTPK)2, (GTPK)3',
        (3')6',\n   (3')7', (6')12).\n   We will show the format for all header data
        and packet (b).\n   Rekey Event Type  - 0x01 (GSAKMP`LKH)\n   GroupID           -
        0xAABBCCDD\n                       0x12345678\n   Time/Date Stamp   - YYYYMMDDHHMMSSZ\n
        \  Rekey Event Type  - 0x01 (GSAKMP`LKH)\n   Algorithm Vers    - 0x01\n   #
        of RkyEvt Pkts  - 0x0003\n   For Packet (b):\n   Packet Length       - 0xLLLL\n
        \  Wrapping KeyID      - 0x000C\n   Wrapping Key Handle - 0xHHHHHHHD\n   #
        of Key Packages   - 0x0003\n     Key Package 1:\n       Key Pkg Type  - 0x00
        (GTPK)\n       Pack Length   - 0xLLLL\n         Key Type            - 0x03
        (3DES`CBC64`192)\n         Key ID              - KEY1\n         Key Handle
        \         - 0xHHHHHHH0\n         Key Creation Date   - YYYYMMDDHHMMSSZ\n         Key
        Expiration Date - YYYYMMDDHHMMSSZ\n         Key Data            - variable,
        based on key definition\n     Key Package 2:\n       Key Pkg Type  - 0x01
        (Rekey  - LKH)\n       Pack Length   - 0xLLLL\n         Key Type            -
        0x03 (3DES`CBC64`192)\n         Key ID              - 0x00000003\n         Key
        Handle          - 0xHHHHHHH3\n         Key Creation Date   - YYYYMMDDHHMMSSZ\n
        \        Key Expiration Date - YYYYMMDDHHMMSSZ\n         Key Data            -
        variable, based on key definition\n     Key Package 3:\n       Key Pkg Type
        \ - 0x01 (Rekey  - LKH)\n       Pack Length   - 0xLLLL\n         Key Type
        \           - 0x03 (3DES`CBC64`192)\n         Key ID              - 0x00000006\n
        \        Key Handle          - 0xHHHHHHH6\n         Key Creation Date   -
        YYYYMMDDHHMMSSZ\n         Key Expiration Date - YYYYMMDDHHMMSSZ\n         Key
        Data            - variable, based on key definition\n"
      title: A.3.2.  LKH Rekey Event Example
    title: A.3.  LKH Examples
  title: Appendix A.  LKH Information
- contents:
  - "Authors' Addresses\n   Hugh Harney (point-of-contact)\n   SPARTA, Inc.\n   7110
    Samuel Morse Drive\n   Columbia, MD 21046\n   Phone: (443) 430-8032\n   Fax:   (443)
    430-8181\n   EMail: hh@sparta.com\n   Uri Meth\n   SPARTA, Inc.\n   7110 Samuel
    Morse Drive\n   Columbia, MD 21046\n   Phone: (443) 430-8058\n   Fax:   (443)
    430-8207\n   EMail: umeth@sparta.com\n   Andrea Colegrove\n   SPARTA, Inc.\n   7110
    Samuel Morse Drive\n   Columbia, MD 21046\n   Phone: (443) 430-8014\n   Fax:   (443)
    430-8163\n   EMail: acc@sparta.com\n   George Gross\n   IdentAware Security\n
    \  82 Old Mountain Road\n   Lebanon, NJ 08833\n   Phone: (908) 268-1629\n   EMail:
    gmgross@identaware.com\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This
    document is subject to the rights, licenses and restrictions\n   contained in
    BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n
    \  This document and the information contained herein are provided on an\n   \"AS
    IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING TASK FORCE
    DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT LIMITED TO
    ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT INFRINGE ANY
    RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at\n   ietf-ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n
    \  Administrative Support Activity (IASA).\n"
  title: Acknowledgement
