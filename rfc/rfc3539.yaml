- contents:
  - '  Authentication, Authorization and Accounting (AAA) Transport Profile

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document discusses transport issues that arise within protocols\n
    \  for Authentication, Authorization and Accounting (AAA).  It also\n   provides
    recommendations on the use of transport by AAA protocols.\n   This includes usage
    of standards-track RFCs as well as experimental\n   proposals.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  2\n       1.1.  Requirements Language. . . . . . . . . . . . . .
    . . . .  2\n       1.2.  Terminology. . . . . . . . . . . . . . . . . . . . .
    . .  2\n   2.  Issues in Transport Usage. . . . . . . . . . . . . . . . . . .
    \ 5\n       2.1.  Application-driven Versus Network-driven . . . . . . . .  5\n
    \      2.2.  Slow Failover. . . . . . . . . . . . . . . . . . . . . .  6\n       2.3.
    \ Use of Nagle Algorithm . . . . . . . . . . . . . . . . .  7\n       2.4.  Multiple
    Connections . . . . . . . . . . . . . . . . . .  7\n       2.5.  Duplicate Detection.
    . . . . . . . . . . . . . . . . . .  8\n       2.6.  Invalidation of Transport
    Parameter Estimates. . . . . .  8\n       2.7.  Inability to use Fast Re-Transmit.
    . . . . . . . . . . .  9\n       2.8.  Congestion Avoidance . . . . . . . . .
    . . . . . . . . .  9\n       2.9.  Delayed Acknowledgments. . . . . . . . . .
    . . . . . . . 11\n       2.10. Premature Failover . . . . . . . . . . . . . .
    . . . . . 11\n       2.11. Head of Line Blocking. . . . . . . . . . . . . . .
    . . . 11\n       2.12. Connection Load Balancing. . . . . . . . . . . . . . .
    . 12\n   3.  AAA Transport Profile. . . . . . . . . . . . . . . . . . . . . 12\n
    \      3.1.  Transport Mappings . . . . . . . . . . . . . . . . . . . 12\n       3.2.
    \ Use of Nagle Algorithm . . . . . . . . . . . . . . . . . 12\n       3.3.  Multiple
    Connections . . . . . . . . . . . . . . . . . . 13\n       3.4.  Application Layer
    Watchdog . . . . . . . . . . . . . . . 13\n       3.5.  Duplicate Detection. .
    . . . . . . . . . . . . . . . . . 19\n       3.6.  Invalidation of Transport Parameter
    Estimates. . . . . . 20\n       3.7.  Inability to use Fast Re-Transmit. . . .
    . . . . . . . . 21\n       3.8.  Head of Line Blocking. . . . . . . . . . . .
    . . . . . . 22\n       3.9.  Congestion Avoidance . . . . . . . . . . . . . .
    . . . . 23\n       3.10. Premature Failover . . . . . . . . . . . . . . . . .
    . . 24\n   4.  Security Considerations. . . . . . . . . . . . . . . . . . . .
    24\n   5.  IANA Considerations. . . . . . . . . . . . . . . . . . . . . . 25\n
    \  6.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n       6.1.
    \ Normative References . . . . . . . . . . . . . . . . . . 25\n       6.2.  Informative
    References . . . . . . . . . . . . . . . . . 26\n   Appendix A - Detailed Watchdog
    Algorithm Description . . . . . . . 28\n   Appendix B - AAA Agents. . . . . .
    . . . . . . . . . . . . . . . . 33\n       B.1.  Relays and Proxies . . . . .
    . . . . . . . . . . . . . . 33\n       B.2.  Re-directs . . . . . . . . . . .
    . . . . . . . . . . . . 35\n       B.3.  Store and Forward Proxies. . . . . .
    . . . . . . . . . . 36\n       B.4.  Transport Layer Proxies. . . . . . . . .
    . . . . . . . . 38\n   Intellectual Property Statement. . . . . . . . . . . .
    . . . . . . 39\n   Acknowledgments. . . . . . . . . . . . . . . . . . . . . .
    . . . . 39\n   Author Addresses . . . . . . . . . . . . . . . . . . . . . . .
    . . 40\n   Full Copyright Statement . . . . . . . . . . . . . . . . . . . . .
    41\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This document discusses transport issues that arise within
    protocols\n   for Authentication, Authorization and Accounting (AAA).  It also\n
    \  provides recommendations on the use of transport by AAA protocols.\n   This
    includes usage of standards-track RFCs as well as experimental\n   proposals.\n"
  - contents:
    - "1.1.  Requirements Language\n   In this document, the key words \"MAY\", \"MUST,
      \"MUST NOT\", \"optional\",\n   \"recommended\", \"SHOULD\", and \"SHOULD NOT\",
      are to be interpreted as\n   described in [RFC2119].\n"
    title: 1.1.  Requirements Language
  - contents:
    - "1.2.  Terminology\n   Accounting\n             The act of collecting information
      on resource usage for the\n             purpose of trend analysis, auditing,
      billing, or cost\n             allocation.\n   Administrative Domain\n             An
      internet, or a collection of networks, computers, and\n             databases
      under a common administration.\n   Agent     A AAA agent is an intermediary
      that communicates with AAA\n             clients and servers.  Several types
      of AAA agents exist,\n             including Relays, Re-directs, and Proxies.\n
      \  Application-driven transport\n             Transport behavior is said to
      be \"application-driven\" when\n             the rate at which messages are
      sent is limited by the rate\n             at which the application generates
      data, rather than by the\n             size of the congestion window.  In the
      most extreme case,\n             the time between transactions exceeds the round-trip
      time\n             between sender and receiver, implying that the application\n
      \            operates with an effective congestion window of one.  AAA\n             transport
      is typically application driven.\n   Attribute Value Pair (AVP)\n             The
      variable length concatenation of a unique Attribute\n             (represented
      by an integer) and a Value containing the\n             actual value identified
      by the attribute.\n   Authentication\n             The act of verifying a claimed
      identity, in the form of a\n             pre-existing label from a mutually
      known name space, as the\n             originator of a message (message authentication)
      or as the\n             end-point of a channel (entity authentication).\n   Authorization\n
      \            The act of determining if a particular right, such as\n             access
      to some resource, can be granted to the presenter of\n             a particular
      credential.\n   Billing   The act of preparing an invoice.\n   Network Access
      Identifier\n             The Network Access Identifier (NAI) is the userID submitted\n
      \            by the host during network access authentication.  In\n             roaming,
      the purpose of the NAI is to identify the user as\n             well as to assist
      in the routing of the authentication\n             request.  The NAI may not
      necessarily be the same as the\n             user's e-mail address or the user-ID
      submitted in an\n             application layer authentication.\n   Network
      Access Server (NAS)\n             A Network Access Server (NAS) is a device
      that hosts\n             connect to in order to get access to the network.\n
      \  Proxy     In addition to forwarding requests and responses, proxies\n             enforce
      policies relating to resource usage and\n             provisioning.  This is
      typically accomplished by tracking\n             the state of NAS devices.  While
      proxies typically do not\n             respond to client Requests prior to receiving
      a Response\n             from the server, they may originate Reject messages
      in\n             cases where policies are violated.  As a result, proxies\n
      \            need to understand the semantics of the messages passing\n             through
      them, and may not support all extensions.\n   Local Proxy\n             A Local
      Proxy is a proxy that exists within the same\n             administrative domain
      as the network device (e.g. NAS) that\n             issued the AAA request.
      \ Typically a local proxy is used to\n             multiplex AAA messages to
      and from a large number of\n             network devices, and may implement
      policy.\n   Store and forward proxy\n             Store and forward proxies
      distinguish themselves from other\n             proxy species by sending a reply
      to the NAS prior to\n             proxying the request to the server.  As a
      result, store and\n             forward proxies need to implement AAA client
      and server\n             functionality for the messages that they handle.  Store
      and\n             Forward proxies also typically keep state on conversations\n
      \            in progress in order to assure delivery of proxied Requests\n             and
      Responses.  While store and forward proxies are most\n             frequently
      deployed for accounting, they also can be used\n             to implement authentication/authorization
      policy.\n   Network-driven transport\n             Transport behavior is said
      to be \"network driven\" when the\n             rate at which messages are sent
      is limited by the\n             congestion window, not by the rate at which
      the application\n             can generate data.  File transfer is an example
      of an\n             application where transport is network driven.\n   Re-direct
      Rather than forwarding Requests and Responses between\n             clients
      and servers, Re-directs refer clients to servers\n             and allow them
      to communicate directly.  Since Re-directs\n             do not sit in the forwarding
      path, they do not alter any\n             AVPs transitting between client and
      server.  Re-directs do\n             not originate messages and are capable
      of handling any\n             message type.  A Re-direct may be configured only
      to re-\n             direct messages of certain types, while acting as a Relay\n
      \            or Proxy for other types.  As with Relays, re-directs do\n             not
      keep state with respect to conversations or NAS\n             resources.\n   Relay
      \    Relays forward requests and responses based on routing-\n             related
      AVPs and domain forwarding table entries.  Since\n             relays do not
      enforce policies, they do not examine or\n             alter non-routing AVPs.
      \ As a result, relays never\n             originate messages, do not need to
      understand the semantics\n             of messages or non-routing AVPs, and
      are capable of\n             handling any extension or message type.  Since
      relays make\n             decisions based on information in routing AVPs and
      domain\n             forwarding tables they do not keep state on NAS resource\n
      \            usage or conversations in progress.\n"
    title: 1.2.  Terminology
  title: 1.  Introduction
- contents:
  - "2.  Issues in AAA Transport Usage\n   Issues that arise in AAA transport usage
    include:\n      Application-driven versus network-driven\n      Slow failover\n
    \     Use of Nagle Algorithm\n      Multiple connections\n      Duplicate detection\n
    \     Invalidation of transport parameter estimates\n      Inability to use fast
    re-transmit\n      Congestion avoidance\n      Delayed acknowledgments\n      Premature
    Failover\n      Head of line blocking\n      Connection load balancing\n   We
    discuss each of these issues in turn.\n"
  - contents:
    - "2.1.  Application-driven versus Network-driven\n   AAA transport behavior is
      typically application rather than network\n   driven.  This means that the rate
      at which messages are sent is\n   typically limited by how quickly they are
      generated by the\n   application, rather than by the size of the congestion
      window.\n   For example, let us assume a 48-port NAS with an average session
      time\n   of 20 minutes.  This device will, on average, send only 144\n   authentication/authorization
      requests/hour, and an equivalent number\n   of accounting requests.  This represents
      an average inter-packet\n   spacing of 25 seconds, which is much larger than
      the Round Trip Time\n   (RTT) in most networks.\n   Even on much larger NAS
      devices, the inter-packet spacing is often\n   larger than the RTT.  For example,
      consider a 2048-port NAS with an\n   average session time of 10 minutes.  It
      will on average send 3.4\n   authentication/authorization requests/second, and
      an equivalent\n   number of accounting requests.  This translates to an average
      inter-\n   packet spacing of 293 ms.\n   However, even where transport behavior
      is largely application-driven,\n   periods of network-driven behavior can occur.
      \ For example, after a\n   NAS reboot, previously stored accounting records
      may be sent to the\n   accounting server in rapid succession.  Similarly, after
      recovery\n   from a power failure, users may respond with a large number of\n
      \  simultaneous logins.  In both cases, AAA messages may be generated\n   more
      quickly than the network will allow them to be sent, and a queue\n   will build
      up.\n   Network congestion can occur when transport behavior is network-\n   driven
      or application-driven.  For example, while a single NAS may\n   not send substantial
      AAA traffic, many NASes may communicate with a\n   single AAA proxy or server.
      \ As a result, routers close to a heavily\n   loaded proxy or server may experience
      congestion, even though traffic\n   from each individual NAS is light.  Such
      \"convergent congestion\" can\n   result in dropped packets in routers near
      the AAA server, or even\n   within the AAA server itself.\n   Let us consider
      what happens when 10,000 48-ports NASes, each with an\n   average session time
      of 20 minutes, are configured with the same AAA\n   agent or server.  The unfortunate
      proxy or server would receive 400\n   authentication/authorization requests/second
      and an equivalent number\n   of accounting requests.  For 1000 octet requests,
      this would generate\n   6.4 Mbps of incoming traffic at the AAA agent or server.\n
      \  While this transaction load is within the capabilities of the fastest\n   AAA
      agents and servers, implementations exist that cannot handle such\n   a high
      load.  Thus high queuing delays and/or dropped packets may be\n   experienced
      at the agent or server, even if routers on the path are\n   not congested.  Thus,
      a well designed AAA protocol needs to be able\n   to handle congestion occurring
      at the AAA server, as well as\n   congestion experienced within the network.\n"
    title: 2.1.  Application-driven versus Network-driven
  - contents:
    - "2.2.  Slow Failover\n   Where TCP [RFC793] is used as the transport, AAA implementations
      will\n   experience very slow fail over times if they wait until a TCP\n   connection
      times out before resending on another connection.  This is\n   not an issue
      for SCTP [RFC2960], which supports endpoint and path\n   failure detection.
      \ As described in section 8 of [RFC2960], when the\n   number of retransmissions
      exceeds the maximum\n   (\"Association.Max.Retrans\"), the peer endpoint is
      considered\n   unreachable, the association enters the CLOSED state, and the
      failure\n   is reported to the application.  This enables more rapid failure\n
      \  detection.\n"
    title: 2.2.  Slow Failover
  - contents:
    - "2.3.  Use of Nagle Algorithm\n   AAA protocol messages are often smaller than
      the maximum segment size\n   (MSS).  While exceptions occur when certificate-based
      authentication\n   messages are issued or where a low path MTU is found, typically
      AAA\n   protocol messages are less than 1000 octets.  Therefore, when using\n
      \  TCP [RFC793], the total packet count and associated network overhead\n   can
      be reduced by combining multiple AAA messages within a single\n   packet.\n
      \  Where AAA runs over TCP and transport behavior is network-driven,\n   such
      as after a reboot when many users login simultaneously, or many\n   stored accounting
      records need to be sent, the Nagle algorithm will\n   result in \"transport
      layer batching\" of AAA messages.  While this\n   does not reduce the work required
      by the application in parsing\n   packets and responding to the messages, it
      does reduce the number of\n   packets processed by routers along the path.  The
      Nagle algorithm is\n   not used with SCTP.\n   Where AAA transport is application-driven,
      the NAS will typically\n   receive a reply from the home server prior to having
      another request\n   to send.  This implies, for example, that accounting requests
      will\n   typically be sent individually rather than being batched by the\n   transport
      layer.  As a result, within the application-driven regime,\n   the Nagle algorithm
      [RFC896] is ineffective.\n"
    title: 2.3.  Use of Nagle Algorithm
  - contents:
    - "2.4.  Multiple Connections\n   Since the RADIUS [RFC2865] Identifier field
      is a single octet, a\n   maximum of 256 requests can be in progress between
      two endpoints\n   described by a 5-tuple: (Client IP address, Client port, UDP,
      Server\n   IP address, Server port).  In order to get around this limitation,\n
      \  RADIUS clients have utilized more than one sending port, sometimes\n   even
      going to the extreme of using a different UDP source port for\n   each NAS port.\n
      \  Were this behavior to be extended to AAA protocols operating over\n   reliable
      transport, the result would be multiplication of the\n   effective slow-start
      ramp-up by the number of connections.  For\n   example, if a AAA client had
      ten connections open to a AAA agent, and\n   used a per-connection initial window
      [RFC3390] of 2, then the\n   effective initial window would be 20.  This is
      inappropriate, since\n   it would permit the AAA client to send a large burst
      of packets into\n   the network.\n"
    title: 2.4.  Multiple Connections
  - contents:
    - "2.5.  Duplicate Detection\n   Where a AAA client maintains connections to multiple
      AAA agents or\n   servers, and where failover/failback or connection load balancing
      is\n   supported, it is possible for multiple agents or servers to receive\n
      \  duplicate copies of the same transaction.  A transaction may be sent\n   on
      another connection before expiration of the \"time wait\" interval\n   necessary
      to guarantee that all packets sent on the original\n   connection have left
      the network.  Therefore it is conceivable that\n   transactions sent on the
      alternate connection will arrive before\n   those sent on the failed connection.
      \ As a result, AAA agents and\n   servers MUST be prepared to handle duplicates,
      and MUST assume that\n   duplicates can arrive on any connection.\n   For example,
      in billing, it is necessary to be able to weed out\n   duplicate accounting
      records, based on the accounting session-id,\n   event-timestamp and NAS identification
      information.  Where\n   authentication requests are always idempotent, the resultant\n
      \  duplicate responses from multiple servers will presumably be\n   identical,
      so that little harm will result.\n   However, there are situations where the
      response to an authentication\n   request will depend on a previously established
      state, such as when\n   simultaneous usage restrictions are being enforced.
      \ In such cases,\n   authentication requests will not be idempotent.  For example,
      while\n   an initial request might elicit an Accept response, a duplicate\n
      \  request might elicit a Reject response from another server, if the\n   user
      were already presumed to be logged in, and only one simultaneous\n   session
      were permitted.  In these situations, the AAA client might\n   receive both
      Accept and Reject responses to the same duplicate\n   request, and the outcome
      will depend on which response arrives first.\n"
    title: 2.5.  Duplicate Detection
  - contents:
    - "2.6.  Invalidation of Transport Parameter Estimates\n   Congestion control
      principles [Congest],[RFC2914] require the ability\n   of a transport protocol
      to respond effectively to congestion, as\n   sensed via increasing delays, packet
      loss, or explicit congestion\n   notification.\n   With network-driven applications,
      it is possible to respond to\n   congestion on a timescale comparable to the
      round-trip time (RTT).\n   However, with AAA protocols, the time between sends
      may be longer\n   than the RTT, so that the network conditions can not be assumed
      to\n   persist between sends.  For example, the congestion window may grow\n
      \  during a period in which congestion is being experienced because few\n   packets
      are sent, limiting the opportunity for feedback.  Similarly,\n   after congestion
      is detected, the congestion window may remain small,\n   even though the network
      conditions that existed at the time of\n   congestion no longer apply by the
      time when the next packets are\n   sent.  In addition, due to the low sampling
      interval, estimates of\n   RTT and RTO made via the procedure described in [RFC2988]
      may become\n   invalid.\n"
    title: 2.6.  Invalidation of Transport Parameter Estimates
  - contents:
    - "2.7.  Inability to Use Fast Re-transmit\n   When congestion window validation
      [RFC2861] is implemented, the\n   result is that AAA protocols operate much
      of the time in slow-start\n   with an initial congestion window set to 1 or
      2, depending on the\n   implementation [RFC3390].  This implies that AAA protocols
      gain\n   little benefit from the windowing features of reliable transport.\n
      \  Since the congestion window is so small, it is generally not possible\n   to
      receive enough duplicate ACKs (3) to trigger fast re-transmit.  In\n   addition,
      since AAA traffic is two-way, ACKs including data will not\n   count as part
      of the duplicate ACKs necessary to trigger fast re-\n   transmit.  As a result,
      dropped packets will require a retransmission\n   timeout (RTO).\n"
    title: 2.7.  Inability to Use Fast Re-transmit
  - contents:
    - "2.8.  Congestion Avoidance\n   The law of conservation of packets [Congest]
      suggests that a client\n   should not send another packet into the network until
      it can be\n   reasonably sure that a packet has exited the network on the same\n
      \  path.  In the case of a AAA client, the law suggests that it should\n   not
      retransmit to the same server or choose another server until it\n   can be reasonably
      sure that a packet has exited the network on the\n   same path.  If the client
      advances the window as responses arrive,\n   then the client will \"self clock\",
      adjusting its transmission rate to\n   the available bandwidth.\n   While a
      AAA client using a reliable transport such as TCP [RFC793] or\n   SCTP [RFC2960]
      will self-clock when communicating directly with a\n   AAA-server, end-to-end
      self-clocking is not assured when AAA agents\n   are present.\n   As described
      in the Appendix, AAA agents include Relays, Proxies,\n   Re-directs, Store and
      Forward proxies, and Transport proxies.  Of\n   these agents, only Transport
      proxies and Re-directs provide a direct\n   transport connection between the
      AAA client and server, allowing\n   end-to-end self-clocking to occur.\n   With
      Relays, Proxies or Store and Forward proxies, two separate and\n   de-coupled
      transport connections are used.  One connection operates\n   between the AAA
      client and agent, and another between the agent and\n   server.  Since the two
      transport connections are de-coupled,\n   transport layer ACKs do not flow end-to-end,
      and self-clocking does\n   not occur.\n   For example, consider what happens
      when the bottleneck exists between\n   a AAA Relay and a AAA server.  Self-clocking
      will occur between the\n   AAA client and AAA Relay, causing the AAA client
      to adjust its\n   sending rate to the rate at which transport ACKs flow back
      from the\n   AAA Relay.  However, since this rate is higher than the bottleneck\n
      \  bandwidth, the overall system will not self-clock.\n   Since there is no
      direct transport connection between the AAA client\n   and AAA server, the AAA
      client does not have the ability to estimate\n   end-to-end transport parameters
      and adjust its sending rate to the\n   bottleneck bandwidth between the Relay
      and server.  As a result, the\n   incoming rate at the AAA Relay can be higher
      than the rate at which\n   packets can be sent to the AAA server.\n   In this
      case, the end-to-end performance will be determined by\n   details of the agent
      implementation.  In general, the end-to-end\n   transport performance in the
      presence of Relays, Proxies or Store and\n   Forward proxies will always be
      worse in terms of delay and packet\n   loss than if the AAA client and server
      were communicating directly.\n   For example, if the agent operates with a large
      receive buffer, it is\n   possible that a large queue will develop on the receiving
      side, since\n   the AAA client is able to send packets to the AAA agent more
      rapidly\n   than the agent can send them to the AAA server.  Eventually, the\n
      \  buffer will overflow, causing wholesale packet loss as well as high\n   delay.\n
      \  Methods to induce fine-grained coupling between the two transport\n   connections
      are difficult to implement.  One possible solution is for\n   the AAA agent
      to operate with a receive buffer that is no larger than\n   its send buffer.
      \ If this is done, \"back pressure\" (closing of the\n   receive window) will
      cause the agent to reduce the AAA client sending\n   rate when the agent send
      buffer fills.  However, unless multiple\n   connections exist between the AAA
      client and AAA agent, closing of\n   the receive window will affect all traffic
      sent by the AAA client,\n   even traffic destined to AAA servers where no bottleneck
      exists.\n   Since multiple connections between a AAA client and agent result
      in\n   multiplication of the effective slow-start ramp rate, this is not\n   recommended.
      \ As a result, use of \"back pressure\" cannot enable\n   individual AAA client-server
      conversations to self-clock, and this\n   technique appears impractical for
      use in AAA.\n"
    title: 2.8.  Congestion Avoidance
  - contents:
    - "2.9.  Delayed Acknowledgments\n   As described in Appendix B, ACKs may comprise
      as much as half of the\n   traffic generated in a AAA exchange.  This occurs
      because AAA\n   conversations are typically application-driven, and therefore
      there\n   is frequently not enough traffic to enable ACK piggybacking.  As a\n
      \  result, AAA protocols running over TCP or SCTP transport may\n   experience
      a doubling of traffic as compared with implementations\n   utilizing UDP transport.\n
      \  It is typically not possible to address this issue via the sockets\n   API.
      \ ACK parameters (such as the value of the delayed ACK timer) are\n   typically
      fixed by TCP and SCTP implementations and are therefore not\n   tunable by the
      application.\n"
    title: 2.9.  Delayed Acknowledgments
  - contents:
    - "2.10.  Premature Failover\n   RADIUS failover implementations are typically
      based on the concept of\n   primary and secondary servers, in which all traffic
      flows to the\n   primary server unless it is unavailable.  However, the failover\n
      \  algorithm was not specified in [RFC2865] or [RFC2866].  As a result,\n   RADIUS
      failover implementations vary in quality, with some failing\n   over prematurely,
      violating the law of \"conservation of packets\".\n   Where a Relay, Proxy or
      Store and Forward proxy is present, the AAA\n   client has no direct connection
      to a AAA server, and is unable to\n   estimate the end-to-end transport parameters.
      \ As a result, a AAA\n   client awaiting an application-layer response from
      the server has no\n   transport-based mechanism for determining an appropriate
      failover\n   timer.\n   For example, if the path between the AAA agent and server
      includes a\n   high delay link, or if the AAA server is very heavily loaded,
      it is\n   possible that the NAS will failover to another agent while packets\n
      \  are still in flight.  This violates the principle of \"conservation of\n
      \  packets\", since the AAA client will inject additional packets into\n   the
      network before having evidence that a previously sent packet has\n   left the
      network.  Such behavior can result in a worse situation on\n   an already congested
      link, resulting in congestive collapse\n   [Congest].\n"
    title: 2.10.  Premature Failover
  - contents:
    - "2.11.  Head of Line Blocking\n   Head of line blocking occurs during periods
      of packet loss where the\n   time between sends is shorter than the re-transmission
      timeout value\n   (RTO).  In such situations, packets back up in the send queue
      until\n   the lost packet can be successfully re-transmitted.  This can be an\n
      \  issue for SCTP when using ordered delivery over a single stream, and\n   for
      TCP.\n   Head of line blocking is typically an issue only on larger NASes.\n
      \  For example, a 48-port NAS with an average inter-packet spacing of 25\n   seconds
      is unlikely to have an RTO greater than this, unless severe\n   packet loss
      has been experienced.  However, a 2048-port NAS with an\n   average inter-packet
      spacing of 293 ms may experience head-of-line\n   blocking since the inter-packet
      spacing is less than the minimum RTO\n   value of 1 second [RFC2988].\n"
    title: 2.11.  Head of Line Blocking
  - contents:
    - "2.12.  Connection Load Balancing\n   In order to lessen queuing delays and
      address head of line blocking,\n   a AAA implementation may wish to load balance
      between connections to\n   multiple destinations.  While it is possible to employ
      dynamic load\n   balancing techniques, this level of sophistication may not
      be\n   required.  In many situations, adequate reliability and load\n   balancing
      can be achieved via static load balancing, where traffic is\n   distributed
      between destinations based on static \"weights\".\n"
    title: 2.12.  Connection Load Balancing
  title: 2.  Issues in AAA Transport Usage
- contents:
  - "3.  AAA Transport Profile\n   In order to address AAA transport issues, it is
    recommended that AAA\n   protocols make use of standards track as well as experimental\n
    \  techniques.  More details are provided in the sections that follow.\n"
  - contents:
    - "3.1.  Transport Mappings\n   AAA Servers MUST support TCP and SCTP.  AAA clients
      SHOULD support\n   SCTP, but MUST support TCP if SCTP is not available.  As
      support for\n   SCTP improves, it is possible that SCTP support will be required
      on\n   clients at some point in the future.  AAA agents inherit all the\n   obligations
      of Servers with respect to transport support.\n"
    title: 3.1.  Transport Mappings
  - contents:
    - "3.2.  Use of Nagle Algorithm\n   While AAA protocols typically operate in the
      application-driven\n   regime, there are circumstances in which they are network
      driven.\n   For example, where an NAS reboots, or where connectivity is restored\n
      \  between an NAS and a AAA agent, it is possible that multiple packets\n   will
      be available for sending.\n   As a result, there are circumstances where the
      transport-layer\n   batching provided by the Nagle Algorithm (12) is useful,
      and as a\n   result, AAA implementations running over TCP MUST enable the Nagle\n
      \  algorithm, [RFC896].  The Nagle algorithm is not used with SCTP.\n"
    title: 3.2.  Use of Nagle Algorithm
  - contents:
    - "3.3.  Multiple Connections\n   AAA protocols SHOULD use only a single persistent
      connection between\n   a AAA client and a AAA agent or server.  They SHOULD
      provide for\n   pipelining of requests, so that more than one request can be
      in\n   progress at a time.  In order to minimize use of inactive connections\n
      \  in roaming situations, a AAA client or agent MAY bring down a\n   connection
      to a AAA agent or server if the connection has been\n   unutilized (discounting
      the watchdog) for a certain period of time,\n   which MUST NOT be less than
      BRINGDOWN_INTERVAL (5 minutes).\n   While a AAA client/agent SHOULD only use
      a single persistent\n   connection to a given AAA agent or server, it MAY have
      connections to\n   multiple AAA agents or servers.  A AAA client/agent connected
      to\n   multiple agents/servers can treat them as primary/secondary or\n   balance
      load between them.\n"
    title: 3.3.  Multiple Connections
  - contents:
    - "3.4.  Application Layer Watchdog\n   In order to enable AAA implementations
      to more quickly detect\n   transport and application-layer failures, AAA protocols
      MUST support\n   an application layer watchdog message.\n   The application
      layer watchdog message enables failover from a peer\n   that has failed, either
      because it is unreachable or because its\n   applications functions have failed.
      \ This is distinct from the\n   purpose of the SCTP heartbeat, which is to enable
      failover between\n   interfaces.  The SCTP heartbeat may enable a failover to
      another path\n   to reach the same server, but does not address the situation
      where\n   the server system or the application service has failed.  Therefore\n
      \  both mechanisms MAY be used together.\n   The watchdog is used in order to
      enable a AAA client or agent to\n   determine when to resend on another connection.
      \ It operates on all\n   open connections and is used to suspend and eventually
      close\n   connections that are experiencing difficulties.  The watchdog is also\n
      \  used to re-open and validate connections that have returned to\n   health.
      \ The watchdog may be utilized either within primary/secondary\n   or load balancing
      configurations.  However, it is not intended as a\n   cluster heartbeat mechanism.\n
      \  The application layer watchdog is designed to detect failures of the\n   immediate
      peer, and not to be affected by failures of downstream\n   proxies or servers.
      \ This prevents instability in downstream AAA\n   components from propagating
      upstream.  While the receipt of any AAA\n   Response from a peer is taken as
      evidence that the peer is up, lack\n   of a Response is insufficient to conclude
      that the peer is down.\n   Since the lack of Response may be the result of problems
      with a\n   downstream proxy or server, only after failure to respond to the\n
      \  watchdog message can it be determined that the peer is down.\n   Since the
      watchdog algorithm takes any AAA Response into account in\n   determining peer
      liveness, decreases in the watchdog timer interval\n   do not significantly
      increase the level of watchdog traffic on\n   heavily loaded networks.  This
      is because watchdog messages do not\n   need to be sent where other AAA Response
      traffic serves as a constant\n   reminder of peer liveness.  Watchdog traffic
      only increases when AAA\n   traffic is light, and therefore a AAA Response \"signal\"
      is not\n   present.  Nevertheless, decreasing the timer interval TWINIT does\n
      \  increase the probability of false failover significantly, and so this\n   decision
      should be made with care.\n"
    - contents:
      - "3.4.1.  Algorithm Overview\n   The watchdog behavior is controlled by an
        algorithm defined in this\n   section.  This algorithm is appropriate for
        use either within\n   primary/secondary or load balancing configurations.
        \ Implementations\n   SHOULD implement this algorithm, which operates as follows:\n
        \  [1] Watchdog behavior is controlled by a single timer (Tw).  The\n       initial
        value of Tw, prior to jittering is Twinit.  The default\n       value of Twinit
        is 30 seconds.  This value was selected because\n       it minimizes the probability
        that failover will be initiated due\n       to a routing flap, as noted in
        [Paxson].\n       While Twinit MAY be set as low as 6 seconds (not including\n
        \      jitter), it MUST NOT be set lower than this.  Note that setting\n       such
        a low value for Twinit is likely to result in an increased\n       probability
        of duplicates, as well as an increase in spurious\n       failover and failback
        attempts.\n       In order to avoid synchronization behaviors that can occur
        with\n       fixed timers among distributed systems, each time the watchdog\n
        \      interval is calculated with a jitter by using the Twinit value\n       and
        randomly adding a value drawn between -2 and 2 seconds.\n       Alternative
        calculations to create jitter MAY be used.  These\n       MUST be pseudo-random,
        generated by a PRNG seeded as per\n       [RFC1750].\n   [2] When any AAA
        message is received, Tw is reset.  This need not be\n       a response to
        a watchdog request.  Receiving a watchdog response\n       from a peer constitutes
        activity, and Tw should be reset.  If the\n       watchdog timer expires and
        no watchdog response is pending, then\n       a watchdog message is sent.
        \ On sending a watchdog request, Tw is\n       reset.\n       Watchdog packets
        are not retransmitted by the AAA protocol, since\n       AAA protocols run
        over reliable transports that will handle all\n       retransmissions internally.
        \ As a result, a watchdog request is\n       only sent when there is no watchdog
        response pending.\n   [3] If the watchdog timer expires and a watchdog response
        is pending,\n       then failover is initiated.  In order for a AAA client
        or agent\n       to perform failover procedures, it is necessary to maintain
        a\n       pending message queue for a given peer.  When an answer message\n
        \      is received, the corresponding request is removed from the queue.\n
        \      The Hop-by-Hop Identifier field MAY be used to match the answer\n       with
        the queued request.\n       When failover is initiated, all messages in the
        queue are sent to\n       an alternate agent, if available.  Multiple identical
        requests or\n       answers may be received as a result of a failover.  The\n
        \      combination of an end-to-end identifier and the origin host MUST\n
        \      be used to identify duplicate messages.\n       Note that where traffic
        is heavy, the application layer watchdog\n       can take as long as 2Tw to
        determine that a peer has gone down.\n       For peers receiving a high volume
        of AAA Requests, AAA Responses\n       will continually reset the timer, so
        that after a failure it will\n       take Tw for the lack of traffic to be
        noticed, and for the\n       watchdog message to be sent.  Another Tw will
        elapse before\n       failover is initiated.\n       On a lightly loaded network
        without much AAA Response traffic,\n       the watchdog timer will typically
        expire without being reset, so\n       that a watchdog response will be outstanding
        and failover will be\n       initiated after only a single timer interval
        has expired.\n   [4] The client MUST NOT close the primary connection until
        the\n       primary's watchdog timer has expired at least twice without a\n
        \      response (note that the watchdog is not sent a second time,\n       however).
        \ Once this has occurred, the client SHOULD cause a\n       transport reset
        or close to be done on the connection.\n       Once the primary connection
        has failed, subsequent requests are\n       sent to the alternate server until
        the watchdog timer on the\n       primary connection is reset.\n       Suspension
        of the primary connection prevents flapping between\n       primary and alternate
        connections, and ensures that failover\n       behavior remains consistent.
        \ The application may not receive a\n       response to the watchdog request
        message due to a connectivity\n       problem, in which case a transport layer
        ACK will not have been\n       received, or the lack of response may be due
        to an application\n       problem.  Without transport layer visibility, the
        application is\n       unable to tell the difference, and must behave conservatively.\n
        \      In situations where no transport layer ACK is received on the\n       primary
        connection after multiple re-transmissions, the RTO will\n       be exponentially
        backed off as described in [RFC2988].  Due to\n       Karn's algorithm as
        implemented in SCTP and TCP, the RTO\n       estimator will not be reset until
        another ACK is received in\n       response to a non-re-transmitted request.
        \ Thus, in cases where\n       the problem occurs at the transport layer,
        after the client fails\n       over to the alternate server, the RTO of the
        primary will remain\n       at a high value unless an ACK is received on the
        primary\n       connection.\n       In the case where the problem occurs at
        the transport layer,\n       subsequent requests sent on the primary connection
        will not\n       receive the same service as was originally provided.  For\n
        \      example, instead of failover occurring after 3 retransmissions,\n       failover
        might occur without even a single retransmission if RTO\n       has been sufficiently
        backed off.  Of course, if the lack of a\n       watchdog response was due
        to an application layer problem, then\n       RTO will not have been backed
        off.  However, without transport\n       layer visibility, there is no way
        for the application to know\n       this.\n       Suspending use of the primary
        connection until a response to a\n       watchdog message is received guarantees
        that the RTO timer will\n       have been reset before the primary connection
        is reused.  If no\n       response is received after the second watchdog timer
        expiration,\n       then the primary connection is closed and the suspension
        becomes\n       permanent.\n   [5] While the connection is in the closed state,
        the AAA client MUST\n       NOT attempt to send further watchdog messages
        on the connection.\n       However, after the connection is closed, the AAA
        client continues\n       to periodically attempt to reopen the connection.\n
        \      The AAA client SHOULD wait for the transport layer to report\n       connection
        failure before attempting again, but MAY choose to\n       bound this wait
        time by the watchdog interval, Tw.  If the\n       connection is successfully
        opened, then the watchdog message is\n       sent.  Once three watchdog messages
        have been sent and responded\n       to, the connection is returned to service,
        and transactions are\n       once again sent over it.  Connection validation
        via receipt of\n       multiple watchdogs is not required when a connection
        is initially\n       brought up -- in this case, the connection can immediately
        be put\n       into service.\n   [6] When using SCTP as a transport, it is
        not necessary to disable\n       SCTP's transport-layer heartbeats.  However,
        if AAA\n       implementations have access to SCTP's heartbeat parameters,
        they\n       MAY chose to ensure that SCTP's heartbeat interval is longer
        than\n       the AAA watchdog interval, Tw.  This will ensure that alternate\n
        \      paths are still probed by SCTP, while the primary path has a\n       minimum
        of heartbeat redundancy.\n"
      title: 3.4.1.  Algorithm Overview
    - contents:
      - "3.4.2.  Primary/Secondary Failover Support\n   The watchdog timer MAY be
        integrated with primary/secondary style\n   failover so as to provide improved
        reliability and basic load\n   balancing.  In order to balance load among
        multiple AAA servers, each\n   AAA server is designated the primary for a
        portion of the clients,\n   and designated as secondaries of varying priority
        for the remainder.\n   In this way, load can be balanced among the AAA servers.\n
        \  Within primary/secondary configurations, the watchdog timer operates\n
        \  as follows:\n   [1] Assume that each client or agent is initially configured
        with a\n       single primary agent or server, and one or more secondary\n
        \      connections.\n   [2] The watchdog mechanism is used to suspend and
        eventually close\n       primary connections that are experiencing difficulties.
        \ It is\n       also used to re-open and validate connections that have returned\n
        \      to health.\n   [3] Once a secondary is promoted to primary status,
        either on a\n       temporary or permanent basis, the next server on the list
        of\n       secondaries is promoted to fill the open secondary slot.\n   [4]
        The client or agent periodically attempts to re-open closed\n       connections,
        so that it is possible that a previously closed\n       connection can be
        returned to service and become eligible for use\n       again.  Implementations
        will typically retain a limit on the\n       number of connections open at
        a time, so that once a previously\n       closed connection is brought online
        again, the lowest priority\n       secondary connection will be closed.  In
        order to prevent\n       periodic closing and re-opening of secondary connections,
        it is\n       recommended that functioning connections remain open for a\n
        \      minimum of 5 minutes.\n   [5] In order to enable diagnosis of failover
        behavior, it is\n       recommended that a table of failover events be kept
        within the\n       MIB.  These failover events SHOULD include appropriate\n
        \      transaction identifiers so that client and server data can be\n       compared,
        providing insight into the cause of the problem\n       (transport or application
        layer).\n"
      title: 3.4.2.  Primary/Secondary Failover Support
    - contents:
      - "3.4.3.  Connection Load Balancing\n   Primary/secondary failover is capable
        of providing improved\n   resilience and basic load balancing.  However, it
        does not address\n   TCP head of line blocking, since only a single connection
        is in use\n   at a time.\n   A AAA client or agent maintaining connections
        to multiple agents or\n   servers MAY load balance between them.  Establishing
        connections to\n   multiple agents or servers reduces, but does not eliminate,
        head of\n   line blocking issues experienced on TCP connections.  This issue
        does\n   not exist with SCTP connections utilizing multiple streams.\n   In
        connection load balancing configurations, the application watchdog\n   operates
        as follows:\n   [1] Assume that each client or agent is initially configured
        with\n       connections to multiple AAA agents or servers, with one\n       connection
        between a given client/agent and an agent/server.\n   [2] In static load balancing,
        transactions are apportioned among the\n       connections based on the total
        number of connections and a\n       \"weight\" assigned to each connection.
        \ Pearson's hash [RFC3074]\n       applied to the NAI [RFC2486] can be used
        to determine which\n       connection will handle a given transaction.  Hashing
        on the NAI\n       provides highly granular load balancing, while ensuring
        that all\n       traffic for a given conversation will be sent to the same
        agent\n       or server.  In dynamic load balancing, the value of the \"weight\"\n
        \      can vary based on conditions such as AAA server load.  Such\n       techniques,
        while sophisticated, are beyond the scope of this\n       document.\n   [3]
        Transactions are distributed to connections based on the total\n       number
        of available connections and their weights.  A change in\n       the number
        of available connections forces recomputation of the\n       hash table.  In
        order not to cause conversations in progress to\n       be switched to new
        destinations, on recomputation, a transitional\n       period is required
        in which both old and new hash tables are\n       needed in order to permit
        aging out of conversations in progress.\n       Note that this requires a
        way to easily determine whether a\n       Request represents a new conversation
        or the continuation of an\n       existing conversation.  As a result, removing
        and adding of\n       connections is an expensive operation, and it is recommended
        that\n       the hash table only be recomputed once a connection is closed
        or\n       returned to service.\n       Suspended connections, although they
        are not used, do not force\n       hash table reconfiguration until they are
        closed.  Similarly,\n       re-opened connections not accumulating sufficient
        watchdog\n       responses do not force a reconfiguration until they are returned\n
        \      to service.\n       While a connection is suspended, transactions that
        were to have\n       been assigned to it are instead assigned to the next
        available\n       server.  While this results in a momentary imbalance, it
        is felt\n       that this is a relatively small price to pay in order to reduce\n
        \      hash table thrashing.\n   [4] In order to enable diagnosis of load
        balancing behavior, it is\n       recommended that in addition to a table
        of failover events, a\n       table of statistics be kept on each client,
        indexed by a AAA\n       server.  That way, the effectiveness of the load
        balancing\n       algorithm can be evaluated.\n"
      title: 3.4.3.  Connection Load Balancing
    title: 3.4.  Application Layer Watchdog
  - contents:
    - "3.5.  Duplicate Detection\n   Multiple facilities are required to enable duplicate
      detection.\n   These include session identifiers as well as hop-by-hop and end-to-\n
      \  end message identifiers.  Hop-by-hop identifiers whose value may\n   change
      at each hop are not sufficient, since a AAA server may receive\n   the same
      message from multiple agents.  For example, a AAA client can\n   send a request
      to Agent1, then failover and resend the request to\n   Agent2; both agents forward
      the request to the home AAA server, with\n   different hop-by-hop identifiers.
      \ A Session Identifier is\n   insufficient as it does not distinguish different
      messages for the\n   the same session.\n   Proper treatment of the end-to-end
      message identifier ensures that\n   AAA operations are idempotent.  For example,
      without an end-to-end\n   identifier, a AAA server keeping track of simultaneous
      logins might\n   send an Accept in response to an initial Request, and then
      a Reject\n   in response to a duplicate Request (where the user was allowed
      only\n   one simultaneous login).  Depending on which Response arrived first,\n
      \  the user might be allowed access or not.\n   However, if the server were
      to store the end-to-end message\n   identifier along with the simultaneous login
      information, then the\n   duplicate Request (which utilizes the same end-to-end
      message\n   identifier) could be identified and the correct response could be\n
      \  returned.\n"
    title: 3.5.  Duplicate Detection
  - contents:
    - "3.6.  Invalidation of Transport Parameter Estimates\n   In order to address
      invalidation of transport parameter estimates,\n   AAA protocol implementations
      MAY utilize Congestion Window Validation\n   [RFC2861] and RTO validation when
      using TCP.  This specification also\n   recommends a procedure for RTO validation.\n
      \  [RFC2581] and [RFC2861] both recommend that a connection go into\n   slow-start
      after a period where no traffic has been sent within the\n   RTO interval.  [RFC2861]
      recommends only increasing the congestion\n   window if it was full when the
      ACK arrived.  The congestion window is\n   reduced by half once every RTO interval
      if no traffic is received.\n   When Congestion Window Validation is used, the
      congestion window will\n   not build during application-driven periods, and
      instead will be\n   decayed.  As a result, AAA applications operating within
      the\n   application-driven regime will typically run with a congestion window\n
      \  equal to the initial window much of the time, operating in \"perpetual\n
      \  slowstart\".\n   During periods in which AAA behavior is application-driven
      this will\n   have no effect.  Since the time between packets will be larger
      than\n   RTT, AAA will operate with an effective congestion window equal to\n
      \  the initial window.  However, during network-driven periods, the\n   effect
      will be to space out sending of AAA packets.  Thus instead of\n   being able
      to send a large burst of packets into the network, a\n   client will need to
      wait several RTTs as the congestion window builds\n   during slow-start.\n   For
      example, a client operating over TCP with an initial window of 2,\n   with 35
      AAA requests to send would take approximately 6 RTTs to send\n   them, as the
      congestion window builds during slow start: 2, 3, 3, 6,\n   9, 12.  After the
      backlog is cleared, the implementation will once\n   again be application-driven
      and the congestion window size will\n   decay.  If the client were using SCTP,
      the number of RTTs needed to\n   transmit all requests would usually be less,
      and would depend on the\n   size of the requests, since SCTP tracks the progress
      for the opening\n   of the congestion window by bytes, not segments.\n   Note
      that [RFC2861] and [RFC2988] do not address the issue of RTO\n   validation.
      \ This is also a problem, particularly when the Congestion\n   Manager [RFC3124]
      is implemented.  During periods of high packet\n   loss, the RTO may be repeatedly
      increased via exponential back-off,\n   and may attain a high value.  Due to
      lack of timely feedback on RTT\n   and RTO during application-driven periods,
      the high RTO estimate may\n   persist long after the conditions that generated
      it have dissipated.\n   RTO validation MAY be used to address this issue for
      TCP, via the\n   following procedure:\n      After the congestion window is
      decayed according to [RFC2861],\n      reset the estimated RTO to 3 seconds.
      \ After the next packet comes\n      in, re-calculate RTTavg, RTTdev, and RTO
      according to the method\n      described in [RFC2581].\n   To address this issue
      for SCTP, AAA implementations SHOULD use SCTP\n   heartbeats.  [RFC2960] states
      that heartbeats should be enabled by\n   default, with an interval of 30 seconds.
      \ If this interval proves to\n   be too long to resolve this issue, AAA implementations
      MAY reduce the\n   heartbeat interval.\n"
    title: 3.6.  Invalidation of Transport Parameter Estimates
  - contents:
    - "3.7.  Inability to Use Fast Re-Transmit\n   When Congestion Window Validation
      [RFC2861] is used, AAA\n   implementations will operate with a congestion window
      equal to the\n   initial window much of the time.  As a result, the window size
      will\n   often not be large enough to enable use of fast re-transmit for TCP.\n
      \  In addition, since AAA traffic is two-way, ACKs carrying data will\n   not
      count towards triggering fast re-transmit.  SCTP is less likely\n   to encounter
      this issue, so the measures described below apply to\n   TCP.\n   To address
      this issue, AAA implementations SHOULD support selective\n   acknowledgement
      as described in [RFC2018] and [RFC2883].  AAA\n   implementations SHOULD also
      implement Limited Transmit for TCP, as\n   described in [RFC3042].  Rather than
      reducing the number of duplicate\n   ACKs required for triggering fast recovery,
      which would increase the\n   number of inappropriate re-transmissions, Limited
      Transmit enables\n   the window size be increased, thus enabling the sending
      of additional\n   packets which in turn may trigger fast re-transmit without
      a change\n   to the algorithm.\n   However, if congestion window validation
      [RFC2861] is implemented,\n   this proposal will only have an effect in situations
      where the time\n   between packets is less than the estimated retransmission
      timeout\n   (RTO).  If the time between packets is greater than RTO, additional\n
      \  packets will typically not be available for sending so as to take\n   advantage
      of the increased window size.  As a result, AAA protocols\n   will typically
      operate with the lowest possible congestion window\n   size, resulting in a
      re-transmission timeout for every lost packet.\n"
    title: 3.7.  Inability to Use Fast Re-Transmit
  - contents:
    - "3.8.  Head of Line Blocking\n   TCP inherently does not provide a solution
      to the head-of-line\n   blocking problem, although its effects can be lessened
      by\n   implementation of Limited Transmit [RFC3042], and connection load\n   balancing.\n"
    - contents:
      - "3.8.1.  Using SCTP Streams to Prevent Head of Line Blocking\n   Each AAA
        node SHOULD distribute its messages evenly across the range\n   of SCTP streams
        that it and its peer have agreed upon.  (A lost\n   message in one stream
        will not cause any other streams to block.)  A\n   trivial and effective implementation
        of this simply increments a\n   counter for the stream ID to send on.  When
        the counter reaches the\n   maximum number of streams for the association,
        it resets to 0.\n   AAA peers MUST be able to accept messages on any stream.
        \ Note that\n   streams are used *solely* to prevent head-of-the-line blocking.
        \ All\n   identifying information is carried within the Diameter payload.\n
        \  Messages distributed across multiple streams may not be received in\n   the
        order they are sent.\n   SCTP peers can allocate up to 65535 streams for an
        association.  The\n   cost for idle streams may or may not be zero, depending
        on the\n   implementation, and the cost for non-idle streams is always greater\n
        \  than 0.  So administrators may wish to limit the number of possible\n   streams
        on their diameter nodes according to the resources (i.e.\n   memory, CPU power,
        etc.) of a particular node.\n   On a Diameter client, the number of streams
        may be determined by the\n   maximum number of peak users on the NAS.  If
        a stream is available\n   per user, then this should be sufficient to prevent
        head-of-line\n   blocking.  On a Diameter proxy, the number of streams may
        be\n   determined by the maximum number of peak sessions in progress from\n
        \  that proxy to each downstream AAA server.\n   Stream IDs do not need to
        be preserved by relay agents.  This\n   simplifies implementation, as agents
        can easily handle forwarding\n   between two associations with different numbers
        of streams.  For\n   example, consider the following case, where a relay server
        DRL\n   forwards messages between a NAS and a home server, HMS.  The NAS and\n
        \  DRL have agreed upon 1000 streams for their association, and DRL and\n
        \  HMS have agreed upon 2000 streams for their association.  The\n   following
        figure shows the message flow from NAS to HMS via DRL, and\n   the stream
        ID assignments for each message:\n   +------+                   +------+                   +------+\n
        \  |      |                   |      |                   |      |\n   | NAS
        \ |    --------->     | DRL  |     --------->    | HMS  |\n   |      |                   |
        \     |                   |      |\n   +------+   1000 streams    +------+
        \   2000 streams   +------+\n              msg 1: str id 0             msg
        1: str id 0\n              msg 2: str id 1             msg 2: str id 1\n              ...\n
        \             msg 1000: str id 999        msg 1000: str id 999\n              msg
        1001: str id 0          msg 1001: str id 1000\n   DRL can forward messages
        1 through 1000 to HMS using the same stream\n   ID that NAS used to send to
        DRL.  However, since the NAS / DRL\n   association has only 1000 streams,
        NAS wraps around to stream ID 0\n   when sending message 1001.  The DRL /
        HMS association, on the other\n   hand, has 2000 streams, so DRL can reassign
        message 1001 to stream ID\n   1000 when forwarding it on to HMS.\n   This
        distribution scheme acts like a hash table.  It is possible, yet\n   unlikely,
        that two messages will end up in the same stream, and even\n   less likely
        that there will be message loss resulting in blocking\n   when this happens.
        \ If it does turn out to be a problem, local\n   administrators can increase
        the number of streams on their nodes to\n   improve performance.\n"
      title: 3.8.1.  Using SCTP Streams to Prevent Head of Line Blocking
    title: 3.8.  Head of Line Blocking
  - contents:
    - "3.9.  Congestion Avoidance\n   In order to improve upon default timer estimates,
      AAA implementations\n   MAY implement the Congestion Manager (CM) [RFC3124].
      \ CM is an end-\n   system module that:\n       (i) Enables an ensemble of multiple
      concurrent streams from a\n           sender destined to the same receiver and
      sharing the same\n           congestion properties to perform proper congestion
      avoidance\n           and control, and\n      (ii) Allows applications to easily
      adapt to network congestion.\n   The CM helps integrate congestion management
      across all applications\n   and transport protocols.  The CM maintains congestion
      parameters\n   (available aggregate and per-stream bandwidth, per-receiver round-\n
      \  trip times, etc.) and exports an API that enables applications to\n   learn
      about network characteristics, pass information to the CM,\n   share congestion
      information with each other, and schedule data\n   transmissions.\n   The CM
      enables the AAA application to access transport parameters\n   (RTTavg, RTTdev)
      via callbacks.  RTO estimates are currently not\n   available via the callback
      interface, though they probably should be.\n   Where available, transport parameters
      SHOULD be used to improve upon\n   default timer values.\n"
    title: 3.9.  Congestion Avoidance
  - contents:
    - "3.10.  Premature Failover\n   Premature failover is prevented by the watchdog
      functionality\n   described above.  If the next hop does not return a reply,
      the AAA\n   client will send a watchdog message to it to verify liveness.  If
      a\n   watchdog reply is received, then the AAA client will know that the\n   next
      hop server is functioning at the application layer.  As a\n   result, it is
      only necessary to provide terminal error messages, such\n   as the following:\n
      \     \"Busy\": agent/Server too busy to handle additional requests, NAS\n      should
      failover all requests to another agent/server.\n      \"Can't Locate\": agent
      can't locate the AAA server for the\n      indicated realm; NAS should failover
      that request to another\n      proxy.\n      \"Can't Forward\": agent has tried
      both primary and secondary AAA\n      servers with no response; NAS should failover
      the request to\n      another agent.\n   Note that these messages differ in
      their scope.  The \"Busy\" message\n   tells the NAS that the agent/server is
      too busy for ANY request.  The\n   \"Can't Locate\" and \"Can't Forward\" messages
      indicate that the\n   ultimate destination cannot be reached or isn't responding,
      implying\n   per-request failover.\n"
    title: 3.10.  Premature Failover
  title: 3.  AAA Transport Profile
- contents:
  - "4.  Security Considerations\n   Since AAA clients, agents and servers serve as
    network access\n   gatekeepers, they are tempting targets for attackers.  General\n
    \  security considerations concerning TCP congestion control are\n   discussed
    in [RFC2581].  However, there are some additional\n   considerations that apply
    to this specification.\n   By enabling failover between AAA agents, this specification
    improves\n   the resilience of AAA applications.  However, it may also open\n
    \  avenues for denial of service attacks.\n   The failover algorithm is driven
    by lack of response to AAA requests\n   and watchdog packets.  On a lightly loaded
    network where AAA\n   responses would not be received prior to expiration of the
    watchdog\n   timer, an attacker can swamp the network, causing watchdog packets
    to\n   be dropped.  This will cause the AAA client to switch to another AAA\n
    \  agent, where the attack can be repeated.  By causing the AAA client\n   to
    cycle between AAA agents, service can be denied to users desiring\n   network
    access.\n   Where TLS [RFC2246] is being used to provide AAA security, there will\n
    \  be a vulnerability to spoofed reset packets, as well as other\n   transport
    layer denial of service attacks (e.g. SYN flooding).  Since\n   SCTP offers improved
    denial of service resilience compared with TCP,\n   where AAA applications run
    over SCTP, this can be mitigated to some\n   extent.\n   Where IPsec [RFC2401]
    is used to provide security, it is important\n   that IPsec policy require IPsec
    on incoming packets.  In order to\n   enable a AAA client to determine what security
    mechanisms are in use\n   on an agent or server without prior knowledge, it may
    be tempting to\n   initiate a connection in the clear, and then to have the AAA
    agent\n   respond with IKE [RFC2409].  While this approach minimizes required\n
    \  client configuration, it increases the vulnerability to denial of\n   service
    attack, since a connection request can now not only tie up\n   transport resources,
    but also resources within the IKE\n   implementation.\n"
  title: 4.  Security Considerations
- contents:
  - "5.  IANA Considerations\n   This document does not create any new number spaces
    for IANA\n   administration.\n"
  - 'References

    '
  - contents:
    - "6.1.  Normative References\n   [RFC793]  Postel, J., \"Transmission Control
      Protocol\", STD 7, RFC\n             793, September 1981.\n   [RFC896]  Nagle,
      J., \"Congestion Control in IP/TCP internetworks\",\n             RFC 896, January
      1984.\n   [RFC1750] Eastlake, D., Crocker, S. and J. Schiller, \"Randomness\n
      \            Recommendations for Security\", RFC 1750, December 1994.\n   [RFC2018]
      Mathis, M., Mahdavi, J., Floyd, S. and A. Romanow, \"TCP\n             Selective
      Acknowledgment Options\", RFC 2018, October 1996.\n   [RFC2119] Bradner, S.,
      \"Key words for use in RFCs to Indicate\n             Requirement Levels\",
      BCP 14, RFC 2119, March 1997.\n   [RFC2486] Aboba, B. and M. Beadles, \"The
      Network Access Identifier\",\n             RFC 2486, January 1999.\n   [RFC2581]
      Allman, M., Paxson, V. and W. Stevens, \"TCP Congestion\n             Control\",
      RFC 2581, April 1999.\n   [RFC2883] Floyd, S., Mahdavi, J., Mathis, M., Podolsky,
      M. and A.\n             Romanow, \"An Extension to the Selective Acknowledgment\n
      \            (SACK) Option for TCP\", RFC 2883, July 2000.\n   [RFC2960] Stewart,
      R., Xie, Q., Morneault, K., Sharp, C.,\n             Schwarzbauer, H., Taylor,
      T., Rytina, I., Kalla, M., Zhang,\n             L. and V. Paxson, \"Stream Control
      Transmission Protocol\",\n             RFC 2960, October 2000.\n   [RFC2988]
      Paxson, V. and M. Allman, \"Computing TCP's Retransmission\n             Timer\",
      RFC 2988, November 2000.\n   [RFC3042] Allman, M., Balakrishnan H. and S. Floyd,
      \"Enhancing TCP's\n             Loss Recovery Using Limited Transmit\", RFC
      3042, January\n             2001.\n   [RFC3074] Volz, B., Gonczi, S., Lemon,
      T. and R. Stevens, \"DHC Load\n             Balancing Algorithm\", RFC 3074,
      February 2001.\n   [RFC3124] Balakrishnan, H. and S. Seshan, \"The Congestion
      Manager\",\n             RFC 3124, June 2001.\n"
    title: 6.1.  Normative References
  - contents:
    - "6.2.  Informative References\n   [RFC2246] Dierks, T. and C. Allen, \"The TLS
      Protocol Version 1.0\",\n             RFC 2246, January 1999.\n   [RFC2401]
      Atkinson, R. and S. Kent, \"Security Architecture for the\n             Internet
      Protocol\", RFC 2401, November 1998.\n   [RFC2409] Harkins, D. and D. Carrel,
      \"The Internet Key Exchange\n             (IKE)\", RFC 2409, November 1998.\n
      \  [RFC2607] Aboba, B. and J. Vollbrecht, \"Proxy Chaining and Policy\n             Implementation
      in Roaming\", RFC 2607, June 1999.\n   [RFC2861] Handley, M., Padhye, J. and
      S. Floyd, \"TCP Congestion\n             Window Validation\", RFC 2861, June
      2000.\n   [RFC2865] Rigney, C., Willens, S., Rubens, A. and W. Simpson, \"Remote\n
      \            Authentication Dial In User Service (RADIUS)\", RFC 2865,\n             June
      2000.\n   [RFC2866] Rigney, C., \"RADIUS Accounting\", RFC 2866, June 2000.\n
      \  [RFC2914] Floyd, S., \"Congestion Control Principles\", BCP 41, RFC\n             2914,
      September 2000.\n   [RFC2975] Aboba, B., Arkko, J. and D. Harrington, \"Introduction
      to\n             Accounting Management\", RFC 2975, June 2000.\n   [RFC3390]
      Allman, M., Floyd, S. and C. Partridge, \"Increasing TCP's\n             Initial
      Window\", RFC 3390, October 2002.\n   [Congest] Jacobson, V., \"Congestion Avoidance
      and Control\", Computer\n             Communication Review, vol. 18, no. 4,
      pp. 314-329, Aug.\n             1988.  ftp://ftp.ee.lbl.gov/papers/congavoid.ps.Z\n
      \  [Paxson]  Paxson, V., \"Measurement and Analysis of End-to-End\n             Internet
      Dynamics\", Ph.D. Thesis, Computer Science\n             Division, University
      of California, Berkeley, April 1997.\n"
    title: 6.2.  Informative References
  title: 5.  IANA Considerations
- contents:
  - "Appendix A - Detailed Watchdog Algorithm\n   In this Appendix, the memory control
    structure that contains all\n   information regarding a specific peer is referred
    to as a Peer\n   Control Block, or PCB.  The PCB contains the following fields:\n
    \  Status:\n     OKAY:       The connection is up\n     SUSPECT:    Failover has
    been initiated on the connection.\n     DOWN:       Connection has been closed.\n
    \    REOPEN:     Attempting to reopen a closed connection\n     INITIAL:    The
    initial state of the pcb when it is first created.\n                 The pcb has
    never been opened.\n   Variables:\n     Pending:    Set to TRUE if there is an
    outstanding unanswered\n                 watchdog request\n     Tw:         Watchdog
    timer value\n     NumDWA:     Number of DWAs received during REOPEN\n   Tw is
    the watchdog timer, measured in seconds.  Every  second, Tw  is\n   decremented.
    \ When it reaches 0, the OnTimerElapsed event (see below)\n   is invoked.  Pseudo-code
    for the algorithm is included on the\n   following pages.\n   SetWatchdog()\n
    \  {\n   /*\n    SetWatchdog() is called whenever it is necessary\n    to reset
    the watchdog timer Tw.  The value of the\n    watchdog timer is calculated based
    on the default\n    initial value TWINIT and a jitter ranging from\n    -2 to
    2 seconds.  The default for TWINIT is 30 seconds,\n    and MUST NOT be set lower
    than 6 seconds.\n   */\n       Tw=TWINIT -2.0 + 4.0 * random() ;\n       SetTimer(Tw)
    ;\n       return ;\n   }\n   /*\n    OnReceive() is called whenever a message\n
    \   is received from the peer.  This message MAY\n    be a request or an answer,
    and can include\n    DWR and DWA messages.  Pending is assumed to\n    be a global
    variable.\n   */\n   OnReceive(pcb, msgType)\n   {\n      if (msgType == DWA)
    {\n           Pending = FALSE;\n           }\n      switch (pcb->Status){\n      case
    OKAY:\n           SetWatchdog();\n           break;\n      case SUSPECT:\n           pcb->Status
    = OKAY;\n           Failback(pcb);\n           SetWatchdog();\n           break;\n
    \     case REOPEN:\n           if (msgType == DWA) {\n              NumDWA++;\n
    \             if (NumDWA == 3) {\n                 pcb->status = OKAY;\n                 Failback();\n
    \             }\n           } else {\n              Throwaway(received packet);\n
    \          }\n           break;\n      case INITIAL:\n      case DOWN:\n           Throwaway(received
    packet);\n           break;\n      default:\n           Error(\"Shouldn't be here!\");\n
    \          break;\n      }\n   }\n   /*\n   OnTimerElapsed() is called whenever
    Tw reaches zero (0).\n   */\n   OnTimerElapsed(pcb)\n   {\n       switch (pcb->status){\n
    \         case OKAY:\n             if (!Pending) {\n                SendWatchdog(pcb);\n
    \               SetWatchdog();\n                Pending = TRUE;\n                break;\n
    \            }\n             pcb->status = SUSPECT;\n             FailOver(pcb);\n
    \            SetWatchdog();\n             break ;\n          case SUSPECT:\n             pcb->status
    = DOWN;\n             CloseConnection(pcb);\n             SetWatchdog();\n             break;\n
    \         case INITIAL:\n          case DOWN:\n             AttemptOpen(pcb);\n
    \            SetWatchdog();\n             break;\n          case REOPEN:\n             if
    (!Pending) {\n                SendWatchdog(pbc);\n                SetWatchdog();\n
    \               Pending = TRUE;\n                break;\n             }\n             if
    (NumDWA < 0) {\n                pcb->status = DOWN;\n                CloseConnection(pcb);\n
    \            } else {\n                NumDWA = -1;\n             }\n             SetWatchdog();\n
    \            break;\n          default:\n             error(\"Shouldn't be here!);\n
    \            break;\n          }\n   }\n   /*\n   OnConnectionUp() is called whenever
    a connection comes up\n   */\n   OnConnectionUp(pcb)\n   {\n       switch (pcb->status){\n
    \         case INITIAL:\n             pcb->status = OKAY;\n             SetWatchdog();\n
    \            break;\n          case DOWN:\n             pcb->status = REOPEN;\n
    \            NumDWA = 0;\n             SendWatchdog(pcb);\n             SetWatchdog();\n
    \            Pending = TRUE;\n             break;\n          default:\n             error(\"Shouldn't
    be here!);\n             break;\n          }\n   }\n   /*\n   OnConnectionDown()
    is called whenever a connection goes down\n   */\n   OnConnectionDown(pcb)\n   {\n
    \      pcb->status = DOWN;\n       CloseConnection();\n       switch (pcb->status){\n
    \         case OKAY:\n             Failover(pcb);\n             SetWatchdog();\n
    \            break;\n          case SUSPECT:\n          case REOPEN:\n             SetWatchdog();\n
    \            break;\n          default:\n             error(\"Shouldn't be here!);\n
    \            break;\n          }\n   }\n   /*  Here is the state machine equivalent
    to the above code:\n   STATE         Event                Actions              New
    State\n   =====         ------               -------              ----------\n
    \  OKAY          Receive DWA          Pending = FALSE\n                                      SetWatchdog()
    \       OKAY\n   OKAY          Receive non-DWA      SetWatchdog()        OKAY\n
    \  SUSPECT       Receive DWA          Pending = FALSE\n                                      Failback()\n
    \                                     SetWatchdog()        OKAY\n   SUSPECT       Receive
    non-DWA      Failback()\n                                      SetWatchdog()        OKAY\n
    \  REOPEN        Receive DWA &        Pending = FALSE\n                 NumDWA
    == 2          NumDWA++\n                                      Failback()           OKAY\n
    \  REOPEN        Receive DWA &        Pending = FALSE\n                 NumDWA
    < 2           NumDWA++             REOPEN\n   STATE         Event                Actions
    \             New State\n   =====         ------               -------              ----------\n
    \  REOPEN        Receive non-DWA      Throwaway()          REOPEN\n   INITIAL
    \      Receive DWA          Pending = FALSE\n                                      Throwaway()
    \         INITIAL\n   INITIAL       Receive non-DWA      Throwaway()          INITIAL\n
    \  DOWN          Receive DWA          Pending = FALSE\n                                      Throwaway()
    \         DOWN\n   DOWN          Receive non-DWA      Throwaway()          DOWN\n
    \  OKAY          Timer expires &      SendWatchdog()\n                 !Pending
    \            SetWatchdog()\n                                      Pending = TRUE
    \      OKAY\n   OKAY          Timer expires &      Failover()\n                 Pending
    \             SetWatchdog()        SUSPECT\n   SUSPECT       Timer expires        CloseConnection()\n
    \                                     SetWatchdog()        DOWN\n   INITIAL       Timer
    expires        AttemptOpen()\n                                      SetWatchdog()
    \       INITIAL\n   DOWN          Timer expires        AttemptOpen()\n                                      SetWatchdog()
    \       DOWN\n   REOPEN        Timer expires &      SendWatchdog()\n                 !Pending
    \            SetWatchdog()\n                                      Pending = TRUE
    \      REOPEN\n   REOPEN        Timer expires &      CloseConnection()\n                 Pending
    &            SetWatchdog()\n                 NumDWA < 0                                DOWN\n
    \  REOPEN        Timer expires &      NumDWA = -1\n                 Pending &
    \           SetWatchdog()\n                 NumDWA >= 0                               REOPEN\n
    \  INITIAL       Connection up        SetWatchdog()        OKAY\n   DOWN          Connection
    up        NumDWA = 0\n                                      SendWatchdog()\n                                      SetWatchdog()\n
    \                                     Pending = TRUE       REOPEN\n   OKAY          Connection
    down      CloseConnection()\n                                      Failover()\n
    \                                     SetWatchdog()        DOWN\n   SUSPECT       Connection
    down      CloseConnection()\n                                      SetWatchdog()
    \       DOWN\n   REOPEN        Connection down      CloseConnection()\n                                      SetWatchdog()
    \       DOWN\n   */\n"
  title: Appendix A - Detailed Watchdog Algorithm
- contents:
  - "Appendix B - AAA Agents\n   As described in [RFC2865] and [RFC2607], AAA agents
    have become\n   popular in order to support services such as roaming and shared
    use\n   networks.  Such agents are used both for\n   authentication/authorization,
    as well as accounting [RFC2975].\n   AAA agents include:\n      Relays\n      Proxies\n
    \     Re-directs\n      Store and Forward proxies\n      Transport layer proxies\n
    \  The transport layer behavior of each of these agents is described\n   below.\n"
  - contents:
    - "B.1 Relays and Proxies\n   While the application-layer behavior of relays and
      proxies are\n   different, at the transport layer the behavior is similar.  In
      both\n   cases, two connections are established: one from the AAA client (NAS)\n
      \  to the relay/proxy, and another from the relay/proxy to the AAA\n   server.
      \ The relay/proxy does not respond to a client request until\n   it receives
      a response from the server.  Since the two connections\n   are de-coupled, the
      end-to-end conversation between the client and\n   server may not self clock.\n
      \  Since AAA transport is typically application-driven, there is\n   frequently
      not enough traffic to enable ACK piggybacking.  As a\n   result, the Nagle algorithm
      is rarely triggered, and delayed ACKs may\n   comprise nearly half the traffic.
      \ Thus AAA protocols running over\n   reliable transport will see packet traffic
      nearly double that\n   experienced with UDP transport.  Since ACK parameters
      (such as the\n   value of the delayed ACK timer) are typically fixed by the
      TCP\n   implementation and are not tunable by the application, there is\n   little
      that can be done about this.\n   A typical trace of a conversation between a
      NAS, proxy and server is\n   shown below:\n   Time            NAS           Relay/Proxy
      \          Server\n   ------          ---           -----------           ------\n
      \  0               Request\n                   ------->\n   OTTnp + Tpr                     Request\n
      \                                  ------->\n   OTTnp + TdA                     Delayed
      ACK\n                                   <-------\n   OTTnp + OTTps +                                 Reply/ACK\n
      \  Tpr + Tsr                                       <-------\n   OTTnp + OTTps
      +\n   Tpr + Tsr +                     Reply\n   OTTsp + TpR                     <-------\n
      \  OTTnp + OTTps +\n   Tpr + Tsr +                     Delayed ACK\n   OTTsp
      + TdA                     ------->\n   OTTnp + OTTps +\n   OTTsp + OTTpn +\n
      \  Tpr + Tsr +      Delayed ACK\n   TpR + TdA        ------->\n   Key\n   ---\n
      \  OTT   = One-way Trip Time\n   OTTnp = One-way trip time (NAS to Relay/Proxy)\n
      \  OTTpn = One-way trip time (Relay/Proxy to NAS)\n   OTTps = One-way trip time
      (Relay/Proxy to Server)\n   OTTsp = One-way trip time (Server to Relay/Proxy)\n
      \  TdA   = Delayed ACK timer\n   Tpr   = Relay/Proxy request processing time\n
      \  TpR   = Relay/Proxy reply processing time\n   Tsr   = Server request processing
      time\n   At time 0, the NAS sends a request to the relay/proxy.  Ignoring the\n
      \  serialization time, the request arrives at the relay/proxy at time\n   OTTnp,
      and the relay/proxy takes an additional Tpr in order to\n   forward the request
      toward the home server.  At time TdA after\n   receiving the request, the relay/proxy
      sends a delayed ACK.  The\n   delayed ACK is sent, rather than being piggybacked
      on the reply, as\n   long as TdA < OTTps + OTTsp + Tpr + Tsr + TpR.\n   Typically
      Tpr < TdA, so that the delayed ACK is sent after the\n   relay/proxy forwards
      the request toward the server, but before the\n   relay/proxy receives the reply
      from the server.  However, depending\n   on the TCP implementation on the relay/proxy
      and when the request is\n   received, it is also possible for the delayed ACK
      to be sent prior to\n   forwarding the request.\n   At time OTTnp + OTTps +
      Tpr, the server receives the request, and Tsr\n   later, it generates the reply.
      \ Where Tsr < TdA, the reply will\n   contain a piggybacked ACK.  However, depending
      on the server\n   responsiveness and TCP implementation, the ACK and reply may
      be sent\n   separately.  This can occur, for example, where a slow database
      or\n   storage system must be accessed prior to sending the reply.\n   At time
      OTTnp + OTTps + OTTsp + Tpr + Tsr the reply/ACK reaches the\n   relay/proxy,
      which then takes TpR additional time to forward the\n   reply to the NAS.  At
      TdA after receiving the reply, the relay/proxy\n   generates a delayed ACK.
      \ Typically TpR < TdA so that the delayed ACK\n   is sent to the server after
      the relay/proxy forwards the reply to the\n   NAS.  However, depending on the
      circumstances and the relay/proxy TCP\n   implementation, the delayed ACK may
      be sent first.\n   As with a delayed ACK sent in response to a request, which
      may be\n   piggybacked if the reply can be received quickly enough, piggybacking\n
      \  of the ACK sent in response to a reply from the server is only\n   possible
      if additional request traffic is available.  However, due to\n   the high inter-packet
      spacings in typical AAA scenarios, this is\n   unlikely unless the AAA protocol
      supports a reply ACK.\n   At time OTTnp + OTTps + OTTsp + OTTpn + Tpr + Tsr
      + TpR the NAS\n   receives the reply.  TdA later, a delayed ACK is generated.\n"
    title: B.1 Relays and Proxies
  - contents:
    - "B.2 Re-directs\n   Re-directs operate by referring a NAS to the AAA server,
      enabling the\n   NAS to talk to the AAA server directly.  Since a direct transport\n
      \  connection is established, the end-to-end connection will self-clock.\n   With
      re-directs, delayed ACKs are less frequent than with\n   application-layer proxies
      since the Re-direct and Server will\n   typically piggyback replies with ACKs.\n
      \  The sequence of events is as follows:\n   Time            NAS             Re-direct
      \      Server\n   ------          ---             ---------       ------\n   0
      \              Request\n                   ------->\n   OTTnp + Tpr                     Redirect/ACK\n
      \                                  <-------\n   OTTnp + Tpr +   Request\n   OTTpn
      + Tnr     ------->\n   OTTnp + OTTpn +\n   Tpr + Tsr +                                     Reply/ACK\n
      \  OTTns                                           <-------\n   OTTnp + OTTpn
      +\n   OTTns + OTTsn +\n   Tpr + Tsr +      Delayed ACK\n   TdA              ------->\n
      \  Key\n   ---\n   OTT   = One-way Trip Time\n   OTTnp = One-way trip time (NAS
      to Re-direct)\n   OTTpn = One-way trip time (Re-direct to NAS)\n   OTTns = One-way
      trip time (NAS to Server)\n   OTTsn = One-way trip time (Server to NAS)\n   TdA
      \  = Delayed ACK timer\n   Tpr   = Re-direct processing time\n   Tnr   = NAS
      re-direct processing time\n   Tsr   = Server request processing time\n"
    title: B.2 Re-directs
  - contents:
    - "B.3 Store and Forward Proxies\n   With a store and forward proxy, the proxy
      may send a reply to the NAS\n   prior to forwarding the request to the server.
      \ While store and\n   forward proxies are most frequently deployed for accounting\n
      \  [RFC2975], they also can be used to implement\n   authentication/authorization
      policy, as described in [RFC2607].\n   As noted in [RFC2975], store and forward
      proxies can have a negative\n   effect on accounting reliability.  By sending
      a reply to the NAS\n   without receiving one from the accounting server, store
      and forward\n   proxies fool the NAS into thinking that the accounting request
      had\n   been accepted by the accounting server when this is not the case.  As\n
      \  a result, the NAS can delete the accounting packet from non-volatile\n   storage
      before it has been accepted by the accounting server.  That\n   leaves the proxy
      responsible for delivering accounting packets.  If\n   the proxy involves moving
      parts (e.g. a disk drive) while the NAS\n   does not, overall system reliability
      can be reduced.  As a result,\n   store and forward proxies SHOULD NOT be used.\n
      \  The sequence of events is as follows:\n   Time            NAS             Proxy
      \          Server\n   ------          ---             -----           ------\n
      \  0               Request\n                   ------->\n   OTTnp + TpR                     Reply/ACK\n
      \                                  <-------\n   OTTnp + Tpr                     Request\n
      \                                  ------->\n   OTTnp + OTTph +                                 Reply/ACK\n
      \  Tpr + Tsr                                       <-------\n   OTTnp + OTTph
      +\n   Tpr + Tsr +                     Reply\n   OTThp + TpR                     <-------\n
      \  OTTnp + OTTph +\n   Tpr + Tsr +                     Delayed ACK\n   OTThp
      + TdA                     ------->\n   OTTnp + OTTph +\n   OTThp + OTTpn +\n
      \  Tpr + Tsr +      Delayed ACK\n   TpR + TdA        ------->\n   Key\n   ---\n
      \  OTT   = One-way Trip Time\n   OTTnp = One-way trip time (NAS to Proxy)\n
      \  OTTpn = One-way trip time (Proxy to NAS)\n   OTTph = One-way trip time (Proxy
      to Home server)\n   OTThp = One-way trip time (Home Server to Proxy)\n   TdA
      \  = Delayed ACK timer\n   Tpr   = Proxy request processing time\n   TpR   =
      Proxy reply processing time\n   Tsr   = Server request processing time\n"
    title: B.3 Store and Forward Proxies
  - contents:
    - "B.4 Transport Layer Proxies\n   In addition to acting as proxies at the application
      layer, transport\n   layer proxies forward transport ACKs between the AAA client
      and\n   server.  This splices together the client-proxy and proxy-server\n   connections
      into a single connection that behaves as though it\n   operates end-to-end,
      exhibiting self-clocking.  However, since\n   transport proxies operate at the
      transport layer, they cannot be\n   implemented purely as applications and they
      are rarely deployed.\n   With a transport proxy, the sequence of events is as
      follows:\n   Time            NAS             Proxy           Home Server\n   ------
      \         ---             -----           -----------\n   0               Request\n
      \                  ------->\n   OTTnp + Tpr                     Request\n                                   ------->\n
      \  OTTnp + OTTph +                                 Reply/ACK\n   Tpr + Tsr                                       <-------\n
      \  OTTnp + OTTph +\n   Tpr + Tsr +                     Reply/ACK\n   OTThp +
      TpR                     <-------\n   OTTnp + OTTph +\n   OTThp + OTTpn +\n   Tpr
      + Tsr +      Delayed ACK\n   TpR + TdA        ------->\n   OTTnp + OTTph +\n
      \  OTThp + OTTpn +\n   Tpr + Tsr +                     Delayed ACK\n   TpR +
      TpD                       ------->\n   Key\n   ---\n   OTT   = One-way Trip
      Time\n   OTTnp = One-way trip time (NAS to Proxy)\n   OTTpn = One-way trip time
      (Proxy to NAS)\n   OTTph = One-way trip time (Proxy to Home server)\n   OTThp
      = One-way trip time (Home Server to Proxy)\n   TdA   = Delayed ACK timer\n   Tpr
      \  = Proxy request processing time\n   TpR   = Proxy reply processing time\n
      \  Tsr   = Server request processing time\n   TpD   = Proxy delayed ack processing
      time\n"
    title: B.4 Transport Layer Proxies
  title: Appendix B - AAA Agents
- contents:
  - "Intellectual Property Statement\n   The IETF takes no position regarding the
    validity or scope of any\n   intellectual property or other rights that might
    be claimed to\n   pertain to the implementation or use of the technology described
    in\n   this document or the extent to which any license under such rights\n   might
    or might not be available; neither does it represent that it\n   has made any
    effort to identify any such rights.  Information on the\n   IETF's procedures
    with respect to rights in standards-track and\n   standards-related documentation
    can be found in BCP-11.  Copies of\n   claims of rights made available for publication
    and any assurances of\n   licenses to be made available, or the result of an attempt
    made to\n   obtain a general license or permission for the use of such\n   proprietary
    rights by implementors or users of this specification can\n   be obtained from
    the IETF Secretariat.\n   The IETF invites any interested party to bring to its
    attention any\n   copyrights, patents or patent applications, or other proprietary\n
    \  rights which may cover technology that may be required to practice\n   this
    standard.  Please address the information to the IETF Executive\n   Director.\n"
  title: Intellectual Property Statement
- contents:
  - "Acknowledgments\n   Thanks to Allison Mankin of AT&T, Barney Wolff of Databus,
    Steve Rich\n   of Cisco, Randy Bush of AT&T, Bo Landarv of IP Unplugged, Jari
    Arkko\n   of Ericsson, and Pat Calhoun of Blackstorm Networks for fruitful\n   discussions
    relating to AAA transport.\n"
  title: Acknowledgments
- contents:
  - "Authors' Addresses\n   Bernard Aboba\n   Microsoft Corporation\n   One Microsoft
    Way\n   Redmond, WA 98052\n   Phone: +1 425 706 6605\n   Fax:   +1 425 936 7329\n
    \  EMail: bernarda@microsoft.com\n   Jonathan Wood\n   Sun Microsystems, Inc.\n
    \  901 San Antonio Road\n   Palo Alto, CA 94303\n   EMail: jonwood@speakeasy.net\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2003).  All
    Rights Reserved.\n   This document and translations of it may be copied and furnished
    to\n   others, and derivative works that comment on or otherwise explain it\n
    \  or assist in its implementation may be prepared, copied, published\n   and
    distributed, in whole or in part, without restriction of any\n   kind, provided
    that the above copyright notice and this paragraph are\n   included on all such
    copies and derivative works.  However, this\n   document itself may not be modified
    in any way, such as by removing\n   the copyright notice or references to the
    Internet Society or other\n   Internet organizations, except as needed for the
    purpose of\n   developing Internet standards in which case the procedures for\n
    \  copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
