- title: __initial_text__
  contents:
  - "I. ABSTRACT\nA mechanism is defined for use by message servers in\ntransferring\
    \ data between hosts.  The mechanism, called the\nMSDTP, is defined in terms of\
    \ a model of the process as a\ntranslation between two sets of items, the abstract\
    \ entities\nsuch as 'strings' and 'integers', and the formats used to\nrepresent\
    \ such data as a byte stream.\nA proposed organization of a general data transfer\n\
    mechanism is described, and the manner in which the MSDTP\nwould be used in that\
    \ environment is presented.\nII. REFERENCES\nBlack, Edward H., \"The DMS Message\
    \ Composer\", MIT Project\nMAC, Programming Technology Division Document\nSYS.16.02.\n\
    Burchfiel, Jerry D., Leavitt, Elsie M., Shapiro, Sonya and\nStrollo, Theodore\
    \ R., compilers, \"Tenex Users' Guide\",\nBolt Beranek and Newman, Cambridge,\
    \ Mass., May 1971,\nrevised January 1975, Descriptive sections on the TENEX\n\
    subsystems: MAlLER, p. 116-11; MAlLSTAT, p. 118-119;\nREADMAIL, p. 137; and SNDMSG,\
    \ p. 165-170.\nHaverty, Jack, \"Communications System Overview\", MIT Project\n\
    MAC, Programming Technology Division Document\nSYS.16.00.\nHaverty, Jack, \"Communications\
    \ System Daemon Manual\", MIT\nProject MAC, Programming Technology Division Document\n\
    SYS.16.01.\nISI Information Automation Project, \"Military Message\nProcessing\
    \ System Design,\" Internal Project\nDocumentation (Out of Print), Jan. 1975\n\
    Message Services Committee, \"Interim Report\", Jan. 28, 1975\nMooers, Charlotte\
    \ D., \"Mailsys Message System: Manual For\nUsers\", Bolt Beranek and Newman,\
    \ Cambridge, Mass., June\n1975 (draft).\nMyer, Theodore H., \"Notes On The BBN\
    \ Mail System\", Bolt\nBeranek and Newman, November 8, 1974.\nMyer, Theodore H.,\
    \ and Henderson, D. Austin, \"Message\nTransmission Protocol\", Network Working\
    \ Group RFC 680,\nPostel, Jon, \"The PCPB8 Format\", NSW Proposal, June 5, 1975\n\
    Tugender, R., and D. R. Oestreicher, \"Basic Functional\nCapabilities for a Military\
    \ Message Processing\nService,\" ISI?RR-74-23., May 1975\nVezza, Al, \"Message\
    \ Services Committee Minority Report\",\nJan. 1975\nIII. OVERVIEW\nThis document\
    \ describes a mechanism developed for use\nby message servers communicating over\
    \ an eight-bit\nbyte-oriented network connection to move data structures and\n\
    associated data-typing information.  It is presented here in\nthe hope that it\
    \ may be of use to other projects which need\nto transfer data structures between\
    \ dissimilar hosts.\nA set of abstract entities called PRIMITIVE ITEMS is\nenumerated.\
    \  These are intended to include traditional data\ntypes of general utility, such\
    \ as integers, strings, and\narrays.\nA mechanism is defined for augmenting the\
    \ set of\nabstract data entities handled, to allow the introduction of\napplication-specific\
    \ data, whose format and semantics are\nunderstood by the application programs\
    \ involved, but which\ncan be transmitted using common coding facilities.  An\n\
    example might be a data structure called a 'file\nspecification', or a 'date'.\
    \  Abstract data entities defined\nusing this mechanism will be termed SEMANTIC\
    \ ITEMS, since\nthey are typically used to carry data having semantic\ncontent\
    \ in the application involved.\nSemantic and primitive items are collectively\
    \ referred\nto simply as ITEMS.\nThe protocol next involves the definition of\
    \ the format\nof the byte stream used to convey items from machine to\nmachine.\
    \  These encodings are described in terms of OBJECTS,\nwhich are the physical\
    \ byte streams transmitted.\nTo complete the protocol, the rules for translating\n\
    between objects and items are presented as each object is\ndefined.\nAn item is\
    \ transmitted by being translated into an\nobject which is transmitted over the\
    \ connection as a stream\nof bytes to the receiver, and reconstructed there as\
    \ an\nitem.  The protocol mechanism may thus be viewed as a simple\ntranslator.\
    \  It enumerates a set of abstract entities, the\nitems, which are known to programmers,\
    \ a set of entities in\nbyte-stream format, the objects, and the translation rules\n\
    for conversion between the sets.  A site implementing the\nMSDTP would typically\
    \ provide a facility to convert between\nobjects and the local representation\
    \ of the various items\nhandled.  Applications using the MSDTP define their\n\
    interactions using items, without regard to the actual\nformats in which such\
    \ items are represented at various\nmachines.  This permits programs to handle\
    \ higher-level\nconcepts such as a character string, without concern for its\n\
    numerous representational formats.  Such detail is handled\nby the MSDTP.\nFinally,\
    \ a discussion of a general data transfer\nmechanism for communication between\
    \ programs is presented,\nand the manner in which the particular byte-oriented\n\
    protocol defined herein would be used in that environment is\ndiscussed.\nTerminology,\
    \ as introduced, is defined and highlighted\nby capitalizing.\nIV. PRIMITIVE DATA\
    \ ITEMS\nThe primitive data items include a variety of\ntraditional, well-understood\
    \ types, such as integers and\nstrings.  Primitive data items will be presented\
    \ using\nmnemonic names preceded by the character pair \"p-\", to serve\nas a\
    \ reminder that the named object is primitive.\nThese items may be represented\
    \ in various computer\nsystems in whatever fashion their programmers desire.\n\
    IV.1 -- Set Of Primitive Items\nThe set of primitive items defined includes p-INT,\n\
    p-STRING, p-STRUC, p-BITS, p-CHAR, p-BOOL, p-EMPTY, and\np-XTRA.\nSince the protocol\
    \ was developed primarily for use in\nmessage services, items such as p-FLOAT\
    \ are not included\nsince they were unnecessary.  Additional items may be easily\n\
    added as necessary.\nA p-INT performs the traditional role of representing\ninteger\
    \ numbers.  A p-BITS (BIT Stream) item represents a\nbit stream.  The two possible\
    \ p-BOOL (BOOLean) items are\nused to represent the logical values of *TRUE* and\
    \ *FALSE*.\nThe single p-EMPTY item is used to, for example, indicate\nthat a\
    \ given field of a message is empty.  It is provided to\nact as a place-holder,\
    \ representing 'no data', and appears\nas *EMPTY*.\nThe p-STRUC (STRUCture) item\
    \ is used to group together\na collection of items as a single value, maintaining\
    \ the\nordering of the elements, such as a p-STRUC of p-INTs.\nA p-CHAR is a single\
    \ character.  The most common\noccurrence of character data, however, will be\
    \ as p-STRINGs.\nA p-STRING should be considered to be a synonym for a\np-STRUC\
    \ containing only p-CHARs.  This concept is important\nfor generality and consistency,\
    \ especially when considering\ndefinitions of permissible operations on structures,\
    \ such as\nextracting subsequences of elements, etc.\nFour p-XTRA items, which\
    \ can be transmitted in a single\nbyte, are made available for higher level protocols\
    \ to use\nwhen a frequently used datum is handled which can be\nrepresented just\
    \ by its name.  An example would be an\nacknowledgment between two servers.  Using\
    \ p-XTRAs to\nrepresent such data permits them to be handled in a single\nbyte.\
    \  There are four possible p-XTRA items, termed *XTRA0*,\n*XTRA1*, *XTRA2*, and\
    \ *XTRA3*.  These may be assigned\nmeanings by user protocols as desired.\nIV.2\
    \ -- Printing Conventions\nThe following printing conventions are introduced to\n\
    facilitate discussion of the primitive items.\nWhen a specific instance of a primitive\
    \ data item is\npresented, it will be shown in a traditional representation\n\
    for that kind of data.  For example, p-INTs are shown as\nsequences of digits,\
    \ e.g. 100, p-STRINGs, as sequences of\ncharacters enclosed in double-quote characters,\
    \ for example\n\"ABCDEF\".\nAs shown above, the two possible p-BOOL items are\
    \ shown\nas *TRUE* or *FALSE*.  The object p-EMPTY appears as\n*EMPTY*.  A bit\
    \ stream, i.e. p-BITS, appears as a stream of\n1s and 0s enclosed in asterisks,\
    \ for example *100101001*.  A\np-CHAR will be presented as the character enclosed\
    \ in single\nquote characters, e.g., 'A'.\nP-STRUCs are printed as the representations\
    \ of their\nelements, enclosed in parentheses, for example (1 2 3 4) or\n(\"XYZ\"\
    \ \"ABC\" 1 2) or ((1 2 3) \"A\" \"B\"). Note that because\np-STRINGs are simply\
    \ a class of p-STRUCs assigned a special\nname and printing format for brevity\
    \ and convenience, the\nitems \"ABC\" and ('A' 'B' 'C') are identical, and the\
    \ latter\nformat should not be used.\nTo present a generic p-STRUC, as in specifying\
    \ formats\nof the contents of something, the items are presented as a\nmnemonic\
    \ name, optionally followed by a colon and the\npermissible types of values for\
    \ that datum.  When one of\nseveral items may appear as the value for some component,\n\
    the permissible ones appear separated by vertical-bar\ncharacters.  For example,\
    \ p-INT|p-STRING represents a single\nitem, which may be either a p-INT or a p-STRING.\n\
    To represent a succession of items, the Kleene star\nconvention is used.  The\
    \ specification p-INT[*] represents\nany number of p-INTs.  Similarly, p-INT[3,5]\
    \ represents from\n3 to 5 p-INTs, while p-INT[*,5] specifies up to 5 and\np-iNT[5,*]\
    \ specifies at least 5 p-INTs.\nFor example, a p-STRUC which is used to carry\
    \ names and\nnumbers might be specified as follows.\n(name:p-STRING number:p-INT)\n\
    In discussing items in general, when a specific data\nvalue is not intended, the\
    \ name and types representation may\nbe used, e.g., offset:p-INT to discuss an\
    \ 'offset' which has\na numeric value.\nV. SEMANTIC ITEM MECHANISM\nThe semantic\
    \ item mechanism provides a means for\nprogram designers to use a variety of application-specific\n\
    data items.\nThis mechanism is implemented using a special tagged\nstructure to\
    \ carry the data type information as well as the\nactual components of the particular\
    \ semantic item.  For\ndiscussion purposes.  Such a special p-STRUC will be termed\
    \ a\np-EDT (Extended Data Type).\nWhen p-EDTs are transferred, their identity\
    \ as a p-EDT\nis maintained.  So that an applications program receives the\ncorresponding\
    \ semantic item instead of a simple p-STRUC.  A\np-EDT is identical to a p-STRUC\
    \ in all other respects.\nV.1 -- Format of p-EDTs\nA prototypical p-EDT follows.\
    \  It is printed as if it\nwere a normal p-STRUC.  Since p-EDTs are converted\
    \ to\nsemantic items for presentation to the user, a p-EDT will\nnever be used\
    \ except in this protocol definition.\n(type:p-INT|p-STRING version:p-INT com1:any\n\
    com2:any ...)\nThe first element, the 'type' is generally a p-INT, and\nis used\
    \ to identify the particular type of semantic item.\nTypes are assigned numeric\
    \ codes in a controlled fashion.\nThe type may alternatively be specified by a\
    \ p-STRING, to\npermit development of new data types for possible later\nassignment\
    \ of codes.  Each type has an equivalent p-STRING\nname.  These may be used interchangeably\
    \ as 'type' elements,\nprimarily to maintain upward compatibility.\nThe second\
    \ element of a p-EDT is always an p-INT, the\n'version', and specifies the exact\
    \ format of the particular\ndatum.  A semantic item may undergo several revisions\
    \ of its\ninternal structure.  Which would be evident through assigning\ndifferent\
    \ versions to each revision.\nSuccessive components.  The 'com' elements, if any.\n\
    carry the actual data of the semantic item.  As each\nsemantic item is defined,\
    \ conventions on permissible values\nand interpretation of these components are\
    \ presented.  Such\ndefinitions may use any types of items to specify the format\n\
    of the semantic item.  Use of lower level concepts, such as\nobjects, in these\
    \ definitions is prohibited.\nSemantic items will be printed as the mnemonic for\
    \ the\ntype involved, preceded by the character pair \"s-\", to\nsignify that\
    \ the data item is handled by this mechanism.\nV.2 -- Printing Conventions\nA\
    \ semantic item is represented as if it were a p-STRUC\ncontaining only the components,\
    \ if any, but preceded by the\nsemantic type name and a # character.  The version\
    \ number is\nassumed to be 1 if unspecified.  For later versions, the\nversion\
    \ number is attached to the type name, as in, for\nexample, FILE-2 to represent\
    \ version 2 of the FILE data\ntype.\nFor example, a semantic item called a 'file\n\
    specification' might be defined, containing two components,\na host number and\
    \ pathname.  A specific instance of such an\nitem might appear as #FILE(69 \"\
    DIRECTORY.NAME-OF-FILE\"),\nwhile a generic s-FILE might be presented as the following.\n\
    #FILE(host:p-INT|p-STRING pathname:p-STRING)\nthe item, which may be either a\
    \ p-INT or p-STRING, and\n'pathname' is the second component, which must be a\n\
    p-STRING.  The full definition would present interpretation\nrules for these components.\n\
    VI.  ENCODING OBJECTS\nThis section presents the set of objects which are used\n\
    to represent items as byte streams for inter-server\ntransmission.  Objects will\
    \ be presented using mnemonic\ntype-names preceded by the character pair \"b-\"\
    , indicating\ntheir existence only as byte streams.\nAll servers are required\
    \ to be capable of decoding the\nentire set of objects.  Servers are not required\
    \ to transmit\ncertain objects which are available to improve channel\nefficiency.\n\
    The encodings are designed to facilitate programming\nand efficiency of the receiving\
    \ decoder.  In all cases, the\ntype and length in bytes of objects is supplied\
    \ as the first\ninformation sent.  This characteristic is important for ease\n\
    of implementation.  The type information permits a decoder to\nbe constructed\
    \ in a modular fashion.  The most important\nadvantage of including size information\
    \ is that the receiver\nalways knows how many bytes it must read to discover what\
    \ to\ndo next, and knows when each object terminates.  This\nrequirement avoids\
    \ many potential problems with timing and\nsynchronization of processes.\nTwo\
    \ varieties of objects are defined.  The first will\nbe called ATOMIC, and includes\
    \ objects used to efficiently\nencode the most common data.  The second variety\
    \ is termed\nNON-ATOMIC, and is used to encode larger or less common\nitems.\n\
    In all cases, a data object begins with a single byte,\nwhich will be termed the\
    \ TYPE-BYTE, a field of which\ncontains the type code of the object.  The following\
    \ bytes,\nif any, are interpreted according to the type involved.\nVI.1 -- Presentation\
    \ Conventations\nIn discussing formats of bytes, the following\nconventions will\
    \ be employed.  The individual bits of a byte\nwill be referenced by using capital\
    \ letters from A to H,\nwhere A signifies the highest order bit, and H the lowest.\n\
    The entire eight bit value, for example, could be referred\nto as ABCDEFGH.  Similarly,\
    \ subfields of the byte will be\nidentified by such sequences.  The CDEF field\
    \ specifies the\nmiddle four bits of a byte.\nIn referring to values of fields,\
    \ binary format will be\nused, and small letters near the end of the alphabet\
    \ will be\nused to identify particular bits for discussion.  For\nexample, we\
    \ might say that the BCD field of a byte contains\na specifier for some type,\
    \ and define its value to be\nBCD=11z.  In discussions of the specifier usage,\
    \ we could\nrefer to the cases where z=l and where z=0, as shorthand\nnotation\
    \ to identify BCD=111 and BCD=110, respectively.\nV1.2 -- Type-Byte Bit Assignment\n\
    To assist in understanding the assignment of the\nvarious type-byte values, the\
    \ table and graph below are\nincluded, showing representations of the eight bits.\n\
    OXXXXXXX -- CHAR7 (CHARacter, 7 bit)\n10XXXXXX -- SINTEGER (Small INTEGER)\nl10XXXXX\
    \ -- NON-ATOM (NON-ATOMic objects)\n11100XXX -- LINTEGER (Large INTEGER)\n11101XXX\
    \ -- reserved\n11110XXX -- SBITSTR (Short BIT STReam)\n111110XX -- XTRA (eXTRA\
    \ single-byte objects)\n1111110X -- BOOL (BOOLean)\n11111110 -- EMPTY (EMPTY data\
    \ item)\n11111111 -- PADDING (unused byte)\nIn each case, the bits identified\
    \ by X's are used to\ncontain information specific to the type involved.  These\n\
    are explained when each type is defined.\nAn equivalent tree representation follows,\
    \ for those\nwho prefer it.\nstart with high order bit\n |\n |\n |\n 0-----0-----0-----0-----0-----0-----0-----0-----X\n\
    0|    0|    0|    0|    0|    0|    0|    0|\n X     |     X     |     X     |\
    \     X     X\nCHAR7  | NON-ATOM  |    BITS   |   BOOL   EMPTY\n (7)   |   (5)\
    \     |    (3)    |   (1)\n       |        0| |           |\n   SINTEGER     \
    \   |          XTRA\n      (6)          |           (2)\n               LINTEGER\n\
    \                  (3)\n        Type-Byte Bit Assignment Scheme\nThis picture\
    \ is interpreted by entering at the top, and\ntaking the appropriate branch at\
    \ each node to correspond to\nthe next bit of the type-byte, as it is scanned\
    \ from left to\nright.  When a type is assigned, the branch terminates with\n\
    an \"X' and the name of the type of the object, with the\nnumber of remaining\
    \ bits in parentheses.  The individual\nobject definitions specify how these bits\
    \ are used for that\nparticular type.\nV1.3 -- Atomic Objects\nAtomic objects\
    \ are identified by specific patterns in a\ntype-byte.  Receiving servers must\
    \ be capable of recognizing\nand handling all atomic types, since the size of\
    \ the object\nis not explicitly present in a uniform fashion.\n| Atomic Object:\
    \ B-CHAR7       |\nThe b-CHAR7 (CHARacter 7 bit) object is introduced to\nhandle\
    \ transmission of characters, in 7-bit ASCII format.\nSince the vast majority\
    \ of message-related data involves\nsuch objects, they are designed to be very\
    \ efficient in\ntransmission.  Other formats, such as eight bit values, can\n\
    be introduced as non-atomic objects.  The format of a b-CHAR7\nfollows:\nA=0 identifying\
    \ the b-CHAR7 data type\nBCDEFGH=tuvwxyz containing the character\ncode\nThe tuvwxyz\
    \ objects contain the ASCII code of the\ncharacter.  For example, transmission\
    \ of a \"space' (ASCII\ncode 32, 40 octal) would be accomplished by the following\n\
    byte.\n00100000\nABCDEFGH\nA=0 to identify this byte as a b-CHAR7.  The remaining\n\
    bits contain the 7 bit code, octal 40, for space.\nA b-CHAR7 standing alone is\
    \ presented as a p-CHAR.\nSuch occurrences will probably be rare if they are used\
    \ at\nall.  The most common use of b-CHAR7's is as elements of\nb-USTRUCs used\
    \ to transmit p-STRINGS, as explained later.\n=============================\n\
    | Atomic Object: B-SINTEGER |\n=============================\nThe b-SINTEGER (Small\
    \ INTEGER) object is used to\ntransmit very small positive integers, of values\
    \ up to 64.\nIt always translates to an p-INT, and any p-INT between 0\nand 63\
    \ may be encoded as a b-SINTEGER for transmission.  The\nformat of an b-SINTEGER\
    \ follows.\nAB=10 identifying the object as a b-SINTEGER\nCDEFGH=uvwxyz containing\
    \ the actual number\nFor example, to transmit the integer 10 (12 octal), the\n\
    following byte would be transmitted:\n10001010\nABCDEFGH\nAB=10 to specify a b-SINTEGER.\
    \  The remaining six bits\ncontain the number 10 expressed in binary.\n=============================\n\
    | Atomic Object: B-SINTEGER |\n=============================\nThe b-SINTEGER (Large\
    \ INTEGER) object is used to\ntransmit p-INTs to any precision up to 64 bits.\
    \  It is\nalways translated as a p-INT.  Sending servers are permitted\nto choose\
    \ either b-SINTEGER or b-SINTEGER format for\ntransmission of numbers, as appropriate.\
    \  When possible,\nb-SINTEGERs can be used for better channel efficiency.  The\n\
    format of a b-SINTEGER follows:\nABCDE=11100 specifying that this is a b-SINTEGER.\n\
    FGH=xyz containing a count of number of bytes to follow.\nThe xyz bits are interpreted\
    \ as a number of bytes to\nfollow which contain the actual binary code of the\
    \ the\ninteger in 2's complement format.  Since a zero-byte integer\nis disallowed,\
    \ the pattern xyz=000 is interpreted as 1000,\nspecifying that 8 bytes follow.\
    \  The number is transmitted\nwith high-order bits first.  This format permits\n\
    transmission of integers as large as 64 bits in magnitude.\nFor example, if the\
    \ number 4096 (10000 octal) is to be\ntransmitted, the following sequence of bytes\
    \ would be sent:\n11100010 00010000 00000000\nABCDEFGH ---actual data---\nABCDE=11100,\
    \ identifying this as a b-LINTEGER, E=0,\nspecifying a positive number, and FGH=010,\
    \ specifying that 2\nbytes follow, containing the actual binary number.\n============================\n\
    | Atomic Object: B-SBITSTR |\n============================\nThe b-SBITSTR (Short\
    \ BIT STReam) object is used to\ntransmit a p-BITS of length 63 or less.  For\
    \ longer bit\nstreams, the non-atomic object b-LBITSTR may be used.  The\nformat\
    \ of a b-SBITSTR follows.\nABCDE=11110 specifying the type as b-SBITSTR\nFGH=xyz\
    \ specifying the number of bytes\nfollowing.\nThe xyz value specifies the number\
    \ of additional bytes\nto be read to obtain the bit stream values.  As in the\
    \ case\nof b-SINTEGER, the value xyz=000 is interpreted as 1000,\nspecifying that\
    \ 8 bytes follow.\nTo avoid requiring specification of exactly the number\nof\
    \ bits contained, the following convention is used.  The\nfirst data byte is scanned\
    \ from left to right until the\nfirst 1 bit is encountered.  The bit stream is\
    \ defined to\nbegin with the immediately following bit, and run through\nthe last\
    \ bit of the last byte read.  In other words, the bit\nstream is 'right-adjusted'\
    \ in the collected bytes, with its\nleft end delimited by the first \"on' bit.\n\
    For example, to send the bit stream *001010011* (9\nbits), the following bytes\
    \ are transmitted.\n11110010 00000010 01010011\nABCDEhij klmnopqr stuvwxyz\nThe\
    \ hij=010 value specifies that two bytes follow.  The\nq bit, which is the first\
    \ 1 bit encountered, identifies the\nstart of the bit stream as being the r bit.\
    \  The rstuvwxyz\nbits are the bit stream being handled.\n=========================\n\
    | Atomic Object: b-BOOL |\n=========================\nThe b-BOOL (BOOLean) object\
    \ is used to transmit\np-BOOLs.  The format of b-BOOL objects follows.\nABCDEFG=1111110\
    \ specifying the type as\nb-BOOL\nH=z specifying the value\nThe two possible translations\
    \ of a b-BOOL are *FALSE*\nand *TRUE*.\n11111100 represents *FALSE*\n11111101\
    \ represents *TRUE*\nABCDEFGz\nif z=0, the value is FALSE, otherwise TRUE.\n|\
    \ Atomic Object: B-EMPTY |\nThe b-EMPTY object type is used to transmit a 'null'\n\
    object, i.e. an *EMPTY*.  The format of an b-EMPTY follows.\nABCDEFGH=11111110\
    \ specifying *EMPTY*\n=========================\n| Atomic Object: B-XTRA |\n=========================\n\
    The b-XTRA objects are used to carry the four possible\np-XTRA items, i.e., *XTRA0*,\
    \ *XTRA1*, *XTRA2*, and *XTRA3*.\nThese four items correspond to the binary coding\
    \ of the\nremaining two bits after the b-XTRA type code bits.  The\nformat of\
    \ a b-XTRA follows.\nABCDEF=111110 to specify the type b-XTRA\nGH=yz to identify\
    \ the particular p-XTRA item\ncarried\nThe GH bits of the byte are decoded to\
    \ produce a\nparticular p-XTRA item, as follows.\nGH=00 -- *XTRA0*\nGH=01 -- *XTRA1*\n\
    GH=10 -- *XTRA2*\nGH=11 -- *XTRA3*\nThe b-XTRA object is included to provide the\
    \ use of\nseveral single-byte data items to higher levels.  These\nitems may be\
    \ assigned by individual applications to improve\nthe efficiency of transmission\
    \ of several very frequent data\nitems.  For example, the message services protocols\
    \ will use\nthese items to convey positive and negative acknowledgments,\ntwo\
    \ very common items in every interaction.\n| Atomic Object: B-PADDING\nThis object\
    \ is anomalous, since it represents really no\ndata at all.  Whenever it is encountered\
    \ in a byte stream in\na position where a type-byte is expected, it is completely\n\
    ignored, and the succeeding byte examined instead.  Its\npurpose is to serve as\
    \ a filler in byte streams, providing\nservers with an aid in handling internal\
    \ problems related to\ntheir specific word lengths, etc.  The encoders may freely\n\
    use this object to serve as padding when necessary.\nAll b-PADDING data objects\
    \ exist only within an encoded\nbyte stream.  They never cause any data item whatsoever\
    \ to\nbe presented externally to the coder module.  The format of a\nb-PADDING\
    \ follows.\nABCDEFGH=11111111\nNote that this does not imply that all such 'null'\n\
    bytes in a stream are to be ignored, since they could be\nencountered as a byte\
    \ within some other type, such as\nb-LINTEGER.  Only bytes of this format which,\
    \ by their\nposition in the stream, appear as a 'type' byte are to be\nignored.\n\
    VI.4 -- Non-Atomic Objects\nNon-atomic objects are are always transmitted preceded\n\
    by both a single type byte and some small number of size\nbyte(s).  The type byte\
    \ identifies that the data object\nconcerned is of a non-atomic type, as well\
    \ as uniquely\nspecifying the particular type involved.  All non-atomic\nobjects\
    \ have type byte values of the following form.\nABC=110 specifying that the object\
    \ is\nnon-atomic\nDEFGH=vwxyz specifying the particular type\nof object\nThe vwxyz\
    \ value is used to specify one of 31 possible\nnon-atomic types.  The value vwxyz=00000\
    \ is reserved for use\nin future expansion.\nIn all non-atomic data objects, the\
    \ byte(s) following\nthe type-byte specify the number of bytes to follow which\n\
    contain the data object.  In all cases, if the number of\nbytes specified are\
    \ processed, the next byte to be seen\nshould be another type-byte, the beginning\
    \ of the next\nobject in the stream.\nThe number of bytes containing the object\
    \ size\ninformation is variable.  These bytes will be termed the\nSIZE-BYTES.\
    \  The first byte encountered has the following\nformat.\nA=s specifying the manner\
    \ in which the size\ninformation is encoded\nBCDEFGH=tuvwxyz specifying the size,\
    \ or\nnumber of bytes containing the size\nThe tuvwxyz values supply a positive\
    \ binary number.  If\nthe s value is a one, the tuvwxyz value specifies the number\n\
    of bytes to follow which should be read and concatenated as\na binary number,\
    \ which will then specify the size of the\nobject.  These bytes will appear with\
    \ high order bits first.\nThus, if s=1, up to 128 bytes may follow, containing\
    \ the\ncount of the succeeding data bytes, which should certainly\nbe sufficient.\n\
    Since many non-atomic objects will be fairly short, the\ns=0 condition is used\
    \ to indicate that the 7 bits contained\nin tuvwxyz specify the actual data byte\
    \ count.  This permits\nobjects of sizes up to 128 bytes to be specified using\
    \ one\nsize-information byte.  The case tuvwxyz=0000000 is\ninterpreted as specifying\
    \ 128 bytes.\nFor example, a data object of some non-atomic type\nwhich requires\
    \ 100 (144 octal) bytes to be transmitted would\nbe sent as follows.\n110XXXXX\
    \ -- identifying a specific\nnon-atomic object\n01100100 -- specifying that 100\
    \ bytes follow\n.\n.\ndata -- the 100 data bytes\n.\n.\nNote that the size count\
    \ does not include the\nsize-specifier byte(s) themselves, but does include all\n\
    succeeding bytes in the stream used to encode the object.\nA data object requiring\
    \ 20000 (47040 octal) bytes would\nappear in the stream as follows.\n110XXXXX\
    \ -- identifying a specific\nnon-atomic object\n10000010 -- specifying that the\
    \ next 2 bytes\ncontain the stream length\n01001110 -- first byte of number 20000\n\
    00100000 -- second byte\n.\n.\ndata -- 20,000 bytes\n.\n.\nInterpretation of the\
    \ contents of the 20000 bytes in\nthe stream can be performed by a module which\
    \ knows the\nspecific format of the non-atomic type specified by DEFGH in\nthe\
    \ type-byte.\nThe remainder of this section defines an initial set of\nnon-atomic\
    \ types, the format of their encoding, and the\nsemantics of their interpretation.\n\
    | Non-atomic Object: B-LBITSTR |\nThe b-LBITSTR (Long BIT Stream) data type is\
    \ introduced\nto transmit p-BITS which cannot be handled by a b-SBITSTR.\nA b-LBITSTR\
    \ may be used to transmit short p-BITS as well.\nIts format follows.\n11000001\
    \ size-bytes data-bytes\nABCDEFGH\nABC=110 identifies this as a non-atomic object.\n\
    DEFGH=00001 specifies that it is a b-LBITSTR.  The standard\nsizing information\
    \ specifies the number of succeeding bytes.\nWithin the data-bytes, the first\
    \ object encountered must\ndecode to a p-INT.  This number conveys the length\
    \ of the\nbit stream to follow.  The actual bit stream begins with the\nnext byte,\
    \ and is left-adjusted in the byte stream.  For\nexample to encode *101010101010*,\
    \ the following b-LBITSTR\ncould be used, although a b-SBITSTR would be more compact.\n\
    11000001 -- identifies a b-LBITSTR\n00000010 -- b-SINTEGER, to specify length\n\
    10001100 -- size = 2\n10101010 -- first 8 data bits\n10100000 -- last 4 data bits\n\
    ==============================\n| Non-atomic Object: B-STRUC |\n==============================\n\
    The b-STRUC (STRUCture) data type is used to transmit\nany p-STRUC.  The translation\
    \ rules for converting a b-STRUC\ninto a primitive item are presented following\
    \ the discussion\nof b-REPEATs.  The b-STRUC format appears as follows.\n11000010\
    \ size-bytes data-bytes\nABCDEFGH\nABC=110 identifies this as a non-atomic type.\n\
    DEFGH=00010 specifies that the object is a b-STRUC.  Within\nthe data-bytes stream,\
    \ objects simply follow in order.  This\nimplies that the b-STRUC encoder and\
    \ decoder modules can\nsimply make use of recursive calls to a standard\nencoder/decoder\
    \ for processing each element of the b-STRUC.\nNote that any type of object is\
    \ permitted as an element of a\nb-STRUC, but the size information of the b-STRUC\
    \ must\ninclude all bytes used to represent the elements.\nContainment of b-STRUCs\
    \ within other b-STRUCs is\npermitted to any reasonable level.  That is, a b-STRUC\
    \ may\ncontain as an element another b-STRUC, which contains\nanother b-STRUC,\
    \ and so on.  All servers are requires to\nhandle such containment to at least\
    \ a minimum depth of\nthree.\nExamples of encoded structures appear in a later\n\
    section.\n============================\n| Non-atomic Object: B-EDT |\n============================\n\
    A b-EDT is the object used as the carrier for p-EDTs in\ntransmission of semantic\
    \ items.  It is functionally\nidentical to a b-STRUC, but has a different type\
    \ code to\npermit it to be identified and converted to a semantic item\ninstead\
    \ of a p-STRUC.  The format of a b-EDT follows.\n11000011 size-bytes data-bytes\n\
    ABCDEFGH\nAs with all non-atomic types, ABC=110 to identify this\nas such, and\
    \ DEFGH=00011 to specify a b-EDT.  The objects in\nthe data-bytes are decoded\
    \ as for b-STRUCs.  However, the\nfirst object must decode to a p-iNT or p-STRING\
    \ and the\nsecond to a p-INT, to conform to the format of p-EDTs.\n| Non-atomic\
    \ Object: b-REPEAT |\nThe b-REPEAT object is never translated directly into\n\
    an item.  It is legal only as an component of an enclosing\nb-STRUC, b-USTRUC,\
    \ b-EDT, or b-REPEAT.  A b-REPEAT is used to\nconcisely specify a set of elements\
    \ to be treated as if they\nappeared in the enclosing structure in place of the\n\
    b-REPEAT.  This provides a mechanism for encoding a sequence\nof identical data\
    \ items or patterns efficiently for\ntransmission.\nA common example of this would\
    \ be in transmission of\ntext, where line images containing long sequences of\
    \ spaces,\nor pages containing multiple carriage-return, line-feed\npairs, are\
    \ often encountered.  Such sequences could be\nencoded as an appropriate b-REPEAT\
    \ to compact the data for\ntransmission.  The format of a b-REPEAT is as follows.\n\
    11000100   -- identifyIng the object as a\n                b-REPEAT\nsize-bytes\
    \ -- the standard non-atomic object\n                size information\ncountspec\
    \  -- an object which translates to a p-INT\n.\n.\ndata -- the objects which define\
    \ the pattern\n.\n.\nThe 'countspec' object must translate to an p-INT to\nspecify\
    \ the number of times that the following data pattern\nshould be repeated in the\
    \ object enclosing the b-REPEAT.\nThe remaining objects in the b-REPEAT constitute\
    \ the\ndata pattern which is to be repeated.  The decoding of the\nenclosing structure\
    \ will be continued as if the data pattern\nobjects appeared 'countspec' times\
    \ in place of the b-REPEAT.\nZero repeat counts are permitted, for generality.\
    \  They\ncause no objects to be simulated in the enclosing structure.\nAn encoder\
    \ does not have to use b-REPEATs at all, if\nsimplicity of coding outweighs the\
    \ benefits of data\ncompression.  In message services, for example, an encoder\n\
    might limIt itself to only compressing long text strings.  It\nis important for\
    \ compatibility, however, to have the ability\nin the decoders to handle b-REPEATs.\n\
    | Non-atomic Object: B-USTRUC |\nThe b-USTRUC (Uniform Structure) object type\
    \ is\nprovided to enable servers to convey the fact that a p-STRUC\nbeing transferred\
    \ contains items of only a single type.  The\nmost common example would involve\
    \ a b-USTRUC which\ntranslates to a p-STRUC of only p-CHARs, and hence may be\n\
    considered to be a p-STRING.  Servers may use this\ninformation to assist them\
    \ in decoding objects efficiently.\nNo server is required to generate b-USTRUCs.\n\
    The internal construction of a b-USTRUC is identical to\nthat of a b-STRUC, except\
    \ for the type-byte.  The format of a\nb-USTRUC follows.\n11000101 size-bytes\
    \ data-bytes\nABCDEFGH\nABC=110 to identify a non-atomic object.  DEFGH=00101\n\
    specifies the object as a b-USTRUC.\n| Non-atomic Object: B-STRING |\nThe b-STRING\
    \ object is included to permit explicit\nspecification of a structure as a p-STRING.\
    \  This\ninformation will permit receiving servers to process the\nincoming structure\
    \ more efficiently.  A b-STRING is\nformatted similarity to a b-USTRUC, except\
    \ that its type-byte\nidentifies the object as a b-STRI/NG.  The normal sizing\n\
    information is followed by a stream of bytes which are\ninterpreted as b-CHAR7s,\
    \ Ignoring the high-order bit.  The\nformat of a b-STRING follows.\n11000110 size-bytes\
    \ data-bytes\nABCDEFGH\nABC=110 to identify a non-atomic object.  DEFGH=00110\n\
    specifies the object as a b-STRING.\nVI.5 -- Structure Translation Rules\nA b-STRUC\
    \ is translated into a p-STRUC.  This is\nperformed by translating each object\
    \ of the b-STRUC Into its\ncorresponding item, and saving it for inclusion In\
    \ the\np-STRUC being generated.  A b-USTRUC is handled similarly,\nbut the coding\
    \ programs may utilize the information that the\nresultant p-STRUC will contain\
    \ items of uniform type.  The\npreferred method of coding p-STRINGS is to use\
    \ b-USTRUCs.\nIf all of the elements of the resultant p-STRUC are\np-CHARs, it\
    \ is presented to the user of the decoder as a\np-STRING.  A p-STRING should be\
    \ considered to be a synonym\nfor a p-STRUC containing only characters.  It need\
    \ not\nnecessarily exist at particular sites which would present\np-STRUCs of\
    \ p-CHARs to their application programs\nThe object b-REPEAT is handled in a special\
    \ fashion\nwhen encountered as an element.  When this occurs, the data\npattern\
    \ of the b-REPEAT is translated into a sequence of\nitems, and that sequence is\
    \ repeated in the next higher\nlevel as many times as specified in the b-REPEAT.\n\
    Therefore, b-REPEATS are legal only as elements of a\nsurrounding b-STRUC, b-USTRUC,\
    \ b-EDT, or b-REPEAT.\nIn encoding a p-STRUC or p-STRING for transmission, a\n\
    translator may use b-REPEATs as desired to effect data\ncompression, but their\
    \ use is not mandatory.  Similarly,\nb-STRINGS may be used, but are not mandatory.\n\
    A b-EDT is translated into a p-EDT to identify it as a\ncarrier for a semantic\
    \ item.  Otherwise, it is treated\nidentically to a b-STRUC.\nVI.6 -- Translation\
    \ Summary\nThe following table summarizes the possible\ntranslations between primitive\
    \ items and objects.\np-INT    <--> b-LINTEGER, b-SINTEGER\np-STRING <--> b-STRING,\
    \ b-STRUC, b-USTRUC\np-STRUC  <--> b-STRING, b-STRUC, b-USTRUC\np-BITS   <-->\
    \ b=SBITSTR, b-LBITSTR\np-CHAR   <--> b-CHAR7\np-BOOL   <--> b-BOOL\np-EMPTY \
    \ <--> b=EMPTY\np-XTRA   <--> b-XTRA\np-EDT    <--> b-EDT (all semantic items)\n\
    -none-   <--> b-PADDING\n-none-   <--> b-REPEAT (only within structure)\nNote\
    \ that all semantic items are represented as p-EDTs\nwhich always exist as b-EDTs\
    \ in byte-stream format.\nV1.7 -- Structure Coding Examples\nThe following stream\
    \ transmits a b-STRUC containing 3\nb-SINTEGERs, with values 1, 2, and 3, representing\
    \ a p-STRUC\ncontaining three p-INTs, i.e. (1 2 3).\n11000010 -- b-STRUC\n00000011\
    \ -- size=3\n10000001 -- b-SINTEGER=1\n10000010 -- b-SINTEGER=2\n10000011 -- b-SINTEGER=3\n\
    The next example represents a b-STRUC containing the\ncharacters X and Y, followed\
    \ by the b-LINTEGER 10,\nrepresenting a p-STRUC of 2 p-CHARs and a p-INT, i.e.,\
    \ ('X'\n'Y' 10).  Note that the p-INT prevents considering this a\np-STRING.\n\
    11000010 -- b-STRUC\n00000100 -- size=4\n01011000 -- b-CHAR7 'X'\n01011001 --\
    \ b-CHAR7 'Y'\n11100001 -- b-LINTEGER\n00001010 -- 10\nNote that a better way\
    \ to send this p-STRUC would be to\nrepresent the integer as a b-SINTEGER, as\
    \ shown below.\n11000010 -- b-STRUC\n00000011 -- size=3\n01011000 -- b-CHAR7 'X'\n\
    01011001 -- b-CHAR7 'Y'\n10001010 -- b-SINTEGER=10\nThe next example shows a b-STRUC\
    \ of b-CHAR7s.  It is\nthe translation of the b-STRING \"HELLO\".\n11000010 --\
    \ b-STRUC\n00000101 -- size=5\n01001000 -- b-CHAR7 'H'\n01000101 -- b-CHAR7 'E'\n\
    01001100 -- b-CHAR7 'L'\n01001100 -- b-CHAR7 'L'\n01001111 -- b-CHAR7 'O'\nThis\
    \ datum could also be transmitted as a b-STRING.\nNote that the character bytes\
    \ are not necessarily b-CHAR7s,\nsince the high-order bit is ignored.\n11000110\
    \ -- b-STRING\n00000101 -- size=5\n01001000 -- 'H'\n01000101 -- 'E'\n01001100\
    \ -- 'L'\n01001100 -- 'L'\n01001111 -- 'O'\nTo encode a p-STRING containing 20\
    \ carriage-return\nline-feed pairs, the following b-STRUC containing a b-REPEAT\n\
    could be used.\n11000010 -- b-STRUC\n00000101 -- size=5\n11000100 -- b-REPEAT\n\
    00000011 -- size=3\n10010100 -- count, b-SINTEGER=20\n00001101 -- b-CHAR7, \"\
    CR'\n00001010 -- b-CHAR7, 'IF'\nTo encode a p-STRUC of p-INTs, where the sequence\n\
    contains a sequence of thirty 0's preceded by a single 1,\nthe following b-STRUC\
    \ could be used.\n11000010 -- b-STRUC\n00000110 -- size=6\n10000001 -- b-SINTEGER=1\n\
    11000100 -- b-REPEAT\n00000010 -- size=2\n10011110 -- count, b-SINTEGER=30\n10000000\
    \ -- b-SINTEGER=0\nVII. A GENERAL DATA TRANSFER SCHEME\nThis section considers\
    \ a possible scheme for extending\nthe concept of a data translator into an multi-purpose\
    \ data\ntransfer mechanism.\nThe proposed environment would provide a set of\n\
    primitive items, including those enumerated herein but\nextended as necessary\
    \ to accommodate a variety of\napplications.  Communication between processes\
    \ would be\ndefined solely in terms of these items, and would\nspecifically avoid\
    \ any consideration of the actual formats\nin which the data is transferred.\n\
    A repertoire of translators would be provided, one of\nwhich is the MSDTP machinery,\
    \ for use in converting items to\nany of a number of transmission formats.  Borrowing\
    \ a\nconcept from radio terminology, each translator would be\nanalogous to a\
    \ different type of modulation scheme, to be\nused to transfer data through some\
    \ communications medium.\nSuch media could be an eight-bit byte-oriented connection,\n\
    36-bit connection, etc.  and conceivably have other\ndistinguishing features,\
    \ such as bandwidth, cost, and delay.\nFor each media which a site supports, it\
    \ would provide its\nprogrammers with a module for performing the translations\n\
    required.\nCertain media or translators might not handle various\nitems.  For\
    \ example, the MSDTP does not handle items which\nmight be termed p-FLOATs, p-COMPLEXs,\
    \ p-ARRAY, and so on.  In\naddition, the efficiency of various media for transfer\
    \ of\nspecific items may differ drastically.  MSDTP, for example,\ntransfers data\
    \ frequently used in message handling very\nefficiently, but is relatively poor\
    \ at transfer of very\nlarge or deep tree structures.\nAvailable at each site\
    \ as a process or subroutine\npackage wouLd be a module responsible for interfacing\
    \ with\nits counterpart at the other end of the media.  These\nmodules would use\
    \ a protocol, not yet defined, to match\ntheir capabilities, and choose a particular\
    \ media and\ntranslator, when more than one exists, for transfer of data\nitems.\n\
    Such a facility could totally insulate applications\nfrom need to consider encoding\
    \ formats, machine differences,\nand so on, as well as eliminate duplication of\
    \ effort in\nproducing such facilities for every new project which\nrequires them.\
    \  In addition, as new translators or media are\nintroduced, they would become\
    \ immediately available to\nexisting users without reprogramming.\nImplementation\
    \ of such a protocol should not be very\ndifficult or time-consuming, since it\
    \ need not be very\nsophisticated in choosing the most appropriate transfer\n\
    mechanism in initial implementations.  The system is\ninherently upward-compatible\
    \ and easily expandable.\n"
