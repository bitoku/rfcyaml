- contents:
  - '              Routing Policy Specification Language (RPSL)

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   RPSL allows a network operator to be able to specify routing policies\n
    \  at various levels in the Internet hierarchy; for example at the\n   Autonomous
    System (AS) level.  At the same time, policies can be\n   specified with sufficient
    detail in RPSL so that low level router\n   configurations can be generated from
    them.  RPSL is extensible; new\n   routing protocols and new protocol features
    can be introduced at any\n   time.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1 Introduction                                                      3\n
    \  2 RPSL Names, Reserved Words, and Representation                    4\n   3
    Contact Information                                               7\n     3.1
    mntner Class . . . . . . . . . . . . . . . . . . . . . . . .  7\n     3.2 person
    Class . . . . . . . . . . . . . . . . . . . . . . . . 10\n     3.3 role Class
    . . . . . . . . . . . . . . . . . . . . . . . . . 11\n   4 route Class                                                      12\n
    \  5 Set Classes                                                      13\n     5.1
    as-set Class . . . . . . . . . . . . . . . . . . . . . . . . 14\n     5.2 route-set
    Class. . . . . . . . . . . . . . . . . . . . . . . 15\n     5.3 Predefined Set
    Objects . . . . . . . . . . . . . . . . . . . 17\n     5.4 Filters and filter-set
    Class . . . . . . . . . . . . . . . . 17\n     5.5 rtr-set Class. . . . . . .
    . . . . . . . . . . . . . . . . . 22\n     5.6 Peerings and peering-set Class
    . . . . . . . . . . . . . . . 24\n   6 aut-num Class                                                    27\n
    \    6.1 import Attribute:  Import Policy Specification . . . . . . . 27\n       6.1.1
    Action Specification . . . . . . . . . . . . . . . . . . 28\n     6.2 export Attribute:
    \ Export Policy Specification . . . . . . . 29\n      6.3 Other Routing Protocols,
    Multi-Protocol Routing Protocols,\n       and Injecting Routes Between Protocols
    . . . . . . . . . . . . 29\n     6.4 Ambiguity Resolution . . . . . . . . . .
    . . . . . . . . . . 31\n     6.5 default Attribute: Default Policy Specification
    \ . . . . . . 33\n     6.6 Structured Policy Specification. . . . . . . . . .
    . . . . . 33\n   7 dictionary Class                                                 37\n
    \    7.1 Initial RPSL Dictionary and Example Policy Actions and\n       Filters.
    . . . . . . . . . . . . . . . . . . . . . . . . . . . 41\n   8 Advanced route
    Class                                             45\n     8.1 Specifying Aggregate
    Routes. . . . . . . . . . . . . . . . . 45\n       8.1.1Interaction with policies
    in aut-num class. . . . . . . . 49\n       8.1.2Ambiguity resolution with overlapping
    aggregates. . . . . 50\n     8.2 Specifying Static Routes . . . . . . . . . .
    . . . . . . . . 52\n   9 inet-rtr Class                                                   52\n
    \  10 Extending RPSL                                                  54\n     10.1
    Extensions by changing the dictionary class . . . . . . . . 54\n     10.2 Extensions
    by adding new attributes to existing classes . . 55\n     10.3 Extensions by adding
    new classes  . . . . . . . . . . . . . 55\n     10.4 Extensions by changing the
    syntax of existing RPSL\n        attributes. . . . . . . . . . . . . . . . . .
    . . . . . . . . 55\n   11 Security Considerations                                         56\n
    \  12 Acknowledgements                                                56\n   References
    \                                                        56\n   A Routing Registry
    Sites                                           59\n   B Grammar Rules                                                    59\n
    \  C Changes from RFC 2280                                            67\n   D
    Authors' Addresses                                               68\n   Full Copyright
    Statement                                           69\n"
  title: Table of Contents
- contents:
  - "1 Introduction\n   This memo is the reference document for the Routing Policy\n
    \  Specification Language (RPSL).  RPSL allows a network operator to be\n   able
    to specify routing policies at various levels in the Internet\n   hierarchy; for
    example at the Autonomous System (AS) level.  At the\n   same time, policies can
    be specified with sufficient detail in RPSL\n   so that low level router configurations
    can be generated from them.\n   RPSL is extensible; new routing protocols and
    new protocol features\n   can be introduced at any time.\n   RPSL is a replacement
    for the current Internet policy specification\n   language known as RIPE-181 [6]
    or RFC-1786 [7].  RIPE-81 [8] was the\n   first language deployed in the Internet
    for specifying routing\n   policies.  It was later replaced by RIPE-181 [6].  Through\n
    \  operational use of RIPE-181 it has become apparent that certain\n   policies
    cannot be specified and a need for an enhanced and more\n   generalized language
    is needed.  RPSL addresses RIPE-181's\n   limitations.\n   RPSL was designed so
    that a view of the global routing policy can be\n   contained in a single cooperatively
    maintained distributed database\n   to improve the integrity of Internet's routing.
    \ RPSL is not designed\n   to be a router configuration language.  RPSL is designed
    so that\n   router configurations can be generated from the description of the\n
    \  policy for one autonomous system (aut-num class) combined with the\n   description
    of a router (inet-rtr class), mainly providing router ID,\n   autonomous system
    number of the router, interfaces and peers of the\n   router, and combined with
    a global database mappings from AS sets to\n   ASes (as-set class), and from origin
    ASes and route sets to route\n   prefixes (route and route-set classes).  The
    accurate population of\n   the RPSL database can help contribute toward such goals
    as router\n   configurations that protect against accidental (or malicious)\n
    \  distribution of inaccurate routing information, verification of\n   Internet's
    routing, and aggregation boundaries beyond a single AS.\n   RPSL is object oriented;
    that is, objects contain pieces of policy\n   and administrative information.
    \ These objects are registered in the\n   Internet Routing Registry (IRR) by the
    authorized organizations.  The\n   registration process is beyond the scope of
    this document.  Please\n   refer to [1, 17, 4] for more details on the IRR.\n
    \  In the following sections, we present the classes that are used to\n   define
    various policy and administrative objects.  The \"mntner\" class\n   defines entities
    authorized to add, delete and modify a set of\n   objects.  The \"person\" and
    \"role\" classes describes technical and\n   administrative contact personnel.
    \ Autonomous systems (ASes) are\n   specified using the \"aut-num\" class.  Routes
    are specified using the\n   \"route\" class.  Sets of objects can be defined using
    the \"as-set\",\n   \"route-set\", \"filter-set\", \"peering-set\", and \"rtr-set\"
    classes.  The\n   \"dictionary\" class provides the extensibility to the language.
    \ The\n   \"inet-rtr\" class is used to specify routers.  Many of these classes\n
    \  were originally defined in earlier documents [6, 13, 16, 12, 5] and\n   have
    all been enhanced.\n   This document is self-contained.  However, the reader is
    encouraged\n   to read RIPE-181 [7] and the associated documents [13, 16, 12,
    5] as\n   they provide significant background as to the motivation and\n   underlying
    principles behind RIPE-181 and consequently, RPSL. For a\n   tutorial on RPSL,
    the reader should read the RPSL applications\n   document [4].\n"
  title: 1 Introduction
- contents:
  - "2 RPSL Names, Reserved Words, and Representation\n   Each class has a set of
    attributes which store a piece of information\n   about the objects of the class.
    \ Attributes can be mandatory or\n   optional: A mandatory attribute has to be
    defined for all objects of\n   the class; optional attributes can be skipped.
    \ Attributes can also\n   be single or multiple valued.  Each object is uniquely
    identified by\n   a set of attributes, referred to as the class \"key\".\n   The
    value of an attribute has a type.  The following types are most\n   widely used.
    \ Note that RPSL is case insensitive and only the\n   characters from the ASCII
    character set can be used.\n   <object-name>\n      Many objects in RPSL have
    a name.  An <object-name> is made up of\n      letters, digits, the character
    underscore \"_\", and the character\n      hyphen \"-\"; the first character of
    a name must be a letter, and\n      the last character of a name must be a letter
    or a digit.  The\n      following words are reserved by RPSL, and they can not
    be used as\n      names:\n          any as-any rs-any peeras\n          and or
    not\n          atomic from to at action accept announce except refine\n          networks
    into inbound outbound\n      Names starting with certain prefixes are reserved
    for certain\n      object types.  Names starting with \"as-\" are reserved for
    as set\n      names.  Names starting with \"rs-\" are reserved for route set\n
    \     names.  Names starting with \"rtrs-\" are reserved for router set\n      names.
    \ Names starting with \"fltr-\" are reserved for filter set\n      names.  Names
    starting with \"prng-\" are reserved for peering set\n      names.\n   <as-number>
    An AS number x is represented as the string \"ASx\".  That\n      is, the AS 226
    is represented as AS226.\n   <ipv4-address> An IPv4 address is represented as
    a sequence of four\n      integers in the range from 0 to 255 separated by the
    character dot\n      \".\".  For example, 128.9.128.5 represents a valid IPv4
    address.\n      In the rest of this document, we may refer to IPv4 addresses as
    IP\n      addresses.\n   <address-prefix> An address prefix is represented as
    an IPv4 address\n      followed by the character slash \"/\" followed by an integer
    in the\n      range from 0 to 32.  The following are valid address prefixes:\n
    \     128.9.128.5/32, 128.9.0.0/16, 0.0.0.0/0; and the following address\n      prefixes
    are invalid:  0/0, 128.9/16 since 0 or 128.9 are not\n      strings containing
    four integers.\n   <address-prefix-range> An address prefix range is an address
    prefix\n      followed by an optional range operator.  The range operators are:\n
    \  ^- is the exclusive more specifics operator; it stands for the more\n      specifics
    of the address prefix excluding the address prefix\n      itself.  For example,
    128.9.0.0/16^- contains all the more\n      specifics of 128.9.0.0/16 excluding
    128.9.0.0/16.\n   ^+ is the inclusive more specifics operator; it stands for the
    more\n      specifics of the address prefix including the address prefix\n      itself.
    \ For example, 5.0.0.0/8^+ contains all the more specifics\n      of 5.0.0.0/8
    including 5.0.0.0/8.\n   ^n where n is an integer, stands for all the length n
    specifics of\n      the address prefix.  For example, 30.0.0.0/8^16 contains all
    the\n      more specifics of 30.0.0.0/8 which are of length 16 such as\n      30.9.0.0/16.\n
    \  ^n-m where n and m are integers, stands for all the length n to\n      length
    m specifics of the address prefix.  For example,\n      30.0.0.0/8^24-32 contains
    all the more specifics of 30.0.0.0/8\n      which are of length 24 to 32 such
    as 30.9.9.96/28.\n   Range operators can also be applied to address prefix sets.
    \ In this\n   case, they distribute over the members of the set.  For example,
    for\n   a route-set (defined later) rs-foo, rs-foo^+ contains all the\n   inclusive
    more specifics of all the prefixes in rs-foo.\n   It is an error to follow a range
    operator with another one (e.g.\n   30.0.0.0/8^24-28^+ is an error).  However,
    a range operator can be\n   applied to an address prefix set that has address
    prefix ranges in it\n   (e.g. {30.0.0.0/8^24-28}^27-30 is not an error).  In this
    case, the\n   outer operator ^n-m distributes over the inner operator ^k-l and\n
    \  becomes the operator ^max(n,k)-m if m is greater than or equal to\n   max(n,k),
    or otherwise, the prefix is deleted from the set.  Note\n   that the operator
    ^n is equivalent to ^n-n; prefix/l^+ is equivalent\n   to prefix/l^l-32; prefix/l^-
    is equivalent to prefix/l^(l+1)-32;\n   {prefix/l^n-m}^+ is equivalent to {prefix/l^n-32};
    and {prefix/l^n-\n   m}^- is equivalent to {prefix/l^(n+1)-32}.  For example,\n
    \               {128.9.0.0/16^+}^-     == {128.9.0.0/16^-}\n                {128.9.0.0/16^-}^+
    \    == {128.9.0.0/16^-}\n                {128.9.0.0/16^17}^24   == {128.9.0.0/16^24}\n
    \               {128.9.0.0/16^20-24}^26-28 == {128.9.0.0/16^26-28}\n                {128.9.0.0/16^20-24}^22-28
    == {128.9.0.0/16^22-28}\n                {128.9.0.0/16^20-24}^18-28 == {128.9.0.0/16^20-28}\n
    \               {128.9.0.0/16^20-24}^18-22 == {128.9.0.0/16^20-22}\n                {128.9.0.0/16^20-24}^18-19
    == {}\n   <date>\n      A date is represented as an eight digit integer of the
    form\n      YYYYMMDD where YYYY represents the year, MM represents the month\n
    \     of the year (01 through 12), and DD represents the day of the\n      month
    (01 through 31).  All dates are in UTC unless otherwise\n      specified.  For
    example, June 24, 1996 is represented as 19960624.\n   <email-address>is as described
    in RFC-822 [10].\n   <dns-name>is as described in RFC-1034 [17].\n   <nic-handle>
    is a uniquely assigned identifier word used by routing,\n      address allocation,
    and other registries to unambiguously refer to\n      contact information.  Person
    and role classes map NIC handles to\n      actual person names, and contact information.\n
    \  <free-form>is a sequence of ASCII characters.\n   <X-name> is a name of an
    object of type X. That is <mntner-name> is a\n      name of a mntner object.\n
    \  <registry-name> is a name of an IRR registry.  The routing registries\n      are
    listed in Appendix A.\n   A value of an attribute may also be a list of one of
    these types.  A\n   list is represented by separating the list members by commas
    \",\".\n   For example, \"AS1, AS2, AS3, AS4\" is a list of AS numbers.  Note
    that\n   being list valued and being multiple valued are orthogonal.  A\n   multiple
    valued attribute has more than one value, each of which may\n   or may not be
    a list.  On the other hand a single valued attribute\n   may have a list value.\n
    \  An RPSL object is textually represented as a list of attribute-value\n   pairs.
    \ Each attribute-value pair is written on a separate line.  The\n   attribute
    name starts at column 0, followed by character \":\" and\n   followed by the value
    of the attribute.  The attribute which has the\n   same name as the object's class
    should be specified first.  The\n   object's representation ends when a blank
    line is encountered.  An\n   attribute's value can be split over multiple lines,
    by having a\n   space, a tab or a plus ('+') character as the first character
    of the\n   continuation lines.  The character \"+\" for line continuation allows\n
    \  attribute values to contain blank lines.  More spaces may optionally\n   be
    used after the continuation character to increase readability.\n   The order of
    attribute-value pairs is significant.\n   An object's description may contain
    comments.  A comment can be\n   anywhere in an object's definition, it starts
    at the first \"#\"\n   character on a line and ends at the first end-of-line character.\n
    \  White space characters can be used to improve readability.\n   An integer can
    be specified using (1) the C programming language\n   notation (e.g. 1, 12345);
    (2) sequence of four 1-octet integers (in\n   the range from 0 to 255) separated
    by the character dot \".\"  (e.g.\n   1.1.1.1, 255.255.0.0), in this case a 4-octet
    integer is formed by\n   concatenating these 1-octet integers in the most significant
    to least\n   significant order; (3) sequence of two 2-octet integers (in the range\n
    \  from 0 to 65535) separated by the character colon \":\" (e.g. 3561:70,\n   3582:10),
    in this case a 4-octet integer is formed by concatenating\n   these 2-octet integers
    in the most significant to least significant\n   order.\n"
  title: 2 RPSL Names, Reserved Words, and Representation
- contents:
  - "3 Contact Information\n   The mntner, person and role classes, admin-c, tech-c,
    mnt-by,\n   changed, and source attributes of all classes describe contact\n   information.
    \ The mntner class also specifies authenticaiton\n   information required to create,
    delete and update other objects.\n   These classes do not specify routing policies
    and each registry may\n   have different or additional requirements on them.  Here
    we present\n   the common denominator for completeness which is the RIPE database\n
    \  implementation [16].  Please consult your routing registry for the\n   latest
    specification of these classes and attributes.  The \"Routing\n   Policy System
    Security\" document [20] describes the authenticaiton\n   and authorization model
    in more detail.\n"
  title: 3 Contact Information
- contents:
  - "3.1 mntner Class\n   The mntner class specifies authenticaiton information required
    to\n   create, delete and update RPSL objects.  A provider, before he/she\n   can
    create RPSL objects, first needs to create a mntner object.  The\n   attributes
    of the mntner class are shown in Figure 1.  The mntner\n   class was first described
    in [13].\n   The mntner attribute is mandatory and is the class key.  Its value
    is\n   an RPSL name.  The auth attribute specifies the scheme that will be\n   used
    to identify and authenticate update requests from this\n   maintainer.  It has
    the following syntax:\n   auth: <scheme-id> <auth-info>\n   E.g.\n          auth:
    NONE\n  Attribute  Value                   Type\n  mntner     <object-name>           mandatory,
    single-valued, class key\n  descr      <free-form>             mandatory, single-valued\n
    \ auth       see description in text mandatory, multi-valued\n  upd-to     <email-address>
    \        mandatory, multi-valued\n  mnt-nfy    <email-address>         optional,
    multi-valued\n  tech-c     <nic-handle>            mandatory, multi-valued\n  admin-c
    \   <nic-handle>            optional, multi-valued\n  remarks    <free-form>             optional,
    multi-valued\n  notify     <email-address>         optional, multi-valued\n  mnt-by
    \    list of <mntner-name>   mandatory, multi-valued\n  changed    <email-address>
    <date>  mandatory, multi-valued\n  source     <registry-name>         mandatory,
    single-valued\n                     Figure 1:  mntner Class Attributes\n          auth:
    CRYPT-PW dhjsdfhruewf\n          auth: MAIL-FROM .*@ripe\\.net\n   The <scheme-id>'s
    currently defined are: NONE, MAIL-FROM, PGP-KEY and\n   CRYPT-PW. The <auth-info>
    is additional information required by a\n   particular scheme: in the case of
    MAIL-FROM, it is a regular\n   expression matching valid email addresses; in the
    case of CRYPT-PW,\n   it is a password in UNIX crypt format; and in the case of
    PGP-KEY, it\n   is a pointer to key-certif object [22] containing the PGP public
    key\n   of the user.  If multiple auth attributes are specified, an update\n   request
    satisfying any one of them is authenticated to be from the\n   maintainer.\n   The
    upd-to attribute is an email address.  On an unauthorized update\n   attempt of
    an object maintained by this maintainer, an email message\n   will be sent to
    this address.  The mnt-nfy attribute is an email\n   address.  A notification
    message will be forwarded to this email\n   address whenever an object maintained
    by this maintainer is added,\n   changed or deleted.\n   The descr attribute is
    a short, free-form textual description of the\n   object.  The tech-c attribute
    is a technical contact NIC handle.\n   This is someone to be contacted for technical
    problems such as\n   misconfiguration.  The admin-c attribute is an administrative
    contact\n   NIC handle.  The remarks attribute is a free text explanation or\n
    \  clarification.  The notify attribute is an email address to which\n   notifications
    of changes to this object should be sent.  The mnt-by\n   attribute is a list
    of mntner object names.  The authorization for\n   changes to this object is governed
    by any of the maintainer objects\n   referenced.  The changed attribute documents
    who last changed this\n   object, and when this change was made.  Its syntax has
    the following\n   form:\n   changed: <email-address> <YYYYMMDD>\n   E.g.\n   changed:
    johndoe@terabit-labs.nn 19900401\n   The <email-address> identifies the person
    who made the last change.\n   <YYYYMMDD> is the date of the change.  The source
    attribute specifies\n   the registry where the object is registered.  Figure 2
    shows an\n   example mntner object.  In the example, UNIX crypt format password\n
    \  authentication is used.\n   mntner:      RIPE-NCC-MNT\n   descr:       RIPE-NCC
    Maintainer\n   admin-c:     DK58\n   tech-c:      OPS4-RIPE\n   upd-to:      ops@ripe.net\n
    \  mnt-nfy:     ops-fyi@ripe.net\n   auth:        CRYPT-PW lz1A7/JnfkTtI\n   mnt-by:
    \     RIPE-NCC-MNT\n   changed:     ripe-dbm@ripe.net 19970820\n   source:      RIPE\n
    \                   Figure 2:  An example mntner object.\n   The descr, tech-c,
    admin-c, remarks, notify, mnt-by, changed and\n   source attributes are attributes
    of all RPSL classes.  Their syntax,\n   semantics, and mandatory, optional, multi-valued,
    or single-valued\n   status are the same for for all RPSL classes.  Only exception
    to this\n   is the admin-c attribute which is mandatory for the aut-num class.\n
    \  We do not further discuss them in other sections.\n"
  title: 3.1 mntner Class
- contents:
  - "3.2 person Class\n   A person class is used to describe information about people.
    \ Even\n   though it does not describe routing policy, we still describe it here\n
    \  briefly since many policy objects make reference to person objects.\n   The
    person class was first described in [15].\n   The attributes of the person class
    are shown in Figure 3.  The person\n   attribute is the full name of the person.
    \ The phone and the fax-no\n   attributes have the following syntax:\n      phone:
    +<country-code> <city> <subscriber> [ext. <extension>]\n   E.g.:\n      phone:
    +31 20 12334676\n  Attribute  Value                   Type\n  person     <free-form>
    \            mandatory, single-valued\n  nic-hdl    <nic-handle>            mandatory,
    single-valued, class key\n  address    <free-form>             mandatory, multi-valued\n
    \ phone      see description in text mandatory, multi-valued\n  fax-no     same
    as phone           optional, multi-valued\n  e-mail     <email-address>         mandatory,
    multi-valued\n                     Figure 3:  person Class Attributes\n      phone:
    +44 123 987654 ext. 4711\n   Figure 4 shows an example person object.\n   person:
    \     Daniel Karrenberg\n   address:     RIPE Network Coordination Centre (NCC)\n
    \  address:     Singel 258\n   address:     NL-1016 AB  Amsterdam\n   address:
    \    Netherlands\n   phone:       +31 20 535 4444\n   fax-no:      +31 20 535
    4445\n   e-mail:      Daniel.Karrenberg@ripe.net\n   nic-hdl:     DK58\n   changed:
    \    Daniel.Karrenberg@ripe.net 19970616\n   source:      RIPE\n                    Figure
    4:  An example person object.\n"
  title: 3.2 person Class
- contents:
  - "3.3 role Class\n   The role class is similar to the person object.  However,
    instead of\n   describing a human being, it describes a role performed by one
    or\n   more human beings.  Examples include help desks, network monitoring\n   centers,
    system administrators, etc.  Role object is particularly\n   useful since often
    a person performing a role may change, however the\n   role itself remains.\n
    \  The attributes of the role class are shown in Figure 5.  The nic-hdl\n   attributes
    of the person and role classes share the same name space.\n   The trouble attribute
    of role object may contain additional contact\n   information to be used when
    a problem arises in any object that\n   references this role object.  Figure 6
    shows an example role object.\n  Attribute  Value                    Type\n  role
    \      <free-form>              mandatory, single-valued\n  nic-hdl    <nic-handle>
    \            mandatory, single-valued,\n                                      class
    key\n  trouble    <free-form>              optional, multi-valued\n  address    <free-form>
    \             mandatory, multi-valued\n  phone      see description in text  mandatory,
    multi-valued\n  fax-no     same as phone            optional, multi-valued\n  e-mail
    \    <email-address>          mandatory, multi-valued\n                      Figure
    5:  role Class Attributes\n   role:        RIPE NCC Operations\n   trouble:\n
    \  address:     Singel 258\n   address:     1016 AB Amsterdam\n   address:     The
    Netherlands\n   phone:       +31 20 535 4444\n   fax-no:      +31 20 545 4445\n
    \  e-mail:      ops@ripe.net\n   admin-c:     CO19-RIPE\n   tech-c:      RW488-RIPE\n
    \  tech-c:      JLSD1-RIPE\n   nic-hdl:     OPS4-RIPE\n   notify:      ops@ripe.net\n
    \  changed:     roderik@ripe.net 19970926\n   source:      RIPE\n                     Figure
    6:  An example role object.\n"
  title: 3.3 role Class
- contents:
  - "4 route Class\n   Each interAS route (also referred to as an interdomain route)\n
    \  originated by an AS is specified using a route object.  The\n   attributes
    of the route class are shown in Figure 7.  The route\n   attribute is the address
    prefix of the route and the origin attribute\n   is the AS number of the AS that
    originates the route into the interAS\n   routing system.  The route and origin
    attribute pair is the class\n   key.\n   Figure 8 shows examples of four route
    objects (we do not include\n   contact attributes such as admin-c, tech-c for
    brevity).  Note that\n   the last two route objects have the same address prefix,
    namely\n   128.8.0.0/16.  However, they are different route objects since they\n
    \  are originated by different ASes (i.e. they have different keys).\n   Attribute
    \    Value                      Type\n   route         <address-prefix>           mandatory,
    single-valued,\n                                            class key\n   origin
    \       <as-number>                mandatory, single-valued,\n                                            class
    key\n   member-of     list of <route-set-names>  optional, multi-valued\n                 see
    Section 5\n   inject        see Section 8              optional, multi-valued\n
    \  components    see Section 8              optional, single-valued\n   aggr-bndry
    \   see Section 8              optional, single-valued\n   aggr-mtd      see Section
    8              optional, single-valued\n   export-comps  see Section 8              optional,
    single-valued\n   holes         see Section 8              optional, multi-valued\n
    \                       Figure 7:  route Class Attributes\n      route: 128.9.0.0/16\n
    \     origin: AS226\n      route: 128.99.0.0/16\n      origin: AS226\n      route:
    128.8.0.0/16\n      origin: AS1\n      route: 128.8.0.0/16\n      origin: AS2\n
    \                            Figure 8:  Route Objects\n"
  title: 4 route Class
- contents:
  - "5 Set Classes\n   To specify policies, it is often useful to define sets of objects.\n
    \  For this purpose we define as-set, route-set, rtr-set, filter-set,\n   and
    peering-set classes.  These classes define a named set.  The\n   members of these
    sets can be specified either directly by listing\n   them in the sets' definition,
    or indirectly by having member objects\n   refer to the sets' names, or a combination
    of both methods.\n   A set's name is an rpsl word with the following restrictions:
    All\n   as-set names start with prefix \"as-\".  All route-set names start with\n
    \  prefix \"rs-\".  All rtr-set names start with prefix \"rtrs-\".  All\n   filter-set
    names start with prefix \"fltr-\".  All peering-set names\n   start with prefix
    \"prng-\".  For example, as-foo is a valid as-set\n   name.\n   Set names can
    also be hierarchical.  A hierarchical set name is a\n   sequence of set names
    and AS numbers separated by colons \":\".  At\n   least one component of such
    a name must be an actual set name (i.e.\n   start with one of the prefixes above).
    \ All the set name components\n   of an hierarchical name has to be of the same
    type.  For example, the\n   following names are valid: AS1:AS-CUSTOMERS, AS1:RS-EXPORT:AS2,
    RS-\n   EXCEPTIONS:RS-BOGUS.\n   The purpose of an hierarchical set name is to
    partition the set name\n   space so that the maintainers of the set X1 controls
    the whole set\n   name space underneath, i.e. X1:...:Xn-1.  Thus, a set object
    with\n   name X1:...:Xn-1:Xn can only be created by the maintainer of the\n   object
    with name X1:...:Xn-1.  That is, only the maintainer of AS1\n   can create a set
    with name AS1:AS-FOO; and only the maintainer of\n   AS1:AS-FOO can create a set
    with name AS1:AS-FOO:AS-BAR. Please see\n   RPS Security Document [20] for details.\n"
  title: 5 Set Classes
- contents:
  - "5.1 as-set Class\n   The attributes of the as-set class are shown in Figure 9.
    \ The as-set\n   attribute defines the name of the set.  It is an RPSL name that\n
    \  starts with \"as-\".  The members attribute lists the members of the\n   set.
    \ The members attribute is a list of AS numbers, or other as-set\n   names.\n
    \     Attribute    Value                    Type\n      as-set       <object-name>
    \           mandatory, single-valued,\n                                            class
    key\n      members      list of <as-numbers> or  optional, multi-valued\n                   <as-set-names>\n
    \     mbrs-by-ref  list of <mntner-names>   optional, multi-valued\n                     Figure
    9:  as-set Class Attributes\n   Figure 10 presents two as-set objects.  The set
    as-foo contains two\n   ASes, namely AS1 and AS2.  The set as-bar contains the
    members of the\n   set as-foo and AS3, that is it contains AS1, AS2, AS3.  The
    set as-\n   empty contains no members.\n as-set: as-foo           as-set: as-bar
    \               as-set: as-empty\n members: AS1, AS2        members: AS3, as-foo\n
    \                       Figure 10:  as-set objects.\n   The mbrs-by-ref attribute
    is a list of maintainer names or the\n   keyword ANY.  If this attribute is used,
    the AS set also includes\n   ASes whose aut-num objects are registered by one
    of these maintainers\n   and whose member-of attribute refers to the name of this
    AS set.  If\n   the value of a mbrs-by-ref attribute is ANY, any AS object referring\n
    \  to the AS set is a member of the set.  If the mbrs-by-ref attribute\n   is
    missing, only the ASes listed in the members attribute are members\n   of the
    set.\n    as-set: as-foo\n    members: AS1, AS2\n    mbrs-by-ref: MNTR-ME\n    aut-num:
    AS3                          aut-num: AS4\n    member-of: as-foo                     member-of:
    as-foo\n    mnt-by: MNTR-ME                       mnt-by: MNTR-OTHER\n                           Figure
    11:  as-set objects.\n   Figure 11 presents an example as-set object that uses
    the mbrs-by-ref\n   attribute.  The set as-foo contains AS1, AS2 and AS3.  AS4
    is not a\n   member of the set as-foo even though the aut-num object references\n
    \  as-foo.  This is because MNTR-OTHER is not listed in the as-foo's\n   mbrs-by-ref
    attribute.\n"
  title: 5.1 as-set Class
- contents:
  - "5.2 route-set Class\n   The attributes of the route-set class are shown in Figure
    12.  The\n   route-set attribute defines the name of the set.  It is an RPSL name\n
    \  that starts with \"rs-\".  The members attribute lists the members of\n   the
    set.  The members attribute is a list of address prefixes or\n   other route-set
    names.  Note that, the route-set class is a set of\n   route prefixes, not of
    RPSL route objects.\n Attribute    Value                              Type\n route-set
    \   <object-name>                      mandatory,\n                                                 single-valued,\n
    \                                                class key\n members      list
    of <address-prefix-range> or  optional, multi-valued\n              <route-set-name>
    or\n              <route-set-name><range-operator>\n mbrs-by-ref  list of <mntner-names>
    \            optional, multi-valued\n                   Figure 12:  route-set
    Class Attributes\n   Figure 13 presents some example route-set objects.  The set
    rs-foo\n   contains two address prefixes, namely 128.9.0.0/16 and 128.9.0.0/24.\n
    \  The set rs-bar contains the members of the set rs-foo and the address\n   prefix
    128.7.0.0/16.\n   An address prefix or a route-set name in a members attribute
    can be\n   optionally followed by a range operator.  For example, the following\n
    \  set:\n   route-set: rs-foo\n   members: 128.9.0.0/16, 128.9.0.0/24\n   route-set:
    rs-bar\n   members: 128.7.0.0/16, rs-foo\n                       Figure 13:  route-set
    Objects\n   route-set: rs-bar\n   members: 5.0.0.0/8^+, 30.0.0.0/8^24-32, rs-foo^+\n
    \  contains all the more specifics of 5.0.0.0/8 including 5.0.0.0/8, all\n   the
    more specifics of 30.0.0.0/8 which are of length 24 to 32 such as\n   30.9.9.96/28,
    and all the more specifics of address prefixes in route\n   set rs-foo.\n   The
    mbrs-by-ref attribute is a list of maintainer names or the\n   keyword ANY.  If
    this attribute is used, the route set also includes\n   address prefixes whose
    route objects are registered by one of these\n   maintainers and whose member-of
    attribute refers to the name of this\n   route set.  If the value of a mbrs-by-ref
    attribute is ANY, any route\n   object referring to the route set name is a member.
    \ If the mbrs-by-\n   ref attribute is missing, only the address prefixes listed
    in the\n   members attribute are members of the set.\n   route-set: rs-foo\n   mbrs-by-ref:
    MNTR-ME, MNTR-YOU\n   route-set: rs-bar\n   members: 128.7.0.0/16\n   mbrs-by-ref:
    MNTR-YOU\n   route: 128.9.0.0/16\n   origin: AS1\n   member-of: rs-foo\n   mnt-by:
    MNTR-ME\n   route: 128.8.0.0/16\n   origin: AS2\n   member-of: rs-foo, rs-bar\n
    \  mnt-by: MNTR-YOU\n                       Figure 14:  route-set objects.\n   Figure
    14 presents example route-set objects that use the mbrs-by-ref\n   attribute.
    \ The set rs-foo contains two address prefixes, namely\n   128.8.0.0/16 and 128.9.0.0/16
    since the route objects for\n   128.8.0.0/16 and 128.9.0.0/16 refer to the set
    name rs-foo in their\n   member-of attribute.  The set rs-bar contains the address
    prefixes\n   128.7.0.0/16 and 128.8.0.0/16.  The route 128.7.0.0/16 is explicitly\n
    \  listed in the members attribute of rs-bar, and the route object for\n   128.8.0.0/16
    refer to the set name rs-bar in its member-of attribute.\n   Note that, if an
    address prefix is listed in a members attribute of a\n   route set, it is a member
    of that route set.  The route object\n   corresponding to this address prefix
    does not need to contain a\n   member-of attribute referring to this set name.
    \ The member-of\n   attribute of the route class is an additional mechanism for\n
    \  specifying the members indirectly.\n"
  title: 5.2 route-set Class
- contents:
  - "5.3 Predefined Set Objects\n   In a context that expects a route set (e.g.  members
    attribute of the\n   route-set class), an AS number ASx defines the set of routes
    that are\n   originated by ASx; and an as-set AS-X defines the set of routes that\n
    \  are originated by the ASes in AS-X. A route p is said to be\n   originated
    by ASx if there is a route object for p with ASx as the\n   value of the origin
    attribute.  For example, in Figure 15, the route\n   set rs-special contains 128.9.0.0/16,
    routes of AS1 and AS2, and\n   routes of the ASes in AS set AS-FOO.\n   route-set:
    rs-special\n   members: 128.9.0.0/16, AS1, AS2, AS-FOO\n          Figure 15:  Use
    of AS numbers and AS sets in route sets.\n   The set rs-any contains all routes
    registered in IRR. The set as-any\n   contains all ASes registered in IRR.\n"
  title: 5.3 Predefined Set Objects
- contents:
  - "5.4 Filters and filter-set Class\n   The attributes of the filter-set class are
    shown in Figure 16.  A\n   filter-set object defines a set of routes that are
    matched by its\n   filter.  The filter-set attribute defines the name of the filter.
    \ It\n   is an RPSL name that starts with \"fltr-\".\n       Attribute   Value
    \        Type\n       filter-set  <object-name> mandatory, single-valued, class
    key\n       filter      <filter>      mandatory, single-valued\n                    Figure
    16:  filter Class Attributes\n      filter-set: fltr-foo\n      filter: { 5.0.0.0/8,
    6.0.0.0/8 }\n      filter-set: fltr-bar\n      filter: (AS1 or fltr-foo) and <AS2>\n
    \                     Figure 17:  filter-set objects.\n   The filter attribute
    defines the set's policy filter.  A policy\n   filter is a logical expression
    which when applied to a set of routes\n   returns a subset of these routes.  We
    say that the policy filter\n   matches the subset returned.  The policy filter
    can match routes\n   using any BGP path attribute, such as the destination address
    prefix\n   (or NLRI), AS-path, or community attributes.\n   The policy filters
    can be composite by using the operators AND, OR,\n   and NOT.  The following policy
    filters can be used to select a subset\n   of routes:\n   ANY\n      The keyword
    ANY matches all routes.\n   Address-Prefix Set This is an explicit list of address
    prefixes\n      enclosed in braces '{' and '}'.  The policy filter matches the
    set\n      of routes whose destination address-prefix is in the set.  For\n      example:\n
    \       { 0.0.0.0/0 }\n        { 128.9.0.0/16, 128.8.0.0/16, 128.7.128.0/17, 5.0.0.0/8
    }\n        { }\n   An address prefix can be optionally followed by a range operator\n
    \  (i.e.\n      { 5.0.0.0/8^+, 128.9.0.0/16^-, 30.0.0.0/8^16, 30.0.0.0/8^24-32
    }\n   contains all the more specifics of 5.0.0.0/8 including 5.0.0.0/8, all\n
    \  the more specifics of 128.9.0.0/16 excluding 128.9.0.0/16, all the\n   more
    specifics of 30.0.0.0/8 which are of length 16 such as\n   30.9.0.0/16, and all
    the more specifics of 30.0.0.0/8 which are of\n   length 24 to 32 such as 30.9.9.96/28.\n
    \  Route Set Name  A route set name matches the set of routes that are\n   members
    of the set.  A route set name may be a name of a route-set\n   object, an AS number,
    or a name of an as-set object (AS numbers and\n   as-set names implicitly define
    route sets; please see Section 5.3).\n   For example:\n      aut-num: AS1\n      import:
    from AS2 accept AS2\n      import: from AS2 accept AS-FOO\n      import: from
    AS2 accept RS-FOO\n   The keyword PeerAS can be used instead of the AS number
    of the peer\n   AS.  PeerAS is particularly useful when the peering is specified\n
    \  using an AS expression.  For example:\n      as-set: AS-FOO\n      members:
    AS2, AS3\n      aut-num: AS1\n      import: from AS-FOO accept PeerAS\n   is same
    as:\n      aut-num: AS1\n      import: from AS2 accept AS2\n      import: from
    AS3 accept AS3\n   A route set name can also be followed by one of the operators
    '^-',\n   '^+', example, { 5.0.0.0/8, 6.0.0.0/8 }^+ equals { 5.0.0.0/8^+,\n   6.0.0.0/8^+
    }, and AS1^- equals all the exclusive more specifics of\n   routes originated
    by AS1.\n   AS Path Regular Expressions\n      An AS-path regular expression can
    be used as a policy filter by\n      enclosing the expression in `<' and `>'.
    \ An AS-path policy filter\n      matches the set of routes which traverses a
    sequence of ASes\n      matched by the AS-path regular expression.  A router can
    check\n      this using the AS_PATH attribute in the Border Gateway Protocol\n
    \     [19], or the RD_PATH attribute in the Inter-Domain Routing\n      Protocol
    [18].\n      AS-path Regular Expressions are POSIX compliant regular\n      expressions
    over the alphabet of AS numbers.  The regular\n      expression constructs are
    as follows:\n   ASN\n      where ASN is an AS number.  ASN matches the AS-path
    that is of\n      length 1 and contains the corresponding AS number (e.g.  AS-path\n
    \     regular expression AS1 matches the AS-path \"1\").\n      The keyword PeerAS
    can be used instead of the AS number of the\n      peer AS.\n   AS-set\n      where
    AS-set is an AS set name.  AS-set matches the AS-paths that\n      is matched
    by one of the ASes in the AS-set.\n   .\n      matches the AS-paths matched by
    any AS number.\n   [...]\n      is an AS number set.  It matches the AS-paths
    matched by the AS\n      numbers listed between the brackets.  The AS numbers
    in the set\n      are separated by white space characters.  If a `-' is used between\n
    \     two AS numbers in this set, all AS numbers between the two AS\n      numbers
    are included in the set.  If an as-set name is listed, all\n      AS numbers in
    the as-set are included.\n   [^...]\n      is a complemented AS number set.  It
    matches any AS-path which is\n      not matched by the AS numbers in the set.\n
    \  ^\n      Matches the empty string at the beginning of an AS-path.\n   $\n      Matches
    the empty string at the end of an AS-path.\n   We next list the regular expression
    operators in the decreasing order\n   of evaluation.  These operators are left
    associative, i.e. performed\n   left to right.\n   Unary postfix operators * +
    ?  {m} {m,n} {m,}\n      For a regular expression A, A* matches zero or more occurrences
    of\n      A; A+ matches one or more occurrences of A; A?  matches zero or\n      one
    occurrence of A; A{m} matches m occurrence of A; A{m,n}\n      matches m to n
    occurrence of A; A{m,} matches m or more occurrence\n      of A. For example,
    [AS1 AS2]{2} matches AS1 AS1, AS1 AS2, AS2 AS1,\n      and AS2 AS2.\n   Unary
    postfix operators ~* ~+ ~{m} ~{m,n} ~{m,}\n      These operators have similar
    functionality as the corresponding\n      operators listed above, but all occurrences
    of the regular\n      expression has to match the same pattern.  For example,
    [AS1\n      AS2]~{2} matches AS1 AS1 and AS2 AS2, but it does not match AS1\n
    \     AS2 and AS2 AS1.\n   Binary catenation operator\n      This is an implicit
    operator and exists between two regular\n      expressions A and B when no other
    explicit operator is specified.\n      The resulting expression A B matches an
    AS-path if A matches some\n      prefix of the AS-path and B matches the rest
    of the AS-path.\n   Binary alternative (or) operator |\n      For a regular expressions
    A and B, A | B matches any AS-path that\n      is matched by A or B.\n   Parenthesis
    can be used to override the default order of evaluation.\n   White spaces can
    be used to increase readability.\n   The following are examples of AS-path filters:\n
    \  <AS3>\n   <^AS1>\n   <AS2$>\n   <^AS1 AS2 AS3$>\n   <^AS1 .* AS2$>.\n   The
    first example matches any route whose AS-path contains AS3, the\n   second matches
    routes whose AS-path starts with AS1, the third\n   matches routes whose AS-path
    ends with AS2, the fourth matches routes\n   whose AS-path is exactly \"1 2 3\",
    and the fifth matches routes whose\n   AS-path starts with AS1 and ends in AS2
    with any number of AS numbers\n   in between.\n   Composite Policy Filters The
    following operators (in decreasing order\n   of evaluation) can be used to form
    composite policy filters:\n   NOT Given a policy filter x, NOT x matches the set
    of routes that\n       are not matched by x.  That is it is the negation of policy\n
    \      filter x.\n   AND Given two policy filters x and y, x AND y matches the
    intersection\n       of the routes that are matched by x and that are matched
    by y.\n   OR  Given two policy filters x and y, x OR y matches the union of the\n
    \      routes that are matched by x and that are matched by y.\n   Note that an
    OR operator can be implicit, that is `x y' is equivalent\n   to `x OR y'.\n  E.g.\n
    \   NOT {128.9.0.0/16, 128.8.0.0/16}\n    AS226 AS227 OR AS228\n    AS226 AND
    NOT {128.9.0.0/16}\n    AS226 AND {0.0.0.0/0^0-18}\n   The first example matches
    any route except 128.9.0.0/16 and\n   128.8.0.0/16.  The second example matches
    the routes of AS226, AS227\n   and AS228.  The third example matches the routes
    of AS226 except\n   128.9.0.0/16.  The fourth example matches the routes of AS226
    whose\n   length are not longer than 18.\n   Routing Policy Attributes Policy
    filters can also use the values of\n   other attributes for comparison.  The attributes
    whose values can be\n   used in policy filters are specified in the RPSL dictionary.
    \ Please\n   refer to Section 7 for details.  An example using the the BGP\n   community
    attribute is shown below:\n    aut-num: AS1\n    export: to AS2 announce AS1 AND
    NOT community(NO_EXPORT)\n   Filters using the routing policy attributes defined
    in the dictionary\n   are evaluated before evaluating the operators AND, OR and
    NOT.\n   Filter Set Name\n      A filter set name matches the set of routes that
    are matched by\n      its filter attribute.  Note that the filter attribute of
    a filter\n      set, can recursively refer to other filter set names.  For example\n
    \     in Figure 17, fltr-foo matches { 5.0.0.0/8, 6.0.0.0/8 }, and\n      fltr-bar
    matches AS1'S routes or { 5.0.0.0/8, 6.0.0.0/8 } if their\n      as path contained
    AS2.\n"
  title: 5.4 Filters and filter-set Class
- contents:
  - "5.5 rtr-set Class\n   The attributes of the rtr-set class are shown in Figure
    18.  The\n   rtr-set attribute defines the name of the set.  It is an RPSL name\n
    \  that starts with \"rtrs-\".  The members attribute lists the members of\n   the
    set.  The members attribute is a list of inet-rtr names,\n   ipv4_addresses or
    other rtr-set names.\n    Attribute    Value                        Type\n    rtr-set
    \     <object-name>                mandatory, single-valued,\n                                              class
    key\n    members      list of <inet-rtr-names> or  optional, multi-valued\n                 <rtr-set-names>\n
    \                or <ipv4_addresses>\n    mbrs-by-ref  list of <mntner-names>
    \      optional, multi-valued\n                    Figure 18:  rtr-set Class Attributes\n
    \  Figure 19 presents two rtr-set objects.  The set rtrs-foo contains\n   two
    routers, namely rtr1.isp.net and rtr2.isp.net.  The set rtrs-bar\n   contains
    the members of the set rtrs-foo and rtr3.isp.net, that is it\n   contains rtr1.isp.net,
    rtr2.isp.net, rtr3.isp.net.\n rtr-set: rtrs-foo                     rtr-set: rtrs-bar\n
    members: rtr1.isp.net, rtr2.isp.net   members: rtr3.isp.net, rtrs-foo\n                        Figure
    19:  rtr-set objects.\n   The mbrs-by-ref attribute is a list of maintainer names
    or the\n   keyword ANY.  If this attribute is used, the router set also includes\n
    \  routers whose inet-rtr objects are registered by one of these\n   maintainers
    and whose member-of attribute refers to the name of this\n   router set.  If the
    value of a mbrs-by-ref attribute is ANY, any\n   inet-rtr object referring to
    the router set is a member of the set.\n   If the mbrs-by-ref attribute is missing,
    only the routers listed in\n   the members attribute are members of the set.\n
    \      rtr-set: rtrs-foo\n       members: rtr1.isp.net, rtr2.isp.net\n       mbrs-by-ref:
    MNTR-ME\n       inet-rtr: rtr3.isp.net\n       local-as: as1\n       ifaddr: 1.1.1.1
    masklen 30\n       member-of: rtrs-foo\n       mnt-by: MNTR-ME\n                              Figure
    20:  rtr-set objects.\n   Figure 20 presents an example rtr-set object that uses
    the mbrs-by-\n   ref attribute.  The set rtrs-foo contains rtr1.isp.net, rtr2.isp.net\n
    \  and rtr3.isp.net.\n"
  title: 5.5 rtr-set Class
- contents:
  - "5.6 Peerings and peering-set Class\n   The attributes of the peering-set class
    are shown in Figure 21.  A\n   peering-set object defines a set of peerings that
    are listed in its\n   peering attributes.  The peering-set attribute defines the
    name of\n   the set.  It is an RPSL name that starts with \"prng-\".\n      Attribute
    \   Value          Type\n      peering-set  <object-name>  mandatory, single-valued,
    class key\n      peering      <peering>      mandatory, multi-valued\n                    Figure
    21:  filter Class Attributes\n   The peering attribute defines a peering that
    can be used for\n   importing or\n     ----------------------                   ----------------------\n
    \    |            7.7.7.1 |-------|   |-------| 7.7.7.2            |\n     |                    |
    \    ========      |                    |\n     |   AS1              |      EX1
    \ |-------| 7.7.7.3     AS2    |\n     |                    |                   |
    \                   |\n     |            9.9.9.1 |------       ------| 9.9.9.2
    \           |\n     ----------------------     |       |     ----------------------\n
    \                              ===========\n                                   |
    \   EX2\n     ----------------------        |\n     |            9.9.9.3 |---------\n
    \    |                    |\n     |   AS3              |\n     ----------------------\n
    \ Figure 22: Example topology consisting of three ASes, AS1, AS2, and\n        AS3;
    two exchange points, EX1 and EX2; and six routers.\n   exporting routes.\n      In
    describing peerings, we are going to use the topology of Figure\n      22.  In
    this topology, there are three ASes, AS1, AS2, and AS3;\n      two exchange points,
    EX1 and EX2; and six routers.  Routers\n      connected to the same exchange point
    peer with each other and\n      exchange routing information.  That is, 7.7.7.1,
    7.7.7.2 and\n      7.7.7.3 peer with each other; 9.9.9.1, 9.9.9.2 and 9.9.9.3
    peer\n      with each other.\n      The syntax of a peering specification is:\n
    \     <as-expression> [<router-expression-1>] [at <router-expression-2>]\n     |
    <peering-set-name>\n      where <as-expression> is an expression over AS numbers
    and AS sets\n      using operators AND, OR, and EXCEPT, and <router-expression-1>
    and\n      <router-expression-2> are expressions over router IP addresses,\n      inet-rtr
    names, and rtr-set names using operators AND, OR, and\n      EXCEPT.  The binary
    \"EXCEPT\" operator is the set subtraction\n      operator and has the same precedence
    as the operator AND (it is\n      semantically equivalent to \"AND NOT\" combination).
    \ That is \"(AS1\n      OR AS2) EXCEPT AS2\" equals \"AS1\".\n      This form
    identifies all the peerings between any local router in\n      <router-expression-2>
    to any of their peer routers in <router-\n      expression-1> in the ASes in <as-expression>.
    \ If <router-\n      expression-2> is not specified, it defaults to all routers
    of the\n      local AS that peer with ASes in <as-expression>.  If <router-\n
    \     expression-1> is not specified, it defaults to all routers of the\n      peer
    ASes in <as-expression> that peer with the local AS.\n      If a <peering-set-name>
    is used, the peerings are listed in the\n      corresponding peering-set object.
    \ Note that the peering-set\n      objects can be recursive.\n      Many special
    forms of this general peering specification is\n      possible.  The following
    examples illustrate the most common\n      cases, using the import attribute of
    the aut-num class.  In the\n      following example 7.7.7.1 imports 128.9.0.0/16
    from 7.7.7.2.\n (1) aut-num: AS1\n     import: from AS2 7.7.7.2 at 7.7.7.1 accept
    { 128.9.0.0/16 }\n   In the following example 7.7.7.1 imports 128.9.0.0/16 from
    7.7.7.2\n   and 7.7.7.3.\n (2) aut-num: AS1\n     import: from AS2 at 7.7.7.1
    accept { 128.9.0.0/16 }\n   In the following example 7.7.7.1 imports 128.9.0.0/16
    from 7.7.7.2\n   and 7.7.7.3, and 9.9.9.1 imports 128.9.0.0/16 from 9.9.9.2.\n
    (3) aut-num: AS1\n     import: from AS2 accept { 128.9.0.0/16 }\n   In the following
    example 9.9.9.1 imports 128.9.0.0/16 from 9.9.9.2\n   and 9.9.9.3.\n (4) as-set:
    AS-FOO\n     members: AS2, AS3\n     aut-num: AS1\n     import: from AS-FOO      at
    9.9.9.1 accept { 128.9.0.0/16 }\n   In the following example 9.9.9.1 imports 128.9.0.0/16
    from 9.9.9.2\n   and 9.9.9.3, and 7.7.7.1 imports 128.9.0.0/16 from 7.7.7.2 and\n
    \  7.7.7.3.\n (5) aut-num: AS1\n     import: from AS-FOO                 accept
    { 128.9.0.0/16 }\n   In the following example AS1 imports 128.9.0.0/16 from AS3
    at router\n   9.9.9.1\n (6) aut-num: AS1\n     import: from AS-FOO and not AS2
    at not 7.7.7.1\n             accept { 128.9.0.0/16 }\n   This is because \"AS-FOO
    and not AS2\" equals AS3 and \"not 7.7.7.1\"\n   equals 9.9.9.1.\n   In the following
    example 9.9.9.1 imports 128.9.0.0/16 from 9.9.9.2\n   and 9.9.9.3.\n (7) peering-set:
    prng-bar\n     peering: AS1 at 9.9.9.1\n     peering-set: prng-foo\n     peering:
    prng-bar\n     peering: AS2 at 9.9.9.1\n     aut-num: AS1\n     import: from prng-foo
    accept { 128.9.0.0/16 }\n"
  title: 5.6 Peerings and peering-set Class
- contents:
  - "6 aut-num Class\n   Routing policies are specified using the aut-num class.  The\n
    \  attributes of the aut-num class are shown in Figure 23.  The value of\n   the
    aut-num attribute is the AS number of the AS described by this\n   object.  The
    as-name attribute is a symbolic name (in RPSL name\n   syntax) of the AS. The
    import, export and default routing policies of\n   the AS are specified using
    import, export and default attributes\n   respectively.\n   Attribute  Value                  Type\n
    \  aut-num    <as-number>            mandatory, single-valued, class key\n   as-name
    \   <object-name>          mandatory, single-valued\n   member-of  list of <as-set-names>
    optional, multi-valued\n   import     see Section 6.1        optional, multi valued\n
    \  export     see Section 6.2        optional, multi valued\n   default    see
    Section 6.5        optional, multi valued\n                    Figure 23:  aut-num
    Class Attributes\n"
  title: 6 aut-num Class
- contents:
  - "6.1 import Attribute:  Import Policy Specification\n   In RPSL, an import policy
    is divided into import policy expressions.\n   Each import policy expression is
    specified using an import attribute.\n   The import attribute has the following
    syntax (we will extend this\n   syntax later in Sections 6.3 and 6.6):\n   import:
    from <peering-1> [action <action-1>]\n            . . .\n            from <peering-N>
    [action <action-N>]\n            accept <filter>\n   The action specification
    is optional.  The semantics of an import\n   attribute is as follows: the set
    of routes that are matched by\n   <filter> are imported from all the peers in
    <peerings>; while\n   importing routes at <peering-M>, <action-M> is executed.\n
    \ E.g.\n    aut-num: AS1\n    import: from AS2 action pref = 1; accept { 128.9.0.0/16
    }\n   This example states that the route 128.9.0.0/16 is accepted from AS2\n   with
    preference 1.  We already presented how peerings (see Section\n   5.6) and filters
    (see Section 5.4) are specified.  We next present\n   how to specify actions.\n"
  title: '6.1 import Attribute:  Import Policy Specification'
- contents:
  - "6.1.1 Action Specification\n   Policy actions in RPSL either set or modify route
    attributes, such as\n   assigning a preference to a route, adding a BGP community
    to the BGP\n   community path attribute, or setting the MULTI-EXIT-DISCRIMINATOR\n
    \  attribute.  Policy actions can also instruct routers to perform\n   special
    operations, such as route flap damping.\n   The routing policy attributes whose
    values can be modified in policy\n   actions are specified in the RPSL dictionary.
    \ Please refer to\n   Section 7 for a list of these attributes.  Each action in
    RPSL is\n   terminated by the semicolon character (';').  It is possible to form\n
    \  composite policy actions by listing them one after the other.  In a\n   composite
    policy action, the actions are executed left to right.  For\n   example,\n aut-num:
    AS1\n import: from AS2\n         action pref = 10; med = 0; community.append(10250,
    3561:10);\n         accept { 128.9.0.0/16 }\n   sets pref to 10, med to 0, and
    then appends 10250 and 3561:10 to the\n   BGP community path attribute.  The pref
    attribute is the inverse of\n   the local-pref attribute (i.e. local-pref == 65535
    - pref).  A route\n   with a local-pref attribute is always preferred over a route
    without\n   one.\n aut-num: AS1\n import: from AS2 action pref = 1;\n         from
    AS3 action pref = 2;\n         accept AS4\n   The above example states that AS4's
    routes are accepted from AS2 with\n   preference 1, and from AS3 with preference
    2 (routes with lower\n   integer preference values are preferred over routes with
    higher\n   integer preference values).\n aut-num: AS1\n import: from AS2 7.7.7.2
    at 7.7.7.1 action pref = 1;\n         from AS2                    action pref
    = 2;\n         accept AS4\n   The above example states that AS4's routes are accepted
    from AS2 on\n   peering 7.7.7.1-7.7.7.2 with preference 1, and on any other peering\n
    \  with AS2 with preference 2.\n"
  title: 6.1.1 Action Specification
- contents:
  - "6.2 export Attribute:  Export Policy Specification\n   Similarly, an export policy
    expression is specified using an export\n   attribute.  The export attribute has
    the following syntax:\n    export: to <peering-1> [action <action-1>]\n            .
    . .\n            to <peering-N> [action <action-N>]\n            announce <filter>\n
    \  The action specification is optional.  The semantics of an export\n   attribute
    is as follows:  the set of routes that are matched by\n   <filter> are exported
    to all the peers specified in <peerings>; while\n   exporting routes at <peering-M>,
    <action-M> is executed.\n  E.g.\n    aut-num: AS1\n    export: to AS2 action med
    = 5; community .= { 70 };\n            announce AS4\n   In this example, AS4's
    routes are announced to AS2 with the med\n   attribute's value set to 5 and community
    70 added to the community\n   list.\n   Example:\n    aut-num: AS1\n    export:
    to AS-FOO announce ANY\n   In this example, AS1 announces all of its routes to
    the ASes in the\n   set AS-FOO.\n"
  title: '6.2 export Attribute:  Export Policy Specification'
- contents:
  - "6.3 Other Routing Protocols, Multi-Protocol Routing Protocols, and\n   Injecting
    Routes Between Protocols\n   The more complete syntax of the import and export
    attributes are as\n   follows:\n    import: [protocol <protocol-1>] [into <protocol-2>]\n
    \           from <peering-1> [action <action-1>]\n            . . .\n            from
    <peering-N> [action <action-N>]\n            accept <filter>\n    export: [protocol
    <protocol-1>] [into <protocol-2>]\n            to <peering-1> [action <action-1>]\n
    \           . . .\n            to <peering-N> [action <action-N>]\n            announce
    <filter>\n   Where the optional protocol specifications can be used for specifying\n
    \  policies for other routing protocols, or for injecting routes of one\n   protocol
    into another protocol, or for multi-protocol routing\n   policies.  The valid
    protocol names are defined in the dictionary.\n   The <protocol-1> is the name
    of the protocol whose routes are being\n   exchanged.  The <protocol-2> is the
    name of the protocol which is\n   receiving these routes.  Both <protocol-1> and
    <protocol-2> default\n   to the Internet Exterior Gateway Protocol, currently
    BGP.\n   In the following example, all interAS routes are injected into RIP.\n
    aut-num: AS1\n import: from AS2 accept AS2\n export: protocol BGP4 into RIP\n
    \        to AS1 announce ANY\n   In the following example, AS1 accepts AS2's routes
    including any more\n   specifics of AS2's routes, but does not inject these extra
    more\n   specific routes into OSPF.\n aut-num: AS1\n import: from AS2 accept AS2^+\n
    export: protocol BGP4 into OSPF\n         to AS1 announce AS2\n   In the following
    example, AS1 injects its static routes (routes which\n   are members of the set
    AS1:RS-STATIC-ROUTES) to the interAS routing\n   protocol and appends AS1 twice
    to their AS paths.\n aut-num: AS1\n import: protocol STATIC into BGP4\n         from
    AS1 action aspath.prepend(AS1, AS1);\n         accept AS1:RS-STATIC-ROUTES\n   In
    the following example, AS1 imports different set of unicast routes\n   for multicast
    reverse path forwarding from AS2:\n aut-num: AS1\n import: from AS2 accept AS2\n
    import: protocol IDMR\n         from AS2 accept AS2:RS-RPF-ROUTES\n"
  title: 6.3 Other Routing Protocols, Multi-Protocol Routing Protocols, and
- contents:
  - "6.4 Ambiguity Resolution\n   It is possible that the same peering can be covered
    by more that one\n   peering specification in a policy expression.  For example:\n
    aut-num: AS1\n import: from AS2 7.7.7.2 at 7.7.7.1 action pref = 2;\n         from
    AS2 7.7.7.2 at 7.7.7.1 action pref = 1;\n         accept AS4\n   This is not an
    error, though definitely not desirable.  To break the\n   ambiguity, the action
    corresponding to the first peering\n   specification is used.  That is the routes
    are accepted with\n   preference 2.  We call this rule as the specification-order
    rule.\n   Consider the example:\n aut-num: AS1\n import: from AS2                    action
    pref = 2;\n         from AS2 7.7.7.2 at 7.7.7.1 action pref = 1; dpa = 5;\n         accept
    AS4\n   where both peering specifications cover the peering 7.7.7.1-7.7.7.2,\n
    \  though the second one covers it more specifically.  The specification\n   order
    rule still applies, and only the action \"pref = 2\" is executed.\n   In fact,
    the second peering-action pair has no use since the first\n   peering-action pair
    always covers it.  If the intended policy was to\n   accept these routes with
    preference 1 on this particular peering and\n   with preference 2 in all other
    peerings, the user should have\n   specified:\n aut-num: AS1\n import: from AS2
    7.7.7.2 at 7.7.7.1 action pref = 1; dpa = 5;\n         from AS2                    action
    pref = 2;\n         accept AS4\n   It is also possible that more than one policy
    expression can cover\n   the same set of routes for the same peering.  For example:\n
    aut-num: AS1\n import: from AS2 action pref = 2; accept AS4\n import: from AS2
    action pref = 1; accept AS4\n   In this case, the specification-order rule is
    still used.  That is,\n   AS4's routes are accepted from AS2 with preference 2.
    \ If the filters\n   were overlapping but not exactly the same:\n aut-num: AS1\n
    import: from AS2 action pref = 2; accept AS4\n import: from AS2 action pref =
    1; accept AS4 OR AS5\n   the AS4's routes are accepted from AS2 with preference
    2 and however\n   AS5's routes are also accepted, but with preference 1.\n   We
    next give the general specification order rule for the benefit of\n   the RPSL
    implementors.  Consider two policy expressions:\n aut-num: AS1\n import: from
    peerings-1 action action-1 accept filter-1\n import: from peerings-2 action action-2
    accept filter-2\n   The above policy expressions are equivalent to the following
    three\n   expressions where there is no ambiguity:\n aut-num: AS1\n import: from
    peerings-1 action action-1 accept filter-1\n import: from peerings-3 action action-2
    accept filter-2 AND NOT filter-1\n import: from peerings-4 action action-2 accept
    filter-2\n   where peerings-3 are those that are covered by both peerings-1 and\n
    \  peerings-2, and peerings-4 are those that are covered by peerings-2\n   but
    not by peerings-1 (\"filter-2 AND NOT filter-1\" matches the routes\n   that are
    matched by filter-2 but not by filter-1).\n   Example:\n aut-num: AS1\n import:
    from AS2 7.7.7.2 at 7.7.7.1\n         action pref = 2;\n         accept {128.9.0.0/16}\n
    import: from AS2\n         action pref = 1;\n         accept {128.9.0.0/16, 75.0.0.0/8}\n
    \  Lets consider two peerings with AS2, 7.7.7.1-7.7.7.2 and 9.9.9.1-\n   9.9.9.2.
    \ Both policy expressions cover 7.7.7.1-7.7.7.2.  On this\n   peering, the route
    128.9.0.0/16 is accepted with preference 2, and\n   the route 75.0.0.0/8 is accepted
    with preference 1.  The peering\n   9.9.9.1-9.9.9.2 is only covered by the second
    policy expressions.\n   Hence, both the route 128.9.0.0/16 and the route 75.0.0.0/8
    are\n   accepted with preference 1 on peering 9.9.9.1-9.9.9.2.\n   Note that the
    same ambiguity resolution rules also apply to export\n   and default policy expressions.\n"
  title: 6.4 Ambiguity Resolution
- contents:
  - "6.5 default Attribute:  Default Policy Specification\n   Default routing policies
    are specified using the default attribute.\n   The default attribute has the following
    syntax:\n    default: to <peering> [action <action>] [networks <filter>]\n   The
    <action> and <filter> specifications are optional.  The semantics\n   are as follows:
    \ The <peering> specification indicates the AS (and\n   the router if present)
    is being defaulted to; the <action>\n   specification, if present, indicates various
    attributes of\n   defaulting, for example a relative preference if multiple defaults\n
    \  are specified; and the <filter> specifications, if present, is a\n   policy
    filter.  A router only uses the default policy if it received\n   the routes matched
    by <filter> from this peer.\n   In the following example, AS1 defaults to AS2
    for routing.\n aut-num: AS1\n default: to AS2\n   In the following example, router
    7.7.7.1 in AS1 defaults to router\n   7.7.7.2 in AS2.\n aut-num: AS1\n default:
    to AS2 7.7.7.2 at 7.7.7.1\n   In the following example, AS1 defaults to AS2 and
    AS3, but prefers\n   AS2 over AS3.\n aut-num: AS1\n default: to AS2 action pref
    = 1;\n default: to AS3 action pref = 2;\n   In the following example, AS1 defaults
    to AS2 and uses 128.9.0.0/16\n   as the default network.\n aut-num: AS1\n default:
    to AS2 networks { 128.9.0.0/16 }\n"
  title: '6.5 default Attribute:  Default Policy Specification'
- contents:
  - "6.6 Structured Policy Specification\n   The import and export policies can be
    structured.  We only reccomend\n   structured policies to advanced RPSL users.
    \ Please feel free to skip\n   this section.\n   The syntax for a structured policy
    specification is the following:\n   <import-factor> ::= from <peering-1> [action
    <action-1>]\n                       . . .\n                       from <peering-N>
    [action <action-N>]\n                       accept <filter>;\n   <import-term>
    ::=  <import-factor> |\n                      LEFT-BRACE\n                      <import-factor>\n
    \                     . . .\n                      <import-factor>\n                      RIGHT-BRACE\n
    \  <import-expression> ::= <import-term>                            |\n                           <import-term>
    EXCEPT <import-expression> |\n                           <import-term> REFINE
    <import-expression>\n   import: [protocol <protocol1>] [into <protocol2>]\n           <import-expression>\n
    \  Please note the semicolon at the end of an <import-factor>.  If the\n   policy
    specification is not structured (as in all the examples in\n   other sections),
    this semicolon is optional.  The syntax and\n   semantics for an <import-factor>
    is already defined in Section 6.1.\n   An <import-term> is either a sequence of
    <import-factor>'s enclosed\n   within matching braces (i.e. `{' and `}') or just
    a single <import-\n   factor>.  The semantics of an <import-term> is the union
    of <import-\n   factor>'s using the specification order rule.  An <import-expression>\n
    \  is either a single <import-term> or an <import-term> followed by one\n   of
    the keywords \"except\" and \"refine\", followed by another <import-\n   expression>.
    \ Note that our definition allows nested expressions.\n   Hence there can be exceptions
    to exceptions, refinements to\n   refinements, or even refinements to exceptions,
    and so on.\n   The semantics for the except operator is as follows: The result
    of an\n   except operation is another <import-term>.  The resulting policy set\n
    \  contains the policies of the right hand side but their filters are\n   modified
    to only include the routes also matched by the left hand\n   side.  The policies
    of the left hand side are included afterwards and\n   their filters are modified
    to exclude the routes matched by the right\n   hand side.  Please note that the
    filters are modified during this\n   process but the actions are copied verbatim.
    \ When there are multiple\n   levels of nesting, the operations (both except and
    refine) are\n   performed right to left.\n   Consider the following example:\n
    import: from AS1 action pref = 1; accept as-foo;\n         except {\n            from
    AS2 action pref = 2; accept AS226;\n            except {\n               from
    AS3 action pref = 3; accept {128.9.0.0/16};\n            }\n         }\n   where
    the route 128.9.0.0/16 is originated by AS226, and AS226 is a\n   member of the
    as set as-foo.  In this example, the route 128.9.0.0/16\n   is accepted from AS3,
    any other route (not 128.9.0.0/16) originated\n   by AS226 is accepted from AS2,
    and any other ASes' routes in as-foo\n   is accepted from AS1.\n   We can come
    to the same conclusion using the algebra defined above.\n   Consider the inner
    exception specification:\n   from AS2 action pref = 2; accept AS226;\n   except
    {\n      from AS3 action pref = 3; accept {128.9.0.0/16};\n   }\n is equivalent
    to\n  {\n   from AS3 action pref = 3; accept AS226 AND {128.9.0.0/16};\n   from
    AS2 action pref = 2; accept AS226 AND NOT {128.9.0.0/16};\n  }\n Hence, the original
    expression is equivalent to:\n import: from AS1 action pref = 1; accept as-foo;\n
    \        except {\n            from AS3 action pref = 3; accept AS226 AND {128.9.0.0/16};\n
    \           from AS2 action pref = 2; accept AS226 AND NOT {128.9.0.0/16};\n         }\n
    which is equivalent to\n"
  - "import: {\n   from AS3 action pref = 3;\n            accept as-foo AND AS226
    AND {128.9.0.0/16};\n   from AS2 action pref = 2;\n            accept as-foo AND
    AS226 AND NOT {128.9.0.0/16};\n   from AS1 action pref = 1;\n            accept
    as-foo AND NOT\n              (AS226 AND NOT {128.9.0.0/16} OR AS226 AND {128.9.0.0/16});\n
    \  }\n Since AS226 is in as-foo and 128.9.0.0/16 is in AS226, it simplifies\n
    to:\n"
  - "import: {\n          from AS3 action pref = 3; accept {128.9.0.0/16};\n          from
    AS2 action pref = 2; accept AS226 AND NOT {128.9.0.0/16};\n          from AS1
    action pref = 1; accept as-foo AND NOT AS226;\n        }\n   In the case of the
    refine operator, the resulting set is constructed\n   by taking the cartasian
    product of the two sides as follows:  for\n   each policy l in the left hand side
    and for each policy r in the\n   right hand side, the peerings of the resulting
    policy are the\n   peerings common to both r and l; the filter of the resulting
    policy\n   is the intersection of l's filter and r's filter; and action of the\n
    \  resulting policy is l's action followed by r's action.  If there are\n   no
    common peerings, or if the intersection of filters is empty, a\n   resulting policy
    is not generated.\n   Consider the following example:\n import: { from AS-ANY
    action pref = 1; accept community(3560:10);\n           from AS-ANY action pref
    = 2; accept community(3560:20);\n         } refine {\n            from AS1 accept
    AS1;\n            from AS2 accept AS2;\n            from AS3 accept AS3;\n         }\n
    \  Here, any route with community 3560:10 is assigned a preference of 1\n   and
    any route with community 3560:20 is assigned a preference of 2\n   regardless
    of whom they are imported from.  However, only AS1's\n   routes are imported from
    AS1, and only AS2's routes are imported from\n   AS2, and only AS3's routes are
    imported form AS3, and no routes are\n   imported from any other AS. We can reach
    the same conclusion using\n   the above algebra.  That is, our example is equivalent
    to:\n import: {\n   from AS1 action pref = 1; accept community(3560:10) AND AS1;\n
    \  from AS1 action pref = 2; accept community(3560:20) AND AS1;\n   from AS2 action
    pref = 1; accept community(3560:10) AND AS2;\n   from AS2 action pref = 2; accept
    community(3560:20) AND AS2;\n   from AS3 action pref = 1; accept community(3560:10)
    AND AS3;\n   from AS3 action pref = 2; accept community(3560:20) AND AS3;\n }\n
    \  Note that the common peerings between \"from AS1\" and \"from AS-ANY\"\n   are
    those peerings in \"from AS1\".  Even though we do not formally\n   define \"common
    peerings\", it is straight forward to deduce the\n   definition from the definitions
    of peerings (please see Section 5.6).\n   Consider the following example:\n import:
    {\n   from AS-ANY action med = 0; accept {0.0.0.0/0^0-18};\n   } refine {\n        from
    AS1 at 7.7.7.1 action pref = 1; accept AS1;\n        from AS1            action
    pref = 2; accept AS1;\n     }\n   where only routes of length 0 to 18 are accepted
    and med's value is\n   set to 0 to disable med's effect for all peerings; In addition,
    from\n   AS1 only AS1's routes are imported, and AS1's routes imported at\n   7.7.7.1
    are preferred over other peerings.  This is equivalent to:\n import: {\n      from
    AS1 at 7.7.7.1 action med=0; pref=1; accept {0.0.0.0/0^0-\n"
  - "18} AND AS1;\n    from  AS1             action med=0; pref=2; accept {0.0.0.0/0^0-\n"
  - "18} AND AS1;\n }\n   The above syntax and semantics also apply equally to structured\n
    \  export policies with \"from\" replaced with \"to\" and \"accept\" is\n   replaced
    with \"announce\".\n"
  title: 6.6 Structured Policy Specification
- contents:
  - "7 dictionary Class\n   The dictionary class provides extensibility to RPSL. Dictionary\n
    \  objects define routing policy attributes, types, and routing\n   protocols.
    \ Routing policy attributes, henceforth called rp-\n   attributes, may correspond
    to actual protocol attributes, such as the\n   BGP path attributes (e.g. community,
    dpa, and AS-path), or they may\n   correspond to router features (e.g. BGP route
    flap damping).  As new\n   protocols, new protocol attributes, or new router features
    are\n   introduced, the dictionary object is updated to include appropriate\n
    \  rp-attribute and protocol definitions.\n   An rp-attribute is an abstract class;
    that is a data representation\n   is not available.  Instead, they are accessed
    through access methods.\n   For example, the rp-attribute for the BGP AS-path
    attribute is called\n   aspath; and it has an access method called prepend which
    stuffs extra\n   AS numbers to the AS-path attributes.  Access methods can take\n
    \  arguments.  Arguments are strongly typed.  For example, the method\n   prepend
    above takes AS numbers as arguments.\n   Once an rp-attribute is defined in the
    dictionary, it can be used to\n   describe policy filters and actions.  Policy
    analysis tools are\n   required to fetch the dictionary object and recognize newly
    defined\n   rp-attributes, types, and protocols.  The analysis tools may\n   approximate
    policy analyses on rp-attributes that they do not\n   understand:  a filter method
    may always match, and an action method\n   may always perform no-operation.  Analysis
    tools may even download\n   code to perform appropriate operations using mechanisms
    outside the\n   scope of RPSL.\n   We next describe the syntax and semantics of
    the dictionary class.\n   This description is not essential for understanding
    dictionary\n   objects (but it is essential for creating one).  Please feel free
    to\n   skip to the RPSL Initial Dictionary subsection (Section 7.1).\n   The attributes
    of the dictionary class are shown in Figure 24.  The\n   dictionary attribute
    is the name of the dictionary object, obeying\n   the RPSL naming rules.  There
    can be many dictionary objects, however\n   there is always one well-known dictionary
    object \"RPSL\". All tools\n   use this dictionary by default.\n Attribute     Value
    \                  Type\n dictionary    <object-name>           mandatory, single-valued,\n
    \                                      class key\n rp-attribute  see description
    in text optional, multi valued\n typedef       see description in text optional,
    multi valued\n protocol      see description in text optional, multi valued\n
    \                 Figure 24:  dictionary Class Attributes\n   The rp-attribute
    attribute has the following syntax:\n   rp-attribute: <name>\n      <method-1>(<type-1-1>,
    ..., <type-1-N1> [, \"...\"])\n      ...\n      <method-M>(<type-M-1>, ..., <type-M-NM>
    [, \"...\"])\n   where <name> is the name of the rp-attribute; and <method-i>
    is the\n   name of an access method for the rp-attribute, taking Ni arguments\n
    \  where the j-th argument is of type <type-i-j>.  A method name is\n   either
    an RPSL name or one of the operators defined in Figure 25.\n   The operator methods
    with the exception of operator() and operator[]\n   can take only one argument.\n
    \  operator=           operator==\n   operator<<=         operator<\n   operator>>=
    \        operator>\n   operator+=          operator>=\n   operator-=          operator<=\n
    \  operator*=          operator!=\n   operator/=          operator()\n   operator.=
    \         operator[]\n                           Figure 25:  Operators\n   An
    rp-attribute can have many methods defined for it.  Some of the\n   methods may
    even have the same name, in which case their arguments\n   are of different types.
    \ If the argument list is followed by \"...\",\n   the method takes a variable
    number of arguments.  In this case, the\n   actual arguments after the Nth argument
    are of type <type-N>.\n   Arguments are strongly typed.  A <type> in RPSL is either
    a\n   predefined type, a union type, a list type, or a dictionary defined\n   type.
    \ The predefined types are listed in Figure 26.\n   integer[lower, upper]              ipv4_address\n
    \  real[lower, upper]                 address_prefix\n   enum[name, name, ...]
    \             address_prefix_range\n   string                             dns_name\n
    \  boolean                            filter\n   rpsl_word                          as_set_name\n
    \  free_text                          route_set_name\n   email                              rtr_set_name\n
    \  as_number                          filter_set_name\n                                      peering_set_name\n
    \                       Figure 26:  Predefined Types\n   The integer and the real
    predefined types can be followed by a lower\n   and an upper bound to specify
    the set of valid values of the\n   argument.  The range specification is optional.
    \ We use the ANSI C\n   language conventions for representing integer, real and
    string\n   values.  The enum type is followed by a list of RPSL names which are\n
    \  the valid values of the type.  The boolean type can take the values\n   true
    or false.  as_number, ipv4_address, address_prefix and dns_name\n   types are
    as in Section 2.  filter type is a policy filter as in\n   Section 6.  The value
    of filter type is suggested to be enclosed in\n   parenthesis.\n   The syntax
    of a union type is as follows:\n    union <type-1>, ... , <type-N>\n   where <type-i>
    is an RPSL type.  The union type is either of the\n   types <type-1> through <type-N>
    (analogous to unions in C[14]).\n   The syntax of a list type is as follows:\n
    \  list [<min_elems>:<max_elems>] of <type>\n   In this case, the list elements
    are of <type> and the list contains\n   at least <min_elems> and at most <max_elems>
    elements.  The size\n   specification is optional.  If it is not specified, there
    is no\n   restriction in the number of list elements.  A value of a list type\n
    \  is represented as a sequence of elements separated by the character\n   \",\"
    and enclosed by the characters \"{\" and \"}\".\n   The typedef attribute in the
    dictionary defines named types as\n   follows:\n   typedef: <name> <type>\n   where
    <name> is a name for type <type>.  typedef attribute is\n   paticularly useful
    when the type defined is not a predefined type\n   (e.g. list of unions, list
    of lists, etc.).\n   A protocol attribute of the dictionary class defines a protocol
    and a\n   set of peering parameters for that protocol (which are used in inet-\n
    \  rtr class in Section 9).  Its syntax is as follows:\n   protocol: <name>\n
    \   MANDATORY | OPTIONAL <parameter-1>(<type-1-1>,...,\n                         <type-1-N1>
    [,\"...\"])\n      ...\n    MANDATORY | OPTIONAL <parameter-M>(<type-M-1>,...,\n
    \                        <type-M-NM> [,\"...\"])\n   where <name> is the name
    of the protocol; MANDATORY and OPTIONAL are\n   keywords; and <parameter-i> is
    a peering parameter for this protocol,\n   taking Ni many arguments.  The syntax
    and semantics of the arguments\n   are as in the rp-attribute.  If the keyword
    MANDATORY is used, the\n   parameter is mandatory and needs to be specified for
    each peering of\n   this protocol.  If the keyword OPTIONAL is used, the parameter
    can be\n   skipped.\n"
  title: 7 dictionary Class
- contents:
  - '7.1 Initial RPSL Dictionary and Example Policy Actions and Filters

    '
  title: 7.1 Initial RPSL Dictionary and Example Policy Actions and Filters
- contents:
  - 'dictionary:   RPSL

    '
  title: 'dictionary:   RPSL'
- contents:
  - "rp-attribute: # preference, smaller values represent higher preferences\n              pref\n
    \             operator=(integer[0, 65535])\n"
  title: 'rp-attribute: # preference, smaller values represent higher preferences'
- contents:
  - "rp-attribute: # BGP multi_exit_discriminator attribute\n              med\n              #
    to set med to 10: med = 10;\n              # to set med to the IGP metric: med
    = igp_cost;\n              operator=(union integer[0, 65535], enum[igp_cost])\n"
  title: 'rp-attribute: # BGP multi_exit_discriminator attribute'
- contents:
  - "rp-attribute: # BGP destination preference attribute (dpa)\n              dpa\n
    \             operator=(integer[0, 65535])\n"
  title: 'rp-attribute: # BGP destination preference attribute (dpa)'
- contents:
  - "rp-attribute: # BGP aspath attribute\n              aspath\n              # prepends
    AS numbers from last to first order\n              prepend(as_number, ...)\n"
  title: 'rp-attribute: # BGP aspath attribute'
- contents:
  - "typedef:      # a community value in RPSL is either\n              #  - a 4 byte
    integer (ok to use 3561:70 notation)\n              #  - internet, no_export,
    no_advertise (see RFC-1997)\n              community_elm union\n                  integer[1,
    4294967295],\n                  enum[internet, no_export, no_advertise],\n"
  title: 'typedef:      # a community value in RPSL is either'
- contents:
  - "typedef:      # list of community values { 40, no_export, 3561:70 }\n              community_list
    list of community_elm\n"
  title: 'typedef:      # list of community values { 40, no_export, 3561:70 }'
- contents:
  - "rp-attribute: # BGP community attribute\n              community\n              #
    set to a list of communities\n              operator=(community_list)\n              #
    append community values\n              operator.=(community_list)\n              append(community_elm,
    ...)\n              # delete community values\n              delete(community_elm,
    ...)\n              # a filter: true if one of community values is contained\n
    \             contains(community_elm, ...)\n              # shortcut to contains:
    community(no_export, 3561:70)\n              operator()(community_elm, ...)\n
    \             # order independent equality comparison\n              operator==(community_list)\n"
  title: 'rp-attribute: # BGP community attribute'
- contents:
  - "rp-attribute: # next hop router in a static route\n              next-hop\n              #
    to set to 7.7.7.7: next-hop = 7.7.7.7;\n              # to set to router's own
    address: next-hop = self;\n              operator=(union ipv4_address, enum[self])\n"
  title: 'rp-attribute: # next hop router in a static route'
- contents:
  - "rp-attribute: # cost of a static route\n              cost\n              operator=(integer[0,
    65535])\n"
  title: 'rp-attribute: # cost of a static route'
- contents:
  - "protocol: BGP4\n          # as number of the peer router\n          MANDATORY
    asno(as_number)\n          # enable flap damping\n          OPTIONAL flap_damp()\n
    \         OPTIONAL flap_damp(integer[0,65535],\n                             #
    penalty per flap\n                             integer[0,65535],\n                             #
    penalty value for supression\n                             integer[0,65535],\n
    \                            # penalty value for reuse\n                             integer[0,65535],\n
    \                            # halflife in secs when up\n                             integer[0,65535],\n
    \                            # halflife in secs when down\n                             integer[0,65535])\n
    \                            # maximum penalty\n"
  title: 'protocol: BGP4'
- contents:
  - 'protocol: OSPF

    '
  title: 'protocol: OSPF'
- contents:
  - 'protocol: RIP

    '
  title: 'protocol: RIP'
- contents:
  - 'protocol: IGRP

    '
  title: 'protocol: IGRP'
- contents:
  - 'protocol: IS-IS

    '
  title: 'protocol: IS-IS'
- contents:
  - 'protocol: STATIC

    '
  title: 'protocol: STATIC'
- contents:
  - 'protocol: RIPng

    '
  title: 'protocol: RIPng'
- contents:
  - 'protocol: DVMRP

    '
  title: 'protocol: DVMRP'
- contents:
  - 'protocol: PIM-DM

    '
  title: 'protocol: PIM-DM'
- contents:
  - 'protocol: PIM-SM

    '
  title: 'protocol: PIM-SM'
- contents:
  - 'protocol: CBT

    '
  title: 'protocol: CBT'
- contents:
  - "protocol: MOSPF\n                        Figure 27:  RPSL Dictionary\n   Figure
    27 shows the initial RPSL dictionary.  It has seven rp-\n   attributes:  pref
    to assign local preference to the routes accepted;\n   med to assign a value to
    the MULTI_EXIT_DISCRIMINATOR BGP attribute;\n   dpa to assign a value to the DPA
    BGP attribute; aspath to prepend a\n   value to the AS_PATH BGP attribute; community
    to assign a value to or\n   to check the value of the community BGP attribute;
    next-hop to assign\n   next hop routers to static routes; and cost to assign a
    cost to\n   static routes.  The dictionary defines two types:  community_elm and\n
    \  community_list.  community_elm type is either a 4-byte unsigned\n   integer,
    or one of the keywords internet, no_export or no_advertise\n   (defined in [9]).
    \ An integer can be specified using two 2-byte\n   integers seperated by \":\"
    \ to partition the community number space so\n   that a provider can use its AS
    number as the first two bytes, and\n   assigns a semantics of its choice to the
    last two bytes.\n   The initial dictionary (Figure 27) defines only options for
    the\n   Border Gateway Protocol:  asno and flap_damp.  The mandatory asno\n   option
    is the AS number of the peer router.  The optional flap_damp\n   option instructs
    the router to damp route flaps [21] when importing\n   routes from the peer router.\n
    \  It can be specified with or without parameters.  If parameters are\n   missing,
    they default to:\n   flap_damp(1000, 2000, 750, 900, 900, 20000)\n   That is,
    a penalty of 1000 is assigned at each route flap, the route\n   is suppressed
    when penalty reaches 2000.  The penalty is reduced in\n   half after 15 minutes
    (900 seconds) of stability regardless of\n   whether the route is up or down.
    \ A supressed route is reused when\n   the penalty falls below 750.  The maximum
    penalty a route can be\n   assigned is 20,000 (i.e. the maximum suppress time
    after a route\n   becomes stable is about 75 minutes).  These parameters are consistent\n
    \  with the default flap damping parameters in several routers.\n"
  title: 'protocol: MOSPF'
- contents:
  - "Policy Actions and Filters Using RP-Attributes\n   The syntax of a policy action
    or a filter using an rp-attribute x is\n   as follows:\n    x.method(arguments)\n
    \   x \"op\" argument\n   where method is a method and \"op\" is an operator method
    of the rp-\n   attribute x.  If an operator method is used in specifying a composite\n
    \  policy filter, it evaluates earlier than the composite policy filter\n   operators
    (i.e. AND, OR, NOT, and implicit or operator).\n   The pref rp-attribute can be
    assigned a positive integer as follows:\n   pref = 10;\n   The med rp-attribute
    can be assigned either a positive integer or the\n   word \"igp_cost\" as follows:\n
    \  med = 0;\n   med = igp_cost;\n   The dpa rp-attribute can be assigned a positive
    integer as follows:\n   dpa = 100;\n   The BGP community attribute is list-valued,
    that is it is a list of\n   4-byte integers each representing a \"community\".
    \ The following\n   examples demonstrate how to add communities to this rp-attribute:\n
    \  community .= { 100 };\n   community .= { NO_EXPORT };\n   community .= { 3561:10
    };\n   In the last case, a 4-byte integer is constructed where the more\n   significant
    two bytes equal 3561 and the less significant two bytes\n   equal 10.  The following
    examples demonstrate how to delete\n   communities from the community rp-attribute:\n
    \  community.delete(100, NO_EXPORT, 3561:10);\n   Filters that use the community
    rp-attribute can be defined as\n   demonstrated by the following examples:\n   community.contains(100,
    NO_EXPORT, 3561:10);\n   community(100, NO_EXPORT, 3561:10);             # shortcut\n
    \  The community rp-attribute can be set to a list of communities as\n   follows:\n
    \  community = {100, NO_EXPORT, 3561:10, 200};\n   community = {};\n   In this
    first case, the community rp-attribute contains the\n   communities 100, NO_EXPORT,
    3561:10, and 200.  In the latter case,\n   the community rp-attribute is cleared.
    \ The community rp-attribute\n   can be compared against a list of communities
    as follows:\n   community == {100, NO_EXPORT, 3561:10, 200};   # exact match\n
    \  To influence the route selection, the BGP as_path rp-attribute can be\n   made
    longer by prepending AS numbers to it as follows:\n   aspath.prepend(AS1);\n   aspath.prepend(AS1,
    AS1, AS1);\n   The following examples are invalid:\n   med = -50;                     #
    -50 is not in the range\n   med = igp;                     # igp is not one of
    the enum values\n   med.assign(10);                # method assign is not defined\n
    \  community.append(AS3561:20);   # the first argument should be 3561\n   Figure
    28 shows a more advanced example using the rp-attribute\n   community.  In this
    example, AS3561 bases its route selection\n   preference on the community attribute.
    \ Other ASes may indirectly\n   affect AS3561's route selection by including the
    appropriate\n   communities in their route announcements.\n    aut-num: AS1\n
    \   export: to AS2 action community.={3561:90};\n            to AS3 action community.={3561:80};\n
    \           announce AS1\n    as-set: AS3561:AS-PEERS\n    members: AS2, AS3\n
    \   aut-num: AS3561\n    import: from AS3561:AS-PEERS\n            action pref
    = 10;\n            accept community(3561:90)\n    import: from AS3561:AS-PEERS\n
    \           action pref = 20;\n            accept community(3561:80)\n    import:
    from AS3561:AS-PEERS\n            action pref = 20;\n            accept community(3561:70)\n
    \   import: from AS3561:AS-PEERS\n            action pref = 0;\n            accept
    ANY\n           Figure 28:  Policy example using the community rp-attribute.\n"
  title: Policy Actions and Filters Using RP-Attributes
- contents:
  - '8 Advanced route Class

    '
  title: 8 Advanced route Class
- contents:
  - "8.1 Specifying Aggregate Routes\n   The components, aggr-bndry, aggr-mtd, export-comps,
    inject, and holes\n   attributes are used for specifying aggregate routes [11].
    \ A route\n   object specifies an aggregate route if any of these attributes,
    with\n   the exception of inject, is specified.  The origin attribute for an\n
    \  aggregate route is the AS performing the aggregation, i.e. the\n   aggregator
    AS. In this section, we used the term \"aggregate\" to refer\n   to the route
    generated, the term \"component\" to refer to the routes\n   used to generate
    the path attributes of the aggregate, and the term\n   \"more specifics\" to refer
    to any route which is a more specific of\n   the aggregate regardless of whether
    it was used to form the path\n   attributes.\n   The components attribute defines
    what component routes are used to\n   form the aggregate.  Its syntax is as follows:\n
    \  components: [ATOMIC] [[<filter>] [protocol <protocol> <filter> ...]]\n   where
    <protocol> is a routing protocol name such as BGP4, OSPF or RIP\n   (valid names
    are defined in the dictionary) and <filter> is a policy\n   expression.  The routes
    that match one of these filters and are\n   learned from the corresponding protocol
    are used to form the\n   aggregate.  If <protocol> is omitted, it defaults to
    any protocol.\n   <filter> implicitly contains an \"AND\" term with the more specifics
    of\n   the aggregate so that only the component routes are selected.  If the\n
    \  keyword ATOMIC is used, the aggregation is done atomically [11].  If\n   a
    <filter> is not specified it defaults to more specifics.  If the\n   components
    attribute is missing, all more specifics without the\n   ATOMIC keyword is used.\n
    \  route: 128.8.0.0/15\n   origin: AS1\n   components: <^AS2>\n   route: 128.8.0.0/15\n
    \  origin: AS1\n   components: protocol BGP4 {128.8.0.0/16^+}\n               protocol
    OSPF {128.9.0.0/16^+}\n                  Figure 29:  Two aggregate route objects.\n
    \  Figure 29 shows two route objects.  In the first example, more\n   specifics
    of 128.8.0.0/15 with AS paths starting with AS2 are\n   aggregated.  In the second
    example, some routes learned from BGP and\n   some routes learned form OSPF are
    aggregated.\n   The aggr-bndry attribute is an AS expression over AS numbers and
    sets\n   (see Section 5.6).  The result defines the set of ASes which form the\n
    \  aggregation boundary.  If the aggr-bndry attribute is missing, the\n   origin
    AS is the sole aggregation boundary.  Outside the aggregation\n   boundary, only
    the aggregate is exported and more specifics are\n   suppressed.  However, within
    the boundary, the more specifics are\n   also exchanged.\n   The aggr-mtd attribute
    specifies how the aggregate is generated.  Its\n   syntax is as follows:\n  aggr-mtd:
    inbound\n          | outbound [<as-expression>]\n   where <as-expression> is an
    expression over AS numbers and sets (see\n   Section 5.6).  If <as-expression>
    is missing, it defaults to AS-ANY.\n   If outbound aggregation is specified, the
    more specifics of the\n   aggregate will be present within the AS and the aggregate
    will be\n   formed at all inter-AS boundaries with ASes in <as-expression> before\n
    \  export, except for ASes that are within the aggregating boundary\n   (i.e.
    aggr-bndry is enforced regardless of <as-expression>).  If\n   inbound aggregation
    is specified, the aggregate is formed at all\n   inter-AS boundaries prior to
    importing routes into the aggregator AS.\n   Note that <as-expression> can not
    be specified with inbound\n   aggregation.  If aggr-mtd attribute is missing,
    it defaults to\n   \"outbound AS-ANY\".\n   route:      128.8.0.0/15            route:
    \     128.8.0.0/15\n   origin:     AS1                     origin:     AS2\n   components:
    {128.8.0.0/15^-}        components: {128.8.0.0/15^-}\n   aggr-bndry: AS1 OR AS2
    \             aggr-bndry: AS1 OR AS2\n   aggr-mtd:   outbound AS-ANY         aggr-mtd:
    \  outbound AS-ANY\n             Figure 30:  Outbound multi-AS aggregation example.\n
    \  Figure 30 shows an example of an outbound aggregation.  In this\n   example,
    AS1 and AS2 are coordinating aggregation and announcing only\n   the less specific
    128.8.0.0/15 to outside world, but exchanging more\n   specifics between each
    other.  This form of aggregation is useful\n   when some of the components are
    within AS1 and some are within AS2.\n   When a set of routes are aggregated, the
    intent is to export only the\n   aggregate route and suppress exporting of the
    more specifics outside\n   the aggregation boundary.  However, to satisfy certain
    policy and\n   topology constraints (e.g. a multi-homed component), it is often\n
    \  required to export some of the components.  The export-comps\n   attribute
    equals an RPSL filter that matches the more specifics that\n   need to be exported
    outside the aggregation boundary.  If this\n   attribute is missing, more specifics
    are not exported outside the\n   aggregation boundary.  Note that, the export-comps
    filter contains an\n   implicit \"AND\" term with the more specifics of the aggregate.\n
    \  Figure 31 shows an example of an outbound aggregation.  In this\n   example,
    the more specific 128.8.8.0/24 is exported outside AS1 in\n   addition to the
    aggregate.  This is useful, when 128.8.8.0/24 is\n   multi-homed site to AS1 with
    some other AS.\n      route:      128.8.0.0/15\n      origin:     AS1\n      components:
    {128.8.0.0/15^-}\n      aggr-mtd:   outbound AS-ANY\n      export-comps: {128.8.8.0/24}\n
    \            Figure 31:  Outbound aggregation with export exception.\n   The inject
    attribute specifies which routers perform the aggregation\n   and when they perform
    it.  Its syntax is as follow:\n  inject: [at <router-expression>] ...\n          [action
    <action>]\n          [upon <condition>]\n   where <action> is an action specification
    (see Section 6.1.1),\n   <condition> is a boolean expression described below,
    and <router-\n   expression> is as described in Section 5.6.\n   All routers in
    <router-expression> and in the aggregator AS perform\n   the aggregation.  If
    a <router-expression> is not specified, all\n   routers inside the aggregator
    AS perform the aggregation.  The\n   <action> specification may set path attributes
    of the aggregate, such\n   as assign a preferences to the aggregate.\n   The upon
    clause is a boolean condition.  The aggregate is generated\n   if and only if
    this condition is true.  <condition> is a boolean\n   expression using the logical
    operators AND and OR (i.e. operator NOT\n   is not allowed) over:\n   HAVE-COMPONENTS
    { list of prefixes }\n   EXCLUDE { list of prefixes }\n   STATIC\n   The list
    of prefixes in HAVE-COMPONENTS can only be more specifics of\n   the aggregate.
    \ It evaluates to true when all the prefixes listed are\n   present in the routing
    table of the aggregating router.  The list can\n   also include prefix ranges
    (i.e. using operators ^-, ^+, ^n, and ^n-\n   m).  In this case, at least one
    prefix from each prefix range needs\n   to be present in the routing table for
    the condition to be true.  The\n   list of prefixes in EXCLUDE can be arbitrary.
    \ It evaluates to true\n   when none of the prefixes listed is present in the
    routing table.\n   The list can also include prefix ranges, and no prefix in that
    range\n   should be present in the routing table.  The keyword static always\n
    \  evaluates to true.  If no upon clause is specified the aggregate is\n   generated
    if an only if there is a component in the routing table\n   (i.e. a more specific
    that matches the filter in the components\n   attribute).\n   route:      128.8.0.0/15\n
    \  origin:     AS1\n   components: {128.8.0.0/15^-}\n   aggr-mtd:   outbound AS-ANY\n
    \  inject:     at 1.1.1.1 action dpa = 100;\n   inject:     at 1.1.1.2 action
    dpa = 110;\n   route:      128.8.0.0/15\n   origin:     AS1\n   components: {128.8.0.0/15^-}\n
    \  aggr-mtd:   outbound AS-ANY\n   inject:     upon HAVE-COMPONENTS {128.8.0.0/16,
    128.9.0.0/16}\n   holes:      128.8.8.0/24\n                      Figure 32:  Examples
    of inject.\n   Figure 32 shows two examples.  In the first case, the aggregate
    is\n   injected at two routers each one setting the dpa path attribute\n   differently.
    \ In the second case, the aggregate is generated only if\n   both 128.8.0.0/16
    and 128.9.0.0/16 are present in the routing table,\n   as opposed to the first
    case where the presence of just one of them\n   is sufficient for injection.\n
    \  The holes attribute lists the component address prefixes which are\n   not
    reachable through the aggregate route (perhaps that part of the\n   address space
    is unallocated).  The holes attribute is useful for\n   diagnosis purposes.  In
    Figure 32, the second example has a hole,\n   namely 128.8.8.0/24.  This may be
    due to a customer changing\n   providers and taking this part of the address space
    with it.\n"
  title: 8.1 Specifying Aggregate Routes
- contents:
  - "8.1.1 Interaction with policies in aut-num class\n   An aggregate formed is announced
    to other ASes only if the export\n   policies of the AS allows exporting the aggregate.
    \ When the\n   aggregate is formed, the more specifics are suppressed from being\n
    \  exported except to the ASes in aggr-bndry and except the components\n   in
    export-comps.  For such exceptions to happen, the export policies\n   of the AS
    should explicitly allow exporting of these exceptions.\n   If an aggregate is
    not formed (due to the upon clause), then the more\n   specifics of the aggregate
    can be exported to other ASes, but only if\n   the export policies of the AS allows
    it.  In other words, before a\n   route (aggregate or more specific) is exported
    it is filtered twice,\n   once based on the route objects, and once based on the
    export\n   policies of the AS.\n   route:        128.8.0.0/16\n   origin:       AS1\n
    \  route:        128.9.0.0/16\n   origin:       AS1\n   route:        128.8.0.0/15\n
    \  origin:       AS1\n   aggr-bndry:   AS1 or AS2 or AS3\n   aggr-mtd:     outbound
    AS3 or AS4 or AS5\n   components:   {128.8.0.0/16, 128.9.0.0/16}\n   inject:       upon
    HAVE-COMPONENTS {128.9.0.0/16, 128.8.0.0/16}\n   aut-num: AS1\n   export:  to
    AS2 announce AS1\n   export:  to AS3 announce AS1 and not {128.9.0.0/16}\n   export:
    \ to AS4 announce AS1\n   export:  to AS5 announce AS1\n   export:  to AS6 announce
    AS1\n          Figure 33:  Interaction with policies in aut-num class.\n   In
    Figure 33 shows an interaction example.  By examining the route\n   objects, the
    more specifics 128.8.0.0/16 and 128.9.0.0/16 should be\n   exchanged between AS1,
    AS2 and AS3 (i.e. the aggregation boundary).\n   Outbound aggregation is done
    to AS4 and AS5 and not to AS3, since AS3\n   is in the aggregation boundary.  The
    aut-num object allows exporting\n   both components to AS2, but only the component
    128.8.0.0/16 to AS3.\n   The aggregate can only be formed if both components are
    available.\n   In this case, only the aggregate is announced to AS4 and AS5.\n
    \  However, if one of the components is not available the aggregate will\n   not
    be formed, and any available component or more specific will be\n   exported to
    AS4 and AS5.  Regardless of aggregation is performed or\n   not, only the more
    specifics will be exported to AS6 (it is not\n   listed in the aggr-mtd attribute).\n
    \  When doing an inbound aggregation, configuration generators may\n   eliminating
    the aggregation statements on routers where import policy\n   of the AS prohibits
    importing of any more specifics.\n"
  title: 8.1.1 Interaction with policies in aut-num class
- contents:
  - "8.1.2 Ambiguity resolution with overlapping aggregates\n   When several aggregate
    routes are specified and they overlap, i.e.\n   one is less specific of the other,
    they must be evaluated more\n   specific to less specific order.  When an outbound
    aggregation is\n   performed for a peer, the aggregate and the components listed
    in the\n   export-comps attribute for that peer are available for generating the\n
    \  next less specific aggregate.  The components that are not specified\n   in
    the export-comps attribute are not available.  A route is\n   exportable to an
    AS if it is the least specific aggregate exportable\n   to that AS or it is listed
    in the export-comps attribute of an\n   exportable route.  Note that this is a
    recursive definition.\n   route:        128.8.0.0/15\n   origin:       AS1\n   aggr-bndry:
    \  AS1 or AS2\n   aggr-mtd:     outbound\n   inject:       upon HAVE-COMPONENTS
    {128.8.0.0/16, 128.9.0.0/16}\n   route:        128.10.0.0/15\n   origin:       AS1\n
    \  aggr-bndry:   AS1 or AS3\n   aggr-mtd:     outbound\n   inject:       upon
    HAVE-COMPONENTS {128.10.0.0/16, 128.11.0.0/16}\n   export-comps: {128.11.0.0/16}\n
    \  route:        128.8.0.0/14\n   origin:       AS1\n   aggr-bndry:   AS1 or AS2
    or AS3\n   aggr-mtd:     outbound\n   inject:       upon HAVE-COMPONENTS {128.8.0.0/15,
    128.10.0.0/15}\n   export-comps: {128.10.0.0/15}\n                   Figure 34:
    \ Overlapping aggregations.\n   In Figure 34, AS1 together with AS2 aggregates
    128.8.0.0/16 and\n   128.9.0.0/16 into 128.8.0.0/15.  Together with AS3, AS1 aggregates\n
    \  128.10.0.0/16 and 128.11.0.0/16 into 128.10.0.0/15.  But altogether\n   they
    aggregate these four routes into 128.8.0.0/14.  Assuming all\n   four components
    are available, a router in AS1 for an outside AS, say\n   AS4, will first generate
    128.8.0.0/15 and 128.10.0.0/15.  This will\n   make 128.8.0.0/15, 128.10.0.0/15
    and its exception 128.11.0.0/16\n   available for generating 128.8.0.0/14.  The
    router will then generate\n   128.8.0.0/14 from these three routes.  Hence for
    AS4, 128.8.0.0/14\n   and its exception 128.10.0.0/15 and its exception 128.11.0.0/16
    will\n   be exportable.\n   For AS2, a router in AS1 will only generate 128.10.0.0/15.
    \ Hence,\n   128.10.0.0/15 and its exception 128.11.0.0/16 will be exportable.\n
    \  Note that 128.8.0.0/16 and 128.9.0.0/16 are also exportable since\n   they
    did not participate in an aggregate exportable to AS2.\n   Similarly, for AS3,
    a router in AS1 will only generate 128.8.0.0/15.\n   In this case 128.8.0.0/15,
    128.10.0.0/16, 128.11.0.0/16 are\n   exportable.\n"
  title: 8.1.2 Ambiguity resolution with overlapping aggregates
- contents:
  - "8.2 Specifying Static Routes\n   The inject attribute can be used to specify
    static routes by using\n   \"upon static\" as the condition:\n  inject: [at <router-expression>]
    ...\n          [action <action>]\n          upon static\n   In this case, the
    routers in <router-expression> executes the\n   <action> and injects the route
    to the interAS routing system\n   statically.  <action> may set certain route
    attributes such as a\n   next-hop router or a cost.\n   In the following example,
    the router 7.7.7.1 injects the route\n   128.7.0.0/16.  The next-hop routers (in
    this example, there are two\n   next-hop routers) for this route are 7.7.7.2 and
    7.7.7.3 and the\n   route has a cost of 10 over 7.7.7.2 and 20 over 7.7.7.3.\n
    \  route:  128.7.0.0/16\n   origin: AS1\n   inject: at 7.7.7.1 action next-hop
    = 7.7.7.2; cost = 10; upon static\n   inject: at 7.7.7.1 action next-hop = 7.7.7.3;
    cost = 20; upon static\n"
  title: 8.2 Specifying Static Routes
- contents:
  - '9 inet-rtr Class

    '
  title: 9 inet-rtr Class
- contents:
  - 'Routers are specified using the inet-rtr class.  The attributes of the

    '
  title: Routers are specified using the inet-rtr class.  The attributes of the
- contents:
  - 'inet-rtr class are shown in Figure 35.  The inet-rtr attribute is a valid

    '
  title: inet-rtr class are shown in Figure 35.  The inet-rtr attribute is a valid
- contents:
  - 'DNS name of the router described.  Each alias attribute, if present, is a

    '
  title: DNS name of the router described.  Each alias attribute, if present, is a
- contents:
  - 'canonical DNS name for the router.  The local-as attribute specifies the AS

    '
  title: canonical DNS name for the router.  The local-as attribute specifies the
    AS
- contents:
  - "number of the AS which owns/operates this router.\n  Attribute  Value                    Type\n
    \ inet-rtr   <dns-name>               mandatory, single-valued, class key\n  alias
    \     <dns-name>               optional, multi-valued\n  local-as   <as-number>
    \             mandatory, single-valued\n  ifaddr     see description in text  mandatory,
    multi-valued\n  peer       see description in text  optional, multi-valued\n  member-of
    \ list of <rtr-set-names>  optional, multi-valued\n                   Figure 35:
    \ inet-rtr Class Attributes\n   The value of an ifaddr attribute has the following
    syntax:\n   <ipv4-address> masklen <integer> [action <action>]\n   The IP address
    and the mask length are mandatory for each interface.\n   Optionally an action
    can be specified to set other parameters of this\n   interface.\n   Figure 36
    presents an example inet-rtr object.  The name of the\n   router is \"amsterdam.ripe.net\".
    \ \"amsterdam1.ripe.net\" is a canonical\n   name for the router.  The router
    is connected to 4 networks.  Its IP\n   addresses and mask lengths in those networks
    are specified in the\n   ifaddr attributes.\n    inet-rtr: Amsterdam.ripe.net\n
    \   alias:    amsterdam1.ripe.net\n    local-as: AS3333\n    ifaddr:   192.87.45.190
    masklen 24\n    ifaddr:   192.87.4.28   masklen 24\n    ifaddr:   193.0.0.222
    \  masklen 27\n    ifaddr:   193.0.0.158   masklen 27\n    peer:     BGP4 192.87.45.195
    asno(AS3334), flap_damp()\n                           Figure 36:  inet-rtr Objects\n
    \  Each peer attribute, if present, specifies a protocol peering with\n   another
    router.  The value of a peer attribute has the following\n   syntax:\n     <protocol>
    <ipv4-address>      <options>\n   | <protocol> <inet-rtr-name>     <options>\n
    \  | <protocol> <rtr-set-name>      <options>\n   | <protocol> <peering-set-name>
    \ <options>\n   where <protocol> is a protocol name, <ipv4-address> is the IP
    address\n   of the peer router, and <options> is a comma separated list of\n   peering
    options for <protocol>.  Instead of the peer's IP address,\n   its inet-rtr-name
    can be used.  Possible protocol names and\n   attributes are defined in the dictionary
    (please see Section 7).  In\n   the above example, the router has a BGP peering
    with the router\n   192.87.45.195 in AS3334 and turns the flap damping on when
    importing\n   routes from this router.\n   Instead of a single peer, a group of
    peers can be specified by using\n   the <rtr-set-name> and <peering-set-name>
    forms.  If <peering-set-\n   name> form is being used only the peerings in the
    corresponding\n   peering set that are with this router are included.  Figure
    37 shows\n   an example inet-rtr object with peering groups.\n    rtr-set: rtrs-ibgp-peers\n
    \   members: 1.1.1.1, 2.2.2.2, 3.3.3.3\n    peering-set: prng-ebgp-peers\n    peering:
    AS3334 192.87.45.195\n    peering: AS3335 192.87.45.196\n    inet-rtr: Amsterdam.ripe.net\n
    \   alias:    amsterdam1.ripe.net\n    local-as: AS3333\n    ifaddr:   192.87.45.190
    masklen 24\n    ifaddr:   192.87.4.28   masklen 24\n    ifaddr:   193.0.0.222
    \  masklen 27\n    ifaddr:   193.0.0.158   masklen 27\n    peer:     BGP4 rtrs-ibgp-peers
    asno(AS3333), flap_damp()\n    peer:     BGP4 prng-ebgp-peers asno(PeerAS), flap_damp()\n
    \                Figure 37:  inet-rtr Object with peering groups\n"
  title: number of the AS which owns/operates this router.
- contents:
  - "10 Extending RPSL\n   Our experience with earlier routing policy languages and
    data formats\n   (PRDB [2], RIPE-81 [8], and RIPE-181 [7]) taught us that RPSL
    had to\n   be extensible.  As a result, extensibility was a primary design goal\n
    \  for RPSL.  New routing protocols or new features to existing routing\n   protocols
    can be easily handled using RPSL's dictionary class.  New\n   classes or new attributes
    to the existing classes can also be added.\n   This section provides guidelines
    for extending RPSL. These guidelines\n   are designed with an eye toward maintaining
    backward compatibility\n   with existing tools and databases.  We next list the
    available\n   options for extending RPSL from the most preferred to the least\n
    \  preferred order.\n"
  title: 10 Extending RPSL
- contents:
  - "10.1 Extensions by changing the dictionary class\n   The dictionary class is
    the primary mechanism provided to extend\n   RPSL.  Dictionary objects define
    routing policy attributes, types,\n   and routing protocols.\n   We recommend
    updating the RPSL dictionary to include appropriate rp-\n   attribute and protocol
    definitions as new path attributes or router\n   features are introduced.  For
    example, in an earlier version of the\n   RPSL document, it was only possible
    to specify that a router performs\n   route flap damping on a peer, but it was
    not possible to specify the\n   parameters of route flap damping.  Later the parameters
    were added by\n   changing the dictionary.\n   When changing the dictionary, full
    compatibility should be\n   maintained.  For example, in our flap damping case,
    we made the\n   parameter specification optional in case this level of detail
    was not\n   desired by some ISPs.  This also achieved compatibility.  Any object\n
    \  registered without the parameters will continue to be valid.  Any\n   tool
    based on RPSL is expected to do a default action on routing\n   policy attributes
    that they do not understand (e.g. issue a warning\n   and otherwise ignore).  Hence,
    old tools upon encountering a flap\n   damping specification with parameters will
    ignore the parameters.\n"
  title: 10.1 Extensions by changing the dictionary class
- contents:
  - "10.2 Extensions by adding new attributes to existing classes\n   New attributes
    can be added to any class.  To ensure full\n   compatibility, new attributes should
    not contradict the semantics of\n   the objects they are attached to.  Any tool
    that uses the IRR should\n   be designed so that it ignores attributes that it
    doesn't understand.\n   Most existing tools adhere to this design principle.\n
    \  We recommend adding new attributes to existing classes when a new\n   aspect
    of a class is discovered.  For example, RPSL route class\n   extends its RIPE-181
    predecessor by including several new attributes\n   that enable aggregate and
    static route specification.\n"
  title: 10.2 Extensions by adding new attributes to existing classes
- contents:
  - "10.3 Extensions by adding new classes\n   New classes can be added to RPSL to
    store new types of policy data.\n   Providing full compatibility is straight forward
    as long as existing\n   classes are still understood.  Since a tool should only
    query the IRR\n   for the classes that it understand, full compatibility should
    not be\n   a problem in this case.\n   Before adding a new class, one should question
    if the information\n   contained in the objects of the new class could have better
    belonged\n   to some other class.  For example, if the geographic location of
    a\n   router needs to be stored in IRR, it may be tempting to add a new\n   class
    called, say router-location class.  However, the information\n   better belongs
    to the inet-rtr class, perhaps in a new attribute\n   called location.\n"
  title: 10.3 Extensions by adding new classes
- contents:
  - "10.4 Extensions by changing the syntax of existing RPSL attributes\n   If all
    of the methods described above fail to provide the desired\n   extension, it may
    be necessary to change the syntax of RPSL. Any\n   change in RPSL syntax must
    provide backwards compatibility, and\n   should be considered only as a last resort
    since full compatibility\n   may not be achievable.  However, we require that
    the old syntax to be\n   still valid.\n"
  title: 10.4 Extensions by changing the syntax of existing RPSL attributes
- contents:
  - "11 Security Considerations\n   This document describes RPSL, a language for expressing
    routing\n   policies.  The language defines a maintainer (mntner class) object\n
    \  which is the entity which controls or \"maintains\" the objects stored\n   in
    a database expressed by RPSL. Requests from maintainers can be\n   authenticated
    with various techniques as defined by the \"auth\"\n   attribute of the maintainer
    object.\n   The exact protocols used by IRR's to communicate RPSL objects is\n
    \  beyond the scope of this document, but it is envisioned that several\n   techniques
    may be used, ranging from interactive query/update\n   protocols to store and
    forward protocols similar to or based on\n   electronic mail (or even voice telephone
    calls).  Regardless of which\n   protocols are used in a given situation, it is
    expected that\n   appropriate security techniques such as IPSEC, TLS or PGP/MIME
    will\n   be utilized.\n"
  title: 11 Security Considerations
- contents:
  - "12 Acknowledgements\n   We would like to thank Jessica Yu, Randy Bush, Alan Barrett,
    Bill\n   Manning, Sue Hares, Ramesh Govindan, Kannan Varadhan, Satish Kumar,\n
    \  Craig Labovitz, Rusty Eddy, David J. LeRoy, David Whipple, Jon\n   Postel,
    Deborah Estrin, Elliot Schwartz, Joachim Schmitz, Mark Prior,\n   Tony Przygienda,
    David Woodgate, Rob Coltun, Sanjay Wadhwa, Ardas\n   Cilingiroglu, and the participants
    of the IETF RPS Working Group for\n   various comments and suggestions.\n"
  title: 12 Acknowledgements
- contents:
  - "References\n   [1] Internet routing registry. procedures.\n       http://www.ra.net/RADB.tools.docs/,\n
    \      http://www.ripe.net/db/doc.html.\n   [2] Nsfnet policy routing database
    (prdb). Maintained by MERIT\n       Network Inc., Ann Arbor, Michigan. Contents
    available from\n       nic.merit.edu.:/nsfnet/announced.networks/nets.tag.now
    by\n       anonymous ftp.\n   [3] Alaettinouglu, C., Bates, T., Gerich, E., Karrenberg,
    D., Meyer,\n       D., Terpstra, M. and C. Villamizer, \"Routing Policy Specification\n
    \      Language (RPSL)\", RFC 2280, January 1998.\n   [4] C. Alaettinouglu, D.
    Meyer, and J. Schmitz. Application of\n       routing policy specification language
    (rpsl) on the internet.\n       Work in Progress.\n   [5] T. Bates. Specifying
    an `internet router' in the routing\n       registry.  Technical Report RIPE-122,
    RIPE, RIPE NCC, Amsterdam,\n       Netherlands, October 1994.\n   [6] T. Bates,
    E. Gerich, L. Joncheray, J-M. Jouanigot, D. Karrenberg,\n       M. Terpstra, and
    J. Yu. Representation of ip routing policies in\n       a routing registry. Technical
    Report ripe-181, RIPE, RIPE NCC,\n       Amsterdam, Netherlands, October 1994.\n
    \  [7] Bates, T., Gerich, E., Joncheray, L., Jouanigot, J-M.,\n       Karrenberg,
    D., Terpstra, M. and J. Yu, \" Representation of IP\n       Routing Policies in
    a Routing Registry\", RFC 1786, March 1995.\n   [8] T. Bates, J-M. Jouanigot,
    D. Karrenberg, P. Lothberg, and M.\n       Terpstra.  Representation of ip routing
    policies in the ripe\n       database. Technical Report ripe-81, RIPE, RIPE NCC,
    Amsterdam,\n       Netherlands, February 1993.\n   [9] Chandra, R., Traina, P.
    and T. Li, \"BGP Communities Attribute\",\n       RFC 1997, August 1996.\n  [10]
    Crocker, D., \"Standard for ARPA Internet Text Messages\", STD 11,\n       RFC
    822, August 1982.\n  [11] Fuller, V., Li, T., Yu, J. and K. Varadhan, \"Classless
    Inter-\n       Domain Routing (CIDR): an Address Assignment and Aggregation\n
    \      Strategy\", RFC 1519, September 1993.\n  [12] D. Karrenberg and T. Bates.
    Description of inter-as networks in\n       the ripe routing registry. Technical
    Report RIPE-104, RIPE, RIPE\n       NCC, Amsterdam, Netherlands, December 1993.\n
    \ [13] D. Karrenberg and M. Terpstra. Authorisation and notification of\n       changes
    in the ripe database. Technical Report ripe-120, RIPE,\n       RIPE NCC, Amsterdam,
    Netherlands, October 1994.\n  [14] B. W. Kernighan and D. M. Ritchie. The C Programming
    Language.\n       Prentice-Hall, 1978.\n  [15] A. Lord and M. Terpstra. Ripe database
    template for networks and\n       persons. Technical Report ripe-119, RIPE, RIPE
    NCC, Amsterdam,\n       Netherlands, October 1994.\n  [16] A. M. R. Magee. Ripe
    ncc database documentation. Technical Report\n       RIPE-157, RIPE, RIPE NCC,
    Amsterdam, Netherlands, May 1997.\n  [17] Mockapetris, P., \"Domain names - concepts
    and facilities\", STD\n       13, RFC 1034, November 1987.\n  [18] Y. Rekhter.
    Inter-domain routing protocol (idrp). Journal of\n       Internetworking Research
    and Experience, 4:61--80, 1993.\n  [19] Rekhter Y. and T. Li, \"A Border Gateway
    Protocol 4 (BGP-4)\", RFC\n       1771, March 1995.\n  [20] C. Villamizar, C.
    Alaettinouglu, D. Meyer, S. Murphy, and C.\n       Orange.  Routing policy system
    security\", Work in Progress.\n  [21] Villamizar, C., Chandra, R. and R. Govindan,
    \"BGP Route Flap\n       Damping\", RFC 2439, November 1998.\n  [22] J. Zsako,
    \"PGP authentication for ripe database updates\", Work in\n       Progress.\n"
  title: References
- contents:
  - "A Routing Registry Sites\n   The set of routing registries as of November 1996
    are RIPE, RADB,\n   CANet, MCI and ANS. You may contact one of these registries
    to find\n   out the current list of registries.\n"
  title: A Routing Registry Sites
- contents:
  - "B Grammar Rules\n   In this section we provide formal grammar rules for RPSL.
    Basic data\n   types are defined in Section 2.  We do not provide formal grammar\n
    \  rules for attributes whose values are of basic types or list of basic\n   types.
    \ The rules are written using the input language of GNU Bison\n   parser.  Hence,
    they can be cut and pasted to that program.\n"
  - '//**** Generic Attributes **********************************************

    '
  - 'changed_attribute: ATTR_CHANGED TKN_EMAIL TKN_INT

    '
  - '//**** aut-num class ***************************************************

    '
  - '//// as_expression /////////////////////////////////////////////////////

    '
  - 'opt_as_expression:

    '
  - '| as_expression

    '
  - 'as_expression: as_expression OP_OR as_expression_term

    '
  - '| as_expression_term

    '
  - 'as_expression_term: as_expression_term OP_AND as_expression_factor

    '
  - '| as_expression_term KEYW_EXCEPT as_expression_factor

    '
  - '| as_expression_factor

    '
  - 'as_expression_factor: ''('' as_expression '')''

    '
  - '| as_expression_operand

    '
  - 'as_expression_operand: TKN_ASNO

    '
  - '| TKN_ASNAME

    '
  - '//// router_expression /////////////////////////////////////////////////

    '
  - 'opt_router_expression:

    '
  - '| router_expression

    '
  - 'opt_router_expression_with_at:

    '
  - '| KEYW_AT router_expression

    '
  - 'router_expression: router_expression OP_OR router_expression_term

    '
  - '| router_expression_term

    '
  - "router_expression_term: router_expression_term OP_AND\n                        router_expression_factor\n"
  - '| router_expression_term KEYW_EXCEPT router_expression_factor

    '
  - '| router_expression_factor

    '
  - 'router_expression_factor: ''('' router_expression '')''

    '
  - '| router_expression_operand

    '
  - 'router_expression_operand: TKN_IPV4

    '
  - '| TKN_DNS

    '
  - '| TKN_RTRSNAME

    '
  - '//// peering ///////////////////////////////////////////////////////////

    '
  - 'peering: as_expression opt_router_expression opt_router_expression_with_at

    '
  - '| TKN_PRNGNAME

    '
  - '//// action ////////////////////////////////////////////////////////////

    '
  - 'opt_action:

    '
  - '| KEYW_ACTION action

    '
  - 'action: single_action

    '
  - '| action single_action

    '
  - 'single_action: TKN_RP_ATTR ''.'' TKN_WORD ''('' generic_list '')'' '';''

    '
  - '| TKN_RP_ATTR TKN_OPERATOR list_item '';''

    '
  - '| TKN_RP_ATTR ''('' generic_list '')'' '';''

    '
  - '| TKN_RP_ATTR ''['' generic_list '']'' '';''

    '
  - '| '';''

    '
  - '//// filter ////////////////////////////////////////////////////////////

    '
  - 'filter: filter OP_OR filter_term

    '
  - '| filter filter_term %prec OP_OR

    '
  - '| filter_term

    '
  - 'filter_term : filter_term OP_AND filter_factor

    '
  - '| filter_factor

    '
  - 'filter_factor :  OP_NOT filter_factor

    '
  - '| ''('' filter '')''

    '
  - '| filter_operand

    '
  - 'filter_operand: KEYW_ANY

    '
  - '| ''<'' filter_aspath ''>''

    '
  - '| filter_rp_attribute

    '
  - '| TKN_FLTRNAME

    '
  - '| filter_prefix

    '
  - 'filter_prefix: filter_prefix_operand OP_MS

    '
  - '|  filter_prefix_operand

    '
  - 'filter_prefix_operand: TKN_ASNO

    '
  - '| KEYW_PEERAS

    '
  - '| TKN_ASNAME

    '
  - '| TKN_RSNAME

    '
  - '| ''{'' opt_filter_prefix_list ''}''

    '
  - 'opt_filter_prefix_list:

    '
  - '| filter_prefix_list

    '
  - 'filter_prefix_list: filter_prefix_list_prefix

    '
  - '| filter_prefix_list '','' filter_prefix_list_prefix

    '
  - 'filter_prefix_list_prefix: TKN_PRFXV4

    '
  - '| TKN_PRFXV4RNG

    '
  - 'filter_aspath: filter_aspath ''|'' filter_aspath_term

    '
  - '| filter_aspath_term

    '
  - 'filter_aspath_term: filter_aspath_term filter_aspath_closure

    '
  - '| filter_aspath_closure

    '
  - 'filter_aspath_closure: filter_aspath_closure ''*''

    '
  - '| filter_aspath_closure ''?''

    '
  - '| filter_aspath_closure ''+''

    '
  - '| filter_aspath_factor

    '
  - 'filter_aspath_factor: ''^''

    '
  - '| ''$''

    '
  - '| ''('' filter_aspath '')''

    '
  - '| filter_aspath_no

    '
  - 'filter_aspath_no: TKN_ASNO

    '
  - '| KEYW_PEERAS

    '
  - '| TKN_ASNAME

    '
  - '| ''.''

    '
  - '| ''['' filter_aspath_range '']''

    '
  - '| ''['' ''^'' filter_aspath_range '']''

    '
  - 'filter_aspath_range:

    '
  - '| filter_aspath_range TKN_ASNO

    '
  - '| filter_aspath_range KEYW_PEERAS

    '
  - '| filter_aspath_range ''.''

    '
  - '| filter_aspath_range TKN_ASNO ''-'' TKN_ASNO

    '
  - '| filter_aspath_range TKN_ASNAME

    '
  - 'filter_rp_attribute: TKN_RP_ATTR ''.'' TKN_WORD ''('' generic_list '')''

    '
  - '| TKN_RP_ATTR TKN_OPERATOR list_item

    '
  - '| TKN_RP_ATTR ''('' generic_list '')''

    '
  - '| TKN_RP_ATTR ''['' generic_list '']''

    '
  - '//// peering action pair ///////////////////////////////////////////////

    '
  - 'import_peering_action_list: KEYW_FROM peering opt_action

    '
  - '| import_peering_action_list KEYW_FROM peering opt_action

    '
  - 'export_peering_action_list: KEYW_TO peering opt_action

    '
  - '| export_peering_action_list KEYW_TO peering opt_action

    '
  - '//// import/export factor //////////////////////////////////////////////

    '
  - 'import_factor: import_peering_action_list KEYW_ACCEPT filter

    '
  - 'import_factor_list: import_factor '';''

    '
  - '| import_factor_list import_factor '';''

    '
  - 'export_factor: export_peering_action_list KEYW_ANNOUNCE filter

    '
  - 'export_factor_list: export_factor '';''

    '
  - '| export_factor_list export_factor '';''

    '
  - '//// import/export term ////////////////////////////////////////////////

    '
  - 'import_term: import_factor '';''

    '
  - '| ''{'' import_factor_list ''}''

    '
  - 'export_term: export_factor '';''

    '
  - '| ''{'' export_factor_list ''}''

    '
  - '//// import/export expression //////////////////////////////////////////

    '
  - 'import_expression: import_term

    '
  - '| import_term KEYW_REFINE import_expression

    '
  - '| import_term KEYW_EXCEPT import_expression

    '
  - 'export_expression: export_term

    '
  - '| export_term KEYW_REFINE export_expression

    '
  - '| export_term KEYW_EXCEPT export_expression

    '
  - '//// protocol ///////////////////////////////////////////////////////////

    '
  - 'opt_protocol_from:

    '
  - '| KEYW_PROTOCOL tkn_word

    '
  - 'opt_protocol_into:

    '
  - '| KEYW_INTO tkn_word

    '
  - '//**** import/export attributes ****************************************

    '
  - 'import_attribute: ATTR_IMPORT

    '
  - '| ATTR_IMPORT opt_protocol_from opt_protocol_into import_factor

    '
  - 'export_attribute: ATTR_EXPORT

    '
  - '| ATTR_EXPORT opt_protocol_from opt_protocol_into export_factor

    '
  - 'opt_default_filter:

    '
  - '| KEYW_NETWORKS filter

    '
  - 'default_attribute: ATTR_DEFAULT KEYW_TO peering

    '
  - 'filter_attribute: ATTR_FILTER filter

    '
  - 'peering_attribute: ATTR_PEERING peering

    '
  - '//**** inet-rtr class **************************************************

    '
  - 'ifaddr_attribute: ATTR_IFADDR TKN_IPV4 KEYW_MASKLEN TKN_INT opt_action

    '
  - '//// peer attribute ////////////////////////////////////////////////////

    '
  - 'opt_peer_options:

    '
  - '| peer_options

    '
  - 'peer_options: peer_option

    '
  - '| peer_options '','' peer_option

    '
  - 'peer_option: tkn_word ''('' generic_list '')''

    '
  - 'peer_id: TKN_IPV4

    '
  - '| TKN_DNS

    '
  - '| TKN_RTRSNAME

    '
  - '| TKN_PRNGNAME

    '
  - 'peer_attribute: ATTR_PEER tkn_word peer_id opt_peer_options

    '
  - '//**** route class *****************************************************

    '
  - 'aggr_bndry_attribute: ATTR_AGGR_BNDRY as_expression

    '
  - 'aggr_mtd_attribute: ATTR_AGGR_MTD KEYW_INBOUND

    '
  - '| ATTR_AGGR_MTD KEYW_OUTBOUND opt_as_expression

    '
  - '//// inject attribute //////////////////////////////////////////////////

    '
  - 'opt_inject_expression:

    '
  - '| KEYW_UPON inject_expression

    '
  - 'inject_expression: inject_expression OP_OR inject_expression_term

    '
  - '| inject_expression_term

    '
  - "inject_expression_term: inject_expression_term OP_AND\n                        inject_expression_factor\n"
  - '| inject_expression_factor

    '
  - 'inject_expression_factor: ''('' inject_expression '')''

    '
  - '| inject_expression_operand

    '
  - 'inject_expression_operand: KEYW_STATIC

    '
  - '| KEYW_HAVE_COMPONENTS ''{'' opt_filter_prefix_list ''}''

    '
  - '| KEYW_EXCLUDE ''{'' opt_filter_prefix_list ''}''

    '
  - "inject_attribute: ATTR_INJECT opt_router_expression_with_at opt_action\n                              opt_inject_expression\n"
  - '//// components attribute //////////////////////////////////////////////

    '
  - 'opt_atomic:

    '
  - '| KEYW_ATOMIC

    '
  - 'components_list:

    '
  - '| filter

    '
  - '| components_list KEYW_PROTOCOL tkn_word filter

    '
  - 'components_attribute: ATTR_COMPONENTS opt_atomic components_list

    '
  - '//**** route-set *******************************************************

    '
  - 'opt_rs_members_list: /* empty list */

    '
  - '| rs_members_list

    '
  - 'rs_members_list: rs_member

    '
  - '| rs_members_list '','' rs_member

    '
  - 'rs_member: TKN_ASNO

    '
  - '| TKN_ASNO OP_MS

    '
  - '| TKN_ASNAME

    '
  - '| TKN_ASNAME OP_MS

    '
  - '| TKN_RSNAME

    '
  - '| TKN_RSNAME OP_MS

    '
  - '| TKN_PRFXV4

    '
  - '| TKN_PRFXV4RNG

    '
  - 'rs_members_attribute: ATTR_RS_MEMBERS opt_rs_members_list

    '
  - '//**** dictionary ******************************************************

    '
  - 'rpattr_attribute: ATTR_RP_ATTR TKN_WORD methods

    '
  - '| ATTR_RP_ATTR TKN_RP_ATTR methods

    '
  - 'methods: method

    '
  - '| methods method

    '
  - 'method: TKN_WORD ''('' '')''

    '
  - '| TKN_WORD ''('' typedef_type_list '')''

    '
  - '| TKN_WORD ''('' typedef_type_list '','' TKN_3DOTS '')''

    '
  - '| KEYW_OPERATOR TKN_OPERATOR ''('' typedef_type_list '')''

    '
  - '| KEYW_OPERATOR TKN_OPERATOR ''('' typedef_type_list '','' TKN_3DOTS '')''

    '
  - '//// typedef attribute  ////////////////////////////////////////////////

    '
  - 'typedef_attribute: ATTR_TYPEDEF TKN_WORD typedef_type

    '
  - 'typedef_type_list: typedef_type

    '
  - '| typedef_type_list '','' typedef_type

    '
  - 'typedef_type: KEYW_UNION typedef_type_list

    '
  - '| KEYW_RANGE KEYW_OF typedef_type

    '
  - '| TKN_WORD

    '
  - '| TKN_WORD ''['' TKN_INT '','' TKN_INT '']''

    '
  - '| TKN_WORD ''['' TKN_REAL '','' TKN_REAL '']''

    '
  - '| TKN_WORD ''['' enum_list '']''

    '
  - '| KEYW_LIST ''['' TKN_INT '':'' TKN_INT '']'' KEYW_OF typedef_type

    '
  - '| KEYW_LIST KEYW_OF typedef_type

    '
  - 'enum_list: tkn_word

    '
  - '| enum_list '','' tkn_word

    '
  - '//// protocol attribute ////////////////////////////////////////////////

    '
  - 'protocol_attribute: ATTR_PROTOCOL tkn_word protocol_options

    '
  - 'protocol_options:

    '
  - '| protocol_options protocol_option

    '
  - 'protocol_option: KEYW_MANDATORY method

    '
  - '| KEYW_OPTIONAL method

    '
  - '//**** Token Definitions ***********************************************

    '
  - '//// flex macros used in token definitions /////////////////////////////

    '
  - 'INT            [[:digit:]]+

    '
  - 'SINT           [+-]?{INT}

    '
  - 'REAL           [+-]?{INT}?\.{INT}({WS}*E{WS}*[+-]?{INT})?

    '
  - 'NAME           [[:alpha:]]([[:alnum:]_-]*[[:alnum:]])?

    '
  - 'ASNO           AS{INT}

    '
  - 'ASNAME         AS-[[:alnum:]_-]*[[:alnum:]]

    '
  - 'RSNAME         RS-[[:alnum:]_-]*[[:alnum:]]

    '
  - 'RTRSNAME       RTRS-[[:alnum:]_-]*[[:alnum:]]

    '
  - 'PRNGNAME       PRNG-[[:alnum:]_-]*[[:alnum:]]

    '
  - 'FLTRNAME       FLTR-[[:alnum:]_-]*[[:alnum:]]

    '
  - 'IPV4           [0-9]+(\.[0-9]+){3,3}

    '
  - 'PRFXV4         {IPV4}\/[0-9]+

    '
  - 'PRFXV4RNG      {PRFXV4}("^+"|"^-"|"^"{INT}|"^"{INT}-{INT})

    '
  - 'ENAMECHAR      [^()<>,;:\\\"\.[\] \t\r]

    '
  - 'ENAME          ({ENAMECHAR}+(\.{ENAMECHAR}+)*\.?)|(\"[^\"@\\\r\n]+\")

    '
  - 'DNAME          [[:alnum:]_-]+

    '
  - '//// Token Definitions ////////////////////////////////////////////////

    '
  - 'TKN_INT         {SINT}

    '
  - 'TKN_INT         {INT}:{INT}             if each {INT} is two octets

    '
  - 'TKN_INT         {INT}.{INT}.{INT}.{INT} if each {INT} is one octet

    '
  - 'TKN_REAL        {REAL}

    '
  - 'TKN_STRING      Same as in programming language C

    '
  - 'TKN_IPV4        {IPV4}

    '
  - 'TKN_PRFXV4      {PRFXV4}

    '
  - 'TKN_PRFXV4RNG   {PRFXV4RNG}

    '
  - 'TKN_ASNO        {ASNO}

    '
  - "TKN_ASNAME      (({ASNO}|peeras|{ASNAME}):)*{ASNAME}\\\n                (:({ASNO}|peeras|{ASNAME}))*\n"
  - "TKN_RSNAME      (({ASNO}|peeras|{RSNAME}):)*{RSNAME}\\\n                (:({ASNO}|peeras|{RSNAME}))*\n"
  - "TKN_RTRSNAME    (({ASNO}|peeras|{RTRSNAME}):)*{RTRSNAME}\\\n                (:({ASNO}|peeras|{RTRSNAME}))*\n"
  - "TKN_PRNGNAME    (({ASNO}|peeras|{PRNGNAME}):)*{PRNGNAME}\\\n                (:({ASNO}|peeras|{PRNGNAME}))*\n"
  - "TKN_FLTRNAME    (({ASNO}|peeras|{FLTRNAME}):)*{FLTRNAME}\\\n                (:({ASNO}|peeras|{FLTRNAME}))*\n"
  - 'TKN_BOOLEAN     true|false

    '
  - 'TKN_RP_ATTR     {NAME} if defined in dictionary

    '
  - 'TKN_WORD        {NAME}

    '
  - 'TKN_DNS         {DNAME}("."{DNAME})+

    '
  - 'TKN_EMAIL       {ENAME}@({DNAME}("."{DNAME})+|{IPV4})

    '
  title: B Grammar Rules
- contents:
  - "C Changes from RFC 2280\n   RFC 2280 [3] contains an earlier version of RPSL.
    This section\n   summarizes the changes since then.  They are as follows:\n  o
    \ It is now possible to write integers as sequence of four 1-octet\n     integers
    (e.g. 1.1.1.1) or as sequence of two 2-octet integers\n     (e.g.  3561:70).  Please
    see Section 2.\n  o  The definition of address prefix range is extended so that
    an\n     address prefix is also an address prefix range.  Please see Section\n
    \    2.\n  o  The semantics for a range operator applied to a set containing\n
    \    address prefix ranges is defined (e.g. {30.0.0.0/8^24-28}^27-30).\n     Please
    see Section 2.\n  o  All dates are now in UTC. Please see Section 2.\n  o  Plus
    ('+') character is added to space and tab characters to split\n     an attribute's
    value to multiple lines (i.e. by starting the\n     following lines with a space,
    a tab or a plus ('+') character).\n     Please see Section 2.\n  o  The withdrawn
    attribute of route class is removed from the\n     language.\n  o  filter-set
    class is introduced.  Please see Section 5.4.\n  o  rtr-set class is introduced.
    \ Please see Section 5.5.\n  o  peering-set class is introduced.  Please see Section
    5.6.\n  o  Filters can now refer to filter-set names.  Please see Section 5.4.\n
    \ o  Peerings can now refer to peering-set, rtr-set names.  Both local\n     and
    peer routers can be specified using router expressions.  Please\n     see Section
    5.6.\n  o  The peer attribute of the inet-rtr class can refer to peering-set,\n
    \    rtr-set names.  Please see Section 9.\n  o  The syntax and semantics of union,
    and list types and typedef\n     attribute have changed.  Please see Section 7.\n
    \ o  In the initial dictionary, the typedef attribute defining the\n     community_elm,
    rp-attribute defining the community attribute has\n     changed.  Please see Section
    7.\n  o  Guideliness for extending RPSL is added.  Please see Section 10.\n  o
    \ Formal grammar rules are added.  Please see Appendix B.\n"
  title: C Changes from RFC 2280
- contents:
  - "D Authors' Addresses\n   Cengiz Alaettinoglu\n   USC/Information Sciences Institute\n
    \  EMail: cengiz@isi.edu\n   Curtis Villamizar\n   Avici Systems\n   EMail: curtis@avici.com\n
    \  Elise Gerich\n   At Home Network\n   EMail: epg@home.net\n   David Kessens\n
    \  Qwest Communications\n   EMail: David.Kessens@qwest.net\n   David Meyer\n   University
    of Oregon\n   EMail: meyer@antc.uoregon.edu\n   Tony Bates\n   Cisco Systems,
    Inc.\n   EMail: tbates@cisco.com\n   Daniel Karrenberg\n   RIPE NCC\n   EMail:
    dfk@ripe.net\n   Marten Terpstra\n   c/o Bay Networks, Inc.\n   EMail: marten@BayNetworks.com\n"
  title: D Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (1999).  All
    Rights Reserved.\n   This document and translations of it may be copied and furnished
    to\n   others, and derivative works that comment on or otherwise explain it\n
    \  or assist in its implmentation may be prepared, copied, published and\n   distributed,
    in whole or in part, without restriction of any kind,\n   provided that the above
    copyright notice and this paragraph are\n   included on all such copies and derivative
    works.  However, this\n   document itself may not be modified in any way, such
    as by removing\n   the copyright notice or references to the Internet Society
    or other\n   Internet organizations, except as needed for the purpose of developing\n
    \  Internet standards in which case the procedures for copyrights defined\n   in
    the Internet Standards process must be followed, or as required to\n   translate
    it into languages other than English.\n   The limited permissions granted above
    are perpetual and will not be\n   revoked by the Internet Society or its successors
    or assigns.\n   This document and the information contained herein is provided
    on an\n   \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n
    \  TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT\n   NOT
    LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN\n   WILL NOT INFRINGE
    ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
