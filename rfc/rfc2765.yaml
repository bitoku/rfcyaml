- title: __initial_text__
  contents:
  - '             Stateless IP/ICMP Translation Algorithm (SIIT)

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies a transition mechanism algorithm in addition\n\
    \   to the mechanisms already specified in [TRANS-MECH].  The algorithm\n   translates\
    \ between IPv4 and IPv6 packet headers (including ICMP\n   headers) in separate\
    \ translator \"boxes\" in the network without\n   requiring any per-connection\
    \ state in those \"boxes\".  This new\n   algorithm can be used as part of a solution\
    \ that allows IPv6 hosts,\n   which do not have a permanently assigned IPv4 addresses,\
    \ to\n   communicate with IPv4-only hosts.  The document neither specifies\n \
    \  address assignment nor routing to and from the IPv6 hosts when they\n   communicate\
    \ with the IPv4-only hosts.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   This document is a product of the NGTRANS working group.\
    \  Some text\n   has been extracted from an old Internet Draft titled \"IPAE:\
    \ The SIPP\n   Interoperability and Transition Mechanism\" authored by R. Gilligan,\n\
    \   E. Nordmark, and B. Hinden.  George Tsirtsis provides the figures for\n  \
    \ Section 1.  Keith Moore provided a careful review of the document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction and Motivation..............................\
    \    2\n      1.1.  Applicability and Limitations.......................    5\n\
    \      1.2.  Assumptions.........................................    7\n     \
    \ 1.3.  Impact Outside the Network Layer....................    7\n   2.  Terminology..............................................\
    \    8\n      2.1.  Addresses...........................................    9\n\
    \      2.2.  Requirements........................................    9\n   3.\
    \  Translating from IPv4 to IPv6............................    9\n      3.1.\
    \  Translating IPv4 Headers into IPv6 Headers..........   11\n      3.2.  Translating\
    \ UDP over IPv4...........................   13\n      3.3.  Translating ICMPv4\
    \ Headers into ICMPv6 Headers......   13\n      3.4.  Translating ICMPv4 Error\
    \ Messages into ICMPv6.......   16\n      3.5.  Knowing when to Translate...........................\
    \   16\n   4.  Translating from IPv6 to IPv4............................   17\n\
    \      4.1.  Translating IPv6 Headers into IPv4 Headers..........   18\n     \
    \ 4.2.  Translating ICMPv6 Headers into ICMPv4 Headers......   20\n      4.3.\
    \  Translating ICMPv6 Error Messages into ICMPv4.......   22\n      4.4.  Knowing\
    \ when to Translate...........................   22\n   5.  Implications for IPv6-Only\
    \ Nodes.........................   22\n   6.  Security Considerations..................................\
    \   23\n   References...................................................   24\n\
    \   Author's Address.............................................   25\n   Full\
    \ Copyright Statement.....................................   26\n"
- title: 1.  Introduction and Motivation
  contents:
  - "1.  Introduction and Motivation\n   The transition mechanisms specified in [TRANS-MECH]\
    \ handle the case\n   of dual IPv4/IPv6 hosts interoperating with both dual hosts\
    \ and\n   IPv4-only hosts, which is needed early in the transition to IPv6.\n\
    \   The dual hosts are assigned both an IPv4 and one or more IPv6\n   addresses.\
    \  As the number of available globally unique IPv4 addresses\n   becomes smaller\
    \ and smaller as the Internet grows there will be a\n   desire to take advantage\
    \ of the large IPv6 address and not require\n   that every new Internet node have\
    \ a permanently assigned IPv4\n   address.\n   There are several different scenarios\
    \ where there might be IPv6-only\n   hosts that need to communicate with IPv4-only\
    \ hosts.  These IPv6\n   hosts might be IPv4-capable, i.e. include an IPv4 implementation\
    \ but\n   not be assigned an IPv4 address, or they might not even include an\n\
    \   IPv4 implementation.\n   -  A completely new network with new devices that\
    \ all support IPv6.\n      In this case it might be beneficial to not have to\
    \ configure the\n      routers within the new network to route IPv4 since none\
    \ of the\n      hosts in the new network are configured with IPv4 addresses. \
    \ But\n      these new IPv6 devices might occasionally need to communicate with\n\
    \      some IPv4 nodes out on the Internet.\n   -  An existing network where a\
    \ large number of IPv6 devices are\n      added.  The IPv6 devices might have\
    \ both an IPv4 and an IPv6\n      protocol stack but there is not enough global\
    \ IPv4 address space\n      to give each one of them a permanent IPv4 address.\
    \  In this case\n      it is more likely that the routers in the network already\
    \ route\n      IPv4 and are upgraded to dual routers.\n   However, there are other\
    \ potential solutions in this area:\n   -  If there is no IPv4 routing inside\
    \ the network i.e., the cloud\n      that contains the new devices, some possible\
    \ solutions are to\n      either use the translators specified in this document\
    \ at the\n      boundary of the cloud, or to use Application Layer Gateways (ALG)\n\
    \      on dual nodes at the cloud's boundary.  The ALG solution is less\n    \
    \  flexible in that it is application protocol specific and it is\n      also\
    \ less robust since an ALG box is likely to be a single point\n      of failure\
    \ for a connection using that box.\n   -  Otherwise, if IPv4 routing is supported\
    \ inside the cloud and the\n      implementations support both IPv6 and IPv4 it\
    \ might suffice to\n      have a mechanism for allocating a temporary address\
    \ IPv4 and use\n      IPv4 end to end when communicating with IPv4-only nodes.\
    \  However,\n      it would seem that such a solution would require the pool of\n\
    \      temporary IPv4 addresses to be partitioned across all the subnets\n   \
    \   in the cloud which would either require a larger pool of IPv4\n      addresses\
    \ or result in cases where communication would fail due to\n      no available\
    \ IPv4 address for the node's subnet.\n   This document specifies an algorithm\
    \ that is one of the components\n   needed to make IPv6-only nodes interoperate\
    \ with IPv4-only nodes.\n   Other components, not specified in this document,\
    \ are a mechanism for\n   the IPv6-only node to somehow acquire a temporary IPv4\
    \ address, and a\n   mechanism for providing routing (perhaps using tunneling)\
    \ to and from\n   the temporary IPv4 address assigned to the node.\n   The temporary\
    \ IPv4 address will be used as an IPv4-translated IPv6\n   address and the packets\
    \ will travel through a stateless IP/ICMP\n   translator that will translate the\
    \ packet headers between IPv4 and\n   IPv6 and translate the addresses in those\
    \ headers between IPv4\n   addresses on one side and IPv4-translated or IPv4-mapped\
    \ IPv6\n   addresses on the other side.\n   This specification does not cover\
    \ how an IPv6 node can acquire a\n   temporary IPv4 address and how such a temporary\
    \ address be registered\n   in the DNS.  The DHCP protocol, perhaps with some\
    \ extensions, could\n   probably be used to acquire temporary addresses with short\
    \ leases but\n   that is outside the scope of this document.  Also, the mechanism\
    \ for\n   routing this IPv4-translated IPv6 address in the site is not\n   specified\
    \ in this document.\n   The figures below show how the Stateless IP/ICMP Translation\n\
    \   algorithm (SIIT) can be used initially for small networks (e.g., a\n   single\
    \ subnet) and later for a site which has IPv6-only hosts in a\n   dual IPv4/IPv6\
    \ network.  This use assumes a mechanism for the IPv6\n   nodes to acquire a temporary\
    \ address from the pool of IPv4 addresses.\n   Note that SIIT is not likely to\
    \ be useful later during transition\n   when most of the Internet is IPv6 and\
    \ there are only small islands of\n   IPv4 nodes, since such use would either\
    \ require the IPv6 nodes to\n   acquire temporary IPv4 addresses from a \"distant\"\
    \ SIIT box operated\n   by a different administration, or require that the IPv6\
    \ routing\n   contain routes for IPv6-mapped addresses.  (The latter is known\
    \ to be\n   a very bad idea due to the size of the IPv4 routing table that would\n\
    \   potentially be injected into IPv6 routing in the form of IPv4-mapped\n   addresses.)\n\
    \                                     ___________\n                          \
    \          /           \\\n      [IPv6 Host]---[SIIT]---------< IPv4 network>--[IPv4\
    \ Host]\n                       |            \\___________/\n                (pool\
    \ of IPv4 addresses)\n      IPv4-translatable ->          IPv4->IPv4 addresser\n\
    \      IPv4-mapped\n           Figure 1.  Using SIIT for a single IPv6-only subnet.\n\
    \                     ___________              ___________\n                 \
    \   /           \\            /           \\\n      [IPv6 Host]--< Dual network>--[SIIT]--<\
    \ IPv4 network>--[IPv4 Host]\n                    \\___________/     |      \\\
    ___________/\n                             (pool of IPv4 addresses)\n      IPv4-translatable\
    \ ->                     IPv4->IPv4 addresser\n      IPv4-mapped\n    Figure 2.\
    \  Using SIIT for an IPv6-only or dual cloud (e.g. a site)\n        which contains\
    \ some IPv6-only hosts as well as IPv4 hosts.\n   The protocol translators are\
    \ assumed to fit around some piece of\n   topology that includes some IPv6-only\
    \ nodes and that may also include\n   IPv4 nodes as well as dual nodes.  There\
    \ has to be a translator on\n   each path used by routing the \"translatable\"\
    \ packets in and out of\n   this cloud to ensure that such packets always get\
    \ translated.  This\n   does not require a translator at every physical connection\
    \ between\n   the cloud and the rest of the Internet since the routing can be\
    \ used\n   to deliver the packets to the translator.\n   The IPv6-only node communicating\
    \ with an IPv4 node through a\n   translator will see an IPv4-mapped address for\
    \ the peer and use an\n   IPv4-translatable address for its local address for\
    \ that\n   communication.  When the IPv6-only node sends packets the IPv4-mapped\n\
    \   address indicates that the translator needs to translate the packets.\n  \
    \ When the IPv4 node sends packets those will translated to have the\n   IPv4-translatable\
    \ address as a destination; it is not possible to use\n   an IPv4-mapped or an\
    \ IPv4-compatible address as a destination since\n   that would either route the\
    \ packet back to the translator (for the\n   IPv4-mapped address) or make the\
    \ packet be encapsulated in IPv4 (for\n   the IPv4-compatible address).  Thus\
    \ this specification introduces the\n   new notion of an IPv4-translatable address.\n"
- title: 1.1.  Applicability and Limitations
  contents:
  - "1.1.  Applicability and Limitations\n   The use of this translation algorithm\
    \ assumes that the IPv6 network\n   is somehow well connected i.e. when an IPv6\
    \ node wants to communicate\n   with another IPv6 node there is an IPv6 path between\
    \ them.  Various\n   tunneling schemes exist that can provide such a path, but\
    \ those\n   mechanisms and their use is outside the scope of this document.\n\
    \   The IPv6 protocol [IPv6] has been designed so that the TCP and UDP\n   pseudo-header\
    \ checksums are not affected by the translations\n   specified in this document,\
    \ thus the translator does not need to\n   modify normal TCP and UDP headers.\
    \  The only exceptions are\n   unfragmented IPv4 UDP packets which need to have\
    \ a UDP checksum\n   computed since a pseudo-header checksum is required for UDP\
    \ in IPv6.\n   Also, ICMPv6 include a pseudo-header checksum but it is not present\n\
    \   in ICMPv4 thus the checksum in ICMP messages need to be modified by\n   the\
    \ translator.  In addition, ICMP error messages contain an IP\n   header as part\
    \ of the payload thus the translator need to rewrite\n   those parts of the packets\
    \ to make the receiver be able to understand\n   the included IP header.  However,\
    \ all of the translator's operations,\n   including path MTU discovery, are stateless\
    \ in the sense that the\n   translator operates independently on each packet and\
    \ does not retain\n   any state from one packet to another.  This allows redundant\n\
    \   translator boxes without any coordination and a given TCP connection\n   can\
    \ have the two directions of packets go through different\n   translator boxes.\n\
    \   The translating function as specified in this document does not\n   translate\
    \ any IPv4 options and it does not translate IPv6 routing\n   headers, hop-by-hop\
    \ extension headers, or destination options\n   headers.  It could be possible\
    \ to define a translation between source\n   routing in IPv4 and IPv6.  However\
    \ such a translation would not be\n   semantically correct due to the slight differences\
    \ between the IPv4\n   and IPv6 source routing.  Also, the usefulness of source\
    \ routing when\n   going through a header translator might be limited since all\
    \ the\n   IPv6-only routers would need to have an IPv4-translated IPv6 address\n\
    \   since the IPv4-only node will send a source route option containing\n   only\
    \ IPv4 addresses.\n   At first sight it might appear that the IPsec functionality\
    \ [IPv6-SA,\n   IPv6-ESP, IPv6-AH] can not be carried across the translator.\n\
    \   However, since the translator does not modify any headers above the\n   logical\
    \ IP layer (IP headers, IPv6 fragment headers, and ICMP\n   messages) packets\
    \ encrypted using ESP in Transport-mode can be\n   carried through the translator.\
    \  [Note that this assumes that the key\n   management can operate between the\
    \ IPv6-only node and the IPv4-only\n   node.]  The AH computation covers parts\
    \ of the IPv4 header fields\n   such as IP addresses, and the identification field\
    \ (fields that are\n   either immutable or predictable by the sender) [IPv6-AUTH].\
    \  While\n   the SIIT algorithm is specified so that those IPv4 fields can be\n\
    \   predicted by the IPv6 sender it is not possible for the IPv6 receiver\n  \
    \ to determine the value of the IPv4 Identification field in packets\n   sent\
    \ by the IPv4 node.  Thus as the translation algorithm is\n   specified in this\
    \ document it is not possible to use end-to-end AH\n   through the translator.\n\
    \   For ESP Tunnel-mode to work through the translator the IPv6 node\n   would\
    \ have to be able to both parse and generate \"inner\" IPv4 headers\n   since\
    \ the inner IP will be encrypted together with the transport\n   protocol.\n \
    \  Thus in practise, only ESP transport mode is relatively easy to make\n   work\
    \ through a translator.\n   IPv4 multicast addresses can not be mapped to IPv6\
    \ multicast\n   addresses.  For instance, ::ffff:224.1.2.3 is an IPv4 mapped IPv6\n\
    \   address with a class D address, however it is not an IPv6 multicast\n   address.\
    \  While the IP/ICMP header translation aspect of this memo in\n   theory works\
    \ for multicast packets this address mapping limitation\n   makes it impossible\
    \ to apply the techniques in this memo for\n   multicast traffic.\n"
- title: 1.2.  Assumptions
  contents:
  - "1.2.  Assumptions\n   The IPv6 nodes using the translator must have an IPv4-translated\
    \ IPv6\n   address while it is communicating with IPv4-only nodes.\n   The use\
    \ of the algorithm assumes that there is an IPv4 address pool\n   used to generate\
    \ IPv4-translated addresses.  Routing needs to be able\n   to route any IPv4 packets,\
    \ whether generated \"outside\" or \"inside\"\n   the translator, destined to\
    \ addresses in this pool towards the\n   translator.  This implies that the address\
    \ pool can not be assigned\n   to subnets but must be separated from the IPv4\
    \ subnets used on the\n   \"inside\" of the translator.\n   Fragmented IPv4 UDP\
    \ packets that do not contain a UDP checksum (i.e.\n   the UDP checksum field\
    \ is zero) are not of significant use over\n   wide-areas in the Internet and\
    \ will not be translated by the\n   translator.  An informal trace [MILLER] in\
    \ the backbone showed that\n   out of 34,984,468 IP packets there were 769 fragmented\
    \ UDP packets\n   with a zero checksum.  However, all of them were due to malicious\
    \ or\n   broken behavior; a port scan and first fragments of IP packets that\n\
    \   are not a multiple of 8 bytes.\n"
- title: 1.3.  Impact Outside the Network Layer
  contents:
  - "1.3.  Impact Outside the Network Layer\n   The potential existence of stateless\
    \ IP/ICMP translators is already\n   taken care of from a protocol perspective\
    \ in [IPv6].  However, an\n   IPv6 node that wants to be able to use translators\
    \ needs some\n   additional logic in the network layer.\n   The network layer\
    \ in an IPv6-only node, when presented by the\n   application with either an IPv4\
    \ destination address or an IPv4-mapped\n   IPv6 destination address, is likely\
    \ to drop the packet and return\n   some error message to the application.  In\
    \ order to take advantage of\n   translators such a node should instead send an\
    \ IPv6 packet where the\n   destination address is the IPv4-mapped address and\
    \ the source address\n   is the node's temporarily assigned IPv4-translated address.\
    \  If the\n   node does not have a temporarily assigned IPv4-translated address\
    \ it\n   should acquire one using mechanisms that are not discussed in this\n\
    \   document.\n   Note that the above also applies to a dual IPv4/IPv6 implementation\n\
    \   node which is not configured with any IPv4 address.\n   There are no extra\
    \ changes needed to applications to operate through\n   a translator beyond what\
    \ applications already need to do to operate\n   on a dual node.  The applications\
    \ that have been modified to work on\n   a dual node already have the mechanisms\
    \ to determine whether they are\n   communicating with an IPv4 or an IPv6 peer.\
    \  Thus if the applications\n   need to modify their behavior depending on the\
    \ type of the peer, such\n   as ftp determining whether to fallback to using the\
    \ PORT/PASV command\n   when EPRT/EPSV fails (as specified in [FTPEXT]), they\
    \ already need to\n   do that when running on dual nodes and the presense of translators\n\
    \   does not add anything.  For example, when using the socket API\n   [BSDAPI]\
    \ the applications know that the peer is IPv6 if they get an\n   AF_INET6 address\
    \ from the name service and the address is not an\n   IPv4-mapped address (i.e.,\
    \ IN6_IS_ADDR_V4MAPPED returns false).  If\n   this is not the case, i.e., the\
    \ address is AF_INET or an IPv4-mapped\n   IPv6 address, the peer is IPv4.\n \
    \  One way of viewing the translator, which might help clarify why\n   applications\
    \ do not need to know that a translator is used, is to\n   look at the information\
    \ that is passed from the transport layer to\n   the network layer.  If the transport\
    \ passes down an IPv4 address\n   (whether or not is in the IPv4-mapped encoding)\
    \ this means that at\n   some point there will be IPv4 packets generated.  In\
    \ a dual node the\n   generation of the IPv4 packets takes place in the sending\
    \ node.  In\n   an IPv6-only node conceptually the only difference is that the\
    \ IPv4\n   packet is generated by the translator - all the information that the\n\
    \   transport layer passed to the network layer will be conveyed to the\n   translator\
    \ in some form.  That form just \"happens\" to be in the form\n   of an IPv6 header.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   This documents uses the terminology defined in [IPv6] and\n\
    \   [TRANS-MECH] with these clarifications:\n         IPv4 capable node:\n   \
    \              A node which has an IPv4 protocol stack.\n                 In order\
    \ for the stack to be usable the node must be\n                 assigned one or\
    \ more IPv4 addresses.\n         IPv4 enabled node:\n                 A node which\
    \ has an IPv4 protocol stack\n                 and is assigned one or more IPv4\
    \ addresses.  Both\n                 IPv4-only and IPv6/IPv4 nodes are IPv4 enabled.\n\
    \         IPv6 capable node:\n                 A node which has an IPv6 protocol\
    \ stack.\n                 In order for the stack to be usable the node must be\n\
    \                 assigned one or more IPv6 addresses.\n         IPv6 enabled\
    \ node:\n                 A node which has an IPv6 protocol stack\n          \
    \       and is assigned one or more IPv6 addresses.  Both\n                 IPv6-only\
    \ and IPv6/IPv4 nodes are IPv6 enabled.\n"
- title: 2.1.  Addresses
  contents:
  - "2.1.  Addresses\n   In addition to the forms of addresses defined in [ADDR-ARCH]\
    \ this\n   document also introduces the new form of IPv4-translated address.\n\
    \   This is needed to avoid using IPv4-compatible addresses outside the\n   intended\
    \ use of automatic tunneling.  Thus the address forms are:\n         IPv4-mapped:\n\
    \                 An address of the form 0::ffff:a.b.c.d which refers\n      \
    \           to a node that is not IPv6-capable.  In addition to\n            \
    \     its use in the API this protocol uses IPv4-mapped\n                 addresses\
    \ in IPv6 packets to refer to an IPv4 node.\n         IPv4-compatible:\n     \
    \            An address of the form 0::0:a.b.c.d which refers to\n           \
    \      an IPv6/IPv4 node that supports automatic tunneling.\n                \
    \ Such addresses are not used in this protocol.\n         IPv4-translated:\n \
    \                An address of the form 0::ffff:0:a.b.c.d which refers\n     \
    \            to an IPv6-enabled node.  Note that the prefix\n                \
    \ 0::ffff:0:0:0/96 is chosen to checksum to zero to\n                 avoid any\
    \ changes to the transport protocol's pseudo\n                 header checksum.\n"
- title: 2.2.  Requirements
  contents:
  - "2.2.  Requirements\n   The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT,\
    \ SHOULD,\n   SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL, when they appear in\
    \ this\n   document, are to be interpreted as described in [KEYWORDS].\n"
- title: 3.  Translating from IPv4 to IPv6
  contents:
  - "3.  Translating from IPv4 to IPv6\n   When an IPv4-to-IPv6 translator receives\
    \ an IPv4 datagram addressed\n   to a destination that lies outside of the attached\
    \ IPv4 island, it\n   translates the IPv4 header of that packet into an IPv6 header.\
    \  It\n   then forwards the packet based on the IPv6 destination address.  The\n\
    \   original IPv4 header on the packet is removed and replaced by an IPv6\n  \
    \ header.  Except for ICMP packets the transport layer header and data\n   portion\
    \ of the packet are left unchanged.\n        +-------------+                 +-------------+\n\
    \        |    IPv4     |                 |    IPv6     |\n        |   Header \
    \   |                 |   Header    |\n        +-------------+               \
    \  +-------------+\n        |  Transport  |                 |  Fragment   |\n\
    \        |   Layer     |      ===>       |   Header    |\n        |   Header \
    \   |                 |(not always) |\n        +-------------+               \
    \  +-------------+\n        |             |                 |  Transport  |\n\
    \        ~    Data     ~                 |   Layer     |\n        |          \
    \   |                 |   Header    |\n        +-------------+               \
    \  +-------------+\n                                        |             |\n\
    \                                        ~    Data     ~\n                   \
    \                     |             |\n                                      \
    \  +-------------+\n                    IPv4-to-IPv6 Translation\n   One of the\
    \ differences between IPv4 and IPv6 is that in IPv6 path MTU\n   discovery is\
    \ mandatory but it is optional in IPv4.  This implies that\n   IPv6 routers will\
    \ never fragment a packet - only the sender can do\n   fragmentation.\n   When\
    \ the IPv4 node performs path MTU discovery (by setting the DF bit\n   in the\
    \ header) the path MTU discovery can operate end-to-end i.e.\n   across the translator.\
    \  In this case either IPv4 or IPv6 routers\n   might send back ICMP \"packet\
    \ too big\" messages to the sender.  When\n   these ICMP errors are sent by the\
    \ IPv6 routers they will pass through\n   a translator which will translate the\
    \ ICMP error to a form that the\n   IPv4 sender can understand.  In this case\
    \ an IPv6 fragment header is\n   only included if the IPv4 packet is already fragmented.\n\
    \   However, when the IPv4 sender does not perform path MTU discovery the\n  \
    \ translator has to ensure that the packet does not exceed the path MTU\n   on\
    \ the IPv6 side.  This is done by fragmenting the IPv4 packet so\n   that it fits\
    \ in 1280 byte IPv6 packet since IPv6 guarantees that 1280\n   byte packets never\
    \ need to be fragmented.  Also, when the IPv4 sender\n   does not perform path\
    \ MTU discovery the translator MUST always\n   include an IPv6 fragment header\
    \ to indicate that the sender allows\n   fragmentation.  That is needed should\
    \ the packet pass through an\n   IPv6-to-IPv4 translator.\n   The above rules\
    \ ensure that when packets are fragmented either by the\n   sender or by IPv4\
    \ routers that the low-order 16 bits of the fragment\n   identification is carried\
    \ end-end to ensure that packets are\n   correctly reassembled.  In addition,\
    \ the rules use the presence of an\n   IPv6 fragment header to indicate that the\
    \ sender might not be using\n   path MTU discovery i.e. the packet should not\
    \ have the DF flag set\n   should it later be translated back to IPv4.\n   Other\
    \ than the special rules for handling fragments and path MTU\n   discovery the\
    \ actual translation of the packet header consists of a\n   simple mapping as\
    \ defined below.  Note that ICMP packets require\n   special handling in order\
    \ to translate the content of ICMP error\n   message and also to add the ICMP\
    \ pseudo-header checksum.\n"
- title: 3.1.  Translating IPv4 Headers into IPv6 Headers
  contents:
  - "3.1.  Translating IPv4 Headers into IPv6 Headers\n   If the DF flag is not set\
    \ and the IPv4 packet will result in an IPv6\n   packet larger than 1280 bytes\
    \ the IPv4 packet MUST be fragmented\n   prior to translating it.  Since IPv4\
    \ packets with DF not set will\n   always result in a fragment header being added\
    \ to the packet the IPv4\n   packets must be fragmented so that their length,\
    \ excluding the IPv4\n   header, is at most 1232 bytes (1280 minus 40 for the\
    \ IPv6 header and\n   8 for the Fragment header).  The resulting fragments are\
    \ then\n   translated independently using the logic described below.\n   If the\
    \ DF bit is set and the packet is not a fragment (i.e., the MF\n   flag is not\
    \ set and the Fragment Offset is zero) then there is no\n   need to add a fragment\
    \ header to the packet.  The IPv6 header fields\n   are set as follows:\n    \
    \     Version:\n                 6\n         Traffic Class:\n                \
    \ By default, copied from IP Type Of Service and\n                 Precedence\
    \ field (all 8 bits are copied).  According\n                 to [DIFFSERV] the\
    \ semantics of the bits are identical\n                 in IPv4 and IPv6.  However,\
    \ in some IPv4 environments\n                 these fields might be used with\
    \ the old semantics of\n                 \"Type Of Service and Precedence\". \
    \ An implementation\n                 of a translator SHOULD provide the ability\
    \ to ignore\n                 the IPv4 \"TOS\" and always set the IPv6 traffic\
    \ class\n                 to zero.\n         Flow Label:\n                 0 (all\
    \ zero bits)\n         Payload Length:\n                 Total length value from\
    \ IPv4 header, minus the size\n                 of the IPv4 header and IPv4 options,\
    \ if present.\n         Next Header:\n                 Protocol field copied from\
    \ IPv4 header\n         Hop Limit:\n                 TTL value copied from IPv4\
    \ header.  Since the\n                 translator is a router, as part of forwarding\
    \ the\n                 packet it needs to decrement either the IPv4 TTL\n   \
    \              (before the translation) or the IPv6 Hop Limit (after\n       \
    \          the translation).  As part of decrementing the TTL or\n           \
    \      Hop Limit the translator (as any router) needs to\n                 check\
    \ for zero and send the ICMPv4 or ICMPv6 \"ttl\n                 exceeded\" error.\n\
    \         Source Address:\n                 The low-order 32 bits is the IPv4\
    \ source address.\n                 The high-order 96 bits is the IPv4-mapped\
    \ prefix\n                 (::ffff:0:0/96)\n         Destination Address:\n  \
    \               The low-order 32 bits is the IPv4 destination\n              \
    \   address.  The high-order 96 bits is the IPv4-\n                 translated\
    \ prefix (0::ffff:0:0:0/96)\n   If IPv4 options are present in the IPv4 packet,\
    \ they are ignored\n   i.e., there is no attempt to translate them.  However,\
    \ if an\n   unexpired source route option is present then the packet MUST instead\n\
    \   be discarded, and an ICMPv4 \"destination unreachable/source route\n   failed\"\
    \ (Type 3/Code 5) error message SHOULD be returned to the\n   sender.\n   If there\
    \ is need to add a fragment header (the DF bit is not set or\n   the packet is\
    \ a fragment) the header fields are set as above with the\n   following exceptions:\n\
    \      IPv6 fields:\n          Payload Length:\n                  Total length\
    \ value from IPv4 header, plus 8 for the\n                  fragment header, minus\
    \ the size of the IPv4 header\n                  and IPv4 options, if present.\n\
    \          Next Header:\n                  Fragment Header (44).\n      Fragment\
    \ header fields:\n          Next Header:\n                  Protocol field copied\
    \ from IPv4 header.\n          Fragment Offset:\n                  Fragment Offset\
    \ copied from the IPv4 header.\n          M flag:\n                  More Fragments\
    \ bit copied from the IPv4 header.\n          Identification:\n              \
    \    The low-order 16 bits copied from the Identification\n                  field\
    \ in the IPv4 header.  The high-order 16 bits set\n                  to zero.\n"
- title: 3.2.  Translating UDP over IPv4
  contents:
  - "3.2.  Translating UDP over IPv4\n   If a UDP packet has a zero UDP checksum then\
    \ a valid checksum must be\n   calculated in order to translate the packet.  A\
    \ stateless translator\n   can not do this for fragmented packets but [MILLER]\
    \ indicates that\n   fragmented UDP packets with a zero checksum appear to only\
    \ be used\n   for malicious purposes.  Thus this is not believed to be a noticeable\n\
    \   limitation.\n   When a translator receives the first fragment of a fragmented\
    \ UDP\n   IPv4 packet and the checksum field is zero the translator SHOULD drop\n\
    \   the packet and generate a system management event specifying at least\n  \
    \ the IP addresses and port numbers in the packet.  When it receives\n   fragments\
    \ other than the first it SHOULD silently drop the packet,\n   since there is\
    \ no port information to log.\n   When a translator receives an unfragmented UDP\
    \ IPv4 packet and the\n   checksum field is zero the translator MUST compute the\
    \ missing UDP\n   checksum as part of translating the packet.  Also, the translator\n\
    \   SHOULD maintain a counter of how many UDP checksums are generated in\n   this\
    \ manner.\n"
- title: 3.3.  Translating ICMPv4 Headers into ICMPv6 Headers
  contents:
  - "3.3.  Translating ICMPv4 Headers into ICMPv6 Headers\n   All ICMP messages that\
    \ are to be translated require that the ICMP\n   checksum field be updated as\
    \ part of the translation since ICMPv6,\n   unlike ICMPv4, has a pseudo-header\
    \ checksum just like UDP and TCP.\n   In addition all ICMP packets need to have\
    \ the Type value translated\n   and for ICMP error messages the included IP header\
    \ also needs\n   translation.\n   The actions needed to translate various ICMPv4\
    \ messages are:\n      ICMPv4 query messages:\n        Echo and Echo Reply (Type\
    \ 8 and Type 0)\n           Adjust the type to 128 and 129, respectively, and\
    \ adjust the\n           ICMP checksum both to take the type change into account\
    \ and\n           to include the ICMPv6 pseudo-header.\n        Information Request/Reply\
    \ (Type 15 and Type 16)\n           Obsoleted in ICMPv4.  Silently drop.\n   \
    \     Timestamp and Timestamp Reply (Type 13 and Type 14)\n           Obsoleted\
    \ in ICMPv6.  Silently drop.\n        Address Mask Request/Reply (Type 17 and\
    \ Type 18)\n           Obsoleted in ICMPv6.  Silently drop.\n        ICMP Router\
    \ Advertisement (Type 9)\n           Single hop message.  Silently drop.\n   \
    \     ICMP Router Solicitation (Type 10)\n           Single hop message.  Silently\
    \ drop.\n        Unknown ICMPv4 types\n           Silently drop.\n      IGMP messages:\n\
    \           While the MLD messages [MLD] are the logical IPv6\n           counterparts\
    \ for the IPv4 IGMP messages all the \"normal\" IGMP\n           messages are\
    \ single-hop messages and should be silently\n           dropped by the translator.\
    \  Other IGMP messages might be used\n           by multicast routing protocols\
    \ and, since it would be a\n           configuration error to try to have router\
    \ adjacencies across\n           IPv4/IPv6 translators those packets should also\
    \ be silently\n           dropped.\n      ICMPv4 error messages:\n        Destination\
    \ Unreachable (Type 3)\n           For all that are not explicitly listed below\
    \ set the Type to\n           1.\n           Translate the code field as follows:\n\
    \              Code 0, 1 (net, host unreachable):\n                     Set Code\
    \ to 0 (no route to destination).\n              Code 2 (protocol unreachable):\n\
    \                     Translate to an ICMPv6 Parameter Problem (Type 4,\n    \
    \                 Code 1) and make the Pointer point to the IPv6 Next\n      \
    \               Header field.\n              Code 3 (port unreachable):\n    \
    \                 Set Code to 4 (port unreachable).\n              Code 4 (fragmentation\
    \ needed and DF set):\n                     Translate to an ICMPv6 Packet Too\
    \ Big message (Type\n                     2) with code 0.  The MTU field needs\
    \ to be adjusted\n                     for the difference between the IPv4 and\
    \ IPv6 header\n                     sizes.  Note that if the IPv4 router did not\
    \ set\n                     the MTU field i.e. the router does not implement\n\
    \                     [PMTUv4], then the translator must use the plateau\n   \
    \                  values specified in [PMTUv4] to determine a likely\n      \
    \               path MTU and include that path MTU in the ICMPv6\n           \
    \          packet. (Use the greatest plateau value that is\n                 \
    \    less than the returned Total Length field.)\n              Code 5 (source\
    \ route failed):\n                     Set Code to 0 (no route to destination).\
    \  Note that\n                     this error is unlikely since source routes\
    \ are not\n                     translated.\n              Code 6,7:\n       \
    \              Set Code to 0 (no route to destination).\n              Code 8:\n\
    \                     Set Code to 0 (no route to destination).\n             \
    \ Code 9, 10 (communication with destination host\n              administratively\
    \ prohibited):\n                     Set Code to 1 (communication with destination\n\
    \                     administratively prohibited)\n              Code 11, 12:\n\
    \                     Set Code to 0 (no route to destination).\n        Redirect\
    \ (Type 5)\n           Single hop message.  Silently drop.\n        Source Quench\
    \ (Type 4)\n           Obsoleted in ICMPv6.  Silently drop.\n        Time Exceeded\
    \ (Type 11)\n           Set the Type field to 3.  The Code field is unchanged.\n\
    \        Parameter Problem (Type 12)\n           Set the Type field to 4.  The\
    \ Pointer needs to be updated to\n           point to the corresponding field\
    \ in the translated include\n           IP header.\n"
- title: 3.4.  Translating ICMPv4 Error Messages into ICMPv6
  contents:
  - "3.4.  Translating ICMPv4 Error Messages into ICMPv6\n   There are some differences\
    \ between the IPv4 and the IPv6 ICMP error\n   message formats as detailed above.\
    \  In addition, the ICMP error\n   messages contain the IP header for the packet\
    \ in error which needs to\n   be translated just like a normal IP header.  The\
    \ translation of this\n   \"packet in error\" is likely to change the length of\
    \ the datagram thus\n   the Payload Length field in the outer IPv6 header might\
    \ need to be\n   updated.\n        +-------------+                 +-------------+\n\
    \        |    IPv4     |                 |    IPv6     |\n        |   Header \
    \   |                 |   Header    |\n        +-------------+               \
    \  +-------------+\n        |   ICMPv4    |                 |   ICMPv6    |\n\
    \        |   Header    |                 |   Header    |\n        +-------------+\
    \                 +-------------+\n        |    IPv4     |      ===>       | \
    \   IPv6     |\n        |   Header    |                 |   Header    |\n    \
    \    +-------------+                 +-------------+\n        |   Partial   |\
    \                 |   Partial   |\n        |  Transport  |                 | \
    \ Transport  |\n        |   Layer     |                 |   Layer     |\n    \
    \    |   Header    |                 |   Header    |\n        +-------------+\
    \                 +-------------+\n                    IPv4-to-IPv6 ICMP Error\
    \ Translation\n   The translation of the inner IP header can be done by recursively\n\
    \   invoking the function that translated the outer IP headers.\n"
- title: 3.5.  Knowing when to Translate
  contents:
  - "3.5.  Knowing when to Translate\n   The translator is assumed to know the pool(s)\
    \ of IPv4 address that\n   are used to represent the internal IPv6-only nodes.\
    \  Thus if the IPv4\n   destination field contains an address that falls in these\
    \ configured\n   sets of prefixes the packet needs to be translated to IPv6.\n"
- title: 4.  Translating from IPv6 to IPv4
  contents:
  - "4.  Translating from IPv6 to IPv4\n   When an IPv6-to-IPv4 translator receives\
    \ an IPv6 datagram addressed\n   to an IPv4-mapped IPv6 address, it translates\
    \ the IPv6 header of that\n   packet into an IPv4 header.  It then forwards the\
    \ packet based on the\n   IPv4 destination address.  The original IPv6 header\
    \ on the packet is\n   removed and replaced by an IPv4 header.  Except for ICMP\
    \ packets the\n   transport layer header and data portion of the packet are left\n\
    \   unchanged.\n        +-------------+                 +-------------+\n    \
    \    |    IPv6     |                 |    IPv4     |\n        |   Header    |\
    \                 |   Header    |\n        +-------------+                 +-------------+\n\
    \        |  Fragment   |                 |  Transport  |\n        |   Header \
    \   |      ===>       |   Layer     |\n        |(if present) |               \
    \  |   Header    |\n        +-------------+                 +-------------+\n\
    \        |  Transport  |                 |             |\n        |   Layer  \
    \   |                 ~    Data     ~\n        |   Header    |               \
    \  |             |\n        +-------------+                 +-------------+\n\
    \        |             |\n        ~    Data     ~\n        |             |\n \
    \       +-------------+\n                    IPv6-to-IPv4 Translation\n   There\
    \ are some differences between IPv6 and IPv4 in the area of\n   fragmentation\
    \ and the minimum link MTU that effect the translation.\n   An IPv6 link has to\
    \ have an MTU of 1280 bytes or greater.  The\n   corresponding limit for IPv4\
    \ is 68 bytes.  Thus, unless there were\n   special measures, it would not be\
    \ possible to do end-to-end path MTU\n   discovery when the path includes an IPv6-to-IPv4\
    \ translator since the\n   IPv6 node might receive ICMP \"packet too big\" messages\
    \ originated by\n   an IPv4 router that report an MTU less than 1280.  However,\
    \ [IPv6]\n   requires that IPv6 nodes handle such an ICMP \"packet too big\" message\n\
    \   by reducing the path MTU to 1280 and including an IPv6 fragment\n   header\
    \ with each packet.  This allows end-to-end path MTU discovery\n   across the\
    \ translator as long as the path MTU is 1280 bytes or\n   greater.  When the path\
    \ MTU drops below the 1280 limit the IPv6\n   sender will originate 1280 byte\
    \ packets that will be fragmented by\n   IPv4 routers along the path after being\
    \ translated to IPv4.\n   The only drawback with this scheme is that it is not\
    \ possible to use\n   PMTU to do optimal UDP fragmentation (as opposed to completely\n\
    \   avoiding fragmentation) at sender since the presence of an IPv6\n   Fragment\
    \ header is interpreted that is it OK to fragment the packet\n   on the IPv4 side.\
    \  Thus if a UDP application wants to send large\n   packets independent of the\
    \ PMTU, the sender will only be able to\n   determine the path MTU on the IPv6\
    \ side of the translator.  If the\n   path MTU on the IPv4 side of the translator\
    \ is smaller then the IPv6\n   sender will not receive any ICMP \"too big\" errors\
    \ and can not adjust\n   the size fragments it is sending.\n   Other than the\
    \ special rules for handling fragments and path MTU\n   discovery the actual translation\
    \ of the packet header consists of a\n   simple mapping as defined below.  Note\
    \ that ICMP packets require\n   special handling in order to translate the content\
    \ of ICMP error\n   message and also to add the ICMP pseudo-header checksum.\n"
- title: 4.1.  Translating IPv6 Headers into IPv4 Headers
  contents:
  - "4.1.  Translating IPv6 Headers into IPv4 Headers\n   If there is no IPv6 Fragment\
    \ header the IPv4 header fields are set as\n   follows:\n         Version:\n \
    \                4\n         Internet Header Length:\n                 5 (no IPv4\
    \ options)\n         Type of Service and Precedence:\n                 By default,\
    \ copied from the IPv6 Traffic Class (all 8\n                 bits).  According\
    \ to [DIFFSERV] the semantics of the\n                 bits are identical in IPv4\
    \ and IPv6.  However, in\n                 some IPv4 environments these bits might\
    \ be used with\n                 the old semantics of \"Type Of Service and\n\
    \                 Precedence\".  An implementation of a translator\n         \
    \        SHOULD provide the ability to ignore the IPv6 traffic\n             \
    \    class and always set the IPv4 \"TOS\" to zero.\n         Total Length:\n\
    \                 Payload length value from IPv6 header, plus the size\n     \
    \            of the IPv4 header.\n         Identification:\n                 All\
    \ zero.\n         Flags:\n                 The More Fragments flag is set to zero.\
    \  The Don't\n                 Fragments flag is set to one.\n         Fragment\
    \ Offset:\n                 All zero.\n         Time to Live:\n              \
    \   Hop Limit value copied from IPv6 header.  Since the\n                 translator\
    \ is a router, as part of forwarding the\n                 packet it needs to\
    \ decrement either the IPv6 Hop\n                 Limit (before the translation)\
    \ or the IPv4 TTL (after\n                 the translation).  As part of decrementing\
    \ the TTL or\n                 Hop Limit the translator (as any router) needs\
    \ to\n                 check for zero and send the ICMPv4 or ICMPv6 \"ttl\n  \
    \               exceeded\" error.\n         Protocol:\n                 Next Header\
    \ field copied from IPv6 header.\n         Header Checksum:\n                \
    \ Computed once the IPv4 header has been created.\n         Source Address:\n\
    \                 If the IPv6 source address is an IPv4-translated\n         \
    \        address then the low-order 32 bits of the IPv6 source\n             \
    \    address is copied to the IPv4 source address.\n                 Otherwise,\
    \ the source address is set to 0.0.0.0.  The\n                 use of 0.0.0.0\
    \ is to avoid completely dropping e.g.\n                 ICMPv6 error messages\
    \ sent by IPv6-only routers which\n                 makes e.g. traceroute present\
    \ something for the\n                 IPv6-only hops.\n         Destination Address:\n\
    \                 IPv6 packets that are translated have an IPv4-mapped\n     \
    \            destination address.  Thus the low-order 32 bits of\n           \
    \      the IPv6 destination address is copied to the IPv4\n                 destination\
    \ address.\n   If any of an IPv6 hop-by-hop options header, destination options\n\
    \   header, or routing header with the Segments Left field equal to zero\n   are\
    \ present in the IPv6 packet, they are ignored i.e., there is no\n   attempt to\
    \ translate them.  However, the Total Length field and the\n   Protocol field\
    \ would have to be adjusted to \"skip\" these extension\n   headers.\n   If a\
    \ routing header with a non-zero Segments Left field is present\n   then the packet\
    \ MUST NOT be translated, and an ICMPv6 \"parameter\n   problem/ erroneous header\
    \ field encountered\" (Type 4/Code 0) error\n   message, with the Pointer field\
    \ indicating the first byte of the\n   Segments Left field, SHOULD be returned\
    \ to the sender.\n   If the IPv6 packet contains a Fragment header the header\
    \ fields are\n   set as above with the following exceptions:\n         Total Length:\n\
    \                 Payload length value from IPv6 header, minus 8 for\n       \
    \          the Fragment header, plus the size of the IPv4\n                 header.\n\
    \         Identification:\n                 Copied from the low-order 16-bits\
    \ in the\n                 Identification field in the Fragment header.\n    \
    \     Flags:\n                 The More Fragments flag is copied from the M flag\
    \ in\n                 the Fragment header.  The Don't Fragments flag is set\n\
    \                 to zero allowing this packet to be fragmented by IPv4\n    \
    \             routers.\n         Fragment Offset:\n                 Copied from\
    \ the Fragment Offset field in the Fragment\n                 Header.\n      \
    \   Protocol:\n                 Next Header value copied from Fragment header.\n"
- title: 4.2.  Translating ICMPv6 Headers into ICMPv4 Headers
  contents:
  - "4.2.  Translating ICMPv6 Headers into ICMPv4 Headers\n   All ICMP messages that\
    \ are to be translated require that the ICMP\n   checksum field be updated as\
    \ part of the translation since ICMPv6,\n   unlike ICMPv4, has a pseudo-header\
    \ checksum just like UDP and TCP.\n   In addition all ICMP packets need to have\
    \ the Type value translated\n   and for ICMP error messages the included IP header\
    \ also needs\n   translation.\n   The actions needed to translate various ICMPv6\
    \ messages are:\n      ICMPv6 informational messages:\n        Echo Request and\
    \ Echo Reply (Type 128 and 129)\n           Adjust the type to 0 and 8, respectively,\
    \ and adjust the ICMP\n           checksum both to take the type change into account\
    \ and to\n           exclude the ICMPv6 pseudo-header.\n        MLD Multicast\
    \ Listener Query/Report/Done (Type 130, 131, 132)\n           Single hop message.\
    \  Silently drop.\n        Neighbor Discover messages (Type 133 through 137)\n\
    \           Single hop message.  Silently drop.\n        Unknown informational\
    \ messages\n           Silently drop.\n      ICMPv6 error messages:\n        Destination\
    \ Unreachable (Type 1)\n           Set the Type field to 3.  Translate the code\
    \ field as\n           follows:\n              Code 0 (no route to destination):\n\
    \                     Set Code to 1 (host unreachable).\n              Code 1\
    \ (communication with destination administratively\n              prohibited):\n\
    \                     Set Code to 10 (communication with destination host\n  \
    \                   administratively prohibited).\n              Code 2 (beyond\
    \ scope of source address):\n                     Set Code to 1 (host unreachable).\
    \  Note that this\n                     error is very unlikely since the IPv4-translatable\n\
    \                     source address is considered to have global scope.\n   \
    \           Code 3 (address unreachable):\n                     Set Code to 1\
    \ (host unreachable).\n              Code 4 (port unreachable):\n            \
    \         Set Code to 3 (port unreachable).\n        Packet Too Big (Type 2)\n\
    \           Translate to an ICMPv4 Destination Unreachable with code 4.\n    \
    \       The MTU field needs to be adjusted for the difference between\n      \
    \     the IPv4 and IPv6 header sizes taking into account whether or\n        \
    \   not the packet in error includes a Fragment header.\n        Time Exceeded\
    \ (Type 3)\n           Set the Type to 11.  The Code field is unchanged.\n   \
    \     Parameter Problem (Type 4)\n           If the Code is 1 translate this to\
    \ an ICMPv4 protocol\n           unreachable (Type 3, Code 2).  Otherwise set\
    \ the Type to 12\n           and the Code to zero.  The Pointer needs to be updated\
    \ to\n           point to the corresponding field in the translated include IP\n\
    \           header.\n        Unknown error messages\n           Silently drop.\n"
- title: 4.3.  Translating ICMPv6 Error Messages into ICMPv4
  contents:
  - "4.3.  Translating ICMPv6 Error Messages into ICMPv4\n   There are some differences\
    \ between the IPv4 and the IPv6 ICMP error\n   message formats as detailed above.\
    \  In addition, the ICMP error\n   messages contain the IP header for the packet\
    \ in error which needs to\n   be translated just like a normal IP header.  The\
    \ translation of this\n   \"packet in error\" is likely to change the length of\
    \ the datagram thus\n   the Total Length field in the outer IPv4 header might\
    \ need to be\n   updated.\n        +-------------+                 +-------------+\n\
    \        |    IPv6     |                 |    IPv4     |\n        |   Header \
    \   |                 |   Header    |\n        +-------------+               \
    \  +-------------+\n        |   ICMPv6    |                 |   ICMPv4    |\n\
    \        |   Header    |                 |   Header    |\n        +-------------+\
    \                 +-------------+\n        |    IPv6     |      ===>       | \
    \   IPv4     |\n        |   Header    |                 |   Header    |\n    \
    \    +-------------+                 +-------------+\n        |   Partial   |\
    \                 |   Partial   |\n        |  Transport  |                 | \
    \ Transport  |\n        |   Layer     |                 |   Layer     |\n    \
    \    |   Header    |                 |   Header    |\n        +-------------+\
    \                 +-------------+\n              IPv6-to-IPv4 ICMP Error Translation\n\
    \   The translation of the inner IP header can be done by recursively\n   invoking\
    \ the function that translated the outer IP headers.\n"
- title: 4.4.  Knowing when to Translate
  contents:
  - "4.4.  Knowing when to Translate\n   When the translator receives an IPv6 packet\
    \ with an IPv4-mapped\n   destination address the packet will be translated to\
    \ IPv4.\n"
- title: 5.  Implications for IPv6-Only Nodes
  contents:
  - "5.  Implications for IPv6-Only Nodes\n   An IPv6-only node which works through\
    \ SIIT translators need some\n   modifications beyond a normal IPv6-only node.\n\
    \   As specified in Section 1.3 the application protocols need to handle\n   operation\
    \ on a dual stack node.  In addition the protocol stack needs\n   to be able to:\n\
    \   o  Determine when an IPv4-translatable address needs to be allocated\n   \
    \   and the allocation needs to be refreshed/renewed.  This can\n      presumably\
    \ be done without involving the applications by e.g.\n      handling this under\
    \ the socket API.  For instance, when the\n      connect or sendto socket calls\
    \ are invoked they could check if the\n      destination is an IPv4-mapped address\
    \ and in that case\n      allocate/refresh the IPv4-translatable address.\n  \
    \ o  Ensure, as part of the source address selection mechanism, that\n      when\
    \ the destination address is an IPv4-mapped address the source\n      address\
    \ MUST be an IPv4-translatable address.  And an IPv4-\n      translatable address\
    \ MUST NOT be used with other forms of IPv6\n      destination addresses.\n  \
    \ o  Should the peer have AAAA/A6 address records the application (or\n      resolver)\
    \ SHOULD never fall back to looking for A address records\n      even if communication\
    \ fails using the available AAAA/A6 records.\n      The reason for this restriction\
    \ is to prevent traffic between two\n      IPv6 nodes (which AAAA/A6 records in\
    \ the DNS) from accidentally\n      going through SIIT translators twice; from\
    \ IPv6 to IPv4 and to\n      IPv6 again.  It is considered preferable to instead\
    \ signal a\n      failure to communicate to the application.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   The use of stateless IP/ICMP translators does\
    \ not introduce any new\n   security issues beyond the security issues that are\
    \ already present\n   in the IPv4 and IPv6 protocols and in the routing protocols\
    \ which are\n   used to make the packets reach the translator.\n   As the Authentication\
    \ Header [IPv6-AUTH] is specified to include the\n   IPv4 Identification field\
    \ and the translating function not being able\n   to always preserve the Identification\
    \ field, it is not possible for\n   an IPv6 endpoint to compute AH on received\
    \ packets that have been\n   translated from IPv4 packets.  Thus AH does not work\
    \ through a\n   translator.\n   Packets with ESP can be translated since ESP does\
    \ not depend on\n   header fields prior to the ESP header.  Note that ESP transport\
    \ mode\n   is easier to handle than ESP tunnel mode; in order to use ESP tunnel\n\
    \   mode the IPv6 node needs to be able to generate an inner IPv4 header\n   when\
    \ transmitting packets and remove such an IPv4 header when\n   receiving packets.\n"
- title: References
  contents:
  - "References\n   [KEYWORDS]   Bradner, S., \"Key words for use in RFCs to Indicate\n\
    \                Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [IPv6]\
    \       Deering, S. and R. Hinden, Editors, \"Internet Protocol,\n           \
    \     Version 6 (IPv6) Specification\", RFC 2460, December\n                1998.\n\
    \   [IPv4]       Postel, J., \"Internet Protocol\", STD 5, RFC 791,\n        \
    \        September 1981.\n   [ADDR-ARCH]  Deering, S. and R. Hinden, Editors,\
    \ \"IP Version 6\n                Addressing Architecture\", RFC 2373, July 1998.\n\
    \   [TRANS-MECH] Gilligan, R. and E. Nordmark, \"Transition Mechanisms for\n \
    \               IPv6 Hosts and Routers\", RFC 1933, April 1996.\n   [DISCOVERY]\
    \  Narten, T., Nordmark, E. and W. Simpson, \"Neighbor\n                Discovery\
    \ for IP Version 6 (IPv6)\", RFC 2461, December\n                1998.\n   [IPv6-SA]\
    \    Atkinson, R., \"Security Architecture for the Internet\n                Protocol\"\
    , RFC 2401, November 1998.\n   [IPv6-AUTH]  Atkinson, R., \"IP Authentication\
    \ Header\", RFC 2402,\n                November 1998.\n   [IPv6-ESP]   Atkinson,\
    \ R., \"IP Encapsulating Security Payload (ESP)\",\n                RFC 2406,\
    \ November 1998.\n   [ICMPv4]     Postel, J., \"Internet Control Message Protocol\"\
    , STD 5,\n                RFC 792, September 1981.\n   [ICMPv6]     Conta, A.\
    \ and S. Deering, \"Internet Control Message\n                Protocol (ICMPv6)\
    \ for the Internet Protocol Version 6\n                (IPv6)\", RFC 2463, December\
    \ 1998.\n   [IGMP]       Deering, S., \"Host extensions for IP multicasting\"\
    , STD\n                5, RFC 1112, August 1989.\n   [PMTUv4]     Mogul, J. and\
    \ S. Deering, \"Path MTU Discovery\", RFC\n                1191, November 1990.\n\
    \   [PMTUv6]     McCann, J., Deering, S. and J. Mogul, \"Path MTU\n          \
    \      Discovery for IP version 6\", RFC 1981, August 1996.\n   [DIFFSERV]   Nichols,\
    \ K., Blake, S., Baker, F. and D. Black,\n                \"Definition of the\
    \ Differentiated Services Field (DS\n                Field) in the IPv4 and IPv6\
    \ Headers\", RFC 2474, December\n                1998.\n   [MLD]        Deering,\
    \ S., Fenner, W. and B. Haberman, \"Multicast\n                Listener Discovery\
    \ (MLD) for IPv6\", RFC 2710, October\n                1999.\n   [FTPEXT]    \
    \ Allman, M., Ostermann, S. and C. Metz, \"FTP Extensions\n                for\
    \ IPv6 and NATs.\", RFC 2428, September 1998.\n   [MILLER]     G. Miller, Email\
    \ to the ngtrans mailing list on 26 March\n                1999.\n   [BSDAPI]\
    \     Gilligan, R., Thomson, S., Bound, J. and W. Stevens,\n                \"\
    Basic Socket Interface Extensions for IPv6\", RFC 2553,\n                March\
    \ 1999.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Erik Nordmark\n   Sun Microsystems, Inc.\n   901 San Antonio\
    \ Road\n   Palo Alto, CA 94303\n   USA\n   Phone: +1 650 786 5166\n   Fax:   +1\
    \ 650 786 5896\n   EMail: nordmark@sun.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2000).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
