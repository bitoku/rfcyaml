- contents:
  - '  Forward Error Correction (FEC) Framework Extension to Sliding Window

    '
  title: __initial_text__
- contents:
  - "Abstract\n   RFC 6363 describes a framework for using Forward Error Correction\n
    \  (FEC) codes to provide protection against packet loss.  The framework\n   supports
    applying FEC to arbitrary packet flows over unreliable\n   transport and is primarily
    intended for real-time, or streaming,\n   media.  However, FECFRAME as per RFC
    6363 is restricted to block FEC\n   codes.  This document updates RFC 6363 to
    support FEC codes based on\n   a sliding encoding window, in addition to block
    FEC codes, in a\n   backward-compatible way.  During multicast/broadcast real-time\n
    \  content delivery, the use of sliding window codes significantly\n   improves
    robustness in harsh environments, with less repair traffic\n   and lower FEC-related
    added latency.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8680.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2020 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction\n   2.  Terminology\n     2.1.  Definitions
    and Abbreviations\n     2.2.  Requirements Language\n   3.  Summary of Architecture
    Overview\n   4.  Procedural Overview\n     4.1.  General\n     4.2.  Sender Operation
    with Sliding Window FEC Codes\n     4.3.  Receiver Operation with Sliding Window
    FEC Codes\n   5.  Protocol Specification\n     5.1.  General\n     5.2.  FEC Framework
    Configuration Information\n     5.3.  FEC Scheme Requirements\n   6.  Feedback\n
    \  7.  Transport Protocols\n   8.  Congestion Control\n   9.  Security Considerations\n
    \  10. Operations and Management Considerations\n   11. IANA Considerations\n
    \  12. References\n     12.1.  Normative References\n     12.2.  Informative References\n
    \  Appendix A.  About Sliding Encoding Window Management\n           (Informational)\n
    \  Acknowledgments\n   Authors' Addresses\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Many applications need to transport a continuous stream
    of packetized\n   data from a source (sender) to one or more destinations (receivers)\n
    \  over networks that do not provide guaranteed packet delivery.  In\n   particular,
    packets may be lost, which is strictly the focus of this\n   document: we assume
    that transmitted packets are either lost (e.g.,\n   because of a congested router,
    a poor signal-to-noise ratio in a\n   wireless network, or because the number
    of bit errors exceeds the\n   correction capabilities of the physical-layer error-correcting
    code)\n   or were received by the transport protocol without any corruption\n
    \  (i.e., the bit errors, if any, have been fixed by the physical-layer\n   error-correcting
    code and therefore are hidden to the upper layers).\n   For these use cases, Forward
    Error Correction (FEC) applied within\n   the transport or application layer is
    an efficient technique to\n   improve packet transmission robustness in the presence
    of packet\n   losses (or \"erasures\") without going through packet retransmissions\n
    \  that create a delay often incompatible with real-time constraints.\n   The
    FEC Building Block defined in [RFC5052] provides a framework for\n   the definition
    of Content Delivery Protocols (CDPs) that make use of\n   separately defined FEC
    schemes.  Any CDP defined according to the\n   requirements of the FEC Building
    Block can then easily be used with\n   any FEC scheme that is also defined according
    to the requirements of\n   the FEC Building Block.\n   Then, FECFRAME [RFC6363]
    provides a framework to define Content\n   Delivery Protocols (CDPs) that provide
    FEC protection for arbitrary\n   packet flows over an unreliable datagram service
    transport, such as\n   UDP.  It is primarily intended for real-time or streaming
    media\n   applications that are using broadcast, multicast, or on-demand\n   delivery.
    \ A subset of FECFRAME is currently part of the 3GPP Evolved\n   Multimedia Broadcast/Multicast
    Service (eMBMS) standard [MBMSTS].\n   However, [RFC6363] only considers block
    FEC schemes defined in\n   accordance with the FEC Building Block [RFC5052] (e.g.,
    [RFC6681],\n   [RFC6816], or [RFC6865]).  These codes require the input flow(s)
    to\n   be segmented into a sequence of blocks.  Then, FEC encoding (at a\n   sender
    or an encoding middlebox) and decoding (at a receiver or a\n   decoding middlebox)
    are both performed on a per-block basis.  For\n   instance, if the current block
    encompasses the 100's to 119's source\n   symbols (i.e., a block of size 20 symbols)
    of an input flow, encoding\n   (and decoding) will be performed on this block
    independently of other\n   blocks.  This approach has major impacts on FEC encoding
    and decoding\n   delays.  The data packets of continuous media flow(s) may be
    passed\n   to the transport layer immediately, without delay.  But the block\n
    \  creation time, which depends on the number of source symbols in this\n   block,
    impacts both the FEC encoding delay (since encoding requires\n   that all source
    symbols be known) and, mechanically, the packet loss\n   recovery delay at a receiver
    (since no repair symbol for the current\n   block can be generated and therefore
    received before that time).\n   Therefore, a good value for the block size is
    necessarily a balance\n   between the maximum FEC decoding latency at the receivers
    (which must\n   be in line with the most stringent real-time requirement of the\n
    \  protected flow(s), hence an incentive to reduce the block size) and\n   the
    desired robustness against long loss bursts (which increases with\n   the block
    size, hence an incentive to increase this size).\n   This document updates [RFC6363]
    in order to also support FEC codes\n   based on a sliding encoding window (a.k.a.,
    convolutional codes)\n   [RFC8406].  This encoding window, either fixed or variable
    size,\n   slides over the set of source symbols.  FEC encoding is launched\n   whenever
    needed from the set of source symbols present in the sliding\n   encoding window
    at that time.  This approach significantly reduces\n   FEC-related latency, since
    repair symbols can be generated and passed\n   to the transport layer on the fly
    at any time and can be regularly\n   received by receivers to quickly recover
    packet losses.  Using\n   sliding window FEC codes is therefore highly beneficial
    to real-time\n   flows, one of the primary targets of FECFRAME.  [RFC8681] provides
    an\n   example of such a FEC scheme for FECFRAME, which is built upon the\n   simple
    sliding window Random Linear Code (RLC).\n   This document is fully backward compatible
    with [RFC6363].  Indeed:\n   *  This FECFRAME update does not prevent or compromise
    in any way the\n      support of block FEC codes.  Both types of codes can nicely\n
    \     coexist, just like different block FEC schemes can coexist.\n   *  Each
    sliding window FEC scheme is associated with a specific FEC\n      Encoding ID
    subject to IANA registration, just like block FEC\n      schemes.\n   *  Any receiver
    -- for instance, a legacy receiver that only supports\n      block FEC schemes
    -- can easily identify the FEC scheme used in a\n      FECFRAME session.  Indeed,
    the FEC Encoding ID that identifies the\n      FEC scheme is carried in FEC Framework
    Configuration Information\n      (see Section 5.5 of [RFC6363]).  For instance,
    when the Session\n      Description Protocol (SDP) is used to carry the FEC Framework\n
    \     Configuration Information, the FEC Encoding ID can be communicated\n      in
    the \"encoding-id=\" parameter of a \"fec-repair-flow\" attribute\n      [RFC6364].
    \ This mechanism is the basic approach for a FECFRAME\n      receiver to determine
    whether or not it supports the FEC scheme\n      used in a given FECFRAME session.\n
    \  This document leverages on [RFC6363] and reuses its structure.  It\n   proposes
    new sections specific to sliding window FEC codes whenever\n   required.  The
    only exception is Section 3, which provides a quick\n   summary of FECFRAME in
    order to facilitate the understanding of this\n   document to readers not familiar
    with the concepts and terminology.\n"
  title: 1.  Introduction
- contents:
  - '2.  Terminology

    '
  - contents:
    - "2.1.  Definitions and Abbreviations\n   The following list of definitions and
      abbreviations is copied from\n   [RFC6363], adding only the Block FEC Code,
      Sliding Window FEC Code,\n   and Encoding/Decoding Window definitions (tagged
      with \"ADDED\"):\n   Application Data Unit (ADU):\n      The unit of source
      data provided as a payload to the transport\n      layer.  For instance, it
      can be a payload containing the result of\n      the RTP packetization of a
      compressed video frame.\n   ADU Flow:\n      A sequence of ADUs associated with
      a transport-layer flow\n      identifier (such as the standard 5-tuple {source
      IP address,\n      source port, destination IP address, destination port, transport\n
      \     protocol}).\n   AL-FEC:\n      Application-Layer Forward Error Correction.\n
      \  Application Protocol:\n      Control protocol used to establish and control
      the source flow\n      being protected, e.g., the Real-Time Streaming Protocol
      (RTSP).\n   Content Delivery Protocol (CDP):\n      A complete application protocol
      specification that, through the\n      use of the framework defined in this
      document, is able to make use\n      of FEC schemes to provide FEC capabilities.\n
      \  FEC Code:\n      An algorithm for encoding data such that the encoded data
      flow is\n      resilient to data loss.  Note that, in general, FEC codes may
      also\n      be used to make a data flow resilient to corruption, but that is\n
      \     not considered in this document.\n   Block FEC Code: (ADDED)\n      A
      FEC code that operates on blocks, i.e., for which the input flow\n      MUST
      be segmented into a sequence of blocks, with FEC encoding and\n      decoding
      being performed independently on a per-block basis.\n   Sliding Window FEC Code:
      (ADDED)\n      A FEC code that can generate repair symbols on the fly, at any\n
      \     time, from the set of source symbols present in the sliding\n      encoding
      window at that time.  These codes are also known as\n      convolutional codes.\n
      \  FEC Framework:\n      A protocol framework for the definition of Content
      Delivery\n      Protocols using FEC, such as the framework defined in this\n
      \     document.\n   FEC Framework Configuration Information:\n      Information
      that controls the operation of the FEC Framework.\n   FEC Payload ID:\n      Information
      that identifies the contents and provides positional\n      information of a
      packet with respect to the FEC scheme.\n   FEC Repair Packet:\n      At a sender
      (respectively, at a receiver), a payload submitted to\n      (respectively,
      received from) the transport protocol containing\n      one or more repair symbols
      along with a Repair FEC Payload ID and\n      possibly an RTP header.\n   FEC
      Scheme:\n      A specification that defines the additional protocol aspects\n
      \     required to use a particular FEC code with the FEC Framework.\n   FEC
      Source Packet:\n      At a sender (respectively, at a receiver), a payload submitted
      to\n      (respectively, received from) the transport protocol containing an\n
      \     ADU along with an optional Explicit Source FEC Payload ID.\n   Repair
      Flow:\n      The packet flow carrying FEC data.\n   Repair FEC Payload ID:\n
      \     A FEC Payload ID specifically for use with repair packets.\n   Source
      Flow:\n      The packet flow to which FEC protection is to be applied.  A\n
      \     source flow consists of ADUs.\n   Source FEC Payload ID:\n      A FEC
      Payload ID specifically for use with source packets.\n   Source Protocol:\n
      \     A protocol used for the source flow being protected, e.g., RTP.\n   Transport
      Protocol:\n      The protocol used for the transport of the source and repair\n
      \     flows.  This protocol needs to provide an unreliable datagram\n      service,
      as UDP does ([RFC6363], Section 7).\n   Encoding Window: (ADDED)\n      Set
      of source symbols available at the sender/coding node that are\n      used (with
      a Sliding Window FEC code) to generate a repair symbol.\n   Decoding Window:
      (ADDED)\n      Set of received or decoded source and repair symbols available
      at\n      a receiver that are used (with a Sliding Window FEC code) to\n      decode
      lost source symbols.\n   Code Rate:\n      The ratio between the number of source
      symbols and the number of\n      encoding symbols.  By definition, the code
      rate is such that 0 <\n      code rate <= 1.  A code rate close to 1 indicates
      that a small\n      number of repair symbols have been produced during the encoding\n
      \     process.\n   Encoding Symbol:\n      Unit of data generated by the encoding
      process.  With systematic\n      codes, source symbols are part of the encoding
      symbols.\n   Packet Erasure Channel:\n      A communication path where packets
      are either lost (e.g., in our\n      case, by a congested router, or because
      the number of transmission\n      errors exceeds the correction capabilities
      of the physical-layer\n      code) or received.  When a packet is received,
      it is assumed that\n      this packet is not corrupted (i.e., in our case, the
      bit errors,\n      if any, are fixed by the physical-layer code and are therefore\n
      \     hidden to the upper layers).\n   Repair Symbol:\n      Encoding symbol
      that is not a source symbol.\n   Source Block:\n      Group of ADUs that are
      to be FEC protected as a single block.\n      This notion is restricted to Block
      FEC codes.\n   Source Symbol:\n      Unit of data used during the encoding process.\n
      \  Systematic Code:\n      FEC code in which the source symbols are part of
      the encoding\n      symbols.\n"
    title: 2.1.  Definitions and Abbreviations
  - contents:
    - "2.2.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT
      RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted
      as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear
      in all\n   capitals, as shown here.\n"
    title: 2.2.  Requirements Language
  title: 2.  Terminology
- contents:
  - "3.  Summary of Architecture Overview\n   The architecture of Section 3 of [RFC6363]
    equally applies to this\n   FECFRAME extension and is not repeated here.  However,
    this section\n   includes a quick summary to facilitate the understanding of this\n
    \  document to readers not familiar with the concepts and terminology.\n   +----------------------+\n
    \  |     Application      |\n   +----------------------+\n              |\n              |
    (1) Application Data Units (ADUs)\n              |\n              v\n   |    FEC
    Framework     |                           |                |\n   |(2) Construct
    source  |(3) Source Block           |                |\n   |    blocks            |
    \                          |(4) FEC Encoding|\n   |(6) Construct FEC     |<--------------------------|
    \               |\n   |    Source and Repair |                           |                |\n
    \  |    Packets           |(5) Explicit Source FEC    |                |\n   +----------------------+
    \   Payload IDs            +----------------+\n              |                Repair
    FEC Payload IDs\n              |                Repair symbols\n              |\n
    \             |(7) FEC Source and Repair Packets\n              v\n   +----------------------+\n
    \  |  Transport Protocol  |\n   +----------------------+\n                Figure
    1: FECFRAME Architecture at a Sender\n   The FECFRAME architecture is illustrated
    in Figure 1 for a block FEC\n   scheme from the sender's point of view.  It shows
    an application\n   generating an ADU flow (other flows from other applications
    may\n   coexist).  These ADUs of variable size must be somehow mapped to\n   source
    symbols of a fixed size (this fixed size is a requirement of\n   all FEC schemes,
    which comes from the way mathematical operations are\n   applied to the symbols'
    content).  This is the goal of an ADU-to-\n   symbols mapping process that is
    FEC scheme specific (see below).\n   Once the source block is built, taking into
    account both the FEC\n   scheme constraints (e.g., in terms of maximum source
    block size) and\n   the application's flow constraints (e.g., in terms of real-time\n
    \  constraints), the associated source symbols are handed to the FEC\n   scheme
    in order to produce an appropriate number of repair symbols.\n   FEC Source Packets
    (containing ADUs) and FEC Repair Packets\n   (containing one or more repair symbols
    each) are then generated and\n   sent using an appropriate transport protocol
    (more precisely,\n   Section 7 of [RFC6363] requires a transport protocol providing
    an\n   unreliable datagram service, such as UDP).  In practice, FEC Source\n   Packets
    may be passed to the transport layer as soon as available\n   without having to
    wait for FEC encoding to take place.  In that case,\n   a copy of the associated
    source symbols needs to be kept within\n   FECFRAME for future FEC encoding purposes.\n
    \  At a receiver (not shown), FECFRAME processing operates in a similar\n   way,
    taking as input the incoming FEC Source and Repair Packets\n   received.  In case
    of FEC Source Packet losses, the FEC decoding of\n   the associated block may
    recover all (in case of successful decoding)\n   or a subset that is potentially
    empty (if decoding fails) of the\n   missing source symbols.  After source-symbol-to-ADU
    mapping, when\n   lost ADUs are recovered, they are then assigned to their respective\n
    \  flow (see below).  ADUs are returned to the application(s), either in\n   their
    initial transmission order (in which case all ADUs received\n   after a lost ADU
    will be delayed until FEC decoding has taken place)\n   or not (in which case
    each ADU is returned as soon as it is received\n   or recovered), depending on
    the application requirements.\n   FECFRAME features two subtle mechanisms whose
    details are FEC scheme\n   dependent:\n   *  ADUs-to-source-symbols mapping: in
    order to manage variable size\n      ADUs, FECFRAME and FEC schemes can use small,
    fixed-size symbols\n      and create a mapping between ADUs and symbols.  The
    mapping\n      details are FEC scheme dependent and must be defined in the\n      associated
    document.  For instance, with certain FEC schemes, to\n      each ADU, this mechanism
    prepends a length field (plus a flow\n      identifier; see below) and pads the
    result to a multiple of the\n      symbol size.  A small ADU may be mapped to
    a single source symbol,\n      while a large one may be mapped to multiple symbols.\n
    \  *  Assignment of decoded ADUs to flows in multi-flow configurations:\n      when
    multiple flows are multiplexed over the same FECFRAME\n      instance, a problem
    is to assign a decoded ADU to the right flow\n      (UDP port numbers and IP addresses
    traditionally used to map\n      incoming ADUs to flows are not recovered during
    FEC decoding).\n      The mapping details are FEC scheme dependent and must be
    defined\n      in the associated document.  For instance, with certain FEC\n      schemes,
    to make it possible, at the FECFRAME sending instance,\n      each ADU is prepended
    with a flow identifier (1 byte) during the\n      ADU-to-source-symbols mapping
    (see above).  The flow identifiers\n      are also shared between all FECFRAME
    instances as part of the FEC\n      Framework Configuration Information.  The
    ADU Information (ADUI),\n      which includes the flow identifier, length, application
    payload,\n      and padding, is then FEC protected.  Therefore, a decoded ADUI\n
    \     contains enough information to assign the ADU to the right flow.\n      Note
    that a FEC scheme may also be restricted to the particular\n      case of a single
    flow over a FECFRAME instance; that would make\n      the above mechanism pointless.\n
    \  A few aspects are not covered by FECFRAME, namely:\n   *  Section 8 of [RFC6363]
    does not detail any congestion control\n      mechanisms and only provides high-level
    normative requirements.\n   *  The possibility of having feedback from receiver(s)
    is considered\n      out of scope, although such a mechanism may exist within
    the\n      application (e.g., through RTP Control Protocol (RTCP) messages).\n
    \  *  Flow adaptation at a FECFRAME sender (e.g., how to set the FEC\n      code
    rate based on transmission conditions) is not detailed, but\n      it needs to
    comply with the congestion control normative\n      requirements (see above).\n"
  title: 3.  Summary of Architecture Overview
- contents:
  - '4.  Procedural Overview

    '
  - contents:
    - "4.1.  General\n   The general considerations of Section 4.1 of [RFC6363] that
      are\n   specific to block FEC codes are not repeated here.\n   With a Sliding
      Window FEC code, the FEC Source Packet MUST contain\n   information to identify
      the position occupied by the ADU within the\n   source flow in terms specific
      to the FEC scheme.  This information is\n   known as the Source FEC Payload
      ID, and the FEC scheme is responsible\n   for defining and interpreting it.\n
      \  With a Sliding Window FEC code, the FEC Repair Packets MUST contain\n   information
      that identifies the relationship between the contained\n   repair payloads and
      the original source symbols used during encoding.\n   This information is known
      as the Repair FEC Payload ID, and the FEC\n   scheme is responsible for defining
      and interpreting it.\n   The sender operation ([RFC6363], Section 4.2) and receiver
      operation\n   ([RFC6363], Section 4.3) are both specific to block FEC codes
      and are\n   therefore omitted below.  The following two sections detail similar\n
      \  operations for Sliding Window FEC codes.\n"
    title: 4.1.  General
  - contents:
    - "4.2.  Sender Operation with Sliding Window FEC Codes\n   With a Sliding Window
      FEC scheme, the following operations,\n   illustrated in Figure 2 for the generic
      case (non-RTP repair flows)\n   and in Figure 3 for the case of RTP repair flows,
      describe a possible\n   way to generate compliant source and repair flows:\n
      \  1.   A new ADU is provided by the application.\n   2.   The FEC Framework
      communicates this ADU to the FEC scheme.\n   3.   The sliding encoding window
      is updated by the FEC scheme.  The\n        ADU-to-source-symbol mapping as
      well as the encoding window\n        management details are both the responsibility
      of the FEC scheme\n        and MUST be detailed there.  Appendix A provides
      non-normative\n        hints about what FEC scheme designers need to consider.\n
      \  4.   The Source FEC Payload ID information of the source packet is\n        determined
      by the FEC scheme.  If required by the FEC scheme,\n        the Source FEC Payload
      ID is encoded into the Explicit Source\n        FEC Payload ID field and returned
      to the FEC Framework.\n   5.   The FEC Framework constructs the FEC Source Packet
      according to\n        Figure 6 in [RFC6363], using the Explicit Source FEC Payload
      ID\n        provided by the FEC scheme if applicable.\n   6.   The FEC Source
      Packet is sent using normal transport-layer\n        procedures.  This packet
      is sent using the same ADU flow\n        identification information as would
      have been used for the\n        original source packet if the FEC Framework
      were not present\n        (e.g., the source and destination addresses and UDP
      port numbers\n        on the IP datagram carrying the source packet will be
      the same\n        whether or not the FEC Framework is applied).\n   7.   When
      the FEC Framework needs to send one or several FEC Repair\n        Packets (e.g.,
      according to the target code rate), it asks the\n        FEC scheme to create
      one or several repair packet payloads from\n        the current sliding encoding
      window along with their Repair FEC\n        Payload ID.\n   8.   The Repair
      FEC Payload IDs and repair packet payloads are\n        provided back by the
      FEC scheme to the FEC Framework.\n   9.   The FEC Framework constructs FEC Repair
      Packets according to\n        Figure 7 in [RFC6363], using the FEC Payload IDs
      and repair\n        packet payloads provided by the FEC scheme.\n   10.  The
      FEC Repair Packets are sent using normal transport-layer\n        procedures.
      \ The port(s) and multicast group(s) to be used for\n        FEC Repair Packets
      are defined in the FEC Framework\n        Configuration Information.\n   +----------------------+\n
      \  |     Application      |\n   +----------------------+\n              |\n
      \             | (1) New Application Data Unit (ADU)\n              v\n   |    FEC
      Framework    |                           |   FEC Scheme   |\n   |                     |
      (2) New ADU               |(3) Update of   |\n   |(5) Construct FEC    | (4)
      Explicit Source       |                |\n   |    Source Packet    |     FEC
      Payload ID(s)     |(7) FEC         |\n   |(9) Construct FEC    | (8) Repair
      FEC Payload ID |                |\n   |    Repair Packet(s) |     + Repair symbol(s)
      \   +----------------+\n   +---------------------+\n              |\n              |
      (6)  FEC Source Packet\n              | (10) FEC Repair Packets\n              v\n
      \  +----------------------+\n   |  Transport Protocol  |\n   +----------------------+\n
      \         Figure 2: Sender Operation with Sliding Window FEC Codes\n   +----------------------+\n
      \  |     Application      |\n   +----------------------+\n              |\n
      \             | (1) New Application Data Unit (ADU)\n              v\n   |    FEC
      Framework    |                           |   FEC Scheme   |\n   |                     |
      (2) New ADU               |(3) Update of   |\n   |(5) Construct FEC    | (4)
      Explicit Source       |                |\n   |    Source Packet    |     FEC
      Payload ID(s)     |(7) FEC         |\n   |(9) Construct FEC    | (8) Repair
      FEC Payload ID |                |\n   |    Repair Packet(s) |     + Repair symbol(s)
      \   +----------------+\n   +---------------------+\n       |             |\n
      \      |(6) Source   |(10) Repair payloads\n       |    packets  |\n       |
      \     + -- -- -- -- -+\n       |      |     RTP      |\n       |      +-- --
      -- -- --+\n       v             v\n   +----------------------+\n   |  Transport
      Protocol  |\n   +----------------------+\n      Figure 3: Sender Operation with
      Sliding Window FEC Codes and RTP\n"
    title: 4.2.  Sender Operation with Sliding Window FEC Codes
  - contents:
    - "4.3.  Receiver Operation with Sliding Window FEC Codes\n   With a Sliding Window
      FEC scheme, the following operations are\n   illustrated in Figure 4 for the
      generic case (non-RTP repair flows)\n   and in Figure 5 for the case of RTP
      repair flows.  The only\n   differences with respect to block FEC codes lie
      in steps (4) and (5).\n   Therefore, this section does not repeat the other
      steps of\n   Section 4.3 of [RFC6363] (\"Receiver Operation\").  The new steps
      (4)\n   and (5) are:\n   4.  The FEC scheme uses the received FEC Payload IDs
      (and derived FEC\n       Source Payload IDs when the Explicit Source FEC Payload
      ID field\n       is not used) to insert source and repair packets into the\n
      \      decoding window in the right way.  If at least one source packet\n       is
      missing and at least one repair packet has been received, then\n       FEC decoding
      is attempted to recover the missing source payloads.\n       The FEC scheme
      determines whether source packets have been lost\n       and whether enough
      repair packets have been received to decode\n       any or all of the missing
      source payloads.\n   5.  The FEC scheme returns the received and decoded ADUs
      to the FEC\n       Framework, along with indications of any ADUs that were missing\n
      \      and could not be decoded.\n   +----------------------+\n   |     Application
      \     |\n   +----------------------+\n              ^\n              |(6) ADUs\n
      \             |\n   |    FEC Framework     |                           |   FEC
      Scheme   |\n   |(2)Extract FEC Payload|(5) ADUs                   |(4) FEC Decoding|\n
      \  |   IDs and pass IDs & |-------------------------->|                |\n   |
      \  payloads to FEC    |(3) Explicit Source FEC    +----------------+\n   |   scheme
      \            |            Payload IDs\n   +----------------------+    Repair
      FEC Payload IDs\n              ^                Source payloads\n              |
      \               Repair payloads\n              |(1) FEC Source\n              |
      \   and Repair Packets\n   +----------------------+\n   |  Transport Protocol
      \ |\n   +----------------------+\n         Figure 4: Receiver Operation with
      Sliding Window FEC Codes\n   +----------------------+\n   |     Application
      \     |\n   +----------------------+\n              ^\n              |(6) ADUs\n
      \             |\n   |    FEC Framework     |                           |   FEC
      Scheme   |\n   |(2)Extract FEC Payload|(5) ADUs                   |(4) FEC Decoding|\n
      \  |   IDs and pass IDs & |-------------------------->|                |\n   |
      \  payloads to FEC    |(3) Explicit Source FEC    +----------------+\n   |   scheme
      \            |            Payload IDs\n   +----------------------+    Repair
      FEC Payload IDs\n       ^             ^         Source payloads\n       |             |
      \        Repair payloads\n       |Source pkts  |Repair payloads\n       |             |\n
      \  +-- |- -- -- -- -- -- -+\n   |RTP| | RTP Processing |\n   |   | +-- -- --
      --|-- -+\n   | +-- -- -- -- -- |--+ |\n   | | RTP Demux        | |\n   +-- --
      -- -- -- -- -- -+\n              ^\n              |(1) FEC Source and Repair
      Packets\n              |\n   +----------------------+\n   |  Transport Protocol
      \ |\n   +----------------------+\n       Figure 5: Receiver Operation with Sliding
      Window FEC Codes and\n                              RTP Repair Flows\n"
    title: 4.3.  Receiver Operation with Sliding Window FEC Codes
  title: 4.  Procedural Overview
- contents:
  - '5.  Protocol Specification

    '
  - contents:
    - "5.1.  General\n   This section discusses the protocol elements for the FEC
      Framework\n   specific to Sliding Window FEC schemes.  The global formats of
      source\n   data packets (i.e., [RFC6363], Figure 6) and repair data packets\n
      \  (i.e., [RFC6363], Figures 7 and 8) remain the same with Sliding\n   Window
      FEC codes.  They are not repeated here.\n"
    title: 5.1.  General
  - contents:
    - "5.2.  FEC Framework Configuration Information\n   The FEC Framework Configuration
      Information considerations of\n   Section 5.5 of [RFC6363] equally apply to
      this FECFRAME extension and\n   are not repeated here.\n"
    title: 5.2.  FEC Framework Configuration Information
  - contents:
    - "5.3.  FEC Scheme Requirements\n   The FEC scheme requirements of Section 5.6
      of [RFC6363] mostly apply\n   to this FECFRAME extension and are not repeated
      here.  An exception,\n   though, is the \"full specification of the FEC code\",
      item (4), which\n   is specific to block FEC codes.  In case of a Sliding Window
      FEC\n   scheme, then the following item (4-bis) applies:\n   4-bis.\n       A
      full specification of the Sliding Window FEC code.\n       This specification
      MUST precisely define the valid FEC-Scheme-\n       Specific Information values,
      the valid FEC Payload ID values, and\n       the valid packet payload sizes
      (where \"packet payload\" refers to\n       the space within a packet dedicated
      to carrying encoding\n       symbols).\n       Furthermore, given valid values
      of the FEC-Scheme-Specific\n       Information, a valid Repair FEC Payload ID
      value, a valid packet\n       payload size, and a valid encoding window (i.e.,
      a set of source\n       symbols), the specification MUST uniquely define the
      values of\n       the encoding symbol (or symbols) to be included in the repair\n
      \      packet payload with the given Repair FEC Payload ID value.\n   Additionally,
      the FEC scheme associated with a Sliding Window FEC\n   code:\n   *  MUST define
      the relationships between ADUs and the associated\n      source symbols (mapping).\n
      \  *  MUST define the management of the encoding window that slides over\n      the
      set of ADUs.  Appendix A provides non-normative hints about\n      what FEC
      scheme designers need to consider.\n   *  MUST define the management of the
      decoding window.  This usually\n      consists of managing a system of linear
      equations (for a linear\n      FEC code).\n"
    title: 5.3.  FEC Scheme Requirements
  title: 5.  Protocol Specification
- contents:
  - "6.  Feedback\n   The discussion in Section 6 of [RFC6363] equally applies to
    this\n   FECFRAME extension and is not repeated here.\n"
  title: 6.  Feedback
- contents:
  - "7.  Transport Protocols\n   The discussion in Section 7 of [RFC6363] equally
    applies to this\n   FECFRAME extension and is not repeated here.\n"
  title: 7.  Transport Protocols
- contents:
  - "8.  Congestion Control\n   The discussion in Section 8 of [RFC6363] equally applies
    to this\n   FECFRAME extension and is not repeated here.\n"
  title: 8.  Congestion Control
- contents:
  - "9.  Security Considerations\n   This FECFRAME extension does not add any new
    security considerations.\n   All the considerations of Section 9 of [RFC6363]
    apply to this\n   document as well.  However, for the sake of completeness, the\n
    \  following goal can be added to the list provided in Section 9.1 of\n   [RFC6363]
    (\"Problem Statement\"):\n   *  Attacks can try to corrupt source flows in order
    to modify the\n      receiver application's behavior (as opposed to just denying\n
    \     service).\n"
  title: 9.  Security Considerations
- contents:
  - "10.  Operations and Management Considerations\n   This FECFRAME extension does
    not add any new Operations and\n   Management Considerations.  All the considerations
    of Section 10 of\n   [RFC6363] apply to this document as well.\n"
  title: 10.  Operations and Management Considerations
- contents:
  - "11.  IANA Considerations\n   This document has no IANA actions.\n   A FEC scheme
    for use with this FEC Framework is identified via its\n   FEC Encoding ID.  It
    is subject to IANA registration in the \"FEC\n   Framework (FECFRAME) FEC Encoding
    IDs\" registry.  All the rules of\n   Section 11 of [RFC6363] apply and are not
    repeated here.\n"
  title: 11.  IANA Considerations
- contents:
  - '12.  References

    '
  - contents:
    - "12.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n
      \             DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n
      \  [RFC6363]  Watson, M., Begen, A., and V. Roca, \"Forward Error\n              Correction
      (FEC) Framework\", RFC 6363,\n              DOI 10.17487/RFC6363, October 2011,\n
      \             <https://www.rfc-editor.org/info/rfc6363>.\n   [RFC8174]  Leiba,
      B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119 Key Words\",
      BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n"
    title: 12.1.  Normative References
  - contents:
    - "12.2.  Informative References\n   [MBMSTS]   3GPP, \"Multimedia Broadcast/Multicast
      Service (MBMS);\n              Protocols and codecs\", 3GPP TS 26.346, March
      2009,\n              <http://ftp.3gpp.org/specs/html-info/26346.htm>.\n   [RFC5052]
      \ Watson, M., Luby, M., and L. Vicisano, \"Forward Error\n              Correction
      (FEC) Building Block\", RFC 5052,\n              DOI 10.17487/RFC5052, August
      2007,\n              <https://www.rfc-editor.org/info/rfc5052>.\n   [RFC6364]
      \ Begen, A., \"Session Description Protocol Elements for the\n              Forward
      Error Correction (FEC) Framework\", RFC 6364,\n              DOI 10.17487/RFC6364,
      October 2011,\n              <https://www.rfc-editor.org/info/rfc6364>.\n   [RFC6681]
      \ Watson, M., Stockhammer, T., and M. Luby, \"Raptor Forward\n              Error
      Correction (FEC) Schemes for FECFRAME\", RFC 6681,\n              DOI 10.17487/RFC6681,
      August 2012,\n              <https://www.rfc-editor.org/info/rfc6681>.\n   [RFC6816]
      \ Roca, V., Cunche, M., and J. Lacan, \"Simple Low-Density\n              Parity
      Check (LDPC) Staircase Forward Error Correction\n              (FEC) Scheme
      for FECFRAME\", RFC 6816,\n              DOI 10.17487/RFC6816, December 2012,\n
      \             <https://www.rfc-editor.org/info/rfc6816>.\n   [RFC6865]  Roca,
      V., Cunche, M., Lacan, J., Bouabdallah, A., and K.\n              Matsuzono,
      \"Simple Reed-Solomon Forward Error Correction\n              (FEC) Scheme for
      FECFRAME\", RFC 6865,\n              DOI 10.17487/RFC6865, February 2013,\n
      \             <https://www.rfc-editor.org/info/rfc6865>.\n   [RFC8406]  Adamson,
      B., Adjih, C., Bilbao, J., Firoiu, V., Fitzek,\n              F., Ghanem, S.,
      Lochin, E., Masucci, A., Montpetit, M-J.,\n              Pedersen, M., Peralta,
      G., Roca, V., Ed., Saxena, P., and\n              S. Sivakumar, \"Taxonomy of
      Coding Techniques for Efficient\n              Network Communications\", RFC
      8406, DOI 10.17487/RFC8406,\n              June 2018, <https://www.rfc-editor.org/info/rfc8406>.\n
      \  [RFC8681]  Roca, V. and B. Teibi, \"Sliding Window Random Linear Code\n              (RLC)
      Forward Erasure Correction (FEC) Schemes for\n              FECFRAME\", RFC
      8681, DOI 10.17487/RFC8681, January 2020,\n              <https://www.rfc-editor.org/info/rfc8681>.\n"
    title: 12.2.  Informative References
  title: 12.  References
- contents:
  - "Appendix A.  About Sliding Encoding Window Management (Informational)\n   The
    FEC Framework does not specify the management of the sliding\n   encoding window,
    which is the responsibility of the FEC scheme.  This\n   annex only provides a
    few informational hints.\n   Source symbols are added to the sliding encoding
    window each time a\n   new ADU is available at the sender after the ADU-to-source-symbol\n
    \  mapping specific to the FEC scheme has been done.\n   Source symbols are removed
    from the sliding encoding window.  For\n   instance:\n   *  After a certain delay,
    when an \"old\" ADU of a real-time flow times\n      out.  The source symbol retention
    delay in the sliding encoding\n      window should therefore be initialized according
    to the real-time\n      features of incoming flow(s) when applicable.\n   *  Once
    the sliding encoding window has reached its maximum size\n      (there is usually
    an upper limit to the sliding encoding window\n      size).  In that case, the
    oldest symbol is removed each time a new\n      source symbol is added.\n   Several
    considerations can impact the management of this sliding\n   encoding window:\n
    \  *  At the source flows level: real-time constraints can limit the\n      total
    time during which source symbols can remain in the encoding\n      window.\n   *
    \ At the FEC code level: theoretical or practical limitations (e.g.,\n      because
    of computational complexity) can limit the number of\n      source symbols in
    the encoding window.\n   *  At the FEC scheme level: signaling and window management
    are\n      intrinsically related.  For instance, an encoding window composed\n
    \     of a nonsequential set of source symbols requires appropriate\n      signaling
    to inform a receiver of the composition of the encoding\n      window, and the
    associated transmission overhead can limit the\n      maximum encoding window
    size.  On the contrary, an encoding window\n      always composed of a sequential
    set of source symbols simplifies\n      signaling: providing the identity of the
    first source symbol plus\n      its number is sufficient, which creates a fixed
    and relatively\n      small transmission overhead.\n"
  title: Appendix A.  About Sliding Encoding Window Management (Informational)
- contents:
  - "Acknowledgments\n   The authors would like to thank Christer Holmberg, David
    Black, Gorry\n   Fairhurst, Emmanuel Lochin, Spencer Dawkins, Ben Campbell, Benjamin\n
    \  Kaduk, Eric Rescorla, Adam Roach, and Greg Skinner for their valuable\n   feedback
    on this document.  This document being an extension of\n   [RFC6363], the authors
    would also like to thank Mark Watson as the\n   main author of that RFC.\n"
  title: Acknowledgments
- contents:
  - "Authors' Addresses\n   Vincent Roca\n   INRIA\n   Univ. Grenoble Alpes\n   France\n
    \  Email: vincent.roca@inria.fr\n   Ali Begen\n   Networked Media\n   Konya/\n"
  title: Authors' Addresses
