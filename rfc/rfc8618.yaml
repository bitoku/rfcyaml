- title: __initial_text__
  contents:
  - '         Compacted-DNS (C-DNS): A Format for DNS Packet Capture

    '
- title: Abstract
  contents:
  - "Abstract\n   This document describes a data representation for collections of\
    \ DNS\n   messages.  The format is designed for efficient storage and\n   transmission\
    \ of large packet captures of DNS traffic; it attempts to\n   minimize the size\
    \ of such packet capture files but retain the full\n   DNS message contents along\
    \ with the most useful transport metadata.\n   It is intended to assist with the\
    \ development of DNS traffic-\n   monitoring applications.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 7841.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8618.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2019 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   4\n   2.  Terminology . . . . . . . . . . . . . . . . . . . . .\
    \ . . . .   5\n   3.  Data Collection Use Cases . . . . . . . . . . . . . . .\
    \ . . .   5\n   4.  Design Considerations . . . . . . . . . . . . . . . . . .\
    \ . .   8\n   5.  Choice of CBOR  . . . . . . . . . . . . . . . . . . . . . .\
    \ .  10\n   6.  C-DNS Format Conceptual Overview  . . . . . . . . . . . . . .\
    \  10\n     6.1.  Block Parameters  . . . . . . . . . . . . . . . . . . . .  14\n\
    \     6.2.  Storage Parameters  . . . . . . . . . . . . . . . . . . .  14\n  \
    \     6.2.1.  Optional Data Items . . . . . . . . . . . . . . . . .  15\n    \
    \   6.2.2.  Optional RRs and OPCODEs  . . . . . . . . . . . . . .  16\n      \
    \ 6.2.3.  Storage Flags . . . . . . . . . . . . . . . . . . . .  17\n       6.2.4.\
    \  IP Address Storage  . . . . . . . . . . . . . . . . .  17\n   7.  C-DNS Format\
    \ Detailed Description . . . . . . . . . . . . . .  18\n     7.1.  Map Quantities\
    \ and Indexes  . . . . . . . . . . . . . . .  18\n     7.2.  Tabular Representation\
    \  . . . . . . . . . . . . . . . . .  18\n     7.3.  \"File\"  . . . . . . . .\
    \ . . . . . . . . . . . . . . . . .  19\n       7.3.1.  \"FilePreamble\"  . .\
    \ . . . . . . . . . . . . . . . . .  20\n         7.3.1.1.  \"BlockParameters\"\
    \ . . . . . . . . . . . . . . . .  20\n           7.3.1.1.1.  \"StorageParameters\"\
    \ . . . . . . . . . . . . .  21\n             7.3.1.1.1.1.  \"StorageHints\" \
    \ . . . . . . . . . . . . .  22\n           7.3.1.1.2.  \"CollectionParameters\"\
    \  . . . . . . . . . . .  24\n       7.3.2.  \"Block\" . . . . . . . . . . . .\
    \ . . . . . . . . . . .  25\n         7.3.2.1.  \"BlockPreamble\" . . . . . .\
    \ . . . . . . . . . . .  26\n         7.3.2.2.  \"BlockStatistics\" . . . . .\
    \ . . . . . . . . . . .  27\n         7.3.2.3.  \"BlockTables\" . . . . . . .\
    \ . . . . . . . . . . .  28\n           7.3.2.3.1.  \"ClassType\" . . . . . .\
    \ . . . . . . . . . . .  29\n           7.3.2.3.2.  \"QueryResponseSignature\"\
    \  . . . . . . . . . .  30\n           7.3.2.3.3.  \"Question\"  . . . . . . .\
    \ . . . . . . . . . .  33\n           7.3.2.3.4.  \"RR\"  . . . . . . . . . .\
    \ . . . . . . . . . .  34\n           7.3.2.3.5.  \"MalformedMessageData\"  .\
    \ . . . . . . . . . .  34\n         7.3.2.4.  \"QueryResponse\" . . . . . . .\
    \ . . . . . . . . . .  35\n           7.3.2.4.1.  \"ResponseProcessingData\" \
    \ . . . . . . . . . .  36\n           7.3.2.4.2.  \"QueryResponseExtended\" .\
    \ . . . . . . . . . .  37\n         7.3.2.5.  \"AddressEventCount\" . . . . .\
    \ . . . . . . . . . .  38\n         7.3.2.6.  \"MalformedMessage\"  . . . . .\
    \ . . . . . . . . . .  39\n   8.  Versioning  . . . . . . . . . . . . . . . .\
    \ . . . . . . . . .  39\n   9.  C-DNS to PCAP . . . . . . . . . . . . . . . .\
    \ . . . . . . . .  40\n     9.1.  Name Compression  . . . . . . . . . . . . .\
    \ . . . . . . .  42\n   10. Data Collection . . . . . . . . . . . . . . . . .\
    \ . . . . . .  42\n     10.1.  Matching Algorithm . . . . . . . . . . . . . .\
    \ . . . . .  43\n     10.2.  Message Identifiers  . . . . . . . . . . . . . .\
    \ . . . .  45\n       10.2.1.  Primary ID (Required)  . . . . . . . . . . . .\
    \ . . .  45\n       10.2.2.  Secondary ID (Optional)  . . . . . . . . . . . .\
    \ . .  46\n     10.3.  Algorithm Parameters . . . . . . . . . . . . . . . . .\
    \ .  46\n     10.4.  Algorithm Requirements . . . . . . . . . . . . . . . . .\
    \  46\n     10.5.  Algorithm Limitations  . . . . . . . . . . . . . . . . .  47\n\
    \     10.6.  Workspace  . . . . . . . . . . . . . . . . . . . . . . .  47\n  \
    \   10.7.  Output . . . . . . . . . . . . . . . . . . . . . . . . .  47\n    \
    \ 10.8.  Post-Processing  . . . . . . . . . . . . . . . . . . . .  47\n   11.\
    \ Implementation Guidance . . . . . . . . . . . . . . . . . . .  47\n     11.1.\
    \  Optional Data  . . . . . . . . . . . . . . . . . . . . .  48\n     11.2.  Trailing\
    \ Bytes . . . . . . . . . . . . . . . . . . . . .  48\n     11.3.  Limiting Collection\
    \ of RDATA . . . . . . . . . . . . . .  49\n     11.4.  Timestamps . . . . . .\
    \ . . . . . . . . . . . . . . . . .  49\n   12. IANA Considerations . . . . .\
    \ . . . . . . . . . . . . . . . .  49\n     12.1.  Transport Types  . . . . .\
    \ . . . . . . . . . . . . . . .  49\n     12.2.  Data Storage Flags . . . . .\
    \ . . . . . . . . . . . . . .  50\n     12.3.  Response-Processing Flags  . .\
    \ . . . . . . . . . . . . .  51\n     12.4.  AddressEvent Types . . . . . . .\
    \ . . . . . . . . . . . .  51\n   13. Security Considerations . . . . . . . .\
    \ . . . . . . . . . . .  52\n   14. Privacy Considerations  . . . . . . . . .\
    \ . . . . . . . . . .  52\n   15. References  . . . . . . . . . . . . . . . .\
    \ . . . . . . . . .  53\n     15.1.  Normative References . . . . . . . . . .\
    \ . . . . . . . .  53\n     15.2.  Informative References . . . . . . . . . .\
    \ . . . . . . .  55\n   Appendix A.  CDDL . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  58\n   Appendix B.  DNS Name Compression Example . . . . . . .\
    \ . . . . .  69\n     B.1.  NSD Compression Algorithm . . . . . . . . . . . .\
    \ . . . .  70\n     B.2.  Knot Authoritative Compression Algorithm  . . . . .\
    \ . . .  70\n     B.3.  Observed Differences  . . . . . . . . . . . . . . . .\
    \ . .  71\n   Appendix C.  Comparison of Binary Formats . . . . . . . . . . .\
    \ .  71\n     C.1.  Comparison with Full PCAP Files . . . . . . . . . . . . .\
    \  74\n     C.2.  Simple versus Block Coding  . . . . . . . . . . . . . . .  74\n\
    \     C.3.  Binary versus Text Formats  . . . . . . . . . . . . . . .  75\n  \
    \   C.4.  Performance . . . . . . . . . . . . . . . . . . . . . . .  75\n    \
    \ C.5.  Conclusions . . . . . . . . . . . . . . . . . . . . . . .  75\n     C.6.\
    \  Block Size Choice . . . . . . . . . . . . . . . . . . . .  76\n   Appendix\
    \ D.  Data Fields for Traffic Regeneration . . . . . . . .  77\n     D.1.  Recommended\
    \ Fields for Traffic Regeneration . . . . . . .  77\n     D.2.  Issues with Small\
    \ Data Captures . . . . . . . . . . . . .  77\n   Acknowledgements  . . . . .\
    \ . . . . . . . . . . . . . . . . . . .  78\n   Authors' Addresses  . . . . .\
    \ . . . . . . . . . . . . . . . . . .  79\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   There has long been a need for server operators to collect\
    \ DNS\n   Queries and Responses on authoritative and recursive name servers for\n\
    \   monitoring and analysis.  This data is used in a number of ways,\n   including\
    \ traffic monitoring, analyzing network attacks, and \"day in\n   the life\" (DITL)\
    \ [ditl] analysis.\n   A wide variety of tools already exist that facilitate the\
    \ collection\n   of DNS traffic data, such as the DNS Statistics Collector (DSC)\n\
    \   [dsc], packetq [packetq], dnscap [dnscap], and dnstap [dnstap].\n   However,\
    \ there is no standard exchange format for large DNS packet\n   captures.  The\
    \ PCAP (\"packet capture\") [pcap] format or the PCAP Next\n   Generation (PCAP-NG)\
    \ [pcapng] format is typically used in practice\n   for packet captures, but these\
    \ file formats can contain a great deal\n   of additional information that is\
    \ not directly pertinent to DNS\n   traffic analysis and thus unnecessarily increases\
    \ the capture file\n   size.  Additionally, these tools and formats typically\
    \ have no filter\n   mechanism to selectively record only certain fields at capture\
    \ time,\n   requiring post-processing for anonymization or pseudonymization of\n\
    \   data to protect user privacy.\n   There has also been work on using text-based\
    \ formats to describe DNS\n   packets (for example, see [dnsxml] and [RFC8427]),\
    \ but this work is\n   largely aimed at producing convenient representations of\
    \ single\n   messages.\n   Many DNS operators may receive hundreds of thousands\
    \ of Queries per\n   second on a single name server instance, so a mechanism to\
    \ minimize\n   the storage and transmission size (and therefore upload overhead)\
    \ of\n   the data collected is highly desirable.\n   The format described in this\
    \ document, C-DNS (Compacted-DNS), focuses\n   on the problem of capturing and\
    \ storing large packet capture files of\n   DNS traffic with the following goals\
    \ in mind:\n   o  Minimize the file size for storage and transmission.\n   o \
    \ Minimize the overhead of producing the packet capture file and the\n      cost\
    \ of any further (general-purpose) compression of the file.\n   This document\
    \ contains:\n   o  A discussion of some common use cases in which DNS data is\n\
    \      collected; see Section 3.\n   o  A discussion of the major design considerations\
    \ in developing an\n      efficient data representation for collections of DNS\
    \ messages; see\n      Section 4.\n   o  A description of why the Concise Binary\
    \ Object Representation\n      (CBOR) [RFC7049] was chosen for this format; see\
    \ Section 5.\n   o  A conceptual overview of the C-DNS format; see Section 6.\n\
    \   o  The definition of the C-DNS format for the collection of DNS\n      messages;\
    \ see Section 7.\n   o  Notes on converting C-DNS data to PCAP format; see Section\
    \ 9.\n   o  Some high-level implementation considerations for applications\n \
    \     designed to produce C-DNS; see Section 10.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\"\
    , \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described\
    \ in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all\n\
    \   capitals, as shown here.\n   \"Packet\" refers to an individual IPv4 or IPv6\
    \ packet.  Typically,\n   packets are UDP datagrams, but such packets may also\
    \ be part of a TCP\n   data stream.  \"Message\", unless otherwise qualified,\
    \ refers to a DNS\n   payload extracted from a UDP datagram or a TCP data stream.\n\
    \   The parts of DNS messages are named as they are in [RFC1035].\n   Specifically,\
    \ the DNS message has five sections: Header, Question,\n   Answer, Authority,\
    \ and Additional.\n"
- title: 3.  Data Collection Use Cases
  contents:
  - "3.  Data Collection Use Cases\n   From a purely server operator perspective,\
    \ collecting full packet\n   captures of all packets going into or out of a name\
    \ server provides\n   the most comprehensive picture of network activity.  However,\
    \ there\n   are several design choices or other limitations that are common to\n\
    \   many DNS installations and operators.\n   o  DNS servers are hosted in a variety\
    \ of situations:\n      *  Self-hosted servers\n      *  Third-party hosting (including\
    \ multiple third parties)\n      *  Third-party hardware (including multiple third\
    \ parties)\n   o  Data is collected under different conditions:\n      *  On well-provisioned\
    \ servers running in a steady state\n      *  On heavily loaded servers\n    \
    \  *  On virtualized servers\n      *  On servers that are under DoS attack\n\
    \      *  On servers that are unwitting intermediaries in DoS attacks\n   o  Traffic\
    \ can be collected via a variety of mechanisms:\n      *  Within the name server\
    \ implementation itself\n      *  On the same hardware as the name server itself\n\
    \      *  Using a network tap on an adjacent host to listen to DNS\n         traffic\n\
    \      *  Using port mirroring to listen from another host\n   o  The capabilities\
    \ of data collection (and upload) networks vary:\n      *  Out-of-band networks\
    \ with the same capacity as the in-band\n         network\n      *  Out-of-band\
    \ networks with less capacity than the in-band\n         network\n      *  Everything\
    \ being on the in-band network\n   Thus, there is a wide range of use cases, from\
    \ very limited data\n   collection environments (third-party hardware, servers\
    \ that are under\n   attack, packet capture on the name server itself and no out-of-band\n\
    \   network) to \"limitless\" environments (self-hosted, well-provisioned\n  \
    \ servers, using a network tap or port mirroring with out-of-band\n   networks\
    \ with the same capacity as the in-band network).  In the\n   former case, it\
    \ is infeasible to reliably collect full packet\n   captures, especially if the\
    \ server is under attack.  In the latter\n   case, collection of full packet captures\
    \ may be reasonable.\n   As a result of these restrictions, the C-DNS data format\
    \ is designed\n   with the most limited use case in mind, such that:\n   o  Data\
    \ collection will occur on the same hardware as the name server\n      itself\n\
    \   o  Collected data will be stored on the same hardware as the name\n      server\
    \ itself, at least temporarily\n   o  Collected data being returned to some central\
    \ analysis system will\n      use the same network interface as the DNS Queries\
    \ and Responses\n   o  There can be multiple third-party servers involved\n  \
    \ Because of these considerations, a major factor in the design of the\n   format\
    \ is minimal storage size of the capture files.\n   Another significant consideration\
    \ for any application that records\n   DNS traffic is that the running of the\
    \ name server software and the\n   transmission of DNS Queries and Responses are\
    \ the most important jobs\n   of a name server; capturing data is not.  Any data\
    \ collection system\n   co-located with the name server needs to be intelligent\
    \ enough to\n   carefully manage its CPU, disk, memory, and network utilization.\n\
    \   This leads to designing a format that requires a relatively low\n   overhead\
    \ to produce and minimizes the requirement for further\n   potentially costly\
    \ compression.\n   However, it is also essential that interoperability with less\n\
    \   restricted infrastructure is maintained.  In particular, it is highly\n  \
    \ desirable that the collection format should facilitate the\n   re-creation of\
    \ common formats (such as PCAP) that are as close to the\n   original as is realistic,\
    \ given the restrictions above.\n"
- title: 4.  Design Considerations
  contents:
  - "4.  Design Considerations\n   This section presents some of the major design\
    \ considerations used in\n   the development of the C-DNS format.\n   1.  The\
    \ basic unit of data is a combined DNS Query and the associated\n       Response\
    \ (a \"Query/Response (Q/R) data item\").  The same\n       structure will be\
    \ used for unmatched Queries and Responses.\n       Queries without Responses\
    \ will be captured omitting the Response\n       data.  Responses without Queries\
    \ will be captured omitting the\n       Query data (but using the Question section\
    \ from the Response, if\n       present, as an identifying QNAME).\n       * \
    \ Rationale: A Query and the associated Response represent the\n          basic\
    \ level of a client's interaction with the server.  Also,\n          combining\
    \ the Query and Response into one item often reduces\n          storage requirements\
    \ due to commonality in the data of the two\n          messages.\n       In the\
    \ context of generating a C-DNS file, it is assumed that\n       only those DNS\
    \ payloads that can be parsed to produce a\n       well-formed DNS message are\
    \ stored in the structured Query/\n       Response data items of the C-DNS format\
    \ and that all other\n       messages will (optionally) be recorded as separate\
    \ malformed\n       messages.  Parsing a well-formed message means, at a minimum,\
    \ the\n       following:\n       *  The packet has a well-formed 12-byte DNS Header\
    \ with a\n          recognized OPCODE.\n       *  The section counts are consistent\
    \ with the section contents.\n       *  All of the Resource Records (RRs) can\
    \ be fully parsed.\n   2.  All top-level fields in each Query/Response data item\
    \ will be\n       optional.\n       *  Rationale: Different operators will have\
    \ different\n          requirements for data to be available for analysis.  Operators\n\
    \          with minimal requirements should not have to pay the cost of\n    \
    \      recording full data, though this will limit the ability to\n          perform\
    \ certain kinds of data analysis and also to reconstruct\n          packet captures.\
    \  For example, omitting the RRs from a\n          Response will reduce the C-DNS\
    \ file size; in principle,\n          Responses can be synthesized if there is\
    \ enough context.\n          Operators may have different policies for collecting\
    \ user data\n          and can choose to omit or anonymize certain fields at capture\n\
    \          time, e.g., client address.\n   3.  Multiple Query/Response data items\
    \ will be collected into blocks\n       in the format.  Common data in a block\
    \ will be abstracted and\n       referenced from individual Query/Response data\
    \ items by indexing.\n       The maximum number of Query/Response data items in\
    \ a block will\n       be configurable.\n       *  Rationale: This blocking and\
    \ indexing action provides a\n          significant reduction in the volume of\
    \ file data generated.\n          Although this introduces complexity, it provides\
    \ compression\n          of the data that makes use of knowledge of the DNS message\n\
    \          structure.\n       *  It is anticipated that the files produced can\
    \ be subject to\n          further compression using general-purpose compression\
    \ tools.\n          Measurements show that blocking significantly reduces the\
    \ CPU\n          required to perform such strong compression.  See\n         \
    \ Appendix C.2.\n       *  Examples of commonality between DNS messages are that\
    \ in most\n          cases the QUESTION RR is the same in the Query and Response\n\
    \          and that there is a finite set of Query \"signatures\" (based on\n\
    \          a subset of attributes).  For many authoritative servers,\n       \
    \   there is very likely to be a finite set of Responses that are\n          generated,\
    \ of which a large number are NXDOMAIN.\n   4.  Traffic metadata can optionally\
    \ be included in each block.\n       Specifically, counts of some types of non-DNS\
    \ packets (e.g.,\n       ICMP, TCP resets) sent to the server may be of interest.\n\
    \   5.  The wire-format content of malformed DNS messages may optionally\n   \
    \    be recorded.\n       *  Rationale: Any structured capture format that does\
    \ not capture\n          the DNS payload byte for byte will be limited to some\
    \ extent\n          in that it cannot represent malformed DNS messages.  Only\n\
    \          those messages that can be fully parsed and transformed into\n    \
    \      the structured format can be fully represented.  Note,\n          however,\
    \ that this can result in rather misleading statistics.\n          For example,\
    \ a malformed Query that cannot be represented in\n          the C-DNS format\
    \ will lead to the (well-formed) DNS Response\n          with error code FORMERR\
    \ appearing as \"unmatched\".  Therefore,\n          it can greatly aid downstream\
    \ analysis to have the wire format\n          of the malformed DNS messages available\
    \ directly in the\n          C-DNS file.\n"
- title: 5.  Choice of CBOR
  contents:
  - "5.  Choice of CBOR\n   This document presents a detailed format description for\
    \ C-DNS.  The\n   format uses CBOR [RFC7049].\n   The choice of CBOR was made\
    \ taking a number of factors into account.\n   o  CBOR is a binary representation\
    \ and thus is economical in storage\n      space.\n   o  Other binary representations\
    \ were investigated, and whilst all had\n      attractive features, none had a\
    \ significant advantage over CBOR.\n      See Appendix C for some discussion of\
    \ this.\n   o  CBOR is an IETF specification and is familiar to IETF\n      participants.\
    \  It is based on the now-common ideas of lists and\n      objects and thus requires\
    \ very little familiarization for those in\n      the wider industry.\n   o  CBOR\
    \ is a simple format and can easily be implemented from scratch\n      if necessary.\
    \  Formats that are more complex require library\n      support, which may present\
    \ problems on unusual platforms.\n   o  CBOR can also be easily converted to text\
    \ formats such as JSON\n      [RFC8259] for debugging and other human inspection\
    \ requirements.\n   o  CBOR data schemas can be described using the Concise Data\n\
    \      Definition Language (CDDL) [RFC8610].\n"
- title: 6.  C-DNS Format Conceptual Overview
  contents:
  - "6.  C-DNS Format Conceptual Overview\n   The following figures show purely schematic\
    \ representations of the\n   C-DNS format to convey the high-level structure of\
    \ the C-DNS format.\n   Section 7 provides a detailed discussion of the CBOR representation\n\
    \   and individual elements.\n   Figure 1 shows the C-DNS format at the top level,\
    \ including the file\n   header and data blocks.  The Query/Response data items,\
    \ Address/Event\n   Count data items, and Malformed Message data items link to\
    \ various\n   Block Tables.\n                   +-------+\n                  \
    \ + C-DNS |\n                   +-------+--------------------------+\n       \
    \            | File Type Identifier             |\n                   +----------------------------------+\n\
    \                   | File Preamble                    |\n                   |\
    \ +--------------------------------+\n                   | | Format Version  \
    \               |\n                   | +--------------------------------+\n \
    \                  | | Block Parameters               |\n                   +-+--------------------------------+\n\
    \                   | Block                            |\n                   |\
    \ +--------------------------------+\n                   | | Block Preamble  \
    \               |\n                   | +--------------------------------+\n \
    \                  | | Block Statistics               |\n                   |\
    \ +--------------------------------+\n                   | | Block Tables    \
    \               |\n                   | +--------------------------------+\n \
    \                  | | Query/Response data items      |\n                   |\
    \ +--------------------------------+\n                   | | Address/Event Count\
    \ data items |\n                   | +--------------------------------+\n    \
    \               | | Malformed Message data items   |\n                   +-+--------------------------------+\n\
    \                   | Block                            |\n                   |\
    \ +--------------------------------+\n                   | | Block Preamble  \
    \               |\n                   | +--------------------------------+\n \
    \                  | | Block Statistics               |\n                   |\
    \ +--------------------------------+\n                   | | Block Tables    \
    \               |\n                   | +--------------------------------+\n \
    \                  | | Query/Response data items      |\n                   |\
    \ +--------------------------------+\n                   | | Address/Event Count\
    \ data items |\n                   | +--------------------------------+\n    \
    \               | | Malformed Message data items   |\n                   +-+--------------------------------+\n\
    \                   | Further Blocks...                |\n                   +----------------------------------+\n\
    \                        Figure 1: The C-DNS Format\n   Figure 2 shows some more-detailed\
    \ relationships within each Block,\n   specifically those between the Query/Response\
    \ data item and the\n   relevant Block Tables.  Some fields have been omitted\
    \ for clarity.\n   +----------------+\n   | Query/Response |\n   +-------------------------+\n\
    \   | Time Offset             |\n   +-------------------------+            +------------------+\n\
    \   | Client Address          |---------+->| IP Address array |\n   +-------------------------+\
    \         |  +------------------+\n   | Client Port             |         |\n\
    \   +-------------------------+         |  +------------------+\n   | Transaction\
    \ ID          |     +---)->| Name/RDATA array |<--------+\n   +-------------------------+\
    \     |   |  +------------------+         |\n   | Query Signature         |--+\
    \  |   |                               |\n   +-------------------------+  |  |\
    \   |  +-----------------+          |\n   | Client Hoplimit (q)     |  +--)---)->|\
    \ Query Signature |          |\n   +-------------------------+     |   |  +-----------------+-------+\
    \  |\n   | Response Delay (r)      |     |   +--| Server Address          |  |\n\
    \   +-------------------------+     |      +-------------------------+  |\n  \
    \ | Query Name              |--+--+      | Server Port             |  |\n   +-------------------------+\
    \  |         +-------------------------+  |\n   | Query Size (q)          |  |\
    \         | Transport Flags         |  |\n   +-------------------------+  |  \
    \       +-------------------------+  |\n   | Response Size (r)       |  |    \
    \     | QR Type                 |  |\n   +-------------------------+  |      \
    \   +-------------------------+  |\n   | Response Processing (r) |  |        \
    \ | QR Signature Flags      |  |\n   | +-----------------------+  |         +-------------------------+\
    \  |\n   | | Bailiwick             |--+         | Query OPCODE (q)        |  |\n\
    \   | +-----------------------+            +-------------------------+  |\n  \
    \ | | Flags                 |            | QR DNS Flags            |  |\n   +-+-----------------------+\
    \            +-------------------------+  |\n   | Extra Query Info (q)    |  \
    \          | Query RCODE (q)         |  |\n   | +-----------------------+    \
    \        +-------------------------+  |\n   | | Question              |--+---+\
    \  +--+-Query Class/Type (q)    |  |\n   | +-----------------------+      |  |\
    \  +-------------------------+  |\n   | | Answer                |--+   |  |  |\
    \ Query QDCOUNT (q)       |  |\n   | +-----------------------+  |   |  |  +-------------------------+\
    \  |\n   | | Authority             |--+   |  |  | Query ANCOUNT (q)       |  |\n\
    \   | +-----------------------+  |   |  |  +-------------------------+  |\n  \
    \ | | Additional            |--+   |  |  | Query NSCOUNT (q)       |  |\n   +-+-----------------------+\
    \  |   |  |  +-------------------------+  |\n   | Extra Response Info (r) |  |-+\
    \ |  |  | Query ARCOUNT (q)       |  |\n   | +-----------------------+  | | |\
    \  |  +-------------------------+  |\n   | | Answer                |--+ | |  |\
    \  | Query EDNS version (q)  |  |\n   | +-----------------------+  | | |  |  +-------------------------+\
    \  |\n   | | Authority             |--+ | |  |  | Query EDNS UDP Size (q) |  |\n\
    \   | +-----------------------+  | | |  |  +-------------------------+  |\n  \
    \ | | Additional            |--+ | |  |  | Query OPT RDATA (q)     |--+\n   +-+-----------------------+\
    \    | |  |  +-------------------------+  |\n                                \
    \  | |  |  | Response RCODE (r)      |  |\n                                  |\
    \ |  |  +-------------------------+  |\n   + -----------------------------+ |\
    \  +----------+                    |\n   |                                |  \
    \           |                    |\n   | + -----------------------------+    \
    \         |                    |\n   | |  +---------------+  +----------+    \
    \       |                    |\n   | +->| Question List |->| Question |      \
    \     |                    |\n   |    | array         |  | array    |        \
    \   |                    |\n   |    +---------------+  +----------+--+       \
    \ |                    |\n   |                       | Name        |--+-----)--------------------+\n\
    \   |                       +-------------+  |     |  +------------+\n   |   \
    \                    | Class/Type  |--)---+-+->| Class/Type |\n   |          \
    \             +-------------+  |   |    | array      |\n   |                 \
    \                       |   |    +------------+--+\n   |                     \
    \                   |   |    | CLASS         |\n   |    +---------------+  +----------+\
    \     |   |    +---------------+\n   +--->| RR List array |->| RR array |    \
    \ |   |    | TYPE          |\n        +---------+-----+  +----------+--+  |  \
    \ |    +---------------+\n                           | Name        |--+   |\n\
    \                           +-------------+      |\n                         \
    \  | Class/Type  |------+\n                           +-------------+\n      \
    \ Figure 2: The Query/Response Data Item and Subsidiary Tables\n   In Figure 2,\
    \ data items annotated (q) are only present when a\n   Query/Response has a Query,\
    \ and those annotated (r) are only present\n   when a Query/Response Response\
    \ is present.\n   A C-DNS file begins with a file header containing a File Type\n\
    \   Identifier and a File Preamble.  The File Preamble contains\n   information\
    \ on the file Format Version and an array of Block\n   Parameters items (the contents\
    \ of which include Collection and\n   Storage Parameters used for one or more\
    \ Blocks).\n   The file header is followed by a series of Blocks.\n   A Block\
    \ consists of a Block Preamble item, some Block Statistics for\n   the traffic\
    \ stored within the Block, and then various arrays of\n   common data collectively\
    \ called the Block Tables.  This is then\n   followed by an array of the Query/Response\
    \ data items detailing the\n   Queries and Responses stored within the Block.\
    \  The array of\n   Query/Response data items is in turn followed by the Address/Event\n\
    \   Count data items (an array of per-client counts of particular IP\n   events)\
    \ and then Malformed Message data items (an array of malformed\n   messages that\
    \ are stored in the Block).\n   The exact nature of the DNS data will affect what\
    \ Block size is the\n   best fit; however, sample data for a root server indicated\
    \ that Block\n   sizes up to 10,000 Query/Response data items give good results.\
    \  See\n   Appendix C.6 for more details.\n   This design exploits data commonality\
    \ and block-based storage to\n   minimize the C-DNS file size.  As a result, C-DNS\
    \ cannot be streamed\n   below the level of a Block.\n"
- title: 6.1.  Block Parameters
  contents:
  - "6.1.  Block Parameters\n   The details of the Block Parameters items are not\
    \ shown in the\n   diagrams but are discussed here for context.\n   An array of\
    \ Block Parameters items is stored in the File Preamble\n   (with a minimum of\
    \ one item at index 0); a Block Parameters item\n   consists of a collection of\
    \ Storage and Collection Parameters that\n   applies to any given Block.  An array\
    \ is used in order to support use\n   cases such as wanting to merge C-DNS files\
    \ from different sources.\n   The Block Preamble item then contains an optional\
    \ index for the Block\n   Parameters item that applies for that Block; if not\
    \ present, the\n   index defaults to 0.  Hence, in effect, a global Block Parameters\n\
    \   item is defined that can then be overridden per Block.\n"
- title: 6.2.  Storage Parameters
  contents:
  - "6.2.  Storage Parameters\n   The Block Parameters item includes a Storage Parameters\
    \ item -- this\n   contains information about the specific data fields stored\
    \ in the\n   C-DNS file.\n   These parameters include:\n   o  The sub-second timing\
    \ resolution used by the data.\n   o  Information (hints) on which optional data\
    \ are omitted.  See\n      Section 6.2.1.\n   o  Recorded OPCODES [opcodes] and\
    \ RR TYPEs [rrtypes].  See\n      Section 6.2.2.\n   o  Flags indicating, for\
    \ example, whether the data is sampled or\n      anonymized.  See Sections 6.2.3\
    \ and 14.\n   o  Client and server IPv4 and IPv6 address prefixes.  See\n    \
    \  Section 6.2.4.\n"
- title: 6.2.1.  Optional Data Items
  contents:
  - "6.2.1.  Optional Data Items\n   To enable implementations to store data to their\
    \ precise requirements\n   in as space-efficient a manner as possible, all fields\
    \ in the\n   following arrays are optional:\n   o  Query/Response\n   o  Query\
    \ Signature\n   o  Malformed Messages\n   In other words, an implementation can\
    \ choose to omit any data item\n   that is not required for its use case (whilst\
    \ observing the\n   restrictions relating to IP address storage described in\n\
    \   Section 6.2.4).  In addition, implementations may be configured to\n   not\
    \ record all RRs or to only record messages with certain OPCODES.\n   This does,\
    \ however, mean that a consumer of a C-DNS file faces two\n   problems:\n   1.\
    \  How can it quickly determine if a file definitely does not\n       contain\
    \ the data items it requires to complete a particular task\n       (e.g., reconstructing\
    \ DNS traffic or performing a specific piece\n       of data analysis)?\n   2.\
    \  How can it determine whether a data item is not present because\n       it\
    \ was (1) explicitly not recorded or (2) not available/present?\n   For example,\
    \ capturing C-DNS data from within a name server\n   implementation makes it unlikely\
    \ that the Client Hoplimit can be\n   recorded.  Or, if there is no Query ARCOUNT\
    \ recorded and no Query OPT\n   RDATA [RFC6891] recorded, is that because no Query\
    \ contained an OPT\n   RR, or because that data was not stored?\n   The Storage\
    \ Parameters item therefore also contains a Storage Hints\n   item, which specifies\
    \ which items the encoder of the file omits from\n   the stored data and will\
    \ therefore never be present.  (This approach\n   is taken because a flag that\
    \ indicated which items were included for\n   collection would not guarantee that\
    \ the item was present -- only that\n   it might be.)  An implementation decoding\
    \ that file can then use\n   these flags to quickly determine whether the input\
    \ data is not rich\n   enough for its needs.\n   One scenario where this may be\
    \ particularly important is the case of\n   regenerating traffic.  It is possible\
    \ to collect such a small set of\n   data items that an implementation decoding\
    \ the file cannot determine\n   if a given Query/Response data item was generated\
    \ from just a Query,\n   just a Response, or a Query/Response pair.  This makes\
    \ it impossible\n   to reconstruct DNS traffic even if sensible defaults are provided\
    \ for\n   the missing data items.  This is discussed in more detail in\n   Section\
    \ 9.\n"
- title: 6.2.2.  Optional RRs and OPCODEs
  contents:
  - "6.2.2.  Optional RRs and OPCODEs\n   Also included in the Storage Parameters\
    \ item are explicit arrays\n   listing the RR TYPEs and the OPCODEs to be recorded.\
    \  These arrays\n   remove any ambiguity over whether, for example, messages containing\n\
    \   particular OPCODEs are not present because (1) certain OPCODEs did\n   not\
    \ occur or (2) the implementation is not configured to record them.\n   In the\
    \ case of OPCODEs, for a message to be fully parsable, the\n   OPCODE must be\
    \ known to the collecting implementation.  Any message\n   with an OPCODE unknown\
    \ to the collecting implementation cannot be\n   validated as correctly formed\
    \ and so must be treated as malformed.\n   Messages with OPCODES known to the\
    \ recording application but not\n   listed in the Storage Parameters item are\
    \ discarded by the recording\n   application during C-DNS capture (regardless\
    \ of whether they are\n   malformed or not).\n   In the case of RRs, each record\
    \ in a message must be fully parsable,\n   including parsing the record RDATA,\
    \ as otherwise the message cannot\n   be validated as correctly formed.  Any RR\
    \ with an RR TYPE not known\n   to the collecting implementation cannot be validated\
    \ as correctly\n   formed and so must be treated as malformed.\n   Once a message\
    \ is correctly parsed, an implementation is free to\n   record only a subset of\
    \ the RRs present.\n"
- title: 6.2.3.  Storage Flags
  contents:
  - "6.2.3.  Storage Flags\n   The Storage Parameters item contains flags that can\
    \ be used to\n   indicate if:\n   o  the data is anonymized,\n   o  the data is\
    \ produced from sample data, or\n   o  names in the data have been normalized\
    \ (converted to uniform\n      case).\n   The Storage Parameters item also contains\
    \ optional fields holding\n   details of the sampling method used and the anonymization\
    \ method\n   used.  It is RECOMMENDED that these fields contain URIs [RFC3986]\n\
    \   pointing to resources describing the methods used.  See Section 14\n   for\
    \ further discussion of anonymization and normalization.\n"
- title: 6.2.4.  IP Address Storage
  contents:
  - "6.2.4.  IP Address Storage\n   The format can store either full IP addresses\
    \ or just IP prefixes;\n   the Storage Parameters item contains fields to indicate\
    \ if only IP\n   prefixes were stored.\n   If the IP address prefixes are absent,\
    \ then full addresses are\n   stored.  In this case, the IP version can be directly\
    \ inferred from\n   the stored address length and the fields \"qr-transport-flags\"\
    \ in\n   QueryResponseSignature, \"ae-transport-flags\" in AddressEventCount,\n\
    \   and \"mm-transport-flags\" in MalformedMessageData (which contain the\n  \
    \ IP version bit) are optional.\n   If IP address prefixes are given, only the\
    \ prefix bits of addresses\n   are stored.  In this case, in order to determine\
    \ the IP version, the\n   fields \"qr-transport-flags\" in QueryResponseSignature,\
    \ \"ae-transport-\n   flags\" in AddressEventCount, and \"mm-transport-flags\"\
    \ in\n   MalformedMessageData MUST be present.  See Sections 7.3.2.3.2 and\n \
    \  7.3.2.3.5.\n   As an example of storing only IP prefixes, if a client IPv6\
    \ prefix of\n   48 is specified, a client address of 2001:db8:85a3::8a2e:370:7334\n\
    \   will be stored as 0x20010db885a3, reducing address storage space\n   requirements.\
    \  Similarly, if a client IPv4 prefix of 16 is specified,\n   a client address\
    \ of 192.0.2.1 will be stored as 0xc000 (192.0).\n"
- title: 7.  C-DNS Format Detailed Description
  contents:
  - "7.  C-DNS Format Detailed Description\n   The CDDL definition for the C-DNS format\
    \ is given in Appendix A.\n"
- title: 7.1.  Map Quantities and Indexes
  contents:
  - "7.1.  Map Quantities and Indexes\n   All map keys are integers with values specified\
    \ in the CDDL.  String\n   keys would significantly bloat the file size.\n   All\
    \ key values specified are positive integers under 24, so their\n   CBOR representation\
    \ is a single byte.  Positive integer values not\n   currently used as keys in\
    \ a map are reserved for use in future\n   standard extensions.\n   Implementations\
    \ may choose to add additional implementation-specific\n   entries to any map.\
    \  Negative integer map keys are reserved for these\n   values.  Key values from\
    \ -1 to -24 also have a single-byte CBOR\n   representation, so such implementation-specific\
    \ extensions are not at\n   any space efficiency disadvantage.\n   An item described\
    \ as an index is the index of the data item in the\n   referenced array.  Indexes\
    \ are 0-based.\n"
- title: 7.2.  Tabular Representation
  contents:
  - "7.2.  Tabular Representation\n   The following sections present the C-DNS specification\
    \ in tabular\n   format with a detailed description of each item.\n   In all quantities\
    \ that contain bit flags, bit 0 indicates the least\n   significant bit, i.e.,\
    \ flag \"n\" in quantity \"q\" is on if\n   \"(q & (1 << n)) != 0\".\n   For the\
    \ sake of readability, all type and field names defined in the\n   CDDL definition\
    \ are shown in double quotes.  Type names are by\n   convention camel case (e.g.,\
    \ \"BlockTables\"), and field names are\n   lowercase with hyphens (e.g., \"block-tables\"\
    ).\n   For the sake of brevity, the following conventions are used in the\n  \
    \ tables:\n   o  The column M marks whether items in a map are mandatory.\n  \
    \    *  X - Mandatory items.\n      *  C - Conditionally mandatory items.  Such\
    \ items are usually\n         optional but may be mandatory in some configurations.\n\
    \      *  If the column is empty, the item is optional.\n   o  The column T gives\
    \ the CBOR datatype of the item.\n      *  U - Unsigned integer.\n      *  I -\
    \ Signed integer (i.e., either a CBOR unsigned integer or a\n         CBOR negative\
    \ integer).\n      *  B - Boolean.\n      *  S - Byte string.\n      *  T - Text\
    \ string.\n      *  M - Map.\n      *  A - Array.\n   In the case of maps and\
    \ arrays, more information on the type of each\n   value, including the CDDL definition\
    \ name if applicable, is given in\n   the description.\n"
- title: 7.3.  "File"
  contents:
  - "7.3.  \"File\"\n   A C-DNS file has an outer structure \"File\", an array that\
    \ contains\n   the following:\n   +---------------+---+---+-------------------------------------------+\n\
    \   | Field         | M | T | Description                               |\n  \
    \ +---------------+---+---+-------------------------------------------+\n   |\
    \ file-type-id  | X | T | String \"C-DNS\" identifying the file type. |\n   |\
    \               |   |   |                                           |\n   | file-preamble\
    \ | X | M | Version and parameter information for the |\n   |               |\
    \   |   | whole file.  Map of type \"FilePreamble\";  |\n   |               |\
    \   |   | see Section 7.3.1.                        |\n   |               |  \
    \ |   |                                           |\n   | file-blocks   | X |\
    \ A | Array of items of type \"Block\"; see       |\n   |               |   |\
    \   | Section 7.3.2.  The array may be empty if |\n   |               |   |  \
    \ | the file contains no data.                |\n   +---------------+---+---+-------------------------------------------+\n"
- title: 7.3.1.  "FilePreamble"
  contents:
  - "7.3.1.  \"FilePreamble\"\n   Information about data in the file.  A map containing\
    \ the following:\n   +----------------------+---+---+------------------------------------+\n\
    \   | Field                | M | T | Description                        |\n  \
    \ +----------------------+---+---+------------------------------------+\n   |\
    \ major-format-version | X | U | Unsigned integer \"1\".  The major   |\n   |\
    \                      |   |   | version of the format used in the  |\n   |  \
    \                    |   |   | file.  See Section 8.              |\n   |    \
    \                  |   |   |                                    |\n   | minor-format-version\
    \ | X | U | Unsigned integer \"0\".  The minor   |\n   |                     \
    \ |   |   | version of the format used in the  |\n   |                      |\
    \   |   | file.  See Section 8.              |\n   |                      |  \
    \ |   |                                    |\n   | private-version      |   |\
    \ U | Version indicator available for    |\n   |                      |   |  \
    \ | private use by implementations.    |\n   |                      |   |   |\
    \                                    |\n   | block-parameters     | X | A | Array\
    \ of items of type             |\n   |                      |   |   | \"BlockParameters\"\
    .  See Section    |\n   |                      |   |   | 7.3.1.1.  The array must\
    \ contain   |\n   |                      |   |   | at least one entry.  (The \
    \         |\n   |                      |   |   | \"block-parameters-index\" item\
    \ in   |\n   |                      |   |   | each \"BlockPreamble\" indicates\
    \     |\n   |                      |   |   | which array entry applies to that\
    \  |\n   |                      |   |   | \"Block\".)                        \
    \  |\n   +----------------------+---+---+------------------------------------+\n"
- title: 7.3.1.1.  "BlockParameters"
  contents:
  - "7.3.1.1.  \"BlockParameters\"\n   Parameters relating to data storage and collection\
    \ that apply to one\n   or more items of type \"Block\".  A map containing the\
    \ following:\n   +-----------------------+---+---+-----------------------------------+\n\
    \   | Field                 | M | T | Description                       |\n  \
    \ +-----------------------+---+---+-----------------------------------+\n   |\
    \ storage-parameters    | X | M | Parameters relating to data       |\n   |  \
    \                     |   |   | storage in a \"Block\" item.  Map   |\n   |  \
    \                     |   |   | of type \"StorageParameters\"; see  |\n   |  \
    \                     |   |   | Section 7.3.1.1.1.                |\n   |    \
    \                   |   |   |                                   |\n   | collection-parameters\
    \ |   | M | Parameters relating to collection |\n   |                       |\
    \   |   | of the data in a \"Block\" item.    |\n   |                       |\
    \   |   | Map of type                       |\n   |                       |  \
    \ |   | \"CollectionParameters\"; see       |\n   |                       |  \
    \ |   | Section 7.3.1.1.2.                |\n   +-----------------------+---+---+-----------------------------------+\n"
- title: 7.3.1.1.1.  "StorageParameters"
  contents:
  - "7.3.1.1.1.  \"StorageParameters\"\n   Parameters relating to how data is stored\
    \ in the items of type\n   \"Block\".  A map containing the following:\n   +------------------+---+---+----------------------------------------+\n\
    \   | Field            | M | T | Description                            |\n  \
    \ +------------------+---+---+----------------------------------------+\n   |\
    \ ticks-per-second | X | U | Sub-second timing is recorded in       |\n   |  \
    \                |   |   | ticks.  This specifies the number of   |\n   |    \
    \              |   |   | ticks in a second.                     |\n   |      \
    \            |   |   |                                        |\n   | max-block-items\
    \  | X | U | The maximum number of items stored in  |\n   |                  |\
    \   |   | any of the arrays in a \"Block\" item    |\n   |                  |\
    \   |   | (Q/R, Address/Event Count, or          |\n   |                  |  \
    \ |   | Malformed Message data items).  An     |\n   |                  |   |\
    \   | indication to a decoder of the         |\n   |                  |   |  \
    \ | resources needed to process the file.  |\n   |                  |   |   |\
    \                                        |\n   | storage-hints    | X | M | Collection\
    \ of hints as to which fields |\n   |                  |   |   | are omitted in\
    \ the arrays that have    |\n   |                  |   |   | optional fields.\
    \  Map of type          |\n   |                  |   |   | \"StorageHints\". \
    \ See Section           |\n   |                  |   |   | 7.3.1.1.1.1.      \
    \                     |\n   |                  |   |   |                     \
    \                   |\n   | opcodes          | X | A | Array of OPCODES [opcodes]\
    \ (unsigned   |\n   |                  |   |   | integers, each in the range 0\
    \ to 15    |\n   |                  |   |   | inclusive) recorded by the collecting\
    \  |\n   |                  |   |   | implementation.  See Section 6.2.2.    |\n\
    \   |                  |   |   |                                        |\n  \
    \ | rr-types         | X | A | Array of RR TYPEs [rrtypes] (unsigned  |\n   |\
    \                  |   |   | integers, each in the range 0 to 65535 |\n   |  \
    \                |   |   | inclusive) recorded by the collecting  |\n   |    \
    \              |   |   | implementation.  See Section 6.2.2.    |\n   |      \
    \            |   |   |                                        |\n   | storage-flags\
    \    |   | U | Bit flags indicating attributes of     |\n   |                \
    \  |   |   | stored data.                           |\n   |                  |\
    \   |   | Bit 0.  1 if the data has been         |\n   |                  |  \
    \ |   | anonymized.                            |\n   |                  |   |\
    \   | Bit 1.  1 if the data is sampled data. |\n   |                  |   |  \
    \ | Bit 2.  1 if the names have been       |\n   |                  |   |   |\
    \ normalized (converted to uniform       |\n   |                  |   |   | case).\
    \                                 |\n   |                  |   |   |         \
    \                               |\n   | client-address   |   | U | IPv4 client\
    \ address prefix length, in  |\n   | -prefix-ipv4     |   |   | the range 1 to\
    \ 32 inclusive.  If       |\n   |                  |   |   | specified, only the\
    \ address prefix     |\n   |                  |   |   | bits are stored.     \
    \                  |\n   |                  |   |   |                        \
    \                |\n   | client-address   |   | U | IPv6 client address prefix\
    \ length, in  |\n   | -prefix-ipv6     |   |   | the range 1 to 128 inclusive.\
    \  If      |\n   |                  |   |   | specified, only the address prefix\
    \     |\n   |                  |   |   | bits are stored.                    \
    \   |\n   |                  |   |   |                                       \
    \ |\n   | server-address   |   | U | IPv4 server address prefix length, in  |\n\
    \   | -prefix-ipv4     |   |   | the range 1 to 32 inclusive.  If       |\n  \
    \ |                  |   |   | specified, only the address prefix     |\n   |\
    \                  |   |   | bits are stored.                       |\n   |  \
    \                |   |   |                                        |\n   | server-address\
    \   |   | U | IPv6 server address prefix length, in  |\n   | -prefix-ipv6    \
    \ |   |   | the range 1 to 128 inclusive.  If      |\n   |                  |\
    \   |   | specified, only the address prefix     |\n   |                  |  \
    \ |   | bits are stored.                       |\n   |                  |   |\
    \   |                                        |\n   | sampling-method  |   | T\
    \ | Information on the sampling method     |\n   |                  |   |   |\
    \ used.  See Section 6.2.3.              |\n   |                  |   |   |  \
    \                                      |\n   | anonymization    |   | T | Information\
    \ on the anonymization       |\n   | -method          |   |   | method used. \
    \ See Section 6.2.3.       |\n   +------------------+---+---+----------------------------------------+\n"
- title: 7.3.1.1.1.1.  "StorageHints"
  contents:
  - "7.3.1.1.1.1.  \"StorageHints\"\n   An indicator of which fields the collecting\
    \ implementation omits in\n   the maps with optional fields.  Note that hints\
    \ have a top-down\n   precedence.  In other words, where a map contains another\
    \ map, the\n   hint on the containing map overrides any hints in the contained\
    \ map\n   and the contained map is omitted.  A map containing the following:\n\
    \   +------------------+---+---+----------------------------------------+\n  \
    \ | Field            | M | T | Description                            |\n   +------------------+---+---+----------------------------------------+\n\
    \   | query-response   | X | U | Hints indicating which \"QueryResponse\" |\n\
    \   | -hints           |   |   | fields are omitted; see Section        |\n  \
    \ |                  |   |   | 7.3.2.4.  If a bit is unset, the field |\n   |\
    \                  |   |   | is omitted from the capture.           |\n   |  \
    \                |   |   | Bit 0.  time-offset                    |\n   |    \
    \              |   |   | Bit 1.  client-address-index           |\n   |      \
    \            |   |   | Bit 2.  client-port                    |\n   |        \
    \          |   |   | Bit 3.  transaction-id                 |\n   |          \
    \        |   |   | Bit 4.  qr-signature-index             |\n   |            \
    \      |   |   | Bit 5.  client-hoplimit                |\n   |              \
    \    |   |   | Bit 6.  response-delay                 |\n   |                \
    \  |   |   | Bit 7.  query-name-index               |\n   |                  |\
    \   |   | Bit 8.  query-size                     |\n   |                  |  \
    \ |   | Bit 9.  response-size                  |\n   |                  |   |\
    \   | Bit 10.  response-processing-data      |\n   |                  |   |  \
    \ | Bit 11.  query-question-sections       |\n   |                  |   |   |\
    \ Bit 12.  query-answer-sections         |\n   |                  |   |   | Bit\
    \ 13.  query-authority-sections      |\n   |                  |   |   | Bit 14.\
    \  query-additional-sections     |\n   |                  |   |   | Bit 15.  response-answer-sections\
    \      |\n   |                  |   |   | Bit 16.  response-authority-sections\
    \   |\n   |                  |   |   | Bit 17.  response-additional-sections \
    \ |\n   |                  |   |   |                                        |\n\
    \   | query-response   | X | U | Hints indicating which                 |\n  \
    \ | -signature-hints |   |   | \"QueryResponseSignature\" fields are    |\n  \
    \ |                  |   |   | omitted; see Section 7.3.2.3.2.  If a  |\n   |\
    \                  |   |   | bit is unset, the field is omitted     |\n   |  \
    \                |   |   | from the capture.                      |\n   |    \
    \              |   |   | Bit 0.  server-address-index           |\n   |      \
    \            |   |   | Bit 1.  server-port                    |\n   |        \
    \          |   |   | Bit 2.  qr-transport-flags             |\n   |          \
    \        |   |   | Bit 3.  qr-type                        |\n   |            \
    \      |   |   | Bit 4.  qr-sig-flags                   |\n   |              \
    \    |   |   | Bit 5.  query-opcode                   |\n   |                \
    \  |   |   | Bit 6.  qr-dns-flags                   |\n   |                  |\
    \   |   | Bit 7.  query-rcode                    |\n   |                  |  \
    \ |   | Bit 8.  query-classtype-index          |\n   |                  |   |\
    \   | Bit 9.  query-qdcount                  |\n   |                  |   |  \
    \ | Bit 10.  query-ancount                 |\n   |                  |   |   |\
    \ Bit 11.  query-nscount                 |\n   |                  |   |   | Bit\
    \ 12.  query-arcount                 |\n   |                  |   |   | Bit 13.\
    \  query-edns-version            |\n   |                  |   |   | Bit 14.  query-udp-size\
    \                |\n   |                  |   |   | Bit 15.  query-opt-rdata-index\
    \         |\n   |                  |   |   | Bit 16.  response-rcode         \
    \       |\n   |                  |   |   |                                   \
    \     |\n   | rr-hints         | X | U | Hints indicating which optional \"RR\"\
    \   |\n   |                  |   |   | fields are omitted; see Section       \
    \ |\n   |                  |   |   | 7.3.2.3.4.  If a bit is unset, the     |\n\
    \   |                  |   |   | field is omitted from the capture.     |\n  \
    \ |                  |   |   | Bit 0.  ttl                            |\n   |\
    \                  |   |   | Bit 1.  rdata-index                    |\n   | other-data-hints\
    \ | X | U | Hints indicating which other datatypes |\n   |                  |\
    \   |   | are omitted.  If a bit is unset, the   |\n   |                  |  \
    \ |   | datatype is omitted from the capture.  |\n   |                  |   |\
    \   | Bit 0.  malformed-messages             |\n   |                  |   |  \
    \ | Bit 1.  address-event-counts           |\n   +------------------+---+---+----------------------------------------+\n"
- title: 7.3.1.1.2.  "CollectionParameters"
  contents:
  - "7.3.1.1.2.  \"CollectionParameters\"\n   Parameters providing information regarding\
    \ how data in the file was\n   collected (applicable for some, but not all, collection\n\
    \   environments).  The values are informational only and serve as\n   metadata\
    \ to downstream analyzers as to the configuration of a\n   collecting implementation.\
    \  They can provide context when\n   interpreting what data is present/absent\
    \ from the capture but cannot\n   necessarily be validated against the data captured.\n\
    \   These parameters have no default.  If they do not appear, nothing can\n  \
    \ be inferred about their value.\n   A map containing the following items:\n \
    \  +------------------+---+---+----------------------------------------+\n   |\
    \ Field            | M | T | Description                            |\n   +------------------+---+---+----------------------------------------+\n\
    \   | query-timeout    |   | U | To be matched with a Query, a Response |\n  \
    \ |                  |   |   | must arrive within this number of      |\n   |\
    \                  |   |   | milliseconds.                          |\n   |  \
    \                |   |   |                                        |\n   | skew-timeout\
    \     |   | U | The network stack may report a         |\n   |               \
    \   |   |   | Response before the corresponding      |\n   |                 \
    \ |   |   | Query.  A Response is not considered   |\n   |                  |\
    \   |   | to be missing a Query until after this |\n   |                  |  \
    \ |   | many microseconds.                     |\n   |                  |   |\
    \   |                                        |\n   | snaplen          |   | U\
    \ | Collect up to this many bytes per      |\n   |                  |   |   |\
    \ packet.                                |\n   |                  |   |   |  \
    \                                      |\n   | promisc          |   | B | \"true\"\
    \ if promiscuous mode             |\n   |                  |   |   | [pcap-options]\
    \ was enabled on the      |\n   |                  |   |   | interface, \"false\"\
    \ otherwise.          |\n   |                  |   |   |                     \
    \                   |\n   | interfaces       |   | A | Array of identifiers (of\
    \ type text     |\n   |                  |   |   | string) of the interfaces used\
    \ for     |\n   |                  |   |   | collection.                     \
    \       |\n   |                  |   |   |                                   \
    \     |\n   | server-addresses |   | A | Array of server collection IP       \
    \   |\n   |                  |   |   | addresses (of type byte string).      \
    \ |\n   |                  |   |   | Metadata for downstream analyzers;     |\n\
    \   |                  |   |   | does not affect collection.            |\n  \
    \ |                  |   |   |                                        |\n   |\
    \ vlan-ids         |   | A | Array of identifiers (of type unsigned |\n   |  \
    \                |   |   | integer, each in the range 1 to 4094   |\n   |    \
    \              |   |   | inclusive) of VLANs [IEEE802.1Q]       |\n   |      \
    \            |   |   | selected for collection.  VLAN IDs are |\n   |        \
    \          |   |   | unique only within an administrative   |\n   |          \
    \        |   |   | domain.                                |\n   |            \
    \      |   |   |                                        |\n   | filter       \
    \    |   | T | Filter for input, in \"tcpdump\"         |\n   |              \
    \    |   |   | [pcap-filter] style.                   |\n   |                \
    \  |   |   |                                        |\n   | generator-id     |\
    \   | T | Implementation-specific human-readable |\n   |                  |  \
    \ |   | string identifying the collection      |\n   |                  |   |\
    \   | method.                                |\n   |                  |   |  \
    \ |                                        |\n   | host-id          |   | T |\
    \ String identifying the collecting      |\n   |                  |   |   | host.\
    \                                  |\n   +------------------+---+---+----------------------------------------+\n"
- title: 7.3.2.  "Block"
  contents:
  - "7.3.2.  \"Block\"\n   Container for data with common collection and storage parameters.\
    \  A\n   map containing the following:\n   +--------------------+---+---+--------------------------------------+\n\
    \   | Field              | M | T | Description                          |\n  \
    \ +--------------------+---+---+--------------------------------------+\n   |\
    \ block-preamble     | X | M | Overall information for the \"Block\"  |\n   |\
    \                    |   |   | item.  Map of type \"BlockPreamble\";  |\n   |\
    \                    |   |   | see Section 7.3.2.1.                 |\n   |  \
    \                  |   |   |                                      |\n   | block-statistics\
    \   |   | M | Statistics about the \"Block\" item.   |\n   |                 \
    \   |   |   | Map of type \"BlockStatistics\"; see   |\n   |                 \
    \   |   |   | Section 7.3.2.2.                     |\n   |                   \
    \ |   |   |                                      |\n   | block-tables       |\
    \   | M | The arrays containing data           |\n   |                    |  \
    \ |   | referenced by individual             |\n   |                    |   |\
    \   | \"QueryResponse\" or                   |\n   |                    |   |\
    \   | \"MalformedMessage\" items.  Map of    |\n   |                    |   |\
    \   | type \"BlockTables\"; see Section      |\n   |                    |   |\
    \   | 7.3.2.3.                             |\n   |                    |   |  \
    \ |                                      |\n   | query-responses    |   | A |\
    \ Details of individual C-DNS Q/R data |\n   |                    |   |   | items.\
    \  Array of items of type       |\n   |                    |   |   | \"QueryResponse\"\
    ; see Section         |\n   |                    |   |   | 7.3.2.4.  If present,\
    \ the array must |\n   |                    |   |   | not be empty.          \
    \              |\n   |                    |   |   |                          \
    \            |\n   | address-event      |   | A | Per-client counts of ICMP messages\
    \   |\n   | -counts            |   |   | and TCP resets.  Array of items of  \
    \ |\n   |                    |   |   | type \"AddressEventCount\"; see       \
    \ |\n   |                    |   |   | Section 7.3.2.5.  If present, the    |\n\
    \   |                    |   |   | array must not be empty.             |\n  \
    \ |                    |   |   |                                      |\n   |\
    \ malformed-messages |   | A | Details of malformed DNS messages.   |\n   |  \
    \                  |   |   | Array of items of type               |\n   |    \
    \                |   |   | \"MalformedMessage\"; see Section      |\n   |    \
    \                |   |   | 7.3.2.6.  If present, the array must |\n   |      \
    \              |   |   | not be empty.                        |\n   +--------------------+---+---+--------------------------------------+\n"
- title: 7.3.2.1.  "BlockPreamble"
  contents:
  - "7.3.2.1.  \"BlockPreamble\"\n   Overall information for a \"Block\" item.  A\
    \ map containing the\n   following:\n   +------------------+---+---+----------------------------------------+\n\
    \   | Field            | M | T | Description                            |\n  \
    \ +------------------+---+---+----------------------------------------+\n   |\
    \ earliest-time    | C | A | A timestamp (two unsigned integers, of |\n   |  \
    \                |   |   | type \"Timestamp\") for the earliest     |\n   |  \
    \                |   |   | record in the \"Block\" item.  The first |\n   |  \
    \                |   |   | integer is the number of seconds since |\n   |    \
    \              |   |   | the POSIX epoch [posix-time]           |\n   |      \
    \            |   |   | (\"time_t\"), excluding leap seconds.    |\n   |      \
    \            |   |   | The second integer is the number of    |\n   |        \
    \          |   |   | ticks (see Section 7.3.1.1.1) since    |\n   |          \
    \        |   |   | the start of the second.  This field   |\n   |            \
    \      |   |   | is mandatory unless all block items    |\n   |              \
    \    |   |   | containing a time offset from the      |\n   |                \
    \  |   |   | start of the Block also omit that time |\n   |                  |\
    \   |   | offset.                                |\n   |                  |  \
    \ |   |                                        |\n   | block-parameters |   |\
    \ U | The index of the item in the           |\n   | -index           |   |  \
    \ | \"block-parameters\" array (in the       |\n   |                  |   |  \
    \ | \"file-preamble\" item) applicable to    |\n   |                  |   |  \
    \ | this block.  If not present, index 0   |\n   |                  |   |   |\
    \ is used.  See Section 7.3.1.           |\n   +------------------+---+---+----------------------------------------+\n"
- title: 7.3.2.2.  "BlockStatistics"
  contents:
  - "7.3.2.2.  \"BlockStatistics\"\n   Basic statistical information about a \"Block\"\
    \ item.  A map containing\n   the following:\n   +---------------------+---+---+-------------------------------------+\n\
    \   | Field               | M | T | Description                         |\n  \
    \ +---------------------+---+---+-------------------------------------+\n   |\
    \ processed-messages  |   | U | Total number of well-formed DNS     |\n   |  \
    \                   |   |   | messages processed from the input   |\n   |    \
    \                 |   |   | traffic stream during collection of |\n   |      \
    \               |   |   | data in this \"Block\" item.          |\n   |      \
    \               |   |   |                                     |\n   | qr-data-items\
    \       |   | U | Total number of Q/R data items in   |\n   |                \
    \     |   |   | this \"Block\" item.                  |\n   |                \
    \     |   |   |                                     |\n   | unmatched-queries\
    \   |   | U | Number of unmatched Queries in this |\n   |                    \
    \ |   |   | \"Block\" item.                       |\n   |                    \
    \ |   |   |                                     |\n   | unmatched-responses |\
    \   | U | Number of unmatched Responses in    |\n   |                     |  \
    \ |   | this \"Block\" item.                  |\n   |                     |  \
    \ |   |                                     |\n   | discarded-opcode    |   |\
    \ U | Number of DNS messages processed    |\n   |                     |   |  \
    \ | from the input traffic stream       |\n   |                     |   |   |\
    \ during collection of data in this   |\n   |                     |   |   | \"\
    Block\" item but not recorded       |\n   |                     |   |   | because\
    \ their OPCODE is not in the  |\n   |                     |   |   | list to be\
    \ collected.               |\n   |                     |   |   |             \
    \                        |\n   | malformed-items     |   | U | Number of malformed\
    \ messages        |\n   |                     |   |   | processed from the input\
    \ traffic    |\n   |                     |   |   | stream during collection of\
    \ data in |\n   |                     |   |   | this \"Block\" item.         \
    \         |\n   +---------------------+---+---+-------------------------------------+\n"
- title: 7.3.2.3.  "BlockTables"
  contents:
  - "7.3.2.3.  \"BlockTables\"\n   Map of arrays containing data referenced by individual\n\
    \   \"QueryResponse\" or \"MalformedMessage\" items in this \"Block\".  Each\n\
    \   element is an array that, if present, must not be empty.\n   An item in the\
    \ \"qlist\" array contains indexes to values in the \"qrr\"\n   array.  Therefore,\
    \ if \"qlist\" is present, \"qrr\" must also be present.\n   Similarly, if \"\
    rrlist\" is present, \"rr\" must also be present.\n   The map contains the following\
    \ items:\n   +-------------------+---+---+---------------------------------------+\n\
    \   | Field             | M | T | Description                           |\n  \
    \ +-------------------+---+---+---------------------------------------+\n   |\
    \ ip-address        |   | A | Array of IP addresses, in network     |\n   |  \
    \                 |   |   | byte order (of type byte string).  If |\n   |    \
    \               |   |   | client or server address prefixes are |\n   |      \
    \             |   |   | set, only the address prefix bits are |\n   |        \
    \           |   |   | stored.  Each string is therefore up  |\n   |          \
    \         |   |   | to 4 bytes long for an IPv4 address,  |\n   |            \
    \       |   |   | or up to 16 bytes long for an IPv6    |\n   |              \
    \     |   |   | address.  See Section 7.3.1.1.1.      |\n   |                \
    \   |   |   |                                       |\n   | classtype        \
    \ |   | A | Array of RR CLASS and TYPE            |\n   |                   |\
    \   |   | information.  Type is \"ClassType\".    |\n   |                   |\
    \   |   | See Section 7.3.2.3.1.                |\n   |                   |  \
    \ |   |                                       |\n   | name-rdata        |   |\
    \ A | Array where each entry is the         |\n   |                   |   |  \
    \ | contents of a single NAME or RDATA in |\n   |                   |   |   |\
    \ wire format (of type byte string).    |\n   |                   |   |   | Note\
    \ that NAMEs, and labels within    |\n   |                   |   |   | RDATA contents,\
    \ are full domain names |\n   |                   |   |   | or labels; no name\
    \ compression (per   |\n   |                   |   |   | [RFC1035]) is used on\
    \ the individual  |\n   |                   |   |   | names/labels within the\
    \ format.       |\n   |                   |   |   |                          \
    \             |\n   | qr-sig            |   | A | Array of Q/R data item signatures.\
    \    |\n   |                   |   |   | Type is \"QueryResponseSignature\". \
    \    |\n   |                   |   |   | See Section 7.3.2.3.2.              \
    \  |\n   |                   |   |   |                                       |\n\
    \   | qlist             |   | A | Array of type \"QuestionList\".  A      |\n\
    \   |                   |   |   | \"QuestionList\" is an array of         |\n\
    \   |                   |   |   | unsigned integers, indexes to         |\n  \
    \ |                   |   |   | \"Question\" items in the \"qrr\" array.  |\n\
    \   |                   |   |   |                                       |\n  \
    \ | qrr               |   | A | Array of type \"Question\".  Each entry |\n  \
    \ |                   |   |   | is the contents of a single Question, |\n   |\
    \                   |   |   | where a Question is the second or     |\n   |  \
    \                 |   |   | subsequent Question in a Query.  See  |\n   |    \
    \               |   |   | Section 7.3.2.3.3.                    |\n   |      \
    \             |   |   |                                       |\n   | rrlist \
    \           |   | A | Array of type \"RRList\".  An \"RRList\"  |\n   |      \
    \             |   |   | is an array of unsigned integers,     |\n   |        \
    \           |   |   | indexes to \"RR\" items in the \"rr\"     |\n   |      \
    \             |   |   | array.                                |\n   |        \
    \           |   |   |                                       |\n   | rr       \
    \         |   | A | Array of type \"RR\".  Each entry is    |\n   |          \
    \         |   |   | the contents of a single RR.  See     |\n   |            \
    \       |   |   | Section 7.3.2.3.4.                    |\n   |              \
    \     |   |   |                                       |\n   | malformed-message\
    \ |   | A | Array of the contents of malformed    |\n   | -data             |\
    \   |   | messages.  Array of type              |\n   |                   |  \
    \ |   | \"MalformedMessageData\".  See Section  |\n   |                   |  \
    \ |   | 7.3.2.3.5.                            |\n   +-------------------+---+---+---------------------------------------+\n"
- title: 7.3.2.3.1.  "ClassType"
  contents:
  - "7.3.2.3.1.  \"ClassType\"\n   RR CLASS and TYPE information.  A map containing\
    \ the following:\n               +-------+---+---+--------------------------+\n\
    \               | Field | M | T | Description              |\n               +-------+---+---+--------------------------+\n\
    \               | type  | X | U | TYPE value [rrtypes].    |\n               |\
    \       |   |   |                          |\n               | class | X | U |\
    \ CLASS value [rrclasses]. |\n               +-------+---+---+--------------------------+\n"
- title: 7.3.2.3.2.  "QueryResponseSignature"
  contents:
  - "7.3.2.3.2.  \"QueryResponseSignature\"\n   Elements of a Q/R data item that are\
    \ often common between multiple\n   individual Q/R data items.  A map containing\
    \ the following:\n   +--------------------+---+---+--------------------------------------+\n\
    \   | Field              | M | T | Description                          |\n  \
    \ +--------------------+---+---+--------------------------------------+\n   |\
    \ server-address     |   | U | The index in the \"ip-address\" array  |\n   |\
    \ -index             |   |   | of the server IP address.  See       |\n   |  \
    \                  |   |   | Section 7.3.2.3.                     |\n   |    \
    \                |   |   |                                      |\n   | server-port\
    \        |   | U | The server port.                     |\n   |              \
    \      |   |   |                                      |\n   | qr-transport-flags\
    \ | C | U | Bit flags describing the transport   |\n   |                    |\
    \   |   | used to service the Query.  Same     |\n   |                    |  \
    \ |   | definition as \"mm-transport-flags\"   |\n   |                    |  \
    \ |   | in Section 7.3.2.3.5, with an        |\n   |                    |   |\
    \   | additional indicator for trailing    |\n   |                    |   |  \
    \ | bytes.  See Appendix A.              |\n   |                    |   |   |\
    \ Bit 0.  IP version.  0 if IPv4, 1 if |\n   |                    |   |   | IPv6.\
    \  See Section 6.2.4.            |\n   |                    |   |   | Bits 1-4.\
    \  Transport.  4-bit         |\n   |                    |   |   | unsigned value\
    \ where                 |\n   |                    |   |   | 0 = UDP [RFC1035]\
    \                    |\n   |                    |   |   | 1 = TCP [RFC1035]  \
    \                  |\n   |                    |   |   | 2 = TLS [RFC7858]    \
    \                |\n   |                    |   |   | 3 = DTLS [RFC8094]     \
    \              |\n   |                    |   |   | 4 = HTTPS [RFC8484]      \
    \            |\n   |                    |   |   | 15 = Non-standard transport\
    \ (see     |\n   |                    |   |   | below)                       \
    \        |\n   |                    |   |   | Values 5-14 are reserved for future\
    \  |\n   |                    |   |   | use.                                 |\n\
    \   |                    |   |   | Bit 5.  1 if trailing bytes in Query |\n  \
    \ |                    |   |   | packet.  See Section 11.2.           |\n   |\
    \                    |   |   |                                      |\n   | qr-type\
    \            |   | U | Type of Query/Response transaction   |\n   |          \
    \          |   |   | based on the definitions in the      |\n   |            \
    \        |   |   | dnstap schema [dnstap-schema].       |\n   |              \
    \      |   |   | 0 = Stub.  A transaction between a   |\n   |                \
    \    |   |   | stub resolver and a DNS server from  |\n   |                  \
    \  |   |   | the perspective of the stub          |\n   |                    |\
    \   |   | resolver.                            |\n   |                    |  \
    \ |   | 1 = Client.  A transaction between a |\n   |                    |   |\
    \   | client and a DNS server (a proxy or  |\n   |                    |   |  \
    \ | full recursive resolver) from the    |\n   |                    |   |   |\
    \ perspective of the DNS server.       |\n   |                    |   |   | 2\
    \ = Resolver.  A transaction between |\n   |                    |   |   | a recursive\
    \ resolver and an          |\n   |                    |   |   | authoritative\
    \ server from the        |\n   |                    |   |   | perspective of the\
    \ recursive         |\n   |                    |   |   | resolver.           \
    \                 |\n   |                    |   |   | 3 = Authoritative.  A transaction\
    \    |\n   |                    |   |   | between a recursive resolver and an\
    \  |\n   |                    |   |   | authoritative server from the        |\n\
    \   |                    |   |   | perspective of the authoritative     |\n  \
    \ |                    |   |   | server.                              |\n   |\
    \                    |   |   | 4 = Forwarder.  A transaction        |\n   |  \
    \                  |   |   | between a downstream forwarder and   |\n   |    \
    \                |   |   | an upstream DNS server (a recursive  |\n   |      \
    \              |   |   | resolver) from the perspective of    |\n   |        \
    \            |   |   | the downstream forwarder.            |\n   |          \
    \          |   |   | 5 = Tool.  A transaction between a   |\n   |            \
    \        |   |   | DNS software tool and a DNS server,  |\n   |              \
    \      |   |   | from the perspective of the tool.    |\n   |                \
    \    |   |   |                                      |\n   | qr-sig-flags     \
    \  |   | U | Bit flags explicitly indicating      |\n   |                    |\
    \   |   | attributes of the message pair       |\n   |                    |  \
    \ |   | represented by this Q/R data item    |\n   |                    |   |\
    \   | (not all attributes may be recorded  |\n   |                    |   |  \
    \ | or deducible).                       |\n   |                    |   |   |\
    \ Bit 0.  1 if a Query was present.    |\n   |                    |   |   | Bit\
    \ 1.  1 if a Response was present. |\n   |                    |   |   | Bit 2.\
    \  1 if a Query was present and |\n   |                    |   |   | it had an\
    \ OPT RR.                    |\n   |                    |   |   | Bit 3.  1 if\
    \ a Response was present  |\n   |                    |   |   | and it had an OPT\
    \ RR.                |\n   |                    |   |   | Bit 4.  1 if a Query\
    \ was present but |\n   |                    |   |   | had no Question.      \
    \               |\n   |                    |   |   | Bit 5.  1 if a Response was\
    \ present  |\n   |                    |   |   | but had no Question (only one\
    \        |\n   |                    |   |   | query-name-index is stored per Q/R\
    \   |\n   |                    |   |   | data item).                         \
    \ |\n   |                    |   |   |                                      |\n\
    \   | query-opcode       |   | U | Query OPCODE.                        |\n  \
    \ |                    |   |   |                                      |\n   |\
    \ qr-dns-flags       |   | U | Bit flags with values from the Query |\n   |  \
    \                  |   |   | and Response DNS flags.  Flag values |\n   |    \
    \                |   |   | are 0 if the Query or Response is    |\n   |      \
    \              |   |   | not present.                         |\n   |        \
    \            |   |   | Bit 0.  Query Checking Disabled      |\n   |          \
    \          |   |   | (CD).                                |\n   |            \
    \        |   |   | Bit 1.  Query Authenticated Data     |\n   |              \
    \      |   |   | (AD).                                |\n   |                \
    \    |   |   | Bit 2.  Query reserved (Z).          |\n   |                  \
    \  |   |   | Bit 3.  Query Recursion Available    |\n   |                    |\
    \   |   | (RA).                                |\n   |                    |  \
    \ |   | Bit 4.  Query Recursion Desired      |\n   |                    |   |\
    \   | (RD).                                |\n   |                    |   |  \
    \ | Bit 5.  Query TrunCation (TC).       |\n   |                    |   |   |\
    \ Bit 6.  Query Authoritative Answer   |\n   |                    |   |   | (AA).\
    \                                |\n   |                    |   |   | Bit 7. \
    \ Query DNSSEC answer OK (DO). |\n   |                    |   |   | Bit 8.  Response\
    \ Checking Disabled   |\n   |                    |   |   | (CD).             \
    \                   |\n   |                    |   |   | Bit 9.  Response Authenticated\
    \ Data  |\n   |                    |   |   | (AD).                           \
    \     |\n   |                    |   |   | Bit 10.  Response reserved (Z).   \
    \   |\n   |                    |   |   | Bit 11.  Response Recursion         \
    \ |\n   |                    |   |   | Available (RA).                      |\n\
    \   |                    |   |   | Bit 12.  Response Recursion Desired  |\n  \
    \ |                    |   |   | (RD).                                |\n   |\
    \                    |   |   | Bit 13.  Response TrunCation (TC).   |\n   |  \
    \                  |   |   | Bit 14.  Response Authoritative      |\n   |    \
    \                |   |   | Answer (AA).                         |\n   |      \
    \              |   |   |                                      |\n   | query-rcode\
    \        |   | U | Query RCODE.  If the Query contains  |\n   |              \
    \      |   |   | an OPT RR [RFC6891], this value      |\n   |                \
    \    |   |   | incorporates any EXTENDED-RCODE      |\n   |                  \
    \  |   |   | value [rcodes].                      |\n   |                    |\
    \   |   |                                      |\n   | query-classtype    |  \
    \ | U | The index in the \"classtype\" array   |\n   | -index             |  \
    \ |   | of the CLASS and TYPE of the first   |\n   |                    |   |\
    \   | Question.  See Section 7.3.2.3.      |\n   |                    |   |  \
    \ |                                      |\n   | query-qdcount      |   | U |\
    \ The QDCOUNT in the Query, or         |\n   |                    |   |   | Response\
    \ if no Query present.        |\n   |                    |   |   |           \
    \                           |\n   | query-ancount      |   | U | Query ANCOUNT.\
    \                       |\n   |                    |   |   |                 \
    \                     |\n   | query-nscount      |   | U | Query NSCOUNT.    \
    \                   |\n   |                    |   |   |                     \
    \                 |\n   | query-arcount      |   | U | Query ARCOUNT.        \
    \               |\n   |                    |   |   |                         \
    \             |\n   | query-edns-version |   | U | The Query EDNS version.  (\"\
    EDNS\"     |\n   |                    |   |   | stands for Extension Mechanisms\
    \ for  |\n   |                    |   |   | DNS.)                            \
    \    |\n   |                    |   |   |                                    \
    \  |\n   | query-udp-size     |   | U | The Query EDNS sender's UDP payload  |\n\
    \   |                    |   |   | size.                                |\n  \
    \ |                    |   |   |                                      |\n   |\
    \ query-opt-rdata    |   | U | The index in the \"name-rdata\" array  |\n   |\
    \ -index             |   |   | of the OPT RDATA.  See Section       |\n   |  \
    \                  |   |   | 7.3.2.3.                             |\n   |    \
    \                |   |   |                                      |\n   | response-rcode\
    \     |   | U | Response RCODE.  If the Response     |\n   |                 \
    \   |   |   | contains an OPT RR [RFC6891], this   |\n   |                   \
    \ |   |   | value incorporates any EXTENDED-     |\n   |                    |\
    \   |   | RCODE value [rcodes].                |\n   +--------------------+---+---+--------------------------------------+\n\
    \   Version 1.0 of C-DNS supports transport values corresponding to DNS\n   transports\
    \ defined in IETF Standards Track documents at the time of\n   writing.  There\
    \ are numerous non-standard methods of sending DNS\n   messages over various transports\
    \ using a variety of protocols, but\n   they are out of scope for this document.\
    \  With the current\n   specification, these can be generically stored using value\
    \ 15\n   (Non-standard transport), or implementations are free to use the\n  \
    \ negative integer map keys to define their own mappings.  Such\n   non-standard\
    \ transports may also be the subject of a future extension\n   to the specification.\n"
- title: 7.3.2.3.3.  "Question"
  contents:
  - "7.3.2.3.3.  \"Question\"\n   Details on individual Questions in a Question section.\
    \  A map\n   containing the following:\n   +-----------------+---+---+-----------------------------------------+\n\
    \   | Field           | M | T | Description                             |\n  \
    \ +-----------------+---+---+-----------------------------------------+\n   |\
    \ name-index      | X | U | The index in the \"name-rdata\" array of  |\n   |\
    \                 |   |   | the QNAME.  See Section 7.3.2.3.        |\n   |  \
    \               |   |   |                                         |\n   | classtype-index\
    \ | X | U | The index in the \"classtype\" array of   |\n   |                \
    \ |   |   | the CLASS and TYPE of the Question.     |\n   |                 |\
    \   |   | See Section 7.3.2.3.                    |\n   +-----------------+---+---+-----------------------------------------+\n"
- title: 7.3.2.3.4.  "RR"
  contents:
  - "7.3.2.3.4.  \"RR\"\n   Details on individual RRs in RR sections.  A map containing\
    \ the\n   following:\n   +-----------------+---+---+-----------------------------------------+\n\
    \   | Field           | M | T | Description                             |\n  \
    \ +-----------------+---+---+-----------------------------------------+\n   |\
    \ name-index      | X | U | The index in the \"name-rdata\" array of  |\n   |\
    \                 |   |   | the NAME.  See Section 7.3.2.3.         |\n   |  \
    \               |   |   |                                         |\n   | classtype-index\
    \ | X | U | The index in the \"classtype\" array of   |\n   |                \
    \ |   |   | the CLASS and TYPE of the RR.  See      |\n   |                 |\
    \   |   | Section 7.3.2.3.                        |\n   |                 |  \
    \ |   |                                         |\n   | ttl             |   |\
    \ U | The RR Time to Live.                    |\n   |                 |   |  \
    \ |                                         |\n   | rdata-index     |   | U |\
    \ The index in the \"name-rdata\" array of  |\n   |                 |   |   |\
    \ the RR RDATA.  See Section 7.3.2.3.     |\n   +-----------------+---+---+-----------------------------------------+\n"
- title: 7.3.2.3.5.  "MalformedMessageData"
  contents:
  - "7.3.2.3.5.  \"MalformedMessageData\"\n   Details on malformed DNS messages stored\
    \ in this \"Block\" item.  A map\n   containing the following:\n   +--------------------+---+---+--------------------------------------+\n\
    \   | Field              | M | T | Description                          |\n  \
    \ +--------------------+---+---+--------------------------------------+\n   |\
    \ server-address     |   | U | The index in the \"ip-address\" array  |\n   |\
    \ -index             |   |   | of the server IP address.  See       |\n   |  \
    \                  |   |   | Section 7.3.2.3.                     |\n   |    \
    \                |   |   |                                      |\n   | server-port\
    \        |   | U | The server port.                     |\n   |              \
    \      |   |   |                                      |\n   | mm-transport-flags\
    \ | C | U | Bit flags describing the transport   |\n   |                    |\
    \   |   | used to service the Query.  See      |\n   |                    |  \
    \ |   | Section 6.2.4.                       |\n   |                    |   |\
    \   | Bits 1-4.  Transport.  4-bit         |\n   |                    |   |  \
    \ | unsigned value where                 |\n   |                    |   |   |\
    \ 0 = UDP [RFC1035]                    |\n   |                    |   |   | 1\
    \ = TCP [RFC1035]                    |\n   |                    |   |   | 2 =\
    \ TLS [RFC7858]                    |\n   |                    |   |   | 3 = DTLS\
    \ [RFC8094]                   |\n   |                    |   |   | 4 = HTTPS [RFC8484]\
    \                  |\n   |                    |   |   | 15 = Non-standard transport\
    \          |\n   |                    |   |   | Values 5-14 are reserved for future\
    \  |\n   |                    |   |   | use.                                 |\n\
    \   |                    |   |   |                                      |\n  \
    \ | mm-payload         |   | S | The payload (raw bytes) of the DNS   |\n   |\
    \                    |   |   | message.                             |\n   +--------------------+---+---+--------------------------------------+\n"
- title: 7.3.2.4.  "QueryResponse"
  contents:
  - "7.3.2.4.  \"QueryResponse\"\n   Details on individual Q/R data items.\n   Note\
    \ that there is no requirement that the elements of the\n   \"query-responses\"\
    \ array are presented in strict chronological order.\n   A map containing the\
    \ following items:\n   +----------------------+---+---+------------------------------------+\n\
    \   | Field                | M | T | Description                        |\n  \
    \ +----------------------+---+---+------------------------------------+\n   |\
    \ time-offset          |   | U | Q/R timestamp as an offset in      |\n   |  \
    \                    |   |   | ticks (see Section 7.3.1.1.1) from |\n   |    \
    \                  |   |   | \"earliest-time\".  The timestamp is |\n   |    \
    \                  |   |   | the timestamp of the Query, or the |\n   |      \
    \                |   |   | Response if there is no Query.     |\n   |        \
    \              |   |   |                                    |\n   | client-address-index\
    \ |   | U | The index in the \"ip-address\"      |\n   |                     \
    \ |   |   | array of the client IP address.    |\n   |                      |\
    \   |   | See Section 7.3.2.3.               |\n   |                      |  \
    \ |   |                                    |\n   | client-port          |   |\
    \ U | The client port.                   |\n   |                      |   |  \
    \ |                                    |\n   | transaction-id       |   | U |\
    \ DNS transaction identifier.        |\n   |                      |   |   |  \
    \                                  |\n   | qr-signature-index   |   | U | The\
    \ index in the \"qr-sig\" array of |\n   |                      |   |   | the\
    \ \"QueryResponseSignature\" item. |\n   |                      |   |   | See\
    \ Section 7.3.2.3.               |\n   |                      |   |   |      \
    \                              |\n   | client-hoplimit      |   | U | The IPv4\
    \ TTL or IPv6 Hoplimit from |\n   |                      |   |   | the Query packet.\
    \                  |\n   |                      |   |   |                    \
    \                |\n   | response-delay       |   | I | The time difference between\
    \ Query  |\n   |                      |   |   | and Response, in ticks.  See \
    \      |\n   |                      |   |   | Section 7.3.1.1.1.  Only present\
    \   |\n   |                      |   |   | if there is a Query and a         \
    \ |\n   |                      |   |   | Response.  The delay can be        |\n\
    \   |                      |   |   | negative if the network            |\n  \
    \ |                      |   |   | stack/capture library returns      |\n   |\
    \                      |   |   | packets out of order.              |\n   |  \
    \                    |   |   |                                    |\n   | query-name-index\
    \     |   | U | The index in the \"name-rdata\"      |\n   |                 \
    \     |   |   | array of the item containing the   |\n   |                   \
    \   |   |   | QNAME for the first Question.  See |\n   |                     \
    \ |   |   | Section 7.3.2.3.                   |\n   |                      |\
    \   |   |                                    |\n   | query-size           |  \
    \ | U | DNS Query message size (see        |\n   |                      |   |\
    \   | below).                            |\n   |                      |   |  \
    \ |                                    |\n   | response-size        |   | U |\
    \ DNS Response message size (see     |\n   |                      |   |   | below).\
    \                            |\n   |                      |   |   |          \
    \                          |\n   | response-processing  |   | M | Data on Response\
    \ processing.  Map  |\n   | -data                |   |   | of type \"ResponseProcessingData\"\
    .  |\n   |                      |   |   | See Section 7.3.2.4.1.             |\n\
    \   |                      |   |   |                                    |\n  \
    \ | query-extended       |   | M | Extended Query data.  Map of type  |\n   |\
    \                      |   |   | \"QueryResponseExtended\".  See      |\n   |\
    \                      |   |   | Section 7.3.2.4.2.                 |\n   |  \
    \                    |   |   |                                    |\n   | response-extended\
    \    |   | M | Extended Response data.  Map of    |\n   |                    \
    \  |   |   | type \"QueryResponseExtended\".  See |\n   |                    \
    \  |   |   | Section 7.3.2.4.2.                 |\n   +----------------------+---+---+------------------------------------+\n\
    \   The \"query-size\" and \"response-size\" fields hold the DNS message\n   size.\
    \  For UDP, this is the size of the UDP payload that contained\n   the DNS message.\
    \  For TCP, it is the size of the DNS message as\n   specified in the two-byte\
    \ message length header.  Trailing bytes in\n   UDP Queries are routinely observed\
    \ in traffic to authoritative\n   servers, and this value allows a calculation\
    \ of how many trailing\n   bytes were present.\n"
- title: 7.3.2.4.1.  "ResponseProcessingData"
  contents:
  - "7.3.2.4.1.  \"ResponseProcessingData\"\n   Information on the server processing\
    \ that produced the Response.  A\n   map containing the following:\n   +------------------+---+---+----------------------------------------+\n\
    \   | Field            | M | T | Description                            |\n  \
    \ +------------------+---+---+----------------------------------------+\n   |\
    \ bailiwick-index  |   | U | The index in the \"name-rdata\" array of |\n   |\
    \                  |   |   | the owner name for the Response        |\n   |  \
    \                |   |   | bailiwick.  See Section 7.3.2.3.       |\n   |    \
    \              |   |   |                                        |\n   | processing-flags\
    \ |   | U | Flags relating to Response processing. |\n   |                  |\
    \   |   | Bit 0.  1 if the Response came from    |\n   |                  |  \
    \ |   | cache.                                 |\n   +------------------+---+---+----------------------------------------+\n"
- title: 7.3.2.4.2.  "QueryResponseExtended"
  contents:
  - "7.3.2.4.2.  \"QueryResponseExtended\"\n   Extended data on the Q/R data item.\n\
    \   Each item in the map is present only if collection of the relevant\n   details\
    \ is configured.\n   A map containing the following items:\n   +------------------+---+---+----------------------------------------+\n\
    \   | Field            | M | T | Description                            |\n  \
    \ +------------------+---+---+----------------------------------------+\n   |\
    \ question-index   |   | U | The index in the \"qlist\" array of the  |\n   |\
    \                  |   |   | entry listing any second and           |\n   |  \
    \                |   |   | subsequent Questions in the Question   |\n   |    \
    \              |   |   | section for the Query or Response.     |\n   |      \
    \            |   |   | See Section 7.3.2.3.                   |\n   |        \
    \          |   |   |                                        |\n   | answer-index\
    \     |   | U | The index in the \"rrlist\" array of the |\n   |             \
    \     |   |   | entry listing the Answer RR sections   |\n   |               \
    \   |   |   | for the Query or Response.  See        |\n   |                 \
    \ |   |   | Section 7.3.2.3.                       |\n   |                  |\
    \   |   |                                        |\n   | authority-index  |  \
    \ | U | The index in the \"rrlist\" array of the |\n   |                  |  \
    \ |   | entry listing the Authority RR         |\n   |                  |   |\
    \   | sections for the Query or Response.    |\n   |                  |   |  \
    \ | See Section 7.3.2.3.                   |\n   |                  |   |   |\
    \                                        |\n   | additional-index |   | U | The\
    \ index in the \"rrlist\" array of the |\n   |                  |   |   | entry\
    \ listing the Additional RR        |\n   |                  |   |   | sections\
    \ for the Query or Response.    |\n   |                  |   |   | See Section\
    \ 7.3.2.3.  Note that Query  |\n   |                  |   |   | OPT RR data can\
    \ optionally be stored   |\n   |                  |   |   | in the QuerySignature.\
    \                 |\n   +------------------+---+---+----------------------------------------+\n"
- title: 7.3.2.5.  "AddressEventCount"
  contents:
  - "7.3.2.5.  \"AddressEventCount\"\n   Counts of various IP-related events relating\
    \ to traffic with\n   individual client addresses.  A map containing the following:\n\
    \   +--------------------+---+---+--------------------------------------+\n  \
    \ | Field              | M | T | Description                          |\n   +--------------------+---+---+--------------------------------------+\n\
    \   | ae-type            | X | U | The type of event.  The following    |\n  \
    \ |                    |   |   | event types are currently defined:   |\n   |\
    \                    |   |   | 0.  TCP reset.                       |\n   |  \
    \                  |   |   | 1.  ICMP time exceeded.              |\n   |    \
    \                |   |   | 2.  ICMP destination unreachable.    |\n   |      \
    \              |   |   | 3.  ICMPv6 time exceeded.            |\n   |        \
    \            |   |   | 4.  ICMPv6 destination unreachable.  |\n   |          \
    \          |   |   | 5.  ICMPv6 packet too big.           |\n   |            \
    \        |   |   |                                      |\n   | ae-code      \
    \      |   | U | A code relating to the event.  For   |\n   |                \
    \    |   |   | ICMP or ICMPv6 events, this MUST be  |\n   |                  \
    \  |   |   | the ICMP [RFC792] or ICMPv6          |\n   |                    |\
    \   |   | [RFC4443] code.  For other events,   |\n   |                    |  \
    \ |   | the contents are undefined.          |\n   |                    |   |\
    \   |                                      |\n   | ae-transport-flags | C | U\
    \ | Bit flags describing the transport   |\n   |                    |   |   |\
    \ used to service the event.  See      |\n   |                    |   |   | Section\
    \ 6.2.4.                       |\n   |                    |   |   | Bit 0.  IP\
    \ version.  0 if IPv4, 1 if |\n   |                    |   |   | IPv6.       \
    \                         |\n   |                    |   |   | Bits 1-4.  Transport.\
    \  4-bit         |\n   |                    |   |   | unsigned value where   \
    \              |\n   |                    |   |   | 0 = UDP [RFC1035]        \
    \            |\n   |                    |   |   | 1 = TCP [RFC1035]          \
    \          |\n   |                    |   |   | 2 = TLS [RFC7858]            \
    \        |\n   |                    |   |   | 3 = DTLS [RFC8094]             \
    \      |\n   |                    |   |   | 4 = HTTPS [RFC8484]              \
    \    |\n   |                    |   |   | 15 = Non-standard transport        \
    \  |\n   |                    |   |   | Values 5-14 are reserved for future  |\n\
    \   |                    |   |   | use.                                 |\n  \
    \ |                    |   |   |                                      |\n   |\
    \ ae-address-index   | X | U | The index in the \"ip-address\" array  |\n   |\
    \                    |   |   | of the client address.  See Section  |\n   |  \
    \                  |   |   | 7.3.2.3.                             |\n   |    \
    \                |   |   |                                      |\n   | ae-count\
    \           | X | U | The number of occurrences of this    |\n   |           \
    \         |   |   | event during the Block collection    |\n   |             \
    \       |   |   | period.                              |\n   +--------------------+---+---+--------------------------------------+\n"
- title: 7.3.2.6.  "MalformedMessage"
  contents:
  - "7.3.2.6.  \"MalformedMessage\"\n   Details on Malformed Message data items. \
    \ A map containing the\n   following:\n   +----------------------+---+---+------------------------------------+\n\
    \   | Field                | M | T | Description                        |\n  \
    \ +----------------------+---+---+------------------------------------+\n   |\
    \ time-offset          |   | U | Message timestamp as an offset in  |\n   |  \
    \                    |   |   | ticks (see Section 7.3.1.1.1) from |\n   |    \
    \                  |   |   | \"earliest-time\".                   |\n   |    \
    \                  |   |   |                                    |\n   | client-address-index\
    \ |   | U | The index in the \"ip-address\"      |\n   |                     \
    \ |   |   | array of the client IP address.    |\n   |                      |\
    \   |   | See Section 7.3.2.3.               |\n   |                      |  \
    \ |   |                                    |\n   | client-port          |   |\
    \ U | The client port.                   |\n   |                      |   |  \
    \ |                                    |\n   | message-data-index   |   | U |\
    \ The index in the \"malformed-       |\n   |                      |   |   | message-data\"\
    \ array of the message |\n   |                      |   |   | data for this message.\
    \  See        |\n   |                      |   |   | Section 7.3.2.3.        \
    \           |\n   +----------------------+---+---+------------------------------------+\n"
- title: 8.  Versioning
  contents:
  - "8.  Versioning\n   The C-DNS File Preamble includes a file Format Version; a\
    \ major and\n   minor version number are required fields.  This document defines\n\
    \   version 1.0 of the C-DNS specification.  This section describes the\n   intended\
    \ use of these version numbers in future specifications.\n   It is noted that\
    \ version 1.0 includes many optional fields;\n   therefore, consumers of version\
    \ 1.0 should be inherently robust to\n   parsing files with variable data content.\n\
    \   Within a major version, a new minor version MUST be a strict superset\n  \
    \ of the previous minor version, with no semantic changes to existing\n   fields.\
    \  New keys MAY be added to existing maps, and new maps MAY be\n   added.  A consumer\
    \ capable of reading a particular major.minor\n   version MUST also be capable\
    \ of reading all previous minor versions\n   of the same major version.  It SHOULD\
    \ also be capable of parsing all\n   subsequent minor versions, ignoring any keys\
    \ or maps that it does not\n   recognize.\n   A new major version indicates changes\
    \ to the format that are not\n   backwards compatible with previous major versions.\
    \  A consumer\n   capable of only reading a particular major version (greater\
    \ than 1)\n   is neither required nor expected to be capable of reading a previous\n\
    \   major version.\n"
- title: 9.  C-DNS to PCAP
  contents:
  - "9.  C-DNS to PCAP\n   It is usually possible to reconstruct PCAP files from the\
    \ C-DNS\n   format in a lossy fashion.  Some of the issues with reconstructing\n\
    \   both the DNS payload and the full packet stream are outlined here.\n   The\
    \ reconstruction of well-formed DNS messages depends on two\n   factors:\n   1.\
    \  Whether or not a particular subset of the optional fields were\n       captured\
    \ in the C-DNS file, specifically the data fields\n       necessary to reconstruct\
    \ a valid IP header and DNS payload for\n       both Query and Response (see Appendix\
    \ D.1).  Clearly, if not all\n       these data fields were captured, the reconstruction\
    \ is likely to\n       be imperfect even if reasonable defaults are provided for\
    \ the\n       reconstruction.\n   2.  Whether or not at least one field was captured\
    \ that unambiguously\n       identifies the Query/Response data item as containing\
    \ just a\n       Query, just a Response, or a Query/Response pair.  Obviously,\
    \ the\n       qr-sig-flags defined in Section 7.3.2.3.2 is such a field;\n   \
    \    however, this field is optional.  For more details, see\n       Appendix\
    \ D.2.\n   It is noted again that simply having hints that indicate that certain\n\
    \   data fields were not omitted does not guarantee that those data\n   fields\
    \ were actually captured.  Therefore, the ability to reconstruct\n   PCAP data\
    \ (in the absence of defaults) can in principle vary for each\n   record captured\
    \ in a C-DNS file, and between Blocks that have\n   differing hints.\n   Even\
    \ if all sections of the Response were captured, one cannot\n   reconstruct the\
    \ DNS Response payload exactly, due to the fact that\n   some DNS names in the\
    \ message on the wire may have been compressed.\n   Section 9.1 discusses this\
    \ in more detail.\n   Some transport information is not captured in the C-DNS\
    \ format.  For\n   example, the following aspects of the original packet stream\
    \ cannot\n   be reconstructed from the C-DNS format:\n   o  IP fragmentation\n\
    \   o  TCP stream information:\n      *  Multiple DNS messages may have been sent\
    \ in a single TCP\n         segment\n      *  A DNS payload may have been split\
    \ across multiple TCP segments\n      *  Multiple DNS messages may have been sent\
    \ on a single TCP\n         session\n   o  TLS session information:\n      * \
    \ TLS version or cipher suites\n      *  TLS-related features such as TCP Fast\
    \ Open (TFO) [RFC7413] or\n         TLS session resumption [RFC5077]\n   o  DNS-over-HTTPS\
    \ [RFC8484] message details:\n      *  Whether the message used POST or GET\n\
    \      *  HTTPS Headers\n   o  Malformed DNS messages if the wire format is not\
    \ recorded\n   o  Any non-DNS messages that were in the original packet stream,\n\
    \      e.g., ICMP\n   Simple assumptions can be made on the reconstruction: fragmented\
    \ and\n   DNS-over-TCP messages can be reconstructed into single packets, and\
    \ a\n   single TCP session can be constructed for each TCP packet.\n   Additionally,\
    \ if malformed messages and non-DNS packets are captured\n   separately, they\
    \ can be merged with packet captures reconstructed\n   from C-DNS to produce a\
    \ more complete packet stream.\n"
- title: 9.1.  Name Compression
  contents:
  - "9.1.  Name Compression\n   All the names stored in the C-DNS format are full\
    \ domain names; no\n   name compression (per [RFC1035]) is used on the individual\
    \ names\n   within the format.  Therefore, when reconstructing a packet, name\n\
    \   compression must be used in order to reproduce the on-the-wire\n   representation\
    \ of the packet.\n   Name compression per [RFC1035] works by substituting trailing\n\
    \   sections of a name with a reference back to the occurrence of those\n   sections\
    \ earlier in the message.  Not all name server software uses\n   the same algorithm\
    \ when compressing domain names within the\n   Responses.  Some attempt maximum\
    \ recompression at the expense of\n   runtime resources, others use heuristics\
    \ to balance compression and\n   speed, and others use different rules for what\
    \ is a valid compression\n   target.\n   This means that Responses to the same\
    \ Query from different name\n   server software that match in terms of DNS payload\
    \ content (header,\n   counts, RRs with name compression removed) do not necessarily\
    \ match\n   byte for byte on the wire.\n   Therefore, it is not possible to ensure\
    \ that the DNS Response payload\n   is reconstructed byte for byte from C-DNS\
    \ data.  However, it can at\n   least, in principle, be reconstructed to have\
    \ the correct payload\n   length (since the original Response length is captured)\
    \ if there is\n   enough knowledge of the commonly implemented name compression\n\
    \   algorithms.  For example, a simplistic approach would be to try each\n   algorithm\
    \ in turn to see if it reproduces the original length,\n   stopping at the first\
    \ match.  This would not guarantee that the\n   correct algorithm has been used,\
    \ as it is possible to match the\n   length whilst still not matching the on-the-wire\
    \ bytes; however,\n   without further information added to the C-DNS data, this\
    \ is the best\n   that can be achieved.\n   Appendix B presents an example of\
    \ two different compression\n   algorithms used by well-known name server software.\n"
- title: 10.  Data Collection
  contents:
  - "10.  Data Collection\n   This section describes a non-normative proposed algorithm\
    \ for the\n   processing of a captured stream of DNS Queries and Responses and\n\
    \   production of a stream of Q/R data items, matching Queries and\n   Responses\
    \ where possible.\n   For the purposes of this discussion, it is assumed that\
    \ the input has\n   been preprocessed such that:\n   1.  All IP fragmentation\
    \ reassembly, TCP stream reassembly, and\n       so on, have already been performed.\n\
    \   2.  Each message is associated with transport metadata required to\n     \
    \  generate the Primary ID (see Section 10.2.1).\n   3.  Each message has a well-formed\
    \ DNS Header of 12 bytes, and (if\n       present) the first Question in the Question\
    \ section can be parsed\n       to generate the Secondary ID (see below).  As\
    \ noted earlier, this\n       requirement can result in a malformed Query being\
    \ removed in the\n       preprocessing stage, but the correctly formed Response\
    \ with RCODE\n       of FORMERR being present.\n   DNS messages are processed\
    \ in the order they are delivered to the\n   implementation.\n   It should be\
    \ noted that packet capture libraries do not necessarily\n   provide packets in\
    \ strict chronological order.  This can, for\n   example, arise on multi-core\
    \ platforms where packets arriving at a\n   network device are processed by different\
    \ cores.  On systems where\n   this behavior has been observed, the timestamps\
    \ associated with each\n   packet are consistent; Queries always have a timestamp\
    \ prior to the\n   Response timestamp.  However, the order in which these packets\
    \ appear\n   in the packet capture stream is not necessarily strictly\n   chronological;\
    \ a Response can appear in the capture stream before the\n   Query that provoked\
    \ the Response.  For this discussion, this\n   non-chronological delivery is termed\
    \ \"skew\".\n   In the presence of skew, Response packets can arrive for matching\n\
    \   before the corresponding Query.  To avoid generating false instances\n   of\
    \ Responses without a matching Query, and Queries without a matching\n   Response,\
    \ the matching algorithm must take the possibility of skew\n   into account.\n"
- title: 10.1.  Matching Algorithm
  contents:
  - "10.1.  Matching Algorithm\n   A schematic representation of the algorithm for\
    \ matching Q/R data\n   items is shown in Figure 3.  It takes individual DNS Query\
    \ or\n   Response messages as input, and it outputs matched Q/R data items.\n\
    \   The numbers in the figure identify matching operations listed in\n   Table\
    \ 1.  Specific details of the algorithm -- for example, queues,\n   timers, and\
    \ identifiers -- are given in the following sections.\n                      \
    \ .----------------------.\n                       | Process next message |<------------------+\n\
    \                       `----------------------'                   |\n       \
    \                            |                              |\n              \
    \     +------------------------------+               |\n                   | Generate\
    \ message identifiers |               |\n                   +------------------------------+\
    \               |\n                                   |                      \
    \        |\n                          Response | Query                       \
    \ |\n                   +--------------< >---------------+             |\n   \
    \                |                                |             |\n         +--------------------+\
    \           +--------------------+  |\n         | Find earliest QR   |       \
    \    | Create QR item (2) |  |\n         | item in OFIFO (1)  |           +--------------------+\
    \  |\n         +--------------------+                     |             |\n  \
    \                  |                        +---------------+    |\n         \
    \     Match | No match               | Append new QR |    |\n          +--------<\
    \ >------+                | item to OFIFO |    |\n          |                \
    \ |                +---------------+    |\n    +-----------+      +--------+ \
    \                  |             |\n    | Update QR |      | Add to |        \
    \  +-------------------+  |\n    | item (3)  |      | RFIFO  |          | Find\
    \ earliest QR  |  |\n    +-----------+      +--------+          | item in RFIFO\
    \ (1) |  |\n          |                 |              +-------------------+ \
    \ |\n          +-----------------+                       |             |\n   \
    \                 |                               |             |\n          \
    \          |     +----------------+  Match | No match    |\n                 \
    \   |     | Remove R       |-------< >-----+      |\n                    |   \
    \  | from RFIFO (3) |               |      |\n                    |     +----------------+\
    \               |      |\n                    |              |               \
    \        |      |\n                    +--------------+-----------------------+\
    \      |\n                                   |                              |\n\
    \            +----------------------------------------------+      |\n       \
    \     | Update all timed-out (QT) OFIFO QR items (4) |      |\n            +----------------------------------------------+\
    \      |\n                                   |                              |\n\
    \                   +--------------------------------+             |\n       \
    \            | Remove all timed-out (ST) R    |             |\n              \
    \     | from RFIFO, create QR item (5) |             |\n                   +--------------------------------+\
    \             |\n               ____________________|_______________________ \
    \      |\n              /                                            /      |\n\
    \             /  Remove all consecutive done entries from  /-------+\n       \
    \     /   front of OFIFO for further processing    /\n           /____________________________________________/\n\
    \           OFIFO = output FIFO containing Q/R data items (Section 10.6)\n   \
    \        RFIFO = Response FIFO containing unmatched Response items\n         \
    \          (Section 10.6)\n           QT = Query Timeout (Section 10.3)\n    \
    \       ST = Skew Timeout (Section 10.3)\n                Figure 3: Query/Response\
    \ Matching Algorithm\n         +-----------+-------------------------------------------+\n\
    \         | Reference | Operation                                 |\n        \
    \ +-----------+-------------------------------------------+\n         | (1)  \
    \     | Find earliest QR item in FIFO where:      |\n         |           | *\
    \ QR.done = false                         |\n         |           | * QR.Q.PrimaryID\
    \ == R.PrimaryID           |\n         |           | and, if both QR.Q and R have\
    \ SecondaryID: |\n         |           | * QR.Q.SecondaryID == R.SecondaryID \
    \      |\n         |           |                                           |\n\
    \         | (2)       | Set:                                      |\n        \
    \ |           | QR.Q := Q                                 |\n         |      \
    \     | QR.R := nil                               |\n         |           | QR.done\
    \ := false                          |\n         |           |                \
    \                           |\n         | (3)       | Set:                   \
    \                   |\n         |           | QR.R := R                      \
    \           |\n         |           | QR.done := true                        \
    \   |\n         |           |                                           |\n  \
    \       | (4)       | Set:                                      |\n         |\
    \           | QR.done := true                           |\n         |        \
    \   |                                           |\n         | (5)       | Set:\
    \                                      |\n         |           | QR.Q := nil \
    \                              |\n         |           | QR.R := R           \
    \                      |\n         |           | QR.done := true             \
    \              |\n         +-----------+-------------------------------------------+\n\
    \            Table 1: Operations Used in the Matching Algorithm\n"
- title: 10.2.  Message Identifiers
  contents:
  - '10.2.  Message Identifiers

    '
- title: 10.2.1.  Primary ID (Required)
  contents:
  - "10.2.1.  Primary ID (Required)\n   A Primary ID is constructed for each message.\
    \  It is composed of the\n   following data:\n   1.  Source IP Address\n   2.\
    \  Destination IP Address\n   3.  Source Port\n   4.  Destination Port\n   5.\
    \  Transport\n   6.  DNS Message ID\n"
- title: 10.2.2.  Secondary ID (Optional)
  contents:
  - "10.2.2.  Secondary ID (Optional)\n   If present, the first Question in the Question\
    \ section is used as a\n   Secondary ID for each message.  Note that there may\
    \ be well-formed\n   DNS Queries that have a QDCOUNT of 0, and some Responses\
    \ may have a\n   QDCOUNT of 0 (for example, Responses with RCODE=FORMERR or NOTIMP).\n\
    \   In this case, the Secondary ID is not used in matching.\n"
- title: 10.3.  Algorithm Parameters
  contents:
  - "10.3.  Algorithm Parameters\n   1.  Query Timeout (QT).  A Query arrives with\
    \ timestamp t1.  If no\n       Response matching that Query has arrived before\
    \ other input\n       arrives timestamped later than (t1 + QT), a Q/R data item\n\
    \       containing only a Query is recorded.  The QT value is typically\n    \
    \   on the order of 5 seconds.\n   2.  Skew Timeout (ST).  A Response arrives\
    \ with timestamp t2.  If a\n       Response has not been matched by a Query before\
    \ input arrives\n       timestamped later than (t2 + ST), a Q/R data item containing\
    \ only\n       a Response is recorded.  The ST value is typically a few\n    \
    \   microseconds.\n"
- title: 10.4.  Algorithm Requirements
  contents:
  - "10.4.  Algorithm Requirements\n   The algorithm is designed to handle the following\
    \ input data:\n   1.  Multiple Queries with the same Primary ID (but different\n\
    \       Secondary ID) arriving before any Responses for these Queries\n      \
    \ are seen.\n   2.  Multiple Queries with the same Primary and Secondary ID arriving\n\
    \       before any Responses for these Queries are seen.\n   3.  Queries for which\
    \ no later Response can be found within the\n       specified timeout.\n   4.\
    \  Responses for which no previous Query can be found within the\n       specified\
    \ timeout.\n"
- title: 10.5.  Algorithm Limitations
  contents:
  - "10.5.  Algorithm Limitations\n   For cases 1 and 2 listed in the above requirements,\
    \ it is not\n   possible to unambiguously match Queries with Responses.  This\n\
    \   algorithm chooses to match to the earliest Query with the correct\n   Primary\
    \ and Secondary ID.\n"
- title: 10.6.  Workspace
  contents:
  - "10.6.  Workspace\n   The algorithm employs two FIFO queues:\n   o  OFIFO: an\
    \ output FIFO containing Q/R data items in chronological\n      order.\n   o \
    \ RFIFO: a FIFO holding Responses without a matching Query in order\n      of\
    \ arrival.\n"
- title: 10.7.  Output
  contents:
  - "10.7.  Output\n   The output is a list of Q/R data items.  Both the Query and\
    \ Response\n   elements are optional in these items; therefore, Q/R data items\
    \ have\n   one of three types of content:\n   1.  A matched pair of Query and\
    \ Response messages\n   2.  A Query message with no Response\n   3.  A Response\
    \ message with no Query\n   The timestamp of a list item is that of the Query\
    \ for cases 1 and 2\n   and that of the Response for case 3.\n"
- title: 10.8.  Post-Processing
  contents:
  - "10.8.  Post-Processing\n   When ending a capture, all items in the RFIFO are\
    \ timed out\n   immediately, generating Response only entries to the OFIFO.  These\n\
    \   and all other remaining entries in the OFIFO should be treated as\n   timed-out\
    \ Queries.\n"
- title: 11.  Implementation Guidance
  contents:
  - "11.  Implementation Guidance\n   Whilst this document makes no specific recommendations\
    \ with respect\n   to \"Canonical CBOR\" (see Section 3.9 of [RFC7049]), the following\n\
    \   guidance may be of use to implementers.\n   Adherence to the first two rules\
    \ given in Section 3.9 of [RFC7049]\n   will minimize file sizes.\n   Adherence\
    \ to the last two rules given in Section 3.9 of [RFC7049] for\n   all maps and\
    \ arrays would unacceptably constrain implementations --\n   for example, in the\
    \ use case of real-time data collection in\n   constrained environments where\
    \ outputting Block Tables after Q/R data\n   items and allowing indefinite-length\
    \ maps and arrays could reduce\n   memory requirements.\n   It is recommended\
    \ that implementations that have fundamental\n   restrictions on what data fields\
    \ they can collect SHOULD always store\n   hints with the bits unset for those\
    \ fields, i.e., they unambiguously\n   indicate that those data fields will be\
    \ omitted from captured C-DNS.\n"
- title: 11.1.  Optional Data
  contents:
  - "11.1.  Optional Data\n   When decoding C-DNS data, some of the items required\
    \ for a particular\n   function that the consumer wishes to perform may be missing.\n\
    \   Consumers should consider providing configurable default values to be\n  \
    \ used in place of the missing values in their output.\n"
- title: 11.2.  Trailing Bytes
  contents:
  - "11.2.  Trailing Bytes\n   A DNS Query message in a UDP or TCP payload can be\
    \ followed by some\n   additional (spurious) bytes, which are not stored in C-DNS.\n\
    \   When DNS traffic is sent over TCP, each message is prefixed with a\n   two-byte\
    \ length field, which gives the message length, excluding the\n   two-byte length\
    \ field.  In this context, trailing bytes can occur in\n   two circumstances,\
    \ with different results:\n   1.  The number of bytes consumed by fully parsing\
    \ the message is less\n       than the number of bytes given in the length field\
    \ (i.e., the\n       length field is incorrect and too large).  In this case,\
    \ the\n       surplus bytes are considered trailing bytes in a manner analogous\n\
    \       to UDP and recorded as such.  If only this case occurs, it is\n      \
    \ possible to process a packet containing multiple DNS messages\n       where\
    \ one or more have trailing bytes.\n   2.  There are surplus bytes between the\
    \ end of a well-formed message\n       and the start of the length field for the\
    \ next message.  In this\n       case, the first of the surplus bytes will be\
    \ processed as the\n       first byte of the next length field, and parsing will\
    \ proceed\n       from there, almost certainly leading to the next and any\n \
    \      subsequent messages in the packet being considered malformed.\n       This\
    \ will not generate a trailing-bytes record for the processed\n       well-formed\
    \ message.\n"
- title: 11.3.  Limiting Collection of RDATA
  contents:
  - "11.3.  Limiting Collection of RDATA\n   Implementations should consider providing\
    \ a configurable maximum\n   RDATA size for captures -- for example, to avoid\
    \ memory issues when\n   confronted with large zone transfer records.\n"
- title: 11.4.  Timestamps
  contents:
  - "11.4.  Timestamps\n   The preamble to each block includes a timestamp of the\
    \ earliest\n   record in the Block.  As described in Section 7.3.2.1, the timestamp\n\
    \   is an array of two unsigned integers.  The first is a POSIX \"time_t\"\n \
    \  [posix-time].  Consumers of C-DNS should be aware of this, as it\n   excludes\
    \ leap seconds and therefore may cause minor anomalies in the\n   data, e.g.,\
    \ when calculating Query throughput.\n"
- title: 12.  IANA Considerations
  contents:
  - "12.  IANA Considerations\n   IANA has created a registry \"C-DNS DNS Capture\
    \ Format\" containing the\n   subregistries defined in Sections 12.1 to 12.4 inclusive.\n\
    \   In all cases, new entries may be added to the subregistries by Expert\n  \
    \ Review as defined in [RFC8126].  Experts are expected to exercise\n   their\
    \ own expert judgment and should consider the following general\n   guidelines\
    \ in addition to any provided guidelines that are particular\n   to a subregistry.\n\
    \   o  There should be a real and compelling use for any new value.\n   o  Values\
    \ assigned should be carefully chosen to minimize storage\n      requirements\
    \ for common cases.\n"
- title: 12.1.  Transport Types
  contents:
  - "12.1.  Transport Types\n   IANA has created a registry \"C-DNS Transports\" of\
    \ C-DNS transport\n   type identifiers.  The primary purpose of this registry\
    \ is to provide\n   unique identifiers for all transports used for DNS Queries.\n\
    \   The following note is included in this registry: \"In version 1.0 of\n   C-DNS\
    \ [RFC8618], there is a field to identify the type of DNS\n   transport.  This\
    \ field is 4 bits in size.\"\n   The initial contents of the registry are as follows.\
    \  See\n   Sections 7.3.2.3.2, 7.3.2.3.5, and 7.3.2.5 of this document:\n    \
    \        +------------+------------------------+-----------+\n            | Identifier\
    \ | Name                   | Reference |\n            +------------+------------------------+-----------+\n\
    \            |     0      | UDP                    | RFC 8618  |\n           \
    \ |     1      | TCP                    | RFC 8618  |\n            |     2   \
    \   | TLS                    | RFC 8618  |\n            |     3      | DTLS  \
    \                 | RFC 8618  |\n            |     4      | HTTPS            \
    \      | RFC 8618  |\n            |    5-14    | Unassigned             |    \
    \       |\n            |     15     | Non-standard transport | RFC 8618  |\n \
    \           +------------+------------------------+-----------+\n   Expert reviewers\
    \ should take the following point into consideration:\n   Is the requested DNS\
    \ transport described by a Standards Track RFC?\n"
- title: 12.2.  Data Storage Flags
  contents:
  - "12.2.  Data Storage Flags\n   IANA has created a registry \"C-DNS Storage Flags\"\
    \ of C-DNS data\n   storage flags.  The primary purpose of this registry is to\
    \ provide\n   indicators giving hints on processing of the data stored.\n   The\
    \ following note is included in this registry: \"In version 1.0 of\n   C-DNS [RFC8618],\
    \ there is a field describing attributes of the data\n   recorded.  The field\
    \ is a CBOR [RFC7049] unsigned integer holding bit\n   flags.\"\n   The initial\
    \ contents of the registry are as follows.  See\n   Section 7.3.1.1.1 of this\
    \ document:\n   +------+------------------+-----------------------------+-----------+\n\
    \   | Bit  | Name             | Description                 | Reference |\n  \
    \ +------+------------------+-----------------------------+-----------+\n   |\
    \  0   | anonymized-data  | The data has been           | RFC 8618  |\n   |  \
    \    |                  | anonymized.                 |           |\n   |    \
    \  |                  |                             |           |\n   |  1   |\
    \ sampled-data     | The data is sampled data.   | RFC 8618  |\n   |      |  \
    \                |                             |           |\n   |  2   | normalized-names\
    \ | Names in the data have been | RFC 8618  |\n   |      |                  |\
    \ normalized.                 |           |\n   |      |                  |  \
    \                           |           |\n   | 3-63 | Unassigned       |    \
    \                         |           |\n   +------+------------------+-----------------------------+-----------+\n"
- title: 12.3.  Response-Processing Flags
  contents:
  - "12.3.  Response-Processing Flags\n   IANA has created a registry \"C-DNS Response\
    \ Flags\" of C-DNS response-\n   processing flags.  The primary purpose of this\
    \ registry is to provide\n   indicators giving hints on the generation of a particular\
    \ Response.\n   The following note is included in this registry: \"In version\
    \ 1.0 of\n   C-DNS [RFC8618], there is a field describing attributes of the\n\
    \   Responses recorded.  The field is a CBOR [RFC7049] unsigned integer\n   holding\
    \ bit flags.\"\n   The initial contents of the registry are as follows.  See\n\
    \   Section 7.3.2.4.1 of this document:\n     +------+------------+-------------------------------+-----------+\n\
    \     | Bit  | Name       | Description                   | Reference |\n    \
    \ +------+------------+-------------------------------+-----------+\n     |  0\
    \   | from-cache | The Response came from cache. | RFC 8618  |\n     | 1-63 |\
    \ Unassigned |                               |           |\n     +------+------------+-------------------------------+-----------+\n"
- title: 12.4.  AddressEvent Types
  contents:
  - "12.4.  AddressEvent Types\n   IANA has created a registry \"C-DNS Address Event\
    \ Types\" of C-DNS\n   AddressEvent types.  The primary purpose of this registry\
    \ is to\n   provide unique identifiers of different types of C-DNS address events\n\
    \   and so specify the contents of the optional companion field \"ae-code\"\n\
    \   for each type.\n   The following note is included in this registry: \"In version\
    \ 1.0 of\n   C-DNS [RFC8618], there is a field identifying types of the events\n\
    \   related to client addresses.  This field is a CBOR [RFC7049] unsigned\n  \
    \ integer.  There is a related optional field \"ae-code\", which, if\n   present,\
    \ holds an additional CBOR unsigned integer giving additional\n   information\
    \ specific to the event type.\"\n   The initial contents of the registry are as\
    \ follows.  See\n   Section 7.3.2.5 of this document:\n   +------------------------+---------------+--------------+-----------+\n\
    \   |       Identifier       | Event Type    | ae-code      | Reference |\n  \
    \ |                        |               | Contents     |           |\n   +------------------------+---------------+--------------+-----------+\n\
    \   |           0            | TCP reset     | None         | RFC 8618  |\n  \
    \ |                        |               |              |           |\n   |\
    \           1            | ICMP time     | ICMP code    | RFC 8618  |\n   |  \
    \                      | exceeded      | [icmpcodes]  |           |\n   |    \
    \                    |               |              |           |\n   |      \
    \     2            | ICMP          | ICMP code    | RFC 8618  |\n   |        \
    \                | destination   | [icmpcodes]  |           |\n   |          \
    \              | unreachable   |              |           |\n   |            \
    \            |               |              |           |\n   |           3  \
    \          | ICMPv6 time   | ICMPv6 code  | RFC 8618  |\n   |                \
    \        | exceeded      | [icmp6codes] |           |\n   |                  \
    \      |               |              |           |\n   |           4        \
    \    | ICMPv6        | ICMPv6 code  | RFC 8618  |\n   |                      \
    \  | destination   | [icmp6codes] |           |\n   |                        |\
    \ unreachable   |              |           |\n   |                        |  \
    \             |              |           |\n   |           5            | ICMPv6\
    \ packet | ICMPv6 code  | RFC 8618  |\n   |                        | too big \
    \      | [icmp6codes] |           |\n   |                        |           \
    \    |              |           |\n   | 6-18446744073709551615 | Unassigned  \
    \  |              |           |\n   +------------------------+---------------+--------------+-----------+\n\
    \   Expert reviewers should take the following point into consideration:\n   \"\
    ae-code\" contents must be defined for a type or, if not appropriate,\n   specified\
    \ as \"None\".  A specification of \"None\" requires less storage\n   and is therefore\
    \ preferred.\n"
- title: 13.  Security Considerations
  contents:
  - "13.  Security Considerations\n   Any control interface MUST perform authentication\
    \ and encryption.\n   Any data upload MUST be authenticated and encrypted.\n"
- title: 14.  Privacy Considerations
  contents:
  - "14.  Privacy Considerations\n   Storage of DNS traffic by operators in PCAP and\
    \ other formats is a\n   long-standing and widespread practice.  Section 2.5 of\n\
    \   [DNS-Priv-Cons] provides an analysis of the risks to Internet users\n   regarding\
    \ the storage of DNS traffic data in servers (recursive\n   resolvers, authoritative\
    \ servers, and rogue servers).\n   Section 5.2 of [DNS-Priv-Svc] describes mitigations\
    \ for those risks\n   for data stored on recursive resolvers (but that could by\
    \ extension\n   apply to authoritative servers).  These include data-handling\n\
    \   practices and methods for data minimization, IP address\n   pseudonymization,\
    \ and anonymization.  Appendix C of [DNS-Priv-Svc]\n   presents an analysis of\
    \ seven published anonymization processes.  In\n   addition, the ICANN Root Server\
    \ System Advisory Committee (RSSAC)\n   have recently published [RSSAC04] (\"\
    Recommendations on Anonymization\n   Processes for Source IP Addresses Submitted\
    \ for Future Analysis\").\n   The above analyses consider full data capture (e.g.,\
    \ using PCAP) as a\n   baseline for privacy considerations; therefore, this format\n\
    \   specification introduces no new user privacy issues beyond those of\n   full\
    \ data capture (which are quite severe).  It does provide\n   mechanisms to selectively\
    \ record only certain fields at the time of\n   data capture, to improve user\
    \ privacy and to explicitly indicate that\n   data is sampled, anonymized, or\
    \ both.  It also provides flags to\n   indicate if data normalization has been\
    \ performed; data normalization\n   increases user privacy by reducing the potential\
    \ for fingerprinting\n   individuals.  However, a trade-off is the potential reduction\
    \ of the\n   capacity to identify attack traffic via Query name signatures.\n\
    \   Operators should carefully consider their operational requirements\n   and\
    \ privacy policies and SHOULD capture at the source the minimum\n   user data\
    \ required to meet their needs.\n"
- title: 15.  References
  contents:
  - '15.  References

    '
- title: 15.1.  Normative References
  contents:
  - "15.1.  Normative References\n   [pcap-filter]\n              tcpdump.org, \"\
    Manpage of PCAP-FILTER\", November 2017,\n              <https://www.tcpdump.org/manpages/pcap-filter.7.html>.\n\
    \   [pcap-options]\n              tcpdump.org, \"Manpage of PCAP\", July 2018,\n\
    \              <https://www.tcpdump.org/manpages/pcap.3pcap.html>.\n   [posix-time]\n\
    \              The Open Group, \"IEEE Standard for Information\n             \
    \ Technology--Portable Operating System Interface (POSIX(R))\n              Base\
    \ Specifications, Issue 7\", IEEE Standard 1003.1-2017,\n              Section\
    \ 4.16, DOI 10.1109/IEEESTD.2018.8277153.\n   [RFC792]   Postel, J., \"Internet\
    \ Control Message Protocol\", STD 5,\n              RFC 792, DOI 10.17487/RFC0792,\
    \ September 1981,\n              <https://www.rfc-editor.org/info/rfc792>.\n \
    \  [RFC1035]  Mockapetris, P., \"Domain names - implementation and\n         \
    \     specification\", STD 13, RFC 1035, DOI 10.17487/RFC1035,\n             \
    \ November 1987, <https://www.rfc-editor.org/info/rfc1035>.\n   [RFC2119]  Bradner,\
    \ S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\"\
    , BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n       \
    \       <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC3986]  Berners-Lee,\
    \ T., Fielding, R., and L. Masinter, \"Uniform\n              Resource Identifier\
    \ (URI): Generic Syntax\", STD 66,\n              RFC 3986, DOI 10.17487/RFC3986,\
    \ January 2005,\n              <https://www.rfc-editor.org/info/rfc3986>.\n  \
    \ [RFC4443]  Conta, A., Deering, S., and M. Gupta, Ed., \"Internet\n         \
    \     Control Message Protocol (ICMPv6) for the Internet\n              Protocol\
    \ Version 6 (IPv6) Specification\", STD 89,\n              RFC 4443, DOI 10.17487/RFC4443,\
    \ March 2006,\n              <https://www.rfc-editor.org/info/rfc4443>.\n   [RFC6891]\
    \  Damas, J., Graff, M., and P. Vixie, \"Extension Mechanisms\n              for\
    \ DNS (EDNS(0))\", STD 75, RFC 6891,\n              DOI 10.17487/RFC6891, April\
    \ 2013,\n              <https://www.rfc-editor.org/info/rfc6891>.\n   [RFC7049]\
    \  Bormann, C. and P. Hoffman, \"Concise Binary Object\n              Representation\
    \ (CBOR)\", RFC 7049, DOI 10.17487/RFC7049,\n              October 2013, <https://www.rfc-editor.org/info/rfc7049>.\n\
    \   [RFC7858]  Hu, Z., Zhu, L., Heidemann, J., Mankin, A., Wessels, D.,\n    \
    \          and P. Hoffman, \"Specification for DNS over Transport\n          \
    \    Layer Security (TLS)\", RFC 7858, DOI 10.17487/RFC7858,\n              May\
    \ 2016, <https://www.rfc-editor.org/info/rfc7858>.\n   [RFC8094]  Reddy, T., Wing,\
    \ D., and P. Patil, \"DNS over Datagram\n              Transport Layer Security\
    \ (DTLS)\", RFC 8094,\n              DOI 10.17487/RFC8094, February 2017,\n  \
    \            <https://www.rfc-editor.org/info/rfc8094>.\n   [RFC8126]  Cotton,\
    \ M., Leiba, B., and T. Narten, \"Guidelines for\n              Writing an IANA\
    \ Considerations Section in RFCs\", BCP 26,\n              RFC 8126, DOI 10.17487/RFC8126,\
    \ June 2017,\n              <https://www.rfc-editor.org/info/rfc8126>.\n   [RFC8174]\
    \  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in\n              RFC 2119\
    \ Key Words\", BCP 14, RFC 8174,\n              DOI 10.17487/RFC8174, May 2017,\n\
    \              <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8484]  Hoffman,\
    \ P. and P. McManus, \"DNS Queries over HTTPS\n              (DoH)\", RFC 8484,\
    \ DOI 10.17487/RFC8484, October 2018,\n              <https://www.rfc-editor.org/info/rfc8484>.\n\
    \   [RFC8610]  Birkholz, H., Vigano, C., and C. Bormann, \"Concise Data\n    \
    \          Definition Language (CDDL): A Notational Convention to\n          \
    \    Express Concise Binary Object Representation (CBOR) and\n              JSON\
    \ Data Structures\", RFC 8610, DOI 10.17487/RFC8610,\n              June 2019,\
    \ <https://www.rfc-editor.org/info/rfc8610>.\n"
- title: 15.2.  Informative References
  contents:
  - "15.2.  Informative References\n   [Avro]     The Apache Software Foundation,\
    \ \"Apache Avro(TM)\", 2019,\n              <https://avro.apache.org/>.\n   [ditl]\
    \     DNS-OARC, \"DITL\", 2018,\n              <https://www.dns-oarc.net/oarc/data/ditl>.\n\
    \   [DNS-Priv-Cons]\n              Bortzmeyer, S. and S. Dickinson, \"DNS Privacy\n\
    \              Considerations\", Work in Progress,\n              draft-ietf-dprive-rfc7626-bis-00,\
    \ July 2019.\n   [DNS-Priv-Svc]\n              Dickinson, S., Overeinder, B.,\
    \ van Rijswijk-Deij, R., and\n              A. Mankin, \"Recommendations for DNS\
    \ Privacy Service\n              Operators\", Work in Progress, draft-ietf-dprive-bcp-op-03,\n\
    \              July 2019.\n   [dnscap]   DNS-OARC, \"DNSCAP\", 2018,\n       \
    \       <https://www.dns-oarc.net/tools/dnscap>.\n   [dnstap]   \"dnstap\", 2016,\
    \ <https://dnstap.info/>.\n   [dnstap-schema]\n              \"dnstap schema\"\
    , commit d860ec1, November 2016,\n              <https://github.com/dnstap/dnstap.pb/blob/master/\n\
    \              dnstap.proto>.\n   [dnsxml]   Daley, J., Ed., Morris, S., and J.\
    \ Dickinson, \"dnsxml - A\n              standard XML representation of DNS data\"\
    , Work in\n              Progress, draft-daley-dnsxml-00, July 2013.\n   [dsc]\
    \      Wessels, D. and J. Lundstrom, \"DSC\", 2016,\n              <https://www.dns-oarc.net/tools/dsc>.\n\
    \   [gzip]     \"gzip\", <https://www.gzip.org/>.\n   [icmp6codes]\n         \
    \     IANA, \"ICMPv6 \"Code\" Fields\",\n              <https://www.iana.org/assignments/icmpv6-parameters/>.\n\
    \   [icmpcodes]\n              IANA, \"Code Fields\",\n              <https://www.iana.org/assignments/icmp-parameters/>.\n\
    \   [IEEE802.1Q]\n              IEEE, \"IEEE Standard for Local and Metropolitan\
    \ Area\n              Networks--Bridges and Bridged Networks\", IEEE\n       \
    \       Standard 802.1Q.\n   [Knot]     \"Knot DNS\", <https://www.knot-dns.cz/>.\n\
    \   [lz4]      \"LZ4\", <https://lz4.github.io/lz4/>.\n   [mmark]    Gieben, M.,\
    \ \"mmark\", commit de69698, May 2019,\n              <https://github.com/mmarkdown/mmark>.\n\
    \   [NSD]      NLnet Labs, \"NSD\", 2019,\n              <https://www.nlnetlabs.nl/projects/nsd/about/>.\n\
    \   [opcodes]  IANA, \"DNS OpCodes\",\n              <https://www.iana.org/assignments/dns-parameters/>.\n\
    \   [packetq]  .SE - The Internet Infrastructure Foundation, \"PacketQ\",\n  \
    \            commit c9b2e89, February 2019,\n              <https://github.com/DNS-OARC/PacketQ>.\n\
    \   [pcap]     \"PCAP\", 2019, <https://www.tcpdump.org/>.\n   [pcapng]   \"pcapng:\
    \ PCAP next generation file format specification\",\n              commit 3c35b6a,\
    \ March 2019,\n              <https://github.com/pcapng/pcapng>.\n   [Protocol-Buffers]\n\
    \              Google LLC, \"Protocol Buffers\",\n              <https://developers.google.com/protocol-buffers/>.\n\
    \   [rcodes]   IANA, \"DNS RCODEs\",\n              <https://www.iana.org/assignments/dns-parameters/>.\n\
    \   [RFC5077]  Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig,\n       \
    \       \"Transport Layer Security (TLS) Session Resumption without\n        \
    \      Server-Side State\", RFC 5077, DOI 10.17487/RFC5077,\n              January\
    \ 2008, <https://www.rfc-editor.org/info/rfc5077>.\n   [RFC7413]  Cheng, Y., Chu,\
    \ J., Radhakrishnan, S., and A. Jain, \"TCP\n              Fast Open\", RFC 7413,\
    \ DOI 10.17487/RFC7413, December 2014,\n              <https://www.rfc-editor.org/info/rfc7413>.\n\
    \   [RFC8259]  Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data\n \
    \             Interchange Format\", STD 90, RFC 8259,\n              DOI 10.17487/RFC8259,\
    \ December 2017,\n              <https://www.rfc-editor.org/info/rfc8259>.\n \
    \  [RFC8427]  Hoffman, P., \"Representing DNS Messages in JSON\",\n          \
    \    RFC 8427, DOI 10.17487/RFC8427, July 2018,\n              <https://www.rfc-editor.org/info/rfc8427>.\n\
    \   [rrclasses]\n              IANA, \"DNS CLASSes\",\n              <https://www.iana.org/assignments/dns-parameters/>.\n\
    \   [rrtypes]  IANA, \"Resource Record (RR) TYPEs\",\n              <https://www.iana.org/assignments/dns-parameters/>.\n\
    \   [RSSAC04]  ICANN, \"Recommendations on Anonymization Processes for\n     \
    \         Source IP Addresses Submitted for Future Analysis\",\n             \
    \ August 2018, <https://www.icann.org/en/system/files/files/\n              rssac-040-07aug18-en.pdf>.\n\
    \   [snappy]   \"snappy\", <https://google.github.io/snappy/>.\n   [snzip]   \
    \ \"Snzip, a compression/decompression tool based on snappy\",\n             \
    \ commit 809c6f2, October 2018,\n              <https://github.com/kubo/snzip>.\n\
    \   [xz]       \"XZ Utils\", <https://tukaani.org/xz/>.\n   [zstd]     \"Zstandard\
    \ - Real-time data compression algorithm\",\n              <https://facebook.github.io/zstd/>.\n"
- title: Appendix A.  CDDL
  contents:
  - "Appendix A.  CDDL\n   This appendix gives a CDDL [RFC8610] specification for\
    \ C-DNS.\n   CDDL does not permit a range of allowed values to be specified for\
    \ a\n   bitfield.  Where necessary, those values are given as a CDDL group,\n\
    \   but the group definition is commented out to prevent CDDL tooling\n   from\
    \ warning that the group is unused.\n   ; CDDL specification of the file format\
    \ for C-DNS,\n   ; which describes a collection of DNS messages and\n   ; traffic\
    \ metadata.\n   ;\n   ; The overall structure of a file.\n   ;\n   File = [\n\
    \       file-type-id  : \"C-DNS\",\n       file-preamble : FilePreamble,\n   \
    \    file-blocks   : [* Block],\n   ]\n   ;\n   ; The File Preamble.\n   ;\n \
    \  FilePreamble = {\n       major-format-version => 1,\n       minor-format-version\
    \ => 0,\n       ? private-version    => uint,\n       block-parameters     =>\
    \ [+ BlockParameters],\n   }\n   major-format-version = 0\n   minor-format-version\
    \ = 1\n   private-version      = 2\n   block-parameters     = 3\n   BlockParameters\
    \ = {\n       storage-parameters      => StorageParameters,\n       ? collection-parameters\
    \ => CollectionParameters,\n   }\n   storage-parameters    = 0\n   collection-parameters\
    \ = 1\n     IPv6PrefixLength = 1..128\n     IPv4PrefixLength = 1..32\n     OpcodeRange\
    \ = 0..15\n     RRTypeRange = 0..65535\n     StorageParameters = {\n         ticks-per-second\
    \             => uint,\n         max-block-items              => uint,\n     \
    \    storage-hints                => StorageHints,\n         opcodes         \
    \             => [+ OpcodeRange],\n         rr-types                     => [+\
    \ RRTypeRange],\n         ? storage-flags              => StorageFlags,\n    \
    \     ? client-address-prefix-ipv4 => IPv4PrefixLength,\n         ? client-address-prefix-ipv6\
    \ => IPv6PrefixLength,\n         ? server-address-prefix-ipv4 => IPv4PrefixLength,\n\
    \         ? server-address-prefix-ipv6 => IPv6PrefixLength,\n         ? sampling-method\
    \            => tstr,\n         ? anonymization-method       => tstr,\n     }\n\
    \     ticks-per-second           = 0\n     max-block-items            = 1\n  \
    \   storage-hints              = 2\n     opcodes                    = 3\n    \
    \ rr-types                   = 4\n     storage-flags              = 5\n     client-address-prefix-ipv4\
    \ = 6\n     client-address-prefix-ipv6 = 7\n     server-address-prefix-ipv4 =\
    \ 8\n     server-address-prefix-ipv6 = 9\n     sampling-method            = 10\n\
    \     anonymization-method       = 11\n       ; A hint indicates whether the collection\
    \ method will always omit\n       ; the item from the file.\n       StorageHints\
    \ = {\n           query-response-hints           => QueryResponseHints,\n    \
    \       query-response-signature-hints =>\n               QueryResponseSignatureHints,\n\
    \           rr-hints                       => RRHints,\n           other-data-hints\
    \               => OtherDataHints,\n       }\n       query-response-hints    \
    \       = 0\n       query-response-signature-hints = 1\n       rr-hints      \
    \                 = 2\n       other-data-hints               = 3\n         QueryResponseHintValues\
    \ = &(\n             time-offset                  : 0,\n             client-address-index\
    \         : 1,\n             client-port                  : 2,\n             transaction-id\
    \               : 3,\n             qr-signature-index           : 4,\n       \
    \      client-hoplimit              : 5,\n             response-delay        \
    \       : 6,\n             query-name-index             : 7,\n             query-size\
    \                   : 8,\n             response-size                : 9,\n   \
    \          response-processing-data     : 10,\n             query-question-sections\
    \      : 11,    ; Second & subsequent\n                                      \
    \             ; Questions\n             query-answer-sections        : 12,\n \
    \            query-authority-sections     : 13,\n             query-additional-sections\
    \    : 14,\n             response-answer-sections     : 15,\n             response-authority-sections\
    \  : 16,\n             response-additional-sections : 17,\n         )\n      \
    \   QueryResponseHints = uint .bits QueryResponseHintValues\n         QueryResponseSignatureHintValues\
    \ = &(\n             server-address-index  : 0,\n             server-port    \
    \       : 1,\n             qr-transport-flags    : 2,\n             qr-type  \
    \             : 3,\n             qr-sig-flags          : 4,\n             query-opcode\
    \          : 5,\n             qr-dns-flags          : 6,\n             query-rcode\
    \           : 7,\n             query-classtype-index : 8,\n             query-qdcount\
    \         : 9,\n             query-ancount         : 10,\n             query-nscount\
    \         : 11,\n             query-arcount         : 12,\n             query-edns-version\
    \    : 13,\n             query-udp-size        : 14,\n             query-opt-rdata-index\
    \ : 15,\n             response-rcode        : 16,\n         )\n         QueryResponseSignatureHints\
    \ =\n             uint .bits QueryResponseSignatureHintValues\n         RRHintValues\
    \ = &(\n             ttl         : 0,\n             rdata-index : 1,\n       \
    \  )\n         RRHints = uint .bits RRHintValues\n         OtherDataHintValues\
    \ = &(\n             malformed-messages   : 0,\n             address-event-counts\
    \ : 1,\n         )\n         OtherDataHints = uint .bits OtherDataHintValues\n\
    \       StorageFlagValues = &(\n           anonymized-data      : 0,\n       \
    \    sampled-data         : 1,\n           normalized-names     : 2,\n       )\n\
    \       StorageFlags = uint .bits StorageFlagValues\n    ; Metadata about data\
    \ collection\n    VLANIdRange = 1..4094\n    CollectionParameters = {\n      \
    \   ? query-timeout      => uint,             ; Milliseconds\n         ? skew-timeout\
    \       => uint,             ; Microseconds\n         ? snaplen            =>\
    \ uint,\n         ? promisc            => bool,\n         ? interfaces       \
    \  => [+ tstr],\n         ? server-addresses   => [+ IPAddress],\n         ? vlan-ids\
    \           => [+ VLANIdRange],\n         ? filter             => tstr,\n    \
    \     ? generator-id       => tstr,\n         ? host-id            => tstr,\n\
    \     }\n     query-timeout      = 0\n     skew-timeout       = 1\n     snaplen\
    \            = 2\n     promisc            = 3\n     interfaces         = 4\n \
    \    server-addresses   = 5\n     vlan-ids           = 6\n     filter        \
    \     = 7\n     generator-id       = 8\n     host-id            = 9\n   ;\n  \
    \ ; Data in the file is stored in Blocks.\n   ;\n   Block = {\n       block-preamble\
    \          => BlockPreamble,\n       ? block-statistics      => BlockStatistics,\
    \ ; Much of this\n                                                   ; could be\
    \ derived\n       ? block-tables          => BlockTables,\n       ? query-responses\
    \       => [+ QueryResponse],\n       ? address-event-counts  => [+ AddressEventCount],\n\
    \       ? malformed-messages    => [+ MalformedMessage],\n   }\n   block-preamble\
    \        = 0\n   block-statistics      = 1\n   block-tables          = 2\n   query-responses\
    \       = 3\n   address-event-counts  = 4\n   malformed-messages    = 5\n   ;\n\
    \   ; The (mandatory) preamble to a Block.\n   ;\n   BlockPreamble = {\n     \
    \  ? earliest-time          => Timestamp,\n       ? block-parameters-index =>\
    \ uint .default 0,\n   }\n   earliest-time          = 0\n   block-parameters-index\
    \ = 1\n   ; Ticks are sub-second intervals.  The number of ticks in a second is\n\
    \   ; file/block metadata.  Signed and unsigned tick types are defined.\n   ticks\
    \ = int\n   uticks = uint\n   Timestamp = [\n       timestamp-secs   : uint, \
    \     ; POSIX time\n       timestamp-ticks  : uticks,\n   ]\n   ;\n   ; Statistics\
    \ about the Block contents.\n   ;\n   BlockStatistics = {\n       ? processed-messages\
    \  => uint,\n       ? qr-data-items       => uint,\n       ? unmatched-queries\
    \   => uint,\n       ? unmatched-responses => uint,\n       ? discarded-opcode\
    \    => uint,\n       ? malformed-items     => uint,\n   }\n   processed-messages\
    \  = 0\n   qr-data-items       = 1\n   unmatched-queries   = 2\n   unmatched-responses\
    \ = 3\n   discarded-opcode    = 4\n   malformed-items     = 5\n   ;\n   ; Tables\
    \ of common data referenced from records in a Block.\n   ;\n   BlockTables = {\n\
    \       ? ip-address             => [+ IPAddress],\n       ? classtype       \
    \       => [+ ClassType],\n       ? name-rdata             => [+ bstr],    ; Holds\
    \ both names\n                                                ; and RDATA\n  \
    \     ? qr-sig                 => [+ QueryResponseSignature],\n       ? QuestionTables,\n\
    \       ? RRTables,\n       ? malformed-message-data => [+ MalformedMessageData],\n\
    \   }\n   ip-address             = 0\n   classtype              = 1\n   name-rdata\
    \             = 2\n   qr-sig                 = 3\n   qlist                  =\
    \ 4\n   qrr                    = 5\n   rrlist                 = 6\n   rr     \
    \                = 7\n   malformed-message-data = 8\n   IPv4Address = bstr .size\
    \ (0..4)\n   IPv6Address = bstr .size (0..16)\n   IPAddress = IPv4Address / IPv6Address\n\
    \   ClassType = {\n       type  => uint,\n       class => uint,\n   }\n   type\
    \  = 0\n   class = 1\n   QueryResponseSignature = {\n       ? server-address-index\
    \  => uint,\n       ? server-port           => uint,\n       ? qr-transport-flags\
    \    => QueryResponseTransportFlags,\n       ? qr-type               => QueryResponseType,\n\
    \       ? qr-sig-flags          => QueryResponseFlags,\n       ? query-opcode\
    \          => uint,\n       ? qr-dns-flags          => DNSFlags,\n       ? query-rcode\
    \           => uint,\n       ? query-classtype-index => uint,\n       ? query-qdcount\
    \         => uint,\n       ? query-ancount         => uint,\n       ? query-nscount\
    \         => uint,\n       ? query-arcount         => uint,\n       ? query-edns-version\
    \    => uint,\n       ? query-udp-size        => uint,\n       ? query-opt-rdata-index\
    \ => uint,\n       ? response-rcode        => uint,\n   }\n   server-address-index\
    \  = 0\n   server-port           = 1\n   qr-transport-flags    = 2\n   qr-type\
    \               = 3\n   qr-sig-flags          = 4\n   query-opcode          =\
    \ 5\n   qr-dns-flags          = 6\n   query-rcode           = 7\n   query-classtype-index\
    \ = 8\n   query-qdcount         = 9\n   query-ancount         = 10\n   query-nscount\
    \         = 11\n   query-arcount         = 12\n   query-edns-version    = 13\n\
    \   query-udp-size        = 14\n   query-opt-rdata-index = 15\n   response-rcode\
    \        = 16\n     ; Transport gives the values that may appear in bits 1..4\
    \ of\n     ; TransportFlags.  There is currently no way to express this in\n \
    \    ; CDDL, so Transport is unused.  To avoid confusion when used\n     ; with\
    \ CDDL tools, it is commented out.\n     ;\n     ; Transport = &(\n     ;    \
    \ udp               : 0,\n     ;     tcp               : 1,\n     ;     tls  \
    \             : 2,\n     ;     dtls              : 3,\n     ;     https      \
    \       : 4,\n     ;     non-standard      : 15,\n     ; )\n     TransportFlagValues\
    \ = &(\n         ip-version         : 0,     ; 0=IPv4, 1=IPv6\n     ) / (1..4)\n\
    \     TransportFlags = uint .bits TransportFlagValues\n     QueryResponseTransportFlagValues\
    \ = &(\n         query-trailingdata : 5,\n     ) / TransportFlagValues\n     QueryResponseTransportFlags\
    \ =\n         uint .bits QueryResponseTransportFlagValues\n     QueryResponseType\
    \ = &(\n         stub      : 0,\n         client    : 1,\n         resolver  :\
    \ 2,\n         auth      : 3,\n         forwarder : 4,\n         tool      : 5,\n\
    \     )\n     QueryResponseFlagValues = &(\n         has-query               :\
    \ 0,\n         has-response            : 1,\n         query-has-opt          \
    \ : 2,\n         response-has-opt        : 3,\n         query-has-no-question\
    \   : 4,\n         response-has-no-question: 5,\n     )\n     QueryResponseFlags\
    \ = uint .bits QueryResponseFlagValues\n     DNSFlagValues = &(\n         query-cd\
    \   : 0,\n         query-ad   : 1,\n         query-z    : 2,\n         query-ra\
    \   : 3,\n         query-rd   : 4,\n         query-tc   : 5,\n         query-aa\
    \   : 6,\n         query-do   : 7,\n         response-cd: 8,\n         response-ad:\
    \ 9,\n         response-z : 10,\n         response-ra: 11,\n         response-rd:\
    \ 12,\n         response-tc: 13,\n         response-aa: 14,\n     )\n     DNSFlags\
    \ = uint .bits DNSFlagValues\n   QuestionTables = (\n       qlist => [+ QuestionList],\n\
    \       qrr   => [+ Question]\n   )\n     QuestionList = [+ uint]           ;\
    \ Index of Question\n     Question = {                      ; Second and subsequent\
    \ Questions\n         name-index      => uint,      ; Index to a name in the\n\
    \                                       ; name-rdata table\n         classtype-index\
    \ => uint,\n     }\n     name-index      = 0\n     classtype-index = 1\n   RRTables\
    \ = (\n       rrlist => [+ RRList],\n       rr     => [+ RR]\n   )\n     RRList\
    \ = [+ uint]                     ; Index of RR\n     RR = {\n         name-index\
    \      => uint,          ; Index to a name in the\n                          \
    \                 ; name-rdata table\n         classtype-index => uint,\n    \
    \     ? ttl           => uint,\n         ? rdata-index   => uint,          ; Index\
    \ to RDATA in the\n                                           ; name-rdata table\n\
    \     }\n     ; Other map key values already defined above.\n     ttl        \
    \ = 2\n     rdata-index = 3\n   MalformedMessageData = {\n       ? server-address-index\
    \   => uint,\n       ? server-port            => uint,\n       ? mm-transport-flags\
    \     => TransportFlags,\n       ? mm-payload             => bstr,\n   }\n   ;\
    \ Other map key values already defined above.\n   mm-transport-flags      = 2\n\
    \   mm-payload              = 3\n   ;\n   ; A single Query/Response data item.\n\
    \   ;\n   QueryResponse = {\n       ? time-offset              => uticks,    \
    \ ; Time offset from\n                                                 ; start\
    \ of Block\n       ? client-address-index     => uint,\n       ? client-port \
    \             => uint,\n       ? transaction-id           => uint,\n       ? qr-signature-index\
    \       => uint,\n       ? client-hoplimit          => uint,\n       ? response-delay\
    \           => ticks,\n       ? query-name-index         => uint,\n       ? query-size\
    \               => uint,       ; DNS size of Query\n       ? response-size   \
    \         => uint,       ; DNS size of Response\n       ? response-processing-data\
    \ => ResponseProcessingData,\n       ? query-extended           => QueryResponseExtended,\n\
    \       ? response-extended        => QueryResponseExtended,\n   }\n   time-offset\
    \              = 0\n   client-address-index     = 1\n   client-port          \
    \    = 2\n   transaction-id           = 3\n   qr-signature-index       = 4\n \
    \  client-hoplimit          = 5\n   response-delay           = 6\n   query-name-index\
    \         = 7\n   query-size               = 8\n   response-size            =\
    \ 9\n   response-processing-data = 10\n   query-extended           = 11\n   response-extended\
    \        = 12\n   ResponseProcessingData = {\n       ? bailiwick-index  => uint,\n\
    \       ? processing-flags => ResponseProcessingFlags,\n   }\n   bailiwick-index\
    \ = 0\n   processing-flags = 1\n     ResponseProcessingFlagValues = &(\n     \
    \    from-cache : 0,\n     )\n     ResponseProcessingFlags = uint .bits ResponseProcessingFlagValues\n\
    \   QueryResponseExtended = {\n       ? question-index   => uint,       ; Index\
    \ of QuestionList\n       ? answer-index     => uint,       ; Index of RRList\n\
    \       ? authority-index  => uint,\n       ? additional-index => uint,\n   }\n\
    \   question-index   = 0\n   answer-index     = 1\n   authority-index  = 2\n \
    \  additional-index = 3\n   ;\n   ; Address event data.\n   ;\n   AddressEventCount\
    \ = {\n       ae-type              => &AddressEventType,\n       ? ae-code   \
    \         => uint,\n       ae-address-index     => uint,\n       ? ae-transport-flags\
    \ => TransportFlags,\n       ae-count             => uint,\n   }\n   ae-type \
    \           = 0\n   ae-code            = 1\n   ae-address-index   = 2\n   ae-transport-flags\
    \ = 3\n   ae-count           = 4\n   AddressEventType = (\n       tcp-reset  \
    \            : 0,\n       icmp-time-exceeded     : 1,\n       icmp-dest-unreachable\
    \  : 2,\n       icmpv6-time-exceeded   : 3,\n       icmpv6-dest-unreachable: 4,\n\
    \       icmpv6-packet-too-big  : 5,\n   )\n   ;\n   ; Malformed messages.\n  \
    \ ;\n   MalformedMessage = {\n       ? time-offset           => uticks,   ; Time\
    \ offset from\n                                            ; start of Block\n\
    \       ? client-address-index  => uint,\n       ? client-port           => uint,\n\
    \       ? message-data-index    => uint,\n   }\n   ; Other map key values already\
    \ defined above.\n   message-data-index = 3\n"
- title: Appendix B.  DNS Name Compression Example
  contents:
  - "Appendix B.  DNS Name Compression Example\n   The basic algorithm, which follows\
    \ the guidance in [RFC1035], is\n   simply to collect each name, and the offset\
    \ in the packet at which it\n   starts, during packet construction.  As each name\
    \ is added, it is\n   offered to each of the collected names in order of collection,\n\
    \   starting from the first name.  If (1) labels at the end of the name\n   can\
    \ be replaced with a reference back to part (or all) of the earlier\n   name and\
    \ (2) the uncompressed part of the name is shorter than any\n   compression already\
    \ found, the earlier name is noted as the\n   compression target for the name.\n\
    \   The following tables illustrate the step-by-step process of adding\n   names\
    \ and performing name compression.  In an example packet, the\n   first name added\
    \ is foo.example, which cannot be compressed.\n          +---+-------------+--------------+--------------------+\n\
    \          | N | Name        | Uncompressed | Compression Target |\n         \
    \ +---+-------------+--------------+--------------------+\n          | 1 | foo.example\
    \ | foo.example  | None               |\n          +---+-------------+--------------+--------------------+\n\
    \   The next name added is bar.example.  This is matched against\n   foo.example.\
    \  The example part of this can be used as a compression\n   target, with the\
    \ remaining uncompressed part of the name being bar.\n        +---+-------------+--------------+-----------------------+\n\
    \        | N | Name        | Uncompressed | Compression Target    |\n        +---+-------------+--------------+-----------------------+\n\
    \        | 1 | foo.example | foo.example  | None                  |\n        |\
    \ 2 | bar.example | bar          | 1 + offset to example |\n        +---+-------------+--------------+-----------------------+\n\
    \   The third name added is www.bar.example.  This is first matched\n   against\
    \ foo.example, and as before this is recorded as a compression\n   target, with\
    \ the remaining uncompressed part of the name being\n   www.bar.  It is then matched\
    \ against the second name, which again can\n   be a compression target.  Because\
    \ the remaining uncompressed part of\n   the name is www, this is an improved\
    \ compression, and so it is\n   adopted.\n      +---+-----------------+--------------+-----------------------+\n\
    \      | N | Name            | Uncompressed | Compression Target    |\n      +---+-----------------+--------------+-----------------------+\n\
    \      | 1 | foo.example     | foo.example  | None                  |\n      |\
    \ 2 | bar.example     | bar          | 1 + offset to example |\n      | 3 | www.bar.example\
    \ | www          | 2                     |\n      +---+-----------------+--------------+-----------------------+\n\
    \   As an optimization, if a name is already perfectly compressed (in\n   other\
    \ words, the uncompressed part of the name is empty), then no\n   further names\
    \ will be considered for compression.\n"
- title: B.1.  NSD Compression Algorithm
  contents:
  - "B.1.  NSD Compression Algorithm\n   Using the above basic algorithm, the packet\
    \ lengths of Responses\n   generated by the Name Server Daemon (NSD) [NSD] can\
    \ be matched almost\n   exactly.  At the time of writing, a tiny number (<.01%)\
    \ of the\n   reconstructed packets had incorrect lengths.\n"
- title: B.2.  Knot Authoritative Compression Algorithm
  contents:
  - "B.2.  Knot Authoritative Compression Algorithm\n   The Knot Authoritative name\
    \ server [Knot] uses different compression\n   behavior, which is the result of\
    \ internal optimization designed to\n   balance runtime speed with compression\
    \ size gains.  In brief, and\n   omitting complications, Knot Authoritative will\
    \ only consider the\n   QNAME and names in the immediately preceding RR section\
    \ in an RRSET\n   as compression targets.\n   A set of smart heuristics as described\
    \ below can be implemented to\n   mimic this, and while not perfect, it produces\
    \ output nearly, but not\n   quite, as good a match as with NSD.  The heuristics\
    \ are as follows:\n   1.  A match is only perfect if the name is completely compressed\
    \ AND\n       the TYPE of the section in which the name occurs matches the TYPE\n\
    \       of the name used as the compression target.\n   2.  If the name occurs\
    \ in RDATA:\n       *  If the compression target name is in a Query, then only\
    \ the\n          first RR in an RRSET can use that name as a compression\n   \
    \       target.\n       *  The compression target name MUST be in RDATA.\n   \
    \    *  The name section TYPE must match the compression target name\n       \
    \   section TYPE.\n       *  The compression target name MUST be in the immediately\n\
    \          preceding RR in the RRSET.\n   Using this algorithm, less than 0.1%\
    \ of the reconstructed packets had\n   incorrect lengths.\n"
- title: B.3.  Observed Differences
  contents:
  - "B.3.  Observed Differences\n   In sample traffic collected on a root name server,\
    \ around 2-4% of\n   Responses generated by Knot had different packet lengths\
    \ than those\n   produced by NSD.\n"
- title: Appendix C.  Comparison of Binary Formats
  contents:
  - "Appendix C.  Comparison of Binary Formats\n   Several binary serialization formats\
    \ were considered.  For\n   completeness, they were also compared to JSON.\n \
    \  o  Apache Avro [Avro].  Data is stored according to a predefined\n      schema.\
    \  The schema itself is always included in the data file.\n      Data can therefore\
    \ be stored untagged, for a smaller serialization\n      size, and be written\
    \ and read by an Avro library.\n      *  At the time of writing, Avro libraries\
    \ are available for C,\n         C++, C#, Java, Python, Ruby, and PHP.  Optionally,\
    \ tools are\n         available for C++, Java, and C# to generate code for encoding\n\
    \         and decoding.\n   o  Google Protocol Buffers [Protocol-Buffers].  Data\
    \ is stored\n      according to a predefined schema.  The schema is used by a\n\
    \      generator to generate code for encoding and decoding the data.\n      Data\
    \ can therefore be stored untagged, for a smaller serialization\n      size. \
    \ The schema is not stored with the data, so unlike Avro, it\n      cannot be\
    \ read with a generic library.\n      *  Code must be generated for a particular\
    \ data schema to read and\n         write data using that schema.  At the time\
    \ of writing, the\n         Google code generator can currently generate code\
    \ for encoding\n         and decoding a schema for C++, Go, Java, Python, Ruby,\
    \ C#,\n         Objective-C, JavaScript, and PHP.\n   o  CBOR [RFC7049].  This\
    \ serialization format is comparable to JSON\n      but with a binary representation.\
    \  It does not use a predefined\n      schema, so data is always stored tagged.\
    \  However, CBOR data\n      schemas can be described using CDDL [RFC8610], and\
    \ tools exist to\n      verify that data files conform to the schema.\n      *\
    \  CBOR is a simple format and is simple to implement.  At the\n         time\
    \ of writing, the CBOR website lists implementations for 16\n         languages.\n\
    \   Avro and Protocol Buffers both allow storage of untagged data, but\n   because\
    \ they rely on the data schema for this, their implementation\n   is considerably\
    \ more complex than CBOR.  Using Avro or Protocol\n   Buffers in an unsupported\
    \ environment would require notably greater\n   development effort compared to\
    \ CBOR.\n   A test program was written that reads input from a PCAP file and\n\
    \   writes output using one of two basic structures: either a simple\n   structure,\
    \ where each Query/Response pair is represented in a single\n   record entry,\
    \ or the C-DNS block structure.\n   The resulting output files were then compressed\
    \ using a variety of\n   common general-purpose lossless compression tools to\
    \ explore the\n   compressibility of the formats.  The compression tools employed\
    \ were:\n   o  snzip [snzip].  A command-line compression tool based on the\n\
    \      Google Snappy library [snappy].\n   o  lz4 [lz4].  The command-line compression\
    \ tool from the reference C\n      LZ4 implementation.\n   o  gzip [gzip].  The\
    \ ubiquitous GNU zip tool.\n   o  zstd [zstd].  Compression using the Zstandard\
    \ algorithm.\n   o  xz [xz].  A popular compression tool noted for high compression.\n\
    \   In all cases, the compression tools were run using their default\n   settings.\n\
    \   Note that this document does not mandate the use of compression, nor\n   any\
    \ particular compression scheme, but it anticipates that in\n   practice output\
    \ data will be subject to general-purpose compression,\n   and so this should\
    \ be taken into consideration.\n   \"test.pcap\", a 662 MB capture of sample data\
    \ from a root instance,\n   was used for the comparison.  The following table\
    \ shows the formatted\n   size and size after compression (abbreviated to Comp.\
    \ in the table\n   headers), together with the task Resident Set Size (RSS) and\
    \ the user\n   time taken by the compression.  File sizes are in MB, RSS is in\
    \ kB,\n   and user time is in seconds.\n   +-------------+-----------+-------+------------+-------+-----------+\n\
    \   | Format      | File Size | Comp. | Comp. Size |   RSS | User Time |\n   +-------------+-----------+-------+------------+-------+-----------+\n\
    \   | PCAP        |    661.87 | snzip |     212.48 |  2696 |      1.26 |\n   |\
    \             |           | lz4   |     181.58 |  6336 |      1.35 |\n   |   \
    \          |           | gzip  |     153.46 |  1428 |     18.20 |\n   |      \
    \       |           | zstd  |      87.07 |  3544 |      4.27 |\n   |         \
    \    |           | xz    |      49.09 | 97416 |    160.79 |\n   |            \
    \ |           |       |            |       |           |\n   | JSON simple | \
    \  4113.92 | snzip |     603.78 |  2656 |      5.72 |\n   |             |    \
    \       | lz4   |     386.42 |  5636 |      5.25 |\n   |             |       \
    \    | gzip  |     271.11 |  1492 |     73.00 |\n   |             |          \
    \ | zstd  |     133.43 |  3284 |      8.68 |\n   |             |           | xz\
    \    |      51.98 | 97412 |    600.74 |\n   |             |           |      \
    \ |            |       |           |\n   | Avro simple |    640.45 | snzip | \
    \    148.98 |  2656 |      0.90 |\n   |             |           | lz4   |    \
    \ 111.92 |  5828 |      0.99 |\n   |             |           | gzip  |     103.07\
    \ |  1540 |     11.52 |\n   |             |           | zstd  |      49.08 | \
    \ 3524 |      2.50 |\n   |             |           | xz    |      22.87 | 97308\
    \ |     90.34 |\n   |             |           |       |            |       | \
    \          |\n   | CBOR simple |    764.82 | snzip |     164.57 |  2664 |    \
    \  1.11 |\n   |             |           | lz4   |     120.98 |  5892 |      1.13\
    \ |\n   |             |           | gzip  |     110.61 |  1428 |     12.88 |\n\
    \   |             |           | zstd  |      54.14 |  3224 |      2.77 |\n   |\
    \             |           | xz    |      23.43 | 97276 |    111.48 |\n   |   \
    \          |           |       |            |       |           |\n   | PBuf simple\
    \ |    749.51 | snzip |     167.16 |  2660 |      1.08 |\n   |             | \
    \          | lz4   |     123.09 |  5824 |      1.14 |\n   |             |    \
    \       | gzip  |     112.05 |  1424 |     12.75 |\n   |             |       \
    \    | zstd  |      53.39 |  3388 |      2.76 |\n   |             |          \
    \ | xz    |      23.99 | 97348 |    106.47 |\n   |             |           | \
    \      |            |       |           |\n   | JSON block  |    519.77 | snzip\
    \ |     106.12 |  2812 |      0.93 |\n   |             |           | lz4   | \
    \    104.34 |  6080 |      0.97 |\n   |             |           | gzip  |    \
    \  57.97 |  1604 |     12.70 |\n   |             |           | zstd  |      61.51\
    \ |  3396 |      3.45 |\n   |             |           | xz    |      27.67 | 97524\
    \ |    169.10 |\n   |             |           |       |            |       | \
    \          |\n   | Avro block  |     60.45 | snzip |      48.38 |  2688 |    \
    \  0.20 |\n   |             |           | lz4   |      48.78 |  8540 |      0.22\
    \ |\n   |             |           | gzip  |      39.62 |  1576 |      2.92 |\n\
    \   |             |           | zstd  |      29.63 |  3612 |      1.25 |\n   |\
    \             |           | xz    |      18.28 | 97564 |     25.81 |\n   |   \
    \          |           |       |            |       |           |\n   | CBOR block\
    \  |     75.25 | snzip |      53.27 |  2684 |      0.24 |\n   |             |\
    \           | lz4   |      51.88 |  8008 |      0.28 |\n   |             |   \
    \        | gzip  |      41.17 |  1548 |      4.36 |\n   |             |      \
    \     | zstd  |      30.61 |  3476 |      1.48 |\n   |             |         \
    \  | xz    |      18.15 | 97556 |     38.78 |\n   |             |           |\
    \       |            |       |           |\n   | PBuf block  |     67.98 | snzip\
    \ |      51.10 |  2636 |      0.24 |\n   |             |           | lz4   | \
    \     52.39 |  8304 |      0.24 |\n   |             |           | gzip  |    \
    \  40.19 |  1520 |      3.63 |\n   |             |           | zstd  |      31.61\
    \ |  3576 |      1.40 |\n   |             |           | xz    |      17.94 | 97440\
    \ |     33.99 |\n   +-------------+-----------+-------+------------+-------+-----------+\n\
    \   The above results are discussed in the following sections.\n"
- title: C.1.  Comparison with Full PCAP Files
  contents:
  - "C.1.  Comparison with Full PCAP Files\n   An important first consideration is\
    \ whether moving away from PCAP\n   offers significant benefits.\n   The simple\
    \ binary formats are typically larger than PCAP, even though\n   they omit some\
    \ information such as Ethernet Media Access Control\n   (MAC) addresses.  But\
    \ not only do they require less CPU to compress\n   than PCAP, the resulting compressed\
    \ files are smaller than compressed\n   PCAP.\n"
- title: C.2.  Simple versus Block Coding
  contents:
  - "C.2.  Simple versus Block Coding\n   The intention of the block coding is to\
    \ perform data deduplication on\n   Query/Response records within the block. \
    \ The simple and block\n   formats shown above store exactly the same information\
    \ for each\n   Query/Response record.  This information is parsed from the DNS\n\
    \   traffic in the input PCAP file, and in all cases each field has an\n   identifier\
    \ and the field data is typed.\n   The data deduplication on the block formats\
    \ show an order-of-\n   magnitude reduction in the size of the format file size\
    \ against the\n   simple formats.  As would be expected, the compression tools\
    \ are able\n   to find and exploit a lot of this duplication, but as the\n   deduplication\
    \ process uses knowledge of DNS traffic, it is able to\n   retain a size advantage.\
    \  This advantage reduces as stronger\n   compression is applied, as again would\
    \ be expected, but even with the\n   strongest compression applied the block-formatted\
    \ data remains around\n   75% of the size of the simple format and its compression\
    \ requires\n   roughly a third of the CPU time.\n"
- title: C.3.  Binary versus Text Formats
  contents:
  - "C.3.  Binary versus Text Formats\n   Text data formats offer many advantages\
    \ over binary formats,\n   particularly in the areas of ad hoc data inspection\
    \ and extraction.\n   It was therefore felt worthwhile to carry out a direct comparison,\n\
    \   implementing JSON versions of the simple and block formats.\n   Concentrating\
    \ on JSON block format, the format files produced are a\n   significant fraction\
    \ of an order of magnitude larger than binary\n   formats.  The impact on file\
    \ size after compression is as might be\n   expected from that starting point;\
    \ the stronger compression produces\n   files that are 150% of the size of similarly\
    \ compressed binary format\n   and require over 4x more CPU to compress.\n"
- title: C.4.  Performance
  contents:
  - "C.4.  Performance\n   Concentrating again on the block formats, all three produce\
    \ format\n   files that are close to an order of magnitude smaller than the\n\
    \   original \"test.pcap\" file.  CBOR produces the largest files and Avro\n \
    \  the smallest, 20% smaller than CBOR.\n   However, once compression is taken\
    \ into account, the size difference\n   narrows.  At medium compression (with\
    \ gzip), the size difference is\n   4%.  Using strong compression (with xz), the\
    \ difference reduces to\n   2%, with Avro the largest and Protocol Buffers the\
    \ smallest, although\n   CBOR and Protocol Buffers require slightly more compression\
    \ CPU.\n   The measurements presented above do not include data on the CPU\n \
    \  required to generate the format files.  Measurements indicate that\n   writing\
    \ Avro requires 10% more CPU than CBOR or Protocol Buffers.  It\n   appears, therefore,\
    \ that Avro's advantage in compression CPU usage is\n   probably offset by a larger\
    \ CPU requirement in writing Avro.\n"
- title: C.5.  Conclusions
  contents:
  - "C.5.  Conclusions\n   The above assessments lead us to the choice of a binary\
    \ format file\n   using blocking.\n   As noted previously, this document anticipates\
    \ that output data will\n   be subject to compression.  There is no compelling\
    \ case for one\n   particular binary serialization format in terms of either final\
    \ file\n   size or machine resources consumed, so the choice must be largely\n\
    \   based on other factors.  CBOR was therefore chosen as the binary\n   serialization\
    \ format for the reasons listed in Section 5.\n"
- title: C.6.  Block Size Choice
  contents:
  - "C.6.  Block Size Choice\n   Given the choice of a CBOR format using blocking,\
    \ the question arises\n   of what an appropriate default value for the maximum\
    \ number of\n   Query/Response pairs in a block should be.  This has two components:\n\
    \   1.  What is the impact on performance of using different block sizes\n   \
    \    in the format file?\n   2.  What is the impact on the size of the format\
    \ file before and\n       after compression?\n   The following table addresses\
    \ the performance question, showing the\n   impact on the performance of a C++\
    \ program converting \"test.pcap\"\n   to C-DNS.  File sizes are in MB, RSS is\
    \ in kB, and user time is\n   in seconds.\n              +------------+-----------+--------+-----------+\n\
    \              | Block Size | File Size |    RSS | User Time |\n             \
    \ +------------+-----------+--------+-----------+\n              |      1,000\
    \ |    133.46 | 612.27 |     15.25 |\n              |      5,000 |     89.85 |\
    \ 676.82 |     14.99 |\n              |     10,000 |     76.87 | 752.40 |    \
    \ 14.53 |\n              |     20,000 |     67.86 | 750.75 |     14.49 |\n   \
    \           |     40,000 |     61.88 | 736.30 |     14.29 |\n              | \
    \    80,000 |     58.08 | 694.16 |     14.28 |\n              |    160,000 | \
    \    55.94 | 733.84 |     14.44 |\n              |    320,000 |     54.41 | 799.20\
    \ |     13.97 |\n              +------------+-----------+--------+-----------+\n\
    \   Therefore, increasing block size tends to increase maximum RSS a\n   little,\
    \ with no significant effect (if anything, a small reduction)\n   on CPU consumption.\n\
    \   The following table demonstrates the effect of increasing block size\n   on\
    \ output file size for different compressions.\n      +------------+--------+-------+-------+-------+-------+-------+\n\
    \      | Block Size |   None | snzip |   lz4 |  gzip |  zstd |    xz |\n     \
    \ +------------+--------+-------+-------+-------+-------+-------+\n      |   \
    \   1,000 | 133.46 | 90.52 | 90.03 | 74.65 | 44.78 | 25.63 |\n      |      5,000\
    \ |  89.85 | 59.69 | 59.43 | 46.99 | 37.33 | 22.34 |\n      |     10,000 |  76.87\
    \ | 50.39 | 50.28 | 38.94 | 33.62 | 21.09 |\n      |     20,000 |  67.86 | 43.91\
    \ | 43.90 | 33.24 | 32.62 | 20.16 |\n      |     40,000 |  61.88 | 39.63 | 39.69\
    \ | 29.44 | 28.72 | 19.52 |\n      |     80,000 |  58.08 | 36.93 | 37.01 | 27.05\
    \ | 26.25 | 19.00 |\n      |    160,000 |  55.94 | 35.10 | 35.06 | 25.44 | 24.56\
    \ | 19.63 |\n      |    320,000 |  54.41 | 33.87 | 33.74 | 24.36 | 23.44 | 18.66\
    \ |\n      +------------+--------+-------+-------+-------+-------+-------+\n \
    \  There is obviously scope for tuning the default block size to the\n   compression\
    \ being employed, traffic characteristics, frequency of\n   output file rollover,\
    \ etc.  Using a strong compression scheme, block\n   sizes over 10,000 Query/Response\
    \ pairs would seem to offer limited\n   improvements.\n"
- title: Appendix D.  Data Fields for Traffic Regeneration
  contents:
  - 'Appendix D.  Data Fields for Traffic Regeneration

    '
- title: D.1.  Recommended Fields for Traffic Regeneration
  contents:
  - "D.1.  Recommended Fields for Traffic Regeneration\n   This section specifies\
    \ the data fields that would need to be captured\n   in order to perform the fullest\
    \ PCAP traffic reconstruction for\n   well-formed DNS messages that is possible\
    \ with C-DNS.\n   o  All data fields in the QueryResponse type except response-\n\
    \      processing-data.\n   o  All data fields in the QueryResponseSignature type\
    \ except qr-type.\n   o  All data fields in the RR TYPE.\n"
- title: D.2.  Issues with Small Data Captures
  contents:
  - "D.2.  Issues with Small Data Captures\n   At the other extreme, an interesting\
    \ corner case arises when opting\n   to perform captures with a smaller data set\
    \ than that recommended\n   above.  The following list specifies a subset of the\
    \ above data\n   fields; if only these data fields are captured, then even a minimal\n\
    \   traffic reconstruction is problematic because there is not enough\n   information\
    \ to determine if the Query/Response data item contained\n   just a Query, just\
    \ a Response, or a Query/Response pair.\n   o  The following data fields from\
    \ the QueryResponse type:\n      *  time-offset\n      *  client-address-index\n\
    \      *  client-port\n      *  transaction-id\n      *  query-name-index\n  \
    \ o  The following data fields from the QueryResponseSignature type:\n      *\
    \  server-address-index\n      *  server-port\n      *  qr-transport-flags\n \
    \     *  query-classtype-index\n   In this case, simply also capturing the qr-sig-flags\
    \ will provide\n   enough information to perform a minimal traffic reconstruction\n\
    \   (assuming that suitable defaults for the remaining fields are\n   provided).\
    \  Additionally, capturing response-delay, query-opcode, and\n   response-rcode\
    \ will avoid having to rely on potentially misleading\n   defaults for these values\
    \ and should result in a PCAP that represents\n   the basics of the real traffic\
    \ flow.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   The authors wish to thank CZ.NIC -- in particular, Tomas\
    \ Gavenciak --\n   for many useful discussions on binary formats, compression,\
    \ and\n   packet matching.  Thanks also to Jan Vcelak and Wouter Wijngaards for\n\
    \   discussions on name compression, and Paul Hoffman for a detailed\n   review\
    \ of this document and the C-DNS CDDL.\n   Thanks also to Robert Edmonds, Jerry\
    \ Lundstrom, Richard Gibson,\n   Stephane Bortzmeyer, and many other members of\
    \ DNSOP for review.\n   Also, thanks to Miek Gieben for [mmark].\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   John Dickinson\n   Sinodun IT\n   Magdalen Centre\n  \
    \ Oxford Science Park\n   Oxford  OX4 4GA\n   United Kingdom\n   Email: jad@sinodun.com\n\
    \   Jim Hague\n   Sinodun IT\n   Magdalen Centre\n   Oxford Science Park\n   Oxford\
    \  OX4 4GA\n   United Kingdom\n   Email: jim@sinodun.com\n   Sara Dickinson\n\
    \   Sinodun IT\n   Magdalen Centre\n   Oxford Science Park\n   Oxford  OX4 4GA\n\
    \   United Kingdom\n   Email: sara@sinodun.com\n   Terry Manderson\n   ICANN\n\
    \   12025 Waterfront Drive\n   Suite 300\n   Los Angeles, CA  90094-2536\n   United\
    \ States of America\n   Email: terry.manderson@icann.org\n   John Bond\n   Wikimedia\
    \ Foundation, Inc.\n   1 Montgomery Street\n   Suite 1600\n   San Francisco, CA\
    \  94104\n   United States of America\n   Email: ietf-wikimedia@johnbond.org\n"
