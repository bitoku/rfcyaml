- contents:
  - "          Mapping YANG to Document Schema Definition Languages\n                     and
    Validating NETCONF Content\n"
  title: __initial_text__
- contents:
  - "Abstract\n   This document specifies the mapping rules for translating YANG data\n
    \  models into Document Schema Definition Languages (DSDL), a\n   coordinated
    set of XML schema languages standardized as ISO/IEC\n   19757.  The following
    DSDL schema languages are addressed by the\n   mapping: Regular Language for XML
    Next Generation (RELAX NG),\n   Schematron, and Schematron and Document Schema
    Renaming Language\n   (DSRL).  The mapping takes one or more YANG modules and
    produces a\n   set of DSDL schemas for a selected target document type -- datastore\n
    \  content, Network Configuration Protocol (NETCONF) messages, etc.\n   Procedures
    for schema-based validation of such documents are also\n   discussed.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6110.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................5\n
    \  2. Terminology and Notation ........................................6\n      2.1.
    Glossary of New Terms ......................................9\n   3. Objectives
    and Motivation ......................................10\n   4. DSDL Schema Languages
    ..........................................11\n      4.1. RELAX NG ..................................................11\n
    \     4.2. Schematron ................................................12\n      4.3.
    Document Semantics Renaming Language (DSRL) ...............13\n   5. Additional
    Annotations .........................................14\n      5.1. Dublin Core
    Metadata Elements .............................14\n      5.2. RELAX NG DTD Compatibility
    Annotations ....................14\n      5.3. NETMOD-Specific Annotations ...............................15\n
    \  6. Overview of the Mapping ........................................16\n   7.
    NETCONF Content Validation .....................................18\n   8. Design
    Considerations ..........................................19\n      8.1. Hybrid
    Schema .............................................19\n      8.2. Modularity
    ................................................22\n      8.3. Granularity ...............................................23\n
    \     8.4. Handling of XML Namespaces ................................24\n   9.
    Mapping YANG Data Models to the Hybrid Schema ..................25\n      9.1.
    Occurrence Rules for Data Nodes ...........................25\n           9.1.1.
    Optional and Mandatory Nodes .......................26\n           9.1.2. Implicit
    Nodes .....................................27\n      9.2. Mapping YANG Groupings
    and Typedefs .......................28\n           9.2.1. YANG Refinements and
    Augments ......................29\n           9.2.2. Type Derivation Chains .............................32\n
    \     9.3. Translation of XPath Expressions ..........................35\n      9.4.
    YANG Language Extensions ..................................36\n   10. Mapping
    YANG Statements to the Hybrid Schema ..................37\n      10.1. The 'anyxml'
    Statement ...................................37\n      10.2. The 'argument' Statement
    .................................38\n      10.3. The 'augment' Statement ..................................39\n
    \     10.4. The 'base' Statement .....................................39\n      10.5.
    The 'belongs-to' Statement ...............................39\n      10.6. The
    'bit' Statement ......................................39\n      10.7. The 'case'
    Statement .....................................39\n      10.8. The 'choice' Statement
    ...................................39\n      10.9. The 'config' Statement ...................................40\n
    \     10.10. The 'contact' Statement .................................40\n      10.11.
    The 'container' Statement ...............................40\n      10.12. The
    'default' Statement .................................40\n      10.13. The 'description'
    Statement .............................42\n      10.14. The 'deviation' Statement
    ...............................42\n      10.15. The 'enum' Statement ....................................42\n
    \     10.16. The 'error-app-tag' Statement ...........................42\n      10.17.
    The 'error-message' Statement ...........................42\n      10.18. The
    'extension' Statement ...............................43\n      10.19. The 'feature'
    Statement .................................43\n      10.20. The 'grouping' Statement
    ................................43\n      10.21. The 'identity' Statement ................................43\n
    \     10.22. The 'if-feature' Statement ..............................45\n      10.23.
    The 'import' Statement ..................................45\n      10.24. The
    'include' Statement .................................45\n      10.25. The 'input'
    Statement ...................................46\n      10.26. The 'key' Statement
    .....................................46\n      10.27. The 'leaf' Statement ....................................46\n
    \     10.28. The 'leaf-list' Statement ...............................46\n      10.29.
    The 'length' Statement ..................................47\n      10.30. The
    'list' Statement ....................................47\n      10.31. The 'mandatory'
    Statement ...............................48\n      10.32. The 'max-elements' Statement
    ............................49\n      10.33. The 'min-elements' Statement ............................49\n
    \     10.34. The 'module' Statement ..................................49\n      10.35.
    The 'must' Statement ....................................49\n      10.36. The
    'namespace' Statement ...............................50\n      10.37. The 'notification'
    Statement ............................50\n      10.38. The 'ordered-by' Statement
    ..............................50\n      10.39. The 'organization' Statement ............................50\n
    \     10.40. The 'output' Statement ..................................51\n      10.41.
    The 'path' Statement ....................................51\n      10.42. The
    'pattern' Statement .................................51\n      10.43. The 'position'
    Statement ................................51\n      10.44. The 'prefix' Statement
    ..................................51\n      10.45. The 'presence' Statement ................................51\n
    \     10.46. The 'range' Statement ...................................51\n      10.47.
    The 'reference' Statement ...............................51\n      10.48. The
    'require-instance' Statement ........................51\n      10.49. The 'revision'
    Statement ................................52\n      10.50. The 'rpc' Statement
    .....................................52\n      10.51. The 'status' Statement ..................................52\n
    \     10.52. The 'submodule' Statement ...............................52\n      10.53.
    The 'type' Statement ....................................53\n           10.53.1.
    The \"empty\" Type .................................54\n           10.53.2. The
    \"boolean\" Type ...............................54\n           10.53.3. The \"binary\"
    Type ................................54\n           10.53.4. The \"bits\" Type
    ..................................54\n           10.53.5. The \"enumeration\"
    and \"union\" Types ..............54\n           10.53.6. The \"identityref\"
    Type ...........................54\n           10.53.7. The \"instance-identifier\"
    Type ...................55\n           10.53.8. The \"leafref\" Type ...............................55\n
    \          10.53.9. The Numeric Types ................................55\n           10.53.10.
    The \"string\" Type ...............................57\n           10.53.11. Derived
    Types ...................................58\n      10.54. The 'typedef' Statement
    .................................59\n      10.55. The 'unique' Statement ..................................59\n
    \     10.56. The 'units' Statement ...................................60\n      10.57.
    The 'uses' Statement ....................................60\n      10.58. The
    'value' Statement ...................................60\n      10.59. The 'when'
    Statement ....................................60\n      10.60. The 'yang-version'
    Statement ............................60\n      10.61. The 'yin-element' Statement
    .............................61\n   11. Mapping the Hybrid Schema to DSDL .............................61\n
    \     11.1. Generating RELAX NG Schemas for Various Document Types ...61\n      11.2.
    Mapping Semantic Constraints to Schematron ...............62\n           11.2.1.
    Constraints on Mandatory Choice ...................65\n      11.3. Mapping Default
    Values to DSRL ...........................67\n   12. Mapping NETMOD-Specific Annotations
    to DSDL Schema Languages ..71\n      12.1. The @nma:config Annotation ...............................71\n
    \     12.2. The @nma:default Annotation ..............................71\n      12.3.
    The <nma:error-app-tag> Annotation .......................71\n      12.4. The
    <nma:error-message> Annotation .......................71\n      12.5. The @if-feature
    Annotation ...............................71\n      12.6. The @nma:implicit Annotation
    .............................72\n      12.7. The <nma:instance-identifier> Annotation
    .................72\n      12.8. The @nma:key Annotation ..................................72\n
    \     12.9. The @nma:leaf-list Annotation ............................72\n      12.10.
    The @nma:leafref Annotation .............................73\n      12.11. The
    @nma:min-elements Annotation ........................73\n      12.12. The @nma:max-elements
    Annotation ........................73\n      12.13. The <nma:must> Annotation
    ...............................73\n      12.14. The <nma:ordered-by> Annotation
    .........................74\n      12.15. The <nma:status> Annotation .............................74\n
    \     12.16. The @nma:unique Annotation ..............................74\n      12.17.
    The @nma:when Annotation ................................74\n   13. IANA Considerations
    ...........................................75\n   14. Security Considerations
    .......................................75\n   15. Contributors ..................................................75\n
    \  16. Acknowledgments ...............................................76\n   17.
    References ....................................................76\n      17.1.
    Normative References .....................................76\n      17.2. Informative
    References ...................................77\n   Appendix A. RELAX NG Schema
    for NETMOD-Specific Annotations .......79\n   Appendix B. Schema-Independent Library
    ............................84\n   Appendix C. Mapping DHCP Data Model - A Complete
    Example ..........85\n      C.1. Input YANG Module .........................................85\n
    \     C.2. Hybrid Schema .............................................88\n      C.3.
    Final DSDL Schemas  .......................................93\n           C.3.1.
    Main RELAX NG Schema for <nc:get> Reply ............93\n           C.3.2. RELAX
    NG Schema - Global Named Pattern\n                  Definitions ........................................95\n
    \          C.3.3. Schematron Schema for <nc:get> Reply ...............98\n           C.3.4.
    DSRL Schema for <nc:get> Reply .....................99\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The NETCONF Working Group has completed a base protocol
    used for\n   configuration management [RFC4741].  This base specification defines\n
    \  protocol bindings and an XML container syntax for configuration and\n   management
    operations, but does not include a data modeling language\n   or accompanying
    rules for how to model configuration and state\n   information carried by NETCONF.
    \ The IETF Operations Area has a long\n   tradition of defining data for Simple
    Network Management Protocol\n   (SNMP) Management Information Bases (MIB) modules
    [RFC1157] using the\n   Structure of Management Information (SMI) language [RFC2578]
    to model\n   its data.  While this specific modeling approach has a number of\n
    \  well-understood problems, most of the data modeling features provided\n   by
    SMI are still considered extremely important.  Simply modeling the\n   valid syntax
    without the additional semantic relationships has caused\n   significant interoperability
    problems in the past.\n   The NETCONF community concluded that a data modeling
    framework is\n   needed to support ongoing development of IETF and vendor-defined\n
    \  management information modules.  The NETMOD Working Group was\n   chartered
    to design a modeling language defining the semantics of\n   operational data,
    configuration data, event notifications, and\n   operations, with focus on \"human-friendliness\",
    i.e., readability and\n   ease of use.  The result is the YANG data modeling language\n
    \  [RFC6020], which now serves for the normative description of NETCONF\n   data
    models.\n   Since NETCONF uses XML for encoding its messages, it is natural to\n
    \  express the constraints on NETCONF content using standard XML schema\n   languages.
    \ For this purpose, the NETMOD WG selected the Document\n   Schema Definition
    Languages (DSDL) that is being standardized as\n   ISO/IEC 19757 [DSDL].  The
    DSDL framework comprises a set of XML\n   schema languages that address grammar
    rules, semantic constraints,\n   and other data modeling aspects, but also, and
    more importantly, do\n   it in a coordinated and consistent way.  While it is
    true that some\n   DSDL parts have not been standardized yet and are still work
    in\n   progress, the three parts that the YANG-to-DSDL mapping relies upon\n   --
    Regular Language for XML Next Generation (RELAX NG), Schematron\n   and Document
    Schema Renaming Language (DSRL) -- already have the\n   status of an ISO/ IEC
    International Standard and are supported in a\n   number of software tools.\n
    \  This document contains a specification of a mapping that translates\n   YANG
    data models to XML schemas utilizing a subset of the DSDL schema\n   languages.
    \ The mapping procedure is divided into two steps: In the\n   first step, the
    structure of the data tree, signatures of remote\n   procedure call (RPC) operations,
    and notifications are expressed as\n   the so-called \"hybrid schema\" -- a single
    RELAX NG schema with\n   annotations representing additional data model information
    (metadata,\n   documentation, semantic constraints, default values, etc.).  The\n
    \  second step then generates a coordinated set of DSDL schemas that can\n   be
    used for validating specific XML documents such as client\n   requests, server
    responses or notifications, perhaps also taking into\n   account additional context
    such as active capabilities or features.\n"
  title: 1.  Introduction
- contents:
  - "2.  Terminology and Notation\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
    \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
    and \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n
    \  The following terms are defined in [RFC4741]:\n   o  client\n   o  datastore\n
    \  o  message\n   o  operation\n   o  server\n   The following terms are defined
    in [RFC6020]:\n   o  augment\n   o  base type\n   o  built-in type\n   o  configuration
    data\n   o  container\n   o  data model\n   o  data node\n   o  data tree\n   o
    \ derived type\n   o  device deviation\n   o  extension\n   o  feature\n   o  grouping\n
    \  o  instance identifier\n   o  leaf-list\n   o  list\n   o  mandatory node\n
    \  o  module\n   o  RPC\n   o  RPC operation\n   o  schema node\n   o  schema
    tree\n   o  state data\n   o  submodule\n   o  top-level data node\n   o  uses\n
    \  The following terms are defined in [XML-INFOSET]:\n   o  attribute\n   o  document\n
    \  o  document element\n   o  document type declaration (DTD)\n   o  element\n
    \  o  information set\n   o  namespace\n   In the text, the following typographic
    conventions are used:\n   o  YANG statement keywords are delimited by single quotes.\n
    \  o  XML element names are delimited by \"<\" and \">\" characters.\n   o  Names
    of XML attributes are prefixed by the \"@\" character.\n   o  Other literal values
    are delimited by double quotes.\n   XML element names are always written with
    explicit namespace prefixes\n   corresponding to the following XML vocabularies:\n
    \  \"a\"  DTD compatibility annotations [RNG-DTD];\n   \"dc\"  Dublin Core metadata
    elements [RFC5013];\n   \"dsrl\"  Document Semantics Renaming Language [DSRL];\n
    \  \"en\"  NETCONF event notifications [RFC5277];\n   \"nc\"  NETCONF protocol
    [RFC4741];\n   \"nma\"  NETMOD-specific schema annotations (see Section 5.3);\n
    \  \"nmf\"  NETMOD-specific XML Path Language (XPath) extension functions\n      (see
    Section 12.7);\n   \"rng\"  RELAX NG [RNG];\n   \"sch\"  ISO Schematron [Schematron];\n
    \  \"xsd\"  W3C XML Schema [XSD].\n   The following table shows the mapping of
    these prefixes to namespace\n   URIs.\n     +--------+-----------------------------------------------------+\n
    \    | Prefix | Namespace URI                                       |\n     +--------+-----------------------------------------------------+\n
    \    | a      | http://relaxng.org/ns/compatibility/annotations/1.0 |\n     |
    \       |                                                     |\n     | dc     |
    http://purl.org/dc/terms                            |\n     |        |                                                     |\n
    \    | dsrl   | http://purl.oclc.org/dsdl/dsrl                      |\n     |
    \       |                                                     |\n     | en     |
    urn:ietf:params:xml:ns:netconf:notification:1.0     |\n     |        |                                                     |\n
    \    | nc     | urn:ietf:params:xml:ns:netconf:base:1.0             |\n     |
    \       |                                                     |\n     | nma    |
    urn:ietf:params:xml:ns:netmod:dsdl-annotations:1    |\n     |        |                                                     |\n
    \    | nmf    | urn:ietf:params:xml:ns:netmod:xpath-extensions:1    |\n     |
    \       |                                                     |\n     | rng    |
    http://relaxng.org/ns/structure/1.0                 |\n     |        |                                                     |\n
    \    | sch    | http://purl.oclc.org/dsdl/schematron                |\n     |
    \       |                                                     |\n     | xsd    |
    http://www.w3.org/2001/XMLSchema                    |\n     +--------+-----------------------------------------------------+\n
    \         Table 1: Used namespace prefixes and corresponding URIs\n"
  - contents:
    - "2.1.  Glossary of New Terms\n   o  ancestor data type: Any data type from which
      a given data type is\n      (transitively) derived.\n   o  ancestor built-in
      data type: The built-in data type that is at the\n      start of the type derivation
      chain for a given data type.\n   o  hybrid schema: A RELAX NG schema with annotations,
      which embodies\n      the same information as the source YANG module(s).  See\n
      \     Section 8.1 for details.\n   o  implicit node: A data node that, if it
      is not instantiated in a\n      data tree, may be added to the information set
      of that data tree\n      (configuration, RPC input or output, notification)
      without\n      changing the semantics of the data tree.\n"
    title: 2.1.  Glossary of New Terms
  title: 2.  Terminology and Notation
- contents:
  - "3.  Objectives and Motivation\n   The main objective of this work is to complement
    YANG as a data\n   modeling language with validation capabilities of DSDL schema\n
    \  languages, namely RELAX NG, Schematron, and DSRL.  This document\n   describes
    the correspondence between grammatical, semantic, and data\n   type constraints
    expressed in YANG and equivalent DSDL patterns and\n   rules.  The ultimate goal
    is to be able to capture all substantial\n   information contained in YANG modules
    and express it in DSDL schemas.\n   While the mapping from YANG to DSDL described
    in this document may in\n   principle be invertible, the inverse mapping from
    DSDL to YANG is\n   beyond the scope of this document.\n   XML-based information
    models and XML-encoded data appear in several\n   different forms in various phases
    of YANG data modeling and NETCONF\n   workflow -- configuration datastore contents,
    RPC requests and\n   replies, and notifications.  Moreover, RPC operations are\n
    \  characterized by an inherent diversity resulting from selective\n   availability
    of capabilities and features.  YANG modules can also\n   define new RPC operations.
    \ The mapping should be able to accommodate\n   this variability and generate
    schemas that are specifically tailored\n   to a particular situation and thus
    considerably more effective for\n   validation than generic all-encompassing schemas.\n
    \  In order to cope with this variability, we assume that the DSDL\n   schemas
    will be generated on demand for a particular purpose from the\n   available collection
    of YANG modules and their lifetime will be\n   relatively short.  In other words,
    we don't envision that any\n   collection of DSDL schemas will be created and
    maintained over an\n   extended period of time in parallel to YANG modules.\n
    \  The generated schemas are primarily intended as input to existing XML\n   schema
    validators and other off-the-shelf tools.  However, the\n   schemas may also be
    perused by developers and users as a formal\n   representation of constraints
    on a particular XML-encoded data\n   object.  Consequently, our secondary goal
    is to keep the schemas as\n   readable as possible.  To this end, the complexity
    of the mapping is\n   distributed into two steps:\n   1.  The first step maps
    one or more YANG modules to the so-called\n       hybrid schema, which is a single
    RELAX NG schema that describes\n       grammatical constraints for the main data
    tree as well as for RPC\n       operations and notifications.  Semantic constraints
    and other\n       information appearing in the input YANG modules is recorded
    in\n       the hybrid schema in the form of foreign namespace annotations.\n       The
    output of the first step can thus be considered a virtually\n       complete equivalent
    of the input YANG modules.  It cannot,\n       however, be directly used for any
    validation.\n   2.  In the second step, the hybrid schema from step 1 is transformed\n
    \      further to a coordinated set of fully conformant DSDL schemas\n       containing
    constraints for a particular data object and a\n       specific situation.  The
    DSDL schemas are intended mainly for\n       machine validation using off-the-shelf
    tools.\n"
  title: 3.  Objectives and Motivation
- contents:
  - "4.  DSDL Schema Languages\n   Document Schema Definition Languages (DSDL) is
    a framework of schema\n   languages that is being developed as the International
    Standard ISO/\n   IEC 19757 [DSDL].  Unlike other approaches to XML document\n
    \  validation, most notably W3C XML Schema Definition (XSD) [XSD], the\n   DSDL
    framework adheres to the principle of \"small languages\": each of\n   the DSDL
    constituents is a stand-alone schema language with a\n   relatively narrow purpose
    and focus.  Together, these schema\n   languages may be used in a coordinated
    way to accomplish various\n   validation tasks.\n   The mapping described in this
    document uses three of the DSDL schema\n   languages, namely RELAX NG [RNG], Schematron
    [Schematron], and DSRL\n   [DSRL].\n"
  - contents:
    - "4.1.  RELAX NG\n   RELAX NG (pronounced \"relaxing\") is an XML schema language
      for\n   grammar-based validation and Part 2 of the ISO/IEC DSDL family of\n
      \  standards [RNG].  Like XSD, it is able to describe constraints on the\n   structure
      and contents of XML documents.  However, unlike the DTD\n   [XML] and XSD schema
      languages, RELAX NG intentionally avoids any\n   infoset augmentation such as
      defining default values.  In the DSDL\n   architecture, the particular task
      of defining and applying default\n   values is delegated to another schema language,
      DSRL (see\n   Section 4.3).\n   As its base data type library, RELAX NG uses
      the W3C XML Schema\n   Datatypes [XSD-D]; but unlike XSD, other data type libraries
      may be\n   used along with it or even replace it if necessary.\n   RELAX NG
      is very liberal in accepting annotations from other\n   namespaces.  With a
      few exceptions, such annotations may be placed\n   anywhere in the schema and
      need no encapsulating elements such as\n   <xsd:annotation> in XSD.\n   RELAX
      NG schemas can be represented in two equivalent syntaxes: XML\n   and compact.
      \ The compact syntax is described in Annex C of the RELAX\n   NG specification
      [RNG-CS], which was added to the standard in 2006\n   (Amendment 1).  Automatic
      bidirectional conversions between the two\n   syntaxes can be accomplished using
      several tools, for example, Trang\n   [Trang].\n   For its terseness and readability,
      the compact syntax is often the\n   preferred form for publishing RELAX NG schemas,
      whereas validators\n   and other software tools usually work with the XML syntax.
      \ However,\n   the compact syntax has two drawbacks:\n   o  External annotations
      make the compact syntax schema considerably\n      less readable.  While in
      the XML syntax the annotating elements\n      and attributes are represented
      in a simple and uniform way (XML\n      elements and attributes from foreign
      namespaces), the compact\n      syntax uses as many as four different syntactic
      constructs:\n      documentation, grammar, initial, and following annotations.\n
      \     Therefore, the impact of annotations on readability is often much\n      stronger
      for the compact syntax than it is for the XML syntax.\n   o  In a computer program,
      it is more difficult to generate the\n      compact syntax than the XML syntax.
      \ While a number of software\n      libraries exist that make it easy to create
      an XML tree in the\n      memory and then serialize it, no such aid is available
      for the\n      compact syntax.\n   For these reasons, the mapping specification
      in this document uses\n   exclusively the XML syntax.  Where appropriate, though,
      the schemas\n   resulting from the translation MAY be presented in the equivalent\n
      \  compact syntax.\n   RELAX NG elements are qualified with the namespace URI\n
      \  \"http://relaxng.org/ns/structure/1.0\".  The namespace of the XSD data\n
      \  type library is \"http://www.w3.org/2001/XMLSchema-datatypes\".\n"
    title: 4.1.  RELAX NG
  - contents:
    - "4.2.  Schematron\n   Schematron is Part 3 of DSDL that reached the status of
      a full ISO/\n   IEC standard in 2006 [Schematron].  In contrast to the traditional\n
      \  schema languages such as DTD, XSD, or RELAX NG, which are based on\n   the
      concept of a formal grammar, Schematron utilizes a rule-based\n   approach.
      \ Its rules may specify arbitrary conditions involving data\n   from different
      parts of an XML document.  Each rule consists of three\n   essential components:\n
      \  o  context - an XPath expression that defines the set of locations\n      where
      the rule is to be applied;\n   o  assert or report condition - another XPath
      expression that is\n      evaluated relative to the location matched by the
      context\n      expression;\n   o  human-readable message that is displayed when
      the assert condition\n      is false or report condition is true.\n   The difference
      between the assert and report condition is that the\n   former is positive in
      that it states a condition that a valid\n   document has to satisfy, whereas
      the latter specifies an error\n   condition.\n   Schematron draws most of its
      expressive power from XPath [XPath] and\n   Extensible Stylesheet Language Transformations
      (XSLT) [XSLT].  ISO\n   Schematron allows for dynamic query language binding
      so that the\n   following XML query languages can be used: STX, XSLT 1.0, XSLT
      1.1,\n   EXSLT, XSLT 2.0, XPath 1.0, XPath 2.0, and XQuery 1.0 (this list may\n
      \  be extended in the future).\n   Human-readable error messages are another
      feature that sets\n   Schematron apart from other common schema languages.  The
      messages\n   may even contain XPath expressions that are evaluated in the actual\n
      \  context and thus refer to information items in the XML document being\n   validated.\n
      \  Another feature of Schematron that is used by the mapping are\n   abstract
      patterns.  These work essentially as macros and may also\n   contain parameters
      which are supplied when the abstract pattern is\n   used.\n   Schematron elements
      are qualified with namespace URI\n   \"http://purl.oclc.org/dsdl/schematron\".\n"
    title: 4.2.  Schematron
  - contents:
    - "4.3.  Document Semantics Renaming Language (DSRL)\n   DSRL (pronounced \"disrule\")
      is Part 8 of DSDL that reached the status\n   of a full ISO/IEC standard in
      2008 [DSRL].  Unlike RELAX NG and\n   Schematron, DSRL is allowed to modify
      XML information set of the\n   validated document.  While DSRL is primarily
      intended for renaming\n   XML elements and attributes, it can also define default
      values for\n   XML attributes and default contents for XML elements or subtrees
      so\n   that the default contents are inserted if they are missing in the\n   validated
      documents.  The latter feature is used by the YANG-to-DSDL\n   mapping for representing
      YANG default contents consisting of leaf\n   nodes with default values and their
      ancestor non-presence containers.\n   DSRL elements are qualified with namespace
      URI\n   \"http://purl.oclc.org/dsdl/dsrl\".\n"
    title: 4.3.  Document Semantics Renaming Language (DSRL)
  title: 4.  DSDL Schema Languages
- contents:
  - "5.  Additional Annotations\n   Besides the DSDL schema languages, the mapping
    also uses three sets\n   of annotations that are added as foreign-namespace attributes
    and\n   elements to RELAX NG schemas.\n   Two of the annotation sets -- Dublin
    Core elements and DTD\n   compatibility annotations -- are standard vocabularies
    for\n   representing metadata and documentation, respectively.  Although\n   these
    data model items are not used for formal validation, they quite\n   often carry
    important information for data model implementers.\n   Therefore, they SHOULD
    be included in the hybrid schema and MAY also\n   appear in the final validation
    schemas.\n   The third set are NETMOD-specific annotations.  They are specifically\n
    \  designed for the hybrid schema and convey semantic constraints and\n   other
    information that cannot be expressed directly in RELAX NG.  In\n   the second
    mapping step, these annotations are converted to\n   Schematron and DSRL rules.\n"
  - contents:
    - "5.1.  Dublin Core Metadata Elements\n   Dublin Core is a system of metadata
      elements that was originally\n   created for describing metadata of World Wide
      Web resources in order\n   to facilitate their automated lookup.  Later it was
      accepted as a\n   standard for describing metadata of arbitrary resources.  This\n
      \  specification uses the definition from [RFC5013].\n   Dublin Core elements
      are qualified with namespace URI\n   \"http://purl.org/dc/terms\".\n"
    title: 5.1.  Dublin Core Metadata Elements
  - contents:
    - "5.2.  RELAX NG DTD Compatibility Annotations\n   DTD compatibility annotations
      are a part of the RELAX NG DTD\n   Compatibility specification [RNG-DTD].  YANG-to-DSDL
      mapping uses\n   only the <a:documentation> annotation for representing YANG\n
      \  'description' and 'reference' texts.\n   Note that there is no intention
      to make the resulting schemas DTD-\n   compatible, the main reason for using
      these annotations is technical:\n   they are well supported and adequately formatted
      by several RELAX NG\n   tools.\n   DTD compatibility annotations are qualified
      with namespace URI\n   \"http://relaxng.org/ns/compatibility/annotations/1.0\".\n"
    title: 5.2.  RELAX NG DTD Compatibility Annotations
  - contents:
    - "5.3.  NETMOD-Specific Annotations\n   NETMOD-specific annotations are XML elements
      and attributes that are\n   qualified with the namespace URI\n   \"urn:ietf:params:xml:ns:netmod:dsdl-annotations:1\"
      and that appear in\n   various locations of the hybrid schema.  YANG statements
      are mapped\n   to these annotations in a straightforward way.  In most cases,
      the\n   annotation attributes and elements have the same name as the\n   corresponding
      YANG statement.\n   Table 2 lists, alphabetically, the names of NETMOD-specific\n
      \  annotation attributes (prefixed with \"@\") and elements (in angle\n   brackets)
      along with a reference to the section where their use is\n   described.  Appendix
      A contains a RELAX NG schema for this annotation\n   vocabulary.\n         +---------------------------+--------------------+------+\n
      \        | annotation                | section            | note |\n         +---------------------------+--------------------+------+\n
      \        | @nma:config               | 10.9               |      |\n         |
      \                          |                    |      |\n         | <nma:data>
      \               | 8.1                | 4    |\n         |                           |
      \                   |      |\n         | @nma:default              | 10.12              |
      \     |\n         |                           |                    |      |\n
      \        | <nma:error-app-tag>       | 10.16              | 1    |\n         |
      \                          |                    |      |\n         | <nma:error-message>
      \      | 10.17              | 1    |\n         |                           |
      \                   |      |\n         | @nma:if-feature           | 10.22              |
      \     |\n         |                           |                    |      |\n
      \        | @nma:implicit             | 10.11, 10.7, 10.12 |      |\n         |
      \                          |                    |      |\n         | <nma:input>
      \              | 8.1                | 4    |\n         |                           |
      \                   |      |\n         | <nma:instance-identifier> | 10.53.7
      \           | 2    |\n         |                           |                    |
      \     |\n         | @nma:key                  | 10.26              |      |\n
      \        |                           |                    |      |\n         |
      @nma:leaf-list            | 10.28              |      |\n         |                           |
      \                   |      |\n         | @nma:leafref              | 10.53.8
      \           |      |\n         |                           |                    |
      \     |\n         | @nma:mandatory            | 10.8               |      |\n
      \        |                           |                    |      |\n         |
      @nma:max-elements         | 10.28              |      |\n         |                           |
      \                   |      |\n         | @nma:min-elements         | 10.28              |
      \     |\n         |                           |                    |      |\n
      \        | @nma:module               | 10.34              |      |\n         |
      \                          |                    |      |\n         | <nma:must>
      \               | 10.35              | 3    |\n         |                           |
      \                   |      |\n         | <nma:notification>        | 8.1                |
      4    |\n         |                           |                    |      |\n
      \        | <nma:notifications>       | 8.1                | 4    |\n         |
      \                          |                    |      |\n         | @nma:ordered-by
      \          | 10.38              |      |\n         | <nma:output>              |
      8.1                | 4    |\n         |                           |                    |
      \     |\n         | <nma:rpc>                 | 8.1                | 4    |\n
      \        |                           |                    |      |\n         |
      <nma:rpcs>                | 8.1                | 4    |\n         |                           |
      \                   |      |\n         | @nma:status               | 10.51              |
      \     |\n         |                           |                    |      |\n
      \        | @nma:unique               | 10.55              |      |\n         |
      \                          |                    |      |\n         | @nma:units
      \               | 10.56              |      |\n         |                           |
      \                   |      |\n         | @nma:when                 | 10.59              |
      \     |\n         +---------------------------+--------------------+------+\n
      \                  Table 2: NETMOD-specific annotations\n   Notes:\n   1.  Appears
      only as a subelement of <nma:must>.\n   2.  Has an optional attribute @require-instance.\n
      \  3.  Has a mandatory attribute @assert and two optional subelements\n       <nma:error-app-tag>
      and <nma:error-message>.\n   4.  Marker element in the hybrid schema.\n"
    title: 5.3.  NETMOD-Specific Annotations
  title: 5.  Additional Annotations
- contents:
  - "6.  Overview of the Mapping\n   This section gives an overview of the YANG-to-DSDL
    mapping, its\n   inputs and outputs.  Figure 1 presents an overall structure of
    the\n   mapping:\n                    +----------------+\n                    |
    YANG module(s) |\n                    +----------------+\n                            |\n
    \                           |T\n                            |\n          +------------------------------------+\n
    \         |           hybrid schema            |\n          +------------------------------------+\n
    \              /       |           |       \\\n              /        |           |
    \       \\\n           Tg/       Tr|           |Tn       \\\n            /          |
    \          |          \\\n      +---------+   +-----+    +-------+    +------+\n
    \     |get reply|   | rpc |    | notif |    | .... |\n      +---------+   +-----+
    \   +-------+    +------+\n                    Figure 1: Structure of the mapping\n
    \  The mapping procedure is divided into two steps:\n   1.  Transformation T in
    the first step maps one or more YANG modules\n       to the hybrid schema (see
    Section 8.1).  Constraints that cannot\n       be expressed directly in RELAX
    NG (list key definitions, 'must'\n       statements, etc.) and various documentation
    texts are recorded in\n       the schema as foreign-namespace annotations.\n   2.
    \ In the second step, the hybrid schema may be transformed in\n       multiple
    ways to a coordinated set of DSDL schemas that can be\n       used for validating
    a particular data object in a specific\n       context.  Figure 1 shows three
    simple possibilities as examples.\n       In the process, appropriate parts of
    the hybrid schema are\n       extracted and specific annotations transformed to
    equivalent, but\n       usually more complex, Schematron patterns, DSRL element
    maps,\n       etc.\n   An implementation of the mapping algorithm MUST accept
    one or more\n   valid YANG modules as its input.  It is important to be able to\n
    \  process multiple YANG modules together since multiple modules may be\n   negotiated
    for a NETCONF session and the contents of the\n   configuration datastore is then
    obtained as the union of data trees\n   specified by the individual modules, which
    may also lead to multiple\n   root nodes of the datastore hierarchy.  In addition,
    the input\n   modules may be further coupled by the 'augment' statement in which\n
    \  one module augments the data tree of another module.\n   It is also assumed
    that the algorithm has access, perhaps on demand,\n   to all YANG modules that
    the input modules import (directly or\n   transitively).\n   Other information
    contained in input YANG modules, such as semantic\n   constraints and default
    values, is recorded in the hybrid schema as\n   annotations -- XML attributes
    or elements qualified with the\n   namespace URI \"urn:ietf:params:xml:ns:netmod:dsdl-annotations:1\".\n
    \  Metadata describing the YANG modules are mapped to Dublin Core\n   annotations
    elements (Section 5.1).  Finally, documentation strings\n   are mapped to <a:documentation>
    elements belonging to the DTD\n   compatibility vocabulary (Section 5.2).\n   The
    output of the second step is a coordinated set of three DSDL\n   schemas corresponding
    to a specific data object and context:\n   o  RELAX NG schema describing the grammatical
    and data type\n      constraints;\n   o  Schematron schema expressing other constraints
    such as uniqueness\n      of list keys or user-specified semantic rules;\n   o
    \ DSRL schema containing the specification of default contents.\n"
  title: 6.  Overview of the Mapping
- contents:
  - "7.  NETCONF Content Validation\n   This section describes how the schemas generated
    by the YANG-to-DSDL\n   mapping are supposed to be applied for validating XML
    instance\n   documents such as the contents of a datastore or various NETCONF\n
    \  messages.\n   The validation proceeds in the following steps, which are also\n
    \  illustrated in Figure 2:\n   1.  The XML instance document is checked for grammatical
    and data\n       type validity using the RELAX NG schema.\n   2.  Default values
    for leaf nodes have to be applied and their\n       ancestor containers added
    where necessary.  It is important to\n       add the implicit nodes before the
    next validation step because\n       YANG specification [RFC6020] requires that
    the data tree against\n       which XPath expressions are evaluated already has
    all defaults\n       filled-in.  Note that this step modifies the information
    set of\n       the validated XML document.\n   3.  The semantic constraints are
    checked using the Schematron schema.\n         +----------+                        +----------+\n
    \        |          |                        |   XML    |\n         |   XML    |
    \                       | document |\n         | document |-----------o----------->|
    \  with   |\n         |          |           ^            | defaults |\n         |
    \         |           |            |          |\n         +----------+           |
    \           +----------+\n              ^                 | filling in       ^\n
    \             | grammar,        | defaults         | semantic\n              |
    data types       |                  | constraints\n              |                 |
    \                 |\n         +----------+       +--------+       +------------+\n
    \        | RELAX NG |       |  DSRL  |       | Schematron |\n         |  schema
    \ |       | schema |       |   schema   |\n         +----------+       +--------+
    \      +------------+\n               Figure 2: Outline of the validation procedure\n"
  title: 7.  NETCONF Content Validation
- contents:
  - "8.  Design Considerations\n   YANG data models could, in principle, be mapped
    to the DSDL schemas\n   in a number of ways.  The mapping procedure described
    in this\n   document uses several specific design decisions that are discussed
    in\n   the following subsections.\n"
  - contents:
    - "8.1.  Hybrid Schema\n   As was explained in Section 6, the first step of the
      mapping produces\n   an intermediate document -- the hybrid schema, which specifies
      all\n   constraints for the entire data model using the RELAX NG syntax and\n
      \  additional annotations.  In cannot be directly used for validation --\n   as
      a matter of fact, it is not even a valid RELAX NG schema because\n   it contains
      multiple schemas demarcated by special annotation\n   elements.\n   Every input
      YANG module corresponds to exactly one embedded grammar\n   in the hybrid schema.
      \ This separation of input YANG modules allows\n   each embedded grammar to
      include named pattern definitions into its\n   own namespace, which is important
      for mapping YANG groupings (see\n   Section 9.2 for additional details).\n   In
      addition to grammatical and data type constraints, YANG modules\n   provide
      other important information that cannot be expressed in a\n   RELAX NG schema:
      semantic constraints, default values, metadata,\n   documentation, and so on.
      \ Such information items are represented in\n   the hybrid schema as XML attributes
      and elements belonging to the\n   namespace with the following URI:\n   \"urn:ietf:params:xml:ns:netmod:dsdl-annotations:1\".
      \ A complete list\n   of these annotations is given in Section 5.3, detailed
      rules about\n   their use are then contained in the following sections.\n   YANG
      modules define data models not only for configuration and state\n   data but
      also for (multiple) RPC operations [RFC4741] and/or event\n   notifications
      [RFC5277].  In order to be able to capture all three\n   types of data models
      in one schema document, the hybrid schema uses\n   special markers that enclose
      sub-schemas for configuration and state\n   data, individual RPC operations
      (both input and output part) and\n   individual notifications.\n   The markers
      are the following XML elements in the namespace of\n   NETMOD-specific annotations
      (URI\n   urn:ietf:params:xml:ns:netmod:dsdl-annotations:1):\n       +-------------------+---------------------------------------+\n
      \      | Element name      | Role                                  |\n       +-------------------+---------------------------------------+\n
      \      | nma:data          | encloses configuration and state data |\n       |
      \                  |                                       |\n       | nma:rpcs
      \         | encloses all RPC operations           |\n       |                   |
      \                                      |\n       | nma:rpc           | encloses
      an individual RPC operation  |\n       |                   |                                       |\n
      \      | nma:input         | encloses an RPC request               |\n       |
      \                  |                                       |\n       | nma:output
      \       | encloses an RPC reply                 |\n       |                   |
      \                                      |\n       | nma:notifications | encloses
      all notifications            |\n       |                   |                                       |\n
      \      | nma:notification  | encloses an individual notification   |\n       +-------------------+---------------------------------------+\n
      \              Table 3: Marker elements in the hybrid schema\n   For example,
      consider a data model formed by two YANG modules\n   \"example-a\" and \"example-b\"
      that define nodes in the namespaces\n   \"http://example.com/ns/example-a\"
      and\n   \"http://example.com/ns/example-b\".  Module \"example-a\" defines\n
      \  configuration/state data, RPC methods and notifications, whereas\n   \"example-b\"
      defines only configuration/state data.  The hybrid schema\n   can then be schematically
      represented as follows:\n  <grammar xmlns=\"http://relaxng.org/ns/structure/1.0\"\n
      \          xmlns:nma=\"urn:ietf:params:xml:ns:netmod:dsdl-annotations:1\"\n
      \          xmlns:exa=\"http://example.com/ns/example-a\"\n           xmlns:exb=\"http://example.com/ns/example-b\"\n
      \          datatypeLibrary=\"http://www.w3.org/2001/XMLSchema-datatypes\">\n
      \   <start>\n      <grammar nma:module=\"example-a\"\n               ns=\"http://example.com/ns/example-a\">\n
      \       <start>\n          <nma:data>\n            ...configuration and state
      data defined in \"example-a\"...\n          </nma:data>\n          <nma:rpcs>\n
      \           <nma:rpc>\n              <nma:input>\n                <element name=\"exa:myrpc\">\n
      \                 ...\n                </element>\n              </nma:input>\n
      \             <nma:output>\n                ...\n              </nma:output>\n
      \           </nma:rpc>\n            ...\n          </nma:rpcs>\n          <nma:notifications>\n
      \           <nma:notification>\n              <element name=\"exa:mynotif\">\n
      \               ...\n              </element>\n            </nma:notification>\n
      \           ...\n          </nma:notifications>\n        </start>\n        ...local
      named pattern definitions of example-a...\n      </grammar>\n      <grammar
      nma:module=\"example-b\"\n               ns=\"http://example.com/ns/example-a\">\n
      \       <start>\n          <nma:data>\n            ...configuration and state
      data defined in \"example-b\"...\n          </nma:data>\n          <nma:rpcs/>\n
      \         <nma:notifications/>\n        </start>\n        ...local named pattern
      definitions of example-b...\n      </grammar>\n    </start>\n    ...global named
      pattern definitions...\n  </grammar>\n   A complete hybrid schema for the data
      model of a DHCP server is given\n   in Appendix C.2.\n"
    title: 8.1.  Hybrid Schema
  - contents:
    - "8.2.  Modularity\n   Both YANG and RELAX NG offer means for modularity, i.e.,
      for\n   splitting the contents of a full schema into separate modules and\n
      \  combining or reusing them in various ways.  However, the approaches\n   taken
      by YANG and RELAX NG differ.  Modularity in RELAX NG is\n   suitable for ad
      hoc combinations of a small number of schemas whereas\n   YANG assumes a large
      set of modules similar to SNMP MIB modules.  The\n   following differences are
      important:\n   o  In YANG, whenever module A imports module B, it gets access
      to the\n      definitions (groupings and typedefs) appearing at the top level
      of\n      module B.  However, no part of data tree from module B is imported\n
      \     along with it.  In contrast, the <rng:include> pattern in RELAX NG\n      imports
      both definitions of named patterns and the entire schema\n      tree from the
      included schema.\n   o  The names of imported YANG groupings and typedefs are
      qualified\n      with the namespace of the imported module.  On the other hand,
      the\n      names of data nodes contained inside the imported groupings, when\n
      \     used within the importing module, become part of the importing\n      module's
      namespace.  In RELAX NG, the names of patterns are\n      unqualified and so
      named patterns defined in both the importing\n      and imported module share
      the same flat namespace.  The contents\n      of RELAX NG named patterns may
      either keep the namespace of the\n      schema where they are defined or inherit
      the namespace of the\n      importing module, analogically to YANG.  However,
      in order to\n      achieve the latter behavior, the definitions of named patterns\n
      \     must be included from an external schema, which has to be prepared\n      in
      a special way (see [Vli04], Chapter 11).\n   In order to map, as much as possible,
      the modularity of YANG to RELAX\n   NG, a validating RELAX NG schema (the result
      of the second mapping\n   step) has to be split into two files, one of them
      containing all\n   global definitions that are mapped from top-level YANG groupings\n
      \  appearing in all input YANG module.  This RELAX NG schema MUST NOT\n   define
      any namespace via the @ns attribute.\n   The other RELAX NG schema file then
      defines actual data trees mapped\n   from input YANG modules, each of them enclosed
      in an own embedded\n   grammar.  Those embedded grammars, in which at least
      one of the\n   global definitions is used, MUST include the first schema with\n
      \  definitions and also MUST define the local namespace using the @ns\n   attribute.
      \ This way, the global definitions can be used inside\n   different embedded
      grammar, each time accepting a different local\n   namespace.\n   Named pattern
      definitions that are mapped from non-top-level YANG\n   groupings MUST be placed
      inside the embedded grammar corresponding to\n   the YANG module where the grouping
      is defined.\n   In the hybrid schema, we need to distinguish the global and
      non-\n   global named pattern definitions while still keeping the hybrid\n   schema
      in one file.  This is accomplished in the following way:\n   o  Every global
      definition MUST be placed as a child of the outer\n      <rng:grammar> element
      (the document root of the hybrid schema).\n   o  Every non-global definitions
      MUST be placed as a child of the\n      corresponding embedded <rng:grammar>
      element.\n   YANG also allows for splitting a module into a number of submodules.\n
      \  However, as submodules have no impact on the scope of identifiers and\n   namespaces,
      the modularity based on submodules is not mapped in any\n   way.  The contents
      of submodules is therefore handled as if the\n   submodule text appeared directly
      in the main module.\n"
    title: 8.2.  Modularity
  - contents:
    - "8.3.  Granularity\n   RELAX NG supports different styles of schema structuring:
      one\n   extreme, often called \"Russian Doll\", specifies the structure of an\n
      \  XML instance document in a single hierarchy.  The other extreme, the\n   flat
      style, uses a similar approach as the Data Type Definition (DTD)\n   schema
      language -- every XML element corresponds to a named pattern\n   definition.
      \ In practice, some compromise between the two extremes is\n   usually chosen.\n
      \  YANG supports both styles in principle, too, but in most cases the\n   modules
      are organized in a way closer to the \"Russian Doll\" style,\n   which provides
      a better insight into the structure of the\n   configuration data.  Groupings
      are usually defined only for contents\n   that are prepared for reuse in multiple
      places via the 'uses'\n   statement.  In contrast, RELAX NG schemas tend to
      be much flatter,\n   because finer granularity is also needed in RELAX NG for\n
      \  extensibility of the schemas -- it is only possible to replace or\n   modify
      schema fragments that are factored out as named patterns.  For\n   YANG, this
      is not an issue since its 'augment' and 'refine'\n   statements can delve, by
      using path expressions, into arbitrary\n   depths of existing structures.\n
      \  In general, it is not feasible to map YANG's powerful extension\n   mechanisms
      to those available in RELAX NG.  For this reason, the\n   mapping essentially
      keeps the granularity of the original YANG data\n   model: YANG groupings and
      definitions of derived types usually have\n   direct counterparts in definitions
      of named patterns in the resulting\n   RELAX NG schema.\n"
    title: 8.3.  Granularity
  - contents:
    - "8.4.  Handling of XML Namespaces\n   Most modern XML schema languages, including
      RELAX NG, Schematron, and\n   DSRL, support schemas for so-called compound XML
      documents that\n   contain elements from multiple namespaces.  This is useful
      for our\n   purpose since the YANG-to-DSDL mapping allows for multiple input
      YANG\n   modules, which naturally leads to compound document schemas.\n   RELAX
      NG offers two alternatives for defining the target namespaces\n   in the schema:\n
      \  1.  First possibility is the traditional XML way via the @xmlns:xxx\n       attribute.\n
      \  2.  One of the target namespace URIs may be declared using the @ns\n       attribute.\n
      \  In both the hybrid schema and validation RELAX NG schemas generated\n   in
      the second step, the namespaces MUST be declared as follows:\n   1.  The root
      <rng:grammar> MUST have @xmlns:xxx attributes declaring\n       prefixes of
      all namespaces that are used in the data model.  The\n       prefixes SHOULD
      be identical to those defined in the 'prefix'\n       statements.  An implementation
      of the mapping MUST resolve all\n       collisions in the prefixes defined by
      different input modules, if\n       there are any.\n   2.  Each embedded <rng:grammar>
      element MUST declare the namespace of\n       the corresponding module using
      the @ns attribute.  This way, the\n       names of nodes defined by global named
      patterns are able to adopt\n       the local namespace of each embedded grammar,
      as explained in\n       Section 8.2.\n   This setup is illustrated by the example
      at the end of Section 8.1.\n   DSRL schemas may declare any number of target
      namespaces via the\n   standard XML attributes xmlns:xxx.\n   In contrast, Schematron
      requires all used namespaces to be defined in\n   the <sch:ns> subelements of
      the document element <sch:schema>.\n"
    title: 8.4.  Handling of XML Namespaces
  title: 8.  Design Considerations
- contents:
  - "9.  Mapping YANG Data Models to the Hybrid Schema\n   This section explains the
    main principles governing the first step of\n   the mapping.  Its result is the
    hybrid schema that is described in\n   Section 8.1.\n   A detailed specification
    of the mapping of individual YANG statements\n   is contained in Section 10.\n"
  - contents:
    - "9.1.  Occurrence Rules for Data Nodes\n   In DSDL schema languages, occurrence
      constraints for a node are\n   always localized together with that node.  In
      a RELAX NG schema, for\n   example, the <rng:optional> pattern appears as the
      parent element of\n   the pattern defining a leaf or non-leaf element.  Similarly,
      DSRL\n   specifies default contents separately for every single node, be it
      a\n   leaf or non-leaf element.\n   For leaf nodes in YANG modules, the occurrence
      constraints are also\n   easily inferred from the substatements of 'leaf'.  On
      the other hand,\n   for a YANG container, it is often necessary to examine its
      entire\n   subtree in order to determine the container's occurrence constraints.\n
      \  Therefore, one of the goals of the first mapping step is to infer the\n   occurrence
      constraints for all data nodes and mark, accordingly, the\n   corresponding
      <rng:element> patterns in the hybrid schema so that any\n   transformation procedure
      in the second mapping step can simply use\n   this information and need not
      examine the subtree again.\n   First, it has to be decided whether a given data
      node must always be\n   present in a valid configuration.  If so, such a node
      is called\n   mandatory, otherwise it is called optional.  This constraint is\n
      \  closely related to the notion of mandatory nodes in Section 3.1 in\n   [RFC6020].
      \ The only difference is that this document also considers\n   list keys to
      be mandatory.\n   The other occurrence constraint has to do with the semantics
      of the\n   'default' statement and the possibility of removing empty non-\n
      \  presence containers.  As a result, the information set of a valid\n   configuration
      may be modified by adding or removing certain leaf or\n   container elements
      without changing the meaning of the configuration.\n   In this document, such
      elements are called implicit.  In the hybrid\n   schema, they can be identified
      as RELAX NG patterns having either the\n   @nma:default or the @nma:implicit
      attribute.\n   Note that both occurrence constraints apply to containers at
      the top\n   level of the data tree, and then also to other containers under
      the\n   additional condition that their parent node exists in the instance\n
      \  document.  For example, consider the following YANG fragment:\n       container
      outer {\n           presence 'Presence of \"outer\" means something.';\n           container
      c1 {\n               leaf foo {\n                   type uint8;\n                   default
      1;\n               }\n           }\n           container c2 {\n               leaf-list
      bar {\n                   type uint8;\n                   min-elements 0;\n
      \              }\n           }\n           container c3 {\n               leaf
      baz {\n                   type uint8;\n                   mandatory true;\n
      \              }\n           }\n       }\n   Here, container \"outer\" has the
      'presence' substatement, which means\n   that it is optional and not implicit.
      \ If \"outer\" is not present in a\n   configuration, its child containers are
      not present as well.\n   However, if \"outer\" does exist, it makes sense to
      ask which of its\n   child containers are optional and which are implicit.  In
      this case,\n   \"c1\" is optional and implicit, \"c2\" is optional but not implicit,
      and\n   \"c3\" is mandatory (and therefore not implicit).\n   The following
      subsections give precise rules for determining whether\n   a container is optional
      or mandatory and whether it is implicit.  In\n   order to simplify the recursive
      definition of these occurrence\n   characteristics, it is useful to define them
      also for other types of\n   YANG schema nodes, i.e., leaf, list, leaf-list,
      anyxml, and choice.\n"
    - contents:
      - "9.1.1.  Optional and Mandatory Nodes\n   The decision whether a given node
        is mandatory or optional is\n   governed by the following rules:\n   o  Leaf,
        anyxml, and choice nodes are mandatory if they contain the\n      substatement
        \"mandatory true;\".  For a choice node, this means\n      that at least one
        node from exactly one case branch must exist.\n   o  In addition, a leaf node
        is mandatory if it is declared as a list\n      key.\n   o  A list or leaf-list
        node is mandatory if it contains the 'min-\n      elements' substatement with
        an argument value greater than zero.\n   o  A container node is mandatory
        if its definition does not contain\n      the 'presence' substatement and
        at least one of its child nodes is\n      mandatory.\n   A node that is not
        mandatory is said to be optional.\n   In RELAX NG, definitions of nodes that
        are optional must be\n   explicitly wrapped in the <rng:optional> element.
        \ The mapping MUST\n   use the above rules to determine whether a YANG node
        is optional, and\n   if so, insert the <rng:optional> element in the hybrid
        schema.\n   However, alternatives in <rng:choice> MUST NOT be defined as optional\n
        \  in the hybrid schema.  If a choice in YANG is not mandatory, <rng:\n   optional>
        MUST be used to wrap the entire <rng:choice> pattern.\n"
      title: 9.1.1.  Optional and Mandatory Nodes
    - contents:
      - "9.1.2.  Implicit Nodes\n   The following rules are used to determine whether
        a given data node\n   is implicit:\n   o  List, leaf-list, and anyxml nodes
        are never implicit.\n   o  A leaf node is implicit if and only if it has a
        default value,\n      defined either directly or via its data type.\n   o
        \ A container node is implicit if and only if it does not have the\n      'presence'
        substatement, none of its children are mandatory, and\n      at least one
        child is implicit.\n   In the hybrid schema, all implicit containers, as well
        as leafs that\n   obtain their default value from a typedef and don't have
        the @nma:\n   default attribute, MUST be marked with @nma:implicit attribute
        having\n   the value of \"true\".\n   Note that Section 7.9.3 in [RFC6020]
        specifies other rules that must\n   be taken into account when deciding whether
        or not a given container\n   or leaf appearing inside a case of a choice is
        ultimately implicit.\n   Specifically, a leaf or container under a case can
        be implicit only\n   if the case appears in the argument of the choice's 'default'\n
        \  statement.  However, this is not sufficient by itself but also\n   depends
        on the particular instance XML document, namely on the\n   presence or absence
        of nodes from other (non-default) cases.  The\n   details are explained in
        Section 11.3.\n"
      title: 9.1.2.  Implicit Nodes
    title: 9.1.  Occurrence Rules for Data Nodes
  - contents:
    - "9.2.  Mapping YANG Groupings and Typedefs\n   YANG groupings and typedefs are
      generally mapped to RELAX NG named\n   patterns.  There are, however, several
      caveats that the mapping has\n   to take into account.\n   First of all, YANG
      typedefs and groupings may appear at all levels of\n   the module hierarchy
      and are subject to lexical scoping, see Section\n   5.5 in [RFC6020].  Second,
      top-level symbols from external modules\n   may be imported as qualified names
      represented using the external\n   module namespace prefix and the name of the
      symbol.  In contrast,\n   named patterns in RELAX NG (both local and imported
      via the <rng:\n   include> pattern) share the same namespace and within a grammar
      they\n   are always global -- their definitions may only appear at the top\n
      \  level as children of the <rng:grammar> element.  Consequently,\n   whenever
      YANG groupings and typedefs are mapped to RELAX NG named\n   pattern definitions,
      their names MUST be disambiguated in order to\n   avoid naming conflicts.  The
      mapping uses the following procedure for\n   mangling the names of groupings
      and type definitions:\n   o  Names of groupings and typedefs appearing at the
      top level of the\n      YANG module hierarchy are prefixed with the module name
      and two\n      underscore characters (\"__\").\n   o  Names of other groupings
      and typedefs, i.e., those that do not\n      appear at the top level of a YANG
      module, are prefixed with the\n      module name, double underscore, and then
      the names of all ancestor\n      data nodes separated by double underscore.\n
      \  o  Finally, since the names of groupings and typedefs in YANG have\n      different
      namespaces, an additional underscore character is added\n      to the beginning
      of the mangled names of all groupings.\n   An additional complication is caused
      by the YANG rules for subelement\n   ordering (see, e.g., Section 7.5.7 in [RFC6020]):
      in RPC input and\n   output parameters, subelements must follow the order specified
      in the\n   data model; otherwise, the order is arbitrary.  Consequently, if
      a\n   grouping is used both in RPC input/output parameters and elsewhere,\n
      \  it MUST be mapped to two different named pattern definitions -- one\n   with
      fixed order and the other with arbitrary order.  To distinguish\n   them, the
      \"__rpc\" suffix MUST be appended to the version with fixed\n   order.\n   EXAMPLE.
      \ Consider the following YANG module that imports the\n   standard module \"ietf-inet-types\"
      [RFC6021]:\n   module example1 {\n       namespace \"http://example.com/ns/example1\";\n
      \      prefix ex1;\n       typedef vowels {\n           type string {\n               pattern
      \"[aeiouy]*\";\n           }\n       }\n       grouping \"grp1\" {\n           leaf
      \"void\" {\n               type \"empty\";\n           }\n       }\n       container
      \"cont\" {\n           leaf foo {\n               type vowels;\n           }\n
      \          uses \"grp1\";\n       }\n   }\n   The hybrid schema generated by
      the first mapping step will then\n   contain the following two (global) named
      pattern definitions:\n   <rng:define name=\"example1__vowels\">\n     <rng:data
      type=\"string\">\n       <rng:param name=\"pattern\">[aeiouy]*</rng:param>\n
      \    </rng:data>\n   </rng:define>\n   <rng:define name=\"_example1__grp1\">\n
      \    <rng:optional>\n       <rng:element name=\"void\">\n         <rng:empty/>\n
      \      </rng:element>\n     </rng:optional>\n   </rng:define>\n"
    - contents:
      - "9.2.1.  YANG Refinements and Augments\n   YANG groupings represent a similar
        concept as named pattern\n   definitions in RELAX NG, and both languages also
        offer mechanisms for\n   their subsequent modification.  However, in RELAX
        NG, the definitions\n   themselves are modified, whereas YANG provides two
        substatements of\n   'uses', which modify expansions of groupings:\n   o  The
        'refine' statement allows for changing parameters of a schema\n      node
        inside the grouping referenced by the parent 'uses'\n      statement;\n   o
        \ The 'augment' statement can be used for adding new schema nodes to\n      the
        grouping contents.\n   Both 'refine' and 'augment' statements are quite powerful
        in that\n   they can address, using XPath-like expressions as their arguments,\n
        \  schema nodes that are arbitrarily deep inside the grouping contents.\n
        \  In contrast, modifications of named pattern definitions in RELAX NG\n   are
        applied exclusively at the topmost level of the named pattern\n   contents.
        \ In order to achieve a modifiability of named patterns\n   comparable to
        YANG, a RELAX NG schema would have to be extremely flat\n   (cf. Section 8.3)
        and very difficult to read.\n   Since the goal of the mapping described in
        this document is to\n   generate ad hoc DSDL schemas, we decided to avoid
        these complications\n   and instead expand the grouping and refine and/or
        augment it \"in\n   place\".  In other words, every 'uses' statement that
        has 'refine'\n   and/or 'augment' substatements is replaced by the contents
        of the\n   corresponding grouping, the changes specified in the 'refine' and\n
        \  'augment' statements are applied, and the resulting YANG schema\n   fragment
        is mapped as if the 'uses'/'grouping' indirection wasn't\n   there.\n   If
        there are further 'uses' statements inside the grouping contents,\n   they
        may require expansion, too: it is necessary if the contained\n   'uses'/'grouping'
        pair lies on the \"modification path\" specified in\n   the argument of a
        'refine' or 'augment' statement.\n   EXAMPLE.  Consider the following YANG
        module:\n   module example2 {\n       namespace \"http://example.com/ns/example2\";\n
        \      prefix ex2;\n       grouping leaves {\n           uses fr;\n           uses
        es;\n       }\n       grouping fr {\n           leaf feuille {\n               type
        string;\n           }\n       }\n       grouping es {\n           leaf hoja
        {\n               type string;\n           }\n       }\n       uses leaves;\n
        \  }\n   The resulting hybrid schema contains three global named pattern\n
        \  definitions corresponding to the three groupings, namely:\n   <rng:define
        name=\"_example2__leaves\">\n     <rng:interleave>\n       <rng:ref name=\"_example2__fr\"/>\n
        \      <rng:ref name=\"_example2__es\"/>\n     </rng:interleave>\n   </rng:define>\n
        \  <rng:define name=\"_example2__fr\">\n     <rng:optional>\n       <rng:element
        name=\"feuille\">\n         <rng:data type=\"string\"/>\n       </rng:element>\n
        \    </rng:optional>\n   </rng:define>\n   <rng:define name=\"_example2__es\">\n
        \    <rng:optional>\n       <rng:element name=\"hoja\">\n         <rng:data
        type=\"string\"/>\n       </rng:element>\n     </rng:optional>\n   </rng:define>\n
        \  and the configuration data part of the hybrid schema is a single\n   named
        pattern reference:\n   <nma:data>\n     <rng:ref name=\"_example2__leaves\"/>\n
        \  </nma:data>\n   Now assume that the \"uses leaves\" statement contains
        a 'refine'\n   substatement, for example:\n   uses leaves {\n       refine
        \"hoja\" {\n           default \"alamo\";\n       }\n   }\n   The resulting
        hybrid schema now contains just one named pattern\n   definition - \"_example2__fr\".
        \ The other two groupings \"leaves\" and\n   \"es\" have to be expanded because
        they both lie on the \"modification\n   path\", i.e., contain the leaf \"hoja\"
        that is being refined.  The\n   configuration data part of the hybrid schema
        now looks like this:\n   <nma:data>\n     <rng:interleave>\n       <rng:ref
        name=\"_example2__fr\"/>\n       <rng:optional>\n         <rng:element name=\"ex2:hoja\"
        nma:default=\"alamo\">\n           <rng:data type=\"string\"/>\n         </rng:element>\n
        \      </rng:optional>\n     </rng:interleave>\n   </nma:data>\n"
      title: 9.2.1.  YANG Refinements and Augments
    - contents:
      - "9.2.2.  Type Derivation Chains\n   RELAX NG has no equivalent of the type
        derivation mechanism in YANG\n   that allows one to restrict a built-in type
        (perhaps in multiple\n   steps) by adding new constraints.  Whenever a derived
        YANG type is\n   used without restrictions -- as a substatement of either
        'leaf' or\n   another 'typedef' -- then the 'type' statement is mapped simply
        to a\n   named pattern reference <rng:ref>, and the type definition is mapped\n
        \  to a RELAX NG named pattern definition <rng:define>.  However, if any\n
        \  restrictions are specified as substatements of the 'type' statement,\n
        \  the type definition MUST be expanded at that point so that only the\n   ancestor
        built-in type appears in the hybrid schema, restricted with\n   facets that
        correspond to the combination of all restrictions found\n   along the type
        derivation chain and also in the 'type' statement.\n   EXAMPLE.  Consider
        this YANG module:\n   module example3 {\n       namespace \"http://example.com/ns/example3\";\n
        \      prefix ex3;\n       typedef dozen {\n           type uint8 {\n               range
        1..12;\n           }\n       }\n       leaf month {\n           type dozen;\n
        \      }\n   }\n   The 'type' statement in \"leaf month\" has no restrictions
        and is\n   therefore mapped simply to the reference <rng:ref\n   name=\"example3__dozen\"/>
        and the corresponding named pattern is\n   defined as follows:\n   <rng:define
        name=\"example3__dozen\">\n     <rng:data type=\"unsignedByte\">\n       <rng:param
        name=\"minInclusive\">1</rng:param>\n       <rng:param name=\"maxInclusive\">12</rng:param>\n
        \    </rng:data>\n   </rng:define>\n   Assume now that the definition of leaf
        \"month\" is changed to:\n   leaf month {\n       type dozen {\n           range
        7..max;\n       }\n   }\n   The output RELAX NG schema then will not contain
        any named pattern\n   definition and the leaf \"month\" will be mapped directly
        to:\n   <rng:element name=\"ex3:month\">\n     <rng:data type=\"unsignedByte\">\n
        \      <rng:param name=\"minInclusive\">7</rng:param>\n       <rng:param name=\"maxInclusive\">12</rng:param>\n
        \    </rng:data>\n   </rng:element>\n   The mapping of type derivation chains
        may be further complicated by\n   the presence of the 'default' statement
        in type definitions.  In the\n   simple case, when a type definition containing
        the 'default'\n   statement is used without restrictions, the 'default' statement
        is\n   mapped to the @nma:default attribute attached to the <rng:define>\n
        \  element.\n   However, if that type definition has to be expanded due to\n
        \  restrictions, the @nma:default attribute arising from the expanded\n   type
        or ancestor types in the type derivation chain MUST be attached\n   to the
        pattern where the expansion occurs.  If there are multiple\n   'default' statements
        in consecutive steps of the type derivation,\n   only the 'default' statement
        that is closest to the expanded type is\n   used.\n   EXAMPLE.  Consider this
        variation of the last example:\n   module example3bis {\n       namespace
        \"http://example.com/ns/example3bis\";\n       prefix ex3bis;\n       typedef
        dozen {\n           type uint8 {\n               range 1..12;\n           }\n
        \          default 7;\n       }\n       leaf month {\n           type dozen;\n
        \      }\n   }\n   The 'typedef' statement in this module is mapped to the
        following\n   named pattern definition:\n   <rng:define name=\"example3bis__dozen\"
        @nma:default=\"7\">\n     <rng:data type=\"unsignedByte\">\n       <rng:param
        name=\"minInclusive\">1</rng:param>\n       <rng:param name=\"maxInclusive\">12</rng:param>\n
        \    </rng:data>\n   </rng:define>\n   If the \"dozen\" type is restricted
        when used in the leaf \"month\"\n   definition, as in the previous example,
        the \"dozen\" type has to be\n   expanded and @nma:default becomes an attribute
        of the <ex3bis:month>\n   element definition:\n   <rng:element name=\"ex3bis:month\"
        @nma:default=\"7\">\n     <rng:data type=\"unsignedByte\">\n       <rng:param
        name=\"minInclusive\">7</rng:param>\n       <rng:param name=\"maxInclusive\">12</rng:param>\n
        \    </rng:data>\n   </rng:element>\n   However, if the definition of the
        leaf \"month\" itself contained the\n   'default' substatement, the default
        specified for the \"dozen\" type\n   would be ignored.\n"
      title: 9.2.2.  Type Derivation Chains
    title: 9.2.  Mapping YANG Groupings and Typedefs
  - contents:
    - "9.3.  Translation of XPath Expressions\n   YANG uses full XPath 1.0 syntax
      [XPath] for the arguments of 'must',\n   'when', and 'path' statements.  As
      the names of data nodes defined in\n   a YANG module always belong to the namespace
      of that YANG module,\n   YANG adopted a simplification similar to the concept
      of default\n   namespace in XPath 2.0: node names in XPath expressions needn't
      carry\n   a namespace prefix inside the module where they are defined and the\n
      \  local module's namespace is assumed.\n   Consequently, all XPath expressions
      MUST be translated into a fully\n   conformant XPath 1.0 expression: every unprefixed
      node name MUST be\n   prepended with the local module's namespace prefix as
      declared by the\n   'prefix' statement.\n   XPath expressions appearing inside
      top-level groupings require\n   special attention because all unprefixed node
      names contained in them\n   must adopt the namespace of each module where the
      grouping is used\n   (cf. Section 8.2).  In order to achieve this, the local
      prefix MUST\n   be represented using the variable \"$pref\" in the hybrid schema.
      \ A\n   Schematron schema which encounters such an XPath expression then\n   supplies
      an appropriate value for this variable via a parameter to an\n   abstract pattern
      to which the YANG grouping is mapped (see\n   Section 11.2).\n   For example,
      XPath expression \"/dhcp/max-lease-time\" appearing in a\n   YANG module with
      the \"dhcp\" prefix will be translated to:\n   o  \"$pref:dhcp/$pref:max-lease-time\",
      if the expression is inside a\n      top-level grouping;\n   o  \"dhcp:dhcp/dhcp:max-lease-time\",
      otherwise.\n   YANG also uses other XPath-like expressions, namely key identifiers\n
      \  and \"descendant schema node identifiers\" (see the ABNF production for\n
      \  and \"descendant-schema-nodeid\" in Section 12 of [RFC6020]).  These\n   expressions
      MUST be translated by adding local module prefixes as\n   well.\n"
    title: 9.3.  Translation of XPath Expressions
  - contents:
    - "9.4.  YANG Language Extensions\n   YANG allows for extending its own language
      in-line by adding new\n   statements with keywords from special namespaces.
      \ Such extensions\n   first have to be declared using the 'extension' statement,
      and then\n   they can be used as the standard YANG statements, from which they
      are\n   distinguished by a namespace prefix qualifying the extension keyword.\n
      \  RELAX NG has a similar extension mechanism -- XML elements and\n   attributes
      with names from foreign namespaces may be inserted at\n   almost any place of
      a RELAX NG schema.\n   YANG language extensions may or may not have a meaning
      in the context\n   of DSDL schemas.  Therefore, an implementation MAY ignore
      any or all\n   of the extensions.  However, an extension that is not ignored
      MUST be\n   mapped to XML element(s) and/or attribute(s) that exactly match
      the\n   YIN form of the extension, see Section 11.1 in [RFC6020].\n   EXAMPLE.
      \ Consider the following extension defined by the \"acme\"\n   module:\n   extension
      documentation-flag {\n       argument number;\n   }\n   This extension can then
      be used in the same or another module, for\n   instance like this:\n   leaf
      folio {\n       acme:documentation-flag 42;\n       type string;\n   }\n   If
      this extension is honored by the mapping, it will be mapped to:\n   <rng:element
      name=\"acme:folio\">\n      <acme:documentation-flag number=\"42\"/>\n      <rng:data
      type=\"string\"/>\n   </rng:element>\n   Note that the 'extension' statement
      itself is not mapped in any way.\n"
    title: 9.4.  YANG Language Extensions
  title: 9.  Mapping YANG Data Models to the Hybrid Schema
- contents:
  - "10.  Mapping YANG Statements to the Hybrid Schema\n   Each subsection in this
    section is devoted to one YANG statement and\n   provides the specification of
    how the statement is mapped to the\n   hybrid schema.  The subsections are sorted
    alphabetically by the\n   statement keyword.\n   Each YANG statement is mapped
    to an XML fragment, typically a single\n   element or attribute, but it may also
    be a larger structure.  The\n   mapping procedure is inherently recursive, which
    means that after\n   finishing a statement the mapping continues with its substatements,\n
    \  if there are any, and a certain element of the resulting fragment\n   becomes
    the parent of other fragments resulting from the mapping of\n   substatements.
    \ Any changes to this default recursive procedure are\n   explicitly specified.\n
    \  YANG XML encoding rules translate to the following rules for ordering\n   multiple
    subelements:\n   1.  Within the <nma:rpcs> subtree (i.e., for input and output\n
    \      parameters of an RPC operation) the order of subelements is fixed\n       and
    their definitions in the hybrid schema MUST follow the order\n       specified
    in the source YANG module.\n   2.  When mapping the 'list' statement, all keys
    MUST come before any\n       other subelements and in the same order as they are
    declared in\n       the 'key' statement.  The order of the remaining (non-key)\n
    \      subelements is not specified, so their definitions in the hybrid\n       schema
    MUST be enclosed in the <rng:interleave> element.\n   3.  Otherwise, the order
    of subelements is arbitrary and,\n       consequently, all definitions of subelements
    in the hybrid schema\n       MUST be enclosed in the <rng:interleave> element.\n
    \  The following conventions are used in this section:\n   o  The argument of
    the statement being mapped is denoted by ARGUMENT.\n   o  The element in the RELAX
    NG schema that becomes the parent of the\n      resulting XML fragment is denoted
    by PARENT.\n"
  - contents:
    - "10.1.  The 'anyxml' Statement\n   This statement is mapped to the <rng:element>
      element and ARGUMENT\n   with prepended local namespace prefix becomes the value
      of its @name\n   attribute.  The contents of <rng:element> are:\n   <rng:ref
      name=\"__anyxml__\"/>\n   Substatements of the 'anyxml' statement, if any, MAY
      be mapped to\n   additional children of the <rng:element> element.\n   If at
      least one 'anyxml' statement occurs in any of the input YANG\n   modules, the
      following pattern definition MUST be added exactly once\n   to the RELAX NG
      schema as a child of the root <rng:grammar> element\n   (cf. [Vli04], p. 172):\n
      \  <rng:define name=\"__anyxml__\">\n     <rng:zeroOrMore>\n       <rng:choice>\n
      \        <rng:attribute>\n           <rng:anyName/>\n         </rng:attribute>\n
      \        <rng:element>\n           <rng:anyName/>\n           <rng:ref name=\"__anyxml__\"/>\n
      \        </rng:element>\n         <rng:text/>\n       </rng:choice>\n     </rng:zeroOrMore>\n
      \  </rng:define>\n   EXAMPLE: YANG statement in a module with namespace prefix
      \"yam\"\n   anyxml data {\n       description \"Any XML content allowed here.\";\n
      \  }\n   is mapped to the following fragment:\n   <rng:element name=\"yam:data\">\n
      \      <a:documentation>Any XML content allowed here</a:documentation>\n       <rng:ref
      name=\"__anyxml__\"/>\n   </rng:element>\n   An anyxml node is optional if there
      is no \"mandatory true;\"\n   substatement.  The <rng:element> element then
      MUST be wrapped in\n   <rng:optional>, except when the 'anyxml' statement is
      a child of the\n   'choice' statement and thus forms a shorthand case for that
      choice\n   (see Section 9.1.1 for details).\n"
    title: 10.1.  The 'anyxml' Statement
  - contents:
    - "10.2.  The 'argument' Statement\n   This statement is not mapped to the output
      schema, but see the rules\n   for handling extensions in Section 9.4.\n"
    title: 10.2.  The 'argument' Statement
  - contents:
    - "10.3.  The 'augment' Statement\n   As a substatement of 'uses', this statement
      is handled as a part of\n   'uses' mapping, see Section 10.57.\n   At the top
      level of a module or submodule, the 'augment' statement is\n   used for augmenting
      the schema tree of another YANG module.  If the\n   augmented module is not
      processed within the same mapping session,\n   the top-level 'augment' statement
      MUST be ignored.  Otherwise, the\n   contents of the statement are added to
      the foreign module with the\n   namespace of the module where the 'augment'
      statement appears.\n"
    title: 10.3.  The 'augment' Statement
  - contents:
    - "10.4.  The 'base' Statement\n   This statement is ignored as a substatement
      of 'identity' and handled\n   within the 'identityref' type if it appears as
      a substatement of that\n   type definition, see Section 10.53.6.\n"
    title: 10.4.  The 'base' Statement
  - contents:
    - "10.5.  The 'belongs-to' Statement\n   This statement is not used since the
      processing of submodules is\n   always initiated from the main module, see Section
      10.24.\n"
    title: 10.5.  The 'belongs-to' Statement
  - contents:
    - "10.6.  The 'bit' Statement\n   This statement is handled within the \"bits\"
      type, see\n   Section 10.53.4.\n"
    title: 10.6.  The 'bit' Statement
  - contents:
    - "10.7.  The 'case' Statement\n   This statement is mapped to the <rng:group>
      or <rng:interleave>\n   element, depending on whether or not the statement belongs
      to an\n   definition of an RPC operation.  If the argument of a sibling\n   'default'
      statement equals to ARGUMENT, the @nma:implicit attribute\n   with the value
      of \"true\" MUST be added to that <rng:group> or <rng:\n   interleave> element.
      \ The @nma:implicit attribute MUST NOT be used\n   for nodes at the top-level
      of a non-default case (see Section 7.9.3\n   in [RFC6020]).\n"
    title: 10.7.  The 'case' Statement
  - contents:
    - "10.8.  The 'choice' Statement\n   This statement is mapped to the <rng:choice>
      element.\n   If 'choice' has the 'mandatory' substatement with the value of\n
      \  \"true\", the attribute @nma:mandatory MUST be added to the <rng:\n   choice>
      element with the value of ARGUMENT.  This case may require\n   additional handling,
      see Section 11.2.1.  Otherwise, if \"mandatory\n   true;\" is not present, the
      <rng:choice> element MUST be wrapped in\n   <rng:optional>.\n   The alternatives
      in <rng:choice> -- mapped from either the 'case'\n   statement or a shorthand
      case -- MUST NOT be defined as optional.\n"
    title: 10.8.  The 'choice' Statement
  - contents:
    - "10.9.  The 'config' Statement\n   This statement is mapped to the @nma:config
      attribute, and ARGUMENT\n   becomes its value.\n"
    title: 10.9.  The 'config' Statement
  - contents:
    - "10.10.  The 'contact' Statement\n   This statement SHOULD NOT be used by the
      mapping since the hybrid\n   schema may be mapped from multiple YANG modules
      created by different\n   authors.  The hybrid schema contains references to
      all input modules\n   in the Dublin Core elements <dc:source>, see Section 10.34.
      \ The\n   original YANG modules are the authoritative sources of the authorship\n
      \  information.\n"
    title: 10.10.  The 'contact' Statement
  - contents:
    - "10.11.  The 'container' Statement\n   Using the rules specified in Section
      9.1.1, the mapping algorithm\n   MUST determine whether the statement defines
      an optional container,\n   and if so, insert the <rng:optional> element and
      make it the new\n   PARENT.\n   The container defined by this statement is then
      mapped to the <rng:\n   element> element, which becomes a child of PARENT and
      uses ARGUMENT\n   with prepended local namespace prefix as the value of its
      @name\n   attribute.\n   Finally, using the rules specified in Section 9.1.2,
      the mapping\n   algorithm MUST determine whether the container is implicit,
      and if\n   so, add the attribute @nma:implicit with the value of \"true\" to
      the\n   <rng:element> element.\n"
    title: 10.11.  The 'container' Statement
  - contents:
    - "10.12.  The 'default' Statement\n   If this statement is a substatement of
      'leaf', it is mapped to the\n   @nma:default attribute of PARENT and ARGUMENT
      becomes its value.\n   As a substatement of 'typedef', the 'default' statement
      is also\n   mapped to the @nma:default attribute with the value of ARGUMENT.
      \ The\n   placement of this attribute depends on whether or not the type\n   definition
      has to be expanded when it is used:\n   o  If the type definition is not expanded,
      @nma:default becomes an\n      attribute of the <rng:define> pattern resulting
      from the parent\n      'typedef' mapping.\n   o  Otherwise, @nma:default becomes
      an attribute of the ancestor RELAX\n      NG pattern inside which the expansion
      takes place.\n   Details and an example are given in Section 9.2.2.\n   Finally,
      as a substatement of 'choice', the 'default' statement\n   identifies the default
      case and is handled within the 'case'\n   statement, see Section 10.7.  If the
      default case uses the shorthand\n   notation where the 'case' statement is omitted,
      the @nma:implicit\n   attribute with the value of \"true\" is either attached
      to the node\n   representing the default case in the shorthand notation or,\n
      \  alternatively, an extra <rng:group> element MAY be inserted and the\n   @nma:implicit
      attribute attached to it.  In the latter case, the net\n   result is the same
      as if the 'case' statement wasn't omitted for the\n   default case.\n   EXAMPLE.
      \ The following 'choice' statement in a module with namespace\n   prefix \"yam\"\n
      \  choice leaves {\n       default feuille;\n       leaf feuille { type empty;
      }\n       leaf hoja { type empty; }\n   }\n   is either mapped directly to:\n
      \  <rng:choice>\n     <rng:element name=\"yam:feuille\" nma:implicit=\"true\">\n
      \      <rng:empty/>\n     </rng:element>\n     <rng:element name=\"yam:hoja\">\n
      \      <rng:empty/>\n     </rng:element/>\n   </rng:choice>\n   or the default
      case may be wrapped in an extra <rng:group>:\n   <rng:choice>\n     <rng:group
      nma:implicit=\"true\">\n       <rng:element name=\"yam:feuille\">\n         <rng:empty/>\n
      \      </rng:element>\n     </rng:group>\n     <rng:element name=\"yam:hoja\">\n
      \      <rng:empty/>\n     </rng:element/>\n   </rng:choice>\n"
    title: 10.12.  The 'default' Statement
  - contents:
    - "10.13.  The 'description' Statement\n   This statement is mapped to the DTD
      compatibility element\n   <a:documentation> and ARGUMENT becomes its text.\n
      \  In order to get properly formatted in the RELAX NG compact syntax,\n   this
      element SHOULD be inserted as the first child of PARENT.\n"
    title: 10.13.  The 'description' Statement
  - contents:
    - "10.14.  The 'deviation' Statement\n   This statement is ignored.  However,
      it is assumed that all\n   deviations are known beforehand and the corresponding
      changes have\n   already been applied to the input YANG modules.\n"
    title: 10.14.  The 'deviation' Statement
  - contents:
    - "10.15.  The 'enum' Statement\n   This statement is mapped to the <rng:value>
      element, and ARGUMENT\n   becomes its text.  All substatements except 'status'
      are ignored\n   because the <rng:value> element cannot contain annotation elements,\n
      \  see [RNG], Section 6.\n"
    title: 10.15.  The 'enum' Statement
  - contents:
    - "10.16.  The 'error-app-tag' Statement\n   This statement is ignored unless
      it is a substatement of 'must'.  In\n   the latter case, it is mapped to the
      <nma:error-app-tag> element.\n   See also Section 10.35.\n"
    title: 10.16.  The 'error-app-tag' Statement
  - contents:
    - "10.17.  The 'error-message' Statement\n   This statement is ignored unless
      it is a substatement of 'must'.  In\n   the latter case, it is mapped to the
      <nma:error-message> element.\n   See also Section 10.35.\n"
    title: 10.17.  The 'error-message' Statement
  - contents:
    - "10.18.  The 'extension' Statement\n   This statement is ignored.  However,
      extensions to the YANG language\n   MAY be mapped as described in Section 9.4.\n"
    title: 10.18.  The 'extension' Statement
  - contents:
    - "10.19.  The 'feature' Statement\n   This statement is ignored.\n"
    title: 10.19.  The 'feature' Statement
  - contents:
    - "10.20.  The 'grouping' Statement\n   This statement is mapped to a RELAX NG
      named pattern definition <rng:\n   define>, but only if the grouping defined
      by this statement is used\n   without refinements and augments in at least one
      of the input\n   modules.  In this case, the named pattern definition becomes
      a child\n   of the <rng:grammar> element and its name is ARGUMENT mangled\n
      \  according to the rules specified in Section 9.2.\n   As explained in Section
      8.2, a named pattern definition MUST be\n   placed:\n   o  as a child of the
      root <rng:grammar> element if the corresponding\n      grouping is defined at
      the top level of an input YANG module;\n   o  otherwise as a child of the embedded
      <rng:grammar> element\n      corresponding to the module in which the grouping
      is defined.\n   Whenever a grouping is used with refinements and/or augments,
      it is\n   expanded so that the refinements and augments may be applied in place\n
      \  to the prescribed schema nodes.  See Section 9.2.1 for further\n   details
      and an example.\n   An implementation MAY offer the option of mapping all 'grouping'\n
      \  statements as named pattern definitions in the output RELAX NG schema\n   even
      if they are not referenced.  This is useful for mapping YANG\n   \"library\"
      modules that typically contain only 'typedef' and/or\n   'grouping' statements.\n"
    title: 10.20.  The 'grouping' Statement
  - contents:
    - "10.21.  The 'identity' Statement\n   This statement is mapped to the following
      named pattern definition\n   which is placed as a child of the root <rng:grammar>
      element:\n   <rng:define name=\"__PREFIX_ARGUMENT\">\n     <rng:choice>\n       <rng:value
      type=\"QName\">PREFIX:ARGUMENT</rng:value>\n       <rng:ref name=\"IDENTITY1\"/>\n
      \      ...\n     </rng:choice>\n   </rng:define>\n   where:\n      PREFIX is
      the prefix used in the hybrid schema for the namespace\n      of the module
      where the current identity is defined.\n      IDENTITY1 is the name of the named
      pattern corresponding to an\n      identity that is derived from the current
      identity.  Exactly one\n      <rng:ref> element MUST be present for every such
      identity.\n   EXAMPLE ([RFC6020], Section 7.16.3).  Consider the following\n
      \  identities defined in two input YANG modules:\n   module crypto-base {\n
      \    namespace \"http://example.com/crypto-base\";\n     prefix \"crypto\";\n
      \    identity crypto-alg {\n       description\n         \"Base identity from
      which all crypto algorithms\n          are derived.\";\n       }\n   }\n   module
      des {\n     namespace \"http://example.com/des\";\n     prefix \"des\";\n     import
      \"crypto-base\" {\n       prefix \"crypto\";\n     }\n     identity des {\n
      \      base \"crypto:crypto-alg\";\n       description \"DES crypto algorithm\";\n
      \    }\n     identity des3 {\n       base \"crypto:crypto-alg\";\n       description
      \"Triple DES crypto algorithm\";\n     }\n   }\n   The identities will be mapped
      to the following named pattern\n   definitions:\n   <define name=\"__crypto_crypto-alg\">\n
      \    <choice>\n       <value type=\"QName\">crypto:crypto-alg</value>\n       <ref
      name=\"__des_des\"/>\n       <ref name=\"__des_des3\"/>\n     </choice>\n   </define>\n
      \  <define name=\"__des_des\">\n     <value type=\"QName\">des:des</value>\n
      \  </define>\n   <define name=\"__des_des3\">\n     <value type=\"QName\">des:des3</value>\n
      \  </define>\n"
    title: 10.21.  The 'identity' Statement
  - contents:
    - "10.22.  The 'if-feature' Statement\n   ARGUMENT together with arguments of
      all sibling 'if-feature'\n   statements (with added prefixes, if missing) MUST
      be collected in a\n   space-separated list that becomes the value of the @nma:if-feature\n
      \  attribute.  This attribute is attached to PARENT.\n"
    title: 10.22.  The 'if-feature' Statement
  - contents:
    - "10.23.  The 'import' Statement\n   This statement is not specifically mapped.
      \ The module whose name is\n   in ARGUMENT has to be parsed so that the importing
      module is able to\n   use its top-level groupings, typedefs and identities,
      and also\n   augment the data tree of the imported module.\n   If the 'import'
      statement has the 'revision' substatement, the\n   corresponding revision of
      the imported module MUST be used.  The\n   mechanism for finding a given module
      revision is outside the scope of\n   this document.\n"
    title: 10.23.  The 'import' Statement
  - contents:
    - "10.24.  The 'include' Statement\n   This statement is not specifically mapped.
      \ The submodule whose name\n   is in ARGUMENT has to be parsed and its contents
      mapped exactly as if\n   the submodule text appeared directly in the main module
      text.\n   If the 'include' statement has the 'revision' substatement, the\n
      \  corresponding revision of the submodule MUST be used.  The mechanism\n   for
      finding a given submodule revision is outside the scope of this\n   document.\n"
    title: 10.24.  The 'include' Statement
  - contents:
    - "10.25.  The 'input' Statement\n   This statement is handled within 'rpc' statement,
      see Section 10.50.\n"
    title: 10.25.  The 'input' Statement
  - contents:
    - "10.26.  The 'key' Statement\n   This statement is mapped to @nma:key attribute.
      \ ARGUMENT MUST be\n   translated so that every key is prefixed with the namespace
      prefix of\n   the local module.  The result of this translation then becomes
      the\n   value of the @nma:key attribute.\n"
    title: 10.26.  The 'key' Statement
  - contents:
    - "10.27.  The 'leaf' Statement\n   This statement is mapped to the <rng:element>
      element and ARGUMENT\n   with prepended local namespace prefix becomes the value
      of its @name\n   attribute.\n   If the leaf is optional, i.e., if there is no
      \"mandatory true;\"\n   substatement and the leaf is not declared among the
      keys of an\n   enclosing list, then the <rng:element> element MUST be enclosed
      in\n   <rng:optional>, except when the 'leaf' statement is a child of the\n
      \  'choice' statement and thus represents a shorthand case for that\n   choice
      (see Section 9.1.1 for details).\n"
    title: 10.27.  The 'leaf' Statement
  - contents:
    - "10.28.  The 'leaf-list' Statement\n   This statement is mapped to a block enclosed
      by either the <rng:\n   zeroOrMore> or the <rng:oneOrMore> element depending
      on whether the\n   argument of 'min-elements' substatement is \"0\" or positive,\n
      \  respectively (it is zero by default).  This <rng:zeroOrMore> or <rng:\n   oneOrMore>
      element becomes the PARENT.\n   <rng:element> is then added as a child element
      of PARENT and ARGUMENT\n   with prepended local namespace prefix becomes the
      value of its @name\n   attribute.  Another attribute, @nma:leaf-list, MUST also
      be added to\n   this <rng:element> element with the value of \"true\".  If the
      'leaf-\n   list' statement has the 'min-elements' substatement and its argument\n
      \  is greater than one, additional attribute @nma:min-elements is\n   attached
      to <rng:element> and the argument of 'min-elements' becomes\n   the value of
      this attribute.  Similarly, if there is the 'max-\n   elements' substatement
      and its argument value is not \"unbounded\",\n   attribute @nma:max-elements
      is attached to this element and the\n   argument of 'max-elements' becomes the
      value of this attribute.\n   EXAMPLE.  Consider the following 'leaf-list' appearing
      in a module\n   with the namespace prefix \"yam\":\n   leaf-list foliage {\n
      \      min-elements 3;\n       max-elements 6378;\n       ordered-by user;\n
      \      type string;\n   }\n   It is mapped to the following RELAX NG fragment:\n
      \  <rng:oneOrMore>\n     <rng:element name=\"yam:foliage\" nma:leaf-list=\"true\"\n
      \                 nma:ordered-by=\"user\"\n                  nma:min-elements=\"3\"
      nma:max-elements=\"6378\">\n       <rng:data type=\"string\"/>\n     </rng:element>\n
      \  </rng:oneOrMore>\n"
    title: 10.28.  The 'leaf-list' Statement
  - contents:
    - "10.29.  The 'length' Statement\n   This statement is handled within the \"string\"
      type, see\n   Section 10.53.10.\n"
    title: 10.29.  The 'length' Statement
  - contents:
    - "10.30.  The 'list' Statement\n   This statement is mapped exactly as the 'leaf-list'
      statement, see\n   Section 10.28.  The only difference is that the @nma:leaf-list\n
      \  annotation either MUST NOT be present or MUST have the value of\n   \"false\".\n
      \  When mapping the substatements of 'list', the order of children of\n   the
      list element MUST be specified so that list keys, if there are\n   any, always
      appear in the same order as they are defined in the 'key'\n   substatement and
      before other children, see [RFC6020], Section 7.8.5.\n   In particular, if a
      list key is defined in a grouping but the list\n   node itself is not a part
      of the same grouping, and the position of\n   the 'uses' statement would violate
      the above ordering requirement,\n   the grouping MUST be expanded, i.e., the
      'uses' statement replaced by\n   the grouping contents.\n   For example, consider
      the following YANG fragment of a module with\n   the prefix \"yam\":\n   grouping
      keygrp {\n     leaf clef {\n       type uint8;\n     }\n   }\n   list foo {\n
      \    key clef;\n     leaf bar {\n       type string;\n     }\n     leaf baz
      {\n       type string;\n     }\n     uses keygrp;\n   }\n   It is mapped to
      the following RELAX NG fragment:\n   <rng:zeroOrMore>\n     <rng:element name=\"yam:foo\"
      nma:key=\"yam:clef\">\n       <rng:element name=\"yam:clef\">\n         <rng:data
      type=\"unsignedByte\"/>\n       </rng:element>\n       <rng:interleave>\n         <rng:element
      name=\"yam:bar\">\n           <rng:data type=\"string\"/>\n         </rng:element>\n
      \        <rng:element name=\"yam:baz\">\n           <rng:data type=\"string\"/>\n
      \        </rng:element>\n       </rng:interleave>\n     </rng:element>\n   </rng:zeroOrMore>\n
      \  Note that the \"keygrp\" grouping is expanded and the definition of\n   \"yam:clef\"
      is moved before the <rng:interleave> pattern.\n"
    title: 10.30.  The 'list' Statement
  - contents:
    - "10.31.  The 'mandatory' Statement\n   This statement may appear as a substatement
      of 'leaf', 'choice', or\n   'anyxml' statement.  If ARGUMENT is \"true\", the
      parent data node is\n   mapped as mandatory, see Section 9.1.1.\n   As a substatement
      of 'choice', this statement is also mapped to the\n   @nma:mandatory attribute,
      which is added to PARENT.  The value of\n   this attribute is the argument of
      the parent 'choice' statement.\n"
    title: 10.31.  The 'mandatory' Statement
  - contents:
    - "10.32.  The 'max-elements' Statement\n   This statement is handled within 'leaf-list'
      or 'list' statements,\n   see Section 10.28.\n"
    title: 10.32.  The 'max-elements' Statement
  - contents:
    - "10.33.  The 'min-elements' Statement\n   This statement is handled within 'leaf-list'
      or 'list' statements,\n   see Section 10.28.\n"
    title: 10.33.  The 'min-elements' Statement
  - contents:
    - "10.34.  The 'module' Statement\n   This statement is mapped to an embedded
      <rng:grammar> pattern having\n   the @nma:module attribute with the value of
      ARGUMENT.  In addition, a\n   <dc:source> element SHOULD be created as a child
      of this <rng:\n   grammar> element and contain ARGUMENT as a metadata reference
      to the\n   input YANG module.  See also Section 10.49.\n   Substatements of
      the 'module' statement MUST be mapped so that:\n   o  statements representing
      configuration/state data are mapped to\n      descendants of the <nma:data>
      element;\n   o  statements representing the contents of RPC requests or replies\n
      \     are mapped to descendants of the <nma:rpcs> element;\n   o  statements
      representing the contents of event notifications are\n      mapped to descendants
      of the <nma:notifications> element.\n"
    title: 10.34.  The 'module' Statement
  - contents:
    - "10.35.  The 'must' Statement\n   This statement is mapped to the <nma:must>
      element.  It has one\n   mandatory attribute @assert (with no namespace) that
      contains\n   ARGUMENT transformed into a valid XPath expression (see Section
      9.3).\n   The <nma:must> element may have other subelements resulting from\n
      \  mapping the 'error-app-tag' and 'error-message' substatements.  Other\n   substatements
      of 'must', i.e., 'description' and 'reference', are\n   ignored.\n   EXAMPLE.
      \ YANG statement in the \"dhcp\" module\n   must 'current() <= ../max-lease-time'
      {\n       error-message\n           \"The default-lease-time must be less than
      max-lease-time\";\n   }\n   is mapped to:\n   <nma:must assert=\"current()&lt;=../dhcp:max-lease-time\">\n
      \    <nma:error-message>\n       The default-lease-time must be less than max-lease-time\n
      \    </nma:error-message>\n   </nma:must>\n"
    title: 10.35.  The 'must' Statement
  - contents:
    - "10.36.  The 'namespace' Statement\n   This statement is mapped simultaneously
      in two ways:\n   1.  to the @xmlns:PREFIX attribute of the root <rng:grammar>
      element\n       where PREFIX is the namespace prefix specified by the sibling\n
      \      'prefix' statement.  ARGUMENT becomes the value of this\n       attribute;\n
      \  2.  to the @ns attribute of PARENT, which is an embedded <rng:\n       grammar>
      pattern.  ARGUMENT becomes the value of this attribute.\n"
    title: 10.36.  The 'namespace' Statement
  - contents:
    - "10.37.  The 'notification' Statement\n   This statement is mapped to the following
      subtree of the <nma:\n   notifications> element in the hybrid schema (where
      PREFIX is the\n   prefix of the local YANG module):\n   <nma:notification>\n
      \    <rng:element name=\"PREFIX:ARGUMENT\">\n       ...\n     </rng:element>\n
      \  </nma:notification>\n   Substatements of 'notification' are mapped under
      <rng:element\n   name=\"PREFIX:ARGUMENT\">.\n"
    title: 10.37.  The 'notification' Statement
  - contents:
    - "10.38.  The 'ordered-by' Statement\n   This statement is mapped to @nma:ordered-by
      attribute and ARGUMENT\n   becomes the value of this attribute.  See Section
      10.28 for an\n   example.\n"
    title: 10.38.  The 'ordered-by' Statement
  - contents:
    - "10.39.  The 'organization' Statement\n   This statement is ignored by the mapping
      because the hybrid schema\n   may be mapped from multiple YANG modules authored
      by different\n   parties.  The hybrid schema SHOULD contain references to all
      input\n   modules in the Dublin Core <dc:source> elements, see Section 10.34.\n
      \  The original YANG modules are the authoritative sources of the\n   authorship
      information.\n"
    title: 10.39.  The 'organization' Statement
  - contents:
    - "10.40.  The 'output' Statement\n   This statement is handled within the 'rpc'
      statement, see\n   Section 10.50.\n"
    title: 10.40.  The 'output' Statement
  - contents:
    - "10.41.  The 'path' Statement\n   This statement is handled within the \"leafref\"
      type, see\n   Section 10.53.8.\n"
    title: 10.41.  The 'path' Statement
  - contents:
    - "10.42.  The 'pattern' Statement\n   This statement is handled within the \"string\"
      type, see\n   Section 10.53.10.\n"
    title: 10.42.  The 'pattern' Statement
  - contents:
    - "10.43.  The 'position' Statement\n   This statement is ignored.\n"
    title: 10.43.  The 'position' Statement
  - contents:
    - "10.44.  The 'prefix' Statement\n   This statement is handled within the sibling
      'namespace' statement,\n   see Section 10.36, or within the parent 'import'
      statement, see\n   Section 10.23.  As a substatement of 'belongs-to' (in submodules),\n
      \  the 'prefix' statement is ignored.\n"
    title: 10.44.  The 'prefix' Statement
  - contents:
    - "10.45.  The 'presence' Statement\n   This statement influences the mapping
      of the parent container\n   (Section 10.11): the parent container definition
      MUST be wrapped in\n   <rng:optional>, regardless of its contents.  See also
      Section 9.1.1.\n"
    title: 10.45.  The 'presence' Statement
  - contents:
    - "10.46.  The 'range' Statement\n   This statement is handled within numeric
      types, see Section 10.53.9.\n"
    title: 10.46.  The 'range' Statement
  - contents:
    - "10.47.  The 'reference' Statement\n   This statement is mapped to <a:documentation>
      element and its text is\n   set to ARGUMENT prefixed with \"See: \".\n"
    title: 10.47.  The 'reference' Statement
  - contents:
    - "10.48.  The 'require-instance' Statement\n   This statement is handled within
      \"instance-identifier\" type\n   (Section 10.53.7).\n"
    title: 10.48.  The 'require-instance' Statement
  - contents:
    - "10.49.  The 'revision' Statement\n   The mapping uses only the most recent
      instance of the 'revision'\n   statement, i.e., one with the latest date in
      ARGUMENT, which\n   specifies the current revision of the input YANG module
      [RFC6020].\n   This date SHOULD be recorded, together with the name of the YANG\n
      \  module, in the corresponding Dublin Core <dc:source> element (see\n   Section
      10.34), for example in this form:\n   <dc:source>YANG module 'foo', revision
      2010-03-02</dc:source>\n   The 'description' substatement of 'revision' is ignored.\n"
    title: 10.49.  The 'revision' Statement
  - contents:
    - "10.50.  The 'rpc' Statement\n   This statement is mapped to the following subtree
      in the RELAX NG\n   schema (where PREFIX is the prefix of the local YANG module):\n
      \  <nma:rpc>\n     <nma:input>\n       <rng:element name=\"PREFIX:ARGUMENT\">\n
      \        ... mapped contents of 'input' ...\n       </rng:element>\n     </nma:input>\n
      \    <nma:output\">\n       ... mapped contents of 'output' ...\n     </nma:output>\n
      \  </nma:rpc>\n   As indicated in the schema fragment, contents of the 'input'\n
      \  substatement (if any) are mapped under <rng:element name=\"PREFIX:\n   ARGUMENT\">.
      \ Similarly, contents of the 'output' substatement are\n   mapped under <nma:output>.
      \ If there is no 'output' substatement, the\n   <nma:output> element MUST NOT
      be present.\n   The <nma:rpc> element is a child of <nma:rpcs>.\n"
    title: 10.50.  The 'rpc' Statement
  - contents:
    - "10.51.  The 'status' Statement\n   This statement MAY be ignored.  Otherwise,
      it is mapped to @nma:\n   status attribute and ARGUMENT becomes its value.\n"
    title: 10.51.  The 'status' Statement
  - contents:
    - "10.52.  The 'submodule' Statement\n   This statement is not specifically mapped.
      \ Its substatements are\n   mapped as if they appeared directly in the module
      to which the\n   submodule belongs.\n"
    title: 10.52.  The 'submodule' Statement
  - contents:
    - "10.53.  The 'type' Statement\n   Most YANG built-in data types have an equivalent
      in the XSD data type\n   library [XSD-D] as shown in Table 4.\n      +-----------+---------------+--------------------------------+\n
      \     | YANG type | XSD type      | Meaning                        |\n      +-----------+---------------+--------------------------------+\n
      \     | int8      | byte          | 8-bit integer value            |\n      |
      \          |               |                                |\n      | int16
      \    | short         | 16-bit integer value           |\n      |           |
      \              |                                |\n      | int32     | int           |
      32-bit integer value           |\n      |           |               |                                |\n
      \     | int64     | long          | 64-bit integer value           |\n      |
      \          |               |                                |\n      | uint8
      \    | unsignedByte  | 8-bit unsigned integer value   |\n      |           |
      \              |                                |\n      | uint16    | unsignedShort
      | 16-bit unsigned integer value  |\n      |           |               |                                |\n
      \     | uint32    | unsignedInt   | 32-bit unsigned integer value  |\n      |
      \          |               |                                |\n      | uint64
      \   | unsignedLong  | 64-bit unsigned integer value  |\n      |           |
      \              |                                |\n      | string    | string
      \       | character string               |\n      |           |               |
      \                               |\n      | binary    | base64Binary  | binary
      data in base64 encoding |\n      +-----------+---------------+--------------------------------+\n
      \    Table 4: YANG built-in data types with equivalents in the W3C XML\n                            Schema
      Type Library\n   Two important data types of the XSD data type library -- \"dateTime\"\n
      \  and \"anyURI\" -- are not built-in types in YANG but instead are\n   defined
      as derived types in the standard modules [RFC6021]: \"date-\n   and-time\" in
      the \"ietf-yang-types\" module and \"uri\" in the \"ietf-\n   inet-types\" module.
      \ However, the formal restrictions in the YANG\n   type definitions are rather
      weak.  Therefore, implementations of the\n   YANG-to-DSDL mapping SHOULD detect
      these derived types in source YANG\n   modules and map them to \"dateType\"
      and \"anyURI\", respectively.\n   Details about the mapping of individual YANG
      built-in types are given\n   in the following subsections.\n"
    - contents:
      - "10.53.1.  The \"empty\" Type\n   This type is mapped to <rng:empty/>.\n"
      title: 10.53.1.  The "empty" Type
    - contents:
      - "10.53.2.  The \"boolean\" Type\n   This built-in type does not allow any
        restrictions and is mapped to\n   the following XML fragment:\n   <rng:choice>\n
        \    <rng:value>true</rng:value>\n     <rng:value>false</rng:value>\n   </rng:choice>\n
        \  Note that the XSD \"boolean\" type cannot be used here because it\n   allows,
        unlike YANG, an alternative numeric representation of boolean\n   values:
        0 for \"false\" and 1 for \"true\".\n"
      title: 10.53.2.  The "boolean" Type
    - contents:
      - "10.53.3.  The \"binary\" Type\n   This built-in type does not allow any restrictions
        and is mapped\n   simply by inserting an <rng:data> element whose @type attribute
        value\n   is set to \"base64Binary\" (see also Table 4).\n"
      title: 10.53.3.  The "binary" Type
    - contents:
      - "10.53.4.  The \"bits\" Type\n   This type is mapped to the <rng:list> and
        for each 'bit' substatement\n   the following XML fragment is inserted as
        a child of <rng:list>:\n   <rng:optional>\n     <rng:value>bit_name</rng:value>\n
        \  </rng:optional>\n   where bit_name is the name of the bit as found in the
        argument of a\n   'bit' substatement.\n"
      title: 10.53.4.  The "bits" Type
    - contents:
      - "10.53.5.  The \"enumeration\" and \"union\" Types\n   These types are mapped
        to the <rng:choice> element.\n"
      title: 10.53.5.  The "enumeration" and "union" Types
    - contents:
      - "10.53.6.  The \"identityref\" Type\n   This type is mapped to the following
        named pattern reference:\n   <rng:ref name=\"__PREFIX_BASE\"/>\n   where PREFIX:BASE
        is the qualified name of the identity appearing in\n   the argument of the
        'base' substatement.\n   For example, assume that module \"des\" in Section
        10.21 contains the\n   following leaf definition:\n   leaf foo {\n     type
        identityref {\n       base crypto:crypto-alg;\n     }\n   }\n   This leaf
        would then be mapped to the following element pattern:\n   <element name=\"des:foo\">\n
        \    <ref name=\"__crypto_crypto-alg\"/>\n   </element>\n"
      title: 10.53.6.  The "identityref" Type
    - contents:
      - "10.53.7.  The \"instance-identifier\" Type\n   This type is mapped to <rng:data>
        element with @type attribute set to\n   \"string\".  In addition, an empty
        <nma:instance-identifier> element\n   MUST be inserted as a child of PARENT.\n
        \  The argument of the 'require-instance' substatement, if it exists,\n   becomes
        the value of the @require-instance attribute of the <nma:\n   instance-identifier>
        element.\n"
      title: 10.53.7.  The "instance-identifier" Type
    - contents:
      - "10.53.8.  The \"leafref\" Type\n   This type is mapped exactly as the type
        of the leaf given in the\n   argument of 'path' substatement.  However, if
        the type of the\n   referred leaf defines a default value, this default value
        MUST be\n   ignored by the mapping.\n   In addition, @nma:leafref attribute
        MUST be added to PARENT.  The\n   argument of the 'path' substatement, translated
        according to\n   Section 9.3, is set as the value of this attribute.\n"
      title: 10.53.8.  The "leafref" Type
    - contents:
      - "10.53.9.  The Numeric Types\n   YANG built-in numeric types are \"int8\",
        \"int16\", \"int32\", \"int64\",\n   \"uint8\", \"uint16\", \"uint32\", \"uint64\",
        and \"decimal64\".  They are\n   mapped to the <rng:data> element with the
        @type attribute set to\n   ARGUMENT translated according to Table 4 above.\n
        \  An exception is the \"decimal64\" type, which is mapped to the\n   \"decimal\"
        type of the XSD data type library.  Its precision and\n   number of fractional
        digits are controlled with the following facets,\n   which MUST always be
        present:\n   o  \"totalDigits\" facet set to the value of 19.\n   o  \"fractionDigits\"
        facet set to the argument of the 'fraction-\n      digits' substatement.\n
        \  The fixed value of \"totalDigits\" corresponds to the maximum of 19\n   decimal
        digits for 64-bit integers.\n   For example, the statement:\n   type decimal64
        {\n       fraction-digits 2;\n   }\n   is mapped to the following RELAX NG
        data type:\n   <rng:data type=\"decimal\">\n     <rng:param name=\"totalDigits\">19</rng:param>\n
        \    <rng:param name=\"fractionDigits\">2</rng:param>\n   </rng:data>\n   All
        numeric types support the 'range' restriction, which is mapped as\n   follows:\n
        \  If the range expression consists of just a single range LO..HI, then\n
        \  it is mapped to a pair of data type facets:\n         <rng:param name=\"minInclusive\">LO</rng:param>\n
        \  and\n          <rng:param name=\"maxInclusive\">HI</rng:param>\n   If the
        range consists of a single number, the values of both facets\n   are set to
        this value.  If LO is equal to the string \"min\", the\n   \"minInclusive\"
        facet is omitted.  If HI is equal to the string \"max\",\n   the \"maxInclusive\"
        facet is omitted.\n   If the range expression has multiple parts separated
        by \"|\", then the\n   parent <rng:data> element must be repeated once for
        every range part\n   and all such <rng:data> elements are wrapped in <rng:choice>
        element.\n   Each <rng:data> element contains the \"minInclusive\" and\n   \"maxInclusive\"
        facets for one part of the range expression as\n   described in the previous
        paragraph.\n   For the \"decimal64\" type, the \"totalDigits\" and \"fractionDigits\"
        must\n   be repeated inside each of the <rng:data> elements.\n   For example,\n
        \  type int32 {\n       range \"-6378..0|42|100..max\";\n   }\n   is mapped
        to the following RELAX NG fragment:\n   <rng:choice>\n     <rng:data type=\"int\">\n
        \      <rng:param name=\"minInclusive\">-6378</rng:param>\n       <rng:param
        name=\"maxInclusive\">0</rng:param>\n     </rng:data>\n     <rng:data type=\"int\">\n
        \      <rng:param name=\"minInclusive\">42</rng:param>\n       <rng:param
        name=\"maxInclusive\">42</rng:param>\n     </rng:data>\n     <rng:data type=\"int\">\n
        \      <rng:param name=\"minInclusive\">100</rng:param>\n     </rng:data>\n
        \  </rng:choice>\n   See Section 9.2.2 for further details on mapping the
        restrictions.\n"
      title: 10.53.9.  The Numeric Types
    - contents:
      - "10.53.10.  The \"string\" Type\n   This type is mapped to the <rng:data>
        element with the @type\n   attribute set to \"string\".\n   The 'length' restriction
        is handled analogically to the 'range'\n   restriction for the numeric types
        (Section 10.53.9):\n   If the length expression has just a single range:\n
        \  o  and if the length range consists of a single number LENGTH, the\n      following
        data type facet is inserted:\n         <rng:param name=\"length\">LENGTH</rng:param>.\n
        \  o  if the length range is of the form LO..HI, i.e., it consists of\n      both
        the lower and upper bound.  The following two data type\n      facets are
        then inserted:\n         <rng:param name=\"minLength\">LO</rng:param>\n   and\n
        \        <rng:param name=\"maxLength\">HI</rng:param>\n   If LO is equal to
        the string \"min\", the \"minLength\" facet is omitted.\n   If HI is equal
        to the string \"max\", the \"maxLength\" facet is omitted.\n   If the length
        expression has of multiple parts separated by \"|\", then\n   the parent <rng:data>
        element must be repeated once for every range\n   part and all such <rng:data>
        elements are wrapped in <rng:choice>\n   element.  Each <rng:data> element
        contains the \"length\" or\n   \"minLength\" and \"maxLength\" facets for
        one part of the length\n   expression as described in the previous paragraph.\n
        \  Every 'pattern' restriction of the \"string\" data type is mapped to\n
        \  the \"pattern\" facet:\n   <rng:param name=\"pattern\">...</rng:param>\n
        \  with text equal to the argument of the 'pattern' statement.  All such\n
        \  \"pattern\" facets must be repeated inside each copy of the <rng:data>\n
        \  element, i.e., once for each length range.\n   For example,\n   type string
        {\n       length \"1|3..8\";\n       pattern \"[A-Z][a-z]*\";\n   }\n   is
        mapped to the following RELAX NG fragment:\n   <rng:choice>\n     <rng:data
        type=\"string\">\n       <rng:param name=\"length\">1</rng:param>\n       <rng:param
        name=\"pattern\">[A-Z][a-z]*</rng:param>\n     </rng:data>\n     <rng:data
        type=\"string\">\n       <rng:param name=\"minLength\">3</rng:param>\n       <rng:param
        name=\"maxLength\">8</rng:param>\n       <rng:param name=\"pattern\">[A-Z][a-z]*</rng:param>\n
        \    </rng:data>\n   </rng:choice>\n"
      title: 10.53.10.  The "string" Type
    - contents:
      - "10.53.11.  Derived Types\n   If the 'type' statement refers to a derived
        type, it is mapped in one\n   of the following ways depending on whether it
        contains any\n   restrictions as its substatements:\n   1.  Without restrictions,
        the 'type' statement is mapped simply to\n       the <rng:ref> element, i.e.,
        a reference to a named pattern.  If\n       the RELAX NG definition of this
        named pattern has not been added\n       to the hybrid schema yet, the corresponding
        type definition MUST\n       be found and its mapping installed as a subelement
        of either the\n       root or an embedded <rng:grammar> element, see Section
        10.54.\n       Even if a given derived type is used more than once in the
        input\n       YANG modules, the mapping of the corresponding 'typedef' MUST
        be\n       installed only once.\n   2.  If any restrictions are present, the
        ancestor built-in type for\n       the given derived type must be determined
        and the mapping of this\n       base type MUST be used.  Restrictions appearing
        at all stages of\n       the type derivation chain MUST be taken into account
        and their\n       conjunction added to the <rng:data> element that defines
        the\n       basic type.\n   See Section 9.2.2 for more details and an example.\n"
      title: 10.53.11.  Derived Types
    title: 10.53.  The 'type' Statement
  - contents:
    - "10.54.  The 'typedef' Statement\n   This statement is mapped to a RELAX NG
      named pattern definition <rng:\n   define>, but only if the type defined by
      this statement is used\n   without restrictions in at least one of the input
      modules.  In this\n   case, the named pattern definition becomes a child of
      either the root\n   or an embedded <rng:grammar> element, depending on whether
      or not the\n   'typedef' statement appears at the top level of a YANG module.
      \ The\n   name of this named pattern definition is set to ARGUMENT mangled\n
      \  according to the rules specified in Section 9.2.\n   Whenever a derived type
      is used with additional restrictions, the\n   ancestor built-in type for the
      derived type is used instead with\n   restrictions (facets) that are a combination
      of all restrictions\n   specified along the type derivation chain.  See Section
      10.53.11 for\n   further details and an example.\n   An implementation MAY offer
      the option of recording all 'typedef'\n   statements as named patterns in the
      output RELAX NG schema even if\n   they are not referenced.  This is useful
      for mapping YANG \"library\"\n   modules containing only 'typedef' and/or 'grouping'
      statements.\n"
    title: 10.54.  The 'typedef' Statement
  - contents:
    - "10.55.  The 'unique' Statement\n   This statement is mapped to the @nma:unique
      attribute.  ARGUMENT MUST\n   be translated so that every node identifier in
      each of its components\n   is prefixed with the namespace prefix of the local
      module, unless the\n   prefix is already present.  The result of this translation
      then\n   becomes the value of the @nma:unique attribute.\n   For example, assuming
      that the local module prefix is \"ex\",\n   unique \"foo ex:bar/baz\"\n   is
      mapped to the following attribute/value pair:\n   nma:unique=\"ex:foo ex:bar/ex:baz\"\n"
    title: 10.55.  The 'unique' Statement
  - contents:
    - "10.56.  The 'units' Statement\n   This statement is mapped to the @nma:units
      attribute and ARGUMENT\n   becomes its value.\n"
    title: 10.56.  The 'units' Statement
  - contents:
    - "10.57.  The 'uses' Statement\n   If this statement has neither 'refine' nor
      'augment' substatements,\n   it is mapped to the <rng:ref> element, i.e., a
      reference to a named\n   pattern, and the value of its @name attribute is set
      to ARGUMENT\n   mangled according to Section 9.2.  If the RELAX NG definition
      of the\n   referenced named pattern has not been added to the hybrid schema
      yet,\n   the corresponding grouping MUST be found and its mapping installed
      as\n   a subelement of <rng:grammar>, see Section 10.20.\n   Otherwise, if the
      'uses' statement has any 'refine' or 'augment'\n   substatements, the corresponding
      grouping must be looked up and its\n   contents inserted under PARENT.  See
      Section 9.2.1 for further\n   details and an example.\n"
    title: 10.57.  The 'uses' Statement
  - contents:
    - "10.58.  The 'value' Statement\n   This statement is ignored.\n"
    title: 10.58.  The 'value' Statement
  - contents:
    - "10.59.  The 'when' Statement\n   This statement is mapped to the @nma:when
      attribute and ARGUMENT,\n   translated according to Section 9.3, becomes it
      value.\n"
    title: 10.59.  The 'when' Statement
  - contents:
    - "10.60.  The 'yang-version' Statement\n   This statement is not mapped to the
      output schema.  However, an\n   implementation SHOULD check that it is compatible
      with the YANG\n   version declared by the statement (currently version 1).  In
      the case\n   of a mismatch, the implementation SHOULD report an error and\n
      \  terminate.\n"
    title: 10.60.  The 'yang-version' Statement
  - contents:
    - "10.61.  The 'yin-element' Statement\n   This statement is not mapped to the
      output schema, but see the rules\n   for extension handling in Section 9.4.\n"
    title: 10.61.  The 'yin-element' Statement
  title: 10.  Mapping YANG Statements to the Hybrid Schema
- contents:
  - "11.  Mapping the Hybrid Schema to DSDL\n   As explained in Section 6, the second
    step of the YANG-to-DSDL\n   mapping takes the hybrid schema and transforms it
    to various DSDL\n   schemas capable of validating instance XML documents.  As
    an input\n   parameter, this step takes, in the simplest case, just a\n   specification
    of the NETCONF XML document type that is to be\n   validated.  These document
    types can be, for example, the contents of\n   a datastore, a reply to <nc:get>
    or <nc:get-config>, contents of\n   other RPC requests/replies and event notifications,
    and so on.\n   The second mapping step has to accomplish the following three general\n
    \  tasks:\n   1.  Extract the parts of the hybrid schema that are appropriate
    for\n       the requested document type.  For example, if a <nc:get> reply is\n
    \      to be validated, the subtree under <nma:data> has to be selected.\n   2.
    \ The schema must be adapted to the specific encapsulating XML\n       elements
    mandated by the RPC layer.  These are, for example, <nc:\n       rpc> and <nc:data>
    elements in the case of a <nc:get> reply or\n       <en:notification> for a notification.\n
    \  3.  Finally, NETMOD-specific annotations that are relevant for the\n       schema
    language of the generated schema must be mapped to the\n       corresponding patterns
    or rules.\n   These three tasks are together much simpler than the first mapping\n
    \  step and can be effectively implemented using XSL transformations\n   [XSLT].\n
    \  The following subsections describe the details of the second mapping\n   step
    for the individual DSDL schema languages.  Section 12 then\n   contains a detailed
    specification for the mapping of all NETMOD-\n   specific annotations.\n"
  - contents:
    - "11.1.  Generating RELAX NG Schemas for Various Document Types\n   With one
      minor exception, obtaining a validating RELAX NG schema from\n   the hybrid
      schema only means taking appropriate parts of the hybrid\n   schema and assembling
      them in a new RELAX NG grammar, perhaps after\n   removing all unwanted annotations.\n
      \  The structure of the resulting RELAX NG schema is similar to that of\n   the
      hybrid schema: the root grammar contains embedded grammars, one\n   for each
      input YANG module.  However, as explained in Section 8.2,\n   global named pattern
      definitions (children of the root <rng:grammar>\n   element) MUST be moved to
      a separate schema file.\n   Depending on the XML document type that is the target
      for validation,\n   such as <nc:get> or <nc:get-config> reply, RPC operations
      or\n   notifications, patterns defining corresponding top-level information\n
      \  items MUST be added, such as <nc:rpc-reply> with the @message-id\n   attribute
      and so on.\n   In order to avoid copying common named pattern definitions for
      common\n   NETCONF elements and attributes to every single output RELAX NG file,\n
      \  such schema-independent definitions SHOULD be collected in a library\n   file
      that is then included by the validating RELAX NG schemas.\n   Appendix B has
      the listing of such a library file.\n   The minor exception mentioned above
      is the annotation @nma:config,\n   which must be observed if the target document
      type is a reply to <nc:\n   get-config>.  In this case, each element definition
      that has this\n   attribute with the value of \"false\" MUST be removed from
      the schema\n   together with its descendants.  See Section 12.1 for more details.\n"
    title: 11.1.  Generating RELAX NG Schemas for Various Document Types
  - contents:
    - "11.2.  Mapping Semantic Constraints to Schematron\n   Schematron schemas tend
      to be much flatter and more uniform compared\n   to RELAX NG.  They have exactly
      four levels of XML hierarchy: <sch:\n   schema>, <sch:pattern>, <sch:rule>,
      and <sch:assert> or <sch:report>.\n   In a Schematron schema generated by the
      second mapping step, the\n   basic unit of organization is a rule represented
      by the <sch:rule>\n   element.  The following NETMOD-specific annotations from
      the hybrid\n   schema (henceforth called \"semantic annotations\") are mapped
      to\n   corresponding Schematron rules: <nma:must>, @nma:key, @nma:unique,\n
      \  @nma:max-elements, @nma:min-elements, @nma:when, @nma:leafref, @nma:\n   leaf-list,
      and also @nma:mandatory appearing as an attribute of <rng:\n   choice> (see
      Section 11.2.1).\n   Each input YANG module is mapped to a Schematron pattern
      whose @id\n   attribute is set to the module name.  Every <rng:element> pattern\n
      \  containing at least one of the above-mentioned semantic annotations\n   is
      then mapped to a Schematron rule:\n   <sch:rule context=\"XELEM\">\n     ...\n
      \  </sch:rule>\n   The value of the mandatory @context attribute of <sch:rule>
      (denoted\n   as XELEM) MUST be set to the absolute path of the context element
      in\n   the data tree.  The <sch:rule> element contains the mappings of all\n
      \  contained semantic annotations in the form of Schematron asserts or\n   reports.\n
      \  Semantic annotations appearing inside a named pattern definition\n   (i.e.,
      having <rng:define> among its ancestors) require special\n   treatment because
      they may be potentially used in different contexts.\n   This is accomplished
      by using Schematron abstract patterns that use\n   the \"$pref\" variable in
      place of the local namespace prefix.  The\n   value of the @id attribute of
      such an abstract pattern MUST be set to\n   the name of the named pattern definition
      that is being mapped (i.e.,\n   the mangled name of the original YANG grouping).\n
      \  When the abstract pattern is instantiated, the values of the\n   following
      two parameters MUST be provided:\n   o  pref: the actual namespace prefix,\n
      \  o  start: XPath expression defining the context in which the grouping\n      is
      used.\n   EXAMPLE.  Consider the following YANG module:\n   module example4
      {\n     namespace \"http://example.com/ns/example4\";\n     prefix ex4;\n     uses
      sorted-leaf-list;\n     grouping sorted-leaf-list {\n       leaf-list sorted-entry
      {\n         must \"not(preceding-sibling::sorted-entry > .)\" {\n           error-message
      \"Entries must appear in ascending order.\";\n         }\n         type uint8;\n
      \      }\n     }\n   }\n   The resulting Schematron schema for a reply to <nc:get>
      is then as\n   follows:\n   <?xml version=\"1.0\" encoding=\"utf-8\"?>\n   <sch:schema
      xmlns:sch=\"http://purl.oclc.org/dsdl/schematron\">\n     <sch:ns uri=\"http://example.com/ns/example4\"
      prefix=\"ex4\"/>\n     <sch:ns uri=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n
      \            prefix=\"nc\"/>\n     <sch:pattern abstract=\"true\"\n                  id=\"_example4__sorted-leaf-list\">\n
      \      <sch:rule context=\"$start/$pref:sorted-entry\">\n         <sch:report\n
      \            test=\". = preceding-sibling::$pref:sorted-entry\">\n           Duplicate
      leaf-list entry \"<sch:value-of select=\".\"/>\".\n         </sch:report>\n
      \        <sch:assert\n             test=\"not(preceding-sibling::$pref:sorted-entry
      &gt; .)\">\n           Entries must appear in ascending order.\n         </sch:assert>\n
      \      </sch:rule>\n     </sch:pattern>\n     <sch:pattern id=\"example4\"/>\n
      \    <sch:pattern id=\"id2573371\" is-a=\"_example4__sorted-leaf-list\">\n       <sch:param
      name=\"start\" value=\"/nc:rpc-reply/nc:data\"/>\n       <sch:param name=\"pref\"
      value=\"ex4\"/>\n     </sch:pattern>\n   </sch:schema>\n   The \"sorted-leaf-list\"
      grouping from the input module is mapped to an\n   abstract pattern with an
      @id value of \"_example4__sorted-leaf-list\"\n   in which the 'must' statement
      corresponds to the <sch:assert>\n   element.  The abstract pattern is the instantiated
      by the pattern\n   with an @id value of \"id2573371\", which sets the \"start\"
      and \"pref\"\n   parameters to appropriate values.\n   Note that another Schematron
      element, <sch:report>, was automatically\n   added, checking for duplicate leaf-list
      entries.\n   The mapping from the hybrid schema to Schematron proceeds in the\n
      \  following steps:\n   1.  First, the active subtree(s) of the hybrid schema
      must be\n       selected depending on the requested target document type.  This\n
      \      procedure is identical to the RELAX NG case, including the\n       handling
      of @nma:config if the target document type is <nc:get-\n       config> reply.\n
      \  2.  Namespaces of all input YANG modules, together with the\n       namespaces
      of base NETCONF (\"nc\" prefix) or notifications (\"en\"\n       prefix) MUST
      be declared using the <sch:ns> element, for example:\n   <sch:ns uri=\"http://example.com/ns/example4\"
      prefix=\"ex4\"/>\n   3.  One pattern is created for every input module.  In
      addition, an\n       abstract pattern is created for every named pattern definition\n
      \      containing one or more semantic annotations.\n   4.  A <sch:rule> element
      is created for each element pattern\n       containing semantic annotations.\n
      \  5.  Every such annotation is then mapped to an <sch:assert> or <sch:\n       report>
      element, which is installed as a child of the <sch:rule>\n       element.\n"
    - contents:
      - "11.2.1.  Constraints on Mandatory Choice\n   In order to fully represent
        the semantics of YANG's 'choice'\n   statement with the \"mandatory true;\"
        substatement, the RELAX NG\n   grammar has to be combined with a special Schematron
        rule.\n   EXAMPLE.  Consider the following module:\n   module example5 {\n
        \      namespace \"http://example.com/ns/example5\";\n       prefix ex5;\n
        \      choice foobar {\n           mandatory true;\n           case foo {\n
        \              leaf foo1 {\n                   type uint8;\n               }\n
        \              leaf foo2 {\n                   type uint8;\n               }\n
        \          }\n           leaf bar {\n               type uint8;\n           }\n
        \      }\n   }\n   In this module, all three leaf nodes in both case branches
        are\n   optional but because of the \"mandatory true;\" statement, at least
        one\n   of them must be present in a valid configuration.  The 'choice'\n
        \  statement from this module is mapped to the following fragment of the\n
        \  RELAX NG schema:\n   <rng:choice>\n     <rng:interleave>\n       <rng:optional>\n
        \        <rng:element name=\"ex5:foo1\">\n           <rng:data type=\"unsignedByte\"/>\n
        \        </rng:element>\n       </rng:optional>\n       <rng:optional>\n         <rng:element
        name=\"ex5:foo2\">\n           <rng:data type=\"unsignedByte\"/>\n         </rng:element>\n
        \      </rng:optional>\n     </rng:interleave>\n     <rng:element name=\"ex5:bar\">\n
        \      <rng:data type=\"unsignedByte\"/>\n     </rng:element>\n   </rng:choice>\n
        \  In the second case branch, the \"ex5:bar\" element is defined as\n   mandatory
        so that this element must be present in a valid\n   configuration if this
        branch is selected.  However, the two elements\n   in the first branch \"foo\"
        cannot be both declared as mandatory since\n   each of them alone suffices
        for a valid configuration.  As a result,\n   the above RELAX NG fragment would
        successfully validate\n   configurations where none of the three leaf elements
        are present.\n   Therefore, mandatory choices, which can be recognized in
        the hybrid\n   schema as <rng:choice> elements with the @nma:mandatory annotation,\n
        \  have to be handled in a special way: for each mandatory choice where\n
        \  at least one of the cases contains more than one node, a Schematron\n   rule
        MUST be added enforcing the presence of at least one element\n   from any
        of the cases.  (RELAX NG schema guarantees that elements\n   from different
        cases cannot be mixed together, that all mandatory\n   nodes are present,
        etc.).\n   For the example module above, the Schematron rule will be as follows:\n
        \  <sch:rule context=\"/nc:rpc-reply/nc:data\">\n     <sch:assert test=\"ex5:foo1
        or ex5:foo2 or ex5:bar\">\n       Node(s) from at least one case of choice
        \"foobar\" must exist.\n     </sch:assert>\n   </sch:rule>\n"
      title: 11.2.1.  Constraints on Mandatory Choice
    title: 11.2.  Mapping Semantic Constraints to Schematron
  - contents:
    - "11.3.  Mapping Default Values to DSRL\n   DSRL is the only component of DSDL
      that is allowed to change the\n   information set of the validated XML document.
      \ While DSRL also has\n   other functions, YANG-to-DSDL mapping uses it only
      for specifying and\n   applying default contents.  For XML instance documents
      based on YANG\n   data models, insertion of default contents may potentially
      take place\n   for all implicit nodes identified by the rules in Section 9.1.2.\n
      \  In DSRL, the default contents of an element are specified using the\n   <dsrl:default-content>
      element, which is a child of <dsrl:element-\n   map>.  Two sibling elements
      of <dsrl:default-content> determine the\n   context for the application of the
      default contents, see [DSRL]:\n   o  the <dsrl:parent> element contains an XSLT
      pattern specifying the\n      parent element; the default contents are applied
      only if the\n      parent element exists in the instance document;\n   o  the
      <dsrl:name> contains the XML name of the element that, if\n      missing or
      empty, is inserted together with the contents of <dsrl:\n      default-content>.\n
      \  The <dsrl:parent> element is optional in a general DSRL schema but,\n   for
      the purpose of the YANG-to-DSDL mapping, this element MUST be\n   always present,
      in order to guarantee a proper application of default\n   contents.\n   DSRL
      mapping only deals with <rng:element> patterns in the hybrid\n   schema that
      define implicit nodes (see Section 9.1.2).  Such element\n   patterns are distinguished
      by having NETMOD-specific annotation\n   attributes @nma:default or @nma:implicit,
      i.e., either:\n   <rng:element name=\"ELEM\" nma:default=\"DEFVALUE\">\n     ...\n
      \  </rng:element>\n   or\n   <rng:element name=\"ELEM\" nma:implicit=\"true\">\n
      \    ...\n   </rng:element>\n   The former case applies to leaf nodes having
      the 'default'\n   substatement, but also to leaf nodes that obtain their default
      value\n   from a typedef, if this typedef is expanded according to the rules
      in\n   Section 9.2.2 so that the @nma:default annotation is attached\n   directly
      to the leaf's element pattern.\n   The latter case is used for all implicit
      containers (see Section 9.1)\n   and for leafs that obtain the default value
      from a typedef and don't\n   have the @nma:default annotation.\n   In the simplest
      case, both element patterns are mapped to the\n   following DSRL element map:\n
      \  <dsrl:element-map>\n     <dsrl:parent>XPARENT</dsrl:parent>\n     <dsrl:name>ELEM</dsrl:name>\n
      \    <dsrl:default-content>DEFCONT</dsrl:default-content>\n   </dsrl:element-map>\n
      \  where XPARENT is the absolute XPath of ELEM's parent element in the\n   data
      tree and DEFCONT is constructed as follows:\n   o  If the implicit node ELEM
      is a leaf and has the @nma:default\n      attribute, DEFCONT is set to the value
      of this attribute (denoted\n      above as DEFVALUE).\n   o  If the implicit
      node ELEM is a leaf and has the @nma:implicit\n      attribute with the value
      of \"true\", the default value has to be\n      determined from the @nma:default
      attribute of the definition of\n      ELEM's type (perhaps recursively) and
      used in place of DEFCONT in\n      the above DSRL element map.  See also Section
      9.2.2.\n   o  Otherwise, the implicit node ELEM is a container and DEFCONT is\n
      \     constructed as an XML fragment containing all descendant elements\n      of
      ELEM that have either the @nma:implicit or the @nma:default\n      attribute.\n
      \  In addition, when mapping the default case of a choice, it has to be\n   guaranteed
      that the default contents are not applied if any node from\n   any non-default
      case is present.  This is accomplished by setting\n   <dsrl:parent> in a special
      way:\n   <dsrl:parent>XPARENT[not (ELEM1|ELEM2|...|ELEMn)]</dsrl:parent>\n   where
      ELEM1, ELEM2, ...  ELEMn are the names of all top-level nodes\n   from all non-default
      cases.  The rest of the element map is exactly\n   as before.\n   EXAMPLE.  Consider
      the following YANG module:\n   module example6 {\n     namespace \"http://example.com/ns/example6\";\n
      \    prefix ex6;\n     container outer {\n       leaf leaf1 {\n         type
      uint8;\n         default 1;\n       }\n       choice one-or-two {\n         default
      \"one\";\n         container one {\n           leaf leaf2 {\n             type
      uint8;\n             default 2;\n           }\n         }\n         leaf leaf3
      {\n           type uint8;\n           default 3;\n         }\n       }\n     }\n
      \  }\n   The DSRL schema generated for the \"get-reply\" target document type\n
      \  will be:\n   <?xml version=\"1.0\" encoding=\"utf-8\"?>\n   <dsrl:maps xmlns:dsrl=\"http://purl.oclc.org/dsdl/dsrl\"\n
      \             xmlns:ex6=\"http://example.com/ns/example6\"\n              xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n
      \    <dsrl:element-map>\n       <dsrl:parent>/nc:rpc-reply/nc:data</dsrl:parent>\n
      \      <dsrl:name>ex6:outer</dsrl:name>\n       <dsrl:default-content>\n         <ex6:leaf1>1</ex6:leaf1>\n
      \        <ex6:one>\n           <ex6:leaf2>2</ex6:leaf2>\n         </ex6:one>\n
      \      </dsrl:default-content>\n     </dsrl:element-map>\n     <dsrl:element-map>\n
      \      <dsrl:parent>/nc:rpc-reply/nc:data/ex6:outer</dsrl:parent>\n       <dsrl:name>ex6:leaf1</dsrl:name>\n
      \      <dsrl:default-content>1</dsrl:default-content>\n     </dsrl:element-map>\n
      \    <dsrl:element-map>\n       <dsrl:parent>\n         /nc:rpc-reply/nc:data/ex6:outer[not(ex6:leaf3)]\n
      \      </dsrl:parent>\n       <dsrl:name>ex6:one</dsrl:name>\n       <dsrl:default-content>\n
      \        <ex6:leaf2>2</ex6:leaf2>\n       </dsrl:default-content>\n     </dsrl:element-map>\n
      \    <dsrl:element-map>\n       <dsrl:parent>\n         /nc:rpc-reply/nc:data/ex6:outer/ex6:one\n
      \      </dsrl:parent>\n       <dsrl:name>ex6:leaf2</dsrl:name>\n       <dsrl:default-content>2</dsrl:default-content>\n
      \    </dsrl:element-map>\n   </dsrl:maps>\n   Note that the default value for
      \"leaf3\" defined in the YANG module is\n   ignored because \"leaf3\" represents
      a non-default alternative of a\n   choice and as such never becomes an implicit
      element.\n"
    title: 11.3.  Mapping Default Values to DSRL
  title: 11.  Mapping the Hybrid Schema to DSDL
- contents:
  - "12.  Mapping NETMOD-Specific Annotations to DSDL Schema Languages\n   This section
    contains the mapping specification for the individual\n   NETMOD-specific annotations.
    \ In each case, the result of the mapping\n   must be inserted into an appropriate
    context of the target DSDL\n   schema as described in Section 11.  The context
    is determined by the\n   element pattern in the hybrid schema to which the annotation
    is\n   attached.  In the rest of this section, CONTELEM will denote the name\n
    \  of this context element properly qualified with its namespace prefix.\n"
  - contents:
    - "12.1.  The @nma:config Annotation\n   If this annotation is present with the
      value of \"false\", the\n   following rules MUST be observed for DSDL schemas
      of <nc:get-config>\n   reply:\n   o  When generating RELAX NG, the contents
      of the CONTELEM definition\n      MUST be changed to <rng:notAllowed>.\n   o
      \ When generating Schematron or DSRL, the CONTELEM definition and\n      all
      its descendants in the hybrid schema MUST be ignored.\n"
    title: 12.1.  The @nma:config Annotation
  - contents:
    - "12.2.  The @nma:default Annotation\n   This annotation is used for generating
      the DSRL schema as described\n   in Section 11.3.\n"
    title: 12.2.  The @nma:default Annotation
  - contents:
    - "12.3.  The <nma:error-app-tag> Annotation\n   This annotation currently has
      no mapping defined.\n"
    title: 12.3.  The <nma:error-app-tag> Annotation
  - contents:
    - "12.4.  The <nma:error-message> Annotation\n   This annotation is handled within
      <nma:must>, see Section 12.13.\n"
    title: 12.4.  The <nma:error-message> Annotation
  - contents:
    - "12.5.  The @if-feature Annotation\n   The information about available features
      MAY be supplied as an input\n   parameter to an implementation.  In this case,
      the following changes\n   MUST be performed for all features that are considered
      unavailable:\n   o  When generating RELAX NG, the contents of the CONTELEM definition\n
      \     MUST be changed to <rng:notAllowed>.\n   o  When generating Schematron
      or DSRL, the CONTELEM definition and\n      all its descendants in the hybrid
      schema MUST be ignored.\n"
    title: 12.5.  The @if-feature Annotation
  - contents:
    - "12.6.  The @nma:implicit Annotation\n   This annotation is used for generating
      the DSRL schema as described\n   in Section 11.3.\n"
    title: 12.6.  The @nma:implicit Annotation
  - contents:
    - "12.7.  The <nma:instance-identifier> Annotation\n   If this annotation element
      has the @require-instance attribute with\n   the value of \"false\", it is ignored.
      \ Otherwise, it is mapped to the\n   following Schematron assert:\n   <sch:assert
      test=\"nmf:evaluate(.)\">\n     The element pointed to by \"CONTELEM\" must
      exist.\n   </sch:assert>\n   The nmf:evaluate() function is an XSLT extension
      function (see\n   Extension Functions in [XSLT]) that evaluates an XPath expression
      at\n   run time.  Such an extension function is available in Extended XSLT\n
      \  (EXSLT) or provided as a proprietary extension by some XSLT\n   processors,
      for example Saxon.\n"
    title: 12.7.  The <nma:instance-identifier> Annotation
  - contents:
    - "12.8.  The @nma:key Annotation\n   Assume this annotation attribute contains
      \"k_1 k_2 ... k_n\", i.e.,\n   specifies n children of CONTELEM as list keys.
      \ The annotation is\n   then mapped to the following Schematron report:\n   <sch:report
      test=\"CONDITION\">\n     Duplicate key of list \"CONTELEM\"\n   </sch:report>\n
      \  where CONDITION has this form:\n   preceding-sibling::CONTELEM[C_1 and C_2
      and ... and C_n]\n   Each sub-expression C_i, for i=1,2,...,n, specifies the
      condition for\n   violated uniqueness of the key k_i, namely\n   k_i=current()/k_i\n"
    title: 12.8.  The @nma:key Annotation
  - contents:
    - "12.9.  The @nma:leaf-list Annotation\n   This annotation is mapped to the following
      Schematron rule, which\n   detects duplicate entries of a leaf-list:\n   <sch:report\n
      \      test=\". = preceding-sibling::PREFIX:sorted-entry\">\n     Duplicate
      leaf-list entry \"<sch:value-of select=\".\"/>\".\n   </sch:report>\n   See
      Section 11.2 for a complete example.\n"
    title: 12.9.  The @nma:leaf-list Annotation
  - contents:
    - "12.10.  The @nma:leafref Annotation\n   This annotation is mapped to the following
      assert:\n   <sch:assert test=\"PATH=.\">\n     Leaf \"PATH\" does not exist
      for leafref value \"VALUE\"\n   </sch:assert>\n   where PATH is the value of
      @nma:leafref and VALUE is the value of the\n   context element in the instance
      document for which the referred leaf\n   doesn't exist.\n"
    title: 12.10.  The @nma:leafref Annotation
  - contents:
    - "12.11.  The @nma:min-elements Annotation\n   This annotation is mapped to the
      following Schematron assert:\n   <sch:assert test=\"count(../CONTELEM)&gt;=MIN\">\n
      \    List \"CONTELEM\" - item count must be at least MIN\n   </sch:assert>\n
      \  where MIN is the value of @nma:min-elements.\n"
    title: 12.11.  The @nma:min-elements Annotation
  - contents:
    - "12.12.  The @nma:max-elements Annotation\n   This annotation is mapped to the
      following Schematron assert:\n"
    - "<sch:assert\n    test=\"count(../CONTELEM)&lt;=MAX or preceding-sibling::../CONTELEM\">\n
      \ Number of list items must be at most MAX\n"
    - "</sch:assert>\n   where MAX is the value of @nma:min-elements.\n"
    title: 12.12.  The @nma:max-elements Annotation
  - contents:
    - "12.13.  The <nma:must> Annotation\n   This annotation is mapped to the following
      Schematron assert:\n   <sch:assert test=\"EXPRESSION\">\n     MESSAGE\n   </sch:assert>\n
      \  where EXPRESSION is the value of the mandatory @assert attribute of\n   <nma:must>.
      \ If the <nma:error-message> subelement exists, MESSAGE is\n   set to its contents;
      otherwise, it is set to the default message\n   \"Condition EXPRESSION must
      be true\".\n"
    title: 12.13.  The <nma:must> Annotation
  - contents:
    - "12.14.  The <nma:ordered-by> Annotation\n   This annotation currently has no
      mapping defined.\n"
    title: 12.14.  The <nma:ordered-by> Annotation
  - contents:
    - "12.15.  The <nma:status> Annotation\n   This annotation currently has no mapping
      defined.\n"
    title: 12.15.  The <nma:status> Annotation
  - contents:
    - "12.16.  The @nma:unique Annotation\n   The mapping of this annotation is almost
      identical as for @nma:key,\n   see Section 12.8, with two small differences:\n
      \  o  The value of @nma:unique is a list of descendant schema node\n      identifiers
      rather than simple leaf names.  However, the XPath\n      expressions specified
      in Section 12.8 work without any\n      modifications if the descendant schema
      node identifiers are\n      substituted for k_1, k_2, ..., k_n.\n   o  The message
      appearing as the text of <sch:report> is different:\n      \"Violated uniqueness
      for list CONTELEM\".\n"
    title: 12.16.  The @nma:unique Annotation
  - contents:
    - "12.17.  The @nma:when Annotation\n   This annotation is mapped to the following
      Schematron assert:\n   <sch:assert test=\"EXPRESSION\">\n     Node \"CONTELEM\"
      is only valid when \"EXPRESSION\" is true.\n   </sch:assert>\n   where EXPRESSION
      is the value of @nma:when.\n"
    title: 12.17.  The @nma:when Annotation
  title: 12.  Mapping NETMOD-Specific Annotations to DSDL Schema Languages
- contents:
  - "13.  IANA Considerations\n   This document requests the following two registrations
    of namespace\n   URIs in the IETF XML registry [RFC3688]:\n   -----------------------------------------------------\n
    \  URI: urn:ietf:params:xml:ns:netmod:dsdl-annotations:1\n   Registrant Contact:
    The IESG.\n   XML: N/A, the requested URI is an XML namespace.\n   -----------------------------------------------------\n
    \  -----------------------------------------------------\n   URI: urn:ietf:params:xml:ns:netmod:xpath-extensions:1\n
    \  Registrant Contact: The IESG.\n   XML: N/A, the requested URI is an XML namespace.\n
    \  -----------------------------------------------------\n"
  title: 13.  IANA Considerations
- contents:
  - "14.  Security Considerations\n   This document defines a procedure that maps
    data models expressed in\n   the YANG language to a coordinated set of DSDL schemas.
    \ The\n   procedure itself has no security impact on the Internet.\n   DSDL schemas
    obtained by the mapping procedure may be used for\n   validating the contents
    of NETCONF messages or entire datastores, and\n   thus they provide additional
    validity checks above those performed by\n   NETCONF server and client implementations
    supporting YANG data\n   models.  The strictness of this validation is directly
    derived from\n   the source YANG modules that the validated XML data adhere to.\n"
  title: 14.  Security Considerations
- contents:
  - "15.  Contributors\n   The following people contributed significantly to the initial
    version\n   of this document:\n   o  Rohan Mahy\n   o  Sharon Chisholm (Ciena)\n"
  title: 15.  Contributors
- contents:
  - "16.  Acknowledgments\n   The editor wishes to thank the following individuals
    who provided\n   helpful suggestions and/or comments on various versions of this\n
    \  document: Andy Bierman, Martin Bjorklund, Jirka Kosek, Juergen\n   Schoenwaelder,
    and Phil Shafer.\n"
  title: 16.  Acknowledgments
- contents:
  - '17.  References

    '
  - contents:
    - "17.1.  Normative References\n   [DSDL]         ISO/IEC, \"Document Schema Definition
      Languages (DSDL)\n                  - Part 1: Overview\", ISO/IEC 19757-1, November
      2004.\n   [DSRL]         ISO/IEC, \"Information Technology - Document Schema\n
      \                 Definition Languages (DSDL) - Part 8: Document\n                  Semantics
      Renaming Language - DSRL\", ISO/\n                  IEC 19757-8:2008(E), December
      2008.\n   [RFC2119]      Bradner, S., \"Key words for use in RFCs to Indicate\n
      \                 Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC3688]
      \     Mealling, M., \"The IETF XML Registry\", BCP 81,\n                  RFC
      3688, January 2004.\n   [RFC4741]      Enns, R., \"NETCONF Configuration Protocol\",
      RFC 4741,\n                  December 2006.\n   [RFC6020]      Bjorklund, M.,
      Ed., \"YANG - A Data Modeling Language\n                  for Network Configuration
      Protocol (NETCONF)\",\n                  RFC 6020, October 2010.\n   [RFC6021]
      \     Schoenwaelder, J., Ed., \"Common YANG Data Types\",\n                  RFC
      6021, October 2010.\n   [RNG]          ISO/IEC, \"Information Technology - Document
      Schema\n                  Definition Languages (DSDL) - Part 2: Regular-Grammar-\n
      \                 Based Validation - RELAX NG. Second Edition.\", ISO/\n                  IEC
      19757-2:2008(E), December 2008.\n   [RNG-CS]       ISO/IEC, \"Information Technology
      - Document Schema\n                  Definition Languages (DSDL) - Part 2: Regular-Grammar-\n
      \                 Based Validation - RELAX NG. AMENDMENT 1: Compact\n                  Syntax\",
      ISO/IEC 19757-2:2003/Amd. 1:2006(E),\n                  January 2006.\n   [RNG-DTD]
      \     Clark, J., Ed. and M. Murata, Ed., \"RELAX NG DTD\n                  Compatibility\",
      OASIS Committee Specification, 3\n                  December 2001.\n   [Schematron]
      \  ISO/IEC, \"Information Technology - Document Schema\n                  Definition
      Languages (DSDL) - Part 3: Rule-Based\n                  Validation - Schematron\",
      ISO/IEC 19757-3:2006(E),\n                  June 2006.\n   [XML]          Bray,
      T., Paoli, J., Sperberg-McQueen, C., Maler, E.,\n                  and F. Yergeau,
      \"Extensible Markup Language (XML) 1.0\n                  (Fifth Edition)\",
      World Wide Web Consortium\n                  Recommendation REC-xml-20081126,
      November 2008,\n                  <http://www.w3.org/TR/2006/REC-xml-20060816>.\n
      \  [XML-INFOSET]  Tobin, R. and J. Cowan, \"XML Information Set (Second\n                  Edition)\",
      World Wide Web Consortium\n                  Recommendation REC-xml-infoset-20040204,\n
      \                 February 2004,\n                  <http://www.w3.org/TR/2004/REC-xml-infoset-20040204>.\n
      \  [XPath]        Clark, J. and S. DeRose, \"XML Path Language (XPath)\n                  Version
      1.0\", World Wide Web Consortium\n                  Recommendation REC-xpath-19991116,
      November 1999,\n                  <http://www.w3.org/TR/1999/REC-xpath-19991116>.\n
      \  [XSD-D]        Biron, P. and A. Malhotra, \"XML Schema Part 2:\n                  Datatypes
      Second Edition\", World Wide Web Consortium\n                  Recommendation
      REC-xmlschema-2-20041028, October 2004,\n                  <http://www.w3.org/TR/2004/REC-xmlschema-2-20041028>.\n
      \  [XSLT]         Clark, J., \"XSL Transformations (XSLT) Version 1.0\",\n                  World
      Wide Web Consortium Recommendation REC-xslt-\n                  19991116, November
      1999.\n"
    title: 17.1.  Normative References
  - contents:
    - "17.2.  Informative References\n   [DHCPtut]      Bjorklund, M., \"DHCP Tutorial\",
      November 2007, <http:/\n                  /www.yang-central.org/twiki/bin/view/Main/\n
      \                 DhcpTutorial>.\n   [RFC1157]      Case, J., Fedor, M., Schoffstall,
      M., and J. Davin,\n                  \"Simple Network Management Protocol (SNMP)\",
      RFC 1157,\n                  May 1990.\n   [RFC2578]      McCloghrie, K., Ed.,
      Perkins, D., Ed., and J.\n                  Schoenwaelder, Ed., \"Structure
      of Management\n                  Information Version 2 (SMIv2)\", STD 58, RFC
      2578,\n                  April 1999.\n   [RFC5013]      Kunze, J., \"The Dublin
      Core Metadata Element Set\",\n                  RFC 5013, August 2007.\n   [RFC5277]
      \     Chisholm, S. and H. Trevino, \"NETCONF Event\n                  Notifications\",
      RFC 5277, July 2008.\n   [Trang]        Clark, J., \"Trang: Multiformat schema
      converter based\n                  on RELAX NG\", 2008,\n                  <http://www.thaiopensource.com/relaxng/trang.html>.\n
      \  [Vli04]        van der Vlist, E., \"RELAX NG\", O'Reilly, 2004.\n   [XSD]
      \         Thompson, H., Beech, D., Maloney, M., and N.\n                  Mendelsohn,
      \"XML Schema Part 1: Structures Second\n                  Edition\", World Wide
      Web Consortium\n                  Recommendation REC-xmlschema-1-20041028, October
      2004,\n                  <http://www.w3.org/TR/2004/REC-xmlschema-1-20041028>.\n
      \  [pyang]        Bjorklund, M. and L. Lhotka, \"pyang: An extensible\n                  YANG
      validator and converter in Python\", 2010,\n                  <http://code.google.com/p/pyang/>.\n"
    title: 17.2.  Informative References
  title: 17.  References
- contents:
  - "Appendix A.  RELAX NG Schema for NETMOD-Specific Annotations\n   This appendix
    defines the content model for all NETMOD-specific\n   annotations in the form
    of RELAX NG named pattern definitions.\n  <CODE BEGINS> file \"nmannot.rng\"\n
    \ <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <grammar xmlns=\"http://relaxng.org/ns/structure/1.0\"\n
    \          xmlns:nma=\"urn:ietf:params:xml:ns:netmod:dsdl-annotations:1\"\n           datatypeLibrary=\"http://www.w3.org/2001/XMLSchema-datatypes\">\n
    \ <define name=\"config-attribute\">\n    <attribute name=\"nma:config\">\n      <data
    type=\"boolean\"/>\n    </attribute>\n  </define>\n  <define name=\"data-element\">\n
    \   <element name=\"nma:data\">\n      <ref name=\"__anyxml__\"/>\n    </element>\n
    \ </define>\n  <define name=\"default-attribute\">\n    <attribute name=\"nma:default\">\n
    \     <data type=\"string\"/>\n    </attribute>\n  </define>\n  <define name=\"error-app-tag-element\">\n
    \   <element name=\"nma:error-app-tag\">\n      <text/>\n    </element>\n  </define>\n
    \ <define name=\"error-message-element\">\n    <element name=\"nma:error-message\">\n
    \     <text/>\n    </element>\n  </define>\n  <define name=\"if-feature-attribute\">\n
    \   <attribute name=\"nma:if-feature\">\n      <list>\n        <data type=\"QName\"/>\n
    \     </list>\n    </attribute>\n  </define>\n  <define name=\"implicit-attribute\">\n
    \   <attribute name=\"nma:implicit\">\n      <data type=\"boolean\"/>\n    </attribute>\n
    \ </define>\n  <define name=\"instance-identifier-element\">\n    <element name=\"nma:instance-identifier\">\n
    \     <optional>\n        <attribute name=\"nma:require-instance\">\n          <data
    type=\"boolean\"/>\n        </attribute>\n      </optional>\n    </element>\n
    \ </define>\n  <define name=\"key-attribute\">\n    <attribute name=\"nma:key\">\n
    \     <list>\n        <data type=\"QName\"/>\n      </list>\n    </attribute>\n
    \ </define>\n  <define name=\"leaf-list-attribute\">\n    <attribute name=\"nma:leaf-list\">\n
    \     <data type=\"boolean\"/>\n    </attribute>\n  </define>\n  <define name=\"leafref-attribute\">\n
    \   <attribute name=\"nma:leafref\">\n      <data type=\"string\"/>\n    </attribute>\n
    \ </define>\n  <define name=\"mandatory-attribute\">\n    <attribute name=\"nma:mandatory\">\n
    \     <data type=\"Name\"/>\n    </attribute>\n  </define>\n  <define name=\"max-elements-attribute\">\n
    \   <attribute name=\"nma:max-elements\">\n      <data type=\"nonNegativeInteger\"/>\n
    \   </attribute>\n  </define>\n  <define name=\"min-elements-attribute\">\n    <attribute
    name=\"nma:min-elements\">\n      <data type=\"nonNegativeInteger\"/>\n    </attribute>\n
    \ </define>\n  <define name=\"module-attribute\">\n    <attribute name=\"nma:module\">\n
    \     <data type=\"Name\"/>\n    </attribute>\n  </define>\n  <define name=\"must-element\">\n
    \   <element name=\"nma:must\">\n      <attribute name=\"assert\">\n        <data
    type=\"string\"/>\n      </attribute>\n      <interleave>\n        <optional>\n
    \         <ref name=\"error-app-tag-element\"/>\n        </optional>\n        <optional>\n
    \         <ref name=\"error-message-element\"/>\n        </optional>\n      </interleave>\n
    \   </element>\n  </define>\n  <define name=\"notifications-element\">\n    <element
    name=\"nma:notifications\">\n      <zeroOrMore>\n        <element name=\"nma:notification\">\n
    \         <ref name=\"__anyxml__\"/>\n        </element>\n      </zeroOrMore>\n
    \   </element>\n  </define>\n  <define name=\"rpcs-element\">\n    <element name=\"nma:rpcs\">\n
    \     <zeroOrMore>\n        <element name=\"nma:rpc\">\n          <interleave>\n
    \           <element name=\"nma:input\">\n              <ref name=\"__anyxml__\"/>\n
    \           </element>\n            <optional>\n              <element name=\"nma:output\">\n
    \               <ref name=\"__anyxml__\"/>\n              </element>\n            </optional>\n
    \         </interleave>\n        </element>\n      </zeroOrMore>\n    </element>\n
    \ </define>\n  <define name=\"ordered-by-attribute\">\n    <attribute name=\"nma:ordered-by\">\n
    \     <choice>\n        <value>user</value>\n        <value>system</value>\n      </choice>\n
    \   </attribute>\n  </define>\n  <define name=\"status-attribute\">\n    <optional>\n
    \     <attribute name=\"nma:status\">\n        <choice>\n          <value>current</value>\n
    \         <value>deprecated</value>\n          <value>obsolete</value>\n        </choice>\n
    \     </attribute>\n    </optional>\n  </define>\n  <define name=\"unique-attribute\">\n
    \   <optional>\n      <attribute name=\"nma:unique\">\n        <list>\n          <data
    type=\"token\"/>\n        </list>\n      </attribute>\n    </optional>\n  </define>\n
    \ <define name=\"units-attribute\">\n    <optional>\n      <attribute name=\"nma:units\">\n
    \       <data type=\"string\"/>\n      </attribute>\n    </optional>\n  </define>\n
    \ <define name=\"when-attribute\">\n    <optional>\n      <attribute name=\"nma:when\">\n
    \       <data type=\"string\"/>\n      </attribute>\n    </optional>\n  </define>\n
    \ <define name=\"__anyxml__\">\n    <zeroOrMore>\n      <choice>\n        <attribute>\n
    \         <anyName/>\n        </attribute>\n        <element>\n          <anyName/>\n
    \         <ref name=\"__anyxml__\"/>\n        </element>\n        <text/>\n      </choice>\n
    \   </zeroOrMore>\n  </define>\n  </grammar>\n  <CODE ENDS>\n"
  title: Appendix A.  RELAX NG Schema for NETMOD-Specific Annotations
- contents:
  - "Appendix B.  Schema-Independent Library\n   In order to avoid copying the common
    named pattern definitions to\n   every RELAX NG schema generated in the second
    mapping step, the\n   definitions are collected in a library file -- schema-independent\n
    \  library -- which is included by the validating schemas under the file\n   name
    \"relaxng-lib.rng\" (XML syntax) and \"relaxng-lib.rnc\" (compact\n   syntax).
    \ The included definitions cover patterns for common elements\n   from base NETCONF
    [RFC4741] and event notifications [RFC5277].\n  <CODE BEGINS> file \"relaxng-lib.rng\"\n
    \ <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <grammar xmlns=\"http://relaxng.org/ns/structure/1.0\"\n
    \          xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n           xmlns:en=\"urn:ietf:params:xml:ns:netconf:notification:1.0\"\n
    \          datatypeLibrary=\"http://www.w3.org/2001/XMLSchema-datatypes\">\n    <define
    name=\"message-id-attribute\">\n      <attribute name=\"message-id\">\n        <data
    type=\"string\">\n          <param name=\"maxLength\">4095</param>\n        </data>\n
    \     </attribute>\n    </define>\n    <define name=\"ok-element\">\n      <element
    name=\"nc:ok\">\n        <empty/>\n      </element>\n    </define>\n    <define
    name=\"eventTime-element\">\n      <element name=\"en:eventTime\">\n        <data
    type=\"dateTime\"/>\n      </element>\n    </define>\n  </grammar>\n  <CODE ENDS>\n"
  title: Appendix B.  Schema-Independent Library
- contents:
  - "Appendix C.  Mapping DHCP Data Model - A Complete Example\n   This appendix demonstrates
    both steps of the YANG-to-DSDL mapping\n   applied to the \"canonical\" DHCP tutorial
    [DHCPtut] data model.  The\n   input YANG module is shown in Appendix C.1 and
    the output schemas in\n   the following two subsections.\n   The hybrid schema
    was obtained by the \"dsdl\" plugin of the pyang tool\n   [pyang] and the validating
    DSDL schemas were obtained by XSLT\n   stylesheets that are also part of pyang
    distribution.\n   Due to the limit of 72 characters per line, a few long strings\n
    \  required manual editing, in particular the regular expression\n   patterns
    for IP addresses, etc.  These were replaced by the\n   placeholder string \"...
    regex pattern ...\".  Also, line breaks were\n   added to several documentation
    strings and Schematron messages.\n   Other than that, the results of the automatic
    translations were not\n   changed.\n"
  - contents:
    - "C.1.  Input YANG Module\n   module dhcp {\n     namespace \"http://example.com/ns/dhcp\";\n
      \    prefix dhcp;\n     import ietf-yang-types { prefix yang; }\n     import
      ietf-inet-types { prefix inet; }\n     organization\n       \"yang-central.org\";\n
      \    description\n       \"Partial data model for DHCP, based on the config
      of\n        the ISC DHCP reference implementation.\";\n     container dhcp {\n
      \      description\n         \"configuration and operational parameters for
      a DHCP server.\";\n       leaf max-lease-time {\n         type uint32;\n         units
      seconds;\n         default 7200;\n       }\n       leaf default-lease-time {\n
      \        type uint32;\n         units seconds;\n         must '. <= ../max-lease-time'
      {\n           error-message\n             \"The default-lease-time must be less
      than max-lease-time\";\n         }\n         default 600;\n       }\n       uses
      subnet-list;\n       container shared-networks {\n         list shared-network
      {\n           key name;\n           leaf name {\n             type string;\n
      \          }\n           uses subnet-list;\n         }\n       }\n       container
      status {\n         config false;\n         list leases {\n           key address;\n
      \          leaf address {\n             type inet:ip-address;\n           }\n
      \          leaf starts {\n             type yang:date-and-time;\n           }\n
      \          leaf ends {\n             type yang:date-and-time;\n           }\n
      \          container hardware {\n             leaf type {\n               type
      enumeration {\n                 enum \"ethernet\";\n                 enum \"token-ring\";\n
      \                enum \"fddi\";\n               }\n             }\n             leaf
      address {\n               type yang:phys-address;\n             }\n           }\n
      \        }\n       }\n     }\n     grouping subnet-list {\n       description
      \"A reusable list of subnets\";\n       list subnet {\n         key net;\n         leaf
      net {\n           type inet:ip-prefix;\n         }\n         container range
      {\n           presence \"enables dynamic address assignment\";\n           leaf
      dynamic-bootp {\n             type empty;\n             description\n               \"Allows
      BOOTP clients to get addresses in this range\";\n           }\n           leaf
      low {\n             type inet:ip-address;\n             mandatory true;\n           }\n
      \          leaf high {\n             type inet:ip-address;\n             mandatory
      true;\n           }\n         }\n         container dhcp-options {\n           description
      \"Options in the DHCP protocol\";\n           leaf-list router {\n             type
      inet:host;\n             ordered-by user;\n             reference \"RFC 2132,
      sec. 3.8\";\n           }\n           leaf domain-name {\n             type
      inet:domain-name;\n             reference \"RFC 2132, sec. 3.17\";\n           }\n
      \        }\n         leaf max-lease-time {\n           type uint32;\n           units
      seconds;\n           default 7200;\n         }\n       }\n     }\n   }\n"
    title: C.1.  Input YANG Module
  - contents:
    - "C.2.  Hybrid Schema\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <grammar\n
      \      xmlns=\"http://relaxng.org/ns/structure/1.0\"\n       xmlns:nma=\"urn:ietf:params:xml:ns:netmod:dsdl-annotations:1\"\n
      \      xmlns:dc=\"http://purl.org/dc/terms\"\n       xmlns:a=\"http://relaxng.org/ns/compatibility/annotations/1.0\"\n
      \      xmlns:dhcp=\"http://example.com/ns/dhcp\"\n       datatypeLibrary=\"http://www.w3.org/2001/XMLSchema-datatypes\">\n
      \   <dc:creator>Pyang 1.0a, DSDL plugin</dc:creator>\n    <dc:date>2010-06-17</dc:date>\n
      \   <start>\n     <grammar nma:module=\"dhcp\" ns=\"http://example.com/ns/dhcp\">\n
      \     <dc:source>YANG module 'dhcp'</dc:source>\n      <start>\n       <nma:data>\n
      \       <optional>\n         <element nma:implicit=\"true\" name=\"dhcp:dhcp\">\n
      \         <interleave>\n           <a:documentation>\n            configuration
      and operational parameters for a DHCP server.\n           </a:documentation>\n
      \          <optional>\n            <element nma:default=\"7200\"\n                     name=\"dhcp:max-lease-time\"\n
      \                    nma:units=\"seconds\">\n             <data type=\"unsignedInt\"/>\n
      \           </element>\n           </optional>\n           <optional>\n            <element
      nma:default=\"600\"\n                     name=\"dhcp:default-lease-time\"\n
      \                    nma:units=\"seconds\">\n             <data type=\"unsignedInt\"/>\n
      \            <nma:must assert=\". &lt;= ../dhcp:max-lease-time\">\n              <nma:error-message>\n
      \              The default-lease-time must be less than max-lease-time\n              </nma:error-message>\n
      \            </nma:must>\n            </element>\n           </optional>\n           <ref
      name=\"_dhcp__subnet-list\"/>\n           <optional>\n            <element name=\"dhcp:shared-networks\">\n
      \            <zeroOrMore>\n              <element nma:key=\"dhcp:name\"\n                       name=\"dhcp:shared-network\">\n
      \              <element name=\"dhcp:name\">\n                <data type=\"string\"/>\n
      \              </element>\n               <ref name=\"_dhcp__subnet-list\"/>\n
      \             </element>\n             </zeroOrMore>\n            </element>\n
      \          </optional>\n           <optional>\n            <element name=\"dhcp:status\"
      nma:config=\"false\">\n             <zeroOrMore>\n              <element nma:key=\"dhcp:address\"\n
      \                      name=\"dhcp:leases\">\n               <element name=\"dhcp:address\">\n
      \               <ref name=\"ietf-inet-types__ip-address\"/>\n               </element>\n
      \              <interleave>\n                <optional>\n                 <element
      name=\"dhcp:starts\">\n                  <ref name=\"ietf-yang-types__date-and-time\"/>\n
      \                </element>\n                </optional>\n                <optional>\n
      \                <element name=\"dhcp:ends\">\n                  <ref name=\"ietf-yang-types__date-and-time\"/>\n
      \                </element>\n                </optional>\n                <optional>\n
      \                <element name=\"dhcp:hardware\">\n                  <interleave>\n
      \                  <optional>\n                    <element name=\"dhcp:type\">\n
      \                    <choice>\n                      <value>ethernet</value>\n
      \                     <value>token-ring</value>\n                      <value>fddi</value>\n
      \                    </choice>\n                    </element>\n                   </optional>\n
      \                  <optional>\n                    <element name=\"dhcp:address\">\n
      \                    <ref name=\"ietf-yang-types__phys-address\"/>\n                    </element>\n
      \                  </optional>\n                  </interleave>\n                 </element>\n
      \               </optional>\n               </interleave>\n              </element>\n
      \            </zeroOrMore>\n            </element>\n           </optional>\n
      \         </interleave>\n         </element>\n        </optional>\n       </nma:data>\n
      \      <nma:rpcs/>\n       <nma:notifications/>\n      </start>\n     </grammar>\n
      \   </start>\n    <define name=\"ietf-yang-types__phys-address\">\n     <data
      type=\"string\">\n      <param name=\"pattern\">([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?</param>\n
      \    </data>\n    </define>\n    <define name=\"ietf-inet-types__ipv6-address\">\n
      \    <data type=\"string\">\n      <param name=\"pattern\">... regex pattern
      ...</param>\n      <param name=\"pattern\">... regex pattern ...</param>\n     </data>\n
      \   </define>\n    <define name=\"ietf-inet-types__ip-prefix\">\n     <choice>\n
      \     <ref name=\"ietf-inet-types__ipv4-prefix\"/>\n      <ref name=\"ietf-inet-types__ipv6-prefix\"/>\n
      \    </choice>\n    </define>\n    <define name=\"ietf-inet-types__host\">\n
      \    <choice>\n      <ref name=\"ietf-inet-types__ip-address\"/>\n      <ref
      name=\"ietf-inet-types__domain-name\"/>\n     </choice>\n    </define>\n    <define
      name=\"ietf-yang-types__date-and-time\">\n     <data type=\"string\">\n      <param
      name=\"pattern\">... regex pattern ...</param>\n     </data>\n    </define>\n
      \   <define name=\"_dhcp__subnet-list\">\n     <a:documentation>A reusable list
      of subnets</a:documentation>\n     <zeroOrMore>\n      <element nma:key=\"net\"
      name=\"subnet\">\n       <element name=\"net\">\n        <ref name=\"ietf-inet-types__ip-prefix\"/>\n
      \      </element>\n       <interleave>\n        <optional>\n         <element
      name=\"range\">\n          <interleave>\n           <optional>\n            <element
      name=\"dynamic-bootp\">\n             <a:documentation>\n              Allows
      BOOTP clients to get addresses in this range\n             </a:documentation>\n
      \            <empty/>\n            </element>\n           </optional>\n           <element
      name=\"low\">\n            <ref name=\"ietf-inet-types__ip-address\"/>\n           </element>\n
      \          <element name=\"high\">\n            <ref name=\"ietf-inet-types__ip-address\"/>\n
      \          </element>\n          </interleave>\n         </element>\n        </optional>\n
      \       <optional>\n         <element name=\"dhcp-options\">\n          <interleave>\n
      \          <a:documentation>\n            Options in the DHCP protocol\n           </a:documentation>\n
      \          <zeroOrMore>\n            <element nma:leaf-list=\"true\" name=\"router\"\n
      \                    nma:ordered-by=\"user\">\n             <a:documentation>\n
      \             See: RFC 2132, sec. 3.8\n             </a:documentation>\n             <ref
      name=\"ietf-inet-types__host\"/>\n            </element>\n           </zeroOrMore>\n
      \          <optional>\n            <element name=\"domain-name\">\n             <a:documentation>\n
      \             See: RFC 2132, sec. 3.17\n             </a:documentation>\n             <ref
      name=\"ietf-inet-types__domain-name\"/>\n            </element>\n           </optional>\n
      \         </interleave>\n         </element>\n        </optional>\n        <optional>\n
      \        <element nma:default=\"7200\" name=\"max-lease-time\"\n                  nma:units=\"seconds\">\n
      \         <data type=\"unsignedInt\"/>\n         </element>\n        </optional>\n
      \      </interleave>\n      </element>\n     </zeroOrMore>\n    </define>\n
      \   <define name=\"ietf-inet-types__domain-name\">\n     <data type=\"string\">\n
      \     <param name=\"pattern\">... regex pattern ...</param>\n      <param name=\"minLength\">1</param>\n
      \     <param name=\"maxLength\">253</param>\n     </data>\n    </define>\n    <define
      name=\"ietf-inet-types__ipv4-prefix\">\n     <data type=\"string\">\n      <param
      name=\"pattern\">... regex pattern ...</param>\n     </data>\n    </define>\n
      \   <define name=\"ietf-inet-types__ipv4-address\">\n     <data type=\"string\">\n
      \     <param name=\"pattern\">... regex pattern ...</param>\n     </data>\n
      \   </define>\n    <define name=\"ietf-inet-types__ipv6-prefix\">\n     <data
      type=\"string\">\n      <param name=\"pattern\">... regex pattern ...</param>\n
      \     <param name=\"pattern\">... regex pattern ...</param>\n     </data>\n
      \   </define>\n    <define name=\"ietf-inet-types__ip-address\">\n     <choice>\n
      \     <ref name=\"ietf-inet-types__ipv4-address\"/>\n      <ref name=\"ietf-inet-types__ipv6-address\"/>\n
      \    </choice>\n    </define>\n   </grammar>\n"
    title: C.2.  Hybrid Schema
  - contents:
    - "C.3.  Final DSDL Schemas\n   This appendix contains DSDL schemas that were
      obtained from the\n   hybrid schema in Appendix C.2 by XSL transformations.
      \ These schemas\n   can be directly used for validating a reply to unfiltered
      <nc:get>\n   with the contents corresponding to the DHCP data model.\n   The
      RELAX NG schema (in two parts, as explained in Section 8.2) also\n   includes
      the schema-independent library from Appendix B.\n"
    - contents:
      - "C.3.1.  Main RELAX NG Schema for <nc:get> Reply\n   <?xml version=\"1.0\"
        encoding=\"utf-8\"?>\n   <grammar\n       xmlns=\"http://relaxng.org/ns/structure/1.0\"\n
        \      xmlns:nma=\"urn:ietf:params:xml:ns:netmod:dsdl-annotations:1\"\n       xmlns:dhcp=\"http://example.com/ns/dhcp\"\n
        \      datatypeLibrary=\"http://www.w3.org/2001/XMLSchema-datatypes\"\n       ns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n
        \   <include href=\"relaxng-lib.rng\"/>\n    <start>\n     <element name=\"rpc-reply\">\n
        \     <ref name=\"message-id-attribute\"/>\n      <element name=\"data\">\n
        \      <interleave>\n        <grammar ns=\"http://example.com/ns/dhcp\">\n
        \        <include href=\"dhcp-gdefs.rng\"/>\n         <start>\n          <optional>\n
        \          <element name=\"dhcp:dhcp\">\n            <interleave>\n             <optional>\n
        \             <element name=\"dhcp:max-lease-time\">\n               <data
        type=\"unsignedInt\"/>\n              </element>\n             </optional>\n
        \            <optional>\n              <element name=\"dhcp:default-lease-time\">\n
        \              <data type=\"unsignedInt\"/>\n              </element>\n             </optional>\n
        \            <ref name=\"_dhcp__subnet-list\"/>\n             <optional>\n
        \             <element name=\"dhcp:shared-networks\">\n               <zeroOrMore>\n
        \               <element name=\"dhcp:shared-network\">\n                 <element
        name=\"dhcp:name\">\n                  <data type=\"string\"/>\n                 </element>\n
        \                <ref name=\"_dhcp__subnet-list\"/>\n                </element>\n
        \              </zeroOrMore>\n              </element>\n             </optional>\n
        \            <optional>\n              <element name=\"dhcp:status\">\n               <zeroOrMore>\n
        \               <element name=\"dhcp:leases\">\n                 <element
        name=\"dhcp:address\">\n                  <ref name=\"ietf-inet-types__ip-address\"/>\n
        \                </element>\n                 <interleave>\n                  <optional>\n
        \                  <element name=\"dhcp:starts\">\n                    <ref
        name=\"ietf-yang-types__date-and-time\"/>\n                   </element>\n
        \                 </optional>\n                  <optional>\n                   <element
        name=\"dhcp:ends\">\n                    <ref name=\"ietf-yang-types__date-and-time\"/>\n
        \                  </element>\n                  </optional>\n                  <optional>\n
        \                  <element name=\"dhcp:hardware\">\n                    <interleave>\n
        \                    <optional>\n                      <element name=\"dhcp:type\">\n
        \                      <choice>\n                        <value>ethernet</value>\n
        \                       <value>token-ring</value>\n                        <value>fddi</value>\n
        \                      </choice>\n                      </element>\n                     </optional>\n
        \                    <optional>\n                      <element name=\"dhcp:address\">\n
        \                      <ref name=\"ietf-yang-types__phys-address\"/>\n                      </element>\n
        \                    </optional>\n                    </interleave>\n                   </element>\n
        \                 </optional>\n                 </interleave>\n                </element>\n
        \              </zeroOrMore>\n              </element>\n             </optional>\n
        \           </interleave>\n           </element>\n          </optional>\n
        \        </start>\n        </grammar>\n       </interleave>\n      </element>\n
        \    </element>\n    </start>\n   </grammar>\n"
      title: C.3.1.  Main RELAX NG Schema for <nc:get> Reply
    - contents:
      - "C.3.2.  RELAX NG Schema - Global Named Pattern Definitions\n   <?xml version=\"1.0\"
        encoding=\"utf-8\"?>\n   <grammar\n       xmlns=\"http://relaxng.org/ns/structure/1.0\"\n
        \      xmlns:nma=\"urn:ietf:params:xml:ns:netmod:dsdl-annotations:1\"\n       xmlns:dhcp=\"http://example.com/ns/dhcp\"\n
        \      datatypeLibrary=\"http://www.w3.org/2001/XMLSchema-datatypes\">\n    <define
        name=\"ietf-yang-types__phys-address\">\n     <data type=\"string\">\n      <param
        name=\"pattern\">\n       ([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?\n      </param>\n
        \    </data>\n    </define>\n    <define name=\"ietf-inet-types__ipv6-address\">\n
        \    <data type=\"string\">\n      <param name=\"pattern\">... regex pattern
        ...</param>\n     </data>\n    </define>\n    <define name=\"ietf-inet-types__ip-prefix\">\n
        \    <choice>\n      <ref name=\"ietf-inet-types__ipv4-prefix\"/>\n      <ref
        name=\"ietf-inet-types__ipv6-prefix\"/>\n     </choice>\n    </define>\n    <define
        name=\"ietf-inet-types__host\">\n     <choice>\n      <ref name=\"ietf-inet-types__ip-address\"/>\n
        \     <ref name=\"ietf-inet-types__domain-name\"/>\n     </choice>\n    </define>\n
        \   <define name=\"ietf-yang-types__date-and-time\">\n     <data type=\"string\">\n
        \     <param name=\"pattern\">... regex pattern ...</param>\n     </data>\n
        \   </define>\n    <define name=\"_dhcp__subnet-list\">\n     <zeroOrMore>\n
        \     <element name=\"subnet\">\n       <element name=\"net\">\n        <ref
        name=\"ietf-inet-types__ip-prefix\"/>\n       </element>\n       <interleave>\n
        \       <optional>\n         <element name=\"range\">\n          <interleave>\n
        \          <optional>\n            <element name=\"dynamic-bootp\">\n             <empty/>\n
        \           </element>\n           </optional>\n           <element name=\"low\">\n
        \           <ref name=\"ietf-inet-types__ip-address\"/>\n           </element>\n
        \          <element name=\"high\">\n            <ref name=\"ietf-inet-types__ip-address\"/>\n
        \          </element>\n          </interleave>\n         </element>\n        </optional>\n
        \       <optional>\n         <element name=\"dhcp-options\">\n          <interleave>\n
        \          <zeroOrMore>\n            <element name=\"router\">\n             <ref
        name=\"ietf-inet-types__host\"/>\n            </element>\n           </zeroOrMore>\n
        \          <optional>\n            <element name=\"domain-name\">\n             <ref
        name=\"ietf-inet-types__domain-name\"/>\n            </element>\n           </optional>\n
        \         </interleave>\n         </element>\n        </optional>\n        <optional>\n
        \        <element name=\"max-lease-time\">\n          <data type=\"unsignedInt\"/>\n
        \        </element>\n        </optional>\n       </interleave>\n      </element>\n
        \    </zeroOrMore>\n    </define>\n    <define name=\"ietf-inet-types__domain-name\">\n
        \    <data type=\"string\">\n      <param name=\"pattern\">... regex pattern
        ...</param>\n      <param name=\"minLength\">1</param>\n      <param name=\"maxLength\">253</param>\n
        \    </data>\n    </define>\n    <define name=\"ietf-inet-types__ipv4-prefix\">\n
        \    <data type=\"string\">\n      <param name=\"pattern\">... regex pattern
        ...</param>\n     </data>\n    </define>\n    <define name=\"ietf-inet-types__ipv4-address\">\n
        \    <data type=\"string\">\n      <param name=\"pattern\">... regex pattern
        ...</param>\n     </data>\n    </define>\n    <define name=\"ietf-inet-types__ipv6-prefix\">\n
        \    <data type=\"string\">\n      <param name=\"pattern\">... regex pattern
        ...</param>\n      <param name=\"pattern\">... regex pattern ...</param>\n
        \    </data>\n    </define>\n    <define name=\"ietf-inet-types__ip-address\">\n
        \    <choice>\n      <ref name=\"ietf-inet-types__ipv4-address\"/>\n      <ref
        name=\"ietf-inet-types__ipv6-address\"/>\n     </choice>\n    </define>\n
        \  </grammar>\n"
      title: C.3.2.  RELAX NG Schema - Global Named Pattern Definitions
    - contents:
      - "C.3.3.  Schematron Schema for <nc:get> Reply\n  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n
        \ <sch:schema xmlns:sch=\"http://purl.oclc.org/dsdl/schematron\">\n   <sch:ns
        uri=\"http://example.com/ns/dhcp\" prefix=\"dhcp\"/>\n   <sch:ns uri=\"urn:ietf:params:xml:ns:netconf:base:1.0\"
        prefix=\"nc\"/>\n   <sch:pattern abstract=\"true\" id=\"_dhcp__subnet-list\">\n
        \   <sch:rule context=\"$start/$pref:subnet\">\n     <sch:report test=\"preceding-sibling::$pref:subnet\n
        \                      [$pref:net=current()/$pref:net]\">\n      Duplicate
        key \"net\"\n     </sch:report>\n    </sch:rule>\n    <sch:rule\n      context=\"$start/$pref:subnet/$pref:dhcp-options/$pref:router\">\n
        \    <sch:report test=\".=preceding-sibling::router\">\n      Duplicate leaf-list
        value \"<sch:value-of select=\".\"/>\"\n     </sch:report>\n    </sch:rule>\n
        \  </sch:pattern>\n   <sch:pattern id=\"dhcp\">\n    <sch:rule\n      context=\"/nc:rpc-reply/nc:data/dhcp:dhcp/dhcp:default-lease-time\">\n
        \    <sch:assert test=\". &lt;= ../dhcp:max-lease-time\">\n      The default-lease-time
        must be less than max-lease-time\n     </sch:assert>\n    </sch:rule>\n    <sch:rule
        context=\"/nc:rpc-reply/nc:data/dhcp:dhcp/\n                       dhcp:shared-networks/dhcp:shared-network\">\n
        \    <sch:report test=\"preceding-sibling::dhcp:shared-network\n                       [dhcp:name=current()/dhcp:name]\">\n
        \     Duplicate key \"dhcp:name\"\n     </sch:report>\n    </sch:rule>\n    <sch:rule
        context=\"/nc:rpc-reply/nc:data/dhcp:dhcp/\n                       dhcp:status/dhcp:leases\">\n
        \    <sch:report test=\"preceding-sibling::dhcp:leases\n                       [dhcp:address=current()/dhcp:address]\">\n
        \     Duplicate key \"dhcp:address\"\n     </sch:report>\n    </sch:rule>\n
        \  </sch:pattern>\n   <sch:pattern id=\"id2768196\" is-a=\"_dhcp__subnet-list\">\n
        \   <sch:param name=\"start\" value=\"/nc:rpc-reply/nc:data/dhcp:dhcp\"/>\n
        \   <sch:param name=\"pref\" value=\"dhcp\"/>\n   </sch:pattern>\n   <sch:pattern
        id=\"id2768215\" is-a=\"_dhcp__subnet-list\">\n    <sch:param name=\"start\"\n
        \              value=\"/nc:rpc-reply/nc:data/dhcp:dhcp/\n                      dhcp:shared-networks/dhcp:shared-network\"/>\n
        \   <sch:param name=\"pref\" value=\"dhcp\"/>\n   </sch:pattern>\n  </sch:schema>\n"
      title: C.3.3.  Schematron Schema for <nc:get> Reply
    - contents:
      - "C.3.4.  DSRL Schema for <nc:get> Reply\n   <?xml version=\"1.0\" encoding=\"utf-8\"?>\n
        \  <dsrl:maps\n       xmlns:dsrl=\"http://purl.oclc.org/dsdl/dsrl\"\n       xmlns:dhcp=\"http://example.com/ns/dhcp\"\n
        \      xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n    <dsrl:element-map>\n
        \    <dsrl:parent>/nc:rpc-reply/nc:data</dsrl:parent>\n     <dsrl:name>dhcp:dhcp</dsrl:name>\n
        \    <dsrl:default-content>\n      <dhcp:max-lease-time>7200</dhcp:max-lease-time>\n
        \     <dhcp:default-lease-time>600</dhcp:default-lease-time>\n     </dsrl:default-content>\n
        \   </dsrl:element-map>\n    <dsrl:element-map>\n     <dsrl:parent>/nc:rpc-reply/nc:data/dhcp:dhcp</dsrl:parent>\n
        \    <dsrl:name>dhcp:max-lease-time</dsrl:name>\n     <dsrl:default-content>7200</dsrl:default-content>\n
        \   </dsrl:element-map>\n    <dsrl:element-map>\n     <dsrl:parent>/nc:rpc-reply/nc:data/dhcp:dhcp</dsrl:parent>\n
        \    <dsrl:name>dhcp:default-lease-time</dsrl:name>\n     <dsrl:default-content>600</dsrl:default-content>\n
        \   </dsrl:element-map>\n    <dsrl:element-map>\n     <dsrl:parent>\n      /nc:rpc-reply/nc:data/dhcp:dhcp/dhcp:subnet\n
        \    </dsrl:parent>\n     <dsrl:name>dhcp:max-lease-time</dsrl:name>\n     <dsrl:default-content>7200</dsrl:default-content>\n
        \   </dsrl:element-map>\n    <dsrl:element-map>\n     <dsrl:parent>\n      /nc:rpc-reply/nc:data/dhcp:dhcp/dhcp:shared-networks/\n
        \     dhcp:shared-network/dhcp:subnet\n     </dsrl:parent>\n     <dsrl:name>dhcp:max-lease-time</dsrl:name>\n
        \    <dsrl:default-content>7200</dsrl:default-content>\n    </dsrl:element-map>\n
        \  </dsrl:maps>\n"
      title: C.3.4.  DSRL Schema for <nc:get> Reply
    title: C.3.  Final DSDL Schemas
  title: Appendix C.  Mapping DHCP Data Model - A Complete Example
- contents:
  - "Author's Address\n   Ladislav Lhotka (editor)\n   CESNET\n   EMail: lhotka@cesnet.cz\n"
  title: Author's Address
