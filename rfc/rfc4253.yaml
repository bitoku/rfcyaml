- title: __initial_text__
  contents:
  - '            The Secure Shell (SSH) Transport Layer Protocol

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   The Secure Shell (SSH) is a protocol for secure remote login and\n\
    \   other secure network services over an insecure network.\n   This document\
    \ describes the SSH transport layer protocol, which\n   typically runs on top\
    \ of TCP/IP.  The protocol can be used as a basis\n   for a number of secure network\
    \ services.  It provides strong\n   encryption, server authentication, and integrity\
    \ protection.  It may\n   also provide compression.\n   Key exchange method, public\
    \ key algorithm, symmetric encryption\n   algorithm, message authentication algorithm,\
    \ and hash algorithm are\n   all negotiated.\n   This document also describes\
    \ the Diffie-Hellman key exchange method\n   and the minimal set of algorithms\
    \ that are needed to implement the\n   SSH transport layer protocol.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Contributors ....................................................3\n  \
    \ 3. Conventions Used in This Document ...............................3\n   4.\
    \ Connection Setup ................................................4\n      4.1.\
    \ Use over TCP/IP ............................................4\n      4.2. Protocol\
    \ Version Exchange ..................................4\n   5. Compatibility With\
    \ Old SSH Versions .............................5\n      5.1. Old Client, New\
    \ Server .....................................6\n      5.2. New Client, Old Server\
    \ .....................................6\n      5.3. Packet Size and Overhead\
    \ ...................................6\n   6. Binary Packet Protocol ..........................................7\n\
    \      6.1. Maximum Packet Length ......................................8\n  \
    \    6.2. Compression ................................................8\n    \
    \  6.3. Encryption .................................................9\n      6.4.\
    \ Data Integrity ............................................12\n      6.5. Key\
    \ Exchange Methods ......................................13\n      6.6. Public\
    \ Key Algorithms .....................................13\n   7. Key Exchange ...................................................15\n\
    \      7.1. Algorithm Negotiation .....................................17\n  \
    \    7.2. Output from Key Exchange ..................................20\n    \
    \  7.3. Taking Keys Into Use ......................................21\n   8. Diffie-Hellman\
    \ Key Exchange ....................................21\n      8.1. diffie-hellman-group1-sha1\
    \ ................................23\n      8.2. diffie-hellman-group14-sha1 ...............................23\n\
    \   9. Key Re-Exchange ................................................23\n  \
    \ 10. Service Request ...............................................24\n   11.\
    \ Additional Messages ...........................................25\n      11.1.\
    \ Disconnection Message ....................................25\n      11.2. Ignored\
    \ Data Message .....................................26\n      11.3. Debug Message\
    \ ............................................26\n      11.4. Reserved Messages\
    \ ........................................27\n   12. Summary of Message Numbers\
    \ ....................................27\n   13. IANA Considerations ...........................................27\n\
    \   14. Security Considerations .......................................28\n  \
    \ 15. References ....................................................29\n    \
    \  15.1. Normative References .....................................29\n      15.2.\
    \ Informative References ...................................30\n   Authors' Addresses\
    \ ................................................31\n   Trademark Notice ..................................................31\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The SSH transport layer is a secure, low level transport\
    \ protocol.\n   It provides strong encryption, cryptographic host authentication,\
    \ and\n   integrity protection.\n   Authentication in this protocol level is host-based;\
    \ this protocol\n   does not perform user authentication.  A higher level protocol\
    \ for\n   user authentication can be designed on top of this protocol.\n   The\
    \ protocol has been designed to be simple and flexible to allow\n   parameter\
    \ negotiation, and to minimize the number of round-trips.\n   The key exchange\
    \ method, public key algorithm, symmetric encryption\n   algorithm, message authentication\
    \ algorithm, and hash algorithm are\n   all negotiated.  It is expected that in\
    \ most environments, only 2\n   round-trips will be needed for full key exchange,\
    \ server\n   authentication, service request, and acceptance notification of\n\
    \   service request.  The worst case is 3 round-trips.\n"
- title: 2.  Contributors
  contents:
  - "2.  Contributors\n   The major original contributors of this set of documents\
    \ have been:\n   Tatu Ylonen, Tero Kivinen, Timo J. Rinne, Sami Lehtinen (all\
    \ of SSH\n   Communications Security Corp), and Markku-Juhani O. Saarinen\n  \
    \ (University of Jyvaskyla).  Darren Moffat was the original editor of\n   this\
    \ set of documents and also made very substantial contributions.\n   Many people\
    \ contributed to the development of this document over the\n   years.  People\
    \ who should be acknowledged include Mats Andersson, Ben\n   Harris, Bill Sommerfeld,\
    \ Brent McClure, Niels Moller, Damien Miller,\n   Derek Fawcus, Frank Cusack,\
    \ Heikki Nousiainen, Jakob Schlyter, Jeff\n   Van Dyke, Jeffrey Altman, Jeffrey\
    \ Hutzelman, Jon Bright, Joseph\n   Galbraith, Ken Hornstein, Markus Friedl, Martin\
    \ Forssen, Nicolas\n   Williams, Niels Provos, Perry Metzger, Peter Gutmann, Simon\n\
    \   Josefsson, Simon Tatham, Wei Dai, Denis Bider, der Mouse, and\n   Tadayoshi\
    \ Kohno.  Listing their names here does not mean that they\n   endorse this document,\
    \ but that they have contributed to it.\n"
- title: 3.  Conventions Used in This Document
  contents:
  - "3.  Conventions Used in This Document\n   All documents related to the SSH protocols\
    \ shall use the keywords\n   \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",\
    \ \"SHALL NOT\", \"SHOULD\",\n   \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" to describe\n   requirements.  These keywords are to be interpreted\
    \ as described in\n   [RFC2119].\n   The keywords \"PRIVATE USE\", \"HIERARCHICAL\
    \ ALLOCATION\", \"FIRST COME\n   FIRST SERVED\", \"EXPERT REVIEW\", \"SPECIFICATION\
    \ REQUIRED\", \"IESG\n   APPROVAL\", \"IETF CONSENSUS\", and \"STANDARDS ACTION\"\
    \ that appear in\n   this document when used to describe namespace allocation\
    \ are to be\n   interpreted as described in [RFC2434].\n   Protocol fields and\
    \ possible values to fill them are defined in this\n   set of documents.  Protocol\
    \ fields will be defined in the message\n   definitions.  As an example, SSH_MSG_CHANNEL_DATA\
    \ is defined as\n   follows.\n      byte      SSH_MSG_CHANNEL_DATA\n      uint32\
    \    recipient channel\n      string    data\n   Throughout these documents, when\
    \ the fields are referenced, they will\n   appear within single quotes.  When\
    \ values to fill those fields are\n   referenced, they will appear within double\
    \ quotes.  Using the above\n   example, possible values for 'data' are \"foo\"\
    \ and \"bar\".\n"
- title: 4.  Connection Setup
  contents:
  - "4.  Connection Setup\n   SSH works over any 8-bit clean, binary-transparent transport.\
    \  The\n   underlying transport SHOULD protect against transmission errors, as\n\
    \   such errors cause the SSH connection to terminate.\n   The client initiates\
    \ the connection.\n"
- title: 4.1.  Use over TCP/IP
  contents:
  - "4.1.  Use over TCP/IP\n   When used over TCP/IP, the server normally listens\
    \ for connections on\n   port 22.  This port number has been registered with the\
    \ IANA, and has\n   been officially assigned for SSH.\n"
- title: 4.2.  Protocol Version Exchange
  contents:
  - "4.2.  Protocol Version Exchange\n   When the connection has been established,\
    \ both sides MUST send an\n   identification string.  This identification string\
    \ MUST be\n      SSH-protoversion-softwareversion SP comments CR LF\n   Since\
    \ the protocol being defined in this set of documents is version\n   2.0, the\
    \ 'protoversion' MUST be \"2.0\".  The 'comments' string is\n   OPTIONAL.  If\
    \ the 'comments' string is included, a 'space' character\n   (denoted above as\
    \ SP, ASCII 32) MUST separate the 'softwareversion'\n   and 'comments' strings.\
    \  The identification MUST be terminated by a\n   single Carriage Return (CR)\
    \ and a single Line Feed (LF) character\n   (ASCII 13 and 10, respectively). \
    \ Implementers who wish to maintain\n   compatibility with older, undocumented\
    \ versions of this protocol may\n   want to process the identification string\
    \ without expecting the\n   presence of the carriage return character for reasons\
    \ described in\n   Section 5 of this document.  The null character MUST NOT be\
    \ sent.\n   The maximum length of the string is 255 characters, including the\n\
    \   Carriage Return and Line Feed.\n   The part of the identification string preceding\
    \ the Carriage Return\n   and Line Feed is used in the Diffie-Hellman key exchange\
    \ (see Section\n   8).\n   The server MAY send other lines of data before sending\
    \ the version\n   string.  Each line SHOULD be terminated by a Carriage Return\
    \ and Line\n   Feed.  Such lines MUST NOT begin with \"SSH-\", and SHOULD be encoded\n\
    \   in ISO-10646 UTF-8 [RFC3629] (language is not specified).  Clients\n   MUST\
    \ be able to process such lines.  Such lines MAY be silently\n   ignored, or MAY\
    \ be displayed to the client user.  If they are\n   displayed, control character\
    \ filtering, as discussed in [SSH-ARCH],\n   SHOULD be used.  The primary use\
    \ of this feature is to allow TCP-\n   wrappers to display an error message before\
    \ disconnecting.\n   Both the 'protoversion' and 'softwareversion' strings MUST\
    \ consist of\n   printable US-ASCII characters, with the exception of whitespace\n\
    \   characters and the minus sign (-).  The 'softwareversion' string is\n   primarily\
    \ used to trigger compatibility extensions and to indicate\n   the capabilities\
    \ of an implementation.  The 'comments' string SHOULD\n   contain additional information\
    \ that might be useful in solving user\n   problems.  As such, an example of a\
    \ valid identification string is\n      SSH-2.0-billsSSH_3.6.3q3<CR><LF>\n   This\
    \ identification string does not contain the optional 'comments'\n   string and\
    \ is thus terminated by a CR and LF immediately after the\n   'softwareversion'\
    \ string.\n   Key exchange will begin immediately after sending this identifier.\n\
    \   All packets following the identification string SHALL use the binary\n   packet\
    \ protocol, which is described in Section 6.\n"
- title: 5.  Compatibility With Old SSH Versions
  contents:
  - "5.  Compatibility With Old SSH Versions\n   As stated earlier, the 'protoversion'\
    \ specified for this protocol is\n   \"2.0\".  Earlier versions of this protocol\
    \ have not been formally\n   documented, but it is widely known that they use\
    \ 'protoversion' of\n   \"1.x\" (e.g., \"1.5\" or \"1.3\").  At the time of this\
    \ writing, many\n   implementations of SSH are utilizing protocol version 2.0,\
    \ but it is\n   known that there are still devices using the previous versions.\n\
    \   During the transition period, it is important to be able to work in a\n  \
    \ way that is compatible with the installed SSH clients and servers\n   that use\
    \ the older version of the protocol.  Information in this\n   section is only\
    \ relevant for implementations supporting compatibility\n   with SSH versions\
    \ 1.x.  For those interested, the only known\n   documentation of the 1.x protocol\
    \ is contained in README files that\n   are shipped along with the source code\
    \ [ssh-1.2.30].\n"
- title: 5.1.  Old Client, New Server
  contents:
  - "5.1.  Old Client, New Server\n   Server implementations MAY support a configurable\
    \ compatibility flag\n   that enables compatibility with old versions.  When this\
    \ flag is on,\n   the server SHOULD identify its 'protoversion' as \"1.99\". \
    \ Clients\n   using protocol 2.0 MUST be able to identify this as identical to\n\
    \   \"2.0\".  In this mode, the server SHOULD NOT send the Carriage Return\n \
    \  character (ASCII 13) after the identification string.\n   In the compatibility\
    \ mode, the server SHOULD NOT send any further\n   data after sending its identification\
    \ string until it has received an\n   identification string from the client. \
    \ The server can then determine\n   whether the client is using an old protocol,\
    \ and can revert to the\n   old protocol if required.  In the compatibility mode,\
    \ the server MUST\n   NOT send additional data before the identification string.\n\
    \   When compatibility with old clients is not needed, the server MAY\n   send\
    \ its initial key exchange data immediately after the\n   identification string.\n"
- title: 5.2.  New Client, Old Server
  contents:
  - "5.2.  New Client, Old Server\n   Since the new client MAY immediately send additional\
    \ data after its\n   identification string (before receiving the server's identification\n\
    \   string), the old protocol may already be corrupt when the client\n   learns\
    \ that the server is old.  When this happens, the client SHOULD\n   close the\
    \ connection to the server, and reconnect using the old\n   protocol.\n"
- title: 5.3.  Packet Size and Overhead
  contents:
  - "5.3.  Packet Size and Overhead\n   Some readers will worry about the increase\
    \ in packet size due to new\n   headers, padding, and the Message Authentication\
    \ Code (MAC).  The\n   minimum packet size is in the order of 28 bytes (depending\
    \ on\n   negotiated algorithms).  The increase is negligible for large\n   packets,\
    \ but very significant for one-byte packets (telnet-type\n   sessions).  There\
    \ are, however, several factors that make this a\n   non-issue in almost all cases:\n\
    \   o  The minimum size of a TCP/IP header is 32 bytes.  Thus, the\n      increase\
    \ is actually from 33 to 51 bytes (roughly).\n   o  The minimum size of the data\
    \ field of an Ethernet packet is 46\n      bytes [RFC0894].  Thus, the increase\
    \ is no more than 5 bytes.\n      When Ethernet headers are considered, the increase\
    \ is less than 10\n      percent.\n   o  The total fraction of telnet-type data\
    \ in the Internet is\n      negligible, even with increased packet sizes.\n  \
    \ The only environment where the packet size increase is likely to have\n   a\
    \ significant effect is PPP [RFC1661] over slow modem lines (PPP\n   compresses\
    \ the TCP/IP headers, emphasizing the increase in packet\n   size).  However,\
    \ with modern modems, the time needed to transfer is\n   in the order of 2 milliseconds,\
    \ which is a lot faster than people can\n   type.\n   There are also issues related\
    \ to the maximum packet size.  To\n   minimize delays in screen updates, one does\
    \ not want excessively\n   large packets for interactive sessions.  The maximum\
    \ packet size is\n   negotiated separately for each channel.\n"
- title: 6.  Binary Packet Protocol
  contents:
  - "6.  Binary Packet Protocol\n   Each packet is in the following format:\n    \
    \  uint32    packet_length\n      byte      padding_length\n      byte[n1]  payload;\
    \ n1 = packet_length - padding_length - 1\n      byte[n2]  random padding; n2\
    \ = padding_length\n      byte[m]   mac (Message Authentication Code - MAC); m\
    \ = mac_length\n      packet_length\n         The length of the packet in bytes,\
    \ not including 'mac' or the\n         'packet_length' field itself.\n      padding_length\n\
    \         Length of 'random padding' (bytes).\n      payload\n         The useful\
    \ contents of the packet.  If compression has been\n         negotiated, this\
    \ field is compressed.  Initially, compression\n         MUST be \"none\".\n \
    \     random padding\n         Arbitrary-length padding, such that the total length\
    \ of\n         (packet_length || padding_length || payload || random padding)\n\
    \         is a multiple of the cipher block size or 8, whichever is\n        \
    \ larger.  There MUST be at least four bytes of padding.  The\n         padding\
    \ SHOULD consist of random bytes.  The maximum amount of\n         padding is\
    \ 255 bytes.\n      mac\n         Message Authentication Code.  If message authentication\
    \ has\n         been negotiated, this field contains the MAC bytes.  Initially,\n\
    \         the MAC algorithm MUST be \"none\".\n   Note that the length of the\
    \ concatenation of 'packet_length',\n   'padding_length', 'payload', and 'random\
    \ padding' MUST be a multiple\n   of the cipher block size or 8, whichever is\
    \ larger.  This constraint\n   MUST be enforced, even when using stream ciphers.\
    \  Note that the\n   'packet_length' field is also encrypted, and processing it\
    \ requires\n   special care when sending or receiving packets.  Also note that\
    \ the\n   insertion of variable amounts of 'random padding' may help thwart\n\
    \   traffic analysis.\n   The minimum size of a packet is 16 (or the cipher block\
    \ size,\n   whichever is larger) bytes (plus 'mac').  Implementations SHOULD\n\
    \   decrypt the length after receiving the first 8 (or cipher block size,\n  \
    \ whichever is larger) bytes of a packet.\n"
- title: 6.1.  Maximum Packet Length
  contents:
  - "6.1.  Maximum Packet Length\n   All implementations MUST be able to process packets\
    \ with an\n   uncompressed payload length of 32768 bytes or less and a total packet\n\
    \   size of 35000 bytes or less (including 'packet_length',\n   'padding_length',\
    \ 'payload', 'random padding', and 'mac').  The\n   maximum of 35000 bytes is\
    \ an arbitrarily chosen value that is larger\n   than the uncompressed length\
    \ noted above.  Implementations SHOULD\n   support longer packets, where they\
    \ might be needed.  For example, if\n   an implementation wants to send a very\
    \ large number of certificates,\n   the larger packets MAY be sent if the identification\
    \ string indicates\n   that the other party is able to process them.  However,\n\
    \   implementations SHOULD check that the packet length is reasonable in\n   order\
    \ for the implementation to avoid denial of service and/or buffer\n   overflow\
    \ attacks.\n"
- title: 6.2.  Compression
  contents:
  - "6.2.  Compression\n   If compression has been negotiated, the 'payload' field\
    \ (and only it)\n   will be compressed using the negotiated algorithm.  The\n\
    \   'packet_length' field and 'mac' will be computed from the compressed\n   payload.\
    \  Encryption will be done after compression.\n   Compression MAY be stateful,\
    \ depending on the method.  Compression\n   MUST be independent for each direction,\
    \ and implementations MUST\n   allow independent choosing of the algorithm for\
    \ each direction.  In\n   practice however, it is RECOMMENDED that the compression\
    \ method be\n   the same in both directions.\n   The following compression methods\
    \ are currently defined:\n      none     REQUIRED        no compression\n    \
    \  zlib     OPTIONAL        ZLIB (LZ77) compression\n   The \"zlib\" compression\
    \ is described in [RFC1950] and in [RFC1951].\n   The compression context is initialized\
    \ after each key exchange, and\n   is passed from one packet to the next, with\
    \ only a partial flush\n   being performed at the end of each packet.  A partial\
    \ flush means\n   that the current compressed block is ended and all data will\
    \ be\n   output.  If the current block is not a stored block, one or more\n  \
    \ empty blocks are added after the current block to ensure that there\n   are\
    \ at least 8 bits, counting from the start of the end-of-block code\n   of the\
    \ current block to the end of the packet payload.\n   Additional methods may be\
    \ defined as specified in [SSH-ARCH] and\n   [SSH-NUMBERS].\n"
- title: 6.3.  Encryption
  contents:
  - "6.3.  Encryption\n   An encryption algorithm and a key will be negotiated during\
    \ the key\n   exchange.  When encryption is in effect, the packet length, padding\n\
    \   length, payload, and padding fields of each packet MUST be encrypted\n   with\
    \ the given algorithm.\n   The encrypted data in all packets sent in one direction\
    \ SHOULD be\n   considered a single data stream.  For example, initialization\
    \ vectors\n   SHOULD be passed from the end of one packet to the beginning of\
    \ the\n   next packet.  All ciphers SHOULD use keys with an effective key\n  \
    \ length of 128 bits or more.\n   The ciphers in each direction MUST run independently\
    \ of each other.\n   Implementations MUST allow the algorithm for each direction\
    \ to be\n   independently selected, if multiple algorithms are allowed by local\n\
    \   policy.  In practice however, it is RECOMMENDED that the same\n   algorithm\
    \ be used in both directions.\n   The following ciphers are currently defined:\n\
    \      3des-cbc         REQUIRED          three-key 3DES in CBC mode\n      blowfish-cbc\
    \     OPTIONAL          Blowfish in CBC mode\n      twofish256-cbc   OPTIONAL\
    \          Twofish in CBC mode,\n                                         with\
    \ a 256-bit key\n      twofish-cbc      OPTIONAL          alias for \"twofish256-cbc\"\
    \n                                         (this is being retained\n         \
    \                                for historical reasons)\n      twofish192-cbc\
    \   OPTIONAL          Twofish with a 192-bit key\n      twofish128-cbc   OPTIONAL\
    \          Twofish with a 128-bit key\n      aes256-cbc       OPTIONAL       \
    \   AES in CBC mode,\n                                         with a 256-bit\
    \ key\n      aes192-cbc       OPTIONAL          AES with a 192-bit key\n     \
    \ aes128-cbc       RECOMMENDED       AES with a 128-bit key\n      serpent256-cbc\
    \   OPTIONAL          Serpent in CBC mode, with\n                            \
    \             a 256-bit key\n      serpent192-cbc   OPTIONAL          Serpent\
    \ with a 192-bit key\n      serpent128-cbc   OPTIONAL          Serpent with a\
    \ 128-bit key\n      arcfour          OPTIONAL          the ARCFOUR stream cipher\n\
    \                                         with a 128-bit key\n      idea-cbc \
    \        OPTIONAL          IDEA in CBC mode\n      cast128-cbc      OPTIONAL \
    \         CAST-128 in CBC mode\n      none             OPTIONAL          no encryption;\
    \ NOT RECOMMENDED\n   The \"3des-cbc\" cipher is three-key triple-DES (encrypt-decrypt-\n\
    \   encrypt), where the first 8 bytes of the key are used for the first\n   encryption,\
    \ the next 8 bytes for the decryption, and the following 8\n   bytes for the final\
    \ encryption.  This requires 24 bytes of key data\n   (of which 168 bits are actually\
    \ used).  To implement CBC mode, outer\n   chaining MUST be used (i.e., there\
    \ is only one initialization\n   vector).  This is a block cipher with 8-byte\
    \ blocks.  This algorithm\n   is defined in [FIPS-46-3].  Note that since this\
    \ algorithm only has\n   an effective key length of 112 bits ([SCHNEIER]), it\
    \ does not meet\n   the specifications that SSH encryption algorithms should use\
    \ keys of\n   128 bits or more.  However, this algorithm is still REQUIRED for\n\
    \   historical reasons; essentially, all known implementations at the\n   time\
    \ of this writing support this algorithm, and it is commonly used\n   because\
    \ it is the fundamental interoperable algorithm.  At some\n   future time, it\
    \ is expected that another algorithm, one with better\n   strength, will become\
    \ so prevalent and ubiquitous that the use of\n   \"3des-cbc\" will be deprecated\
    \ by another STANDARDS ACTION.\n   The \"blowfish-cbc\" cipher is Blowfish in\
    \ CBC mode, with 128-bit keys\n   [SCHNEIER].  This is a block cipher with 8-byte\
    \ blocks.\n   The \"twofish-cbc\" or \"twofish256-cbc\" cipher is Twofish in CBC\
    \ mode,\n   with 256-bit keys as described [TWOFISH].  This is a block cipher\n\
    \   with 16-byte blocks.\n   The \"twofish192-cbc\" cipher is the same as above,\
    \ but with a 192-bit\n   key.\n   The \"twofish128-cbc\" cipher is the same as\
    \ above, but with a 128-bit\n   key.\n   The \"aes256-cbc\" cipher is AES (Advanced\
    \ Encryption Standard)\n   [FIPS-197], in CBC mode.  This version uses a 256-bit\
    \ key.\n   The \"aes192-cbc\" cipher is the same as above, but with a 192-bit\
    \ key.\n   The \"aes128-cbc\" cipher is the same as above, but with a 128-bit\
    \ key.\n   The \"serpent256-cbc\" cipher in CBC mode, with a 256-bit key as\n\
    \   described in the Serpent AES submission.\n   The \"serpent192-cbc\" cipher\
    \ is the same as above, but with a 192-bit\n   key.\n   The \"serpent128-cbc\"\
    \ cipher is the same as above, but with a 128-bit\n   key.\n   The \"arcfour\"\
    \ cipher is the Arcfour stream cipher with 128-bit keys.\n   The Arcfour cipher\
    \ is believed to be compatible with the RC4 cipher\n   [SCHNEIER].  Arcfour (and\
    \ RC4) has problems with weak keys, and\n   should be used with caution.\n   The\
    \ \"idea-cbc\" cipher is the IDEA cipher in CBC mode [SCHNEIER].\n   The \"cast128-cbc\"\
    \ cipher is the CAST-128 cipher in CBC mode with a\n   128-bit key [RFC2144].\n\
    \   The \"none\" algorithm specifies that no encryption is to be done.\n   Note\
    \ that this method provides no confidentiality protection, and it\n   is NOT RECOMMENDED.\
    \  Some functionality (e.g., password\n   authentication) may be disabled for\
    \ security reasons if this cipher\n   is chosen.\n   Additional methods may be\
    \ defined as specified in [SSH-ARCH] and in\n   [SSH-NUMBERS].\n"
- title: 6.4.  Data Integrity
  contents:
  - "6.4.  Data Integrity\n   Data integrity is protected by including with each packet\
    \ a MAC that\n   is computed from a shared secret, packet sequence number, and\
    \ the\n   contents of the packet.\n   The message authentication algorithm and\
    \ key are negotiated during\n   key exchange.  Initially, no MAC will be in effect,\
    \ and its length\n   MUST be zero.  After key exchange, the 'mac' for the selected\
    \ MAC\n   algorithm will be computed before encryption from the concatenation\n\
    \   of packet data:\n      mac = MAC(key, sequence_number || unencrypted_packet)\n\
    \   where unencrypted_packet is the entire packet without 'mac' (the\n   length\
    \ fields, 'payload' and 'random padding'), and sequence_number\n   is an implicit\
    \ packet sequence number represented as uint32.  The\n   sequence_number is initialized\
    \ to zero for the first packet, and is\n   incremented after every packet (regardless\
    \ of whether encryption or\n   MAC is in use).  It is never reset, even if keys/algorithms\
    \ are\n   renegotiated later.  It wraps around to zero after every 2^32\n   packets.\
    \  The packet sequence_number itself is not included in the\n   packet sent over\
    \ the wire.\n   The MAC algorithms for each direction MUST run independently,\
    \ and\n   implementations MUST allow choosing the algorithm independently for\n\
    \   both directions.  In practice however, it is RECOMMENDED that the\n   same\
    \ algorithm be used in both directions.\n   The value of 'mac' resulting from\
    \ the MAC algorithm MUST be\n   transmitted without encryption as the last part\
    \ of the packet.  The\n   number of 'mac' bytes depends on the algorithm chosen.\n\
    \   The following MAC algorithms are currently defined:\n      hmac-sha1    REQUIRED\
    \        HMAC-SHA1 (digest length = key\n                                   length\
    \ = 20)\n      hmac-sha1-96 RECOMMENDED     first 96 bits of HMAC-SHA1 (digest\n\
    \                                   length = 12, key length = 20)\n      hmac-md5\
    \     OPTIONAL        HMAC-MD5 (digest length = key\n                        \
    \           length = 16)\n      hmac-md5-96  OPTIONAL        first 96 bits of\
    \ HMAC-MD5 (digest\n                                   length = 12, key length\
    \ = 16)\n      none         OPTIONAL        no MAC; NOT RECOMMENDED\n   The \"\
    hmac-*\" algorithms are described in [RFC2104].  The \"*-n\" MACs\n   use only\
    \ the first n bits of the resulting value.\n   SHA-1 is described in [FIPS-180-2]\
    \ and MD5 is described in [RFC1321].\n   Additional methods may be defined, as\
    \ specified in [SSH-ARCH] and in\n   [SSH-NUMBERS].\n"
- title: 6.5.  Key Exchange Methods
  contents:
  - "6.5.  Key Exchange Methods\n   The key exchange method specifies how one-time\
    \ session keys are\n   generated for encryption and for authentication, and how\
    \ the server\n   authentication is done.\n   Two REQUIRED key exchange methods\
    \ have been defined:\n      diffie-hellman-group1-sha1 REQUIRED\n      diffie-hellman-group14-sha1\
    \ REQUIRED\n   These methods are described in Section 8.\n   Additional methods\
    \ may be defined as specified in [SSH-NUMBERS].  The\n   name \"diffie-hellman-group1-sha1\"\
    \ is used for a key exchange method\n   using an Oakley group, as defined in [RFC2409].\
    \  SSH maintains its\n   own group identifier space that is logically distinct\
    \ from Oakley\n   [RFC2412] and IKE; however, for one additional group, the Working\n\
    \   Group adopted the number assigned by [RFC3526], using diffie-\n   hellman-group14-sha1\
    \ for the name of the second defined group.\n   Implementations should treat these\
    \ names as opaque identifiers and\n   should not assume any relationship between\
    \ the groups used by SSH and\n   the groups defined for IKE.\n"
- title: 6.6.  Public Key Algorithms
  contents:
  - "6.6.  Public Key Algorithms\n   This protocol has been designed to operate with\
    \ almost any public key\n   format, encoding, and algorithm (signature and/or\
    \ encryption).\n   There are several aspects that define a public key type:\n\
    \   o  Key format: how is the key encoded and how are certificates\n      represented.\
    \  The key blobs in this protocol MAY contain\n      certificates in addition\
    \ to keys.\n   o  Signature and/or encryption algorithms.  Some key types may\
    \ not\n      support both signing and encryption.  Key usage may also be\n   \
    \   restricted by policy statements (e.g., in certificates).  In this\n      case,\
    \ different key types SHOULD be defined for the different\n      policy alternatives.\n\
    \   o  Encoding of signatures and/or encrypted data.  This includes but\n    \
    \  is not limited to padding, byte order, and data formats.\n   The following\
    \ public key and/or certificate formats are currently\n   defined:\n   ssh-dss\
    \           REQUIRED     sign   Raw DSS Key\n   ssh-rsa           RECOMMENDED\
    \  sign   Raw RSA Key\n   pgp-sign-rsa      OPTIONAL     sign   OpenPGP certificates\
    \ (RSA key)\n   pgp-sign-dss      OPTIONAL     sign   OpenPGP certificates (DSS\
    \ key)\n   Additional key types may be defined, as specified in [SSH-ARCH] and\n\
    \   in [SSH-NUMBERS].\n   The key type MUST always be explicitly known (from algorithm\n\
    \   negotiation or some other source).  It is not normally included in\n   the\
    \ key blob.\n   Certificates and public keys are encoded as follows:\n      string\
    \    certificate or public key format identifier\n      byte[n]   key/certificate\
    \ data\n   The certificate part may be a zero length string, but a public key\
    \ is\n   required.  This is the public key that will be used for\n   authentication.\
    \  The certificate sequence contained in the\n   certificate blob can be used\
    \ to provide authorization.\n   Public key/certificate formats that do not explicitly\
    \ specify a\n   signature format identifier MUST use the public key/certificate\n\
    \   format identifier as the signature identifier.\n   Signatures are encoded\
    \ as follows:\n      string    signature format identifier (as specified by the\n\
    \                public key/certificate format)\n      byte[n]   signature blob\
    \ in format specific encoding.\n   The \"ssh-dss\" key format has the following\
    \ specific encoding:\n      string    \"ssh-dss\"\n      mpint     p\n      mpint\
    \     q\n      mpint     g\n      mpint     y\n   Here, the 'p', 'q', 'g', and\
    \ 'y' parameters form the signature key\n   blob.\n   Signing and verifying using\
    \ this key format is done according to the\n   Digital Signature Standard [FIPS-186-2]\
    \ using the SHA-1 hash\n   [FIPS-180-2].\n   The resulting signature is encoded\
    \ as follows:\n      string    \"ssh-dss\"\n      string    dss_signature_blob\n\
    \   The value for 'dss_signature_blob' is encoded as a string containing\n   r,\
    \ followed by s (which are 160-bit integers, without lengths or\n   padding, unsigned,\
    \ and in network byte order).\n   The \"ssh-rsa\" key format has the following\
    \ specific encoding:\n      string    \"ssh-rsa\"\n      mpint     e\n      mpint\
    \     n\n   Here the 'e' and 'n' parameters form the signature key blob.\n   Signing\
    \ and verifying using this key format is performed according to\n   the RSASSA-PKCS1-v1_5\
    \ scheme in [RFC3447] using the SHA-1 hash.\n   The resulting signature is encoded\
    \ as follows:\n      string    \"ssh-rsa\"\n      string    rsa_signature_blob\n\
    \   The value for 'rsa_signature_blob' is encoded as a string containing\n   s\
    \ (which is an integer, without lengths or padding, unsigned, and in\n   network\
    \ byte order).\n   The \"pgp-sign-rsa\" method indicates the certificates, the\
    \ public key,\n   and the signature are in OpenPGP compatible binary format\n\
    \   ([RFC2440]).  This method indicates that the key is an RSA-key.\n   The \"\
    pgp-sign-dss\" is as above, but indicates that the key is a\n   DSS-key.\n"
- title: 7.  Key Exchange
  contents:
  - "7.  Key Exchange\n   Key exchange (kex) begins by each side sending name-lists\
    \ of\n   supported algorithms.  Each side has a preferred algorithm in each\n\
    \   category, and it is assumed that most implementations, at any given\n   time,\
    \ will use the same preferred algorithm.  Each side MAY guess\n   which algorithm\
    \ the other side is using, and MAY send an initial key\n   exchange packet according\
    \ to the algorithm, if appropriate for the\n   preferred method.\n   The guess\
    \ is considered wrong if:\n   o  the kex algorithm and/or the host key algorithm\
    \ is guessed wrong\n      (server and client have different preferred algorithm),\
    \ or\n   o  if any of the other algorithms cannot be agreed upon (the\n      procedure\
    \ is defined below in Section 7.1).\n   Otherwise, the guess is considered to\
    \ be right, and the\n   optimistically sent packet MUST be handled as the first\
    \ key exchange\n   packet.\n   However, if the guess was wrong, and a packet was\
    \ optimistically sent\n   by one or both parties, such packets MUST be ignored\
    \ (even if the\n   error in the guess would not affect the contents of the initial\n\
    \   packet(s)), and the appropriate side MUST send the correct initial\n   packet.\n\
    \   A key exchange method uses explicit server authentication if the key\n   exchange\
    \ messages include a signature or other proof of the server's\n   authenticity.\
    \  A key exchange method uses implicit server\n   authentication if, in order\
    \ to prove its authenticity, the server\n   also has to prove that it knows the\
    \ shared secret, K, by sending a\n   message and a corresponding MAC that the\
    \ client can verify.\n   The key exchange method defined by this document uses\
    \ explicit server\n   authentication.  However, key exchange methods with implicit\
    \ server\n   authentication MAY be used with this protocol.  After a key exchange\n\
    \   with implicit server authentication, the client MUST wait for a\n   response\
    \ to its service request message before sending any further\n   data.\n"
- title: 7.1.  Algorithm Negotiation
  contents:
  - "7.1.  Algorithm Negotiation\n   Key exchange begins by each side sending the\
    \ following packet:\n      byte         SSH_MSG_KEXINIT\n      byte[16]     cookie\
    \ (random bytes)\n      name-list    kex_algorithms\n      name-list    server_host_key_algorithms\n\
    \      name-list    encryption_algorithms_client_to_server\n      name-list  \
    \  encryption_algorithms_server_to_client\n      name-list    mac_algorithms_client_to_server\n\
    \      name-list    mac_algorithms_server_to_client\n      name-list    compression_algorithms_client_to_server\n\
    \      name-list    compression_algorithms_server_to_client\n      name-list \
    \   languages_client_to_server\n      name-list    languages_server_to_client\n\
    \      boolean      first_kex_packet_follows\n      uint32       0 (reserved for\
    \ future extension)\n   Each of the algorithm name-lists MUST be a comma-separated\
    \ list of\n   algorithm names (see Algorithm Naming in [SSH-ARCH] and additional\n\
    \   information in [SSH-NUMBERS]).  Each supported (allowed) algorithm\n   MUST\
    \ be listed in order of preference, from most to least.\n   The first algorithm\
    \ in each name-list MUST be the preferred (guessed)\n   algorithm.  Each name-list\
    \ MUST contain at least one algorithm name.\n      cookie\n         The 'cookie'\
    \ MUST be a random value generated by the sender.\n         Its purpose is to\
    \ make it impossible for either side to fully\n         determine the keys and\
    \ the session identifier.\n      kex_algorithms\n         Key exchange algorithms\
    \ were defined above.  The first\n         algorithm MUST be the preferred (and\
    \ guessed) algorithm.  If\n         both sides make the same guess, that algorithm\
    \ MUST be used.\n         Otherwise, the following algorithm MUST be used to choose\
    \ a key\n         exchange method: Iterate over client's kex algorithms, one at\
    \ a\n         time.  Choose the first algorithm that satisfies the following\n\
    \         conditions:\n         +  the server also supports the algorithm,\n \
    \        +  if the algorithm requires an encryption-capable host key,\n      \
    \      there is an encryption-capable algorithm on the server's\n            server_host_key_algorithms\
    \ that is also supported by the\n            client, and\n         +  if the algorithm\
    \ requires a signature-capable host key,\n            there is a signature-capable\
    \ algorithm on the server's\n            server_host_key_algorithms that is also\
    \ supported by the\n            client.\n      If no algorithm satisfying all\
    \ these conditions can be found, the\n      connection fails, and both sides MUST\
    \ disconnect.\n      server_host_key_algorithms\n         A name-list of the algorithms\
    \ supported for the server host\n         key.  The server lists the algorithms\
    \ for which it has host\n         keys; the client lists the algorithms that it\
    \ is willing to\n         accept.  There MAY be multiple host keys for a host,\
    \ possibly\n         with different algorithms.\n         Some host keys may not\
    \ support both signatures and encryption\n         (this can be determined from\
    \ the algorithm), and thus not all\n         host keys are valid for all key exchange\
    \ methods.\n         Algorithm selection depends on whether the chosen key exchange\n\
    \         algorithm requires a signature or an encryption-capable host\n     \
    \    key.  It MUST be possible to determine this from the public key\n       \
    \  algorithm name.  The first algorithm on the client's name-list\n         that\
    \ satisfies the requirements and is also supported by the\n         server MUST\
    \ be chosen.  If there is no such algorithm, both\n         sides MUST disconnect.\n\
    \      encryption_algorithms\n         A name-list of acceptable symmetric encryption\
    \ algorithms (also\n         known as ciphers) in order of preference.  The chosen\n\
    \         encryption algorithm to each direction MUST be the first\n         algorithm\
    \ on the client's name-list that is also on the\n         server's name-list.\
    \  If there is no such algorithm, both sides\n         MUST disconnect.\n    \
    \     Note that \"none\" must be explicitly listed if it is to be\n         acceptable.\
    \  The defined algorithm names are listed in Section\n         6.3.\n      mac_algorithms\n\
    \         A name-list of acceptable MAC algorithms in order of\n         preference.\
    \  The chosen MAC algorithm MUST be the first\n         algorithm on the client's\
    \ name-list that is also on the\n         server's name-list.  If there is no\
    \ such algorithm, both sides\n         MUST disconnect.\n         Note that \"\
    none\" must be explicitly listed if it is to be\n         acceptable.  The MAC\
    \ algorithm names are listed in Section 6.4.\n      compression_algorithms\n \
    \        A name-list of acceptable compression algorithms in order of\n      \
    \   preference.  The chosen compression algorithm MUST be the first\n        \
    \ algorithm on the client's name-list that is also on the\n         server's name-list.\
    \  If there is no such algorithm, both sides\n         MUST disconnect.\n    \
    \     Note that \"none\" must be explicitly listed if it is to be\n         acceptable.\
    \  The compression algorithm names are listed in\n         Section 6.2.\n    \
    \  languages\n         This is a name-list of language tags in order of preference\n\
    \         [RFC3066].  Both parties MAY ignore this name-list.  If there\n    \
    \     are no language preferences, this name-list SHOULD be empty as\n       \
    \  defined in Section 5 of [SSH-ARCH].  Language tags SHOULD NOT\n         be\
    \ present unless they are known to be needed by the sending\n         party.\n\
    \      first_kex_packet_follows\n         Indicates whether a guessed key exchange\
    \ packet follows.  If a\n         guessed packet will be sent, this MUST be TRUE.\
    \  If no guessed\n         packet will be sent, this MUST be FALSE.\n        \
    \ After receiving the SSH_MSG_KEXINIT packet from the other side,\n         each\
    \ party will know whether their guess was right.  If the\n         other party's\
    \ guess was wrong, and this field was TRUE, the\n         next packet MUST be\
    \ silently ignored, and both sides MUST then\n         act as determined by the\
    \ negotiated key exchange method.  If\n         the guess was right, key exchange\
    \ MUST continue using the\n         guessed packet.\n   After the SSH_MSG_KEXINIT\
    \ message exchange, the key exchange\n   algorithm is run.  It may involve several\
    \ packet exchanges, as\n   specified by the key exchange method.\n   Once a party\
    \ has sent a SSH_MSG_KEXINIT message for key exchange or\n   re-exchange, until\
    \ it has sent a SSH_MSG_NEWKEYS message (Section\n   7.3), it MUST NOT send any\
    \ messages other than:\n   o  Transport layer generic messages (1 to 19) (but\n\
    \      SSH_MSG_SERVICE_REQUEST and SSH_MSG_SERVICE_ACCEPT MUST NOT be\n      sent);\n\
    \   o  Algorithm negotiation messages (20 to 29) (but further\n      SSH_MSG_KEXINIT\
    \ messages MUST NOT be sent);\n   o  Specific key exchange method messages (30\
    \ to 49).\n   The provisions of Section 11 apply to unrecognized messages.\n \
    \  Note, however, that during a key re-exchange, after sending a\n   SSH_MSG_KEXINIT\
    \ message, each party MUST be prepared to process an\n   arbitrary number of messages\
    \ that may be in-flight before receiving a\n   SSH_MSG_KEXINIT message from the\
    \ other party.\n"
- title: 7.2.  Output from Key Exchange
  contents:
  - "7.2.  Output from Key Exchange\n   The key exchange produces two values: a shared\
    \ secret K, and an\n   exchange hash H.  Encryption and authentication keys are\
    \ derived from\n   these.  The exchange hash H from the first key exchange is\n\
    \   additionally used as the session identifier, which is a unique\n   identifier\
    \ for this connection.  It is used by authentication methods\n   as a part of\
    \ the data that is signed as a proof of possession of a\n   private key.  Once\
    \ computed, the session identifier is not changed,\n   even if keys are later\
    \ re-exchanged.\n   Each key exchange method specifies a hash function that is\
    \ used in\n   the key exchange.  The same hash algorithm MUST be used in key\n\
    \   derivation.  Here, we'll call it HASH.\n   Encryption keys MUST be computed\
    \ as HASH, of a known value and K, as\n   follows:\n   o  Initial IV client to\
    \ server: HASH(K || H || \"A\" || session_id)\n      (Here K is encoded as mpint\
    \ and \"A\" as byte and session_id as raw\n      data.  \"A\" means the single\
    \ character A, ASCII 65).\n   o  Initial IV server to client: HASH(K || H || \"\
    B\" || session_id)\n   o  Encryption key client to server: HASH(K || H || \"C\"\
    \ || session_id)\n   o  Encryption key server to client: HASH(K || H || \"D\"\
    \ || session_id)\n   o  Integrity key client to server: HASH(K || H || \"E\" ||\
    \ session_id)\n   o  Integrity key server to client: HASH(K || H || \"F\" || session_id)\n\
    \   Key data MUST be taken from the beginning of the hash output.  As\n   many\
    \ bytes as needed are taken from the beginning of the hash value.\n   If the key\
    \ length needed is longer than the output of the HASH, the\n   key is extended\
    \ by computing HASH of the concatenation of K and H and\n   the entire key so\
    \ far, and appending the resulting bytes (as many as\n   HASH generates) to the\
    \ key.  This process is repeated until enough\n   key material is available; the\
    \ key is taken from the beginning of\n   this value.  In other words:\n      K1\
    \ = HASH(K || H || X || session_id)   (X is e.g., \"A\")\n      K2 = HASH(K ||\
    \ H || K1)\n      K3 = HASH(K || H || K1 || K2)\n      ...\n      key = K1 ||\
    \ K2 || K3 || ...\n   This process will lose entropy if the amount of entropy\
    \ in K is\n   larger than the internal state size of HASH.\n"
- title: 7.3.  Taking Keys Into Use
  contents:
  - "7.3.  Taking Keys Into Use\n   Key exchange ends by each side sending an SSH_MSG_NEWKEYS\
    \ message.\n   This message is sent with the old keys and algorithms.  All messages\n\
    \   sent after this message MUST use the new keys and algorithms.\n   When this\
    \ message is received, the new keys and algorithms MUST be\n   used for receiving.\n\
    \   The purpose of this message is to ensure that a party is able to\n   respond\
    \ with an SSH_MSG_DISCONNECT message that the other party can\n   understand if\
    \ something goes wrong with the key exchange.\n      byte      SSH_MSG_NEWKEYS\n"
- title: 8.  Diffie-Hellman Key Exchange
  contents:
  - "8.  Diffie-Hellman Key Exchange\n   The Diffie-Hellman (DH) key exchange provides\
    \ a shared secret that\n   cannot be determined by either party alone.  The key\
    \ exchange is\n   combined with a signature with the host key to provide host\n\
    \   authentication.  This key exchange method provides explicit server\n   authentication\
    \ as defined in Section 7.\n   The following steps are used to exchange a key.\
    \  In this, C is the\n   client; S is the server; p is a large safe prime; g is\
    \ a generator\n   for a subgroup of GF(p); q is the order of the subgroup; V_S\
    \ is S's\n   identification string; V_C is C's identification string; K_S is S's\n\
    \   public host key; I_C is C's SSH_MSG_KEXINIT message and I_S is S's\n   SSH_MSG_KEXINIT\
    \ message that have been exchanged before this part\n   begins.\n   1. C generates\
    \ a random number x (1 < x < q) and computes\n      e = g^x mod p.  C sends e\
    \ to S.\n   2. S generates a random number y (0 < y < q) and computes\n      f\
    \ = g^y mod p.  S receives e.  It computes K = e^y mod p,\n      H = hash(V_C\
    \ || V_S || I_C || I_S || K_S || e || f || K)\n      (these elements are encoded\
    \ according to their types; see below),\n      and signature s on H with its private\
    \ host key.  S sends\n      (K_S || f || s) to C.  The signing operation may involve\
    \ a\n      second hashing operation.\n   3. C verifies that K_S really is the\
    \ host key for S (e.g., using\n      certificates or a local database).  C is\
    \ also allowed to accept\n      the key without verification; however, doing so\
    \ will render the\n      protocol insecure against active attacks (but may be\
    \ desirable for\n      practical reasons in the short term in many environments).\
    \  C then\n      computes K = f^x mod p, H = hash(V_C || V_S || I_C || I_S ||\
    \ K_S\n      || e || f || K), and verifies the signature s on H.\n   Values of\
    \ 'e' or 'f' that are not in the range [1, p-1] MUST NOT be\n   sent or accepted\
    \ by either side.  If this condition is violated, the\n   key exchange fails.\n\
    \   This is implemented with the following messages.  The hash algorithm\n   for\
    \ computing the exchange hash is defined by the method name, and is\n   called\
    \ HASH.  The public key algorithm for signing is negotiated with\n   the SSH_MSG_KEXINIT\
    \ messages.\n   First, the client sends the following:\n      byte      SSH_MSG_KEXDH_INIT\n\
    \      mpint     e\n   The server then responds with the following:\n      byte\
    \      SSH_MSG_KEXDH_REPLY\n      string    server public host key and certificates\
    \ (K_S)\n      mpint     f\n      string    signature of H\n   The hash H is computed\
    \ as the HASH hash of the concatenation of the\n   following:\n      string  \
    \  V_C, the client's identification string (CR and LF\n                excluded)\n\
    \      string    V_S, the server's identification string (CR and LF\n        \
    \        excluded)\n      string    I_C, the payload of the client's SSH_MSG_KEXINIT\n\
    \      string    I_S, the payload of the server's SSH_MSG_KEXINIT\n      string\
    \    K_S, the host key\n      mpint     e, exchange value sent by the client\n\
    \      mpint     f, exchange value sent by the server\n      mpint     K, the\
    \ shared secret\n   This value is called the exchange hash, and it is used to\n\
    \   authenticate the key exchange.  The exchange hash SHOULD be kept\n   secret.\n\
    \   The signature algorithm MUST be applied over H, not the original\n   data.\
    \  Most signature algorithms include hashing and additional\n   padding (e.g.,\
    \ \"ssh-dss\" specifies SHA-1 hashing).  In that case, the\n   data is first hashed\
    \ with HASH to compute H, and H is then hashed\n   with SHA-1 as part of the signing\
    \ operation.\n"
- title: 8.1.  diffie-hellman-group1-sha1
  contents:
  - "8.1.  diffie-hellman-group1-sha1\n   The \"diffie-hellman-group1-sha1\" method\
    \ specifies the Diffie-Hellman\n   key exchange with SHA-1 as HASH, and Oakley\
    \ Group 2 [RFC2409] (1024-\n   bit MODP Group).  This method MUST be supported\
    \ for interoperability\n   as all of the known implementations currently support\
    \ it.  Note that\n   this method is named using the phrase \"group1\", even though\
    \ it\n   specifies the use of Oakley Group 2.\n"
- title: 8.2.  diffie-hellman-group14-sha1
  contents:
  - "8.2.  diffie-hellman-group14-sha1\n   The \"diffie-hellman-group14-sha1\" method\
    \ specifies a Diffie-Hellman\n   key exchange with SHA-1 as HASH and Oakley Group\
    \ 14 [RFC3526] (2048-\n   bit MODP Group), and it MUST also be supported.\n"
- title: 9.  Key Re-Exchange
  contents:
  - "9.  Key Re-Exchange\n   Key re-exchange is started by sending an SSH_MSG_KEXINIT\
    \ packet when\n   not already doing a key exchange (as described in Section 7.1).\
    \  When\n   this message is received, a party MUST respond with its own\n   SSH_MSG_KEXINIT\
    \ message, except when the received SSH_MSG_KEXINIT\n   already was a reply. \
    \ Either party MAY initiate the re-exchange, but\n   roles MUST NOT be changed\
    \ (i.e., the server remains the server, and\n   the client remains the client).\n\
    \   Key re-exchange is performed using whatever encryption was in effect\n   when\
    \ the exchange was started.  Encryption, compression, and MAC\n   methods are\
    \ not changed before a new SSH_MSG_NEWKEYS is sent after\n   the key exchange\
    \ (as in the initial key exchange).  Re-exchange is\n   processed identically\
    \ to the initial key exchange, except for the\n   session identifier that will\
    \ remain unchanged.  It is permissible to\n   change some or all of the algorithms\
    \ during the re-exchange.  Host\n   keys can also change.  All keys and initialization\
    \ vectors are\n   recomputed after the exchange.  Compression and encryption contexts\n\
    \   are reset.\n   It is RECOMMENDED that the keys be changed after each gigabyte\
    \ of\n   transmitted data or after each hour of connection time, whichever\n \
    \  comes sooner.  However, since the re-exchange is a public key\n   operation,\
    \ it requires a fair amount of processing power and should\n   not be performed\
    \ too often.\n   More application data may be sent after the SSH_MSG_NEWKEYS packet\n\
    \   has been sent; key exchange does not affect the protocols that lie\n   above\
    \ the SSH transport layer.\n"
- title: 10.  Service Request
  contents:
  - "10.  Service Request\n   After the key exchange, the client requests a service.\
    \  The service\n   is identified by a name.  The format of names and procedures\
    \ for\n   defining new names are defined in [SSH-ARCH] and [SSH-NUMBERS].\n  \
    \ Currently, the following names have been reserved:\n      ssh-userauth\n   \
    \   ssh-connection\n   Similar local naming policy is applied to the service names,\
    \ as is\n   applied to the algorithm names.  A local service should use the\n\
    \   PRIVATE USE syntax of \"servicename@domain\".\n      byte      SSH_MSG_SERVICE_REQUEST\n\
    \      string    service name\n   If the server rejects the service request, it\
    \ SHOULD send an\n   appropriate SSH_MSG_DISCONNECT message and MUST disconnect.\n\
    \   When the service starts, it may have access to the session identifier\n  \
    \ generated during the key exchange.\n   If the server supports the service (and\
    \ permits the client to use\n   it), it MUST respond with the following:\n   \
    \   byte      SSH_MSG_SERVICE_ACCEPT\n      string    service name\n   Message\
    \ numbers used by services should be in the area reserved for\n   them (see [SSH-ARCH]\
    \ and [SSH-NUMBERS]).  The transport level will\n   continue to process its own\
    \ messages.\n   Note that after a key exchange with implicit server authentication,\n\
    \   the client MUST wait for a response to its service request message\n   before\
    \ sending any further data.\n"
- title: 11.  Additional Messages
  contents:
  - "11.  Additional Messages\n   Either party may send any of the following messages\
    \ at any time.\n"
- title: 11.1.  Disconnection Message
  contents:
  - "11.1.  Disconnection Message\n      byte      SSH_MSG_DISCONNECT\n      uint32\
    \    reason code\n      string    description in ISO-10646 UTF-8 encoding [RFC3629]\n\
    \      string    language tag [RFC3066]\n   This message causes immediate termination\
    \ of the connection.  All\n   implementations MUST be able to process this message;\
    \ they SHOULD be\n   able to send this message.\n   The sender MUST NOT send or\
    \ receive any data after this message, and\n   the recipient MUST NOT accept any\
    \ data after receiving this message.\n   The Disconnection Message 'description'\
    \ string gives a more specific\n   explanation in a human-readable form.  The\
    \ Disconnection Message\n   'reason code' gives the reason in a more machine-readable\
    \ format\n   (suitable for localization), and can have the values as displayed\
    \ in\n   the table below.  Note that the decimal representation is displayed\n\
    \   in this table for readability, but the values are actually uint32\n   values.\n\
    \           Symbolic name                                reason code\n       \
    \    -------------                                -----------\n      SSH_DISCONNECT_HOST_NOT_ALLOWED_TO_CONNECT\
    \             1\n      SSH_DISCONNECT_PROTOCOL_ERROR                         \
    \ 2\n      SSH_DISCONNECT_KEY_EXCHANGE_FAILED                     3\n      SSH_DISCONNECT_RESERVED\
    \                                4\n      SSH_DISCONNECT_MAC_ERROR           \
    \                    5\n      SSH_DISCONNECT_COMPRESSION_ERROR               \
    \        6\n      SSH_DISCONNECT_SERVICE_NOT_AVAILABLE                   7\n \
    \     SSH_DISCONNECT_PROTOCOL_VERSION_NOT_SUPPORTED          8\n      SSH_DISCONNECT_HOST_KEY_NOT_VERIFIABLE\
    \                 9\n      SSH_DISCONNECT_CONNECTION_LOST                    \
    \    10\n      SSH_DISCONNECT_BY_APPLICATION                         11\n    \
    \  SSH_DISCONNECT_TOO_MANY_CONNECTIONS                   12\n      SSH_DISCONNECT_AUTH_CANCELLED_BY_USER\
    \                 13\n      SSH_DISCONNECT_NO_MORE_AUTH_METHODS_AVAILABLE    \
    \     14\n      SSH_DISCONNECT_ILLEGAL_USER_NAME                      15\n   If\
    \ the 'description' string is displayed, the control character\n   filtering discussed\
    \ in [SSH-ARCH] should be used to avoid attacks by\n   sending terminal control\
    \ characters.\n   Requests for assignments of new Disconnection Message 'reason\
    \ code'\n   values (and associated 'description' text) in the range of 0x00000010\n\
    \   to 0xFDFFFFFF MUST be done through the IETF CONSENSUS method, as\n   described\
    \ in [RFC2434].  The Disconnection Message 'reason code'\n   values in the range\
    \ of 0xFE000000 through 0xFFFFFFFF are reserved for\n   PRIVATE USE.  As noted,\
    \ the actual instructions to the IANA are in\n   [SSH-NUMBERS].\n"
- title: 11.2.  Ignored Data Message
  contents:
  - "11.2.  Ignored Data Message\n      byte      SSH_MSG_IGNORE\n      string   \
    \ data\n   All implementations MUST understand (and ignore) this message at any\n\
    \   time (after receiving the identification string).  No implementation\n   is\
    \ required to send them.  This message can be used as an additional\n   protection\
    \ measure against advanced traffic analysis techniques.\n"
- title: 11.3.  Debug Message
  contents:
  - "11.3.  Debug Message\n      byte      SSH_MSG_DEBUG\n      boolean   always_display\n\
    \      string    message in ISO-10646 UTF-8 encoding [RFC3629]\n      string \
    \   language tag [RFC3066]\n   All implementations MUST understand this message,\
    \ but they are\n   allowed to ignore it.  This message is used to transmit information\n\
    \   that may help debugging.  If 'always_display' is TRUE, the message\n   SHOULD\
    \ be displayed.  Otherwise, it SHOULD NOT be displayed unless\n   debugging information\
    \ has been explicitly requested by the user.\n   The 'message' doesn't need to\
    \ contain a newline.  It is, however,\n   allowed to consist of multiple lines\
    \ separated by CRLF (Carriage\n   Return - Line Feed) pairs.\n   If the 'message'\
    \ string is displayed, the terminal control character\n   filtering discussed\
    \ in [SSH-ARCH] should be used to avoid attacks by\n   sending terminal control\
    \ characters.\n"
- title: 11.4.  Reserved Messages
  contents:
  - "11.4.  Reserved Messages\n   An implementation MUST respond to all unrecognized\
    \ messages with an\n   SSH_MSG_UNIMPLEMENTED message in the order in which the\
    \ messages were\n   received.  Such messages MUST be otherwise ignored.  Later\
    \ protocol\n   versions may define other meanings for these message types.\n \
    \     byte      SSH_MSG_UNIMPLEMENTED\n      uint32    packet sequence number\
    \ of rejected message\n"
- title: 12.  Summary of Message Numbers
  contents:
  - "12.  Summary of Message Numbers\n   The following is a summary of messages and\
    \ their associated message\n   number.\n         SSH_MSG_DISCONNECT          \
    \   1\n         SSH_MSG_IGNORE                 2\n         SSH_MSG_UNIMPLEMENTED\
    \          3\n         SSH_MSG_DEBUG                  4\n         SSH_MSG_SERVICE_REQUEST\
    \        5\n         SSH_MSG_SERVICE_ACCEPT         6\n         SSH_MSG_KEXINIT\
    \                20\n         SSH_MSG_NEWKEYS                21\n   Note that\
    \ numbers 30-49 are used for kex packets.  Different kex\n   methods may reuse\
    \ message numbers in this range.\n"
- title: 13.  IANA Considerations
  contents:
  - "13.  IANA Considerations\n   This document is part of a set.  The IANA considerations\
    \ for the SSH\n   protocol as defined in [SSH-ARCH], [SSH-USERAUTH], [SSH-CONNECT],\
    \ and\n   this document, are detailed in [SSH-NUMBERS].\n"
- title: 14.  Security Considerations
  contents:
  - "14.  Security Considerations\n   This protocol provides a secure encrypted channel\
    \ over an insecure\n   network.  It performs server host authentication, key exchange,\n\
    \   encryption, and integrity protection.  It also derives a unique\n   session\
    \ ID that may be used by higher-level protocols.\n   Full security considerations\
    \ for this protocol are provided in\n   [SSH-ARCH].\n"
- title: 15.  References
  contents:
  - '15.  References

    '
- title: 15.1.  Normative References
  contents:
  - "15.1.  Normative References\n   [SSH-ARCH]     Ylonen, T. and C. Lonvick, Ed.,\
    \ \"The Secure Shell\n                  (SSH) Protocol Architecture\", RFC 4251,\
    \ January 2006.\n   [SSH-USERAUTH] Ylonen, T. and C. Lonvick, Ed., \"The Secure\
    \ Shell\n                  (SSH) Authentication Protocol\", RFC 4252, January\n\
    \                  2006.\n   [SSH-CONNECT]  Ylonen, T. and C. Lonvick, Ed., \"\
    The Secure Shell\n                  (SSH) Connection Protocol\", RFC 4254, January\
    \ 2006.\n   [SSH-NUMBERS]  Lehtinen, S. and C. Lonvick, Ed., \"The Secure Shell\n\
    \                  (SSH) Protocol Assigned Numbers\", RFC 4250, January\n    \
    \              2006.\n   [RFC1321]      Rivest, R., \"The MD5 Message-Digest Algorithm\
    \ \", RFC\n                  1321, April 1992.\n   [RFC1950]      Deutsch, P.\
    \ and J-L. Gailly, \"ZLIB Compressed Data\n                  Format Specification\
    \ version 3.3\", RFC 1950, May 1996.\n   [RFC1951]      Deutsch, P., \"DEFLATE\
    \ Compressed Data Format\n                  Specification version 1.3\", RFC 1951,\
    \ May 1996.\n   [RFC2104]      Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC:\n\
    \                  Keyed-Hashing for Message Authentication\", RFC 2104,\n   \
    \               February 1997.\n   [RFC2119]      Bradner, S., \"Key words for\
    \ use in RFCs to Indicate\n                  Requirement Levels\", BCP 14, RFC\
    \ 2119, March 1997.\n   [RFC2144]      Adams, C., \"The CAST-128 Encryption Algorithm\"\
    , RFC\n                  2144, May 1997.\n   [RFC2409]      Harkins, D. and D.\
    \ Carrel, \"The Internet Key Exchange\n                  (IKE)\", RFC 2409, November\
    \ 1998.\n   [RFC2434]      Narten, T. and H. Alvestrand, \"Guidelines for Writing\n\
    \                  an IANA Considerations Section in RFCs\", BCP 26, RFC\n   \
    \               2434, October 1998.\n   [RFC2440]      Callas, J., Donnerhacke,\
    \ L., Finney, H., and R.\n                  Thayer, \"OpenPGP Message Format\"\
    , RFC 2440, November\n                  1998.\n   [RFC3066]      Alvestrand, H.,\
    \ \"Tags for the Identification of\n                  Languages\", BCP 47, RFC\
    \ 3066, January 2001.\n   [RFC3447]      Jonsson, J. and B. Kaliski, \"Public-Key\
    \ Cryptography\n                  Standards (PKCS) #1: RSA Cryptography Specifications\n\
    \                  Version 2.1\", RFC 3447, February 2003.\n   [RFC3526]     \
    \ Kivinen, T. and M. Kojo, \"More Modular Exponential\n                  (MODP)\
    \ Diffie-Hellman groups for Internet Key Exchange\n                  (IKE)\",\
    \ RFC 3526, May 2003.\n   [RFC3629]      Yergeau, F., \"UTF-8, a transformation\
    \ format of ISO\n                  10646\", STD 63, RFC 3629, November 2003.\n\
    \   [FIPS-180-2]   US National Institute of Standards and Technology,\n      \
    \            \"Secure Hash Standard (SHS)\", Federal Information\n           \
    \       Processing Standards Publication 180-2, August 2002.\n   [FIPS-186-2]\
    \   US National Institute of Standards and Technology,\n                  \"Digital\
    \ Signature Standard (DSS)\", Federal\n                  Information Processing\
    \ Standards Publication 186-2,\n                  January 2000.\n   [FIPS-197]\
    \     US National Institute of Standards and Technology,\n                  \"\
    Advanced Encryption Standard (AES)\", Federal\n                  Information Processing\
    \ Standards Publication 197,\n                  November 2001.\n   [FIPS-46-3]\
    \    US National Institute of Standards and Technology,\n                  \"\
    Data Encryption Standard (DES)\", Federal Information\n                  Processing\
    \ Standards Publication 46-3, October 1999.\n   [SCHNEIER]     Schneier, B., \"\
    Applied Cryptography Second Edition:\n                  protocols algorithms and\
    \ source in code in C\", John\n                  Wiley and Sons, New York, NY,\
    \ 1996.\n   [TWOFISH]      Schneier, B., \"The Twofish Encryptions Algorithm:\
    \ A\n                  128-Bit Block Cipher, 1st Edition\", March 1999.\n"
- title: 15.2.  Informative References
  contents:
  - "15.2.  Informative References\n   [RFC0894]      Hornig, C., \"Standard for the\
    \ transmission of IP\n                  datagrams over Ethernet networks\", STD\
    \ 41, RFC 894,\n                  April 1984.\n   [RFC1661]      Simpson, W.,\
    \ \"The Point-to-Point Protocol (PPP)\", STD\n                  51, RFC 1661,\
    \ July 1994.\n   [RFC2412]      Orman, H., \"The OAKLEY Key Determination Protocol\"\
    ,\n                  RFC 2412, November 1998.\n   [ssh-1.2.30]   Ylonen, T., \"\
    ssh-1.2.30/RFC\", File within compressed\n                  tarball ftp://ftp.funet.fi/pub/unix/security/\n\
    \                  login/ssh/ssh-1.2.30.tar.gz, November 1995.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Tatu Ylonen\n   SSH Communications Security Corp\n   Valimotie\
    \ 17\n   00380 Helsinki\n   Finland\n   EMail: ylo@ssh.com\n   Chris Lonvick (editor)\n\
    \   Cisco Systems, Inc.\n   12515 Research Blvd.\n   Austin  78759\n   USA\n \
    \  EMail: clonvick@cisco.com\n"
- title: Trademark Notice
  contents:
  - "Trademark Notice\n   \"ssh\" is a registered trademark in the United States and/or\
    \ other\n   countries.\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n\
    \   Administrative Support Activity (IASA).\n"
