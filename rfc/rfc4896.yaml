- title: __initial_text__
  contents:
  - '     Signaling Compression (SigComp) Corrections and Clarifications

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The IETF Trust (2007).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes common misinterpretations and some\n   ambiguities\
    \ in the Signaling Compression Protocol (SigComp), and\n   offers guidance to\
    \ developers to resolve any resultant problems.\n   SigComp defines a scheme for\
    \ compressing messages generated by\n   application protocols such as the Session\
    \ Initiation Protocol (SIP).\n   This document updates the following RFCs: RFC\
    \ 3320, RFC 3321, and RFC\n   3485.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  3\n     1.1.  Terminology  . . . . . . . . . . . . . . . . . .\
    \ . . . . .  3\n   2.  Decompression Memory Size  . . . . . . . . . . . . . .\
    \ . . . .  3\n     2.1.  Bytecode within Decompression Memory Size  . . . . .\
    \ . . .  3\n     2.2.  Default Decompression Memory Size  . . . . . . . . . .\
    \ . .  4\n   3.  UDVM Instructions  . . . . . . . . . . . . . . . . . . . . .\
    \ .  5\n     3.1.  Data Input Instructions  . . . . . . . . . . . . . . . . .\
    \  5\n     3.2.  MULTILOAD  . . . . . . . . . . . . . . . . . . . . . . . .  5\n\
    \     3.3.  STATE-FREE . . . . . . . . . . . . . . . . . . . . . . . .  6\n  \
    \   3.4.  Using the Stack  . . . . . . . . . . . . . . . . . . . . .  6\n   4.\
    \  Byte Copying Rules . . . . . . . . . . . . . . . . . . . . . .  7\n     4.1.\
    \  Instructions That Use Byte Copying Rules . . . . . . . . .  9\n   5.  State\
    \ Retention Priority . . . . . . . . . . . . . . . . . . .  9\n     5.1.  Priority\
    \ Values  . . . . . . . . . . . . . . . . . . . . .  9\n     5.2.  Multiple State\
    \ Retention Priorities  . . . . . . . . . . . 10\n     5.3.  Retention Priority\
    \ 65535 (or -1) . . . . . . . . . . . . . 10\n   6.  Duplicate State  . . . .\
    \ . . . . . . . . . . . . . . . . . . . 14\n   7.  State Identifier Clashes .\
    \ . . . . . . . . . . . . . . . . . . 14\n   8.  Message Misordering  . . . .\
    \ . . . . . . . . . . . . . . . . . 15\n   9.  Requested Feedback . . . . . .\
    \ . . . . . . . . . . . . . . . . 15\n     9.1.  Feedback When SMS Is Zero  .\
    \ . . . . . . . . . . . . . . . 15\n     9.2.  Updating Feedback Requests . .\
    \ . . . . . . . . . . . . . . 16\n   10. Advertising Resources  . . . . . . .\
    \ . . . . . . . . . . . . . 16\n     10.1. The I-bit and Local State Items  .\
    \ . . . . . . . . . . . . 16\n     10.2. Dynamic Update of Resources  . . . .\
    \ . . . . . . . . . . . 17\n     10.3. Advertisement of Locally Available State\
    \ Items . . . . . . 17\n       10.3.1.  Basic SigComp . . . . . . . . . . . .\
    \ . . . . . . . . 18\n       10.3.2.  Dictionaries  . . . . . . . . . . . . .\
    \ . . . . . . . 18\n       10.3.3.  SigComp Extended Mechanisms . . . . . . .\
    \ . . . . . . 19\n   11. Uncompressed Bytecode  . . . . . . . . . . . . . . .\
    \ . . . . . 19\n   12. RFC 3485 SIP/SDP Static Dictionary . . . . . . . . . .\
    \ . . . . 20\n   13. Security Considerations  . . . . . . . . . . . . . . . .\
    \ . . . 21\n   14. IANA Considerations  . . . . . . . . . . . . . . . . . . .\
    \ . . 22\n   15. Acknowledgements . . . . . . . . . . . . . . . . . . . . . .\
    \ . 22\n   16. References . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ 23\n     16.1. Normative References . . . . . . . . . . . . . . . . . . . 23\n\
    \     16.2. Informative References . . . . . . . . . . . . . . . . . . 23\n  \
    \ Appendix A.  Dummy Application Protocol (DAP)  . . . . . . . . . . 24\n    \
    \ A.1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . 24\n     A.2.\
    \  Processing a DAP Message . . . . . . . . . . . . . . . . . 24\n     A.3.  DAP\
    \ Message Format in ABNF . . . . . . . . . . . . . . . . 26\n     A.4.  An Example\
    \ of a DAP Message  . . . . . . . . . . . . . . . 26\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   SigComp [1] defines the Universal Decompressor Virtual Machine\
    \ (UDVM)\n   for decompressing messages sent by a compliant compressor.  SigComp\n\
    \   further describes mechanisms to deal with state handling, message\n   structure,\
    \ and other details.  While the behavior of the decompressor\n   is specified\
    \ in great detail, the behavior of the compressor is left\n   as a choice for\
    \ the implementer.  During implementation and\n   interoperability tests, some\
    \ areas of SigComp that need clarification\n   have been identified.  The sections\
    \ that follow enumerate the problem\n   areas identified in the specification,\
    \ and attempt to provide\n   clarification.\n   Note that, as this document refers\
    \ to sections in several other\n   documents, the following notation is applied:\n\
    \      \"in Section 3.4\" refers to Section 3.4 of this document\n      \"in RFC\
    \ 3320-Section 3.4\" refers to Section 3.4 of RFC 3320 [1]\n"
- title: 1.1.  Terminology
  contents:
  - "1.1.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"\
    SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\"\
    , and \"OPTIONAL\" in this\n   document are to be interpreted as described in\
    \ RFC 2119 [5].\n"
- title: 2.  Decompression Memory Size
  contents:
  - '2.  Decompression Memory Size

    '
- title: 2.1.  Bytecode within Decompression Memory Size
  contents:
  - "2.1.  Bytecode within Decompression Memory Size\n   SigComp [1] states that the\
    \ default Decompression Memory Size (DMS)\n   is 2K.  The UDVM memory size is\
    \ defined in RFC 3320-Section 7 to be\n   (DMS - n), where n is the size of the\
    \ SigComp message, for messages\n   transported over UDP and (DMS / 2) for those\
    \ transported over TCP.\n   This means that when the message contains the bytecode\
    \ (as it will\n   for at least the first message) there will actually be two copies\
    \ of\n   the bytecode within the decompressor memory (see Figure 1).  The\n  \
    \ presence of the second copy of bytecode in decompressor memory is\n   correct\
    \ in this case.\n    |<----------------------------DMS--------------------------------->|\n\
    \    |<-----SigComp message---->|<------------UDVM memory size--------->|\n  \
    \  +-+----------+-------------+-----+----------+----------------------+\n    |\
    \ | bytecode |  comp msg   |     | bytecode | circular buffer      |\n    +-+----------+-------------+-----+----------+----------------------+\n\
    \     ^                            ^\n     |                            |\n  \
    \  SigComp header          Low bytes of UDVM\n            Figure 1: Bytecode and\
    \ UDVM memory size within DMS\n"
- title: 2.2.  Default Decompression Memory Size
  contents:
  - "2.2.  Default Decompression Memory Size\n   For many implementations, the length\
    \ of decompression bytecode sent\n   is in the range of three to four hundred\
    \ bytes.  Because SigComp\n   specifies a default DMS of 2K, the described scheme\
    \ seriously\n   restricts the size of the circular buffer, and of the compressed\n\
    \   message itself.  In some cases, this set of circumstances has a\n   damaging\
    \ effect on the compression ratio; for others, it makes it\n   completely impossible\
    \ to send certain messages compressed.\n   To address this problem, those mandating\
    \ the use of SigComp need to\n   also provide further specification for their\
    \ application that\n   mandates the use of an appropriately sized DMS.  Sizing\
    \ of such a DMS\n   should take into account (1) the size of bytecode for algorithms\n\
    \   likely to be employed in compressing the application messages, (2)\n   the\
    \ size of any buffers or structures necessary to execute such\n   algorithms,\
    \ (3) the size of application messages, and (4) the average\n   entropy present\
    \ within a single application message.\n   For example, assume a typical compression\
    \ algorithm requiring\n   approximately 400 bytes of bytecode, plus about 2432\
    \ bytes of data\n   structures.  The required UDVM memory size is 400 + 2432 =\
    \ 2832.  For\n   a TCP-based protocol, this means the DMS must be at least 5664\
    \ (2832\n   * 2) bytes, which is rounded up to 8k.  For a UDP-based protocol,\
    \ one\n   must take into account the size of the SigComp messages themselves.\n\
    \   Assuming a text-based protocol with sufficient average entropy to\n   compress\
    \ a single message by 50% (without any previous message\n   history), and messages\
    \ that are not expected to exceed 8192 bytes in\n   size, the protocol message\
    \ itself will add 4096 bytes to the SigComp\n   message size (on top of the 400\
    \ bytes of bytecode plus a 3-byte\n   header), or 4096 + 400 + 3 = 4499.  To calculate\
    \ the DMS, one must\n   add this to the required UDVM memory size: 2832 + 4499\
    \ = 6531, which\n   is again rounded up to 8k of DMS.\n"
- title: 3.  UDVM Instructions
  contents:
  - '3.  UDVM Instructions

    '
- title: 3.1.  Data Input Instructions
  contents:
  - "3.1.  Data Input Instructions\n   When inputting data from the compressed message,\
    \ the INPUT-BYTES (RFC\n   3320-Section 9.4.2) and INPUT-BITS (RFC 3320-Section\
    \ 9.4.3)\n   instructions both have the paragraph:\n   \"If the instruction requests\
    \ data that lies beyond the end of the\n   SigComp message, no data is returned.\
    \  Instead the UDVM moves program\n   execution to the address specified by the\
    \ address operand.\"\n   The intent is that if n bytes/bits are requested, but\
    \ only m are left\n   in the message (where m < n), then the decompression dispatcher\
    \ MUST\n   NOT return any bytes/bits to the UDVM, and the m bytes/bits that are\n\
    \   there MUST remain in the message unchanged.\n   For example, if the remaining\
    \ bytes of a message are: 0x01 0x02 0x03\n   and the UDVM encounters an INPUT-BYTES\
    \ (6, a, b) instruction.  Then\n   the decompressor dispatcher returns no bytes\
    \ and jumps to the\n   instruction specified by b.  This contains an INPUT-BYTES\
    \ (2, c, d)\n   instruction so the decompressor dispatcher successfully returns\
    \ the\n   bytes 0x01 and 0x02.\n   In the case where an INPUT-BYTES instruction\
    \ follows an INPUT-BITS\n   instruction that has left a partial byte in the message,\
    \ the partial\n   byte should still be thrown away even if there are not enough\
    \ bytes\n   to input.\n   INPUT-BYTES (0, a, b) can be used to flush out a partial\
    \ byte.\n"
- title: 3.2.  MULTILOAD
  contents:
  - "3.2.  MULTILOAD\n   In order to make step-by-step implementation simpler, the\
    \ MULTILOAD\n   instruction is explicitly not allowed to write into any memory\n\
    \   positions occupied by the MULTILOAD opcode or any of its parameters.\n   Additionally,\
    \ if there is any indirection of parameters, the\n   indirection MUST be done\
    \ at execution time.\n   Any implementation technique other than a step-by-step\
    \ implementation\n   (e.g., decode all operands then execute, which is the model\
    \ of all\n   other instructions) MUST yield the same result as a step-by-step\n\
    \   implementation would.\n   For example:\n   at (64)\n   :location_a       \
    \              pad (2)\n   :location_b                     pad (2)\n   :location_c\
    \                     pad (2)\n   pad (30)\n   :udvm_memory_size             \
    \  pad (2)\n   :circular_buffer                pad (2)\n   align (64)\n   MULTILOAD\
    \ (location_a, 3, circular_buffer,\n                   udvm_memory_size, $location_a)\n\
    \   The step-by-step implementation would: write the address of\n   circular_buffer\
    \ into location_a (memory address 64); write the\n   address of udvm_memory_size\
    \ into location_a + 2 (memory address 66);\n   write the value stored in location_a\
    \ (accessed using indirection -\n   that is now the address of circular_buffer)\
    \ into location_a + 4\n   (memory address 68).  Therefore, at the end of the execution\
    \ by a\n   correct implementation, location_c will contain the address of\n  \
    \ circular_buffer.\n"
- title: 3.3.  STATE-FREE
  contents:
  - "3.3.  STATE-FREE\n   The STATE-FREE instruction does not check the minimum_access_length.\n\
    \   This is correct because the state cannot be freed until the\n   application\
    \ has authenticated the message.  The lack of checking does\n   not pose a security\
    \ risk because if the sender has enough information\n   to create authenticated\
    \ messages, then sending messages that save\n   state can push previous state\
    \ out of storage anyway.\n   The STATE-FREE instruction can only free state in\
    \ the compartment\n   that corresponds to the message being decompressed.  Attempting\
    \ to\n   free state that is either from another compartment, or that is not\n\
    \   associated with any compartment, has no effect.\n"
- title: 3.4.  Using the Stack
  contents:
  - "3.4.  Using the Stack\n   The instructions PUSH, POP, CALL, and RETURN make use\
    \ of a stack that\n   is set up using the well-known memory address stack_location\
    \ to\n   define where in memory the stack is located.  Use of the stack is\n \
    \  defined in RFC 3320-Section 8.3, which states: '\"Pushing\" a value on\n  \
    \ the stack is an abbreviation for copying the value to\n   stack[stack_fill]\
    \ and then increasing stack_fill by 1.' and\n   'stack_fill is an abbreviation\
    \ for the 2-byte word at stack_location\n   and stack_location + 1'.\n   In the\
    \ very rare case that the value of stack_fill is 0xFFFF when a\n   value is pushed\
    \ onto the stack, then the original stack_fill value\n   MUST be increased by\
    \ 1 to 0x0000 and written back to stack_location\n   and stack_location + 1 (which\
    \ will overwrite the value that has been\n   pushed onto the stack).\n      The\
    \ new value pushed onto the stack has, in theory, been written\n      to stack\
    \ [0xFFFF] = stack_location.  Stack_fill would then be\n      increased by 1;\
    \ however, the value at stack_location and\n      stack_location + 1 has just\
    \ been updated.  To maintain the\n      integrity of the stack with regard to\
    \ over and underflow,\n      stack_fill cannot be re-read at this point, and the\
    \ pushed value\n      is overwritten.\n"
- title: 4.  Byte Copying Rules
  contents:
  - "4.  Byte Copying Rules\n   RFC 3320-Section 8.4 states that \"The string of bytes\
    \ is copied in\n   ascending order of memory address, respecting the bounds set\
    \ by\n   byte_copy_left and byte_copy_right.\"  This is misleading in that it\n\
    \   is perfectly legitimate to copy bytes outside of the bounds set by\n   byte_copy_left\
    \ and byte_copy_right.  Byte_copy_left and\n   byte_copy_right provide the ability\
    \ to maintain a circular buffer as\n   follows:\n   For moving to the right\n\
    \   if current_byte == ((byte_copy_right - 1) mod 2 ^ 16):\n       next_byte =\
    \ byte_copy_left\n   else:\n       next_byte = (current_byte + 1) mod 2 ^ 16\n\
    \   which is equivalent to the algorithm given in RFC 3320-Section 8.4.\n   For\
    \ moving to the left\n   if current_byte == byte_copy_left:\n       previous_byte\
    \ = (byte_copy_right - 1) mod 2 ^ 16\n   else:\n       previous_byte = (current_byte\
    \ - 1) mod 2 ^ 16\n   Moving to the left is only used for COPY_OFFSET.\n   Consequently,\
    \ copying could begin to the left of byte_copy_left and\n   continue across it\
    \ (and jump back to it according to the given\n   algorithm if necessary) and\
    \ could begin at or to the right of\n   byte_copy_right (though care must be taken\
    \ to prevent decompression\n   failure due to writing to / reading from beyond\
    \ the UDVM memory).\n   For further clarity: consider the UDVM memory laid out\
    \ as follows,\n   with byte_copy_left and byte_copy_right in the locations indicated\
    \ by\n   \"BCL\" and \"BCR\", respectively:\n   +----------------------------------------+\n\
    \   |                                        |\n   +----------^------------^----------------+\n\
    \             BCL          BCR\n   If an opcode read or wrote bytes starting to\
    \ the left of\n   byte_copy_left, it would do so in the following order:\n   +----------------------------------------+\n\
    \   |       abcdefghijkl                     |\n   +----------^------------^----------------+\n\
    \             BCL          BCR\n   If the opcode continues to read or write until\
    \ it reaches\n   byte_copy_right, it would then wrap around to byte_copy_left\
    \ and\n   continue (letters after the wrap are capitalized for clarity):\n   +----------------------------------------+\n\
    \   |       abcQRSTUVjklmnop                 |\n   +----------^------------^----------------+\n\
    \             BCL          BCR\n   Similarly, writing to the right of byte_copy_right\
    \ is a perfectly\n   valid operation for opcodes that honor byte copying rules:\n\
    \   +----------------------------------------+\n   |                         \
    \ abcdefg       |\n   +----------^------------^----------------+\n           \
    \  BCL          BCR\n   A final, somewhat odd relic of the foregoing rules occurs\
    \ when\n   byte_copy_right is actually less than byte_copy_left.  In this case,\n\
    \   reads and writes will skip the memory between the pointers:\n   +----------------------------------------+\n\
    \   |     abcde             fghijkl          |\n   +----------^------------^----------------+\n\
    \             BCR          BCL\n"
- title: 4.1.  Instructions That Use Byte Copying Rules
  contents:
  - "4.1.  Instructions That Use Byte Copying Rules\n   This document amends the list\
    \ of instructions that obey byte copying\n   rules in RFC 3320-Section 8.4 to\
    \ include STATE-CREATE and CRC.\n   RFC 3320-Section 8.4 specifies the byte copying\
    \ rules and includes a\n   list of the instructions that obey them.  STATE-CREATE\
    \ is not in this\n   list but END-MESSAGE is.  This caused confusion due to the\
    \ fact that\n   neither instruction actually does any byte copying; rather, both\n\
    \   instructions give information to the state-handler to create state.\n   Logically,\
    \ both instructions should have the same information about\n   byte copying.\n\
    \   When state is created by the state-handler (whether from an END-\n   MESSAGE\
    \ or a STATE-CREATE instruction), the byte copying rules of RFC\n   3320-Section\
    \ 8.4 apply.\n   Note that, if the contents of the UDVM changes between the occurrence\n\
    \   of the STATE-CREATE instruction and the state being created, the\n   bytes\
    \ that are stored are those in the buffer at the time of creation\n   (i.e., when\
    \ the message has been decompressed and authenticated).\n   CRC is not mentioned\
    \ in RFC 3320-Section 8.4 in the list of\n   instructions that obey byte copying\
    \ rules, but its description in RFC\n   3320-Section 9.3.5 states that these rules\
    \ are to be obeyed.  When\n   reading data over which to perform the CRC check,\
    \ byte copying rules\n   apply as specified in RFC 3320-Section 8.4.\n   When\
    \ the partial identifier for a STATE-FREE instruction is read,\n   (during the\
    \ execution of END-MESSAGE) byte copying rules as per RFC\n   3320-Section 8.4\
    \ apply.\n   Given that reading the buffer for creating and freeing state within\n\
    \   the END-MESSAGE instruction obeys byte copying rules, there may be\n   some\
    \ confusion as to whether reading feedback items should also obey\n   byte copying\
    \ rules.  Byte copying rules do not apply for reading\n   feedback items.\n"
- title: 5.  State Retention Priority
  contents:
  - '5.  State Retention Priority

    '
- title: 5.1.  Priority Values
  contents:
  - "5.1.  Priority Values\n   For state_retention_priority, 65535 < 0 < 1 < ... <\
    \ 65534.  This is\n   slightly counter intuitive, but is correct.\n"
- title: 5.2.  Multiple State Retention Priorities
  contents:
  - "5.2.  Multiple State Retention Priorities\n   There may be confusion when the\
    \ same piece of state is created at two\n   different retention priorities.  The\
    \ following clarifies this:\n      The retention priority MUST be associated with\
    \ the compartment and\n      not with the piece of state.  For example, if endpoint\
    \ A creates a\n      piece of state with retention priority 1 and endpoint B creates\n\
    \      exactly the same state with retention priority 2, there should be\n   \
    \   one copy (assuming the model of state management suggested in\n      SigComp\
    \ [1]) of the actual state, but each compartment should keep\n      a record of\
    \ this piece of state with its own priority.  (If this\n      does not happen\
    \ then the state could be kept for longer than A\n      anticipated or less time\
    \ than B anticipated, depending on which\n      priority is used.  This could\
    \ cause Decompression Failure to\n      occur.)\n      If the same piece of state\
    \ is created within a compartment with a\n      different priority, then one copy\
    \ of it should be stored with the\n      new priority and it MUST count only once\
    \ against SMS.  That is,\n      the state creation updates the priority rather\
    \ than creates a new\n      piece of state.\n"
- title: 5.3.  Retention Priority 65535 (or -1)
  contents:
  - "5.3.  Retention Priority 65535 (or -1)\n   There is potentially a problem with\
    \ storing multiple pieces of state\n   with the minimum retention priority (65535)\
    \ as defined in SigComp\n   [1].  This can be shown by considering the following\
    \ examples that\n   are of shared mode, which is documented in SigComp Extended\
    \ [2].  The\n   key thing about state with retention priority 65535 is that it\
    \ can be\n   created by an endpoint in the decompressor compartment without the\n\
    \   knowledge of the remote compressor (which controls state creation in\n   the\
    \ decompressor compartment).\n   Example 1:\n       [SMn state is shared mode\
    \ state (priority 65535),\n        BC is bytecode state (priority 1),\n      \
    \  BFn is buffer state (priority 0)]\n       Endpoint A                  Endpoint\
    \ B\n       [decomp cpt]                [comp cpt]\n       [SM1]\n       ------------------------------->\n\
    \                                   [SM1]\n       [SM1, SM2]\n       --------------------X\
    \ (message lost)\n                                   [SM1, BC, BF1]\n       <------------ref\
    \ SM1------------\n       [SM2, BC, BF1]\n                                   endpoint\
    \ B still believes SM1\n                                   is at endpoint A\n\
    \                                   [BC, BF1, BF2]\n       <------------ref SM1------------\n\
    \       decompression failure at A\n       because SM1 has already been deleted\n\
    \   Example 2:\n       Endpoint A                  Endpoint B\n       [decomp\
    \ cpt]                [comp cpt]\n       [SM1]\n       ------------------------------->\n\
    \                                   [SM1]\n                                  \
    \ [SM1, BC, BF1]\n       (message lost)X------ref SM1-----\n       [SM1, SM2]\n\
    \       ------------------------------->\n                                   endpoint\
    \ B does not create SM2\n                                   because there is no\
    \ space\n                                   [SM1, BC, BF1]\n                 \
    \                  [SM1, BC, BF1, BF2]\n       <------------ref SM1------------\n\
    \       [SM2, BC, BF2]\n                                   endpoint B still believes\
    \ SM1\n                                   is at endpoint A\n                 \
    \                  [BC, BF1, BF2, BF3]\n       <------------ref SM1------------\n\
    \       decompression failure at A\n       because SM1 has already been deleted\n\
    \                Figure 2: Retention priority 65535 examples\n   Once there is\
    \ more than one piece of minimum priority state created\n   in a decompressor\
    \ compartment, the corresponding compressor cannot be\n   certain about which\
    \ pieces of state are present in that\n   (decompressor) compartment.  If there\
    \ is only one piece of state,\n   then no such ambiguity exists.\n   The problem\
    \ is a consequence of the different rules for the creation\n   of minimum priority\
    \ state.  In particular, the creation of the second\n   piece of state without\
    \ the knowledge of the compressor could mean\n   that the first piece is pushed\
    \ out earlier than the compressor\n   expects (despite the fact that the state\
    \ processing rules from\n   SigComp [1] are being implemented correctly).\n  \
    \ SigComp [1] also states that a compressor MUST be certain that all of\n   the\
    \ data needed to decompress a SigComp message is available at the\n   receiving\
    \ endpoint.  Thus, it SHOULD NOT reference any state unless\n   it can be sure\
    \ that the state exists.  The fact that the compressor\n   at B has no way of\
    \ knowing how much state has been created at A can\n   lead to a loss of synchronization\
    \ between the endpoints, which is not\n   acceptable.\n   One observation is that\
    \ it is always safe to reference a piece of\n   minimum priority state following\
    \ receipt of the advertisement of the\n   state.\n   If it is known that both\
    \ endpoints are running SigComp version 2, as\n   defined in NACK [3], then an\
    \ endpoint MAY assume that the likelihood\n   of a loss of synchronization is\
    \ very small, and rely on the NACK\n   mechanism for recovery.\n   However, for\
    \ a compressor to try and avoid causing the generation of\n   NACKs, it has to\
    \ be able to make some assumptions about the behavior\n   of the peer compressor.\
    \  Also, if one of the endpoints does not\n   support NACK, then some other solution\
    \ is needed.\n   Consequently, where NACK is not supported or for NACK averse\n\
    \   compressors, the recommendation is that only one piece of minimum\n   priority\
    \ state SHOULD be present in a compartment at any one time.\n   If both endpoints\
    \ support NACK [3], then this recommendation MAY be\n   relaxed, but implementers\
    \ need to think carefully about the\n   consequences of creating multiple pieces\
    \ of minimum priority state.\n   In either case, if the behavior of the application\
    \ restricts the\n   message flow, this fact could be exploited to allow safe creation\
    \ of\n   multiple minimum priority states; however, care must still be taken.\n\
    \   Note that if a compressor wishes the remote endpoint to be able to\n   create\
    \ a new piece of minimum priority state, it can use the STATE-\n   FREE instruction\
    \ to remove the existing piece of state.\n"
- title: 6.  Duplicate State
  contents:
  - "6.  Duplicate State\n   If a piece of state is created in a compartment in which\
    \ it already\n   exists, the time of its creation SHOULD be updated as if it had\
    \ just\n   been created, irrespective of whether or not there is a new state\n\
    \   retention priority.\n"
- title: 7.  State Identifier Clashes
  contents:
  - "7.  State Identifier Clashes\n   RFC 3320-Section 6.2 states that when creating\
    \ a piece of state, the\n   full 20-byte hash should be checked to see whether\
    \ or not another\n   piece of state with this identifier exists.  If it does,\
    \ and the\n   state item is not identical, then the new creation MUST fail.  It\
    \ is\n   stated that the probability of this occurring is vanishingly small\n\
    \   (and so it is, see below).\n   However, when state is accessed, only the first\
    \ n bytes of the state\n   identifier are used, where n could be as low as 6.\
    \  At this point, if\n   there are two pieces of state with the same first n bytes\
    \ of state\n   identifier, the STATE-ACCESS instruction will cause decompression\n\
    \   failure.  The compressor referencing the state will not expect this\n   failure\
    \ mode because the state creation succeeded without a clash.\n   At a server endpoint\
    \ where there could be thousands or millions of\n   pieces of state, how likely\
    \ is this to actually happen?\n   Consider the birthday paradox (where there only\
    \ have to be 23 people\n   in a room to have a greater than 50% chance that two\
    \ of them will\n   have the same birthday (Birthday [8])).\n   The naive calculation\
    \ using factorials gives:\n                      N!\n   Pd(N,s) = 1 - -------------\n\
    \                 (N - s)! N^s\n   where N is the number of possible values and\
    \ s is the sample size.\n   However, due to dealing with large numbers, an approximation\
    \ is\n   needed:\n   Pd(N,s) = 1 - e^( LnFact(N) - LnFact(N-s) - s Ln(N) )\n \
    \  where LnFact (x) is the log of x!, which can be approximated by:\n   LnFact(x)\
    \ ~ (x + 1/2) Ln(x) - x + Ln(2*Pi)/2 +\n                1       1         1  \
    \         1\n               --- - ------- + -------- - --------\n            \
    \   12x   360 x^3   1260 x^5   1680 x^7\n   which using N = 2^48 [6 octet partial\
    \ state identifier] gives:\n   s = 1 000 000: Pd (N,s) = 0.018%\n   s = 10 000\
    \ 000: Pd (N,s) = 16.28%\n   s = 100 000 000: Pd (N,s) = 100.00%\n   so when implementing,\
    \ thought should be given as to whether or not 6\n   octets of state identifier\
    \ is enough to ensure that state access will\n   be successful (particularly at\
    \ a server).\n   The likelihood of a clash when using the full 20 octets of state\n\
    \   identifier, does indeed have a vanishingly small probability:\n   using N\
    \ = 2^160 [full 20 octet state identifier] gives:\n   s = 1 000 000: Pd (N,s)\
    \ = 3.42E-35%\n   s = 10 000 000: Pd (N,s) = 3.42E-33%\n   s = 100 000 000: Pd\
    \ (N,s) = 3.42E-31%\n   Consequently, care must be taken when deciding how many\
    \ octets of\n   state identifier to use to access state at the server.\n"
- title: 8.  Message Misordering
  contents:
  - "8.  Message Misordering\n   SigComp [1] makes only one reference to the possibility\
    \ of misordered\n   messages.  However, the statement that the 'compressor MUST\
    \ ensure\n   that the message can be decompressed using the resources available\
    \ at\n   the remote endpoint' puts the onus on the compressor to take account\n\
    \   of the possibility of misordering occurring.\n   Whether misordering can occur\
    \ and whether that would have an impact\n   depends on the compartment definition\
    \ and the transport protocol in\n   use.  Therefore, it is up to the implementer\
    \ of the compressor to\n   take these factors into account.\n"
- title: 9.  Requested Feedback
  contents:
  - '9.  Requested Feedback

    '
- title: 9.1.  Feedback When SMS Is Zero
  contents:
  - "9.1.  Feedback When SMS Is Zero\n   If an endpoint receives a request for feedback,\
    \ then it SHOULD return\n   the feedback even if its SMS is zero.  The storage\
    \ overhead of the\n   requested feedback is NOT part of the SMS.\n"
- title: 9.2.  Updating Feedback Requests
  contents:
  - "9.2.  Updating Feedback Requests\n   When an endpoint receives a valid message\
    \ it updates the requested\n   feedback data for that compartment.  RFC 3320-Section\
    \ 5 states that\n   there is no need to transmit any requested feedback item more\
    \ than\n   once.  However, there are cases where it would be beneficial for the\n\
    \   feedback to be sent more than once (e.g., a retransmitted 200 OK SIP\n   message\
    \ [9] to an INVITE SIP message implies that the original 200\n   OK, and the feedback\
    \ it carried, might not have reached the remote\n   endpoint).  Therefore, an\
    \ endpoint SHOULD transmit feedback\n   repeatedly until it receives another valid\
    \ message that updates the\n   feedback.\n   RFC 3320-Section 9.4.9 states that\
    \ when requested_feedback_location\n   equals zero, no feedback request is made.\
    \  However, there is no\n   indication of whether this means that the existing\
    \ feedback data is\n   left untouched or if this means that the existing feedback\
    \ data\n   SHOULD be overwritten to be 'no feedback data'.  If\n   requested_feedback_location\
    \ equals zero, the existing feedback data\n   SHOULD be left untouched and returned\
    \ in any subsequent messages as\n   before.\n   RFC 3320-Section 9.4.9 also makes\
    \ no statement about what happens to\n   existing feedback data when requested_feedback_location\
    \ does not\n   equal zero but the Q flag indicating the presence/absence of a\n\
    \   requested_feedback_item is zero.  In this case, the existing feedback\n  \
    \ data SHOULD be overwritten to be 'no feedback data'.\n"
- title: 10.  Advertising Resources
  contents:
  - '10.  Advertising Resources

    '
- title: 10.1.  The I-bit and Local State Items
  contents:
  - "10.1.  The I-bit and Local State Items\n   The I-bit in requested feedback is\
    \ a mechanism by which a compressor\n   can tell a remote endpoint that it is\
    \ not going to access any local\n   state items.  By doing so, it gives the remote\
    \ endpoint the option of\n   not advertising them in subsequent messages.  Setting\
    \ the I-bit does\n   not obligate the remote endpoint to cease sending advertisements.\n\
    \   The remote endpoint SHOULD still advertise its parameters such as DMS\n  \
    \ and state memory size (SMS).  (This is particularly important; if the\n   sender\
    \ of the first message sets the I-bit, it will still want the\n   advertisement\
    \ of parameters from the receiver.  If it doesn't receive\n   these, it has to\
    \ assume the default parameters which will affect\n   compression efficiency.)\n\
    \   The endpoint receiving an I-bit of 1 can reclaim the memory used to\n   store\
    \ the locally available state items.  However, this has NO impact\n   on any state\
    \ that has been created by the sender using END-MESSAGE or\n   STATE-CREATE instructions.\n"
- title: 10.2.  Dynamic Update of Resources
  contents:
  - "10.2.  Dynamic Update of Resources\n   Decompressor resources such as SMS and\
    \ DMS can be dynamically updated\n   at the compressor by use of the SMS and DMS\
    \ bits in returned\n   parameters feedback (see RFC 3320-Section 9.4.9).  Changing\
    \ resources\n   dynamically (apart from initial advertisements for each compartment)\n\
    \   is not expected to happen very often.\n   If additional resources are advertised\
    \ to a compressor, then it is up\n   to the implementation at the compressor whether\
    \ or not to make use of\n   these resources.  For example, if the decompressor\
    \ advertises 8k SMS\n   but the compressor only has 4k SMS, then the compressor\
    \ MAY choose\n   not to use the extra 4k (e.g., in order to monitor state saved\
    \ at the\n   decompressor).  In this case, there is no synchronization problem.\n\
    \   The compressor MUST NOT use more than the most recently advertised\n   resources.\
    \  Note that the compressor SMS is unofficial (it enables\n   the compressor to\
    \ monitor decompressor state) and is separate from\n   the SMS advertised by the\
    \ decompressor.\n   Reducing the resources has potential synchronization issues\
    \ and so\n   SHOULD NOT be done unless absolutely necessary.  If this is the case\n\
    \   then the memory MUST NOT be reclaimed until the remote endpoint has\n   acknowledged\
    \ the message sent with the advertisement.  If state is to\n   be deleted to accommodate\
    \ a reduction in SMS then both endpoints MUST\n   delete it according to the state\
    \ retention priority (see RFC 3320-\n   Section 6.2).  The compressor MUST NOT\
    \ then use more than the amount\n   of resources most recently advertised.\n"
- title: 10.3.  Advertisement of Locally Available State Items
  contents:
  - "10.3.  Advertisement of Locally Available State Items\n   RFC 3320-Section 3.3.3\
    \ defines locally available state items to be\n   the pieces of state that an\
    \ endpoint has available but that have not\n   been uploaded by the SigComp message.\
    \  The examples given are\n   dictionaries and well known pieces of bytecode;\
    \ and the advertisement\n   mechanism discussed in RFC 3320-Section 9.4.9 provides\
    \ a way for the\n   endpoint to advertise the pieces of locally available state\
    \ that it\n   has.\n   However, SigComp [1] does not (nor was it ever intended\
    \ to) fully\n   define the use of locally available state items, in particular,\
    \ the\n   length of time for which they will be available.  The use of locally\n\
    \   available state items is left for definition in other documents.\n   However,\
    \ this fact, coupled with the fact that SigComp does contain\n   some hooks for\
    \ uses of locally available state items and the fact\n   that some of the definitions\
    \ of such uses (in SigComp Extended [2])\n   are incomplete has caused some confusion.\
    \  Therefore, this section\n   clarifies the situation.\n   Note that any definitions\
    \ of uses of locally available state items\n   MUST NOT conflict with any other\
    \ uses.\n"
- title: 10.3.1.  Basic SigComp
  contents:
  - "10.3.1.  Basic SigComp\n   SigComp provides a mechanism for an endpoint to advertise\
    \ locally\n   available state (RFC 3320-Section 9.4.9).  If the endpoint receiving\n\
    \   the advertisement does not 'recognize' it and therefore know the\n   properties\
    \ of the state e.g., its length and lifetime, the compressor\n   needs to consider\
    \ very carefully whether or not to access the state;\n   especially if NACK [3]\
    \ is not available.\n   SigComp provides the following hooks for use in conjunction\
    \ with\n   locally available state items.  Without further definition, locally\n\
    \   available state SHOULD NOT be used.\n   RFC 3320-Section 6.2 allows for the\
    \ possibility to map locally\n   available state items to a compartment and states\
    \ that, if this is\n   done, the state items MUST have state retention priority\
    \ 65535 in\n   order to not interfere with state created at the request of the\n\
    \   remote compressor.  Note that Section 5.3 also recommends that only\n   one\
    \ such piece of state SHOULD be created per compartment.\n   The I-bit in the\
    \ requested_feedback_location (see RFC 3320-Section\n   9.4.9) allows a compressor\
    \ to indicate to the remote endpoint that it\n   will not reference any of the\
    \ previously advertised locally available\n   state.  Depending on the implementation\
    \ model for state handling at\n   the remote endpoint, this could allow the remote\
    \ endpoint to reclaim\n   the memory being used by such state items.\n"
- title: 10.3.2.  Dictionaries
  contents:
  - "10.3.2.  Dictionaries\n   The most basic use of the local state advertisement\
    \ is the\n   advertisement of a dictionary (e.g., the dictionary specified by\
    \ SIP/\n   SDP Static Dictionary [4]) or a piece of bytecode.  In general, these\n\
    \   pieces of state:\n   o  are not mapped to compartments\n   o  are local to\
    \ the endpoint\n   o  are available for at least the duration of the compartment\n\
    \   o  do not have any impact on the compartment SMS\n   However, for a given\
    \ piece of state the exact lifetime needs to be\n   defined e.g., in public specifications\
    \ such as SigComp for SIP [7] or\n   the 3GPP IMS specification [10].  Such a\
    \ specification should also\n   indicate whether or not advertisement of the state\
    \ is needed.\n"
- title: 10.3.3.  SigComp Extended Mechanisms
  contents:
  - "10.3.3.  SigComp Extended Mechanisms\n   SigComp Extended [2] defines some uses\
    \ of local state advertisements\n   for which additional clarification is provided\
    \ here.\n   Shared-mode (see RFC 3321-Section 5.2) is well-defined (when combined\n\
    \   with the clarification in Section 5.3).  In particular, the states\n   that\
    \ are created and advertised are mapped into the compartment, have\n   the minimum\
    \ retention priority and persist only until they are\n   deleted by the creation\
    \ of new (non-minimum retention priority) state\n   or use of a STATE-FREE instruction.\n\
    \   The definition of endpoint initiated acknowledgments (RFC 3321-\n   Section\
    \ 5.1.2) requires clarification in order to ensure that the\n   definition does\
    \ not preclude advertisements being used to indicate\n   that state will be kept\
    \ beyond the lifetime of the compartment (as\n   discussed in SigComp for SIP\
    \ [7]).  Thus the clarification is:\n      Where Endpoint A requests state creation\
    \ at Endpoint B, Endpoint B\n      MAY subsequently advertise the hash of the\
    \ created state item to\n      Endpoint A.  This conveys to Endpoint A (i) that\
    \ the state has\n      been successfully created within the compartment; and (ii)\
    \ that\n      the state will be available for at least the lifetime of the state\n\
    \      as defined by the state deletion rules according to age and\n      retention\
    \ priority of SigComp [1].  If the state is available at\n      Endpoint B after\
    \ it would be deleted from the compartment\n      according to [1], then the state\
    \ no longer counts towards the SMS\n      of the compartment.  Since there is\
    \ no guarantee of such state\n      being available beyond its normally defined\
    \ lifetime, endpoints\n      SHOULD only attempt to access the state after this\
    \ time where it\n      is known that NACK [3] is available.\n"
- title: 11.  Uncompressed Bytecode
  contents:
  - "11.  Uncompressed Bytecode\n   It is possible to write bytecode that simply instructs\
    \ the\n   decompressor to output the entire message (effectively sending it\n\
    \   uncompressed, but within a SigComp message).  This is particularly\n   useful\
    \ if the bytecode is well-known (so that decompressors can\n   recognize and output\
    \ the bytes without running a VM if they wish);\n   therefore, it is documented\
    \ here.\n   The mnemonic code is:\n   at (0)\n   :udvm_memory_size         pad\
    \ (2)\n   :cycles_per_bit           pad (2)\n   :sigcomp_version          pad\
    \ (2)\n   :partial_state_id_length  pad (2)\n   :state_length             pad\
    \ (2)\n   :reserved                 pad (2)\n   at (64)\n   :byte_copy_left  \
    \         pad (2)\n   :byte_copy_right          pad (2)\n   :input_bit_order \
    \         pad (2)\n   :stack_location           pad (2)\n   ; Simple loop\n  \
    \ ;       Read a byte\n   ;       Output a byte\n   ; Until there are no more\
    \ bytes!\n   at (128)\n   :start\n   INPUT-BYTES (1, byte_copy_left, end)\n  \
    \ OUTPUT (byte_copy_left, 1)\n   JUMP (start)\n   :end\n   END-MESSAGE (0,0,0,0,0,0,0)\n\
    \   which translates to give the following SigComp message:\n   0xf8, 0x00, 0xa1,\
    \ 0x1c, 0x01, 0x86, 0x09, 0x22, 0x86, 0x01, 0x16,\n   0xf9, 0x23\n"
- title: 12.  RFC 3485 SIP/SDP Static Dictionary
  contents:
  - "12.  RFC 3485 SIP/SDP Static Dictionary\n   SIP/SDP Static Dictionary [4] provides\
    \ a dictionary of strings\n   frequently used in SIP and SDP messages.  The format\
    \ of the\n   dictionary is the list of strings followed by a table of offset\n\
    \   references to the strings so that a compressor can choose to\n   reference\
    \ the address of the string or the entry in the table.  Both\n   parts of the\
    \ dictionary are divided into 5 prioritized sections to\n   allow compressors\
    \ to choose how much of it they use (which is\n   particularly useful in the case\
    \ where it has to be downloaded).  If\n   only part of the dictionary is used,\
    \ then the corresponding sections\n   of both parts (strings and offset table)\
    \ are used.\n   However, there are some minor bugs in the dictionary.  In a number\
    \ of\n   places, the entry in the offset table refers to an address that is\n\
    \   not in the corresponding priority section in the list of strings.\n   Consequently,\
    \ if the bytecode uses the offset table and limits use of\n   the dictionary to\
    \ priorities less than 4, then care must be taken not\n   to use the following\
    \ strings in the dictionary:\n      'application' at 0x0334 is not at priority\
    \ 2 (it's priority 4)\n      'sdp' at 0x064b is not at priority 2 (it's priority\
    \ 4)\n      'send' at 0x089d is not at priority 2 (it's priority 3)\n      'recv'\
    \ at 0x0553 is not at priority 2 (it's priority 4)\n      'phone' at 0x00f2 is\
    \ not at priority 3 (it's priority 4)\n   This document does not correct the dictionary,\
    \ as any changes to the\n   dictionary itself would be non-backwards-compatible,\
    \ and require all\n   implementations to maintain two different copies of the\
    \ dictionary.\n   Such a cost is far too high for a bug that is trivial to work\
    \ around\n   and has a negligible effect on compression ratios.  Instead, the\
    \ flaw\n   is pointed out to allow implementers to avoid any consequent\n   problems.\
    \  Specifically, if the bytecode sent to a remote endpoint\n   contains instructions\
    \ that load only a sub-portion of the SIP/SDP\n   dictionary, then the input stream\
    \ provided to that bytecode cannot\n   reference any of these five offsets in\
    \ the offset table, unless the\n   corresponding string portion of the dictionary\
    \ has also been loaded.\n   For example, if bytecode loads only the first three\
    \ priorities of the\n   dictionary (both string and offset table), use of the\
    \ offset for\n   \"send\" (at 0x089d) would be valid; however, use of the offset\
    \ for\n   \"phone\" (at 0x00f2) would not.\n"
- title: 13.  Security Considerations
  contents:
  - "13.  Security Considerations\n   This document updates SigComp [1], SigComp Extended\
    \ [2], and the\n   SigComp Static Dictionary [4].  The security considerations\
    \ for [2]\n   and [4] are the same as for [1]; therefore, this section discusses\n\
    \   only how the security considerations for [1] are affected by the\n   updates.\n\
    \   Several security risks are discussed in [1].  These are discussed\n   briefly\
    \ here; however, this update does not change the security\n   considerations of\
    \ SigComp:\n      Snooping into state of other users - this is mitigated by using\
    \ at\n      least 48 bits from the hash.  This update does not reduce the\n  \
    \    minimum and recommends use of more bits under certain\n      circumstances.\n\
    \      Faking state or making unauthorized changes - this is mitigated by\n  \
    \    the fact that the application layer has to authorize state\n      manipulation.\
    \  This update does not change that mechanism.\n      Use of SigComp as a tool\
    \ in a Denial of Service (DoS) attack -\n      this is mitigated by the fact that\
    \ SigComp only generates one\n      decompressed message per incoming compressed\
    \ message.  That is not\n      changed by this update.\n      Attacking SigComp\
    \ as the DoS target by filling with state - this\n      is mitigated by the fact\
    \ that the application layer has to\n      authorize state manipulation.  This\
    \ update does not change that\n      mechanism.\n      Attacking the UDVM by sending\
    \ it looping code - this is mitigated\n      by the upper limit of \"UDVM cycles\"\
    , which is unchanged by this\n      update.\n"
- title: 14.  IANA Considerations
  contents:
  - "14.  IANA Considerations\n   This document updates SigComp [1], but does not\
    \ change the version.\n   Consequently, the IANA considerations are the same as\
    \ those for [1].\n   This document updates SigComp Extended [2], but does not\
    \ change the\n   version.  Consequently, the IANA considerations are the same\
    \ as those\n   for [2].\n   This document updates Static Dictionary [4], but does\
    \ not change the\n   version.  Consequently, the IANA considerations are the same\
    \ as those\n   for [4].\n"
- title: 15.  Acknowledgements
  contents:
  - "15.  Acknowledgements\n   We would like to thank the following people who, largely\
    \ through\n   being foolish enough to be authors or implementors of SigComp, have\n\
    \   provided us their confusion, suggestions, and comments:\n      Richard Price\n\
    \      Lajos Zaccomer\n      Timo Forsman\n      Tor-Erik Malen\n      Jan Christoffersson\n\
    \      Kwang Mien Chan\n      William Kembery\n      Pekka Pessi\n"
- title: 16.  References
  contents:
  - '16.  References

    '
- title: 16.1.  Normative References
  contents:
  - "16.1.  Normative References\n   [1]   Price, R., Borman, C., Christoffersson,\
    \ J., Hannu, H., Liu, Z.,\n         and J. Rosenberg, \"Signaling Compression\
    \ (SigComp)\", RFC 3320,\n         January 2003.\n   [2]   Hannu, H., Christoffersson,\
    \ J., Forsgren, S., Leung, K., Liu,\n         Z., and R. Price, \"Signaling Compression\
    \ (SigComp) - Extended\n         Operations\", RFC 3321, January 2003.\n   [3]\
    \   Roach, A., \"A Negative Acknowledgement Mechanism for Signaling\n        \
    \ Compression)\", RFC 4077, October 2004.\n   [4]   Garcia-Martin, M., Borman,\
    \ C., Ott, J., Price, R., and A.\n         Roach, \"The Session Initiation Protocol\
    \ (SIP) and Session\n         Description Protocol (SDP) Static Dictionary for\
    \ Signaling\n         Compression (SigComp)\", RFC 3485, February 2003.\n   [5]\
    \   Bradner, S., \"Key words for use in RFCs to Indicate Requirement\n       \
    \  Levels\", RFC 2119, March 1997.\n"
- title: 16.2.  Informative References
  contents:
  - "16.2.  Informative References\n   [6]   Crocker, D. and P. Overell, \"Augmented\
    \ BNF for Syntax\n         Specifications (ABNF)\", RFC 2234, November 1997.\n\
    \   [7]   Borman, C., Liu, Z., Price, R., and G. Camarillo, \"Applying\n     \
    \    Signaling Compression (SigComp) to the Session Initiation\n         Protocol\
    \ (SIP)\", Work in Progress, November 2006.\n   [8]   Ritter, T., \"Estimating\
    \ Population from Repetitions in\n         Accumulated Random Samples\", 1994,\n\
    \         <http://www.ciphersbyritter.com/ARTS/BIRTHDAY.HTM>.\n   [9]   Rosenberg,\
    \ J., Schulzrinne, H., Camarillo, G., Johnston, A.,\n         Peterson, J., Sparks,\
    \ R., Handley, M., and E. Schooler, \"SIP:\n         Session Initiation Protocol\"\
    , RFC 3261, June 2002.\n   [10]  \"IP Multimedia Call Control Protocol based on\
    \ Session\n         Initiation Protocol (SIP)\", October 2006.\n"
- title: Appendix A.  Dummy Application Protocol (DAP)
  contents:
  - 'Appendix A.  Dummy Application Protocol (DAP)

    '
- title: A.1.  Introduction
  contents:
  - "A.1.  Introduction\n   This appendix defines a simple dummy application protocol\
    \ (DAP) that\n   can be used for SigComp interoperability testing.  This is handy\
    \ for\n   SigComp implementations that are not integrated with a SIP stack.  It\n\
    \   also provides some features that facilitate the testing of SigComp\n   internal\
    \ operations.\n   The message format is quite simple.  Each message consists of\
    \ a\n   8-line message-header, an empty line, and an OPTIONAL message-body.\n\
    \   The style resembles that of SIP and HTTP.\n   The exact message format is\
    \ given later in augmented Backus-Naur Form\n   (ABNF) [6].  Here are a few notes:\n\
    \      Each line of message-header MUST be terminated with CRLF.\n      The empty\
    \ line MUST be present even if the message-body is not.\n      Body-length is\
    \ the length of the message-body, excluding the CRLF\n      that separates the\
    \ message-body from the message-header.\n      All strings in the message-header\
    \ are case-insensitive.\n      For implementation according to this appendix,\
    \ the DAP-version\n      MUST be set to 1.\n"
- title: A.2.  Processing a DAP Message
  contents:
  - "A.2.  Processing a DAP Message\n   A message with an invalid format will be discarded\
    \ by a DAP receiver\n   For testing purposes, a message with a valid format will\
    \ be returned\n   to the original sender (IP address, port number) in clear text,\
    \ i.e.,\n   without compression.  This is the case even if the sender requests\n\
    \   this receiver to reject the message.  Note that the entire DAP\n   message\
    \ (message-header + CRLF + message-body) is returned.  This\n   allows the sender\
    \ to compare what it sent with what the receiver\n   decompressed.\n   Endpoint-ID\
    \ is the global identifier of the sending endpoint.  It can\n   be used to test\
    \ the case where multiple SigComp endpoints communicate\n   with the same remote\
    \ SigComp endpoint.  For simplicity, the IPv4\n   address is used for this purpose.\n\
    \   Compartment-ID is the identifier of the *compressor* compartment that\n  \
    \ the *sending* endpoint used to compress this message.  It is assigned\n   by\
    \ the sender and therefore only unique per sending endpoint; i.e.,\n   DAP messages\
    \ sent by different endpoints MAY carry the same\n   compartment-ID.  Therefore,\
    \ the receiver SHOULD use the (endpoint-ID,\n   compartment-ID) pair carried in\
    \ a message to determine the\n   decompressor compartment identifier for that\
    \ message.  The exact\n   local representation of the derived compartment identifier\
    \ is an\n   implementation choice.\n   To test SigComp feedback [1], peer compartments\
    \ between two endpoints\n   are defined in DAP as those with the same compartment-ID.\
    \  For\n   example, (endpoint-A, 1) and (endpoint-B, 1) are peer compartments.\n\
    \   That means, SigComp feedback for a DAP message sent from compartment\n   1\
    \ of endpoint-A to endpoint-B will be piggybacked on a DAP message\n   sent from\
    \ compartment 1 of endpoint-B to endpoint-A.\n   A DAP receiver will follow the\
    \ instruction carried in message-header\n   line-5 to either accept or reject\
    \ a DAP message.  Note: line-6 and\n   line-7 will be ignored if the message is\
    \ rejected.\n   A DAP receiver will follow the instruction in line-6 to create\
    \ or\n   close the decompressor compartment that is associated with the\n   received\
    \ DAP message (see above).\n   If line-7 of a received DAP message-header carries\
    \ \"TRUE\", the\n   receiver will send back a response message to the sender.\
    \  This\n   allows the test of SigComp feedback.  As mentioned above, the\n  \
    \ response message MUST be compressed by, and sent from, the local\n   compressor\
    \ compartment that is a peer of the remote compressor\n   compartment.  Other\
    \ than this constraint, the response message is\n   just a regular DAP message\
    \ that can carry arbitrary message-header\n   and message-body.  For example,\
    \ the \"need-response\" field of the\n   response can also be set to TRUE, which\
    \ will trigger a response to\n   response, and so on.  Note that since each endpoint\
    \ has control over\n   the \"need-response\" field of its own messages, this does\
    \ not lead to\n   a dead loop.  A sensible implementation of a DAP sender SHOULD\
    \ NOT\n   blindly set this field to TRUE unless a response is desired.  For\n\
    \   testing, the message-body of a response MAY contain the message-\n   header\
    \ of the original message that triggered the response.\n   Message-seq can be\
    \ used by a DAP sender to track each message it\n   sends, e.g., in case of losses.\
    \  Message loss can happen either on\n   the path or at the receiving endpoint\
    \ (i.e., due to decompression\n   failure).  The assignment of message-seq is\
    \ up to the sender.  For\n   example, it could be either assigned per compartment\
    \ or per endpoint.\n   This has no impact on the receiving side.\n"
- title: A.3.  DAP Message Format in ABNF
  contents:
  - "A.3.  DAP Message Format in ABNF\n   (Note: see (ABNF) [6] for basic rules.)\n"
- title: DAP-message = message-header CRLF [ message-body ]
  contents:
  - 'DAP-message = message-header CRLF [ message-body ]

    '
- title: message-body = *OCTET
  contents:
  - 'message-body = *OCTET

    '
- title: message-header = line-1 line-2 line-3 line-4 line-5 line-6 line-7 line-8
  contents:
  - 'message-header = line-1 line-2 line-3 line-4 line-5 line-6 line-7 line-8

    '
- title: line-1 = "DAP-version" ":" 1*DIGIT CRLF
  contents:
  - 'line-1 = "DAP-version" ":" 1*DIGIT CRLF

    '
- title: line-2 = "endpoint-ID" ":" IPv4address CRLF
  contents:
  - 'line-2 = "endpoint-ID" ":" IPv4address CRLF

    '
- title: line-3 = "compartment-ID" ":" 1*DIGIT CRLF
  contents:
  - 'line-3 = "compartment-ID" ":" 1*DIGIT CRLF

    '
- title: line-4 = "message-seq" ":" 1*DIGIT CRLF
  contents:
  - 'line-4 = "message-seq" ":" 1*DIGIT CRLF

    '
- title: line-5 = "message-auth" ":" ( "ACCEPT" / "REJECT" ) CRLF
  contents:
  - 'line-5 = "message-auth" ":" ( "ACCEPT" / "REJECT" ) CRLF

    '
- title: line-6 = "compartment-op" ":" ( "CREATE" / "CLOSE" / "NONE" ) CRLF
  contents:
  - 'line-6 = "compartment-op" ":" ( "CREATE" / "CLOSE" / "NONE" ) CRLF

    '
- title: line-7 = "need-response" ":" ( "TRUE" / "FALSE" )
  contents:
  - 'line-7 = "need-response" ":" ( "TRUE" / "FALSE" )

    '
- title: line-8 = "body-length" ":" 1*DIGIT CRLF
  contents:
  - 'line-8 = "body-length" ":" 1*DIGIT CRLF

    '
- title: IPv4address = 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT
  contents:
  - 'IPv4address = 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT

    '
- title: A.4.  An Example of a DAP Message
  contents:
  - "A.4.  An Example of a DAP Message\n      DAP-version: 1\n      endpoint-ID: 123.45.67.89\n\
    \      compartment-ID: 2\n      message-seq: 0\n      message-auth: ACCEPT\n \
    \     compartment-op: CREATE\n      need-response: TRUE\n      body-length: 228\n\
    \   This is a DAP message sent from SigComp endpoint at IP address\n   123.45.67.89.\
    \  This is the first message sent from compartment 2.\n   Please accept the message,\
    \ create the associated compartment, and\n   send back a response message.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Abigail Surtees\n   Siemens/Roke Manor Research\n   Roke\
    \ Manor Research Ltd.\n   Romsey, Hants  SO51 0ZN\n   UK\n   Phone: +44 (0)1794\
    \ 833131\n   EMail: abigail.surtees@roke.co.uk\n   URI:   http://www.roke.co.uk\n\
    \   Mark A. West\n   Siemens/Roke Manor Research\n   Roke Manor Research Ltd.\n\
    \   Romsey, Hants  SO51 0ZN\n   UK\n   Phone: +44 (0)1794 833311\n   EMail: mark.a.west@roke.co.uk\n\
    \   URI:   http://www.roke.co.uk\n   Adam Roach\n   Estacado Systems\n   17210\
    \ Campbell Rd.\n   Suite 250\n   Dallas, TX  75252\n   US\n   Phone: sip:adam@estacado.net\n\
    \   EMail: adam@estacado.net\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n\
    \   Administrative Support Activity (IASA).\n"
