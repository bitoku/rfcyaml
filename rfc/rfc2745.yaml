- contents:
  - '                        RSVP Diagnostic Messages

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document specifies the RSVP diagnostic facility, which allows
    a\n   user to collect information about the RSVP state along a path.  This\n   specification
    describes the functionality, diagnostic message\n   formats, and processing rules.\n"
  title: Abstract
- contents:
  - "1.  Introduction\n   In the basic RSVP protocol [RSVP], error messages are the
    only means\n   for an end host to receive feedback regarding a failure in setting
    up\n   either path state or reservation state.  An error message carries\n   back
    only the information from the failed point, without any\n   information about
    the state at other hops before or after the\n   failure.  In the absence of failures,
    a host receives no feedback\n   regarding the details of a reservation that has
    been put in place,\n   such as whether, or where, or how, its own reservation
    request is\n   being merged with that of others.  Such missing information can
    be\n   highly desirable for debugging purposes, or for network resource\n   management
    in general.\n   This document specifies the RSVP diagnostic facility, which is\n
    \  designed to fill this information gap.  The diagnostic facility can\n   be
    used to collect and report RSVP state information along the path\n   from a receiver
    to a specific sender.  It uses Diagnostic messages\n   that are independent of
    other RSVP control messages and produce no\n   side-effects; that is, they do
    not change any RSVP state at either\n   nodes or hosts.  Similarly, they provide
    not an error report but\n   rather a collection of requested RSVP state information.\n
    \  The RSVP diagnostic facility was designed with the following goals:\n   -  To
    collect RSVP state information from every RSVP-capable hop\n      along a path
    defined by path state, either for an existing\n      reservation or before a reservation
    request is made.  More\n      specifically, we want to be able to collect information
    about\n      flowspecs, refresh timer values, and reservation merging at each\n
    \     hop along the path.\n   -  To collect the IP hop count across each non-RSVP
    cloud.\n   -  To avoid diagnostic packet implosion or explosion.\n   The following
    is specifically identified as a non-goal:\n   -  Checking the resource availability
    along a path.  Such\n      functionality may be useful for future reservation
    requests, but\n      it would require modifications to existing admission control\n
    \     modules that is beyond the scope of RSVP.\n"
  title: 1.  Introduction
- contents:
  - "2.  Overview\n   The diagnostic facility introduces two new RSVP message types:\n
    \  Diagnostic Request (DREQ) and Diagnostic Reply (DREP).  A DREQ\n   message
    can be originated by a client in a \"requester\" host, which\n   may or may not
    be a participant of the RSVP session to be diagnosed.\n   A client in the requester
    host invokes the RSVP diagnostic facility\n   by generating a DREQ packet and
    sending it towards the LAST-HOP node,\n   which should be on the RSVP path to
    be diagnosed. This DREQ packet\n   specifies the RSVP session and a sender host
    for that session.\n   Starting from the LAST-HOP, the DREQ packet collects information\n
    \  hop-by-hop as it is forwarded towards the sender (see Figure 1),\n   until
    it reaches the ending node.  Specifically, each RSVP-capable\n   hop adds to the
    DREQ message a response (DIAG_RESPONSE) object\n   containing local RSVP state
    for the specified RSVP session.\n   When the DREQ packet reaches the ending node,
    the message type is\n   changed to Diagnostic Reply (DREP) and the completed response
    is sent\n   to the original requester node.  Partial responses may also be\n   returned
    before the DREQ packet reaches the ending node if an error\n   condition along
    the path, such as \"no path state\", prevents further\n   forwarding of the DREQ
    packet.  To avoid packet implosion or\n   explosion, all diagnostic packets are
    forwarded via unicast only.\n   Thus, there are generally three nodes (hosts and/or
    routers) involved\n   in performing the diagnostic function: the requester node,
    the\n   starting node, and the ending node, as shown in Figure 1.  It is\n   possible
    that the client invoking the diagnosis function may reside\n   directly on the
    starting node, in which case that the first two nodes\n   are the same.  The starting
    node is named \"LAST-HOP\", meaning the\n   last-hop of the path segment to be
    diagnosed.  The LAST-HOP node can\n   be either a receiver node or an intermediate
    node along the path.\n   The ending node is usually the specified sender host.
    \ However, the\n   client can limit the length of the path segment to be diagnosed
    by\n   specifying a hop-count limit in the DREQ message.\n                  LAST-HOP
    \                 Ending\n     Receiver        node                     node           Sender\n
    \        __           __         __            __              __\n        |  |---------|
    \ |------>|  |--> ...-->|  |--> ...---->|  |\n        |__|         |__| DREQ  |__|
    \  DREQ   |__|   DREQ     |__|\n                      ^                         .
    \             |\n                      |                         .              |\n
    \                     | DREQ                    . DREP         | DREP\n                      |
    \                        .              |\n                     _|_               DREP
    \    V              V\n        Requester   |   | <------------------------------------\n
    \       (client)    |___|\n                         Figure 1\n   DREP packets
    can be unicast from the ending node back to the\n   requester either directly
    or hop-by-hop along the reverse of the path\n   taken by the DREQ message to the
    LAST-HOP, and thence to the\n   requester.  The direct return is faster and more
    efficient, but the\n   hop-by-hop reverse-path route may be the only choice if
    the packets\n   have to cross firewalls.  Hop-by-hop return is accomplished using
    an\n   optional ROUTE object, which is built incrementally to contain a list\n
    \  of node addresses that the DREQ packet has passed through.  The ROUTE\n   object
    is then used in reverse as a source route to forward the DREP\n   hop-by-hop back
    to the LAST-HOP node.\n   A DREQ message always consists of a single unfragmented
    IP datagram.\n   On the other hand, one DREQ message can generate multiple DREP\n
    \  packets, each containing a fragment of the total DREQ message.  When\n   the
    path consists of many hops, the total length of a DREP message\n   will exceed
    the MTU size before reaching the ending node; thus, the\n   message has to be
    fragmented.  Relying on IP fragmentation and\n   reassembly, however, can be problematic,
    especially when DREP\n   messages are returned to the requester hop-by-hop, in
    which case\n   fragmentation/reassembly would have to be performed at every hop.
    \ To\n   avoid such excessive overhead, we let the requester define a default\n
    \  path MTU size that is carried in every DREQ packet.  If an\n   intermediate
    node finds that the default MTU size is bigger than the\n   MTU of the incoming
    interface, it reduces the default MTU size to the\n   MTU size of the incoming
    interface. If an intermediate node detects\n   that a DREQ packet size is larger
    than the default MTU size, it\n   returns to the requester (in either manner described
    above) a DREP\n   fragment containing accumulated responses.  It then removes
    these\n   responses from the DREQ and continues to forward it.  The requester\n
    \  node can reassemble the resulting DREP fragments into a complete DREP\n   message.\n
    \  When discussing diagnostic packet handling, this document uses\n   direction
    terminology that is consistent with the RSVP functional\n   specification [RSVP],
    relative to the direction of data packet flow.\n   Thus, a DREQ packet enters
    a node through an \"outgoing interface\" and\n   is forwarded towards the sender
    through an \"incoming interface\",\n   because DREQ packets travel in the reverse
    direction to the data\n   flow.\n   Notice that DREQ packets can be forwarded
    only after the RSVP path\n   state has been set up.  If no path state exists,
    one may resort to\n   the traceroute or mtrace facility to examine whether the\n
    \  unicast/multicast routing is working correctly.\n"
  title: 2.  Overview
- contents:
  - "3.  Diagnostic Packet Format\n   Like other RSVP messages, DREQ and DREP messages
    consist of an RSVP\n   Common Header followed by a variable set of typed RSVP
    data objects.\n   The following sequence must be used:\n           +-----------------------------------+\n
    \          |        RSVP Common Header         |\n           +-----------------------------------+\n
    \          |         Session object            |\n           +-----------------------------------+\n
    \          |      Next-Hop RSVP_HOP object     |\n           +-----------------------------------+\n
    \          |       DIAGNOSTIC object           |\n           +-----------------------------------+\n
    \          |    (optional) DIAG_SELECT object  |\n           +-----------------------------------+\n
    \          |    (optional) ROUTE object        |\n           +-----------------------------------+\n
    \          | zero or more DIAG_RESPONSE objects|\n           +-----------------------------------+\n
    \  The session object identifies the RSVP session for which the state\n   information
    is being collected.  We describe each of the other parts.\n"
  - contents:
    - "3.1.  RSVP Message Common Header\n   The RSVP message common header is defined
      in [RSVP].  The following\n   specific exceptions and extensions are needed
      for DREP and DREQ.\n   Type field: define:\n          Type = 8: DREQ     Diagnostic
      Request\n          Type = 9: DREP     Diagnostic Reply\n   RSVP length:\n      If
      this is a DREP message and the MF flag in the DIAGNOSTIC object\n      (see
      below) is set, this field indicates the length of this single\n      DREP fragment
      rather than the total length of the complete DREP\n      reply message (which
      cannot generally be known in advance).\n"
    title: 3.1.  RSVP Message Common Header
  - contents:
    - "3.2.  Next-Hop RSVP_HOP Object\n   This RSVP_HOP object carries the LIH of
      the interface through which\n   the DREQ should be received at the upstream
      node. This object is\n   updated hop-by hop. It is used for the same reasons
      that a RESV\n   message contains an RSVP_HOP object: to distinguish logical\n
      \  interfaces and avoid problems caused by routing asymmetries and non-\n   RSVP
      clouds.\n   While the IP address is not really used during DREQ processing,
      for\n   consistency with the use of the RSVP_HOP object in other RSVP\n   messages,
      the IP address in the RSVP_HOP object to contain the\n   address of the interface
      through which the DREQ was sent.\n"
    title: 3.2.  Next-Hop RSVP_HOP Object
  - contents:
    - "3.3.  DIAGNOSTIC Object\n   A DIAGNOSTIC object contains the common diagnostic
      control\n   information in both DREQ and DREP messages.\n   o IPv4 DIAGNOSTIC
      object: Class = 30, C-Type = 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   | Max-RSVP-hops | RSVP-hop-count|         Reserved            |MF|\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                          Request ID                           |\n    +---------------+---------------+---------------+---------------+\n
      \   |           Path MTU            |     Fragment Offset           |\n    +---------------+---------------+---------------+---------------+\n
      \   |                         LAST-HOP Address                      |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                                                               |\n    |
      \                    SENDER_TEMPLATE object                    |\n    |                                                               |\n
      \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |
      \                                                              |\n    |                 Requester
      FILTER_SPEC object                  |\n    |                                                               |\n
      \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Here
      all IP addresses use the 4 byte IPv4 format, both explicitly in\n   the LAST-HOP
      Address and by using the IPv4 forms of the embedded\n   FILTER_SPEC and RSVP_HOP
      objects.\n   o IPv6 DIAGNOSTIC object: Class = 30, C-Type = 2\n   The format
      is the same, except all explicit and embedded IP addresses\n   are 16 byte IPv6
      addresses.\n   The fields are as follows:\n   Max-RSVP-hops\n      An octet
      specifying the maximum number of RSVP hops over which\n      information will
      be collected.  If an error condition in the\n      middle of the path prevents
      the DREQ packet from reaching the\n      specified ending node, the Max-RSVP-hops
      field may be used to\n      perform an expanding-length search to reach the
      point just before\n      the problem.  If this value is 1, the starting node
      and the ending\n      node of the query will be the same.  If it is zero, there
      is no\n      hop limit.\n   RSVP-hop-count\n      Records the number of RSVP
      hops that have been traversed so far.\n      If the starting and ending nodes
      are the same, this value will be\n      1 in the resulting DREP message.\n   Fragment
      Offset\n      Indicates where this DREP fragment belongs in the complete DREP\n
      \     message, measured in octets.  The first fragment has offset zero.\n      Fragment
      Offset is used also to determine if a DREQ message\n      containing zero DIAG_RESPONSE
      objects should be processed at an\n      RSVP capable node.\n   MF flag\n      Flag
      means \"more fragments\".  It must be set to zero (0) in all\n      DREQ messages.
      \ It must be set to one (1) in all DREP packets that\n      carry partial results
      and are returned by intermediate nodes due\n      to the MTU limit.  When the
      DREQ message is converted to a DREP\n      message in the ending node, the MF
      flag must remain zero.\n   Request ID\n      Identifies an individual DREQ message
      and the corresponding DREP\n      message (or all the fragments of the reply
      message).\n      One possible way to define the Request ID would use 16 bits
      to\n      specify the ID of the process making the query and 16 bits to\n      distinguish
      different queries from this process.\n   Path MTU\n      Specifies a default
      MTU size in octets for DREP and DREQ messages.\n      This value should not
      be smaller than the size of the \"base\" DREQ\n      packet. A \"base\" DREQ
      packet is one that contains a Common Header,\n      a Session object, a Next-Hop
      RSVP_HOP object, a DIAGNOSTIC object,\n      an empty ROUTE object and a single
      default DIAG_RESPONSE (see\n      below).  The assumption made here is that
      a diagnostic packet of\n      this size can always be forwarded without IP fragmentation.\n
      \  LAST-HOP Address\n      The IP address of the LAST-HOP node.  The DREQ message
      starts\n      collecting information at this node and proceeds toward the\n
      \     sender.\n   SENDER_TEMPLATE object\n      This IPv4/IPv6 SENDER_TEMPLATE
      object contains the IP address and\n      the port of a sender for the session
      being diagnosed.  The DREQ\n      packet is forwarded hop-by-hop towards this
      address.\n   Requester FILTER_SPEC Object\n      This IPv4/IPv6 FILTER_SPEC
      object contains the IP address and the\n      port from which the request originated
      and to which the DREP\n      message(s) should be sent.\n"
    title: 3.3.  DIAGNOSTIC Object
  - contents:
    - "3.4.  DIAG_SELECT Object\n   o DIAG_SELECT Class = 33, C-Type = 1.\n   A Diagnostic
      message may optionally contain a DIAG_SELECT object to\n   specify which specific
      RSVP objects should be reported in a\n   DIAG_RESPONSE object.  In the absence
      of a DIAG_SELECT object, the\n   DIAG_RESPONSE object added by the node will
      contain a default set of\n   object types (see DIAG_RESPONSE object below).\n
      \  The DIAG_SELECT object contains a list of [Class, C-type] pairs, in\n   the
      following format:\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |    class      |     C-Type    |    class      |     C-Type    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   //                                                             //\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |    class      |     C-Type    |    class      |     C-Type    |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  When a DIAG_SELECT object is included in a DREQ message, each RSVP\n   node
      along the path will add a DIAG_RESPONSE object containing\n   response objects
      (see below) whose classes and C-Types match entries\n   in the DIAG_SELECT list
      (and are from matching path and reservation\n   state). A C-type octet of zero
      is a 'wildcard', matching any C-Type\n   associated with the associated class.\n
      \  Depending on the type of objects requested, a node can find the\n   associated
      information in the path or reservation state stored for\n   the session described
      in the SESSION object. Specifically,\n   information for the RSVP_HOP,SENDER_TEMPLATE,
      SENDER_TSPEC, ADSPEC\n   objects can be extracted from the node's path state,
      while\n   information for the FLOWSPEC, FILTER_SPEC, CONFIRM, STYLE and SCOPE\n
      \  objects can be found in the node's reservation state (if existent).\n   If
      the number of [Class, C-Type] pairs is odd, the last two octets of\n   the DIAG_SELECT
      object must be  zero. A maximum DIAG_SELECT object is\n   one that contains
      the [Class, C-type] pairs for all the RSVP objects\n   that can be requested
      in a Diagnostic query.\n"
    title: 3.4.  DIAG_SELECT Object
  - contents:
    - "3.5.  ROUTE Object\n   A diagnostic message may contain a ROUTE object, which
      is used to\n   record the route of the DREQ message and as a source route for\n
      \  returning the DREP message(s) hop-by-hop.\n   o IPv4 ROUTE object: Class
      = 31, C-Type = 1.\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |             reserved                          |    R-pointer  |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                                                               |\n    +
      \                    RSVP Node List                            |\n    |                                                               |\n
      \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   This
      message signifies how the reply should be returned.  If it does\n   not exist
      in the DREQ packet then DREP packets should be sent to the\n   requester directly.
      If it does exist, DREP packets must be returned\n   hop-by-hop along the reverse
      path to the LAST-HOP node and thence to\n   the requester node.\n   An empty
      ROUTE object is one that has an empty RSVP Node list and R-\n   pointer is equal
      to zero.\n   RSVP Node List\n      A list of RSVP node IPv4 addresses.  The
      number of addresses in\n      this list can be computed from the object size.\n
      \  R-pointer\n      Used in DREP messages only (see Section 4.2 for details),
      but it\n      is incremented as each hop adds its incoming interface address
      in\n      the ROUTE object.\n   o IPv6 ROUTE object: Class = 31, C-Type = 2\n
      \  The same, except RSVP Node List contains IPv6 addresses.\n   In a DREQ message,
      RSVP Node List specifies all RSVP hops between the\n   LAST-HOP address specified
      in the DIAGNOSTIC object, and the last\n   RSVP node the DREQ message has visited.
      \ In a DREP message, RSVP Node\n   List specifies all RSVP hops between the
      LAST-HOP and the node that\n   returns this DREP message.\n"
    title: 3.5.  ROUTE Object
  - contents:
    - "3.6.  DIAG_RESPONSE Object\n   Each RSVP node attaches a DIAG_RESPONSE object
      to each DREQ message\n   it receives, before forwarding the message.  The DIAG_RESPONSE
      object\n   contains the state to be reported for this node.  It has a fixed-\n
      \  format header and then a variable list of RSVP state objects, or\n   \"response
      objects\".\n   o IPv4 DIAG_RESPONSE object: Class = 32, C-Type = 1.\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                       DREQ Arrival Time                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                  Incoming Interface Address                   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                  Outgoing Interface Address                   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                 Previous-RSVP-Hop Router Address              |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |   D-TTL       |M|R-err|  K    |      Timer value              |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |                                                               |\n    |
      \                 (optional) TUNNEL object                     |\n    |                                                               |\n
      \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |
      \                                                              |\n    //                       Response
      objects                      //\n    |                                                               |\n
      \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   o
      IPv6 DIAG_RESPONSE object: Class = 32, C-Type = 2.\n   This object has the same
      format, except that all explicit and\n   embedded IP addresses are IPv6 addresses.\n
      \  The fields are as follows:\n   DREQ Arrival Time\n      A 32-bit NTP timestamp
      specifying the time the DREQ message\n      arrived at this node.  The 32-bit
      form of an NTP timestamp\n      consists of the middle 32 bits of the full 64-bit
      form, that is,\n      the low 16 bits of the integer part and the high 16 bits
      of the\n      fractional part.\n   Incoming Interface Address\n      Specifies
      the IP address of the interface on which messages from\n      the sender are
      expected to arrive, or 0 if unknown.\n   Outgoing Interface Address\n      Specifies
      the IP address of the interface through which the DREQ\n      message arrived
      and to which messages from the given sender and\n      for the specified session
      address flow, or 0 if unknown.\n   Previous-RSVP-Hop Router Address\n      Specifies
      the IP address from which this node receives RSVP PATH\n      messages for this
      source, or 0 if unknown.  This is also the\n      interface to which the DREQ
      will be forwarded.\n   D-TTL\n      The number of IP hops this DREQ message
      traveled from the down-\n      stream RSVP node to the current node.\n   M flag\n
      \     A single-bit flag which indicates whether the reservation\n      described
      by the response objects is merged with reservations from\n      other down-stream
      interfaces when being forwarded upstream.\n   R-error\n      A 3-bit field that
      indicates error conditions at a node. Currently\n      defined values are:\n
      \          0x00: no error\n           0x01: No PATH state\n           0x02:
      packet too big\n           0x04: ROUTE object too big\n   K\n      The refresh
      timer multiple (defined in [RSVP]).\n   Timer value\n      The local refresh
      timer value in seconds.\n   The set of response objects to be included at the
      end of the\n   DIAG_RESPONSE object is determined by a DIAG_SELECT object, if
      one is\n   present.  If no DIAG_SELECT object is present, the response objects\n
      \  belong to the default list of classes:\n      SENDER_TSPEC object      FILTER_SPEC
      object      FLOWSPEC object\n      STYLE object\n   Any C-Type present in the
      local RSVP state will be used.  These\n   response objects may be in any order
      but they must all be at the end\n   of the DIAG_RESPONSE object.\n   A default
      DIAG_RESPONSE object is one containing the default list of\n   classes described
      above.\n"
    title: 3.6.  DIAG_RESPONSE Object
  - contents:
    - "3.7.  TUNNEL Object\n   The optional TUNNEL object should be inserted when
      a DREQ message\n   arrives at an RSVP node that acts as a tunnel exit point.\n
      \  The TUNNEL object provides the mapping between the end-to-end RSVP\n   session
      that is being diagnosed and the RSVP session over the tunnel.\n   This mapping
      information allows the diagnosis client to conduct\n   diagnosis over the involved
      tunnel session, by invoking a separate\n   Diagnostic query for the corresponding
      Tunnel Session and Tunnel\n   Sender.  Keep in mind, however, that multiple
      end-to-end sessions may\n   all map to one pre-configured tunnel session that
      may have totally\n   different parameter settings.\n   The tunnel object is
      defined in the RSVP Tunnel Specification\n   [RSVPTUN].\n"
    title: 3.7.  TUNNEL Object
  title: 3.  Diagnostic Packet Format
- contents:
  - '4.  Diagnostic Packet Forwarding Rules

    '
  - contents:
    - "4.1.  DREQ Packet Forwarding\n   DREQ messages are forwarded  hop-by-hop via
      unicast from the LAST-HOP\n   address to the Sender address, as specified in
      the DIAGNOSTIC object.\n   If an RSVP capable node, other than the LAST-HOP
      node, receives a\n   DREQ message  that contains no DIAG_RESPONSE objects and
      has a zero\n   Fragment Offset, the node should forward the DREQ packet towards
      the\n   LAST-HOP without doing any of the processing mentioned below. The\n
      \  reason is that such conditions apply only for nodes downstream of the\n   LAST-HOP
      where no information should be collected.\n   Processing begins when a DREQ
      message, DREQ_in, arrives at a node.\n       1. Create a new DIAG_RESPONSE object.
      Compute the IP hop count\n          from the previous RSVP hop. This is done
      by subtracting the\n          value of the TTL value in the IP header from Send_TTL
      in the\n          RSVP common header.  Save the result in the D-TTL field of
      the\n          DIAG_RESPONSE object.\n       2. Set the DREQ Arrival Time and
      the Outgoing Interface Address\n          in the DIAG_RESPONSE object.  If this
      node is the LAST-HOP,\n          then the Out- going Interface Address field
      in the\n          DIAG_RESPONSE object contains the following value depending
      on\n          the session being diagnosed.\n         *  If the session in question
      is a unicast session, then the\n            Out-going Interface Address field
      contains the address of\n            the interface LAST-HOP uses to send PATH
      messages and data\n            to the receiver specified by the session address.\n
      \        *  Otherwise, if it is a multicast session and there is at\n            least
      one receiver for this session, LAST_HOP should use the\n            address
      of one of local interfaces used to reach one of the\n            receivers.\n
      \        *  Otherwise Outgoing Interface Address should be zero.\n       3.
      Increment the RSVP-hop-count field in the DIAGNOSTIC message\n          object
      by one.\n       4. If no PATH state exists for the specified session, set R-error\n
      \         = 0x01 (No PATH state) and goto step 7.\n       5. Set the rest of
      the fields in the DIAG_RESPONSE object. If\n          DREQ_in contains a DIAG_SELECT
      object, the response object\n          classes are those specified in the DIAG_SELECT;
      otherwise,\n          they are SENDER_TSPEC, STYLE, and FLOWSPEC objects. If
      no\n          reservation state exists for the specified RSVP session, the\n
      \         DIAG_RESPONSE object will contain no FLOWSPEC, FILTER_SPEC or\n          STYLE
      object. If neither PATH nor reservation state exists for\n          the specified
      RSVP session, then no response objects will be\n          appended to the DIAG_RESPONSE
      object.\n       6. If RSVP-hop-count is less than Max-RSVP-hops and this node
      is\n          not the sender, then the DREQ is eligible for forwarding; set\n
      \         the Path MTU to the min of the Path MTU and the MTU size of\n          the
      incoming interface for the sender being diagnosed.\n       7. If the size of
      DREQ_in plus the size of the new DIAG_RESPONSE\n          object plus the size
      of an IP address (if a ROUTE object\n          exists and R-error= 0) is larger
      than Path MTU, then the new\n          diagnostic message will be too large
      to be forwarded or\n          returned without fragmentation; set the \"packet
      too big\"\n          (0x02) error bit in DIAG_RESPONSE and goto Step SD1 in\n
      \         Send_DREP (below).\n       8. If the \"No PATH state\" (0x01) error
      bit is set or if RSVP-\n          hop-count is equal to Max-RSVP-hops or if
      this node is the\n          sender, then the DREQ cannot be forwarded further;
      goto Step\n          10.\n       9. Forward the DREQ towards the sender, as
      follows.  If a ROUTE\n          object exists, append the \"Incoming Interface
      Address\" to the\n          end of the ROUTE object and increment R-Pointer
      by one.\n          Update the Next-Hop RSVP_HOP object, append the new\n          DIAG_RESPONSE
      object to the list of DIAG_RESPONSE object, and\n          update the message
      length field in the RSVP common header\n          accordingly. Finally, recompute
      the checksum, forward DREQ_in\n          to the next hop towards the sender,
      and return.\n      10. Turn the DREQ into a DREP and return to the requester,
      as\n          follows.  Append the DIAG_RESPONSE object to the end of\n          DREQ_in
      and update the packet length.  If a ROUTE object is\n          present in the
      message, decrement the R-pointer and set target\n          address to the last
      address in the ROUTE object, otherwise set\n          target address to the
      requester address. Change the Type Field\n          in the Common header from
      DREQ to DREP.  Finally, recompute\n          the checksum, send the DREP to
      the target address, and return.\n          Note that the MF bit must be off
      in this case.\n   Send_DREP:\n   This sequence is entered if the DREQ message
      augmented with the new\n   DIAG_RESPONSE object is too large to be forwarded
      towards the sender\n   or, if it is not eligible for forwarding, too large to
      be returned as\n   a DREP.\n   SD1. Make a copy of DREQ_in and change the message
      type field from\n        DREQ to DREP.  Trim all DIAG_RESPONSE objects from
      DREQ_in and\n        adjust the Fragment Offset.  The DREP message contains
      the\n        DIAG_RESPONSE objects accumulated by prior nodes.\n   SD2. Send
      the DREP message towards the requester, as follows.  If a\n        ROUTE object
      is present in the DREP message, decrement the R-\n        pointer and set target
      address to the last address in the ROUTE\n        object, otherwise set target
      address to the requester address.\n        Set the MF bit, recompute the checksum
      and send the DREP message\n        back to the target address.\n   SD3. If the
      reduced size of DREQ_in plus the size of DIAG_RESPONSE\n        plus the size
      of an IP address (if a ROUTE object exists) is\n        smaller than or equal
      to Path MTU, then return to Step 8 of the\n        main DREQ processing sequence
      above.\n   SD4. If a ROUTE object exists, replace the ROUTE object in DREQ_in\n
      \       with an empty ROUTE object and turn on the \"ROUTE object too\n        big\"
      (0x04) error bit in the DIAG_RESPONSE.  In either case,\n        return to Step
      8 of the main DREQ processing sequence above.\n"
    title: 4.1.  DREQ Packet Forwarding
  - contents:
    - "4.2.  DREP Forwarding\n   When a ROUTE object is present, DREP messages are
      forwarded hop-by-\n   hop towards the requester, by reversing the route as listed
      in the\n   ROUTE object. Otherwise, DREP messages are sent directly to the\n
      \  original requester.\n   When a node receives a DREP message, it simply decreases
      R-pointer by\n   one (address length), recomputes the checksum and forwards
      the\n   message to the address pointed to by R-pointer in the route list. If\n
      \  a node, other than the LAST-HOP, receives a DREP packet where R-\n   pointer
      is equal to zero, it must send it directly to the requester.\n   When the LAST-HOP
      node receives a DREP message, it sends the message\n   to the requester.\n"
    title: 4.2.  DREP Forwarding
  - contents:
    - "4.3.  MTU Selection and Adjustment\n   Because the DREQ message carries the
      allowed MTU size of previous\n   hops that the DREP messages will later traverse,
      this unique feature\n   allows easy semantic fragmentation as described above.
      \ Whenever the\n   DREQ message approaches the size of Path MTU, it can be trimmed\n
      \  before being forwarded again.\n   When a requester sends a DREQ message,
      the Path MTU field in the\n   DIAGNOSTIC object can be set to a configured default
      value. It is\n   possible that the original Path MTU value is chosen larger
      than the\n   actual MTU value along some portion of the path being traced.\n
      \  Therefore each intermediate RSVP node must check the MTU value when\n   processing
      a DREQ message.  If the specified MTU value is larger than\n   the MTU of the
      incoming interface (that the DREQ message will be\n   forwarded to), the node
      changes the MTU value in the header to the\n   smaller value.\n   Whenever a
      DREQ message size becomes larger than the Path MTU value,\n   an intermediate
      RSVP node makes a copy of the message, converts it to\n   a DREP message to
      send back, and then trims off the partial results\n   from the DREQ message.
      If in this case also the DREQ cannot be\n   forwarded upstream due to a large
      ROUTE object, the \"ROUTE object too\n   big\" is set and the ROUTE object is
      trimmed. As a result of the ROUTE\n   object trimming, DREP(s) will come hop-by-hop
      up to this node and\n   will then immediately be forwarded to the requester
      address.\n   Even if the steps shown above are followed there are a few cases\n
      \  where fragmentation at the IP layer will happen. For example, non-\n   RSVP
      hops with smaller MTUs may exist before LAST-HOP is reached, or\n   if the response
      is sent directly back to requester (as opposed to hop\n   by hop) the DREP may
      take a different route to the requester than the\n   DREQ took from the requester.
      Another case is when there exists a\n   link with MTU smaller than the minimum
      Path MTU value defined in\n   Section 3.3.\n"
    title: 4.3.  MTU Selection and Adjustment
  - contents:
    - "4.4.  Errors\n   If an error condition prevents a DREP message from being forwarded\n
      \  further, the message is simply dropped.\n   If an error condition, such as
      lack of PATH state, prevents a DREQ\n   message from being forwarded further,
      the node must change the\n   current message to DREP type and return it to the
      response address.\n"
    title: 4.4.  Errors
  title: 4.  Diagnostic Packet Forwarding Rules
- contents:
  - '5.  Problem Diagnosis by Using RSVP Diagnostic Facility

    '
  - contents:
    - "5.1.  Across Firewalls\n   Firewalls may cause problems in diagnostic message
      forwarding.  Let\n   us look at two different cases.\n   First, let us assume
      that the querier resides on a receiving host of\n   the session to be examined.
      \ In this case, firewalls should not\n   prevent the forwarding of the diagnostic
      messages in a hop-by-hop\n   manner, assuming that proper holes have been punched
      on the firewall\n   to allow hop-by-hop forwarding of other RSVP messages.  The
      querier\n   may start by not including a ROUTE object, which can give a faster\n
      \  response delivery and reduced overhead at intermediate nodes.\n   However
      if no response is received, the querier may resend the DREQ\n   message with
      a ROUTE object, specifying that a hop-by-hop reply\n   should be sent.\n   If
      the requester is a third party host and is separated from the\n   LAST-HOP address
      by a firewall (either the requester is behind a\n   firewall, or the LAST-HOP
      is a node behind a firewall, or both), at\n   this time we do not know any other
      solution but to change the LAST-\n   HOP to a node that is on the same side
      of the firewall as the\n   requester.\n"
    title: 5.1.  Across Firewalls
  - contents:
    - "5.2.  Examination of RSVP Timers\n   One can easily collect information about
      the current timer value at\n   each RSVP hop along the way.  This will be very
      helpful in situations\n   when the reservation state goes up and down frequently,
      to find out\n   whether the state changes are due to improper setting of timer\n
      \  values, or K values (when across lossy links), or frequent routing\n   changes.\n"
    title: 5.2.  Examination of RSVP Timers
  - contents:
    - "5.3.  Discovering Non-RSVP Clouds\n   The D-TTL field in each DIAG_RESPONSE
      object shows the number of\n   routing hops between adjacent RSVP nodes.  Therefore
      any value\n   greater than one indicates a non-RSVP cloud in between.  Together\n
      \  with the arrival timestamps (assuming NTP works), this value can also\n   give
      some vague, though not necessarily accurate, indication of how\n   big that
      cloud might be.  One might also find out all the\n   intermediate non-RSVP nodes
      by running either unicast or multicast\n   trace route.\n"
    title: 5.3.  Discovering Non-RSVP Clouds
  - contents:
    - "5.4.  Discovering Reservation Merges\n   The flowspec value in a DIAG_RESPONSE
      object specifies the amount of\n   resources being reserved for the data stream
      defined by the filter\n   spec in the same data block.  When this value of adjacent\n
      \  DIAG_RESPONSE objects differs, that is, a downstream node Rd has a\n   smaller
      value than its immediate upstream node Ru, it indicates a\n   merge of reservation
      with RSVP request(s) from other down stream\n   interface(s) at Rd.  Further,
      in case of SE style reservation, one\n   can examine how the different SE scopes
      get merged at each hop.\n   In particular, if a receiver sends a DREQ message
      before sending its\n   own reservation, it can discover (1) how many RSVP hops
      there are\n   along the path between the specified sender and itself, (2) how
      many\n   of the hops already have some reservation by other receivers, and (3)\n
      \  possibly a rough prediction of how its reservation request might get\n   merged
      with other existing ones.\n"
    title: 5.4.  Discovering Reservation Merges
  - contents:
    - "5.5.  Error Diagnosis\n   In addition to examining the state of a working reservation,
      RSVP\n   diagnostic messages are more likely to be invoked when things are not\n
      \  working correctly.  For example, a receiver has reserved an adequate\n   pipe
      for a specified incoming data stream, yet the observed delay or\n   loss ratio
      is much higher than expected.  In this case the receiver\n   can use the diagnostic
      facility to examine the reservation state at\n   each RSVP hop along the way
      to find out whether the RSVP state is set\n   up correctly, whether there is
      any black-hole along the way that\n   caused RSVP message losses, or whether
      there are non-RSVP clouds, and\n   where they are, that may have caused the
      performance problem.\n"
    title: 5.5.  Error Diagnosis
  - contents:
    - "5.6.  Crossing \"Legacy\" RSVP Routers\n   Since this diagnosis facility was
      developed and added to RSVP after a\n   number of RSVP implementations were
      in place, it is possible, or even\n   likely, that when performing RSVP diagnosis,
      one may encounter one or\n   more RSVP-capable nodes that do not understand
      diagnostic messages\n   and drop them.  When this happens, the invoking client
      will get no\n   response from its requests.\n   One way to by-pass such \"legacy\"
      RSVP nodes is to perform RSVP\n   diagnosis repeatedly, guided by information
      from traceroute, or\n   mtrace in case of multicast.  When an RSVP diagnostic
      query times out\n   (see next section), one may first use traceroute to get
      the list of\n   nodes along the path, and then gradually increase the value
      of Max-\n   RSVP-hops field in the DREQ message, starting from a low value until\n
      \  one no longer receives a response.  One can then try RSVP diagnosis\n   again
      by starting with the first node (which is further upstream\n   towards the sender)
      after the unresponding one.\n   There are two problem with the method mentioned
      above in the case of\n   unicast sessions. Both problems are related to the
      fact that\n   traceroute information provides the path from the requester to
      the\n   sender. The first problem is that the LAST-HOP may not be on the path\n
      \  from the requester to the sender. In this case we can get information\n   only
      from the portion of the path from the LAST-HOP to the sender\n   which intersects
      with the path from the requester to the sender. If\n   routers that are not
      on the intersection of the two paths don't have\n   PATH state for the session
      being diagnosed then they will reply with\n   R-error=0x01. The requester can
      overcome this problem by sending a\n   DREQ to every router on the path (from
      itself to the sender) until it\n   reaches the first router that belongs to
      the path from the sender to\n   the LAST-HOP.\n   The second problem is that
      traceroute provides the path from the\n   requester to the sender which, due
      to routing asymmetries, may be\n   different than the path traffic from the
      sender to the LAST-HOP uses.\n   There is (at least) one case where this asymmetry
      will cause the\n   diagnosis to fail. We present this case below.\n                                Downstream
      Path                Sender\n                                __         __            __
      \      __\n   Receiver             +------|  |<------|  |<-- ...---|  |-----|
      \ |\n      __          __   /       |__|       |__|          |__|     |__|\n
      \    |  |--....--|X |_/                    ^\n     |__|        |__| \\     Router
      B       |\n                Black  \\        __         |\n                Hole
      \   +----->|  |---->---+\n                               |__| Upstream Path\n
      \                            Router A\n                             Figure 2\n
      \  Here the first hop upstream of the black hole is different on the\n   upstream
      path and the downstream path. Traceroute will indicate\n   router A as the previous
      hop (instead of router B which is the right\n   one). Sending a DREQ to router
      A will result in A responding with R-\n   error 0x01 (No PATH State). If the
      two paths converge again then the\n   requester can use the solution proposed
      above to get any (partial)\n   information from the rest of the path.\n   We
      don't have, for the moment, any complete solutions for the\n   problematic scenarios
      described here.\n"
    title: 5.6.  Crossing "Legacy" RSVP Routers
  title: 5.  Problem Diagnosis by Using RSVP Diagnostic Facility
- contents:
  - "6.  Comments on Diagnostic Client Implementation.\n   Following the design principle
    that nodes in the network should not\n   hold more than necessary state,  RSVP
    nodes are responsible only for\n   forwarding Diagnostic messages and filling
    DIAG_RESPONSE objects.\n   Additional diagnostic functionality should be carried
    out by the\n   diagnostic clients.  Furthermore, if the diagnostic function is\n
    \  invoked from a third-party host, we should not require that host be\n   running
    an RSVP daemon to perform the function.  Below we sketch out\n   the basic functions
    that a diagnostic client daemon should carry out.\n      1. Take input from the
    user about the session to be diagnosed, the\n         last-hop and the sender
    address, the Max-RSVP-hops, and\n         possibly the DIAG_SELECT list, create
    a DREQ message and send\n         to the LAST-HOP RSVP node using raw IP message
    with protocol\n         number 46 (RSVP).  If the user specified that the response\n
    \        should be sent hop-by-hop include an empty ROUTE object to the\n         DREQ
    message sent. Set the Path_MTU to the smaller of the user\n         request and
    the MTU of the link through which the DREQ will be\n         sent.\n         The
    port of the UDP socket on which the Diagnostic Client is\n         listening for
    replies should be included in the Requester\n         FILTER_SPEC object.\n      2.
    Set a retransmission timer, waiting for the reply (one or more\n         DREP
    messages).  Listen to the specified UDP port for responses\n         from the
    LAST-HOP RSVP node.\n         The LAST-HOP RSVP node, upon receiving DREP messages,
    sends\n         them to the Diagnostic Client as UDP packets, using the port\n
    \        supplied in the Requester FILTER_SPEC object.\n      3. Upon receiving
    a DREP message to an outstanding diagnostic\n         request, the client should
    clear the retransmission timer,\n         check to see if the reply contains the
    complete result of the\n         requested diagnosis.  If so, it should pass the
    result up to\n         the invoking entity immediately.\n      4. Reassemble DREP
    fragments.  If the first reply to an\n         outstanding diagnostic request
    contains only a fragment of the\n         expected result, the client should set
    up a reassembly timer in\n         a way similar to IP packet reassembly timer.
    \ If the timer goes\n         off before all fragments arrive, the client should
    pass the\n         partial result to the invoking entity.\n      5. Use retransmission
    and reassembly timers to gracefully handle\n         packet losses and reply fragment
    scenarios.\n         In the absence of response to the first diagnostic request,
    a\n         client should retransmit the request a few times.  If all the\n         retransmissions
    also fail, the client should invoke traceroute\n         or mtrace to obtain the
    list of hops along the path segment to\n         be diagnosed, and then perform
    an iteration of diagnosis with\n         increasing hop count as suggested in
    Section 5.6 in order to\n         cross RSVP-capable but diagnosis-incapable nodes.\n
    \     6. If all the above efforts fail, the client must notify the\n         invoking
    entity.\n"
  title: 6.  Comments on Diagnostic Client Implementation.
- contents:
  - "7.  Security Considerations\n   RSVP Diagnostics, as any other diagnostic tool,
    can be a security\n   threat since it can reveal possibly sensitive RSVP state
    information\n   to unwanted third parties.\n   We feel that the threat is minimal,
    since as explained in the\n   Introduction Diagnostics messages produce no side-effects
    and\n   therefore they cannot change RSVP state in the nodes. In this respect\n
    \  RSVP Diagnostics is less a security threat than other diagnostic\n   tools
    and protocols such as SNMP.\n   Furthermore, processing of Diagnostic messages
    can be disabled if it\n   is felt that is a security threat.\n"
  title: 7.  Security Considerations
- contents:
  - "8.  Acknowledgments\n   The idea of developing a diagnostic facility for RSVP
    was first\n   suggested by Mark Handley of ACIRI.  Many thanks to Lee Breslau
    of\n   AT&T Labs and John Krawczyk of Nortel Networks for their valuable\n   comments
    on the first draft of this memo.  Lee Breslau, Bob Braden,\n   and John Krawczyk
    contributed further comments after March 1996 IETF.\n   Steven Berson provided
    valuable comments on various drafts of the\n   memo. Tim Gleeson contributed an
    extensive list of editorial\n   comments. We would also like to acknowledge Intel
    for providing a\n   research grant as a partial support for this work. Subramaniam\n
    \  Vincent did most of this work while a graduate research assistant at\n   the
    USC Information Sciences Institute (ISI).\n"
  title: 8.  Acknowledgments
- contents:
  - "9.  References\n   [RSVP]    Braden, R., Zhang, L., Berson, S., Herzog, S. and
    S. Jamin,\n             \"Resource ReserVation Protocol -- Version 1 Functional\n
    \            Specification\", RFC 2205, September 1997.\n   [RSVPTUN] Terzis,
    A., Krawczyk, J., Wroclawski, J. and L. Zhang,\n             \"RSVP Operation
    Over IP Tunnels\", RFC 2746, January 2000.\n"
  title: 9.  References
- contents:
  - "10.  Authors' Addresses\n   Andreas Terzis\n   UCLA\n   4677 Boelter Hall\n   Los
    Angeles, CA 90095\n   Phone:    310-267-2190\n   EMail:    terzis@cs.ucla.edu\n
    \  Bob Braden\n   USC Information Sciences Institute\n   4676 Admiralty Way\n
    \  Marina del Rey, CA 90292\n   Phone:    310 822-1511\n   EMail:    braden@isi.edu\n
    \  Subramaniam Vincent\n   Cisco Systems\n   275, E Tasman Drive, MS SJC04/2/1\n
    \  San Jose, CA 95134\n   Phone:    408 525 3474\n   EMail:    svincent@cisco.com\n
    \  Lixia Zhang\n   UCLA\n   4531G Boelter Hall\n   Los Angeles, CA  90095\n   Phone:
    \   310-825-2695\n   EMail:    lixia@cs.ucla.edu\n"
  title: 10.  Authors' Addresses
- contents:
  - "10.  Full Copyright Statement\n   Copyright (C) The Internet Society (2000).
    \ All Rights Reserved.\n   This document and translations of it may be copied
    and furnished to\n   others, and derivative works that comment on or otherwise
    explain it\n   or assist in its implementation may be prepared, copied, published\n
    \  and distributed, in whole or in part, without restriction of any\n   kind,
    provided that the above copyright notice and this paragraph are\n   included on
    all such copies and derivative works.  However, this\n   document itself may not
    be modified in any way, such as by removing\n   the copyright notice or references
    to the Internet Society or other\n   Internet organizations, except as needed
    for the purpose of\n   developing Internet standards in which case the procedures
    for\n   copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: 10.  Full Copyright Statement
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
