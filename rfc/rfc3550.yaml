- title: __initial_text__
  contents:
  - '          RTP: A Transport Protocol for Real-Time Applications

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This memorandum describes RTP, the real-time transport protocol.\
    \  RTP\n   provides end-to-end network transport functions suitable for\n   applications\
    \ transmitting real-time data, such as audio, video or\n   simulation data, over\
    \ multicast or unicast network services.  RTP\n   does not address resource reservation\
    \ and does not guarantee\n   quality-of-service for real-time services.  The data\
    \ transport is\n   augmented by a control protocol (RTCP) to allow monitoring\
    \ of the\n   data delivery in a manner scalable to large multicast networks, and\n\
    \   to provide minimal control and identification functionality.  RTP and\n  \
    \ RTCP are designed to be independent of the underlying transport and\n   network\
    \ layers.  The protocol supports the use of RTP-level\n   translators and mixers.\n\
    \   Most of the text in this memorandum is identical to RFC 1889 which it\n  \
    \ obsoletes.  There are no changes in the packet formats on the wire,\n   only\
    \ changes to the rules and algorithms governing how the protocol\n   is used.\
    \  The biggest change is an enhancement to the scalable timer\n   algorithm for\
    \ calculating when to send RTCP packets in order to\n   minimize transmission\
    \ in excess of the intended rate when many\n   participants join a session simultaneously.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction ................................................\
    \   4\n       1.1  Terminology ............................................  \
    \ 5\n   2.  RTP Use Scenarios ...........................................   5\n\
    \       2.1  Simple Multicast Audio Conference ......................   6\n  \
    \     2.2  Audio and Video Conference .............................   7\n    \
    \   2.3  Mixers and Translators .................................   7\n      \
    \ 2.4  Layered Encodings ......................................   8\n   3.  Definitions\
    \ .................................................   8\n   4.  Byte Order, Alignment,\
    \ and Time Format ......................  12\n   5.  RTP Data Transfer Protocol\
    \ ..................................  13\n       5.1  RTP Fixed Header Fields\
    \ ................................  13\n       5.2  Multiplexing RTP Sessions\
    \ ..............................  16\n       5.3  Profile-Specific Modifications\
    \ to the RTP Header .......  18\n            5.3.1  RTP Header Extension ............................\
    \  18\n   6.  RTP Control Protocol -- RTCP ................................  19\n\
    \       6.1  RTCP Packet Format .....................................  21\n  \
    \     6.2  RTCP Transmission Interval .............................  24\n    \
    \        6.2.1  Maintaining the Number of Session Members .......  28\n      \
    \ 6.3  RTCP Packet Send and Receive Rules .....................  28\n        \
    \    6.3.1  Computing the RTCP Transmission Interval ........  29\n          \
    \  6.3.2  Initialization ..................................  30\n            6.3.3\
    \  Receiving an RTP or Non-BYE RTCP Packet .........  31\n            6.3.4  Receiving\
    \ an RTCP BYE Packet ....................  31\n            6.3.5  Timing Out an\
    \ SSRC ..............................  32\n            6.3.6  Expiration of Transmission\
    \ Timer ................  32\n            6.3.7  Transmitting a BYE Packet .......................\
    \  33\n            6.3.8  Updating we_sent ................................  34\n\
    \            6.3.9  Allocation of Source Description Bandwidth ......  34\n  \
    \     6.4  Sender and Receiver Reports ............................  35\n    \
    \        6.4.1  SR: Sender Report RTCP Packet ...................  36\n      \
    \      6.4.2  RR: Receiver Report RTCP Packet .................  42\n        \
    \    6.4.3  Extending the Sender and Receiver Reports .......  42\n          \
    \  6.4.4  Analyzing Sender and Receiver Reports ...........  43\n       6.5  SDES:\
    \ Source Description RTCP Packet ...................  45\n            6.5.1  CNAME:\
    \ Canonical End-Point Identifier SDES Item .  46\n            6.5.2  NAME: User\
    \ Name SDES Item .......................  48\n            6.5.3  EMAIL: Electronic\
    \ Mail Address SDES Item ........  48\n            6.5.4  PHONE: Phone Number\
    \ SDES Item ...................  49\n            6.5.5  LOC: Geographic User Location\
    \ SDES Item .........  49\n            6.5.6  TOOL: Application or Tool Name SDES\
    \ Item ........  49\n            6.5.7  NOTE: Notice/Status SDES Item ...................\
    \  50\n            6.5.8  PRIV: Private Extensions SDES Item ..............  50\n\
    \       6.6  BYE: Goodbye RTCP Packet ...............................  51\n  \
    \     6.7  APP: Application-Defined RTCP Packet ...................  52\n   7.\
    \  RTP Translators and Mixers ..................................  53\n       7.1\
    \  General Description ....................................  53\n       7.2  RTCP\
    \ Processing in Translators .........................  55\n       7.3  RTCP Processing\
    \ in Mixers ..............................  57\n       7.4  Cascaded Mixers ........................................\
    \  58\n   8.  SSRC Identifier Allocation and Use ..........................  59\n\
    \       8.1  Probability of Collision ...............................  59\n  \
    \     8.2  Collision Resolution and Loop Detection ................  60\n    \
    \   8.3  Use with Layered Encodings .............................  64\n   9. \
    \ Security ....................................................  65\n       9.1\
    \  Confidentiality ........................................  65\n       9.2  Authentication\
    \ and Message Integrity ...................  67\n   10. Congestion Control ..........................................\
    \  67\n   11. RTP over Network and Transport Protocols ....................  68\n\
    \   12. Summary of Protocol Constants ...............................  69\n  \
    \     12.1 RTCP Packet Types ......................................  70\n    \
    \   12.2 SDES Types .............................................  70\n   13.\
    \ RTP Profiles and Payload Format Specifications ..............  71\n   14. Security\
    \ Considerations .....................................  73\n   15. IANA Considerations\
    \ .........................................  73\n   16. Intellectual Property\
    \ Rights Statement ......................  74\n   17. Acknowledgments .............................................\
    \  74\n   Appendix A.   Algorithms ........................................  75\n\
    \   Appendix A.1  RTP Data Header Validity Checks ...................  78\n  \
    \ Appendix A.2  RTCP Header Validity Checks .......................  82\n   Appendix\
    \ A.3  Determining Number of Packets Expected and Lost ...  83\n   Appendix A.4\
    \  Generating RTCP SDES Packets ......................  84\n   Appendix A.5  Parsing\
    \ RTCP SDES Packets .........................  85\n   Appendix A.6  Generating\
    \ a Random 32-bit Identifier .............  85\n   Appendix A.7  Computing the\
    \ RTCP Transmission Interval ..........  87\n   Appendix A.8  Estimating the Interarrival\
    \ Jitter ................  94\n   Appendix B.   Changes from RFC 1889 .............................\
    \  95\n   References ...................................................... 100\n\
    \   Normative References ............................................ 100\n  \
    \ Informative References .......................................... 100\n   Authors'\
    \ Addresses .............................................. 103\n   Full Copyright\
    \ Statement ........................................ 104\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   This memorandum specifies the real-time transport protocol\
    \ (RTP),\n   which provides end-to-end delivery services for data with real-time\n\
    \   characteristics, such as interactive audio and video.  Those services\n  \
    \ include payload type identification, sequence numbering, timestamping\n   and\
    \ delivery monitoring.  Applications typically run RTP on top of\n   UDP to make\
    \ use of its multiplexing and checksum services; both\n   protocols contribute\
    \ parts of the transport protocol functionality.\n   However, RTP may be used\
    \ with other suitable underlying network or\n   transport protocols (see Section\
    \ 11).  RTP supports data transfer to\n   multiple destinations using multicast\
    \ distribution if provided by the\n   underlying network.\n   Note that RTP itself\
    \ does not provide any mechanism to ensure timely\n   delivery or provide other\
    \ quality-of-service guarantees, but relies\n   on lower-layer services to do\
    \ so.  It does not guarantee delivery or\n   prevent out-of-order delivery, nor\
    \ does it assume that the underlying\n   network is reliable and delivers packets\
    \ in sequence.  The sequence\n   numbers included in RTP allow the receiver to\
    \ reconstruct the\n   sender's packet sequence, but sequence numbers might also\
    \ be used to\n   determine the proper location of a packet, for example in video\n\
    \   decoding, without necessarily decoding packets in sequence.\n   While RTP\
    \ is primarily designed to satisfy the needs of multi-\n   participant multimedia\
    \ conferences, it is not limited to that\n   particular application.  Storage\
    \ of continuous data, interactive\n   distributed simulation, active badge, and\
    \ control and measurement\n   applications may also find RTP applicable.\n   This\
    \ document defines RTP, consisting of two closely-linked parts:\n   o  the real-time\
    \ transport protocol (RTP), to carry data that has\n      real-time properties.\n\
    \   o  the RTP control protocol (RTCP), to monitor the quality of service\n  \
    \    and to convey information about the participants in an on-going\n      session.\
    \  The latter aspect of RTCP may be sufficient for \"loosely\n      controlled\"\
    \ sessions, i.e., where there is no explicit membership\n      control and set-up,\
    \ but it is not necessarily intended to support\n      all of an application's\
    \ control communication requirements.  This\n      functionality may be fully\
    \ or partially subsumed by a separate\n      session control protocol, which is\
    \ beyond the scope of this\n      document.\n   RTP represents a new style of\
    \ protocol following the principles of\n   application level framing and integrated\
    \ layer processing proposed by\n   Clark and Tennenhouse [10].  That is, RTP is\
    \ intended to be malleable\n   to provide the information required by a particular\
    \ application and\n   will often be integrated into the application processing\
    \ rather than\n   being implemented as a separate layer.  RTP is a protocol framework\n\
    \   that is deliberately not complete.  This document specifies those\n   functions\
    \ expected to be common across all the applications for which\n   RTP would be\
    \ appropriate.  Unlike conventional protocols in which\n   additional functions\
    \ might be accommodated by making the protocol\n   more general or by adding an\
    \ option mechanism that would require\n   parsing, RTP is intended to be tailored\
    \ through modifications and/or\n   additions to the headers as needed.  Examples\
    \ are given in Sections\n   5.3 and 6.4.3.\n   Therefore, in addition to this\
    \ document, a complete specification of\n   RTP for a particular application will\
    \ require one or more companion\n   documents (see Section 13):\n   o  a profile\
    \ specification document, which defines a set of payload\n      type codes and\
    \ their mapping to payload formats (e.g., media\n      encodings).  A profile\
    \ may also define extensions or modifications\n      to RTP that are specific\
    \ to a particular class of applications.\n      Typically an application will\
    \ operate under only one profile.  A\n      profile for audio and video data may\
    \ be found in the companion RFC\n      3551 [1].\n   o  payload format specification\
    \ documents, which define how a\n      particular payload, such as an audio or\
    \ video encoding, is to be\n      carried in RTP.\n   A discussion of real-time\
    \ services and algorithms for their\n   implementation as well as background discussion\
    \ on some of the RTP\n   design decisions can be found in [11].\n"
- title: 1.1 Terminology
  contents:
  - "1.1 Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in BCP\
    \ 14, RFC 2119 [2]\n   and indicate requirement levels for compliant RTP implementations.\n"
- title: 2. RTP Use Scenarios
  contents:
  - "2. RTP Use Scenarios\n   The following sections describe some aspects of the\
    \ use of RTP.  The\n   examples were chosen to illustrate the basic operation\
    \ of\n   applications using RTP, not to limit what RTP may be used for.  In\n\
    \   these examples, RTP is carried on top of IP and UDP, and follows the\n   conventions\
    \ established by the profile for audio and video specified\n   in the companion\
    \ RFC 3551.\n"
- title: 2.1 Simple Multicast Audio Conference
  contents:
  - "2.1 Simple Multicast Audio Conference\n   A working group of the IETF meets to\
    \ discuss the latest protocol\n   document, using the IP multicast services of\
    \ the Internet for voice\n   communications.  Through some allocation mechanism\
    \ the working group\n   chair obtains a multicast group address and pair of ports.\
    \  One port\n   is used for audio data, and the other is used for control (RTCP)\n\
    \   packets.  This address and port information is distributed to the\n   intended\
    \ participants.  If privacy is desired, the data and control\n   packets may be\
    \ encrypted as specified in Section 9.1, in which case\n   an encryption key must\
    \ also be generated and distributed.  The exact\n   details of these allocation\
    \ and distribution mechanisms are beyond\n   the scope of RTP.\n   The audio conferencing\
    \ application used by each conference\n   participant sends audio data in small\
    \ chunks of, say, 20 ms duration.\n   Each chunk of audio data is preceded by\
    \ an RTP header; RTP header and\n   data are in turn contained in a UDP packet.\
    \  The RTP header indicates\n   what type of audio encoding (such as PCM, ADPCM\
    \ or LPC) is contained\n   in each packet so that senders can change the encoding\
    \ during a\n   conference, for example, to accommodate a new participant that\
    \ is\n   connected through a low-bandwidth link or react to indications of\n \
    \  network congestion.\n   The Internet, like other packet networks, occasionally\
    \ loses and\n   reorders packets and delays them by variable amounts of time.\
    \  To\n   cope with these impairments, the RTP header contains timing\n   information\
    \ and a sequence number that allow the receivers to\n   reconstruct the timing\
    \ produced by the source, so that in this\n   example, chunks of audio are contiguously\
    \ played out the speaker\n   every 20 ms.  This timing reconstruction is performed\
    \ separately for\n   each source of RTP packets in the conference.  The sequence\
    \ number\n   can also be used by the receiver to estimate how many packets are\n\
    \   being lost.\n   Since members of the working group join and leave during the\n\
    \   conference, it is useful to know who is participating at any moment\n   and\
    \ how well they are receiving the audio data.  For that purpose,\n   each instance\
    \ of the audio application in the conference periodically\n   multicasts a reception\
    \ report plus the name of its user on the RTCP\n   (control) port.  The reception\
    \ report indicates how well the current\n   speaker is being received and may\
    \ be used to control adaptive\n   encodings.  In addition to the user name, other\
    \ identifying\n   information may also be included subject to control bandwidth\
    \ limits.\n   A site sends the RTCP BYE packet (Section 6.6) when it leaves the\n\
    \   conference.\n"
- title: 2.2 Audio and Video Conference
  contents:
  - "2.2 Audio and Video Conference\n   If both audio and video media are used in\
    \ a conference, they are\n   transmitted as separate RTP sessions.  That is, separate\
    \ RTP and RTCP\n   packets are transmitted for each medium using two different\
    \ UDP port\n   pairs and/or multicast addresses.  There is no direct coupling\
    \ at the\n   RTP level between the audio and video sessions, except that a user\n\
    \   participating in both sessions should use the same distinguished\n   (canonical)\
    \ name in the RTCP packets for both so that the sessions\n   can be associated.\n\
    \   One motivation for this separation is to allow some participants in\n   the\
    \ conference to receive only one medium if they choose.  Further\n   explanation\
    \ is given in Section 5.2.  Despite the separation,\n   synchronized playback\
    \ of a source's audio and video can be achieved\n   using timing information carried\
    \ in the RTCP packets for both\n   sessions.\n"
- title: 2.3 Mixers and Translators
  contents:
  - "2.3 Mixers and Translators\n   So far, we have assumed that all sites want to\
    \ receive media data in\n   the same format.  However, this may not always be\
    \ appropriate.\n   Consider the case where participants in one area are connected\n\
    \   through a low-speed link to the majority of the conference\n   participants\
    \ who enjoy high-speed network access.  Instead of forcing\n   everyone to use\
    \ a lower-bandwidth, reduced-quality audio encoding, an\n   RTP-level relay called\
    \ a mixer may be placed near the low-bandwidth\n   area.  This mixer resynchronizes\
    \ incoming audio packets to\n   reconstruct the constant 20 ms spacing generated\
    \ by the sender, mixes\n   these reconstructed audio streams into a single stream,\
    \ translates\n   the audio encoding to a lower-bandwidth one and forwards the\
    \ lower-\n   bandwidth packet stream across the low-speed link.  These packets\n\
    \   might be unicast to a single recipient or multicast on a different\n   address\
    \ to multiple recipients.  The RTP header includes a means for\n   mixers to identify\
    \ the sources that contributed to a mixed packet so\n   that correct talker indication\
    \ can be provided at the receivers.\n   Some of the intended participants in the\
    \ audio conference may be\n   connected with high bandwidth links but might not\
    \ be directly\n   reachable via IP multicast.  For example, they might be behind\
    \ an\n   application-level firewall that will not let any IP packets pass.\n \
    \  For these sites, mixing may not be necessary, in which case another\n   type\
    \ of RTP-level relay called a translator may be used.  Two\n   translators are\
    \ installed, one on either side of the firewall, with\n   the outside one funneling\
    \ all multicast packets received through a\n   secure connection to the translator\
    \ inside the firewall.  The\n   translator inside the firewall sends them again\
    \ as multicast packets\n   to a multicast group restricted to the site's internal\
    \ network.\n   Mixers and translators may be designed for a variety of purposes.\
    \  An\n   example is a video mixer that scales the images of individual people\n\
    \   in separate video streams and composites them into one video stream\n   to\
    \ simulate a group scene.  Other examples of translation include the\n   connection\
    \ of a group of hosts speaking only IP/UDP to a group of\n   hosts that understand\
    \ only ST-II, or the packet-by-packet encoding\n   translation of video streams\
    \ from individual sources without\n   resynchronization or mixing.  Details of\
    \ the operation of mixers and\n   translators are given in Section 7.\n"
- title: 2.4 Layered Encodings
  contents:
  - "2.4 Layered Encodings\n   Multimedia applications should be able to adjust the\
    \ transmission\n   rate to match the capacity of the receiver or to adapt to network\n\
    \   congestion.  Many implementations place the responsibility of rate-\n   adaptivity\
    \ at the source.  This does not work well with multicast\n   transmission because\
    \ of the conflicting bandwidth requirements of\n   heterogeneous receivers.  The\
    \ result is often a least-common\n   denominator scenario, where the smallest\
    \ pipe in the network mesh\n   dictates the quality and fidelity of the overall\
    \ live multimedia\n   \"broadcast\".\n   Instead, responsibility for rate-adaptation\
    \ can be placed at the\n   receivers by combining a layered encoding with a layered\
    \ transmission\n   system.  In the context of RTP over IP multicast, the source\
    \ can\n   stripe the progressive layers of a hierarchically represented signal\n\
    \   across multiple RTP sessions each carried on its own multicast group.\n  \
    \ Receivers can then adapt to network heterogeneity and control their\n   reception\
    \ bandwidth by joining only the appropriate subset of the\n   multicast groups.\n\
    \   Details of the use of RTP with layered encodings are given in\n   Sections\
    \ 6.3.9, 8.3 and 11.\n"
- title: 3. Definitions
  contents:
  - "3. Definitions\n   RTP payload: The data transported by RTP in a packet, for\n\
    \      example audio samples or compressed video data.  The payload\n      format\
    \ and interpretation are beyond the scope of this document.\n   RTP packet: A\
    \ data packet consisting of the fixed RTP header, a\n      possibly empty list\
    \ of contributing sources (see below), and the\n      payload data.  Some underlying\
    \ protocols may require an\n      encapsulation of the RTP packet to be defined.\
    \  Typically one\n      packet of the underlying protocol contains a single RTP\
    \ packet,\n      but several RTP packets MAY be contained if permitted by the\n\
    \      encapsulation method (see Section 11).\n   RTCP packet: A control packet\
    \ consisting of a fixed header part\n      similar to that of RTP data packets,\
    \ followed by structured\n      elements that vary depending upon the RTCP packet\
    \ type.  The\n      formats are defined in Section 6.  Typically, multiple RTCP\n\
    \      packets are sent together as a compound RTCP packet in a single\n     \
    \ packet of the underlying protocol; this is enabled by the length\n      field\
    \ in the fixed header of each RTCP packet.\n   Port: The \"abstraction that transport\
    \ protocols use to\n      distinguish among multiple destinations within a given\
    \ host\n      computer.  TCP/IP protocols identify ports using small positive\n\
    \      integers.\" [12] The transport selectors (TSEL) used by the OSI\n     \
    \ transport layer are equivalent to ports.  RTP depends upon the\n      lower-layer\
    \ protocol to provide some mechanism such as ports to\n      multiplex the RTP\
    \ and RTCP packets of a session.\n   Transport address: The combination of a network\
    \ address and port\n      that identifies a transport-level endpoint, for example\
    \ an IP\n      address and a UDP port.  Packets are transmitted from a source\n\
    \      transport address to a destination transport address.\n   RTP media type:\
    \ An RTP media type is the collection of payload\n      types which can be carried\
    \ within a single RTP session.  The RTP\n      Profile assigns RTP media types\
    \ to RTP payload types.\n   Multimedia session: A set of concurrent RTP sessions\
    \ among a\n      common group of participants.  For example, a videoconference\n\
    \      (which is a multimedia session) may contain an audio RTP session\n    \
    \  and a video RTP session.\n   RTP session: An association among a set of participants\n\
    \      communicating with RTP.  A participant may be involved in multiple\n  \
    \    RTP sessions at the same time.  In a multimedia session, each\n      medium\
    \ is typically carried in a separate RTP session with its own\n      RTCP packets\
    \ unless the the encoding itself multiplexes multiple\n      media into a single\
    \ data stream.  A participant distinguishes\n      multiple RTP sessions by reception\
    \ of different sessions using\n      different pairs of destination transport\
    \ addresses, where a pair\n      of transport addresses comprises one network\
    \ address plus a pair\n      of ports for RTP and RTCP.  All participants in an\
    \ RTP session may\n      share a common destination transport address pair, as\
    \ in the case\n      of IP multicast, or the pairs may be different for each\n\
    \      participant, as in the case of individual unicast network\n      addresses\
    \ and port pairs.  In the unicast case, a participant may\n      receive from\
    \ all other participants in the session using the same\n      pair of ports, or\
    \ may use a distinct pair of ports for each.\n      The distinguishing feature\
    \ of an RTP session is that each\n      maintains a full, separate space of SSRC\
    \ identifiers (defined\n      next).  The set of participants included in one\
    \ RTP session\n      consists of those that can receive an SSRC identifier transmitted\n\
    \      by any one of the participants either in RTP as the SSRC or a CSRC\n  \
    \    (also defined below) or in RTCP.  For example, consider a three-\n      party\
    \ conference implemented using unicast UDP with each\n      participant receiving\
    \ from the other two on separate port pairs.\n      If each participant sends\
    \ RTCP feedback about data received from\n      one other participant only back\
    \ to that participant, then the\n      conference is composed of three separate\
    \ point-to-point RTP\n      sessions.  If each participant provides RTCP feedback\
    \ about its\n      reception of one other participant to both of the other\n \
    \     participants, then the conference is composed of one multi-party\n     \
    \ RTP session.  The latter case simulates the behavior that would\n      occur\
    \ with IP multicast communication among the three\n      participants.\n     \
    \ The RTP framework allows the variations defined here, but a\n      particular\
    \ control protocol or application design will usually\n      impose constraints\
    \ on these variations.\n   Synchronization source (SSRC): The source of a stream\
    \ of RTP\n      packets, identified by a 32-bit numeric SSRC identifier carried\
    \ in\n      the RTP header so as not to be dependent upon the network address.\n\
    \      All packets from a synchronization source form part of the same\n     \
    \ timing and sequence number space, so a receiver groups packets by\n      synchronization\
    \ source for playback.  Examples of synchronization\n      sources include the\
    \ sender of a stream of packets derived from a\n      signal source such as a\
    \ microphone or a camera, or an RTP mixer\n      (see below).  A synchronization\
    \ source may change its data format,\n      e.g., audio encoding, over time. \
    \ The SSRC identifier is a\n      randomly chosen value meant to be globally unique\
    \ within a\n      particular RTP session (see Section 8).  A participant need\
    \ not\n      use the same SSRC identifier for all the RTP sessions in a\n    \
    \  multimedia session; the binding of the SSRC identifiers is\n      provided\
    \ through RTCP (see Section 6.5.1).  If a participant\n      generates multiple\
    \ streams in one RTP session, for example from\n      separate video cameras,\
    \ each MUST be identified as a different\n      SSRC.\n   Contributing source\
    \ (CSRC): A source of a stream of RTP packets\n      that has contributed to the\
    \ combined stream produced by an RTP\n      mixer (see below).  The mixer inserts\
    \ a list of the SSRC\n      identifiers of the sources that contributed to the\
    \ generation of a\n      particular packet into the RTP header of that packet.\
    \  This list\n      is called the CSRC list.  An example application is audio\n\
    \      conferencing where a mixer indicates all the talkers whose speech\n   \
    \   was combined to produce the outgoing packet, allowing the receiver\n     \
    \ to indicate the current talker, even though all the audio packets\n      contain\
    \ the same SSRC identifier (that of the mixer).\n   End system: An application\
    \ that generates the content to be sent\n      in RTP packets and/or consumes\
    \ the content of received RTP\n      packets.  An end system can act as one or\
    \ more synchronization\n      sources in a particular RTP session, but typically\
    \ only one.\n   Mixer: An intermediate system that receives RTP packets from one\n\
    \      or more sources, possibly changes the data format, combines the\n     \
    \ packets in some manner and then forwards a new RTP packet.  Since\n      the\
    \ timing among multiple input sources will not generally be\n      synchronized,\
    \ the mixer will make timing adjustments among the\n      streams and generate\
    \ its own timing for the combined stream.\n      Thus, all data packets originating\
    \ from a mixer will be identified\n      as having the mixer as their synchronization\
    \ source.\n   Translator: An intermediate system that forwards RTP packets\n \
    \     with their synchronization source identifier intact.  Examples of\n    \
    \  translators include devices that convert encodings without mixing,\n      replicators\
    \ from multicast to unicast, and application-level\n      filters in firewalls.\n\
    \   Monitor: An application that receives RTCP packets sent by\n      participants\
    \ in an RTP session, in particular the reception\n      reports, and estimates\
    \ the current quality of service for\n      distribution monitoring, fault diagnosis\
    \ and long-term statistics.\n      The monitor function is likely to be built\
    \ into the application(s)\n      participating in the session, but may also be\
    \ a separate\n      application that does not otherwise participate and does not\
    \ send\n      or receive the RTP data packets (since they are on a separate\n\
    \      port).  These are called third-party monitors.  It is also\n      acceptable\
    \ for a third-party monitor to receive the RTP data\n      packets but not send\
    \ RTCP packets or otherwise be counted in the\n      session.\n   Non-RTP means:\
    \ Protocols and mechanisms that may be needed in\n      addition to RTP to provide\
    \ a usable service.  In particular, for\n      multimedia conferences, a control\
    \ protocol may distribute\n      multicast addresses and keys for encryption,\
    \ negotiate the\n      encryption algorithm to be used, and define dynamic mappings\n\
    \      between RTP payload type values and the payload formats they\n      represent\
    \ for formats that do not have a predefined payload type\n      value.  Examples\
    \ of such protocols include the Session Initiation\n      Protocol (SIP) (RFC\
    \ 3261 [13]), ITU Recommendation H.323 [14] and\n      applications using SDP\
    \ (RFC 2327 [15]), such as RTSP (RFC 2326\n      [16]).  For simple\n      applications,\
    \ electronic mail or a conference database may also be\n      used.  The specification\
    \ of such protocols and mechanisms is\n      outside the scope of this document.\n"
- title: 4. Byte Order, Alignment, and Time Format
  contents:
  - "4. Byte Order, Alignment, and Time Format\n   All integer fields are carried\
    \ in network byte order, that is, most\n   significant byte (octet) first.  This\
    \ byte order is commonly known as\n   big-endian.  The transmission order is described\
    \ in detail in [3].\n   Unless otherwise noted, numeric constants are in decimal\
    \ (base 10).\n   All header data is aligned to its natural length, i.e., 16-bit\
    \ fields\n   are aligned on even offsets, 32-bit fields are aligned at offsets\n\
    \   divisible by four, etc.  Octets designated as padding have the value\n   zero.\n\
    \   Wallclock time (absolute date and time) is represented using the\n   timestamp\
    \ format of the Network Time Protocol (NTP), which is in\n   seconds relative\
    \ to 0h UTC on 1 January 1900 [4].  The full\n   resolution NTP timestamp is a\
    \ 64-bit unsigned fixed-point number with\n   the integer part in the first 32\
    \ bits and the fractional part in the\n   last 32 bits.  In some fields where\
    \ a more compact representation is\n   appropriate, only the middle 32 bits are\
    \ used; that is, the low 16\n   bits of the integer part and the high 16 bits\
    \ of the fractional part.\n   The high 16 bits of the integer part must be determined\n\
    \   independently.\n   An implementation is not required to run the Network Time\
    \ Protocol in\n   order to use RTP.  Other time sources, or none at all, may be\
    \ used\n   (see the description of the NTP timestamp field in Section 6.4.1).\n\
    \   However, running NTP may be useful for synchronizing streams\n   transmitted\
    \ from separate hosts.\n   The NTP timestamp will wrap around to zero some time\
    \ in the year\n   2036, but for RTP purposes, only differences between pairs of\
    \ NTP\n   timestamps are used.  So long as the pairs of timestamps can be\n  \
    \ assumed to be within 68 years of each other, using modular arithmetic\n   for\
    \ subtractions and comparisons makes the wraparound irrelevant.\n"
- title: 5. RTP Data Transfer Protocol
  contents:
  - '5. RTP Data Transfer Protocol

    '
- title: 5.1 RTP Fixed Header Fields
  contents:
  - "5.1 RTP Fixed Header Fields\n   The RTP header has the following format:\n  \
    \  0                   1                   2                   3\n    0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |V=2|P|X|  CC   |M|     PT      |       sequence number         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           timestamp                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           synchronization source (SSRC) identifier            |\n   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n\
    \   |            contributing source (CSRC) identifiers             |\n   |  \
    \                           ....                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The first twelve octets are present in every RTP packet, while the\n   list\
    \ of CSRC identifiers is present only when inserted by a mixer.\n   The fields\
    \ have the following meaning:\n   version (V): 2 bits\n      This field identifies\
    \ the version of RTP.  The version defined by\n      this specification is two\
    \ (2).  (The value 1 is used by the first\n      draft version of RTP and the\
    \ value 0 is used by the protocol\n      initially implemented in the \"vat\"\
    \ audio tool.)\n   padding (P): 1 bit\n      If the padding bit is set, the packet\
    \ contains one or more\n      additional padding octets at the end which are not\
    \ part of the\n      payload.  The last octet of the padding contains a count\
    \ of how\n      many padding octets should be ignored, including itself.  Padding\n\
    \      may be needed by some encryption algorithms with fixed block sizes\n  \
    \    or for carrying several RTP packets in a lower-layer protocol data\n    \
    \  unit.\n   extension (X): 1 bit\n      If the extension bit is set, the fixed\
    \ header MUST be followed by\n      exactly one header extension, with a format\
    \ defined in Section\n      5.3.1.\n   CSRC count (CC): 4 bits\n      The CSRC\
    \ count contains the number of CSRC identifiers that follow\n      the fixed header.\n\
    \   marker (M): 1 bit\n      The interpretation of the marker is defined by a\
    \ profile.  It is\n      intended to allow significant events such as frame boundaries\
    \ to\n      be marked in the packet stream.  A profile MAY define additional\n\
    \      marker bits or specify that there is no marker bit by changing the\n  \
    \    number of bits in the payload type field (see Section 5.3).\n   payload type\
    \ (PT): 7 bits\n      This field identifies the format of the RTP payload and\
    \ determines\n      its interpretation by the application.  A profile MAY specify\
    \ a\n      default static mapping of payload type codes to payload formats.\n\
    \      Additional payload type codes MAY be defined dynamically through\n    \
    \  non-RTP means (see Section 3).  A set of default mappings for\n      audio\
    \ and video is specified in the companion RFC 3551 [1].  An\n      RTP source\
    \ MAY change the payload type during a session, but this\n      field SHOULD NOT\
    \ be used for multiplexing separate media streams\n      (see Section 5.2).\n\
    \      A receiver MUST ignore packets with payload types that it does not\n  \
    \    understand.\n   sequence number: 16 bits\n      The sequence number increments\
    \ by one for each RTP data packet\n      sent, and may be used by the receiver\
    \ to detect packet loss and to\n      restore packet sequence.  The initial value\
    \ of the sequence number\n      SHOULD be random (unpredictable) to make known-plaintext\
    \ attacks\n      on encryption more difficult, even if the source itself does\
    \ not\n      encrypt according to the method in Section 9.1, because the\n   \
    \   packets may flow through a translator that does.  Techniques for\n      choosing\
    \ unpredictable numbers are discussed in [17].\n   timestamp: 32 bits\n      The\
    \ timestamp reflects the sampling instant of the first octet in\n      the RTP\
    \ data packet.  The sampling instant MUST be derived from a\n      clock that\
    \ increments monotonically and linearly in time to allow\n      synchronization\
    \ and jitter calculations (see Section 6.4.1).  The\n      resolution of the clock\
    \ MUST be sufficient for the desired\n      synchronization accuracy and for measuring\
    \ packet arrival jitter\n      (one tick per video frame is typically not sufficient).\
    \  The clock\n      frequency is dependent on the format of data carried as payload\n\
    \      and is specified statically in the profile or payload format\n      specification\
    \ that defines the format, or MAY be specified\n      dynamically for payload\
    \ formats defined through non-RTP means.  If\n      RTP packets are generated\
    \ periodically, the nominal sampling\n      instant as determined from the sampling\
    \ clock is to be used, not a\n      reading of the system clock.  As an example,\
    \ for fixed-rate audio\n      the timestamp clock would likely increment by one\
    \ for each\n      sampling period.  If an audio application reads blocks covering\n\
    \      160 sampling periods from the input device, the timestamp would be\n  \
    \    increased by 160 for each such block, regardless of whether the\n      block\
    \ is transmitted in a packet or dropped as silent.\n      The initial value of\
    \ the timestamp SHOULD be random, as for the\n      sequence number.  Several\
    \ consecutive RTP packets will have equal\n      timestamps if they are (logically)\
    \ generated at once, e.g., belong\n      to the same video frame.  Consecutive\
    \ RTP packets MAY contain\n      timestamps that are not monotonic if the data\
    \ is not transmitted\n      in the order it was sampled, as in the case of MPEG\
    \ interpolated\n      video frames.  (The sequence numbers of the packets as transmitted\n\
    \      will still be monotonic.)\n      RTP timestamps from different media streams\
    \ may advance at\n      different rates and usually have independent, random offsets.\n\
    \      Therefore, although these timestamps are sufficient to reconstruct\n  \
    \    the timing of a single stream, directly comparing RTP timestamps\n      from\
    \ different media is not effective for synchronization.\n      Instead, for each\
    \ medium the RTP timestamp is related to the\n      sampling instant by pairing\
    \ it with a timestamp from a reference\n      clock (wallclock) that represents\
    \ the time when the data\n      corresponding to the RTP timestamp was sampled.\
    \  The reference\n      clock is shared by all media to be synchronized.  The\
    \ timestamp\n      pairs are not transmitted in every data packet, but at a lower\n\
    \      rate in RTCP SR packets as described in Section 6.4.\n      The sampling\
    \ instant is chosen as the point of reference for the\n      RTP timestamp because\
    \ it is known to the transmitting endpoint and\n      has a common definition\
    \ for all media, independent of encoding\n      delays or other processing.  The\
    \ purpose is to allow synchronized\n      presentation of all media sampled at\
    \ the same time.\n      Applications transmitting stored data rather than data\
    \ sampled in\n      real time typically use a virtual presentation timeline derived\n\
    \      from wallclock time to determine when the next frame or other unit\n  \
    \    of each medium in the stored data should be presented.  In this\n      case,\
    \ the RTP timestamp would reflect the presentation time for\n      each unit.\
    \  That is, the RTP timestamp for each unit would be\n      related to the wallclock\
    \ time at which the unit becomes current on\n      the virtual presentation timeline.\
    \  Actual presentation occurs\n      some time later as determined by the receiver.\n\
    \      An example describing live audio narration of prerecorded video\n     \
    \ illustrates the significance of choosing the sampling instant as\n      the\
    \ reference point.  In this scenario, the video would be\n      presented locally\
    \ for the narrator to view and would be\n      simultaneously transmitted using\
    \ RTP.  The \"sampling instant\" of a\n      video frame transmitted in RTP would\
    \ be established by referencing\n      its timestamp to the wallclock time when\
    \ that video frame was\n      presented to the narrator.  The sampling instant\
    \ for the audio RTP\n      packets containing the narrator's speech would be established\
    \ by\n      referencing the same wallclock time when the audio was sampled.\n\
    \      The audio and video may even be transmitted by different hosts if\n   \
    \   the reference clocks on the two hosts are synchronized by some\n      means\
    \ such as NTP.  A receiver can then synchronize presentation\n      of the audio\
    \ and video packets by relating their RTP timestamps\n      using the timestamp\
    \ pairs in RTCP SR packets.\n   SSRC: 32 bits\n      The SSRC field identifies\
    \ the synchronization source.  This\n      identifier SHOULD be chosen randomly,\
    \ with the intent that no two\n      synchronization sources within the same RTP\
    \ session will have the\n      same SSRC identifier.  An example algorithm for\
    \ generating a\n      random identifier is presented in Appendix A.6.  Although\
    \ the\n      probability of multiple sources choosing the same identifier is\n\
    \      low, all RTP implementations must be prepared to detect and\n      resolve\
    \ collisions.  Section 8 describes the probability of\n      collision along with\
    \ a mechanism for resolving collisions and\n      detecting RTP-level forwarding\
    \ loops based on the uniqueness of\n      the SSRC identifier.  If a source changes\
    \ its source transport\n      address, it must also choose a new SSRC identifier\
    \ to avoid being\n      interpreted as a looped source (see Section 8.2).\n  \
    \ CSRC list: 0 to 15 items, 32 bits each\n      The CSRC list identifies the contributing\
    \ sources for the payload\n      contained in this packet.  The number of identifiers\
    \ is given by\n      the CC field.  If there are more than 15 contributing sources,\n\
    \      only 15 can be identified.  CSRC identifiers are inserted by\n      mixers\
    \ (see Section 7.1), using the SSRC identifiers of\n      contributing sources.\
    \  For example, for audio packets the SSRC\n      identifiers of all sources that\
    \ were mixed together to create a\n      packet are listed, allowing correct talker\
    \ indication at the\n      receiver.\n"
- title: 5.2 Multiplexing RTP Sessions
  contents:
  - "5.2 Multiplexing RTP Sessions\n   For efficient protocol processing, the number\
    \ of multiplexing points\n   should be minimized, as described in the integrated\
    \ layer processing\n   design principle [10].  In RTP, multiplexing is provided\
    \ by the\n   destination transport address (network address and port number) which\n\
    \   is different for each RTP session.  For example, in a teleconference\n   composed\
    \ of audio and video media encoded separately, each medium\n   SHOULD be carried\
    \ in a separate RTP session with its own destination\n   transport address.\n\
    \   Separate audio and video streams SHOULD NOT be carried in a single\n   RTP\
    \ session and demultiplexed based on the payload type or SSRC\n   fields.  Interleaving\
    \ packets with different RTP media types but\n   using the same SSRC would introduce\
    \ several problems:\n   1. If, say, two audio streams shared the same RTP session\
    \ and the\n      same SSRC value, and one were to change encodings and thus acquire\n\
    \      a different RTP payload type, there would be no general way of\n      identifying\
    \ which stream had changed encodings.\n   2. An SSRC is defined to identify a\
    \ single timing and sequence number\n      space.  Interleaving multiple payload\
    \ types would require\n      different timing spaces if the media clock rates\
    \ differ and would\n      require different sequence number spaces to tell which\
    \ payload\n      type suffered packet loss.\n   3. The RTCP sender and receiver\
    \ reports (see Section 6.4) can only\n      describe one timing and sequence number\
    \ space per SSRC and do not\n      carry a payload type field.\n   4. An RTP mixer\
    \ would not be able to combine interleaved streams of\n      incompatible media\
    \ into one stream.\n   5. Carrying multiple media in one RTP session precludes:\
    \ the use of\n      different network paths or network resource allocations if\n\
    \      appropriate; reception of a subset of the media if desired, for\n     \
    \ example just audio if video would exceed the available bandwidth;\n      and\
    \ receiver implementations that use separate processes for the\n      different\
    \ media, whereas using separate RTP sessions permits\n      either single- or\
    \ multiple-process implementations.\n   Using a different SSRC for each medium\
    \ but sending them in the same\n   RTP session would avoid the first three problems\
    \ but not the last\n   two.\n   On the other hand, multiplexing multiple related\
    \ sources of the same\n   medium in one RTP session using different SSRC values\
    \ is the norm for\n   multicast sessions.  The problems listed above don't apply:\
    \ an RTP\n   mixer can combine multiple audio sources, for example, and the same\n\
    \   treatment is applicable for all of them.  It may also be appropriate\n   to\
    \ multiplex streams of the same medium using different SSRC values\n   in other\
    \ scenarios where the last two problems do not apply.\n"
- title: 5.3 Profile-Specific Modifications to the RTP Header
  contents:
  - "5.3 Profile-Specific Modifications to the RTP Header\n   The existing RTP data\
    \ packet header is believed to be complete for\n   the set of functions required\
    \ in common across all the application\n   classes that RTP might support.  However,\
    \ in keeping with the ALF\n   design principle, the header MAY be tailored through\
    \ modifications or\n   additions defined in a profile specification while still\
    \ allowing\n   profile-independent monitoring and recording tools to function.\n\
    \   o  The marker bit and payload type field carry profile-specific\n      information,\
    \ but they are allocated in the fixed header since many\n      applications are\
    \ expected to need them and might otherwise have to\n      add another 32-bit\
    \ word just to hold them.  The octet containing\n      these fields MAY be redefined\
    \ by a profile to suit different\n      requirements, for example with more or\
    \ fewer marker bits.  If\n      there are any marker bits, one SHOULD be located\
    \ in the most\n      significant bit of the octet since profile-independent monitors\n\
    \      may be able to observe a correlation between packet loss patterns\n   \
    \   and the marker bit.\n   o  Additional information that is required for a particular\
    \ payload\n      format, such as a video encoding, SHOULD be carried in the payload\n\
    \      section of the packet.  This might be in a header that is always\n    \
    \  present at the start of the payload section, or might be indicated\n      by\
    \ a reserved value in the data pattern.\n   o  If a particular class of applications\
    \ needs additional\n      functionality independent of payload format, the profile\
    \ under\n      which those applications operate SHOULD define additional fixed\n\
    \      fields to follow immediately after the SSRC field of the existing\n   \
    \   fixed header.  Those applications will be able to quickly and\n      directly\
    \ access the additional fields while profile-independent\n      monitors or recorders\
    \ can still process the RTP packets by\n      interpreting only the first twelve\
    \ octets.\n   If it turns out that additional functionality is needed in common\n\
    \   across all profiles, then a new version of RTP should be defined to\n   make\
    \ a permanent change to the fixed header.\n"
- title: 5.3.1 RTP Header Extension
  contents:
  - "5.3.1 RTP Header Extension\n   An extension mechanism is provided to allow individual\n\
    \   implementations to experiment with new payload-format-independent\n   functions\
    \ that require additional information to be carried in the\n   RTP data packet\
    \ header.  This mechanism is designed so that the\n   header extension may be\
    \ ignored by other interoperating\n   implementations that have not been extended.\n\
    \   Note that this header extension is intended only for limited use.\n   Most\
    \ potential uses of this mechanism would be better done another\n   way, using\
    \ the methods described in the previous section.  For\n   example, a profile-specific\
    \ extension to the fixed header is less\n   expensive to process because it is\
    \ not conditional nor in a variable\n   location.  Additional information required\
    \ for a particular payload\n   format SHOULD NOT use this header extension, but\
    \ SHOULD be carried in\n   the payload section of the packet.\n    0         \
    \          1                   2                   3\n    0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      defined by profile       |           length              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        header extension                       |\n   |  \
    \                           ....                              |\n   If the X bit\
    \ in the RTP header is one, a variable-length header\n   extension MUST be appended\
    \ to the RTP header, following the CSRC list\n   if present.  The header extension\
    \ contains a 16-bit length field that\n   counts the number of 32-bit words in\
    \ the extension, excluding the\n   four-octet extension header (therefore zero\
    \ is a valid length).  Only\n   a single extension can be appended to the RTP\
    \ data header.  To allow\n   multiple interoperating implementations to each experiment\n\
    \   independently with different header extensions, or to allow a\n   particular\
    \ implementation to experiment with more than one type of\n   header extension,\
    \ the first 16 bits of the header extension are left\n   open for distinguishing\
    \ identifiers or parameters.  The format of\n   these 16 bits is to be defined\
    \ by the profile specification under\n   which the implementations are operating.\
    \  This RTP specification does\n   not define any header extensions itself.\n"
- title: 6. RTP Control Protocol -- RTCP
  contents:
  - "6. RTP Control Protocol -- RTCP\n   The RTP control protocol (RTCP) is based\
    \ on the periodic transmission\n   of control packets to all participants in the\
    \ session, using the same\n   distribution mechanism as the data packets.  The\
    \ underlying protocol\n   MUST provide multiplexing of the data and control packets,\
    \ for\n   example using separate port numbers with UDP.  RTCP performs four\n\
    \   functions:\n   1. The primary function is to provide feedback on the quality\
    \ of the\n      data distribution.  This is an integral part of the RTP's role\
    \ as\n      a transport protocol and is related to the flow and congestion\n \
    \     control functions of other transport protocols (see Section 10 on\n    \
    \  the requirement for congestion control).  The feedback may be\n      directly\
    \ useful for control of adaptive encodings [18,19], but\n      experiments with\
    \ IP multicasting have shown that it is also\n      critical to get feedback from\
    \ the receivers to diagnose faults in\n      the distribution.  Sending reception\
    \ feedback reports to all\n      participants allows one who is observing problems\
    \ to evaluate\n      whether those problems are local or global.  With a distribution\n\
    \      mechanism like IP multicast, it is also possible for an entity\n      such\
    \ as a network service provider who is not otherwise involved\n      in the session\
    \ to receive the feedback information and act as a\n      third-party monitor\
    \ to diagnose network problems.  This feedback\n      function is performed by\
    \ the RTCP sender and receiver reports,\n      described below in Section 6.4.\n\
    \   2. RTCP carries a persistent transport-level identifier for an RTP\n     \
    \ source called the canonical name or CNAME, Section 6.5.1.  Since\n      the\
    \ SSRC identifier may change if a conflict is discovered or a\n      program is\
    \ restarted, receivers require the CNAME to keep track of\n      each participant.\
    \  Receivers may also require the CNAME to\n      associate multiple data streams\
    \ from a given participant in a set\n      of related RTP sessions, for example\
    \ to synchronize audio and\n      video.  Inter-media synchronization also requires\
    \ the NTP and RTP\n      timestamps included in RTCP packets by data senders.\n\
    \   3. The first two functions require that all participants send RTCP\n     \
    \ packets, therefore the rate must be controlled in order for RTP to\n      scale\
    \ up to a large number of participants.  By having each\n      participant send\
    \ its control packets to all the others, each can\n      independently observe\
    \ the number of participants.  This number is\n      used to calculate the rate\
    \ at which the packets are sent, as\n      explained in Section 6.2.\n   4. A\
    \ fourth, OPTIONAL function is to convey minimal session control\n      information,\
    \ for example participant identification to be\n      displayed in the user interface.\
    \  This is most likely to be useful\n      in \"loosely controlled\" sessions\
    \ where participants enter and\n      leave without membership control or parameter\
    \ negotiation.  RTCP\n      serves as a convenient channel to reach all the participants,\
    \ but\n      it is not necessarily expected to support all the control\n     \
    \ communication requirements of an application.  A higher-level\n      session\
    \ control protocol, which is beyond the scope of this\n      document, may be\
    \ needed.\n   Functions 1-3 SHOULD be used in all environments, but particularly\
    \ in\n   the IP multicast environment.  RTP application designers SHOULD avoid\n\
    \   mechanisms that can only work in unicast mode and will not scale to\n   larger\
    \ numbers.  Transmission of RTCP MAY be controlled separately\n   for senders\
    \ and receivers, as described in Section 6.2, for cases\n   such as unidirectional\
    \ links where feedback from receivers is not\n   possible.\n   Non-normative note:\
    \  In the multicast routing approach\n      called Source-Specific Multicast (SSM),\
    \ there is only one sender\n      per \"channel\" (a source address, group address\
    \ pair), and\n      receivers (except for the channel source) cannot use multicast\
    \ to\n      communicate directly with other channel members.  The\n      recommendations\
    \ here accommodate SSM only through Section 6.2's\n      option of turning off\
    \ receivers' RTCP entirely.  Future work will\n      specify adaptation of RTCP\
    \ for SSM so that feedback from receivers\n      can be maintained.\n"
- title: 6.1 RTCP Packet Format
  contents:
  - "6.1 RTCP Packet Format\n   This specification defines several RTCP packet types\
    \ to carry a\n   variety of control information:\n   SR:   Sender report, for\
    \ transmission and reception statistics from\n         participants that are active\
    \ senders\n   RR:   Receiver report, for reception statistics from participants\n\
    \         that are not active senders and in combination with SR for\n       \
    \  active senders reporting on more than 31 sources\n   SDES: Source description\
    \ items, including CNAME\n   BYE:  Indicates end of participation\n   APP:  Application-specific\
    \ functions\n   Each RTCP packet begins with a fixed part similar to that of RTP\
    \ data\n   packets, followed by structured elements that MAY be of variable\n\
    \   length according to the packet type but MUST end on a 32-bit\n   boundary.\
    \  The alignment requirement and a length field in the fixed\n   part of each\
    \ packet are included to make RTCP packets \"stackable\".\n   Multiple RTCP packets\
    \ can be concatenated without any intervening\n   separators to form a compound\
    \ RTCP packet that is sent in a single\n   packet of the lower layer protocol,\
    \ for example UDP.  There is no\n   explicit count of individual RTCP packets\
    \ in the compound packet\n   since the lower layer protocols are expected to provide\
    \ an overall\n   length to determine the end of the compound packet.\n   Each\
    \ individual RTCP packet in the compound packet may be processed\n   independently\
    \ with no requirements upon the order or combination of\n   packets.  However,\
    \ in order to perform the functions of the protocol,\n   the following constraints\
    \ are imposed:\n   o  Reception statistics (in SR or RR) should be sent as often\
    \ as\n      bandwidth constraints will allow to maximize the resolution of the\n\
    \      statistics, therefore each periodically transmitted compound RTCP\n   \
    \   packet MUST include a report packet.\n   o  New receivers need to receive\
    \ the CNAME for a source as soon as\n      possible to identify the source and\
    \ to begin associating media for\n      purposes such as lip-sync, so each compound\
    \ RTCP packet MUST also\n      include the SDES CNAME except when the compound\
    \ RTCP packet is\n      split for partial encryption as described in Section 9.1.\n\
    \   o  The number of packet types that may appear first in the compound\n    \
    \  packet needs to be limited to increase the number of constant bits\n      in\
    \ the first word and the probability of successfully validating\n      RTCP packets\
    \ against misaddressed RTP data packets or other\n      unrelated packets.\n \
    \  Thus, all RTCP packets MUST be sent in a compound packet of at least\n   two\
    \ individual packets, with the following format:\n   Encryption prefix:  If and\
    \ only if the compound packet is to be\n      encrypted according to the method\
    \ in Section 9.1, it MUST be\n      prefixed by a random 32-bit quantity redrawn\
    \ for every compound\n      packet transmitted.  If padding is required for the\
    \ encryption, it\n      MUST be added to the last packet of the compound packet.\n\
    \   SR or RR:  The first RTCP packet in the compound packet MUST\n      always\
    \ be a report packet to facilitate header validation as\n      described in Appendix\
    \ A.2.  This is true even if no data has been\n      sent or received, in which\
    \ case an empty RR MUST be sent, and even\n      if the only other RTCP packet\
    \ in the compound packet is a BYE.\n   Additional RRs:  If the number of sources\
    \ for which reception\n      statistics are being reported exceeds 31, the number\
    \ that will fit\n      into one SR or RR packet, then additional RR packets SHOULD\
    \ follow\n      the initial report packet.\n   SDES:  An SDES packet containing\
    \ a CNAME item MUST be included\n      in each compound RTCP packet, except as\
    \ noted in Section 9.1.\n      Other source description items MAY optionally be\
    \ included if\n      required by a particular application, subject to bandwidth\n\
    \      constraints (see Section 6.3.9).\n   BYE or APP:  Other RTCP packet types,\
    \ including those yet to be\n      defined, MAY follow in any order, except that\
    \ BYE SHOULD be the\n      last packet sent with a given SSRC/CSRC.  Packet types\
    \ MAY appear\n      more than once.\n   An individual RTP participant SHOULD send\
    \ only one compound RTCP\n   packet per report interval in order for the RTCP\
    \ bandwidth per\n   participant to be estimated correctly (see Section 6.2), except\
    \ when\n   the compound RTCP packet is split for partial encryption as described\n\
    \   in Section 9.1.  If there are too many sources to fit all the\n   necessary\
    \ RR packets into one compound RTCP packet without exceeding\n   the maximum transmission\
    \ unit (MTU) of the network path, then only\n   the subset that will fit into\
    \ one MTU SHOULD be included in each\n   interval.  The subsets SHOULD be selected\
    \ round-robin across multiple\n   intervals so that all sources are reported.\n\
    \   It is RECOMMENDED that translators and mixers combine individual RTCP\n  \
    \ packets from the multiple sources they are forwarding into one\n   compound\
    \ packet whenever feasible in order to amortize the packet\n   overhead (see Section\
    \ 7).  An example RTCP compound packet as might\n   be produced by a mixer is\
    \ shown in Fig. 1.  If the overall length of\n   a compound packet would exceed\
    \ the MTU of the network path, it SHOULD\n   be segmented into multiple shorter\
    \ compound packets to be transmitted\n   in separate packets of the underlying\
    \ protocol.  This does not impair\n   the RTCP bandwidth estimation because each\
    \ compound packet represents\n   at least one distinct participant.  Note that\
    \ each of the compound\n   packets MUST begin with an SR or RR packet.\n   An\
    \ implementation SHOULD ignore incoming RTCP packets with types\n   unknown to\
    \ it.  Additional RTCP packet types may be registered with\n   the Internet Assigned\
    \ Numbers Authority (IANA) as described in\n   Section 15.\n   if encrypted: random\
    \ 32-bit integer\n   |\n   |[--------- packet --------][---------- packet ----------][-packet-]\n\
    \   |\n   |                receiver            chunk        chunk\n   V      \
    \          reports           item  item   item  item\n   --------------------------------------------------------------------\n\
    \   R[SR #sendinfo #site1#site2][SDES #CNAME PHONE #CNAME LOC][BYE##why]\n   --------------------------------------------------------------------\n\
    \   |                                                                  |\n   |<-----------------------\
    \  compound packet ----------------------->|\n   |<--------------------------\
    \  UDP packet ------------------------->|\n   #: SSRC/CSRC identifier\n      \
    \        Figure 1: Example of an RTCP compound packet\n"
- title: 6.2 RTCP Transmission Interval
  contents:
  - "6.2 RTCP Transmission Interval\n   RTP is designed to allow an application to\
    \ scale automatically over\n   session sizes ranging from a few participants to\
    \ thousands.  For\n   example, in an audio conference the data traffic is inherently\
    \ self-\n   limiting because only one or two people will speak at a time, so with\n\
    \   multicast distribution the data rate on any given link remains\n   relatively\
    \ constant independent of the number of participants.\n   However, the control\
    \ traffic is not self-limiting.  If the reception\n   reports from each participant\
    \ were sent at a constant rate, the\n   control traffic would grow linearly with\
    \ the number of participants.\n   Therefore, the rate must be scaled down by dynamically\
    \ calculating\n   the interval between RTCP packet transmissions.\n   For each\
    \ session, it is assumed that the data traffic is subject to\n   an aggregate\
    \ limit called the \"session bandwidth\" to be divided among\n   the participants.\
    \  This bandwidth might be reserved and the limit\n   enforced by the network.\
    \  If there is no reservation, there may be\n   other constraints, depending on\
    \ the environment, that establish the\n   \"reasonable\" maximum for the session\
    \ to use, and that would be the\n   session bandwidth.  The session bandwidth\
    \ may be chosen based on some\n   cost or a priori knowledge of the available\
    \ network bandwidth for the\n   session.  It is somewhat independent of the media\
    \ encoding, but the\n   encoding choice may be limited by the session bandwidth.\
    \  Often, the\n   session bandwidth is the sum of the nominal bandwidths of the\
    \ senders\n   expected to be concurrently active.  For teleconference audio, this\n\
    \   number would typically be one sender's bandwidth.  For layered\n   encodings,\
    \ each layer is a separate RTP session with its own session\n   bandwidth parameter.\n\
    \   The session bandwidth parameter is expected to be supplied by a\n   session\
    \ management application when it invokes a media application,\n   but media applications\
    \ MAY set a default based on the single-sender\n   data bandwidth for the encoding\
    \ selected for the session.  The\n   application MAY also enforce bandwidth limits\
    \ based on multicast\n   scope rules or other criteria.  All participants MUST\
    \ use the same\n   value for the session bandwidth so that the same RTCP interval\
    \ will\n   be calculated.\n   Bandwidth calculations for control and data traffic\
    \ include lower-\n   layer transport and network protocols (e.g., UDP and IP)\
    \ since that\n   is what the resource reservation system would need to know. \
    \ The\n   application can also be expected to know which of these protocols are\n\
    \   in use.  Link level headers are not included in the calculation since\n  \
    \ the packet will be encapsulated with different link level headers as\n   it\
    \ travels.\n   The control traffic should be limited to a small and known fraction\n\
    \   of the session bandwidth: small so that the primary function of the\n   transport\
    \ protocol to carry data is not impaired; known so that the\n   control traffic\
    \ can be included in the bandwidth specification given\n   to a resource reservation\
    \ protocol, and so that each participant can\n   independently calculate its share.\
    \  The control traffic bandwidth is\n   in addition to the session bandwidth for\
    \ the data traffic.  It is\n   RECOMMENDED that the fraction of the session bandwidth\
    \ added for RTCP\n   be fixed at 5%.  It is also RECOMMENDED that 1/4 of the RTCP\n\
    \   bandwidth be dedicated to participants that are sending data so that\n   in\
    \ sessions with a large number of receivers but a small number of\n   senders,\
    \ newly joining participants will more quickly receive the\n   CNAME for the sending\
    \ sites.  When the proportion of senders is\n   greater than 1/4 of the participants,\
    \ the senders get their\n   proportion of the full RTCP bandwidth.  While the\
    \ values of these and\n   other constants in the interval calculation are not\
    \ critical, all\n   participants in the session MUST use the same values so the\
    \ same\n   interval will be calculated.  Therefore, these constants SHOULD be\n\
    \   fixed for a particular profile.\n   A profile MAY specify that the control\
    \ traffic bandwidth may be a\n   separate parameter of the session rather than\
    \ a strict percentage of\n   the session bandwidth.  Using a separate parameter\
    \ allows rate-\n   adaptive applications to set an RTCP bandwidth consistent with\
    \ a\n   \"typical\" data bandwidth that is lower than the maximum bandwidth\n\
    \   specified by the session bandwidth parameter.\n   The profile MAY further\
    \ specify that the control traffic bandwidth\n   may be divided into two separate\
    \ session parameters for those\n   participants which are active data senders\
    \ and those which are not;\n   let us call the parameters S and R.  Following\
    \ the recommendation\n   that 1/4 of the RTCP bandwidth be dedicated to data senders,\
    \ the\n   RECOMMENDED default values for these two parameters would be 1.25%\n\
    \   and 3.75%, respectively.  When the proportion of senders is greater\n   than\
    \ S/(S+R) of the participants, the senders get their proportion of\n   the sum\
    \ of these parameters.  Using two parameters allows RTCP\n   reception reports\
    \ to be turned off entirely for a particular session\n   by setting the RTCP bandwidth\
    \ for non-data-senders to zero while\n   keeping the RTCP bandwidth for data senders\
    \ non-zero so that sender\n   reports can still be sent for inter-media synchronization.\
    \  Turning\n   off RTCP reception reports is NOT RECOMMENDED because they are\
    \ needed\n   for the functions listed at the beginning of Section 6, particularly\n\
    \   reception quality feedback and congestion control.  However, doing so\n  \
    \ may be appropriate for systems operating on unidirectional links or\n   for\
    \ sessions that don't require feedback on the quality of reception\n   or liveness\
    \ of receivers and that have other means to avoid\n   congestion.\n   The calculated\
    \ interval between transmissions of compound RTCP\n   packets SHOULD also have\
    \ a lower bound to avoid having bursts of\n   packets exceed the allowed bandwidth\
    \ when the number of participants\n   is small and the traffic isn't smoothed\
    \ according to the law of large\n   numbers.  It also keeps the report interval\
    \ from becoming too small\n   during transient outages like a network partition\
    \ such that\n   adaptation is delayed when the partition heals.  At application\n\
    \   startup, a delay SHOULD be imposed before the first compound RTCP\n   packet\
    \ is sent to allow time for RTCP packets to be received from\n   other participants\
    \ so the report interval will converge to the\n   correct value more quickly.\
    \  This delay MAY be set to half the\n   minimum interval to allow quicker notification\
    \ that the new\n   participant is present.  The RECOMMENDED value for a fixed\
    \ minimum\n   interval is 5 seconds.\n   An implementation MAY scale the minimum\
    \ RTCP interval to a smaller\n   value inversely proportional to the session bandwidth\
    \ parameter with\n   the following limitations:\n   o  For multicast sessions,\
    \ only active data senders MAY use the\n      reduced minimum value to calculate\
    \ the interval for transmission\n      of compound RTCP packets.\n   o  For unicast\
    \ sessions, the reduced value MAY be used by\n      participants that are not\
    \ active data senders as well, and the\n      delay before sending the initial\
    \ compound RTCP packet MAY be zero.\n   o  For all sessions, the fixed minimum\
    \ SHOULD be used when\n      calculating the participant timeout interval (see\
    \ Section 6.3.5)\n      so that implementations which do not use the reduced value\
    \ for\n      transmitting RTCP packets are not timed out by other participants\n\
    \      prematurely.\n   o  The RECOMMENDED value for the reduced minimum in seconds\
    \ is 360\n      divided by the session bandwidth in kilobits/second.  This minimum\n\
    \      is smaller than 5 seconds for bandwidths greater than 72 kb/s.\n   The\
    \ algorithm described in Section 6.3 and Appendix A.7 was designed\n   to meet\
    \ the goals outlined in this section.  It calculates the\n   interval between\
    \ sending compound RTCP packets to divide the allowed\n   control traffic bandwidth\
    \ among the participants.  This allows an\n   application to provide fast response\
    \ for small sessions where, for\n   example, identification of all participants\
    \ is important, yet\n   automatically adapt to large sessions.  The algorithm\
    \ incorporates\n   the following characteristics:\n   o  The calculated interval\
    \ between RTCP packets scales linearly with\n      the number of members in the\
    \ group.  It is this linear factor\n      which allows for a constant amount of\
    \ control traffic when summed\n      across all members.\n   o  The interval between\
    \ RTCP packets is varied randomly over the\n      range [0.5,1.5] times the calculated\
    \ interval to avoid unintended\n      synchronization of all participants [20].\
    \  The first RTCP packet\n      sent after joining a session is also delayed by\
    \ a random variation\n      of half the minimum RTCP interval.\n   o  A dynamic\
    \ estimate of the average compound RTCP packet size is\n      calculated, including\
    \ all those packets received and sent, to\n      automatically adapt to changes\
    \ in the amount of control\n      information carried.\n   o  Since the calculated\
    \ interval is dependent on the number of\n      observed group members, there\
    \ may be undesirable startup effects\n      when a new user joins an existing\
    \ session, or many users\n      simultaneously join a new session.  These new\
    \ users will initially\n      have incorrect estimates of the group membership,\
    \ and thus their\n      RTCP transmission interval will be too short.  This problem\
    \ can be\n      significant if many users join the session simultaneously.  To\n\
    \      deal with this, an algorithm called \"timer reconsideration\" is\n    \
    \  employed.  This algorithm implements a simple back-off mechanism\n      which\
    \ causes users to hold back RTCP packet transmission if the\n      group sizes\
    \ are increasing.\n   o  When users leave a session, either with a BYE or by timeout,\
    \ the\n      group membership decreases, and thus the calculated interval\n  \
    \    should decrease.  A \"reverse reconsideration\" algorithm is used to\n  \
    \    allow members to more quickly reduce their intervals in response\n      to\
    \ group membership decreases.\n   o  BYE packets are given different treatment\
    \ than other RTCP packets.\n      When a user leaves a group, and wishes to send\
    \ a BYE packet, it\n      may do so before its next scheduled RTCP packet.  However,\n\
    \      transmission of BYEs follows a back-off algorithm which avoids\n      floods\
    \ of BYE packets should a large number of members\n      simultaneously leave\
    \ the session.\n   This algorithm may be used for sessions in which all participants\
    \ are\n   allowed to send.  In that case, the session bandwidth parameter is\n\
    \   the product of the individual sender's bandwidth times the number of\n   participants,\
    \ and the RTCP bandwidth is 5% of that.\n   Details of the algorithm's operation\
    \ are given in the sections that\n   follow.  Appendix A.7 gives an example implementation.\n"
- title: 6.2.1 Maintaining the Number of Session Members
  contents:
  - "6.2.1 Maintaining the Number of Session Members\n   Calculation of the RTCP packet\
    \ interval depends upon an estimate of\n   the number of sites participating in\
    \ the session.  New sites are\n   added to the count when they are heard, and\
    \ an entry for each SHOULD\n   be created in a table indexed by the SSRC or CSRC\
    \ identifier (see\n   Section 8.2) to keep track of them.  New entries MAY be\
    \ considered\n   not valid until multiple packets carrying the new SSRC have been\n\
    \   received (see Appendix A.1), or until an SDES RTCP packet containing\n   a\
    \ CNAME for that SSRC has been received.  Entries MAY be deleted from\n   the\
    \ table when an RTCP BYE packet with the corresponding SSRC\n   identifier is\
    \ received, except that some straggler data packets might\n   arrive after the\
    \ BYE and cause the entry to be recreated.  Instead,\n   the entry SHOULD be marked\
    \ as having received a BYE and then deleted\n   after an appropriate delay.\n\
    \   A participant MAY mark another site inactive, or delete it if not yet\n  \
    \ valid, if no RTP or RTCP packet has been received for a small number\n   of\
    \ RTCP report intervals (5 is RECOMMENDED).  This provides some\n   robustness\
    \ against packet loss.  All sites must have the same value\n   for this multiplier\
    \ and must calculate roughly the same value for the\n   RTCP report interval in\
    \ order for this timeout to work properly.\n   Therefore, this multiplier SHOULD\
    \ be fixed for a particular profile.\n   For sessions with a very large number\
    \ of participants, it may be\n   impractical to maintain a table to store the\
    \ SSRC identifier and\n   state information for all of them.  An implementation\
    \ MAY use SSRC\n   sampling, as described in [21], to reduce the storage requirements.\n\
    \   An implementation MAY use any other algorithm with similar\n   performance.\
    \  A key requirement is that any algorithm considered\n   SHOULD NOT substantially\
    \ underestimate the group size, although it\n   MAY overestimate.\n"
- title: 6.3 RTCP Packet Send and Receive Rules
  contents:
  - "6.3 RTCP Packet Send and Receive Rules\n   The rules for how to send, and what\
    \ to do when receiving an RTCP\n   packet are outlined here.  An implementation\
    \ that allows operation in\n   a multicast environment or a multipoint unicast\
    \ environment MUST meet\n   the requirements in Section 6.2.  Such an implementation\
    \ MAY use the\n   algorithm defined in this section to meet those requirements,\
    \ or MAY\n   use some other algorithm so long as it provides equivalent or better\n\
    \   performance.  An implementation which is constrained to two-party\n   unicast\
    \ operation SHOULD still use randomization of the RTCP\n   transmission interval\
    \ to avoid unintended synchronization of multiple\n   instances operating in the\
    \ same environment, but MAY omit the \"timer\n   reconsideration\" and \"reverse\
    \ reconsideration\" algorithms in Sections\n   6.3.3, 6.3.6 and 6.3.7.\n   To\
    \ execute these rules, a session participant must maintain several\n   pieces\
    \ of state:\n   tp: the last time an RTCP packet was transmitted;\n   tc: the\
    \ current time;\n   tn: the next scheduled transmission time of an RTCP packet;\n\
    \   pmembers: the estimated number of session members at the time tn\n      was\
    \ last recomputed;\n   members: the most current estimate for the number of session\n\
    \      members;\n   senders: the most current estimate for the number of senders\
    \ in\n      the session;\n   rtcp_bw: The target RTCP bandwidth, i.e., the total\
    \ bandwidth\n      that will be used for RTCP packets by all members of this session,\n\
    \      in octets per second.  This will be a specified fraction of the\n     \
    \ \"session bandwidth\" parameter supplied to the application at\n      startup.\n\
    \   we_sent: Flag that is true if the application has sent data\n      since the\
    \ 2nd previous RTCP report was transmitted.\n   avg_rtcp_size: The average compound\
    \ RTCP packet size, in octets,\n      over all RTCP packets sent and received\
    \ by this participant.  The\n      size includes lower-layer transport and network\
    \ protocol headers\n      (e.g., UDP and IP) as explained in Section 6.2.\n  \
    \ initial: Flag that is true if the application has not yet sent\n      an RTCP\
    \ packet.\n   Many of these rules make use of the \"calculated interval\" between\n\
    \   packet transmissions.  This interval is described in the following\n   section.\n"
- title: 6.3.1 Computing the RTCP Transmission Interval
  contents:
  - "6.3.1 Computing the RTCP Transmission Interval\n   To maintain scalability, the\
    \ average interval between packets from a\n   session participant should scale\
    \ with the group size.  This interval\n   is called the calculated interval. \
    \ It is obtained by combining a\n   number of the pieces of state described above.\
    \  The calculated\n   interval T is then determined as follows:\n   1. If the\
    \ number of senders is less than or equal to 25% of the\n      membership (members),\
    \ the interval depends on whether the\n      participant is a sender or not (based\
    \ on the value of we_sent).\n      If the participant is a sender (we_sent true),\
    \ the constant C is\n      set to the average RTCP packet size (avg_rtcp_size)\
    \ divided by 25%\n      of the RTCP bandwidth (rtcp_bw), and the constant n is\
    \ set to the\n      number of senders.  If we_sent is not true, the constant C\
    \ is set\n      to the average RTCP packet size divided by 75% of the RTCP\n \
    \     bandwidth.  The constant n is set to the number of receivers\n      (members\
    \ - senders).  If the number of senders is greater than\n      25%, senders and\
    \ receivers are treated together.  The constant C\n      is set to the average\
    \ RTCP packet size divided by the total RTCP\n      bandwidth and n is set to\
    \ the total number of members.  As stated\n      in Section 6.2, an RTP profile\
    \ MAY specify that the RTCP bandwidth\n      may be explicitly defined by two\
    \ separate parameters (call them S\n      and R) for those participants which\
    \ are senders and those which\n      are not.  In that case, the 25% fraction\
    \ becomes S/(S+R) and the\n      75% fraction becomes R/(S+R).  Note that if R\
    \ is zero, the\n      percentage of senders is never greater than S/(S+R), and\
    \ the\n      implementation must avoid division by zero.\n   2. If the participant\
    \ has not yet sent an RTCP packet (the variable\n      initial is true), the constant\
    \ Tmin is set to 2.5 seconds, else it\n      is set to 5 seconds.\n   3. The deterministic\
    \ calculated interval Td is set to max(Tmin, n*C).\n   4. The calculated interval\
    \ T is set to a number uniformly distributed\n      between 0.5 and 1.5 times\
    \ the deterministic calculated interval.\n   5. The resulting value of T is divided\
    \ by e-3/2=1.21828 to compensate\n      for the fact that the timer reconsideration\
    \ algorithm converges to\n      a value of the RTCP bandwidth below the intended\
    \ average.\n   This procedure results in an interval which is random, but which,\
    \ on\n   average, gives at least 25% of the RTCP bandwidth to senders and the\n\
    \   rest to receivers.  If the senders constitute more than one quarter\n   of\
    \ the membership, this procedure splits the bandwidth equally among\n   all participants,\
    \ on average.\n"
- title: 6.3.2 Initialization
  contents:
  - "6.3.2 Initialization\n   Upon joining the session, the participant initializes\
    \ tp to 0, tc to\n   0, senders to 0, pmembers to 1, members to 1, we_sent to\
    \ false,\n   rtcp_bw to the specified fraction of the session bandwidth, initial\n\
    \   to true, and avg_rtcp_size to the probable size of the first RTCP\n   packet\
    \ that the application will later construct.  The calculated\n   interval T is\
    \ then computed, and the first packet is scheduled for\n   time tn = T.  This\
    \ means that a transmission timer is set which\n   expires at time T.  Note that\
    \ an application MAY use any desired\n   approach for implementing this timer.\n\
    \   The participant adds its own SSRC to the member table.\n"
- title: 6.3.3 Receiving an RTP or Non-BYE RTCP Packet
  contents:
  - "6.3.3 Receiving an RTP or Non-BYE RTCP Packet\n   When an RTP or RTCP packet\
    \ is received from a participant whose SSRC\n   is not in the member table, the\
    \ SSRC is added to the table, and the\n   value for members is updated once the\
    \ participant has been validated\n   as described in Section 6.2.1.  The same\
    \ processing occurs for each\n   CSRC in a validated RTP packet.\n   When an RTP\
    \ packet is received from a participant whose SSRC is not\n   in the sender table,\
    \ the SSRC is added to the table, and the value\n   for senders is updated.\n\
    \   For each compound RTCP packet received, the value of avg_rtcp_size is\n  \
    \ updated:\n      avg_rtcp_size = (1/16) * packet_size + (15/16) * avg_rtcp_size\n\
    \   where packet_size is the size of the RTCP packet just received.\n"
- title: 6.3.4 Receiving an RTCP BYE Packet
  contents:
  - "6.3.4 Receiving an RTCP BYE Packet\n   Except as described in Section 6.3.7 for\
    \ the case when an RTCP BYE is\n   to be transmitted, if the received packet is\
    \ an RTCP BYE packet, the\n   SSRC is checked against the member table.  If present,\
    \ the entry is\n   removed from the table, and the value for members is updated.\
    \  The\n   SSRC is then checked against the sender table.  If present, the entry\n\
    \   is removed from the table, and the value for senders is updated.\n   Furthermore,\
    \ to make the transmission rate of RTCP packets more\n   adaptive to changes in\
    \ group membership, the following \"reverse\n   reconsideration\" algorithm SHOULD\
    \ be executed when a BYE packet is\n   received that reduces members to a value\
    \ less than pmembers:\n   o  The value for tn is updated according to the following\
    \ formula:\n         tn = tc + (members/pmembers) * (tn - tc)\n   o  The value\
    \ for tp is updated according the following formula:\n         tp = tc - (members/pmembers)\
    \ * (tc - tp).\n   o  The next RTCP packet is rescheduled for transmission at\
    \ time tn,\n      which is now earlier.\n   o  The value of pmembers is set equal\
    \ to members.\n   This algorithm does not prevent the group size estimate from\n\
    \   incorrectly dropping to zero for a short time due to premature\n   timeouts\
    \ when most participants of a large session leave at once but\n   some remain.\
    \  The algorithm does make the estimate return to the\n   correct value more rapidly.\
    \  This situation is unusual enough and the\n   consequences are sufficiently\
    \ harmless that this problem is deemed\n   only a secondary concern.\n"
- title: 6.3.5 Timing Out an SSRC
  contents:
  - "6.3.5 Timing Out an SSRC\n   At occasional intervals, the participant MUST check\
    \ to see if any of\n   the other participants time out.  To do this, the participant\n\
    \   computes the deterministic (without the randomization factor)\n   calculated\
    \ interval Td for a receiver, that is, with we_sent false.\n   Any other session\
    \ member who has not sent an RTP or RTCP packet since\n   time tc - MTd (M is\
    \ the timeout multiplier, and defaults to 5) is\n   timed out.  This means that\
    \ its SSRC is removed from the member list,\n   and members is updated.  A similar\
    \ check is performed on the sender\n   list.  Any member on the sender list who\
    \ has not sent an RTP packet\n   since time tc - 2T (within the last two RTCP\
    \ report intervals) is\n   removed from the sender list, and senders is updated.\n\
    \   If any members time out, the reverse reconsideration algorithm\n   described\
    \ in Section 6.3.4 SHOULD be performed.\n   The participant MUST perform this\
    \ check at least once per RTCP\n   transmission interval.\n"
- title: 6.3.6 Expiration of Transmission Timer
  contents:
  - "6.3.6 Expiration of Transmission Timer\n   When the packet transmission timer\
    \ expires, the participant performs\n   the following operations:\n   o  The transmission\
    \ interval T is computed as described in Section\n      6.3.1, including the randomization\
    \ factor.\n   o  If tp + T is less than or equal to tc, an RTCP packet is\n  \
    \    transmitted.  tp is set to tc, then another value for T is\n      calculated\
    \ as in the previous step and tn is set to tc + T.  The\n      transmission timer\
    \ is set to expire again at time tn.  If tp + T\n      is greater than tc, tn\
    \ is set to tp + T.  No RTCP packet is\n      transmitted.  The transmission timer\
    \ is set to expire at time tn.\n   o  pmembers is set to members.\n   If an RTCP\
    \ packet is transmitted, the value of initial is set to\n   FALSE.  Furthermore,\
    \ the value of avg_rtcp_size is updated:\n      avg_rtcp_size = (1/16) * packet_size\
    \ + (15/16) * avg_rtcp_size\n   where packet_size is the size of the RTCP packet\
    \ just transmitted.\n"
- title: 6.3.7 Transmitting a BYE Packet
  contents:
  - "6.3.7 Transmitting a BYE Packet\n   When a participant wishes to leave a session,\
    \ a BYE packet is\n   transmitted to inform the other participants of the event.\
    \  In order\n   to avoid a flood of BYE packets when many participants leave the\n\
    \   system, a participant MUST execute the following algorithm if the\n   number\
    \ of members is more than 50 when the participant chooses to\n   leave.  This\
    \ algorithm usurps the normal role of the members variable\n   to count BYE packets\
    \ instead:\n   o  When the participant decides to leave the system, tp is reset\
    \ to\n      tc, the current time, members and pmembers are initialized to 1,\n\
    \      initial is set to 1, we_sent is set to false, senders is set to 0,\n  \
    \    and avg_rtcp_size is set to the size of the compound BYE packet.\n      The\
    \ calculated interval T is computed.  The BYE packet is then\n      scheduled\
    \ for time tn = tc + T.\n   o  Every time a BYE packet from another participant\
    \ is received,\n      members is incremented by 1 regardless of whether that participant\n\
    \      exists in the member table or not, and when SSRC sampling is in\n     \
    \ use, regardless of whether or not the BYE SSRC would be included\n      in the\
    \ sample.  members is NOT incremented when other RTCP packets\n      or RTP packets\
    \ are received, but only for BYE packets.  Similarly,\n      avg_rtcp_size is\
    \ updated only for received BYE packets.  senders\n      is NOT updated when RTP\
    \ packets arrive; it remains 0.\n   o  Transmission of the BYE packet then follows\
    \ the rules for\n      transmitting a regular RTCP packet, as above.\n   This\
    \ allows BYE packets to be sent right away, yet controls their\n   total bandwidth\
    \ usage.  In the worst case, this could cause RTCP\n   control packets to use\
    \ twice the bandwidth as normal (10%) -- 5% for\n   non-BYE RTCP packets and 5%\
    \ for BYE.\n   A participant that does not want to wait for the above mechanism\
    \ to\n   allow transmission of a BYE packet MAY leave the group without\n   sending\
    \ a BYE at all.  That participant will eventually be timed out\n   by the other\
    \ group members.\n   If the group size estimate members is less than 50 when the\n\
    \   participant decides to leave, the participant MAY send a BYE packet\n   immediately.\
    \  Alternatively, the participant MAY choose to execute\n   the above BYE backoff\
    \ algorithm.\n   In either case, a participant which never sent an RTP or RTCP\
    \ packet\n   MUST NOT send a BYE packet when they leave the group.\n"
- title: 6.3.8 Updating we_sent
  contents:
  - "6.3.8 Updating we_sent\n   The variable we_sent contains true if the participant\
    \ has sent an RTP\n   packet recently, false otherwise.  This determination is\
    \ made by\n   using the same mechanisms as for managing the set of other\n   participants\
    \ listed in the senders table.  If the participant sends\n   an RTP packet when\
    \ we_sent is false, it adds itself to the sender\n   table and sets we_sent to\
    \ true.  The reverse reconsideration\n   algorithm described in Section 6.3.4\
    \ SHOULD be performed to possibly\n   reduce the delay before sending an SR packet.\
    \  Every time another RTP\n   packet is sent, the time of transmission of that\
    \ packet is maintained\n   in the table.  The normal sender timeout algorithm\
    \ is then applied to\n   the participant -- if an RTP packet has not been transmitted\
    \ since\n   time tc - 2T, the participant removes itself from the sender table,\n\
    \   decrements the sender count, and sets we_sent to false.\n"
- title: 6.3.9 Allocation of Source Description Bandwidth
  contents:
  - "6.3.9 Allocation of Source Description Bandwidth\n   This specification defines\
    \ several source description (SDES) items in\n   addition to the mandatory CNAME\
    \ item, such as NAME (personal name)\n   and EMAIL (email address).  It also provides\
    \ a means to define new\n   application-specific RTCP packet types.  Applications\
    \ should exercise\n   caution in allocating control bandwidth to this additional\n\
    \   information because it will slow down the rate at which reception\n   reports\
    \ and CNAME are sent, thus impairing the performance of the\n   protocol.  It\
    \ is RECOMMENDED that no more than 20% of the RTCP\n   bandwidth allocated to\
    \ a single participant be used to carry the\n   additional information.  Furthermore,\
    \ it is not intended that all\n   SDES items will be included in every application.\
    \  Those that are\n   included SHOULD be assigned a fraction of the bandwidth\
    \ according to\n   their utility.  Rather than estimate these fractions dynamically,\
    \ it\n   is recommended that the percentages be translated statically into\n \
    \  report interval counts based on the typical length of an item.\n   For example,\
    \ an application may be designed to send only CNAME, NAME\n   and EMAIL and not\
    \ any others.  NAME might be given much higher\n   priority than EMAIL because\
    \ the NAME would be displayed continuously\n   in the application's user interface,\
    \ whereas EMAIL would be displayed\n   only when requested.  At every RTCP interval,\
    \ an RR packet and an\n   SDES packet with the CNAME item would be sent.  For\
    \ a small session\n   operating at the minimum interval, that would be every 5\
    \ seconds on\n   the average.  Every third interval (15 seconds), one extra item\
    \ would\n   be included in the SDES packet.  Seven out of eight times this would\n\
    \   be the NAME item, and every eighth time (2 minutes) it would be the\n   EMAIL\
    \ item.\n   When multiple applications operate in concert using cross-application\n\
    \   binding through a common CNAME for each participant, for example in a\n  \
    \ multimedia conference composed of an RTP session for each medium, the\n   additional\
    \ SDES information MAY be sent in only one RTP session.  The\n   other sessions\
    \ would carry only the CNAME item.  In particular, this\n   approach should be\
    \ applied to the multiple sessions of a layered\n   encoding scheme (see Section\
    \ 2.4).\n"
- title: 6.4 Sender and Receiver Reports
  contents:
  - "6.4 Sender and Receiver Reports\n   RTP receivers provide reception quality feedback\
    \ using RTCP report\n   packets which may take one of two forms depending upon\
    \ whether or not\n   the receiver is also a sender.  The only difference between\
    \ the\n   sender report (SR) and receiver report (RR) forms, besides the packet\n\
    \   type code, is that the sender report includes a 20-byte sender\n   information\
    \ section for use by active senders.  The SR is issued if a\n   site has sent\
    \ any data packets during the interval since issuing the\n   last report or the\
    \ previous one, otherwise the RR is issued.\n   Both the SR and RR forms include\
    \ zero or more reception report\n   blocks, one for each of the synchronization\
    \ sources from which this\n   receiver has received RTP data packets since the\
    \ last report.\n   Reports are not issued for contributing sources listed in the\
    \ CSRC\n   list.  Each reception report block provides statistics about the data\n\
    \   received from the particular source indicated in that block.  Since a\n  \
    \ maximum of 31 reception report blocks will fit in an SR or RR packet,\n   additional\
    \ RR packets SHOULD be stacked after the initial SR or RR\n   packet as needed\
    \ to contain the reception reports for all sources\n   heard during the interval\
    \ since the last report.  If there are too\n   many sources to fit all the necessary\
    \ RR packets into one compound\n   RTCP packet without exceeding the MTU of the\
    \ network path, then only\n   the subset that will fit into one MTU SHOULD be\
    \ included in each\n   interval.  The subsets SHOULD be selected round-robin across\
    \ multiple\n   intervals so that all sources are reported.\n   The next sections\
    \ define the formats of the two reports, how they may\n   be extended in a profile-specific\
    \ manner if an application requires\n   additional feedback information, and how\
    \ the reports may be used.\n   Details of reception reporting by translators and\
    \ mixers is given in\n   Section 7.\n"
- title: '6.4.1 SR: Sender Report RTCP Packet'
  contents:
  - "6.4.1 SR: Sender Report RTCP Packet\n        0                   1          \
    \         2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: header |V=2|P|    RC   |   PT=SR=200   |             length            |
  contents:
  - "header |V=2|P|    RC   |   PT=SR=200   |             length            |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                         SSRC of sender                        |\n      \
    \ +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n"
- title: sender |              NTP timestamp, most significant word             |
  contents:
  - 'sender |              NTP timestamp, most significant word             |

    '
- title: info   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - "info   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \     |             NTP timestamp, least significant word             |\n    \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \ |                         RTP timestamp                         |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |                     sender's packet count                     |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                      sender's octet count                     |\n      \
    \ +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n"
- title: report |                 SSRC_1 (SSRC of first source)                 |
  contents:
  - 'report |                 SSRC_1 (SSRC of first source)                 |

    '
- title: block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - "block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  1\
    \    | fraction lost |       cumulative number of packets lost       |\n     \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \           extended highest sequence number received           |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |                      interarrival jitter                      |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                         last SR (LSR)                         |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                   delay since last SR (DLSR)                  |\n       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n"
- title: report |                 SSRC_2 (SSRC of second source)                |
  contents:
  - 'report |                 SSRC_2 (SSRC of second source)                |

    '
- title: block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - "block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  2\
    \    :                               ...                             :\n     \
    \  +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n       |\
    \                  profile-specific extensions                  |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The sender report packet consists of three sections, possibly\n   followed\
    \ by a fourth profile-specific extension section if defined.\n   The first section,\
    \ the header, is 8 octets long.  The fields have the\n   following meaning:\n\
    \   version (V): 2 bits\n      Identifies the version of RTP, which is the same\
    \ in RTCP packets\n      as in RTP data packets.  The version defined by this\
    \ specification\n      is two (2).\n   padding (P): 1 bit\n      If the padding\
    \ bit is set, this individual RTCP packet contains\n      some additional padding\
    \ octets at the end which are not part of\n      the control information but are\
    \ included in the length field.  The\n      last octet of the padding is a count\
    \ of how many padding octets\n      should be ignored, including itself (it will\
    \ be a multiple of\n      four).  Padding may be needed by some encryption algorithms\
    \ with\n      fixed block sizes.  In a compound RTCP packet, padding is only\n\
    \      required on one individual packet because the compound packet is\n    \
    \  encrypted as a whole for the method in Section 9.1.  Thus, padding\n      MUST\
    \ only be added to the last individual packet, and if padding\n      is added\
    \ to that packet, the padding bit MUST be set only on that\n      packet.  This\
    \ convention aids the header validity checks described\n      in Appendix A.2\
    \ and allows detection of packets from some early\n      implementations that\
    \ incorrectly set the padding bit on the first\n      individual packet and add\
    \ padding to the last individual packet.\n   reception report count (RC): 5 bits\n\
    \      The number of reception report blocks contained in this packet.  A\n  \
    \    value of zero is valid.\n   packet type (PT): 8 bits\n      Contains the\
    \ constant 200 to identify this as an RTCP SR packet.\n   length: 16 bits\n  \
    \    The length of this RTCP packet in 32-bit words minus one,\n      including\
    \ the header and any padding.  (The offset of one makes\n      zero a valid length\
    \ and avoids a possible infinite loop in\n      scanning a compound RTCP packet,\
    \ while counting 32-bit words\n      avoids a validity check for a multiple of\
    \ 4.)\n   SSRC: 32 bits\n      The synchronization source identifier for the originator\
    \ of this\n      SR packet.\n   The second section, the sender information, is\
    \ 20 octets long and is\n   present in every sender report packet.  It summarizes\
    \ the data\n   transmissions from this sender.  The fields have the following\n\
    \   meaning:\n   NTP timestamp: 64 bits\n      Indicates the wallclock time (see\
    \ Section 4) when this report was\n      sent so that it may be used in combination\
    \ with timestamps\n      returned in reception reports from other receivers to\
    \ measure\n      round-trip propagation to those receivers.  Receivers should\n\
    \      expect that the measurement accuracy of the timestamp may be\n      limited\
    \ to far less than the resolution of the NTP timestamp.  The\n      measurement\
    \ uncertainty of the timestamp is not indicated as it\n      may not be known.\
    \  On a system that has no notion of wallclock\n      time but does have some\
    \ system-specific clock such as \"system\n      uptime\", a sender MAY use that\
    \ clock as a reference to calculate\n      relative NTP timestamps.  It is important\
    \ to choose a commonly\n      used clock so that if separate implementations are\
    \ used to produce\n      the individual streams of a multimedia session, all\n\
    \      implementations will use the same clock.  Until the year 2036,\n      relative\
    \ and absolute timestamps will differ in the high bit so\n      (invalid) comparisons\
    \ will show a large difference; by then one\n      hopes relative timestamps will\
    \ no longer be needed.  A sender that\n      has no notion of wallclock or elapsed\
    \ time MAY set the NTP\n      timestamp to zero.\n   RTP timestamp: 32 bits\n\
    \      Corresponds to the same time as the NTP timestamp (above), but in\n   \
    \   the same units and with the same random offset as the RTP\n      timestamps\
    \ in data packets.  This correspondence may be used for\n      intra- and inter-media\
    \ synchronization for sources whose NTP\n      timestamps are synchronized, and\
    \ may be used by media-independent\n      receivers to estimate the nominal RTP\
    \ clock frequency.  Note that\n      in most cases this timestamp will not be\
    \ equal to the RTP\n      timestamp in any adjacent data packet.  Rather, it MUST\
    \ be\n      calculated from the corresponding NTP timestamp using the\n      relationship\
    \ between the RTP timestamp counter and real time as\n      maintained by periodically\
    \ checking the wallclock time at a\n      sampling instant.\n   sender's packet\
    \ count: 32 bits\n      The total number of RTP data packets transmitted by the\
    \ sender\n      since starting transmission up until the time this SR packet was\n\
    \      generated.  The count SHOULD be reset if the sender changes its\n     \
    \ SSRC identifier.\n   sender's octet count: 32 bits\n      The total number of\
    \ payload octets (i.e., not including header or\n      padding) transmitted in\
    \ RTP data packets by the sender since\n      starting transmission up until the\
    \ time this SR packet was\n      generated.  The count SHOULD be reset if the\
    \ sender changes its\n      SSRC identifier.  This field can be used to estimate\
    \ the average\n      payload data rate.\n   The third section contains zero or\
    \ more reception report blocks\n   depending on the number of other sources heard\
    \ by this sender since\n   the last report.  Each reception report block conveys\
    \ statistics on\n   the reception of RTP packets from a single synchronization\
    \ source.\n   Receivers SHOULD NOT carry over statistics when a source changes\
    \ its\n   SSRC identifier due to a collision.  These statistics are:\n   SSRC_n\
    \ (source identifier): 32 bits\n      The SSRC identifier of the source to which\
    \ the information in this\n      reception report block pertains.\n   fraction\
    \ lost: 8 bits\n      The fraction of RTP data packets from source SSRC_n lost\
    \ since the\n      previous SR or RR packet was sent, expressed as a fixed point\n\
    \      number with the binary point at the left edge of the field.  (That\n  \
    \    is equivalent to taking the integer part after multiplying the\n      loss\
    \ fraction by 256.)  This fraction is defined to be the number\n      of packets\
    \ lost divided by the number of packets expected, as\n      defined in the next\
    \ paragraph.  An implementation is shown in\n      Appendix A.3.  If the loss\
    \ is negative due to duplicates, the\n      fraction lost is set to zero.  Note\
    \ that a receiver cannot tell\n      whether any packets were lost after the last\
    \ one received, and\n      that there will be no reception report block issued\
    \ for a source\n      if all packets from that source sent during the last reporting\n\
    \      interval have been lost.\n   cumulative number of packets lost: 24 bits\n\
    \      The total number of RTP data packets from source SSRC_n that have\n   \
    \   been lost since the beginning of reception.  This number is\n      defined\
    \ to be the number of packets expected less the number of\n      packets actually\
    \ received, where the number of packets received\n      includes any which are\
    \ late or duplicates.  Thus, packets that\n      arrive late are not counted as\
    \ lost, and the loss may be negative\n      if there are duplicates.  The number\
    \ of packets expected is\n      defined to be the extended last sequence number\
    \ received, as\n      defined next, less the initial sequence number received.\
    \  This may\n      be calculated as shown in Appendix A.3.\n   extended highest\
    \ sequence number received: 32 bits\n      The low 16 bits contain the highest\
    \ sequence number received in an\n      RTP data packet from source SSRC_n, and\
    \ the most significant 16\n      bits extend that sequence number with the corresponding\
    \ count of\n      sequence number cycles, which may be maintained according to\
    \ the\n      algorithm in Appendix A.1.  Note that different receivers within\n\
    \      the same session will generate different extensions to the\n      sequence\
    \ number if their start times differ significantly.\n   interarrival jitter: 32\
    \ bits\n      An estimate of the statistical variance of the RTP data packet\n\
    \      interarrival time, measured in timestamp units and expressed as an\n  \
    \    unsigned integer.  The interarrival jitter J is defined to be the\n     \
    \ mean deviation (smoothed absolute value) of the difference D in\n      packet\
    \ spacing at the receiver compared to the sender for a pair\n      of packets.\
    \  As shown in the equation below, this is equivalent to\n      the difference\
    \ in the \"relative transit time\" for the two packets;\n      the relative transit\
    \ time is the difference between a packet's RTP\n      timestamp and the receiver's\
    \ clock at the time of arrival,\n      measured in the same units.\n      If Si\
    \ is the RTP timestamp from packet i, and Ri is the time of\n      arrival in\
    \ RTP timestamp units for packet i, then for two packets\n      i and j, D may\
    \ be expressed as\n         D(i,j) = (Rj - Ri) - (Sj - Si) = (Rj - Sj) - (Ri -\
    \ Si)\n      The interarrival jitter SHOULD be calculated continuously as each\n\
    \      data packet i is received from source SSRC_n, using this\n      difference\
    \ D for that packet and the previous packet i-1 in order\n      of arrival (not\
    \ necessarily in sequence), according to the formula\n         J(i) = J(i-1) +\
    \ (|D(i-1,i)| - J(i-1))/16\n      Whenever a reception report is issued, the current\
    \ value of J is\n      sampled.\n      The jitter calculation MUST conform to\
    \ the formula specified here\n      in order to allow profile-independent monitors\
    \ to make valid\n      interpretations of reports coming from different implementations.\n\
    \      This algorithm is the optimal first-order estimator and the gain\n    \
    \  parameter 1/16 gives a good noise reduction ratio while\n      maintaining\
    \ a reasonable rate of convergence [22].  A sample\n      implementation is shown\
    \ in Appendix A.8.  See Section 6.4.4 for a\n      discussion of the effects of\
    \ varying packet duration and delay\n      before transmission.\n   last SR timestamp\
    \ (LSR): 32 bits\n      The middle 32 bits out of 64 in the NTP timestamp (as\
    \ explained in\n      Section 4) received as part of the most recent RTCP sender\
    \ report\n      (SR) packet from source SSRC_n.  If no SR has been received yet,\n\
    \      the field is set to zero.\n   delay since last SR (DLSR): 32 bits\n   \
    \   The delay, expressed in units of 1/65536 seconds, between\n      receiving\
    \ the last SR packet from source SSRC_n and sending this\n      reception report\
    \ block.  If no SR packet has been received yet\n      from SSRC_n, the DLSR field\
    \ is set to zero.\n      Let SSRC_r denote the receiver issuing this receiver\
    \ report.\n      Source SSRC_n can compute the round-trip propagation delay to\n\
    \      SSRC_r by recording the time A when this reception report block is\n  \
    \    received.  It calculates the total round-trip time A-LSR using the\n    \
    \  last SR timestamp (LSR) field, and then subtracting this field to\n      leave\
    \ the round-trip propagation delay as (A - LSR - DLSR).  This\n      is illustrated\
    \ in Fig. 2.  Times are shown in both a hexadecimal\n      representation of the\
    \ 32-bit fields and the equivalent floating-\n      point decimal representation.\
    \  Colons indicate a 32-bit field\n      divided into a 16-bit integer part and\
    \ 16-bit fraction part.\n      This may be used as an approximate measure of distance\
    \ to cluster\n      receivers, although some links have very asymmetric delays.\n\
    \   [10 Nov 1995 11:33:25.125 UTC]       [10 Nov 1995 11:33:36.5 UTC]\n   n  \
    \               SR(n)              A=b710:8000 (46864.500 s)\n   ---------------------------------------------------------------->\n\
    \                      v                 ^\n   ntp_sec =0xb44db705 v         \
    \      ^ dlsr=0x0005:4000 (    5.250s)\n   ntp_frac=0x20000000  v            \
    \ ^  lsr =0xb705:2000 (46853.125s)\n     (3024992005.125 s)  v           ^\n \
    \  r                      v         ^ RR(n)\n   ---------------------------------------------------------------->\n\
    \                          |<-DLSR->|\n                           (5.250 s)\n\
    \   A     0xb710:8000 (46864.500 s)\n   DLSR -0x0005:4000 (    5.250 s)\n   LSR\
    \  -0xb705:2000 (46853.125 s)\n   -------------------------------\n   delay 0x0006:2000\
    \ (    6.125 s)\n           Figure 2: Example for round-trip time computation\n"
- title: '6.4.2 RR: Receiver Report RTCP Packet'
  contents:
  - "6.4.2 RR: Receiver Report RTCP Packet\n        0                   1        \
    \           2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: header |V=2|P|    RC   |   PT=RR=201   |             length            |
  contents:
  - "header |V=2|P|    RC   |   PT=RR=201   |             length            |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                     SSRC of packet sender                     |\n      \
    \ +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n"
- title: report |                 SSRC_1 (SSRC of first source)                 |
  contents:
  - 'report |                 SSRC_1 (SSRC of first source)                 |

    '
- title: block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - "block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  1\
    \    | fraction lost |       cumulative number of packets lost       |\n     \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \           extended highest sequence number received           |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |                      interarrival jitter                      |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                         last SR (LSR)                         |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                   delay since last SR (DLSR)                  |\n       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n"
- title: report |                 SSRC_2 (SSRC of second source)                |
  contents:
  - 'report |                 SSRC_2 (SSRC of second source)                |

    '
- title: block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - "block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  2\
    \    :                               ...                             :\n     \
    \  +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n       |\
    \                  profile-specific extensions                  |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The format of the receiver report (RR) packet is the same as that of\n   the\
    \ SR packet except that the packet type field contains the constant\n   201 and\
    \ the five words of sender information are omitted (these are\n   the NTP and\
    \ RTP timestamps and sender's packet and octet counts).\n   The remaining fields\
    \ have the same meaning as for the SR packet.\n   An empty RR packet (RC = 0)\
    \ MUST be put at the head of a compound\n   RTCP packet when there is no data\
    \ transmission or reception to\n   report.\n"
- title: 6.4.3 Extending the Sender and Receiver Reports
  contents:
  - "6.4.3 Extending the Sender and Receiver Reports\n   A profile SHOULD define profile-specific\
    \ extensions to the sender\n   report and receiver report if there is additional\
    \ information that\n   needs to be reported regularly about the sender or receivers.\
    \  This\n   method SHOULD be used in preference to defining another RTCP packet\n\
    \   type because it requires less overhead:\n   o  fewer octets in the packet\
    \ (no RTCP header or SSRC field);\n   o  simpler and faster parsing because applications\
    \ running under that\n      profile would be programmed to always expect the extension\
    \ fields\n      in the directly accessible location after the reception reports.\n\
    \   The extension is a fourth section in the sender- or receiver-report\n   packet\
    \ which comes at the end after the reception report blocks, if\n   any.  If additional\
    \ sender information is required, then for sender\n   reports it would be included\
    \ first in the extension section, but for\n   receiver reports it would not be\
    \ present.  If information about\n   receivers is to be included, that data SHOULD\
    \ be structured as an\n   array of blocks parallel to the existing array of reception\
    \ report\n   blocks; that is, the number of blocks would be indicated by the RC\n\
    \   field.\n"
- title: 6.4.4 Analyzing Sender and Receiver Reports
  contents:
  - "6.4.4 Analyzing Sender and Receiver Reports\n   It is expected that reception\
    \ quality feedback will be useful not\n   only for the sender but also for other\
    \ receivers and third-party\n   monitors.  The sender may modify its transmissions\
    \ based on the\n   feedback; receivers can determine whether problems are local,\n\
    \   regional or global; network managers may use profile-independent\n   monitors\
    \ that receive only the RTCP packets and not the corresponding\n   RTP data packets\
    \ to evaluate the performance of their networks for\n   multicast distribution.\n\
    \   Cumulative counts are used in both the sender information and\n   receiver\
    \ report blocks so that differences may be calculated between\n   any two reports\
    \ to make measurements over both short and long time\n   periods, and to provide\
    \ resilience against the loss of a report.  The\n   difference between the last\
    \ two reports received can be used to\n   estimate the recent quality of the distribution.\
    \  The NTP timestamp\n   is included so that rates may be calculated from these\
    \ differences\n   over the interval between two reports.  Since that timestamp\
    \ is\n   independent of the clock rate for the data encoding, it is possible\n\
    \   to implement encoding- and profile-independent quality monitors.\n   An example\
    \ calculation is the packet loss rate over the interval\n   between two reception\
    \ reports.  The difference in the cumulative\n   number of packets lost gives\
    \ the number lost during that interval.\n   The difference in the extended last\
    \ sequence numbers received gives\n   the number of packets expected during the\
    \ interval.  The ratio of\n   these two is the packet loss fraction over the interval.\
    \  This ratio\n   should equal the fraction lost field if the two reports are\n\
    \   consecutive, but otherwise it may not.  The loss rate per second can\n   be\
    \ obtained by dividing the loss fraction by the difference in NTP\n   timestamps,\
    \ expressed in seconds.  The number of packets received is\n   the number of packets\
    \ expected minus the number lost.  The number of\n   packets expected may also\
    \ be used to judge the statistical validity\n   of any loss estimates.  For example,\
    \ 1 out of 5 packets lost has a\n   lower significance than 200 out of 1000.\n\
    \   From the sender information, a third-party monitor can calculate the\n   average\
    \ payload data rate and the average packet rate over an\n   interval without receiving\
    \ the data.  Taking the ratio of the two\n   gives the average payload size. \
    \ If it can be assumed that packet\n   loss is independent of packet size, then\
    \ the number of packets\n   received by a particular receiver times the average\
    \ payload size (or\n   the corresponding packet size) gives the apparent throughput\n\
    \   available to that receiver.\n   In addition to the cumulative counts which\
    \ allow long-term packet\n   loss measurements using differences between reports,\
    \ the fraction\n   lost field provides a short-term measurement from a single\
    \ report.\n   This becomes more important as the size of a session scales up enough\n\
    \   that reception state information might not be kept for all receivers\n   or\
    \ the interval between reports becomes long enough that only one\n   report might\
    \ have been received from a particular receiver.\n   The interarrival jitter field\
    \ provides a second short-term measure of\n   network congestion.  Packet loss\
    \ tracks persistent congestion while\n   the jitter measure tracks transient congestion.\
    \  The jitter measure\n   may indicate congestion before it leads to packet loss.\
    \  The\n   interarrival jitter field is only a snapshot of the jitter at the\n\
    \   time of a report and is not intended to be taken quantitatively.\n   Rather,\
    \ it is intended for comparison across a number of reports from\n   one receiver\
    \ over time or from multiple receivers, e.g., within a\n   single network, at\
    \ the same time.  To allow comparison across\n   receivers, it is important the\
    \ the jitter be calculated according to\n   the same formula by all receivers.\n\
    \   Because the jitter calculation is based on the RTP timestamp which\n   represents\
    \ the instant when the first data in the packet was sampled,\n   any variation\
    \ in the delay between that sampling instant and the time\n   the packet is transmitted\
    \ will affect the resulting jitter that is\n   calculated.  Such a variation in\
    \ delay would occur for audio packets\n   of varying duration.  It will also occur\
    \ for video encodings because\n   the timestamp is the same for all the packets\
    \ of one frame but those\n   packets are not all transmitted at the same time.\
    \  The variation in\n   delay until transmission does reduce the accuracy of the\
    \ jitter\n   calculation as a measure of the behavior of the network by itself,\n\
    \   but it is appropriate to include considering that the receiver buffer\n  \
    \ must accommodate it.  When the jitter calculation is used as a\n   comparative\
    \ measure, the (constant) component due to variation in\n   delay until transmission\
    \ subtracts out so that a change in the\n   network jitter component can then\
    \ be observed unless it is relatively\n   small.  If the change is small, then\
    \ it is likely to be\n   inconsequential.\n"
- title: '6.5 SDES: Source Description RTCP Packet'
  contents:
  - "6.5 SDES: Source Description RTCP Packet\n        0                   1     \
    \              2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: header |V=2|P|    SC   |  PT=SDES=202  |             length            |
  contents:
  - "header |V=2|P|    SC   |  PT=SDES=202  |             length            |\n  \
    \     +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n"
- title: chunk  |                          SSRC/CSRC_1                          |
  contents:
  - "chunk  |                          SSRC/CSRC_1                          |\n  1\
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     \
    \  |                           SDES items                          |\n       |\
    \                              ...                              |\n       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n"
- title: chunk  |                          SSRC/CSRC_2                          |
  contents:
  - "chunk  |                          SSRC/CSRC_2                          |\n  2\
    \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     \
    \  |                           SDES items                          |\n       |\
    \                              ...                              |\n       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n\
    \   The SDES packet is a three-level structure composed of a header and\n   zero\
    \ or more chunks, each of which is composed of items describing\n   the source\
    \ identified in that chunk.  The items are described\n   individually in subsequent\
    \ sections.\n   version (V), padding (P), length:\n      As described for the\
    \ SR packet (see Section 6.4.1).\n   packet type (PT): 8 bits\n      Contains\
    \ the constant 202 to identify this as an RTCP SDES packet.\n   source count (SC):\
    \ 5 bits\n      The number of SSRC/CSRC chunks contained in this SDES packet.\
    \  A\n      value of zero is valid but useless.\n   Each chunk consists of an\
    \ SSRC/CSRC identifier followed by a list of\n   zero or more items, which carry\
    \ information about the SSRC/CSRC.\n   Each chunk starts on a 32-bit boundary.\
    \  Each item consists of an 8-\n   bit type field, an 8-bit octet count describing\
    \ the length of the\n   text (thus, not including this two-octet header), and\
    \ the text\n   itself.  Note that the text can be no longer than 255 octets, but\n\
    \   this is consistent with the need to limit RTCP bandwidth consumption.\n  \
    \ The text is encoded according to the UTF-8 encoding specified in RFC\n   2279\
    \ [5].  US-ASCII is a subset of this encoding and requires no\n   additional encoding.\
    \  The presence of multi-octet encodings is\n   indicated by setting the most\
    \ significant bit of a character to a\n   value of one.\n   Items are contiguous,\
    \ i.e., items are not individually padded to a\n   32-bit boundary.  Text is not\
    \ null terminated because some multi-\n   octet encodings include null octets.\
    \  The list of items in each chunk\n   MUST be terminated by one or more null\
    \ octets, the first of which is\n   interpreted as an item type of zero to denote\
    \ the end of the list.\n   No length octet follows the null item type octet, but\
    \ additional null\n   octets MUST be included if needed to pad until the next\
    \ 32-bit\n   boundary.  Note that this padding is separate from that indicated\
    \ by\n   the P bit in the RTCP header.  A chunk with zero items (four null\n \
    \  octets) is valid but useless.\n   End systems send one SDES packet containing\
    \ their own source\n   identifier (the same as the SSRC in the fixed RTP header).\
    \  A mixer\n   sends one SDES packet containing a chunk for each contributing\
    \ source\n   from which it is receiving SDES information, or multiple complete\n\
    \   SDES packets in the format above if there are more than 31 such\n   sources\
    \ (see Section 7).\n   The SDES items currently defined are described in the next\
    \ sections.\n   Only the CNAME item is mandatory.  Some items shown here may be\n\
    \   useful only for particular profiles, but the item types are all\n   assigned\
    \ from one common space to promote shared use and to simplify\n   profile-independent\
    \ applications.  Additional items may be defined in\n   a profile by registering\
    \ the type numbers with IANA as described in\n   Section 15.\n"
- title: '6.5.1 CNAME: Canonical End-Point Identifier SDES Item'
  contents:
  - "6.5.1 CNAME: Canonical End-Point Identifier SDES Item\n    0                \
    \   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    CNAME=1    |     length    | user and domain name        ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The CNAME identifier has the following properties:\n   o  Because the randomly\
    \ allocated SSRC identifier may change if a\n      conflict is discovered or if\
    \ a program is restarted, the CNAME\n      item MUST be included to provide the\
    \ binding from the SSRC\n      identifier to an identifier for the source (sender\
    \ or receiver)\n      that remains constant.\n   o  Like the SSRC identifier,\
    \ the CNAME identifier SHOULD also be\n      unique among all participants within\
    \ one RTP session.\n   o  To provide a binding across multiple media tools used\
    \ by one\n      participant in a set of related RTP sessions, the CNAME SHOULD\
    \ be\n      fixed for that participant.\n   o  To facilitate third-party monitoring,\
    \ the CNAME SHOULD be suitable\n      for either a program or a person to locate\
    \ the source.\n   Therefore, the CNAME SHOULD be derived algorithmically and not\n\
    \   entered manually, when possible.  To meet these requirements, the\n   following\
    \ format SHOULD be used unless a profile specifies an\n   alternate syntax or\
    \ semantics.  The CNAME item SHOULD have the format\n   \"user@host\", or \"host\"\
    \ if a user name is not available as on single-\n   user systems.  For both formats,\
    \ \"host\" is either the fully qualified\n   domain name of the host from which\
    \ the real-time data originates,\n   formatted according to the rules specified\
    \ in RFC 1034 [6], RFC 1035\n   [7] and Section 2.1 of RFC 1123 [8]; or the standard\
    \ ASCII\n   representation of the host's numeric address on the interface used\n\
    \   for the RTP communication.  For example, the standard ASCII\n   representation\
    \ of an IP Version 4 address is \"dotted decimal\", also\n   known as dotted quad,\
    \ and for IP Version 6, addresses are textually\n   represented as groups of hexadecimal\
    \ digits separated by colons (with\n   variations as detailed in RFC 3513 [23]).\
    \  Other address types are\n   expected to have ASCII representations that are\
    \ mutually unique.  The\n   fully qualified domain name is more convenient for\
    \ a human observer\n   and may avoid the need to send a NAME item in addition,\
    \ but it may be\n   difficult or impossible to obtain reliably in some operating\n\
    \   environments.  Applications that may be run in such environments\n   SHOULD\
    \ use the ASCII representation of the address instead.\n   Examples are \"doe@sleepy.example.com\"\
    , \"doe@192.0.2.89\" or\n   \"doe@2201:056D::112E:144A:1E24\" for a multi-user\
    \ system.  On a system\n   with no user name, examples would be \"sleepy.example.com\"\
    ,\n   \"192.0.2.89\" or \"2201:056D::112E:144A:1E24\".\n   The user name SHOULD\
    \ be in a form that a program such as \"finger\" or\n   \"talk\" could use, i.e.,\
    \ it typically is the login name rather than\n   the personal name.  The host\
    \ name is not necessarily identical to the\n   one in the participant's electronic\
    \ mail address.\n   This syntax will not provide unique identifiers for each source\
    \ if an\n   application permits a user to generate multiple sources from one\n\
    \   host.  Such an application would have to rely on the SSRC to further\n   identify\
    \ the source, or the profile for that application would have\n   to specify additional\
    \ syntax for the CNAME identifier.\n   If each application creates its CNAME independently,\
    \ the resulting\n   CNAMEs may not be identical as would be required to provide\
    \ a binding\n   across multiple media tools belonging to one participant in a\
    \ set of\n   related RTP sessions.  If cross-media binding is required, it may\
    \ be\n   necessary for the CNAME of each tool to be externally configured with\n\
    \   the same value by a coordination tool.\n   Application writers should be aware\
    \ that private network address\n   assignments such as the Net-10 assignment proposed\
    \ in RFC 1918 [24]\n   may create network addresses that are not globally unique.\
    \  This\n   would lead to non-unique CNAMEs if hosts with private addresses and\n\
    \   no direct IP connectivity to the public Internet have their RTP\n   packets\
    \ forwarded to the public Internet through an RTP-level\n   translator.  (See\
    \ also RFC 1627 [25].)  To handle this case,\n   applications MAY provide a means\
    \ to configure a unique CNAME, but the\n   burden is on the translator to translate\
    \ CNAMEs from private\n   addresses to public addresses if necessary to keep private\
    \ addresses\n   from being exposed.\n"
- title: '6.5.2 NAME: User Name SDES Item'
  contents:
  - "6.5.2 NAME: User Name SDES Item\n    0                   1                  \
    \ 2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     NAME=2    |     length    | common name of source       ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   This is the real name used to describe the source, e.g., \"John Doe,\n   Bit\
    \ Recycler\".  It may be in any form desired by the user.  For\n   applications\
    \ such as conferencing, this form of name may be the most\n   desirable for display\
    \ in participant lists, and therefore might be\n   sent most frequently of those\
    \ items other than CNAME.  Profiles MAY\n   establish such priorities.  The NAME\
    \ value is expected to remain\n   constant at least for the duration of a session.\
    \  It SHOULD NOT be\n   relied upon to be unique among all participants in the\
    \ session.\n"
- title: '6.5.3 EMAIL: Electronic Mail Address SDES Item'
  contents:
  - "6.5.3 EMAIL: Electronic Mail Address SDES Item\n    0                   1   \
    \                2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    EMAIL=3    |     length    | email address of source     ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The email address is formatted according to RFC 2822 [9], for\n   example,\
    \ \"John.Doe@example.com\".  The EMAIL value is expected to\n   remain constant\
    \ for the duration of a session.\n"
- title: '6.5.4 PHONE: Phone Number SDES Item'
  contents:
  - "6.5.4 PHONE: Phone Number SDES Item\n    0                   1              \
    \     2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    PHONE=4    |     length    | phone number of source      ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The phone number SHOULD be formatted with the plus sign replacing the\n  \
    \ international access code.  For example, \"+1 908 555 1212\" for a\n   number\
    \ in the United States.\n"
- title: '6.5.5 LOC: Geographic User Location SDES Item'
  contents:
  - "6.5.5 LOC: Geographic User Location SDES Item\n    0                   1    \
    \               2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     LOC=5     |     length    | geographic location of site ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Depending on the application, different degrees of detail are\n   appropriate\
    \ for this item.  For conference applications, a string\n   like \"Murray Hill,\
    \ New Jersey\" may be sufficient, while, for an\n   active badge system, strings\
    \ like \"Room 2A244, AT&T BL MH\" might be\n   appropriate.  The degree of detail\
    \ is left to the implementation\n   and/or user, but format and content MAY be\
    \ prescribed by a profile.\n   The LOC value is expected to remain constant for\
    \ the duration of a\n   session, except for mobile hosts.\n"
- title: '6.5.6 TOOL: Application or Tool Name SDES Item'
  contents:
  - "6.5.6 TOOL: Application or Tool Name SDES Item\n    0                   1   \
    \                2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     TOOL=6    |     length    |name/version of source appl. ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   A string giving the name and possibly version of the application\n   generating\
    \ the stream, e.g., \"videotool 1.2\".  This information may\n   be useful for\
    \ debugging purposes and is similar to the Mailer or\n   Mail-System-Version SMTP\
    \ headers.  The TOOL value is expected to\n   remain constant for the duration\
    \ of the session.\n"
- title: '6.5.7 NOTE: Notice/Status SDES Item'
  contents:
  - "6.5.7 NOTE: Notice/Status SDES Item\n    0                   1              \
    \     2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     NOTE=7    |     length    | note about the source       ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The following semantics are suggested for this item, but these or\n   other\
    \ semantics MAY be explicitly defined by a profile.  The NOTE\n   item is intended\
    \ for transient messages describing the current state\n   of the source, e.g.,\
    \ \"on the phone, can't talk\".  Or, during a\n   seminar, this item might be\
    \ used to convey the title of the talk.  It\n   should be used only to carry exceptional\
    \ information and SHOULD NOT\n   be included routinely by all participants because\
    \ this would slow\n   down the rate at which reception reports and CNAME are sent,\
    \ thus\n   impairing the performance of the protocol.  In particular, it SHOULD\n\
    \   NOT be included as an item in a user's configuration file nor\n   automatically\
    \ generated as in a quote-of-the-day.\n   Since the NOTE item may be important\
    \ to display while it is active,\n   the rate at which other non-CNAME items such\
    \ as NAME are transmitted\n   might be reduced so that the NOTE item can take\
    \ that part of the RTCP\n   bandwidth.  When the transient message becomes inactive,\
    \ the NOTE\n   item SHOULD continue to be transmitted a few times at the same\n\
    \   repetition rate but with a string of length zero to signal the\n   receivers.\
    \  However, receivers SHOULD also consider the NOTE item\n   inactive if it is\
    \ not received for a small multiple of the repetition\n   rate, or perhaps 20-30\
    \ RTCP intervals.\n"
- title: '6.5.8 PRIV: Private Extensions SDES Item'
  contents:
  - "6.5.8 PRIV: Private Extensions SDES Item\n     0                   1        \
    \           2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |     PRIV=8    |     length    | prefix length |prefix string...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    ...             |                  value string               ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   This item is used to define experimental or application-specific SDES\n  \
    \ extensions.  The item contains a prefix consisting of a length-string\n   pair,\
    \ followed by the value string filling the remainder of the item\n   and carrying\
    \ the desired information.  The prefix length field is 8\n   bits long.  The prefix\
    \ string is a name chosen by the person defining\n   the PRIV item to be unique\
    \ with respect to other PRIV items this\n   application might receive.  The application\
    \ creator might choose to\n   use the application name plus an additional subtype\
    \ identification if\n   needed.  Alternatively, it is RECOMMENDED that others\
    \ choose a name\n   based on the entity they represent, then coordinate the use\
    \ of the\n   name within that entity.\n   Note that the prefix consumes some space\
    \ within the item's total\n   length of 255 octets, so the prefix should be kept\
    \ as short as\n   possible.  This facility and the constrained RTCP bandwidth\
    \ SHOULD\n   NOT be overloaded; it is not intended to satisfy all the control\n\
    \   communication requirements of all applications.\n   SDES PRIV prefixes will\
    \ not be registered by IANA.  If some form of\n   the PRIV item proves to be of\
    \ general utility, it SHOULD instead be\n   assigned a regular SDES item type\
    \ registered with IANA so that no\n   prefix is required.  This simplifies use\
    \ and increases transmission\n   efficiency.\n"
- title: '6.6 BYE: Goodbye RTCP Packet'
  contents:
  - "6.6 BYE: Goodbye RTCP Packet\n       0                   1                  \
    \ 2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |V=2|P|    SC   |   PT=BYE=203  |             length            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                           SSRC/CSRC                           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      :                              ...                              :\n   \
    \   +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n"
- title: (opt) |     length    |               reason for leaving            ...
  contents:
  - "(opt) |     length    |               reason for leaving            ...\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   The\
    \ BYE packet indicates that one or more sources are no longer\n   active.\n  \
    \ version (V), padding (P), length:\n      As described for the SR packet (see\
    \ Section 6.4.1).\n   packet type (PT): 8 bits\n      Contains the constant 203\
    \ to identify this as an RTCP BYE packet.\n   source count (SC): 5 bits\n    \
    \  The number of SSRC/CSRC identifiers included in this BYE packet.\n      A count\
    \ value of zero is valid, but useless.\n   The rules for when a BYE packet should\
    \ be sent are specified in\n   Sections 6.3.7 and 8.2.\n   If a BYE packet is\
    \ received by a mixer, the mixer SHOULD forward the\n   BYE packet with the SSRC/CSRC\
    \ identifier(s) unchanged.  If a mixer\n   shuts down, it SHOULD send a BYE packet\
    \ listing all contributing\n   sources it handles, as well as its own SSRC identifier.\
    \  Optionally,\n   the BYE packet MAY include an 8-bit octet count followed by\
    \ that many\n   octets of text indicating the reason for leaving, e.g., \"camera\n\
    \   malfunction\" or \"RTP loop detected\".  The string has the same\n   encoding\
    \ as that described for SDES.  If the string fills the packet\n   to the next\
    \ 32-bit boundary, the string is not null terminated.  If\n   not, the BYE packet\
    \ MUST be padded with null octets to the next 32-\n   bit boundary.  This padding\
    \ is separate from that indicated by the P\n   bit in the RTCP header.\n"
- title: '6.7 APP: Application-Defined RTCP Packet'
  contents:
  - "6.7 APP: Application-Defined RTCP Packet\n    0                   1         \
    \          2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |V=2|P| subtype |   PT=APP=204  |             length            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                           SSRC/CSRC                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                          name (ASCII)                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   application-dependent data                ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The APP packet is intended for experimental use as new applications\n   and\
    \ new features are developed, without requiring packet type value\n   registration.\
    \  APP packets with unrecognized names SHOULD be ignored.\n   After testing and\
    \ if wider use is justified, it is RECOMMENDED that\n   each APP packet be redefined\
    \ without the subtype and name fields and\n   registered with IANA using an RTCP\
    \ packet type.\n   version (V), padding (P), length:\n      As described for the\
    \ SR packet (see Section 6.4.1).\n   subtype: 5 bits\n      May be used as a subtype\
    \ to allow a set of APP packets to be\n      defined under one unique name, or\
    \ for any application-dependent\n      data.\n   packet type (PT): 8 bits\n  \
    \    Contains the constant 204 to identify this as an RTCP APP packet.\n   name:\
    \ 4 octets\n      A name chosen by the person defining the set of APP packets\
    \ to be\n      unique with respect to other APP packets this application might\n\
    \      receive.  The application creator might choose to use the\n      application\
    \ name, and then coordinate the allocation of subtype\n      values to others\
    \ who want to define new packet types for the\n      application.  Alternatively,\
    \ it is RECOMMENDED that others choose\n      a name based on the entity they\
    \ represent, then coordinate the use\n      of the name within that entity.  The\
    \ name is interpreted as a\n      sequence of four ASCII characters, with uppercase\
    \ and lowercase\n      characters treated as distinct.\n   application-dependent\
    \ data: variable length\n      Application-dependent data may or may not appear\
    \ in an APP packet.\n      It is interpreted by the application and not RTP itself.\
    \  It MUST\n      be a multiple of 32 bits long.\n"
- title: 7. RTP Translators and Mixers
  contents:
  - "7. RTP Translators and Mixers\n   In addition to end systems, RTP supports the\
    \ notion of \"translators\"\n   and \"mixers\", which could be considered as \"\
    intermediate systems\" at\n   the RTP level.  Although this support adds some\
    \ complexity to the\n   protocol, the need for these functions has been clearly\
    \ established\n   by experiments with multicast audio and video applications in\
    \ the\n   Internet.  Example uses of translators and mixers given in Section\n\
    \   2.3 stem from the presence of firewalls and low bandwidth\n   connections,\
    \ both of which are likely to remain.\n"
- title: 7.1 General Description
  contents:
  - "7.1 General Description\n   An RTP translator/mixer connects two or more transport-level\n\
    \   \"clouds\".  Typically, each cloud is defined by a common network and\n  \
    \ transport protocol (e.g., IP/UDP) plus a multicast address and\n   transport\
    \ level destination port or a pair of unicast addresses and\n   ports.  (Network-level\
    \ protocol translators, such as IP version 4 to\n   IP version 6, may be present\
    \ within a cloud invisibly to RTP.)  One\n   system may serve as a translator\
    \ or mixer for a number of RTP\n   sessions, but each is considered a logically\
    \ separate entity.\n   In order to avoid creating a loop when a translator or\
    \ mixer is\n   installed, the following rules MUST be observed:\n   o  Each of\
    \ the clouds connected by translators and mixers\n      participating in one RTP\
    \ session either MUST be distinct from all\n      the others in at least one of\
    \ these parameters (protocol, address,\n      port), or MUST be isolated at the\
    \ network level from the others.\n   o  A derivative of the first rule is that\
    \ there MUST NOT be multiple\n      translators or mixers connected in parallel\
    \ unless by some\n      arrangement they partition the set of sources to be forwarded.\n\
    \   Similarly, all RTP end systems that can communicate through one or\n   more\
    \ RTP translators or mixers share the same SSRC space, that is,\n   the SSRC identifiers\
    \ MUST be unique among all these end systems.\n   Section 8.2 describes the collision\
    \ resolution algorithm by which\n   SSRC identifiers are kept unique and loops\
    \ are detected.\n   There may be many varieties of translators and mixers designed\
    \ for\n   different purposes and applications.  Some examples are to add or\n\
    \   remove encryption, change the encoding of the data or the underlying\n   protocols,\
    \ or replicate between a multicast address and one or more\n   unicast addresses.\
    \  The distinction between translators and mixers is\n   that a translator passes\
    \ through the data streams from different\n   sources separately, whereas a mixer\
    \ combines them to form one new\n   stream:\n   Translator: Forwards RTP packets\
    \ with their SSRC identifier\n      intact; this makes it possible for receivers\
    \ to identify\n      individual sources even though packets from all the sources\
    \ pass\n      through the same translator and carry the translator's network\n\
    \      source address.  Some kinds of translators will pass through the\n    \
    \  data untouched, but others MAY change the encoding of the data and\n      thus\
    \ the RTP data payload type and timestamp.  If multiple data\n      packets are\
    \ re-encoded into one, or vice versa, a translator MUST\n      assign new sequence\
    \ numbers to the outgoing packets.  Losses in\n      the incoming packet stream\
    \ may induce corresponding gaps in the\n      outgoing sequence numbers.  Receivers\
    \ cannot detect the presence\n      of a translator unless they know by some other\
    \ means what payload\n      type or transport address was used by the original\
    \ source.\n   Mixer: Receives streams of RTP data packets from one or more\n \
    \     sources, possibly changes the data format, combines the streams in\n   \
    \   some manner and then forwards the combined stream.  Since the\n      timing\
    \ among multiple input sources will not generally be\n      synchronized, the\
    \ mixer will make timing adjustments among the\n      streams and generate its\
    \ own timing for the combined stream, so it\n      is the synchronization source.\
    \  Thus, all data packets forwarded\n      by a mixer MUST be marked with the\
    \ mixer's own SSRC identifier.\n      In order to preserve the identity of the\
    \ original sources\n      contributing to the mixed packet, the mixer SHOULD insert\
    \ their\n      SSRC identifiers into the CSRC identifier list following the fixed\n\
    \      RTP header of the packet.  A mixer that is also itself a\n      contributing\
    \ source for some packet SHOULD explicitly include its\n      own SSRC identifier\
    \ in the CSRC list for that packet.\n      For some applications, it MAY be acceptable\
    \ for a mixer not to\n      identify sources in the CSRC list.  However, this\
    \ introduces the\n      danger that loops involving those sources could not be\
    \ detected.\n   The advantage of a mixer over a translator for applications like\n\
    \   audio is that the output bandwidth is limited to that of one source\n   even\
    \ when multiple sources are active on the input side.  This may be\n   important\
    \ for low-bandwidth links.  The disadvantage is that\n   receivers on the output\
    \ side don't have any control over which\n   sources are passed through or muted,\
    \ unless some mechanism is\n   implemented for remote control of the mixer.  The\
    \ regeneration of\n   synchronization information by mixers also means that receivers\
    \ can't\n   do inter-media synchronization of the original streams.  A multi-\n\
    \   media mixer could do it.\n         [E1]                                  \
    \  [E6]\n          |                                       |\n    E1:17 |    \
    \                             E6:15 |\n          |                           \
    \            |   E6:15\n          V  M1:48 (1,17)         M1:48 (1,17)    V  \
    \ M1:48 (1,17)\n         (M1)-------------><T1>-----------------><T2>-------------->[E7]\n\
    \          ^                 ^     E4:47           ^   E4:47\n     E2:1 |    \
    \       E4:47 |                     |   M3:89 (64,45)\n          |           \
    \      |                     |\n         [E2]              [E4]     M3:89 (64,45)\
    \ |\n                                                  |        legend:\n   [E3]\
    \ --------->(M2)----------->(M3)------------|        [End system]\n          E3:64\
    \        M2:12 (64)  ^                       (Mixer)\n                       \
    \            | E5:45                 <Translator>\n                          \
    \         |\n                                  [E5]          source: SSRC (CSRCs)\n\
    \                                                ------------------->\n   Figure\
    \ 3: Sample RTP network with end systems, mixers and translators\n   A collection\
    \ of mixers and translators is shown in Fig. 3 to\n   illustrate their effect\
    \ on SSRC and CSRC identifiers.  In the figure,\n   end systems are shown as rectangles\
    \ (named E), translators as\n   triangles (named T) and mixers as ovals (named\
    \ M).  The notation \"M1:\n   48(1,17)\" designates a packet originating a mixer\
    \ M1, identified by\n   M1's (random) SSRC value of 48 and two CSRC identifiers,\
    \ 1 and 17,\n   copied from the SSRC identifiers of packets from E1 and E2.\n"
- title: 7.2 RTCP Processing in Translators
  contents:
  - "7.2 RTCP Processing in Translators\n   In addition to forwarding data packets,\
    \ perhaps modified, translators\n   and mixers MUST also process RTCP packets.\
    \  In many cases, they will\n   take apart the compound RTCP packets received\
    \ from end systems to\n   aggregate SDES information and to modify the SR or RR\
    \ packets.\n   Retransmission of this information may be triggered by the packet\n\
    \   arrival or by the RTCP interval timer of the translator or mixer\n   itself.\n\
    \   A translator that does not modify the data packets, for example one\n   that\
    \ just replicates between a multicast address and a unicast\n   address, MAY simply\
    \ forward RTCP packets unmodified as well.  A\n   translator that transforms the\
    \ payload in some way MUST make\n   corresponding transformations in the SR and\
    \ RR information so that it\n   still reflects the characteristics of the data\
    \ and the reception\n   quality.  These translators MUST NOT simply forward RTCP\
    \ packets.  In\n   general, a translator SHOULD NOT aggregate SR and RR packets\
    \ from\n   different sources into one packet since that would reduce the\n   accuracy\
    \ of the propagation delay measurements based on the LSR and\n   DLSR fields.\n\
    \   SR sender information:  A translator does not generate its own\n      sender\
    \ information, but forwards the SR packets received from one\n      cloud to the\
    \ others.  The SSRC is left intact but the sender\n      information MUST be modified\
    \ if required by the translation.  If a\n      translator changes the data encoding,\
    \ it MUST change the \"sender's\n      byte count\" field.  If it also combines\
    \ several data packets into\n      one output packet, it MUST change the \"sender's\
    \ packet count\"\n      field.  If it changes the timestamp frequency, it MUST\
    \ change the\n      \"RTP timestamp\" field in the SR packet.\n   SR/RR reception\
    \ report blocks:  A translator forwards reception\n      reports received from\
    \ one cloud to the others.  Note that these\n      flow in the direction opposite\
    \ to the data.  The SSRC is left\n      intact.  If a translator combines several\
    \ data packets into one\n      output packet, and therefore changes the sequence\
    \ numbers, it MUST\n      make the inverse manipulation for the packet loss fields\
    \ and the\n      \"extended last sequence number\" field.  This may be complex.\
    \  In\n      the extreme case, there may be no meaningful way to translate the\n\
    \      reception reports, so the translator MAY pass on no reception\n      report\
    \ at all or a synthetic report based on its own reception.\n      The general\
    \ rule is to do what makes sense for a particular\n      translation.\n      A\
    \ translator does not require an SSRC identifier of its own, but\n      MAY choose\
    \ to allocate one for the purpose of sending reports\n      about what it has\
    \ received.  These would be sent to all the\n      connected clouds, each corresponding\
    \ to the translation of the\n      data stream as sent to that cloud, since reception\
    \ reports are\n      normally multicast to all participants.\n   SDES:  Translators\
    \ typically forward without change the SDES\n      information they receive from\
    \ one cloud to the others, but MAY,\n      for example, decide to filter non-CNAME\
    \ SDES information if\n      bandwidth is limited.  The CNAMEs MUST be forwarded\
    \ to allow SSRC\n      identifier collision detection to work.  A translator that\n\
    \      generates its own RR packets MUST send SDES CNAME information\n      about\
    \ itself to the same clouds that it sends those RR packets.\n   BYE:  Translators\
    \ forward BYE packets unchanged.  A translator\n      that is about to cease forwarding\
    \ packets SHOULD send a BYE packet\n      to each connected cloud containing all\
    \ the SSRC identifiers that\n      were previously being forwarded to that cloud,\
    \ including the\n      translator's own SSRC identifier if it sent reports of\
    \ its own.\n   APP:  Translators forward APP packets unchanged.\n"
- title: 7.3 RTCP Processing in Mixers
  contents:
  - "7.3 RTCP Processing in Mixers\n   Since a mixer generates a new data stream of\
    \ its own, it does not\n   pass through SR or RR packets at all and instead generates\
    \ new\n   information for both sides.\n   SR sender information:  A mixer does\
    \ not pass through sender\n      information from the sources it mixes because\
    \ the characteristics\n      of the source streams are lost in the mix.  As a\
    \ synchronization\n      source, the mixer SHOULD generate its own SR packets\
    \ with sender\n      information about the mixed data stream and send them in\
    \ the same\n      direction as the mixed stream.\n   SR/RR reception report blocks:\
    \  A mixer generates its own\n      reception reports for sources in each cloud\
    \ and sends them out\n      only to the same cloud.  It MUST NOT send these reception\
    \ reports\n      to the other clouds and MUST NOT forward reception reports from\n\
    \      one cloud to the others because the sources would not be SSRCs\n      there\
    \ (only CSRCs).\n   SDES:  Mixers typically forward without change the SDES\n\
    \      information they receive from one cloud to the others, but MAY,\n     \
    \ for example, decide to filter non-CNAME SDES information if\n      bandwidth\
    \ is limited.  The CNAMEs MUST be forwarded to allow SSRC\n      identifier collision\
    \ detection to work.  (An identifier in a CSRC\n      list generated by a mixer\
    \ might collide with an SSRC identifier\n      generated by an end system.)  A\
    \ mixer MUST send SDES CNAME\n      information about itself to the same clouds\
    \ that it sends SR or RR\n      packets.\n      Since mixers do not forward SR\
    \ or RR packets, they will typically\n      be extracting SDES packets from a\
    \ compound RTCP packet.  To\n      minimize overhead, chunks from the SDES packets\
    \ MAY be aggregated\n      into a single SDES packet which is then stacked on\
    \ an SR or RR\n      packet originating from the mixer.  A mixer which aggregates\
    \ SDES\n      packets will use more RTCP bandwidth than an individual source\n\
    \      because the compound packets will be longer, but that is\n      appropriate\
    \ since the mixer represents multiple sources.\n      Similarly, a mixer which\
    \ passes through SDES packets as they are\n      received will be transmitting\
    \ RTCP packets at higher than the\n      single source rate, but again that is\
    \ correct since the packets\n      come from multiple sources.  The RTCP packet\
    \ rate may be different\n      on each side of the mixer.\n      A mixer that\
    \ does not insert CSRC identifiers MAY also refrain\n      from forwarding SDES\
    \ CNAMEs.  In this case, the SSRC identifier\n      spaces in the two clouds are\
    \ independent.  As mentioned earlier,\n      this mode of operation creates a\
    \ danger that loops can't be\n      detected.\n   BYE:  Mixers MUST forward BYE\
    \ packets.  A mixer that is about to\n      cease forwarding packets SHOULD send\
    \ a BYE packet to each\n      connected cloud containing all the SSRC identifiers\
    \ that were\n      previously being forwarded to that cloud, including the mixer's\n\
    \      own SSRC identifier if it sent reports of its own.\n   APP:  The treatment\
    \ of APP packets by mixers is application-specific.\n"
- title: 7.4 Cascaded Mixers
  contents:
  - "7.4 Cascaded Mixers\n   An RTP session may involve a collection of mixers and\
    \ translators as\n   shown in Fig. 3.  If two mixers are cascaded, such as M2\
    \ and M3 in\n   the figure, packets received by a mixer may already have been\
    \ mixed\n   and may include a CSRC list with multiple identifiers.  The second\n\
    \   mixer SHOULD build the CSRC list for the outgoing packet using the\n   CSRC\
    \ identifiers from already-mixed input packets and the SSRC\n   identifiers from\
    \ unmixed input packets.  This is shown in the output\n   arc from mixer M3 labeled\
    \ M3:89(64,45) in the figure.  As in the case\n   of mixers that are not cascaded,\
    \ if the resulting CSRC list has more\n   than 15 identifiers, the remainder cannot\
    \ be included.\n"
- title: 8.  SSRC Identifier Allocation and Use
  contents:
  - "8.  SSRC Identifier Allocation and Use\n   The SSRC identifier carried in the\
    \ RTP header and in various fields\n   of RTCP packets is a random 32-bit number\
    \ that is required to be\n   globally unique within an RTP session.  It is crucial\
    \ that the number\n   be chosen with care in order that participants on the same\
    \ network or\n   starting at the same time are not likely to choose the same number.\n\
    \   It is not sufficient to use the local network address (such as an\n   IPv4\
    \ address) for the identifier because the address may not be\n   unique.  Since\
    \ RTP translators and mixers enable interoperation among\n   multiple networks\
    \ with different address spaces, the allocation\n   patterns for addresses within\
    \ two spaces might result in a much\n   higher rate of collision than would occur\
    \ with random allocation.\n   Multiple sources running on one host would also\
    \ conflict.\n   It is also not sufficient to obtain an SSRC identifier simply\
    \ by\n   calling random() without carefully initializing the state.  An\n   example\
    \ of how to generate a random identifier is presented in\n   Appendix A.6.\n"
- title: 8.1 Probability of Collision
  contents:
  - "8.1 Probability of Collision\n   Since the identifiers are chosen randomly, it\
    \ is possible that two or\n   more sources will choose the same number.  Collision\
    \ occurs with the\n   highest probability when all sources are started simultaneously,\
    \ for\n   example when triggered automatically by some session management\n  \
    \ event.  If N is the number of sources and L the length of the\n   identifier\
    \ (here, 32 bits), the probability that two sources\n   independently pick the\
    \ same value can be approximated for large N\n   [26] as 1 - exp(-N**2 / 2**(L+1)).\
    \  For N=1000, the probability is\n   roughly 10**-4.\n   The typical collision\
    \ probability is much lower than the worst-case\n   above.  When one new source\
    \ joins an RTP session in which all the\n   other sources already have unique\
    \ identifiers, the probability of\n   collision is just the fraction of numbers\
    \ used out of the space.\n   Again, if N is the number of sources and L the length\
    \ of the\n   identifier, the probability of collision is N / 2**L.  For N=1000,\n\
    \   the probability is roughly 2*10**-7.\n   The probability of collision is further\
    \ reduced by the opportunity\n   for a new source to receive packets from other\
    \ participants before\n   sending its first packet (either data or control). \
    \ If the new source\n   keeps track of the other participants (by SSRC identifier),\
    \ then\n   before transmitting its first packet the new source can verify that\n\
    \   its identifier does not conflict with any that have been received, or\n  \
    \ else choose again.\n"
- title: 8.2 Collision Resolution and Loop Detection
  contents:
  - "8.2 Collision Resolution and Loop Detection\n   Although the probability of SSRC\
    \ identifier collision is low, all RTP\n   implementations MUST be prepared to\
    \ detect collisions and take the\n   appropriate actions to resolve them.  If\
    \ a source discovers at any\n   time that another source is using the same SSRC\
    \ identifier as its\n   own, it MUST send an RTCP BYE packet for the old identifier\
    \ and\n   choose another random one.  (As explained below, this step is taken\n\
    \   only once in case of a loop.)  If a receiver discovers that two other\n  \
    \ sources are colliding, it MAY keep the packets from one and discard\n   the\
    \ packets from the other when this can be detected by different\n   source transport\
    \ addresses or CNAMEs.  The two sources are expected\n   to resolve the collision\
    \ so that the situation doesn't last.\n   Because the random SSRC identifiers\
    \ are kept globally unique for each\n   RTP session, they can also be used to\
    \ detect loops that may be\n   introduced by mixers or translators.  A loop causes\
    \ duplication of\n   data and control information, either unmodified or possibly\
    \ mixed, as\n   in the following examples:\n   o  A translator may incorrectly\
    \ forward a packet to the same\n      multicast group from which it has received\
    \ the packet, either\n      directly or through a chain of translators.  In that\
    \ case, the\n      same packet appears several times, originating from different\n\
    \      network sources.\n   o  Two translators incorrectly set up in parallel,\
    \ i.e., with the\n      same multicast groups on both sides, would both forward\
    \ packets\n      from one multicast group to the other.  Unidirectional translators\n\
    \      would produce two copies; bidirectional translators would form a\n    \
    \  loop.\n   o  A mixer can close a loop by sending to the same transport\n  \
    \    destination upon which it receives packets, either directly or\n      through\
    \ another mixer or translator.  In this case a source might\n      show up both\
    \ as an SSRC on a data packet and a CSRC in a mixed\n      data packet.\n   A\
    \ source may discover that its own packets are being looped, or that\n   packets\
    \ from another source are being looped (a third-party loop).\n   Both loops and\
    \ collisions in the random selection of a source\n   identifier result in packets\
    \ arriving with the same SSRC identifier\n   but a different source transport\
    \ address, which may be that of the\n   end system originating the packet or an\
    \ intermediate system.\n   Therefore, if a source changes its source transport\
    \ address, it MAY\n   also choose a new SSRC identifier to avoid being interpreted\
    \ as a\n   looped source.  (This is not MUST because in some applications of RTP\n\
    \   sources may be expected to change addresses during a session.)  Note\n   that\
    \ if a translator restarts and consequently changes the source\n   transport address\
    \ (e.g., changes the UDP source port number) on which\n   it forwards packets,\
    \ then all those packets will appear to receivers\n   to be looped because the\
    \ SSRC identifiers are applied by the original\n   source and will not change.\
    \  This problem can be avoided by keeping\n   the source transport address fixed\
    \ across restarts, but in any case\n   will be resolved after a timeout at the\
    \ receivers.\n   Loops or collisions occurring on the far side of a translator\
    \ or\n   mixer cannot be detected using the source transport address if all\n\
    \   copies of the packets go through the translator or mixer, however,\n   collisions\
    \ may still be detected when chunks from two RTCP SDES\n   packets contain the\
    \ same SSRC identifier but different CNAMEs.\n   To detect and resolve these conflicts,\
    \ an RTP implementation MUST\n   include an algorithm similar to the one described\
    \ below, though the\n   implementation MAY choose a different policy for which\
    \ packets from\n   colliding third-party sources are kept.  The algorithm described\n\
    \   below ignores packets from a new source or loop that collide with an\n   established\
    \ source.  It resolves collisions with the participant's\n   own SSRC identifier\
    \ by sending an RTCP BYE for the old identifier and\n   choosing a new one.  However,\
    \ when the collision was induced by a\n   loop of the participant's own packets,\
    \ the algorithm will choose a\n   new identifier only once and thereafter ignore\
    \ packets from the\n   looping source transport address.  This is required to\
    \ avoid a flood\n   of BYE packets.\n   This algorithm requires keeping a table\
    \ indexed by the source\n   identifier and containing the source transport addresses\
    \ from the\n   first RTP packet and first RTCP packet received with that identifier,\n\
    \   along with other state for that source.  Two source transport\n   addresses\
    \ are required since, for example, the UDP source port\n   numbers may be different\
    \ on RTP and RTCP packets.  However, it may be\n   assumed that the network address\
    \ is the same in both source transport\n   addresses.\n   Each SSRC or CSRC identifier\
    \ received in an RTP or RTCP packet is\n   looked up in the source identifier\
    \ table in order to process that\n   data or control information.  The source\
    \ transport address from the\n   packet is compared to the corresponding source\
    \ transport address in\n   the table to detect a loop or collision if they don't\
    \ match.  For\n   control packets, each element with its own SSRC identifier,\
    \ for\n   example an SDES chunk, requires a separate lookup.  (The SSRC\n   identifier\
    \ in a reception report block is an exception because it\n   identifies a source\
    \ heard by the reporter, and that SSRC identifier\n   is unrelated to the source\
    \ transport address of the RTCP packet sent\n   by the reporter.)  If the SSRC\
    \ or CSRC is not found, a new entry is\n   created.  These table entries are removed\
    \ when an RTCP BYE packet is\n   received with the corresponding SSRC identifier\
    \ and validated by a\n   matching source transport address, or after no packets\
    \ have arrived\n   for a relatively long time (see Section 6.2.1).\n   Note that\
    \ if two sources on the same host are transmitting with the\n   same source identifier\
    \ at the time a receiver begins operation, it\n   would be possible that the first\
    \ RTP packet received came from one of\n   the sources while the first RTCP packet\
    \ received came from the other.\n   This would cause the wrong RTCP information\
    \ to be associated with the\n   RTP data, but this situation should be sufficiently\
    \ rare and harmless\n   that it may be disregarded.\n   In order to track loops\
    \ of the participant's own data packets, the\n   implementation MUST also keep\
    \ a separate list of source transport\n   addresses (not identifiers) that have\
    \ been found to be conflicting.\n   As in the source identifier table, two source\
    \ transport addresses\n   MUST be kept to separately track conflicting RTP and\
    \ RTCP packets.\n   Note that the conflicting address list should be short, usually\n\
    \   empty.  Each element in this list stores the source addresses plus\n   the\
    \ time when the most recent conflicting packet was received.  An\n   element MAY\
    \ be removed from the list when no conflicting packet has\n   arrived from that\
    \ source for a time on the order of 10 RTCP report\n   intervals (see Section\
    \ 6.2).\n   For the algorithm as shown, it is assumed that the participant's own\n\
    \   source identifier and state are included in the source identifier\n   table.\
    \  The algorithm could be restructured to first make a separate\n   comparison\
    \ against the participant's own source identifier.\n      if (SSRC or CSRC identifier\
    \ is not found in the source\n          identifier table) {\n          create\
    \ a new entry storing the data or control source\n              transport address,\
    \ the SSRC or CSRC and other state;\n      }\n      /* Identifier is found in\
    \ the table */\n      else if (table entry was created on receipt of a control\
    \ packet\n               and this is the first data packet or vice versa) {\n\
    \          store the source transport address from this packet;\n      }\n   \
    \   else if (source transport address from the packet does not match\n       \
    \        the one saved in the table entry for this identifier) {\n          /*\
    \ An identifier collision or a loop is indicated */\n          if (source identifier\
    \ is not the participant's own) {\n              /* OPTIONAL error counter step\
    \ */\n              if (source identifier is from an RTCP SDES chunk\n       \
    \           containing a CNAME item that differs from the CNAME\n            \
    \      in the table entry) {\n                  count a third-party collision;\n\
    \              } else {\n                  count a third-party loop;\n       \
    \       }\n              abort processing of data packet or control element;\n\
    \              /* MAY choose a different policy to keep new source */\n      \
    \    }\n          /* A collision or loop of the participant's own packets */\n\
    \          else if (source transport address is found in the list of\n       \
    \            conflicting data or control source transport\n                  \
    \ addresses) {\n              /* OPTIONAL error counter step */\n            \
    \  if (source identifier is not from an RTCP SDES chunk\n                  containing\
    \ a CNAME item or CNAME is the\n                  participant's own) {\n     \
    \             count occurrence of own traffic looped;\n              }\n     \
    \         mark current time in conflicting address list entry;\n             \
    \ abort processing of data packet or control element;\n          }\n         \
    \ /* New collision, change SSRC identifier */\n          else {\n            \
    \  log occurrence of a collision;\n              create a new entry in the conflicting\
    \ data or control\n                  source transport address list and mark current\
    \ time;\n              send an RTCP BYE packet with the old SSRC identifier;\n\
    \              choose a new SSRC identifier;\n              create a new entry\
    \ in the source identifier table with\n                  the old SSRC plus the\
    \ source transport address from\n                  the data or control packet\
    \ being processed;\n          }\n      }\n   In this algorithm, packets from a\
    \ newly conflicting source address\n   will be ignored and packets from the original\
    \ source address will be\n   kept.  If no packets arrive from the original source\
    \ for an extended\n   period, the table entry will be timed out and the new source\
    \ will be\n   able to take over.  This might occur if the original source detects\n\
    \   the collision and moves to a new source identifier, but in the usual\n   case\
    \ an RTCP BYE packet will be received from the original source to\n   delete the\
    \ state without having to wait for a timeout.\n   If the original source address\
    \ was received through a mixer (i.e.,\n   learned as a CSRC) and later the same\
    \ source is received directly,\n   the receiver may be well advised to switch\
    \ to the new source address\n   unless other sources in the mix would be lost.\
    \  Furthermore, for\n   applications such as telephony in which some sources such\
    \ as mobile\n   entities may change addresses during the course of an RTP session,\n\
    \   the RTP implementation SHOULD modify the collision detection\n   algorithm\
    \ to accept packets from the new source transport address.\n   To guard against\
    \ flip-flopping between addresses if a genuine\n   collision does occur, the algorithm\
    \ SHOULD include some means to\n   detect this case and avoid switching.\n   When\
    \ a new SSRC identifier is chosen due to a collision, the\n   candidate identifier\
    \ SHOULD first be looked up in the source\n   identifier table to see if it was\
    \ already in use by some other\n   source.  If so, another candidate MUST be generated\
    \ and the process\n   repeated.\n   A loop of data packets to a multicast destination\
    \ can cause severe\n   network flooding.  All mixers and translators MUST implement\
    \ a loop\n   detection algorithm like the one here so that they can break loops.\n\
    \   This should limit the excess traffic to no more than one duplicate\n   copy\
    \ of the original traffic, which may allow the session to continue\n   so that\
    \ the cause of the loop can be found and fixed.  However, in\n   extreme cases\
    \ where a mixer or translator does not properly break the\n   loop and high traffic\
    \ levels result, it may be necessary for end\n   systems to cease transmitting\
    \ data or control packets entirely.  This\n   decision may depend upon the application.\
    \  An error condition SHOULD\n   be indicated as appropriate.  Transmission MAY\
    \ be attempted again\n   periodically after a long, random time (on the order\
    \ of minutes).\n"
- title: 8.3 Use with Layered Encodings
  contents:
  - "8.3 Use with Layered Encodings\n   For layered encodings transmitted on separate\
    \ RTP sessions (see\n   Section 2.4), a single SSRC identifier space SHOULD be\
    \ used across\n   the sessions of all layers and the core (base) layer SHOULD\
    \ be used\n   for SSRC identifier allocation and collision resolution.  When a\n\
    \   source discovers that it has collided, it transmits an RTCP BYE\n   packet\
    \ on only the base layer but changes the SSRC identifier to the\n   new value\
    \ in all layers.\n"
- title: 9. Security
  contents:
  - "9. Security\n   Lower layer protocols may eventually provide all the security\n\
    \   services that may be desired for applications of RTP, including\n   authentication,\
    \ integrity, and confidentiality.  These services have\n   been specified for\
    \ IP in [27].  Since the initial audio and video\n   applications using RTP needed\
    \ a confidentiality service before such\n   services were available for the IP\
    \ layer, the confidentiality service\n   described in the next section was defined\
    \ for use with RTP and RTCP.\n   That description is included here to codify existing\
    \ practice.  New\n   applications of RTP MAY implement this RTP-specific confidentiality\n\
    \   service for backward compatibility, and/or they MAY implement\n   alternative\
    \ security services.  The overhead on the RTP protocol for\n   this confidentiality\
    \ service is low, so the penalty will be minimal\n   if this service is obsoleted\
    \ by other services in the future.\n   Alternatively, other services, other implementations\
    \ of services and\n   other algorithms may be defined for RTP in the future. \
    \ In\n   particular, an RTP profile called Secure Real-time Transport Protocol\n\
    \   (SRTP) [28] is being developed to provide confidentiality of the RTP\n   payload\
    \ while leaving the RTP header in the clear so that link-level\n   header compression\
    \ algorithms can still operate.  It is expected that\n   SRTP will be the correct\
    \ choice for many applications.  SRTP is based\n   on the Advanced Encryption\
    \ Standard (AES) and provides stronger\n   security than the service described\
    \ here.  No claim is made that the\n   methods presented here are appropriate\
    \ for a particular security\n   need.  A profile may specify which services and\
    \ algorithms should be\n   offered by applications, and may provide guidance as\
    \ to their\n   appropriate use.\n   Key distribution and certificates are outside\
    \ the scope of this\n   document.\n"
- title: 9.1 Confidentiality
  contents:
  - "9.1 Confidentiality\n   Confidentiality means that only the intended receiver(s)\
    \ can decode\n   the received packets; for others, the packet contains no useful\n\
    \   information.  Confidentiality of the content is achieved by\n   encryption.\n\
    \   When it is desired to encrypt RTP or RTCP according to the method\n   specified\
    \ in this section, all the octets that will be encapsulated\n   for transmission\
    \ in a single lower-layer packet are encrypted as a\n   unit.  For RTCP, a 32-bit\
    \ random number redrawn for each unit MUST be\n   prepended to the unit before\
    \ encryption.  For RTP, no prefix is\n   prepended; instead, the sequence number\
    \ and timestamp fields are\n   initialized with random offsets.  This is considered\
    \ to be a weak\n   initialization vector (IV) because of poor randomness properties.\
    \  In\n   addition, if the subsequent field, the SSRC, can be manipulated by an\n\
    \   enemy, there is further weakness of the encryption method.\n   For RTCP, an\
    \ implementation MAY segregate the individual RTCP packets\n   in a compound RTCP\
    \ packet into two separate compound RTCP packets,\n   one to be encrypted and\
    \ one to be sent in the clear.  For example,\n   SDES information might be encrypted\
    \ while reception reports were sent\n   in the clear to accommodate third-party\
    \ monitors that are not privy\n   to the encryption key.  In this example, depicted\
    \ in Fig. 4, the SDES\n   information MUST be appended to an RR packet with no\
    \ reports (and the\n   random number) to satisfy the requirement that all compound\
    \ RTCP\n   packets begin with an SR or RR packet.  The SDES CNAME item is\n  \
    \ required in either the encrypted or unencrypted packet, but not both.\n   The\
    \ same SDES information SHOULD NOT be carried in both packets as\n   this may\
    \ compromise the encryption.\n             UDP packet                     UDP\
    \ packet\n   -----------------------------  ------------------------------\n \
    \  [random][RR][SDES #CNAME ...]  [SR #senderinfo #site1 #site2]\n   -----------------------------\
    \  ------------------------------\n             encrypted                    \
    \ not encrypted\n   #: SSRC identifier\n       Figure 4: Encrypted and non-encrypted\
    \ RTCP packets\n   The presence of encryption and the use of the correct key are\n\
    \   confirmed by the receiver through header or payload validity checks.\n   Examples\
    \ of such validity checks for RTP and RTCP headers are given\n   in Appendices\
    \ A.1 and A.2.\n   To be consistent with existing implementations of the initial\n\
    \   specification of RTP in RFC 1889, the default encryption algorithm is\n  \
    \ the Data Encryption Standard (DES) algorithm in cipher block chaining\n   (CBC)\
    \ mode, as described in Section 1.1 of RFC 1423 [29], except that\n   padding\
    \ to a multiple of 8 octets is indicated as described for the P\n   bit in Section\
    \ 5.1.  The initialization vector is zero because random\n   values are supplied\
    \ in the RTP header or by the random prefix for\n   compound RTCP packets.  For\
    \ details on the use of CBC initialization\n   vectors, see [30].\n   Implementations\
    \ that support the encryption method specified here\n   SHOULD always support\
    \ the DES algorithm in CBC mode as the default\n   cipher for this method to maximize\
    \ interoperability.  This method was\n   chosen because it has been demonstrated\
    \ to be easy and practical to\n   use in experimental audio and video tools in\
    \ operation on the\n   Internet.  However, DES has since been found to be too\
    \ easily broken.\n   It is RECOMMENDED that stronger encryption algorithms such\
    \ as\n   Triple-DES be used in place of the default algorithm.  Furthermore,\n\
    \   secure CBC mode requires that the first block of each packet be XORed\n  \
    \ with a random, independent IV of the same size as the cipher's block\n   size.\
    \  For RTCP, this is (partially) achieved by prepending each\n   packet with a\
    \ 32-bit random number, independently chosen for each\n   packet.  For RTP, the\
    \ timestamp and sequence number start from random\n   values, but consecutive\
    \ packets will not be independently randomized.\n   It should be noted that the\
    \ randomness in both cases (RTP and RTCP)\n   is limited.  High-security applications\
    \ SHOULD consider other, more\n   conventional, protection means.  Other encryption\
    \ algorithms MAY be\n   specified dynamically for a session by non-RTP means.\
    \  In particular,\n   the SRTP profile [28] based on AES is being developed to\
    \ take into\n   account known plaintext and CBC plaintext manipulation concerns,\
    \ and\n   will be the correct choice in the future.\n   As an alternative to encryption\
    \ at the IP level or at the RTP level\n   as described above, profiles MAY define\
    \ additional payload types for\n   encrypted encodings.  Those encodings MUST\
    \ specify how padding and\n   other aspects of the encryption are to be handled.\
    \  This method\n   allows encrypting only the data while leaving the headers in\
    \ the\n   clear for applications where that is desired.  It may be particularly\n\
    \   useful for hardware devices that will handle both decryption and\n   decoding.\
    \  It is also valuable for applications where link-level\n   compression of RTP\
    \ and lower-layer headers is desired and\n   confidentiality of the payload (but\
    \ not addresses) is sufficient\n   since encryption of the headers precludes compression.\n"
- title: 9.2 Authentication and Message Integrity
  contents:
  - "9.2 Authentication and Message Integrity\n   Authentication and message integrity\
    \ services are not defined at the\n   RTP level since these services would not\
    \ be directly feasible without\n   a key management infrastructure.  It is expected\
    \ that authentication\n   and integrity services will be provided by lower layer\
    \ protocols.\n"
- title: 10. Congestion Control
  contents:
  - "10. Congestion Control\n   All transport protocols used on the Internet need\
    \ to address\n   congestion control in some way [31].  RTP is not an exception,\
    \ but\n   because the data transported over RTP is often inelastic (generated\n\
    \   at a fixed or controlled rate), the means to control congestion in\n   RTP\
    \ may be quite different from those for other transport protocols\n   such as\
    \ TCP.  In one sense, inelasticity reduces the risk of\n   congestion because\
    \ the RTP stream will not expand to consume all\n   available bandwidth as a TCP\
    \ stream can.  However, inelasticity also\n   means that the RTP stream cannot\
    \ arbitrarily reduce its load on the\n   network to eliminate congestion when\
    \ it occurs.\n   Since RTP may be used for a wide variety of applications in many\n\
    \   different contexts, there is no single congestion control mechanism\n   that\
    \ will work for all.  Therefore, congestion control SHOULD be\n   defined in each\
    \ RTP profile as appropriate.  For some profiles, it\n   may be sufficient to\
    \ include an applicability statement restricting\n   the use of that profile to\
    \ environments where congestion is avoided\n   by engineering.  For other profiles,\
    \ specific methods such as data\n   rate adaptation based on RTCP feedback may\
    \ be required.\n"
- title: 11. RTP over Network and Transport Protocols
  contents:
  - "11. RTP over Network and Transport Protocols\n   This section describes issues\
    \ specific to carrying RTP packets within\n   particular network and transport\
    \ protocols.  The following rules\n   apply unless superseded by protocol-specific\
    \ definitions outside this\n   specification.\n   RTP relies on the underlying\
    \ protocol(s) to provide demultiplexing of\n   RTP data and RTCP control streams.\
    \  For UDP and similar protocols,\n   RTP SHOULD use an even destination port\
    \ number and the corresponding\n   RTCP stream SHOULD use the next higher (odd)\
    \ destination port number.\n   For applications that take a single port number\
    \ as a parameter and\n   derive the RTP and RTCP port pair from that number, if\
    \ an odd number\n   is supplied then the application SHOULD replace that number\
    \ with the\n   next lower (even) number to use as the base of the port pair. \
    \ For\n   applications in which the RTP and RTCP destination port numbers are\n\
    \   specified via explicit, separate parameters (using a signaling\n   protocol\
    \ or other means), the application MAY disregard the\n   restrictions that the\
    \ port numbers be even/odd and consecutive\n   although the use of an even/odd\
    \ port pair is still encouraged.  The\n   RTP and RTCP port numbers MUST NOT be\
    \ the same since RTP relies on\n   the port numbers to demultiplex the RTP data\
    \ and RTCP control\n   streams.\n   In a unicast session, both participants need\
    \ to identify a port pair\n   for receiving RTP and RTCP packets.  Both participants\
    \ MAY use the\n   same port pair.  A participant MUST NOT assume that the source\
    \ port\n   of the incoming RTP or RTCP packet can be used as the destination\n\
    \   port for outgoing RTP or RTCP packets.  When RTP data packets are\n   being\
    \ sent in both directions, each participant's RTCP SR packets\n   MUST be sent\
    \ to the port that the other participant has specified for\n   reception of RTCP.\
    \  The RTCP SR packets combine sender information\n   for the outgoing data plus\
    \ reception report information for the\n   incoming data.  If a side is not actively\
    \ sending data (see Section\n   6.4), an RTCP RR packet is sent instead.\n   It\
    \ is RECOMMENDED that layered encoding applications (see Section\n   2.4) use\
    \ a set of contiguous port numbers.  The port numbers MUST be\n   distinct because\
    \ of a widespread deficiency in existing operating\n   systems that prevents use\
    \ of the same port with multiple multicast\n   addresses, and for unicast, there\
    \ is only one permissible address.\n   Thus for layer n, the data port is P +\
    \ 2n, and the control port is P\n   + 2n + 1.  When IP multicast is used, the\
    \ addresses MUST also be\n   distinct because multicast routing and group membership\
    \ are managed\n   on an address granularity.  However, allocation of contiguous\
    \ IP\n   multicast addresses cannot be assumed because some groups may require\n\
    \   different scopes and may therefore be allocated from different\n   address\
    \ ranges.\n   The previous paragraph conflicts with the SDP specification, RFC\
    \ 2327\n   [15], which says that it is illegal for both multiple addresses and\n\
    \   multiple ports to be specified in the same session description\n   because\
    \ the association of addresses with ports could be ambiguous.\n   It is intended\
    \ that this restriction will be relaxed in a revision of\n   RFC 2327 to allow\
    \ an equal number of addresses and ports to be\n   specified with a one-to-one\
    \ mapping implied.\n   RTP data packets contain no length field or other delineation,\n\
    \   therefore RTP relies on the underlying protocol(s) to provide a\n   length\
    \ indication.  The maximum length of RTP packets is limited only\n   by the underlying\
    \ protocols.\n   If RTP packets are to be carried in an underlying protocol that\n\
    \   provides the abstraction of a continuous octet stream rather than\n   messages\
    \ (packets), an encapsulation of the RTP packets MUST be\n   defined to provide\
    \ a framing mechanism.  Framing is also needed if\n   the underlying protocol\
    \ may contain padding so that the extent of the\n   RTP payload cannot be determined.\
    \  The framing mechanism is not\n   defined here.\n   A profile MAY specify a\
    \ framing method to be used even when RTP is\n   carried in protocols that do\
    \ provide framing in order to allow\n   carrying several RTP packets in one lower-layer\
    \ protocol data unit,\n   such as a UDP packet.  Carrying several RTP packets\
    \ in one network or\n   transport packet reduces header overhead and may simplify\n\
    \   synchronization between different streams.\n"
- title: 12. Summary of Protocol Constants
  contents:
  - "12. Summary of Protocol Constants\n   This section contains a summary listing\
    \ of the constants defined in\n   this specification.\n   The RTP payload type\
    \ (PT) constants are defined in profiles rather\n   than this document.  However,\
    \ the octet of the RTP header which\n   contains the marker bit(s) and payload\
    \ type MUST avoid the reserved\n   values 200 and 201 (decimal) to distinguish\
    \ RTP packets from the RTCP\n   SR and RR packet types for the header validation\
    \ procedure described\n   in Appendix A.1.  For the standard definition of one\
    \ marker bit and a\n   7-bit payload type field as shown in this specification,\
    \ this\n   restriction means that payload types 72 and 73 are reserved.\n"
- title: 12.1 RTCP Packet Types
  contents:
  - "12.1 RTCP Packet Types\n   abbrev.  name                 value\n   SR       sender\
    \ report          200\n   RR       receiver report        201\n   SDES     source\
    \ description     202\n   BYE      goodbye                203\n   APP      application-defined\
    \    204\n   These type values were chosen in the range 200-204 for improved\n\
    \   header validity checking of RTCP packets compared to RTP packets or\n   other\
    \ unrelated packets.  When the RTCP packet type field is compared\n   to the corresponding\
    \ octet of the RTP header, this range corresponds\n   to the marker bit being\
    \ 1 (which it usually is not in data packets)\n   and to the high bit of the standard\
    \ payload type field being 1 (since\n   the static payload types are typically\
    \ defined in the low half).\n   This range was also chosen to be some distance\
    \ numerically from 0 and\n   255 since all-zeros and all-ones are common data\
    \ patterns.\n   Since all compound RTCP packets MUST begin with SR or RR, these\
    \ codes\n   were chosen as an even/odd pair to allow the RTCP validity check to\n\
    \   test the maximum number of bits with mask and value.\n   Additional RTCP packet\
    \ types may be registered through IANA (see\n   Section 15).\n"
- title: 12.2 SDES Types
  contents:
  - "12.2 SDES Types\n   abbrev.  name                            value\n   END  \
    \    end of SDES list                    0\n   CNAME    canonical name       \
    \               1\n   NAME     user name                           2\n   EMAIL\
    \    user's electronic mail address      3\n   PHONE    user's phone number  \
    \               4\n   LOC      geographic user location            5\n   TOOL\
    \     name of application or tool         6\n   NOTE     notice about the source\
    \             7\n   PRIV     private extensions                  8\n   Additional\
    \ SDES types may be registered through IANA (see Section\n   15).\n"
- title: 13.  RTP Profiles and Payload Format Specifications
  contents:
  - "13.  RTP Profiles and Payload Format Specifications\n   A complete specification\
    \ of RTP for a particular application will\n   require one or more companion documents\
    \ of two types described here:\n   profiles, and payload format specifications.\n\
    \   RTP may be used for a variety of applications with somewhat differing\n  \
    \ requirements.  The flexibility to adapt to those requirements is\n   provided\
    \ by allowing multiple choices in the main protocol\n   specification, then selecting\
    \ the appropriate choices or defining\n   extensions for a particular environment\
    \ and class of applications in\n   a separate profile document.  Typically an\
    \ application will operate\n   under only one profile in a particular RTP session,\
    \ so there is no\n   explicit indication within the RTP protocol itself as to\
    \ which\n   profile is in use.  A profile for audio and video applications may\
    \ be\n   found in the companion RFC 3551.  Profiles are typically titled \"RTP\n\
    \   Profile for ...\".\n   The second type of companion document is a payload\
    \ format\n   specification, which defines how a particular kind of payload data,\n\
    \   such as H.261 encoded video, should be carried in RTP.  These\n   documents\
    \ are typically titled \"RTP Payload Format for XYZ\n   Audio/Video Encoding\"\
    .  Payload formats may be useful under multiple\n   profiles and may therefore\
    \ be defined independently of any particular\n   profile.  The profile documents\
    \ are then responsible for assigning a\n   default mapping of that format to a\
    \ payload type value if needed.\n   Within this specification, the following items\
    \ have been identified\n   for possible definition within a profile, but this\
    \ list is not meant\n   to be exhaustive:\n   RTP data header: The octet in the\
    \ RTP data header that contains\n      the marker bit and payload type field MAY\
    \ be redefined by a\n      profile to suit different requirements, for example\
    \ with more or\n      fewer marker bits (Section 5.3, p. 18).\n   Payload types:\
    \ Assuming that a payload type field is included,\n      the profile will usually\
    \ define a set of payload formats (e.g.,\n      media encodings) and a default\
    \ static mapping of those formats to\n      payload type values.  Some of the\
    \ payload formats may be defined\n      by reference to separate payload format\
    \ specifications.  For each\n      payload type defined, the profile MUST specify\
    \ the RTP timestamp\n      clock rate to be used (Section 5.1, p. 14).\n   RTP\
    \ data header additions: Additional fields MAY be appended to\n      the fixed\
    \ RTP data header if some additional functionality is\n      required across the\
    \ profile's class of applications independent of\n      payload type (Section\
    \ 5.3, p. 18).\n   RTP data header extensions: The contents of the first 16 bits\
    \ of\n      the RTP data header extension structure MUST be defined if use of\n\
    \      that mechanism is to be allowed under the profile for\n      implementation-specific\
    \ extensions (Section 5.3.1, p. 18).\n   RTCP packet types: New application-class-specific\
    \ RTCP packet\n      types MAY be defined and registered with IANA.\n   RTCP report\
    \ interval: A profile SHOULD specify that the values\n      suggested in Section\
    \ 6.2 for the constants employed in the\n      calculation of the RTCP report\
    \ interval will be used.  Those are\n      the RTCP fraction of session bandwidth,\
    \ the minimum report\n      interval, and the bandwidth split between senders\
    \ and receivers.\n      A profile MAY specify alternate values if they have been\n\
    \      demonstrated to work in a scalable manner.\n   SR/RR extension: An extension\
    \ section MAY be defined for the\n      RTCP SR and RR packets if there is additional\
    \ information that\n      should be reported regularly about the sender or receivers\n\
    \      (Section 6.4.3, p. 42 and 43).\n   SDES use: The profile MAY specify the\
    \ relative priorities for\n      RTCP SDES items to be transmitted or excluded\
    \ entirely (Section\n      6.3.9); an alternate syntax or semantics for the CNAME\
    \ item\n      (Section 6.5.1); the format of the LOC item (Section 6.5.5); the\n\
    \      semantics and use of the NOTE item (Section 6.5.7); or new SDES\n     \
    \ item types to be registered with IANA.\n   Security: A profile MAY specify which\
    \ security services and\n      algorithms should be offered by applications, and\
    \ MAY provide\n      guidance as to their appropriate use (Section 9, p. 65).\n\
    \   String-to-key mapping: A profile MAY specify how a user-provided\n      password\
    \ or pass phrase is mapped into an encryption key.\n   Congestion: A profile SHOULD\
    \ specify the congestion control\n      behavior appropriate for that profile.\n\
    \   Underlying protocol: Use of a particular underlying network or\n      transport\
    \ layer protocol to carry RTP packets MAY be required.\n   Transport mapping:\
    \ A mapping of RTP and RTCP to transport-level\n      addresses, e.g., UDP ports,\
    \ other than the standard mapping\n      defined in Section 11, p. 68 may be specified.\n\
    \   Encapsulation: An encapsulation of RTP packets may be defined to\n      allow\
    \ multiple RTP data packets to be carried in one lower-layer\n      packet or\
    \ to provide framing over underlying protocols that do not\n      already do so\
    \ (Section 11, p. 69).\n   It is not expected that a new profile will be required\
    \ for every\n   application.  Within one application class, it would be better\
    \ to\n   extend an existing profile rather than make a new one in order to\n \
    \  facilitate interoperation among the applications since each will\n   typically\
    \ run under only one profile.  Simple extensions such as the\n   definition of\
    \ additional payload type values or RTCP packet types may\n   be accomplished\
    \ by registering them through IANA and publishing their\n   descriptions in an\
    \ addendum to the profile or in a payload format\n   specification.\n"
- title: 14. Security Considerations
  contents:
  - "14. Security Considerations\n   RTP suffers from the same security liabilities\
    \ as the underlying\n   protocols.  For example, an impostor can fake source or\
    \ destination\n   network addresses, or change the header or payload.  Within\
    \ RTCP, the\n   CNAME and NAME information may be used to impersonate another\n\
    \   participant.  In addition, RTP may be sent via IP multicast, which\n   provides\
    \ no direct means for a sender to know all the receivers of\n   the data sent\
    \ and therefore no measure of privacy.  Rightly or not,\n   users may be more\
    \ sensitive to privacy concerns with audio and video\n   communication than they\
    \ have been with more traditional forms of\n   network communication [33].  Therefore,\
    \ the use of security\n   mechanisms with RTP is important.  These mechanisms\
    \ are discussed in\n   Section 9.\n   RTP-level translators or mixers may be used\
    \ to allow RTP traffic to\n   reach hosts behind firewalls.  Appropriate firewall\
    \ security\n   principles and practices, which are beyond the scope of this\n\
    \   document, should be followed in the design and installation of these\n   devices\
    \ and in the admission of RTP applications for use behind the\n   firewall.\n"
- title: 15. IANA Considerations
  contents:
  - "15. IANA Considerations\n   Additional RTCP packet types and SDES item types\
    \ may be registered\n   through the Internet Assigned Numbers Authority (IANA).\
    \  Since these\n   number spaces are small, allowing unconstrained registration\
    \ of new\n   values would not be prudent.  To facilitate review of requests and\
    \ to\n   promote shared use of new types among multiple applications, requests\n\
    \   for registration of new values must be documented in an RFC or other\n   permanent\
    \ and readily available reference such as the product of\n   another cooperative\
    \ standards body (e.g., ITU-T).  Other requests may\n   also be accepted, under\
    \ the advice of a \"designated expert.\"\n   (Contact the IANA for the contact\
    \ information of the current expert.)\n   RTP profile specifications SHOULD register\
    \ with IANA a name for the\n   profile in the form \"RTP/xxx\", where xxx is a\
    \ short abbreviation of\n   the profile title.  These names are for use by higher-level\
    \ control\n   protocols, such as the Session Description Protocol (SDP), RFC 2327\n\
    \   [15], to refer to transport methods.\n"
- title: 16. Intellectual Property Rights Statement
  contents:
  - "16. Intellectual Property Rights Statement\n   The IETF takes no position regarding\
    \ the validity or scope of any\n   intellectual property or other rights that\
    \ might be claimed to\n   pertain to the implementation or use of the technology\
    \ described in\n   this document or the extent to which any license under such\
    \ rights\n   might or might not be available; neither does it represent that it\n\
    \   has made any effort to identify any such rights.  Information on the\n   IETF's\
    \ procedures with respect to rights in standards-track and\n   standards-related\
    \ documentation can be found in BCP-11.  Copies of\n   claims of rights made available\
    \ for publication and any assurances of\n   licenses to be made available, or\
    \ the result of an attempt made to\n   obtain a general license or permission\
    \ for the use of such\n   proprietary rights by implementors or users of this\
    \ specification can\n   be obtained from the IETF Secretariat.\n   The IETF invites\
    \ any interested party to bring to its attention any\n   copyrights, patents or\
    \ patent applications, or other proprietary\n   rights which may cover technology\
    \ that may be required to practice\n   this standard.  Please address the information\
    \ to the IETF Executive\n   Director.\n"
- title: 17.  Acknowledgments
  contents:
  - "17.  Acknowledgments\n   This memorandum is based on discussions within the IETF\
    \ Audio/Video\n   Transport working group chaired by Stephen Casner and Colin\
    \ Perkins.\n   The current protocol has its origins in the Network Voice Protocol\n\
    \   and the Packet Video Protocol (Danny Cohen and Randy Cole) and the\n   protocol\
    \ implemented by the vat application (Van Jacobson and Steve\n   McCanne).  Christian\
    \ Huitema provided ideas for the random identifier\n   generator.  Extensive analysis\
    \ and simulation of the timer\n   reconsideration algorithm was done by Jonathan\
    \ Rosenberg.  The\n   additions for layered encodings were specified by Michael\
    \ Speer and\n   Steve McCanne.\n"
- title: Appendix A - Algorithms
  contents:
  - "Appendix A - Algorithms\n   We provide examples of C code for aspects of RTP\
    \ sender and receiver\n   algorithms.  There may be other implementation methods\
    \ that are\n   faster in particular operating environments or have other advantages.\n\
    \   These implementation notes are for informational purposes only and\n   are\
    \ meant to clarify the RTP specification.\n   The following definitions are used\
    \ for all examples; for clarity and\n   brevity, the structure definitions are\
    \ only valid for 32-bit big-\n   endian (most significant octet first) architectures.\
    \  Bit fields are\n   assumed to be packed tightly in big-endian bit order, with\
    \ no\n   additional padding.  Modifications would be required to construct a\n\
    \   portable implementation.\n   /*\n    * rtp.h  --  RTP header file\n    */\n\
    \   #include <sys/types.h>\n   /*\n    * The type definitions below are valid\
    \ for 32-bit architectures and\n    * may have to be adjusted for 16- or 64-bit\
    \ architectures.\n    */\n   typedef unsigned char  u_int8;\n   typedef unsigned\
    \ short u_int16;\n   typedef unsigned int   u_int32;\n   typedef          short\
    \ int16;\n   /*\n    * Current protocol version.\n    */\n   #define RTP_VERSION\
    \    2\n   #define RTP_SEQ_MOD (1<<16)\n   #define RTP_MAX_SDES 255      /* maximum\
    \ text length for SDES */\n   typedef enum {\n       RTCP_SR   = 200,\n      \
    \ RTCP_RR   = 201,\n       RTCP_SDES = 202,\n       RTCP_BYE  = 203,\n       RTCP_APP\
    \  = 204\n   } rtcp_type_t;\n   typedef enum {\n       RTCP_SDES_END   = 0,\n\
    \       RTCP_SDES_CNAME = 1,\n       RTCP_SDES_NAME  = 2,\n       RTCP_SDES_EMAIL\
    \ = 3,\n       RTCP_SDES_PHONE = 4,\n       RTCP_SDES_LOC   = 5,\n       RTCP_SDES_TOOL\
    \  = 6,\n       RTCP_SDES_NOTE  = 7,\n       RTCP_SDES_PRIV  = 8\n   } rtcp_sdes_type_t;\n\
    \   /*\n    * RTP data header\n    */\n   typedef struct {\n       unsigned int\
    \ version:2;   /* protocol version */\n       unsigned int p:1;         /* padding\
    \ flag */\n       unsigned int x:1;         /* header extension flag */\n    \
    \   unsigned int cc:4;        /* CSRC count */\n       unsigned int m:1;     \
    \    /* marker bit */\n       unsigned int pt:7;        /* payload type */\n \
    \      unsigned int seq:16;      /* sequence number */\n       u_int32 ts;   \
    \            /* timestamp */\n       u_int32 ssrc;             /* synchronization\
    \ source */\n       u_int32 csrc[1];          /* optional CSRC list */\n   } rtp_hdr_t;\n\
    \   /*\n    * RTCP common header word\n    */\n   typedef struct {\n       unsigned\
    \ int version:2;   /* protocol version */\n       unsigned int p:1;         /*\
    \ padding flag */\n       unsigned int count:5;     /* varies by packet type */\n\
    \       unsigned int pt:8;        /* RTCP packet type */\n       u_int16 length;\
    \           /* pkt len in words, w/o this word */\n   } rtcp_common_t;\n   /*\n\
    \    * Big-endian mask for version, padding bit and packet type pair\n    */\n\
    \   #define RTCP_VALID_MASK (0xc000 | 0x2000 | 0xfe)\n   #define RTCP_VALID_VALUE\
    \ ((RTP_VERSION << 14) | RTCP_SR)\n   /*\n    * Reception report block\n    */\n\
    \   typedef struct {\n       u_int32 ssrc;             /* data source being reported\
    \ */\n       unsigned int fraction:8;  /* fraction lost since last SR/RR */\n\
    \       int lost:24;              /* cumul. no. pkts lost (signed!) */\n     \
    \  u_int32 last_seq;         /* extended last seq. no. received */\n       u_int32\
    \ jitter;           /* interarrival jitter */\n       u_int32 lsr;           \
    \   /* last SR packet from this source */\n       u_int32 dlsr;             /*\
    \ delay since last SR packet */\n   } rtcp_rr_t;\n   /*\n    * SDES item\n   \
    \ */\n   typedef struct {\n       u_int8 type;              /* type of item (rtcp_sdes_type_t)\
    \ */\n       u_int8 length;            /* length of item (in octets) */\n    \
    \   char data[1];             /* text, not null-terminated */\n   } rtcp_sdes_item_t;\n\
    \   /*\n    * One RTCP packet\n    */\n   typedef struct {\n       rtcp_common_t\
    \ common;     /* common header */\n       union {\n           /* sender report\
    \ (SR) */\n           struct {\n               u_int32 ssrc;     /* sender generating\
    \ this report */\n               u_int32 ntp_sec;  /* NTP timestamp */\n     \
    \          u_int32 ntp_frac;\n               u_int32 rtp_ts;   /* RTP timestamp\
    \ */\n               u_int32 psent;    /* packets sent */\n               u_int32\
    \ osent;    /* octets sent */\n               rtcp_rr_t rr[1];  /* variable-length\
    \ list */\n           } sr;\n           /* reception report (RR) */\n        \
    \   struct {\n               u_int32 ssrc;     /* receiver generating this report\
    \ */\n               rtcp_rr_t rr[1];  /* variable-length list */\n          \
    \ } rr;\n           /* source description (SDES) */\n           struct rtcp_sdes\
    \ {\n               u_int32 src;      /* first SSRC/CSRC */\n               rtcp_sdes_item_t\
    \ item[1]; /* list of SDES items */\n           } sdes;\n           /* BYE */\n\
    \           struct {\n               u_int32 src[1];   /* list of sources */\n\
    \               /* can't express trailing text for reason */\n           } bye;\n\
    \       } r;\n   } rtcp_t;\n   typedef struct rtcp_sdes rtcp_sdes_t;\n   /*\n\
    \    * Per-source state information\n    */\n   typedef struct {\n       u_int16\
    \ max_seq;        /* highest seq. number seen */\n       u_int32 cycles;     \
    \    /* shifted count of seq. number cycles */\n       u_int32 base_seq;     \
    \  /* base seq number */\n       u_int32 bad_seq;        /* last 'bad' seq number\
    \ + 1 */\n       u_int32 probation;      /* sequ. packets till source is valid\
    \ */\n       u_int32 received;       /* packets received */\n       u_int32 expected_prior;\
    \ /* packet expected at last interval */\n       u_int32 received_prior; /* packet\
    \ received at last interval */\n       u_int32 transit;        /* relative trans\
    \ time for prev pkt */\n       u_int32 jitter;         /* estimated jitter */\n\
    \       /* ... */\n   } source;\n"
- title: A.1 RTP Data Header Validity Checks
  contents:
  - "A.1 RTP Data Header Validity Checks\n   An RTP receiver should check the validity\
    \ of the RTP header on\n   incoming packets since they might be encrypted or might\
    \ be from a\n   different application that happens to be misaddressed.  Similarly,\
    \ if\n   encryption according to the method described in Section 9 is enabled,\n\
    \   the header validity check is needed to verify that incoming packets\n   have\
    \ been correctly decrypted, although a failure of the header\n   validity check\
    \ (e.g., unknown payload type) may not necessarily\n   indicate decryption failure.\n\
    \   Only weak validity checks are possible on an RTP data packet from a\n   source\
    \ that has not been heard before:\n   o  RTP version field must equal 2.\n   o\
    \  The payload type must be known, and in particular it must not be\n      equal\
    \ to SR or RR.\n   o  If the P bit is set, then the last octet of the packet must\n\
    \      contain a valid octet count, in particular, less than the total\n     \
    \ packet length minus the header size.\n   o  The X bit must be zero if the profile\
    \ does not specify that the\n      header extension mechanism may be used.  Otherwise,\
    \ the extension\n      length field must be less than the total packet size minus\
    \ the\n      fixed header length and padding.\n   o  The length of the packet\
    \ must be consistent with CC and payload\n      type (if payloads have a known\
    \ length).\n   The last three checks are somewhat complex and not always possible,\n\
    \   leaving only the first two which total just a few bits.  If the SSRC\n   identifier\
    \ in the packet is one that has been received before, then\n   the packet is probably\
    \ valid and checking if the sequence number is\n   in the expected range provides\
    \ further validation.  If the SSRC\n   identifier has not been seen before, then\
    \ data packets carrying that\n   identifier may be considered invalid until a\
    \ small number of them\n   arrive with consecutive sequence numbers.  Those invalid\
    \ packets MAY\n   be discarded or they MAY be stored and delivered once validation\
    \ has\n   been achieved if the resulting delay is acceptable.\n   The routine\
    \ update_seq shown below ensures that a source is declared\n   valid only after\
    \ MIN_SEQUENTIAL packets have been received in\n   sequence.  It also validates\
    \ the sequence number seq of a newly\n   received packet and updates the sequence\
    \ state for the packet's\n   source in the structure to which s points.\n   When\
    \ a new source is heard for the first time, that is, its SSRC\n   identifier is\
    \ not in the table (see Section 8.2), and the per-source\n   state is allocated\
    \ for it, s->probation is set to the number of\n   sequential packets required\
    \ before declaring a source valid\n   (parameter MIN_SEQUENTIAL) and other variables\
    \ are initialized:\n      init_seq(s, seq);\n      s->max_seq = seq - 1;\n   \
    \   s->probation = MIN_SEQUENTIAL;\n   A non-zero s->probation marks the source\
    \ as not yet valid so the\n   state may be discarded after a short timeout rather\
    \ than a long one,\n   as discussed in Section 6.2.1.\n   After a source is considered\
    \ valid, the sequence number is considered\n   valid if it is no more than MAX_DROPOUT\
    \ ahead of s->max_seq nor more\n   than MAX_MISORDER behind.  If the new sequence\
    \ number is ahead of\n   max_seq modulo the RTP sequence number range (16 bits),\
    \ but is\n   smaller than max_seq, it has wrapped around and the (shifted) count\n\
    \   of sequence number cycles is incremented.  A value of one is returned\n  \
    \ to indicate a valid sequence number.\n   Otherwise, the value zero is returned\
    \ to indicate that the validation\n   failed, and the bad sequence number plus\
    \ 1 is stored.  If the next\n   packet received carries the next higher sequence\
    \ number, it is\n   considered the valid start of a new packet sequence presumably\
    \ caused\n   by an extended dropout or a source restart.  Since multiple complete\n\
    \   sequence number cycles may have been missed, the packet loss\n   statistics\
    \ are reset.\n   Typical values for the parameters are shown, based on a maximum\n\
    \   misordering time of 2 seconds at 50 packets/second and a maximum\n   dropout\
    \ of 1 minute.  The dropout parameter MAX_DROPOUT should be a\n   small fraction\
    \ of the 16-bit sequence number space to give a\n   reasonable probability that\
    \ new sequence numbers after a restart will\n   not fall in the acceptable range\
    \ for sequence numbers from before the\n   restart.\n   void init_seq(source *s,\
    \ u_int16 seq)\n   {\n       s->base_seq = seq;\n       s->max_seq = seq;\n  \
    \     s->bad_seq = RTP_SEQ_MOD + 1;   /* so seq == bad_seq is false */\n     \
    \  s->cycles = 0;\n       s->received = 0;\n       s->received_prior = 0;\n  \
    \     s->expected_prior = 0;\n       /* other initialization */\n   }\n   int\
    \ update_seq(source *s, u_int16 seq)\n   {\n       u_int16 udelta = seq - s->max_seq;\n\
    \       const int MAX_DROPOUT = 3000;\n       const int MAX_MISORDER = 100;\n\
    \       const int MIN_SEQUENTIAL = 2;\n       /*\n        * Source is not valid\
    \ until MIN_SEQUENTIAL packets with\n        * sequential sequence numbers have\
    \ been received.\n        */\n       if (s->probation) {\n           /* packet\
    \ is in sequence */\n           if (seq == s->max_seq + 1) {\n               s->probation--;\n\
    \               s->max_seq = seq;\n               if (s->probation == 0) {\n \
    \                  init_seq(s, seq);\n                   s->received++;\n    \
    \               return 1;\n               }\n           } else {\n           \
    \    s->probation = MIN_SEQUENTIAL - 1;\n               s->max_seq = seq;\n  \
    \         }\n           return 0;\n       } else if (udelta < MAX_DROPOUT) {\n\
    \           /* in order, with permissible gap */\n           if (seq < s->max_seq)\
    \ {\n               /*\n                * Sequence number wrapped - count another\
    \ 64K cycle.\n                */\n               s->cycles += RTP_SEQ_MOD;\n \
    \          }\n           s->max_seq = seq;\n       } else if (udelta <= RTP_SEQ_MOD\
    \ - MAX_MISORDER) {\n           /* the sequence number made a very large jump\
    \ */\n           if (seq == s->bad_seq) {\n               /*\n               \
    \ * Two sequential packets -- assume that the other side\n                * restarted\
    \ without telling us so just re-sync\n                * (i.e., pretend this was\
    \ the first packet).\n                */\n               init_seq(s, seq);\n \
    \          }\n           else {\n               s->bad_seq = (seq + 1) & (RTP_SEQ_MOD-1);\n\
    \               return 0;\n           }\n       } else {\n           /* duplicate\
    \ or reordered packet */\n       }\n       s->received++;\n       return 1;\n\
    \   }\n   The validity check can be made stronger requiring more than two\n  \
    \ packets in sequence.  The disadvantages are that a larger number of\n   initial\
    \ packets will be discarded (or delayed in a queue) and that\n   high packet loss\
    \ rates could prevent validation.  However, because\n   the RTCP header validation\
    \ is relatively strong, if an RTCP packet is\n   received from a source before\
    \ the data packets, the count could be\n   adjusted so that only two packets are\
    \ required in sequence.  If\n   initial data loss for a few seconds can be tolerated,\
    \ an application\n   MAY choose to discard all data packets from a source until\
    \ a valid\n   RTCP packet has been received from that source.\n   Depending on\
    \ the application and encoding, algorithms may exploit\n   additional knowledge\
    \ about the payload format for further validation.\n   For payload types where\
    \ the timestamp increment is the same for all\n   packets, the timestamp values\
    \ can be predicted from the previous\n   packet received from the same source\
    \ using the sequence number\n   difference (assuming no change in payload type).\n\
    \   A strong \"fast-path\" check is possible since with high probability\n   the\
    \ first four octets in the header of a newly received RTP data\n   packet will\
    \ be just the same as that of the previous packet from the\n   same SSRC except\
    \ that the sequence number will have increased by one.\n   Similarly, a single-entry\
    \ cache may be used for faster SSRC lookups\n   in applications where data is\
    \ typically received from one source at a\n   time.\n"
- title: A.2 RTCP Header Validity Checks
  contents:
  - "A.2 RTCP Header Validity Checks\n   The following checks should be applied to\
    \ RTCP packets.\n   o  RTP version field must equal 2.\n   o  The payload type\
    \ field of the first RTCP packet in a compound\n      packet must be equal to\
    \ SR or RR.\n   o  The padding bit (P) should be zero for the first packet of\
    \ a\n      compound RTCP packet because padding should only be applied, if it\n\
    \      is needed, to the last packet.\n   o  The length fields of the individual\
    \ RTCP packets must add up to\n      the overall length of the compound RTCP packet\
    \ as received.  This\n      is a fairly strong check.\n   The code fragment below\
    \ performs all of these checks.  The packet\n   type is not checked for subsequent\
    \ packets since unknown packet types\n   may be present and should be ignored.\n\
    \      u_int32 len;        /* length of compound RTCP packet in words */\n   \
    \   rtcp_t *r;          /* RTCP header */\n      rtcp_t *end;        /* end of\
    \ compound RTCP packet */\n      if ((*(u_int16 *)r & RTCP_VALID_MASK) != RTCP_VALID_VALUE)\
    \ {\n          /* something wrong with packet format */\n      }\n      end =\
    \ (rtcp_t *)((u_int32 *)r + len);\n      do r = (rtcp_t *)((u_int32 *)r + r->common.length\
    \ + 1);\n      while (r < end && r->common.version == 2);\n      if (r != end)\
    \ {\n          /* something wrong with packet format */\n      }\n"
- title: A.3 Determining Number of Packets Expected and Lost
  contents:
  - "A.3 Determining Number of Packets Expected and Lost\n   In order to compute packet\
    \ loss rates, the number of RTP packets\n   expected and actually received from\
    \ each source needs to be known,\n   using per-source state information defined\
    \ in struct source\n   referenced via pointer s in the code below.  The number\
    \ of packets\n   received is simply the count of packets as they arrive, including\
    \ any\n   late or duplicate packets.  The number of packets expected can be\n\
    \   computed by the receiver as the difference between the highest\n   sequence\
    \ number received (s->max_seq) and the first sequence number\n   received (s->base_seq).\
    \  Since the sequence number is only 16 bits\n   and will wrap around, it is necessary\
    \ to extend the highest sequence\n   number with the (shifted) count of sequence\
    \ number wraparounds\n   (s->cycles).  Both the received packet count and the\
    \ count of cycles\n   are maintained the RTP header validity check routine in\
    \ Appendix A.1.\n      extended_max = s->cycles + s->max_seq;\n      expected\
    \ = extended_max - s->base_seq + 1;\n   The number of packets lost is defined\
    \ to be the number of packets\n   expected less the number of packets actually\
    \ received:\n      lost = expected - s->received;\n   Since this signed number\
    \ is carried in 24 bits, it should be clamped\n   at 0x7fffff for positive loss\
    \ or 0x800000 for negative loss rather\n   than wrapping around.\n   The fraction\
    \ of packets lost during the last reporting interval\n   (since the previous SR\
    \ or RR packet was sent) is calculated from\n   differences in the expected and\
    \ received packet counts across the\n   interval, where expected_prior and received_prior\
    \ are the values\n   saved when the previous reception report was generated:\n\
    \      expected_interval = expected - s->expected_prior;\n      s->expected_prior\
    \ = expected;\n      received_interval = s->received - s->received_prior;\n  \
    \    s->received_prior = s->received;\n      lost_interval = expected_interval\
    \ - received_interval;\n      if (expected_interval == 0 || lost_interval <= 0)\
    \ fraction = 0;\n      else fraction = (lost_interval << 8) / expected_interval;\n\
    \   The resulting fraction is an 8-bit fixed point number with the binary\n  \
    \ point at the left edge.\n"
- title: A.4 Generating RTCP SDES Packets
  contents:
  - "A.4 Generating RTCP SDES Packets\n   This function builds one SDES chunk into\
    \ buffer b composed of argc\n   items supplied in arrays type, value and length.\
    \  It returns a\n   pointer to the next available location within b.\n   char\
    \ *rtp_write_sdes(char *b, u_int32 src, int argc,\n                        rtcp_sdes_type_t\
    \ type[], char *value[],\n                        int length[])\n   {\n      \
    \ rtcp_sdes_t *s = (rtcp_sdes_t *)b;\n       rtcp_sdes_item_t *rsp;\n       int\
    \ i;\n       int len;\n       int pad;\n       /* SSRC header */\n       s->src\
    \ = src;\n       rsp = &s->item[0];\n       /* SDES items */\n       for (i =\
    \ 0; i < argc; i++) {\n           rsp->type = type[i];\n           len = length[i];\n\
    \           if (len > RTP_MAX_SDES) {\n               /* invalid length, may want\
    \ to take other action */\n               len = RTP_MAX_SDES;\n           }\n\
    \           rsp->length = len;\n           memcpy(rsp->data, value[i], len);\n\
    \           rsp = (rtcp_sdes_item_t *)&rsp->data[len];\n       }\n       /* terminate\
    \ with end marker and pad to next 4-octet boundary */\n       len = ((char *)\
    \ rsp) - b;\n       pad = 4 - (len & 0x3);\n       b = (char *) rsp;\n       while\
    \ (pad--) *b++ = RTCP_SDES_END;\n       return b;\n   }\n"
- title: A.5 Parsing RTCP SDES Packets
  contents:
  - "A.5 Parsing RTCP SDES Packets\n   This function parses an SDES packet, calling\
    \ functions find_member()\n   to find a pointer to the information for a session\
    \ member given the\n   SSRC identifier and member_sdes() to store the new SDES\
    \ information\n   for that member.  This function expects a pointer to the header\
    \ of\n   the RTCP packet.\n   void rtp_read_sdes(rtcp_t *r)\n   {\n       int\
    \ count = r->common.count;\n       rtcp_sdes_t *sd = &r->r.sdes;\n       rtcp_sdes_item_t\
    \ *rsp, *rspn;\n       rtcp_sdes_item_t *end = (rtcp_sdes_item_t *)\n        \
    \                       ((u_int32 *)r + r->common.length + 1);\n       source\
    \ *s;\n       while (--count >= 0) {\n           rsp = &sd->item[0];\n       \
    \    if (rsp >= end) break;\n           s = find_member(sd->src);\n          \
    \ for (; rsp->type; rsp = rspn ) {\n               rspn = (rtcp_sdes_item_t *)((char*)rsp+rsp->length+2);\n\
    \               if (rspn >= end) {\n                   rsp = rspn;\n         \
    \          break;\n               }\n               member_sdes(s, rsp->type,\
    \ rsp->data, rsp->length);\n           }\n           sd = (rtcp_sdes_t *)\n  \
    \              ((u_int32 *)sd + (((char *)rsp - (char *)sd) >> 2)+1);\n      \
    \ }\n       if (count >= 0) {\n           /* invalid packet format */\n      \
    \ }\n   }\n"
- title: A.6 Generating a Random 32-bit Identifier
  contents:
  - "A.6 Generating a Random 32-bit Identifier\n   The following subroutine generates\
    \ a random 32-bit identifier using\n   the MD5 routines published in RFC 1321\
    \ [32].  The system routines may\n   not be present on all operating systems,\
    \ but they should serve as\n   hints as to what kinds of information may be used.\
    \  Other system\n   calls that may be appropriate include\n   o  getdomainname(),\n\
    \   o  getwd(), or\n   o  getrusage().\n   \"Live\" video or audio samples are\
    \ also a good source of random\n   numbers, but care must be taken to avoid using\
    \ a turned-off\n   microphone or blinded camera as a source [17].\n   Use of this\
    \ or a similar routine is recommended to generate the\n   initial seed for the\
    \ random number generator producing the RTCP\n   period (as shown in Appendix\
    \ A.7), to generate the initial values for\n   the sequence number and timestamp,\
    \ and to generate SSRC values.\n   Since this routine is likely to be CPU-intensive,\
    \ its direct use to\n   generate RTCP periods is inappropriate because predictability\
    \ is not\n   an issue.  Note that this routine produces the same result on\n \
    \  repeated calls until the value of the system clock changes unless\n   different\
    \ values are supplied for the type argument.\n   /*\n    * Generate a random 32-bit\
    \ quantity.\n    */\n   #include <sys/types.h>   /* u_long */\n   #include <sys/time.h>\
    \    /* gettimeofday() */\n   #include <unistd.h>      /* get..() */\n   #include\
    \ <stdio.h>       /* printf() */\n   #include <time.h>        /* clock() */\n\
    \   #include <sys/utsname.h> /* uname() */\n   #include \"global.h\"      /* from\
    \ RFC 1321 */\n   #include \"md5.h\"         /* from RFC 1321 */\n   #define MD_CTX\
    \ MD5_CTX\n   #define MDInit MD5Init\n   #define MDUpdate MD5Update\n   #define\
    \ MDFinal MD5Final\n   static u_long md_32(char *string, int length)\n   {\n \
    \      MD_CTX context;\n       union {\n           char   c[16];\n           u_long\
    \ x[4];\n       } digest;\n       u_long r;\n       int i;\n       MDInit (&context);\n\
    \       MDUpdate (&context, string, length);\n       MDFinal ((unsigned char *)&digest,\
    \ &context);\n       r = 0;\n       for (i = 0; i < 3; i++) {\n           r ^=\
    \ digest.x[i];\n       }\n       return r;\n   }                             \
    \  /* md_32 */\n   /*\n    * Return random unsigned 32-bit quantity.  Use 'type'\
    \ argument if\n    * you need to generate several different values in close succession.\n\
    \    */\n   u_int32 random32(int type)\n   {\n       struct {\n           int\
    \     type;\n           struct  timeval tv;\n           clock_t cpu;\n       \
    \    pid_t   pid;\n           u_long  hid;\n           uid_t   uid;\n        \
    \   gid_t   gid;\n           struct  utsname name;\n       } s;\n       gettimeofday(&s.tv,\
    \ 0);\n       uname(&s.name);\n       s.type = type;\n       s.cpu  = clock();\n\
    \       s.pid  = getpid();\n       s.hid  = gethostid();\n       s.uid  = getuid();\n\
    \       s.gid  = getgid();\n       /* also: system uptime */\n       return md_32((char\
    \ *)&s, sizeof(s));\n   }                               /* random32 */\n"
- title: A.7 Computing the RTCP Transmission Interval
  contents:
  - "A.7 Computing the RTCP Transmission Interval\n   The following functions implement\
    \ the RTCP transmission and reception\n   rules described in Section 6.2.  These\
    \ rules are coded in several\n   functions:\n   o  rtcp_interval() computes the\
    \ deterministic calculated interval,\n      measured in seconds.  The parameters\
    \ are defined in Section 6.3.\n   o  OnExpire() is called when the RTCP transmission\
    \ timer expires.\n   o  OnReceive() is called whenever an RTCP packet is received.\n\
    \   Both OnExpire() and OnReceive() have event e as an argument.  This is\n  \
    \ the next scheduled event for that participant, either an RTCP report\n   or\
    \ a BYE packet.  It is assumed that the following functions are\n   available:\n\
    \   o  Schedule(time t, event e) schedules an event e to occur at time t.\n  \
    \    When time t arrives, the function OnExpire is called with e as an\n     \
    \ argument.\n   o  Reschedule(time t, event e) reschedules a previously scheduled\n\
    \      event e for time t.\n   o  SendRTCPReport(event e) sends an RTCP report.\n\
    \   o  SendBYEPacket(event e) sends a BYE packet.\n   o  TypeOfEvent(event e)\
    \ returns EVENT_BYE if the event being\n      processed is for a BYE packet to\
    \ be sent, else it returns\n      EVENT_REPORT.\n   o  PacketType(p) returns PACKET_RTCP_REPORT\
    \ if packet p is an RTCP\n      report (not BYE), PACKET_BYE if its a BYE RTCP\
    \ packet, and\n      PACKET_RTP if its a regular RTP data packet.\n   o  ReceivedPacketSize()\
    \ and SentPacketSize() return the size of the\n      referenced packet in octets.\n\
    \   o  NewMember(p) returns a 1 if the participant who sent packet p is\n    \
    \  not currently in the member list, 0 otherwise.  Note this function\n      is\
    \ not sufficient for a complete implementation because each CSRC\n      identifier\
    \ in an RTP packet and each SSRC in a BYE packet should\n      be processed.\n\
    \   o  NewSender(p) returns a 1 if the participant who sent packet p is\n    \
    \  not currently in the sender sublist of the member list, 0\n      otherwise.\n\
    \   o  AddMember() and RemoveMember() to add and remove participants from\n  \
    \    the member list.\n   o  AddSender() and RemoveSender() to add and remove\
    \ participants from\n      the sender sublist of the member list.\n   These functions\
    \ would have to be extended for an implementation that\n   allows the RTCP bandwidth\
    \ fractions for senders and non-senders to be\n   specified as explicit parameters\
    \ rather than fixed values of 25% and\n   75%.  The extended implementation of\
    \ rtcp_interval() would need to\n   avoid division by zero if one of the parameters\
    \ was zero.\n   double rtcp_interval(int members,\n                        int\
    \ senders,\n                        double rtcp_bw,\n                        int\
    \ we_sent,\n                        double avg_rtcp_size,\n                  \
    \      int initial)\n   {\n       /*\n        * Minimum average time between RTCP\
    \ packets from this site (in\n        * seconds).  This time prevents the reports\
    \ from `clumping' when\n        * sessions are small and the law of large numbers\
    \ isn't helping\n        * to smooth out the traffic.  It also keeps the report\
    \ interval\n        * from becoming ridiculously small during transient outages\
    \ like\n        * a network partition.\n        */\n       double const RTCP_MIN_TIME\
    \ = 5.;\n       /*\n        * Fraction of the RTCP bandwidth to be shared among\
    \ active\n        * senders.  (This fraction was chosen so that in a typical\n\
    \        * session with one or two active senders, the computed report\n     \
    \   * time would be roughly equal to the minimum report time so that\n       \
    \ * we don't unnecessarily slow down receiver reports.)  The\n        * receiver\
    \ fraction must be 1 - the sender fraction.\n        */\n       double const RTCP_SENDER_BW_FRACTION\
    \ = 0.25;\n       double const RTCP_RCVR_BW_FRACTION = (1-RTCP_SENDER_BW_FRACTION);\n\
    \       /*\n       /* To compensate for \"timer reconsideration\" converging to\
    \ a\n        * value below the intended average.\n        */\n       double const\
    \ COMPENSATION = 2.71828 - 1.5;\n       double t;                   /* interval\
    \ */\n       double rtcp_min_time = RTCP_MIN_TIME;\n       int n;            \
    \          /* no. of members for computation */\n       /*\n        * Very first\
    \ call at application start-up uses half the min\n        * delay for quicker\
    \ notification while still allowing some time\n        * before reporting for\
    \ randomization and to learn about other\n        * sources so the report interval\
    \ will converge to the correct\n        * interval more quickly.\n        */\n\
    \       if (initial) {\n           rtcp_min_time /= 2;\n       }\n       /*\n\
    \        * Dedicate a fraction of the RTCP bandwidth to senders unless\n     \
    \   * the number of senders is large enough that their share is\n        * more\
    \ than that fraction.\n        */\n       n = members;\n       if (senders <=\
    \ members * RTCP_SENDER_BW_FRACTION) {\n           if (we_sent) {\n          \
    \     rtcp_bw *= RTCP_SENDER_BW_FRACTION;\n               n = senders;\n     \
    \      } else {\n               rtcp_bw *= RTCP_RCVR_BW_FRACTION;\n          \
    \     n -= senders;\n           }\n       }\n       /*\n        * The effective\
    \ number of sites times the average packet size is\n        * the total number\
    \ of octets sent when each site sends a report.\n        * Dividing this by the\
    \ effective bandwidth gives the time\n        * interval over which those packets\
    \ must be sent in order to\n        * meet the bandwidth target, with a minimum\
    \ enforced.  In that\n        * time interval we send one report so this time\
    \ is also our\n        * average time between reports.\n        */\n       t =\
    \ avg_rtcp_size * n / rtcp_bw;\n       if (t < rtcp_min_time) t = rtcp_min_time;\n\
    \       /*\n        * To avoid traffic bursts from unintended synchronization\
    \ with\n        * other sites, we then pick our actual next report interval as\
    \ a\n        * random number uniformly distributed between 0.5*t and 1.5*t.\n\
    \        */\n       t = t * (drand48() + 0.5);\n       t = t / COMPENSATION;\n\
    \       return t;\n   }\n   void OnExpire(event e,\n                 int    members,\n\
    \                 int    senders,\n                 double rtcp_bw,\n        \
    \         int    we_sent,\n                 double *avg_rtcp_size,\n         \
    \        int    *initial,\n                 time_tp   tc,\n                 time_tp\
    \   *tp,\n                 int    *pmembers)\n   {\n       /* This function is\
    \ responsible for deciding whether to send an\n        * RTCP report or BYE packet\
    \ now, or to reschedule transmission.\n        * It is also responsible for updating\
    \ the pmembers, initial, tp,\n        * and avg_rtcp_size state variables.  This\
    \ function should be\n        * called upon expiration of the event timer used\
    \ by Schedule().\n        */\n       double t;     /* Interval */\n       double\
    \ tn;    /* Next transmit time */\n       /* In the case of a BYE, we use \"timer\
    \ reconsideration\" to\n        * reschedule the transmission of the BYE if necessary\
    \ */\n       if (TypeOfEvent(e) == EVENT_BYE) {\n           t = rtcp_interval(members,\n\
    \                             senders,\n                             rtcp_bw,\n\
    \                             we_sent,\n                             *avg_rtcp_size,\n\
    \                             *initial);\n           tn = *tp + t;\n         \
    \  if (tn <= tc) {\n               SendBYEPacket(e);\n               exit(1);\n\
    \           } else {\n               Schedule(tn, e);\n           }\n       }\
    \ else if (TypeOfEvent(e) == EVENT_REPORT) {\n           t = rtcp_interval(members,\n\
    \                             senders,\n                             rtcp_bw,\n\
    \                             we_sent,\n                             *avg_rtcp_size,\n\
    \                             *initial);\n           tn = *tp + t;\n         \
    \  if (tn <= tc) {\n               SendRTCPReport(e);\n               *avg_rtcp_size\
    \ = (1./16.)*SentPacketSize(e) +\n                   (15./16.)*(*avg_rtcp_size);\n\
    \               *tp = tc;\n               /* We must redraw the interval.  Don't\
    \ reuse the\n                  one computed above, since its not actually\n  \
    \                distributed the same, as we are conditioned\n               \
    \   on it being small enough to cause a packet to\n                  be sent */\n\
    \               t = rtcp_interval(members,\n                                 senders,\n\
    \                                 rtcp_bw,\n                                 we_sent,\n\
    \                                 *avg_rtcp_size,\n                          \
    \       *initial);\n               Schedule(t+tc,e);\n               *initial\
    \ = 0;\n           } else {\n               Schedule(tn, e);\n           }\n \
    \          *pmembers = members;\n       }\n   }\n   void OnReceive(packet p,\n\
    \                  event e,\n                  int *members,\n               \
    \   int *pmembers,\n                  int *senders,\n                  double\
    \ *avg_rtcp_size,\n                  double *tp,\n                  double tc,\n\
    \                  double tn)\n   {\n       /* What we do depends on whether we\
    \ have left the group, and are\n        * waiting to send a BYE (TypeOfEvent(e)\
    \ == EVENT_BYE) or an RTCP\n        * report.  p represents the packet that was\
    \ just received.  */\n       if (PacketType(p) == PACKET_RTCP_REPORT) {\n    \
    \       if (NewMember(p) && (TypeOfEvent(e) == EVENT_REPORT)) {\n            \
    \   AddMember(p);\n               *members += 1;\n           }\n           *avg_rtcp_size\
    \ = (1./16.)*ReceivedPacketSize(p) +\n               (15./16.)*(*avg_rtcp_size);\n\
    \       } else if (PacketType(p) == PACKET_RTP) {\n           if (NewMember(p)\
    \ && (TypeOfEvent(e) == EVENT_REPORT)) {\n               AddMember(p);\n     \
    \          *members += 1;\n           }\n           if (NewSender(p) && (TypeOfEvent(e)\
    \ == EVENT_REPORT)) {\n               AddSender(p);\n               *senders +=\
    \ 1;\n           }\n       } else if (PacketType(p) == PACKET_BYE) {\n       \
    \    *avg_rtcp_size = (1./16.)*ReceivedPacketSize(p) +\n               (15./16.)*(*avg_rtcp_size);\n\
    \           if (TypeOfEvent(e) == EVENT_REPORT) {\n               if (NewSender(p)\
    \ == FALSE) {\n                   RemoveSender(p);\n                   *senders\
    \ -= 1;\n               }\n               if (NewMember(p) == FALSE) {\n     \
    \              RemoveMember(p);\n                   *members -= 1;\n         \
    \      }\n               if (*members < *pmembers) {\n                   tn =\
    \ tc +\n                       (((double) *members)/(*pmembers))*(tn - tc);\n\
    \                   *tp = tc -\n                       (((double) *members)/(*pmembers))*(tc\
    \ - *tp);\n                   /* Reschedule the next report for time tn */\n \
    \                  Reschedule(tn, e);\n                   *pmembers = *members;\n\
    \               }\n           } else if (TypeOfEvent(e) == EVENT_BYE) {\n    \
    \           *members += 1;\n           }\n       }\n   }\n"
- title: A.8 Estimating the Interarrival Jitter
  contents:
  - "A.8 Estimating the Interarrival Jitter\n   The code fragments below implement\
    \ the algorithm given in Section\n   6.4.1 for calculating an estimate of the\
    \ statistical variance of the\n   RTP data interarrival time to be inserted in\
    \ the interarrival jitter\n   field of reception reports.  The inputs are r->ts,\
    \ the timestamp from\n   the incoming packet, and arrival, the current time in\
    \ the same units.\n   Here s points to state for the source; s->transit holds\
    \ the relative\n   transit time for the previous packet, and s->jitter holds the\n\
    \   estimated jitter.  The jitter field of the reception report is\n   measured\
    \ in timestamp units and expressed as an unsigned integer, but\n   the jitter\
    \ estimate is kept in a floating point.  As each data packet\n   arrives, the\
    \ jitter estimate is updated:\n      int transit = arrival - r->ts;\n      int\
    \ d = transit - s->transit;\n      s->transit = transit;\n      if (d < 0) d =\
    \ -d;\n      s->jitter += (1./16.) * ((double)d - s->jitter);\n   When a reception\
    \ report block (to which rr points) is generated for\n   this member, the current\
    \ jitter estimate is returned:\n      rr->jitter = (u_int32) s->jitter;\n   Alternatively,\
    \ the jitter estimate can be kept as an integer, but\n   scaled to reduce round-off\
    \ error.  The calculation is the same except\n   for the last line:\n      s->jitter\
    \ += d - ((s->jitter + 8) >> 4);\n   In this case, the estimate is sampled for\
    \ the reception report as:\n      rr->jitter = s->jitter >> 4;\n"
- title: Appendix B - Changes from RFC 1889
  contents:
  - "Appendix B - Changes from RFC 1889\n   Most of this RFC is identical to RFC 1889.\
    \  There are no changes in\n   the packet formats on the wire, only changes to\
    \ the rules and\n   algorithms governing how the protocol is used.  The biggest\
    \ change is\n   an enhancement to the scalable timer algorithm for calculating\
    \ when\n   to send RTCP packets:\n   o  The algorithm for calculating the RTCP\
    \ transmission interval\n      specified in Sections 6.2 and 6.3 and illustrated\
    \ in Appendix A.7\n      is augmented to include \"reconsideration\" to minimize\
    \ transmission\n      in excess of the intended rate when many participants join\
    \ a\n      session simultaneously, and \"reverse reconsideration\" to reduce\n\
    \      the incidence and duration of false participant timeouts when the\n   \
    \   number of participants drops rapidly.  Reverse reconsideration is\n      also\
    \ used to possibly shorten the delay before sending RTCP SR\n      when transitioning\
    \ from passive receiver to active sender mode.\n   o  Section 6.3.7 specifies\
    \ new rules controlling when an RTCP BYE\n      packet should be sent in order\
    \ to avoid a flood of packets when\n      many participants leave a session simultaneously.\n\
    \   o  The requirement to retain state for inactive participants for a\n     \
    \ period long enough to span typical network partitions was removed\n      from\
    \ Section 6.2.1.  In a session where many participants join for\n      a brief\
    \ time and fail to send BYE, this requirement would cause a\n      significant\
    \ overestimate of the number of participants.  The\n      reconsideration algorithm\
    \ added in this revision compensates for\n      the large number of new participants\
    \ joining simultaneously when a\n      partition heals.\n   It should be noted\
    \ that these enhancements only have a significant\n   effect when the number of\
    \ session participants is large (thousands)\n   and most of the participants join\
    \ or leave at the same time.  This\n   makes testing in a live network difficult.\
    \  However, the algorithm\n   was subjected to a thorough analysis and simulation\
    \ to verify its\n   performance.  Furthermore, the enhanced algorithm was designed\
    \ to\n   interoperate with the algorithm in RFC 1889 such that the degree of\n\
    \   reduction in excess RTCP bandwidth during a step join is proportional\n  \
    \ to the fraction of participants that implement the enhanced\n   algorithm. \
    \ Interoperation of the two algorithms has been verified\n   experimentally on\
    \ live networks.\n   Other functional changes were:\n   o  Section 6.2.1 specifies\
    \ that implementations may store only a\n      sampling of the participants' SSRC\
    \ identifiers to allow scaling to\n      very large sessions.  Algorithms are\
    \ specified in RFC 2762 [21].\n   o  In Section 6.2 it is specified that RTCP\
    \ sender and non-sender\n      bandwidths may be set as separate parameters of\
    \ the session rather\n      than a strict percentage of the session bandwidth,\
    \ and may be set\n      to zero.  The requirement that RTCP was mandatory for\
    \ RTP sessions\n      using IP multicast was relaxed.  However, a clarification\
    \ was also\n      added that turning off RTCP is NOT RECOMMENDED.\n   o  In Sections\
    \ 6.2, 6.3.1 and Appendix A.7, it is specified that the\n      fraction of participants\
    \ below which senders get dedicated RTCP\n      bandwidth changes from the fixed\
    \ 1/4 to a ratio based on the RTCP\n      sender and non-sender bandwidth parameters\
    \ when those are given.\n      The condition that no bandwidth is dedicated to\
    \ senders when there\n      are no senders was removed since that is expected\
    \ to be a\n      transitory state.  It also keeps non-senders from using sender\n\
    \      RTCP bandwidth when that is not intended.\n   o  Also in Section 6.2 it\
    \ is specified that the minimum RTCP interval\n      may be scaled to smaller\
    \ values for high bandwidth sessions, and\n      that the initial RTCP delay may\
    \ be set to zero for unicast\n      sessions.\n   o  Timing out a participant\
    \ is to be based on inactivity for a number\n      of RTCP report intervals calculated\
    \ using the receiver RTCP\n      bandwidth fraction even for active senders.\n\
    \   o  Sections 7.2 and 7.3 specify that translators and mixers should\n     \
    \ send BYE packets for the sources they are no longer forwarding.\n   o  Rule\
    \ changes for layered encodings are defined in Sections 2.4,\n      6.3.9, 8.3\
    \ and 11.  In the last of these, it is noted that the\n      address and port\
    \ assignment rule conflicts with the SDP\n      specification, RFC 2327 [15],\
    \ but it is intended that this\n      restriction will be relaxed in a revision\
    \ of RFC 2327.\n   o  The convention for using even/odd port pairs for RTP and\
    \ RTCP in\n      Section 11 was clarified to refer to destination ports.  The\n\
    \      requirement to use an even/odd port pair was removed if the two\n     \
    \ ports are specified explicitly.  For unicast RTP sessions,\n      distinct port\
    \ pairs may be used for the two ends (Sections 3, 7.1\n      and 11).\n   o  A\
    \ new Section 10 was added to explain the requirement for\n      congestion control\
    \ in applications using RTP.\n   o  In Section 8.2, the requirement that a new\
    \ SSRC identifier MUST be\n      chosen whenever the source transport address\
    \ is changed has been\n      relaxed to say that a new SSRC identifier MAY be\
    \ chosen.\n      Correspondingly, it was clarified that an implementation MAY\n\
    \      choose to keep packets from the new source address rather than the\n  \
    \    existing source address when an SSRC collision occurs between two\n     \
    \ other participants, and SHOULD do so for applications such as\n      telephony\
    \ in which some sources such as mobile entities may change\n      addresses during\
    \ the course of an RTP session.\n   o  An indentation bug in the RFC 1889 printing\
    \ of the pseudo-code for\n      the collision detection and resolution algorithm\
    \ in Section 8.2\n      has been corrected by translating the syntax to pseudo\
    \ C language,\n      and the algorithm has been modified to remove the restriction\
    \ that\n      both RTP and RTCP must be sent from the same source port number.\n\
    \   o  The description of the padding mechanism for RTCP packets was\n      clarified\
    \ and it is specified that padding MUST only be applied to\n      the last packet\
    \ of a compound RTCP packet.\n   o  In Section A.1, initialization of base_seq\
    \ was corrected to be seq\n      rather than seq - 1, and the text was corrected\
    \ to say the bad\n      sequence number plus 1 is stored.  The initialization\
    \ of max_seq\n      and other variables for the algorithm was separated from the\
    \ text\n      to make clear that this initialization must be done in addition\
    \ to\n      calling the init_seq() function (and a few words lost in RFC 1889\n\
    \      when processing the document from source to output form were\n      restored).\n\
    \   o  Clamping of number of packets lost in Section A.3 was corrected to\n  \
    \    use both positive and negative limits.\n   o  The specification of \"relative\"\
    \ NTP timestamp in the RTCP SR\n      section now defines these timestamps to\
    \ be based on the most\n      common system-specific clock, such as system uptime,\
    \ rather than\n      on session elapsed time which would not be the same for multiple\n\
    \      applications started on the same machine at different times.\n   Non-functional\
    \ changes:\n   o  It is specified that a receiver MUST ignore packets with payload\n\
    \      types it does not understand.\n   o  In Fig. 2, the floating point NTP\
    \ timestamp value was corrected,\n      some missing leading zeros were added\
    \ in a hex number, and the UTC\n      timezone was specified.\n   o  The inconsequence\
    \ of NTP timestamps wrapping around in the year\n      2036 is explained.\n  \
    \ o  The policy for registration of RTCP packet types and SDES types\n      was\
    \ clarified in a new Section 15, IANA Considerations.  The\n      suggestion that\
    \ experimenters register the numbers they need and\n      then unregister those\
    \ which prove to be unneeded has been removed\n      in favor of using APP and\
    \ PRIV.  Registration of profile names was\n      also specified.\n   o  The reference\
    \ for the UTF-8 character set was changed from an\n      X/Open Preliminary Specification\
    \ to be RFC 2279.\n   o  The reference for RFC 1597 was updated to RFC 1918 and\
    \ the\n      reference for RFC 2543 was updated to RFC 3261.\n   o  The last paragraph\
    \ of the introduction in RFC 1889, which\n      cautioned implementors to limit\
    \ deployment in the Internet, was\n      removed because it was deemed no longer\
    \ relevant.\n   o  A non-normative note regarding the use of RTP with Source-Specific\n\
    \      Multicast (SSM) was added in Section 6.\n   o  The definition of \"RTP\
    \ session\" in Section 3 was expanded to\n      acknowledge that a single session\
    \ may use multiple destination\n      transport addresses (as was always the case\
    \ for a translator or\n      mixer) and to explain that the distinguishing feature\
    \ of an RTP\n      session is that each corresponds to a separate SSRC identifier\n\
    \      space.  A new definition of \"multimedia session\" was added to\n     \
    \ reduce confusion about the word \"session\".\n   o  The meaning of \"sampling\
    \ instant\" was explained in more detail as\n      part of the definition of the\
    \ timestamp field of the RTP header in\n      Section 5.1.\n   o  Small clarifications\
    \ of the text have been made in several places,\n      some in response to questions\
    \ from readers.  In particular:\n      -  In RFC 1889, the first five words of\
    \ the second sentence of\n         Section 2.2 were lost in processing the document\
    \ from source to\n         output form, but are now restored.\n      -  A definition\
    \ for \"RTP media type\" was added in Section 3 to\n         allow the explanation\
    \ of multiplexing RTP sessions in Section\n         5.2 to be more clear regarding\
    \ the multiplexing of multiple\n         media.  That section also now explains\
    \ that multiplexing\n         multiple sources of the same medium based on SSRC\
    \ identifiers\n         may be appropriate and is the norm for multicast sessions.\n\
    \      -  The definition for \"non-RTP means\" was expanded to include\n     \
    \    examples of other protocols constituting non-RTP means.\n      -  The description\
    \ of the session bandwidth parameter is expanded\n         in Section 6.2, including\
    \ a clarification that the control\n         traffic bandwidth is in addition\
    \ to the session bandwidth for\n         the data traffic.\n      -  The effect\
    \ of varying packet duration on the jitter calculation\n         was explained\
    \ in Section 6.4.4.\n      -  The method for terminating and padding a sequence\
    \ of SDES items\n         was clarified in Section 6.5.\n      -  IPv6 address\
    \ examples were added in the description of SDES\n         CNAME in Section 6.5.1,\
    \ and \"example.com\" was used in place of\n         other example domain names.\n\
    \      -  The Security section added a formal reference to IPSEC now that\n  \
    \       it is available, and says that the confidentiality method\n         defined\
    \ in this specification is primarily to codify existing\n         practice.  It\
    \ is RECOMMENDED that stronger encryption\n         algorithms such as Triple-DES\
    \ be used in place of the default\n         algorithm, and noted that the SRTP\
    \ profile based on AES will be\n         the correct choice in the future.  A\
    \ caution about the weakness\n         of the RTP header as an initialization\
    \ vector was added.  It\n         was also noted that payload-only encryption\
    \ is necessary to\n         allow for header compression.\n      -  The method\
    \ for partial encryption of RTCP was clarified; in\n         particular, SDES\
    \ CNAME is carried in only one part when the\n         compound RTCP packet is\
    \ split.\n      -  It is clarified that only one compound RTCP packet should be\n\
    \         sent per reporting interval and that if there are too many\n       \
    \  active sources for the reports to fit in the MTU, then a subset\n         of\
    \ the sources should be selected round-robin over multiple\n         intervals.\n\
    \      -  A note was added in Appendix A.1 that packets may be saved\n       \
    \  during RTP header validation and delivered upon success.\n      -  Section\
    \ 7.3 now explains that a mixer aggregating SDES packets\n         uses more RTCP\
    \ bandwidth due to longer packets, and a mixer\n         passing through RTCP\
    \ naturally sends packets at higher than the\n         single source rate, but\
    \ both behaviors are valid.\n      -  Section 13 clarifies that an RTP application\
    \ may use multiple\n         profiles but typically only one in a given session.\n\
    \      -  The terms MUST, SHOULD, MAY, etc. are used as defined in RFC\n     \
    \    2119.\n      -  The bibliography was divided into normative and informative\n\
    \         references.\n"
- title: References
  contents:
  - 'References

    '
- title: Normative References
  contents:
  - "Normative References\n   [1]  Schulzrinne, H. and S. Casner, \"RTP Profile for\
    \ Audio and Video\n        Conferences with Minimal Control\", RFC 3551, July\
    \ 2003.\n   [2]  Bradner, S., \"Key Words for Use in RFCs to Indicate Requirement\n\
    \        Levels\", BCP 14, RFC 2119, March 1997.\n   [3]  Postel, J., \"Internet\
    \ Protocol\", STD 5, RFC 791, September 1981.\n   [4]  Mills, D., \"Network Time\
    \ Protocol (Version 3) Specification,\n        Implementation and Analysis\",\
    \ RFC 1305, March 1992.\n   [5]  Yergeau, F., \"UTF-8, a Transformation Format\
    \ of ISO 10646\", RFC\n        2279, January 1998.\n   [6]  Mockapetris, P., \"\
    Domain Names - Concepts and Facilities\", STD\n        13, RFC 1034, November\
    \ 1987.\n   [7]  Mockapetris, P., \"Domain Names - Implementation and\n      \
    \  Specification\", STD 13, RFC 1035, November 1987.\n   [8]  Braden, R., \"Requirements\
    \ for Internet Hosts - Application and\n        Support\", STD 3, RFC 1123, October\
    \ 1989.\n   [9]  Resnick, P., \"Internet Message Format\", RFC 2822, April 2001.\n"
- title: Informative References
  contents:
  - "Informative References\n   [10] Clark, D. and D. Tennenhouse, \"Architectural\
    \ Considerations for\n        a New Generation of Protocols,\" in SIGCOMM Symposium\
    \ on\n        Communications Architectures and Protocols , (Philadelphia,\n  \
    \      Pennsylvania), pp. 200--208, IEEE Computer Communications\n        Review,\
    \ Vol. 20(4), September 1990.\n   [11] Schulzrinne, H., \"Issues in designing\
    \ a transport protocol for\n        audio and video conferences and other multiparticipant\
    \ real-time\n        applications.\" expired Internet Draft, October 1993.\n \
    \  [12] Comer, D., Internetworking with TCP/IP , vol. 1.  Englewood\n        Cliffs,\
    \ New Jersey: Prentice Hall, 1991.\n   [13] Rosenberg, J., Schulzrinne, H., Camarillo,\
    \ G., Johnston, A.,\n        Peterson, J., Sparks, R., Handley, M. and E. Schooler,\
    \ \"SIP:\n        Session Initiation Protocol\", RFC 3261, June 2002.\n   [14]\
    \ International Telecommunication Union, \"Visual telephone systems\n        and\
    \ equipment for local area networks which provide a non-\n        guaranteed quality\
    \ of service\", Recommendation H.323,\n        Telecommunication Standardization\
    \ Sector of ITU, Geneva,\n        Switzerland, July 2003.\n   [15] Handley, M.\
    \ and V. Jacobson, \"SDP: Session Description\n        Protocol\", RFC 2327, April\
    \ 1998.\n   [16] Schulzrinne, H., Rao, A. and R. Lanphier, \"Real Time Streaming\n\
    \        Protocol (RTSP)\", RFC 2326, April 1998.\n   [17] Eastlake 3rd, D., Crocker,\
    \ S. and J. Schiller, \"Randomness\n        Recommendations for Security\", RFC\
    \ 1750, December 1994.\n   [18] Bolot, J.-C., Turletti, T. and I. Wakeman, \"\
    Scalable Feedback\n        Control for Multicast Video Distribution in the Internet\"\
    , in\n        SIGCOMM Symposium on Communications Architectures and Protocols,\n\
    \        (London, England), pp. 58--67, ACM, August 1994.\n   [19] Busse, I.,\
    \ Deffner, B. and H. Schulzrinne, \"Dynamic QoS Control\n        of Multimedia\
    \ Applications Based on RTP\", Computer\n        Communications , vol. 19, pp.\
    \ 49--58, January 1996.\n   [20] Floyd, S. and V. Jacobson, \"The Synchronization\
    \ of Periodic\n        Routing Messages\", in SIGCOMM Symposium on Communications\n\
    \        Architectures and Protocols (D. P. Sidhu, ed.), (San Francisco,\n   \
    \     California), pp. 33--44, ACM, September 1993.  Also in [34].\n   [21] Rosenberg,\
    \ J. and H. Schulzrinne, \"Sampling of the Group\n        Membership in RTP\"\
    , RFC 2762, February 2000.\n   [22] Cadzow, J., Foundations of Digital Signal\
    \ Processing and Data\n        Analysis New York, New York: Macmillan, 1987.\n\
    \   [23] Hinden, R. and S. Deering, \"Internet Protocol Version 6 (IPv6)\n   \
    \     Addressing Architecture\", RFC 3513, April 2003.\n   [24] Rekhter, Y., Moskowitz,\
    \ B., Karrenberg, D., de Groot, G. and E.\n        Lear, \"Address Allocation\
    \ for Private Internets\", RFC 1918,\n        February 1996.\n   [25] Lear, E.,\
    \ Fair, E., Crocker, D. and T. Kessler, \"Network 10\n        Considered Harmful\
    \ (Some Practices Shouldn't be Codified)\", RFC\n        1627, July 1994.\n  \
    \ [26] Feller, W., An Introduction to Probability Theory and its\n        Applications,\
    \ vol. 1.  New York, New York: John Wiley and Sons,\n        third ed., 1968.\n\
    \   [27] Kent, S. and R. Atkinson, \"Security Architecture for the\n        Internet\
    \ Protocol\", RFC 2401, November 1998.\n   [28] Baugher, M., Blom, R., Carrara,\
    \ E., McGrew, D., Naslund, M.,\n        Norrman, K. and D. Oran, \"Secure Real-time\
    \ Transport Protocol\",\n        Work in Progress, April 2003.\n   [29] Balenson,\
    \ D., \"Privacy Enhancement for Internet Electronic Mail:\n        Part III\"\
    , RFC 1423, February 1993.\n   [30] Voydock, V. and S. Kent, \"Security Mechanisms\
    \ in High-Level\n        Network Protocols\", ACM Computing Surveys, vol. 15,\
    \ pp. 135-171,\n        June 1983.\n   [31] Floyd, S., \"Congestion Control Principles\"\
    , BCP 41, RFC 2914,\n        September 2000.\n   [32] Rivest, R., \"The MD5 Message-Digest\
    \ Algorithm\", RFC 1321, April\n        1992.\n   [33] Stubblebine, S., \"Security\
    \ Services for Multimedia\n        Conferencing\", in 16th National Computer Security\
    \ Conference,\n        (Baltimore, Maryland), pp. 391--395, September 1993.\n\
    \   [34] Floyd, S. and V. Jacobson, \"The Synchronization of Periodic\n      \
    \  Routing Messages\", IEEE/ACM Transactions on Networking, vol. 2,\n        pp.\
    \ 122--136, April 1994.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Henning Schulzrinne\n   Department of Computer Science\n\
    \   Columbia University\n   1214 Amsterdam Avenue\n   New York, NY 10027\n   United\
    \ States\n   EMail: schulzrinne@cs.columbia.edu\n   Stephen L. Casner\n   Packet\
    \ Design\n   3400 Hillview Avenue, Building 3\n   Palo Alto, CA 94304\n   United\
    \ States\n   EMail: casner@acm.org\n   Ron Frederick\n   Blue Coat Systems Inc.\n\
    \   650 Almanor Avenue\n   Sunnyvale, CA 94085\n   United States\n   EMail: ronf@bluecoat.com\n\
    \   Van Jacobson\n   Packet Design\n   3400 Hillview Avenue, Building 3\n   Palo\
    \ Alto, CA 94304\n   United States\n   EMail: van@packetdesign.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2003).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
