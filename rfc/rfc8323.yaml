- contents:
  - ' CoAP (Constrained Application Protocol) over TCP, TLS, and WebSockets

    '
  title: __initial_text__
- contents:
  - "Abstract\n   The Constrained Application Protocol (CoAP), although inspired by\n
    \  HTTP, was designed to use UDP instead of TCP.  The message layer of\n   CoAP
    over UDP includes support for reliable delivery, simple\n   congestion control,
    and flow control.\n   Some environments benefit from the availability of CoAP
    carried over\n   reliable transports such as TCP or Transport Layer Security (TLS).\n
    \  This document outlines the changes required to use CoAP over TCP,\n   TLS,
    and WebSockets transports.  It also formally updates RFC 7641\n   for use with
    these transports and RFC 7959 to enable the use of\n   larger messages over a
    reliable transport.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8323.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2018 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \  2. Conventions and Terminology .....................................6\n   3.
    CoAP over TCP ...................................................7\n      3.1.
    Messaging Model ............................................7\n      3.2. Message
    Format .............................................9\n      3.3. Message Transmission
    ......................................11\n      3.4. Connection Health .........................................12\n
    \  4. CoAP over WebSockets ...........................................13\n      4.1.
    Opening Handshake .........................................15\n      4.2. Message
    Format ............................................15\n      4.3. Message Transmission
    ......................................16\n      4.4. Connection Health .........................................17\n
    \  5. Signaling ......................................................17\n      5.1.
    Signaling Codes ...........................................17\n      5.2. Signaling
    Option Numbers ..................................18\n      5.3. Capabilities and
    Settings Messages (CSMs) .................18\n      5.4. Ping and Pong Messages
    ....................................20\n      5.5. Release Messages ..........................................21\n
    \     5.6. Abort Messages ............................................23\n      5.7.
    Signaling Examples ........................................24\n   6. Block-Wise
    Transfer and Reliable Transports ....................25\n      6.1. Example: GET
    with BERT Blocks .............................27\n      6.2. Example: PUT with
    BERT Blocks .............................27\n   7. Observing Resources over Reliable
    Transports ...................28\n      7.1. Notifications and Reordering ..............................28\n
    \     7.2. Transmission and Acknowledgments ..........................28\n      7.3.
    Freshness .................................................28\n      7.4. Cancellation
    ..............................................29\n   8. CoAP over Reliable Transport
    URIs ..............................29\n      8.1. coap+tcp URI Scheme .......................................30\n
    \     8.2. coaps+tcp URI Scheme ......................................31\n      8.3.
    coap+ws URI Scheme ........................................32\n      8.4. coaps+ws
    URI Scheme .......................................33\n      8.5. Uri-Host and
    Uri-Port Options .............................33\n      8.6. Decomposing URIs
    into Options .............................34\n      8.7. Composing URIs from Options
    ...............................35\n   9. Securing CoAP ..................................................35\n
    \     9.1. TLS Binding for CoAP over TCP .............................36\n      9.2.
    TLS Usage for CoAP over WebSockets ........................37\n   10. Security
    Considerations .......................................37\n      10.1. Signaling
    Messages .......................................37\n   11. IANA Considerations
    ...........................................38\n      11.1. Signaling Codes ..........................................38\n
    \     11.2. CoAP Signaling Option Numbers Registry ...................38\n      11.3.
    Service Name and Port Number Registration ................40\n      11.4. Secure
    Service Name and Port Number Registration .........40\n      11.5. URI Scheme
    Registration ..................................41\n      11.6. Well-Known URI
    Suffix Registration .......................43\n      11.7. ALPN Protocol Identifier
    .................................44\n      11.8. WebSocket Subprotocol Registration
    .......................44\n      11.9. CoAP Option Numbers Registry .............................44\n
    \  12. References ....................................................45\n      12.1.
    Normative References .....................................45\n      12.2. Informative
    References ...................................47\n   Appendix A. Examples of CoAP
    over WebSockets ......................49\n   Acknowledgments ...................................................52\n
    \  Contributors ......................................................52\n   Authors'
    Addresses ................................................53\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The Constrained Application Protocol (CoAP) [RFC7252] was
    designed\n   for Internet of Things (IoT) deployments, assuming that UDP [RFC768]\n
    \  can be used unimpeded as can the Datagram Transport Layer Security\n   (DTLS)
    protocol [RFC6347] over UDP.  The use of CoAP over UDP is\n   focused on simplicity,
    has a low code footprint, and has a small\n   over-the-wire message size.\n   The
    primary reason for introducing CoAP over TCP [RFC793] and TLS\n   [RFC5246] is
    that some networks do not forward UDP packets.  Complete\n   blocking of UDP happens
    in between about 2% and 4% of terrestrial\n   access networks, according to [EK2016].
    \ UDP impairment is especially\n   concentrated in enterprise networks and networks
    in geographic\n   regions with otherwise challenged connectivity.  Some networks
    also\n   rate-limit UDP traffic, as reported in [BK2015], and deployment\n   investigations
    related to the standardization of Quick UDP Internet\n   Connections (QUIC) revealed
    numbers around 0.3% [SW2016].\n   The introduction of CoAP over TCP also leads
    to some additional\n   effects that may be desirable in a specific deployment:\n
    \  o  Where NATs are present along the communication path, CoAP over TCP\n      leads
    to different NAT traversal behavior than CoAP over UDP.\n      NATs often calculate
    expiration timers based on the\n      transport-layer protocol being used by application
    protocols.\n      Many NATs maintain TCP-based NAT bindings for longer periods
    based\n      on the assumption that a transport-layer protocol, such as TCP,\n
    \     offers additional information about the session lifecycle.  UDP,\n      on
    the other hand, does not provide such information to a NAT and\n      timeouts
    tend to be much shorter [HomeGateway].  According to\n      [HomeGateway], the
    mean for TCP and UDP NAT binding timeouts is\n      386 minutes (TCP) and 160
    seconds (UDP).  Shorter timeout values\n      require keepalive messages to be
    sent more frequently.  Hence, the\n      use of CoAP over TCP requires less-frequent
    transmission of\n      keepalive messages.\n   o  TCP utilizes mechanisms for
    congestion control and flow control\n      that are more sophisticated than the
    default mechanisms provided\n      by CoAP over UDP; these TCP mechanisms are
    useful for the transfer\n      of larger payloads.  (However, work is ongoing
    to add advanced\n      congestion control to CoAP over UDP as well; see [CoCoA].)\n
    \  Note that the use of CoAP over UDP (and CoAP over DTLS over UDP) is\n   still
    the recommended transport for use in constrained node networks,\n   particularly
    when used in concert with block-wise transfer.  CoAP\n   over TCP is applicable
    for those cases where the networking\n   infrastructure leaves no other choice.
    \ The use of CoAP over TCP\n   leads to a larger code size, more round trips,
    increased RAM\n   requirements, and larger packet sizes.  Developers implementing
    CoAP\n   over TCP are encouraged to consult [TCP-in-IoT] for guidance on\n   low-footprint
    TCP implementations for IoT devices.\n   Standards based on CoAP, such as Lightweight
    Machine to Machine\n   [LWM2M], currently use CoAP over UDP as a transport; adding
    support\n   for CoAP over TCP enables them to address the issues above for\n   specific
    deployments and to protect investments in existing CoAP\n   implementations and
    deployments.\n   Although HTTP/2 could also potentially address the need for\n
    \  enterprise firewall traversal, there would be additional costs and\n   delays
    introduced by such a transition from CoAP to HTTP/2.\n   Currently, there are
    also fewer HTTP/2 implementations available for\n   constrained devices in comparison
    to CoAP.  Since CoAP also supports\n   group communication using IP-layer multicast
    and unreliable\n   communication, IoT devices would have to support HTTP/2 in
    addition\n   to CoAP.\n   Furthermore, CoAP may be integrated into a web environment
    where the\n   front end uses CoAP over UDP from IoT devices to a cloud\n   infrastructure
    and then CoAP over TCP between the back-end services.\n   A TCP-to-UDP gateway
    can be used at the cloud boundary to communicate\n   with the UDP-based IoT device.\n
    \  Finally, CoAP applications running inside a web browser may be\n   without
    access to connectivity other than HTTP.  In this case, the\n   WebSocket Protocol
    [RFC6455] may be used to transport CoAP requests\n   and responses, as opposed
    to cross-proxying them via HTTP to an\n   HTTP-to-CoAP cross-proxy.  This preserves
    the functionality of CoAP\n   without translation -- in particular, the Observe
    Option [RFC7641].\n   To address the above-mentioned deployment requirements,
    this document\n   defines how to transport CoAP over TCP, CoAP over TLS, and CoAP
    over\n   WebSockets.  For these cases, the reliability offered by the\n   transport
    protocol subsumes the reliability functions of the message\n   layer used for
    CoAP over UDP.  (Note that for both a reliable\n   transport and the message layer
    for CoAP over UDP, the reliability\n   offered is per transport hop: where proxies
    -- see Sections 5.7 and\n   10 of [RFC7252] -- are involved, that layer's reliability
    function\n   does not extend end to end.)  Figure 1 illustrates the layering:\n
    \    +--------------------------------+\n     |          Application           |\n
    \    +--------------------------------+\n     +--------------------------------+\n
    \    |  Requests/Responses/Signaling  |  CoAP (RFC 7252) / This Document\n     |--------------------------------|\n
    \    |        Message Framing         |  This Document\n     +--------------------------------+\n
    \    |      Reliable Transport        |\n     +--------------------------------+\n
    \           Figure 1: Layering of CoAP over Reliable Transports\n   This document
    specifies how to access resources using CoAP requests\n   and responses over the
    TCP, TLS, and WebSocket protocols.  This\n   allows connectivity-limited applications
    to obtain end-to-end CoAP\n   connectivity either (1) by communicating CoAP directly
    with a CoAP\n   server accessible over a TCP, TLS, or WebSocket connection or
    (2) via\n   a CoAP intermediary that proxies CoAP requests and responses between\n
    \  different transports, such as between WebSockets and UDP.\n   Section 7 updates
    [RFC7641] (\"Observing Resources in the Constrained\n   Application Protocol (CoAP)\")
    for use with CoAP over reliable\n   transports.  [RFC7641] is an extension to
    CoAP that enables CoAP\n   clients to \"observe\" a resource on a CoAP server.
    \ (The CoAP client\n   retrieves a representation of a resource and registers
    to be notified\n   by the CoAP server when the representation is updated.)\n"
  title: 1.  Introduction
- contents:
  - "2.  Conventions and Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
    \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT
    RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted
    as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear
    in all\n   capitals, as shown here.\n   This document assumes that readers are
    familiar with the terms and\n   concepts that are used in [RFC6455], [RFC7252],
    [RFC7641], and\n   [RFC7959].\n   The term \"reliable transport\" is used only
    to refer to transport\n   protocols, such as TCP, that provide reliable and ordered
    delivery of\n   a byte stream.\n   Block-wise Extension for Reliable Transport
    (BERT):\n      Extends [RFC7959] to enable the use of larger messages over a\n
    \     reliable transport.\n   BERT Option:\n      A Block1 or Block2 option that
    includes an SZX (block size)\n      value of 7.\n   BERT Block:\n      The payload
    of a CoAP message that is affected by a BERT Option in\n      descriptive usage
    (see Section 2.1 of [RFC7959]).\n   Transport Connection:\n      Underlying reliable
    byte-stream connection, as directly provided\n      by TCP or indirectly provided
    via TLS or WebSockets.\n   Connection:\n      Transport Connection, unless explicitly
    qualified otherwise.\n   Connection Initiator:\n      The peer that opens a Transport
    Connection, i.e., the TCP active\n      opener, TLS client, or WebSocket client.\n
    \  Connection Acceptor:\n      The peer that accepts the Transport Connection
    opened by the other\n      peer, i.e., the TCP passive opener, TLS server, or
    WebSocket\n      server.\n"
  title: 2.  Conventions and Terminology
- contents:
  - "3.  CoAP over TCP\n   The request/response interaction model of CoAP over TCP
    is the same\n   as CoAP over UDP.  The primary differences are in the message
    layer.\n   The message layer of CoAP over UDP supports optional reliability by\n
    \  defining four types of messages: Confirmable, Non-confirmable,\n   Acknowledgment,
    and Reset.  In addition, messages include a\n   Message ID to relate Acknowledgments
    to Confirmable messages and to\n   detect duplicate messages.\n   Management of
    the transport connections is left to the application,\n   i.e., the present specification
    does not describe how an application\n   decides to open a connection or to reopen
    another one in the presence\n   of failures (or what it would deem to be a failure;
    see also\n   Section 5.4).  In particular, the Connection Initiator need not be\n
    \  the client of the first request placed on the connection.  Some\n   implementations
    will want to implement dynamic connection management\n   similar to the technique
    described in Section 6 of [RFC7230] for\n   HTTP: opening a connection when the
    first client request is ready to\n   be sent, reusing that connection for subsequent
    messages until no\n   more messages are sent for a certain time period and no
    requests are\n   outstanding (possibly with a configurable idle time), and then\n
    \  starting a release process (orderly shutdown) (see Section 5.5).  In\n   implementations
    of this kind, connection releases or aborts may not\n   be indicated as errors
    to the application but may simply be handled\n   by automatic reconnection once
    the need arises again.  Other\n   implementations may be based on configured connections
    that are kept\n   open continuously and lead to management system notifications
    on\n   release or abort.  The protocol defined in the present specification\n
    \  is intended to work with either model (or other, application-specific\n   connection
    management models).\n"
  - contents:
    - "3.1.  Messaging Model\n   Conceptually, CoAP over TCP replaces most of the
      message layer of\n   CoAP over UDP with a framing mechanism on top of the byte
      stream\n   provided by TCP/TLS, conveying the length information for each\n
      \  message that, on datagram transports, is provided by the UDP/DTLS\n   datagram
      layer.\n   TCP ensures reliable message transmission, so the message layer of\n
      \  CoAP over TCP is not required to support Acknowledgment messages or\n   to
      detect duplicate messages.  As a result, both the Type and\n   Message ID fields
      are no longer required and are removed from the\n   message format for CoAP
      over TCP.\n   Figure 2 illustrates the difference between CoAP over UDP and
      CoAP\n   over reliable transports.  The removed Type and Message ID fields are\n
      \  indicated by dashes.\n      CoAP Client       CoAP Server     CoAP Client
      \      CoAP Server\n          |                    |            |                    |\n
      \         |   CON [0xbc90]     |            | (-------) [------] |\n          |
      GET /temperature   |            | GET /temperature   |\n          |   (Token
      0x71)     |            |   (Token 0x71)     |\n          +------------------->|
      \           +------------------->|\n          |                    |            |
      \                   |\n          |   ACK [0xbc90]     |            | (-------)
      [------] |\n          |   2.05 Content     |            |   2.05 Content     |\n
      \         |   (Token 0x71)     |            |   (Token 0x71)     |\n          |
      \    \"22.5 C\"       |            |     \"22.5 C\"       |\n          |<-------------------+
      \           |<-------------------+\n          |                    |            |
      \                   |\n              CoAP over UDP                   CoAP over
      reliable\n                                                  transports\n     Figure
      2: Comparison between CoAP over Unreliable Transports and\n                       CoAP
      over Reliable Transports\n"
    title: 3.1.  Messaging Model
  - contents:
    - "3.2.  Message Format\n   The CoAP message format defined in [RFC7252], as shown
      in Figure 3,\n   relies on the datagram transport (UDP, or DTLS over UDP) for
      keeping\n   the individual messages separate and for providing length\n   information.\n
      \   0                   1                   2                   3\n    0 1 2
      3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |Ver| T |  TKL  |      Code     |          Message ID           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |   Token (if any, TKL bytes) ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |   Options (if any) ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |1 1 1 1 1 1 1 1|    Payload (if any) ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \          Figure 3: CoAP Message Format as Defined in RFC 7252\n   The message
      format for CoAP over TCP is very similar to the format\n   specified for CoAP
      over UDP.  The differences are as follows:\n   o  Since the underlying TCP connection
      provides retransmissions and\n      deduplication, there is no need for the
      reliability mechanisms\n      provided by CoAP over UDP.  The Type (T) and Message
      ID fields in\n      the CoAP message header are elided.\n   o  The Version (Vers)
      field is elided as well.  In contrast to the\n      message format of CoAP over
      UDP, the message format for CoAP over\n      TCP does not include a version
      number.  CoAP is defined in\n      [RFC7252] with a version number of 1.  At
      this time, there is no\n      known reason to support version numbers different
      from 1.  If\n      version negotiation needs to be addressed in the future,\n
      \     Capabilities and Settings Messages (CSMs) (see Section 5.3) have\n      been
      specifically designed to enable such a potential feature.\n   o  In a stream-oriented
      transport protocol such as TCP, a form of\n      message delimitation is needed.
      \ For this purpose, CoAP over TCP\n      introduces a length field with variable
      size.  Figure 4 shows the\n      adjusted CoAP message format with a modified
      structure for the\n      fixed header (first 4 bytes of the header for CoAP
      over UDP),\n      which includes the length information of variable size.\n
      \   0                   1                   2                   3\n    0 1 2
      3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |  Len  |  TKL  | Extended Length (if any, as chosen by Len) ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |      Code     | Token (if any, TKL bytes) ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |  Options (if any) ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |1 1 1 1 1 1 1 1|    Payload (if any) ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \              Figure 4: CoAP Frame for Reliable Transports\n   Length (Len):
      \ 4-bit unsigned integer.  A value between 0 and 12\n      inclusive indicates
      the length of the message in bytes, starting\n      with the first bit of the
      Options field.  Three values are\n      reserved for special constructs:\n      13:
      \ An 8-bit unsigned integer (Extended Length) follows the\n         initial
      byte and indicates the length of options/payload\n         minus 13.\n      14:
      \ A 16-bit unsigned integer (Extended Length) in network byte\n         order
      follows the initial byte and indicates the length of\n         options/payload
      minus 269.\n      15:  A 32-bit unsigned integer (Extended Length) in network
      byte\n         order follows the initial byte and indicates the length of\n
      \        options/payload minus 65805.\n   The encoding of the Length field is
      modeled after the Option Length\n   field of the CoAP Options (see Section 3.1
      of [RFC7252]).\n   For simplicity, a Payload Marker (0xFF) is shown in Figure
      4; the\n   Payload Marker indicates the start of the optional payload and is\n
      \  absent for zero-length payloads (see Section 3 of [RFC7252]).  (If\n   present,
      the Payload Marker is included in the message length, which\n   counts from
      the start of the Options field to the end of the Payload\n   field.)\n   For
      example, a CoAP message just containing a 2.03 code with the\n   Token 7f and
      no options or payload is encoded as shown in Figure 5.\n    0                   1
      \                  2\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |      0x01     |      0x43
      \    |      0x7f     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   Len   =    0 ------>  0x01\n    TKL   =    1 ___/\n    Code  =  2.03     -->
      0x43\n    Token =               0x7f\n             Figure 5: CoAP Message with
      No Options or Payload\n   The semantics of the other CoAP header fields are
      left unchanged.\n"
    title: 3.2.  Message Format
  - contents:
    - "3.3.  Message Transmission\n   Once a Transport Connection is established,
      each endpoint MUST send a\n   CSM (see Section 5.3) as its first message on
      the connection.  This\n   message establishes the initial settings and capabilities
      for the\n   endpoint, such as maximum message size or support for block-wise\n
      \  transfers.  The absence of options in the CSM indicates that base\n   values
      are assumed.\n   To avoid a deadlock, the Connection Initiator MUST NOT wait
      for the\n   Connection Acceptor to send its initial CSM before sending its own\n
      \  initial CSM.  Conversely, the Connection Acceptor MAY wait for the\n   Connection
      Initiator to send its initial CSM before sending its own\n   initial CSM.\n
      \  To avoid unnecessary latency, a Connection Initiator MAY send\n   additional
      messages after its initial CSM without waiting to receive\n   the Connection
      Acceptor's CSM; however, it is important to note that\n   the Connection Acceptor's
      CSM might indicate capabilities that impact\n   how the Connection Initiator
      is expected to communicate with the\n   Connection Acceptor.  For example, the
      Connection Acceptor's CSM\n   could indicate a Max-Message-Size Option (see
      Section 5.3.1) that is\n   smaller than the base value (1152) in order to limit
      both buffering\n   requirements and head-of-line blocking.\n   Endpoints MUST
      treat a missing or invalid CSM as a connection error\n   and abort the connection
      (see Section 5.6).\n   CoAP requests and responses are exchanged asynchronously
      over the\n   Transport Connection.  A CoAP client can send multiple requests\n
      \  without waiting for a response, and the CoAP server can return\n   responses
      in any order.  Responses MUST be returned over the same\n   connection as the
      originating request.  Each concurrent request is\n   differentiated by its Token,
      which is scoped locally to the\n   connection.\n   The Transport Connection
      is bidirectional, so requests can be sent by\n   both the entity that established
      the connection (Connection\n   Initiator) and the remote host (Connection Acceptor).
      \ If one side\n   does not implement a CoAP server, an error response MUST be
      returned\n   for all CoAP requests from the other side.  The simplest approach
      is\n   to always return 5.01 (Not Implemented).  A more elaborate mock\n   server
      could also return 4.xx responses such as 4.04 (Not Found) or\n   4.02 (Bad Option)
      where appropriate.\n   Retransmission and deduplication of messages are provided
      by TCP.\n"
    title: 3.3.  Message Transmission
  - contents:
    - "3.4.  Connection Health\n   Empty messages (Code 0.00) can always be sent and
      MUST be ignored by\n   the recipient.  This provides a basic keepalive function
      that can\n   refresh NAT bindings.\n   If a CoAP client does not receive any
      response for some time after\n   sending a CoAP request (or, similarly, when
      a client observes a\n   resource and it does not receive any notification for
      some time), it\n   can send a CoAP Ping Signaling message (see Section 5.4)
      to test the\n   Transport Connection and verify that the CoAP server is responsive.\n
      \  When the underlying Transport Connection is closed or reset, the\n   signaling
      state and any observation state (see Section 7.4)\n   associated with the connection
      are removed.  Messages that are\n   in flight may or may not be lost.\n"
    title: 3.4.  Connection Health
  title: 3.  CoAP over TCP
- contents:
  - "4.  CoAP over WebSockets\n   CoAP over WebSockets is intentionally similar to
    CoAP over TCP;\n   therefore, this section only specifies the differences between
    the\n   transports.\n   CoAP over WebSockets can be used in a number of configurations.
    \ The\n   most basic configuration is a CoAP client retrieving or updating a\n
    \  CoAP resource located on a CoAP server that exposes a WebSocket\n   endpoint
    (see Figure 6).  The CoAP client acts as the WebSocket\n   client, establishes
    a WebSocket connection, and sends a CoAP request,\n   to which the CoAP server
    returns a CoAP response.  The WebSocket\n   connection can be used for any number
    of requests.\n            ___________                            ___________\n
    \          |           |                          |           |\n           |
    \         _|___      requests      ___|_          |\n           |   CoAP  /  \\
    \ \\  ------------->  /  /  \\  CoAP   |\n           |  Client \\__/__/  <-------------
    \ \\__\\__/ Server  |\n           |           |         responses        |           |\n
    \          |___________|                          |___________|\n                   WebSocket
    \ =============>  WebSocket\n                     Client     Connection     Server\n
    \      Figure 6: CoAP Client (WebSocket Client) Accesses CoAP Server\n                            (WebSocket
    Server)\n   The challenge with this configuration is how to identify a resource\n
    \  in the namespace of the CoAP server.  When the WebSocket Protocol is\n   used
    by a dedicated client directly (i.e., not from a web page\n   through a web browser),
    the client can connect to any WebSocket\n   endpoint.  Sections 8.3 and 8.4 define
    new URI schemes that enable\n   the client to identify both a WebSocket endpoint
    and the path and\n   query of the CoAP resource within that endpoint.\n   Another
    possible configuration is to set up a CoAP forward proxy at\n   the WebSocket
    endpoint.  Depending on what transports are available\n   to the proxy, it could
    forward the request to a CoAP server with a\n   CoAP UDP endpoint (Figure 7),
    an SMS endpoint (a.k.a. mobile phone),\n   or even another WebSocket endpoint.
    \ The CoAP client specifies the\n   resource to be updated or retrieved in the
    Proxy-Uri Option.\n     ___________                ___________                ___________\n
    \   |           |              |           |              |           |\n    |
    \         _|___        ___|_         _|___        ___|_          |\n    |   CoAP
    \ /  \\  \\ ---> /  /  \\ CoAP  /  \\  \\ ---> /  /  \\  CoAP   |\n    |  Client
    \\__/__/ <--- \\__\\__/ Proxy \\__/__/ <--- \\__\\__/ Server  |\n    |           |
    \             |           |              |           |\n    |___________|              |___________|
    \             |___________|\n            WebSocket ===> WebSocket      UDP            UDP\n
    \             Client        Server      Client          Server\n       Figure
    7: CoAP Client (WebSocket Client) Accesses CoAP Server\n       (UDP Server) via
    a CoAP Proxy (WebSocket Server / UDP Client)\n   A third possible configuration
    is a CoAP server running inside a web\n   browser (Figure 8).  The web browser
    initially connects to a\n   WebSocket endpoint and is then reachable through the
    WebSocket\n   server.  When no connection exists, the CoAP server is unreachable.\n
    \  Because the WebSocket server is the only way to reach the CoAP\n   server,
    the CoAP proxy should be a reverse-proxy.\n     ___________                ___________
    \               ___________\n    |           |              |           |              |
    \          |\n    |          _|___        ___|_         _|___        ___|_          |\n
    \   |   CoAP  /  \\  \\ ---> /  /  \\ CoAP  /  /  \\ ---> /  \\  \\  CoAP   |\n
    \   |  Client \\__/__/ <--- \\__\\__/ Proxy \\__\\__/ <--- \\__/__/ Server  |\n
    \   |           |              |           |              |           |\n    |___________|
    \             |___________|              |___________|\n               UDP            UDP
    \     WebSocket <=== WebSocket\n             Client          Server      Server
    \       Client\n    Figure 8: CoAP Client (UDP Client) Accesses CoAP Server (WebSocket\n
    \        Client) via a CoAP Proxy (UDP Server / WebSocket Server)\n   Further
    configurations are possible, including those where a\n   WebSocket connection
    is established through an HTTP proxy.\n"
  - contents:
    - "4.1.  Opening Handshake\n   Before CoAP requests and responses are exchanged,
      a WebSocket\n   connection is established as defined in Section 4 of [RFC6455].\n
      \  Figure 9 shows an example.\n   The WebSocket client MUST include the subprotocol
      name \"coap\" in the\n   list of protocols; this indicates support for the protocol
      defined in\n   this document.\n   The WebSocket client includes the hostname
      of the WebSocket server in\n   the Host header field of its handshake as per
      [RFC6455].  The Host\n   header field also indicates the default value of the
      Uri-Host Option\n   in requests from the WebSocket client to the WebSocket server.\n
      \           GET /.well-known/coap HTTP/1.1\n            Host: example.org\n
      \           Upgrade: websocket\n            Connection: Upgrade\n            Sec-WebSocket-Key:
      dGhlIHNhbXBsZSBub25jZQ==\n            Sec-WebSocket-Protocol: coap\n            Sec-WebSocket-Version:
      13\n            HTTP/1.1 101 Switching Protocols\n            Upgrade: websocket\n
      \           Connection: Upgrade\n            Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\n
      \           Sec-WebSocket-Protocol: coap\n                 Figure 9: Example
      of an Opening Handshake\n"
    title: 4.1.  Opening Handshake
  - contents:
    - "4.2.  Message Format\n   Once a WebSocket connection is established, CoAP requests
      and\n   responses can be exchanged as WebSocket messages.  Since CoAP uses a\n
      \  binary message format, the messages are transmitted in binary data\n   frames
      as specified in Sections 5 and 6 of [RFC6455].\n   The message format shown
      in Figure 10 is the same as the message\n   format for CoAP over TCP (see Section
      3.2), with one change: the\n   Length (Len) field MUST be set to zero, because
      the WebSocket frame\n   contains the length.\n      0                   1                   2
      \                  3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    | Len=0 |  TKL  |      Code     |    Token (TKL bytes) ...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |   Options (if any) ...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |1 1 1 1 1 1 1 1|    Payload (if any) ...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \             Figure 10: CoAP Message Format over WebSockets\n   As with CoAP
      over TCP, the message format for CoAP over WebSockets\n   eliminates the Version
      field defined in CoAP over UDP.  If CoAP\n   version negotiation is required
      in the future, CoAP over WebSockets\n   can address the requirement by defining
      a new subprotocol identifier\n   that is negotiated during the opening handshake.\n
      \  Requests and responses can be fragmented as specified in Section 5.4\n   of
      [RFC6455], though typically they are sent unfragmented, as they\n   tend to
      be small and fully buffered before transmission.  The\n   WebSocket Protocol
      does not provide means for multiplexing.  If it is\n   not desirable for a large
      message to monopolize the connection,\n   requests and responses can be transferred
      in a block-wise fashion as\n   defined in [RFC7959].\n"
    title: 4.2.  Message Format
  - contents:
    - "4.3.  Message Transmission\n   As with CoAP over TCP, each endpoint MUST send
      a CSM (see\n   Section 5.3) as its first message on the WebSocket connection.\n
      \  CoAP requests and responses are exchanged asynchronously over the\n   WebSocket
      connection.  A CoAP client can send multiple requests\n   without waiting for
      a response, and the CoAP server can return\n   responses in any order.  Responses
      MUST be returned over the same\n   connection as the originating request.  Each
      concurrent request is\n   differentiated by its Token, which is scoped locally
      to the\n   connection.\n   The connection is bidirectional, so requests can
      be sent by both the\n   entity that established the connection and the remote
      host.\n   As with CoAP over TCP, retransmission and deduplication of messages\n
      \  are provided by the WebSocket Protocol.  CoAP over WebSockets\n   therefore
      does not make a distinction between Confirmable messages\n   and Non-confirmable
      messages and does not provide Acknowledgment or\n   Reset messages.\n"
    title: 4.3.  Message Transmission
  - contents:
    - "4.4.  Connection Health\n   As with CoAP over TCP, a CoAP client can test the
      health of the\n   connection for CoAP over WebSockets by sending a CoAP Ping
      Signaling\n   message (Section 5.4).  To ensure that redundant maintenance traffic\n
      \  is not transmitted, WebSocket Ping and unsolicited Pong frames\n   (Section
      5.5 of [RFC6455]) SHOULD NOT be used.\n"
    title: 4.4.  Connection Health
  title: 4.  CoAP over WebSockets
- contents:
  - "5.  Signaling\n   Signaling messages are specifically introduced only for CoAP
    over\n   reliable transports to allow peers to:\n   o  Learn related characteristics,
    such as maximum message size for\n      the connection.\n   o  Shut down the connection
    in an orderly fashion.\n   o  Provide diagnostic information when terminating
    a connection in\n      response to a serious error condition.\n   Signaling is
    a third basic kind of message in CoAP, after requests\n   and responses.  Signaling
    messages share a common structure with the\n   existing CoAP messages.  There
    are a code, a Token, options, and an\n   optional payload.\n   (See Section 3
    of [RFC7252] for the overall structure of the message\n   format, option format,
    and option value formats.)\n"
  - contents:
    - "5.1.  Signaling Codes\n   A code in the 7.00-7.31 range indicates a Signaling
      message.  Values\n   in this range are assigned by the \"CoAP Signaling Codes\"
      subregistry\n   (see Section 11.1).\n   For each message, there are a sender
      and a peer receiving the\n   message.\n   Payloads in Signaling messages are
      diagnostic payloads as defined in\n   Section 5.5.2 of [RFC7252], unless otherwise
      defined by a Signaling\n   message option.\n"
    title: 5.1.  Signaling Codes
  - contents:
    - "5.2.  Signaling Option Numbers\n   Option Numbers for Signaling messages are
      specific to the message\n   code.  They do not share the number space with CoAP
      options for\n   request/response messages or with Signaling messages using other\n
      \  codes.\n   Option Numbers are assigned by the \"CoAP Signaling Option Numbers\"\n
      \  subregistry (see Section 11.2).\n   Signaling Options are elective or critical
      as defined in\n   Section 5.4.1 of [RFC7252].  If a Signaling Option is critical
      and\n   not understood by the receiver, it MUST abort the connection (see\n
      \  Section 5.6).  If the option is understood but cannot be processed,\n   the
      option documents the behavior.\n"
    title: 5.2.  Signaling Option Numbers
  - contents:
    - "5.3.  Capabilities and Settings Messages (CSMs)\n   CSMs are used for two purposes:\n
      \  o  Each capability option indicates one capability of the sender to\n      the
      recipient.\n   o  Each setting option indicates a setting that will be applied
      by\n      the sender.\n   One CSM MUST be sent by each endpoint at the start
      of the Transport\n   Connection.  Additional CSMs MAY be sent at any other time
      by either\n   endpoint over the lifetime of the connection.\n   Both capability
      options and setting options are cumulative.  A CSM\n   does not invalidate a
      previously sent capability indication or\n   setting even if it is not repeated.
      \ A capability message without any\n   option is a no-operation (and can be
      used as such).  An option that\n   is sent might override a previous value for
      the same option.  The\n   option defines how to handle this case if needed.\n
      \  Base values are listed below for CSM options.  These are the values\n   for
      the capability and settings before any CSMs send a modified\n   value.\n   These
      are not default values (as defined in Section 5.4.4 in\n   [RFC7252]) for the
      option.  Default values apply on a per-message\n   basis and are thus reset
      when the value is not present in a\n   given CSM.\n   CSMs are indicated by
      the 7.01 (CSM) code; see Table 1\n   (Section 11.1).\n"
    - contents:
      - "5.3.1.  Max-Message-Size Capability Option\n   The sender can use the elective
        Max-Message-Size Option to indicate\n   the maximum size of a message in bytes
        that it can receive.  The\n   message size indicated includes the entire message,
        starting from the\n   first byte of the message header and ending at the end
        of the message\n   payload.\n   (Note that there is no relationship of the
        message size to the\n   overall request or response body size that may be
        achievable in\n   block-wise transfer.  For example, the exchange depicted
        in Figure 13\n   (Section 6.1) can be performed if the CoAP client indicates
        a value\n   of around 6000 bytes for the Max-Message-Size Option, even though
        the\n   total body size transferred to the client is 3072 + 5120 + 4711 =\n
        \  12903 bytes.)\n   +---+---+---+---------+------------------+--------+--------+--------+\n
        \  | # | C | R | Applies | Name             | Format | Length | Base   |\n
        \  |   |   |   | to      |                  |        |        | Value  |\n
        \  +---+---+---+---------+------------------+--------+--------+--------+\n
        \  | 2 |   |   | CSM     | Max-Message-Size |   uint |    0-4 | 1152   |\n
        \  +---+---+---+---------+------------------+--------+--------+--------+\n
        \                        C=Critical, R=Repeatable\n   As per Section 4.6 of
        [RFC7252], the base value (and the value used\n   when this option is not
        implemented) is 1152.\n   The active value of the Max-Message-Size Option
        is replaced each time\n   the option is sent with a modified value.  Its starting
        value is its\n   base value.\n"
      title: 5.3.1.  Max-Message-Size Capability Option
    - contents:
      - "5.3.2.  Block-Wise-Transfer Capability Option\n   +---+---+---+---------+------------------+--------+--------+--------+\n
        \  | # | C | R | Applies | Name             | Format | Length | Base   |\n
        \  |   |   |   | to      |                  |        |        | Value  |\n
        \  +---+---+---+---------+------------------+--------+--------+--------+\n
        \  | 4 |   |   | CSM     | Block-Wise-      |  empty |      0 | (none) |\n
        \  |   |   |   |         | Transfer         |        |        |        |\n
        \  +---+---+---+---------+------------------+--------+--------+--------+\n
        \                        C=Critical, R=Repeatable\n   A sender can use the
        elective Block-Wise-Transfer Option to indicate\n   that it supports the block-wise
        transfer protocol [RFC7959].\n   If the option is not given, the peer has
        no information about whether\n   block-wise transfers are supported by the
        sender or not.  An\n   implementation wishing to offer block-wise transfers
        to its peer\n   therefore needs to indicate so via the Block-Wise-Transfer
        Option.\n   If a Max-Message-Size Option is indicated with a value that is\n
        \  greater than 1152 (in the same CSM or a different CSM), the\n   Block-Wise-Transfer
        Option also indicates support for BERT (see\n   Section 6).  Subsequently,
        if the Max-Message-Size Option is\n   indicated with a value equal to or less
        than 1152, BERT support is no\n   longer indicated.  (Note that the indication
        of BERT support does not\n   oblige either peer to actually choose to make
        use of BERT.)\n   Implementation note: When indicating a value of the Max-Message-Size\n
        \  Option with an intention to enable BERT, the indicating\n   implementation
        may want to (1) choose a particular BERT block size it\n   wants to encourage
        and (2) add a delta for the header and any options\n   that may also need
        to be included in the message with a BERT block of\n   that size.  Section
        4.6 of [RFC7252] adds 128 bytes to a maximum\n   block size of 1024 to arrive
        at a default message size of 1152.  A\n   BERT-enabled implementation may
        want to indicate a BERT block size of\n   2048 or a higher multiple of 1024
        and at the same time be more\n   generous with the size of the header and
        options added (say, 256 or\n   512).  However, adding 1024 or more to the
        base BERT block size may\n   encourage the peer implementation to vary the
        BERT block size based\n   on the size of the options included; this type of
        scenario might make\n   it harder to establish interoperability.\n"
      title: 5.3.2.  Block-Wise-Transfer Capability Option
    title: 5.3.  Capabilities and Settings Messages (CSMs)
  - contents:
    - "5.4.  Ping and Pong Messages\n   In CoAP over reliable transports, Empty messages
      (Code 0.00) can\n   always be sent and MUST be ignored by the recipient.  This
      provides a\n   basic keepalive function.  In contrast, Ping and Pong messages
      are a\n   bidirectional exchange.\n   Upon receipt of a Ping message, the receiver
      MUST return a Pong\n   message with an identical Token in response.  Unless
      the Ping carries\n   an option with delaying semantics such as the Custody Option,
      it\n   SHOULD respond as soon as practical.  As with all Signaling messages,\n
      \  the recipient of a Ping or Pong message MUST ignore elective options\n   it
      does not understand.\n   Ping and Pong messages are indicated by the 7.02 code
      (Ping) and\n   the 7.03 code (Pong).\n   Note that, as with similar mechanisms
      defined in [RFC6455] and\n   [RFC7540], the present specification does not define
      any specific\n   maximum time that the sender of a Ping message has to allow
      when\n   waiting for a Pong reply.  Any limitations on patience for this reply\n
      \  are a matter of the application making use of these messages, as is\n   any
      approach to recover from a failure to respond in time.\n"
    - contents:
      - "5.4.1.  Custody Option\n   +---+---+---+----------+----------------+--------+--------+---------+\n
        \  | # | C | R | Applies  | Name           | Format | Length | Base    |\n
        \  |   |   |   | to       |                |        |        | Value   |\n
        \  +---+---+---+----------+----------------+--------+--------+---------+\n
        \  | 2 |   |   | Ping,    | Custody        |  empty |      0 | (none)  |\n
        \  |   |   |   | Pong     |                |        |        |         |\n
        \  +---+---+---+----------+----------------+--------+--------+---------+\n
        \                        C=Critical, R=Repeatable\n   When responding to a
        Ping message, the receiver can include an\n   elective Custody Option in the
        Pong message.  This option indicates\n   that the application has processed
        all the request/response messages\n   received prior to the Ping message on
        the current connection.  (Note\n   that there is no definition of specific
        application semantics for\n   \"processed\", but there is an expectation that
        the receiver of a Pong\n   message with a Custody Option should be able to
        free buffers based on\n   this indication.)\n   A sender can also include
        an elective Custody Option in a Ping\n   message to explicitly request the
        inclusion of an elective Custody\n   Option in the corresponding Pong message.
        \ In that case, the receiver\n   SHOULD delay its Pong message until it finishes
        processing all the\n   request/response messages received prior to the Ping
        message on the\n   current connection.\n"
      title: 5.4.1.  Custody Option
    title: 5.4.  Ping and Pong Messages
  - contents:
    - "5.5.  Release Messages\n   A Release message indicates that the sender does
      not want to continue\n   maintaining the Transport Connection and opts for an
      orderly\n   shutdown, but wants to leave it to the peer to actually start closing\n
      \  the connection.  The details are in the options.  A diagnostic\n   payload
      (see Section 5.5.2 of [RFC7252]) MAY be included.\n   A peer will normally respond
      to a Release message by closing the\n   Transport Connection.  (In case that
      does not happen, the sender of\n   the release may want to implement a timeout
      mechanism if getting rid\n   of the connection is actually important to it.)\n
      \  Messages may be in flight or responses outstanding when the sender\n   decides
      to send a Release message (which is one reason the sender had\n   decided to
      wait before closing the connection).  The peer responding\n   to the Release
      message SHOULD delay the closing of the connection\n   until it has responded
      to all requests received by it before the\n   Release message.  It also MAY
      wait for the responses to its own\n   requests.\n   It is NOT RECOMMENDED for
      the sender of a Release message to continue\n   sending requests on the connection
      it already indicated to be\n   released: the peer might close the connection
      at any time and miss\n   those requests.  The peer is not obligated to check
      for this\n   condition, though.\n   Release messages are indicated by the 7.04
      code (Release).\n   Release messages can indicate one or more reasons using
      elective\n   options.  The following options are defined:\n   +---+---+---+---------+------------------+--------+--------+--------+\n
      \  | # | C | R | Applies | Name             | Format | Length | Base   |\n   |
      \  |   |   | to      |                  |        |        | Value  |\n   +---+---+---+---------+------------------+--------+--------+--------+\n
      \  | 2 |   | x | Release | Alternative-     | string |  1-255 | (none) |\n   |
      \  |   |   |         | Address          |        |        |        |\n   +---+---+---+---------+------------------+--------+--------+--------+\n
      \                        C=Critical, R=Repeatable\n   The elective Alternative-Address
      Option requests the peer to instead\n   open a connection of the same scheme
      as the present connection to the\n   alternative transport address given.  Its
      value is in the form\n   \"authority\" as defined in Section 3.2 of [RFC3986].
      \ (Existing state\n   related to the connection is not transferred from the
      present\n   connection to the new connection.)\n   The Alternative-Address Option
      is a repeatable option as defined in\n   Section 5.4.5 of [RFC7252].  When multiple
      occurrences of the option\n   are included, the peer can choose any of the alternative
      transport\n   addresses.\n   +---+---+---+---------+-----------------+--------+--------+---------+\n
      \  | # | C | R | Applies | Name            | Format | Length | Base    |\n   |
      \  |   |   | to      |                 |        |        | Value   |\n   +---+---+---+---------+-----------------+--------+--------+---------+\n
      \  | 4 |   |   | Release | Hold-Off        |   uint |    0-3 | (none)  |\n   +---+---+---+---------+-----------------+--------+--------+---------+\n
      \                        C=Critical, R=Repeatable\n   The elective Hold-Off
      Option indicates that the server is requesting\n   that the peer not reconnect
      to it for the number of seconds given in\n   the value.\n"
    title: 5.5.  Release Messages
  - contents:
    - "5.6.  Abort Messages\n   An Abort message indicates that the sender is unable
      to continue\n   maintaining the Transport Connection and cannot even wait for
      an\n   orderly release.  The sender shuts down the connection immediately\n
      \  after the Abort message (and may or may not wait for a Release\n   message,
      Abort message, or connection shutdown in the inverse\n   direction).  A diagnostic
      payload (see Section 5.5.2 of [RFC7252])\n   SHOULD be included in the Abort
      message.  Messages may be in flight\n   or responses outstanding when the sender
      decides to send an Abort\n   message.  The general expectation is that these
      will NOT be\n   processed.\n   Abort messages are indicated by the 7.05 code
      (Abort).\n   Abort messages can indicate one or more reasons using elective\n
      \  options.  The following option is defined:\n   +---+---+---+---------+-----------------+--------+--------+---------+\n
      \  | # | C | R | Applies | Name            | Format | Length | Base    |\n   |
      \  |   |   | to      |                 |        |        | Value   |\n   +---+---+---+---------+-----------------+--------+--------+---------+\n
      \  | 2 |   |   | Abort   | Bad-CSM-Option  |   uint |    0-2 | (none)  |\n   +---+---+---+---------+-----------------+--------+--------+---------+\n
      \                        C=Critical, R=Repeatable\n   Bad-CSM-Option, which
      is elective, indicates that the sender is\n   unable to process the CSM option
      identified by its Option Number,\n   e.g., when it is critical and the Option
      Number is unknown by the\n   sender, or when there is a parameter problem with
      the value of an\n   elective option.  More detailed information SHOULD be included
      as a\n   diagnostic payload.\n   For CoAP over UDP, messages that contain syntax
      violations are\n   processed as message format errors.  As described in Sections
      4.2 and\n   4.3 of [RFC7252], such messages are rejected by sending a matching\n
      \  Reset message and otherwise ignoring the message.\n   For CoAP over reliable
      transports, the recipient rejects such\n   messages by sending an Abort message
      and otherwise ignoring (not\n   processing) the message.  No specific Option
      has been defined for the\n   Abort message in this case, as the details are
      best left to a\n   diagnostic payload.\n"
    title: 5.6.  Abort Messages
  - contents:
    - "5.7.  Signaling Examples\n   An encoded example of a Ping message with a non-empty
      Token is shown\n   in Figure 11.\n       0                   1                   2\n
      \      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |      0x01     |      0xe2     |      0x42     |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      Len   =    0 -------> 0x01\n       TKL   =    1 ___/\n       Code  =
      7.02 Ping --> 0xe2\n       Token =               0x42\n                      Figure
      11: Ping Message Example\n   An encoded example of the corresponding Pong message
      is shown in\n   Figure 12.\n       0                   1                   2\n
      \      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |      0x01     |      0xe3     |      0x42     |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      Len   =    0 -------> 0x01\n       TKL   =    1 ___/\n       Code  =
      7.03 Pong --> 0xe3\n       Token =               0x42\n                      Figure
      12: Pong Message Example\n"
    title: 5.7.  Signaling Examples
  title: 5.  Signaling
- contents:
  - "6.  Block-Wise Transfer and Reliable Transports\n   The message size restrictions
    defined in Section 4.6 of [RFC7252] to\n   avoid IP fragmentation are not necessary
    when CoAP is used over a\n   reliable transport.  While this suggests that the
    block-wise transfer\n   protocol [RFC7959] is also no longer needed, it remains
    applicable\n   for a number of cases:\n   o  Large messages, such as firmware
    downloads, may cause undesired\n      head-of-line blocking when a single transport
    connection is used.\n   o  A UDP-to-TCP gateway may simply not have the context
    to convert a\n      message with a Block Option into the equivalent exchange without\n
    \     any use of a Block Option (it would need to convert the entire\n      block-wise
    exchange from start to end into a single exchange).\n   BERT extends the block-wise
    transfer protocol to enable the use of\n   larger messages over a reliable transport.\n
    \  The use of this new extension is signaled by sending Block1 or Block2\n   Options
    with SZX == 7 (a \"BERT Option\").  SZX == 7 is a reserved\n   value in [RFC7959].\n
    \  In control usage, a BERT Option is interpreted in the same way as the\n   equivalent
    Option with SZX == 6, except that it also indicates the\n   capability to process
    BERT blocks.  As with the basic block-wise\n   transfer protocol, the recipient
    of a CoAP request with a BERT Option\n   in control usage is allowed to respond
    with a different SZX value,\n   e.g., to send a non-BERT block instead.\n   In
    descriptive usage, a BERT Option is interpreted in the same way as\n   the equivalent
    Option with SZX == 6, except that the payload is also\n   allowed to contain multiple
    blocks.  For non-final BERT blocks, the\n   payload is always a multiple of 1024
    bytes.  For final BERT blocks,\n   the payload is a multiple (possibly 0) of 1024
    bytes plus a partial\n   block of less than 1024 bytes.\n   The recipient of a
    non-final BERT block (M=1) conceptually partitions\n   the payload into a sequence
    of 1024-byte blocks and acts exactly as\n   if it had received this sequence in
    conjunction with block numbers\n   starting at, and sequentially increasing from,
    the block number given\n   in the Block Option.  In other words, the entire BERT
    block is\n   positioned at the byte position that results from multiplying the\n
    \  block number by 1024.  The position of further blocks to be\n   transferred
    is indicated by incrementing the block number by the\n   number of elements in
    this sequence (i.e., the size of the payload\n   divided by 1024 bytes).\n   As
    with SZX == 6, the recipient of a final BERT block (M=0) simply\n   appends the
    payload at the byte position that is indicated by the\n   block number multiplied
    by 1024.\n   The following examples illustrate BERT Options.  A value of SZX ==
    7\n   is labeled as \"BERT\" or as \"BERT(nnn)\" to indicate a payload of\n   size
    nnn.\n   In all these examples, a Block Option is decomposed to indicate the\n
    \  kind of Block Option (1 or 2) followed by a colon, the block number\n   (NUM),
    the more bit (M), and the block size (2**(SZX + 4)) separated\n   by slashes.
    \ For example, a Block2 Option value of 33 would be shown\n   as 2:2/0/32), or
    a Block1 Option value of 59 would be shown as\n   1:3/1/128.\n"
  - contents:
    - "6.1.  Example: GET with BERT Blocks\n   Figure 13 shows a GET request with
      a response that is split into\n   three BERT blocks.  The first response contains
      3072 bytes of\n   payload; the second, 5120; and the third, 4711.  Note how
      the block\n   number increments to move the position inside the response body\n
      \  forward.\n   CoAP Client                             CoAP Server\n     |
      \                                           |\n     | GET, /status                       ------>
      |\n     |                                            |\n     | <------   2.05
      Content, 2:0/1/BERT(3072)   |\n     |                                            |\n
      \    | GET, /status, 2:3/0/BERT           ------> |\n     |                                            |\n
      \    | <------   2.05 Content, 2:3/1/BERT(5120)   |\n     |                                            |\n
      \    | GET, /status, 2:8/0/BERT          ------>  |\n     |                                            |\n
      \    | <------   2.05 Content, 2:8/0/BERT(4711)   |\n                      Figure
      13: GET with BERT Blocks\n"
    title: '6.1.  Example: GET with BERT Blocks'
  - contents:
    - "6.2.  Example: PUT with BERT Blocks\n   Figure 14 demonstrates a PUT exchange
      with BERT blocks.\n   CoAP Client                             CoAP Server\n
      \    |                                             |\n     | PUT, /options,
      1:0/1/BERT(8192)     ------> |\n     |                                             |\n
      \    | <------   2.31 Continue, 1:0/1/BERT         |\n     |                                             |\n
      \    | PUT, /options, 1:8/1/BERT(16384)    ------> |\n     |                                             |\n
      \    | <------   2.31 Continue, 1:8/1/BERT         |\n     |                                             |\n
      \    | PUT, /options, 1:24/0/BERT(5683)    ------> |\n     |                                             |\n
      \    | <------   2.04 Changed, 1:24/0/BERT         |\n     |                                             |\n
      \                     Figure 14: PUT with BERT Blocks\n"
    title: '6.2.  Example: PUT with BERT Blocks'
  title: 6.  Block-Wise Transfer and Reliable Transports
- contents:
  - "7.  Observing Resources over Reliable Transports\n   This section describes how
    the procedures defined in [RFC7641] for\n   observing resources over CoAP are
    applied (and modified, as needed)\n   for reliable transports.  In this section,
    \"client\" and \"server\"\n   refer to the CoAP client and CoAP server.\n"
  - contents:
    - "7.1.  Notifications and Reordering\n   When using the Observe Option [RFC7641]
      with CoAP over UDP,\n   notifications from the server set the option value to
      an increasing\n   sequence number for reordering detection on the client, since\n
      \  messages can arrive in a different order than they were sent.  This\n   sequence
      number is not required for CoAP over reliable transports,\n   since TCP ensures
      reliable and ordered delivery of messages.  The\n   value of the Observe Option
      in 2.xx notifications MAY be empty on\n   transmission and MUST be ignored on
      reception.\n   Implementation note: This means that a proxy from a reordering\n
      \  transport to a reliable (in-order) transport (such as a UDP-to-TCP\n   proxy)
      needs to process the Observe Option in notifications according\n   to the rules
      in Section 3.4 of [RFC7641].\n"
    title: 7.1.  Notifications and Reordering
  - contents:
    - "7.2.  Transmission and Acknowledgments\n   For CoAP over UDP, server notifications
      to the client can be\n   Confirmable or Non-confirmable.  A Confirmable message
      requires the\n   client to respond with either an Acknowledgment message or
      a Reset\n   message.  An Acknowledgment message indicates that the client is\n
      \  alive and wishes to receive further notifications.  A Reset message\n   indicates
      that the client does not recognize the Token; this causes\n   the server to
      remove the associated entry from the list of observers.\n   Since TCP eliminates
      the need for the message layer to support\n   reliability, CoAP over reliable
      transports does not support\n   Confirmable or Non-confirmable message types.
      \ All notifications are\n   delivered reliably to the client with positive acknowledgment
      of\n   receipt occurring at the TCP level.  If the client does not recognize\n
      \  the Token in a notification, it MAY immediately abort the connection\n   (see
      Section 5.6).\n"
    title: 7.2.  Transmission and Acknowledgments
  - contents:
    - "7.3.  Freshness\n   For CoAP over UDP, if a client does not receive a notification
      for\n   some time, it can send a new GET request with the same Token as the\n
      \  original request to re-register its interest in a resource and verify\n   that
      the server is still responsive.  For CoAP over reliable\n   transports, it is
      more efficient to check the health of the\n   connection (and all its active
      observations) by sending a single CoAP\n   Ping Signaling message (Section 5.4)
      rather than individual requests\n   to confirm each active observation.  (Note
      that such a Ping/Pong only\n   confirms a single hop: a proxy is not obligated
      or expected to react\n   to a Ping by checking all its own registered interests
      or all the\n   connections, if any, underlying them.  A proxy MAY maintain its
      own\n   schedule for confirming the interests that it relies on being\n   registered
      toward the origin server; however, it is generally\n   inadvisable for a proxy
      to generate a large number of outgoing checks\n   based on a single incoming
      check.)\n"
    title: 7.3.  Freshness
  - contents:
    - "7.4.  Cancellation\n   For CoAP over UDP, a client that is no longer interested
      in receiving\n   notifications can \"forget\" the observation and respond to
      the next\n   notification from the server with a Reset message to cancel the\n
      \  observation.\n   For CoAP over reliable transports, a client MUST explicitly\n
      \  deregister by issuing a GET request that has the Token field set to\n   the
      Token of the observation to be canceled and includes an Observe\n   Option with
      the value set to 1 (deregister).\n   If the client observes one or more resources
      over a reliable\n   transport, then the CoAP server (or intermediary in the
      role of the\n   CoAP server) MUST remove all entries associated with the client\n
      \  endpoint from the lists of observers when the connection either\n   times
      out or is closed.\n"
    title: 7.4.  Cancellation
  title: 7.  Observing Resources over Reliable Transports
- contents:
  - "8.  CoAP over Reliable Transport URIs\n   CoAP over UDP [RFC7252] defines the
    \"coap\" and \"coaps\" URI schemes.\n   This document introduces four additional
    URI schemes for identifying\n   CoAP resources and providing a means of locating
    the resource:\n   o  The \"coap+tcp\" URI scheme for CoAP over TCP.\n   o  The
    \"coaps+tcp\" URI scheme for CoAP over TCP secured by TLS.\n   o  The \"coap+ws\"
    URI scheme for CoAP over WebSockets.\n   o  The \"coaps+ws\" URI scheme for CoAP
    over WebSockets secured by TLS.\n   Resources made available via these schemes
    have no shared identity\n   even if their resource identifiers indicate the same
    authority (the\n   same host listening to the same TCP port).  They are hosted
    in\n   distinct namespaces because each URI scheme implies a distinct origin\n
    \  server.\n   In this section, the syntax for the URI schemes is specified using\n
    \  the Augmented Backus-Naur Form (ABNF) [RFC5234].  The definitions of\n   \"host\",
    \"port\", \"path-abempty\", and \"query\" are adopted from\n   [RFC3986].\n   Section
    8 (\"Multicast CoAP\") in [RFC7252] is not applicable to these\n   schemes.\n
    \  As with the \"coap\" and \"coaps\" schemes defined in [RFC7252], all URI\n
    \  schemes defined in this section also support the path prefix\n   \"/.well-known/\"
    as defined by [RFC5785] for \"well-known locations\" in\n   the namespace of a
    host.  This enables discovery as per Section 7 of\n   [RFC7252].\n"
  - contents:
    - "8.1.  coap+tcp URI Scheme\n   The \"coap+tcp\" URI scheme identifies CoAP resources
      that are intended\n   to be accessible using CoAP over TCP.\n     coap-tcp-URI
      = \"coap+tcp:\" \"//\" host [ \":\" port ]\n       path-abempty [ \"?\" query
      ]\n   The syntax defined in Section 6.1 of [RFC7252] applies to this URI\n   scheme,
      with the following change:\n   o  The port subcomponent indicates the TCP port
      at which the CoAP\n      Connection Acceptor is located.  (If it is empty or
      not given,\n      then the default port 5683 is assumed, as with UDP.)\n   Encoding
      considerations:  The scheme encoding conforms to the\n      encoding rules established
      for URIs in [RFC3986].\n   Interoperability considerations:  None.\n   Security
      considerations:  See Section 11.1 of [RFC7252].\n"
    title: 8.1.  coap+tcp URI Scheme
  - contents:
    - "8.2.  coaps+tcp URI Scheme\n   The \"coaps+tcp\" URI scheme identifies CoAP
      resources that are\n   intended to be accessible using CoAP over TCP secured
      with TLS.\n     coaps-tcp-URI = \"coaps+tcp:\" \"//\" host [ \":\" port ]\n
      \      path-abempty [ \"?\" query ]\n   The syntax defined in Section 6.2 of
      [RFC7252] applies to this URI\n   scheme, with the following changes:\n   o
      \ The port subcomponent indicates the TCP port at which the TLS\n      server
      for the CoAP Connection Acceptor is located.  If it is\n      empty or not given,
      then the default port 5684 is assumed.\n   o  If a TLS server does not support
      the Application-Layer Protocol\n      Negotiation (ALPN) extension [RFC7301]
      or wishes to accommodate\n      TLS clients that do not support ALPN, it MAY
      offer a coaps+tcp\n      endpoint on TCP port 5684.  This endpoint MAY also
      be ALPN\n      enabled.  A TLS server MAY offer coaps+tcp endpoints on ports\n
      \     other than TCP port 5684, which MUST be ALPN enabled.\n   o  For TCP ports
      other than port 5684, the TLS client MUST use the\n      ALPN extension to advertise
      the \"coap\" protocol identifier (see\n      Section 11.7) in the list of protocols
      in its ClientHello.  If the\n      TCP server selects and returns the \"coap\"
      protocol identifier\n      using the ALPN extension in its ServerHello, then
      the connection\n      succeeds.  If the TLS server either does not negotiate
      the ALPN\n      extension or returns a no_application_protocol alert, the TLS\n
      \     client MUST close the connection.\n   o  For TCP port 5684, a TLS client
      MAY use the ALPN extension to\n      advertise the \"coap\" protocol identifier
      in the list of protocols\n      in its ClientHello.  If the TLS server selects
      and returns the\n      \"coap\" protocol identifier using the ALPN extension
      in its\n      ServerHello, then the connection succeeds.  If the TLS server\n
      \     returns a no_application_protocol alert, then the TLS client MUST\n      close
      the connection.  If the TLS server does not negotiate the\n      ALPN extension,
      then coaps+tcp is implicitly selected.\n   o  For TCP port 5684, if the TLS
      client does not use the ALPN\n      extension to negotiate the protocol, then
      coaps+tcp is implicitly\n      selected.\n   Encoding considerations:  The scheme
      encoding conforms to the\n      encoding rules established for URIs in [RFC3986].\n
      \  Interoperability considerations:  None.\n   Security considerations:  See
      Section 11.1 of [RFC7252].\n"
    title: 8.2.  coaps+tcp URI Scheme
  - contents:
    - "8.3.  coap+ws URI Scheme\n   The \"coap+ws\" URI scheme identifies CoAP resources
      that are intended\n   to be accessible using CoAP over WebSockets.\n     coap-ws-URI
      = \"coap+ws:\" \"//\" host [ \":\" port ]\n       path-abempty [ \"?\" query
      ]\n   The port subcomponent is OPTIONAL.  The default is port 80.\n   The WebSocket
      endpoint is identified by a \"ws\" URI that is composed\n   of the authority
      part of the \"coap+ws\" URI and the well-known path\n   \"/.well-known/coap\"
      [RFC5785] [RFC8307].  Within the endpoint\n   specified in a \"coap+ws\" URI,
      the path and query parts of the URI\n   identify a resource that can be operated
      on by the methods defined\n   by CoAP:\n             coap+ws://example.org/sensors/temperature?u=Cel\n
      \                 \\______  ______/\\___________  ___________/\n                         \\/
      \                  \\/\n                                            Uri-Path:
      \"sensors\"\n       ws://example.org/.well-known/coap    Uri-Path: \"temperature\"\n
      \                                           Uri-Query: \"u=Cel\"\n                    Figure
      15: The \"coap+ws\" URI Scheme\n   Encoding considerations:  The scheme encoding
      conforms to the\n      encoding rules established for URIs in [RFC3986].\n   Interoperability
      considerations:  None.\n   Security considerations:  See Section 11.1 of [RFC7252].\n"
    title: 8.3.  coap+ws URI Scheme
  - contents:
    - "8.4.  coaps+ws URI Scheme\n   The \"coaps+ws\" URI scheme identifies CoAP resources
      that are intended\n   to be accessible using CoAP over WebSockets secured by
      TLS.\n     coaps-ws-URI = \"coaps+ws:\" \"//\" host [ \":\" port ]\n       path-abempty
      [ \"?\" query ]\n   The port subcomponent is OPTIONAL.  The default is port
      443.\n   The WebSocket endpoint is identified by a \"wss\" URI that is composed\n
      \  of the authority part of the \"coaps+ws\" URI and the well-known path\n   \"/.well-known/coap\"
      [RFC5785] [RFC8307].  Within the endpoint\n   specified in a \"coaps+ws\" URI,
      the path and query parts of the URI\n   identify a resource that can be operated
      on by the methods defined\n   by CoAP:\n             coaps+ws://example.org/sensors/temperature?u=Cel\n
      \                  \\______  ______/\\___________  ___________/\n                          \\/
      \                  \\/\n                                            Uri-Path:
      \"sensors\"\n       wss://example.org/.well-known/coap   Uri-Path: \"temperature\"\n
      \                                           Uri-Query: \"u=Cel\"\n                   Figure
      16: The \"coaps+ws\" URI Scheme\n   Encoding considerations:  The scheme encoding
      conforms to the\n      encoding rules established for URIs in [RFC3986].\n   Interoperability
      considerations:  None.\n   Security considerations:  See Section 11.1 of [RFC7252].\n"
    title: 8.4.  coaps+ws URI Scheme
  - contents:
    - "8.5.  Uri-Host and Uri-Port Options\n   CoAP over reliable transports maintains
      the property from\n   Section 5.10.1 of [RFC7252]:\n      The default values
      for the Uri-Host and Uri-Port Options are\n      sufficient for requests to
      most servers.\n   Unless otherwise noted, the default value of the Uri-Host
      Option is\n   the IP literal representing the destination IP address of the
      request\n   message.  The default value of the Uri-Port Option is the destination\n
      \  TCP port.\n   For CoAP over TLS, these default values are the same, unless
      Server\n   Name Indication (SNI) [RFC6066] is negotiated.  In this case, the\n
      \  default value of the Uri-Host Option in requests from the TLS client\n   to
      the TLS server is the SNI host.\n   For CoAP over WebSockets, the default value
      of the Uri-Host Option in\n   requests from the WebSocket client to the WebSocket
      server is\n   indicated by the Host header field from the WebSocket handshake.\n"
    title: 8.5.  Uri-Host and Uri-Port Options
  - contents:
    - "8.6.  Decomposing URIs into Options\n   The steps are the same as those specified
      in Section 6.4 of\n   [RFC7252], with minor changes:\n   This step from [RFC7252]:\n
      \  3.  If |url| does not have a <scheme> component whose value, when\n       converted
      to ASCII lowercase, is \"coap\" or \"coaps\", then fail\n       this algorithm.\n
      \  is updated to:\n   3.  If |url| does not have a <scheme> component whose
      value, when\n       converted to ASCII lowercase, is \"coap+tcp\", \"coaps+tcp\",\n
      \      \"coap+ws\", or \"coaps+ws\", then fail this algorithm.\n   This step
      from [RFC7252]:\n   7.  If |port| does not equal the request's destination UDP
      port,\n       include a Uri-Port Option and let that option's value be |port|.\n
      \  is updated to:\n   7.  If |port| does not equal the request's destination
      TCP port,\n       include a Uri-Port Option and let that option's value be |port|.\n"
    title: 8.6.  Decomposing URIs into Options
  - contents:
    - "8.7.  Composing URIs from Options\n   The steps are the same as those specified
      in Section 6.5 of\n   [RFC7252], with minor changes:\n   This step from [RFC7252]:\n
      \  1.  If the request is secured using DTLS, let |url| be the string\n       \"coaps://\".
      \ Otherwise, let |url| be the string \"coap://\".\n   is updated to:\n   1.
      \ For CoAP over TCP, if the request is secured using TLS, let |url|\n       be
      the string \"coaps+tcp://\".  Otherwise, let |url| be the string\n       \"coap+tcp://\".
      \ For CoAP over WebSockets, if the request is\n       secured using TLS, let
      |url| be the string \"coaps+ws://\".\n       Otherwise, let |url| be the string
      \"coap+ws://\".\n   This step from [RFC7252]:\n   4.  If the request includes
      a Uri-Port Option, let |port| be that\n       option's value.  Otherwise, let
      |port| be the request's\n       destination UDP port.\n   is updated to:\n   4.
      \ If the request includes a Uri-Port Option, let |port| be that\n       option's
      value.  Otherwise, let |port| be the request's\n       destination TCP port.\n"
    title: 8.7.  Composing URIs from Options
  title: 8.  CoAP over Reliable Transport URIs
- contents:
  - "9.  Securing CoAP\n   \"Security Challenges For the Internet Of Things\" [SecurityChallenges]\n
    \  recommends the following:\n      ... it is essential that IoT protocol suites
    specify a mandatory\n      to implement but optional to use security solution.
    \ This will\n      ensure security is available in all implementations, but\n
    \     configurable to use when not necessary (e.g., in closed\n      environment).
    ... even if those features stretch the capabilities\n      of such devices.\n
    \  A security solution MUST be implemented to protect CoAP over reliable\n   transports
    and MUST be enabled by default.  This document defines the\n   TLS binding, but
    alternative solutions at different layers in the\n   protocol stack MAY be used
    to protect CoAP over reliable transports\n   when appropriate.  Note that there
    is ongoing work to support a data-\n   object-based security model for CoAP that
    is independent of transport\n   (see [OSCORE]).\n"
  - contents:
    - "9.1.  TLS Binding for CoAP over TCP\n   The TLS usage guidance in [RFC7925]
      applies, including the guidance\n   about cipher suites in that document that
      are derived from the\n   mandatory-to-implement cipher suites defined in [RFC7252].\n
      \  This guidance assumes implementation in a constrained device or for\n   communication
      with a constrained device.  However, CoAP over TCP/TLS\n   has a wider applicability.
      \ It may, for example, be implemented on a\n   gateway or on a device that is
      less constrained (such as a smart\n   phone or a tablet), for communication
      with a peer that is likewise\n   less constrained, or within a back-end environment
      that only\n   communicates with constrained devices via proxies.  As an exception\n
      \  to the previous paragraph, in this case, the recommendations in\n   [RFC7525]
      are more appropriate.\n   Since the guidance offered in [RFC7925] differs from
      the guidance\n   offered in [RFC7525] in terms of algorithms and credential
      types, it\n   is assumed that an implementation of CoAP over TCP/TLS that needs
      to\n   support both cases implements the recommendations offered by both\n   specifications.\n
      \  During the provisioning phase, a CoAP device is provided with the\n   security
      information that it needs, including keying materials,\n   access control lists,
      and authorization servers.  At the end of the\n   provisioning phase, the device
      will be in one of four security modes:\n   NoSec:  TLS is disabled.\n   PreSharedKey:
      \ TLS is enabled.  The guidance in Section 4.2 of\n      [RFC7925] applies.\n
      \  RawPublicKey:  TLS is enabled.  The guidance in Section 4.3 of\n      [RFC7925]
      applies.\n   Certificate:  TLS is enabled.  The guidance in Section 4.4 of\n
      \     [RFC7925] applies.\n   The \"NoSec\" mode is optional to implement.  The
      system simply sends\n   the packets over normal TCP; this is indicated by the
      \"coap+tcp\"\n   scheme and the TCP CoAP default port.  The system is secured
      only by\n   keeping attackers from being able to send or receive packets from
      the\n   network with the CoAP nodes.\n   \"PreSharedKey\", \"RawPublicKey\",
      or \"Certificate\" is mandatory to\n   implement for the TLS binding, depending
      on the credential type used\n   with the device.  These security modes are achieved
      using TLS and\n   are indicated by the \"coaps+tcp\" scheme and TLS-secured
      CoAP\n   default port.\n"
    title: 9.1.  TLS Binding for CoAP over TCP
  - contents:
    - "9.2.  TLS Usage for CoAP over WebSockets\n   A CoAP client requesting a resource
      identified by a \"coaps+ws\" URI\n   negotiates a secure WebSocket connection
      to a WebSocket server\n   endpoint with a \"wss\" URI.  This is described in
      Section 8.4.\n   The client MUST perform a TLS handshake after opening the connection\n
      \  to the server.  The guidance in Section 4.1 of [RFC6455] applies.\n   When
      a CoAP server exposes resources identified by a \"coaps+ws\" URI,\n   the guidance
      in Section 4.4 of [RFC7925] applies towards mandatory-\n   to-implement TLS
      functionality for certificates.  For the server-side\n   requirements for accepting
      incoming connections over an HTTPS\n   (HTTP over TLS) port, the guidance in
      Section 4.2 of [RFC6455]\n   applies.\n   Note that the guidance above formally
      inherits the mandatory-to-\n   implement cipher suites defined in [RFC5246].
      \ However, modern\n   browsers usually implement cipher suites that are more
      recent; these\n   cipher suites are then automatically picked up via the JavaScript\n
      \  WebSocket API.  WebSocket servers that provide secure CoAP over\n   WebSockets
      for the browser use case will need to follow the browser\n   preferences and
      MUST follow [RFC7525].\n"
    title: 9.2.  TLS Usage for CoAP over WebSockets
  title: 9.  Securing CoAP
- contents:
  - "10.  Security Considerations\n   The security considerations of [RFC7252] apply.
    \ For CoAP over\n   WebSockets and CoAP over TLS-secured WebSockets, the security\n
    \  considerations of [RFC6455] also apply.\n"
  - contents:
    - "10.1.  Signaling Messages\n   The guidance given by an Alternative-Address
      Option cannot be\n   followed blindly.  In particular, a peer MUST NOT assume
      that a\n   successful connection to the Alternative-Address inherits all the\n
      \  security properties of the current connection.\n"
    title: 10.1.  Signaling Messages
  title: 10.  Security Considerations
- contents:
  - '11.  IANA Considerations

    '
  - contents:
    - "11.1.  Signaling Codes\n   IANA has created a third subregistry for values
      of the Code field in\n   the CoAP header (Section 12.1 of [RFC7252]).  The name
      of this\n   subregistry is \"CoAP Signaling Codes\".\n   Each entry in the subregistry
      must include the Signaling Code in the\n   range 7.00-7.31, its name, and a
      reference to its documentation.\n   Initial entries in this subregistry are
      as follows:\n                      +------+---------+-----------+\n                      |
      Code | Name    | Reference |\n                      +------+---------+-----------+\n
      \                     | 7.01 | CSM     | RFC 8323  |\n                      |
      \     |         |           |\n                      | 7.02 | Ping    | RFC
      8323  |\n                      |      |         |           |\n                      |
      7.03 | Pong    | RFC 8323  |\n                      |      |         |           |\n
      \                     | 7.04 | Release | RFC 8323  |\n                      |
      \     |         |           |\n                      | 7.05 | Abort   | RFC
      8323  |\n                      +------+---------+-----------+\n                       Table
      1: CoAP Signaling Codes\n   All other Signaling Codes are Unassigned.\n   The
      IANA policy for future additions to this subregistry is\n   \"IETF Review\"
      or \"IESG Approval\" as described in [RFC8126].\n"
    title: 11.1.  Signaling Codes
  - contents:
    - "11.2.  CoAP Signaling Option Numbers Registry\n   IANA has created a subregistry
      for Option Numbers used in CoAP\n   Signaling Options within the \"Constrained
      RESTful Environments (CoRE)\n   Parameters\" registry.  The name of this subregistry
      is \"CoAP\n   Signaling Option Numbers\".\n   Each entry in the subregistry
      must include one or more of the codes\n   in the \"CoAP Signaling Codes\" subregistry
      (Section 11.1), the number\n   for the Option, the name of the Option, and a
      reference to the\n   Option's documentation.\n   Initial entries in this subregistry
      are as follows:\n         +------------+--------+---------------------+-----------+\n
      \        | Applies to | Number | Name                | Reference |\n         +------------+--------+---------------------+-----------+\n
      \        | 7.01       |      2 | Max-Message-Size    |  RFC 8323 |\n         |
      \           |        |                     |           |\n         | 7.01       |
      \     4 | Block-Wise-Transfer |  RFC 8323 |\n         |            |        |
      \                    |           |\n         | 7.02, 7.03 |      2 | Custody
      \            |  RFC 8323 |\n         |            |        |                     |
      \          |\n         | 7.04       |      2 | Alternative-Address |  RFC 8323
      |\n         |            |        |                     |           |\n         |
      7.04       |      4 | Hold-Off            |  RFC 8323 |\n         |            |
      \       |                     |           |\n         | 7.05       |      2
      | Bad-CSM-Option      |  RFC 8323 |\n         +------------+--------+---------------------+-----------+\n
      \                  Table 2: CoAP Signaling Option Codes\n   The IANA policy
      for future additions to this subregistry is based on\n   number ranges for the
      option numbers, analogous to the policy defined\n   in Section 12.2 of [RFC7252].
      \ (The policy is analogous rather than\n   identical because the structure of
      this subregistry includes an\n   additional column (\"Applies to\"); however,
      the value of this column\n   has no influence on the policy.)\n   The documentation
      for a Signaling Option Number should specify the\n   semantics of an option
      with that number, including the following\n   properties:\n   o  Whether the
      option is critical or elective, as determined by the\n      Option Number.\n
      \  o  Whether the option is repeatable.\n   o  The format and length of the
      option's value.\n   o  The base value for the option, if any.\n"
    title: 11.2.  CoAP Signaling Option Numbers Registry
  - contents:
    - "11.3.  Service Name and Port Number Registration\n   IANA has assigned the
      port number 5683 and the service name \"coap\",\n   in accordance with [RFC6335].\n
      \  Service Name:\n      coap\n   Transport Protocol:\n      tcp\n   Assignee:\n
      \     IESG <iesg@ietf.org>\n   Contact:\n      IETF Chair <chair@ietf.org>\n
      \  Description:\n      Constrained Application Protocol (CoAP)\n   Reference:\n
      \     RFC 8323\n   Port Number:\n      5683\n"
    title: 11.3.  Service Name and Port Number Registration
  - contents:
    - "11.4.  Secure Service Name and Port Number Registration\n   IANA has assigned
      the port number 5684 and the service name \"coaps\",\n   in accordance with
      [RFC6335].  The port number is to address the\n   exceptional case of TLS implementations
      that do not support the ALPN\n   extension [RFC7301].\n   Service Name:\n      coaps\n
      \  Transport Protocol:\n      tcp\n   Assignee:\n      IESG <iesg@ietf.org>\n
      \  Contact:\n      IETF Chair <chair@ietf.org>\n   Description:\n      Constrained
      Application Protocol (CoAP)\n   Reference:\n      [RFC7301], RFC 8323\n   Port
      Number:\n      5684\n"
    title: 11.4.  Secure Service Name and Port Number Registration
  - contents:
    - "11.5.  URI Scheme Registration\n   URI schemes are registered within the \"Uniform
      Resource Identifier\n   (URI) Schemes\" registry maintained at [IANA.uri-schemes].\n
      \  Note: The following has been added as a note for each of the URI\n   schemes
      defined in this document:\n      CoAP registers different URI schemes for accessing
      CoAP resources\n      via different protocols.  This approach runs counter to
      the WWW\n      principle that a URI identifies a resource and that multiple
      URIs\n      for identifying the same resource should be avoided\n      <https://www.w3.org/TR/webarch/#avoid-uri-aliases>.\n
      \  This is not a problem for many of the usage scenarios envisioned for\n   CoAP
      over reliable transports; additional URI schemes can be\n   introduced to address
      additional usage scenarios (as being prepared,\n   for example, in [Multi-Transport-URIs]
      and [CoAP-Alt-Transports]).\n"
    - contents:
      - "11.5.1.  coap+tcp\n   IANA has registered the URI scheme \"coap+tcp\".  This
        registration\n   request complies with [RFC7595].\n   Scheme name:\n      coap+tcp\n
        \  Status:\n      Permanent\n   Applications/protocols that use this scheme
        name:\n      The scheme is used by CoAP endpoints to access CoAP resources\n
        \     using TCP.\n   Contact:\n      IETF Chair <chair@ietf.org>\n   Change
        controller:\n      IESG <iesg@ietf.org>\n   Reference:\n      Section 8.1
        in RFC 8323\n"
      title: 11.5.1.  coap+tcp
    - contents:
      - "11.5.2.  coaps+tcp\n   IANA has registered the URI scheme \"coaps+tcp\".
        \ This registration\n   request complies with [RFC7595].\n   Scheme name:\n
        \     coaps+tcp\n   Status:\n      Permanent\n   Applications/protocols that
        use this scheme name:\n      The scheme is used by CoAP endpoints to access
        CoAP resources\n      using TLS.\n   Contact:\n      IETF Chair <chair@ietf.org>\n
        \  Change controller:\n      IESG <iesg@ietf.org>\n   Reference:\n      Section
        8.2 in RFC 8323\n"
      title: 11.5.2.  coaps+tcp
    - contents:
      - "11.5.3.  coap+ws\n   IANA has registered the URI scheme \"coap+ws\".  This
        registration\n   request complies with [RFC7595].\n   Scheme name:\n      coap+ws\n
        \  Status:\n      Permanent\n   Applications/protocols that use this scheme
        name:\n      The scheme is used by CoAP endpoints to access CoAP resources\n
        \     using the WebSocket Protocol.\n   Contact:\n      IETF Chair <chair@ietf.org>\n
        \  Change controller:\n      IESG <iesg@ietf.org>\n   Reference:\n      Section
        8.3 in RFC 8323\n"
      title: 11.5.3.  coap+ws
    - contents:
      - "11.5.4.  coaps+ws\n   IANA has registered the URI scheme \"coaps+ws\".  This
        registration\n   request complies with [RFC7595].\n   Scheme name:\n      coaps+ws\n
        \  Status:\n      Permanent\n   Applications/protocols that use this scheme
        name:\n      The scheme is used by CoAP endpoints to access CoAP resources\n
        \     using the WebSocket Protocol secured with TLS.\n   Contact:\n      IETF
        Chair <chair@ietf.org>\n   Change controller:\n      IESG <iesg@ietf.org>\n
        \  References:\n      Section 8.4 in RFC 8323\n"
      title: 11.5.4.  coaps+ws
    title: 11.5.  URI Scheme Registration
  - contents:
    - "11.6.  Well-Known URI Suffix Registration\n   IANA has registered \"coap\"
      in the \"Well-Known URIs\" registry.  This\n   registration request complies
      with [RFC5785].\n   URI suffix:\n      coap\n   Change controller:\n      IETF\n
      \  Specification document(s):\n      RFC 8323\n   Related information:\n      None.\n"
    title: 11.6.  Well-Known URI Suffix Registration
  - contents:
    - "11.7.  ALPN Protocol Identifier\n   IANA has assigned the following value in
      the \"Application-Layer\n   Protocol Negotiation (ALPN) Protocol IDs\" registry
      created by\n   [RFC7301].  The \"coap\" string identifies CoAP when used over
      TLS.\n   Protocol:\n      CoAP\n   Identification Sequence:\n      0x63 0x6f
      0x61 0x70 (\"coap\")\n   Reference:\n      RFC 8323\n"
    title: 11.7.  ALPN Protocol Identifier
  - contents:
    - "11.8.  WebSocket Subprotocol Registration\n   IANA has registered the WebSocket
      CoAP subprotocol in the \"WebSocket\n   Subprotocol Name Registry\":\n   Subprotocol
      Identifier:\n      coap\n   Subprotocol Common Name:\n      Constrained Application
      Protocol (CoAP)\n   Subprotocol Definition:\n      RFC 8323\n"
    title: 11.8.  WebSocket Subprotocol Registration
  - contents:
    - "11.9.  CoAP Option Numbers Registry\n   IANA has added this document as a reference
      for the following entries\n   registered by [RFC7959] in the \"CoAP Option Numbers\"
      subregistry\n   defined by [RFC7252]:\n                 +--------+--------+--------------------+\n
      \                | Number | Name   | Reference          |\n                 +--------+--------+--------------------+\n
      \                | 23     | Block2 | RFC 7959, RFC 8323 |\n                 |
      \       |        |                    |\n                 | 27     | Block1
      | RFC 7959, RFC 8323 |\n                 +--------+--------+--------------------+\n
      \                      Table 3: CoAP Option Numbers\n"
    title: 11.9.  CoAP Option Numbers Registry
  title: 11.  IANA Considerations
- contents:
  - '12.  References

    '
  - contents:
    - "12.1.  Normative References\n   [RFC793]   Postel, J., \"Transmission Control
      Protocol\", STD 7,\n              RFC 793, DOI 10.17487/RFC0793, September 1981,\n
      \             <https://www.rfc-editor.org/info/rfc793>.\n   [RFC2119]  Bradner,
      S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\",
      BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n
      \  [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n              Resource
      Identifier (URI): Generic Syntax\", STD 66,\n              RFC 3986, DOI 10.17487/RFC3986,
      January 2005,\n              <https://www.rfc-editor.org/info/rfc3986>.\n   [RFC5234]
      \ Crocker, D., Ed., and P. Overell, \"Augmented BNF for\n              Syntax
      Specifications: ABNF\", STD 68, RFC 5234,\n              DOI 10.17487/RFC5234,
      January 2008,\n              <https://www.rfc-editor.org/info/rfc5234>.\n   [RFC5246]
      \ Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)
      Protocol Version 1.2\", RFC 5246,\n              DOI 10.17487/RFC5246, August
      2008,\n              <https://www.rfc-editor.org/info/rfc5246>.\n   [RFC5785]
      \ Nottingham, M. and E. Hammer-Lahav, \"Defining Well-Known\n              Uniform
      Resource Identifiers (URIs)\", RFC 5785,\n              DOI 10.17487/RFC5785,
      April 2010,\n              <https://www.rfc-editor.org/info/rfc5785>.\n   [RFC6066]
      \ Eastlake 3rd, D., \"Transport Layer Security (TLS)\n              Extensions:
      Extension Definitions\", RFC 6066,\n              DOI 10.17487/RFC6066, January
      2011,\n              <https://www.rfc-editor.org/info/rfc6066>.\n   [RFC6455]
      \ Fette, I. and A. Melnikov, \"The WebSocket Protocol\",\n              RFC
      6455, DOI 10.17487/RFC6455, December 2011,\n              <https://www.rfc-editor.org/info/rfc6455>.\n
      \  [RFC7252]  Shelby, Z., Hartke, K., and C. Bormann, \"The Constrained\n              Application
      Protocol (CoAP)\", RFC 7252,\n              DOI 10.17487/RFC7252, June 2014,\n
      \             <https://www.rfc-editor.org/info/rfc7252>.\n   [RFC7301]  Friedl,
      S., Popov, A., Langley, A., and E. Stephan,\n              \"Transport Layer
      Security (TLS) Application-Layer Protocol\n              Negotiation Extension\",
      RFC 7301, DOI 10.17487/RFC7301,\n              July 2014, <https://www.rfc-editor.org/info/rfc7301>.\n
      \  [RFC7525]  Sheffer, Y., Holz, R., and P. Saint-Andre,\n              \"Recommendations
      for Secure Use of Transport Layer\n              Security (TLS) and Datagram
      Transport Layer Security\n              (DTLS)\", BCP 195, RFC 7525, DOI 10.17487/RFC7525,\n
      \             May 2015, <https://www.rfc-editor.org/info/rfc7525>.\n   [RFC7595]
      \ Thaler, D., Ed., Hansen, T., and T. Hardie, \"Guidelines\n              and
      Registration Procedures for URI Schemes\", BCP 35,\n              RFC 7595,
      DOI 10.17487/RFC7595, June 2015,\n              <https://www.rfc-editor.org/info/rfc7595>.\n
      \  [RFC7641]  Hartke, K., \"Observing Resources in the Constrained\n              Application
      Protocol (CoAP)\", RFC 7641,\n              DOI 10.17487/RFC7641, September
      2015,\n              <https://www.rfc-editor.org/info/rfc7641>.\n   [RFC7925]
      \ Tschofenig, H., Ed., and T. Fossati, \"Transport Layer\n              Security
      (TLS) / Datagram Transport Layer Security (DTLS)\n              Profiles for
      the Internet of Things\", RFC 7925,\n              DOI 10.17487/RFC7925, July
      2016,\n              <https://www.rfc-editor.org/info/rfc7925>.\n   [RFC7959]
      \ Bormann, C. and Z. Shelby, Ed., \"Block-Wise Transfers in\n              the
      Constrained Application Protocol (CoAP)\", RFC 7959,\n              DOI 10.17487/RFC7959,
      August 2016,\n              <https://www.rfc-editor.org/info/rfc7959>.\n   [RFC8126]
      \ Cotton, M., Leiba, B., and T. Narten, \"Guidelines for\n              Writing
      an IANA Considerations Section in RFCs\", BCP 26,\n              RFC 8126, DOI
      10.17487/RFC8126, June 2017,\n              <https://www.rfc-editor.org/info/rfc8126>.\n
      \  [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in\n              RFC
      2119 Key Words\", BCP 14, RFC 8174,\n              DOI 10.17487/RFC8174, May
      2017,\n              <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8307]
      \ Bormann, C., \"Well-Known URIs for the WebSocket Protocol\",\n              RFC
      8307, DOI 10.17487/RFC8307, January 2018,\n              <https://www.rfc-editor.org/info/rfc8307>.\n"
    title: 12.1.  Normative References
  - contents:
    - "12.2.  Informative References\n   [BK2015]   Byrne, C. and J. Kleberg, \"Advisory
      Guidelines for UDP\n              Deployment\", Work in Progress, draft-byrne-opsec-udp-\n
      \             advisory-00, July 2015.\n   [CoAP-Alt-Transports]\n              Silverajan,
      B. and T. Savolainen, \"CoAP Communication with\n              Alternative Transports\",
      Work in Progress,\n              draft-silverajan-core-coap-alternative-transports-10,\n
      \             July 2017.\n   [CoCoA]    Bormann, C., Betzler, A., Gomez, C.,
      and I. Demirkol,\n              \"CoAP Simple Congestion Control/Advanced\",
      Work in\n              Progress, draft-ietf-core-cocoa-02, October 2017.\n   [EK2016]
      \  Edeline, K., Kuehlewind, M., Trammell, B., Aben, E., and\n              B.
      Donnet, \"Using UDP for Internet Transport Evolution\",\n              arXiv
      preprint 1612.07816, December 2016,\n              <https://arxiv.org/abs/1612.07816>.\n
      \  [HomeGateway]\n              Haetoenen, S., Nyrhinen, A., Eggert, L., Strowes,
      S.,\n              Sarolahti, P., and N. Kojo, \"An experimental study of home\n
      \             gateway characteristics\", Proceedings of the 10th ACM\n              SIGCOMM
      conference on Internet measurement,\n              DOI 10.1145/1879141.1879174,
      November 2010.\n   [IANA.uri-schemes]\n              IANA, \"Uniform Resource
      Identifier (URI) Schemes\",\n              <https://www.iana.org/assignments/uri-schemes>.\n
      \  [LWM2M]    Open Mobile Alliance, \"Lightweight Machine to Machine\n              Technical
      Specification Version 1.0\", February 2017,\n              <http://www.openmobilealliance.org/release/LightweightM2M/\n
      \             V1_0-20170208-A/\n              OMA-TS-LightweightM2M-V1_0-20170208-A.pdf>.\n
      \  [Multi-Transport-URIs]\n              Thaler, D., \"Using URIs With Multiple
      Transport Stacks\",\n              Work in Progress, draft-thaler-appsawg-multi-transport-\n
      \             uris-01, July 2017.\n   [OSCORE]   Selander, G., Mattsson, J.,
      Palombini, F., and L. Seitz,\n              \"Object Security for Constrained
      RESTful Environments\n              (OSCORE)\", Work in Progress, draft-ietf-core-object-\n
      \             security-08, January 2018.\n   [RFC768]   Postel, J., \"User Datagram
      Protocol\", STD 6, RFC 768,\n              DOI 10.17487/RFC0768, August 1980,\n
      \             <https://www.rfc-editor.org/info/rfc768>.\n   [RFC6335]  Cotton,
      M., Eggert, L., Touch, J., Westerlund, M., and S.\n              Cheshire, \"Internet
      Assigned Numbers Authority (IANA)\n              Procedures for the Management
      of the Service Name and\n              Transport Protocol Port Number Registry\",
      BCP 165,\n              RFC 6335, DOI 10.17487/RFC6335, August 2011,\n              <https://www.rfc-editor.org/info/rfc6335>.\n
      \  [RFC6347]  Rescorla, E. and N. Modadugu, \"Datagram Transport Layer\n              Security
      Version 1.2\", RFC 6347, DOI 10.17487/RFC6347,\n              January 2012,
      <https://www.rfc-editor.org/info/rfc6347>.\n   [RFC7230]  Fielding, R., Ed.,
      and J. Reschke, Ed., \"Hypertext\n              Transfer Protocol (HTTP/1.1):
      Message Syntax and Routing\",\n              RFC 7230, DOI 10.17487/RFC7230,
      June 2014,\n              <https://www.rfc-editor.org/info/rfc7230>.\n   [RFC7540]
      \ Belshe, M., Peon, R., and M. Thomson, Ed., \"Hypertext\n              Transfer
      Protocol Version 2 (HTTP/2)\", RFC 7540,\n              DOI 10.17487/RFC7540,
      May 2015,\n              <https://www.rfc-editor.org/info/rfc7540>.\n   [SecurityChallenges]\n
      \             Polk, T. and S. Turner, \"Security Challenges For the\n              Internet
      Of Things\", Interconnecting Smart Objects with\n              the Internet
      / IAB Workshop, February 2011,\n              <https://www.iab.org/wp-content/IAB-uploads/2011/03/\n
      \             Turner.pdf>.\n   [SW2016]   Swett, I., \"QUIC Deployment Experience
      @Google\", IETF 96\n              Proceedings, Berlin, Germany, July 2016,\n
      \             <https://www.ietf.org/proceedings/96/slides/\n              slides-96-quic-3.pdf>.\n
      \  [TCP-in-IoT]\n              Gomez, C., Crowcroft, J., and M. Scharf, \"TCP
      Usage\n              Guidance in the Internet of Things (IoT)\", Work in\n              Progress,
      draft-ietf-lwig-tcp-constrained-node-\n              networks-01, October 2017.\n"
    title: 12.2.  Informative References
  title: 12.  References
- contents:
  - "Appendix A.  Examples of CoAP over WebSockets\n   This appendix gives examples
    for the first two configurations\n   discussed in Section 4.\n   An example of
    the process followed by a CoAP client to retrieve the\n   representation of a
    resource identified by a \"coap+ws\" URI might be\n   as follows.  Figure 17 below
    illustrates the WebSocket and CoAP\n   messages exchanged in detail.\n   1.  The
    CoAP client obtains the URI\n       <coap+ws://example.org/sensors/temperature?u=Cel>,
    for example,\n       from a resource representation that it retrieved previously.\n
    \  2.  The CoAP client establishes a WebSocket connection to the\n       endpoint
    URI composed of the authority \"example.org\" and the\n       well-known path
    \"/.well-known/coap\",\n       <ws://example.org/.well-known/coap>.\n   3.  CSMs
    (Section 5.3) are exchanged (not shown).\n   4.  The CoAP client sends a single-frame,
    masked, binary message\n       containing a CoAP request.  The request indicates
    the target\n       resource with the Uri-Path (\"sensors\", \"temperature\") and\n
    \      Uri-Query (\"u=Cel\") Options.\n   5.  The CoAP client waits for the server
    to return a response.\n   6.  The CoAP client uses the connection for further
    requests, or the\n       connection is closed.\n      CoAP        CoAP\n     Client
    \     Server\n   (WebSocket  (WebSocket\n     Client)     Server)\n        |          |\n
    \       |          |\n        +=========>|  GET /.well-known/coap HTTP/1.1\n        |
    \         |  Host: example.org\n        |          |  Upgrade: websocket\n        |
    \         |  Connection: Upgrade\n        |          |  Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\n
    \       |          |  Sec-WebSocket-Protocol: coap\n        |          |  Sec-WebSocket-Version:
    13\n        |          |\n        |<=========+  HTTP/1.1 101 Switching Protocols\n
    \       |          |  Upgrade: websocket\n        |          |  Connection: Upgrade\n
    \       |          |  Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\n        |
    \         |  Sec-WebSocket-Protocol: coap\n        :          :\n        :<-------->:
    \ Exchange of CSMs (not shown)\n        |          |\n        +--------->|  Binary
    frame (opcode=%x2, FIN=1, MASK=1)\n        |          |    +-------------------------+\n
    \       |          |    | GET                     |\n        |          |    |
    Token: 0x53             |\n        |          |    | Uri-Path: \"sensors\"     |\n
    \       |          |    | Uri-Path: \"temperature\" |\n        |          |    |
    Uri-Query: \"u=Cel\"      |\n        |          |    +-------------------------+\n
    \       |          |\n        |<---------+  Binary frame (opcode=%x2, FIN=1, MASK=0)\n
    \       |          |    +-------------------------+\n        |          |    |
    2.05 Content            |\n        |          |    | Token: 0x53             |\n
    \       |          |    | Payload: \"22.3 Cel\"     |\n        |          |    +-------------------------+\n
    \       :          :\n        :          :\n        +--------->|  Close frame
    (opcode=%x8, FIN=1, MASK=1)\n        |          |\n        |<---------+  Close
    frame (opcode=%x8, FIN=1, MASK=0)\n        |          |\n    Figure 17: A CoAP
    Client Retrieves the Representation of a Resource\n                       Identified
    by a \"coap+ws\" URI\n   Figure 18 shows how a CoAP client uses a CoAP forward
    proxy with a\n   WebSocket endpoint to retrieve the representation of the resource\n
    \  \"coap://[2001:db8::1]/\".  The use of the forward proxy and the\n   address
    of the WebSocket endpoint are determined by the client from\n   local configuration
    rules.  The request URI is specified in the\n   Proxy-Uri Option.  Since the request
    URI uses the \"coap\" URI scheme,\n   the proxy fulfills the request by issuing
    a Confirmable GET request\n   over UDP to the CoAP server and returning the response
    over the\n   WebSocket connection to the client.\n     CoAP        CoAP       CoAP\n
    \   Client      Proxy      Server\n  (WebSocket  (WebSocket    (UDP\n    Client)
    \    Server)   Endpoint)\n       |          |          |\n       +--------->|
    \         |  Binary frame (opcode=%x2, FIN=1, MASK=1)\n       |          |          |
    \   +------------------------------------+\n       |          |          |    |
    GET                                |\n       |          |          |    | Token:
    0x7d                        |\n       |          |          |    | Proxy-Uri:
    \"coap://[2001:db8::1]/\" |\n       |          |          |    +------------------------------------+\n
    \      |          |          |\n       |          +--------->|  CoAP message (Ver=1,
    T=Con, MID=0x8f54)\n       |          |          |    +------------------------------------+\n
    \      |          |          |    | GET                                |\n       |
    \         |          |    | Token: 0x0a15                      |\n       |          |
    \         |    +------------------------------------+\n       |          |          |\n
    \      |          |<---------+  CoAP message (Ver=1, T=Ack, MID=0x8f54)\n       |
    \         |          |    +------------------------------------+\n       |          |
    \         |    | 2.05 Content                       |\n       |          |          |
    \   | Token: 0x0a15                      |\n       |          |          |    |
    Payload: \"ready\"                   |\n       |          |          |    +------------------------------------+\n
    \      |          |          |\n       |<---------+          |  Binary frame (opcode=%x2,
    FIN=1, MASK=0)\n       |          |          |    +------------------------------------+\n
    \      |          |          |    | 2.05 Content                       |\n       |
    \         |          |    | Token: 0x7d                        |\n       |          |
    \         |    | Payload: \"ready\"                   |\n       |          |          |
    \   +------------------------------------+\n       |          |          |\n    Figure
    18: A CoAP Client Retrieves the Representation of a Resource\n       Identified
    by a \"coap\" URI via a WebSocket-Enabled CoAP Proxy\n"
  title: Appendix A.  Examples of CoAP over WebSockets
- contents:
  - "Acknowledgments\n   We would like to thank Stephen Berard, Geoffrey Cristallo,
    Olivier\n   Delaby, Esko Dijk, Christian Groves, Nadir Javed, Michael Koster,\n
    \  Achim Kraus, David Navarro, Szymon Sasin, Goeran Selander, Zach\n   Shelby,
    Andrew Summers, Julien Vermillard, and Gengyu Wei for their\n   feedback.\n   Last
    Call reviews from Yoshifumi Nishida, Mark Nottingham, and Meral\n   Shirazipour
    as well as several IESG reviewers provided extensive\n   comments; from the IESG,
    we would like to specifically call out Ben\n   Campbell, Mirja Kuehlewind, Eric
    Rescorla, Adam Roach, and the\n   responsible AD Alexey Melnikov.\n"
  title: Acknowledgments
- contents:
  - "Contributors\n   Matthias Kovatsch\n   Siemens AG\n   Otto-Hahn-Ring 6\n   Munich
    \ D-81739\n   Germany\n   Phone: +49-173-5288856\n   Email: matthias.kovatsch@siemens.com\n
    \  Teemu Savolainen\n   Nokia Technologies\n   Hatanpaan valtatie 30\n   Tampere
    \ FI-33100\n   Finland\n   Email: teemu.savolainen@nokia.com\n   Valik Solorzano
    Barboza\n   Zebra Technologies\n   820 W. Jackson Blvd. Suite 700\n   Chicago,
    IL  60607\n   United States of America\n   Phone: +1-847-634-6700\n   Email: vsolorzanobarboza@zebra.com\n"
  title: Contributors
- contents:
  - "Authors' Addresses\n   Carsten Bormann\n   Universitaet Bremen TZI\n   Postfach
    330440\n   Bremen  D-28359\n   Germany\n   Phone: +49-421-218-63921\n   Email:
    cabo@tzi.org\n   Simon Lemay\n   Zebra Technologies\n   820 W. Jackson Blvd. Suite
    700\n   Chicago, IL  60607\n   United States of America\n   Phone: +1-847-634-6700\n
    \  Email: slemay@zebra.com\n   Hannes Tschofenig\n   ARM Ltd.\n   110 Fulbourn
    Road\n   Cambridge  CB1 9NJ\n   United Kingdom\n   Email: Hannes.tschofenig@gmx.net\n
    \  URI:   http://www.tschofenig.priv.at\n   Klaus Hartke\n   Universitaet Bremen
    TZI\n   Postfach 330440\n   Bremen  D-28359\n   Germany\n   Phone: +49-421-218-63905\n
    \  Email: hartke@tzi.org\n   Bilhanan Silverajan\n   Tampere University of Technology\n
    \  Korkeakoulunkatu 10\n   Tampere  FI-33720\n   Finland\n   Email: bilhanan.silverajan@tut.fi\n
    \  Brian Raymor (editor)\n   Email: brianraymor@hotmail.com\n"
  title: Authors' Addresses
