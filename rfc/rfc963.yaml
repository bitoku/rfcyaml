- title: __initial_text__
  contents:
  - "              SOME PROBLEMS WITH THE SPECIFICATION OF THE\n                 \
    \ MILITARY STANDARD INTERNET PROTOCOL\n"
- title: STATUS OF THIS MEMO
  contents:
  - "STATUS OF THIS MEMO\n   The purpose of this RFC is to provide helpful information\
    \ on the\n   Military Standard Internet Protocol (MIL-STD-1777) so that one can\n\
    \   obtain a reliable implementation of this protocol standard.\n   Distribution\
    \ of this note is unlimited.\n"
- title: ABSTRACT
  contents:
  - "ABSTRACT\n   This paper points out several significant problems in the\n   specification\
    \ of the Military Standard Internet Protocol\n   (MIL-STD-1777, dated August 1983\
    \ [MILS83a]).  These results are based\n   on an initial investigation of this\
    \ protocol standard.  The problems\n   are: (1) a failure to reassemble fragmented\
    \ messages completely; (2)\n   a missing state transition; (3) errors in testing\
    \ for reassembly\n   completion; (4) errors in computing fragment sizes; (5) minor\
    \ errors\n   in message reassembly; (6) incorrectly computed length for certain\n\
    \   datagrams.  This note also proposes solutions to these problems.\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   In recent years, much progress has been made in creating\
    \ an\n   integrated set of tools for developing reliable communication\n   protocols.\
    \  These tools provide assistance in the specification,\n   verification, implementation\
    \ and testing of protocols.  Several\n   protocols have been analyzed and developed\
    \ using such tools.\n   Examples of automated verification and implementation\
    \ of several real\n   world protocols are discussed in [BLUT82] [BLUT83] [SIDD83]\
    \ [SIDD84].\n   We are currently working on the automatic implementation of the\n\
    \   Military Standard Internet Protocol (IP).  This analysis will be\n   based\
    \ on the published specification [MILS83a] of IP dated 12 August\n   1983.\n \
    \  While studying the MIL Standard IP specification, we have noticed\n   numerous\
    \ errors in the specification of this protocol.  One\n   consequence of these\
    \ errors is that the protocol will never deliver\n   fragmented incoming datagrams;\
    \ if this error is corrected, such\n   datagrams will be missing some data and\
    \ their lengths will be\n   incorrectly reported.  In addition, outgoing datagrams\
    \ that are\n   divided into fragments will be missing some data.  The proof of\
    \ these\n   statements follows from the specification of IP [MILS83a] as\n   discussed\
    \ below.\n"
- title: RFC 963                                                    November 1985
  contents:
  - 'RFC 963                                                    November 1985

    '
- title: Some Problems with MIL-STD IP
  contents:
  - 'Some Problems with MIL-STD IP

    '
- title: 2.  Internet Protocol
  contents:
  - "2.  Internet Protocol\n   The Internet Protocol (IP) is a network layer protocol\
    \ in the DoD\n   protocol hierarchy which provides communication across interconnected\n\
    \   packet-switched networks in an internetwork environment.  IP provides\n  \
    \ a pure datagram service with no mechanism for reliability, flow\n   control,\
    \ sequencing, etc.  Instead, these features are provided by a\n   connection-oriented\
    \ protocol, DoD Transmission Control Protocol (TCP)\n   [MILS83b], which is implemented\
    \ in the layer above IP.  TCP is\n   designed to operate successfully over channels\
    \ that are inherently\n   unreliable, i.e., which can lose, damage, duplicate,\
    \ and reorder\n   packets.\n   Over the years, DARPA has supported specifications\
    \ of several\n   versions of IP; the last one appeared in [POSJ81].  A few years\
    \ ago,\n   the Defense Communications Agency decided to standardize IP for use\n\
    \   in DoD networks.  For this purpose, the DCA supported formal\n   specification\
    \ of this protocol, following the design discussed in\n   [POSJ81] and the technique\
    \ and organization defined in [SDC82].  A\n   detailed specification of this protocol,\
    \ given in [MILS83a], has been\n   adopted as the DoD standard for the Internet\
    \ Protocol.\n   The specification of IP state transitions is organized into decision\n\
    \   tables; the decision functions and action procedures are specified in\n  \
    \ a subset of Ada[1], and may employ a set of machine-specific data\n   structures.\
    \  Decision tables are supplied for the pairs <state name,\n   interface event>\
    \ as follows: <inactive, send from upper layer>,\n   <inactive, receive from lower\
    \ layer>, and <reassembling, receive from\n   lower layer>.  To provide an error\
    \ indication in the case that some\n   fragments of a datagram are received but\
    \ some are missing, a decision\n   table is also supplied for the pair <reassembling,\
    \ reassembly time\n   limit elapsed>.  (The event names are English descriptions\
    \ and not\n   the names employed by [MILS83a].)\n"
- title: 3.  Problems with MIL Standard IP
  contents:
  - "3.  Problems with MIL Standard IP\n   One of the major functions of IP is the\
    \ fragmentation of datagrams\n   that cannot be transmitted over a subnetwork\
    \ in one piece, and their\n   subsequent reassembly.  The specification has several\
    \ problems in\n   this area.  One of the most significant is the failure to insert\
    \ the\n   last fragment of an incoming datagram; this would cause datagrams to\n\
    \   be delivered to the upper-level protocol (ULP) with some data\n   missing.\
    \ Another error in this area is that an incorrect value of the\n   data length\
    \ for reassembled datagrams is passed to the ULP, with\n   unpredictable consequences.\n\
    \   As the specification [MILS83a] is now written, these errors are of\n"
- title: RFC 963                                                    November 1985
  contents:
  - 'RFC 963                                                    November 1985

    '
- title: Some Problems with MIL-STD IP
  contents:
  - "Some Problems with MIL-STD IP\n   little consequence, since the test for reassembly\
    \ completion will\n   always fail, with the result that reassembled datagrams\
    \ would never\n   be delivered at all.\n   In addition, a missing row in one of\
    \ the decision tables creates the\n   problem that network control (ICMP) messages\
    \ that arrive in fragments\n   will never be processed.  Among the other errors\
    \ are the possibility\n   that a few bytes will be discarded from each fragment\
    \ transmitted and\n   certain statements that will create run-time exceptions\
    \ instead of\n   performing their intended functions.\n   A general problem with\
    \ this specification is that the program\n   language and action table portions\
    \ of the specification were clearly\n   not checked by any automatic syntax checking\
    \ process.  Variable and\n   procedure names are occasionally misspelled, and\
    \ the syntax of the\n   action statements is often incorrect.  We have enumerated\
    \ some of\n   these problems below as a set of cautionary notes to implementors,\n\
    \   but we do not claim to have listed them all.  In particular, syntax\n   errors\
    \ are only discussed when they occur in conjunction with other\n   problems.\n\
    \   The following section discusses some of the serious errors that we\n   have\
    \ discovered with the MIL standard IP [MIL83a] during our initial\n   study of\
    \ this protocol.  We also propose corrections to each of these\n   problems.\n"
- title: 4.  Detailed Discussion of the Problems
  contents:
  - "4.  Detailed Discussion of the Problems\n   Problem 1: Failure to Insert Last\
    \ Fragment\n      This problem occurs in the decision table corresponding to the\n\
    \      state reassembling and the input \"receive from lower layer\"\n      [MILS83a,\
    \ sec 9.4.6.1.3].  The problem occurs in the following row\n      of this table:[2]\n\
    \      ________________________________________________________\n      check-\
    \    SNP      TTL    where    a     reass    ICMP\n       sum     params   valid\
    \    to     frag   done    check-\n      valid?   valid?     ?       ?      ?\
    \       ?      sum?\n      __________________________________________________________________\n\
    \      YES      YES      YES     ULP    YES     YES      d      reass_\n     \
    \                                                          delivery;\n       \
    \                                                        state :=\n          \
    \                                                      INACTIVE\n      __________________________________________________________________\n\
    \      The reass_done function, as will be seen below, returns YES if the\n"
- title: RFC 963                                                    November 1985
  contents:
  - 'RFC 963                                                    November 1985

    '
- title: Some Problems with MIL-STD IP
  contents:
  - "Some Problems with MIL-STD IP\n      fragment just received is the last fragment\
    \ needed to assemble a\n      complete datagram and NO otherwise.  The action\
    \ procedure\n      reass_delivery simply delivers a completely reassembled datagram\n\
    \      to the upper-level protocol.  It is the action procedure\n      reassemble\
    \ that inserts an incoming fragment into the datagram\n      being assembled.\
    \  Since this row does not call reassemble, the\n      result will be that every\
    \ incoming fragmented datagram will be\n      delivered to the upper layer with\
    \ one fragment missing.  The\n      solution is to rewrite this row of the table\
    \ as follows:\n      ________________________________________________________\n\
    \      check-    SNP      TTL    where    a     reass    ICMP\n       sum    \
    \ params   valid    to     frag   done    check-\n      valid?   valid?     ?\
    \       ?      ?       ?      sum?\n      __________________________________________________________________\n\
    \      YES      YES      YES     ULP    YES     YES      d    reassemble;\n  \
    \                                                             reass_\n       \
    \                                                        delivery;\n         \
    \                                                      state :=\n            \
    \                                                    INACTIVE\n      __________________________________________________________________\n\
    \      Incidentally, the mnemonic value of the name of the reass_done\n      function\
    \ is questionable, since at the moment this function is\n      called datagram\
    \ reassembly cannot possibly have been completed.  A\n      better name for this\
    \ function might be last_fragment.\n   Problem 2: Missing State Transition\n \
    \     This problem is the omission of a row of the same decision table\n     \
    \ [MILS83a, sec 9.4.6.1.3].  Incoming packets may be directed to an\n      upper-level\
    \ protocol (ULP), or they may be network control\n      messages, which are marked\
    \ ICMP (Internet Control Message\n      Protocol).  When control messages have\
    \ been completely assembled,\n      they are processed by an IP procedure called\
    \ analyze.  The\n      decision table contains the row\n      ________________________________________________________\n\
    \      check-    SNP      TTL    where    a     reass    ICMP\n       sum    \
    \ params   valid    to     frag   done    check-\n      valid?   valid?     ?\
    \       ?      ?       ?      sum?\n      __________________________________________________________________\n\
    \      YES      YES      YES    ICMP    YES     NO       d    reassemble;\n  \
    \    __________________________________________________________________\n"
- title: RFC 963                                                    November 1985
  contents:
  - 'RFC 963                                                    November 1985

    '
- title: Some Problems with MIL-STD IP
  contents:
  - "Some Problems with MIL-STD IP\n      but makes no provision for the case in which\
    \ where_to returns\n      ICMP, a_frag returns YES, and reass_done returns YES.\
    \  An\n      additional row should be inserted, which reads as follows:\n    \
    \  ________________________________________________________\n      check-    SNP\
    \      TTL    where    a     reass    ICMP\n       sum     params   valid    to\
    \     frag   done    check-\n      valid?   valid?     ?       ?      ?      \
    \ ?      sum?\n      __________________________________________________________________\n\
    \      YES      YES      YES    ICMP    YES     YES      d    reassemble;\n  \
    \                                                             analyze;\n     \
    \                                                          state :=\n        \
    \                                                        INACTIVE\n      __________________________________________________________________\n\
    \      Omitting this row means that incoming fragmented ICMP messages\n      will\
    \ never be analyzed, since the state machine does not have any\n      action specified\
    \ when the last fragment is received.\n   Problem 3: Errors in reass_done\n  \
    \    The function reass_done, as can be seen from the above, determines\n    \
    \  whether the incoming subnetwork packet contains the last fragment\n      needed\
    \ to complete the reassembly of an IP datagram.  In order to\n      understand\
    \ the errors in this function, we must first understand\n      how it employs\
    \ its data structures.\n      The reassembly of incoming fragments is accomplished\
    \ by means of a\n      bit map maintained separately for each state machine. \
    \ Since all\n      fragments are not necessarily the same length, each bit in\
    \ the map\n      represents not a fragment, but a block, that is, a unit of eight\n\
    \      octets.  Each fragment, with the possible exception of the \"tail\"\n \
    \     fragment (we shall define this term below), is an integral number\n    \
    \  of consecutive blocks. Each fragment's offset from the beginning\n      of\
    \ the datagram is given, in units of blocks, by a field in the\n      packet header\
    \ of each incoming packet.  The total length of each\n      fragment, including\
    \ the fragment's header, is specified in the\n      header field total_length;\
    \ this length is given in octets.  The\n      length of the header is specified\
    \ in the field header_length; this\n      length is given in words, that is, units\
    \ of four octets.\n      In analyzing this subroutine, we must distinguish between\
    \ the\n      \"tail\" fragment and the \"last\" fragment.  We define the last\n\
    \      fragment as the one which is received last in time, that is, the\n    \
    \  fragment that permits reassembly to be completed.  The tail\n      fragment\
    \ is the fragment that is spatially last, that is, the\n      fragment that is\
    \ spatially located after any other fragment.  The\n"
- title: RFC 963                                                    November 1985
  contents:
  - 'RFC 963                                                    November 1985

    '
- title: Some Problems with MIL-STD IP
  contents:
  - "Some Problems with MIL-STD IP\n      length and offset of the tail fragment make\
    \ it possible to compute\n      the length of the entire datagram.  This computation\
    \ is actually\n      done in the action procedure reassembly, and the result is\
    \ saved\n      in the state vector field total_data_length; if the tail fragment\n\
    \      has not been received, this value is assumed to be zero.\n      It is the\
    \ task of the reass_done function [MILS83a, sec 9.4.6.2.6]\n      to determine\
    \ whether the incoming fragment is the last fragment.\n      This determination\
    \ is made as follows:\n         1) If the tail fragment has not been received\
    \ previously and\n         the incoming fragment is not the tail fragment, then\
    \ return NO.\n         2) Otherwise, if the tail fragment has not been received,\
    \ but\n         the incoming fragment is the tail fragment, determine whether\n\
    \         all fragments spatially preceding the tail fragment have also\n    \
    \     been received.\n         3) Otherwise, if the tail fragment has been received\
    \ earlier,\n         determine whether the incoming fragment is the last one needed\n\
    \         to complete reassembly.\n      The evaluation of case (2) is accomplished\
    \ by the following\n      statment:\n         if (state_vector.reassembly_map\
    \ from 0 to\n           (((from_SNP.dtgm.total_length -\n               (from_SNP.dtgm.header_length\
    \ * 4) + 7) / 8)\n           + 7) / 8 is set)\n         then return YES;\n   \
    \   The double occurrence of the subexpression \" + 7 ) / 8\" is\n      apparently\
    \ a misprint.  The function f(x) = (x + 7) / 8 will\n      convert x from octets\
    \ to blocks, rounding any remainder upward.\n      There is no need for this function\
    \ to be performed twice.  The\n      second problem is that the fragment_offset\
    \ field of the incoming\n      packet is ignored.  The tail fragment specifies\
    \ only its own\n      length, not the length of the entire datagram; to determine\
    \ the\n      latter, the tail fragment's offset must be added to the tail\n  \
    \    fragment's own length.  The third problem hinges on the meaning of\n    \
    \  the English \"... from ... to ...\" phrase.  If this phrase has the\n     \
    \ same meaning as the \"..\" range indication in Ada [ADA83, sec 3.6],\n     \
    \ that is, includes both the upper and lower bounds, then it is\n      necessary\
    \ to subtract 1 from the final expression.\n      The expression following the\
    \ word to, above, should thus be\n      changed to read\n"
- title: RFC 963                                                    November 1985
  contents:
  - 'RFC 963                                                    November 1985

    '
- title: Some Problems with MIL-STD IP
  contents:
  - "Some Problems with MIL-STD IP\n         from_SNP.dtgm.fragment_offset +\n   \
    \          ((from_SNP.dtgm.total_length -\n                 (from_SNP.dtgm.header_length\
    \ * 4) + 7) / 8) - 1\n      Another serious problem with this routine occurs when\
    \ evaluating\n      case (3).  In this case, the relevant statement is\n     \
    \    if (all reassembly map from 0 to\n           (state_vector.total_data_length\
    \ + 7)/8 is set\n         then return YES\n      If the tail fragment was received\
    \ earlier, the code asks, in\n      effect, whether all the bits in the reassembly\
    \ map have been set.\n      This, however, will not be the case even if the incoming\
    \ fragment\n      is the last fragment, since the routine reassembly, which actually\n\
    \      sets these bits, has not yet been called for this fragment.  This\n   \
    \   statement must therefore skip the bits corresponding to the\n      incoming\
    \ fragment.  In specifying the range to be tested,\n      allowance must be made\
    \ for whether these bits fall at the\n      beginning of the bit map or in the\
    \ middle (the case where they\n      fall at the end has already been tested).\
    \ The statement must\n      therefore be changed to read\n         if from_SNP.dtgm.fragment_offset\
    \ = 0 then\n           if (all reassembly map from\n             from_SNP.dtgm.fragment_offset\
    \ +\n               ((from_SNP.dtgm.total_length -\n                 from_SNP.dtgm.header_length\
    \ * 4) + 7) / 8\n             to ((state_vector.total_data_length + 7) / 8 - 1)\
    \ is set)\n           then return YES;\n           else return NO;\n         \
    \  end if;\n           else\n           if (all reassembly map from 0 to\n   \
    \          (from_SNP.dtgm.fragment_offset - 1) is set)\n             and (all\
    \ reassembly map from\n               from_SNP.dtgm.fragment_offset +\n      \
    \           ((from_SNP.dtgm.total_length -\n                   from_SNP.dtgm.header_length\
    \ * 4) + 7) / 8\n               to ((state_vector.total_data_length + 7) / 8 -\
    \ 1) is set)\n           then return YES;\n           else return NO;\n      \
    \     end if;\n           end if;\n"
- title: RFC 963                                                    November 1985
  contents:
  - 'RFC 963                                                    November 1985

    '
- title: Some Problems with MIL-STD IP
  contents:
  - "Some Problems with MIL-STD IP\n      Note that here again it is necessary to\
    \ subtract 1 from the upper\n      bound.\n   Problem 4: Errors in fragment_and_send\n\
    \      The action procedure fragment_and_send [MILS83a, sec 9.4.6.3.7] is\n  \
    \    used to break up datagrams that are too large to be sent through\n      the\
    \ subnetwork as a single packet.  The specification requires\n      [MILS83a sec\
    \ 9.2.2, sec 9.4.6.3.7] each fragment, except possibly\n      the \"tail\" fragment,\
    \ to contain a whole number of 8-octet groups\n      (called \"blocks\"); moreover,\
    \ each fragment must begin at a block\n      boundary.\n      In the algorithm\
    \ set forth in fragment_and_send, all fragments\n      except the tail fragment\
    \ are set to the same size; the procedure\n      begins by calculating this size.\
    \  This is done by the following\n      statement:\n         data_per_fragment\
    \ := maximum subnet transmission unit\n                                - (20 +\
    \ number of bytes of option data);\n      Besides the failure to allow for header\
    \ padding, which is\n      discussed in the next section, this statement makes\
    \ the serious\n      error of not assuring that the result is an integral multiple\
    \ of\n      the block size, i.e., a multiple of eight octets.  The consequence\n\
    \      of this would be that as many as seven octets per fragment would\n    \
    \  never be sent at all. To correct this problem, and to allow for\n      header\
    \ padding, this statement must be changed to\n         data_per_fragment := (maximum\
    \ subnet transmission unit\n                  - (((20 + number of bytes of option\
    \ data)+3)/4*4)/8*8;\n      Another problem in this procedure is the failure to\
    \ provide for\n      the case in which the length of the data is an exact multiple\
    \ of\n      eight.  The procedure contains the statements\n         number_of\
    \ fragments := (from_ULP.length +\n                           (data_per_fragment\
    \ - 1)) / data_per_fragment;\n         data_in_last_frag := from_ULP.length modulo\
    \ data_per_fragment;\n      (Note that in our terminology we would rename data_in_last_frag\
    \ as\n      data_in_tail_frag; notice, also, that the proper spelling of the\n\
    \      Ada operator is mod [ADA83, sec 4.5.5].)\n      If data_in_last_frag is\
    \ zero, some serious difficulties arise.\n      One result might be that the datagram\
    \ will be broken into one more\n"
- title: RFC 963                                                    November 1985
  contents:
  - 'RFC 963                                                    November 1985

    '
- title: Some Problems with MIL-STD IP
  contents:
  - "Some Problems with MIL-STD IP\n      fragment than necessary, with the tail fragment\
    \ containing no data\n      bytes.  The assignment of data into the tail fragment\
    \ will succeed\n      even though it will now take the form\n         output_data\
    \ [i..i-1] := input_data [j..j-1];\n      because Ada makes provision for so-called\
    \ \"null slices\" [ADA83,\n      sec 4.1.2] and will treat this assignment as\
    \ a no-op [ADA83, sec\n      5.2.1].\n      This does, however, cause the transmission\
    \ of an unnecessary\n      packet, and also creates difficulties for the reassembly\n\
    \      procedure, which must now be prepared to handle empty packets, for\n  \
    \    which not even one bit of the reassembly map should be set.\n      Moreover,\
    \ as the procedure is now written, even this will not\n      occur.  This is because\
    \ the calculation of the number of fragments\n      is incorrect.\n      A numerical\
    \ example will clarify this point.  Suppose that the\n      total datagram length\
    \ is 16 bytes and that the number of bytes per\n      fragment is to be 8.  Then\
    \ the above statements will compute\n      number_of_fragments = (16 + 7)/8 =\
    \ 2 and data_in_last_frag = 16\n      mod 8 = 0.  The result of the inconsistency\
    \ between\n      number_of_fragments and data_in_last_frag will be that instead\
    \ of\n      sending three fragments, of lengths 8, 8, and 0, the procedure\n \
    \     will send only two fragments, of lengths 8 and 0; the last eight\n     \
    \ octets will never be sent.\n      To avoid these difficulties, the specification\
    \ should add the\n      following statement, immediately after computing\n   \
    \   data_in_last_frag:\n         if data_in_last_frag = 0 then\n             \
    \                    data_in_last_frag := data_per_fragment;\n         end if;\n\
    \      This procedure also contains several minor errors.  In addition to\n  \
    \    failures to account for packet header padding, which are\n      enumerated\
    \ in the next section, there is a failure to convert the\n      header length\
    \ from words (four octets) to octets in one statement.\n      This statement,\
    \ which calculates the total length of the non-tail\n      fragments, is\n   \
    \      to_SNP.dtgm.total_length := to_SNP.dtgm.header_length\n               \
    \                                     + data_per_fragment;\n"
- title: RFC 963                                                    November 1985
  contents:
  - 'RFC 963                                                    November 1985

    '
- title: Some Problems with MIL-STD IP
  contents:
  - "Some Problems with MIL-STD IP\n      Since header length is expressed  in  units\
    \  of  words,  this\n      statement should read\n         to_SNP.dtgm.total_length\
    \ := to_SNP.dtgm.header_length * 4\n                                         \
    \           + data_per_fragment;\n      This is apparently no more than a misprint,\
    \ since the\n      corresponding calculation for the tail fragment is done correctly.\n\
    \   Problem 5: Errors in reassembly\n      The action procedure reassembly [MILS83a,\
    \ sec 9.4.6.3.9], which is\n      referred to as reassemble elsewhere in the specification\
    \ [MILS83a,\n      sec 9.4.6.1.2, sec 9.4.6.1.3], inserts an incoming fragment\
    \ into a\n      datagram being reassembled.  This procedure contains several\n\
    \      relatively minor errors.\n      In two places in this procedure, a range\
    \ is written to contain one\n      more member than it ought to have.  In the\
    \ first, data from the\n      fragment is to be inserted into the datagram being\
    \ reassembled:\n         state_vector.data [from_SNP.dtgm.fragment_offset*8 ..\n\
    \             from_SNP.dtgm.fragment_offset*8 + data_in_frag] :=\n           \
    \          from_SNP.dtgm.data [0..data_in_frag-1];\n      In this statement, the\
    \ slice on the left contains one more byte\n      than the slice on the right.\
    \  This will cause a run-time exception\n      to be raised [ADA83, sec 5.2.1].\
    \  The statement should read\n         state_vector.data [from_SNP.dtgm.fragment_offset*8\
    \ ..\n             from_SNP.dtgm.fragment_offset*8 + data_in_frag - 1] :=\n  \
    \                   from_SNP.dtgm.data [0..data_in_frag-1];\n      A similar problem\
    \ occurs in the computation of the range of bits\n      in the reassembly map\
    \ that corresponds to the incoming fragment.\n      This statement begins\n  \
    \       for j in (from_SNP.dtgm.fragment_offset) ..\n                  ((from_SNP.dtgm.fragment_offset\
    \ +\n                 data_in_frag + 7)/8) loop\n      Not only are the parentheses\
    \ in this statement located incorrectly\n      (because the function f(x) = (x\
    \ + 7) / 8 should be executed only\n      on the argument data_in_frag), but also\
    \ this range contains one\n      extra member.  The statement should read\n"
- title: RFC 963                                                    November 1985
  contents:
  - 'RFC 963                                                    November 1985

    '
- title: Some Problems with MIL-STD IP
  contents:
  - "Some Problems with MIL-STD IP\n         for j in (from_SNP.dtgm.fragment_offset)\
    \ ..\n                  (from_SNP.dtgm.fragment_offset +\n                 (data_in_frag\
    \ + 7)/8) - 1 loop\n      Note that if the statement is corrected in this manner\
    \ it will\n      also handle the case of a zero-length fragment, mentioned above,\n\
    \      since the loop will not be executed even once [ADA83, sS 5.5].\n      Another\
    \ minor problem occurs when this procedure attempts to save\n      the header\
    \ of the leading fragment.  The relevant statement is\n         state_vector.header\
    \ := from_SNP.dtgm;\n      This statement attempts to transfer the entire incoming\
    \ fragment\n      into a record that is big enough to contain only the header.\
    \  The\n      result, in Ada, is not truncation, but a run-time exception\n  \
    \    [ADA83, sec 5.2]. The correction should be something like\n         state_vector.header\
    \ := from_SNP.dtgm.header;\n      This correction cannot be made without also\
    \ defining the header\n      portion of the datagram as a subrecord in [MILS83a,\
    \ sec 9.4.4.6];\n      such a definition would also necessitate changing many\
    \ other\n      statements. For example, from_SNP.dtgm.fragment_offset would now\n\
    \      have to be written as from_SNP.dtgm.header.fragment_offset.\n      Another\
    \ possible solution is to write the above statement as a\n      series of assignments\
    \ for each field in the header, in the\n      following fashion:\n         state_vector.header.version\
    \ :=\n                                                  from_SNP.dtgm.version;\n\
    \         state_vector.header.header_length :=\n                             \
    \               from_SNP.dtgm.header_length;\n         state_vector.header.type_of_service\
    \ :=\n                                          from_SNP.dtgm.type_of_service;\n\
    \         -- etc.\n      Note also that this procedure will fail if an incoming\
    \ fragment,\n      other than the tail fragment, does not contain a multiple of\
    \ eight\n      characters.  Implementors must be careful to check for this in\
    \ the\n      decision function SNP_params_valid [MILS83a, sec 9.4.6.2.7].\n"
- title: RFC 963                                                    November 1985
  contents:
  - 'RFC 963                                                    November 1985

    '
- title: Some Problems with MIL-STD IP
  contents:
  - "Some Problems with MIL-STD IP\n   Problem 6: Incorrect Data Length for Fragmented\
    \ Datagrams\n      The procedure reassembled_delivery [MILS83a, sec 9.4.6.3.10]\
    \ does\n      not deliver the proper data length to the upper-level protocol.\n\
    \      This is because the assignment is\n         to_ULP.length := state_vector.header.total_length\n\
    \                                - state_vector.header.header_length * 4;\n  \
    \    The fields in state_vector.header have been filled in by the\n      reassembly\
    \ procedure, discussed above, by copying the header of\n      the leading fragment.\
    \  The field total_length in this fragment,\n      however, refers only to this\
    \ particular fragment, and not to the\n      entire datagram (this is not entirely\
    \ clear from it definition in\n      [MILS83a, sec 9.3.4], but the fragment_and_send\
    \ procedure\n      [MILS83a, sec 9.4.6.3.7] insures that this is the case).\n\
    \      The length of the entire datagram can only be computed from the\n     \
    \ length and offset of the tail fragment.  This computation is\n      actually\
    \ done in the reassembly procedure [MILS83a, sec\n      9.4.6.3.9], and the result\
    \ saved in state_vector.total_data_length\n      (see above).  It is impossible,\
    \ however, for reassembly to fill in\n      state_vector.header.total_length at\
    \ this time, because\n      state_vector.header.header_length is filled in from\
    \ the lead\n      fragment, which may not yet have been received.\n      Therefore,\
    \ reassembled_delivery must replace the above statement\n      with\n        \
    \ to_ULP.length := state_vector.total_data_length;\n      The consequence of leaving\
    \ this error uncorrected is that the\n      upper-level protocol will be informed\
    \ only of the delivery of as\n      many octets as there are in the lead fragment.\n"
- title: 5.  Implementation Difficulties of MIL Standard IP
  contents:
  - "5.  Implementation Difficulties of MIL Standard IP\n   In addition to the problems\
    \ discussed above, there are several\n   features of the MIL standard IP specification\
    \ [MILS83a] which lead to\n   difficulties for the implementor.  These difficulties,\
    \ while not\n   actually errors in the specification, take the form of assumptions\n\
    \   which are not explicitly stated, but of which implementors must be\n   aware.\n"
- title: RFC 963                                                    November 1985
  contents:
  - 'RFC 963                                                    November 1985

    '
- title: Some Problems with MIL-STD IP
  contents:
  - "Some Problems with MIL-STD IP\n   5.1  Header Padding\n      In several places,\
    \ the specification makes a computation of the\n      length of a packet header\
    \ without explicitly allowing for padding.\n      The padding is needed because\
    \ the specification requires [MILS83a,\n      sec 9.3.14] that each header end\
    \ on a 32-bit boundary.\n      One place this problem arises is in the need_to_frag\
    \ decision\n      function [MILS83a, sec 9.4.6.2.5].  This function is used to\n\
    \      determine whether fragmentation is required for an outgoing\n      datagram.\
    \ It consists of the single statement\n         if ((from_ULP.length + (number\
    \ of bytes of option data)\n               + 20) > maximum transmission unit of\
    \ the local subnetwork\n         then return YES\n         else return NO;\n \
    \        end if;\n      (A minor syntax error results from not terminating the\
    \ first\n      return statement with a semicolon [ADA83, sec 5.1, sec 5.3, sec\n\
    \      5.9].) In order to allow for padding, the expression for the\n      length\
    \ of the outgoing datagram should be\n         (((from_ULP.length + (number of\
    \ bytes of option data) + 20)\n                                              \
    \               + 3)/4 * 4)\n      Another place that this problem arises is in\
    \ the action procedure\n      build_and_send [MILS83a, sec 9.4.6.3.2], which prepares\n\
    \      unfragmented datagrams for transmission.  To compute the header\n     \
    \ field header_length, which is expressed in words, i.e., units of\n      four\
    \ octets [MILS83a, sec 9.3.2], this procedure contains the\n      statement\n\
    \         to_SNP.dtgm.header_length := 5 +\n                                 \
    \    (number of bytes of option data)/4;\n      In order to allow for padding,\
    \ this statement should read\n         to_SNP.dtgm.header_length :=\n        \
    \                     5 + ((number of bytes of option data)+3)/4;\n      The identical\
    \ statement appears in the action procedure\n      fragment_and_send [MILS83a,\
    \ sec 9.4.6.3.7], which prepares\n      datagram fragments for transmission, and\
    \ requires the same\n      correction.\n"
- title: RFC 963                                                    November 1985
  contents:
  - 'RFC 963                                                    November 1985

    '
- title: Some Problems with MIL-STD IP
  contents:
  - "Some Problems with MIL-STD IP\n      The procedure fragment_and_send also has\
    \ this problem in two other\n      places.  In the first, the number of octets\
    \ in each fragment is\n      computed by\n         data_per_fragment := maximum\
    \ subnet transmission unit\n                                - (20 + number of\
    \ bytes of option data);\n      In order to allow for padding, this statement\
    \ should read\n         data_per_fragment := maximum subnet transmission unit\n\
    \                      - (((20 + number of bytes of option data)+3)/4*4);\n  \
    \    (Actually, this statement must be changed to\n         data_per_fragment\
    \ := (maximum subnet transmission unit\n                  - (((20 + number of\
    \ bytes of option data)+3)/4*4)/8*8;\n      in order to accomplish its intended\
    \ purpose, for reasons which\n      have been discussed above.)\n      A similar\
    \ problem occurs in the statement which computes the\n      header length for\
    \ individual fragments:\n         to_SNP.dtgm.header_length := 5 +\n         \
    \                             (number of copy options octets/4);\n      To allow\
    \ for padding, this should be changed to\n         to_SNP.dtgm.header_length :=\
    \ 5 +\n                                    (number of copy options octets+3/4);\n\
    \      Notice that all of these errors can also be corrected if the\n      English\
    \ phrase \"number of bytes of option data\", and similar\n      phrases, are always\
    \ understood to include any necessary padding.\n   5.2  Subnetworks with Small\
    \ Transmission Sizes\n      When an outgoing datagram is too large to be transmitted\
    \ as a\n      single packet, it must be fragmented.  On certain subnetworks, the\n\
    \      possibility exists that the maximum number of bytes that may be\n     \
    \ transmitted at a time is less than the size of an IP packet header\n      for\
    \ a given datagram.  In this case, the datagram cannot be sent,\n      even in\
    \ fragmented form.  Note that this does not necessarily mean\n      that the subnetwork\
    \ cannot send any datagrams at all, since the\n      size of the header may be\
    \ highly variable.  When this problem\n      arises, it should be detected by\
    \ IP.  The proper place to detect\n      this situation is in the function can_frag.\n"
- title: RFC 963                                                    November 1985
  contents:
  - 'RFC 963                                                    November 1985

    '
- title: Some Problems with MIL-STD IP
  contents:
  - "Some Problems with MIL-STD IP\n      The can_frag decision function [MILS83a,\
    \ sec 9.4.6.2.2] is used to\n      determine whether a particular outgoing datagram,\
    \ which is too\n      long to be transmitted as a single fragment, is allowed\
    \ to be\n      fragmented. In the current specification, this function consists\n\
    \      of the single statement\n         if (from_ULP.dont_fragment = TRUE)\n\
    \         then return NO\n         else return YES\n         end if;\n      (A\
    \ minor syntax error is that the return statements should be\n      terminated\
    \ by semicolons; see [ADA83, sec 5.1, sec 5.3, sec 5.9].)\n      If the above\
    \ problem occurs, the procedure fragment_and_send will\n      obtain negative\
    \ numbers for fragment sizes, with unpredictable\n      results.  This should\
    \ be prevented by assuring that the subnetwork\n      can send the datagram header\
    \ and at least one block (eight octets)\n      of data.  The can_frag function\
    \ should be recoded as\n         if ((8 + ((number of bytes of option data)+3)/4*4\
    \ + 20)\n                    > maximum transmission unit of the local subnetwork)\n\
    \         then return NO;\n         elsif (from_ULP.dont_fragment = TRUE)\n  \
    \       then return NO\n         else return YES\n         end if;\n      This\
    \ is similar to the logic of the function need_to_frag,\n      discussed above.\n\
    \   5.3  Subnetwork Interface\n      Provision is made for the subnetwork to report\
    \ errors to IP\n      [MILS83a, sec 6.3.6.2], but no provision is made for the\
    \ IP entity\n      to take any action when such errors occur.\n      In addition,\
    \ the specification [MILS83a, sec 8.2.1.1] calls for\n      the subnetwork to\
    \ accept type-of-service indicators (precedence,\n      reliability, delay, and\
    \ throughput), which may be difficult to\n      implement on many local networks.\n"
- title: RFC 963                                                    November 1985
  contents:
  - 'RFC 963                                                    November 1985

    '
- title: Some Problems with MIL-STD IP
  contents:
  - "Some Problems with MIL-STD IP\n   5.4  ULP Errors\n      The IP specification\
    \ [MILS83a, sec 9.4.6.3.6] states\n         The format of error reports to a ULP\
    \ is implementation\n         dependent. However, included in the report should\
    \ be a value\n         indicating the type of error, and some information to identify\n\
    \         the associated data or datagram.\n      The most natural way to provide\
    \ the latter information would be to\n      return the datagram identifier to\
    \ the upper-level protocol, since\n      this identifier is normally supplied\
    \ by the sending ULP [MILS83a,\n      sec 9.3.5].  However, the to_ULP data structure\
    \ makes no provision\n      for this information [MILS83a, sec 9.4.4.3], probably\
    \ because this\n      information is irrelevant for datagrams received from the\n\
    \      subnetwork. Implementors may feel a need to add this field to the\n   \
    \   to_ULP data structure.\n   5.5  Initialization of Data Structures\n      The\
    \ decision function reass_done [MILS83a, sec 9.4.6.2.6] makes\n      the implicit\
    \ assumption that data structures within each finite\n      state machine are\
    \ initialized to zero when the machine is created.\n      In particular, this\
    \ routine will not function properly unless\n      state_vector.reassembly_map\
    \ and state_vector.total_data_length are\n      so initialized.  Since this assumption\
    \ is not stated explicitly,\n      implementors should be aware of it.  There\
    \ may be other\n      initialization assumptions that we have not discovered.\n\
    \   5.6  Locally Defined Types\n      The procedures error_to_source [MILS83a,\
    \ sec 9.4.6.3.5] and\n      error_to_ULP [MILS83a, sec 9.4.6.3.6] define enumeration\
    \ types in\n      comments.  The former contains the comment\n         error_param\
    \ : (PARAM_PROBLEM, EXPIRED_TTL, PROTOCOL_UNREACH);\n      and the latter\n  \
    \       error_param : (PARAM_PROBLEM, CAN'T_FRAGMENT, NET_UNREACH,\n         \
    \                               PROTOCOL_UNREACH, PORT_UNREACH);\n      These\
    \ enumerated values are used before they are encountered\n      [MILS83a, sec\
    \ 9.4.6.1.1, sec 9.4.6.1.2, sec 9.4.6.1.3, et al.];\n      implementors will probably\
    \ wish to define some error type\n      globally.\n"
- title: RFC 963                                                    November 1985
  contents:
  - 'RFC 963                                                    November 1985

    '
- title: Some Problems with MIL-STD IP
  contents:
  - "Some Problems with MIL-STD IP\n   5.7  Miscellaneous Difficulties\n      The\
    \ specification contains many Ada syntax errors, some of which\n      have been\
    \ shown above.  We have only mentioned syntax errors\n      above, however, when\
    \ they occurred in conjunction with other\n      problems.  One of the main syntactic\
    \ difficulties that we have not\n      mentioned is that the specification frequently\
    \ creates unnamed\n      types, by declaring records within records; such declarations\
    \ are\n      legal in Pascal, but not in Ada [ADA83, sec 3.7].\n      Another\
    \ problem is that slice assignments frequently do not\n      contain the same\
    \ number of elements on the left and right sides,\n      which will raise a run-time\
    \ exception [ADA83, sec 5.2.1].  While\n      we have mentioned some of these,\
    \ there are others which are not\n      enumerated above.\n      In particular,\
    \ the procedure error_to_source [MILS83a, sec\n      9.4.6.3.5] contains the statement\n\
    \         to_SNP.dtgm.data [8..N+3] := from_SNP.dtgm.data [0..N-1];\n      We\
    \ believe that N+3 is a misprint for N+8, but even so the left\n      side contains\
    \ one more byte than the right.  Implementors should\n      carefully check every\
    \ slice assignment.\n"
- title: 6.  An Implementation of MIL Standard IP
  contents:
  - "6.  An Implementation of MIL Standard IP\n   In our discussion above, we have\
    \ pointed out several serious problems\n   with the Military Standard IP [MILS83a]\
    \ specification which must be\n   corrected to produce a running implementation\
    \ conforming to this\n   standard.  We have produced a running C implementation\
    \ for the MIL\n   Standard IP, after problems discussed above were fixed in the\
    \ IP\n   specification.  An important feature of this implementation is that\n\
    \   it was generated semi-automatically from the IP specification with\n   the\
    \ help of a protocol development system [BLUT82] [BLUT83] [SIDD83].\n   Since\
    \ this implementation was derived directly from the IP\n   specification with\
    \ the help of tools, it conforms to the IP standard\n   better that any handed-coded\
    \ IP implementation can do.\n   The problems pointed out in this paper with the\
    \ current specification\n   of the MIL Standard IP [MILS83a] are based on an initial\n\
    \   investigation of the protocol.\n"
- title: RFC 963                                                    November 1985
  contents:
  - 'RFC 963                                                    November 1985

    '
- title: Some Problems with MIL-STD IP
  contents:
  - 'Some Problems with MIL-STD IP

    '
- title: NOTES
  contents:
  - "NOTES\n   [1] Ada is a registered trademark of the U.S. Government - Ada Joint\n\
    \   Program Office.\n   [2] d indicates a \"don't care\" condition.\n"
- title: ACKNOWLEDGEMENTS
  contents:
  - "ACKNOWLEDGEMENTS\n   The author extends his gratitude to Tom Blumer Michael Breslin,\
    \ Bob\n   Pollack and Mark J. Vincenzes, for many helpful discussions.  Thanks\n\
    \   are also due to B. Simon and M. Bernstein for bringing to author's\n   attention\
    \ a specification of the DoD Internet Protocol during 1981-82\n   when a detailed\
    \ study of this protocol began.  The author is also\n   grateful to Jon Postel\
    \ and Carl Sunshine for several informative\n   discussions about DoD IP/TCP during\
    \ the last few years.\n"
- title: REFERENCES
  contents:
  - "REFERENCES\n   [ADA83]   Military Standard Ada(R) Programming Language, United\n\
    \             States Department of Defense, ANSI/MIL-STD-1815A-1983, 22\n    \
    \         January 1983\n   [BLUT83]  Blumer, T. P., and Sidhu, D. P., \"Mechanical\
    \ Verification\n             and Automatic Implementation of Communication Protocols,\"\
    \n             to appear in IEEE Trans. Softw. Eng.\n   [BLUT82]  Blumer, T. P.,\
    \ and Tenney, R. L., \"A Formal Specification\n             Technique and Implementation\
    \ Method for Protocols,\"\n             Computer Networks, Vol. 6, No. 3, July\
    \ 1982, pp. 201-217.\n   [MILS83a] \"Military Standard Internet Protocol,\" United\
    \ States\n             Department of Defense, MIL-STD-1777, 12 August 1983.\n\
    \   [MILS83b] \"Military Standard Transmission Control Protocol,\" United\n  \
    \           States Department of Defense, MIL-STD-1778, 12 August 1983.\n   [POSJ81]\
    \  Postel, J. (ed.), \"DoD Standard Internet Protocol,\" Defense\n           \
    \  Advanced Research Projects Agency, Information Processing\n             Techniques\
    \ Office, RFC-791, September 1981.\n   [SDC82]   DCEC Protocol Standardization\
    \ Program: Protocol\n             Specification Report, System Development Corporation,\n\
    \             TM-7172/301/00, 29 March 1982\n   [SIDD83]  Sidhu, D. P., and Blumer,\
    \ T. P., \"Verification of NBS Class\n             4 Transport Protocol,\" to\
    \ appear in IEEE Trans. Comm.\n"
- title: RFC 963                                                    November 1985
  contents:
  - 'RFC 963                                                    November 1985

    '
- title: Some Problems with MIL-STD IP
  contents:
  - "Some Problems with MIL-STD IP\n   [SIDD84]  Sidhu, D. P., and Blumer, T. P.,\
    \ \"Some Problems with the\n             Specification of the Military Standard\
    \ Transmission Control\n             Protocol,\" in Protocol Specification, Testing\
    \ and\n             Verification IV, (ed.) Y. Yemini et al (1984).\n"
