- title: __initial_text__
  contents:
  - '                  TCP Extensions for High Performance

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This RFC specifies an IAB standards track protocol for\
    \ the Internet\n   community, and requests discussion and suggestions for improvements.\n\
    \   Please refer to the current edition of the \"IAB Official Protocol\n   Standards\"\
    \ for the standardization state and status of this protocol.\n   Distribution\
    \ of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo presents a set of TCP extensions to improve performance\n\
    \   over large bandwidth*delay product paths and to provide reliable\n   operation\
    \ over very high-speed paths.  It defines new TCP options for\n   scaled windows\
    \ and timestamps, which are designed to provide\n   compatible interworking with\
    \ TCP's that do not implement the\n   extensions.  The timestamps are used for\
    \ two distinct mechanisms:\n   RTTM (Round Trip Time Measurement) and PAWS (Protect\
    \ Against Wrapped\n   Sequences).  Selective acknowledgments are not included\
    \ in this memo.\n   This memo combines and supersedes RFC-1072 and RFC-1185, adding\n\
    \   additional clarification and more detailed specification.  Appendix C\n  \
    \ summarizes the changes from the earlier RFCs.\n"
- title: TABLE OF CONTENTS
  contents:
  - "TABLE OF CONTENTS\n   Authors' Addresses ...............................................\
    \ 37\n"
- title: 1. INTRODUCTION
  contents:
  - "1. INTRODUCTION\n   The TCP protocol [Postel81] was designed to operate reliably\
    \ over\n   almost any transmission medium regardless of transmission rate,\n \
    \  delay, corruption, duplication, or reordering of segments.\n   Production TCP\
    \ implementations currently adapt to transfer rates in\n   the range of 100 bps\
    \ to 10**7 bps and round-trip delays in the range\n   1 ms to 100 seconds.  Recent\
    \ work on TCP performance has shown that\n   TCP can work well over a variety\
    \ of Internet paths, ranging from 800\n   Mbit/sec I/O channels to 300 bit/sec\
    \ dial-up modems [Jacobson88a].\n   The introduction of fiber optics is resulting\
    \ in ever-higher\n   transmission speeds, and the fastest paths are moving out\
    \ of the\n   domain for which TCP was originally engineered.  This memo defines\
    \ a\n   set of modest extensions to TCP to extend the domain of its\n   application\
    \ to match this increasing network capability.  It is based\n   upon and obsoletes\
    \ RFC-1072 [Jacobson88b] and RFC-1185 [Jacobson90b].\n   There is no one-line\
    \ answer to the question: \"How fast can TCP go?\".\n   There are two separate\
    \ kinds of issues, performance and reliability,\n   and each depends upon different\
    \ parameters.  We discuss each in turn.\n   1.1  TCP Performance\n      TCP performance\
    \ depends not upon the transfer rate itself, but\n      rather upon the product\
    \ of the transfer rate and the round-trip\n      delay.  This \"bandwidth*delay\
    \ product\" measures the amount of data\n      that would \"fill the pipe\"; it\
    \ is the buffer space required at\n      sender and receiver to obtain maximum\
    \ throughput on the TCP\n      connection over the path, i.e., the amount of unacknowledged\
    \ data\n      that TCP must handle in order to keep the pipeline full.  TCP\n\
    \      performance problems arise when the bandwidth*delay product is\n      large.\
    \  We refer to an Internet path operating in this region as a\n      \"long, fat\
    \ pipe\", and a network containing this path as an \"LFN\"\n      (pronounced\
    \ \"elephan(t)\").\n      High-capacity packet satellite channels (e.g., DARPA's\
    \ Wideband\n      Net) are LFN's.  For example, a DS1-speed satellite channel\
    \ has a\n      bandwidth*delay product of 10**6 bits or more; this corresponds\
    \ to\n      100 outstanding TCP segments of 1200 bytes each.  Terrestrial\n  \
    \    fiber-optical paths will also fall into the LFN class; for\n      example,\
    \ a cross-country delay of 30 ms at a DS3 bandwidth\n      (45Mbps) also exceeds\
    \ 10**6 bits.\n      There are three fundamental performance problems with the\
    \ current\n      TCP over LFN paths:\n      (1)  Window Size Limit\n         \
    \  The TCP header uses a 16 bit field to report the receive\n           window\
    \ size to the sender.  Therefore, the largest window\n           that can be used\
    \ is 2**16 = 65K bytes.\n           To circumvent this problem, Section 2 of this\
    \ memo defines a\n           new TCP option, \"Window Scale\", to allow windows\
    \ larger than\n           2**16.  This option defines an implicit scale factor,\
    \ which\n           is used to multiply the window size value found in a TCP\n\
    \           header to obtain the true window size.\n      (2)  Recovery from Losses\n\
    \           Packet losses in an LFN can have a catastrophic effect on\n      \
    \     throughput.  Until recently, properly-operating TCP\n           implementations\
    \ would cause the data pipeline to drain with\n           every packet loss, and\
    \ require a slow-start action to\n           recover.  Recently, the Fast Retransmit\
    \ and Fast Recovery\n           algorithms [Jacobson90c] have been introduced.\
    \  Their\n           combined effect is to recover from one packet loss per\n\
    \           window, without draining the pipeline.  However, more than\n     \
    \      one packet loss per window typically results in a\n           retransmission\
    \ timeout and the resulting pipeline drain and\n           slow start.\n     \
    \      Expanding the window size to match the capacity of an LFN\n           results\
    \ in a corresponding increase of the probability of\n           more than one\
    \ packet per window being dropped.  This could\n           have a devastating\
    \ effect upon the throughput of TCP over an\n           LFN.  In addition, if\
    \ a congestion control mechanism based\n           upon some form of random dropping\
    \ were introduced into\n           gateways, randomly spaced packet drops would\
    \ become common,\n           possible increasing the probability of dropping more\
    \ than one\n           packet per window.\n           To generalize the Fast Retransmit/Fast\
    \ Recovery mechanism to\n           handle multiple packets dropped per window,\
    \ selective\n           acknowledgments are required.  Unlike the normal cumulative\n\
    \           acknowledgments of TCP, selective acknowledgments give the\n     \
    \      sender a complete picture of which segments are queued at the\n       \
    \    receiver and which have not yet arrived.  Some evidence in\n           favor\
    \ of selective acknowledgments has been published\n           [NBS85], and selective\
    \ acknowledgments have been included in\n           a number of experimental Internet\
    \ protocols -- VMTP\n           [Cheriton88], NETBLT [Clark87], and RDP [Velten84],\
    \ and\n           proposed for OSI TP4 [NBS85].  However, in the non-LFN\n   \
    \        regime, selective acknowledgments reduce the number of\n           packets\
    \ retransmitted but do not otherwise improve\n           performance, making their\
    \ complexity of questionable value.\n           However, selective acknowledgments\
    \ are expected to become\n           much more important in the LFN regime.\n\
    \           RFC-1072 defined a new TCP \"SACK\" option to send a selective\n \
    \          acknowledgment.  However, there are important technical\n         \
    \  issues to be worked out concerning both the format and\n           semantics\
    \ of the SACK option.  Therefore, SACK has been\n           omitted from this\
    \ package of extensions.  It is hoped that\n           SACK can \"catch up\" during\
    \ the standardization process.\n      (3)  Round-Trip Measurement\n          \
    \ TCP implements reliable data delivery by retransmitting\n           segments\
    \ that are not acknowledged within some retransmission\n           timeout (RTO)\
    \ interval.  Accurate dynamic determination of an\n           appropriate RTO\
    \ is essential to TCP performance.  RTO is\n           determined by estimating\
    \ the mean and variance of the\n           measured round-trip time (RTT), i.e.,\
    \ the time interval\n           between sending a segment and receiving an acknowledgment\
    \ for\n           it [Jacobson88a].\n           Section 4 introduces a new TCP\
    \ option, \"Timestamps\", and then\n           defines a mechanism using this\
    \ option that allows nearly\n           every segment, including retransmissions,\
    \ to be timed at\n           negligible computational cost.  We use the mnemonic\
    \ RTTM\n           (Round Trip Time Measurement) for this mechanism, to\n    \
    \       distinguish it from other uses of the Timestamps option.\n   1.2 TCP Reliability\n\
    \      Now we turn from performance to reliability.  High transfer rate\n    \
    \  enters TCP performance through the bandwidth*delay product.\n      However,\
    \ high transfer rate alone can threaten TCP reliability by\n      violating the\
    \ assumptions behind the TCP mechanism for duplicate\n      detection and sequencing.\n\
    \      An especially serious kind of error may result from an accidental\n   \
    \   reuse of TCP sequence numbers in data segments.  Suppose that an\n      \"\
    old duplicate segment\", e.g., a duplicate data segment that was\n      delayed\
    \ in Internet queues, is delivered to the receiver at the\n      wrong moment,\
    \ so that its sequence numbers falls somewhere within\n      the current window.\
    \  There would be no checksum failure to warn of\n      the error, and the result\
    \ could be an undetected corruption of the\n      data.  Reception of an old duplicate\
    \ ACK segment at the\n      transmitter could be only slightly less serious: it\
    \ is likely to\n      lock up the connection so that no further progress can be\
    \ made,\n      forcing an RST on the connection.\n      TCP reliability depends\
    \ upon the existence of a bound on the\n      lifetime of a segment: the \"Maximum\
    \ Segment Lifetime\" or MSL.  An\n      MSL is generally required by any reliable\
    \ transport protocol,\n      since every sequence number field must be finite,\
    \ and therefore\n      any sequence number may eventually be reused.  In the Internet\n\
    \      protocol suite, the MSL bound is enforced by an IP-layer\n      mechanism,\
    \ the \"Time-to-Live\" or TTL field.\n      Duplication of sequence numbers might\
    \ happen in either of two\n      ways:\n      (1)  Sequence number wrap-around\
    \ on the current connection\n           A TCP sequence number contains 32 bits.\
    \  At a high enough\n           transfer rate, the 32-bit sequence space may be\
    \ \"wrapped\"\n           (cycled) within the time that a segment is delayed in\
    \ queues.\n      (2)  Earlier incarnation of the connection\n           Suppose\
    \ that a connection terminates, either by a proper\n           close sequence\
    \ or due to a host crash, and the same\n           connection (i.e., using the\
    \ same pair of sockets) is\n           immediately reopened.  A delayed segment\
    \ from the terminated\n           connection could fall within the current window\
    \ for the new\n           incarnation and be accepted as valid.\n      Duplicates\
    \ from earlier incarnations, Case (2), are avoided by\n      enforcing the current\
    \ fixed MSL of the TCP spec, as explained in\n      Section 5.3 and Appendix B.\
    \   However, case (1), avoiding the\n      reuse of sequence numbers within the\
    \ same connection, requires an\n      MSL bound that depends upon the transfer\
    \ rate, and at high enough\n      rates, a new mechanism is required.\n      More\
    \ specifically, if the maximum effective bandwidth at which TCP\n      is able\
    \ to transmit over a particular path is B bytes per second,\n      then the following\
    \ constraint must be satisfied for error-free\n      operation:\n          2**31\
    \ / B  > MSL (secs)                     [1]\n      The following table shows the\
    \ value for Twrap = 2**31/B in\n      seconds, for some important values of the\
    \ bandwidth B:\n           Network       B*8          B         Twrap\n      \
    \                bits/sec   bytes/sec      secs\n           _______    _______\
    \      ______       ______\n           ARPANET       56kbps       7KBps    3*10**5\
    \ (~3.6 days)\n           DS1          1.5Mbps     190KBps    10**4 (~3 hours)\n\
    \           Ethernet      10Mbps    1.25MBps    1700 (~30 mins)\n           DS3\
    \           45Mbps     5.6MBps    380\n           FDDI         100Mbps    12.5MBps\
    \    170\n           Gigabit        1Gbps     125MBps    17\n      It is clear\
    \ that wrap-around of the sequence space is not a\n      problem for 56kbps packet\
    \ switching or even 10Mbps Ethernets.  On\n      the other hand, at DS3 and FDDI\
    \ speeds, Twrap is comparable to the\n      2 minute MSL assumed by the TCP specification\
    \ [Postel81].  Moving\n      towards gigabit speeds, Twrap becomes too small for\
    \ reliable\n      enforcement by the Internet TTL mechanism.\n      The 16-bit\
    \ window field of TCP limits the effective bandwidth B to\n      2**16/RTT, where\
    \ RTT is the round-trip time in seconds\n      [McKenzie89].  If the RTT is large\
    \ enough, this limits B to a\n      value that meets the constraint [1] for a\
    \ large MSL value.  For\n      example, consider a transcontinental backbone with\
    \ an RTT of 60ms\n      (set by the laws of physics).  With the bandwidth*delay\
    \ product\n      limited to 64KB by the TCP window size, B is then limited to\n\
    \      1.1MBps, no matter how high the theoretical transfer rate of the\n    \
    \  path.  This corresponds to cycling the sequence number space in\n      Twrap=\
    \ 2000 secs, which is safe in today's Internet.\n      It is important to understand\
    \ that the culprit is not the larger\n      window but rather the high bandwidth.\
    \  For example, consider a\n      (very large) FDDI LAN with a diameter of 10km.\
    \  Using the speed of\n      light, we can compute the RTT across the ring as\n\
    \      (2*10**4)/(3*10**8) = 67 microseconds, and the delay*bandwidth\n      product\
    \ is then 833 bytes.  A TCP connection across this LAN using\n      a window of\
    \ only 833 bytes will run at the full 100mbps and can\n      wrap the sequence\
    \ space in about 3 minutes, very close to the MSL\n      of TCP.  Thus, high speed\
    \ alone can cause a reliability problem\n      with sequence number wrap-around,\
    \ even without extended windows.\n      Watson's Delta-T protocol [Watson81] includes\
    \ network-layer\n      mechanisms for precise enforcement of an MSL.  In contrast,\
    \ the IP\n      mechanism for MSL enforcement is loosely defined and even more\n\
    \      loosely implemented in the Internet.  Therefore, it is unwise to\n    \
    \  depend upon active enforcement of MSL for TCP connections, and it\n      is\
    \ unrealistic to imagine setting MSL's smaller than the current\n      values\
    \ (e.g., 120 seconds specified for TCP).\n      A possible fix for the problem\
    \ of cycling the sequence space would\n      be to increase the size of the TCP\
    \ sequence number field.  For\n      example, the sequence number field (and also\
    \ the acknowledgment\n      field) could be expanded to 64 bits.  This could be\
    \ done either by\n      changing the TCP header or by means of an additional option.\n\
    \      Section 5 presents a different mechanism, which we call PAWS\n      (Protect\
    \ Against Wrapped Sequence numbers), to extend TCP\n      reliability to transfer\
    \ rates well beyond the foreseeable upper\n      limit of network bandwidths.\
    \  PAWS uses the TCP Timestamps option\n      defined in Section 4 to protect\
    \ against old duplicates from the\n      same connection.\n   1.3 Using TCP options\n\
    \      The extensions defined in this memo all use new TCP options.  We\n    \
    \  must address two possible issues concerning the use of TCP\n      options:\
    \ (1) compatibility and (2) overhead.\n      We must pay careful attention to\
    \ compatibility, i.e., to\n      interoperation with existing implementations.\
    \  The only TCP option\n      defined previously, MSS, may appear only on a SYN\
    \ segment.  Every\n      implementation should (and we expect that most will)\
    \ ignore\n      unknown options on SYN segments.  However, some buggy TCP\n  \
    \    implementation might be crashed by the first appearance of an\n      option\
    \ on a non-SYN segment.  Therefore, for each of the\n      extensions defined\
    \ below, TCP options will be sent on non-SYN\n      segments only when an exchange\
    \ of options on the SYN segments has\n      indicated that both sides understand\
    \ the extension.  Furthermore,\n      an extension option will be sent in a <SYN,ACK>\
    \ segment only if\n      the corresponding option was received in the initial\
    \ <SYN>\n      segment.\n      A question may be raised about the bandwidth and\
    \ processing\n      overhead for TCP options.  Those options that occur on SYN\n\
    \      segments are not likely to cause a performance concern.  Opening a\n  \
    \    TCP connection requires execution of significant special-case\n      code,\
    \ and the processing of options is unlikely to increase that\n      cost significantly.\n\
    \      On the other hand, a Timestamps option may appear in any data or\n    \
    \  ACK segment, adding 12 bytes to the 20-byte TCP header.  We\n      believe\
    \ that the bandwidth saved by reducing unnecessary\n      retransmissions will\
    \ more than pay for the extra header bandwidth.\n      There is also an issue\
    \ about the processing overhead for parsing\n      the variable byte-aligned format\
    \ of options, particularly with a\n      RISC-architecture CPU.  To meet this\
    \ concern, Appendix A contains\n      a recommended layout of the options in TCP\
    \ headers to achieve\n      reasonable data field alignment.  In the spirit of\
    \ Header\n      Prediction, a TCP can quickly test for this layout and if it is\n\
    \      verified then use a fast path.  Hosts that use this canonical\n      layout\
    \ will effectively use the options as a set of fixed-format\n      fields appended\
    \ to the TCP header.  However, to retain the\n      philosophical and protocol\
    \ framework of TCP options, a TCP must be\n      prepared to parse an arbitrary\
    \ options field, albeit with less\n      efficiency.\n      Finally, we observe\
    \ that most of the mechanisms defined in this\n      memo are important for LFN's\
    \ and/or very high-speed networks.  For\n      low-speed networks, it might be\
    \ a performance optimization to NOT\n      use these mechanisms.  A TCP vendor\
    \ concerned about optimal\n      performance over low-speed paths might consider\
    \ turning these\n      extensions off for low-speed paths, or allow a user or\n\
    \      installation manager to disable them.\n"
- title: 2. TCP WINDOW SCALE OPTION
  contents:
  - "2. TCP WINDOW SCALE OPTION\n   2.1  Introduction\n      The window scale extension\
    \ expands the definition of the TCP\n      window to 32 bits and then uses a scale\
    \ factor to carry this 32-\n      bit value in the 16-bit Window field of the\
    \ TCP header (SEG.WND in\n      RFC-793).  The scale factor is carried in a new\
    \ TCP option, Window\n      Scale.  This option is sent only in a SYN segment\
    \ (a segment with\n      the SYN bit on), hence the window scale is fixed in each\
    \ direction\n      when a connection is opened.  (Another design choice would\
    \ be to\n      specify the window scale in every TCP segment.  It would be\n \
    \     incorrect to send a window scale option only when the scale factor\n   \
    \   changed, since a TCP option in an acknowledgement segment will not\n     \
    \ be delivered reliably (unless the ACK happens to be piggy-backed\n      on data\
    \ in the other direction).  Fixing the scale when the\n      connection is opened\
    \ has the advantage of lower overhead but the\n      disadvantage that the scale\
    \ factor cannot be changed during the\n      connection.)\n      The maximum receive\
    \ window, and therefore the scale factor, is\n      determined by the maximum\
    \ receive buffer space.  In a typical\n      modern implementation, this maximum\
    \ buffer space is set by default\n      but can be overridden by a user program\
    \ before a TCP connection is\n      opened.  This determines the scale factor,\
    \ and therefore no new\n      user interface is needed for window scaling.\n \
    \  2.2  Window Scale Option\n      The three-byte Window Scale option may be sent\
    \ in a SYN segment by\n      a TCP.  It has two purposes: (1) indicate that the\
    \ TCP is prepared\n      to do both send and receive window scaling, and (2) communicate\
    \ a\n      scale factor to be applied to its receive window.  Thus, a TCP\n  \
    \    that is prepared to scale windows should send the option, even if\n     \
    \ its own scale factor is 1.  The scale factor is limited to a power\n      of\
    \ two and encoded logarithmically, so it may be implemented by\n      binary shift\
    \ operations.\n      TCP Window Scale Option (WSopt):\n         Kind: 3 Length:\
    \ 3 bytes\n                +---------+---------+---------+\n                |\
    \ Kind=3  |Length=3 |shift.cnt|\n                +---------+---------+---------+\n\
    \         This option is an offer, not a promise; both sides must send\n     \
    \    Window Scale options in their SYN segments to enable window\n         scaling\
    \ in either direction.  If window scaling is enabled,\n         then the TCP that\
    \ sent this option will right-shift its true\n         receive-window values by\
    \ 'shift.cnt' bits for transmission in\n         SEG.WND.  The value 'shift.cnt'\
    \ may be zero (offering to scale,\n         while applying a scale factor of 1\
    \ to the receive window).\n         This option may be sent in an initial <SYN>\
    \ segment (i.e., a\n         segment with the SYN bit on and the ACK bit off).\
    \  It may also\n         be sent in a <SYN,ACK> segment, but only if a Window\
    \ Scale op-\n         tion was received in the initial <SYN> segment.  A Window\
    \ Scale\n         option in a segment without a SYN bit should be ignored.\n \
    \        The Window field in a SYN (i.e., a <SYN> or <SYN,ACK>) segment\n    \
    \     itself is never scaled.\n   2.3  Using the Window Scale Option\n      A\
    \ model implementation of window scaling is as follows, using the\n      notation\
    \ of RFC-793 [Postel81]:\n      *    All windows are treated as 32-bit quantities\
    \ for storage in\n           the connection control block and for local calculations.\n\
    \           This includes the send-window (SND.WND) and the receive-\n       \
    \    window (RCV.WND) values, as well as the congestion window.\n      *    The\
    \ connection state is augmented by two window shift counts,\n           Snd.Wind.Scale\
    \ and Rcv.Wind.Scale, to be applied to the\n           incoming and outgoing window\
    \ fields, respectively.\n      *    If a TCP receives a <SYN> segment containing\
    \ a Window Scale\n           option, it sends its own Window Scale option in the\
    \ <SYN,ACK>\n           segment.\n      *    The Window Scale option is sent with\
    \ shift.cnt = R, where R\n           is the value that the TCP would like to use\
    \ for its receive\n           window.\n      *    Upon receiving a SYN segment\
    \ with a Window Scale option\n           containing shift.cnt = S, a TCP sets\
    \ Snd.Wind.Scale to S and\n           sets Rcv.Wind.Scale to R; otherwise, it\
    \ sets both\n           Snd.Wind.Scale and Rcv.Wind.Scale to zero.\n      *  \
    \  The window field (SEG.WND) in the header of every incoming\n           segment,\
    \ with the exception of SYN segments, is left-shifted\n           by Snd.Wind.Scale\
    \ bits before updating SND.WND:\n              SND.WND = SEG.WND << Snd.Wind.Scale\n\
    \           (assuming the other conditions of RFC793 are met, and using\n    \
    \       the \"C\" notation \"<<\" for left-shift).\n      *    The window field\
    \ (SEG.WND) of every outgoing segment, with\n           the exception of SYN segments,\
    \ is right-shifted by\n           Rcv.Wind.Scale bits:\n              SEG.WND\
    \ = RCV.WND >> Rcv.Wind.Scale.\n      TCP determines if a data segment is \"old\"\
    \ or \"new\" by testing\n      whether its sequence number is within 2**31 bytes\
    \ of the left edge\n      of the window, and if it is not, discarding the data\
    \ as \"old\".  To\n      insure that new data is never mistakenly considered old\
    \ and vice-\n      versa, the left edge of the sender's window has to be at most\n\
    \      2**31 away from the right edge of the receiver's window.\n      Similarly\
    \ with the sender's right edge and receiver's left edge.\n      Since the right\
    \ and left edges of either the sender's or\n      receiver's window differ by\
    \ the window size, and since the sender\n      and receiver windows can be out\
    \ of phase by at most the window\n      size, the above constraints imply that\
    \ 2 * the max window size\n      must be less than 2**31, or\n           max window\
    \ < 2**30\n      Since the max window is 2**S (where S is the scaling shift count)\n\
    \      times at most 2**16 - 1 (the maximum unscaled window), the maximum\n  \
    \    window is guaranteed to be < 2*30 if S <= 14.  Thus, the shift\n      count\
    \ must be limited to 14 (which allows windows of 2**30 = 1\n      Gbyte).  If\
    \ a Window Scale option is received with a shift.cnt\n      value exceeding 14,\
    \ the TCP should log the error but use 14\n      instead of the specified value.\n\
    \      The scale factor applies only to the Window field as transmitted\n    \
    \  in the TCP header; each TCP using extended windows will maintain\n      the\
    \ window values locally as 32-bit numbers.  For example, the\n      \"congestion\
    \ window\" computed by Slow Start and Congestion\n      Avoidance is not affected\
    \ by the scale factor, so window scaling\n      will not introduce quantization\
    \ into the congestion window.\n"
- title: '3.  RTTM: ROUND-TRIP TIME MEASUREMENT'
  contents:
  - "3.  RTTM: ROUND-TRIP TIME MEASUREMENT\n   3.1  Introduction\n      Accurate and\
    \ current RTT estimates are necessary to adapt to\n      changing traffic conditions\
    \ and to avoid an instability known as\n      \"congestion collapse\" [Nagle84]\
    \ in a busy network.  However,\n      accurate measurement of RTT may be difficult\
    \ both in theory and in\n      implementation.\n      Many TCP implementations\
    \ base their RTT measurements upon a sample\n      of only one packet per window.\
    \  While this yields an adequate\n      approximation to the RTT for small windows,\
    \ it results in an\n      unacceptably poor RTT estimate for an LFN.  If we look\
    \ at RTT\n      estimation as a signal processing problem (which it is), a data\n\
    \      signal at some frequency, the packet rate, is being sampled at a\n    \
    \  lower frequency, the window rate.  This lower sampling frequency\n      violates\
    \ Nyquist's criteria and may therefore introduce \"aliasing\"\n      artifacts\
    \ into the estimated RTT [Hamming77].\n      A good RTT estimator with a conservative\
    \ retransmission timeout\n      calculation can tolerate aliasing when the sampling\
    \ frequency is\n      \"close\" to the data frequency.   For example, with a window\
    \ of 8\n      packets, the sample rate is 1/8 the data frequency -- less than\
    \ an\n      order of magnitude different.  However, when the window is tens or\n\
    \      hundreds of packets, the RTT estimator may be seriously in error,\n   \
    \   resulting in spurious retransmissions.\n      If there are dropped packets,\
    \ the problem becomes worse.  Zhang\n      [Zhang86], Jain [Jain86] and Karn [Karn87]\
    \ have shown that it is\n      not possible to accumulate reliable RTT estimates\
    \ if retransmitted\n      segments are included in the estimate.  Since a full\
    \ window of\n      data will have been transmitted prior to a retransmission,\
    \ all of\n      the segments in that window will have to be ACKed before the next\n\
    \      RTT sample can be taken.  This means at least an additional\n      window's\
    \ worth of time between RTT measurements and, as the error\n      rate approaches\
    \ one per window of data (e.g., 10**-6 errors per\n      bit for the Wideband\
    \ satellite network), it becomes effectively\n      impossible to obtain a valid\
    \ RTT measurement.\n      A solution to these problems, which actually simplifies\
    \ the sender\n      substantially, is as follows: using TCP options, the sender\
    \ places\n      a timestamp in each data segment, and the receiver reflects these\n\
    \      timestamps back in ACK segments.  Then a single subtract gives the\n  \
    \    sender an accurate RTT measurement for every ACK segment (which\n      will\
    \ correspond to every other data segment, with a sensible\n      receiver).  We\
    \ call this the RTTM (Round-Trip Time Measurement)\n      mechanism.\n      It\
    \ is vitally important to use the RTTM mechanism with big\n      windows; otherwise,\
    \ the door is opened to some dangerous\n      instabilities due to aliasing. \
    \ Furthermore, the option is\n      probably useful for all TCP's, since it simplifies\
    \ the sender.\n   3.2  TCP Timestamps Option\n      TCP is a symmetric protocol,\
    \ allowing data to be sent at any time\n      in either direction, and therefore\
    \ timestamp echoing may occur in\n      either direction.  For simplicity and\
    \ symmetry, we specify that\n      timestamps always be sent and echoed in both\
    \ directions.  For\n      efficiency, we combine the timestamp and timestamp reply\
    \ fields\n      into a single TCP Timestamps Option.\n      TCP Timestamps Option\
    \ (TSopt):\n         Kind: 8\n         Length: 10 bytes\n          +-------+-------+---------------------+---------------------+\n\
    \          |Kind=8 |  10   |   TS Value (TSval)  |TS Echo Reply (TSecr)|\n   \
    \       +-------+-------+---------------------+---------------------+\n      \
    \        1       1              4                     4\n         The Timestamps\
    \ option carries two four-byte timestamp fields.\n         The Timestamp Value\
    \ field (TSval) contains the current value of\n         the timestamp clock of\
    \ the TCP sending the option.\n         The Timestamp Echo Reply field (TSecr)\
    \ is only valid if the ACK\n         bit is set in the TCP header; if it is valid,\
    \ it echos a times-\n         tamp value that was sent by the remote TCP in the\
    \ TSval field\n         of a Timestamps option.  When TSecr is not valid, its\
    \ value\n         must be zero.  The TSecr value will generally be from the most\n\
    \         recent Timestamp option that was received; however, there are\n    \
    \     exceptions that are explained below.\n         A TCP may send the Timestamps\
    \ option (TSopt) in an initial\n         <SYN> segment (i.e., segment containing\
    \ a SYN bit and no ACK\n         bit), and may send a TSopt in other segments\
    \ only if it re-\n         ceived a TSopt in the initial <SYN> segment for the\
    \ connection.\n   3.3 The RTTM Mechanism\n      The timestamp value to be sent\
    \ in TSval is to be obtained from a\n      (virtual) clock that we call the \"\
    timestamp clock\".  Its values\n      must be at least approximately proportional\
    \ to real time, in order\n      to measure actual RTT.\n      The following example\
    \ illustrates a one-way data flow with\n      segments arriving in sequence without\
    \ loss.  Here A, B, C...\n      represent data blocks occupying successive blocks\
    \ of sequence\n      numbers, and ACK(A),...  represent the corresponding cumulative\n\
    \      acknowledgments.  The two timestamp fields of the Timestamps\n      option\
    \ are shown symbolically as <TSval= x,TSecr=y>.  Each TSecr\n      field contains\
    \ the value most recently received in a TSval field.\n         TCP  A        \
    \                                  TCP B\n                        <A,TSval=1,TSecr=120>\
    \ ------>\n             <---- <ACK(A),TSval=127,TSecr=1>\n                   \
    \     <B,TSval=5,TSecr=127> ------>\n             <---- <ACK(B),TSval=131,TSecr=5>\n\
    \             . . . . . . . . . . . . . . . . . . . . . .\n                  \
    \      <C,TSval=65,TSecr=131> ------>\n             <---- <ACK(C),TSval=191,TSecr=65>\n\
    \                        (etc)\n      The dotted line marks a pause (60 time units\
    \ long) in which A had\n      nothing to send.  Note that this pause inflates\
    \ the RTT which B\n      could infer from receiving TSecr=131 in data segment\
    \ C.  Thus, in\n      one-way data flows, RTTM in the reverse direction measures\
    \ a value\n      that is inflated by gaps in sending data.  However, the following\n\
    \      rule prevents a resulting inflation of the measured RTT:\n           A\
    \ TSecr value received in a segment is used to update the\n           averaged\
    \ RTT measurement only if the segment acknowledges\n           some new data,\
    \ i.e., only if it advances the left edge of the\n           send window.\n  \
    \    Since TCP B is not sending data, the data segment C does not\n      acknowledge\
    \ any new data when it arrives at B.  Thus, the inflated\n      RTTM measurement\
    \ is not used to update B's RTTM measurement.\n   3.4  Which Timestamp to Echo\n\
    \      If more than one Timestamps option is received before a reply\n      segment\
    \ is sent, the TCP must choose only one of the TSvals to\n      echo, ignoring\
    \ the others.  To minimize the state kept in the\n      receiver (i.e., the number\
    \ of unprocessed TSvals), the receiver\n      should be required to retain at\
    \ most one timestamp in the\n      connection control block.\n      There are\
    \ three situations to consider:\n      (A)  Delayed ACKs.\n           Many TCP's\
    \ acknowledge only every Kth segment out of a group\n           of segments arriving\
    \ within a short time interval; this\n           policy is known generally as\
    \ \"delayed ACKs\".  The data-sender\n           TCP must measure the effective\
    \ RTT, including the additional\n           time due to delayed ACKs, or else\
    \ it will retransmit\n           unnecessarily.  Thus, when delayed ACKs are in\
    \ use, the\n           receiver should reply with the TSval field from the earliest\n\
    \           unacknowledged segment.\n      (B)  A hole in the sequence space (segment(s)\
    \ have been lost).\n           The sender will continue sending until the window\
    \ is filled,\n           and the receiver may be generating ACKs as these out-of-order\n\
    \           segments arrive (e.g., to aid \"fast retransmit\").\n           The\
    \ lost segment is probably a sign of congestion, and in\n           that situation\
    \ the sender should be conservative about\n           retransmission.  Furthermore,\
    \ it is better to overestimate\n           than underestimate the RTT.  An ACK\
    \ for an out-of-order\n           segment should therefore contain the timestamp\
    \ from the most\n           recent segment that advanced the window.\n       \
    \    The same situation occurs if segments are re-ordered by the\n           network.\n\
    \      (C)  A filled hole in the sequence space.\n           The segment that\
    \ fills the hole represents the most recent\n           measurement of the network\
    \ characteristics.  On the other\n           hand, an RTT computed from an earlier\
    \ segment would probably\n           include the sender's retransmit time-out,\
    \ badly biasing the\n           sender's average RTT estimate.  Thus, the timestamp\
    \ from the\n           latest segment (which filled the hole) must be echoed.\n\
    \      An algorithm that covers all three cases is described in the\n      following\
    \ rules for Timestamps option processing on a synchronized\n      connection:\n\
    \      (1)  The connection state is augmented with two 32-bit slots:\n       \
    \    TS.Recent holds a timestamp to be echoed in TSecr whenever a\n          \
    \ segment is sent, and Last.ACK.sent holds the ACK field from\n           the\
    \ last segment sent.  Last.ACK.sent will equal RCV.NXT\n           except when\
    \ ACKs have been delayed.\n      (2)  If Last.ACK.sent falls within the range\
    \ of sequence numbers\n           of an incoming segment:\n              SEG.SEQ\
    \ <= Last.ACK.sent < SEG.SEQ + SEG.LEN\n           then the TSval from the segment\
    \ is copied to TS.Recent;\n           otherwise, the TSval is ignored.\n     \
    \ (3)  When a TSopt is sent, its TSecr field is set to the current\n         \
    \  TS.Recent value.\n      The following examples illustrate these rules.  Here\
    \ A, B, C...\n      represent data segments occupying successive blocks of sequence\n\
    \      numbers, and ACK(A),...  represent the corresponding\n      acknowledgment\
    \ segments.  Note that ACK(A) has the same sequence\n      number as B.  We show\
    \ only one direction of timestamp echoing, for\n      clarity.\n      o    Packets\
    \ arrive in sequence, and some of the ACKs are delayed.\n           By Case (A),\
    \ the timestamp from the oldest unacknowledged\n           segment is echoed.\n\
    \                                                      TS.Recent\n           \
    \         <A, TSval=1> ------------------->\n                                \
    \                          1\n                    <B, TSval=2> ------------------->\n\
    \                                                          1\n               \
    \     <C, TSval=3> ------------------->\n                                    \
    \                      1\n                             <---- <ACK(C), TSecr=1>\n\
    \                    (etc)\n      o    Packets arrive out of order, and every\
    \ packet is\n           acknowledged.\n           By Case (B), the timestamp from\
    \ the last segment that\n           advanced the left window edge is echoed, until\
    \ the missing\n           segment arrives; it is echoed according to Case (C).\
    \  The\n           same sequence would occur if segments B and D were lost and\n\
    \           retransmitted..\n                                                \
    \      TS.Recent\n                    <A, TSval=1> ------------------->\n    \
    \                                                      1\n                   \
    \          <---- <ACK(A), TSecr=1>\n                                         \
    \                 1\n                    <C, TSval=3> ------------------->\n \
    \                                                         1\n                \
    \             <---- <ACK(A), TSecr=1>\n                                      \
    \                    1\n                    <B, TSval=2> ------------------->\n\
    \                                                          2\n               \
    \              <---- <ACK(C), TSecr=2>\n                                     \
    \                     2\n                    <E, TSval=5> ------------------->\n\
    \                                                          2\n               \
    \              <---- <ACK(C), TSecr=2>\n                                     \
    \                     2\n                    <D, TSval=4> ------------------->\n\
    \                                                          4\n               \
    \              <---- <ACK(E), TSecr=4>\n                    (etc)\n"
- title: '4.  PAWS: PROTECT AGAINST WRAPPED SEQUENCE NUMBERS'
  contents:
  - "4.  PAWS: PROTECT AGAINST WRAPPED SEQUENCE NUMBERS\n   4.1  Introduction\n  \
    \    Section 4.2 describes a simple mechanism to reject old duplicate\n      segments\
    \ that might corrupt an open TCP connection; we call this\n      mechanism PAWS\
    \ (Protect Against Wrapped Sequence numbers).  PAWS\n      operates within a single\
    \ TCP connection, using state that is saved\n      in the connection control block.\
    \  Section 4.3 and Appendix C\n      discuss the implications of the PAWS mechanism\
    \ for avoiding old\n      duplicates from previous incarnations of the same connection.\n\
    \   4.2  The PAWS Mechanism\n      PAWS uses the same TCP Timestamps option as\
    \ the RTTM mechanism\n      described earlier, and assumes that every received\
    \ TCP segment\n      (including data and ACK segments) contains a timestamp SEG.TSval\n\
    \      whose values are monotone non-decreasing in time.  The basic idea\n   \
    \   is that a segment can be discarded as an old duplicate if it is\n      received\
    \ with a timestamp SEG.TSval less than some timestamp\n      recently received\
    \ on this connection.\n      In both the PAWS and the RTTM mechanism, the \"timestamps\"\
    \ are 32-\n      bit unsigned integers in a modular 32-bit space.  Thus, \"less\n\
    \      than\" is defined the same way it is for TCP sequence numbers, and\n  \
    \    the same implementation techniques apply.  If s and t are\n      timestamp\
    \ values, s < t if 0 < (t - s) < 2**31, computed in\n      unsigned 32-bit arithmetic.\n\
    \      The choice of incoming timestamps to be saved for this comparison\n   \
    \   must guarantee a value that is monotone increasing.  For example,\n      we\
    \ might save the timestamp from the segment that last advanced\n      the left\
    \ edge of the receive window, i.e., the most recent in-\n      sequence segment.\
    \  Instead, we choose the value TS.Recent\n      introduced in Section 3.4 for\
    \ the RTTM mechanism, since using a\n      common value for both PAWS and RTTM\
    \ simplifies the implementation\n      of both.  As Section 3.4 explained, TS.Recent\
    \ differs from the\n      timestamp from the last in-sequence segment only in\
    \ the case of\n      delayed ACKs, and therefore by less than one window.  Either\n\
    \      choice will therefore protect against sequence number wrap-around.\n  \
    \    RTTM was specified in a symmetrical manner, so that TSval\n      timestamps\
    \ are carried in both data and ACK segments and are\n      echoed in TSecr fields\
    \ carried in returning ACK or data segments.\n      PAWS submits all incoming\
    \ segments to the same test, and therefore\n      protects against duplicate ACK\
    \ segments as well as data segments.\n      (An alternative un-symmetric algorithm\
    \ would protect against old\n      duplicate ACKs: the sender of data would reject\
    \ incoming ACK\n      segments whose TSecr values were less than the TSecr saved\
    \ from\n      the last segment whose ACK field advanced the left edge of the\n\
    \      send window.  This algorithm was deemed to lack economy of\n      mechanism\
    \ and symmetry.)\n      TSval timestamps sent on {SYN} and {SYN,ACK} segments\
    \ are used to\n      initialize PAWS.  PAWS protects against old duplicate non-SYN\n\
    \      segments, and duplicate SYN segments received while there is a\n      synchronized\
    \ connection.  Duplicate {SYN} and {SYN,ACK} segments\n      received when there\
    \ is no connection will be discarded by the\n      normal 3-way handshake and\
    \ sequence number checks of TCP.\n      It is recommended that RST segments NOT\
    \ carry timestamps, and that\n      RST segments be acceptable regardless of their\
    \ timestamp.  Old\n      duplicate RST segments should be exceedingly unlikely,\
    \ and their\n      cleanup function should take precedence over timestamps.\n\
    \      4.2.1  Basic PAWS Algorithm\n         The PAWS algorithm requires the following\
    \ processing to be\n         performed on all incoming segments for a synchronized\n\
    \         connection:\n         R1)  If there is a Timestamps option in the arriving\
    \ segment\n              and SEG.TSval < TS.Recent and if TS.Recent is valid (see\n\
    \              later discussion), then treat the arriving segment as not\n   \
    \           acceptable:\n                   Send an acknowledgement in reply as\
    \ specified in\n                   RFC-793 page 69 and drop the segment.\n   \
    \                Note: it is necessary to send an ACK segment in order\n     \
    \              to retain TCP's mechanisms for detecting and\n                \
    \   recovering from half-open connections.  For example,\n                   see\
    \ Figure 10 of RFC-793.\n         R2)  If the segment is outside the window, reject\
    \ it (normal\n              TCP processing)\n         R3)  If an arriving segment\
    \ satisfies: SEG.SEQ <= Last.ACK.sent\n              (see Section 3.4), then record\
    \ its timestamp in TS.Recent.\n         R4)  If an arriving segment is in-sequence\
    \ (i.e., at the left\n              window edge), then accept it normally.\n \
    \        R5)  Otherwise, treat the segment as a normal in-window, out-\n     \
    \         of-sequence TCP segment (e.g., queue it for later delivery\n       \
    \       to the user).\n         Steps R2, R4, and R5 are the normal TCP processing\
    \ steps\n         specified by RFC-793.\n         It is important to note that\
    \ the timestamp is checked only when\n         a segment first arrives at the\
    \ receiver, regardless of whether\n         it is in-sequence or it must be queued\
    \ for later delivery.\n         Consider the following example.\n            \
    \  Suppose the segment sequence: A.1, B.1, C.1, ..., Z.1 has\n              been\
    \ sent, where the letter indicates the sequence number\n              and the\
    \ digit represents the timestamp.  Suppose also that\n              segment B.1\
    \ has been lost.  The timestamp in TS.TStamp is\n              1 (from A.1), so\
    \ C.1, ..., Z.1 are considered acceptable\n              and are queued.  When\
    \ B is retransmitted as segment B.2\n              (using the latest timestamp),\
    \ it fills the hole and causes\n              all the segments through Z to be\
    \ acknowledged and passed\n              to the user.  The timestamps of the queued\
    \ segments are\n              *not* inspected again at this time, since they have\n\
    \              already been accepted.  When B.2 is accepted, TS.Stamp is\n   \
    \           set to 2.\n         This rule allows reasonable performance under\
    \ loss.  A full\n         window of data is in transit at all times, and after\
    \ a loss a\n         full window less one packet will show up out-of-sequence\
    \ to be\n         queued at the receiver (e.g., up to ~2**30 bytes of data); the\n\
    \         timestamp option must not result in discarding this data.\n        \
    \ In certain unlikely circumstances, the algorithm of rules R1-R4\n         could\
    \ lead to discarding some segments unnecessarily, as shown\n         in the following\
    \ example:\n              Suppose again that segments: A.1, B.1, C.1, ..., Z.1\
    \ have\n              been sent in sequence and that segment B.1 has been lost.\n\
    \              Furthermore, suppose delivery of some of C.1, ... Z.1 is\n    \
    \          delayed until AFTER the retransmission B.2 arrives at the\n       \
    \       receiver.  These delayed segments will be discarded\n              unnecessarily\
    \ when they do arrive, since their timestamps\n              are now out of date.\n\
    \         This case is very unlikely to occur.  If the retransmission was\n  \
    \       triggered by a timeout, some of the segments C.1, ... Z.1 must\n     \
    \    have been delayed longer than the RTO time.  This is presumably\n       \
    \  an unlikely event, or there would be many spurious timeouts and\n         retransmissions.\
    \  If B's retransmission was triggered by the\n         \"fast retransmit\" algorithm,\
    \ i.e., by duplicate ACKs, then the\n         queued segments that caused these\
    \ ACKs must have been received\n         already.\n         Even if a segment\
    \ were delayed past the RTO, the Fast\n         Retransmit mechanism [Jacobson90c]\
    \ will cause the delayed\n         packets to be retransmitted at the same time\
    \ as B.2, avoiding\n         an extra RTT and therefore causing a very small performance\n\
    \         penalty.\n         We know of no case with a significant probability\
    \ of occurrence\n         in which timestamps will cause performance degradation\
    \ by\n         unnecessarily discarding segments.\n      4.2.2  Timestamp Clock\n\
    \         It is important to understand that the PAWS algorithm does not\n   \
    \      require clock synchronization between sender and receiver.  The\n     \
    \    sender's timestamp clock is used to stamp the segments, and the\n       \
    \  sender uses the echoed timestamp to measure RTT's.  However,\n         the\
    \ receiver treats the timestamp as simply a monotone-\n         increasing serial\
    \ number, without any necessary connection to\n         its clock.  From the receiver's\
    \ viewpoint, the timestamp is\n         acting as a logical extension of the high-order\
    \ bits of the\n         sequence number.\n         The receiver algorithm does\
    \ place some requirements on the\n         frequency of the timestamp clock.\n\
    \         (a)  The timestamp clock must not be \"too slow\".\n              It\
    \ must tick at least once for each 2**31 bytes sent.  In\n              fact,\
    \ in order to be useful to the sender for round trip\n              timing, the\
    \ clock should tick at least once per window's\n              worth of data, and\
    \ even with the RFC-1072 window\n              extension, 2**31 bytes must be\
    \ at least two windows.\n              To make this more quantitative, any clock\
    \ faster than 1\n              tick/sec will reject old duplicate segments for\
    \ link\n              speeds of ~8 Gbps.  A 1ms timestamp clock will work at\n\
    \              link speeds up to 8 Tbps (8*10**12) bps!\n         (b)  The timestamp\
    \ clock must not be \"too fast\".\n              Its recycling time must be greater\
    \ than MSL seconds.\n              Since the clock (timestamp) is 32 bits and\
    \ the worst-case\n              MSL is 255 seconds, the maximum acceptable clock\
    \ frequency\n              is one tick every 59 ns.\n              However, it\
    \ is desirable to establish a much longer\n              recycle period, in order\
    \ to handle outdated timestamps on\n              idle connections (see Section\
    \ 4.2.3), and to relax the MSL\n              requirement for preventing sequence\
    \ number wrap-around.\n              With a 1 ms timestamp clock, the 32-bit timestamp\
    \ will\n              wrap its sign bit in 24.8 days.  Thus, it will reject old\n\
    \              duplicates on the same connection if MSL is 24.8 days or\n    \
    \          less.  This appears to be a very safe figure; an MSL of\n         \
    \     24.8 days or longer can probably be assumed by the gateway\n           \
    \   system without requiring precise MSL enforcement by the\n              TTL\
    \ value in the IP layer.\n         Based upon these considerations, we choose\
    \ a timestamp clock\n         frequency in the range 1 ms to 1 sec per tick. \
    \ This range also\n         matches the requirements of the RTTM mechanism, which\
    \ does not\n         need much more resolution than the granularity of the\n \
    \        retransmit timer, e.g., tens or hundreds of milliseconds.\n         The\
    \ PAWS mechanism also puts a strong monotonicity requirement\n         on the\
    \ sender's timestamp clock.  The method of implementation\n         of the timestamp\
    \ clock to meet this requirement depends upon\n         the system hardware and\
    \ software.\n         *    Some hosts have a hardware clock that is guaranteed\
    \ to be\n              monotonic between hardware resets.\n         *    A clock\
    \ interrupt may be used to simply increment a binary\n              integer by\
    \ 1 periodically.\n         *    The timestamp clock may be derived from a system\
    \ clock\n              that is subject to being abruptly changed, by adding a\n\
    \              variable offset value.  This offset is initialized to\n       \
    \       zero.  When a new timestamp clock value is needed, the\n             \
    \ offset can be adjusted as necessary to make the new value\n              equal\
    \ to or larger than the previous value (which was\n              saved for this\
    \ purpose).\n      4.2.3  Outdated Timestamps\n         If a connection remains\
    \ idle long enough for the timestamp\n         clock of the other TCP to wrap\
    \ its sign bit, then the value\n         saved in TS.Recent will become too old;\
    \ as a result, the PAWS\n         mechanism will cause all subsequent segments\
    \ to be rejected,\n         freezing the connection (until the timestamp clock\
    \ wraps its\n         sign bit again).\n         With the chosen range of timestamp\
    \ clock frequencies (1 sec to\n         1 ms), the time to wrap the sign bit will\
    \ be between 24.8 days\n         and 24800 days.  A TCP connection that is idle\
    \ for more than 24\n         days and then comes to life is exceedingly unusual.\
    \  However,\n         it is undesirable in principle to place any limitation on\
    \ TCP\n         connection lifetimes.\n         We therefore require that an implementation\
    \ of PAWS include a\n         mechanism to \"invalidate\" the TS.Recent value\
    \ when a connection\n         is idle for more than 24 days.  (An alternative\
    \ solution to the\n         problem of outdated timestamps would be to send keepalive\n\
    \         segments at a very low rate, but still more often than the\n       \
    \  wrap-around time for timestamps, e.g., once a day.  This would\n         impose\
    \ negligible overhead.  However, the TCP specification has\n         never included\
    \ keepalives, so the solution based upon\n         invalidation was chosen.)\n\
    \         Note that a TCP does not know the frequency, and therefore, the\n  \
    \       wraparound time, of the other TCP, so it must assume the worst.\n    \
    \     The validity of TS.Recent needs to be checked only if the basic\n      \
    \   PAWS timestamp check fails, i.e., only if SEG.TSval <\n         TS.Recent.\
    \  If TS.Recent is found to be invalid, then the\n         segment is accepted,\
    \ regardless of the failure of the timestamp\n         check, and rule R3 updates\
    \ TS.Recent with the TSval from the\n         new segment.\n         To detect\
    \ how long the connection has been idle, the TCP may\n         update a clock\
    \ or timestamp value associated with the\n         connection whenever TS.Recent\
    \ is updated, for example.  The\n         details will be implementation-dependent.\n\
    \      4.2.4  Header Prediction\n         \"Header prediction\" [Jacobson90a]\
    \ is a high-performance\n         transport protocol implementation technique\
    \ that is most\n         important for high-speed links.  This technique optimizes\
    \ the\n         code for the most common case, receiving a segment correctly\n\
    \         and in order.  Using header prediction, the receiver asks the\n    \
    \     question, \"Is this segment the next in sequence?\"  This\n         question\
    \ can be answered in fewer machine instructions than the\n         question, \"\
    Is this segment within the window?\"\n         Adding header prediction to our\
    \ timestamp procedure leads to\n         the following recommended sequence for\
    \ processing an arriving\n         TCP segment:\n         H1)  Check timestamp\
    \ (same as step R1 above)\n         H2)  Do header prediction: if segment is next\
    \ in sequence and\n              if there are no special conditions requiring\
    \ additional\n              processing, accept the segment, record its timestamp,\
    \ and\n              skip H3.\n         H3)  Process the segment normally, as\
    \ specified in RFC-793.\n              This includes dropping segments that are\
    \ outside the win-\n              dow and possibly sending acknowledgments, and\
    \ queueing\n              in-window, out-of-sequence segments.\n         Another\
    \ possibility would be to interchange steps H1 and H2,\n         i.e., to perform\
    \ the header prediction step H2 FIRST, and\n         perform H1 and H3 only when\
    \ header prediction fails.  This\n         could be a performance improvement,\
    \ since the timestamp check\n         in step H1 is very unlikely to fail, and\
    \ it requires interval\n         arithmetic on a finite field, a relatively expensive\
    \ operation.\n         To perform this check on every single segment is contrary\
    \ to\n         the philosophy of header prediction.  We believe that this\n  \
    \       change might reduce CPU time for TCP protocol processing by up\n     \
    \    to 5-10% on high-speed networks.\n         However, putting H2 first would\
    \ create a hazard: a segment from\n         2**32 bytes in the past might arrive\
    \ at exactly the wrong time\n         and be accepted mistakenly by the header-prediction\
    \ step.  The\n         following reasoning has been introduced [Jacobson90b] to\
    \ show\n         that the probability of this failure is negligible.\n       \
    \       If all segments are equally likely to show up as old\n              duplicates,\
    \ then the probability of an old duplicate\n              exactly matching the\
    \ left window edge is the maximum\n              segment size (MSS) divided by\
    \ the size of the sequence\n              space.  This ratio must be less than\
    \ 2**-16, since MSS\n              must be < 2**16; for example, it will be (2**12)/(2**32)\
    \ =\n              2**-20 for an FDDI link.  However, the older a segment is,\n\
    \              the less likely it is to be retained in the Internet, and\n   \
    \           under any reasonable model of segment lifetime the\n             \
    \ probability of an old duplicate exactly at the left window\n              edge\
    \ must be much smaller than 2**-16.\n              The 16 bit TCP checksum also\
    \ allows a basic unreliability\n              of one part in 2**16.  A protocol\
    \ mechanism whose\n              reliability exceeds the reliability of the TCP\
    \ checksum\n              should be considered \"good enough\", i.e., it won't\n\
    \              contribute significantly to the overall error rate.  We\n     \
    \         therefore believe we can ignore the problem of an old\n            \
    \  duplicate being accepted by doing header prediction before\n              checking\
    \ the timestamp.\n         However, this probabilistic argument is not universally\n\
    \         accepted, and the consensus at present is that the performance\n   \
    \      gain does not justify the hazard in the general case.  It is\n        \
    \ therefore recommended that H2 follow H1.\n   4.3.  Duplicates from Earlier Incarnations\
    \ of Connection\n      The PAWS mechanism protects against errors due to sequence\
    \ number\n      wrap-around on high-speed connection.  Segments from an earlier\n\
    \      incarnation of the same connection are also a potential cause of\n    \
    \  old duplicate errors.  In both cases, the TCP mechanisms to\n      prevent\
    \ such errors depend upon the enforcement of a maximum\n      segment lifetime\
    \ (MSL) by the Internet (IP) layer (see Appendix of\n      RFC-1185 for a detailed\
    \ discussion).  Unlike the case of sequence\n      space wrap-around, the MSL\
    \ required to prevent old duplicate\n      errors from earlier incarnations does\
    \ not depend upon the transfer\n      rate.  If the IP layer enforces the recommended\
    \ 2 minute MSL of\n      TCP, and if the TCP rules are followed, TCP connections\
    \ will be\n      safe from earlier incarnations, no matter how high the network\n\
    \      speed.  Thus, the PAWS mechanism is not required for this case.\n     \
    \ We may still ask whether the PAWS mechanism can provide additional\n      security\
    \ against old duplicates from earlier connections, allowing\n      us to relax\
    \ the enforcement of MSL by the IP layer.  Appendix B\n      explores this question,\
    \ showing that further assumptions and/or\n      mechanisms are required, beyond\
    \ those of PAWS.  This is not part\n      of the current extension.\n"
- title: 5.  CONCLUSIONS AND ACKNOWLEDGMENTS
  contents:
  - "5.  CONCLUSIONS AND ACKNOWLEDGMENTS\n   This memo presented a set of extensions\
    \ to TCP to provide efficient\n   operation over large-bandwidth*delay-product\
    \ paths and reliable\n   operation over very high-speed paths.  These extensions\
    \ are designed\n   to provide compatible interworking with TCP's that do not implement\n\
    \   the extensions.\n   These mechanisms are implemented using new TCP options\
    \ for scaled\n   windows and timestamps.  The timestamps are used for two distinct\n\
    \   mechanisms: RTTM (Round Trip Time Measurement) and PAWS (Protect\n   Against\
    \ Wrapped Sequences).\n   The Window Scale option was originally suggested by\
    \ Mike St. Johns of\n   USAF/DCA.  The present form of the option was suggested\
    \ by Mike\n   Karels of UC Berkeley in response to a more cumbersome scheme defined\n\
    \   by Van Jacobson.  Lixia Zhang helped formulate the PAWS mechanism\n   description\
    \ in RFC-1185.\n   Finally, much of this work originated as the result of discussions\n\
    \   within the End-to-End Task Force on the theoretical limitations of\n   transport\
    \ protocols in general and TCP in particular.  More recently,\n   task force members\
    \ and other on the end2end-interest list have made\n   valuable contributions\
    \ by pointing out flaws in the algorithms and\n   the documentation.  The authors\
    \ are grateful for all these\n   contributions.\n"
- title: 6.  REFERENCES
  contents:
  - "6.  REFERENCES\n      [Clark87]  Clark, D., Lambert, M., and L. Zhang, \"NETBLT:\
    \ A Bulk\n      Data Transfer Protocol\", RFC 998, MIT, March 1987.\n      [Garlick77]\
    \  Garlick, L., R. Rom, and J. Postel, \"Issues in\n      Reliable Host-to-Host\
    \ Protocols\", Proc. Second Berkeley Workshop\n      on Distributed Data Management\
    \ and Computer Networks, May 1977.\n      [Hamming77]  Hamming, R., \"Digital\
    \ Filters\", ISBN 0-13-212571-4,\n      Prentice Hall, Englewood Cliffs, N.J.,\
    \ 1977.\n      [Cheriton88]  Cheriton, D., \"VMTP: Versatile Message Transaction\n\
    \      Protocol\", RFC 1045, Stanford University, February 1988.\n      [Jacobson88a]\
    \ Jacobson, V., \"Congestion Avoidance and Control\",\n      SIGCOMM '88, Stanford,\
    \ CA., August 1988.\n      [Jacobson88b]  Jacobson, V., and R. Braden, \"TCP Extensions\
    \ for\n      Long-Delay Paths\", RFC-1072, LBL and USC/Information Sciences\n\
    \      Institute, October 1988.\n      [Jacobson90a]  Jacobson, V., \"4BSD Header\
    \ Prediction\", ACM\n      Computer Communication Review, April 1990.\n      [Jacobson90b]\
    \  Jacobson, V., Braden, R., and Zhang, L., \"TCP\n      Extension for High-Speed\
    \ Paths\", RFC-1185, LBL and USC/Information\n      Sciences Institute, October\
    \ 1990.\n      [Jacobson90c]  Jacobson, V., \"Modified TCP congestion avoidance\n\
    \      algorithm\", Message to end2end-interest mailing list, April 1990.\n  \
    \    [Jain86]  Jain, R., \"Divergence of Timeout Algorithms for Packet\n     \
    \ Retransmissions\", Proc. Fifth Phoenix Conf. on Comp. and Comm.,\n      Scottsdale,\
    \ Arizona, March 1986.\n      [Karn87]  Karn, P. and C. Partridge, \"Estimating\
    \ Round-Trip Times\n      in Reliable Transport Protocols\", Proc. SIGCOMM '87,\
    \ Stowe, VT,\n      August 1987.\n      [McKenzie89]  McKenzie, A., \"A Problem\
    \ with the TCP Big Window\n      Option\", RFC 1110, BBN STC, August 1989.\n \
    \     [Nagle84]  Nagle, J., \"Congestion Control in IP/TCP\n      Internetworks\"\
    , RFC 896, FACC, January 1984.\n      [NBS85]  Colella, R., Aronoff, R., and K.\
    \ Mills, \"Performance\n      Improvements for ISO Transport\", Ninth Data Comm\
    \ Symposium,\n      published in ACM SIGCOMM Comp Comm Review, vol. 15, no. 5,\n\
    \      September 1985.\n      [Postel81]  Postel, J., \"Transmission Control Protocol\
    \ - DARPA\n      Internet Program Protocol Specification\", RFC 793, DARPA,\n\
    \      September 1981.\n      [Velten84] Velten, D., Hinden, R., and J. Sax, \"\
    Reliable Data\n      Protocol\", RFC 908, BBN, July 1984.\n      [Watson81]  Watson,\
    \ R., \"Timer-based Mechanisms in Reliable\n      Transport Protocol Connection\
    \ Management\", Computer Networks, Vol.\n      5, 1981.\n      [Zhang86]  Zhang,\
    \ L., \"Why TCP Timers Don't Work Well\", Proc.\n      SIGCOMM '86, Stowe, Vt.,\
    \ August 1986.\n"
- title: 'APPENDIX A:  IMPLEMENTATION SUGGESTIONS'
  contents:
  - "APPENDIX A:  IMPLEMENTATION SUGGESTIONS\n   The following layouts are recommended\
    \ for sending options on non-SYN\n   segments, to achieve maximum feasible alignment\
    \ of 32-bit and 64-bit\n   machines.\n       +--------+--------+--------+--------+\n\
    \       |   NOP  |  NOP   |  TSopt |   10   |\n       +--------+--------+--------+--------+\n\
    \       |          TSval   timestamp        |\n       +--------+--------+--------+--------+\n\
    \       |          TSecr   timestamp        |\n       +--------+--------+--------+--------+\n"
- title: 'APPENDIX B: DUPLICATES FROM EARLIER CONNECTION INCARNATIONS'
  contents:
  - "APPENDIX B: DUPLICATES FROM EARLIER CONNECTION INCARNATIONS\n   There are two\
    \ cases to be considered:  (1) a system crashing (and\n   losing connection state)\
    \ and restarting, and (2) the same connection\n   being closed and reopened without\
    \ a loss of host state.  These will\n   be described in the following two sections.\n\
    \   B.1  System Crash with Loss of State\n      TCP's quiet time of one MSL upon\
    \ system startup handles the loss\n      of connection state in a system crash/restart.\
    \  For an\n      explanation, see for example \"When to Keep Quiet\" in the TCP\n\
    \      protocol specification [Postel81].  The MSL that is required here\n   \
    \   does not depend upon the transfer speed.  The current TCP MSL of 2\n     \
    \ minutes seems acceptable as an operational compromise, as many\n      host systems\
    \ take this long to boot after a crash.\n      However, the timestamp option may\
    \ be used to ease the MSL\n      requirements (or to provide additional security\
    \ against data\n      corruption).  If timestamps are being used and if the timestamp\n\
    \      clock can be guaranteed to be monotonic over a system\n      crash/restart,\
    \ i.e., if the first value of the sender's timestamp\n      clock after a crash/restart\
    \ can be guaranteed to be greater than\n      the last value before the restart,\
    \ then a quiet time will be\n      unnecessary.\n      To dispense totally with\
    \ the quiet time would require that the\n      host clock be synchronized to a\
    \ time source that is stable over\n      the crash/restart period, with an accuracy\
    \ of one timestamp clock\n      tick or better.  We can back off from this strict\
    \ requirement to\n      take advantage of approximate clock synchronization. \
    \ Suppose that\n      the clock is always re-synchronized to within N timestamp\
    \ clock\n      ticks and that booting (extended with a quiet time, if necessary)\n\
    \      takes more than N ticks.  This will guarantee monotonicity of the\n   \
    \   timestamps, which can then be used to reject old duplicates even\n      without\
    \ an enforced MSL.\n   B.2  Closing and Reopening a Connection\n      When a TCP\
    \ connection is closed, a delay of 2*MSL in TIME-WAIT\n      state ties up the\
    \ socket pair for 4 minutes (see Section 3.5 of\n      [Postel81].  Applications\
    \ built upon TCP that close one connection\n      and open a new one (e.g., an\
    \ FTP data transfer connection using\n      Stream mode) must choose a new socket\
    \ pair each time.  The TIME-\n      WAIT delay serves two different purposes:\n\
    \      (a)  Implement the full-duplex reliable close handshake of TCP.\n     \
    \      The proper time to delay the final close step is not really\n         \
    \  related to the MSL; it depends instead upon the RTO for the\n           FIN\
    \ segments and therefore upon the RTT of the path.  (It\n           could be argued\
    \ that the side that is sending a FIN knows\n           what degree of reliability\
    \ it needs, and therefore it should\n           be able to determine the length\
    \ of the TIME-WAIT delay for\n           the FIN's recipient.  This could be accomplished\
    \ with an\n           appropriate TCP option in FIN segments.)\n           Although\
    \ there is no formal upper-bound on RTT, common\n           network engineering\
    \ practice makes an RTT greater than 1\n           minute very unlikely.  Thus,\
    \ the 4 minute delay in TIME-WAIT\n           state works satisfactorily to provide\
    \ a reliable full-duplex\n           TCP close.  Note again that this is independent\
    \ of MSL\n           enforcement and network speed.\n           The TIME-WAIT\
    \ state could cause an indirect performance\n           problem if an application\
    \ needed to repeatedly close one\n           connection and open another at a\
    \ very high frequency, since\n           the number of available TCP ports on\
    \ a host is less than\n           2**16.  However, high network speeds are not\
    \ the major\n           contributor to this problem; the RTT is the limiting factor\n\
    \           in how quickly connections can be opened and closed.\n           Therefore,\
    \ this problem will be no worse at high transfer\n           speeds.\n      (b)\
    \  Allow old duplicate segments to expire.\n           To replace this function\
    \ of TIME-WAIT state, a mechanism\n           would have to operate across connections.\
    \  PAWS is defined\n           strictly within a single connection; the last timestamp\
    \ is\n           TS.Recent is kept in the connection control block, and\n    \
    \       discarded when a connection is closed.\n           An additional mechanism\
    \ could be added to the TCP, a per-host\n           cache of the last timestamp\
    \ received from any connection.\n           This value could then be used in the\
    \ PAWS mechanism to reject\n           old duplicate segments from earlier incarnations\
    \ of the\n           connection, if the timestamp clock can be guaranteed to have\n\
    \           ticked at least once since the old connection was open.  This\n  \
    \         would require that the TIME-WAIT delay plus the RTT together\n     \
    \      must be at least one tick of the sender's timestamp clock.\n          \
    \ Such an extension is not part of the proposal of this RFC.\n           Note\
    \ that this is a variant on the mechanism proposed by\n           Garlick, Rom,\
    \ and Postel [Garlick77], which required each\n           host to maintain connection\
    \ records containing the highest\n           sequence numbers on every connection.\
    \  Using timestamps\n           instead, it is only necessary to keep one quantity\
    \ per remote\n           host, regardless of the number of simultaneous connections\
    \ to\n           that host.\n"
- title: 'APPENDIX C: CHANGES FROM RFC-1072, RFC-1185'
  contents:
  - "APPENDIX C: CHANGES FROM RFC-1072, RFC-1185\n   The protocol extensions defined\
    \ in this document differ in several\n   important ways from those defined in\
    \ RFC-1072 and RFC-1185.\n   (a)  SACK has been deferred to a later memo.\n  \
    \ (b)  The detailed rules for sending timestamp replies (see Section\n       \
    \ 3.4) differ in important ways.  The earlier rules could result\n        in an\
    \ under-estimate of the RTT in certain cases (packets\n        dropped or out\
    \ of order).\n   (c)  The same value TS.Recent is now shared by the two distinct\n\
    \        mechanisms RTTM and PAWS.  This simplification became possible\n    \
    \    because of change (b).\n   (d)  An ambiguity in RFC-1185 was resolved in\
    \ favor of putting\n        timestamps on ACK as well as data segments.  This\
    \ supports the\n        symmetry of the underlying TCP protocol.\n   (e)  The\
    \ echo and echo reply options of RFC-1072 were combined into a\n        single\
    \ Timestamps option, to reflect the symmetry and to\n        simplify processing.\n\
    \   (f)  The problem of outdated timestamps on long-idle connections,\n      \
    \  discussed in Section 4.2.2, was realized and resolved.\n   (g)  RFC-1185 recommended\
    \ that header prediction take precedence over\n        the timestamp check.  Based\
    \ upon some scepticism about the\n        probabilistic arguments given in Section\
    \ 4.2.4, it was decided\n        to recommend that the timestamp check be performed\
    \ first.\n   (h)  The spec was modified so that the extended options will be sent\n\
    \        on <SYN,ACK> segments only when they are received in the\n        corresponding\
    \ <SYN> segments.  This provides the most\n        conservative possible conditions\
    \ for interoperation with\n        implementations without the extensions.\n \
    \  In addition to these substantive changes, the present RFC attempts to\n   specify\
    \ the algorithms unambiguously by presenting modifications to\n   the Event Processing\
    \ rules of RFC-793; see Appendix E.\n"
- title: 'APPENDIX D: SUMMARY OF NOTATION'
  contents:
  - "APPENDIX D: SUMMARY OF NOTATION\n   The following notation has been used in this\
    \ document.\n   Options\n       WSopt:       TCP Window Scale Option\n       TSopt:\
    \       TCP Timestamps Option\n   Option Fields\n       shift.cnt:   Window scale\
    \ byte in WSopt.\n       TSval:       32-bit Timestamp Value field in TSopt.\n\
    \       TSecr:       32-bit Timestamp Reply field in TSopt.\n   Option Fields\
    \ in Current Segment\n       SEG.TSval:   TSval field from TSopt in current segment.\n\
    \       SEG.TSecr:   TSecr field from TSopt in current segment.\n       SEG.WSopt:\
    \   8-bit value in WSopt\n   Clock Values\n       my.TSclock:      Local source\
    \ of 32-bit timestamp values\n       my.TSclock.rate: Period of my.TSclock (1\
    \ ms to 1 sec).\n   Per-Connection State Variables\n       TS.Recent:       Latest\
    \ received Timestamp\n       Last.ACK.sent:   Last ACK field sent\n       Snd.TS.OK:\
    \       1-bit flag\n       Snd.WS.OK:       1-bit flag\n       Rcv.Wind.Scale:\
    \  Receive window scale power\n       Snd.Wind.Scale:  Send window scale power\n"
- title: 'APPENDIX E: EVENT PROCESSING'
  contents:
  - 'APPENDIX E: EVENT PROCESSING

    '
- title: Event Processing
  contents:
  - "Event Processing\n  OPEN Call\n     ...\n    An initial send sequence number\
    \ (ISS) is selected.  Send a SYN\n    segment of the form:\n        <SEQ=ISS><CTL=SYN><TSval=my.TSclock><WSopt=Rcv.Wind.Scale>\n\
    \      ...\n  SEND Call\n    CLOSED STATE (i.e., TCB does not exist)\n      ...\n\
    \    LISTEN STATE\n      If the foreign socket is specified, then change the connection\n\
    \      from passive to active, select an ISS.  Send a SYN segment\n      containing\
    \ the options: <TSval=my.TSclock> and\n      <WSopt=Rcv.Wind.Scale>.  Set SND.UNA\
    \ to ISS, SND.NXT to ISS+1.\n      Enter SYN-SENT state. ...\n    SYN-SENT STATE\n\
    \    SYN-RECEIVED STATE\n      ...\n    ESTABLISHED STATE\n    CLOSE-WAIT STATE\n\
    \      Segmentize the buffer and send it with a piggybacked\n      acknowledgment\
    \ (acknowledgment value = RCV.NXT).  ...\n      If the urgent flag is set ...\n\
    \      If the Snd.TS.OK flag is set, then include the TCP Timestamps\n      option\
    \ <TSval=my.TSclock,TSecr=TS.Recent> in each data segment.\n      Scale the receive\
    \ window for transmission in the segment header:\n            SEG.WND = (SND.WND\
    \ >> Rcv.Wind.Scale).\n  SEGMENT ARRIVES\n     ...\n    If the state is LISTEN\
    \ then\n      first check for an RST\n        ...\n      second check for an ACK\n\
    \        ...\n      third check for a SYN\n        if the SYN bit is set, check\
    \ the security.  If the ...\n         ...\n        If the SEG.PRC is less than\
    \ the TCB.PRC then continue.\n        Check for a Window Scale option (WSopt);\
    \ if one is found, save\n        SEG.WSopt in Snd.Wind.Scale and set Snd.WS.OK\
    \ flag on.\n        Otherwise, set both Snd.Wind.Scale and Rcv.Wind.Scale to zero\n\
    \        and clear Snd.WS.OK flag.\n        Check for a TSopt option; if one is\
    \ found, save SEG.TSval in the\n        variable TS.Recent and turn on the Snd.TS.OK\
    \ bit.\n        Set RCV.NXT to SEG.SEQ+1, IRS is set to SEG.SEQ and any other\n\
    \        control or text should be queued for processing later.  ISS\n       \
    \ should be selected and a SYN segment sent of the form:\n          <SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>\n\
    \        If the Snd.WS.OK bit is on, include a WSopt option\n        <WSopt=Rcv.Wind.Scale>\
    \ in this segment.  If the Snd.TS.OK bit is\n        on, include a TSopt <TSval=my.TSclock,TSecr=TS.Recent>\
    \ in this\n        segment.  Last.ACK.sent is set to RCV.NXT.\n        SND.NXT\
    \ is set to ISS+1 and SND.UNA to ISS.  The connection\n        state should be\
    \ changed to SYN-RECEIVED.  Note that any other\n        incoming control or data\
    \ (combined with SYN) will be processed\n        in the SYN-RECEIVED state, but\
    \ processing of SYN and ACK should\n        not be repeated.  If the listen was\
    \ not fully specified (i.e.,\n        the foreign socket was not fully specified),\
    \ then the\n        unspecified fields should be filled in now.\n      fourth\
    \ other text or control\n       ...\n    If the state is SYN-SENT then\n     \
    \ first check the ACK bit\n        ...\n      fourth check the SYN bit\n     \
    \    ...\n        If the SYN bit is on and the security/compartment and precedence\n\
    \        are acceptable then, RCV.NXT is set to SEG.SEQ+1, IRS is set to\n   \
    \     SEG.SEQ, and any acknowledgements on the retransmission queue\n        which\
    \ are thereby acknowledged should be removed.\n        Check for a Window Scale\
    \ option (WSopt); if is found, save\n        SEG.WSopt in Snd.Wind.Scale; otherwise,\
    \ set both Snd.Wind.Scale\n        and Rcv.Wind.Scale to zero.\n        Check\
    \ for a TSopt option; if one is found, save SEG.TSval in\n        variable TS.Recent\
    \ and turn on the Snd.TS.OK bit in the\n        connection control block.  If\
    \ the ACK bit is set, use my.TSclock\n        - SEG.TSecr as the initial RTT estimate.\n\
    \        If SND.UNA > ISS (our SYN has been ACKed), change the connection\n  \
    \      state to ESTABLISHED, form an ACK segment:\n            <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>\n\
    \        and send it.  If the Snd.Echo.OK bit is on, include a TSopt\n       \
    \ option <TSval=my.TSclock,TSecr=TS.Recent> in this ACK segment.\n        Last.ACK.sent\
    \ is set to RCV.NXT.\n        Data or controls which were queued for transmission\
    \ may be\n        included.  If there are other controls or text in the segment\n\
    \        then continue processing at the sixth step below where the URG\n    \
    \    bit is checked, otherwise return.\n        Otherwise enter SYN-RECEIVED,\
    \ form a SYN,ACK segment:\n            <SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>\n \
    \       and send it.  If the Snd.Echo.OK bit is on, include a TSopt\n        option\
    \ <TSval=my.TSclock,TSecr=TS.Recent> in this segment.  If\n        the Snd.WS.OK\
    \ bit is on, include a WSopt option\n        <WSopt=Rcv.Wind.Scale> in this segment.\
    \  Last.ACK.sent is set to\n        RCV.NXT.\n        If there are other controls\
    \ or text in the segment, queue them\n        for processing after the ESTABLISHED\
    \ state has been reached,\n        return.\n      fifth, if neither of the SYN\
    \ or RST bits is set then drop the\n      segment and return.\n    Otherwise,\n\
    \    First, check sequence number\n      SYN-RECEIVED STATE\n      ESTABLISHED\
    \ STATE\n      FIN-WAIT-1 STATE\n      FIN-WAIT-2 STATE\n      CLOSE-WAIT STATE\n\
    \      CLOSING STATE\n      LAST-ACK STATE\n      TIME-WAIT STATE\n        Segments\
    \ are processed in sequence.  Initial tests on arrival\n        are used to discard\
    \ old duplicates, but further processing is\n        done in SEG.SEQ order.  If\
    \ a segment's contents straddle the\n        boundary between old and new, only\
    \ the new parts should be\n        processed.\n        Rescale the received window\
    \ field:\n            TrueWindow = SEG.WND << Snd.Wind.Scale,\n        and use\
    \ \"TrueWindow\" in place of SEG.WND in the following steps.\n        Check whether\
    \ the segment contains a Timestamps option and bit\n        Snd.TS.OK is on. \
    \ If so:\n          If SEG.TSval < TS.Recent, then test whether connection has\n\
    \          been idle less than 24 days; if both are true, then the\n         \
    \ segment is not acceptable; follow steps below for an\n          unacceptable\
    \ segment.\n          If SEG.SEQ is equal to Last.ACK.sent, then save SEG.ECopt\
    \ in\n          variable TS.Recent.\n        There are four cases for the acceptability\
    \ test for an incoming\n        segment:\n          ...\n        If an incoming\
    \ segment is not acceptable, an acknowledgment\n        should be sent in reply\
    \ (unless the RST bit is set, if so drop\n        the segment and return):\n \
    \         <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>\n        Last.ACK.sent is set to\
    \ SEG.ACK of the acknowledgment.  If the\n        Snd.Echo.OK bit is on, include\
    \ the Timestamps option\n        <TSval=my.TSclock,TSecr=TS.Recent> in this ACK\
    \ segment.  Set\n        Last.ACK.sent to SEG.ACK and send the ACK segment.  After\n\
    \        sending the acknowledgment, drop the unacceptable segment and\n     \
    \   return.\n          ...\n    fifth check the ACK field.\n      if the ACK bit\
    \ is off drop the segment and return.\n      if the ACK bit is on\n        ...\n\
    \        ESTABLISHED STATE\n          If SND.UNA < SEG.ACK =< SND.NXT then, set\
    \ SND.UNA <- SEG.ACK.\n          Also compute a new estimate of round-trip time.\
    \  If Snd.TS.OK\n          bit is on, use my.TSclock - SEG.TSecr; otherwise use\
    \ the\n          elapsed time since the first segment in the retransmission\n\
    \          queue was sent.  Any segments on the retransmission queue\n       \
    \   which are thereby entirely acknowledged...\n            ...\n    Seventh,\
    \ process the segment text.\n      ESTABLISHED STATE\n      FIN-WAIT-1 STATE\n\
    \      FIN-WAIT-2 STATE\n          ...\n        Send an acknowledgment of the\
    \ form:\n          <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>\n        If the Snd.TS.OK\
    \ bit is on, include Timestamps option\n        <TSval=my.TSclock,TSecr=TS.Recent>\
    \ in this ACK segment.  Set\n        Last.ACK.sent to SEG.ACK of the acknowledgment,\
    \ and send it.\n        This acknowledgment should be piggy-backed on a segment\
    \ being\n        transmitted if possible without incurring undue delay.\n    \
    \     ...\n"
- title: Security Considerations
  contents:
  - "Security Considerations\n   Security issues are not discussed in this memo.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Van Jacobson\n   University of California\n   Lawrence\
    \ Berkeley Laboratory\n   Mail Stop 46A\n   Berkeley, CA 94720\n   Phone: (415)\
    \ 486-6411\n   EMail: van@CSAM.LBL.GOV\n   Bob Braden\n   University of Southern\
    \ California\n   Information Sciences Institute\n   4676 Admiralty Way\n   Marina\
    \ del Rey, CA 90292\n   Phone: (310) 822-1511\n   EMail: Braden@ISI.EDU\n   Dave\
    \ Borman\n   Cray Research\n   655-E Lone Oak Drive\n   Eagan, MN 55121\n   Phone:\
    \ (612) 683-5571\n   Email: dab@cray.com\n"
