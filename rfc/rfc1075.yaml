- title: __initial_text__
  contents:
  - '               Distance Vector Multicast Routing Protocol

    '
- title: 1. Status of this Memo
  contents:
  - "1. Status of this Memo\n   This RFC describes a distance-vector-style routing\
    \ protocol for\n   routing multicast datagrams through an internet.  It is derived\
    \ from\n   the Routing Information Protocol (RIP) [1], and implements\n   multicasting\
    \ as described in RFC-1054.  This is an experimental\n   protocol, and its implementation\
    \ is not recommended at this time.\n   Distribution of this memo is unlimited.\n"
- title: 2. Introduction
  contents:
  - "2. Introduction\n   A draft standard for multicasting over IP networks now exists\
    \ [2],\n   but no routing protocols to support internetwork multicasting are\n\
    \   available.  This memo describes an experimental routing protocol,\n   named\
    \ DVMRP, that implements internetwork multicasting.  DVMRP\n   combines many of\
    \ the features of RIP [1] with the Truncated Reverse\n   Path Broadcasting (TRPB)\
    \ algorithm described by Deering [3].\n   DVMRP is an \"interior gateway protocol\"\
    ; suitable for use within an\n   autonomous system, but not between different\
    \ autonomous systems.\n   DVMRP is not currently developed for use in routing\
    \ non-multicast\n   datagrams, so a router that routes both multicast and unicast\n\
    \   datagrams must run two separate routing processes.  DVMRP is designed\n  \
    \ to be easily extensible and could be extended to route unicast\n   datagrams.\n\
    \   DVMRP was developed to experiment with the algorithms in [3].  RIP\n   was\
    \ used as the starting point for the development because an\n   implementation\
    \ was available and distance vector algorithms are\n   simple, as compared to\
    \ link-state algorithms [4].  In addition, to\n   allow experiments to traverse\
    \ networks that do not support\n   multicasting, a mechanism called \"tunneling\"\
    \ was developed.\n   The multicast forwarding algorithm requires the building\
    \ of trees\n   based on routing information.  This tree building needs more state\n\
    \   information than RIP is designed to provide, so DVMRP is much more\n   complicated\
    \ in some places than RIP.  A link-state algorithm, which\n   already maintains\
    \ much of the state needed, might prove a better\n   basis for Internet multicasting\
    \ routing and forwarding.\n   DVMRP differs from RIP in one very important way.\
    \  RIP thinks in\n   terms of routing and forwarding datagrams to a particular\n\
    \   destination.  The purpose of DVMRP is to keep track of the return\n   paths\
    \ to the source of multicast datagrams.  To make explanation of\n   DVMRP more\
    \ consistent with RIP, the word \"destination\" is used\n   instead of the more\
    \ proper \"source\", but the reader must remember\n   that datagrams are not forwarded\
    \ to these destinations, but originate\n   from them.\n   This memo is organized\
    \ into the following sections:\n           - A description of DVMRP is presented.\n\
    \           - Tunnels are explained.\n           - The routing algorithm is shown.\n\
    \           - The forwarding algorithm is shown.\n           - The various time\
    \ values are listed.\n           - Configuration information is specified.\n \
    \  This memo does not analyze distance-vector routing, nor fully explain\n   the\
    \ distance-vector algorithm; see [1] for more information on these\n   topics.\
    \  The process or processes that perform the routing and\n   forwarding functions\
    \ are called \"routers\" in this memo.\n"
- title: 3. Protocol Description
  contents:
  - "3. Protocol Description\n   DVMRP uses the Internet Group Management Protocol\
    \ (IGMP) to exchange\n   routing datagrams [2].\n   DVMRP datagrams are composed\
    \ of two portions: a small, fixed length\n   IGMP header, and a stream of tagged\
    \ data.\n   The fixed length IGMP header of DVMRP messages is:\n       0     \
    \              1                   2                   3\n       0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |Version| Type  |  Subtype      |           Checksum            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   The\
    \ version is 1.\n   The type for DVMRP is 3.\n   The subtype is one of:\n   1\
    \ = Response; the message provides routes to some destination(s).\n   2 = Request;\
    \ the message requests routes to some destination(s).\n   3 = Non-membership report;\
    \ the message provides non-membership\n       report(s).\n   4 = Non-membership\
    \ cancellation; the message cancels previous\n       non-membership report(s).\n\
    \   The checksum is the 16-bit one's complement of the one's complement\n   sum\
    \ of the entire message, excluding the IP header.  For computing\n   the checksum,\
    \ the checksum field is zeroed.\n   The rest of the DVMRP message is a stream\
    \ of tagged data.  The reason\n   for using a stream of tagged data is to provide\
    \ easy extensibility\n   (new commands can be developed by adding new tags) and\
    \ to reduce the\n   amount of redundant data in a message.  The elements in the\
    \ stream,\n   called commands, are multiples of 16 bits, for convenient alignment.\n\
    \   The commands are organized as an eight bit command numeric code, with\n  \
    \ at least an eight bit data portion.  Sixteen-bit alignment of all\n   commands\
    \ is required.\n   A message that has an error in it will be discarded at the\
    \ point in\n   processing where the error is detected.  Any state changed due\
    \ to the\n   message contents before the error will not be restored to its\n \
    \  previous values.\n   Certain commands have default values defined in their\
    \ specification.\n   As the defaults may be changed as the protocol is developed\
    \ further,\n   a cautious implementation will not send out messages that depend\
    \ on\n   defaults.\n   The length of DVMRP messages is limited to 512 bytes, excluding\
    \ the\n   IP header.\n"
- title: 3.1 NULL Command
  contents:
  - "3.1 NULL Command\n   Format:  0 1 2 3 4 5 6 7    0 1 2 3 4 5 6 7\n          \
    \ +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+\n           |        0      |  |    Ignored\
    \    |\n           +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+\n   Description: The NULL\
    \ command can be used to provide additional\n   alignment or padding to 32 bits.\n"
- title: 3.2 Address Family Indicator (AFI) Command
  contents:
  - "3.2 Address Family Indicator (AFI) Command\n   Format:  0 1 2 3 4 5 6 7    0\
    \ 1 2 3 4 5 6 7\n           +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+\n           |\
    \        2      |  |     family    |\n           +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+\n\
    \   Values for family:\n      2 = IP address family, in which addresses are 32\
    \ bits long.\n   Default: Family = 2.\n   Description: The AFI command provides\
    \ the address family for\n   subsequent addresses in the stream (until a different\
    \ AFI command is\n   given).\n   It is an error if the receiver does not support\
    \ the address family.\n"
- title: 3.3 Subnetmask Command
  contents:
  - "3.3 Subnetmask Command\n   Format:  0 1 2 3 4 5 6 7    0 1 2 3 4 5 6 7\n    \
    \       +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+\n           |        3      |  |\
    \     count     |\n           +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+\n   Additional\
    \ argument, with AFI = IP:\n    0                   1                   2    \
    \               3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Subnet mask                                                   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Count is 0 or 1.\n   Default: Assume that following routes are to networks,\
    \ and use a mask\n   of the network mask of each route's destination.\n   Description:\
    \ The Subnetmask command provides the subnet mask to use\n   for subsequent routes.\
    \  There are some requirements on the bits in\n   the subnetmask: bits 0 through\
    \ 7 must be 1, and all of the bits must\n   not be 1.\n   If the count is 0, then\
    \ no subnet mask applies, assume that the\n   following routes are to networks,\
    \ and use a mask of the network mask\n   of each route's destination.  If count\
    \ is 1, then a subnet mask\n   should be in the data stream, of an appropriate\
    \ size given the\n   address family.\n   It is an error for count not to equal\
    \ 0 or 1.\n   Subnetmasks should not be sent outside of the appropriate network.\n\
    \   See [6] for more information regarding IP subnetting.\n"
- title: 3.4 Metric Command
  contents:
  - "3.4 Metric Command\n   Format:  0 1 2 3 4 5 6 7    0 1 2 3 4 5 6 7\n        \
    \   +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+\n           |        4      |  |    \
    \ value     |\n           +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+\n   Value is the\
    \ metric, as an unsigned value ranging from 1 to 255.\n   Default: None.\n   Description:\
    \ The metric command provides the metric to subsequent\n   destinations.  The\
    \ metric is relative to the router that sent this\n   DVMRP routing update.\n\
    \   It is an error for metric to equal 0.\n"
- title: 3.5 Flags0 Command
  contents:
  - "3.5 Flags0 Command\n   Format:  0 1 2 3 4 5 6 7    0 1 2 3 4 5 6 7\n        \
    \   +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+\n           |        5      |  |    \
    \ value     |\n           +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+\n   Meaning of\
    \ bits in value:\n      Bit 7: Destination is unreachable.\n      Bit 6: Split\
    \ Horizon concealed route.\n   Default: All bits zero.\n   Description: The flags0\
    \ command provides a way to set a number of\n   flags.  The only defined flags,\
    \ bits 6 and 7, can be used to provide\n   more information about a route with\
    \ a metric of infinity.  A router\n   that receives a flag that it does not support\
    \ should ignore the flag.\n   The command is called flags0 to permit the definition\
    \ of additional\n   flag commands in the future (flags1, etc.).\n   This is an\
    \ experimental command, and may be changed in the future.\n"
- title: 3.6 Infinity Command
  contents:
  - "3.6 Infinity Command\n   Format:  0 1 2 3 4 5 6 7    0 1 2 3 4 5 6 7\n      \
    \     +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+\n           |        6      |  |  \
    \   value     |\n           +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+\n   Value is\
    \ the infinity, as an unsigned value ranging from 1 to 255.\n   Default: Value\
    \ = 16.\n   Description: The infinity command defines the infinity for subsequent\n\
    \   metrics in the stream.\n   It is an error for infinity to be zero, or less\
    \ than the current\n   metric.\n"
- title: 3.7 Destination Address (DA) Command
  contents:
  - "3.7 Destination Address (DA) Command\n   Format:  0 1 2 3 4 5 6 7    0 1 2 3\
    \ 4 5 6 7\n           +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+\n           |     \
    \   7      |  |     count     |\n           +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+\n\
    \   Array of 'count' additional arguments, with AFI = IP:\n    0             \
    \      1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Destination Address1                                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Destination Address2                                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Count is the number of addresses supplied, from 1 to 255.  The length\n  \
    \ of the addresses depends upon the current address family.  The number\n   of\
    \ addresses supplied is subject to the message length limitation of\n   512 bytes.\n\
    \   Default: None.\n   Description: The DA command provides a list of destinations.\
    \  While\n   this format can express routes to hosts, the routing algorithm only\n\
    \   supports network and subnetwork routing.  The current metric,\n   infinity,\
    \ flags0 and subnetmask, when combined with a single\n   destination address,\
    \ define a route.  The current metric must be less\n   than or equal to the current\
    \ infinity.\n   It is an error for count to equal 0.\n"
- title: 3.8 Requested Destination Address (RDA) Command
  contents:
  - "3.8 Requested Destination Address (RDA) Command\n   Format:  0 1 2 3 4 5 6 7\
    \    0 1 2 3 4 5 6 7\n           +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+\n      \
    \     |        8      |  |     count     |\n           +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+\n\
    \   Array of 'count' additional arguments, with AFI = IP:\n    0             \
    \      1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Requested Destination Address1                                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Requested Destination Address2                                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Count is the number of addresses supplied, from 0 to 255.  The length\n  \
    \ of the addresses depends upon the current address family.  The number\n   of\
    \ addresses supplied is subject to the message length limitation of\n   512 bytes.\n\
    \   Default: None.\n   Description: The RDA command provides a list of destinations\
    \ for whom\n   routes are requested.  A routing request for all routes is encoded\
    \ by\n   using a count = 0.\n"
- title: 3.9 Non Membership Report (NMR) Command
  contents:
  - "3.9 Non Membership Report (NMR) Command\n   Format:  0 1 2 3 4 5 6 7    0 1 2\
    \ 3 4 5 6 7\n           +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+\n           |   \
    \     9      |  |     count     |\n           +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+\n\
    \    Array of 'count' additional arguments, with AFI = IP:\n    0            \
    \       1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Multicast Address1                                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Hold Down Time1                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Multicast Address2                                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Hold Down Time2                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Count is the number of Multicast Address and Hold Down Time pairs\n   supplied,\
    \ from 1 to 255.  The length of the addresses depends upon\n   the current address\
    \ family.  The number of pairs supplied is subject\n   to the message length limitation\
    \ of 512 bytes.\n   Default: None.\n   Description: The NMR command is experimental,\
    \ and has not been tested\n   in an implementation.  Each multicast address and\
    \ hold down time pair\n   is called a non-membership report.  The non-membership\
    \ report tells\n   the receiving router that the sending router has no descendent\
    \ group\n   members in the given group.  Based on this information the receiving\n\
    \   router can stop forwarding datagrams to the sending router for the\n   particular\
    \ multicast address(es) listed.  The hold down time\n   indicates, in seconds,\
    \ how long the NMR is valid.\n   It is an error for count to equal 0.\n   The\
    \ only other commands in a message that has NMR commands can be the\n   AFI, flags0,\
    \ and NULL commands.  No relevant flags for the flags0\n   command are currently\
    \ defined, but that may change in the future.\n"
- title: 3.10 Non Membership Report Cancel (NMR Cancel) Command
  contents:
  - "3.10 Non Membership Report Cancel (NMR Cancel) Command\n   Format:  0 1 2 3 4\
    \ 5 6 7    0 1 2 3 4 5 6 7\n           +-+-+-+-+-+-+-+-+  +-+-+-+-+-+-+-+-+\n\
    \           |       10      |  |     count     |\n           +-+-+-+-+-+-+-+-+\
    \  +-+-+-+-+-+-+-+-+\n    Array of 'count' additional arguments, with AFI = IP:\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Multicast Address1                                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Multicast Address2                                            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Count is the number of Multicast Addresses supplied, from 1 to 255.\n   The\
    \ length of the addresses depends upon the current address family.\n   The number\
    \ of addresses supplied is subject to the message length\n   limitation of 512\
    \ bytes.\n   Default: None.\n   Description: The NMR Cancel command is experimental,\
    \ and has not been\n   tested in an implementation.  For each multicast address\
    \ listed, any\n   previous corresponding non-membership reports are canceled.\
    \  When\n   there is no corresponding non-membership report for a given multicast\n\
    \   address, the Cancel command should be ignored for that multicast\n   address.\n\
    \   It is an error for count to equal 0.\n   The only other commands in a message\
    \ that has NMR Cancel commands can\n   be the AFI, flags0, and NULL commands.\
    \  No relevant flags for the\n   flags0 command are currently defined, but that\
    \ may change in the\n   future.\n"
- title: '3.12 Examples (with bytes in ''{}''), not including the message header:'
  contents:
  - '3.12 Examples (with bytes in ''{}''), not including the message header:

    '
- title: 3.12.1 Supplying a single route to the IP address 128.2.251.231 with
  contents:
  - "3.12.1 Supplying a single route to the IP address 128.2.251.231 with\n   a metric\
    \ of 2, an infinity of 16, a subnetmask of 255.255.255.0:\n   Subtype 1,\n   AFI\
    \ 2,  Metric 2, Infinity 16, Subnet Mask 255.255.255.0\n   {2} {2} {4} {2}   {6}\
    \ {16}     {3} {1} {255} {255} {255} {0}\n   DA Count=1 [128.2.251.231]\n   {7}\
    \ {1} {128} {2} {251} {231}\n"
- title: 3.12.2 Supplying a route to the IP addresses 128.2.251.231 and
  contents:
  - "3.12.2 Supplying a route to the IP addresses 128.2.251.231 and\n   128.2.236.2\
    \ with a metric of 2, an infinity of 16, a subnetmask of\n   255.255.255.0:\n\
    \   Subtype 1,\n   AFI 2,  Metric 2, Infinity 16, Subnet Mask 255.255.255.0\n\
    \   {2} {2} {4} {2}   {6} {16}     {3} {1} 255} {255} {255} {0}\n   DA Count=2\
    \ [128.2.251.231] [128.2.236.2]\n   {7} {1} {128} {2} {251} {231} {128} {2} {236}\
    \ {2}\n"
- title: 3.12.3 Request for all routes to IP destinations.
  contents:
  - "3.12.3 Request for all routes to IP destinations.\n   Subtype 2, AFI 2,  RDA\
    \ Count = 0\n              {2} {2} {8} {0}\n"
- title: 3.12.4 Non Membership Report for groups 224.2.3.1 and 224.5.4.6 with a
  contents:
  - "3.12.4 Non Membership Report for groups 224.2.3.1 and 224.5.4.6 with a\n   hold\
    \ down time of 20 seconds, and group 224.7.8.5 with a hold down\n   time of 40\
    \ seconds.\n   Subtype 3,\n   AFI 2,  NMR Count = 3 [224.2.3.1, 20]\n   {2} {2}\
    \ {10} {3} {224} {2} {3} {1} {0} {0} {0} {20}\n   [224.5.4.6, 20] [224.7.8.5,\
    \ 40]\n   {224} {5} {4} {6} {0} {0} {0} {20} {224} {7} {8} {5} {0} {0} {0} {40}\n"
- title: 3.13 Summary of Commands
  contents:
  - "3.13 Summary of Commands\n   Value   Name            Other commands allowed in\
    \ same message\n   -----   ----            ---------------------------------------\n\
    \   0       Null            Null, AFI, Subnetmask, Metric, Flags0,\n         \
    \                  Infinity, DA, RDA, NMR, NMR-cancel\n   2       AFI        \
    \     Null, AFI, Subnetmask, Metric, Flags0,\n                           Infinity,\
    \ DA, RDA, NMR, NMR-cancel\n   3       Subnetmask      Null, AFI, Subnetmask,\
    \ Metric, Flags0,\n                           Infinity, DA, RDA\n   4       Metric\
    \          Null, AFI, Subnetmask, Metric, Flags0,\n                          \
    \ Infinity, DA\n   5       Flags0          Null, AFI, Subnetmask, Metric, Flags0,\n\
    \                           Infinity, DA\n   6       Infinity        Null, AFI,\
    \ Subnetmask, Metric, Flags0,\n                           Infinity, DA\n   7 \
    \      DA              Null, AFI, Subnetmask, Metric, Flags0,\n              \
    \             Infinity, DA\n   8       RDA             Null, AFI, Subnetmask,\
    \ Flags0, RDA\n   9       NMR             Null, AFI, Flags0, NMR\n   10      NMR-cancel\
    \      Null, AFI, Flags0, NMR-cancel\n"
- title: 4. Tunnels
  contents:
  - "4. Tunnels\n   A tunnel is a method for sending datagrams between routers separated\n\
    \   by gateways that do not support multicasting routing.  It acts as a\n   virtual\
    \ network between two routers.  For instance, a router running\n   at Stanford,\
    \ and a router running at BBN might be connected with a\n   tunnel to allow multicast\
    \ datagrams to traverse the Internet.  We\n   consider tunnels to be a transitional\
    \ hack.\n   Tunneling is done with a weakly encapsulated normal multicasted\n\
    \   datagram.  The weak encapsulation uses a special two element IP loose\n  \
    \ source route [5].  (This form of encapsulation is preferable to\n   \"strong\"\
    \ encapsulation, i.e., prepending an entire new IP header,\n   because it does\
    \ not require the tunnel end-points to know each\n   other's maximum reassembly\
    \ buffer size.  It also has the benefit of\n   correct behavior of the originator's\
    \ time-to-live value and any other\n   IP options present.)\n   A tunnel has a\
    \ local end-point, remote end-point, metric, and\n   threshold associated with\
    \ it.  The routers at each end of the tunnel\n   need only agree upon the local\
    \ and remote end-points.  See section 8\n   for information on how tunnels are\
    \ configured.  Because the number of\n   intermediate gateways between the end-points\
    \ of a tunnel is unknown,\n   additional research is needed to determine appropriate\
    \ metrics and\n   thresholds.\n   To send a datagram on a tunnel, the following\
    \ occurs:\n      - A null IP option is inserted into the datagram.  This provides\n\
    \        preferred alignment for the loose source route IP option.\n      - A\
    \ two element loose source route IP option is inserted into\n        the datagram.\n\
    \      - The source route pointer is set to point to the second element\n    \
    \    in the source route.\n      - The first element in the source route is replaced\
    \ with the\n        address of the originating host (the original IP source\n\
    \        address).\n      - The second element in the source route is replaced\
    \ with the\n        multicast destination address provided by the originating\
    \ host\n        (the original IP destination address).\n      - The IP source\
    \ address is replaced with the address of the\n        router's appropriate outgoing\
    \ physical interface (the local\n        tunnel end-point).\n      - The IP destination\
    \ address is replaced with an address of the\n        remote router (the remote\
    \ tunnel end-point).\n      - The datagram is transmitted to the remote router\
    \ using\n        non-multicast routing algorithms.\n   Intermediate, non-multicast\
    \ gateways will route the tunneled datagram\n   to the remote tunnel end-point.\
    \  Because the datagram's IP source\n   address has been replaced with the address\
    \ of the local tunnel end-\n   point, ICMP error messages will go to the originating\
    \ multicast\n   router.  This behavior is desired, because a host that sends a\n\
    \   multicast datagram, which a multicast router decides to tunnel,\n   should\
    \ not be aware of the use of the tunnel.  If the datagram's IP\n   source address\
    \ were not changed when encapsulating the datagram, any\n   ICMP errors would\
    \ be sent to the originating host.\n   When the remote tunnel end-point receives\
    \ the tunneled datagram, the\n   following occurs:\n      - The IP source address\
    \ is replaced with the first element in the\n        loose source route.\n   \
    \   - The IP destination address is replaced with the second element\n       \
    \ in the loose source route.\n      - The null option and the loose source route\
    \ option are removed\n        from the datagram.  This is needed because a host\
    \ should not\n        be able to tell that it has received a datagram that was\
    \ sent\n        through a tunnel.\n   Because no specific network is associated\
    \ with a tunnel, there are no\n   local group memberships to be tracked for a\
    \ tunnel.  The only\n   neighbor on a tunnel can be the remote end-point.  Routing\
    \ messages\n   should be exchanged through tunnels, but a route is not created\
    \ for a\n   tunnel.  The routing messages should be sent as unicast datagrams\n\
    \   directly to the remote tunnel end-point; they should not use an IP\n   loose\
    \ source route.\n   Justification for using the loose source route and record\
    \ option for\n   tunneling:\n      We considered defining our own IP option to\
    \ handle tunneling, but\n      we are worried that intermediate gateways do not\
    \ transparently\n      pass IP options that are unknown to them.  Datagrams using\
    \ a new\n      option would not traverse the Internet.  It would be better for\
    \ us\n      if we could create a new IP option, but it won't work presently.\n\
    \      Recall that this is a transition design to allow us to experiment\n   \
    \   in the current environment.\n      The tunneled packet containing the LSRR\
    \ option has the following\n      features:\n                      Field     \
    \       Value\n                      -----            --------------------\n \
    \                     src address    = src gateway address\n                 \
    \     dst address    = dst gateway address\n                      LSRR pointer\
    \   = points to LSRR address 2\n                      LSRR address 1 = src host\n\
    \                      LSRR address 2 = multicast destination\n      Two questions\
    \ raised about using the LSRR option for tunnels are\n      \"Can intermediate\
    \ gateways ignore the option?\", and \"Can the\n      destination gateway properly\
    \ detect that the LSRR is used for a\n      tunnel?\".\n      When an intermediate\
    \ gateway receives a datagram, it examines the\n      destination address.  For\
    \ a tunneled datagram, the destination\n      address will not match an address\
    \ of the receiving gateway.\n      Therefore, the LSRR option will not be examined,\
    \ and the\n      intermediate gateway will forward the datagram on to its next\
    \ hop\n      for the destination address.\n      When the destination gateway\
    \ receives a datagram, it notes that\n      the datagram destination address matches\
    \ one of its own address.\n      It will then look at the next LSRR option address,\
    \ since the\n      source route is not exhausted.  That address is a multicast\n\
    \      address.  Since hosts are forbidden from putting multicast\n      addresses\
    \ into source routes, the gateway can infer that the LSRR\n      is for tunneling.\
    \  The weakness here is that perhaps there is some\n      other meaning for the\
    \ multicast address in the LSRR.  No other\n      meaning is currently defined.\n\
    \      If a tunneled datagram is by error addressed to a destination\n      gateway\
    \ that does not support multicasting, then the destination\n      gateway will\
    \ try to find a route to the multicast address.  This\n      will fail, and an\
    \ ICMP destination unreachable error message will\n      be sent to the tunneled\
    \ datagram's source.  Since the source\n      address in the tunneled datagram\
    \ has been adjusted to be the\n      address of the source multicast gateway,\
    \ the ICMP errors will not\n      go to the originating host, which has no knowledge\
    \ of tunnels.\n"
- title: 5. Routing Algorithm
  contents:
  - "5. Routing Algorithm\n   This section provides a terse description of the distance-vector\n\
    \   routing algorithm.  See [1] for more information.\n   While DVMRP can express\
    \ routes to individual hosts, the forwarding\n   and routing algorithms only support\
    \ network and subnetwork routing.\n   In the discussion below, the term \"virtual\
    \ interface\" is used to\n   refer to a physical interface or a tunnel local end-point.\
    \  A\n   physical interface is a network interface, for instance, an Ethernet\n\
    \   card.  A route to a destination will be through a virtual interface.\n   The\
    \ term \"virtual network\" is used to refer to a physical network or\n   a tunnel,\
    \ with the qualification that routes only reference physical\n   networks.\n \
    \  The TRPB algorithm forwards multicast datagrams by computing the\n   shortest\
    \ (reverse) path tree from the source (physical) network to\n   all possible recipients\
    \ of the datagram.  Each multicast router must\n   determine its place in the\
    \ tree, relative to the particular source,\n   and then determine which of its\
    \ virtual interfaces are in the\n   shortest path tree.  The datagram is forwarded\
    \ out these virtual\n   interfaces.  The process of excluding virtual interfaces\
    \ not in the\n   shortest path tree is called \"pruning.\"\n   Consider a virtual\
    \ network.  Using Deering's terminology [3], a\n   router is called the \"parent\"\
    \ of the virtual network if that router\n   is responsible for forwarding datagrams\
    \ onto that virtual network\n   through its connecting virtual interface.  The\
    \ virtual network can\n   also be considered a \"child\" virtual network of the\
    \ router.  Using\n   the child information, routers can do Reverse Path Broadcasting\n\
    \   (RPB).\n   Unnecessary datagrams may still be sent onto some networks, because\n\
    \   there might not be any recipients for those datagrams on the\n   networks.\
    \  There are two kinds of recipients: hosts that are members\n   of a particular\
    \ multicast group, and multicast routers.  If no\n   multicast routers on a virtual\
    \ network consider that virtual network\n   uptree to a given source, then that\
    \ virtual network is a \"leaf\"\n   network.  If a network is a leaf for a given\
    \ source, and there are no\n   members of a particular group on the network, then\
    \ there are no\n   recipients for datagrams from the source to the group on that\n\
    \   network.  That network's parent router can forgo sending those\n   datagrams\
    \ on that network, or \"truncate\" the shortest path tree.  The\n   algorithm\
    \ that tracks and uses this information is the Truncated\n   Reverse Path Broadcasting\
    \ (TRPB) algorithm.\n   Determining which virtual networks are leaves is not simple.\
    \  If any\n   neighboring router considers a given virtual network in the path\
    \ to a\n   given destination, then the virtual network is not a leaf.\n   Otherwise,\
    \ it is a leaf.  This is a voting function.  If a route,\n   with a metric poisoned\
    \ by split horizon processing, is sent by some\n   router, then that router uses\
    \ that virtual network as the uptree path\n   for that route (i.e.  that router\
    \ votes that the virtual network is\n   not a leaf relative to the route's destination).\
    \  Since the number of\n   routers on a virtual network is dynamic, and since\
    \ all received\n   routing updates are not kept by routers, a heuristic is needed\
    \ to\n   determine when a network is a leaf.  DVMRP samples the routing\n   updates\
    \ on a virtual interface while a hold down timer is running,\n   which is for\
    \ a time period of LEAF_TIMEOUT seconds.  There is one\n   hold down timer per\
    \ virtual interface.  If a route is received with a\n   metric poisoned by split\
    \ horizon processing while the hold down timer\n   is running, or at any other\
    \ time, then the appropriate virtual\n   interface for that route is \"spoiled\"\
    -- it is not a leaf.  For every\n   route, any virtual interface that was not\
    \ spoiled by the time the\n   hold down timer expires is considered a leaf.\n\
    \   For a description of an even better forwarding algorithm, the Reverse\n  \
    \ Path Multicasting algorithm, see [3].\n   A route entry should have the following\
    \ in it:\n           - Destination address (a source of multicast datagrams) *\n\
    \           - Subnet mask of the destination address                *\n      \
    \     - Next-hop router to the destination address\n           - Virtual interface\
    \ to the next-hop router              *\n           - List of child virtual interfaces\
    \                      *\n           - List of leaf virtual interfaces       \
    \                *\n           - A dominant router address for each virtual interface\n\
    \           - A subordinate router address for each virtual interface\n      \
    \     - Timer\n           - Set of flags that indicate the state of the entry\n\
    \           - Metric\n           - Infinity\n   The lines that are marked with\
    \ '*' indicate fields that are directly\n   used by the forwarding algorithm.\n\
    \   The lists of child and leaf interfaces can be implemented as bitmaps.\n"
- title: 5.1 Sending Routing Messages
  contents:
  - "5.1 Sending Routing Messages\n   DVMRP routing messages can be used for three\
    \ basic purposes: to\n   periodically supply all routing information, to gratuitously\
    \ supply\n   routing information for recently changed routes, or supply some or\n\
    \   all routes in response to a request.\n   Routing messages sent to physical\
    \ interfaces should have an IP TTL of\n   1.\n   A number of timeouts and rates\
    \ are used by the routing and forwarding\n   algorithms.  See section 6 for their\
    \ values.\n   Rules for when to send routing messages:\n      - Every FULL_UPDATE_RATE\
    \ seconds a router should send out\n        DVMRP messages with all of its routing\
    \ information to all of its\n        virtual interfaces.  To prevent routers from\
    \ synchronizing when\n        they send updates, a real-time timer must be used.\n\
    \      - Whenever a route is changed, a routing update should be sent\n      \
    \  for that route.  Some delay must occur between triggered\n        updates to\
    \ avoid flooding the network with triggered updates;\n        intervals of TRIGGERED_UPDATE_RATE\
    \ seconds is suggested.\n      - A request for all routes should be sent on all\
    \ virtual\n        interfaces when an DVMRP router is restarted.\n      - If possible,\
    \ when a DVMRP router is about to terminate\n        execution, it should send\
    \ out DVMRP messages with metrics\n        equal to infinity for all of its routes,\
    \ on all virtual\n        interfaces.\n   When sending to routers connected via\
    \ networks that support\n   multicasting, the messages should be multicast to\
    \ address 224.0.0.4.\n   Therefore, routers must listen to multicast address 224.0.0.4\
    \ on\n   every physical interface that supports multicasting.  If multicasting\n\
    \   isn't supported, broadcasting can be used.  As already mentioned,\n   routing\
    \ updates to tunnels should be sent as unicast datagrams to the\n   remote end-point\
    \ of the tunnel.\n   When sending routing messages, except in response to a specific\
    \ route\n   request (via RDA command with a non-zero count), poisoned split\n\
    \   horizon processing must be done.  This means that given a route that\n   uses\
    \ network X, routing updates sent to network X must include that\n   route with\
    \ the metric equal to the infinity and should include the\n   appropriate flag\
    \ set in a FLAGS0 command.\n   Poisoned split horizon is one way to reduce the\
    \ likelihood of routing\n   loops.  Another method, not available in RIP, is to\
    \ choose a better\n   infinity in a route.  For routes propagated in a small,\
    \ but well\n   connected, network an infinity smaller than 16 might be better.\
    \  The\n   smaller the infinity, the less time a counting-to-infinity event will\n\
    \   take.  In traversing a wide internet, an infinity of 16 might be too\n   small.\
    \  At the cost of a longer counting-to-infinity event, the\n   infinity can be\
    \ increased.\n   One concept in Internet Multicasting is to use \"thresholds\"\
    \ to\n   restrict which multicast datagrams exit a network.  Multicast routers\n\
    \   on the edge of a subnetted network or autonomous system may require a\n  \
    \ datagram to have large TTL to exit a network.  This mechanism keeps\n   most\
    \ multicast datagrams within the network, reducing external\n   traffic.  An application\
    \ that wants to multicast outside of its\n   network would need to give its multicast\
    \ datagrams at least a TTL of\n   the sum of the threshold and the distance to\
    \ the edge of the network\n   (assuming TTL is used as a hop count within the\
    \ network).  A\n   configuration option should allow specifying the threshold\
    \ for both\n   physical interfaces and tunnels.\n   When a router is started,\
    \ it must send out a request for all routes\n   on each of its virtual interfaces.\
    \  The request is a message that has\n   an RDA command with a count equal to\
    \ 0 in it.\n"
- title: 5.2 Receiving Routing Messages
  contents:
  - "5.2 Receiving Routing Messages\n   A router must know the virtual interface that\
    \ a routing message\n   arrived on.  Because the routing message may be addressed\
    \ to the\n   all-multicast-routers IP address, and because of tunnels, the\n \
    \  incoming interface can not be identified merely by examining the\n   message's\
    \ IP destination address\n   For each route expressed in a routing message, the\
    \ following must\n   occur:\n   IF a metric was given for the route:\n   THEN\
    \    add in the metric of the virtual interface that the message\n           arrived\
    \ on.\n   Lookup the route's destination address in the routing tables.\n   IF\
    \ the route doesn't exist in the tables:\n   THEN    try to find a route to the\
    \ same network in the routing\n           tables.\n           IF that route exists\
    \ in the tables:\n           THEN    IF this route came from the same router as\
    \ the router\n                   that the found route came from:\n           \
    \        THEN    CONTINUE with next route.\n           IF route doesn't have a\
    \ metric of infinity:\n                   THEN    add the route to the routing\
    \ tables.\n           CONTINUE with next route.\n   IF this route came from the\
    \ same router as the router that the found\n      route came from:\n   THEN  \
    \  clear the route timer.\n           IF a metric was received, and it is different\
    \ than the found\n           route's metric:\n           THEN    change the found\
    \ route to use the new metric and\n                   infinity.\n            \
    \       IF the metric is equal to the infinity:\n                   THEN    set\
    \ the route timer to the\n                           EXPIRATION_TIMEOUT.\n   \
    \                CONTINUE with next route.\n           IF the received infinity\
    \ does not equal the found route's\n           infinity:\n           THEN    change\
    \ the found route's infinity to be the received\n                   infinity.\n\
    \                   change the found route's metric to be the minimum of\n   \
    \                the received infinity and the found route's metric.\n   ELSE\
    \    IF a metric was received, and (it is less than the found\n           route's\
    \ metric or (the route timer is at least halfway to the\n           EXPIRATION_TIMEOUT\
    \ and the found route's metric equals the\n           received metric, and the\
    \ metric is less than the received\n           infinity)):\n           THEN  \
    \  change the routing tables to use the received route.\n                   clear\
    \ the route timer.\n   CONTINUE with next route.\n"
- title: 5.3 Neighbors
  contents:
  - "5.3 Neighbors\n   A list should be kept of the neighboring multicast routers\
    \ on every\n   attached network.  The information can be derived by the DVMRP\n\
    \   routing messages that are received.  A neighbor that has not been\n   heard\
    \ from in NEIGHBOR_TIMEOUT seconds should be considered to be\n   down.\n"
- title: 5.4 Local Group Memberships
  contents:
  - "5.4 Local Group Memberships\n   As required by [2], a multicast router must keep\
    \ track of group\n   memberships on the multicast-capable networks attached to\
    \ it.  Every\n   QUERY_RATE seconds an IGMP membership request should be sent\
    \ to the\n   All Hosts multicast address (224.0.0.1) on each network by a\n  \
    \ designated router on that network.  The IGMP membership request will\n   cause\
    \ hosts to respond with IGMP membership reports after a small\n   delay.  Hosts\
    \ will send the report for a group to the group's\n   multicast address.\n   The\
    \ membership requests should have an IP TTL of 1.\n   The routers on a network\
    \ elect or \"designate\" a single router to do\n   the queries.  The designated\
    \ router is the router with the lowest IP\n   address on that network.  Upon startup\
    \ a router considers itself to\n   be the designated router until it learns (presumably\
    \ through routing\n   messages) of a router with a lower address.  To learn about\
    \ the group\n   members present on a network at startup, a router should multicast\
    \ a\n   number of membership requests, separated by a small delay.  We\n   suggest\
    \ sending three requests separated by four seconds.\n   The multicast router must\
    \ receive all datagrams sent to all multicast\n   addresses.  Upon receiving an\
    \ IGMP membership report for a group from\n   an interface, it must either record\
    \ the existence of that group on\n   the interface and record the time, or update\
    \ the time if the group is\n   already recorded.  The recorded group memberships\
    \ must be timed-out.\n   If a group member report is not received for a recorded\
    \ group after\n   MEMBERSHIP_TIMEOUT seconds, the recorded group should be deleted.\n"
- title: 6. Forwarding Algorithm
  contents:
  - "6. Forwarding Algorithm\n   The section describes the multicast forwarding algorithm\
    \ and the\n   state that must be kept for the algorithm.\n   The forwarding algorithm\
    \ is applied to determine how multicast\n   datagrams arriving on a physical interface\
    \ or a tunnel should be\n   handled.  If multicast datagrams were flooded, a datagram\
    \ received on\n   one virtual interface would be forwarded out of every other\
    \ virtual\n   interface.  Because of redundant paths in the internet, datagrams\n\
    \   would be duplicated.  The child and leaf information, that the\n   routing\
    \ algorithm supplies, is used to prune branches in the tree to\n   all possible\
    \ destinations.\n   In route entries, there is a dominant router address for each\
    \ virtual\n   interface.  This address is the address of some router that has\
    \ a\n   route with a lower metric (and whose metric does not equal infinity)\n\
    \   to the destination, on that virtual interface.  The dominant router\n   address\
    \ is not set for the next-hop virtual interface.\n   Also in route entries, there\
    \ is a subordinate router address for each\n   virtual interface.  This address\
    \ is the address of some router that\n   considers this router to be the parent\
    \ of the virtual network.\n   Therefore, the subordinate router address is not\
    \ set for a virtual\n   interface to a leaf network.\n   The algorithm for manipulating\
    \ the children and leaf lists in route\n   entries is:\n   Upon router startup:\n\
    \           Create a route entry for each virtual interface, with:\n         \
    \      - all other virtual interfaces in its child list,\n               - an\
    \ empty leaf list,\n               - no dominant router addresses, and\n     \
    \          - no subordinate router addresses.\n           Start a hold down timer\
    \ for each virtual interface, with\n           a value of LEAF_TIMEOUT.\n   Upon\
    \ receiving a new route:\n           Create the route entry, with:\n         \
    \      - all virtual interfaces, other than the one on which the\n           \
    \      new route was received, in its child list,\n               - empty leaf\
    \ list,\n               - no dominant router addresses, and\n               -\
    \ no subordinate router addresses.\n           Start the hold down timer for all\
    \ virtual interfaces, other\n           than the one on which the new route was\
    \ received, with a\n           value of LEAF_TIMEOUT.\n   Upon receiving a route\
    \ on virtual interface V from neighbor N with a\n   lower metric than the one\
    \ in the routing table (or the same metric as\n   the one in the routing table,\
    \ if N's address is less than my address\n   for V), for that route:\n     If\
    \ V is in the child list, delete V from the child list.\n     If there is no dominant\
    \ router for V and if V is not (now) the\n     next-hop virtual interface, record\
    \ N as the dominant router.\n   Upon receiving a route on virtual interface V\
    \ from neighbor N with a\n   larger metric than the one in the routing table (or\
    \ the same metric\n   as the one in the routing table, if N's address is greater\
    \ than my\n   address for V), for that route:\n     If N is the dominant router\
    \ for V, delete N as the dominant router\n     and add V to the child list.\n\
    \   Upon receiving a route from neighbor N on virtual interface V with a\n   metric\
    \ equal to infinity (the split horizon flag should also be set),\n   for that\
    \ route:\n     If V is in the leaf list, delete V from the leaf list.\n     If\
    \ there is no subordinate router for V, record N as the\n     subordinate router.\n\
    \   Upon receiving a route from neighbor N on virtual interface V with a\n   metric\
    \ other than infinity (and no split horizon flag), for that\n   route:\n     If\
    \ N is the subordinate router for V, delete N as the subordinate\n     router\
    \ and start the hold down timer for V.\n   Upon timer expiration for a virtual\
    \ interface (V), for each route:\n     If there is no subordinate router for V,\
    \ add V to the leaf list.\n   Upon failure of neighbor N on virtual interface\
    \ V, for each route:\n     If N is the dominant router for V, delete N as the\
    \ dominant router\n     and add V to the child list.\n     If N is the subordinate\
    \ router for V, delete N as the subordinate\n     router and start the hold down\
    \ timer for V.\n   The forwarding algorithm is:\n   IF the IP TTL is less than\
    \ 2:\n   THEN    CONTINUE with next datagram.\n   find the route to the source\
    \ of the IP datagram.\n   IF no route exists:\n   THEN    CONTINUE with next datagram.\n\
    \   IF the datagram was not received on the next-hop virtual interface\n   for\
    \ the route:\n   THEN    CONTINUE with next datagram.\n   IF the datagram is tunneled:\n\
    \   THEN    replace the datagram's source address with the first address\n   \
    \        in the IP loose source route.\n           replace the datagram's destination\
    \ address with the second\n           address in the IP loose source route.\n\
    \           delete the loose source route and the null option from the\n     \
    \      datagram and adjust the IP header length fields to reflect\n          \
    \ the deletion.\n   If the datagram destination is group 224.0.0.0 or group 224.0.0.1:\n\
    \   THEN    CONTINUE with next datagram.\n   FOR each virtual interface V\n  \
    \ DO      IF V is in the child list for the source of the datagram:\n        \
    \   THEN    IF V is not in the leaf list for the source\n                   OR\
    \ there are members of the destination group on V:\n                   THEN  \
    \  IF the IP TTL is greater then V's threshold:\n                           THEN\
    \    subtract 1 from the IP TTL\n                                   forward the\
    \ datagram out V\n"
- title: 7. Time Values
  contents:
  - "7. Time Values\n   This section contains a list of the various rates and timeouts,\
    \ their\n   meanings, and their values.  All values are in seconds.\n   How dynamic\
    \ the routing environment is effects the following rates.\n   A lower rate will\
    \ allow quicker adaptation to a change in the\n   environment, at the cost of\
    \ wasting network bandwidth.\n   FULL_UPDATE_RATE = 60\n           - How often\
    \ routing messages containing complete routing\n             tables are sent.\n\
    \   TRIGGERED_UPDATE_RATE = 5\n           - How often triggered routing messages\
    \ may be sent out.\n   Raising the following rates and timeouts may increase the\
    \ time that\n   packets may be forwarded to a virtual interface unnecessarily.\n\
    \   QUERY_RATE = 120\n           - How often local group membership is queried.\n\
    \   MEMBERSHIP_TIMEOUT = 2 * QUERY_RATE + 20\n           - How long a local group\
    \ membership is valid without\n             confirmation.\n   LEAF_TIMEOUT = 2\
    \ * FULL_UPDATE_RATE + 5\n           - How long the hold down timer is for a virtual\
    \ interface.\n   Increasing the following timeouts will increase the stability\
    \ of the\n   routing algorithm, at the cost of slower reactions to changes in\
    \ the\n   routing environment.\n   NEIGHBOR_TIMEOUT = 4 * FULL_UPDATE_RATE\n \
    \          - How long a neighbor is considered up without confirmation.\n    \
    \         This is important for timing out routes, and for setting\n         \
    \    the children and leaf flags.\n   EXPIRATION_TIMEOUT = 2 * FULL_UPDATE_RATE\n\
    \           - How long a route is considered valid without confirmation.\n   \
    \          When this timeout expires, packets will no longer be\n            \
    \ forwarded on the route, and routing updates will consider\n             this\
    \ route to have a metric of infinity.\n   GARBAGE_TIMEOUT = 4 * FULL_UPDATE_RATE\n\
    \           - How long a route exists without confirmation.  When this\n     \
    \        timeout expires, routing updates will no longer contain any\n       \
    \      information on this route, and the route will be deleted.\n"
- title: 8. Configuration options
  contents:
  - "8. Configuration options\n   A router should be configurabled with the following\
    \ information:\n   - Tunnel descriptions: local end-point, remote end-point, metric,\
    \ and\n     threshold.  If no threshold is provided, the metric should be used\n\
    \     as the default threshold.\n   - For a physical interface: metric, infinity,\
    \ threshold and\n     subnetwork mask.  If no threshold is provided, the metric\
    \ should be\n     used as the default threshold.\n"
- title: 9. Conclusion
  contents:
  - "9. Conclusion\n   This memo has presented DVMRP, an extensible distance-vector-style\n\
    \   routing protocol, and a TRPB routing algorithm.  An implementation of\n  \
    \ the ideas presented in this document has been done, and is being\n   tested.\n\
    \   The added features in DVMRP, as compared to RIP, give it flexibility\n   at\
    \ the cost of more complex processing.  DVMRP still has the\n   disadvantages\
    \ of being a distance-vector algorithm.  Because link-\n   state algorithms maintain\
    \ much of the state information that DVMRP\n   has to maintain in excess of what\
    \ RIP needs, a multicast link-state\n   routing protocol should be developed.\n\
    \   The TRPB algorithm can cause unneeded datagrams to be sent.  The\n   Reverse\
    \ Path Multicasting algorithm (RPM) [3] might be a better\n   algorithm.  The\
    \ NMR and NMR-cancel DVMRP messages are designed to\n   support RPM.  Further\
    \ research is needed on this topic.\n"
- title: 10. Acknowledgements
  contents:
  - "10. Acknowledgements\n   We would like to thank Robb Foster, Alan Dahlbom, Ross\
    \ Callon, and\n   the IETF Host Working Group for their ideas.\n"
- title: 11. Bibliography
  contents:
  - "11. Bibliography\n     [1]  Hedrick, C., \"Routing Information Protocol\", RFC\
    \ 1058, Rutgers\n          University, June 1988.\n     [2]  Deering, S., \"Host\
    \ Extensions for IP Multicasting\", RFC 1054,\n          Stanford University,\
    \ May 1988.\n     [3]  Deering, S., \"Multicast Routing in Internetworks and Extended\n\
    \          LANs\", SIGCOMM Summer 1988 Proceedings, August 1988.\n     [4]  Callon,\
    \ R., \"A Comparison of 'Link State' and 'Distance\n          Vector' Routing\
    \ Algorithms\", DEC, November 1987.\n     [5]  Postel, J., \"Internet Protocol\"\
    , RFC 791, USC/Information\n          Sciences Institute, September 1981.\n  \
    \   [6]  Mills, D., \"Toward an Internet Standard Scheme for\n          Subnetting\"\
    , RFC 940, University of Delaware, April 1985.\n"
