- contents:
  - '              RTP Payload Format for JPEG-compressed Video

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1998).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This memo describes the RTP payload format for JPEG video streams.\n
    \  The packet format is optimized for real-time video streams where\n   codec
    parameters change rarely from frame to frame.\n   This document is a product of
    the Audio-Video Transport working group\n   within the Internet Engineering Task
    Force.  Comments are solicited\n   and should be addressed to the working group's
    mailing list at rem-\n   conf@es.net and/or the author(s).\n"
  title: Abstract
- contents:
  - "Changes from RFC 2035\n   Most of this memo is identical to RFC 2035.  The changes
    made to the\n   protocol are summarized in Appendix D.\n"
  title: Changes from RFC 2035
- contents:
  - "Key Words\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\"
    in this\n   document are to be interpreted as described in RFC 2119 [9].\n"
  title: Key Words
- contents:
  - "1.  Introduction\n   The Joint Photographic Experts Group (JPEG) standard [1,2,3]
    defines\n   a family of compression algorithms for continuous-tone, still images.\n
    \  This still image compression standard can be applied to video by\n   compressing
    each frame of video as an independent still image and\n   transmitting them in
    series.  Video coded in this fashion is often\n   called Motion-JPEG.\n   We first
    give an overview of JPEG and then describe the specific\n   subset of JPEG that
    is supported in RTP and the mechanism by which\n   JPEG frames are carried as
    RTP payloads.\n   The JPEG standard defines four modes of operation: the sequential
    DCT\n   mode, the progressive DCT mode, the lossless mode, and the\n   hierarchical
    mode.  Depending on the mode, the image is represented\n   in one or more passes.
    \ Each pass (called a frame in the JPEG\n   standard) is further broken down into
    one or more scans.  Within each\n   scan, there are one to four components, which
    represent the three\n   components of a color signal (e.g., \"red, green, and
    blue\", or a\n   luminance signal and two chrominance signals).  These components
    can\n   be encoded as separate scans or interleaved into a single scan.\n   Each
    frame and scan is preceded with a header containing optional\n   definitions for
    compression parameters like quantization tables and\n   Huffman coding tables.
    \ The headers and optional parameters are\n   identified with \"markers\" and
    comprise a marker segment; each scan\n   appears as an entropy-coded bit stream
    within two marker segments.\n   Markers are aligned to byte boundaries and (in
    general) cannot appear\n   in the entropy-coded segment, allowing scan boundaries
    to be\n   determined without parsing the bit stream.\n   Compressed data is represented
    in one of three formats: the\n   interchange format, the abbreviated format, or
    the table-\n   specification format.  The interchange format contains definitions\n
    \  for all the tables used by the entropy-coded segments, while the\n   abbreviated
    format might omit some assuming they were defined out-\n   of-band or by a \"previous\"
    image.\n   The JPEG standard does not define the meaning or format of the\n   components
    that comprise the image.  Attributes like the color space\n   and pixel aspect
    ratio must be specified out-of-band with respect to\n   the JPEG bit stream.  The
    JPEG File Interchange Format (JFIF) [4] is\n   a de-facto standard that provides
    this extra information using an\n   application marker segment (APP0).  Note that
    a JFIF file is simply a\n   JPEG interchange format image along with the APP0
    segment.  In the\n   case of video, additional parameters must be defined out-of-band\n
    \  (e.g., frame rate, interlaced vs. non-interlaced, etc.).\n   While the JPEG
    standard provides a rich set of algorithms for\n   flexible compression, cost-effective
    hardware implementations of the\n   full standard have not appeared.  Instead,
    most hardware JPEG video\n   codecs implement only a subset of the sequential
    DCT mode of\n   operation.  Typically, marker segments are interpreted in software\n
    \  (which \"re-programs\" the hardware) and the hardware is presented with\n   a
    single, interleaved entropy-coded scan represented in the YUV color\n   space.\n
    \  The scan contains an ordered sequence of Minimum Coded Units, or\n   MCUs,
    which are the smallest group of image data coded in a JPEG bit\n   stream.  Each
    MCU defines the image data for a small rectangular\n   block of the output image.\n
    \  Restart markers in the JPEG data denote a point where the decoder\n   should
    reset its state.  As defined by JPEG, restart markers are the\n   only type of
    marker that may appear embedded in the entropy-coded\n   segment, and they may
    only appear on an MCU boundary.  A \"restart\n   interval\" is defined to be a
    block of data containing a restart\n   marker followed by some fixed number of
    MCUs.  An exception is made\n   for the first restart interval in each frame,
    which omits the initial\n   restart marker and just begins with the MCU data.
    \ When these markers\n   are used, each frame is composed of some fixed number
    of back-to-back\n   restart intervals.\n"
  title: 1.  Introduction
- contents:
  - "2.  JPEG Over RTP\n   To maximize interoperability among hardware-based codecs,
    we assume\n   the sequential DCT operating mode [1,Annex F] and restrict the set
    of\n   predefined RTP/JPEG \"type codes\" (defined below) to single-scan,\n   interleaved
    images.  While this is more restrictive than even\n   baseline JPEG, many hardware
    implementation fall short of the\n   baseline specification (e.g., most hardware
    cannot decode non-\n   interleaved scans).\n   In practice, most of the table-specification
    data rarely changes from\n   frame to frame within a single video stream.  Therefore
    RTP/JPEG data\n   is represented in abbreviated format, with all of the tables
    omitted\n   from the bit stream where possible.  Each frame begins immediately\n
    \  with the (single) entropy-coded scan.  The information that would\n   otherwise
    be in both the frame and scan headers is represented\n   entirely within the RTP/JPEG
    header (defined below) that lies between\n   the RTP header and the JPEG payload.\n
    \  While parameters like Huffman tables and color space are likely to\n   remain
    fixed for the lifetime of the video stream, other parameters\n   should be allowed
    to vary, notably the quantization tables and image\n   size (e.g., to implement
    rate-adaptive transmission or allow a user\n   to adjust the \"quality level\"
    or resolution manually).  Thus explicit\n   fields in the RTP/JPEG header are
    allocated to represent this\n   information.  Since only a small set of quantization
    tables are\n   typically used, we encode the entire set of quantization tables
    in a\n   small integer field.  Customized quantization tables are accommodated\n
    \  by using a special range of values in this field, and then placing\n   the
    table before the beginning of the JPEG payload.  The image width\n   and height
    are encoded explicitly.\n   Because JPEG frames are typically larger than the
    underlying\n   network's maximum packet size, frames must often be fragmented
    into\n   several packets.  One approach is to allow the network layer below\n
    \  RTP (e.g., IP) to perform the fragmentation.  However, this precludes\n   rate-controlling
    the resulting packet stream or partial delivery in\n   the presence of loss, and
    frames may be larger than the maximum\n   network layer reassembly length (see
    [10] for more information).  To\n   avoid these limitations, RTP/JPEG defines
    a simple fragmentation and\n   reassembly scheme at the RTP level.\n"
  title: 2.  JPEG Over RTP
- contents:
  - "3.  RTP/JPEG Packet Format\n   The RTP timestamp is in units of 90000Hz.  The
    same timestamp MUST\n   appear in each fragment of a given frame.  The RTP marker
    bit MUST be\n   set in the last packet of a frame.\n"
  - contents:
    - "3.1.  JPEG header\n   Each packet contains a special JPEG header which immediately
      follows\n   the RTP header.  The first 8 bytes of this header, called the \"main\n
      \  JPEG header\", are as follows:\n    0                   1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  | Type-specific |              Fragment Offset                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |      Type     |       Q       |     Width     |     Height    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  All fields in this header except for the Fragment Offset field MUST\n   remain
      the same in all packets that correspond to the same JPEG\n   frame.\n   A Restart
      Marker header and/or Quantization Table header may follow\n   this header, depending
      on the values of the Type and Q fields.\n"
    - contents:
      - "3.1.1.  Type-specific: 8 bits\n   Interpretation depends on the value of
        the type field.  If no\n   interpretation is specified, this field MUST be
        zeroed on\n   transmission and ignored on reception.\n"
      title: '3.1.1.  Type-specific: 8 bits'
    - contents:
      - "3.1.2.  Fragment Offset: 24 bits\n   The Fragment Offset is the offset in
        bytes of the current packet in\n   the JPEG frame data. This value is encoded
        in network byte order\n   (most significant byte first). The Fragment Offset
        plus the length of\n   the payload data in the packet MUST NOT exceed 2^24
        bytes.\n"
      title: '3.1.2.  Fragment Offset: 24 bits'
    - contents:
      - "3.1.3.  Type: 8 bits\n   The type field specifies the information that would
        otherwise be\n   present in a JPEG abbreviated table-specification as well
        as the\n   additional JFIF-style parameters not defined by JPEG.  Types 0-63
        are\n   reserved as fixed, well-known mappings to be defined by this document\n
        \  and future revisions of this document.  Types 64-127 are the same as\n
        \  types 0-63, except that restart markers are present in the JPEG data\n
        \  and a Restart Marker header appears immediately following the main\n   JPEG
        header.  Types 128-255 are free to be dynamically defined by a\n   session
        setup protocol (which is beyond the scope of this document).\n"
      title: '3.1.3.  Type: 8 bits'
    - contents:
      - "3.1.4.  Q: 8 bits\n   The Q field defines the quantization tables for this
        frame.  Q values\n   0-127 indicate the quantization tables are computed using
        an\n   algorithm determined by the Type field (see below).  Q values 128-255\n
        \  indicate that a Quantization Table header appears after the main JPEG\n
        \  header (and the Restart Marker header, if present) in the first\n   packet
        of the frame (fragment offset 0).  This header can be used to\n   explicitly
        specify the quantization tables in-band.\n"
      title: '3.1.4.  Q: 8 bits'
    - contents:
      - "3.1.5.  Width: 8 bits\n   This field encodes the width of the image in 8-pixel
        multiples (e.g.,\n   a width of 40 denotes an image 320 pixels wide).  The
        maximum width\n   is 2040 pixels.\n"
      title: '3.1.5.  Width: 8 bits'
    - contents:
      - "3.1.6.  Height: 8 bits\n   This field encodes the height of the image in
        8-pixel multiples\n   (e.g., a height of 30 denotes an image 240 pixels tall).
        When\n   encoding interlaced video, this is the height of a video field, since\n
        \  fields are individually JPEG encoded. The maximum height is 2040\n   pixels.\n"
      title: '3.1.6.  Height: 8 bits'
    - contents:
      - "3.1.7.  Restart Marker header\n   This header MUST be present immediately
        after the main JPEG header\n   when using types 64-127.  It provides the additional
        information\n   required to properly decode a data stream containing restart
        markers.\n    0                   1                   2                   3\n
        \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |       Restart Interval        |F|L|       Restart Count       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  The Restart Interval field specifies the number of MCUs that appear\n   between
        restart markers.  It is identical to the 16 bit value that\n   would appear
        in the DRI marker segment of a JFIF header.  This value\n   MUST NOT be zero.\n
        \  If the restart intervals in a frame are not guaranteed to be aligned\n
        \  with packet boundaries, the F (first) and L (last) bits MUST be set\n   to
        1 and the Restart Count MUST be set to 0x3FFF.  This indicates\n   that a
        receiver MUST reassemble the entire frame before decoding it.\n   To support
        partial frame decoding, the frame is broken into \"chunks\"\n   each containing
        an integral number of restart intervals. The Restart\n   Count field contains
        the position of the first restart interval in\n   the current \"chunk\" so
        that receivers know which part of the frame\n   this data corresponds to.
        \ A Restart Interval value SHOULD be chosen\n   to allow a \"chunk\" to completely
        fit within a single packet.  In this\n   case, both the F and L bits of the
        packet are set to 1.  However, if\n   a chunk needs to be spread across multiple
        packets, the F bit will be\n   set to 1 in the first packet of the chunk (and
        only that one) and the\n   L bit will be set to 1 in the last packet of the
        chunk (and only that\n   one).\n"
      title: 3.1.7.  Restart Marker header
    - contents:
      - "3.1.8.  Quantization Table header\n   This header MUST be present after the
        main JPEG header (and after the\n   Restart Marker header, if present) when
        using Q values 128-255.  It\n   provides a way to specify the quantization
        tables associated with\n   this Q value in-band.\n    0                   1
        \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |      MBZ      |   Precision   |             Length            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |                    Quantization Table Data                    |\n   |
        \                             ...                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  The Length field is set to the length in bytes of the quantization\n   table
        data to follow.  The Length field MAY be set to zero to\n   indicate that
        no quantization table data is included in this frame.\n   See section 4.2
        for more information.  If the Length field in a\n   received packet is larger
        than the remaining number of bytes, the\n   packet MUST be discarded.\n   When
        table data is included, the number of tables present depends on\n   the JPEG
        type field.  For example, type 0 uses two tables (one for\n   the luminance
        component and one shared by the chrominance\n   components).  Each table is
        an array of 64 values given in zig-zag\n   order, identical to the format
        used in a JFIF DQT marker segment.\n   For each quantization table present,
        a bit in the Precision field\n   specifies the size of the coefficients in
        that table.  If the bit is\n   zero, the coefficients are 8 bits yielding
        a table length of 64\n   bytes.  If the bit is one, the coefficients are 16
        bits for a table\n   length of 128 bytes.  For 16 bit tables, the coefficients
        are\n   presented in network byte order.  The rightmost bit in the Precision\n
        \  field (bit 15 in the diagram above) corresponds to the first table\n   and
        each additional table uses the next bit to the left.  Bits beyond\n   those
        corresponding to the tables needed by the type in use MUST be\n   ignored.\n
        \  For Q values from 128 to 254, the Q value to quantization table data\n
        \  mapping MUST be static, i.e., the receivers are guaranteed that they\n
        \  only need to read the table data once in order to correctly decode\n   frames
        sent with that Q value.  A Q value of 255 denotes that the\n   quantization
        table mapping is dynamic and can change on every frame.\n   Decoders MUST
        NOT depend on any previous version of the tables, and\n   need to reload these
        tables on every frame.  Packets MUST NOT contain\n   Q = 255 and Length =
        0.\n"
      title: 3.1.8.  Quantization Table header
    - contents:
      - "3.1.9.  JPEG Payload\n   The data following the RTP/JPEG headers is an entropy-coded
        segment\n   consisting of a single scan.  The scan header is not present and
        is\n   inferred from the RTP/JPEG header.  The scan is terminated either\n
        \  implicitly (i.e., the point at which the image is fully parsed), or\n   explicitly
        with an EOI marker.  The scan may be padded to arbitrary\n   length with undefined
        bytes.  (Some existing hardware codecs generate\n   extra lines at the bottom
        of a video frame and removal of these lines\n   would require a Huffman-decoding
        pass over the data.)\n   The type code determines whether restart markers
        are present.  If a\n   type supports restart markers, the packet MUST contain
        a non-zero\n   Restart Interval value in a Restart Marker Header and restart
        markers\n   MUST appear on byte aligned boundaries beginning with an 0xFF
        between\n   MCUs at that interval.  Additional 0xFF bytes MAY appear between\n
        \  restart intervals.  This can be used in the packetization process to\n
        \  align data to something like a word boundary for more efficient\n   copying.
        \ Restart markers MUST NOT appear anywhere else in the JPEG\n   payload.  Types
        which do not support restart makers MUST NOT contain\n   restart markers anywhere
        in the JPEG payload. All packets MUST\n   contain a \"stuffed\" 0x00 byte
        following any true 0xFF byte generated\n   by the entropy coder [1, Sec.  B.1.1.5].\n"
      title: 3.1.9.  JPEG Payload
    title: 3.1.  JPEG header
  title: 3.  RTP/JPEG Packet Format
- contents:
  - '4.  Discussion

    '
  - contents:
    - "4.1.  The Type Field\n   The Type field defines the abbreviated table-specification
      and\n   additional JFIF-style parameters not defined by JPEG, since they are\n
      \  not present in the body of the transmitted JPEG data.\n   Three ranges of
      the type field are currently defined. Types 0-63 are\n   reserved as fixed,
      well-known mappings to be defined by this document\n   and future revisions
      of this document. Types 64-127 are the same as\n   types 0-63, except that restart
      markers are present in the JPEG data\n   and a Restart Marker header appears
      immediately following the main\n   JPEG header. Types 128-255 are free to be
      dynamically defined by a\n   session setup protocol (which is beyond the scope
      of this document).\n   Of the first group of fixed mappings, types 0 and 1 are
      currently\n   defined, along with the corresponding types 64 and 65 that indicate\n
      \  the presence of restart markers.  They correspond to an abbreviated\n   table-specification
      indicating the \"Baseline DCT sequential\" mode,\n   8-bit samples, square pixels,
      three components in the YUV color\n   space, standard Huffman tables as defined
      in [1, Annex K.3], and a\n   single interleaved scan with a scan component selector
      indicating\n   components 1, 2, and 3 in that order.  The Y, U, and V color
      planes\n   correspond to component numbers 1, 2, and 3, respectively.  Component\n
      \  1 (i.e., the luminance plane) uses Huffman table number 0 and\n   quantization
      table number 0 (defined below) and components 2 and 3\n   (i.e., the chrominance
      planes) use Huffman table number 1 and\n   quantization table number 1 (defined
      below).\n   Type numbers 2-5 are reserved and SHOULD NOT be used.  Applications\n
      \  based on previous versions of this document (RFC 2035) should be\n   updated
      to indicate the presence of restart markers with type 64 or\n   65 and the Restart
      Marker header.\n   The two RTP/JPEG types currently defined are described below:\n
      \                           horizontal   vertical   Quantization\n           types
      \ component samp. fact. samp. fact. table number\n         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \        |       |  1 (Y)  |     2     |     1     |     0     |\n         |
      0, 64 |  2 (U)  |     1     |     1     |     1     |\n         |       |  3
      (V)  |     1     |     1     |     1     |\n         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \        |       |  1 (Y)  |     2     |     2     |     0     |\n         |
      1, 65 |  2 (U)  |     1     |     1     |     1     |\n         |       |  3
      (V)  |     1     |     1     |     1     |\n         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  These sampling factors indicate that the chrominance components of\n   type
      0 video is downsampled horizontally by 2 (often called 4:2:2)\n   while the
      chrominance components of type 1 video are downsampled both\n   horizontally
      and vertically by 2 (often called 4:2:0).\n   Types 0 and 1 can be used to carry
      both progressively scanned and\n   interlaced image data.  This is encoded using
      the Type-specific field\n   in the main JPEG header.  The following values are
      defined:\n      0 : Image is progressively scanned.  On a computer monitor,
      it can\n          be displayed as-is at the specified width and height.\n      1
      : Image is an odd field of an interlaced video signal.  The\n          height
      specified in the main JPEG header is half of the height\n          of the entire
      displayed image.  This field should be de-\n          interlaced with the even
      field following it such that lines\n          from each of the images alternate.
      \ Corresponding lines from\n          the even field should appear just above
      those same lines from\n          the odd field.\n      2 : Image is an even
      field of an interlaced video signal.\n      3 : Image is a single field from
      an interlaced video signal, but\n          it should be displayed full frame
      as if it were received as\n          both the odd & even fields of the frame.
      \ On a computer\n          monitor, each line in the image should be displayed
      twice,\n          doubling the height of the image.\n   Appendix B contains
      C source code for transforming the RTP/JPEG\n   header parameters into the JPEG
      frame and scan headers that are\n   absent from the data payload.\n"
    title: 4.1.  The Type Field
  - contents:
    - "4.2.  The Q Field\n   For JPEG types 0 and 1 (and their corresponding types
      64 and 65), Q\n   values between 1 and 99 inclusive are defined as follows.
      \ Other\n   values less than 128 are reserved.  Additional types are encouraged\n
      \  to use this definition if applicable.\n   Both type 0 and type 1 JPEG require
      two quantization tables.  These\n   tables are calculated as follows.  For 1
      <= Q <= 99, the Independent\n   JPEG Group's formula [5] is used to produce
      a scale factor S as:\n           S = 5000 / Q          for  1 <= Q <= 50\n             =
      200 - 2 * Q       for 51 <= Q <= 99\n   This value is then used to scale Tables
      K.1 and K.2 from [1]\n   (saturating each value to 8 bits) to give quantization
      table numbers\n   0 and 1, respectively.  C source code is provided in Appendix
      A to\n   compute these tables.\n   For Q values 128-255, dynamically defined
      quantization tables are\n   used.  These tables may be specified either in-band
      or out of band by\n   something like a session setup protocol, but the Quantization
      Table\n   header MUST be present in the first packet of every frame. When the\n
      \  tables are specified out of band, they may be omitted from the packet\n   by
      setting the Length field in this header to 0.\n   When the quantization tables
      are sent in-band, they need not be sent\n   with every frame.  Like the out
      of band case, frames which do not\n   contain tables will have a Quantization
      Table header with a Length\n   field of 0.  While this does decrease the overhead
      of including the\n   tables, new receivers will be unable to properly decode
      frames from\n   the time they start up until they receive the tables.\n"
    title: 4.2.  The Q Field
  - contents:
    - "4.3.  Fragmentation and Reassembly\n   Since JPEG frames can be large, they
      must often be fragmented.\n   Frames SHOULD be fragmented into packets in a
      manner avoiding\n   fragmentation at a lower level.  If support for partial
      frame\n   decoding is desired, frames SHOULD be fragmented such that each\n
      \  packet contains an integral number of restart intervals (see below).\n   Each
      packet that makes up a single frame MUST have the same\n   timestamp, and the
      RTP marker bit MUST be set on the last packet in a\n   frame.  The fragment
      offset field of each packet is set to the byte\n   offset of its payload data
      within the original frame.  Packets making\n   up a frame SHOULD be sent sequentially
      and the fragments they contain\n   MUST NOT overlap one another.\n   An entire
      frame can be identified as a sequence of packets beginning\n   with a packet
      having a zero fragment offset and ending with a packet\n   having the RTP marker
      bit set.  Missing packets can be detected\n   either with RTP sequence numbers
      or with the fragment offset and\n   lengths of each packet.  Reassembly could
      be carried out without the\n   offset field (i.e., using only the RTP marker
      bit and sequence\n   numbers), but an efficient single-copy implementation would
      not\n   otherwise be possible in the presence of misordered packets.\n   Moreover,
      if the last packet of the previous frame (containing the\n   marker bit) were
      dropped, then a receiver could not always detect\n   that the current frame
      is entirely intact.\n"
    title: 4.3.  Fragmentation and Reassembly
  - contents:
    - "4.4.  Restart Markers\n   Restart markers indicate a point in the JPEG stream
      at which the\n   Huffman decoder and DC predictors are reset, allowing partial\n
      \  decoding starting at that point.  To fully take advantage of this,\n   however,
      a decoder must know which MCUs of a frame a particular\n   restart interval
      encodes.  While the original JPEG specification does\n   provide a small sequence
      number field in the restart markers for this\n   purpose, it is not large enough
      to properly cope with the loss of an\n   entire packet's worth of data at a
      typical network MTU size.  The\n   RTP/JPEG Restart Marker header contains the
      additional information\n   needed to accomplish this.\n   The size of restart
      intervals SHOULD be chosen to always allow an\n   integral number of restart
      intervals to fit within a single packet.\n   This will guarantee that packets
      can be decoded independently from\n   one another.  If a restart interval ends
      up being larger than a\n   packet, the F and L bits in the Restart Marker header
      can be used to\n   fragment it, but the resulting set of packets must all be
      received by\n   a decoder for that restart interval to be decoded properly.\n
      \  Once a decoder has received either a single packet with both the F\n   and
      L bits set on or a contiguous sequence of packets (based on the\n   RTP sequence
      number) which begin with an F bit and end with an L bit,\n   it can begin decoding.
      \ The position of the MCU at the beginning of\n   the data can be determined
      by multiplying the Restart Count value by\n   the Restart Interval value.  A
      packet (or group of packets as\n   identified by the F and L bits) may contain
      any number of consecutive\n   restart intervals.\n   To accommodate encoders
      which generate frames with restart markers in\n   them but cannot fragment the
      data in this manner, the Restart Count\n   field may be set to 0x3FFF with the
      F and L bits both set to 1.  This\n   indicates to decoders that the entire
      frame must be reassembled\n   before decoding it.\n"
    title: 4.4.  Restart Markers
  title: 4.  Discussion
- contents:
  - "5.  Security Considerations\n   RTP packets using the payload format defined
    in this specification\n   are subject to the security considerations discussed
    in the RTP\n   specification [6], and any appropriate RTP profile (for example
    [7]).\n   This implies that confidentiality of the media streams is achieved by\n
    \  encryption. Because the data compression used with this payload\n   format
    is applied end-to-end, encryption may be performed after\n   compression so there
    is no conflict between the two operations.\n   A potential denial-of-service threat
    exists for data encodings using\n   compression techniques that have non-uniform
    receiver-end\n   computational load.  The attacker can inject pathological datagrams\n
    \  into the stream which are complex to decode and cause the receiver to\n   be
    overloaded.  However, this encoding does not exhibit any\n   significant non-uniformity.\n
    \  Another potential denial-of-service threat exists around the\n   fragmentation
    mechanism presented here.  Receivers should be prepared\n   to limit the total
    amount of data associated with assembling received\n   frames so as to avoid resource
    exhaustion.\n   As with any IP-based protocol, in some circumstances a receiver
    may\n   be overloaded simply by the receipt of too many packets, either\n   desired
    or undesired.  Network-layer authentication may be used to\n   discard packets
    from undesired sources, but the processing cost of\n   the authentication itself
    may be too high.  In a multicast\n   environment, pruning of specific sources
    will be implemented in a\n   future version of IGMP [8] and in multicast routing
    protocols to\n   allow a receiver to select which sources are allowed to reach
    it.\n   A security review of this payload format found no additional\n   considerations
    beyond those in the RTP specification.\n"
  title: 5.  Security Considerations
- contents:
  - "6.  Authors' Addresses\n   Lance M. Berc\n   Systems Research Center\n   Digital
    Equipment Corporation\n   130 Lytton Ave\n   Palo Alto CA 94301\n   Phone: +1
    650 853 2100\n   EMail: berc@pa.dec.com\n   William C. Fenner\n   Xerox PARC\n
    \  3333 Coyote Hill Road\n   Palo Alto, CA 94304\n   Phone: +1 650 812 4816\n
    \  EMail: fenner@parc.xerox.com\n   Ron Frederick\n   Xerox PARC\n   3333 Coyote
    Hill Road\n   Palo Alto, CA 94304\n   Phone: +1 650 812 4459\n   EMail: frederick@parc.xerox.com\n
    \  Steven McCanne\n   University of California at Berkeley\n   Electrical Engineering
    and Computer Science\n   633 Soda Hall\n   Berkeley, CA 94720\n   Phone: +1 510
    642 0865\n   EMail: mccanne@cs.berkeley.edu\n   Paul Stewart\n   Xerox PARC\n
    \  3333 Coyote Hill Road\n   Palo Alto, CA 94304\n   Phone: +1 650 812 4821\n
    \  EMail: stewart@parc.xerox.com\n"
  title: 6.  Authors' Addresses
- contents:
  - "7.  References\n   [1]  ISO DIS 10918-1. Digital Compression and Coding of Continuous-\n
    \       tone Still Images (JPEG), CCITT Recommendation T.81.\n   [2]  William
    B. Pennebaker, Joan L. Mitchell, JPEG: Still Image Data\n        Compression Standard,
    Van Nostrand Reinhold, 1993.\n   [3]  Gregory K. Wallace, The JPEG Sill Picture
    Compression Standard,\n        Communications of the ACM, April 1991, Vol 34,
    No. 1, pp. 31-44.\n   [4]  The JPEG File Interchange Format.  Maintained by C-Cube\n
    \       Microsystems, Inc., and available in\n        ftp://ftp.uu.net/graphics/jpeg/jfif.ps.gz.\n
    \  [5]  Tom Lane et. al., The Independent JPEG Group software JPEG\n        codec.
    \ Source code available in\n        ftp://ftp.uu.net/graphics/jpeg/jpegsrc.v6a.tar.gz.\n
    \  [6]  Schulzrinne, H., Casner, S., Frederick, R. and V. Jacobson,\n        \"RTP:
    A Transport Protocol for Real-Time Applications\", RFC\n        1889, January
    1996.\n   [7]  Schulzrinne, H., \"RTP Profile for Audio and Video Conferences\n
    \       with Minimal Control\", RFC 1890, January 1996.\n   [8]  Fenner, W., \"Internet
    Group Management Protocol Version 2\", RFC\n        2236, November 1997.\n   [9]
    \ Bradner, S., \"Key words for use in RFCs to Indicate Requirement\n        Levels\",
    BCP 14, RFC 2119, March 1997.\n   [10] Kent C., and J. Mogul, \"Fragmentation
    Considered Harmful\",\n        Proceedings of the ACM SIGCOMM '87 Workshop on
    Frontiers in\n        Computer Communications Technology, August 1987.\n"
  title: 7.  References
- contents:
  - "Appendix A\n   The following code can be used to create a quantization table
    from a\n   Q factor:\n"
  - "/*\n * Table K.1 from JPEG spec.\n */\n"
  - "static const int jpeg_luma_quantizer[64] = {\n        16, 11, 10, 16, 24, 40,
    51, 61,\n        12, 12, 14, 19, 26, 58, 60, 55,\n        14, 13, 16, 24, 40,
    57, 69, 56,\n        14, 17, 22, 29, 51, 87, 80, 62,\n        18, 22, 37, 56,
    68, 109, 103, 77,\n        24, 35, 55, 64, 81, 104, 113, 92,\n        49, 64,
    78, 87, 103, 121, 120, 101,\n        72, 92, 95, 98, 112, 100, 103, 99\n"
  - '};

    '
  - "/*\n * Table K.2 from JPEG spec.\n */\n"
  - "static const int jpeg_chroma_quantizer[64] = {\n        17, 18, 24, 47, 99, 99,
    99, 99,\n        18, 21, 26, 66, 99, 99, 99, 99,\n        24, 26, 56, 99, 99,
    99, 99, 99,\n        47, 66, 99, 99, 99, 99, 99, 99,\n        99, 99, 99, 99,
    99, 99, 99, 99,\n        99, 99, 99, 99, 99, 99, 99, 99,\n        99, 99, 99,
    99, 99, 99, 99, 99,\n        99, 99, 99, 99, 99, 99, 99, 99\n"
  - '};

    '
  - "/*\n * Call MakeTables with the Q factor and two u_char[64] return arrays\n */\n"
  - 'void

    '
  - 'MakeTables(int q, u_char *lqt, u_char *cqt)

    '
  - "{\n  int i;\n  int factor = q;\n  if (q < 1) factor = 1;\n  if (q > 99) factor
    = 99;\n  if (q < 50)\n    q = 5000 / factor;\n  else\n    q = 200 - factor*2;\n
    \ for (i=0; i < 64; i++) {\n    int lq = (jpeg_luma_quantizer[i] * q + 50) / 100;\n
    \   int cq = (jpeg_chroma_quantizer[i] * q + 50) / 100;\n    /* Limit the quantizers
    to 1 <= q <= 255 */\n    if (lq < 1) lq = 1;\n    else if (lq > 255) lq = 255;\n
    \   lqt[i] = lq;\n    if (cq < 1) cq = 1;\n    else if (cq > 255) cq = 255;\n
    \   cqt[i] = cq;\n  }\n"
  - '}

    '
  title: Appendix A
- contents:
  - "Appendix B\n   The following routines can be used to create the JPEG marker segments\n
    \  corresponding to the table-specification data that is absent from the\n   RTP/JPEG
    body.\n"
  - "u_char lum_dc_codelens[] = {\n        0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
    0, 0, 0,\n"
  - '};

    '
  - "u_char lum_dc_symbols[] = {\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\n"
  - '};

    '
  - "u_char lum_ac_codelens[] = {\n        0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0,
    0, 1, 0x7d,\n"
  - '};

    '
  - "u_char lum_ac_symbols[] = {\n        0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05,
    0x12,\n        0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,\n        0x22,
    0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08,\n        0x23, 0x42, 0xb1, 0xc1, 0x15,
    0x52, 0xd1, 0xf0,\n        0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16,\n        0x17,
    0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28,\n        0x29, 0x2a, 0x34, 0x35, 0x36,
    0x37, 0x38, 0x39,\n        0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,\n        0x4a,
    0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,\n        0x5a, 0x63, 0x64, 0x65, 0x66,
    0x67, 0x68, 0x69,\n        0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,\n        0x7a,
    0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,\n        0x8a, 0x92, 0x93, 0x94, 0x95,
    0x96, 0x97, 0x98,\n        0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n        0xa8,
    0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6,\n        0xb7, 0xb8, 0xb9, 0xba, 0xc2,
    0xc3, 0xc4, 0xc5,\n        0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4,\n        0xd5,
    0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2,\n        0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
    0xe8, 0xe9, 0xea,\n        0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,\n        0xf9,
    0xfa,\n"
  - '};

    '
  - "u_char chm_dc_codelens[] = {\n        0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,
    0, 0, 0,\n"
  - '};

    '
  - "u_char chm_dc_symbols[] = {\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\n"
  - '};

    '
  - "u_char chm_ac_codelens[] = {\n        0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0,
    1, 2, 0x77,\n"
  - '};

    '
  - "u_char chm_ac_symbols[] = {\n        0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05,
    0x21,\n        0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,\n        0x13,
    0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91,\n        0xa1, 0xb1, 0xc1, 0x09, 0x23,
    0x33, 0x52, 0xf0,\n        0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34,\n        0xe1,
    0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26,\n        0x27, 0x28, 0x29, 0x2a, 0x35,
    0x36, 0x37, 0x38,\n        0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,\n        0x49,
    0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,\n        0x59, 0x5a, 0x63, 0x64, 0x65,
    0x66, 0x67, 0x68,\n        0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,\n        0x79,
    0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n        0x88, 0x89, 0x8a, 0x92, 0x93,
    0x94, 0x95, 0x96,\n        0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5,\n        0xa6,
    0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4,\n        0xb5, 0xb6, 0xb7, 0xb8, 0xb9,
    0xba, 0xc2, 0xc3,\n        0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2,\n        0xd3,
    0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda,\n        0xe2, 0xe3, 0xe4, 0xe5, 0xe6,
    0xe7, 0xe8, 0xe9,\n        0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,\n        0xf9,
    0xfa,\n"
  - '};

    '
  - 'u_char *

    '
  - 'MakeQuantHeader(u_char *p, u_char *qt, int tableNo)

    '
  - "{\n        *p++ = 0xff;\n        *p++ = 0xdb;            /* DQT */\n        *p++
    = 0;               /* length msb */\n        *p++ = 67;              /* length
    lsb */\n        *p++ = tableNo;\n        memcpy(p, qt, 64);\n        return (p
    + 64);\n"
  - '}

    '
  - 'u_char *

    '
  - "MakeHuffmanHeader(u_char *p, u_char *codelens, int ncodes,\n                  u_char
    *symbols, int nsymbols, int tableNo,\n                  int tableClass)\n"
  - "{\n        *p++ = 0xff;\n        *p++ = 0xc4;            /* DHT */\n        *p++
    = 0;               /* length msb */\n        *p++ = 3 + ncodes + nsymbols; /*
    length lsb */\n        *p++ = (tableClass << 4) | tableNo;\n        memcpy(p,
    codelens, ncodes);\n        p += ncodes;\n        memcpy(p, symbols, nsymbols);\n
    \       p += nsymbols;\n        return (p);\n"
  - '}

    '
  - 'u_char *

    '
  - "MakeDRIHeader(u_char *p, u_short dri) {\n        *p++ = 0xff;\n        *p++ =
    0xdd;            /* DRI */\n        *p++ = 0x0;             /* length msb */\n
    \       *p++ = 4;               /* length lsb */\n        *p++ = dri >> 8;        /*
    dri msb */\n        *p++ = dri & 0xff;      /* dri lsb */\n        return (p);\n"
  - '}

    '
  - "/*\n *  Arguments:\n *    type, width, height: as supplied in RTP/JPEG header\n
    *    lqt, cqt: quantization tables as either derived from\n *         the Q field
    using MakeTables() or as specified\n *         in section 4.2.\n *    dri: restart
    interval in MCUs, or 0 if no restarts.\n *\n *    p: pointer to return area\n
    *\n *  Return value:\n *    The length of the generated headers.\n *\n *    Generate
    a frame and scan headers that can be prepended to the\n *    RTP/JPEG data payload
    to produce a JPEG compressed image in\n *    interchange format (except for possible
    trailing garbage and\n *    absence of an EOI marker to terminate the scan).\n
    */\n"
  - "int MakeHeaders(u_char *p, int type, int w, int h, u_char *lqt,\n                u_char
    *cqt, u_short dri)\n"
  - "{\n        u_char *start = p;\n        /* convert from blocks to pixels */\n
    \       w <<= 3;\n        h <<= 3;\n        *p++ = 0xff;\n        *p++ = 0xd8;
    \           /* SOI */\n        p = MakeQuantHeader(p, lqt, 0);\n        p = MakeQuantHeader(p,
    cqt, 1);\n        if (dri != 0)\n                p = MakeDRIHeader(p, dri);\n
    \       *p++ = 0xff;\n        *p++ = 0xc0;            /* SOF */\n        *p++
    = 0;               /* length msb */\n        *p++ = 17;              /* length
    lsb */\n        *p++ = 8;               /* 8-bit precision */\n        *p++ =
    h >> 8;          /* height msb */\n        *p++ = h;               /* height lsb
    */\n        *p++ = w >> 8;          /* width msb */\n        *p++ = w;               /*
    wudth lsb */\n        *p++ = 3;               /* number of components */\n        *p++
    = 0;               /* comp 0 */\n        if (type == 0)\n                *p++
    = 0x21;    /* hsamp = 2, vsamp = 1 */\n        else\n                *p++ = 0x22;
    \   /* hsamp = 2, vsamp = 2 */\n        *p++ = 0;               /* quant table
    0 */\n        *p++ = 1;               /* comp 1 */\n        *p++ = 0x11;            /*
    hsamp = 1, vsamp = 1 */\n        *p++ = 1;               /* quant table 1 */\n
    \       *p++ = 2;               /* comp 2 */\n        *p++ = 0x11;            /*
    hsamp = 1, vsamp = 1 */\n        *p++ = 1;               /* quant table 1 */\n
    \       p = MakeHuffmanHeader(p, lum_dc_codelens,\n                              sizeof(lum_dc_codelens),\n
    \                             lum_dc_symbols,\n                              sizeof(lum_dc_symbols),
    0, 0);\n        p = MakeHuffmanHeader(p, lum_ac_codelens,\n                              sizeof(lum_ac_codelens),\n
    \                             lum_ac_symbols,\n                              sizeof(lum_ac_symbols),
    0, 1);\n        p = MakeHuffmanHeader(p, chm_dc_codelens,\n                              sizeof(chm_dc_codelens),\n
    \                             chm_dc_symbols,\n                              sizeof(chm_dc_symbols),
    1, 0);\n        p = MakeHuffmanHeader(p, chm_ac_codelens,\n                              sizeof(chm_ac_codelens),\n
    \                             chm_ac_symbols,\n                              sizeof(chm_ac_symbols),
    1, 1);\n        *p++ = 0xff;\n        *p++ = 0xda;            /* SOS */\n        *p++
    = 0;               /* length msb */\n        *p++ = 12;              /* length
    lsb */\n        *p++ = 3;               /* 3 components */\n        *p++ = 0;
    \              /* comp 0 */\n        *p++ = 0;               /* huffman table
    0 */\n        *p++ = 1;               /* comp 1 */\n        *p++ = 0x11;            /*
    huffman table 1 */\n        *p++ = 2;               /* comp 2 */\n        *p++
    = 0x11;            /* huffman table 1 */\n        *p++ = 0;               /* first
    DCT coeff */\n        *p++ = 63;              /* last DCT coeff */\n        *p++
    = 0;               /* sucessive approx. */\n        return (p - start);\n"
  - '};

    '
  title: Appendix B
- contents:
  - "Appendix C\n   The following routine is used to illustrate the RTP/JPEG packet\n
    \  fragmentation and header creation.\n   For clarity and brevity, the structure
    definitions are only valid for\n   32-bit big-endian (most significant octet first)
    architectures. Bit\n   fields are assumed to be packed tightly in big-endian bit
    order, with\n   no additional padding. Modifications would be required to construct
    a\n   portable implementation.\n"
  - "/*\n * RTP data header from RFC1889\n */\n"
  - "typedef struct {\n        unsigned int version:2;   /* protocol version */\n
    \       unsigned int p:1;         /* padding flag */\n        unsigned int x:1;
    \        /* header extension flag */\n        unsigned int cc:4;        /* CSRC
    count */\n        unsigned int m:1;         /* marker bit */\n        unsigned
    int pt:7;        /* payload type */\n        u_int16 seq;              /* sequence
    number */\n        u_int32 ts;               /* timestamp */\n        u_int32
    ssrc;             /* synchronization source */\n        u_int32 csrc[1];          /*
    optional CSRC list */\n"
  - '} rtp_hdr_t;

    '
  - '#define RTP_HDR_SZ 12

    '
  - '/* The following definition is from RFC1890 */

    '
  - '#define RTP_PT_JPEG             26

    '
  - "struct jpeghdr {\n        unsigned int tspec:8;   /* type-specific field */\n
    \       unsigned int off:24;    /* fragment byte offset */\n        u_int8 type;
    \           /* id of jpeg decoder params */\n        u_int8 q;               /*
    quantization factor (or table id) */\n        u_int8 width;           /* frame
    width in 8 pixel blocks */\n        u_int8 height;          /* frame height in
    8 pixel blocks */\n"
  - '};

    '
  - "struct jpeghdr_rst {\n        u_int16 dri;\n        unsigned int f:1;\n        unsigned
    int l:1;\n        unsigned int count:14;\n"
  - '};

    '
  - "struct jpeghdr_qtable {\n        u_int8  mbz;\n        u_int8  precision;\n        u_int16
    length;\n"
  - '};

    '
  - '#define RTP_JPEG_RESTART           0x40

    '
  - "/* Procedure SendFrame:\n *\n *  Arguments:\n *    start_seq: The sequence number
    for the first packet of the current\n *               frame.\n *    ts: RTP timestamp
    for the current frame\n *    ssrc: RTP SSRC value\n *    jpeg_data: Huffman encoded
    JPEG scan data\n *    len: Length of the JPEG scan data\n *    type: The value
    the RTP/JPEG type field should be set to\n *    typespec: The value the RTP/JPEG
    type-specific field should be set\n *              to\n *    width: The width
    in pixels of the JPEG image\n *    height: The height in pixels of the JPEG image\n
    *    dri: The number of MCUs between restart markers (or 0 if there\n *         are
    no restart markers in the data\n *    q: The Q factor of the data, to be specified
    using the Independent\n *       JPEG group's algorithm if 1 <= q <= 99, specified
    explicitly\n *       with lqt and cqt if q >= 128, or undefined otherwise.\n *
    \   lqt: The quantization table for the luminance channel if q >= 128\n *    cqt:
    The quantization table for the chrominance channels if\n *         q >= 128\n
    *\n *  Return value:\n *    the sequence number to be sent for the first packet
    of the next\n *    frame.\n *\n * The following are assumed to be defined:\n *\n
    * PACKET_SIZE                         - The size of the outgoing packet\n * send_packet(u_int8
    *data, int len)  - Sends the packet to the network\n */\n"
  - "u_int16 SendFrame(u_int16 start_seq, u_int32 ts, u_int32 ssrc,\n                   u_int8
    *jpeg_data, int len, u_int8 type,\n                   u_int8 typespec, int width,
    int height, int dri,\n                   u_int8 q, u_int8 *lqt, u_int8 *cqt) {\n
    \       rtp_hdr_t rtphdr;\n        struct jpeghdr jpghdr;\n        struct jpeghdr_rst
    rsthdr;\n        struct jpeghdr_qtable qtblhdr;\n        u_int8 packet_buf[PACKET_SIZE];\n
    \       u_int8 *ptr;\n        int bytes_left = len;\n        int seq = start_seq;\n
    \       int pkt_len, data_len;\n        /* Initialize RTP header\n         */\n
    \       rtphdr.version = 2;\n        rtphdr.p = 0;\n        rtphdr.x = 0;\n        rtphdr.cc
    = 0;\n        rtphdr.m = 0;\n        rtphdr.pt = RTP_PT_JPEG;\n        rtphdr.seq
    = start_seq;\n        rtphdr.ts = ts;\n        rtphdr.ssrc = ssrc;\n        /*
    Initialize JPEG header\n         */\n        jpghdr.tspec = typespec;\n        jpghdr.off
    = 0;\n        jpghdr.type = type | ((dri != 0) ? RTP_JPEG_RESTART : 0);\n        jpghdr.q
    = q;\n        jpghdr.width = width / 8;\n        jpghdr.height = height / 8;\n
    \       /* Initialize DRI header\n         */\n        if (dri != 0) {\n                rsthdr.dri
    = dri;\n                rsthdr.f = 1;        /* This code does not align RIs */\n
    \               rsthdr.l = 1;\n                rsthdr.count = 0x3fff;\n        }\n
    \       /* Initialize quantization table header\n         */\n        if (q >=
    128) {\n                qtblhdr.mbz = 0;\n                qtblhdr.precision =
    0; /* This code uses 8 bit tables only */\n                qtblhdr.length = 128;
    \ /* 2 64-byte tables */\n        }\n        while (bytes_left > 0) {\n                ptr
    = packet_buf + RTP_HDR_SZ;\n                memcpy(ptr, &jpghdr, sizeof(jpghdr));\n
    \               ptr += sizeof(jpghdr);\n                if (dri != 0) {\n                        memcpy(ptr,
    &rsthdr, sizeof(rsthdr));\n                        ptr += sizeof(rsthdr);\n                }\n
    \               if (q >= 128 && jpghdr.off == 0) {\n                        memcpy(ptr,
    &qtblhdr, sizeof(qtblhdr));\n                        ptr += sizeof(qtblhdr);\n
    \                       memcpy(ptr, lqt, 64);\n                        ptr +=
    64;\n                        memcpy(ptr, cqt, 64);\n                        ptr
    += 64;\n                }\n                data_len = PACKET_SIZE - (ptr - packet_buf);\n
    \               if (data_len >= bytes_left) {\n                        data_len
    = bytes_left;\n                        rtphdr.m = 1;\n                }\n                memcpy(packet_buf,
    &rtphdr, RTP_HDR_SZ);\n                memcpy(ptr, jpeg_data + jpghdr.off, data_len);\n
    \               send_packet(packet_buf, (ptr - packet_buf) + data_len);\n                jpghdr.off
    += data_len;\n                bytes_left -= data_len;\n                rtphdr.seq++;\n
    \       }\n        return rtphdr.seq;\n"
  - '}

    '
  title: Appendix C
- contents:
  - "Appendix D\n   This section outlines the changes between this document and its\n
    \  precdecessor, RFC 2035.  The changes to the protocol were made with\n   an
    eye towards causing as few interoperability problems between\n   implementations
    based on the older text and newer implementations,\n   and indeed, many of the
    obsolete conventions can still be\n   unambiguously decoded by a newer implementation.
    \ However, use of the\n   older conventions in newer implementations is strongly
    discouraged.\n    o   Types 0 and 1 have been augmented to allow for the encoding
    of\n        interlaced video images, using 2 bits of the type-specific\n        field.
    \ See section 4.1 for details.\n    o   There has been discussion in the working
    group arguing for more\n        flexibility in specifying the JPEG quantization
    tables.  This\n        memo allows table coefficients to be specified explicitly\n
    \       through the use of an optional Quantization Table header,\n        discussed
    in sections 3.1.8 and 4.2.\n    o   In RFC 2035, the encoding of restart marker
    information in the\n        Type field made it difficult to add new types. Additionally,
    the\n        type- specific field was used for the restart count, making it\n
    \       unavailable for other type-specific purposes.  This memo moves\n        the
    restart marker indication to a particular bit in the Type\n        field, and
    adds an optional header to hold the additional\n        information required,
    leaving the type-specific field free for\n        its intended purpose.  The handling
    of partial frame decoding\n        was also made more robust against packet loss.
    \ See sections\n        3.1.7 and 4.4 for details.\n"
  title: Appendix D
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (1998).  All
    Rights Reserved.\n   This document and translations of it may be copied and furnished
    to\n   others, and derivative works that comment on or otherwise explain it\n
    \  or assist in its implementation may be prepared, copied, published\n   and
    distributed, in whole or in part, without restriction of any\n   kind, provided
    that the above copyright notice and this paragraph are\n   included on all such
    copies and derivative works.  However, this\n   document itself may not be modified
    in any way, such as by removing\n   the copyright notice or references to the
    Internet Society or other\n   Internet organizations, except as needed for the
    purpose of\n   developing Internet standards in which case the procedures for\n
    \  copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: Full Copyright Statement
