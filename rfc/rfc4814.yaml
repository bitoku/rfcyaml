- title: __initial_text__
  contents:
  - '  Hash and Stuffing: Overlooked Factors in Network Device Benchmarking

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The IETF Trust (2007).\n"
- title: Abstract
  contents:
  - "Abstract\n   Test engineers take pains to declare all factors that affect a given\n\
    \   measurement, including intended load, packet length, test duration,\n   and\
    \ traffic orientation.  However, current benchmarking practice\n   overlooks two\
    \ factors that have a profound impact on test results.\n   First, existing methodologies\
    \ do not require the reporting of\n   addresses or other test traffic contents,\
    \ even though these fields\n   can affect test results.  Second, \"stuff\" bits\
    \ and bytes inserted in\n   test traffic by some link-layer technologies add significant\
    \ and\n   variable overhead, which in turn affects test results.  This document\n\
    \   describes the effects of these factors; recommends guidelines for\n   test\
    \ traffic contents; and offers formulas for determining the\n   probability of\
    \ bit- and byte-stuffing in test traffic.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  3\n   2.  Requirements . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  3\n   3.  General Considerations . . . . . . . . . . . . . . . .\
    \ . . . .  4\n     3.1.  Repeatability  . . . . . . . . . . . . . . . . . . .\
    \ . . .  4\n     3.2.  Randomness . . . . . . . . . . . . . . . . . . . . . .\
    \ . .  4\n   4.  Packet Content Variations  . . . . . . . . . . . . . . . . .\
    \ .  5\n     4.1.  Problem Statement  . . . . . . . . . . . . . . . . . . . .\
    \  5\n     4.2.  IEEE 802 MAC Addresses . . . . . . . . . . . . . . . . . .  7\n\
    \       4.2.1.  Randomized Sets of MAC Addresses . . . . . . . . . . .  8\n  \
    \   4.3.  MPLS Addressing  . . . . . . . . . . . . . . . . . . . . .  9\n    \
    \ 4.4.  Network-layer Addressing . . . . . . . . . . . . . . . . .  9\n     4.5.\
    \  Transport-Layer Addressing . . . . . . . . . . . . . . . . 10\n     4.6.  Application-Layer\
    \ Patterns . . . . . . . . . . . . . . . . 10\n   5.  Control Character Stuffing\
    \ . . . . . . . . . . . . . . . . . . 11\n     5.1.  Problem Statement  . . .\
    \ . . . . . . . . . . . . . . . . . 11\n     5.2.  PPP Bit-Stuffing . . . . .\
    \ . . . . . . . . . . . . . . . . 12\n       5.2.1.  Calculating Bit-Stuffing\
    \ Probability . . . . . . . . . 14\n       5.2.2.  Bit-Stuffing for Finite Strings\
    \  . . . . . . . . . . . 15\n       5.2.3.  Applied Bit-Stuffing . . . . . . .\
    \ . . . . . . . . . . 16\n     5.3.  POS Byte-Stuffing  . . . . . . . . . . .\
    \ . . . . . . . . . 16\n       5.3.1.  Nullifying ACCM  . . . . . . . . . . .\
    \ . . . . . . . . 17\n       5.3.2.  Other Stuffed Characters . . . . . . . .\
    \ . . . . . . . 17\n       5.3.3.  Applied Byte-Stuffing  . . . . . . . . . .\
    \ . . . . . . 17\n   6.  Security Considerations  . . . . . . . . . . . . . .\
    \ . . . . . 18\n   7.  Normative References . . . . . . . . . . . . . . . . .\
    \ . . . . 19\n   Appendix A.  Acknowledgements  . . . . . . . . . . . . . . .\
    \ . . . 20\n   Appendix B.  Proof of Formula for Finite Bit-Stuffing  . . . .\
    \ . . 20\n   Appendix C.  Explicit Calculation of Bit-Stuffing Overhead for\n\
    \                IPv4  . . . . . . . . . . . . . . . . . . . . . . . . 21\n  \
    \ Appendix D.  Explicit Calculation of Bit-Stuffing Overhead for\n           \
    \     IPv6  . . . . . . . . . . . . . . . . . . . . . . . . 23\n   Appendix E.\
    \  Terminology . . . . . . . . . . . . . . . . . . . . . 24\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Experience in benchmarking networking devices suggests that\
    \ the\n   contents of test traffic can have a profound impact on test results.\n\
    \   For example, some devices may forward randomly addressed traffic\n   without\
    \ loss, but drop significant numbers of packets when offered\n   packets containing\
    \ nonrandom addresses.\n   Methodologies such as [RFC2544] and [RFC2889] do not\
    \ require any\n   declaration of packet contents.  These methodologies do require\
    \ the\n   declaration of test parameters such as traffic distribution and\n  \
    \ traffic orientation, and yet packet contents can have at least as\n   great\
    \ an impact on test results as the other factors.  Variations in\n   packet contents\
    \ also can lead to non-repeatability of test results:\n   Two individuals may\
    \ follow methodology procedures to the letter, and\n   still obtain very different\
    \ results.\n   A related issue is the insertion of stuff bits or bytes by link-layer\n\
    \   technologies using PPP with High-Level Data Link Control (HDLC)-like\n   framing.\
    \  This stuffing is done to ensure sequences in test traffic\n   will not be confused\
    \ with control characters.\n   Stuffing adds significant and variable overhead.\
    \  Currently there is\n   no standard method for determining the probability that\
    \ stuffing will\n   occur for a given pattern, and thus no way to determine what\
    \ impact\n   stuffing will have on test results.\n   This document covers two\
    \ areas.  First, we discuss strategies for\n   dealing with randomness and nonrandomness\
    \ in test traffic.  Second,\n   we present formulas to determine the probability\
    \ of bit- and byte-\n   stuffing on Point-to-Point Protocol (PPP) and Packet over\
    \ SONET (POS)\n   circuits.  In both areas, we provide recommendations for obtaining\n\
    \   better repeatability in test results.\n   Benchmarking activities as described\
    \ in this memo are limited to\n   technology characterization using controlled\
    \ stimuli in a laboratory\n   environment, using dedicated address space.\n  \
    \ The benchmarking network topology will be an independent test setup\n   and\
    \ MUST NOT be connected to devices that may forward the test\n   traffic into\
    \ a production network, or misroute traffic to the test\n   management network.\n"
- title: 2.  Requirements
  contents:
  - "2.  Requirements\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n"
- title: 3.  General Considerations
  contents:
  - '3.  General Considerations

    '
- title: 3.1.  Repeatability
  contents:
  - "3.1.  Repeatability\n   Repeatability is a desirable trait in benchmarking, but\
    \ it can be an\n   elusive goal.  It is a common but mistaken belief that test\
    \ results\n   can always be recreated provided the device under test and test\n\
    \   instrument are configured identically for each test iteration.  In\n   fact,\
    \ even identical configurations may introduce some variations in\n   test traffic,\
    \ such as changes in timestamps, TCP sequence numbers, or\n   other common phenomena.\n\
    \   While this variability does not necessarily invalidate test results,\n   it\
    \ is important to recognize the existing variation.  Exact bit-for-\n   bit repeatability\
    \ of test traffic is a hard problem.  A simpler\n   approach is to acknowledge\
    \ that some variation exists, characterize\n   that variation, and describe it\
    \ when analyzing test results.\n   Another issue related to repeatability is the\
    \ avoidance of randomness\n   in test traffic.  For example, benchmarking experience\
    \ with some IEEE\n   802.11 devices suggests that nonrandom media access control\
    \ (MAC) and\n   IP addresses must be used across multiple trials.  Although this\n\
    \   would seem to contradict some recommendations made in this document,\n   in\
    \ fact either nonrandom or pseudorandom patterns may be more\n   desirable depending\
    \ on the test setup.  There are also situations\n   where it may be desirable\
    \ to use combinations of the two, for example\n   by generating pseudorandom traffic\
    \ patterns for one test trial and\n   then re-using the same pattern across all\
    \ trials.  The keywords in\n   this document are RECOMMENDs and not MUSTs with\
    \ regard to the use of\n   pseudorandom test traffic patterns.\n   Note also that\
    \ this discussion covers only repeatability, which is\n   concerned with variability\
    \ of test results from trial to trial on the\n   same test bed.  A separate concern\
    \ is reproducibility, which refers\n   to the precision of test results obtained\
    \ from different test beds.\n   Clearly, reproducibility across multiple test\
    \ beds requires\n   repeatability on a single test bed.\n"
- title: 3.2.  Randomness
  contents:
  - "3.2.  Randomness\n   This document recommends the use of pseudorandom patterns\
    \ in test\n   traffic under controlled lab conditions.  The rand() functions\n\
    \   available in many programming languages produce output that is\n   pseudorandom\
    \ rather than truly random.  Pseudorandom patterns are\n   sufficient for the\
    \ recommendations given in this document, provided\n   they produce output that\
    \ is uniformly distributed across the pattern\n   space.\n   Specifically, for\
    \ any random bit pattern of length L, the probability\n   of generating that specific\
    \ pattern SHOULD equal 1 over 2 to the Lth\n   power.\n"
- title: 4.  Packet Content Variations
  contents:
  - '4.  Packet Content Variations

    '
- title: 4.1.  Problem Statement
  contents:
  - "4.1.  Problem Statement\n   The contents of test traffic can have a significant\
    \ impact on metrics\n   such as throughput, jitter, latency, and loss.  For example,\
    \ many\n   network devices feed addresses into a hashing algorithm to determine\n\
    \   upon which path to forward a given packet.\n   Consider the simple case of\
    \ an Ethernet switch with eight network\n   processors (NPs) in its switching\
    \ fabric:\n                               ingress\n                          \
    \        ||\n                                  \\/\n          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \          | ___   ___   ___   ___   ___   ___   ___   ___  |\n          ||  \
    \ | |   | |   | |   | |   | |   | |   | |   | |\n          ||NP0| |NP1| |NP2|\
    \ |NP3| |NP4| |NP5| |NP6| |NP7| |\n          ||___| |___| |___| |___| |___| |___|\
    \ |___| |___| |\n          |                                                |\n\
    \          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n               \
    \                   ||\n                                  \\/\n              \
    \                  egress\n   To assign incoming traffic to the various NPs, suppose\
    \ a hashing\n   algorithm performs an exclusive-or (XOR) operation on the least\n\
    \   significant 3 bits of the source and destination MAC addresses in\n   each\
    \ frame.  (This is an actual example the authors have observed in\n   multiple\
    \ devices from multiple manufacturers.)\n   In theory, a random distribution of\
    \ source and destination MAC\n   addresses should result in traffic being uniformly\
    \ distributed across\n   all eight NPs.  (Instances of the term \"random\" in\
    \ this document\n   refer to a random uniform distribution across a given address\
    \ space.\n   Section 3.2 describes random uniform distributions in more detail.)\n\
    \   In practice, the actual outcome of the hash (and thus any test\n   results)\
    \ will be very different depending on the degree of randomness\n   in test traffic.\n\
    \   Suppose the traffic is nonrandom so that every interface of the test\n   instrument\
    \ uses this pattern in its source MAC addresses:\n      00:00:PP:00:00:01\n  \
    \ where PP is the source interface number of the test instrument.\n   In this\
    \ case, the least significant 3 bits of every source and\n   destination MAC address\
    \ are 001, regardless of interface number.\n   Thus, the outcome of the XOR operation\
    \ will always be 0, given the\n   same three least significant bits:\n      001\
    \ ^ 001 = 000\n   Thus, the switch will assign all traffic to NP0, leaving the\
    \ other\n   seven NPs idle.  Given a heavy enough load, NP0 and the switch will\n\
    \   become congested, even though seven other NPs are available.  At\n   most,\
    \ this device will be able to utilize approximately 12.5 percent\n   of its total\
    \ capacity, with the remaining 87.5 percent of capacity\n   unused.\n   Now consider\
    \ the same example with randomly distributed addresses.\n   In this case, the\
    \ test instrument offers traffic using MAC addresses\n   with this pattern:\n\
    \      00:00:PP:00:00:RR\n   where PP is the source interface number of the test\
    \ instrument and RR\n   is a pseudorandom number.  In this case, there should\
    \ be an equal\n   probability of the least significant 3 bits of the MAC address\
    \ having\n   any value from 000 to 111 inclusive.  Thus, the outcome of XOR\n\
    \   operations should be equally distributed from 0 to 7, and\n   distribution\
    \ across NPs should also be equal (at least for this\n   particular 3-bit hashing\
    \ algorithm).  Absent other impediments, the\n   device should be able to utilize\
    \ 100 percent of available capacity.\n   This simple example presumes knowledge\
    \ on the tester's part of the\n   hashing algorithm used by the device under test.\
    \  Knowledge of such\n   algorithms is not always possible beforehand, and in\
    \ any event\n   violates the \"black box\" spirit of many documents produced by\
    \ the\n   IETF Benchmarking Working Group (BMWG).\n   Therefore, this memo adds\
    \ a new consideration for benchmarking\n   methodologies to select traffic patterns\
    \ that overcome the effects of\n   nonrandomness, regardless of the hashing algorithms\
    \ in use.  The\n   balance of this section offers recommendations for test traffic\n\
    \   patterns to avoid these effects, starting at the link layer and\n   working\
    \ up to the application layer.\n"
- title: 4.2.  IEEE 802 MAC Addresses
  contents:
  - "4.2.  IEEE 802 MAC Addresses\n   Test traffic SHOULD use pseudorandom patterns\
    \ in IEEE 802 MAC\n   addresses.  The following source and destination MAC address\
    \ pattern\n   is RECOMMENDED:\n      (RR & 0xFC):PP:PP:RR:RR:RR\n   where (RR\
    \ & 0xFC) is a pseudorandom number bitwise ANDed with 0xFC,\n   PP:PP is the 1-indexed\
    \ interface number of the test instrument and\n   RR:RR:RR is a pseudorandom number.\n\
    \   The bitwise ANDing of the high-order byte in the MAC address with\n   0xFC\
    \ sets the low-order two bits of that byte to 0, guaranteeing a\n   non-multicast\
    \ address and a non locally administered address.  Note\n   that the resulting\
    \ addresses may violate IEEE 802 standards by using\n   organizationally unique\
    \ identifiers (OUIs) not assigned to the test\n   port manufacturer.  However,\
    \ since these addresses will be used only\n   on isolated test networks there\
    \ should be no possibility of mistaken\n   identity.\n   Test traffic SHOULD use\
    \ PP:PP to identify the source interface number\n   of the test instrument.  Such\
    \ identification can be useful in\n   troubleshooting.  Allocating 2 bytes of\
    \ the MAC address for interface\n   identification allows for tests of up to 65,536\
    \ interfaces.  A 2-byte\n   space allows for tests much larger than those currently\
    \ used in\n   device benchmarking; however, tests involving more than 256\n  \
    \ interfaces (fully utilizing a 1-byte space) are fairly common.\n   Note that\
    \ the \"PP:PP\" designation refers to the source interface of\n   the test instrument,\
    \ not the device under test/system under test\n   (DUT/SUT).  There are situations\
    \ where the DUT/SUT interface number\n   may change during the test; one example\
    \ would be a test of wireless\n   LAN roaming.  By referring to the (presumably\
    \ static) source\n   interface number of the test instrument, test engineers can\
    \ keep\n   track of test traffic regardless of any possible DUT/SUT changes.\n\
    \   Further, source interface numbers SHOULD be 1-indexed and SHOULD NOT\n   be\
    \ zero-indexed.  This avoids the low but nonzero probability of an\n   all-zeros\
    \ MAC address.  Some devices will drop frames with all-zeros\n   MAC addresses.\n\
    \   It is RECOMMENDED to use pseudorandom patterns in the least\n   significant\
    \ 3 bytes of the MAC address.  Using pseudorandom values\n   for the low-order\
    \ 3 bytes means choosing one of 16.7 million unique\n   addresses.  While this\
    \ address space is vastly larger than is\n   currently required in lab benchmarking,\
    \ it does assure more realistic\n   test traffic.\n   Note also that since only\
    \ 30 of 48 bits in the MAC address have\n   pseudorandom values, there is no possibility\
    \ of randomly generating a\n   broadcast or multicast value by accident.\n"
- title: 4.2.1.  Randomized Sets of MAC Addresses
  contents:
  - "4.2.1.  Randomized Sets of MAC Addresses\n   It is common benchmarking practice\
    \ for a test instrument to emulate\n   multiple hosts, even on a single interface.\
    \  This is desirable in\n   assessing DUT/SUT scalability.\n   However, test instruments\
    \ may emulate multiple MAC addresses by\n   incrementing and/or decrementing addresses\
    \ from a fixed starting\n   point.  This leads to situations, as described above\
    \ in \"Address\n   Pattern Variations\", where hashing algorithms produce nonoptimal\n\
    \   outcomes.\n   The outcome can be nonoptimal even if the set of addresses begins\n\
    \   with a pseudorandom number.  For example, the following source/\n   destination\
    \ pairs will not be equally distributed by the 3-bit\n   hashing algorithm discussed\
    \ above:\n   Source                   Destination\n   00:00:01:FC:B3:45      \
    \  00:00:19:38:8C:80\n   00:00:01:FC:B3:46        00:00:19:38:8C:81\n   00:00:01:FC:B3:47\
    \        00:00:19:38:8C:82\n   00:00:01:FC:B3:48        00:00:19:38:8C:83\n  \
    \ 00:00:01:FC:B3:49        00:00:19:38:8C:84\n   00:00:01:FC:B3:4A        00:00:19:38:8C:85\n\
    \   00:00:01:FC:B3:4B        00:00:19:38:8C:86\n   00:00:01:FC:B3:4C        00:00:19:38:8C:87\n\
    \   Again working with our 3-bit XOR hashing algorithm, we get the\n   following\
    \ outcomes:\n   101 ^ 000 = 101\n   110 ^ 001 = 111\n   111 ^ 010 = 101\n   000\
    \ ^ 011 = 011\n   001 ^ 100 = 101\n   010 ^ 101 = 111\n   011 ^ 110 = 101\n  \
    \ 100 ^ 111 = 011\n   Note that only three of eight possible outcomes are achieved\
    \ when\n   incrementing addresses.  This is actually the best case.\n   Incrementing\
    \ from other combinations of pseudorandom address pairs\n   produces only one\
    \ or two out of eight possible outcomes.\n   Every MAC address SHOULD be pseudorandom,\
    \ not just the starting one.\n   When generating traffic with multiple addresses,\
    \ it is RECOMMENDED\n   that all addresses use pseudorandom values.  There are\
    \ multiple ways\n   to use sets of pseudorandom numbers.  One strategy would be\
    \ for the\n   test instrument to iterate over an array of pseudorandom values\n\
    \   rather than incrementing/decrementing from a starting address.  The\n   actual\
    \ method is an implementation detail; in the end, any method\n   that uses multiple\
    \ addresses with pseudorandom patterns will be\n   sufficient.\n   Experience\
    \ with benchmarking of IEEE 802.11 devices suggests\n   suboptimal test outcomes\
    \ may result if different pseudorandom MAC and\n   IP addresses are used from\
    \ trial to trial.  In such cases (not just\n   for 802.11 but for any device using\
    \ IEEE 802 MAC and IP addresses),\n   testers MAY generate a pseudorandom set\
    \ of MAC and IP addresses once,\n   or MAY generate a nonrandom set of MAC and\
    \ IP addresses once.  In\n   either case, the same MAC and IP addresses MUST be\
    \ used in all\n   trials.\n"
- title: 4.3.  MPLS Addressing
  contents:
  - "4.3.  MPLS Addressing\n   Similar to L2 switches, multiprotocol label switching\
    \ (MPLS) devices\n   make forwarding decisions based on a 20-bit MPLS label. \
    \ Unless\n   specific labels are required, it is RECOMMENDED that uniformly random\n\
    \   values between 16 and 1,048,575 be used for all labels assigned by\n   test\
    \ equipment.  As per [RFC3032], this avoids using reserved MPLS\n   labels in\
    \ the range of 0-15 inclusive.\n"
- title: 4.4.  Network-layer Addressing
  contents:
  - "4.4.  Network-layer Addressing\n   When routers make forwarding decisions based\
    \ solely on the\n   destination network address, there may be no potential for\
    \ hashing\n   collision of source and destination addresses, as in the case of\n\
    \   Ethernet switching discussed earlier.  However, the potential still\n   exists\
    \ for hashing collisions at the network layer, and testers\n   SHOULD take this\
    \ potential into consideration when crafting the\n   network-layer contents of\
    \ test traffic.\n   For example, the equal cost multipath (ECMP) feature performs\
    \ load-\n   sharing across multiple links.  Routers implementing ECMP may perform\n\
    \   a hash of source and destination IP addresses in assigning flows.\n   Since\
    \ multiple ECMP routes by definition have the same metric,\n   routers use some\
    \ other \"tie-breaker\" mechanism to assign traffic to\n   each link.  As far\
    \ as the authors are aware, there is no standard\n   algorithm for ECMP link assignment.\
    \  Some implementations perform a\n   hash of all bits of the source and destination\
    \ IP addresses for this\n   purpose.  Others may perform a hash on one or more\
    \ bytes in the\n   source and destination IP addresses.\n   Just as in the case\
    \ of MAC addresses, nonrandom IP addresses can have\n   an adverse effect on the\
    \ outcome of ECMP link assignment decisions.\n   When benchmarking devices that\
    \ implement ECMP or any other form of\n   Layer 3 aggregation, it is RECOMMENDED\
    \ to use a randomly distributed\n   range of IP addresses.  In particular, testers\
    \ SHOULD NOT use\n   addresses that produce the undesired effects of address processing.\n\
    \   If, for example, a DUT can be observed to exhibit high packet loss\n   when\
    \ offered IPv4 network addresses that take the form x.x.1.x/24,\n   and relatively\
    \ low packet loss when the source and destination\n   network addresses take the\
    \ form of x.x.R.x/24 (where R is some random\n   value between 0 and 9), test\
    \ engineers SHOULD use the random pattern.\n"
- title: 4.5.  Transport-Layer Addressing
  contents:
  - "4.5.  Transport-Layer Addressing\n   Some devices with transport- or application-layer\
    \ awareness use TCP\n   or UDP port numbers in making forwarding decisions.  Examples\
    \ of such\n   devices include load balancers and application-layer firewalls.\n\
    \   Test instruments have the capability of generating packets with\n   random\
    \ TCP and UDP source and destination port numbers.  Known\n   destination port\
    \ numbers are often required for testing application-\n   layer devices.  However,\
    \ unless known port numbers are specifically\n   required for a test, it is RECOMMENDED\
    \ to use pseudorandom and\n   uniformly distributed values for both source and\
    \ destination port\n   numbers.\n   In addition, it may be desirable to pick pseudorandom\
    \ values from a\n   selected pool of numbers.  Many services identify themselves\
    \ through\n   use of reserved destination port numbers between 1 and 49151\n \
    \  inclusive.  Unless specific port numbers are required, it is\n   RECOMMENDED\
    \ to pick randomly distributed destination port numbers\n   between these lower\
    \ and upper boundaries.\n   Similarly, clients typically choose source port numbers\
    \ in the space\n   between 1024 and 65535 inclusive.  Unless specific port numbers\
    \ are\n   required, it is RECOMMENDED to pick randomly distributed source port\n\
    \   numbers between these lower and upper boundaries.\n"
- title: 4.6.  Application-Layer Patterns
  contents:
  - "4.6.  Application-Layer Patterns\n   Many measurements require the insertion\
    \ of application-layer\n   header(s) and payload into test traffic.  Application-layer\
    \ packet\n   contents offer additional opportunities for stuffing to occur, and\n\
    \   may also present nonrandom outcomes when fed through application-\n   layer-aware\
    \ hashing algorithms.  Given the vast number of\n   application-layer protocols\
    \ in use, we make no recommendation for\n   specific test traffic patterns to\
    \ be used; however, test engineers\n   SHOULD be aware that application-layer\
    \ traffic contents MAY produce\n   nonrandom outcomes with some hashing algorithms.\
    \  The same issues\n   that apply with lower-layer traffic patterns also apply\
    \ at the\n   application layer.  As discussed in section 5, the potential for\n\
    \   stuffing exists with any part of a test packet, including\n   application-layer\
    \ contents.  For example, some traffic generators\n   insert fields into packet\
    \ payloads to distinguish test traffic.\n   These fields may contain a transmission\
    \ timestamp; sequence number;\n   test equipment interface identifier and/or \"\
    stream\" number; and a\n   cyclic redundancy check (CRC) over the contents of\
    \ the test payload\n   or test packet.  All these fields are potential candidates\
    \ for\n   stuffing.\n"
- title: 5.  Control Character Stuffing
  contents:
  - '5.  Control Character Stuffing

    '
- title: 5.1.  Problem Statement
  contents:
  - "5.1.  Problem Statement\n   Link-layer technologies that use High-Level Data\
    \ Link Control (HDLC)-\n   like framing may insert an extra bit or byte before\
    \ each instance of\n   a control character in traffic.  These \"stuffing\" insertions\
    \ prevent\n   confusion with control characters, but they may also introduce\n\
    \   significant overhead.  Stuffing is data-dependent; thus, selection of\n  \
    \ different payload patterns will result in frames transmitted on the\n   media\
    \ that vary in length, even though the original frames may all be\n   of the same\
    \ length.\n   The overhead of these escape sequences is problematic for two\n\
    \   reasons.  First, explicitly calculating the amount of overhead can be\n  \
    \ non-trivial or even impossible for certain types of test traffic.  In\n   such\
    \ cases, the best testers can do is to characterize the\n   probability that an\
    \ escape sequence will occur for a given pattern.\n   This greatly complicates\
    \ the requirement of declaring exactly how\n   much traffic is offered to a DUT/SUT.\n\
    \   Second, in the absence of characterization and compensation for this\n   overhead,\
    \ the tester may unwittingly congest the DUT/SUT.  For\n   example, if a tester\
    \ intends to offer traffic to a DUT at 95 percent\n   of line rate, but the link-layer\
    \ protocol introduces an additional 1\n   percent of overhead to escape control\
    \ characters, then the aggregate\n   offered load will be 96 percent of line rate.\
    \  If the DUT's actual\n   channel capacity is only 95 percent, congestion will\
    \ occur and the\n   DUT will drop traffic even though the tester did not intend\
    \ this\n   outcome.\n   As described in [RFC1661] and [RFC1662], PPP and HDLC-like\
    \ framing\n   introduce two kinds of escape sequences: bit- and byte-stuffing.\n\
    \   Bit-stuffing refers to the insertion of an escape bit on bit-\n   synchronous\
    \ links.  Byte-stuffing refers to the insertion of an\n   escape byte on byte-synchronous\
    \ links.  We discuss each in turn.\n"
- title: 5.2.  PPP Bit-Stuffing
  contents:
  - "5.2.  PPP Bit-Stuffing\n   [RFC1662], section 5.2, specifies that any sequence\
    \ of five\n   contiguous \"1\" bits within a frame must be escaped by inserting\
    \ a \"0\"\n   bit prior to the sequence.  This escaping is necessary to avoid\n\
    \   confusion with the HDLC control character 0x7E, which contains six\n   \"\
    1\" bits.\n   Consider the following PPP frame containing a TCP/IP packet.  Not\n\
    \   shown is the 1-byte flag sequence (0x7E), at least one of which must\n   occur\
    \ between frames.\n   The contents of the various frame fields can be described\
    \ one of\n   three ways:\n   1.  Field contents never change over the test duration.\
    \  An example\n       would be the IP version number.\n   2.  Field contents change\
    \ over the test duration.  Some of these\n       changes are known prior to the\
    \ test duration.  An example would\n       be the use of incrementing IP addresses.\
    \  Some of these changes\n       are unknown.  An example would be a dynamically\
    \ calculated field\n       such as the TCP checksum.\n   3.  Field contents may\
    \ not be known.  An example would be proprietary\n       payload fields in test\
    \ packets.\n   In the diagram below, 30 out of 48 total bytes in the packet headers\n\
    \   are subject to change over the test duration.  Additionally, the\n   payload\
    \ field could be subject to change both content and size.  The\n   fields containing\
    \ the changeable bytes are given in ((double\n   parentheses)).\n    0       \
    \            1                   2                   3\n    0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    Address    |    Control    |           Protocol            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |Version|  IHL  |Type of Service|          Total Length         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         Identification        |Flags|      Fragment Offset    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Time to Live |    Protocol   |       ((Header Checksum))     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     ((Source Address))                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                  ((Destination Address))                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |        ((Source Port))        |     ((Destination Port))      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      ((Sequence Number))                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                  ((Acknowledgment Number))                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Data |           |U|A|P|R|S|F|                               |\n   | Offset|\
    \ Reserved  |R|C|S|S|Y|I|          ((Window))           |\n   |       |      \
    \     |G|K|H|T|N|N|                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |         ((Checksum))          |         Urgent Pointer        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   /  \
    \                        ((payload))                          /\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       ((FCS (4 bytes) ))                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   None of the other fields are known to contain sequences subject to\n   bit-stuffing,\
    \ at least not in their entirety.  Note that there is no\n   payload in this simple\
    \ example; as noted in section 4.6, the payload\n   contents of test traffic often\
    \ will present additional opportunities\n   for stuffing to occur, and MUST be\
    \ taken into account when\n   calculating stuff probability.\n   Given the information\
    \ at hand, and assuming static contents for the\n   rest of the fields, the challenge\
    \ is to determine the probability\n   that bit-stuffing will occur.\n"
- title: 5.2.1.  Calculating Bit-Stuffing Probability
  contents:
  - "5.2.1.  Calculating Bit-Stuffing Probability\n   In order to calculate bit-stuffing\
    \ probabilities, we assume that for\n   any string of length L, where b_n represents\
    \ the \"n\"th bit of the\n   string and 1 <= n <= L, the probability of b_n equalling\
    \ \"1\" is 0.5,\n   and the probability of b_n equalling \"0\" is 0.5.  Additionally,\
    \ the\n   value of b_n is independent of any other bits.\n   We can calculate\
    \ the probability of bit-stuffing for both infinite\n   and finite strings of\
    \ random bits.  We begin with the infinite-string\n   case.  For an infinitely\
    \ long string of uniformly random bits, we\n   will need to insert a stuff bit\
    \ if and only if state 5 is reached in\n   the following state table.\n      \
    \             |--------------------<----------------------|\n                \
    \   |                                           |1\n    _______      __|__   \
    \   _____      _____      _____      __|__\n   |       | 1  |     | 1  |     |\
    \ 1  |     | 1  |     | 1  |     |\n   | start |--->|  1  |--->|  2  |--->|  3\
    \  |--->|  4  |--->|  5  |\n   |_______|    |_____|    |_____|    |_____|    |_____|\
    \    |_____|\n     |   |         |          |          |          |          |\n\
    \     |   |0        |0         |0         |0         |0         |0\n     |-<-|----<----|----<-----|----<-----|----<-----|----<-----|\n\
    \   Initially, we begin in the \"start\" state.  A \"1\" bit moves us into\n \
    \  the next highest state, and a \"0\" bit returns us to the start state.\n  \
    \ From state 5, a \"1\" bit takes us back to the 1 state and a \"0\" bit\n   returns\
    \ us to \"start\".\n   From this state diagram we can build the following transition\
    \ matrix:\n     \\ To |\n      \\   |\n       \\  |\n   From \\ | start     1\
    \       2       3       4       5\n   ______\\|_________________________________________________\n\
    \    start |  0.5  |  0.5  |  0.0  |  0.0  |  0.0  |  0.0\n        1 |  0.5  |\
    \  0.0  |  0.5  |  0.0  |  0.0  |  0.0\n        2 |  0.5  |  0.0  |  0.0  |  0.5\
    \  |  0.0  |  0.0\n        3 |  0.5  |  0.0  |  0.0  |  0.0  |  0.5  |  0.0\n\
    \        4 |  0.5  |  0.0  |  0.0  |  0.0  |  0.0  |  0.5\n        5 |  0.5  |\
    \  0.5  |  0.0  |  0.0  |  0.0  |  0.0\n   With this transition matrix we can\
    \ build the following system of\n   equations.  If P(x) represents the probability\
    \ of reaching state x,\n   then:\n   P(start) = 0.5 * P(start) + 0.5 * P(1) +\
    \ 0.5 * P(2) + 0.5 * P(3) +\n              0.5 * P(4) + 0.5 * P(5)\n   P(1) =\
    \ 0.5 * P(start) + 0.5 * P(5)\n   P(2) = 0.5 * P(1)\n   P(3) = 0.5 * P(2)\n  \
    \ P(4) = 0.5 * P(3)\n   P(5) = 0.5 * P(4)\n   P(start) + P(1) + P(2) + P(3) +\
    \ P(4) + P(5) = 1\n   Solving this system of equations yields:\n   P(start) =\
    \ 0.5\n   P(1) = 8/31\n   P(2) = 4/31\n   P(3) = 2/31\n   P(4) = 1/31\n   P(5)\
    \ = 1/62\n   Thus, for an infinitely long string of uniformly random bits, the\n\
    \   probability of any individual bit causing a transition to state 5,\n   and\
    \ thus causing a stuff, is 1/62.\n"
- title: 5.2.2.  Bit-Stuffing for Finite Strings
  contents:
  - "5.2.2.  Bit-Stuffing for Finite Strings\n   For a uniformly random finite bit\
    \ string of length L, we can\n   explicitly count the number of bit-stuffs in\
    \ the set of all possible\n   strings of length L.  This count can then be used\
    \ to calculate the\n   expected number of stuffs for the string.\n   Let f(L)\
    \ represent the number of bit-stuffs in the set of all\n   possible strings of\
    \ length L.  Clearly, for 0 <= L <= 4, f(L) = 0 as\n   there are no strings of\
    \ length 5.  For L >= 5, f(L) = 2^(L-5) + (L-5)\n   * 2^(L-6) + f(L-5).\n   A\
    \ proof of this formula can be found in Appendix B.\n   Now, the expected number\
    \ of stuffing events, E[stuffs], can be found\n   by dividing the total number\
    \ of stuffs in all possible strings by the\n   total number of strings.  Thus\
    \ for any L, E[stuffs] = f(L) / 2^L.\n   Similarly, the probability that any particular\
    \ bit is the cause of a\n   bit-stuff can be calculated by dividing the total\
    \ number of stuffs in\n   the set of all strings of length L by the total number\
    \ of bits in the\n   set of all strings of length L.  Hence for any L, the probability\n\
    \   that L_n, where 5 <= n <= L, caused a stuff is f(L) / (L * 2^L).\n"
- title: 5.2.3.  Applied Bit-Stuffing
  contents:
  - "5.2.3.  Applied Bit-Stuffing\n   The amount of overhead attributable to bit-stuffing\
    \ may be calculated\n   explicitly as long as the expected number of stuff bits\
    \ per frame,\n   E[bit-stuffs] is known.  For long uniformly random bit-strings,\n\
    \   E[bit-stuffs] may be approximated by multiplying the length of the\n   string\
    \ by 1/62.\n   % overhead = E[bit-stuffs] / framesize (in bits)\n   Given that\
    \ the overhead added by bit-stuffing is approximately 1 in\n   62, or 1.6 percent,\
    \ it is RECOMMENDED that testers reduce the maximum\n   intended load by 1.6 percent\
    \ to avoid introducing congestion when\n   testing devices using bit-synchronous\
    \ interfaces (such as T1/E1,\n   DS-3, and the like).\n   The percentage given\
    \ above is an approximation.  For greatest\n   precision, the actual intended\
    \ load SHOULD be explicitly calculated\n   from the test traffic.\n   Note that\
    \ the DUT/SUT may be able to forward intended loads higher\n   than the calculated\
    \ theoretical maximum rate without packet loss.\n   This results from queuing\
    \ on the part of the DUT/SUT.  While a\n   device's throughput may be above this\
    \ level, delay-related\n   measurements may be affected.  Accordingly, it is RECOMMENDED\
    \ to\n   reduce offered levels by the amount of bit-stuffing overhead when\n \
    \  testing devices using bit-synchronous links.  This recommendation\n   applies\
    \ for all measurements, including throughput.\n"
- title: 5.3.  POS Byte-Stuffing
  contents:
  - "5.3.  POS Byte-Stuffing\n   [RFC1662] requires that \"Each Flag Sequence, Control\
    \ Escape octet,\n   and any octet which is flagged in the sending Async-Control-\n\
    \   Character-Map (ACCM), is replaced by a two octet sequence consisting\n   of\
    \ the Control Escape octet followed by the original octet exclusive-\n   or'd\
    \ with hexadecimal 0x20\".  The practical effect of this is to\n   insert a stuff\
    \ byte for instances of up to 34 characters: 0x7E, 0x7D,\n   or any of 32 ACCM\
    \ values.\n   A common implementation of PPP in HDLC-like framing is in PPP over\n\
    \   SONET/SDH (POS), as defined in [RFC2615].\n   As with the bit-stuffing case,\
    \ the requirement in characterizing POS\n   test traffic is to determine the probability\
    \ that byte-stuffing will\n   occur for a given sequence.  This is much simpler\
    \ to do than with\n   bit-synchronous links, since there is no possibility of\
    \ overlap\n   across byte boundaries.\n"
- title: 5.3.1.  Nullifying ACCM
  contents:
  - "5.3.1.  Nullifying ACCM\n   Testers can greatly reduce the probability of byte-stuffing\
    \ by\n   configuring link partners to negotiate an ACCM value of 0x00.  It is\n\
    \   RECOMMENDED that testers configure the test instrument(s) and DUT/SUT\n  \
    \ to negotiate an ACCM value of 0x00 unless specific ACCM values are\n   required.\n\
    \   One instance where nonzero ACCM values are used is in the Layer 2\n   Tunneling\
    \ Protocol (L2TP), as defined in [RFC2661], section 4.4.6.\n   When the default\
    \ ACCM values are used, the probability of stuffing\n   for any given random byte\
    \ is 34 in 256, or approximately 13.3\n   percent.\n"
- title: 5.3.2.  Other Stuffed Characters
  contents:
  - "5.3.2.  Other Stuffed Characters\n   If an ACCM value of 0x00 is negotiated,\
    \ the only characters subject\n   to stuffing are the flag and control escape\
    \ characters.  Thus, we can\n   say that without ACCM the probability of stuffing\
    \ for any given\n   random byte is 2 in 256, or approximately 0.8 percent.\n"
- title: 5.3.3.  Applied Byte-Stuffing
  contents:
  - "5.3.3.  Applied Byte-Stuffing\n   The amount of overhead attributable to byte-stuffing\
    \ may be\n   calculated explicitly as long as the expected number of stuff bytes\n\
    \   per frame, E[byte-stuffs], is known.  For long uniformly random byte-\n  \
    \ strings, E[byte-stuffs] may be approximated by multiplying the length\n   of\
    \ the string by the probability that any single byte is a stuff\n   byte.\n  \
    \ % overhead = E[byte-stuffs] / framesize (in bytes)\n   When testing a DUT/SUT\
    \ that implements PPP in HDLC-like framing and\n   L2TP (or any other technology\
    \ that uses nonzero ACCM values), it is\n   RECOMMENDED that testers reduce the\
    \ maximum intended load by 13.3\n   percent to avoid introducing congestion.\n\
    \   When testing a DUT/SUT that implements PPP in HDLC-like framing and\n   an\
    \ ACCM value of 0x00, it is RECOMMENDED that testers reduce the\n   maximum intended\
    \ load by 0.8 percent to avoid introducing congestion.\n   Note that the percentages\
    \ given above are approximations.  For\n   greatest precision, the actual intended\
    \ load SHOULD be explicitly\n   calculated from the test traffic\n   Note also\
    \ that the DUT/SUT may be able to forward intended loads\n   higher than the calculated\
    \ theoretical maximum rate without packet\n   loss.  This results from queuing\
    \ on the part of the DUT/SUT.  While a\n   device's throughput may be above this\
    \ level, delay-related\n   measurements may be affected.  Accordingly, it is RECOMMENDED\
    \ to\n   reduce offered levels by the amount of byte-stuffing overhead when\n\
    \   testing devices using byte-synchronous links.  This recommendation\n   applies\
    \ for all measurements, including throughput.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   This document recommends the use of pseudorandom\
    \ patterns in test\n   traffic.  This usage requires a uniform distribution, but\
    \ does not\n   have strict predictability requirements.  Although it is not\n\
    \   sufficient for security applications, the rand() function of many\n   programming\
    \ languages may provide a uniform distribution that is\n   usable for testing\
    \ purposes in lab conditions.  Implementations of\n   rand() may vary and provide\
    \ different properties so test designers\n   SHOULD understand the distribution\
    \ created by the underlying function\n   and how seeding the initial state affects\
    \ its behavior.\n   [RFC2615], section 6, discusses a denial-of-service attack\
    \ involving\n   the intentional transmission of characters that require stuffing.\n\
    \   This attack could consume up to 100 percent of available bandwidth.\n   However,\
    \ the test networks described in BMWG documents generally\n   SHOULD NOT be reachable\
    \ by anyone other than the tester(s).\n"
- title: 7.  Normative References
  contents:
  - "7.  Normative References\n   [RFC1661]  Simpson, W., \"The Point-to-Point Protocol\
    \ (PPP)\", STD 51,\n              RFC 1661, July 1994.\n   [RFC1662]  Simpson,\
    \ W., \"PPP in HDLC-like Framing\", STD 51, RFC 1662,\n              July 1994.\n\
    \   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n        \
    \      Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2544]  Bradner,\
    \ S. and J. McQuaid, \"Benchmarking Methodology for\n              Network Interconnect\
    \ Devices\", RFC 2544, March 1999.\n   [RFC2615]  Malis, A. and W. Simpson, \"\
    PPP over SONET/SDH\", RFC 2615,\n              June 1999.\n   [RFC2661]  Townsley,\
    \ W., Valencia, A., Rubens, A., Pall, G., Zorn,\n              G., and B. Palter,\
    \ \"Layer Two Tunneling Protocol \"L2TP\"\",\n              RFC 2661, August 1999.\n\
    \   [RFC2889]  Mandeville, R. and J. Perser, \"Benchmarking Methodology\n    \
    \          for LAN Switching Devices\", RFC 2889, August 2000.\n   [RFC3032] \
    \ Rosen, E., Tappan, D., Fedorkow, G., Rekhter, Y.,\n              Farinacci,\
    \ D., Li, T., and A. Conta, \"MPLS Label Stack\n              Encoding\", RFC\
    \ 3032, January 2001.\n"
- title: Appendix A.  Acknowledgements
  contents:
  - "Appendix A.  Acknowledgements\n   The authors gratefully acknowledge reviews\
    \ and contributions by Tom\n   Alexander, Len Ciavattone, Robert Craig, John Dawson,\
    \ Neil Carter,\n   Glenn Chagnot, Kevin Dubray, Diego Dugatkin, Rafael Francis,\
    \ Paul\n   Hoffman, David Joyner, Al Morton, Joe Perches, Jerry Perser, Scott\n\
    \   Poretsky, Dan Romascanu, and Kris Rousey.\n"
- title: Appendix B.  Proof of Formula for Finite Bit-Stuffing
  contents:
  - "Appendix B.  Proof of Formula for Finite Bit-Stuffing\n   We would like to construct\
    \ a function, f(L), that allows us to\n   explicitly count the total number of\
    \ bit-stuffs in the set of all\n   strings of length L.  Let S represent a bit\
    \ string of length L.\n   Additionally, let b_n be the nth bit of string S where\
    \ 1 <= n <= L.\n   Clearly, when 0 <= L <= 4, f(L) = 0, as there can be no possible\
    \ bit-\n   stuff if there are < 5 bits.\n   Suppose L >= 5, then there is some\
    \ number of strings that will cause\n   stuffing events.  Let us count them.\n\
    \   We begin by counting the number of strings that will cause at least\n   one\
    \ bit-stuff.  Let us suppose that the first 5 bits, b_1,...,b_5,\n   cause a stuffing\
    \ event.  Then, there are (L-5) bits that could have\n   any value, i.e., the\
    \ bits in position b_6 to b_L.  So, there must be\n   2^(L-5) strings where the\
    \ first 5 bits cause a stuff.\n   Now suppose that some other sequence of bits\
    \ causes a stuff, b_n to\n   b_(n+4) for some 1 < n <= L-4.  In order to guarantee\
    \ that b_n starts\n   a stuff sequence, b_(n-1) must be 0, otherwise a stuff could\
    \ occur at\n   b_(n+3).  Thus, there are a total of 6 bits which must have fixed\n\
    \   values in the string, S, and a total of L-6 bits which do not have\n   fixed\
    \ values.  Hence, for each value of n, there are 2^(L-6) possible\n   strings\
    \ with at least one bit-stuff for a total of (L-5) * 2^(L-6).\n   So, given a\
    \ string of length L, where L >= 5, we know that there are\n   2^(L-5) + (L-5)\
    \ * 2^(L-6) strings which will be transmitted with at\n   least one stuffed bit.\
    \  However, if L >= 10, then there could be more\n   than one bit-stuff within\
    \ the string S.  Let Z represent a sequence\n   of 5 sequential \"1\" bits.  Consider\
    \ the bit string ..., b_n, b_(n+1),\n   b_(n+2), Z, b_(n+8), b_(n+9), ... where\
    \ 1 <= n <= L-9.  For the above\n   sequence of bits to generate two stuffing\
    \ events, there must be at\n   least one run of five sequential one's bits in\
    \ ..., b_n, b_(n+1),\n   b_(n+2), b_(n+8), b_(n+9), ...  Note that the position\
    \ of Z in the\n   above sequence is irrelevant when looking for bit-stuffs.\n\
    \   Additionally, we've already determined that the number of strings\n   with\
    \ at least one stuff in a bit string of length L is 2^(L-5) +\n   (L-5) * 2^(L-6).\
    \  Thus, the total number of stuffing events in the\n   set of all bit strings\
    \ of length L can be represented as f(L) =\n   2^(L-5) + (L-5) * 2^(L-6) + f(L-5)\
    \ for all L >= 5.\n"
- title: Appendix C.  Explicit Calculation of Bit-Stuffing Overhead for IPv4
  contents:
  - "Appendix C.  Explicit Calculation of Bit-Stuffing Overhead for IPv4\n   Consider\
    \ a scenario where a tester is transmitting IPv4 test packets\n   across a bit\
    \ synchronous link.  The test traffic has the following\n   parameters (values\
    \ are in decimal):\n           +-----------------------+---------------------------+\n\
    \           | Field                 |           Value           |\n          \
    \ +-----------------------+---------------------------+\n           | IP Version\
    \            |             4             |\n           | IP Header Length    \
    \  |             5             |\n           | Type of service (TOS) |       \
    \      0             |\n           | Datagram Length       |            1028 \
    \          |\n           | ID                    |             0             |\n\
    \           | Flags/Fragments       |             0             |\n          \
    \ | Time to live (TTL)    |             64            |\n           | Protocol\
    \              |             17            |\n           | Source IP         \
    \    | 192.18.13.1-192.18.13.254 |\n           | Destination IP        |     \
    \   192.18.1.10        |\n           | Source UDP Port       |     pseudorandom\
    \ port     |\n           | Destination UDP Port  |     pseudorandom port     |\n\
    \           | UDP Length            |            1008           |\n          \
    \ | Payload               |  1000 pseudorandom bytes  |\n           +-----------------------+---------------------------+\n\
    \   We want to calculate the expected number of stuffs per packet, or\n   E[packet\
    \ stuffs].\n   First, we observe that we have 254 different IP headers to consider,\n\
    \   and secondly, that the changing 4th octet in the IP source addresses\n   will\
    \ produce occasional bit-stuffing events, so we must enumerate\n   these occurrences.\
    \  Additionally, we must take into account that the\n   3rd octet of the source\
    \ IP and the first octet of the destination IP\n   will affect stuffing occurrences.\n\
    \   An exhaustive search shows that cycling through all 254 headers\n   produces\
    \ 51 bit-stuffs for the destination IP address.  This gives us\n   an expectation\
    \ of 51/254 stuffs per packet due to the changing source\n   IP address.\n   For\
    \ the IP CRC, we observe that the value will decrement as the\n   source IP is\
    \ incremented.  A little calculation shows that the CRC\n   values for these headers\
    \ will fall in the range of 0xE790 to 0xE88F.\n   Additionally, both the protocol\
    \ and source IP address must be\n   considered, as they provide a source of extra\
    \ leading and trailing\n   \"1\" bits.\n   An exhaustive search shows that cycling\
    \ through all 254 headers will\n   produce 102 bit-stuffs for the CRC.  This gives\
    \ us an expectation of\n   102/254 stuffs per packet due to the CRC.\n   Since\
    \ our destination IP address is even and the UDP length is less\n   than 32768,\
    \ the random source and destination ports provide 32 bits\n   of sequential random\
    \ data without forcing us to consider the boundary\n   bits.  Additionally, we\
    \ will assume that since our payload is\n   pseudorandom, our UDP CRC will be\
    \ too.  The even UDP length field\n   again allows us to only consider the bits\
    \ explicitly contained within\n   the CRC and data fields.  So, using the formula\
    \ for the expected\n   number of stuffs in a finite string from section 5.2.2,\
    \ we determine\n   that E[UDP stuffs] = f(32)/2^32 + f(8000+16)/2^(8000+16). \
    \ Now,\n   f(32)/2^32 is calculable without too much difficulty and is\n   approximately\
    \ 0.465.  However, f(8016)/2^8016 is a little large to\n   calculate easily, so\
    \ we will approximate this value by using the\n   probability value obtained in\
    \ section 5.2.1.  Thus, E[UDP] ~ 0.465 +\n   8016/62 ~ 129.755.\n   Hence, E[packet\
    \ stuffs] = 51/254 + 102/254 + 129.755 = 130.357.\n   However, since we cannot\
    \ have a fractional stuff, we round down to\n   130.  Thus, we expect 130 stuffs\
    \ per packet.\n   Finally, we can calculate bit-stuffing overhead by dividing\
    \ the\n   expected number of stuff bits by the total number of bits in the IP\n\
    \   datagram.  So, this example traffic would generate 1.58% overhead.\n   If\
    \ our payload had consisted exclusively of zero bits, our overhead\n   would have\
    \ been 0.012%.  An all-ones payload would produce 19.47%\n   overhead.\n"
- title: Appendix D.  Explicit Calculation of Bit-Stuffing Overhead for IPv6
  contents:
  - "Appendix D.  Explicit Calculation of Bit-Stuffing Overhead for IPv6\n   Consider\
    \ a scenario where a tester is transmitting IPv6 test packets\n   across a bit-synchronous\
    \ link.  The test traffic has the following\n   parameters (values are in decimal\
    \ except for IPv6 addresses, which\n   are in hexadecimal):\n        +----------------------+----------------------------------+\n\
    \        | Field                |               Value              |\n       \
    \ +----------------------+----------------------------------+\n        | IP Version\
    \           |                 6                |\n        | Traffic Class    \
    \    |                 0                |\n        | Flow Label           |  \
    \      pseudorandom label        |\n        | Payload Length       |         \
    \      1008               |\n        | Next Header          |                17\
    \                |\n        | Hop Limit            |                64       \
    \         |\n        | Source IP            | 2001:DB8:0:1::1-2001:DB8:0:1::FF\
    \ |\n        | Destination IP       |         2001:DB8:0:2::10         |\n   \
    \     | Source UDP Port      |         pseudorandom port        |\n        | Destination\
    \ UDP Port |         pseudorandom port        |\n        | UDP Length        \
    \   |               1008               |\n        | Payload              |   \
    \   1000 pseudorandom bytes     |\n        +----------------------+----------------------------------+\n\
    \   We want to calculate the expected number of stuffs per packet, or\n   E[packet\
    \ stuffs].\n   First, we observe that we have 255 different IP headers to consider,\n\
    \   and secondly, that the changing 4th quad in the IP source addresses\n   will\
    \ produce occasional bit-stuffing events, so we must enumerate\n   these occurrences.\
    \  Additionally, we also note that since the first\n   quad of the destination\
    \ address has a leading zero bit, we do no have\n   to consider these adjacent\
    \ bits when calculating the number of bit-\n   stuffs in the source IP address.\n\
    \   An exhaustive search shows that cycling through all 255 headers\n   produces\
    \ 20 bit-stuffs for the source IP address.  This gives us an\n   expectation of\
    \ 20/255 stuffs per packet due to the changing source IP\n   address.\n   We also\
    \ have to consider our pseudorandomly generated flow label.\n   However, since\
    \ our Traffic Class field is 0 and our Payload Length\n   field is less than 32768\
    \ (and thus the leading bit of the Payload\n   Length field is 0), we may consider\
    \ the flow label as 20 bits of\n   random data.  Thus the expectation of a stuff\
    \ in the flow label is\n   f(20)/2^20 ~ .272.\n   Similar to the flow label case\
    \ above, the fourth quad of our\n   destination IP address is even and the UDP\
    \ length field is less than\n   32768, so the random source and destination ports\
    \ provide 32 bits of\n   sequential random data without forcing us to consider\
    \ the boundary\n   bits.  Additionally, we will assume that since our payload\
    \ is\n   pseudorandom, our UDP CRC will be too.  The even UDP length field\n \
    \  again allows us to only consider the bits explicitly contained within\n   the\
    \ CRC and data fields.  So, using the formula for the expected\n   number of stuffs\
    \ in a finite string from section 5.2.2, we determine\n   that E[UDP stuffs] =\
    \ f(32)/2^32 + f(8000+16)/2^(8000+16).  Now,\n   f(32)/2^32 is calculable without\
    \ too much difficulty and is\n   approximately 0.465.  However, f(8016)/2^8016\
    \ is a little large to\n   calculate easily, so we will approximate this value\
    \ by using the\n   probability value obtained in section 5.2.1.  Thus, E[UDP stuffs]\
    \ ~\n   0.465 + 8016/62 ~ 129.755.\n   Now we may explicitly calculate that E[packet\
    \ stuffs] = 20/255 +\n   0.272 + 129.755 = 130.105.  However, since we cannot\
    \ have a\n   fractional stuff, we round down to 130.  Thus, we expect 130 stuffs\n\
    \   per packet.\n   Finally, we can calculate bit-stuffing overhead by dividing\
    \ the\n   expected number of stuff bits by the total number of bits in the IP\n\
    \   datagram.  So, this example traffic would generate 1.55% overhead.\n   If\
    \ our payload had consisted exclusively of zero bits, our overhead\n   would have\
    \ been 0.010%.  An all-ones payload would produce 19.09%\n   overhead.\n"
- title: Appendix E.  Terminology
  contents:
  - "Appendix E.  Terminology\n   Hashing\n   Also known as a hash function.  In the\
    \ context of this document, an\n   algorithm for transforming data for use in\
    \ path selection by a\n   networking device.  For example, an Ethernet switch\
    \ with multiple\n   processing elements might use the source and destination MAC\n\
    \   addresses of an incoming frame as input for a hash function.  The\n   hash\
    \ function produces numeric output that tells the switch which\n   processing\
    \ element to use in forwarding the frame.\n   Randomness\n   In the context of\
    \ this document, the quality of having an equal\n   probability of any possible\
    \ outcome for a given pattern space.  For\n   example, if an experiment has N\
    \ randomly distributed outcomes, then\n   any individual outcome has a 1 in N\
    \ probability of occurrence.\n   Repeatability\n   The precision of test results\
    \ obtained on a single test bed, but from\n   trial to trial.  See also \"reproducibility\"\
    .\n   Reproducibility\n   The precision of test results between different setups,\
    \ possibly at\n   different locations.  See also \"repeatability\".\n   Stuffing\n\
    \   The insertion of a bit or byte within a frame to avoid confusion with\n  \
    \ control characters.  For example, RFC 1662 requires the insertion of\n   a \"\
    0\" bit prior to any sequence of five contiguous \"1\" bits within a\n   frame\
    \ to avoid confusion with the HDLC control character 0x7E.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   David Newman\n   Network Test\n   EMail: dnewman@networktest.com\n\
    \   Timmons C. Player\n   Spirent Communications\n   EMail: timmons.player@spirent.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
