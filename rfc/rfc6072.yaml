- title: __initial_text__
  contents:
  - ''
- title: Certificate Management Service for the Session Initiation Protocol (SIP)
  contents:
  - 'Certificate Management Service for the Session Initiation Protocol (SIP)

    '
- title: Abstract
  contents:
  - "Abstract\n   This document defines a credential service that allows Session\n\
    \   Initiation Protocol (SIP) User Agents (UAs) to use a SIP event\n   package\
    \ to discover the certificates of other users.  This mechanism\n   allows User\
    \ Agents that want to contact a given Address-of-Record\n   (AOR) to retrieve\
    \ that AOR's certificate by subscribing to the\n   credential service, which returns\
    \ an authenticated response\n   containing that certificate.  The credential service\
    \ also allows\n   users to store and retrieve their own certificates and private\
    \ keys.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6072.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Definitions .....................................................4\n  \
    \ 3. Overview ........................................................4\n   4.\
    \ UA Behavior with Certificates ...................................7\n   5. UA\
    \ Behavior with Credentials ....................................8\n   6. Event\
    \ Package Formal Definition for \"certificate\" ...............9\n      6.1. Event\
    \ Package Name .........................................9\n      6.2. SUBSCRIBE\
    \ Bodies ...........................................9\n      6.3. Subscription\
    \ Duration .....................................10\n      6.4. NOTIFY Bodies .............................................10\n\
    \      6.5. Subscriber Generation of SUBSCRIBE Requests ...............10\n  \
    \    6.6. Notifier Processing of SUBSCRIBE Requests .................11\n    \
    \  6.7. Notifier Generation of NOTIFY Requests ....................11\n      6.8.\
    \ Subscriber Processing of NOTIFY Requests ..................11\n      6.9. Handling\
    \ of Forked Requests ...............................11\n      6.10. Rate of Notifications\
    \ ....................................12\n      6.11. State Agents and Lists ...................................12\n\
    \      6.12. Behavior of a Proxy Server ...............................12\n  \
    \ 7. Event Package Formal Definition for \"credential\" ...............12\n  \
    \    7.1. Event Package Name ........................................12\n    \
    \  7.2. SUBSCRIBE Bodies ..........................................12\n      7.3.\
    \ Subscription Duration .....................................12\n      7.4. NOTIFY\
    \ Bodies .............................................13\n      7.5. Subscriber\
    \ Generation of SUBSCRIBE Requests ...............13\n      7.6. Notifier Processing\
    \ of SUBSCRIBE Requests .................14\n      7.7. Notifier Generation of\
    \ NOTIFY Requests ....................14\n      7.8. Generation of PUBLISH Requests\
    \ ............................15\n      7.9. Notifier Processing of PUBLISH Requests\
    \ ...................15\n      7.10. Subscriber Processing of NOTIFY Requests\
    \ .................16\n      7.11. Handling of Forked Requests ..............................16\n\
    \      7.12. Rate of Notifications ....................................16\n  \
    \    7.13. State Agents and Lists ...................................16\n    \
    \  7.14. Behavior of a Proxy Server ...............................16\n   8. Identity\
    \ Signatures ............................................16\n   9. Examples .......................................................17\n\
    \      9.1. Encrypted Page Mode Instant Message .......................17\n  \
    \    9.2. Setting and Retrieving UA Credentials .....................18\n   10.\
    \ Security Considerations .......................................19\n      10.1.\
    \ Certificate Revocation ...................................21\n      10.2. Certificate\
    \ Replacement ..................................22\n      10.3. Trusting the Identity\
    \ of a Certificate ...................22\n           10.3.1. Extra Assurance ...................................23\n\
    \      10.4. SACRED Framework .........................................24\n  \
    \    10.5. Crypto Profiles ..........................................24\n    \
    \  10.6. User Certificate Generation ..............................25\n      10.7.\
    \ Private Key Storage ......................................25\n      10.8. Compromised\
    \ Authentication Service .......................26\n   11. IANA Considerations\
    \ ...........................................26\n      11.1. Certificate Event\
    \ Package ................................27\n      11.2. Credential Event Package\
    \ .................................27\n      11.3. Identity Algorithm .......................................27\n\
    \   12. Acknowledgments ...............................................27\n  \
    \ 13. References ....................................................28\n    \
    \  13.1. Normative References .....................................28\n      13.2.\
    \ Informative References ...................................29\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   [RFC3261], as amended by [RFC3853], provides a mechanism\
    \ for end-to-\n   end encryption and integrity using Secure/Multipurpose Internet\
    \ Mail\n   Extensions (S/MIME) [RFC5751].  Several security properties of\n  \
    \ [RFC3261] depend on S/MIME, and yet it has not been widely deployed.\n   One\
    \ reason is the complexity of providing a reasonable certificate\n   distribution\
    \ infrastructure.  This specification proposes a way to\n   address discovery,\
    \ retrieval, and management of certificates for SIP\n   deployments.  Combined\
    \ with the SIP Identity [RFC4474] specification,\n   this specification allows\
    \ users to have certificates that are not\n   signed by any well known certification\
    \ authority while still strongly\n   binding the user's identity to the certificate.\n\
    \   In addition, this specification provides a mechanism that allows SIP\n   User\
    \ Agents such as IP phones to enroll and get their credentials\n   without any\
    \ more configuration information than they commonly have\n   today.  The end user\
    \ expends no extra effort.\n"
- title: 2.  Definitions
  contents:
  - "2.  Definitions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n\
    \   Certificate:  A Public Key Infrastructure using X.509 (PKIX)-\n      [RFC5280]\
    \ style certificate containing a public key and a list of\n      identities in\
    \ the SubjectAltName that are bound to this key.  The\n      certificates discussed\
    \ in this document are generally self-signed\n      and use the mechanisms in\
    \ the SIP Identity [RFC4474] specification\n      to vouch for their validity.\
    \  Certificates that are signed by a\n      certification authority can also be\
    \ used with all the mechanisms\n      in this document; however, they need not\
    \ be validated by the\n      receiver (although the receiver can validate them\
    \ for extra\n      assurance; see Section 10.3.1).\n   Credential:  For this document,\
    \ \"credential\" means the combination of\n      a certificate and the associated\
    \ private key.\n   Password Phrase:  A password used to encrypt and decrypt a\
    \ PKCS #8\n      (Public Key Cryptographic System #8) private key.\n"
- title: 3.  Overview
  contents:
  - "3.  Overview\n   The general approach is to provide a new SIP service referred\
    \ to as a\n   \"credential service\" that allows SIP User Agents (UAs) to subscribe\n\
    \   to other users' certificates using a new SIP event package [RFC3265].\n  \
    \ The certificate is delivered to the subscribing UA in a corresponding\n   SIP\
    \ NOTIFY request.  An authentication service as described in the\n   SIP Identity\
    \ [RFC4474] specification can be used to vouch for the\n   identity of the sender\
    \ of the certificate by using the sender's proxy\n   domain certificate to sign\
    \ the NOTIFY request.  The authentication\n   service is vouching that the sender\
    \ is allowed to populate the SIP\n   From header field value.  The sender of the\
    \ message is vouching that\n   this is an appropriate certificate for the user\
    \ identified in the SIP\n   From header field value.  The credential service can\
    \ manage public\n   certificates as well as the user's private keys.  Users can\
    \ update\n   their credentials, as stored on the credential service, using a SIP\n\
    \   PUBLISH [RFC3903] request.  The UA authenticates to the credential\n   service\
    \ using a shared secret when a UA is updating a credential.\n   Typically the\
    \ shared secret will be the same one that is used by the\n   UA to authenticate\
    \ a REGISTER request with the Registrar for the\n   domain (usually with SIP Digest\
    \ Authentication).\n   The following figure shows Bob publishing his credentials\
    \ from one of\n   his User Agents (e.g., his laptop software client), retrieving\
    \ his\n   credentials from another of his User Agents (e.g., his mobile phone),\n\
    \   and then Alice retrieving Bob's certificate and sending a message to\n   Bob.\
    \  SIP 200-class responses are omitted from the diagram to make\n   the figure\
    \ easier to understand.\n                example.com domain\n                ------------------\n\
    \    Alice       Proxy  Auth   Cred               Bob1  Bob2\n      |        \
    \   |      |      | TLS Handshake    |    |\n      |  [ Bob generates   ]    |<--------------------->|\n\
    \      |  [ credentials and ]    | PUBLISH (credential)  |\n      |  [ publishes\
    \ them  ]    |<----------------------|\n      |           |      |      | Digest\
    \ Challenge      |\n      |           |      |      |---------------------->|\n\
    \      |           |      |      | PUBLISH + Digest      |\n      |          \
    \ |      |      |<----------------------|\n      |           |      |      | \
    \                 |\n      |           |      |      | time passes...   |\n  \
    \    |           |      |      |                  |\n      |           |     \
    \ |      | TLS Handshake    |\n      |   [ Bob later gets ]    |<---------------->|\n\
    \      |   [ back his own   ]    | SUBSCRIBE        |\n      |   [ credentials\
    \    ]    | (credential)     |\n      |   [ at another     ]    |<-----------------|\n\
    \      |   [ User Agent     ]    | SUBSCRIBE+Digest |\n      |           |   \
    \   |      |<-----------------|\n      |           |      |      | NOTIFY    \
    \       |\n      |           |      |      |----------------->|\n      |     \
    \      |      |      | Bob decrypts key |\n      |           |      |      | \
    \                 |\n      |           |      |      |                  |\n  \
    \    | SUBSCRIBE (certificate) |    Alice fetches |\n      |---------->|----->|----->|\
    \    Bob's cert    |\n      |           |      |NOTIFY|                  |\n \
    \     | NOTIFY+Identity  |<-----|                  |\n      |<----------+------|\
    \      |  Alice uses cert |\n      |           |      |      |  to encrypt   \
    \   |\n      | MESSAGE   |      |      |  message to Bob  |\n      |---------->|------+------+----------------->|\n\
    \   Bob's UA (Bob2) does a Transport Layer Security (TLS) [RFC5246]\n   handshake\
    \ with the credential server to authenticate that the UA is\n   connected to the\
    \ correct credential server.  Then Bob's UA publishes\n   his newly created or\
    \ updated credentials.  The credential server\n   challenges the UA using a Digest\
    \ Authentication scheme to\n   authenticate that the UA knows Bob's shared secret.\
    \  Once the UA is\n   authenticated, the credential server stores Bob's credentials.\n\
    \   Another of Bob's User Agents (Bob1) wants to fetch its current\n   credentials.\
    \  It does a TLS [RFC5246] handshake with the credential\n   server to authenticate\
    \ that the UA is connected to the correct\n   credential server.  Then Bob's UA\
    \ subscribes for the credentials.\n   The credential server challenges the UA\
    \ to authenticate that the UA\n   knows Bob's shared secret.  Once the UA is authenticated,\
    \ the\n   credential server sends a NOTIFY that contains Bob's credentials.\n\
    \   The private key portion of the credential may have been encrypted\n   with\
    \ a secret that only Bob's UA (and not the credential server)\n   knows.  In this\
    \ case, once Bob's UA decrypts the private key, it will\n   be ready to go.  Typically\
    \ Bob's UA would do this when it first\n   registers on the network.\n   Some\
    \ time later Alice decides that she wishes to discover Bob's\n   certificate so\
    \ that she can send him an encrypted message or so that\n   she can verify the\
    \ signature on a message from Bob.  Alice's UA sends\n   a SUBSCRIBE message to\
    \ Bob's AOR.  The proxy in Bob's domain routes\n   this to the credential server\
    \ via an \"authentication service\" as\n   defined in [RFC4474].  The credential\
    \ server returns a NOTIFY that\n   contains Bob's public certificate in the body.\
    \  This is routed\n   through an authentication service that signs that this message\
    \ really\n   can validly claim to be from the AOR \"sip:bob@example.com\".  Alice's\n\
    \   UA receives the certificate and can use it to encrypt a message to\n   Bob.\n\
    \   It is critical to understand that the only way that Alice can trust\n   that\
    \ the certificate really is the one for Bob and that the NOTIFY\n   has not been\
    \ spoofed is for Alice to check that the Identity\n   [RFC4474] header field value\
    \ is correct.\n   The mechanism described in this document works for both self-signed\n\
    \   certificates and certificates signed by well known certification\n   authorities.\
    \  In order to deploy certificates signed by well known\n   certification authorities,\
    \ certification authorities would have to\n   support adding SIP URIs to the SubjectAltName\
    \ of the certificates\n   they generate.  This is something that has been rarely\
    \ implemented by\n   commercial certification authorities.  However, most UAs\
    \ would only\n   use self-signed certificates and would use an authentication\
    \ service\n   as described in [RFC4474] to provide a strong binding of an AOR\
    \ to\n   the certificates.\n   The mechanisms described in this document allow\
    \ for three different\n   styles of deployment:\n   1.  Deployments where the\
    \ credential server only stores certificates\n       and does not store any private\
    \ key information.  If the\n       deployment had users with multiple devices,\
    \ some other scheme\n       (perhaps even manual provisioning) would be used to\
    \ get the right\n       private keys onto all the devices that a user employs.\n\
    \   2.  Deployments where the credential server stores certificates and\n    \
    \   also stores an encrypted version of the private keys.  The\n       credential\
    \ server would not know or need the password phrase for\n       decrypting the\
    \ private key.  The credential server would help\n       move the private keys\
    \ between devices, but the user would need to\n       enter a password phrase\
    \ on each device to allow that device to\n       decrypt (and encrypt) the private\
    \ key information.\n   3.  Deployments where the credential server generates and\
    \ stores the\n       certificates and private keys.  Deployments such as these\
    \ may not\n       use password phrases.  Consequently, the private keys are not\n\
    \       encrypted inside the PKCS #8 objects.  This style of deployment\n    \
    \   would often have the credential server, instead of the devices,\n       create\
    \ the credentials.\n"
- title: 4.  UA Behavior with Certificates
  contents:
  - "4.  UA Behavior with Certificates\n   When a User Agent wishes to discover some\
    \ other user's certificate,\n   it subscribes to the \"certificate\" SIP event\
    \ package as described in\n   Section 6 to get the certificate.  While the subscription\
    \ is active,\n   if the certificate is updated, the Subscriber will receive the\n\
    \   updated certificate in a notification.\n   The Subscriber needs to decide\
    \ how long it is willing to trust that\n   the certificate it receives is still\
    \ valid.  If the certificate is\n   revoked before it expires, the Notifier will\
    \ send a notification with\n   an empty body to indicate that the certificate\
    \ is no longer valid.\n   If the certificate is renewed before it expires, the\
    \ Notifier will\n   send a notification with a body containing the new certificate.\
    \  Note\n   that the Subscriber might not receive the notification if an attacker\n\
    \   blocks this traffic.  The amount of time that the Subscriber caches a\n  \
    \ certificate SHOULD be configurable.  A default of one day is\n   RECOMMENDED.\n\
    \   Note that the actual duration of the subscription is unrelated to the\n  \
    \ caching time or validity time of the corresponding certificate.\n   Allowing\
    \ subscriptions to persist after a certificate is no longer\n   valid ensures\
    \ that Subscribers receive the replacement certificate in\n   a timely fashion.\
    \  The Notifier could return an immediate\n   notification with the certificate\
    \ in response to a subscribe request\n   and then immediately terminate subscription,\
    \ setting the reason\n   parameter to \"probation\".  The Subscriber will have\
    \ to periodically\n   poll the Notifier to verify the validity of the certificate.\n\
    \   If the UA uses a cached certificate in a request and receives a 437\n   (Unsupported\
    \ Certificate) response, it SHOULD remove the certificate\n   it used from the\
    \ cache and attempt to fetch the certificate again.\n   If the certificate is\
    \ changed, then the UA SHOULD retry the original\n   request with the new certificate.\
    \  This situation usually indicates\n   that the certificate was recently updated,\
    \ and that the Subscriber\n   has not received a corresponding notification. \
    \ If the certificate\n   fetched is the same as the one that was previously in\
    \ the cache, then\n   the UA SHOULD NOT try the request again.  This situation\
    \ can happen\n   when the request is retargeted to a different user than the original\n\
    \   request.  The 437 response is defined in [RFC4474].\n      Note: A UA that\
    \ has a presence list MAY want to subscribe to the\n      certificates of all\
    \ the presentities in the list when the UA\n      subscribes to their presence,\
    \ so that when the user wishes to\n      contact a presentity, the UA will already\
    \ have the appropriate\n      certificate.  Future specifications might consider\
    \ the possibility\n      of retrieving the certificates along with the presence\
    \ documents.\n   The details of how a UA deals with receiving encrypted messages\
    \ is\n   outside the scope of this specification.  It is worth noting that if\n\
    \   Charlie's User Agent Server (UAS) receives a request that is\n   encrypted\
    \ to Bob, it would be valid and legal for that UA to send a\n   302 redirecting\
    \ the call to Bob.\n"
- title: 5.  UA Behavior with Credentials
  contents:
  - "5.  UA Behavior with Credentials\n   UAs discover their own credentials by subscribing\
    \ to their AOR with\n   an event type of \"credential\" as described in Section\
    \ 7.  After a UA\n   registers, it SHOULD retrieve its credentials by subscribing\
    \ to them\n   as described in Section 6.5.\n   When a UA discovers its credential,\
    \ the private key information might\n   be encrypted with a password phrase. \
    \ The UA SHOULD request that the\n   user enter the password phrase on the device,\
    \ and the UA MAY cache\n   this password phrase for future use.\n   There are\
    \ several different cases in which a UA should generate a new\n   credential:\n\
    \   o  If the UA receives a NOTIFY with no body for the credential\n      package.\n\
    \   o  If the certificate has expired.\n   o  If the certificate's notAfter date\
    \ is within the next 600 seconds,\n      the UA SHOULD attempt to create replacement\
    \ credentials.  The UA\n      does this by waiting a random amount of time between\
    \ 0 and\n      300 seconds.  If no new credentials have been received in that\n\
    \      time, the UA creates new credentials to replace the expiring ones\n   \
    \   and sends them in a PUBLISH request following the rules for\n      modifying\
    \ event state as described in Section 4.4 of [RFC3903].\n   o  If the user of\
    \ the device has indicated via the user interface\n      that they wish to revoke\
    \ the current certificate and issue a new\n      one.\n   Credentials are created\
    \ by constructing a new key pair that will\n   require appropriate randomness\
    \ as described in [RFC4086] and then\n   creating a certificate as described in\
    \ Section 10.6.  The UA MAY\n   encrypt the private key with a password phrase\
    \ supplied by the user\n   as specified in Section 10.5.  Next, the UA updates\
    \ the user's\n   credential by sending a PUBLISH [RFC3903] request with the\n\
    \   credentials or just the certificate as described in Section 7.8.\n   If a\
    \ UA wishes to revoke the existing certificate without publishing\n   a new one,\
    \ it MUST send a PUBLISH with an empty body to the\n   credential server.\n"
- title: 6.  Event Package Formal Definition for "certificate"
  contents:
  - '6.  Event Package Formal Definition for "certificate"

    '
- title: 6.1.  Event Package Name
  contents:
  - "6.1.  Event Package Name\n   This document defines a SIP event package as defined\
    \ in [RFC3265].\n   The event-package token name for this package is:\n      \
    \    certificate\n"
- title: 6.2.  SUBSCRIBE Bodies
  contents:
  - "6.2.  SUBSCRIBE Bodies\n   This package does not define any SUBSCRIBE bodies.\n"
- title: 6.3.  Subscription Duration
  contents:
  - "6.3.  Subscription Duration\n   Subscriptions to this event package can range\
    \ from no time to weeks.\n   Subscriptions in days are more typical and are RECOMMENDED.\
    \  The\n   default subscription duration for this event package is one day.\n\
    \   The credential service is encouraged to keep the subscriptions active\n  \
    \ for AORs that are communicating frequently, but the credential\n   service MAY\
    \ terminate the subscription at any point in time.\n"
- title: 6.4.  NOTIFY Bodies
  contents:
  - "6.4.  NOTIFY Bodies\n   The body of a NOTIFY request for this package MUST either\
    \ be empty or\n   contain an application/pkix-cert body (as defined in [RFC2585])\
    \ that\n   contains the certificate, unless an Accept header field has\n   negotiated\
    \ some other type.  The Content-Disposition MUST be set to\n   \"signal\" as defined\
    \ in [RFC3204].\n   A future extension MAY define other NOTIFY bodies.  If no\
    \ \"Accept\"\n   header field is present in the SUBSCRIBE, the body type defined\
    \ in\n   this document MUST be assumed.\n   Implementations that generate large\
    \ notifications are reminded to\n   follow the message size restrictions for unreliable\
    \ transports\n   articulated in Section 18.1.1 of [RFC3261].\n"
- title: 6.5.  Subscriber Generation of SUBSCRIBE Requests
  contents:
  - "6.5.  Subscriber Generation of SUBSCRIBE Requests\n   A UA discovers a certificate\
    \ by sending a SUBSCRIBE request with an\n   event type of \"certificate\" to\
    \ the AOR for which a certificate is\n   desired.  In general, the UA stays subscribed\
    \ to the certificate for\n   as long as it plans to use and cache the certificate,\
    \ so that the UA\n   can be notified about changes or revocations to the certificate.\n\
    \   Subscriber User Agents will typically subscribe to certificate\n   information\
    \ for a period of hours or days, and automatically attempt\n   to re-subscribe\
    \ just before the subscription is completely expired.\n   When a user de-registers\
    \ from a device (logoff, power down of a\n   mobile device, etc.), Subscribers\
    \ SHOULD unsubscribe by sending a\n   SUBSCRIBE request with an Expires header\
    \ field of zero.\n"
- title: 6.6.  Notifier Processing of SUBSCRIBE Requests
  contents:
  - "6.6.  Notifier Processing of SUBSCRIBE Requests\n   When a SIP credential server\
    \ receives a SUBSCRIBE request with the\n   certificate event-type, it is not\
    \ necessary to authenticate the\n   subscription request.  The Notifier MAY limit\
    \ the duration of the\n   subscription to an administrator-defined period of time.\
    \  The\n   duration of the subscription does not correspond in any way to the\n\
    \   period for which the certificate will be valid.\n   When the credential server\
    \ receives a SUBSCRIBE request for a\n   certificate, it first checks to see if\
    \ it has credentials for the\n   requested URI.  If it does not have a certificate,\
    \ it returns a\n   NOTIFY request with an empty message body.\n"
- title: 6.7.  Notifier Generation of NOTIFY Requests
  contents:
  - "6.7.  Notifier Generation of NOTIFY Requests\n   Immediately after a subscription\
    \ is accepted, the Notifier MUST send\n   a NOTIFY with the current certificate,\
    \ or an empty body if no\n   certificate is available for the target user.  In\
    \ either case it\n   forms a NOTIFY with the From header field value set to the\
    \ value of\n   the To header field in the SUBSCRIBE request.  This server sending\n\
    \   the NOTIFY needs either to implement an authentication service (as\n   described\
    \ in SIP Identity [RFC4474]) or else the server needs to be\n   set up such that\
    \ the NOTIFY request will be sent through an\n   authentication service.  Sending\
    \ the NOTIFY request through the\n   authentication service requires the SUBSCRIBE\
    \ request to have been\n   routed through the authentication service, since the\
    \ NOTIFY is sent\n   within the dialog formed by the subscription.\n"
- title: 6.8.  Subscriber Processing of NOTIFY Requests
  contents:
  - "6.8.  Subscriber Processing of NOTIFY Requests\n   The resulting NOTIFY will\
    \ contain an application/pkix-cert body that\n   contains the requested certificate.\
    \  The UA MUST follow the\n   procedures in Section 10.3 to decide if the received\
    \ certificate can\n   be used.  The UA needs to cache this certificate for future\
    \ use.  The\n   maximum length of time for which it should be cached is discussed\
    \ in\n   Section 10.1.  The certificate MUST be removed from the cache if the\n\
    \   certificate has been revoked (if a NOTIFY with an empty body is\n   received),\
    \ or if it is updated by a subsequent NOTIFY.  The UA MUST\n   check that the\
    \ NOTIFY is correctly signed by an authentication\n   service as described in\
    \ [RFC4474].  If the identity asserted by the\n   authentication service does\
    \ not match the AOR that the UA subscribed\n   to, the certificate in the NOTIFY\
    \ is discarded and MUST NOT be used.\n"
- title: 6.9.  Handling of Forked Requests
  contents:
  - "6.9.  Handling of Forked Requests\n   This event package does not permit forked\
    \ requests.  At most one\n   subscription to this event type is permitted per\
    \ resource.\n"
- title: 6.10.  Rate of Notifications
  contents:
  - "6.10.  Rate of Notifications\n   Notifiers SHOULD NOT generate NOTIFY requests\
    \ more frequently than\n   once per minute.\n"
- title: 6.11.  State Agents and Lists
  contents:
  - "6.11.  State Agents and Lists\n   The credential server described in this section\
    \ that serves\n   certificates is a state agent as defined in [RFC3265], and\n\
    \   implementations of the credential server MUST be implemented as a\n   state\
    \ agent.\n   Implementers MUST NOT use the event list extension [RFC4662] with\n\
    \   this event type.  It is not possible to make such an approach work,\n   because\
    \ the authentication service would have to simultaneously\n   assert several different\
    \ identities.\n"
- title: 6.12.  Behavior of a Proxy Server
  contents:
  - "6.12.  Behavior of a Proxy Server\n   There are no additional requirements on\
    \ a SIP proxy, other than to\n   transparently forward the SUBSCRIBE and NOTIFY\
    \ requests as required\n   in SIP.  This specification describes the proxy, authentication\n\
    \   service, and credential service as three separate services, but it is\n  \
    \ certainly possible to build a single SIP network element that\n   performs all\
    \ of these services at the same time.\n"
- title: 7.  Event Package Formal Definition for "credential"
  contents:
  - '7.  Event Package Formal Definition for "credential"

    '
- title: 7.1.  Event Package Name
  contents:
  - "7.1.  Event Package Name\n   This document defines a SIP event package as defined\
    \ in [RFC3265].\n   The event-package token name for this package is:\n      \
    \   credential\n"
- title: 7.2.  SUBSCRIBE Bodies
  contents:
  - "7.2.  SUBSCRIBE Bodies\n   This package does not define any SUBSCRIBE bodies.\n"
- title: 7.3.  Subscription Duration
  contents:
  - "7.3.  Subscription Duration\n   Subscriptions to this event package can range\
    \ from hours to one week.\n   Subscriptions in days are more typical and are RECOMMENDED.\
    \  The\n   default subscription duration for this event package is one day.\n\
    \   The credential service SHOULD keep subscriptions active for UAs that\n   are\
    \ currently registered.\n"
- title: 7.4.  NOTIFY Bodies
  contents:
  - "7.4.  NOTIFY Bodies\n   An implementation compliant to this specification MUST\
    \ support the\n   multipart/mixed type (see [RFC2046]).  This allows a notification\
    \ to\n   contain multiple resource documents including at a minimum the\n   application/pkix-cert\
    \ body with the certificate and an application/\n   pkcs8 body that has the associated\
    \ private key information for the\n   certificate.  The application/pkcs8 media\
    \ type is defined in\n   [RFC5958].\n   The absence of an Accept header in the\
    \ SUBSCRIBE indicates support\n   for multipart/mixed and the content types application/pkix-cert\
    \ and\n   application/pkcs8.  If an Accept header is present, these types MUST\n\
    \   be included, in addition to any other types supported by the client.\n   The\
    \ application/pkix-cert body is a Distinguished Encoding Rules\n   (DER)-encoded\
    \ X.509v3 certificate [RFC2585].  The application/pkcs8\n   body contains a DER-encoded\
    \ [RFC5958] object that contains the\n   private key.  The PKCS #8 objects MUST\
    \ be of type PrivateKeyInfo.\n   The integrity and confidentiality of the PKCS\
    \ #8 objects are provided\n   by the TLS transport.  The transport encoding of\
    \ all the MIME bodies\n   is binary.\n"
- title: 7.5.  Subscriber Generation of SUBSCRIBE Requests
  contents:
  - "7.5.  Subscriber Generation of SUBSCRIBE Requests\n   A Subscriber User Agent\
    \ will subscribe to its credential information\n   for a period of hours or days\
    \ and will automatically attempt to\n   re-subscribe before the subscription has\
    \ completely expired.\n   The Subscriber SHOULD subscribe to its credentials whenever\
    \ a new\n   user becomes associated with the device (a new login).  The\n   Subscriber\
    \ SHOULD also renew its subscription immediately after a\n   reboot, or when the\
    \ Subscriber's network connectivity has just been\n   re-established.\n   The\
    \ UA needs to authenticate with the credential service for these\n   operations.\
    \  The UA MUST use TLS to directly connect to the server\n   acting as the credential\
    \ service or to a server that is authoritative\n   for the domain of the credential\
    \ service.  The UA MUST NOT connect\n   through an intermediate proxy to the credential\
    \ service.  The UA may\n   be configured with a specific name for the credential\
    \ service;\n   otherwise, normal SIP routing is used.  As described in RFC 3261,\
    \ the\n   TLS connection needs to present a certificate that matches the\n   expected\
    \ name of the server to which the connection was formed, so\n   that the UA knows\
    \ it is talking to the correct server.  Failing to do\n   this may result in the\
    \ UA publishing its private key information to\n   an attacker.  The credential\
    \ service will authenticate the UA using\n   the usual SIP Digest mechanism, so\
    \ the UA can expect to receive a SIP\n   challenge to the SUBSCRIBE or PUBLISH\
    \ requests.\n"
- title: 7.6.  Notifier Processing of SUBSCRIBE Requests
  contents:
  - "7.6.  Notifier Processing of SUBSCRIBE Requests\n   When a credential service\
    \ receives a SUBSCRIBE for a credential, the\n   credential service has to authenticate\
    \ and authorize the UA, and\n   validate that adequate transport security is being\
    \ used.  Only a UA\n   that can authenticate as being able to register as the\
    \ AOR is\n   authorized to receive the credentials for that AOR.  The credential\n\
    \   service MUST challenge the UA to authenticate the UA and then decide\n   if\
    \ it is authorized to receive the credentials.  If authentication is\n   successful,\
    \ the Notifier MAY limit the duration of the subscription\n   to an administrator-defined\
    \ period of time.  The duration of the\n   subscription MUST NOT be larger than\
    \ the length of time for which the\n   certificate is still valid.  The Expires\
    \ header field SHOULD be set\n   so that it is not longer than the notAfter date\
    \ in the certificate.\n"
- title: 7.7.  Notifier Generation of NOTIFY Requests
  contents:
  - "7.7.  Notifier Generation of NOTIFY Requests\n   Once the UA has authenticated\
    \ with the credential service and the\n   subscription is accepted, the credential\
    \ service MUST immediately\n   send a Notify request.  The authentication service\
    \ is applied to this\n   NOTIFY request in the same way as the certificate subscriptions.\
    \  If\n   the credential is revoked, the credential service MUST terminate any\n\
    \   current subscriptions and force the UA to re-authenticate by sending\n   a\
    \ NOTIFY with its Subscription-State header field set to \"terminated\"\n   and\
    \ a reason parameter set to \"deactivated\".  (This causes a\n   Subscriber to\
    \ retry the subscription immediately.)  This is so that\n   if a secret for retrieving\
    \ the credentials gets compromised, the\n   rogue UA will not continue to receive\
    \ credentials after the\n   compromised secret has been changed.\n   Any time\
    \ the credentials for this URI change, the credential service\n   MUST send a\
    \ new NOTIFY to any active subscriptions with the new\n   credentials.\n   The\
    \ notification MUST be sent over TLS so that it is integrity\n   protected, and\
    \ the TLS needs to be directly connected between the UA\n   and the credential\
    \ service with no intermediaries.\n"
- title: 7.8.  Generation of PUBLISH Requests
  contents:
  - "7.8.  Generation of PUBLISH Requests\n   A User Agent SHOULD be configurable\
    \ to control whether it publishes\n   the credential for a user or just the user's\
    \ certificate.\n   When publishing just a certificate, the body contains an application/\n\
    \   pkix-cert.  When publishing a credential, the body contains a\n   multipart/mixed\
    \ containing both an application/pkix-cert and an\n   application/pkcs8 body.\n\
    \   When the UA sends the PUBLISH [RFC3903] request, it needs to do the\n   following:\n\
    \   o  The UA MUST use TLS to directly connect to the server acting as\n     \
    \ the credential service or to a server that is authoritative for\n      the domain\
    \ of the credential service.  The UA MUST NOT connect\n      through an intermediate\
    \ proxy to the credential service.\n   o  The Expires header field value in the\
    \ PUBLISH request SHOULD be\n      set to match the time for which the certificate\
    \ is valid.\n   o  If the certificate includes Basic Constraints, it SHOULD set\
    \ the\n      cA boolean to false.\n"
- title: 7.9.  Notifier Processing of PUBLISH Requests
  contents:
  - "7.9.  Notifier Processing of PUBLISH Requests\n   When the credential service\
    \ receives a PUBLISH request to update\n   credentials, it MUST authenticate and\
    \ authorize this request in the\n   same way as for subscriptions for credentials.\
    \  If the authorization\n   succeeds, then the credential service MUST perform\
    \ the following\n   checks on the certificate:\n   o  The notBefore validity time\
    \ MUST NOT be in the future.\n   o  The notAfter validity time MUST be in the\
    \ future.\n   o  If a cA BasicConstraints boolean is set in the certificate, it\
    \ is\n      set to FALSE.\n   If all of these succeed, the credential service\
    \ updates the\n   credential for this URI, processes all the active certificates\
    \ and\n   credential subscriptions to this URI, and generates a NOTIFY request\n\
    \   with the new credential or certificate.  Note the SubjectAltName\n   SHOULD\
    \ NOT be checked, as that would restrict which certificates\n   could be used\
    \ and offers no additional security guarantees.\n   If the Subscriber submits\
    \ a PUBLISH request with no body and\n   Expires=0, this revokes the current credentials.\
    \  Watchers of these\n   credentials will receive an update with no body, indicating\
    \ that they\n   MUST stop any previously stored credentials.  Note that subscriptions\n\
    \   to the certificate package are NOT terminated; each Subscriber to the\n  \
    \ certificate package receives a notification with an empty body.\n"
- title: 7.10.  Subscriber Processing of NOTIFY Requests
  contents:
  - "7.10.  Subscriber Processing of NOTIFY Requests\n   When the UA receives a valid\
    \ NOTIFY request, it should replace its\n   existing credentials with the new\
    \ received ones.  If the UA cannot\n   decrypt the PKCS #8 object, it MUST send\
    \ a 437 (Unsupported\n   Certificate) response.  Later, if the user provides a\
    \ new password\n   phrase for the private key, the UA can subscribe to the credentials\n\
    \   again and attempt to decrypt with the new password phrase.\n"
- title: 7.11.  Handling of Forked Requests
  contents:
  - "7.11.  Handling of Forked Requests\n   This event package does not permit forked\
    \ requests.\n"
- title: 7.12.  Rate of Notifications
  contents:
  - "7.12.  Rate of Notifications\n   Notifiers SHOULD NOT generate NOTIFY requests\
    \ more frequently than\n   once per minute.\n"
- title: 7.13.  State Agents and Lists
  contents:
  - "7.13.  State Agents and Lists\n   The credential server described in this section\
    \ which serves\n   credentials is a state agent, and implementations of the credential\n\
    \   server MUST be implemented as a state agent.\n   Implementers MUST NOT use\
    \ the event list extension [RFC4662] with\n   this event type.\n"
- title: 7.14.  Behavior of a Proxy Server
  contents:
  - "7.14.  Behavior of a Proxy Server\n   The behavior is identical to behavior described\
    \ for certificate\n   subscriptions in Section 6.12.\n"
- title: 8.  Identity Signatures
  contents:
  - "8.  Identity Signatures\n   The [RFC4474] authentication service defined a signature\
    \ algorithm\n   based on SHA-1 called rsa-sha1.  This specification adds a signature\n\
    \   algorithm that is roughly the same but based on SHA-256 and called\n   rsa-sha256.\n\
    \   When using the rsa-sha256 algorithm, the signature MUST be computed\n   in\
    \ exactly the same way as described in Section 9 of [RFC4474] with\n   the exception\
    \ that instead of using sha1WithRSAEncryption, the\n   computation is done using\
    \ sha256WithRSAEncryption as described in\n   [RFC5754].\n   Implementations of\
    \ this specification MUST implement both rsa-sha1\n   and rsa-sha256.  The IANA\
    \ registration for rsa-sha256 is defined in\n   Section 11.3.\n"
- title: 9.  Examples
  contents:
  - "9.  Examples\n   In all of these examples, large parts of the messages are omitted\
    \ to\n   highlight what is relevant to this document.  The lines in the\n   examples\
    \ that are prefixed by $ represent encrypted blocks of data.\n"
- title: 9.1.  Encrypted Page Mode Instant Message
  contents:
  - "9.1.  Encrypted Page Mode Instant Message\n   In this example, Alice sends Bob\
    \ an encrypted page mode instant\n   message.  Alice does not already have Bob's\
    \ public key from previous\n   communications, so she fetches Bob's public key\
    \ from Bob's credential\n   service:\n   SUBSCRIBE sip:bob@biloxi.example.com\
    \ SIP/2.0\n   ...\n   Event: certificate\n   The credential service responds with\
    \ the certificate in a NOTIFY.\n   NOTIFY alice@atlanta.example.com  SIP/2.0\n\
    \   Subscription-State: active; expires=7200\n   ....\n   From: <sip:bob@biloxi.example.com>;tag=1234\n\
    \   Identity: \".... stuff removed ....\"\n   Identity-Info: <https://atlanta.example.com/cert>;alg=rsa-sha256\n\
    \   ....\n   Event: certificate\n   Content-Type: application/pkix-cert\n   Content-Disposition:\
    \ signal\n   < certificate data >\n   Next, Alice sends a SIP MESSAGE to Bob and\
    \ can encrypt the body using\n   Bob's public key as shown below.\n    MESSAGE\
    \ sip:bob@biloxi.example.com SIP/2.0\n    ...\n    Content-Type: application/pkcs7-mime\n\
    \    Content-Disposition: render\n    $ Content-Type: text/plain\n    $\n    $\
    \ < encrypted version of \"Hello\" >\n"
- title: 9.2.  Setting and Retrieving UA Credentials
  contents:
  - "9.2.  Setting and Retrieving UA Credentials\n   When Alice's UA wishes to publish\
    \ Alice's certificate and private key\n   to the credential service, it sends\
    \ a PUBLISH request like the one\n   below.  This must be sent over a TLS connection\
    \ directly to the\n   domain of the credential service.  The credential service\
    \ presents a\n   certificate where the SubjectAltName contains an entry that matches\n\
    \   the domain name in the request line of the PUBLISH request and\n   challenges\
    \ the request to authenticate her.\n    PUBLISH sips:alice@atlanta.example.com\
    \ SIP/2.0\n    ...\n    Event: credential\n    Content-Type: multipart/mixed;boundary=boundary\n\
    \    Content-Disposition: signal\n    --boundary\n    Content-ID: 123\n    Content-Type:\
    \ application/pkix-cert\n    < Public certificate for Alice >\n    --boundary\n\
    \    Content-ID: 456\n    Content-Type: application/pkcs8\n    < Private Key for\
    \ Alice >\n    --boundary\n   If one of Alice's UAs subscribes to the credential\
    \ event, the\n   credential service will challenge the request to authenticate\
    \ her,\n   and the NOTIFY will include a body similar to the one in the PUBLISH\n\
    \   example above.\n"
- title: 10.  Security Considerations
  contents:
  - "10.  Security Considerations\n   The high-level message flow from a security\
    \ point of view is\n   summarized in the following figure.  The 200 responses\
    \ are removed\n   from the figure, as they do not have much to do with the overall\n\
    \   security.\n   In this figure, authC refers to authentication and authZ refers\
    \ to\n   authorization.\n   Alice     Server              Bob UA\n    |      \
    \     | TLS Handshake    | 1) Client authC/Z server\n    |           |<---------------->|\n\
    \    |           | PUBLISH          | 2) Client sends request\n    |         \
    \  |<-----------------|    (write credential)\n    |           | Digest Challenge\
    \ | 3) Server challenges client\n    |           |----------------->|\n    | \
    \          | PUBLISH + Digest | 4) Server authC/Z client\n    |           |<-----------------|\n\
    \    |           |      time...     |\n    |           |                  |\n\
    \    |           | TLS Handshake    | 5) Client authC/Z server\n    |        \
    \   |<---------------->|\n    |           | SUBSCRIBE        | 6) Client sends\
    \ request\n    |           |<-----------------|    (read credential)\n    |  \
    \         | Digest Challenge | 7) Server challenges client\n    |           |----------------->|\n\
    \    |           | SUBSCRIBE+Digest | 8) Server authC/Z client\n    |        \
    \   |<-----------------|\n    |           | NOTIFY           | 9) Server returns\
    \ credential\n    |           |----------------->|\n    |           |\n    | SUBSCRIBE\
    \ |   10) Client requests certificate\n    |---------->|\n    |           |\n\
    \    |NOTIFY+AUTH|   11) Server returns user's certificate and signs that\n  \
    \  |<----------|       it is valid using certificate for the domain\n    |   \
    \        |\n   When the UA, labeled Bob, first created a credential for Bob, it\n\
    \   would store this on the credential server.  The UA authenticated the\n   server\
    \ using the certificates from the TLS handshake.  The server\n   authenticated\
    \ the UA using a digest-style challenge with a shared\n   secret.\n   The UA,\
    \ labeled Bob, wishes to request its credentials from the\n   server.  First,\
    \ it forms a TLS connection to the server, which\n   provides integrity and privacy\
    \ protection and also authenticates the\n   server to Bob's UA.  Next, the UA\
    \ requests its credentials using a\n   SUBSCRIBE request.  The server challenges\
    \ the SUBSCRIBE Request to\n   authenticate Bob's UA.  The server and Bob's UA\
    \ have a shared secret\n   that is used for this.  If the authentication is successful,\
    \ the\n   server sends the credentials to Bob's UA.  The private key in the\n\
    \   credentials may have been encrypted using a shared secret that the\n   server\
    \ does not know.\n   A similar process would be used for Bob's UA to publish new\n\
    \   credentials to the server.  Bob's UA would send a PUBLISH request\n   containing\
    \ the new credentials.  When this happened, all the other\n   UAs that were subscribed\
    \ to Bob's credentials would receive a NOTIFY\n   with the new credentials.\n\
    \   Alice wishes to find Bob's certificate and sends a SUBSCRIBE to the\n   server.\
    \  The server sends the response in a NOTIFY.  This does not\n   need to be sent\
    \ over a privacy or integrity protected channel, as the\n   authentication service\
    \ described in [RFC4474] provides integrity\n   protection of this information\
    \ and signs it with the certificate for\n   the domain.\n   This whole scheme\
    \ is highly dependent on trusting the operators of\n   the credential service\
    \ and trusting that the credential service will\n   not be compromised.  The security\
    \ of all the users will be\n   compromised if the credential service is compromised.\n\
    \      Note: There has been significant discussion of the topic of\n      avoiding\
    \ deployments in which the credential servers store the\n      private keys, even\
    \ in some encrypted form that the credential\n      server does not know how to\
    \ decrypt.  Various schemes were\n      considered to avoid this, but they all\
    \ result in either moving the\n      problem to some other server, which does\
    \ not seem to make the\n      problem any better, or having a different credential\
    \ for each\n      device.  For some deployments where each user has only one device,\n\
    \      this is fine, but for deployments with multiple devices, it would\n   \
    \   require that when Alice went to contact Bob, Alice would have to\n      provide\
    \ messages encrypted for all of Bob's devices.  The SIPPING\n      Working Group\
    \ did consider this architecture and decided it was\n      not appropriate due\
    \ both to the information it revealed about the\n      devices and users, and\
    \ to the amount of signaling required to make\n      it work.\n   This specification\
    \ requires that TLS be used for the SIP\n   communications to place and retrieve\
    \ a UA's private key.  This\n   provides security in two ways:\n   1.  Confidentiality\
    \ is provided for the Digest Authentication\n       exchange, thus protecting\
    \ it from dictionary attacks.\n   2.  Confidentiality is provided for the private\
    \ key, thus protecting\n       it from being exposed to passive attackers.\n \
    \  In order to prevent man-in-the-middle attacks, TLS clients MUST check\n   that\
    \ the SubjectAltName of the certificate for the server they\n   connected to exactly\
    \ matches the server they were trying to connect\n   to.  The TLS client must\
    \ be directly connected to the correct server;\n   otherwise, any intermediaries\
    \ in the TLS path can compromise the\n   certificate and instead provide a certificate\
    \ for which the attacker\n   knows the private key.  This may lead the UA that\
    \ relies on this\n   compromised certificate to lose confidential information.\
    \  Failing to\n   use TLS or selecting a poor cipher suite (such as NULL encryption)\n\
    \   may result in credentials, including private keys, being sent\n   unencrypted\
    \ over the network and will render the whole system\n   useless.\n   The correct\
    \ checking of chained certificates as specified in TLS\n   [RFC5246] is critical\
    \ for the client to authenticate the server.  If\n   the client does not authenticate\
    \ that it is talking to the correct\n   credential service, a man-in-the-middle\
    \ attack is possible.\n"
- title: 10.1.  Certificate Revocation
  contents:
  - "10.1.  Certificate Revocation\n   If a particular credential needs to be revoked,\
    \ the new credential is\n   simply published to the credential service.  Every\
    \ device with a copy\n   of the old credential or certificate in its cache will\
    \ have a\n   subscription and will rapidly (order of seconds) be notified and\n\
    \   replace its cache.  Clients that are not subscribed will subscribe\n   when\
    \ they next need to use the certificate and will get the new\n   certificate.\n\
    \   It is possible that an attacker could mount a denial-of-service (DoS)\n  \
    \ attack such that the UA that had cached a certificate did not receive\n   the\
    \ NOTIFY with its revocation.  To protect against this attack, the\n   UA needs\
    \ to limit how long it caches certificates.  After this time,\n   the UA would\
    \ invalidate the cached information, even though no NOTIFY\n   had ever been received\
    \ due to the attacker blocking it.\n   The duration of this cached information\
    \ is in some ways similar to a\n   device deciding how often to check a Certificate\
    \ Revocation List\n   (CRL).  For many applications, a default time of one day\
    \ is\n   suggested, but for some applications it may be desirable to set the\n\
    \   time to zero so that no certificates are cached at all and the\n   credential\
    \ is checked for validity every time the certificate is\n   used.\n   The UA MUST\
    \ NOT cache the certificates for a period longer than that\n   of the subscription\
    \ duration.  This is to avoid the UA using invalid\n   cached credentials when\
    \ the Notifier of the new credentials has been\n   prevented from updating the\
    \ UA.\n"
- title: 10.2.  Certificate Replacement
  contents:
  - "10.2.  Certificate Replacement\n   The UAs in the system replace the certificates\
    \ close to the time that\n   the certificates would expire.  If a UA has used\
    \ the same key pair to\n   encrypt a very large volume of traffic, the UA MAY\
    \ choose to replace\n   the credential with a new one before the normal expiration.\n"
- title: 10.3.  Trusting the Identity of a Certificate
  contents:
  - "10.3.  Trusting the Identity of a Certificate\n   When a UA wishes to discover\
    \ the certificate for\n   sip:alice@example.com, the UA subscribes to the certificate\
    \ for\n   alice@example.com and receives a certificate in the body of a SIP\n\
    \   NOTIFY request.  The term \"original URI\" is used to describe the URI\n \
    \  that was in the To header field value of the SUBSCRIBE request.  So,\n   in\
    \ this case, the original URI would be sip:alice@example.com.\n   If the certificate\
    \ is signed by a trusted certification authority,\n   and one of the names in\
    \ the SubjectAltName matches the original URI,\n   then this certificate MAY be\
    \ used, but only for exactly the original\n   URI and not for other identities\
    \ found in the SubjectAltName.\n   Otherwise, there are several steps the UA MUST\
    \ perform before using\n   this certificate.\n   o  The From header field in the\
    \ NOTIFY request MUST match the\n      original URI that was subscribed to.\n\
    \   o  The UA MUST check the Identity header field as described in the\n     \
    \ Identity [RFC4474] specification to validate that bodies have not\n      been\
    \ tampered with and that an authentication service has\n      validated this From\
    \ header field.\n   o  The UA MUST check the validity time of the certificate\
    \ and stop\n      using the certificate if it is invalid.  (Implementations are\n\
    \      reminded to verify both the notBefore and notAfter validity\n      times.)\n\
    \   o  The certificate MAY have several names in the SubjectAltName, but\n   \
    \   the UA MUST only use this certificate when it needs the\n      certificate\
    \ for the identity asserted by the authentication\n      service in the NOTIFY.\
    \  This means that the certificate should\n      only be indexed in the certificate\
    \ cache by the AOR that the\n      authentication service asserted and not by\
    \ the value of all the\n      identities found in the SubjectAltName list.\n \
    \  These steps result in a chain of bindings that result in a trusted\n   binding\
    \ between the original AOR that was subscribed to and a public\n   key.  The original\
    \ AOR is forced to match the From header field.  The\n   authentication service\
    \ validates that this request did come from the\n   identity claimed in the From\
    \ header field value and that the bodies\n   in the request that carry the certificate\
    \ have not been tampered\n   with.  The certificate in the body contains the public\
    \ key for the\n   identity.  Only the UA that can authenticate as this AOR, or\
    \ devices\n   with access to the private key of the domain, can tamper with this\n\
    \   body.  This stops other users from being able to provide a false\n   public\
    \ key.  This chain of assertion from original URI, to From, to\n   body, to public\
    \ key is critical to the security of the mechanism\n   described in this specification.\
    \  If any of the steps above are not\n   followed, this chain of security will\
    \ be broken and the system will\n   not work.\n"
- title: 10.3.1.  Extra Assurance
  contents:
  - "10.3.1.  Extra Assurance\n   Although the certificates used with this document\
    \ need not be\n   validatable to a trust anchor via PKIX [RFC5280] procedures,\n\
    \   certificates that can be validated may also be distributed via this\n   mechanism.\
    \  Such certificates potentially offer an additional level\n   of security because\
    \ they can be used with the secure (and partially\n   isolated) certification\
    \ authority user verification and key issuance\n   toolset, rather than depending\
    \ on the security of generic SIP\n   implementations.\n   When a relying party\
    \ receives a certificate that is not self-signed,\n   it MAY attempt to validate\
    \ the certificate using the rules in\n   Section 6 of [RFC5280].  If the certificate\
    \ validates successfully\n   and the names correctly match the user's AOR (see\
    \ Section 10.6), then\n   the implementation SHOULD provide some indication that\
    \ the\n   certificate has been validated with an external authority.  In\n   general,\
    \ failure to validate a certificate via this mechanism SHOULD\n   NOT be used\
    \ as a reason to reject the certificate.  However, if the\n   certificate is revoked,\
    \ then the implementation SHOULD reject it.\n"
- title: 10.4.  SACRED Framework
  contents:
  - "10.4.  SACRED Framework\n   This specification includes a mechanism that allows\
    \ end users to\n   share the same credentials across different end-user devices.\
    \  This\n   mechanism is based on the one presented in the Securely Available\n\
    \   Credentials (SACRED) Framework [RFC3760].  While this mechanism is\n   fully\
    \ described in this document, the requirements and background are\n   more thoroughly\
    \ discussed in [RFC3760].\n   Specifically, Sections 7.5, 7.6, and 7.9 follow\
    \ the TLS with Client\n   Authentication (cTLS) architecture described in Section\
    \ 4.2.2 of\n   [RFC3760].  The client authenticates the server using the server's\n\
    \   TLS certificate.  The server authenticates the client using a SIP\n   Digest\
    \ transaction inside the TLS session.  The TLS sessions form a\n   strong session\
    \ key that is used to protect the credentials being\n   exchanged.\n"
- title: 10.5.  Crypto Profiles
  contents:
  - "10.5.  Crypto Profiles\n   Credential services SHOULD implement the server name\
    \ indication\n   extensions in [RFC4366].  As specified in [RFC5246], credential\n\
    \   services MUST support the TLS cipher suite\n   TLS_RSA_WITH_AES_128_CBC_SHA.\
    \  In addition, they MUST support the TLS\n   cipher suite TLS_RSA_WITH_AES_128_CBC_SHA256\
    \ as specified in\n   [RFC5246].  If additional cipher suites are supported, then\n\
    \   implementations MUST NOT negotiate a cipher suite that employs NULL\n   encryption,\
    \ integrity, or authentication algorithms.\n   Implementations of TLS typically\
    \ support multiple versions of the\n   Transport Layer Security protocol as well\
    \ as the older Secure Socket\n   Layer (SSL) protocol.  Because of known security\
    \ vulnerabilities,\n   clients and servers MUST NOT request, offer, or use SSL\
    \ 2.0.  See\n   Appendix E.2 of [RFC5246] for further details.\n   The PKCS #8\
    \ encryption in the clients MUST implement PBES2 with a key\n   derivation algorithm\
    \ of PBKDF2 using HMAC.  Clients MUST implement\n   this HMAC with both SHA-1\
    \ [RFC3370] and SHA-256 [RFC5754].  Clients\n   MUST implement an encryption algorithm\
    \ of id-aes128-wrap-pad as\n   defined in [RFC5649].  Some pre-standard deployments\
    \ of this\n   specification used DES-EDE2-CBC-Pad as defined in [RFC2898] so,\
    \ for\n   some implementations, it may be desirable to also support that\n   algorithm.\
    \  A different password SHOULD be used for the PKCS #8\n   encryption than is\
    \ used for authentication of the client.  It is\n   important to choose sufficiently\
    \ strong passwords.  Specific advice\n   on the password can be found in Section\
    \ 6 of [RFC5959].\n"
- title: 10.6.  User Certificate Generation
  contents:
  - "10.6.  User Certificate Generation\n   The certificates need to be consistent\
    \ with [RFC5280].  The\n   sha1WithRSAEncryption and sha256WithRSAEncryption algorithms\
    \ for the\n   signatureAlgorithm MUST be implemented.  The Issuers SHOULD be the\n\
    \   same as the subject.  Given the ease of issuing new certificates with\n  \
    \ this system, the Validity field can be relatively short.  A Validity\n   value\
    \ of one year or less is RECOMMENDED.  The SubjectAltName must\n   have a URI\
    \ type that is set to the SIP URL corresponding to the user\n   AOR.  It MAY be\
    \ desirable to put some randomness into the length of\n   time for which the certificates\
    \ are valid so that it does not become\n   necessary to renew all the certificates\
    \ in the system at the same\n   time.\n   When creating a new key pair for a certificate,\
    \ it is critical to\n   have appropriate randomness as described in [RFC4086].\
    \  This can be\n   challenging on some embedded devices, such as some IP phones,\
    \ and\n   implementers should pay particular attention to this point.\n   It is\
    \ worth noting that a UA can discover the current time by looking\n   at the Date\
    \ header field value in the 200 response to a REGISTER\n   request.\n"
- title: 10.7.  Private Key Storage
  contents:
  - "10.7.  Private Key Storage\n   The protection afforded private keys is a critical\
    \ security factor.\n   On a small scale, failure of devices to protect the private\
    \ keys will\n   permit an attacker to masquerade as the user or decrypt their\n\
    \   personal information.  As noted in the SACRED Framework, when stored\n   on\
    \ an end-user device, such as a diskette or hard drive, credentials\n   SHOULD\
    \ NOT be in the clear.  It is RECOMMENDED that private keys be\n   stored securely\
    \ in the device, more specifically, encrypting them\n   using tamper-resistant\
    \ hardware encryption and exposing them only\n   when required: for example, the\
    \ private key is decrypted when\n   necessary to generate a digital signature,\
    \ and re-encrypted\n   immediately to limit exposure in the RAM to a short period\
    \ of time.\n   Some implementations may limit access to private keys by prompting\n\
    \   users for a PIN prior to allowing access to the private key.\n   On the server\
    \ side, the protection of unencrypted PKCS #8 objects is\n   equally important.\
    \  Failure of a server to protect the private keys\n   would be catastrophic,\
    \ as attackers with access to unencrypted\n   PKCS #8 objects could masquerade\
    \ as any user whose private key was\n   not encrypted.  Therefore, it is also\
    \ recommended that the private\n   keys be stored securely in the server, more\
    \ specifically, encrypting\n   them using tamper-resistant hardware encryption\
    \ and exposing them\n   only when required.\n   FIPS 140-2 [FIPS-140-2] provides\
    \ useful guidance on secure storage.\n"
- title: 10.8.  Compromised Authentication Service
  contents:
  - "10.8.  Compromised Authentication Service\n   One of the worst attacks against\
    \ the Certificate Management Service\n   described in this document would be if\
    \ the authentication service\n   were compromised.  This attack is somewhat analogous\
    \ to a\n   certification authority being compromised in traditional PKI systems.\n\
    \   The attacker could make a fake certificate for which it knows the\n   private\
    \ key, use it to receive any traffic for a given use, and then\n   re-encrypt\
    \ that traffic with the correct key and forward the\n   communication to the intended\
    \ receiver.  The attacker would thus\n   become a \"man in the middle\" in the\
    \ communications.\n   There is not too much that can be done to protect against\
    \ this type\n   of attack.  A UA MAY subscribe to its own certificate under some\n\
    \   other identity to try to detect whether the credential server is\n   handing\
    \ out the correct certificates.  It will be difficult to do\n   this in a way\
    \ that does not allow the credential server to recognize\n   the user's UA.\n\
    \   The UA MAY also save the fingerprints of the cached certificates and\n   warn\
    \ users when the certificates change significantly before their\n   expiry date.\n\
    \   The UA MAY also allow the user to see the fingerprints of the cached\n   certificates\
    \ so that they can be verified by some other out-of-band\n   means.\n"
- title: 11.  IANA Considerations
  contents:
  - "11.  IANA Considerations\n   This specification defines two new event packages\
    \ that IANA has added\n   to the \"Session Initiation Protocol (SIP) Event Types\
    \ Namespace\"\n   registry.\n"
- title: 11.1.  Certificate Event Package
  contents:
  - "11.1.  Certificate Event Package\n   To: ietf-sip-events@iana.org\n   Subject:\
    \ Registration of new SIP event package\n   Package Name: certificate\n   Is this\
    \ registration for a template-package:  No\n   Published Specification(s): This\
    \ document\n   New Event header parameters: This package defines no\n        \
    \                        new parameters\n   Person & email address to contact\
    \ for further information:\n     Cullen Jennings <fluffy@cisco.com>\n"
- title: 11.2.  Credential Event Package
  contents:
  - "11.2.  Credential Event Package\n   To: ietf-sip-events@iana.org\n   Subject:\
    \ Registration of new SIP event package\n   Package Name: credential\n   Is this\
    \ registration for a template-package:  No\n   Published Specification(s): This\
    \ document\n   Person & email address to contact for further information:\n  \
    \   Cullen Jennings <fluffy@cisco.com>\n"
- title: 11.3.  Identity Algorithm
  contents:
  - "11.3.  Identity Algorithm\n   IANA added the following entry to the \"Identity-Info\
    \ Algorithm\n   Parameter Values\" registry.\n   \"alg\" Parameter Name    Reference\n\
    \   ----------------------  ---------\n   rsa-sha256              [RFC6072]\n"
- title: 12.  Acknowledgments
  contents:
  - "12.  Acknowledgments\n   Many thanks to Eric Rescorla, Russ Housley, Jim Schaad,\
    \ Rohan Mahy,\n   and Sean Turner for significant help, discussion, and text.\
    \  Many\n   others provided useful comments and text, including Kumiko Ono, Peter\n\
    \   Gutmann, Yaron Pdut, Aki Niemi, Magnus Nystrom, Paul Hoffman, Adina\n   Simu,\
    \ Dan Wing, Mike Hammer, Pasi Eronen, Alexey Melnikov, Tim Polk,\n   John Elwell,\
    \ Jonathan Rosenberg, and Lyndsay Campbell.\n"
- title: 13.  References
  contents:
  - '13.  References

    '
- title: 13.1.  Normative References
  contents:
  - "13.1.  Normative References\n   [RFC2046]     Freed, N. and N. Borenstein, \"\
    Multipurpose Internet\n                 Mail Extensions (MIME) Part Two: Media\
    \ Types\",\n                 RFC 2046, November 1996.\n   [RFC2119]     Bradner,\
    \ S., \"Key words for use in RFCs to Indicate\n                 Requirement Levels\"\
    , BCP 14, RFC 2119, March 1997.\n   [RFC2585]     Housley, R. and P. Hoffman,\
    \ \"Internet X.509 Public Key\n                 Infrastructure Operational Protocols:\
    \ FTP and HTTP\",\n                 RFC 2585, May 1999.\n   [RFC3204]     Zimmerer,\
    \ E., Peterson, J., Vemuri, A., Ong, L., Audet,\n                 F., Watson,\
    \ M., and M. Zonoun, \"MIME media types for\n                 ISUP and QSIG Objects\"\
    , RFC 3204, December 2001.\n   [RFC3261]     Rosenberg, J., Schulzrinne, H., Camarillo,\
    \ G.,\n                 Johnston, A., Peterson, J., Sparks, R., Handley, M.,\n\
    \                 and E. Schooler, \"SIP: Session Initiation Protocol\",\n   \
    \              RFC 3261, June 2002.\n   [RFC3265]     Roach, A., \"Session Initiation\
    \ Protocol (SIP)-Specific\n                 Event Notification\", RFC 3265, June\
    \ 2002.\n   [RFC3370]     Housley, R., \"Cryptographic Message Syntax (CMS)\n\
    \                 Algorithms\", RFC 3370, August 2002.\n   [RFC3903]     Niemi,\
    \ A., \"Session Initiation Protocol (SIP) Extension\n                 for Event\
    \ State Publication\", RFC 3903, October 2004.\n   [RFC4474]     Peterson, J.\
    \ and C. Jennings, \"Enhancements for\n                 Authenticated Identity\
    \ Management in the Session\n                 Initiation Protocol (SIP)\", RFC\
    \ 4474, August 2006.\n   [RFC5246]     Dierks, T. and E. Rescorla, \"The Transport\
    \ Layer\n                 Security (TLS) Protocol Version 1.2\", RFC 5246,\n \
    \                August 2008.\n   [RFC5280]     Cooper, D., Santesson, S., Farrell,\
    \ S., Boeyen, S.,\n                 Housley, R., and W. Polk, \"Internet X.509\
    \ Public Key\n                 Infrastructure Certificate and Certificate Revocation\n\
    \                 List (CRL) Profile\", RFC 5280, May 2008.\n   [RFC4086]    \
    \ Eastlake, D., Schiller, J., and S. Crocker, \"Randomness\n                 Requirements\
    \ for Security\", BCP 106, RFC 4086,\n                 June 2005.\n   [RFC4366]\
    \     Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen,\n               \
    \  J., and T. Wright, \"Transport Layer Security (TLS)\n                 Extensions\"\
    , RFC 4366, April 2006.\n   [RFC5754]     Turner, S., \"Using SHA2 Algorithms\
    \ with Cryptographic\n                 Message Syntax\", RFC 5754, January 2010.\n\
    \   [RFC5649]     Housley, R. and M. Dworkin, \"Advanced Encryption\n        \
    \         Standard (AES) Key Wrap with Padding Algorithm\",\n                \
    \ RFC 5649, September 2009.\n   [RFC5958]     Turner, S., \"Asymmetric Key Packages\"\
    , RFC 5958,\n                 August 2010.\n   [RFC5959]     Turner, S., \"Algorithms\
    \ for Asymmetric Key Package\n                 Content Type\", RFC 5959, August\
    \ 2010.\n"
- title: 13.2.  Informative References
  contents:
  - "13.2.  Informative References\n   [RFC2898]     Kaliski, B., \"PKCS #5: Password-Based\
    \ Cryptography\n                 Specification Version 2.0\", RFC 2898, September\
    \ 2000.\n   [RFC3760]     Gustafson, D., Just, M., and M. Nystrom, \"Securely\n\
    \                 Available Credentials (SACRED) - Credential Server\n       \
    \          Framework\", RFC 3760, April 2004.\n   [RFC3853]     Peterson, J.,\
    \ \"S/MIME Advanced Encryption Standard\n                 (AES) Requirement for\
    \ the Session Initiation Protocol\n                 (SIP)\", RFC 3853, July 2004.\n\
    \   [RFC4662]     Roach, A., Campbell, B., and J. Rosenberg, \"A Session\n   \
    \              Initiation Protocol (SIP) Event Notification Extension\n      \
    \           for Resource Lists\", RFC 4662, August 2006.\n   [RFC5751]     Ramsdell,\
    \ B. and S. Turner, \"Secure/Multipurpose\n                 Internet Mail Extensions\
    \ (S/MIME) Version 3.2 Message\n                 Specification\", RFC 5751, January\
    \ 2010.\n   [FIPS-140-2]  NIST, \"Security Requirements for Cryptographic\n  \
    \               Modules\", May 2001, <http://csrc.nist.gov/publications/\n   \
    \              fips/fips140-2/fips1402.pdf>.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Cullen Jennings\n   Cisco Systems\n   170 West Tasman\
    \ Drive\n   San Jose, CA  95134\n   USA\n   Phone: +1 408 421-9990\n   EMail:\
    \ fluffy@cisco.com\n   Jason Fischl (editor)\n   Skype\n   3210 Porter Drive\n\
    \   Palo Alto, CA  94304\n   USA\n   Phone: +1-415-202-5192\n   EMail: jason.fischl@skype.net\n"
