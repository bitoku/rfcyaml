- title: __initial_text__
  contents:
  - '       Discovery Proxy for Multicast DNS-Based Service Discovery

    '
- title: Abstract
  contents:
  - "Abstract\n   This document specifies a network proxy that uses Multicast DNS\
    \ to\n   automatically populate the wide-area unicast Domain Name System\n   namespace\
    \ with records describing devices and services found on the\n   local link.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 7841.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8766.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2020 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction\n   2.  Operational Analogy\n   3.  Conventions\
    \ and Terminology Used in This Document\n   4.  Compatibility Considerations\n\
    \   5.  Discovery Proxy Operation\n     5.1.  Delegated Subdomain for DNS-based\
    \ Service Discovery Records\n     5.2.  Domain Enumeration\n       5.2.1.  Domain\
    \ Enumeration via Unicast Queries\n       5.2.2.  Domain Enumeration via Multicast\
    \ Queries\n     5.3.  Delegated Subdomain for LDH Host Names\n     5.4.  Delegated\
    \ Subdomain for Reverse Mapping\n     5.5.  Data Translation\n       5.5.1.  DNS\
    \ TTL Limiting\n       5.5.2.  Suppressing Unusable Records\n       5.5.3.  NSEC\
    \ and NSEC3 Queries\n       5.5.4.  No Text-Encoding Translation\n       5.5.5.\
    \  Application-Specific Data Translation\n     5.6.  Answer Aggregation\n   6.\
    \  Administrative DNS Records\n     6.1.  DNS SOA (Start of Authority) Record\n\
    \     6.2.  DNS NS Records\n     6.3.  DNS Delegation Records\n     6.4.  DNS\
    \ SRV Records\n     6.5.  Domain Enumeration Records\n   7.  DNSSEC Considerations\n\
    \     7.1.  Online Signing Only\n     7.2.  NSEC and NSEC3 Records\n   8.  IPv6\
    \ Considerations\n   9.  Security Considerations\n     9.1.  Authenticity\n  \
    \   9.2.  Privacy\n     9.3.  Denial of Service\n   10. IANA Considerations\n\
    \   11. References\n     11.1.  Normative References\n     11.2.  Informative\
    \ References\n   Appendix A.  Implementation Status\n     A.1.  Already Implemented\
    \ and Deployed\n     A.2.  Already Implemented\n     A.3.  Partially Implemented\n\
    \   Acknowledgments\n   Author's Address\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Multicast DNS [RFC6762] and its companion technology DNS-based\n\
    \   Service Discovery [RFC6763] were created to provide IP networking\n   with\
    \ the ease of use and autoconfiguration for which AppleTalk was\n   well known\
    \ [RFC6760] [ZC] [ROADMAP].\n   For a small home network consisting of just a\
    \ single link (or a few\n   physical links bridged together to appear as a single\
    \ logical link\n   from the point of view of IP), Multicast DNS [RFC6762] is sufficient\n\
    \   for client devices to look up the \".local\" host names of peers on the\n\
    \   same home network, and to use Multicast DNS-based Service Discovery\n   (DNS-SD)\
    \ [RFC6763] to discover services offered on that home network.\n   For a larger\
    \ network consisting of multiple links that are\n   interconnected using IP-layer\
    \ routing instead of link-layer bridging,\n   link-local Multicast DNS alone is\
    \ insufficient because link-local\n   Multicast DNS packets, by design, are not\
    \ propagated onto other\n   links.\n   Using link-local multicast packets for\
    \ Multicast DNS was a conscious\n   design choice [RFC6762].  Even when limited\
    \ to a single link,\n   multicast traffic is still generally considered to be\
    \ more expensive\n   than unicast, because multicast traffic impacts many devices\
    \ instead\n   of just a single recipient.  In addition, with some technologies\
    \ like\n   Wi-Fi [IEEE-11], multicast traffic is inherently less efficient and\n\
    \   less reliable than unicast, because Wi-Fi multicast traffic is sent\n   at\
    \ lower data rates, and is not acknowledged [MCAST].  Increasing the\n   amount\
    \ of expensive multicast traffic by flooding it across multiple\n   links would\
    \ make the traffic load even worse.\n   Partitioning the network into many small\
    \ links curtails the spread of\n   expensive multicast traffic but limits the\
    \ discoverability of\n   services.  At the opposite end of the spectrum, using\
    \ a very large\n   local link with thousands of hosts enables better service discovery\n\
    \   but at the cost of larger amounts of multicast traffic.\n   Performing DNS-based\
    \ Service Discovery using purely Unicast DNS is\n   more efficient and doesn't\
    \ require large multicast domains but does\n   require that the relevant data\
    \ be available in the Unicast DNS\n   namespace.  The Unicast DNS namespace in\
    \ question could fall within a\n   traditionally assigned globally unique domain\
    \ name, or it could be\n   within a private local unicast domain name such as\
    \ \".home.arpa\"\n   [RFC8375].\n   In the DNS-SD specification [RFC6763], Section\
    \ 10 (\"Populating the\n   DNS with Information\") discusses various possible\
    \ ways that a\n   service's PTR, SRV, TXT, and address records can make their\
    \ way into\n   the Unicast DNS namespace, including manual zone file configuration\n\
    \   [RFC1034] [RFC1035], DNS Update [RFC2136] [RFC3007], and proxies of\n   various\
    \ kinds.\n   One option is to make the relevant data available in the Unicast\
    \ DNS\n   namespace by manual DNS configuration.  This option has been used for\n\
    \   many years at IETF meetings to advertise the IETF terminal room\n   printer.\
    \  Details of this example are given in Appendix A of the\n   Roadmap document\
    \ [ROADMAP].  However, this manual DNS configuration\n   is labor intensive, error\
    \ prone, and requires a reasonable degree of\n   DNS expertise.\n   Another option\
    \ is to populate the Unicast DNS namespace by having the\n   devices offering\
    \ the services do that themselves, using DNS Update\n   [REG-PROT] [DNS-UL]. \
    \ However, this requires configuration of DNS\n   Update keys on those devices,\
    \ which has proven onerous and\n   impractical for simple devices like printers\
    \ and network cameras.\n   Hence, to facilitate efficient and reliable DNS-based\
    \ Service\n   Discovery, a hybrid is needed that combines the ease of use of\n\
    \   Multicast DNS with the efficiency and scalability of Unicast DNS.\n   This\
    \ document specifies a type of proxy called a \"Discovery Proxy\"\n   that uses\
    \ Multicast DNS [RFC6762] to discover Multicast DNS records\n   on its local link\
    \ on demand, and makes corresponding DNS records\n   visible in the Unicast DNS\
    \ namespace.\n   In principle, similar mechanisms could be defined for other local\n\
    \   discovery protocols, by creating a proxy that (i) uses the protocol\n   in\
    \ question to discover local information on demand, and then (ii)\n   makes corresponding\
    \ DNS records visible in the Unicast DNS namespace.\n   Such mechanisms for other\
    \ local discovery protocols could be\n   addressed in future documents.\n   The\
    \ design of the Discovery Proxy is guided by the previously\n   published DNS-based\
    \ Service Discovery requirements document\n   [RFC7558].\n   In simple terms,\
    \ a descriptive DNS name is chosen for each link in an\n   organization.  Using\
    \ a DNS NS record, responsibility for that DNS\n   name is delegated to a Discovery\
    \ Proxy physically attached to that\n   link.  When a remote client issues a unicast\
    \ query for a name falling\n   within the delegated subdomain, the normal DNS\
    \ delegation mechanism\n   results in the unicast query arriving at the Discovery\
    \ Proxy, since\n   it has been declared authoritative for those names.  Now, instead\
    \ of\n   consulting a textual zone file on disk to discover the answer to the\n\
    \   query as a traditional authoritative DNS server would, a Discovery\n   Proxy\
    \ consults its local link, using Multicast DNS, to find the\n   answer to the\
    \ question.\n   For fault tolerance reasons, there may be more than one Discovery\n\
    \   Proxy serving a given link.\n   Note that the Discovery Proxy uses a \"pull\"\
    \ model.  Until some remote\n   client has requested data, the local link is not\
    \ queried using\n   Multicast DNS.  In the idle state, in the absence of client\
    \ requests,\n   the Discovery Proxy sends no packets and imposes no burden on\
    \ the\n   network.  It operates purely \"on demand\".\n   An alternative proposal\
    \ that has been discussed is a proxy that\n   performs DNS updates to a remote\
    \ DNS server on behalf of the\n   Multicast DNS devices on the local network.\
    \  The difficulty with this\n   is that Multicast DNS devices do not routinely\
    \ announce their records\n   on the network.  Generally, they remain silent until\
    \ queried.  This\n   means that the complete set of Multicast DNS records in use\
    \ on a link\n   can only be discovered by active querying, not by passive listening.\n\
    \   Because of this, a proxy can only know what names exist on a link by\n   issuing\
    \ queries for them, and since it would be impractical to issue\n   queries for\
    \ every possible name just to find out which names exist\n   and which do not,\
    \ there is no reasonable way for a proxy to\n   programmatically learn all the\
    \ answers it would need to push up to\n   the remote DNS server using DNS Update.\
    \  Even if such a mechanism\n   were possible, it would risk generating high load\
    \ on the network\n   continuously, even when there are no clients with any interest\
    \ in\n   that data.\n   Hence, having a model where the query comes to the Discovery\
    \ Proxy is\n   much more efficient than a model where the Discovery Proxy pushes\
    \ the\n   answers out to some other remote DNS server.\n   A client seeking to\
    \ discover services and other information performs\n   this by sending traditional\
    \ DNS queries to the Discovery Proxy or by\n   sending DNS Push Notification subscription\
    \ requests [RFC8765].\n   How a client discovers what domain name(s) to use for\
    \ its DNS-based\n   Service Discovery queries (and, consequently, what Discovery\
    \ Proxy or\n   Proxies to use) is described in Section 5.2.\n   The diagram below\
    \ illustrates a network topology using a Discovery\n   Proxy to provide discovery\
    \ service to a remote client.\n    +--------+   Unicast     +-----------+  +---------+\
    \  +---------+\n    | Remote | Communication | Discovery |  | Network |  | Network\
    \ |\n    | Client |---- . . . ----|   Proxy   |  | Printer |  | Camera  |\n  \
    \                        Multicast-capable LAN segment (e.g., Ethernet)\n    \
    \                    Figure 1: Example Deployment\n   Note that there need not\
    \ be any Discovery Proxy on the link to which\n   the remote client is directly\
    \ attached.  The remote client\n   communicates directly with the Discovery Proxy\
    \ using normal unicast\n   TCP/IP communication mechanisms, potentially spanning\
    \ multiple IP\n   hops, possibly including VPN tunnels and other similar long-distance\n\
    \   communication channels.\n"
- title: 2.  Operational Analogy
  contents:
  - "2.  Operational Analogy\n   A Discovery Proxy does not operate as a multicast\
    \ relay or multicast\n   forwarder.  There is no danger of multicast forwarding\
    \ loops that\n   result in traffic storms, because no multicast packets are forwarded.\n\
    \   A Discovery Proxy operates as a _proxy_ for remote clients,\n   performing\
    \ queries on their behalf and reporting the results back.\n   A reasonable analogy\
    \ is making a telephone call to a colleague at\n   your workplace and saying,\
    \ \"I'm out of the office right now.  Would\n   you mind bringing up a printer\
    \ browser window and telling me the\n   names of the printers you see?\"  That\
    \ entails no risk of a forwarding\n   loop causing a traffic storm, because no\
    \ multicast packets are sent\n   over the telephone call.\n   A similar analogy,\
    \ instead of enlisting another human being to\n   initiate the service discovery\
    \ operation on your behalf, is to log in\n   to your own desktop work computer\
    \ using screen sharing and then run\n   the printer browser yourself to see the\
    \ list of printers.  Or, log in\n   using Secure Shell (ssh) and type \"dns-sd\
    \ -B _ipp._tcp\" and observe\n   the list of discovered printer names.  In neither\
    \ case is there any\n   risk of a forwarding loop causing a traffic storm, because\
    \ no\n   multicast packets are being sent over the screen-sharing or ssh\n   connection.\n\
    \   The Discovery Proxy provides another way of performing remote\n   queries,\
    \ which uses a different protocol instead of screen sharing or\n   ssh.  The Discovery\
    \ Proxy mechanism can be thought of as a custom\n   Remote Procedure Call (RPC)\
    \ protocol that allows a remote client to\n   exercise the Multicast DNS APIs\
    \ on the Discovery Proxy device, just\n   as a local client running on the Discovery\
    \ Proxy device would use\n   those APIs.\n   When the Discovery Proxy software\
    \ performs Multicast DNS operations,\n   the exact same Multicast DNS caching\
    \ mechanisms are applied as when\n   any other client software on that Discovery\
    \ Proxy device performs\n   Multicast DNS operations, regardless of whether that\
    \ be running a\n   printer browser client locally, a remote user running the printer\n\
    \   browser client via a screen-sharing connection, a remote user logged\n   in\
    \ via ssh running a command-line tool like \"dns-sd\", or a remote\n   user sending\
    \ DNS requests that cause a Discovery Proxy to perform\n   discovery operations\
    \ on its behalf.\n"
- title: 3.  Conventions and Terminology Used in This Document
  contents:
  - "3.  Conventions and Terminology Used in This Document\n   The key words \"MUST\"\
    , \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD\
    \ NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in\
    \ this document are to be interpreted as described in\n   BCP 14 [RFC2119] [RFC8174]\
    \ when, and only when, they appear in all\n   capitals, as shown here.\n   The\
    \ Discovery Proxy builds on Multicast DNS, which works between\n   hosts on the\
    \ same link.  For the purposes of this document, a set of\n   hosts is considered\
    \ to be \"on the same link\" if:\n   *  when any host from that set sends a packet\
    \ to any other host in\n      that set, using unicast, multicast, or broadcast,\
    \ the entire link-\n      layer packet payload arrives unmodified, and\n   * \
    \ a broadcast sent over that link, by any host from that set of\n      hosts,\
    \ can be received by every other host in that set.\n   The link-layer _header_\
    \ may be modified, such as in Token Ring Source\n   Routing [IEEE-5], but not\
    \ the link-layer _payload_.  In particular,\n   if any device forwarding a packet\
    \ modifies any part of the IP header\n   or IP payload, then the packet is no\
    \ longer considered to be on the\n   same link.  This means that the packet may\
    \ pass through devices such\n   as repeaters, bridges, hubs, or switches and still\
    \ be considered to\n   be on the same link for the purpose of this document, but\
    \ not through\n   a device such as an IP router that decrements the IP TTL or\
    \ otherwise\n   modifies the IP header.\n"
- title: 4.  Compatibility Considerations
  contents:
  - "4.  Compatibility Considerations\n   No changes to existing devices are required\
    \ to work with a Discovery\n   Proxy.\n   Existing devices that advertise services\
    \ using Multicast DNS work\n   with a Discovery Proxy.\n   Existing clients that\
    \ support DNS-based Service Discovery over\n   Unicast DNS work with a Discovery\
    \ Proxy.  DNS-based Service Discovery\n   over Unicast DNS was introduced in Mac\
    \ OS X 10.4 Tiger in April 2005\n   and has been included in Apple products introduced\
    \ since then,\n   including the iPhone and iPad.  It has also been included in\
    \ products\n   from other vendors, such as Microsoft Windows 10.\n   An overview\
    \ of the larger collection of associated DNS-based Service\n   Discovery technologies,\
    \ and how the Discovery Proxy technology\n   relates to those, is given in the\
    \ Service Discovery Road Map document\n   [ROADMAP].\n"
- title: 5.  Discovery Proxy Operation
  contents:
  - "5.  Discovery Proxy Operation\n   In a typical configuration, a Discovery Proxy\
    \ is configured to be\n   authoritative [RFC1034] [RFC1035] for four or more DNS\
    \ subdomains,\n   listed below.  Authority for these subdomains is delegated from\
    \ the\n   parent domain to the Discovery Proxy in the usual way for DNS\n   delegation,\
    \ via NS records.\n   A DNS subdomain for DNS-based Service Discovery records.\n\
    \      This subdomain name may contain rich text, including spaces and\n     \
    \ other punctuation.  This is because this subdomain name is used\n      only\
    \ in graphical user interfaces, where rich text is appropriate.\n   A DNS subdomain\
    \ for host name records.\n      This subdomain name SHOULD be limited to letters,\
    \ digits, and\n      hyphens in order to facilitate the convenient use of host\
    \ names in\n      command-line interfaces.\n   One or more DNS subdomains for\
    \ IPv4 Reverse Mapping records.\n      These subdomains will have names that end\
    \ in \"in-addr.arpa\".\n   One or more DNS subdomains for IPv6 Reverse Mapping\
    \ records.\n      These subdomains will have names that end in \"ip6.arpa\".\n\
    \   In an enterprise network, the naming and delegation of these\n   subdomains\
    \ is typically performed by conscious action of the network\n   administrator.\
    \  In a home network, naming and delegation would\n   typically be performed using\
    \ some automatic configuration mechanism\n   such as Home Networking Control Protocol\
    \ (HNCP) [RFC7788].\n   These three varieties of delegated subdomains (service\
    \ discovery,\n   host names, and reverse mapping) are described below in Sections\
    \ 5.1,\n   5.3, and 5.4.\n   How a client discovers where to issue its DNS-based\
    \ Service Discovery\n   queries is described in Section 5.2.\n"
- title: 5.1.  Delegated Subdomain for DNS-based Service Discovery Records
  contents:
  - "5.1.  Delegated Subdomain for DNS-based Service Discovery Records\n   In its\
    \ simplest form, each link in an organization is assigned a\n   unique Unicast\
    \ DNS domain name such as \"Building 1.example.com\" or\n   \"2nd Floor.Building\
    \ 3.example.com\".  Grouping multiple links under a\n   single Unicast DNS domain\
    \ name is to be specified in a future\n   companion document, but for the purposes\
    \ of this document, assume\n   that each link has its own unique Unicast DNS domain\
    \ name.  In a\n   graphical user interface these names are not displayed as strings\n\
    \   with dots as shown above, but something more akin to a typical file\n   browser\
    \ graphical user interface (which is harder to illustrate in a\n   text-only document)\
    \ showing folders, subfolders, and files in a file\n   system.\n     | *example.com*\
    \ |  Building 1  |  1st Floor  | Alice's printer   |\n     |               | \
    \ Building 2  | *2nd Floor* | Bob's printer     |\n     |               | *Building\
    \ 3* |  3rd Floor  | Charlie's printer |\n     |               |  Building 4 \
    \ |  4th Floor  |                   |\n     |               |  Building 5  | \
    \            |                   |\n     |               |  Building 6  |    \
    \         |                   |\n                         Figure 2: Illustrative\
    \ GUI\n   Each named link in an organization has one or more Discovery Proxies\n\
    \   that serve it.  This Discovery Proxy function could be performed by a\n  \
    \ device like a router or switch that is physically attached to that\n   link.\
    \  In the parent domain, NS records are used to delegate\n   ownership of each\
    \ defined link name (e.g., \"Building 1.example.com\")\n   to one or more Discovery\
    \ Proxies that serve the named link.  In other\n   words, the Discovery Proxies\
    \ are the authoritative name servers for\n   that subdomain.  As in the rest of\
    \ DNS-based Service Discovery, all\n   names are represented as-is using plain\
    \ UTF-8 encoding and, as\n   described in Section 5.5.4, no text-encoding translations\
    \ are\n   performed.\n   With appropriate VLAN configuration [IEEE-1Q], a single\
    \ Discovery\n   Proxy device could have a logical presence on many links and serve\
    \ as\n   the Discovery Proxy for all those links.  In such a configuration,\n\
    \   the Discovery Proxy device would have a single physical Ethernet\n   [IEEE-3]\
    \ port, configured as a VLAN trunk port, which would appear to\n   software on\
    \ that device as multiple virtual Ethernet interfaces, one\n   connected to each\
    \ of the VLAN links.\n   As an alternative to using VLAN technology, using a Multicast\
    \ DNS\n   Discovery Relay [RELAY] is another way that a Discovery Proxy can\n\
    \   have a \"virtual\" presence on a remote link.\n   When a DNS-SD client issues\
    \ a Unicast DNS query to discover services\n   in a particular Unicast DNS subdomain\n\
    \   (e.g., \"_ipp._tcp.Building 1.example.com. PTR ?\"), the normal DNS\n   delegation\
    \ mechanism results in that query being forwarded until it\n   reaches the delegated\
    \ authoritative name server for that subdomain,\n   namely, the Discovery Proxy\
    \ on the link in question.  Like a\n   conventional Unicast DNS server, a Discovery\
    \ Proxy implements the\n   usual Unicast DNS protocol [RFC1034] [RFC1035] over\
    \ UDP and TCP.\n   However, unlike a conventional Unicast DNS server that generates\n\
    \   answers from the data in its manually configured zone file, a\n   Discovery\
    \ Proxy learns answers using Multicast DNS.  A Discovery\n   Proxy does this by\
    \ consulting its Multicast DNS cache and/or issuing\n   Multicast DNS queries,\
    \ as appropriate according to the usual protocol\n   rules of Multicast DNS [RFC6762],\
    \ for the corresponding Multicast DNS\n   name, type, and class, with the delegated\
    \ zone part of the name\n   replaced with \".local\" (e.g., in this case,\n  \
    \ \"_ipp._tcp.local. PTR ?\").  Then, from the received Multicast DNS\n   data,\
    \ the Discovery Proxy synthesizes the appropriate Unicast DNS\n   response, with\
    \ the \".local\" top-level label of the owner name\n   replaced with the name\
    \ of the delegated zone.  Further details of the\n   name translation rules are\
    \ described in Section 5.5.  Rules\n   specifying how long the Discovery Proxy\
    \ should wait to accumulate\n   Multicast DNS responses before sending its unicast\
    \ reply are\n   described in Section 5.6.\n   The existing Multicast DNS caching\
    \ mechanism is used to minimize\n   unnecessary Multicast DNS queries on the wire.\
    \  The Discovery Proxy\n   is acting as a client of the underlying Multicast DNS\
    \ subsystem and\n   benefits from the same caching and efficiency measures as\
    \ any other\n   client using that subsystem.\n   Note that the contents of the\
    \ delegated zone, generated as it is by\n   performing \".local\" Multicast DNS\
    \ queries, mirrors the records\n   available on the local link via Multicast DNS\
    \ very closely, but not\n   precisely.  There is not a full bidirectional equivalence\
    \ between the\n   two.  Certain records that are available via Multicast DNS may\
    \ not\n   have equivalents in the delegated zone possibly because they are\n \
    \  invalid or not relevant in the delegated zone or because they are\n   being\
    \ suppressed because they are unusable outside the local link\n   (see Section\
    \ 5.5.2).  Conversely, certain records that appear in the\n   delegated zone may\
    \ not have corresponding records available on the\n   local link via Multicast\
    \ DNS.  In particular, there are certain\n   administrative SRV records (see Section\
    \ 6) that logically fall within\n   the delegated zone but semantically represent\
    \ metadata _about_ the\n   zone rather than records _within_ the zone.  Consequently,\
    \ these\n   administrative records in the delegated zone do not have any\n   corresponding\
    \ counterparts in the Multicast DNS namespace of the\n   local link.\n"
- title: 5.2.  Domain Enumeration
  contents:
  - "5.2.  Domain Enumeration\n   A DNS-SD client performs Domain Enumeration [RFC6763]\
    \ via certain PTR\n   queries, using both unicast and multicast.\n   If a DNS-SD\
    \ client receives a Domain Name configuration via DHCP then\n   it issues unicast\
    \ queries derived from this domain name.  It also\n   issues unicast queries using\
    \ names derived from its IPv4 subnet\n   address(es) and IPv6 prefix(es).  These\
    \ unicast Domain Enumeration\n   queries are described in Section 5.2.1.  A DNS-SD\
    \ client also issues\n   multicast Domain Enumeration queries in the \"local\"\
    \ domain [RFC6762],\n   as described in Section 5.2.2.  The results of all the\
    \ Domain\n   Enumeration queries are combined for DNS-based Service Discovery\n\
    \   purposes.\n"
- title: 5.2.1.  Domain Enumeration via Unicast Queries
  contents:
  - "5.2.1.  Domain Enumeration via Unicast Queries\n   The (human or automated) administrator\
    \ creates Unicast DNS Domain\n   Enumeration PTR records [RFC6763] to inform clients\
    \ of available\n   service discovery domains.  Two varieties of such Unicast DNS\
    \ Domain\n   Enumeration PTR records exist: those with names derived from the\n\
    \   domain name communicated to the clients via DHCP option 15 [RFC2132],\n  \
    \ and those with names derived from either IPv4 subnet address(es) or\n   IPv6\
    \ prefix(es) in use by the clients.  Below is an example showing\n   the name-based\
    \ variety, where the DHCP server configured the client\n   with the domain name\
    \ \"example.com\":\n         b._dns-sd._udp.example.com.    PTR   Building 1.example.com.\n\
    \         db._dns-sd._udp.example.com.   PTR   Building 1.example.com.\n     \
    \    lb._dns-sd._udp.example.com.   PTR   Building 1.example.com.\n   The meaning\
    \ of these records is defined in the DNS-based Service\n   Discovery specification\
    \ [RFC6763] but, for convenience, is repeated\n   here.  The \"b\" (\"browse\"\
    ) records tell the client device the list of\n   browsing domains to display for\
    \ the user to select from.  The \"db\"\n   (\"default browse\") record tells the\
    \ client device which domain in\n   that list should be selected by default. \
    \ The \"db\" domain MUST be one\n   of the domains in the \"b\" list; if not,\
    \ then no domain is selected by\n   default.  The \"lb\" (\"legacy browse\") record\
    \ tells the client device\n   which domain to automatically browse on behalf of\
    \ applications that\n   don't implement user interface for multi-domain browsing\
    \ (which is\n   most of them at the time of writing).  The \"lb\" domain is often\
    \ the\n   same as the \"db\" domain, or sometimes the \"db\" domain plus one or\n\
    \   more others that should be included in the list of automatic browsing\n  \
    \ domains for legacy clients.\n   Note that in the example above, for clarity,\
    \ space characters in\n   names are shown as actual spaces.  If this data is manually\
    \ entered\n   into a textual zone file for authoritative server software such\
    \ as\n   BIND, care must be taken because the space character is used as a\n \
    \  field separator, and other characters like dot ('.'), semicolon\n   (';'),\
    \ dollar ('$'), backslash ('\\'), etc., also have special\n   meaning.  These\
    \ characters have to be escaped when entered into a\n   textual zone file, following\
    \ the rules in Section 5.1 of the DNS\n   specification [RFC1035].  For example,\
    \ a literal space in a name is\n   represented in the textual zone file using\
    \ '\\032', so\n   \"Building 1.example.com\" is entered as \"Building\\0321.example.com\"\
    .\n   DNS responses are limited to a maximum size of 65535 bytes.  This\n   limits\
    \ the maximum number of domains that can be returned for a\n   Domain Enumeration\
    \ query as follows:\n   A DNS response header is 12 bytes.  That's typically followed\
    \ by a\n   single qname (up to 256 bytes) plus qtype (2 bytes) and qclass\n  \
    \ (2 bytes), leaving 65275 for the Answer Section.\n   An Answer Section Resource\
    \ Record consists of:\n   *  Owner name, encoded as a compression pointer, 2 bytes\n\
    \   *  RRTYPE (type PTR), 2 bytes\n   *  RRCLASS (class IN), 2 bytes\n   *  TTL,\
    \ 4 bytes\n   *  RDLENGTH, 2 bytes\n   *  RDATA (domain name), up to 256 bytes\n\
    \   This means that each Resource Record in the Answer Section can take\n   up\
    \ to 268 bytes total, which means that the Answer Section can\n   contain, in\
    \ the worst case, no more than 243 domains.\n   In a more typical scenario, where\
    \ the domain names are not all\n   maximum-sized names, and there is some similarity\
    \ between names so\n   that reasonable name compression is possible, each Answer\n\
    \   Section Resource Record may average 140 bytes, which means that the\n   Answer\
    \ Section can contain up to 466 domains.\n   It is anticipated that this should\
    \ be sufficient for even a large\n   corporate network or university campus.\n"
- title: 5.2.2.  Domain Enumeration via Multicast Queries
  contents:
  - "5.2.2.  Domain Enumeration via Multicast Queries\n   In the case where Discovery\
    \ Proxy functionality is widely deployed\n   within an enterprise (either by having\
    \ a Discovery Proxy physically\n   on each link, or by having a Discovery Proxy\
    \ with a remote \"virtual\"\n   presence on each link using VLANs or Multicast\
    \ DNS Discovery Relays\n   [RELAY]), this offers an additional way to provide\
    \ Domain Enumeration\n   configuration data for clients.\n   Note that this function\
    \ of the Discovery Proxy is supplementary to\n   the primary purpose of the Discovery\
    \ Proxy, which is to facilitate\n   _remote_ clients discovering services on the\
    \ Discovery Proxy's local\n   link.  This publication of Domain Enumeration configuration\
    \ data via\n   link-local multicast on the Discovery Proxy's local link is performed\n\
    \   for the benefit of _local_ clients attached to that link, and\n   typically\
    \ directs those clients to contact other distant Discovery\n   Proxies attached\
    \ to other links.  Generally, a client does not need\n   to use the local Discovery\
    \ Proxy on its own link, because a client is\n   generally able to perform its\
    \ own Multicast DNS queries on that link.\n   (The exception to this is when the\
    \ local Wi-Fi access point is\n   blocking or filtering local multicast traffic,\
    \ requiring even local\n   clients to use their local Discovery Proxy to perform\
    \ local\n   discovery.)\n   A Discovery Proxy can be configured to generate Multicast\
    \ DNS\n   responses for the following Multicast DNS Domain Enumeration queries\n\
    \   issued by clients:\n       b._dns-sd._udp.local.    PTR   ?\n       db._dns-sd._udp.local.\
    \   PTR   ?\n       lb._dns-sd._udp.local.   PTR   ?\n   This provides the ability\
    \ for Discovery Proxies to indicate\n   recommended browsing domains to DNS-SD\
    \ clients on a per-link\n   granularity.  In some enterprises, it may be preferable\
    \ to provide\n   this per-link configuration information in the form of Discovery\n\
    \   Proxy configuration data rather than by populating the Unicast DNS\n   servers\
    \ with the same data (in the \"ip6.arpa\" or \"in-addr.arpa\"\n   domains).\n\
    \   Regardless of how the network operator chooses to provide this\n   configuration\
    \ data, clients will perform Domain Enumeration via both\n   unicast and multicast\
    \ queries and then combine the results of these\n   queries.\n"
- title: 5.3.  Delegated Subdomain for LDH Host Names
  contents:
  - "5.3.  Delegated Subdomain for LDH Host Names\n   DNS-SD service instance names\
    \ and domains are allowed to contain\n   arbitrary Net-Unicode text [RFC5198],\
    \ encoded as precomposed UTF-8\n   [RFC3629].\n   Users typically interact with\
    \ service discovery software by viewing a\n   list of discovered service instance\
    \ names on a display and selecting\n   one of them by pointing, touching, or clicking.\
    \  Similarly, in\n   software that provides a multi-domain DNS-SD user interface,\
    \ users\n   view a list of offered domains on the display and select one of them\n\
    \   by pointing, touching, or clicking.  To use a service, users don't\n   have\
    \ to remember domain or instance names, or type them; users just\n   have to be\
    \ able to recognize what they see on the display and touch\n   or click on the\
    \ thing they want.\n   In contrast, host names are often remembered and typed.\
    \  Also, host\n   names have historically been used in command-line interfaces\
    \ where\n   spaces can be inconvenient.  For this reason, host names have\n  \
    \ traditionally been restricted to letters, digits, and hyphens (LDH)\n   with\
    \ no spaces or other punctuation.\n   While we do want to allow rich text for\
    \ DNS-SD service instance names\n   and domains, it is advisable, for maximum\
    \ compatibility with existing\n   usage, to restrict host names to the traditional\
    \ letter-digit-hyphen\n   rules.  This means that while the service name\n   \"\
    My Printer._ipp._tcp.Building 1.example.com\" is acceptable and\n   desirable\
    \ (it is displayed in a graphical user interface as an\n   instance called \"\
    My Printer\" in the domain \"Building 1\" at\n   \"example.com\"), the host name\
    \ \"My-Printer.Building 1.example.com\" is\n   less desirable (because of the\
    \ space in \"Building 1\").\n   To accommodate this difference in allowable characters,\
    \ a Discovery\n   Proxy SHOULD support having two separate subdomains delegated\
    \ to it\n   for each link it serves: one whose name is allowed to contain\n  \
    \ arbitrary Net-Unicode text [RFC5198], and a second more constrained\n   subdomain\
    \ whose name is restricted to contain only letters, digits,\n   and hyphens, to\
    \ be used for host name records (names of 'A' and\n   'AAAA' address records).\
    \  The restricted names may be any valid name\n   consisting of only letters,\
    \ digits, and hyphens, including Punycode-\n   encoded names [RFC3492].\n   For\
    \ example, a Discovery Proxy could have the two subdomains\n   \"Building 1.example.com\"\
    \ and \"bldg-1.example.com\" delegated to it.\n   The Discovery Proxy would then\
    \ translate these two Multicast DNS\n   records:\n      My Printer._ipp._tcp.local.\
    \ SRV 0 0 631 prnt.local.\n      prnt.local.                 A   203.0.113.2\n\
    \   into Unicast DNS records as follows:\n      My Printer._ipp._tcp.Building\
    \ 1.example.com.\n      prnt.bldg-1.example.com.     A   203.0.113.2\n   Note\
    \ that the SRV record name is translated using the rich-text\n   domain name (\"\
    Building 1.example.com\"), and the address record name\n   is translated using\
    \ the LDH domain (\"bldg-1.example.com\").  Further\n   details of the name translation\
    \ rules are described in Section 5.5.\n   A Discovery Proxy MAY support only a\
    \ single rich-text Net-Unicode\n   domain and use that domain for all records,\
    \ including 'A' and 'AAAA'\n   address records, but implementers choosing this\
    \ option should be\n   aware that this choice may produce host names that are\
    \ awkward to use\n   in command-line environments.  Whether or not this is an\
    \ issue\n   depends on whether users in the target environment are expected to\
    \ be\n   using command-line interfaces.\n   A Discovery Proxy MUST NOT be restricted\
    \ to support only a letter-\n   digit-hyphen subdomain, because that results in\
    \ an unnecessarily poor\n   user experience.\n   As described in Section 5.2.1,\
    \ for clarity, in examples here space\n   characters in names are shown as actual\
    \ spaces.  If this dynamically\n   discovered data were to be manually entered\
    \ into a textual zone file\n   (which it isn't), then spaces would need to be\
    \ represented using\n   '\\032', so \"My Printer._ipp._tcp.Building 1.example.com\"\
    \ would become\n   \"My\\032Printer._ipp._tcp.Building\\0321.example.com\".\n\
    \   Note that the '\\032' representation does not appear in DNS messages\n   sent\
    \ over the air.  In the wire format of DNS messages, spaces are\n   sent as spaces,\
    \ not as '\\032', and likewise, in a graphical user\n   interface at the client\
    \ device, spaces are shown as spaces, not as\n   '\\032'.\n"
- title: 5.4.  Delegated Subdomain for Reverse Mapping
  contents:
  - "5.4.  Delegated Subdomain for Reverse Mapping\n   A Discovery Proxy can facilitate\
    \ easier management of reverse mapping\n   domains, particularly for IPv6 addresses\
    \ where manual management may\n   be more onerous than it is for IPv4 addresses.\n\
    \   To achieve this, in the parent domain, NS records are used to\n   delegate\
    \ ownership of the appropriate reverse mapping domain to the\n   Discovery Proxy.\
    \  In other words, the Discovery Proxy becomes the\n   authoritative name server\
    \ for the reverse mapping domain.  For fault\n   tolerance reasons, there may\
    \ be more than one Discovery Proxy serving\n   a given link.\n   If a given link\
    \ is using the IPv4 subnet 203.0.113/24, then the\n   domain \"113.0.203.in-addr.arpa\"\
    \ is delegated to the Discovery Proxy\n   for that link.\n   If a given link is\
    \ using the IPv6 prefix 2001:0DB8:1234:5678::/64,\n   then the domain \"8.7.6.5.4.3.2.1.8.b.d.0.1.0.0.2.ip6.arpa\"\
    \ is\n   delegated to the Discovery Proxy for that link.\n   When a reverse mapping\
    \ query arrives at the Discovery Proxy, it\n   issues the identical query on its\
    \ local link, as a Multicast DNS\n   query.  The mechanism to force an apparently\
    \ unicast name to be\n   resolved using link-local Multicast DNS varies depending\
    \ on the API\n   set being used.  For example, in the \"dns_sd.h\" APIs (available\
    \ on\n   macOS, iOS, Bonjour for Windows, Linux, and Android), using\n   kDNSServiceFlagsForceMulticast\
    \ indicates that the\n   DNSServiceQueryRecord() call should perform the query\
    \ using Multicast\n   DNS.  Other API sets have different ways of forcing multicast\n\
    \   queries.  When the host owning that IPv4 or IPv6 address responds\n   with\
    \ a name of the form \"something.local\", the Discovery Proxy\n   rewrites it\
    \ to use its configured LDH host name domain instead of\n   \".local\" and returns\
    \ the response to the caller.\n   For example, a Discovery Proxy with the two\
    \ subdomains\n   \"113.0.203.in-addr.arpa\" and \"bldg-1.example.com\" delegated\
    \ to it\n   would translate this Multicast DNS record:\n      2.113.0.203.in-addr.arpa.\
    \ PTR prnt.local.\n   into this Unicast DNS response:\n      2.113.0.203.in-addr.arpa.\
    \ PTR prnt.bldg-1.example.com.\n   In this example the \"prnt.local\" host name\
    \ is translated using the\n   delegated LDH subdomain, as described in Section\
    \ 5.5.\n   Subsequent queries for the prnt.bldg-1.example.com address record,\n\
    \   falling as it does within the bldg-1.example.com domain, which is\n   delegated\
    \ to this Discovery Proxy, will arrive at this Discovery\n   Proxy where they\
    \ are answered by issuing Multicast DNS queries and\n   using the received Multicast\
    \ DNS answers to synthesize Unicast DNS\n   responses, as described above.\n \
    \  Note that this description assumes that all addresses on a given IPv4\n   subnet\
    \ or IPv6 prefix are mapped to host names using the Discovery\n   Proxy mechanism.\
    \  It would be possible to implement a Discovery Proxy\n   that can be configured\
    \ so that some address-to-name mappings are\n   performed using Multicast DNS\
    \ on the local link, while other address-\n   to-name mappings within the same\
    \ IPv4 subnet or IPv6 prefix are\n   configured manually.\n"
- title: 5.5.  Data Translation
  contents:
  - "5.5.  Data Translation\n   For the delegated rich-text and LDH subdomains, generating\n\
    \   appropriate Multicast DNS queries involves translating from the\n   configured\
    \ DNS domain (e.g., \"Building 1.example.com\") on the Unicast\n   DNS side to\
    \ \".local\" on the Multicast DNS side.\n   For the delegated reverse-mapping\
    \ subdomain, generating appropriate\n   Multicast DNS queries involves using the\
    \ appropriate API mechanism to\n   indicate that a query should be performed using\
    \ Multicast DNS, as\n   described in Section 5.4.\n   Generating appropriate Unicast\
    \ DNS responses from the received\n   Multicast DNS answers involves translating\
    \ back from \".local\" to the\n   appropriate configured Unicast DNS domain as\
    \ necessary, as described\n   below.\n   In the examples below, the delegated\
    \ subdomains are as follows:\n   Delegated subdomain for rich-text names     \
    \  Building 1.example.com.\n   Delegated subdomain for LDH names             \
    \    bldg-1.example.com.\n   Delegated subdomain for IPv4 reverse mapping  113.0.203.in-addr.arpa.\n\
    \   Names in Multicast DNS answers that do not end in \".local\" do not\n   require\
    \ any translation.\n   Names in Multicast DNS answers that end in \".local\" are\
    \ only\n   meaningful on the local link, and require translation to make them\n\
    \   useable by clients outside the local link.\n   Names that end in \".local\"\
    \ may appear both as the owner names of\n   received Multicast DNS answer records,\
    \ and in the RDATA of received\n   Multicast DNS answer records.\n   In a received\
    \ Multicast DNS answer record, if the owner name ends\n   with \".local\", then\
    \ the \".local\" top-level label is replaced with the\n   name of the delegated\
    \ subdomain as was used in the originating query.\n   In a received Multicast\
    \ DNS answer record, if a name in the RDATA\n   ends with \".local\", then the\
    \ name is translated according to the\n   delegated subdomain that was used in\
    \ the originating query, as\n   explained below.\n   For queries in subdomains\
    \ delegated for LDH host names, \".local\"\n   names in RDATA are translated to\
    \ that delegated LDH subdomain.  For\n   example, a query for \"thing.bldg-1.example.com\"\
    \ will be translated to\n   a Multicast DNS query for \"thing.local\".  If that\
    \ query returns this\n   CNAME record:\n     thing.local.               CNAME\
    \  prnt.local.\n   then both the owner name and the name in the RDATA are translated\n\
    \   from \".local\" to the LDH subdomain \"bldg-1.example.com\":\n     thing.bldg-1.example.com.\
    \  CNAME  prnt.bldg-1.example.com.\n   For queries in subdomains delegated for\
    \ reverse mapping names,\n   \".local\" names in RDATA are translated to the delegated\
    \ LDH\n   subdomain, if one is configured, or to the delegated rich-text\n   subdomain\
    \ otherwise.  For example, consider a reverse mapping query\n   that returns this\
    \ PTR record:\n     2.113.0.203.in-addr.arpa.  PTR  prnt.local.\n   The owner\
    \ name is not translated because it does not end in \".local\".\n   The name in\
    \ the RDATA is translated from \".local\" to the LDH\n   subdomain \"bldg-1.example.com\"\
    :\n     2.113.0.203.in-addr.arpa.  PTR  prnt.bldg-1.example.com.\n   For queries\
    \ in subdomains delegated for rich-text names, \".local\"\n   names in RDATA are\
    \ translated according to whether or not they\n   represent host names (i.e.,\
    \ RDATA names that are the owner names of A\n   and AAAA DNS records).  RDATA\
    \ names ending in \".local\" that represent\n   host names are translated to the\
    \ delegated LDH subdomain, if one is\n   configured, or to the delegated rich-text\
    \ subdomain otherwise.  All\n   other RDATA names ending in \".local\" are translated\
    \ to the delegated\n   rich-text subdomain.  For example, consider a DNS-SD service\
    \ browsing\n   PTR query that returns this PTR record for IPP printing:\n    \
    \ _ipp._tcp.local.  PTR  My Printer._ipp._tcp.local.\n   Both the owner name and\
    \ the name in the RDATA are translated from\n   \".local\" to the rich-text subdomain:\n\
    \     _ipp._tcp.Building 1.example.com.\n                       PTR  My Printer._ipp._tcp.Building\
    \ 1.example.com.\n   In contrast, consider a query that returns this SRV record\
    \ for a\n   specific IPP printing instance:\n     My Printer._ipp._tcp.local.\
    \  SRV  0 0 631 prnt.local.\n   As for all queries, the owner name is translated\
    \ to the delegated\n   subdomain of the originating query, the delegated rich-text\
    \ subdomain\n   \"Building 1.example.com\".  However, the \".local\" name in the\
    \ RDATA is\n   the target host name field of an SRV record, a field that is used\n\
    \   exclusively for host names.  Consequently it is translated to the LDH\n  \
    \ subdomain \"bldg-1.example.com\", if configured, instead of the rich-\n   text\
    \ subdomain:\n     My Printer._ipp._tcp.Building 1.example.com.\n   Other beneficial\
    \ translation and filtering operations are described\n   below.\n"
- title: 5.5.1.  DNS TTL Limiting
  contents:
  - "5.5.1.  DNS TTL Limiting\n   For efficiency, Multicast DNS typically uses moderately\
    \ high DNS TTL\n   values.  For example, the typical TTL on DNS-SD service browsing\
    \ PTR\n   records is 75 minutes.  What makes these moderately high TTLs\n   acceptable\
    \ is the cache coherency mechanisms built in to the\n   Multicast DNS protocol,\
    \ which protect against stale data persisting\n   for too long.  When a service\
    \ shuts down gracefully, it sends goodbye\n   packets to remove its service browsing\
    \ PTR record(s) immediately from\n   neighboring caches.  If a service shuts down\
    \ abruptly without sending\n   goodbye packets, the Passive Observation Of Failures\
    \ (POOF) mechanism\n   described in Section 10.5 of the Multicast DNS specification\n\
    \   [RFC6762] comes into play to purge the cache of stale data.\n   A traditional\
    \ Unicast DNS client on a distant remote link does not\n   get to participate\
    \ in these Multicast DNS cache coherency mechanisms\n   on the local link.  For\
    \ traditional Unicast DNS queries (those\n   received without using Long-Lived\
    \ Queries (LLQ) [RFC8764] or DNS Push\n   Notification subscriptions [RFC8765]),\
    \ the DNS TTLs reported in the\n   resulting Unicast DNS response MUST be capped\
    \ to be no more than ten\n   seconds.\n   Similarly, for negative responses, the\
    \ negative caching TTL indicated\n   in the SOA record [RFC2308] should also be\
    \ ten seconds (see\n   Section 6.1).\n   This value of ten seconds is chosen based\
    \ on user-experience\n   considerations.\n   For negative caching, suppose a user\
    \ is attempting to access a remote\n   device (e.g., a printer), and they are\
    \ unsuccessful because that\n   device is powered off.  Suppose they then place\
    \ a telephone call and\n   ask for the device to be powered on.  We want the device\
    \ to become\n   available to the user within a reasonable time period.  It is\n\
    \   reasonable to expect it to take on the order of ten seconds for a\n   simple\
    \ device with a simple embedded operating system to power on.\n   Once the device\
    \ is powered on and has announced its presence on the\n   network via Multicast\
    \ DNS, we would like it to take no more than a\n   further ten seconds for stale\
    \ negative cache entries to expire from\n   Unicast DNS caches, making the device\
    \ available to the user desiring\n   to access it.\n   Similar reasoning applies\
    \ to capping positive TTLs at ten seconds.\n   In the event of a device moving\
    \ location, getting a new DHCP address,\n   or other renumbering events, we would\
    \ like the updated information to\n   be available to remote clients in a relatively\
    \ timely fashion.\n   However, network administrators should be aware that many\
    \ recursive\n   resolvers by default are configured to impose a minimum TTL of\
    \ 30\n   seconds.  If stale data appears to be persisting in the network to\n\
    \   the extent that it adversely impacts user experience, network\n   administrators\
    \ are advised to check the configuration of their\n   recursive resolvers.\n \
    \  For received Unicast DNS queries that use LLQ [RFC8764] or DNS Push\n   Notifications\
    \ [RFC8765], the Multicast DNS record's TTL SHOULD be\n   returned unmodified,\
    \ because the notification channel exists to\n   inform the remote client as records\
    \ come and go.  For further details\n   about Long-Lived Queries and its newer\
    \ replacement, DNS Push\n   Notifications, see Section 5.6.\n"
- title: 5.5.2.  Suppressing Unusable Records
  contents:
  - "5.5.2.  Suppressing Unusable Records\n   A Discovery Proxy SHOULD offer a configurable\
    \ option, enabled by\n   default, to suppress Unicast DNS answers for records\
    \ that are not\n   useful outside the local link.  When the option to suppress\
    \ unusable\n   records is enabled:\n   *  For a Discovery Proxy that is serving\
    \ only clients outside the\n      local link, DNS A and AAAA records for IPv4\
    \ link-local addresses\n      [RFC3927] and IPv6 link-local addresses [RFC4862]\
    \ SHOULD be\n      suppressed.\n   *  Similarly, for sites that have multiple\
    \ private address realms\n      [RFC1918], in cases where the Discovery Proxy\
    \ can determine that\n      the querying client is in a different address realm,\
    \ private\n      addresses SHOULD NOT be communicated to that client.\n   *  IPv6\
    \ Unique Local Addresses [RFC4193] SHOULD be suppressed in\n      cases where\
    \ the Discovery Proxy can determine that the querying\n      client is in a different\
    \ IPv6 address realm.\n   *  By the same logic, DNS SRV records that reference\
    \ target host\n      names that have no addresses usable by the requester should\
    \ be\n      suppressed, and likewise, DNS-SD service browsing PTR records that\n\
    \      point to unusable SRV records should similarly be suppressed.\n"
- title: 5.5.3.  NSEC and NSEC3 Queries
  contents:
  - "5.5.3.  NSEC and NSEC3 Queries\n   Multicast DNS devices do not routinely announce\
    \ their records on the\n   network.  Generally, they remain silent until queried.\
    \  This means\n   that the complete set of Multicast DNS records in use on a link\
    \ can\n   only be discovered by active querying, not by passive listening.\n \
    \  Because of this, a Discovery Proxy can only know what names exist on\n   a\
    \ link by issuing queries for them, and since it would be impractical\n   to issue\
    \ queries for every possible name just to find out which names\n   exist and which\
    \ do not, a Discovery Proxy cannot programmatically\n   generate the traditional\
    \ Unicast DNS NSEC [RFC4034] and NSEC3\n   [RFC5155] records that assert the nonexistence\
    \ of a large range of\n   names.\n   When queried for an NSEC or NSEC3 record\
    \ type, the Discovery Proxy\n   issues a qtype \"ANY\" query using Multicast DNS\
    \ on the local link and\n   then generates an NSEC or NSEC3 response with a Type\
    \ Bit Map\n   signifying which record types do and do not exist for just the\n\
    \   specific name queried, and no other names.\n   Multicast DNS NSEC records\
    \ received on the local link MUST NOT be\n   forwarded unmodified to a unicast\
    \ querier, because there are slight\n   differences in the NSEC record data. \
    \ In particular, Multicast DNS\n   NSEC records do not have the NSEC bit set in\
    \ the Type Bit Map,\n   whereas conventional Unicast DNS NSEC records do have\
    \ the NSEC bit\n   set.\n"
- title: 5.5.4.  No Text-Encoding Translation
  contents:
  - "5.5.4.  No Text-Encoding Translation\n   A Discovery Proxy does no translation\
    \ between text encodings.\n   Specifically, a Discovery Proxy does no translation\
    \ between Punycode\n   encoding [RFC3492] and UTF-8 encoding [RFC3629], either\
    \ in the owner\n   name of DNS records or anywhere in the RDATA of DNS records\
    \ (such as\n   the RDATA of PTR records, SRV records, NS records, or other record\n\
    \   types like TXT, where it is ambiguous whether the RDATA may contain\n   DNS\
    \ names).  All bytes are treated as-is with no attempt at text-\n   encoding translation.\
    \  A client implementing DNS-based Service\n   Discovery [RFC6763] will use UTF-8\
    \ encoding for its unicast DNS-based\n   Service Discovery queries, which the\
    \ Discovery Proxy passes through\n   without any text-encoding translation to\
    \ the Multicast DNS subsystem.\n   Responses from the Multicast DNS subsystem\
    \ are similarly returned,\n   without any text-encoding translation, back to the\
    \ requesting unicast\n   client.\n"
- title: 5.5.5.  Application-Specific Data Translation
  contents:
  - "5.5.5.  Application-Specific Data Translation\n   There may be cases where Application-Specific\
    \ Data Translation is\n   appropriate.\n   For example, AirPrint printers tend\
    \ to advertise fairly verbose\n   information about their capabilities in their\
    \ DNS-SD TXT record.  TXT\n   record sizes in the range of 500-1000 bytes are\
    \ not uncommon.  This\n   information is a legacy from lineprinter (LPR) printing,\
    \ because LPR\n   does not have in-band capability negotiation, so all of this\n\
    \   information is conveyed using the DNS-SD TXT record instead.\n   Internet\
    \ Printing Protocol (IPP) printing does have in-band\n   capability negotiation,\
    \ but for convenience, printers tend to include\n   the same capability information\
    \ in their IPP DNS-SD TXT records as\n   well.  For local Multicast DNS (mDNS)\
    \ use, this extra TXT record\n   information is wasteful but not fatal.  However,\
    \ when a Discovery\n   Proxy aggregates data from multiple printers on a link,\
    \ and sends it\n   via unicast (via UDP or TCP), this amount of unnecessary TXT\
    \ record\n   information can result in large responses.  A DNS reply over TCP\n\
    \   carrying information about 70 printers with an average of 700 bytes\n   per\
    \ printer adds up to about 50 kilobytes of data.  Therefore, a\n   Discovery Proxy\
    \ that is aware of the specifics of an application-\n   layer protocol such as\
    \ AirPrint (which uses IPP) can elide\n   unnecessary key/value pairs from the\
    \ DNS-SD TXT record for better\n   network efficiency.\n   Also, the DNS-SD TXT\
    \ record for many printers contains an \"adminurl\"\n   key (e.g., \"adminurl=http://printername.local/status.html\"\
    ).  For\n   this URL to be useful outside the local link, the embedded \".local\"\
    \n   host name needs to be translated to an appropriate name with larger\n   scope.\
    \  It is easy to translate \".local\" names when they appear in\n   well-defined\
    \ places: as a record's owner name, or in domain name\n   fields in the RDATA\
    \ of record types like PTR and SRV.  In the\n   printing case, some application-specific\
    \ knowledge about the\n   semantics of the \"adminurl\" key is needed for the\
    \ Discovery Proxy to\n   know that it contains a name that needs to be translated.\
    \  This is\n   somewhat analogous to the need for NAT gateways to contain ALGs\n\
    \   (Application-Level Gateways) to facilitate the correct translation of\n  \
    \ protocols that embed addresses in unexpected places.\n   To avoid the need for\
    \ application-specific knowledge about the\n   semantics of particular TXT record\
    \ keys, protocol designers are\n   advised to avoid placing link-local names or\
    \ link-local IP addresses\n   in TXT record keys if translation of those names\
    \ or addresses would\n   be required for off-link operation.  In the printing\
    \ case, the\n   consequence of failing to translate the \"adminurl\" key correctly\n\
    \   would be that, when accessed from a different link, printing will\n   still\
    \ work, but clicking the \"Admin\" user interface button will fail\n   to open\
    \ the printer's administration page.  Rather than duplicating\n   the host name\
    \ from the service's SRV record in its \"adminurl\" key,\n   thereby having the\
    \ same host name appear in two places, a better\n   design might have been to\
    \ omit the host name from the \"adminurl\" key\n   and instead have the client\
    \ implicitly substitute the target host\n   name from the service's SRV record\
    \ in place of a missing host name in\n   the \"adminurl\" key.  That way, the\
    \ desired host name only appears\n   once and is in a well-defined place where\
    \ software like the Discovery\n   Proxy is expecting to find it.\n   Note that\
    \ this kind of Application-Specific Data Translation is\n   expected to be very\
    \ rare; it is the exception rather than the rule.\n   This is an example of a\
    \ common theme in computing.  It is frequently\n   the case that it is wise to\
    \ start with a clean, layered design with\n   clear boundaries.  Then, in certain\
    \ special cases, those layer\n   boundaries may be violated where the performance\
    \ and efficiency\n   benefits outweigh the inelegance of the layer violation.\n\
    \   These layer violations are optional.  They are done primarily for\n   efficiency\
    \ reasons and generally should not be required for correct\n   operation.  A Discovery\
    \ Proxy MAY operate solely at the mDNS layer\n   without any knowledge of semantics\
    \ at the DNS-SD layer or above.\n"
- title: 5.6.  Answer Aggregation
  contents:
  - "5.6.  Answer Aggregation\n   In a simple analysis, simply gathering multicast\
    \ answers and\n   forwarding them in a unicast response seems adequate, but it\
    \ raises\n   the question of how long the Discovery Proxy should wait to be sure\n\
    \   that it has received all the Multicast DNS answers it needs to form a\n  \
    \ complete Unicast DNS response.  If it waits too little time, then it\n   risks\
    \ its Unicast DNS response being incomplete.  If it waits too\n   long, then it\
    \ creates a poor user experience at the client end.  In\n   fact, there may be\
    \ no time that is both short enough to produce a\n   good user experience and\
    \ at the same time long enough to reliably\n   produce complete results.\n   Similarly,\
    \ the Discovery Proxy (the authoritative name server for the\n   subdomain in\
    \ question) needs to decide what DNS TTL to report for\n   these records.  If\
    \ the TTL is too long, then the recursive resolvers\n   issuing queries on behalf\
    \ of their clients risk caching stale data\n   for too long.  If the TTL is too\
    \ short, then the amount of network\n   traffic will be more than necessary. \
    \ In fact, there may be no TTL\n   that is both short enough to avoid undesirable\
    \ stale data and, at the\n   same time, long enough to be efficient on the network.\n\
    \   Both these dilemmas are solved by the use of DNS Long-Lived Queries\n   (LLQ)\
    \ [RFC8764] or its newer replacement, DNS Push Notifications\n   [RFC8765].\n\
    \   Clients supporting unicast DNS-based Service Discovery SHOULD\n   implement\
    \ DNS Push Notifications [RFC8765] for improved user\n   experience.\n   Clients\
    \ and Discovery Proxies MAY support both LLQ and DNS Push\n   Notifications, and\
    \ when talking to a Discovery Proxy that supports\n   both, the client may use\
    \ either protocol, as it chooses, though it is\n   expected that only DNS Push\
    \ Notifications will continue to be\n   supported in the long run.\n   When a\
    \ Discovery Proxy receives a query using LLQ or DNS Push\n   Notifications, it\
    \ responds immediately using the Multicast DNS\n   records it already has in its\
    \ cache (if any).  This provides a good\n   client user experience by providing\
    \ a near-instantaneous response.\n   Simultaneously, the Discovery Proxy issues\
    \ a Multicast DNS query on\n   the local link to discover if there are any additional\
    \ Multicast DNS\n   records it did not already know about.  Should additional\
    \ Multicast\n   DNS responses be received, these are then delivered to the client\n\
    \   using additional LLQ or DNS Push Notification update messages.  The\n   timeliness\
    \ of such update messages is limited only by the timeliness\n   of the device\
    \ responding to the Multicast DNS query.  If the\n   Multicast DNS device responds\
    \ quickly, then the update message is\n   delivered quickly.  If the Multicast\
    \ DNS device responds slowly, then\n   the update message is delivered slowly.\
    \  The benefit of using\n   multiple update messages to deliver results as they\
    \ become available\n   is that the Discovery Proxy can respond promptly because\
    \ it doesn't\n   have to deliver all the results in a single response that needs\
    \ to be\n   delayed to allow for the expected worst-case delay for receiving all\n\
    \   the Multicast DNS responses.\n   With a proxy that supported only standard\
    \ DNS queries, even if it\n   were to try to provide reliability by assuming an\
    \ excessively\n   pessimistic worst-case time (thereby giving a very poor user\n\
    \   experience), there would still be the risk of a slow Multicast DNS\n   device\
    \ taking even longer than that worst-case time (e.g., a device\n   that is not\
    \ even powered on until ten seconds after the initial query\n   is received),\
    \ resulting in incomplete responses.  Using update\n   messages to deliver subsequent\
    \ asynchronous replies solves this\n   dilemma: even very late responses are not\
    \ lost; they are delivered in\n   subsequent update messages.\n   Note that while\
    \ normal DNS queries are generally received via the\n   client's configured recursive\
    \ resolver, LLQ and DNS Push Notification\n   subscriptions may be received directly\
    \ from the client.\n   There are two factors that determine how unicast responses\
    \ are\n   generated:\n   The first factor is whether or not the Discovery Proxy\
    \ already has at\n   least one record in its cache that answers the question.\n\
    \   The second factor is whether the client used a normal DNS query, or\n   established\
    \ a subscription using LLQ or DNS Push Notifications.\n   Normal DNS queries are\
    \ typically used for one-shot operations like\n   SRV or address record queries.\
    \  LLQ and DNS Push Notification\n   subscriptions are typically used for long-lived\
    \ service browsing PTR\n   queries.  Normal DNS queries and LLQ each have different\
    \ response\n   timing depending on the cache state, yielding the first four cases\n\
    \   listed below.  DNS Push Notifications, the newer protocol, has\n   uniform\
    \ behavior regardless of cache state, yielding the fifth case\n   listed below.\n\
    \   *  Standard DNS query; no answer in cache:\n      Issue an mDNS query on the\
    \ local link, exactly as a local client\n      would issue an mDNS query, for\
    \ the desired record name, type, and\n      class, including retransmissions,\
    \ as appropriate, according to the\n      established mDNS retransmission schedule\
    \ [RFC6762].  The Discovery\n      Proxy awaits Multicast DNS responses.\n   \
    \   As soon as any Multicast DNS response packet is received that\n      contains\
    \ one or more positive answers to that question (with or\n      without the Cache\
    \ Flush bit [RFC6762] set) or a negative answer\n      (signified via a Multicast\
    \ DNS NSEC record [RFC6762]), the\n      Discovery Proxy generates a Unicast DNS\
    \ response message\n      containing the corresponding (filtered and translated)\
    \ answers and\n      sends it to the remote client.\n      If after six seconds\
    \ no relevant Multicast DNS answers have been\n      received, cancel the mDNS\
    \ query and return a negative response to\n      the remote client.  Six seconds\
    \ is enough time for the underlying\n      Multicast DNS subsystem to transmit\
    \ three mDNS queries and allow\n      some time for responses to arrive.\n   \
    \   (Reasoning: Queries not using LLQ or Push Notifications are\n      generally\
    \ queries that expect an answer from only one device, so\n      the first response\
    \ is also the only response.)\n      DNS TTLs in responses MUST be capped to at\
    \ most ten seconds.\n   *  Standard DNS query; at least one answer in cache:\n\
    \      No local mDNS queries are performed.\n      The Discovery Proxy generates\
    \ a Unicast DNS response message\n      containing the answer(s) from the cache\
    \ right away, to minimize\n      delay.\n      (Reasoning: Queries not using LLQ\
    \ or Push Notifications are\n      generally queries that expect an answer from\
    \ only one device.\n      Given RRSet TTL harmonization, if the proxy has one\
    \ Multicast DNS\n      answer in its cache, it can reasonably assume that it has\
    \ the\n      whole set.)\n      DNS TTLs in responses MUST be capped to at most\
    \ ten seconds.\n   *  Long-Lived Query (LLQ); no answer in cache:\n      As in\
    \ the case above with no answer in the cache, plan to perform\n      mDNS querying\
    \ for six seconds, returning an LLQ response message\n      to the remote client\
    \ as soon as any relevant mDNS response is\n      received.\n      If after six\
    \ seconds no relevant mDNS answers have been received,\n      and the client has\
    \ not cancelled its Long-Lived Query, return a\n      negative LLQ response message\
    \ to the remote client.\n      (Reasoning: We don't need to rush to send an empty\
    \ answer.)\n      Regardless of whether or not a relevant mDNS response is received\n\
    \      within six seconds, the Long-Lived Query remains active for as\n      long\
    \ as the client maintains the LLQ state, and results in the\n      ongoing transmission\
    \ of mDNS queries until the Long-Lived Query is\n      cancelled.  If the set\
    \ of mDNS answers changes, LLQ Event Response\n      messages are sent.\n    \
    \  DNS TTLs in responses are returned unmodified.\n   *  Long-Lived Query (LLQ);\
    \ at least one answer in cache:\n      As in the case above with at least one\
    \ answer in the cache, the\n      Discovery Proxy generates a unicast LLQ response\
    \ message\n      containing the answer(s) from the cache right away, to minimize\n\
    \      delay.\n      The Long-Lived Query remains active for as long as the client\n\
    \      maintains the LLQ state, and results in the transmission of mDNS\n    \
    \  queries (with appropriate Known Answer lists) to determine if\n      further\
    \ answers are available.  If the set of mDNS answers\n      changes, LLQ Event\
    \ Response messages are sent.\n      (Reasoning: We want a user interface that\
    \ is displayed very\n      rapidly yet continues to remain accurate even as the\
    \ network\n      environment changes.)\n      DNS TTLs in responses are returned\
    \ unmodified.\n   *  Push Notification Subscription\n      The Discovery Proxy\
    \ acknowledges the subscription request\n      immediately.\n      If one or more\
    \ answers are already available in the cache, those\n      answers are then sent\
    \ in an immediately following DNS PUSH\n      message.\n      The Push Notification\
    \ subscription remains active until the client\n      cancels the subscription,\
    \ and results in the transmission of mDNS\n      queries (with appropriate Known\
    \ Answer lists) to determine if\n      further answers are available.  If the\
    \ set of mDNS answers\n      changes, further DNS PUSH messages are sent.\n  \
    \    (Reasoning: We want a user interface that is displayed very\n      rapidly\
    \ yet continues to remain accurate even as the network\n      environment changes.)\n\
    \      DNS TTLs in responses are returned unmodified.\n   Where the text above\
    \ refers to returning \"a negative response to the\n   remote client\", it is\
    \ describing returning a \"no error no answer\"\n   negative response, not NXDOMAIN.\
    \  This is because the Discovery Proxy\n   cannot know all the Multicast DNS domain\
    \ names that may exist on a\n   link at any given time, so any name with no answers\
    \ may have child\n   names that do exist, making it an \"empty non-terminal\"\
    \ name.\n   Note that certain aspects of the behavior described here do not have\n\
    \   to be implemented overtly by the Discovery Proxy; they occur\n   naturally\
    \ as a result of using existing Multicast DNS APIs.\n   For example, in the first\
    \ case above (standard DNS query and no\n   answers in the cache), if a new Multicast\
    \ DNS query is requested\n   (either by a local client on the Discovery Proxy\
    \ device, or by the\n   Discovery Proxy software on that device on behalf of a\
    \ remote\n   client), and there is not already an identical Multicast DNS query\n\
    \   active and there are no matching answers already in the Multicast DNS\n  \
    \ cache on the Discovery Proxy device, then this will cause a series of\n   Multicast\
    \ DNS query packets to be issued with exponential backoff.\n   The exponential\
    \ backoff sequence in some implementations starts at\n   one second and then doubles\
    \ for each retransmission (0, 1, 3, 7\n   seconds, etc.), and in others, it starts\
    \ at one second and then\n   triples for each retransmission (0, 1, 4, 13 seconds,\
    \ etc.).  In\n   either case, if no response has been received after six seconds,\
    \ that\n   is long enough that the underlying Multicast DNS implementation will\n\
    \   have sent three query packets without receiving any response.  At\n   that\
    \ point, the Discovery Proxy cancels its Multicast DNS query (so\n   no further\
    \ Multicast DNS query packets will be sent for this query)\n   and returns a negative\
    \ response to the remote client via unicast.\n   The six-second delay is chosen\
    \ to be long enough to give enough time\n   for devices to respond, yet short\
    \ enough not to be too onerous for a\n   human user waiting for a response.  For\
    \ example, using the \"dig\" DNS\n   debugging tool, the current default settings\
    \ result in it waiting a\n   total of 15 seconds for a reply (three transmissions\
    \ of the DNS UDP\n   query packet, with a wait of 5 seconds after each packet),\
    \ which is\n   ample time for it to have received a negative reply from a Discovery\n\
    \   Proxy after six seconds.\n   The text above states that for a standard DNS\
    \ query, if at least one\n   answer is already available in the cache, then a\
    \ Discovery Proxy\n   should not issue additional mDNS query packets.  This also\
    \ occurs\n   naturally as a result of using existing Multicast DNS APIs.  If a\
    \ new\n   Multicast DNS query is requested (either locally, or by the Discovery\n\
    \   Proxy on behalf of a remote client) for which there are relevant\n   answers\
    \ already in the Multicast DNS cache on the Discovery Proxy\n   device, and after\
    \ the answers are delivered the Multicast DNS query\n   is immediately cancelled,\
    \ then no Multicast DNS query packets will be\n   generated for this query.\n"
- title: 6.  Administrative DNS Records
  contents:
  - '6.  Administrative DNS Records

    '
- title: 6.1.  DNS SOA (Start of Authority) Record
  contents:
  - "6.1.  DNS SOA (Start of Authority) Record\n   The MNAME field SHOULD contain\
    \ the host name of the Discovery Proxy\n   device (i.e., the same domain name\
    \ as the RDATA of the NS record\n   delegating the relevant zone(s) to this Discovery\
    \ Proxy device).\n   The RNAME field SHOULD contain the mailbox of the person\
    \ responsible\n   for administering this Discovery Proxy device.\n   The SERIAL\
    \ field MUST be zero.\n   Zone transfers are undefined for Discovery Proxy zones,\
    \ and\n   consequently, the REFRESH, RETRY, and EXPIRE fields have no useful\n\
    \   meaning for Discovery Proxy zones.  These fields SHOULD contain\n   reasonable\
    \ default values.  The RECOMMENDED values are: REFRESH 7200,\n   RETRY 3600, and\
    \ EXPIRE 86400.\n   The MINIMUM field (used to control the lifetime of negative\
    \ cache\n   entries) SHOULD contain the value 10.  This value is chosen based\
    \ on\n   user-experience considerations (see Section 5.5.1).\n   In the event\
    \ that there are multiple Discovery Proxy devices on a\n   link for fault tolerance\
    \ reasons, this will result in clients\n   receiving inconsistent SOA records\
    \ (different MNAME and possibly\n   RNAME) depending on which Discovery Proxy\
    \ answers their SOA query.\n   However, since clients generally have no reason\
    \ to use the MNAME or\n   RNAME data, this is unlikely to cause any problems.\n"
- title: 6.2.  DNS NS Records
  contents:
  - "6.2.  DNS NS Records\n   In the event that there are multiple Discovery Proxy\
    \ devices on a\n   link for fault tolerance reasons, the parent zone MUST be configured\n\
    \   with NS records giving the names of all the Discovery Proxy devices\n   on\
    \ the link.\n   Each Discovery Proxy device MUST be configured to answer NS queries\n\
    \   for the zone apex name by giving its own NS record, and the NS\n   records\
    \ of its fellow Discovery Proxy devices on the same link, so\n   that it can return\
    \ the correct answers for NS queries.\n   The target host name in the RDATA of\
    \ an NS record MUST NOT reference\n   a name that falls within any zone delegated\
    \ to a Discovery Proxy.\n   Apart from the zone apex name, all other host names\
    \ (names of A and\n   AAAA DNS records) that fall within a zone delegated to a\
    \ Discovery\n   Proxy correspond to local Multicast DNS host names, which logically\n\
    \   belong to the respective Multicast DNS hosts defending those names,\n   not\
    \ the Discovery Proxy.  Generally speaking, the Discovery Proxy\n   does not own\
    \ or control the delegated zone; it is merely a conduit to\n   the corresponding\
    \ \".local\" namespace, which is controlled by the\n   Multicast DNS hosts on\
    \ that link.  If an NS record were to reference\n   a manually determined host\
    \ name that falls within a delegated zone,\n   that manually determined host name\
    \ may inadvertently conflict with a\n   corresponding \".local\" host name that\
    \ is owned and controlled by some\n   device on that link.\n"
- title: 6.3.  DNS Delegation Records
  contents:
  - "6.3.  DNS Delegation Records\n   Since the Multicast DNS specification [RFC6762]\
    \ states that there can\n   be no delegation (subdomains) within a \".local\"\
    \ namespace, this\n   implies that any name within a zone delegated to a Discovery\
    \ Proxy\n   (except for the zone apex name itself) cannot have any answers for\n\
    \   any DNS queries for RRTYPEs SOA, NS, or DS.  Consequently:\n   *  for any\
    \ query for the zone apex name of a zone delegated to a\n      Discovery Proxy,\
    \ the Discovery Proxy MUST generate the appropriate\n      immediate answers as\
    \ described above, and\n   *  for any query for any name below the zone apex,\
    \ for RRTYPEs SOA,\n      NS, or DS, the Discovery Proxy MUST generate an immediate\
    \ negative\n      answer.\n"
- title: 6.4.  DNS SRV Records
  contents:
  - "6.4.  DNS SRV Records\n   There are certain special DNS records that logically\
    \ fall within the\n   delegated Unicast DNS subdomain, but rather than mapping\
    \ to their\n   corresponding \".local\" namesakes, they actually contain metadata\n\
    \   pertaining to the operation of the delegated Unicast DNS subdomain\n   itself.\
    \  They do not exist in the corresponding \".local\" namespace of\n   the local\
    \ link.  For these queries, a Discovery Proxy MUST generate\n   immediate answers,\
    \ whether positive or negative, to avoid delays\n   while clients wait for their\
    \ query to be answered.\n   For example, if a Discovery Proxy implements Long-Lived\
    \ Queries\n   [RFC8764], then it MUST positively respond to\n   \"_dns-llq._udp.<zone>\
    \ SRV\" queries, \"_dns-llq._tcp.<zone> SRV\"\n   queries, and \"_dns-llq-tls._tcp.<zone>\
    \ SRV\" queries as appropriate.\n   If it does not implement Long-Lived Queries,\
    \ it MUST return an\n   immediate negative answer for those queries, instead of\
    \ passing those\n   queries through to the local network as Multicast DNS queries\
    \ and\n   then waiting unsuccessfully for answers that will not be forthcoming.\n\
    \   If a Discovery Proxy implements DNS Push Notifications [RFC8765],\n   then\
    \ it MUST positively respond to \"_dns-push-tls._tcp.<zone>\"\n   queries.  Otherwise,\
    \ it MUST return an immediate negative answer for\n   those queries.\n   A Discovery\
    \ Proxy MUST return an immediate negative answer for\n   \"_dns-update._udp.<zone>\
    \ SRV\" queries, \"_dns-update._tcp.<zone> SRV\"\n   queries, and \"_dns-update-tls._tcp.<zone>\
    \ SRV\" queries, since using\n   DNS Update [RFC2136] to change zones generated\
    \ dynamically from local\n   Multicast DNS data is not possible.\n"
- title: 6.5.  Domain Enumeration Records
  contents:
  - "6.5.  Domain Enumeration Records\n   If the network operator chooses to use address-based\
    \ unicast Domain\n   Enumeration queries for client configuration (see Section\
    \ 5.2.1), and\n   the network operator also chooses to delegate the enclosing\
    \ reverse\n   mapping subdomain to a Discovery Proxy, then that Discovery Proxy\n\
    \   becomes responsible for serving the answers to those address-based\n   unicast\
    \ Domain Enumeration queries.\n   As with the SRV metadata records described above,\
    \ a Discovery Proxy\n   configured with delegated reverse mapping subdomains is\
    \ responsible\n   for generating immediate (positive or negative) answers for\
    \ address-\n   based unicast Domain Enumeration queries, rather than passing them\n\
    \   though to the underlying Multicast DNS subsystem and then waiting\n   unsuccessfully\
    \ for answers that will not be forthcoming.\n"
- title: 7.  DNSSEC Considerations
  contents:
  - '7.  DNSSEC Considerations

    '
- title: 7.1.  Online Signing Only
  contents:
  - "7.1.  Online Signing Only\n   The Discovery Proxy acts as the authoritative name\
    \ server for\n   designated subdomains, and if DNSSEC is to be used, the Discovery\n\
    \   Proxy needs to possess a copy of the signing keys in order to\n   generate\
    \ authoritative signed data from the local Multicast DNS\n   responses it receives.\
    \  Offline signing is not applicable to\n   Discovery Proxy.\n"
- title: 7.2.  NSEC and NSEC3 Records
  contents:
  - "7.2.  NSEC and NSEC3 Records\n   In DNSSEC, NSEC and NSEC3 records are used to\
    \ assert the nonexistence\n   of certain names, also described as \"authenticated\
    \ denial of\n   existence\" [RFC4034] [RFC5155].\n   Since a Discovery Proxy only\
    \ knows what names exist on the local link\n   by issuing queries for them, and\
    \ since it would be impractical to\n   issue queries for every possible name just\
    \ to find out which names\n   exist and which do not, a Discovery Proxy cannot\
    \ programmatically\n   synthesize the traditional NSEC and NSEC3 records that\
    \ assert the\n   nonexistence of a large range of names.  Instead, when generating\
    \ a\n   negative response, a Discovery Proxy programmatically synthesizes a\n\
    \   single NSEC record asserting the nonexistence of just the specific\n   name\
    \ queried and no others.  Since the Discovery Proxy has the zone\n   signing key,\
    \ it can do this on demand.  Since the NSEC record asserts\n   the nonexistence\
    \ of only a single name, zone walking is not a\n   concern, and NSEC3 is therefore\
    \ not necessary.\n   Note that this applies only to traditional immediate DNS\
    \ queries,\n   which may return immediate negative answers when no immediate\n\
    \   positive answer is available.  When used with a DNS Push Notification\n  \
    \ subscription [RFC8765], there are no negative answers, merely the\n   absence\
    \ of answers so far, which may change in the future if answers\n   become available.\n"
- title: 8.  IPv6 Considerations
  contents:
  - "8.  IPv6 Considerations\n   An IPv4-only host and an IPv6-only host behave as\
    \ \"ships that pass in\n   the night\".  Even if they are on the same Ethernet\
    \ [IEEE-3], neither\n   is aware of the other's traffic.  For this reason, each\
    \ link may have\n   _two_ unrelated \".local.\" zones: one for IPv4 and one for\
    \ IPv6.\n   Since, for practical purposes, a group of IPv4-only hosts and a group\n\
    \   of IPv6-only hosts on the same Ethernet act as if they were on two\n   entirely\
    \ separate Ethernet segments, it is unsurprising that their\n   use of the \"\
    .local.\" zone should occur exactly as it would if they\n   really were on two\
    \ entirely separate Ethernet segments.\n   It will be desirable to have a mechanism\
    \ to \"stitch\" together these\n   two unrelated \".local.\" zones so that they\
    \ appear as one.  Such a\n   mechanism will need to be able to differentiate between\
    \ a dual-stack\n   (v4/v6) host participating in both \".local.\" zones, and two\
    \ different\n   hosts: one IPv4-only and the other IPv6-only, which are both trying\n\
    \   to use the same name(s).  Such a mechanism will be specified in a\n   future\
    \ companion document.\n   At present, it is RECOMMENDED that a Discovery Proxy\
    \ be configured\n   with a single domain name for both the IPv4 and IPv6 \".local.\"\
    \ zones\n   on the local link, and when a unicast query is received, it should\n\
    \   issue Multicast DNS queries using both IPv4 and IPv6 on the local\n   link\
    \ and then combine the results.\n"
- title: 9.  Security Considerations
  contents:
  - '9.  Security Considerations

    '
- title: 9.1.  Authenticity
  contents:
  - "9.1.  Authenticity\n   A service proves its presence on a link by its ability\
    \ to answer\n   link-local multicast queries on that link.  If greater security\
    \ is\n   desired, then the Discovery Proxy mechanism should not be used, and\n\
    \   something with stronger security should be used instead such as\n   authenticated\
    \ secure DNS Update [RFC2136] [RFC3007].\n"
- title: 9.2.  Privacy
  contents:
  - "9.2.  Privacy\n   The Domain Name System is, generally speaking, a global public\n\
    \   database.  Records that exist in the Domain Name System name\n   hierarchy\
    \ can be queried by name from, in principle, anywhere in the\n   world.  If services\
    \ on a mobile device (like a laptop computer) are\n   made visible via the Discovery\
    \ Proxy mechanism, then when those\n   services become visible in a domain such\
    \ as \"My House.example.com\",\n   it might indicate to (potentially hostile)\
    \ observers that the mobile\n   device is in the owner's home.  When those services\
    \ disappear from\n   \"My House.example.com\", that change could be used by observers\
    \ to\n   infer when the mobile device (and possibly its owner) may have left\n\
    \   the house.  The privacy of this information may be protected using\n   techniques\
    \ like firewalls, split-view DNS, and Virtual Private\n   Networks (VPNs), as\
    \ are customarily used today to protect the privacy\n   of corporate DNS information.\n\
    \   The privacy issue is particularly serious for the IPv4 and IPv6\n   reverse\
    \ zones.  If the public delegation of the reverse zones points\n   to the Discovery\
    \ Proxy, and the Discovery Proxy is reachable\n   globally, then it could leak\
    \ a significant amount of information.\n   Attackers could discover hosts that\
    \ otherwise might not be easy to\n   identify, and learn their host names.  Attackers\
    \ could also discover\n   the existence of links where hosts frequently come and\
    \ go.\n   The Discovery Proxy could provide sensitive records only to\n   authenticated\
    \ users.  This is a general DNS problem, not specific to\n   the Discovery Proxy.\
    \  Work is underway in the IETF to tackle this\n   problem [RFC7626].\n"
- title: 9.3.  Denial of Service
  contents:
  - "9.3.  Denial of Service\n   A remote attacker could use a rapid series of unique\
    \ Unicast DNS\n   queries to induce a Discovery Proxy to generate a rapid series\
    \ of\n   corresponding Multicast DNS queries on one or more of its local\n   links.\
    \  Multicast traffic is generally more expensive than unicast\n   traffic, especially\
    \ on Wi-Fi links [MCAST], which makes this attack\n   particularly serious.  To\
    \ limit the damage that can be caused by such\n   attacks, a Discovery Proxy (or\
    \ the underlying Multicast DNS subsystem\n   that it utilizes) MUST implement\
    \ Multicast DNS query rate limiting\n   appropriate to the link technology in\
    \ question.  For today's\n   802.11b/g/n/ac Wi-Fi links (for which approximately\
    \ 200 multicast\n   packets per second is sufficient to consume approximately\
    \ 100% of the\n   wireless spectrum), a limit of 20 Multicast DNS query packets\
    \ per\n   second is RECOMMENDED.  On other link technologies like Gigabit\n  \
    \ Ethernet, higher limits may be appropriate.  A consequence of this\n   rate\
    \ limiting is that a rogue remote client could issue an excessive\n   number of\
    \ queries resulting in denial of service to other legitimate\n   remote clients\
    \ attempting to use that Discovery Proxy.  However, this\n   is preferable to\
    \ a rogue remote client being able to inflict even\n   greater harm on the local\
    \ network, which could impact the correct\n   operation of all local clients on\
    \ that network.\n"
- title: 10.  IANA Considerations
  contents:
  - "10.  IANA Considerations\n   This document has no IANA actions.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [RFC1034]  Mockapetris, P., \"Domain names -\
    \ concepts and facilities\",\n              STD 13, RFC 1034, DOI 10.17487/RFC1034,\
    \ November 1987,\n              <https://www.rfc-editor.org/info/rfc1034>.\n \
    \  [RFC1035]  Mockapetris, P., \"Domain names - implementation and\n         \
    \     specification\", STD 13, RFC 1035, DOI 10.17487/RFC1035,\n             \
    \ November 1987, <https://www.rfc-editor.org/info/rfc1035>.\n   [RFC1918]  Rekhter,\
    \ Y., Moskowitz, B., Karrenberg, D., de Groot, G.\n              J., and E. Lear,\
    \ \"Address Allocation for Private\n              Internets\", BCP 5, RFC 1918,\
    \ DOI 10.17487/RFC1918,\n              February 1996, <https://www.rfc-editor.org/info/rfc1918>.\n\
    \   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n        \
    \      Requirement Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119,\
    \ March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC2308]\
    \  Andrews, M., \"Negative Caching of DNS Queries (DNS\n              NCACHE)\"\
    , RFC 2308, DOI 10.17487/RFC2308, March 1998,\n              <https://www.rfc-editor.org/info/rfc2308>.\n\
    \   [RFC3629]  Yergeau, F., \"UTF-8, a transformation format of ISO\n        \
    \      10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November\n           \
    \   2003, <https://www.rfc-editor.org/info/rfc3629>.\n   [RFC3927]  Cheshire,\
    \ S., Aboba, B., and E. Guttman, \"Dynamic\n              Configuration of IPv4\
    \ Link-Local Addresses\", RFC 3927,\n              DOI 10.17487/RFC3927, May 2005,\n\
    \              <https://www.rfc-editor.org/info/rfc3927>.\n   [RFC4034]  Arends,\
    \ R., Austein, R., Larson, M., Massey, D., and S.\n              Rose, \"Resource\
    \ Records for the DNS Security Extensions\",\n              RFC 4034, DOI 10.17487/RFC4034,\
    \ March 2005,\n              <https://www.rfc-editor.org/info/rfc4034>.\n   [RFC4862]\
    \  Thomson, S., Narten, T., and T. Jinmei, \"IPv6 Stateless\n              Address\
    \ Autoconfiguration\", RFC 4862,\n              DOI 10.17487/RFC4862, September\
    \ 2007,\n              <https://www.rfc-editor.org/info/rfc4862>.\n   [RFC5155]\
    \  Laurie, B., Sisson, G., Arends, R., and D. Blacka, \"DNS\n              Security\
    \ (DNSSEC) Hashed Authenticated Denial of\n              Existence\", RFC 5155,\
    \ DOI 10.17487/RFC5155, March 2008,\n              <https://www.rfc-editor.org/info/rfc5155>.\n\
    \   [RFC5198]  Klensin, J. and M. Padlipsky, \"Unicode Format for Network\n  \
    \            Interchange\", RFC 5198, DOI 10.17487/RFC5198, March 2008,\n    \
    \          <https://www.rfc-editor.org/info/rfc5198>.\n   [RFC6762]  Cheshire,\
    \ S. and M. Krochmal, \"Multicast DNS\", RFC 6762,\n              DOI 10.17487/RFC6762,\
    \ February 2013,\n              <https://www.rfc-editor.org/info/rfc6762>.\n \
    \  [RFC6763]  Cheshire, S. and M. Krochmal, \"DNS-Based Service\n            \
    \  Discovery\", RFC 6763, DOI 10.17487/RFC6763, February 2013,\n             \
    \ <https://www.rfc-editor.org/info/rfc6763>.\n   [RFC8174]  Leiba, B., \"Ambiguity\
    \ of Uppercase vs Lowercase in RFC\n              2119 Key Words\", BCP 14, RFC\
    \ 8174, DOI 10.17487/RFC8174,\n              May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n\
    \   [RFC8490]  Bellis, R., Cheshire, S., Dickinson, J., Dickinson, S.,\n     \
    \         Lemon, T., and T. Pusateri, \"DNS Stateful Operations\",\n         \
    \     RFC 8490, DOI 10.17487/RFC8490, March 2019,\n              <https://www.rfc-editor.org/info/rfc8490>.\n\
    \   [RFC8765]  Pusateri, T. and S. Cheshire, \"DNS Push Notifications\",\n   \
    \           RFC 8765, DOI 10.17487/RFC8765, June 2020,\n              <https://www.rfc-editor.org/info/rfc8765>.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [DNS-UL]   Cheshire, S. and T. Lemon, \"Dynamic\
    \ DNS Update Leases\",\n              Work in Progress, Internet-Draft, draft-sekar-dns-ul-02,\
    \ 2\n              August 2018,\n              <https://tools.ietf.org/html/draft-sekar-dns-ul-02>.\n\
    \   [IEEE-1Q]  IEEE, \"IEEE Standard for Local and metropolitan area\n       \
    \       networks -- Bridges and Bridged Networks\", IEEE Std \n              802.1Q-2014,\
    \ DOI 10.1109/IEEESTD.2014.6991462, 2014,\n              <https://ieeexplore.ieee.org/document/6991462>.\n\
    \   [IEEE-3]   IEEE, \"IEEE Standard for Ethernet\",\n              DOI 10.1109/IEEESTD.2018.8457469,\
    \ IEEE Std 802.3-2018,\n              December 2008,\n              <https://ieeexplore.ieee.org/document/8457469>.\n\
    \   [IEEE-5]   IEEE, \"Telecommunications and information exchange between\n \
    \             systems - Local and metropolitan area networks - Part 5:\n     \
    \         Token ring access method and physical layer\n              specifications\"\
    , IEEE Std 802.5-1998, 1998,\n              <https://standards.ieee.org/standard/802_5-1998.html>.\n\
    \   [IEEE-11]  IEEE, \"Information technology - Telecommunications and\n     \
    \         information exchange between systems - Local and\n              metropolitan\
    \ area networks - Specific requirements - Part\n              11: Wireless LAN\
    \ Medium Access Control (MAC) and Physical\n              Layer (PHY) Specifications\"\
    , IEEE Std 802.11-2016,\n              December 2016,\n              <https://standards.ieee.org/standard/802_11-2016.html>.\n\
    \   [MCAST]    Perkins, C., McBride, M., Stanley, D., Kumari, W., and J.\n   \
    \           Zuniga, \"Multicast Considerations over IEEE 802 Wireless\n      \
    \        Media\", Work in Progress, Internet-Draft, draft-ietf-\n            \
    \  mboned-ieee802-mcast-problems-11, 11 December 2019,\n              <https://tools.ietf.org/html/draft-ietf-mboned-ieee802-\n\
    \              mcast-problems-11>.\n   [OHP]      \"ohybridproxy - an mDNS/DNS\
    \ hybrid-proxy based on\n              mDNSResponder\", commit 464d6c9, June 2017,\n\
    \              <https://github.com/sbyx/ohybridproxy/>.\n   [REG-PROT] Cheshire,\
    \ S. and T. Lemon, \"Service Registration Protocol\n              for DNS-Based\
    \ Service Discovery\", Work in Progress,\n              Internet-Draft, draft-sctl-service-registration-02,\
    \ 15\n              July 2018, <https://tools.ietf.org/html/draft-sctl-\n    \
    \          service-registration-02>.\n   [RELAY]    Cheshire, S. and T. Lemon,\
    \ \"Multicast DNS Discovery\n              Relay\", Work in Progress, Internet-Draft,\
    \ draft-sctl-\n              dnssd-mdns-relay-04, 21 March 2018,\n           \
    \   <https://tools.ietf.org/html/draft-sctl-dnssd-mdns-relay-\n              04>.\n\
    \   [RFC2132]  Alexander, S. and R. Droms, \"DHCP Options and BOOTP Vendor\n \
    \             Extensions\", RFC 2132, DOI 10.17487/RFC2132, March 1997,\n    \
    \          <https://www.rfc-editor.org/info/rfc2132>.\n   [RFC2136]  Vixie, P.,\
    \ Ed., Thomson, S., Rekhter, Y., and J. Bound,\n              \"Dynamic Updates\
    \ in the Domain Name System (DNS UPDATE)\",\n              RFC 2136, DOI 10.17487/RFC2136,\
    \ April 1997,\n              <https://www.rfc-editor.org/info/rfc2136>.\n   [RFC3007]\
    \  Wellington, B., \"Secure Domain Name System (DNS) Dynamic\n              Update\"\
    , RFC 3007, DOI 10.17487/RFC3007, November 2000,\n              <https://www.rfc-editor.org/info/rfc3007>.\n\
    \   [RFC3492]  Costello, A., \"Punycode: A Bootstring encoding of Unicode\n  \
    \            for Internationalized Domain Names in Applications\n            \
    \  (IDNA)\", RFC 3492, DOI 10.17487/RFC3492, March 2003,\n              <https://www.rfc-editor.org/info/rfc3492>.\n\
    \   [RFC4193]  Hinden, R. and B. Haberman, \"Unique Local IPv6 Unicast\n     \
    \         Addresses\", RFC 4193, DOI 10.17487/RFC4193, October 2005,\n       \
    \       <https://www.rfc-editor.org/info/rfc4193>.\n   [RFC6760]  Cheshire, S.\
    \ and M. Krochmal, \"Requirements for a Protocol\n              to Replace the\
    \ AppleTalk Name Binding Protocol (NBP)\",\n              RFC 6760, DOI 10.17487/RFC6760,\
    \ February 2013,\n              <https://www.rfc-editor.org/info/rfc6760>.\n \
    \  [RFC7558]  Lynn, K., Cheshire, S., Blanchet, M., and D. Migault,\n        \
    \      \"Requirements for Scalable DNS-Based Service Discovery\n             \
    \ (DNS-SD) / Multicast DNS (mDNS) Extensions\", RFC 7558,\n              DOI 10.17487/RFC7558,\
    \ July 2015,\n              <https://www.rfc-editor.org/info/rfc7558>.\n   [RFC7626]\
    \  Bortzmeyer, S., \"DNS Privacy Considerations\", RFC 7626,\n              DOI\
    \ 10.17487/RFC7626, August 2015,\n              <https://www.rfc-editor.org/info/rfc7626>.\n\
    \   [RFC7788]  Stenberg, M., Barth, S., and P. Pfister, \"Home Networking\n  \
    \            Control Protocol\", RFC 7788, DOI 10.17487/RFC7788, April\n     \
    \         2016, <https://www.rfc-editor.org/info/rfc7788>.\n   [RFC8375]  Pfister,\
    \ P. and T. Lemon, \"Special-Use Domain\n              'home.arpa.'\", RFC 8375,\
    \ DOI 10.17487/RFC8375, May 2018,\n              <https://www.rfc-editor.org/info/rfc8375>.\n\
    \   [RFC8764]  Cheshire, S. and M. Krochmal, \"Apple's DNS Long-Lived\n      \
    \        Queries Protocol\", RFC 8764, DOI 10.17487/RFC8764, June\n          \
    \    2020, <https://www.rfc-editor.org/info/rfc8764>.\n   [ROADMAP]  Cheshire,\
    \ S., \"Service Discovery Road Map\", Work in\n              Progress, Internet-Draft,\
    \ draft-cheshire-dnssd-roadmap-03,\n              23 October 2018, <https://tools.ietf.org/html/draft-\n\
    \              cheshire-dnssd-roadmap-03>.\n   [ZC]       Cheshire, S. and D.H.\
    \ Steinberg, \"Zero Configuration\n              Networking: The Definitive Guide\"\
    , O'Reilly Media, Inc.,\n              ISBN 0-596-10100-7, December 2005.\n"
- title: Appendix A.  Implementation Status
  contents:
  - "Appendix A.  Implementation Status\n   Some aspects of the mechanism specified\
    \ in this document already\n   exist in deployed software.  Some aspects are new.\
    \  This section\n   outlines which aspects already exist and which are new.\n"
- title: A.1.  Already Implemented and Deployed
  contents:
  - "A.1.  Already Implemented and Deployed\n   Domain enumeration by the client (\"\
    b._dns-sd._udp.<zone>\" queries) is\n   already implemented and deployed.\n  \
    \ Performing unicast queries to the indicated discovery domain is\n   already\
    \ implemented and deployed.\n   These are implemented and deployed in Mac OS X\
    \ 10.4 Tiger and later\n   (including all versions of Apple iOS, on all models\
    \ of iPhones,\n   iPads, Apple TVs and HomePods), in Bonjour for Windows, and\
    \ in\n   Android 4.1 \"Jelly Bean\" (API Level 16) and later.\n   Domain enumeration\
    \ and unicast querying have been used for several\n   years at IETF meetings to\
    \ make terminal room printers discoverable\n   from outside the terminal room.\
    \  When an IETF attendee presses\n   \"Cmd-P\" on a Mac, or selects AirPrint on\
    \ an iPad or iPhone, and the\n   terminal room printers appear, it is because\
    \ the client is sending\n   Unicast DNS queries to the IETF DNS servers.  A walk-through\
    \ giving\n   the details of this particular specific example is given in\n   Appendix\
    \ A of the Roadmap document [ROADMAP].\n   The Long-Lived Query mechanism [RFC8764]\
    \ referred to in this\n   specification exists and is deployed but was not standardized\
    \ by the\n   IETF.  The IETF has developed a superior Long-Lived Query mechanism\n\
    \   called DNS Push Notifications [RFC8765], which is built on DNS\n   Stateful\
    \ Operations [RFC8490].  DNS Push Notifications is implemented\n   and deployed\
    \ in Mac OS X 10.15 and later, and iOS 13 and later.\n"
- title: A.2.  Already Implemented
  contents:
  - "A.2.  Already Implemented\n   A minimal portable Discovery Proxy implementation\
    \ has been produced\n   by Markus Stenberg and Steven Barth, which runs on OS\
    \ X and several\n   Linux variants including OpenWrt [OHP].  It was demonstrated\
    \ at the\n   Berlin IETF in July 2013.\n   Tom Pusateri has an implementation\
    \ that runs on any Unix/Linux\n   system.  It has a RESTful interface for management\
    \ and an\n   experimental demo command-line interface (CLI) and web interface.\n\
    \   Ted Lemon also has produced a portable implementation of Discovery\n   Proxy,\
    \ which is available in the mDNSResponder open source code.\n"
- title: A.3.  Partially Implemented
  contents:
  - "A.3.  Partially Implemented\n   At the time of writing, existing APIs make multiple\
    \ domains visible\n   to client software, but most client user interfaces lump\
    \ all\n   discovered services into a single flat list.  This is largely a\n  \
    \ chicken-and-egg problem.  Application writers were naturally\n   reluctant to\
    \ spend time writing domain-aware user interface code when\n   few customers would\
    \ benefit from it.  If Discovery Proxy deployment\n   becomes common, then application\
    \ writers will have a reason to\n   provide a better user experience.  Existing\
    \ applications will work\n   with the Discovery Proxy but will show all services\
    \ in a single flat\n   list.  Applications with improved user interfaces will\
    \ show services\n   grouped by domain.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   Thanks to Markus Stenberg for helping develop the policy\
    \ regarding\n   the four styles of unicast response according to what data is\n\
    \   immediately available in the cache.  Thanks to Anders Brandt, Ben\n   Campbell,\
    \ Tim Chown, Alissa Cooper, Spencer Dawkins, Ralph Droms,\n   Joel Halpern, Ray\
    \ Hunter, Joel Jaeggli, Warren Kumari, Ted Lemon,\n   Alexey Melnikov, Kathleen\
    \ Moriarty, Tom Pusateri, Eric Rescorla, Adam\n   Roach, David Schinazi, Markus\
    \ Stenberg, Dave Thaler, and Andrew\n   Yourtchenko for their comments.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Stuart Cheshire\n   Apple Inc.\n   One Apple Park Way\n\
    \   Cupertino, California 95014\n   United States of America\n"
