- title: __initial_text__
  contents:
  - "        Profile for Datagram Congestion Control Protocol (DCCP)\n       Congestion\
    \ Control ID 3: TCP-Friendly Rate Control (TFRC)\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document contains the profile for Congestion Control Identifier\n\
    \   3, TCP-Friendly Rate Control (TFRC), in the Datagram Congestion\n   Control\
    \ Protocol (DCCP).  CCID 3 should be used by senders that want\n   a TCP-friendly\
    \ sending rate, possibly with Explicit Congestion\n   Notification (ECN), while\
    \ minimizing abrupt rate changes.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................2\n\
    \   2. Conventions .....................................................3\n  \
    \ 3. Usage ...........................................................3\n    \
    \  3.1. Relationship with TFRC .....................................4\n      3.2.\
    \ Half-Connection Example ....................................4\n   4. Connection\
    \ Establishment ........................................5\n   5. Congestion Control\
    \ on Data Packets ..............................5\n      5.1. Response to Idle\
    \ and Application-Limited Periods ...........7\n      5.2. Response to Data Dropped\
    \ and Slow Receiver .................8\n      5.3. Packet Sizes ...............................................9\n\
    \   6. Acknowledgements ................................................9\n  \
    \    6.1. Loss Interval Definition ..................................10\n    \
    \       6.1.1. Loss Interval Lengths ..............................12\n      6.2.\
    \ Congestion Control on Acknowledgements ....................13\n      6.3. Acknowledgements\
    \ of Acknowledgements ......................13\n      6.4. Determining Quiescence\
    \ ....................................14\n   7. Explicit Congestion Notification\
    \ ...............................14\n   8. Options and Features ...........................................14\n\
    \      8.1. Window Counter Value ......................................15\n  \
    \    8.2. Elapsed Time Options ......................................17\n    \
    \  8.3. Receive Rate Option .......................................17\n      8.4.\
    \ Send Loss Event Rate Feature ..............................18\n      8.5. Loss\
    \ Event Rate Option ....................................18\n      8.6. Loss Intervals\
    \ Option .....................................18\n           8.6.1. Option Details\
    \ .....................................19\n           8.6.2. Example ............................................20\n\
    \   9. Verifying Congestion Control Compliance with ECN ...............22\n  \
    \    9.1. Verifying the ECN Nonce Echo ..............................22\n    \
    \  9.2. Verifying the Reported Loss Intervals and Loss\n           Event Rate\
    \ ................................................23\n   10. Implementation Issues\
    \ .........................................23\n      10.1. Timestamp Usage ..........................................23\n\
    \      10.2. Determining Loss Events at the Receiver ..................24\n  \
    \    10.3. Sending Feedback Packets .................................25\n   11.\
    \ Security Considerations .......................................27\n   12. IANA\
    \ Considerations ...........................................28\n      12.1. Reset\
    \ Codes ..............................................28\n      12.2. Option Types\
    \ .............................................28\n      12.3. Feature Numbers\
    \ ..........................................28\n   13. Thanks ........................................................29\n\
    \   A. Appendix: Possible Future Changes to CCID 3 ....................30\n  \
    \ Normative References ..............................................31\n   Informative\
    \ References ............................................31\n"
- title: List of Tables
  contents:
  - "List of Tables\n   Table 1: DCCP CCID 3 Options ......................................14\n\
    \   Table 2: DCCP CCID 3 Feature Numbers ..............................15\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document contains the profile for Congestion Control\
    \ Identifier\n   3, TCP-Friendly Rate Control (TFRC), in the Datagram Congestion\n\
    \   Control Protocol (DCCP) [RFC4340].  DCCP uses Congestion Control\n   Identifiers,\
    \ or CCIDs, to specify the congestion control mechanism in\n   use on a half-connection.\n\
    \   TFRC is a receiver-based congestion control mechanism that provides a\n  \
    \ TCP-friendly sending rate while minimizing the abrupt rate changes\n   characteristic\
    \ of TCP or of TCP-like congestion control [RFC3448].\n   The sender's allowed\
    \ sending rate is set in response to the loss\n   event rate, which is typically\
    \ reported by the receiver to the\n   sender.  See Section 3 for more on application\
    \ requirements.\n"
- title: 2.  Conventions
  contents:
  - "2.  Conventions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n\
    \   All multi-byte numerical quantities in CCID 3, such as arguments to\n   options,\
    \ are transmitted in network byte order (most significant byte\n   first).\n \
    \  A DCCP half-connection consists of the application data sent by one\n   endpoint\
    \ and the corresponding acknowledgements sent by the other\n   endpoint.  The\
    \ terms \"HC-Sender\" and \"HC-Receiver\" denote the\n   endpoints sending application\
    \ data and acknowledgements,\n   respectively.  Since CCIDs apply at the level\
    \ of half-connections, we\n   abbreviate HC-Sender to \"sender\" and HC-Receiver\
    \ to \"receiver\" in\n   this document.  See [RFC4340] for more discussion.\n\
    \   For simplicity, we say that senders send DCCP-Data packets and\n   receivers\
    \ send DCCP-Ack packets.  Both of these categories are meant\n   to include DCCP-DataAck\
    \ packets.\n   The phrases \"ECN-marked\" and \"marked\" refer to packets marked\
    \ ECN\n   Congestion Experienced unless otherwise noted.\n   This document uses\
    \ a number of variables from [RFC3448], including\n   the following:\n   o  X_recv:\
    \ The receive rate in bytes per second.  See [RFC3448],\n      Section 3.2.2.\n\
    \   o  s: The packet size in bytes.  See [RFC3448], Section 3.1.\n   o  p: The\
    \ loss event rate.  See [RFC3448], Section 3.1.\n"
- title: 3.  Usage
  contents:
  - "3.  Usage\n   CCID 3's TFRC congestion control is appropriate for flows that\
    \ would\n   prefer to minimize abrupt changes in the sending rate, including\n\
    \   streaming media applications with small or moderate receiver\n   buffering\
    \ before playback.  TCP-like congestion control, such as that\n   of DCCP's CCID\
    \ 2 [RFC4341], halves the sending rate in response to\n   each congestion event\
    \ and thus cannot provide a relatively smooth\n   sending rate.\n   As explained\
    \ in [RFC3448], Section 1, the penalty of having smoother\n   throughput than\
    \ TCP while competing fairly for bandwidth with TCP is\n   that the TFRC mechanism\
    \ in CCID 3 responds slower to changes in\n   available bandwidth than do TCP\
    \ or TCP-like mechanisms.  Thus, CCID 3\n   should only be used for applications\
    \ with a requirement for smooth\n   throughput.  For applications that simply\
    \ need to transfer as much\n   data as possible in as short a time as possible,\
    \ we recommend using\n   TCP-like congestion control, such as CCID 2.\n   CCID\
    \ 3 should also not be used by applications that change their\n   sending rate\
    \ by varying the packet size, rather than by varying the\n   rate at which packets\
    \ are sent.  A new CCID will be required for\n   these applications.\n"
- title: 3.1.  Relationship with TFRC
  contents:
  - "3.1.  Relationship with TFRC\n   The congestion control mechanisms described\
    \ here follow the TFRC\n   mechanism standardized by the IETF [RFC3448].  Conforming\
    \ CCID 3\n   implementations MAY track updates to the TCP throughput equation\n\
    \   directly, as updates are standardized in the IETF, rather than wait\n   for\
    \ revisions of this document.  However, conforming implementations\n   SHOULD\
    \ wait for explicit updates to CCID 3 before implementing other\n   changes to\
    \ TFRC congestion control.\n"
- title: 3.2.  Half-Connection Example
  contents:
  - "3.2.  Half-Connection Example\n   This example shows the typical progress of\
    \ a half-connection using\n   CCID 3's TFRC Congestion Control, not including\
    \ connection initiation\n   and termination.  The example is informative, not\
    \ normative.\n   1. The sender transmits DCCP-Data packets.  Its sending rate\
    \ is\n      governed by the allowed transmit rate as specified in [RFC3448],\n\
    \      Section 3.2.  Each DCCP-Data packet has a sequence number and the\n   \
    \   DCCP header's CCVal field contains the window counter value, which\n     \
    \ is used by the receiver in determining when multiple losses belong\n      in\
    \ a single loss event.\n      In the typical case of an ECN-capable half-connection,\
    \ each DCCP-\n      Data and DCCP-DataAck packet is sent as ECN Capable, with\
    \ either\n      the ECT(0) or the ECT(1) codepoint set.  The use of the ECN Nonce\n\
    \      with TFRC is described in Section 9.\n   2. The receiver sends DCCP-Ack\
    \ packets acknowledging the data packets\n      at least once per round-trip time,\
    \ unless the sender is sending at\n      a rate of less than one packet per round-trip\
    \ time, as indicated\n      by the TFRC specification ([RFC3448], Section 6).\
    \  Each DCCP-Ack\n      packet uses a sequence number, identifies the most recent\
    \ packet\n      received from the sender, and includes feedback about the recent\n\
    \      loss intervals experienced by the receiver.\n   3. The sender continues\
    \ sending DCCP-Data packets as controlled by\n      the allowed transmit rate.\
    \  Upon receiving DCCP-Ack packets, the\n      sender updates its allowed transmit\
    \ rate as specified in\n      [RFC3448], Section 4.3.  This update is based on\
    \ a loss event rate\n      calculated by the sender using the receiver's loss\
    \ intervals\n      feedback.  If it prefers, the sender can also use a loss event\n\
    \      rate calculated and reported by the receiver.\n   4. The sender estimates\
    \ round-trip times and calculates a nofeedback\n      time, as specified in [RFC3448],\
    \ Section 4.4.  If no feedback is\n      received from the receiver in that time\
    \ (at least four round-trip\n      times), the sender halves its sending rate.\n"
- title: 4. Connection Establishment
  contents:
  - "4. Connection Establishment\n   The client initiates the connection by using\
    \ mechanisms described in\n   the DCCP specification [RFC4340].  During or after\
    \ CCID 3\n   negotiation, the client and/or server may want to negotiate the\n\
    \   values of the Send Ack Vector and Send Loss Event Rate features.\n"
- title: 5. Congestion Control on Data Packets
  contents:
  - "5. Congestion Control on Data Packets\n   CCID 3 uses the congestion control\
    \ mechanisms of TFRC [RFC3448].  The\n   following discussion summarizes information\
    \ from [RFC3448], which\n   should be considered normative except where specifically\
    \ indicated\n   otherwise.\n   Loss Event Rate\n   The basic operation of CCID\
    \ 3 centers around the calculation of a\n   loss event rate: the number of loss\
    \ events as a fraction of the\n   number of packets transmitted, weighted over\
    \ the last several loss\n   intervals.  This loss event rate, a round-trip time\
    \ estimate, and the\n   average packet size are plugged into the TCP throughput\
    \ equation, as\n   specified in [RFC3448], Section 3.1.  The result is a fair\
    \ transmit\n   rate close to what a modern TCP would achieve in the same conditions.\n\
    \   CCID 3 senders are limited to this fair rate.\n   The loss event rate itself\
    \ is calculated in CCID 3 using recent loss\n   interval lengths reported by the\
    \ receiver.  Loss intervals are\n   precisely defined in Section 6.1.  In summary,\
    \ a loss interval is up\n   to 1 RTT of possibly lost or ECN-marked data packets,\
    \ followed by an\n   arbitrary number of non-dropped, non-marked data packets.\
    \  Thus, long\n   loss intervals represent low congestion rates.  The CCID 3 Loss\n\
    \   Intervals option is used to report loss interval lengths; see Section\n  \
    \ 8.6.\n   Other Congestion Control Mechanisms\n   The sender starts in a slow-start\
    \ phase, roughly doubling its allowed\n   sending rate each round-trip time. \
    \ The slow-start phase is ended by\n   the receiver's report of a data packet\
    \ drop or mark, after which the\n   sender uses the loss event rate to calculate\
    \ its allowed sending\n   rate.\n   [RFC3448], Section 4, specifies an initial\
    \ sending rate of one packet\n   per round-trip time (RTT) as follows: The sender\
    \ initializes the\n   allowed sending rate to one packet per second.  As soon\
    \ as a feedback\n   packet is received from the receiver, the sender has a measurement\
    \ of\n   the round-trip time and then sets the initial allowed sending rate to\n\
    \   one packet per RTT.  However, while the initial TCP window used to be\n  \
    \ one segment, [RFC2581] allows an initial TCP window of two segments,\n   and\
    \ [RFC3390] allows an initial TCP window of three or four segments\n   (up to\
    \ 4380 bytes).  [RFC3390] gives an upper bound on the initial\n   window of min(4*MSS,\
    \ max(2*MSS, 4380 bytes)).\n   Therefore, in contrast to [RFC3448], the initial\
    \ CCID 3 sending rate\n   is allowed to be at least two packets per RTT, and at\
    \ most four\n   packets per RTT, depending on the packet size.  The initial rate\
    \ is\n   only allowed to be three or four packets per RTT when, in terms of\n\
    \   segment size, that translates to at most 4380 bytes per RTT.\n   The sender's\
    \ measurement of the round-trip time uses the Elapsed Time\n   and/or Timestamp\
    \ Echo option contained in feedback packets, as\n   described in Section 8.2.\
    \  The Elapsed Time option is required, while\n   the Timestamp Echo option is\
    \ not.  The sender maintains an average\n   round-trip time heavily weighted on\
    \ the most recent measurements.\n   Each DCCP-Data packet contains a sequence\
    \ number.  Each DCCP-Data\n   packet also contains a window counter value, as\
    \ described in Section\n   8.1.  The window counter is generally incremented by\
    \ one every\n   quarter round-trip time.  The receiver uses it as a coarse-grained\n\
    \   timestamp to determine when a packet loss should be considered part\n   of\
    \ an existing loss interval and when it must begin a new loss\n   interval.\n\
    \   Because TFRC is rate-based instead of window-based, and because\n   feedback\
    \ packets can be dropped in the network, the sender needs some\n   mechanism for\
    \ reducing its sending rate in the absence of positive\n   feedback from the receiver.\
    \  As described in Section 6, the receiver\n   sends feedback packets roughly\
    \ once per round-trip time.  As\n   specified in [RFC3448], Section 4.3, the sender\
    \ sets a nofeedback\n   timer to at least four round-trip times, or to twice the\
    \ interval\n   between data packets, whichever is larger.  If the sender hasn't\n\
    \   received a feedback packet from the receiver when the nofeedback\n   timer\
    \ expires, then the sender halves its allowed sending rate.  The\n   allowed sending\
    \ rate is never reduced below one packet per 64\n   seconds.  Note that not all\
    \ acknowledgements are considered feedback\n   packets, since feedback packets\
    \ must contain valid Loss Intervals,\n   Elapsed Time, and Receive Rate options.\n\
    \   If the sender never receives a feedback packet from the receiver, and\n  \
    \ as a consequence never gets to set the allowed sending rate to one\n   packet\
    \ per RTT, then the sending rate is left at its initial rate of\n   one packet\
    \ per second, with the nofeedback timer expiring after two\n   seconds.  The allowed\
    \ sending rate is halved each time the nofeedback\n   timer expires.  Thus, if\
    \ no feedback is received from the receiver,\n   the allowed sending rate is never\
    \ above one packet per second and is\n   quickly reduced below one packet per\
    \ second.\n   The feedback packets from the receiver contain a Receive Rate option\n\
    \   specifying the rate at which data packets arrived at the receiver\n   since\
    \ the last feedback packet.  The allowed sending rate can be at\n   most twice\
    \ the rate received at the receiver in the last round-trip\n   time.  This may\
    \ be less than the nominal fair rate if, for example,\n   the application is sending\
    \ less than its fair share.\n"
- title: 5.1.  Response to Idle and Application-Limited Periods
  contents:
  - "5.1.  Response to Idle and Application-Limited Periods\n   One consequence of\
    \ the nofeedback timer is that the sender reduces\n   the allowed sending rate\
    \ when the sender has been idle for a\n   significant period of time.  In [RFC3448],\
    \ Section 4.4, the allowed\n   sending rate is never reduced to fewer than two\
    \ packets per round-\n   trip time as the result of an idle period.  CCID 3 revises\
    \ this to\n   take into account the larger initial windows allowed by [RFC3390]:\n\
    \   the allowed sending rate is never reduced to less than the [RFC3390]\n   initial\
    \ sending rate as the result of an idle period.  If the allowed\n   sending rate\
    \ is less than the initial sending rate upon entry to the\n   idle period, then\
    \ it will still be less than the initial sending rate\n   when the idle period\
    \ is exited.  However, if the allowed sending rate\n   is greater than or equal\
    \ to the initial sending rate upon entry to\n   the idle period, then it should\
    \ not be reduced below the initial\n   sending rate no matter how long the idle\
    \ period lasts.\n   The sender's allowed sending rate is limited to at most twice\
    \ the\n   receive rate reported by the receiver.  Thus, after an application-\n\
    \   limited period, the sender can at most double its sending rate from\n   one\
    \ round-trip time to the next, until it reaches the allowed sending\n   rate determined\
    \ by the loss event rate.\n"
- title: 5.2.  Response to Data Dropped and Slow Receiver
  contents:
  - "5.2.  Response to Data Dropped and Slow Receiver\n   DCCP's Data Dropped option\
    \ lets a receiver declare that a packet was\n   dropped at the end host before\
    \ delivery to the application -- for\n   instance, because of corruption or receive\
    \ buffer overflow.  Its Slow\n   Receiver option lets a receiver declare that\
    \ it is having trouble\n   keeping up with the sender's packets, although nothing\
    \ has yet been\n   dropped.  CCID 3 senders respond to these options as described\
    \ in\n   [RFC4340], with the following further clarifications.\n   o  Drop Code\
    \ 2 (\"receive buffer drop\").  The allowed sending rate is\n      reduced by\
    \ one packet per RTT for each packet newly acknowledged\n      as Drop Code 2,\
    \ except that it is never reduced below one packet\n      per RTT as a result\
    \ of Drop Code 2.\n   o  Adjusting the receive rate X_recv.  A CCID 3 sender SHOULD\
    \ also\n      respond to non-network-congestion events, such as those implied\
    \ by\n      Data Dropped and Slow Receiver options, by adjusting X_recv, the\n\
    \      receive rate reported by the receiver in Receive Rate options (see\n  \
    \    Section 8.3).  The CCID 3 sender's allowed sending rate is limited\n    \
    \  to at most twice the receive rate reported by the receiver via the\n      \"\
    min(..., 2*X_recv)\" clause in TFRC's throughput calculations\n      ([RFC3448],\
    \ Section 4.3).  When the sender receives one or more\n      Data Dropped and\
    \ Slow Receiver options, the sender adjusts X_recv\n      as follows:\n      1.\
    \ X_inrecv is equal to the Receive Rate in bytes per second\n         reported\
    \ by the receiver in the most recent acknowledgement.\n      2. X_drop is set\
    \ to the sending rate upper bound implied by Data\n         Dropped and Slow Receiver\
    \ options.  If the sender receives a\n         Slow Receiver option, which requests\
    \ that the sender not\n         increase its sending rate for roughly a round-trip\
    \ time\n         [RFC4340], then X_drop should be set to X_inrecv.  Similarly,\n\
    \         if the sender receives a Data Dropped option indicating, for\n     \
    \    example, that three packets were dropped with Drop Code 2, then\n       \
    \  the upper bound on the sending rate will be decreased by at\n         most\
    \ three packets per RTT, by the sender setting X_drop to\n                  max(X_inrecv\
    \ - 3*s/RTT, min(X_inrecv, s/RTT)).\n         Again, s is the packet size in bytes.\n\
    \      3. X_recv is then set to min(X_inrecv, X_drop/2).\n      As a result, the\
    \ next round-trip time's sending rate will be\n      limited to at most 2*(X_drop/2)\
    \ = X_drop.  The effects of the Slow\n      Receiver and Data Dropped options\
    \ on X_recv will mostly vanish by\n      the round-trip time after that, which\
    \ is appropriate for this\n      non-network-congestion feedback.  This procedure\
    \ MUST only be used\n      for those Drop Codes not related to corruption (see\
    \ [RFC4340]).\n      Currently, this is limited to Drop Codes 0, 1, and 2.\n"
- title: 5.3.  Packet Sizes
  contents:
  - "5.3.  Packet Sizes\n   CCID 3 is intended for applications that use a fixed packet\
    \ size, and\n   that vary their sending rate in packets per second in response\
    \ to\n   congestion.  CCID 3 is not appropriate for applications that require\n\
    \   a fixed interval of time between packets and vary their packet size\n   instead\
    \ of their packet rate in response to congestion.  However,\n   some attention\
    \ might be required for applications using CCID 3 that\n   vary their packet size\
    \ not in response to congestion, but in response\n   to other application-level\
    \ requirements.\n   The packet size s is used in the TCP throughput equation.\
    \  A CCID 3\n   implementation MAY calculate s as the segment size averaged over\n\
    \   multiple round trip times -- for example, over the most recent four\n   loss\
    \ intervals, for loss intervals as defined in Section 6.1.\n   Alternately, a\
    \ CCID 3 implementation MAY use the Maximum Packet Size\n   to derive s.  In this\
    \ case, s is set to the Maximum Segment Size\n   (MSS), the maximum size in bytes\
    \ for the data segment, not including\n   the default DCCP and IP packet headers.\
    \  Each packet transmitted then\n   counts as one MSS, regardless of the actual\
    \ segment size, and the TCP\n   throughput equation can be interpreted as specifying\
    \ the sending rate\n   in packets per second.\n   CCID 3 implementations MAY check\
    \ for applications that appear to be\n   manipulating the packet size inappropriately.\
    \  For example, an\n   application might send small packets for a while, building\
    \ up a fast\n   rate, then switch to large packets to take advantage of the fast\n\
    \   rate.  (Preliminary simulations indicate that applications may not be\n  \
    \ able to increase their overall transfer rates this way, so it is not\n   clear\
    \ that this manipulation will occur in practice [V03].)\n"
- title: 6.  Acknowledgements
  contents:
  - "6.  Acknowledgements\n   The receiver sends a feedback packet to the sender roughly\
    \ once per\n   round-trip time, if the sender is sending packets that frequently.\n\
    \   This rate is determined by the TFRC protocol as specified in\n   [RFC3448],\
    \ Section 6.\n   Each feedback packet contains an Acknowledgement Number, which\
    \ equals\n   the greatest valid sequence number received so far on this\n   connection.\
    \  (\"Greatest\" is, of course, measured in circular sequence\n   space.)  Each\
    \ feedback packet also includes at least the following\n   options:\n   1. An\
    \ Elapsed Time and/or Timestamp Echo option specifying the amount\n      of time\
    \ elapsed since the arrival at the receiver of the packet\n      whose sequence\
    \ number appears in the Acknowledgement Number field.\n      These options are\
    \ described in [RFC4340], Section 13.\n   2. A Receive Rate option, defined in\
    \ Section 8.3, specifying the rate\n      at which data was received since the\
    \ last DCCP-Ack was sent.\n   3. A Loss Intervals option, defined in Section 8.6,\
    \ specifying the\n      most recent loss intervals experienced by the receiver.\
    \  (The\n      definition of a loss interval is provided below.)  From Loss\n\
    \      Intervals, the sender can easily calculate the loss event rate p\n    \
    \  using the procedure described in [RFC3448], Section 5.4.\n   Acknowledgements\
    \ not containing at least these three options are not\n   considered feedback\
    \ packets.\n   The receiver MAY also include other options concerning the loss\
    \ event\n   rate, including Loss Event Rate, which gives the loss event rate\n\
    \   calculated by the receiver (Section 8.5), and DCCP's generic Ack\n   Vector\
    \ option, which reports the specific sequence numbers of any\n   lost or marked\
    \ packets ([RFC4340], Section 11.4).  Ack Vector is not\n   required by CCID 3's\
    \ congestion control mechanisms: the Loss\n   Intervals option provides all the\
    \ information needed to manage the\n   transmit rate and probabilistically verify\
    \ receiver feedback.\n   However, Ack Vector may be useful for applications that\
    \ need to\n   determine exactly which packets were lost.  The receiver MAY also\n\
    \   include other acknowledgement-related options, such as DCCP's Data\n   Dropped\
    \ option ([RFC4340], Section 11.7).\n   If the HC-Receiver is also sending data\
    \ packets to the HC-Sender,\n   then it MAY piggyback acknowledgement information\
    \ on those data\n   packets more frequently than TFRC's specified acknowledgement\
    \ rate\n   allows.\n"
- title: 6.1.  Loss Interval Definition
  contents:
  - "6.1.  Loss Interval Definition\n   As described in [RFC3448], Section 5.2, a\
    \ loss interval begins with a\n   lost or ECN-marked data packet; continues with\
    \ at most one round-trip\n   time's worth of packets that may or may not be lost\
    \ or marked; and\n   completes with an arbitrarily long series of non-dropped,\
    \ non-marked\n   data packets.  For example, here is a single loss interval, assuming\n\
    \   that sequence numbers increase as you move right:\n           Lossy Part\n\
    \            <= 1 RTT   __________ Lossless Part __________\n          /     \
    \     \\/                                   \\\n          *----*--*--*-------------------------------------\n\
    \          ^    ^  ^  ^\n         losses or marks\n   Note that a loss interval's\
    \ lossless part might be empty, as in the\n   first interval below:\n        \
    \  Lossy Part   Lossy Part\n           <= 1 RTT     <= 1 RTT   _____ Lossless\
    \ Part _____\n         /          \\/           \\/                         \\\
    \n         *----*--*--***--------*-*---------------------------\n         ^  \
    \  ^  ^  ^^^        ^ ^\n         \\_ Int. 1 _/\\_____________ Interval 2 _____________/\n\
    \   As in [RFC3448], Section 5.2, the length of the lossy part MUST be\n   less\
    \ than or equal to 1 RTT.  CCID 3 uses window counter values, not\n   receive\
    \ times, to determine whether multiple packets occurred in the\n   same RTT and\
    \ thus belong to the same loss event; see Section 10.2.  A\n   loss interval whose\
    \ lossy part lasts for more than 1 RTT, or whose\n   lossless part contains a\
    \ dropped or marked data packet, is invalid.\n   A missing data packet doesn't\
    \ begin a new loss interval until NDUPACK\n   packets have been seen after the\
    \ \"hole\", where NDUPACK = 3.  Thus, up\n   to NDUPACK of the most recent sequence\
    \ numbers (including the\n   sequence numbers of any holes) might temporarily\
    \ not be part of any\n   loss interval while the implementation waits to see whether\
    \ a hole\n   will be filled.  See [RFC3448], Section 5.1, and [RFC2581], Section\n\
    \   3.2, for further discussion of NDUPACK.\n   As specified by [RFC3448], Section\
    \ 5, all loss intervals except the\n   first begin with a lost or marked data\
    \ packet, and all loss intervals\n   are as long as possible, subject to the validity\
    \ constraints above.\n   Lost and ECN-marked non-data packets may occur freely\
    \ in the lossless\n   part of a loss interval.  (Non-data packets consist of those\
    \ packet\n   types that cannot carry application data; namely, DCCP-Ack, DCCP-\n\
    \   Close, DCCP-CloseReq, DCCP-Reset, DCCP-Sync, and DCCP-SyncAck.)  In\n   the\
    \ absence of better information, a receiver MUST conservatively\n   assume that\
    \ every lost packet was a data packet and thus must occur\n   in some lossy part.\
    \  DCCP's NDP Count option can help the receiver\n   determine whether a particular\
    \ packet contained data; see [RFC4340],\n   Section 7.7.\n"
- title: 6.1.1.  Loss Interval Lengths
  contents:
  - "6.1.1.  Loss Interval Lengths\n   [RFC3448] defines the TFRC congestion control\
    \ mechanism in terms of a\n   one-way transfer of data, with data packets going\
    \ from the sender to\n   the receiver and feedback packets going from the receiver\
    \ back to the\n   sender.  However, CCID 3 applies in a context of two half-\n\
    \   connections, with DCCP-Data and DCCP-DataAck packets from one half-\n   connection\
    \ sharing sequence number space with DCCP-Ack packets from\n   the other half-connection.\
    \  For the purposes of CCID 3 congestion\n   control, loss interval lengths should\
    \ include data packets and should\n   exclude the acknowledgement packets from\
    \ the reverse half-connection.\n   However, it is also useful to report the total\
    \ number of packets in\n   each loss interval (for example, to facilitate ECN\
    \ Nonce\n   verification).\n   CCID 3's Loss Intervals option thus reports three\
    \ lengths for each\n   loss interval, the lengths of the lossy and lossless parts\
    \ defined\n   above and a separate data length.  First, the lossy and lossless\n\
    \   lengths are measured in sequence numbers.  Together, they sum to the\n   interval's\
    \ sequence length, which is the total number of packets the\n   sender transmitted\
    \ during the interval.  This is easily calculated in\n   DCCP as the greatest\
    \ packet sequence number in the interval minus the\n   greatest packet sequence\
    \ number in the preceding interval (or, if\n   there is no preceding interval,\
    \ then the predecessor to the half-\n   connection's initial sequence number).\
    \  The interval's data length,\n   however, is the number used in TFRC's loss\
    \ event rate calculation, as\n   defined in [RFC3448], Section 5, and is calculated\
    \ as follows.\n   For all loss intervals except the first, the data length equals\
    \ the\n   sequence length minus the number of non-data packets the sender\n  \
    \ transmitted during the loss interval, except that the minimum data\n   length\
    \ is one packet.  In the absence of better information, an\n   endpoint MUST conservatively\
    \ assume that the loss interval contained\n   only data packets, in which case\
    \ the data length equals the sequence\n   length.  To achieve greater precision,\
    \ the sender can calculate the\n   exact number of non-data packets in an interval\
    \ by remembering which\n   sent packets contained data; the receiver can account\
    \ for received\n   non-data packets by not including them in the data length,\
    \ and for\n   packets that were not received, it may be able to discriminate\n\
    \   between lost data packets and lost non-data packets using DCCP's NDP\n   Count\
    \ option.\n   The first loss interval's data length is undefined until the first\n\
    \   loss event.  [RFC3448], Section 6.3.1 specifies how the first loss\n   interval's\
    \ data length is calculated once the first loss event has\n   occurred; this calculation\
    \ uses X_recv, the most recent receive rate,\n   as input.  Until this first loss\
    \ event, the loss event rate is zero,\n   as is the data length reported for the\
    \ interval in the Loss Intervals\n   option.\n   The first loss interval's data\
    \ length might be less than, equal to,\n   or even greater than its sequence length.\
    \  Any other loss interval's\n   data length must be less than or equal to its\
    \ sequence length.\n   A sender MAY use the loss event rate or loss interval data\
    \ lengths as\n   reported by the receiver, or it MAY recalculate loss event rate\n\
    \   and/or loss interval data lengths based on receiver feedback and\n   additional\
    \ information.  For example, assume the network drops a\n   DCCP-Ack packet with\
    \ sequence number 50.  The receiver might then\n   report a loss interval beginning\
    \ at sequence number 50.  If the\n   sender determined that this loss interval\
    \ actually contained no lost\n   or ECN-marked data packets, then it might coalesce\
    \ the loss interval\n   with the previous loss interval, resulting in a larger\
    \ allowed\n   transmit rate.\n"
- title: 6.2.  Congestion Control on Acknowledgements
  contents:
  - "6.2.  Congestion Control on Acknowledgements\n   The rate and timing for generating\
    \ acknowledgements is determined by\n   the TFRC algorithm ([RFC3448], Section\
    \ 6).  The sending rate for\n   acknowledgements is relatively low -- roughly\
    \ once per round-trip\n   time -- so there is no need for explicit congestion\
    \ control on\n   acknowledgements.\n"
- title: 6.3.  Acknowledgements of Acknowledgements
  contents:
  - "6.3.  Acknowledgements of Acknowledgements\n   TFRC acknowledgements don't generally\
    \ need to be reliable, so the\n   sender generally need not acknowledge the receiver's\n\
    \   acknowledgements.  When Ack Vector or Data Dropped is used, however,\n   the\
    \ sender, DCCP A, MUST occasionally acknowledge the receiver's\n   acknowledgements\
    \ so that the receiver can free up Ack Vector or Data\n   Dropped state.  When\
    \ both half-connections are active, the necessary\n   acknowledgements will be\
    \ contained in A's acknowledgements to B's\n   data.  If the B-to-A half-connection\
    \ goes quiescent, however, DCCP A\n   must send an acknowledgement proactively.\n\
    \   Thus, when Ack Vector or Data Dropped is used, an active sender MUST\n   acknowledge\
    \ the receiver's acknowledgements approximately once per\n   round-trip time,\
    \ within a factor of two or three, probably by sending\n   a DCCP-DataAck packet.\
    \  No acknowledgement options are necessary,\n   just the Acknowledgement Number\
    \ in the DCCP-DataAck header.\n   The sender MAY choose to acknowledge the receiver's\
    \ acknowledgements\n   even if they do not contain Ack Vectors or Data Dropped\
    \ options.  For\n   instance, regular acknowledgements can shrink the size of\
    \ the Loss\n   Intervals option.  Unlike Ack Vector and Data Dropped, however,\
    \ the\n   Loss Intervals option is bounded in size (and receiver state), so\n\
    \   acks-of-acks are not required.\n"
- title: 6.4.  Determining Quiescence
  contents:
  - "6.4.  Determining Quiescence\n   This section describes how a CCID 3 receiver\
    \ determines that the\n   corresponding sender is not sending any data and therefore\
    \ has gone\n   quiescent.  See [RFC4340], Section 11.1, for general information\
    \ on\n   quiescence.\n   Let T equal the greater of 0.2 seconds and two round-trip\
    \ times.  (A\n   CCID 3 receiver has a rough measure of the round-trip time so\
    \ that it\n   can pace its acknowledgements.)  The receiver detects that the sender\n\
    \   has gone quiescent after T seconds have passed without receiving any\n   additional\
    \ data from the sender.\n"
- title: 7.  Explicit Congestion Notification
  contents:
  - "7.  Explicit Congestion Notification\n   CCID 3 supports Explicit Congestion\
    \ Notification (ECN) [RFC3168].  In\n   the typical case of an ECN-capable half-connection\
    \ (where the\n   receiver's ECN Incapable feature is set to zero), the sender\
    \ will use\n   the ECN Nonce for its data packets, as specified in [RFC4340],\n\
    \   Section 12.2.  Information about the ECN Nonce MUST be returned by\n   the\
    \ receiver using the Loss Intervals option, and any Ack Vector\n   options MUST\
    \ include the ECN Nonce Sum.  The sender MAY maintain a\n   table with the ECN\
    \ nonce sum for each packet and use this information\n   to probabilistically\
    \ verify the ECN nonce sums returned in Loss\n   Intervals or Ack Vector options.\
    \  Section 9 describes this further.\n"
- title: 8.  Options and Features
  contents:
  - "8.  Options and Features\n   CCID 3 can make use of DCCP's Ack Vector, Timestamp,\
    \ Timestamp Echo,\n   and Elapsed Time options, and its Send Ack Vector and ECN\
    \ Incapable\n   features.  In addition, the following CCID-specific options are\n\
    \   defined for use with CCID 3.\n                   Option                  \
    \      DCCP-   Section\n          Type     Length     Meaning            Data?\
    \  Reference\n          -----    ------     -------            -----  ---------\n\
    \         128-191              Reserved\n           192        6       Loss Event\
    \ Rate      N      8.5\n           193     variable   Loss Intervals       N \
    \     8.6\n           194        6       Receive Rate         N      8.3\n   \
    \      195-255              Reserved\n                       Table 1: DCCP CCID\
    \ 3 Options\n   The \"DCCP-Data?\" column indicates that all currently defined\
    \ CCID 3-\n   specific options MUST be ignored when they occur on DCCP-Data\n\
    \   packets.\n   The following CCID-specific feature is also defined.\n      \
    \                                  Rec'n Initial        Section\n      Number\
    \   Meaning                  Rule   Value  Req'd Reference\n      ------   -------\
    \                  -----  -----  ----- ---------\n      128-191  Reserved\n  \
    \      192    Send Loss Event Rate      SP      0      N      8.4\n      193-255\
    \  Reserved\n                   Table 2: DCCP CCID 3 Feature Numbers\n   The column\
    \ meanings are described in [RFC4340], Table 4.  \"Rec'n\n   Rule\" defines the\
    \ feature's reconciliation rule, where \"SP\" means\n   server-priority.  \"Req'd\"\
    \ specifies whether every CCID 3\n   implementation MUST understand a feature;\
    \ Send Loss Event Rate is\n   optional, in that it behaves like an extension ([RFC4340],\
    \ Section\n   15).\n"
- title: 8.1.  Window Counter Value
  contents:
  - "8.1.  Window Counter Value\n   The data sender stores a 4-bit window counter\
    \ value in the DCCP\n   generic header's CCVal field on every data packet it sends.\
    \  This\n   value is set to 0 at the beginning of the transmission and generally\n\
    \   increased by 1 every quarter of a round-trip time, as described in\n   [RFC3448],\
    \ Section 3.2.1.  Window counters use circular arithmetic\n   modulo 16 for all\
    \ operations, including comparisons; see [RFC4340],\n   Section 3.1, for more\
    \ information on circular arithmetic.  For\n   reference, the DCCP generic header\
    \ is as follows.  (The diagram is\n   repeated from [RFC4340], Section 5.1, which\
    \ also shows the generic\n   header with a 24-bit Sequence Number field.)\n  \
    \   0                   1                   2                   3\n     0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |          Source Port          |           Dest Port           |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |  Data Offset  | CCVal | CsCov |           Checksum            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    | Res | Type  |1|   Reserved    |  Sequence Number (high bits)  .\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    .                  Sequence Number (low bits)                   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The CCVal field has enough space to express 4 round-trip times at\n   quarter-RTT\
    \ granularity.  The sender MUST avoid wrapping CCVal on\n   adjacent packets,\
    \ as might happen, for example, if two data-carrying\n   packets were sent 4 round-trip\
    \ times apart with no packets\n   intervening.  Therefore, the sender SHOULD use\
    \ the following\n   algorithm for setting CCVal.  The algorithm uses three variables:\n\
    \   \"last_WC\" holds the last window counter value sent, \"last_WC_time\" is\n\
    \   the time at which the first packet with window counter value\n   \"last_WC\"\
    \ was sent, and \"RTT\" is the current round-trip time\n   estimate.  last_WC\
    \ is initialized to zero, and last_WC_time to the\n   time of the first packet\
    \ sent.  Before sending a new packet, proceed\n   like this:\n      Let quarter_RTTs\
    \ = floor((current_time - last_WC_time) / (RTT/4)).\n      If quarter_RTTs > 0,\
    \ then:\n         Set last_WC := (last_WC + min(quarter_RTTs, 5)) mod 16.\n  \
    \       Set last_WC_time := current_time.\n      Set the packet header's CCVal\
    \ field to last_WC.\n   When this algorithm is used, adjacent data-carrying packets'\
    \ CCVal\n   counters never differ by more than five, modulo 16.\n   The window\
    \ counter value may also change as feedback packets arrive.\n   In particular,\
    \ after receiving an acknowledgement for a packet sent\n   with window counter\
    \ WC, the sender SHOULD increase its window\n   counter, if necessary, so that\
    \ subsequent packets have window counter\n   value at least (WC + 4) mod 16.\n\
    \   The CCVal counters are used by the receiver to determine whether\n   multiple\
    \ losses belong to a single loss event, to determine the\n   interval to use for\
    \ calculating the receive rate, and to determine\n   when to send feedback packets.\
    \  None of these procedures require the\n   receiver to maintain an explicit estimate\
    \ of the round-trip time.\n   However, implementors who wish to keep such an RTT\
    \ estimate may do so\n   using CCVal.  Let T(I) be the arrival time of the earliest\
    \ valid\n   received packet with CCVal = I.  (Of course, when the window counter\n\
    \   value wraps around to the same value mod 16, we must recalculate\n   T(I).)\
    \  Let D = 2, 3, or 4 and say that T(K) and T(K+D) both exist\n   (packets were\
    \ received with window counters K and K+D).  Then the\n   value (T(K+D) - T(K))\
    \ * 4/D MAY serve as an estimate of the round-\n   trip time.  Values of D = 4\
    \ SHOULD be preferred for RTT estimation.\n   Concretely, say that the following\
    \ packets arrived:\n   Time:       T1  T2  T3 T4  T5           T6  T7   T8  T9\n\
    \          ------*---*---*-*----*------------*---*----*--*---->\n   CCVal:   \
    \   K-1 K-1  K K   K+1          K+3 K+4  K+3 K+4\n   Then T7 - T3, the difference\
    \ between the receive times of the first\n   packet received with window counter\
    \ K+4 and the first packet received\n   with window counter K, is a reasonable\
    \ round-trip time estimate.\n   Because of the necessary constraint that measurements\
    \ only come from\n   packet pairs whose CCVals differ by at most 4, this procedure\
    \ does\n   not work when the inter-packet sending times are significantly\n  \
    \ greater than the RTT, resulting in packet pairs whose CCVals differ\n   by 5.\
    \  Explicit RTT measurement techniques, such as Timestamp and\n   Timestamp Echo,\
    \ should be used in that case.\n"
- title: 8.2.  Elapsed Time Options
  contents:
  - "8.2.  Elapsed Time Options\n   The data receiver MUST include an elapsed time\
    \ value on every\n   required acknowledgement.  This helps the sender distinguish\
    \ between\n   network round-trip time, which it must include in its rate equations,\n\
    \   and delay at the receiver due to TFRC's infrequent acknowledgement\n   rate,\
    \ which it need not include.  The receiver MUST at least include\n   an Elapsed\
    \ Time option on every feedback packet, but if at least one\n   recent data packet\
    \ (i.e., a packet received after the previous DCCP-\n   Ack was sent) included\
    \ a Timestamp option, then the receiver SHOULD\n   include the corresponding Timestamp\
    \ Echo option, with Elapsed Time\n   value, as well.  All of these option types\
    \ are defined in the main\n   DCCP specification [RFC4340].\n"
- title: 8.3.  Receive Rate Option
  contents:
  - "8.3.  Receive Rate Option\n   +--------+--------+--------+--------+--------+--------+\n\
    \   |11000010|00000110|            Receive Rate           |\n   +--------+--------+--------+--------+--------+--------+\n\
    \    Type=194   Len=6\n   This option MUST be sent by the data receiver on all\
    \ required\n   acknowledgements.  Its four data bytes indicate the rate at which\
    \ the\n   receiver has received data since it last sent an acknowledgement, in\n\
    \   bytes per second.  To calculate this receive rate, the receiver sets\n   t\
    \ to the larger of the estimated round-trip time and the time since\n   the last\
    \ Receive Rate option was sent.  (Received data packets'\n   window counters can\
    \ be used to produce a suitable RTT estimate, as\n   described in Section 8.1.)\
    \  The receive rate then equals the number\n   of data bytes received in the most\
    \ recent t seconds, divided by t.\n   Receive Rate options MUST NOT be sent on\
    \ DCCP-Data packets, and any\n   Receive Rate options on received DCCP-Data packets\
    \ MUST be ignored.\n"
- title: 8.4.  Send Loss Event Rate Feature
  contents:
  - "8.4.  Send Loss Event Rate Feature\n   The Send Loss Event Rate feature lets\
    \ CCID 3 endpoints negotiate\n   whether the receiver MUST provide Loss Event\
    \ Rate options on its\n   acknowledgements.  DCCP A sends a \"Change R(Send Loss\
    \ Event Rate, 1)\"\n   option to ask DCCP B to send Loss Event Rate options as\
    \ part of its\n   acknowledgement traffic.\n   Send Loss Event Rate has feature\
    \ number 192 and is server-priority.\n   It takes one-byte Boolean values.  DCCP\
    \ B MUST send Loss Event Rate\n   options on its acknowledgements when Send Loss\
    \ Event Rate/B is one,\n   although it MAY send Loss Event Rate options even when\
    \ Send Loss\n   Event Rate/B is zero.  Values of two or more are reserved.  A\
    \ CCID 3\n   half-connection starts with Send Loss Event Rate equal to zero.\n"
- title: 8.5.  Loss Event Rate Option
  contents:
  - "8.5.  Loss Event Rate Option\n   +--------+--------+--------+--------+--------+--------+\n\
    \   |11000000|00000110|          Loss Event Rate          |\n   +--------+--------+--------+--------+--------+--------+\n\
    \    Type=192   Len=6\n   The option value indicates the inverse of the loss event\
    \ rate,\n   rounded UP, as calculated by the receiver.  Its units are data\n \
    \  packets per loss interval.  Thus, if the Loss Event Rate option value\n   is\
    \ 100, then the loss event rate is 0.01 loss events per data packet\n   (and the\
    \ average loss interval contains 100 data packets).  When each\n   loss event\
    \ has exactly one data packet loss, the loss event rate is\n   the same as the\
    \ data packet drop rate.\n   See [RFC3448], Section 5, for a normative calculation\
    \ of loss event\n   rate.  Before any losses have occurred, when the loss event\
    \ rate is\n   zero, the Loss Event Rate option value is set to\n   \"11111111111111111111111111111111\"\
    \ in binary (or, equivalently, to\n   2^32 - 1).  The loss event rate calculation\
    \ uses loss interval data\n   lengths, as defined in Section 6.1.1.\n   Loss Event\
    \ Rate options MUST NOT be sent on DCCP-Data packets, and\n   any Loss Event Rate\
    \ options on received DCCP-Data packets MUST be\n   ignored.\n"
- title: 8.6.  Loss Intervals Option
  contents:
  - "8.6.  Loss Intervals Option\n   +--------+--------+--------+--------...--------+--------+---\n\
    \   |11000001| Length |  Skip  |   Loss Interval   | More Loss\n   |        |\
    \        | Length |                   | Intervals...\n   +--------+--------+--------+--------...--------+--------+---\n\
    \    Type=193                         9 bytes\n   Each 9-byte Loss Interval contains\
    \ three fields, as follows:\n     ____________________ Loss Interval _____________________\n\
    \    /                                                        \\\n   +--------...-------+--------...--------+--------...--------+\n\
    \   | Lossless Length  |E|   Loss Length   |    Data Length    |\n   +--------...-------+--------...--------+--------...--------+\n\
    \          3 bytes            3 bytes             3 bytes\n   The receiver reports\
    \ its observed loss intervals using a Loss\n   Intervals option.  Section 6.1\
    \ defines loss intervals.  This option\n   MUST be sent by the data receiver on\
    \ all required acknowledgements.\n   The option reports up to 28 loss intervals\
    \ seen by the receiver,\n   although TFRC currently uses at most the latest 9\
    \ of these.  This\n   lets the sender calculate a loss event rate and probabilistically\n\
    \   verify the receiver's ECN Nonce Echo.\n   The Loss Intervals option serves\
    \ several purposes.\n   o  The sender can use the Loss Intervals option to calculate\
    \ the loss\n      event rate.\n   o  Loss Intervals information is easily checked\
    \ for consistency\n      against previous Loss Intervals options, and against\
    \ any Loss\n      Event Rate calculated by the receiver.\n   o  The sender can\
    \ probabilistically verify the ECN Nonce Echo for\n      each Loss Interval, reducing\
    \ the likelihood of misbehavior.\n   Loss Intervals options MUST NOT be sent on\
    \ DCCP-Data packets, and any\n   Loss Intervals options on received DCCP-Data\
    \ packets MUST be ignored.\n"
- title: 8.6.1.  Option Details
  contents:
  - "8.6.1.  Option Details\n   The Loss Intervals option contains information about\
    \ one to 28\n   consecutive loss intervals, always including the most recent loss\n\
    \   interval.  Intervals are listed in reverse chronological order.\n   Should\
    \ more than 28 loss intervals need to be reported, then multiple\n   Loss Intervals\
    \ options can be sent; the second option begins where\n   the first left off,\
    \ and so forth.  The options MUST contain\n   information about at least the most\
    \ recent NINTERVAL + 1 = 9 loss\n   intervals unless (1) there have not yet been\
    \ NINTERVAL + 1 loss\n   intervals, or (2) the receiver knows, because of the\
    \ sender's\n   acknowledgements, that some previously transmitted loss interval\n\
    \   information has been received.  In this second case, the receiver\n   need\
    \ not send loss intervals that the sender already knows about,\n   except that\
    \ it MUST transmit at least one loss interval regardless.\n   The NINTERVAL parameter\
    \ is equal to \"n\" as defined in [RFC3448],\n   Section 5.4.\n   Loss interval\
    \ sequence numbers are delta encoded starting from the\n   Acknowledgement Number.\
    \  Therefore, Loss Intervals options MUST NOT\n   be sent on packets without an\
    \ Acknowledgement Number, and any Loss\n   Intervals options received on such\
    \ packets MUST be ignored.\n   The first byte of option data is Skip Length, which\
    \ indicates the\n   number of packets up to and including the Acknowledgement\
    \ Number that\n   are not part of any Loss Interval.  As discussed above, Skip\
    \ Length\n   must be less than or equal to NDUPACK = 3.  In a packet containing\n\
    \   multiple Loss Intervals options, the Skip Lengths of the second and\n   subsequent\
    \ options MUST equal zero; such options with nonzero Skip\n   Lengths MUST be\
    \ ignored.\n   Loss Interval structures follow Skip Length.  Each Loss Interval\n\
    \   consists of a Lossless Length, a Loss Length, an ECN Nonce Echo (E),\n   and\
    \ a Data Length.\n   Lossless Length, a 24-bit number, specifies the number of\
    \ packets in\n   the loss interval's lossless part.  Note again that this part\
    \ may\n   contain lost or marked non-data packets.\n   Loss Length, a 23-bit number,\
    \ specifies the number of packets in the\n   loss interval's lossy part.  The\
    \ sum of the Lossless Length and the\n   Loss Length equals the loss interval's\
    \ sequence length.  Receivers\n   SHOULD report the minimum valid Loss Length\
    \ for each loss interval,\n   making the first and last sequence numbers in each\
    \ lossy part\n   correspond to lost or marked data packets.\n   The ECN Nonce\
    \ Echo, stored in the high-order bit of the 3-byte field\n   containing Loss Length,\
    \ equals the one-bit sum (exclusive-or, or\n   parity) of data packet nonces received\
    \ over the loss interval's\n   lossless part (which is Lossless Length packets\
    \ long).  If Lossless\n   Length is 0, the receiver is ECN Incapable, or the Lossless\
    \ Length\n   contained no data packets, then the ECN Nonce Echo MUST be reported\n\
    \   as 0.  Note that any ECN nonces on received non-data packets MUST NOT\n  \
    \ contribute to the ECN Nonce Echo.\n   Finally, Data Length, a 24-bit number,\
    \ specifies the loss interval's\n   data length, as defined in Section 6.1.1.\n"
- title: 8.6.2.  Example
  contents:
  - "8.6.2.  Example\n   Consider the following sequence of packets, where \"-\" represents\
    \ a\n   safely delivered packet and \"*\" represents a lost or marked packet.\n\
    \   Sequence\n    Numbers: 0         10        20        30        40  44\n  \
    \           |         |         |         |         |   |\n             ----------*--------***-*--------*----------*-\n\
    \   Assuming that packet 43 was lost, not marked, this sequence might be\n   divided\
    \ into loss intervals as follows:\n             0         10        20       \
    \ 30        40  44\n             |         |         |         |         |   |\n\
    \             ----------*--------***-*--------*----------*-\n             \\________/\\\
    _______/\\___________/\\_________/\n                 L0       L1         L2  \
    \        L3\n   A Loss Intervals option sent on a packet with Acknowledgement\
    \ Number\n   44 to acknowledge this set of loss intervals might contain the bytes\n\
    \   193,39,2, 0,0,10, 128,0,1, 0,0,10, 0,0,8, 0,0,5, 0,0,10, 0,0,8,\n   0,0,1,\
    \ 0,0,8, 0,0,10, 128,0,0, 0,0,15.  This option is interpreted as\n   follows.\n\
    \   193 The Loss Intervals option number.\n   39  The length of the option, including\
    \ option type and length bytes.\n       This option contains information about\
    \ (39 - 3)/9 = 4 loss\n       intervals.\n   2   The Skip Length is 2 packets.\
    \  Thus, the most recent loss\n       interval, L3, ends immediately before sequence\
    \ number 44 - 2 + 1\n       = 43.\n   0,0,10, 128,0,1, 0,0,10\n       These bytes\
    \ define L3.  L3 consists of a 10-packet lossless part\n       (0,0,10), preceded\
    \ by a 1-packet lossy part.  Continuing to\n       subtract, the lossless part\
    \ begins with sequence number 43 - 10 =\n       33, and the lossy part begins\
    \ with sequence number 33 - 1 = 32.\n       The ECN Nonce Echo for the lossless\
    \ part (namely, packets 33\n       through 42, inclusive) equals 1.  The interval's\
    \ data length is\n       10, so the receiver believes that the interval contained\
    \ exactly\n       one non-data packet.\n   0,0,8, 0,0,5, 0,0,10\n       This defines\
    \ L2, whose lossless part begins with sequence number\n       32 - 8 = 24; whose\
    \ lossy part begins with sequence number 24 - 5\n       = 19; whose ECN Nonce\
    \ Echo (for packets [24,31]) equals 0; and\n       whose data length is 10.\n\
    \   0,0,8, 0,0,1, 0,0,8\n       L1's lossless part begins with sequence number\
    \ 11, its lossy part\n       begins with sequence number 10, its ECN Nonce Echo\
    \ (for packets\n       [11,18]) equals 0, and its data length is 8.\n   0,0,10,\
    \ 128,0,0, 0,0,15\n       L0's lossless part begins with sequence number 0, it\
    \ has no lossy\n       part, its ECN Nonce Echo (for packets [0,9]) equals 1,\
    \ and its\n       data length is 15.  (This must be the first loss interval in\
    \ the\n       connection; otherwise, a data length greater than the sequence\n\
    \       length would be invalid.)\n"
- title: 9.  Verifying Congestion Control Compliance with ECN
  contents:
  - "9.  Verifying Congestion Control Compliance with ECN\n   The sender can use Loss\
    \ Intervals options' ECN Nonce Echoes (and\n   possibly any Ack Vectors' ECN Nonce\
    \ Echoes) to probabilistically\n   verify that the receiver is correctly reporting\
    \ all dropped or marked\n   packets.  Even if ECN is not used (the receiver's\
    \ ECN Incapable\n   feature is set to one), the sender could still check on the\
    \ receiver\n   by occasionally not sending a packet, or sending a packet out-of-\n\
    \   order, to catch the receiver in an error in Loss Intervals or Ack\n   Vector\
    \ information.  This is not as robust or non-intrusive as the\n   verification\
    \ provided by the ECN Nonce, however.\n"
- title: 9.1.  Verifying the ECN Nonce Echo
  contents:
  - "9.1.  Verifying the ECN Nonce Echo\n   To verify the ECN Nonce Echo included\
    \ with a Loss Intervals option,\n   the sender maintains a table with the ECN\
    \ nonce sum for each data\n   packet.  As defined in [RFC3540], the nonce sum\
    \ for sequence number S\n   is the one-bit sum (exclusive-or, or parity) of data\
    \ packet nonces\n   over the sequence number range [I,S], where I is the initial\
    \ sequence\n   number.  Let NonceSum(S) represent this nonce sum for sequence\
    \ number\n   S, and define NonceSum(I - 1) as 0.  Note that NonceSum does not\n\
    \   account for the nonces of non-data packets such as DCCP-Ack.  Then\n   the\
    \ Nonce Echo for an interval of packets with sequence numbers X to\n   Y, inclusive,\
    \ should equal the following one-bit sum:\n         NonceSum(X - 1) + NonceSum(Y)\n\
    \   Since an ECN Nonce Echo is returned for the lossless part of each\n   Loss\
    \ Interval, a misbehaving receiver -- meaning a receiver that\n   reports a lost\
    \ or marked data packet as \"received non-marked\", to\n   avoid rate reductions\
    \ -- has only a 50% chance of guessing the\n   correct Nonce Echo for each loss\
    \ interval.\n   To verify the ECN Nonce Echo included with an Ack Vector option,\
    \ the\n   sender maintains a table with the ECN nonce value sent for each\n  \
    \ packet.  The Ack Vector option explicitly says which packets were\n   received\
    \ non-marked; the sender just adds up the nonces for those\n   packets using a\
    \ one-bit sum and compares the result to the Nonce Echo\n   encoded in the Ack\
    \ Vector's option type.  Again, a misbehaving\n   receiver has only a 50% chance\
    \ of guessing an Ack Vector's correct\n   Nonce Echo.  Alternatively, an Ack Vector's\
    \ ECN Nonce Echo may also\n   be calculated from a table of ECN nonce sums, rather\
    \ than from ECN\n   nonces.  If the Ack Vector contains many long runs of non-marked,\n\
    \   non-dropped packets, the nonce sum-based calculation will probably be\n  \
    \ faster than a straightforward nonce-based calculation.\n   Note that Ack Vector's\
    \ ECN Nonce Echo is measured over both data\n   packets and non-data packets,\
    \ while the Loss Intervals option reports\n   ECN Nonce Echoes for data packets\
    \ only.  Thus, different nonce sum\n   tables are required to verify the two options.\n"
- title: 9.2.  Verifying the Reported Loss Intervals and Loss Event Rate
  contents:
  - "9.2.  Verifying the Reported Loss Intervals and Loss Event Rate\n   Besides probabilistically\
    \ verifying the ECN Nonce Echoes reported by\n   the receiver, the sender may\
    \ also verify the loss intervals and any\n   loss event rate reported by the receiver,\
    \ if it so desires.\n   Specifically, the Loss Intervals option explicitly reports\
    \ the size\n   of each loss interval as seen by the receiver; the sender can verify\n\
    \   that the receiver is not falsely combining two loss events into one\n   reported\
    \ Loss Interval by using saved window counter information.\n   The sender can\
    \ also compare any Loss Event Rate option to the loss\n   event rate it calculates\
    \ using the Loss Intervals option.\n   Note that in some cases the loss event\
    \ rate calculated by the sender\n   could differ from an explicit Loss Event Rate\
    \ option sent by the\n   receiver.  In particular, when a number of successive\
    \ packets are\n   dropped, the receiver does not know the sending times for these\n\
    \   packets and interprets these losses as a single loss event.  In\n   contrast,\
    \ if the sender has saved the sending times or window counter\n   information\
    \ for these packets, then the sender can determine if these\n   losses constitute\
    \ a single loss event or several successive loss\n   events.  Thus, with its knowledge\
    \ of the sending times of dropped\n   packets, the sender is able to make a more\
    \ accurate calculation of\n   the loss event rate.  These kinds of differences\
    \ SHOULD NOT be\n   misinterpreted as attempted receiver misbehavior.\n"
- title: 10.  Implementation Issues
  contents:
  - '10.  Implementation Issues

    '
- title: 10.1.  Timestamp Usage
  contents:
  - "10.1.  Timestamp Usage\n   CCID 3 data packets need not carry Timestamp options.\
    \  The sender can\n   store the times at which recent packets were sent; the\n\
    \   Acknowledgement Number and Elapsed Time option contained on each\n   required\
    \ acknowledgement then provide sufficient information to\n   compute the round\
    \ trip time.  Alternatively, the sender MAY include\n   Timestamp options on some\
    \ of its data packets.  The receiver will\n   respond with Timestamp Echo options\
    \ including Elapsed Times, allowing\n   the sender to calculate round-trip times\
    \ without storing sent\n   packets' timestamps at all.\n"
- title: 10.2.  Determining Loss Events at the Receiver
  contents:
  - "10.2.  Determining Loss Events at the Receiver\n   The window counter is used\
    \ by the receiver to determine whether\n   multiple lost packets belong to the\
    \ same loss event.  The sender\n   increases the window counter by one every quarter\
    \ round-trip time.\n   This section describes in detail the procedure for using\
    \ the window\n   counter to determine when two lost packets belong to the same\
    \ loss\n   event.\n   [RFC3448], Section 3.2.1 specifies that each data packet\
    \ contains a\n   timestamp and gives as an alternative implementation a \"timestamp\"\
    \n   that is incremented every quarter of an RTT, as is the window counter\n \
    \  in CCID 3.  However, [RFC3448], Section 5.2 on \"Translation from Loss\n  \
    \ History to Loss Events\" is written in terms of timestamps, not in\n   terms\
    \ of window counters.  In this section, we give a procedure for\n   the translation\
    \ from loss history to loss events that is explicitly\n   in terms of window counters.\n\
    \   To determine whether two lost packets with sequence numbers X and Y\n   belong\
    \ to different loss events, the receiver proceeds as follows.\n   Assume Y > X\
    \ in circular sequence space.\n   o  Let X_prev be the greatest valid sequence\
    \ number received with\n      X_prev < X.\n   o  Let Y_prev be the greatest valid\
    \ sequence number received with\n      Y_prev < Y.\n   o  Given a sequence number\
    \ N, let C(N) be the window counter value\n      associated with that packet.\n\
    \   o  Packets X and Y belong to different loss events if there exists a\n   \
    \   packet with sequence number S so that X_prev < S <= Y_prev, and\n      the\
    \ distance from C(X_prev) to C(S) is greater than 4.  (The\n      distance is\
    \ the number D so that C(X_prev) + D = C(S) (mod\n      WCTRMAX), where WCTRMAX\
    \ is the maximum value for the window\n      counter -- in our case, 16.)\n  \
    \    That is, the receiver only considers losses X and Y as separate\n      loss\
    \ events if there exists some packet S received between X and\n      Y, with the\
    \ distance from C(X_prev) to C(S) greater than 4.  This\n      complex calculation\
    \ is necessary in order to handle the case where\n      window counter space wrapped\
    \ completely between X and Y.  When\n      that space does not wrap, the receiver\
    \ can simply check whether\n      the distance from C(X_prev) to C(Y_prev) is\
    \ greater than 4; if so,\n      then X and Y belong to separate loss events.\n\
    \   Window counters can help the receiver disambiguate multiple losses\n   after\
    \ a sudden decrease in the actual round-trip time.  When the\n   sender receives\
    \ an acknowledgement acknowledging a data packet with\n   window counter i, the\
    \ sender increases its window counter, if\n   necessary, so that subsequent data\
    \ packets are sent with window\n   counter values of at least i+4.  This can help\
    \ minimize errors where\n   the receiver incorrectly interprets multiple loss\
    \ events as a single\n   loss event.\n   We note that if all of the packets between\
    \ X and Y are lost in the\n   network, then X_prev and Y_prev are equal, and the\
    \ series of\n   consecutive losses is treated by the receiver as a single loss\
    \ event.\n   However, the sender will receive no DCCP-Ack packets during a period\n\
    \   of consecutive losses, and the sender will reduce its sending rate\n   accordingly.\n\
    \   As an alternative to the window counter, the sender could have sent\n   its\
    \ estimate of the round-trip time to the receiver directly in a\n   round-trip\
    \ time option; the receiver would use the sender's round-\n   trip time estimate\
    \ to infer when multiple lost or marked packets\n   belong in the same loss event.\
    \  In some respects, a round-trip time\n   option would give a more precise encoding\
    \ of the sender's round-trip\n   time estimate than does the window counter. \
    \ However, the window\n   counter conveys information about the relative *sending*\
    \ times for\n   packets, while the receiver could only use the round-trip time\
    \ option\n   to distinguish between the relative *receive* times (in the absence\n\
    \   of timestamps).  That is, the window counter will give more robust\n   performance\
    \ when there is a large variation in delay for packets sent\n   within a window\
    \ of data.  Slightly more speculatively, a round-trip\n   time option might possibly\
    \ be used more easily by middleboxes\n   attempting to verify that a flow used\
    \ conforming end-to-end\n   congestion control.\n"
- title: 10.3.  Sending Feedback Packets
  contents:
  - "10.3.  Sending Feedback Packets\n   [RFC3448], Sections 6.1 and 6.2 specify that\
    \ the TFRC receiver must\n   send a feedback packet when a newly calculated loss\
    \ event rate p is\n   greater than its previous value.  CCID 3 follows this rule.\n\
    \   In addition, [RFC3448], Section 6.2, specifies that the receiver use\n   a\
    \ feedback timer to decide when to send additional feedback packets.\n   If the\
    \ feedback timer expires and data packets have been received\n   since the previous\
    \ feedback was sent, then the receiver sends a\n   feedback packet.  When the\
    \ feedback timer expires, the receiver\n   resets the timer to expire after R_m\
    \ seconds, where R_m is the most\n   recent estimate of the round-trip time received\
    \ from the sender.\n   CCID 3 receivers, however, generally use window counter\
    \ values\n   instead of a feedback timer to determine when to send additional\n\
    \   feedback packets.  This section describes how.\n   Whenever the receiver sends\
    \ a feedback message, the receiver sets a\n   local variable last_counter to the\
    \ greatest received value of the\n   window counter since the last feedback message\
    \ was sent, if any data\n   packets have been received since the last feedback\
    \ message was sent.\n   If the receiver receives a data packet with a window counter\
    \ value\n   greater than or equal to last_counter + 4, then the receiver sends\
    \ a\n   new feedback packet.  (\"Greater\" and \"greatest\" are measured in\n\
    \   circular window counter space.)\n   This procedure ensures that when the sender\
    \ is sending at a rate less\n   than one packet per round-trip time, the receiver\
    \ sends a feedback\n   packet after each data packet.  Similarly, this procedure\
    \ ensures\n   that when the sender is sending several packets per round-trip time,\n\
    \   the receiver will send a feedback packet each time that a data packet\n  \
    \ arrives with a window counter at least four greater than the window\n   counter\
    \ when the last feedback packet was sent.  Thus, the feedback\n   timer is not\
    \ necessary when the window counter is used.\n   However, the feedback timer still\
    \ could be useful in some rare cases\n   to prevent the sender from unnecessarily\
    \ halving its sending rate.\n   In particular, one could construct scenarios where\
    \ the use of the\n   feedback timer at the receiver would prevent the unnecessary\n\
    \   expiration of the nofeedback timer at the sender.  Consider the case\n   below,\
    \ in which a feedback packet is sent when a data packet arrives\n   with a window\
    \ counter of K.\n      Window\n      Counters: K   K+1 K+2 K+3 K+4 K+5 K+6  ...\
    \  K+15 K+16 K+17 ...\n                |   |   |   |   |   |   |         |   \
    \ |    |\n      Data      |   |   |   |   |   |   |         |    |    |\n    \
    \  Packets   |   |   |   |   |   |   |         |    |    |\n      Received:  \
    \ - -  ---  -                ...   - - -- -  -- --  -\n                  |   \
    \             |               |    |    |        |\n                  |      \
    \          |               |    |    |        |\n      Events:     1:        \
    \       2:              3:   4:   5:       6:\n                 \"A\"        \
    \                      \"B\"  Timer \"B\"\n                 sent             \
    \                sent       received\n           1:  Feedback message A is sent.\n\
    \           2:  A feedback message would have been sent if feedback\n        \
    \       timers had been used.\n           3:  Feedback message B is sent.\n  \
    \         4:  Sender's nofeedback timer expires.\n           5:  Feedback message\
    \ B is received at the sender.\n           6:  Sender's nofeedback timer would\
    \ have expired if feedback\n               timers had been used, and the feedback\
    \ message at 2 had\n               been sent.\n   The receiver receives data after\
    \ the feedback packet has been sent\n   but has received no data packets with\
    \ a window counter between K+4\n   and K+14.  A data packet with a window counter\
    \ of K+4 or larger would\n   have triggered sending a new feedback packet, but\
    \ no feedback packet\n   is sent until time 3.\n   The TFRC protocol specifies\
    \ that after a feedback packet is received,\n   the sender sets a nofeedback timer\
    \ to at least four times the round-\n   trip time estimate.  If the sender doesn't\
    \ receive any feedback\n   packets before the nofeedback timer expires, then the\
    \ sender halves\n   its sending rate.  In the figure, the sender receives feedback\n\
    \   message A (time 1) and then sets the nofeedback timer to expire\n   roughly\
    \ four round-trip times later (time 4).  The sender starts\n   sending again just\
    \ before the nofeedback timer expires but doesn't\n   receive the resulting feedback\
    \ message until after its expiration,\n   resulting in an unnecessary halving\
    \ of the sending rate.  If the\n   connection had used feedback timers, the receiver\
    \ would have sent a\n   feedback message when the feedback timer expired at time\
    \ 2, and the\n   halving of the sending rate would have been avoided.\n   For\
    \ implementors who wish to implement a feedback timer for the data\n   receiver,\
    \ we suggest estimating the round-trip time from the most\n   recent data packet,\
    \ as described in Section 8.1.  We note that this\n   procedure does not work\
    \ when the inter-packet sending times are\n   greater than the RTT.\n"
- title: 11.  Security Considerations
  contents:
  - "11.  Security Considerations\n   Security considerations for DCCP have been discussed\
    \ in [RFC4340],\n   and security considerations for TFRC have been discussed in\n\
    \   [RFC3448], Section 9.  The security considerations for TFRC include\n   the\
    \ need to protect against spoofed feedback and the need to protect\n   the congestion\
    \ control mechanisms against incorrect information from\n   the receiver.\n  \
    \ In this document, we have extensively discussed the mechanisms the\n   sender\
    \ can use to verify the information sent by the receiver.  When\n   ECN is used,\
    \ the receiver returns ECN Nonce information to the\n   sender.  When ECN is not\
    \ used, then, as Section 9 shows, the sender\n   could still use various techniques\
    \ that might catch the receiver in\n   an error in reporting congestion, but this\
    \ is not as robust or non-\n   intrusive as the verification provided by the ECN\
    \ Nonce.\n"
- title: 12.  IANA Considerations
  contents:
  - "12.  IANA Considerations\n   This specification defines the value 3 in the DCCP\
    \ CCID namespace\n   managed by IANA.  This assignment is also mentioned in [RFC4340].\n\
    \   CCID 3 also introduces three sets of numbers whose values should be\n   allocated\
    \ by IANA; namely, CCID 3-specific Reset Codes, option types,\n   and feature\
    \ numbers.  These ranges will prevent any future CCID 3-\n   specific allocations\
    \ from polluting DCCP's corresponding global\n   namespaces; see [RFC4340], Section\
    \ 10.3.  However, we note that this\n   document makes no particular allocations\
    \ from the Reset Code range,\n   except for experimental and testing use [RFC3692].\
    \  We refer to the\n   Standards Action policy outlined in [RFC2434].\n"
- title: 12.1.  Reset Codes
  contents:
  - "12.1.  Reset Codes\n   Each entry in the DCCP CCID 3 Reset Code registry contains\
    \ a CCID 3-\n   specific Reset Code, which is a number in the range 128-255; a\
    \ short\n   description of the Reset Code; and a reference to the RFC defining\n\
    \   the Reset Code.  Reset Codes 184-190 and 248-254 are permanently\n   reserved\
    \ for experimental and testing use.  The remaining Reset Codes\n   -- 128-183,\
    \ 191-247, and 255 -- are currently reserved and should be\n   allocated with\
    \ the Standards Action policy, which requires IESG\n   review and approval and\
    \ standards-track IETF RFC publication.\n"
- title: 12.2.  Option Types
  contents:
  - "12.2.  Option Types\n   Each entry in the DCCP CCID 3 option type registry contains\
    \ a CCID\n   3-specific option type, which is a number in the range 128-255; the\n\
    \   name of the option, such as \"Loss Intervals\"; and a reference to the\n \
    \  RFC defining the option type.  The registry is initially populated\n   using\
    \ the values in Table 1, in Section 8.  This document allocates\n   option types\
    \ 192-194, and option types 184-190 and 248-254 are\n   permanently reserved for\
    \ experimental and testing use.  The remaining\n   option types -- 128-183, 191,\
    \ 195-247, and 255 -- are currently\n   reserved and should be allocated with\
    \ the Standards Action policy,\n   which requires IESG review and approval and\
    \ standards-track IETF RFC\n   publication.\n"
- title: 12.3.  Feature Numbers
  contents:
  - "12.3.  Feature Numbers\n   Each entry in the DCCP CCID 3 feature number registry\
    \ contains a CCID\n   3-specific feature number, which is a number in the range\
    \ 128-255;\n   the name of the feature, such as \"Send Loss Event Rate\"; and\
    \ a\n   reference to the RFC defining the feature number.  The registry is\n \
    \  initially populated using the values in Table 2, in Section 8.  This\n   document\
    \ allocates feature number 192, and feature numbers 184-190\n   and 248-254 are\
    \ permanently reserved for experimental and testing\n   use.  The remaining feature\
    \ numbers -- 128-183, 191, 193-247, and 255\n   -- are currently reserved and\
    \ should be allocated with the Standards\n   Action policy, which requires IESG\
    \ review and approval and\n   standards-track IETF RFC publication.\n"
- title: 13.  Thanks
  contents:
  - "13.  Thanks\n   We thank Mark Handley for his help in defining CCID 3.  We also\
    \ thank\n   Mark Allman, Aaron Falk, Ladan Gharai, Sara Karlberg, Greg Minshall,\n\
    \   Arun Venkataramani, David Vos, Yufei Wang, Magnus Westerlund, and\n   members\
    \ of the DCCP Working Group for feedback on versions of this\n   document.\n"
- title: 'A.  Appendix: Possible Future Changes to CCID 3'
  contents:
  - "A.  Appendix: Possible Future Changes to CCID 3\n   There are a number of cases\
    \ where the behavior of TFRC as specified\n   in [RFC3448] does not match the\
    \ desires of possible users of DCCP.\n   These include the following:\n   1. The\
    \ initial sending rate of at most four packets per RTT, as\n      specified in\
    \ [RFC3390].\n   2. The receiver's sending of an acknowledgement for every data\
    \ packet\n      received, when the receiver receives at a rate less than one\n\
    \      packet per round-trip time.\n   3. The sender's limitation of at most doubling\
    \ the sending rate from\n      one round-trip time to the next (or, more specifically,\
    \ of\n      limiting the sending rate to at most twice the reported receive\n\
    \      rate over the previous round-trip time).\n   4. The limitation of halving\
    \ the allowed sending rate after an idle\n      period of four round-trip times\
    \ (possibly down to the initial\n      sending rate of two to four packets per\
    \ round-trip time).\n   5. The response function used in [RFC3448], Section 3.1,\
    \ which does\n      not closely match the behavior of TCP in environments with\
    \ high\n      packet drop rates [RFC3714].\n   One suggestion for higher initial\
    \ sending rates is an initial sending\n   rate of up to eight small packets per\
    \ RTT, when the total packet\n   size, including headers, is at most 4380 bytes.\
    \  Because the packets\n   would be rate-paced out over a round-trip time, instead\
    \ of sent\n   back-to-back as they would be in TCP, an initial sending rate of\n\
    \   eight small packets per RTT with TFRC-based congestion control would\n   be\
    \ considerably milder than the impact of an initial window of eight\n   small\
    \ packets sent back-to-back in TCP.  As Section 5.1 describes,\n   the initial\
    \ sending rate also serves as a lower bound for reductions\n   of the allowed\
    \ sending rate during an idle period.\n   We note that with CCID 3, the sender\
    \ is in slow-start in the\n   beginning and responds promptly to the report of\
    \ a packet loss or\n   mark.  However, in the absence of feedback from the receiver,\
    \ the\n   sender can maintain its old sending rate for up to four round-trip\n\
    \   times.  One possibility would be that for an initial window of eight\n   small\
    \ packets, the initial nofeedback timer would be set to two\n   round-trip times\
    \ instead of four, so that the sending rate would be\n   reduced after two round-trips\
    \ without feedback.\n   Research and engineering will be needed to investigate\
    \ the pros and\n   cons of modifying these limitations in order to allow larger\
    \ initial\n   sending rates, to send fewer acknowledgements when the data sending\n\
    \   rate is low, to allow more abrupt changes in the sending rate, or to\n   allow\
    \ a higher sending rate after an idle period.\n"
- title: Normative References
  contents:
  - "Normative References\n   [RFC2119]      Bradner, S., \"Key words for use in RFCs\
    \ to Indicate\n                  Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [RFC2434]      Narten, T. and H. Alvestrand, \"Guidelines for Writing\n\
    \                  an IANA Considerations Section in RFCs\", BCP 26, RFC\n   \
    \               2434, October 1998.\n   [RFC2581]      Allman, M., Paxson, V.,\
    \ and W. Stevens, \"TCP\n                  Congestion Control\", RFC 2581, April\
    \ 1999.\n   [RFC3168]      Ramakrishnan, K., Floyd, S., and D. Black, \"The\n\
    \                  Addition of Explicit Congestion Notification (ECN) to\n   \
    \               IP\", RFC 3168, September 2001.\n   [RFC3390]      Allman, M.,\
    \ Floyd, S., and C. Partridge, \"Increasing\n                  TCP's Initial Window\"\
    , RFC 3390, October 2002.\n   [RFC3448]      Handley, M., Floyd, S., Padhye, J.,\
    \ and J. Widmer,\n                  \"TCP Friendly Rate Control (TFRC): Protocol\n\
    \                  Specification\", RFC 3448, January 2003.\n   [RFC3692]    \
    \  Narten, T., \"Assigning Experimental and Testing\n                  Numbers\
    \ Considered Useful\", BCP 82, RFC 3692, January\n                  2004.\n  \
    \ [RFC4340]      Kohler, E., Handley, M., and S. Floyd, \"Datagram\n         \
    \         Congestion Control Protocol (DCCP)\", RFC 4340, March\n            \
    \      2006.\n"
- title: Informative References
  contents:
  - "Informative References\n   [RFC3540]      Spring, N., Wetherall, D., and D. Ely,\
    \ \"Robust\n                  Explicit Congestion Notification (ECN) Signaling\
    \ with\n                  Nonces\", RFC 3540, June 2003.\n   [RFC3714]      Floyd,\
    \ S. and J. Kempf, \"IAB Concerns Regarding\n                  Congestion Control\
    \ for Voice Traffic in the Internet\",\n                  RFC 3714, March 2004.\n\
    \   [RFC4341]      Floyd, S. and E. Kohler, \"Profile for Datagram\n         \
    \         Congestion Control Protocol (DCCP) Congestion Control\n            \
    \      ID 2: TCP-like Congestion Control\", RFC 4341, March\n                \
    \  2006.\n   [V03]          Arun Venkataramani, August 2003.  Citation for\n \
    \                 acknowledgement purposes only.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Sally Floyd\n   ICSI Center for Internet Research\n  \
    \ 1947 Center Street, Suite 600\n   Berkeley, CA 94704\n   USA\n   EMail: floyd@icir.org\n\
    \   Eddie Kohler\n   4531C Boelter Hall\n   UCLA Computer Science Department\n\
    \   Los Angeles, CA 90095\n   USA\n   EMail: kohler@cs.ucla.edu\n   Jitendra Padhye\n\
    \   Microsoft Research\n   One Microsoft Way\n   Redmond, WA 98052\n   USA\n \
    \  EMail: padhye@microsoft.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n\
    \   Administrative Support Activity (IASA).\n"
