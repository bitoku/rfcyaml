- contents:
  - "                Support for Multiple Hash Algorithms in\n              Cryptographically
    Generated Addresses (CGAs)\n"
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The IETF Trust (2007).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document analyzes the implications of recent attacks on commonly\n
    \  used hash functions on Cryptographically Generated Addresses (CGAs)\n   and
    updates the CGA specification to support multiple hash\n   algorithms.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . . . 2\n   2.  Terminology . . . . . . . . . . . . . . . . . . . . . .
    . . . . 2\n   3.  Impact of Collision Attacks in CGAs . . . . . . . . . . . .
    . . 2\n   4.  Options for Multiple Hash Algorithm Support in CGAs . . . . . .
    3\n     4.1.  Where to Encode the Hash Function?  . . . . . . . . . . . . 4\n
    \  5.  CGA Generation Procedure  . . . . . . . . . . . . . . . . . . . 6\n   6.
    \ IANA Considerations . . . . . . . . . . . . . . . . . . . . . . 6\n   7.  Security
    Considerations . . . . . . . . . . . . . . . . . . . . 7\n   8.  Acknowledgements
    \ . . . . . . . . . . . . . . . . . . . . . . . 7\n   9.  References  . . . .
    . . . . . . . . . . . . . . . . . . . . . . 7\n     9.1.  Normative References
    \ . . . . . . . . . . . . . . . . . . . 7\n     9.2.  Informative References  .
    . . . . . . . . . . . . . . . . . 7\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Recent attacks to currently used hash functions have motivated
    a\n   considerable amount of concern in the Internet community.  The\n   recommended
    approach [6] [10] to deal with this issue is first to\n   analyze the impact of
    these attacks on the different Internet\n   protocols that use hash functions
    and second to make sure that the\n   different Internet protocols that use hash
    functions are capable of\n   migrating to an alternative (more secure) hash function
    without a\n   major disruption in the Internet operation.\n   This document performs
    such analysis for the Cryptographically\n   Generated Addresses (CGAs) defined
    in [2].  The first conclusion of\n   the analysis is that the security of the
    protocols using CGAs is not\n   affected by the recently available attacks against
    hash functions.\n   The second conclusion of the analysis is that the hash function
    used\n   is hard coded in the CGA specification.  This document updates the\n
    \  CGA specification [2] to enable the support of alternative hash\n   functions.
    \ In order to do so, this document creates a new registry\n   managed by IANA
    to register the different hash algorithms used in\n   CGAs.\n"
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\"
    in this\n   document are to be interpreted as described in RFC 2119 [1].\n"
  title: 2.  Terminology
- contents:
  - "3.  Impact of Collision Attacks in CGAs\n   Recent advances in cryptography have
    resulted in simplified attacks\n   against the collision-free property of certain
    commonly used hash\n   functions [6] [10], including SHA-1 that is the hash function
    used by\n   CGAs [2].  The result is that it is possible to obtain two messages,\n
    \  M1 and M2, that have the same hash value with much less than 2^(L/2)\n   attempts.
    \ We will next analyze the impact of such attacks in the\n   currently proposed
    usages of CGAs.\n   As we understand it, the attacks against the collision-free
    property\n   of a hash function mostly challenge the application of such hash\n
    \  functions, for the provision of non-repudiation capabilities.  This\n   is
    because an attacker would be capable to create two different\n   messages that
    result in the same hash value and it can then present\n   any of the messages
    interchangeably (for example after one of them\n   has been signed by the other
    party involved in the transaction).\n   However, it must be noted that both messages
    must be generated by the\n   same party.\n   As far as we understand, current
    usages of CGAs does not include the\n   provision of non-repudiation capabilities,
    so attacks against the\n   collision-free property of the hash function do not
    enable any useful\n   attack against CGA-based protocols.\n   Current usages of
    the CGAs are basically oriented to prove the\n   ownership of a CGA and then bind
    it to alternative addresses that can\n   be used to reach the original CGA.  This
    type of application of the\n   CGA include:\n   o  The application of CGAs to
    protect the shim6 protocol [7].  In\n      this case, CGAs are used as identifiers
    for the established\n      communications.  CGA features are used to prove that
    the owner of\n      the identifier is the one that is providing the alternative\n
    \     addresses that can be used to reach the initial identifier.  This\n      is
    achieved by signing the list of alternative addresses available\n      in the
    multihomed host with the private key of the CGA.\n   o  The application of CGAs
    to secure the IPv6 mobility support\n      protocol [8] as proposed in [9].  In
    this case, the CGAs are used\n      as Home Addresses and they are used to prove
    that the owner of the\n      Home Address is the one creating the binding with
    the new Care-off\n      Address.  Similarly to the previous case, this is achieved
    by\n      signing the Binding Update message carrying the Care-off Address\n      with
    the private key of the CGA.\n   o  The application of CGA to Secure Neighbour
    Discovery [4].  In this\n      case, the CGA features are used to prove the address
    ownership, so\n      that it is possible to verify that the owner of the IP address
    is\n      the one that is providing the layer 2 address information.  This\n      is
    achieved by signing the layer 2 address information with the\n      private key
    of the CGA.\n   Essentially, all the current applications of CGAs rely on CGAs
    to\n   protect a communication between two peers from third party attacks\n   and
    not to provide protection from the peer itself.  Attacks against\n   the collision-free
    property of the hash functions suppose that one of\n   the parties is generating
    two messages with the same hash value in\n   order to launch an attack against
    its communicating peer.  Since CGAs\n   are not currently used to providing this
    type of protection, it is\n   then natural that no additional attacks are enabled
    by a weaker\n   collision resistance of the hash function.\n"
  title: 3.  Impact of Collision Attacks in CGAs
- contents:
  - "4.  Options for Multiple Hash Algorithm Support in CGAs\n   CGAs, as currently
    defined in [2], are intrinsically bound to the\n   SHA-1 hash algorithm and no
    other hash function is supported.\n   Even though the attacks against the collision-free
    property of the\n   hash functions do not result in new vulnerabilities in the
    current\n   applications of CGAs, it seems wise to enable multiple hash function\n
    \  support in CGAs.  This is mainly for two reasons: first, potential\n   future
    applications of the CGA technology may be susceptible to\n   attacks against the
    collision-free property of SHA-1.  Supporting\n   alternative hash functions would
    allow applications that have\n   stricter requirements on the collision-free property
    to use CGAs.\n   Second, one lesson learned from the recent attacks against hash\n
    \  functions is that it is possible that one day we need to start using\n   alternative
    hash functions because of successful attacks against\n   other properties of the
    commonly used hash functions.  Therefore, it\n   seems wise to modify protocols
    in general and the CGAs in particular\n   to support this transition to alternative
    hash functions as easy as\n   possible.\n"
  - contents:
    - "4.1.  Where to Encode the Hash Function?\n   The next question we need to answer
      is where to encode the hash\n   function that is being used.  There are several
      options that can be\n   considered:\n   One option would be to include the hash
      function used as an input to\n   the hash function.  This basically means to
      create an extension to\n   the CGA Parameter Data Structure, as defined in [3],
      that codifies\n   the hash function used.  The problem is that this approach
      is\n   vulnerable to bidding down attacks or downgrading attacks as defined\n
      \  in [10].  This means that even if a strong hash function is used, an\n   attacker
      could find a CGA Parameter Data Structure that uses a weaker\n   function but
      results in an equal hash value.  This happens when the\n   original hash function
      H1 and CGA Parameters Data Structure\n   indicating H1 result in value X, and
      another hash function H2 and CGA\n   Parameters Data Structure indicating H2
      also result in the same value\n   X.\n   In other words, the downgrading attack
      would work as follows: suppose\n   that Alice generates a CGA CGA_A using the
      strong hash function\n   HashStrong and using a CGA Parameter Data Structure
      CGA_PDS_A.  The\n   selected hash function HashStrong is encoded as an extension
      field in\n   the CGA_PDS_A.  Suppose that by using a brute force attack, an\n
      \  attacker X finds an alternative CGA Parameter Data Structure\n   CGA_PDS_X
      whose hash value, by using a weaker hash function, is\n   CGA_A.  At this point,
      the attacker can pretend to be the owner of\n   CGA_A and the stronger hash
      function has not provided additional\n   protection.\n   The conclusion from
      the previous analysis is that the hash function\n   used in the CGA generation
      must be encoded in the address itself.\n   Since we want to support several
      hash functions, we will likely need\n   at least 2 or 3 bits for this.\n   One
      option would be to use more bits from the hash bits of the\n   interface identifier.
      \ However, the problem with this approach is\n   that the resulting CGA is weaker
      because less hash information is\n   encoded in the address.  In addition, since
      those bits are currently\n   used as hash bits, it is impossible to make this
      approach backward\n   compatible with existent implementations.\n   Another
      option would be to use the \"u\" and the \"g\" bits to encode\n   this information,
      but this is probably not such a good idea since\n   those bits have been honoured
      so far in all interface identifier\n   generation mechanisms, which allow them
      to be used for the original\n   purpose (for instance we can still create a
      global registry for\n   unique interface identifiers).  Finally, another option
      is to encode\n   the hash value used in the Sec bits.  The Sec bits are used
      to\n   artificially introduce additional difficulty in the CGA generation\n
      \  process in order to provide additional protection against brute force\n   attacks.
      \ The Sec bits have been designed in a way that the lifetime\n   of CGAs are
      extended, when it is feasible to attack 59-bits long hash\n   values.  However,
      this is not the case today, so in general CGA will\n   have a Sec value of 000.
      \ The proposal is to encode in the Sec bits,\n   not only information about
      brute force attack protection but also to\n   encode the hash function used
      to generate the hash.  So for instance,\n   the Sec value 000 would mean that
      the hash function used is SHA-1 and\n   the 0 bits of hash2 (as defined in RFC
      3972) must be 0.  Sec value of\n   001 could be that the hash function used
      is SHA-1 and the 16 bits of\n   hash2 (as defined in RFC 3972) must be zero.
      \ However, the other\n   values of Sec could mean that an alternative hash function
      needs to\n   be used and that a certain amount of bits of hash2 must be zero.
      \ The\n   proposal is not to define any concrete hash function to be used for\n
      \  other Sec values, since it is not yet clear that we need to do so nor\n   is
      it clear which hash function should be selected.\n   Note that since there are
      only 8 Sec values, it may be necessary to\n   reuse Sec values when we run out
      of unused Sec values.  The scenario\n   where such an approach makes sense is
      where there are some Sec values\n   that are no longer being used because the
      resulting security has\n   become weak.  In this case, where the usage of the
      Sec value has long\n   been abandoned, it would be possible to reassign the
      Sec values.\n   However, this must be a last resource option, since it may affect\n
      \  interoperability.  This is because two implementations using\n   different
      meanings of a given Sec value would not be able to\n   interoperate properly
      (i.e., if an old implementation receives a CGA\n   generated with the new meaning
      of the Sec value, it will fail and the\n   same for a new implementation receiving
      a CGA generated with the old\n   meaning of the Sec value).  In case the approach
      of reassigning a Sec\n   value is followed, a long time is required between
      the deprecation of\n   the old value and the reassignment in order to prevent\n
      \  misinterpretation of the value by old implementations.\n   An erroneous interpretation
      of a reused Sec value, both on the CGA\n   owner's side and the CGA verifier's
      side, would have the following\n   result, CGA verification would fail in the
      worst case and both nodes\n   would have to revert to unprotected IPv6 addresses.
      \ This can happen\n   only with obsolete CGA parameter sets, which would be
      considered\n   insecure anyway.  In any case, an implementation must not\n   simultaneously
      support two different meanings of a Sec value.\n"
    title: 4.1.  Where to Encode the Hash Function?
  title: 4.  Options for Multiple Hash Algorithm Support in CGAs
- contents:
  - "5.  CGA Generation Procedure\n   The SEC registry defined in the IANA considerations
    section of this\n   document contains entries for the different Sec values.  Each
    of\n   these entries points to an RFC that defines the CGA generation\n   procedure
    that MUST be used when generating CGAs with the associated\n   Sec value.\n   It
    should be noted that the CGA generation procedure may be changed\n   by the new
    procedure not only in terms of the hash function used but\n   also in other aspects,
    e.g., longer Modifier values may be required\n   if the number of 0s required
    in hash2 exceed the currently defined\n   bound of 112 bits.  The new procedure
    (which potentially involves a\n   longer Modifier value) would be described in
    the RFC pointed to by\n   the corresponding Sec registry entry.\n   In addition,
    the RFC that defines the CGA generation procedure for a\n   Sec value MUST explicitly
    define the minimum key length acceptable\n   for CGAs with that Sec value.  This
    is to provide a coherent\n   protection both in the hash and the public key techniques.\n"
  title: 5.  CGA Generation Procedure
- contents:
  - "6.  IANA Considerations\n   This document defines a new registry entitled \"CGA
    SEC\" for the Sec\n   field defined in RFC 3972 [2] that has been created and
    is maintained\n   by IANA.  The values in this name space are 3-bit unsigned integers.\n
    \  Initial values for the CGA Extension Type field are given below;\n   future
    assignments are to be made through Standards Action [5].\n   Assignments consist
    of a name, the value, and the RFC number where\n   the CGA generation procedure
    is defined.\n   The following initial values are assigned in this document:\n
    \         Name        | Value |  RFCs\n   -------------------+-------+------------\n
    \  SHA-1_0hash2bits   |   000 | 3972, 4982\n   SHA-1_16hash2bits  |   001 | 3972,
    4982\n   SHA-1_32hash2bits  |   010 | 3972, 4982\n"
  title: 6.  IANA Considerations
- contents:
  - "7.  Security Considerations\n   This document is about security issues and, in
    particular, about\n   protection against potential attacks against hash functions.\n"
  title: 7.  Security Considerations
- contents:
  - "8.  Acknowledgements\n   Russ Housley, James Kempf, Christian Vogt, Pekka Nikander,
    and Henrik\n   Levkowetz reviewed and provided comments about this document.\n
    \  Marcelo Bagnulo worked on this document while visiting Ericsson\n   Research
    Laboratory Nomadiclab.\n"
  title: 8.  Acknowledgements
- contents:
  - '9.  References

    '
  - contents:
    - "9.1.  Normative References\n   [1]   Bradner, S., \"Key words for use in RFCs
      to Indicate Requirement\n         Levels\", BCP 14, RFC 2119, March 1997.\n
      \  [2]   Aura, T., \"Cryptographically Generated Addresses (CGA)\",\n         RFC
      3972, March 2005.\n   [3]   Bagnulo, M. and J. Arkko, \"Cryptographically Generated\n
      \        Addresses (CGA) Extension Field Format\", RFC 4581,\n         October
      2006.\n   [4]   Arkko, J., Kempf, J., Zill, B., and P. Nikander, \"SEcure\n
      \        Neighbor Discovery (SEND)\", RFC 3971, March 2005.\n"
    title: 9.1.  Normative References
  - contents:
    - "9.2.  Informative References\n   [5]   Narten, T. and H. Alvestrand, \"Guidelines
      for Writing an IANA\n         Considerations Section in RFCs\", BCP 26, RFC
      2434,\n         October 1998.\n   [6]   Hoffman, P. and B. Schneier, \"Attacks
      on Cryptographic Hashes\n         in Internet Protocols\", RFC 4270, November
      2005.\n   [7]   Nordmark, E. and M. Bagnulo, \"Multihoming L3 Shim Approach\",\n
      \        Work in Progress, July 2005.\n   [8]   Johnson, D., Perkins, C., and
      J. Arkko, \"Mobility Support in\n         IPv6\", RFC 3775, June 2004.\n   [9]
      \  Arkko, J., \"Applying Cryptographically Generated Addresses and\n         Credit-Based
      Authorization to Mobile IPv6\", Work in Progress,\n         June 2006.\n   [10]
      \ Bellovin, S. and E. Rescorla, \"Deploying a New Hash Algorithm\",\n         NDSS
      '06, February 2006.\n"
    title: 9.2.  Informative References
  title: 9.  References
- contents:
  - "Authors' Addresses\n   Marcelo Bagnulo\n   Universidad Carlos III de Madrid\n
    \  Av. Universidad 30\n   Leganes, Madrid  28911\n   SPAIN\n   Phone: 34 91 6249500\n
    \  EMail: marcelo@it.uc3m.es\n   URI:   http://www.it.uc3m.es\n   Jari Arkko\n
    \  Ericsson\n   Jorvas  02420\n   Finland\n   EMail: jari.arkko@ericsson.com\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document
    is subject to the rights, licenses and restrictions\n   contained in BCP 78, and
    except as set forth therein, the authors\n   retain all their rights.\n   This
    document and the information contained herein are provided on an\n   \"AS IS\"
    basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE INTERNET ENGINEERING
    TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT
    LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE
    ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at\n   ietf-ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
