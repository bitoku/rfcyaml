- title: __initial_text__
  contents:
  - '                 Cabletron''s VLS Protocol Specification

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   The Virtual LAN Link State Protocol (VLSP) is part of the InterSwitch\n\
    \   Message Protocol (ISMP) which provides interswitch communication\n   between\
    \ switches running Cabletron's SecureFast VLAN (SFVLAN)\n   product.  VLSP is\
    \ used to determine and maintain a fully connected\n   mesh topology graph of\
    \ the switch fabric.  Each switch maintains an\n   identical database describing\
    \ the topology. Call-originating switches\n   use the topology database to determine\
    \ the path over which to route a\n   call connection.\n   VLSP provides support\
    \ for equal-cost multipath routing, and\n   recalculates routes quickly in the\
    \ face of topological changes,\n   utilizing a minimum of routing protocol traffic.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n    1. Introduction............................................\
    \  3\n       1.1 Acknowledgments.....................................  3\n   \
    \    1.2 Data Conventions....................................  3\n       1.3 ISMP\
    \ Overview.......................................  4\n    2. VLS Protocol Overview...................................\
    \  5\n       2.1 Definitions of Commonly Used Terms..................  6\n   \
    \    2.2 Differences Between VLSP and OSPF...................  7\n           2.2.1\
    \ Operation at the Physical Layer...............  8\n           2.2.2 All Links\
    \ Treated as Point-to-Point...........  8\n           2.2.3 Routing Path Information......................\
    \  9\n           2.2.4 Configurable Parameters.......................  9\n   \
    \        2.2.5 Features Not supported........................  9\n       2.3 Functional\
    \ Summary.................................. 10\n       2.4 Protocol Packets....................................\
    \ 11\n       2.5 Protocol Data Structures............................ 12\n   \
    \    2.6 Basic Implementation Requirements................... 12\n       2.7 Organization\
    \ of the Remainder of This Document...... 13\n    3. Interface Data Structure................................\
    \ 14\n       3.1 Interface States.................................... 16\n   \
    \    3.2 Events Causing Interface State Changes.............. 18\n       3.3 Interface\
    \ State Machine............................. 21\n    4. Neighbor Data Structure.................................\
    \ 23\n       4.1 Neighbor States..................................... 25\n   \
    \    4.2 Events Causing Neighbor State Changes............... 27\n       4.3 Neighbor\
    \ State Machine.............................. 29\n    5. Area Data Structure.....................................\
    \ 33\n       5.1 Adding and Deleting Link State Advertisements....... 34\n   \
    \    5.2 Accessing Link State Advertisements................. 35\n       5.3 Best\
    \ Path Lookup.................................... 35\n    6. Discovery Process.......................................\
    \ 35\n       6.1 Neighbor Discovery.................................. 36\n   \
    \    6.2 Bidirectional Communication......................... 37\n       6.3 Designated\
    \ Switch................................... 38\n           6.3.1 Selecting the\
    \ Designated Switch............... 39\n       6.4 Adjacencies.........................................\
    \ 41\n    7. Synchronizing the Databases............................. 42\n   \
    \    7.1 Link State Advertisements........................... 43\n           7.1.1\
    \ Determining Which\n                 Link State Advertisement Is Newer.............\
    \ 44\n       7.2 Database Exchange Process........................... 44\n   \
    \        7.2.1 Database Description Packets.................. 44\n           7.2.2\
    \ Negotiating the Master/Slave Relationship..... 45\n           7.2.3 Exchanging\
    \ Database Description Packets....... 46\n       7.3 Updating the Database...............................\
    \ 48\n       7.4 An Example.......................................... 49\n   \
    \ 8. Maintaining the Databases............................... 51\n       8.1 Originating\
    \ Link State Advertisements............... 52\n           8.1.1 Switch Link Advertisements....................\
    \ 52\n           8.1.2 Network Link Advertisements................... 55\n   \
    \    8.2 Distributing Link State Advertisements.............. 56\n           8.2.1\
    \ Overview...................................... 57\n           8.2.2 Processing\
    \ an\n                 Incoming Link State Update Packet............. 58\n   \
    \        8.2.3 Forwarding Link State Advertisements.......... 60\n           8.2.4\
    \ Installing Link\n                 State Advertisements in the Database..........\
    \ 62\n           8.2.5 Retransmitting Link State Advertisements...... 63\n   \
    \        8.2.6 Acknowledging Link State Advertisements....... 64\n       8.3 Aging\
    \ the Link State Database....................... 66\n           8.3.1 Premature\
    \ Aging of Advertisements............. 66\n    9. Calculating the Best Paths..............................\
    \ 67\n   10. Protocol Packets........................................ 67\n   \
    \    10.1 ISMP Packet Format................................. 68\n           \
    \ 10.1.1 Frame Header................................ 69\n            10.1.2 ISMP\
    \ Packet Header.......................... 70\n            10.1.3 ISMP Message\
    \ Body........................... 71\n       10.2 VLSP Packet Processing.............................\
    \ 71\n       10.3 Network Layer Address Information.................. 72\n   \
    \    10.4 VLSP Packet Header................................. 73\n       10.5\
    \ Options Field...................................... 75\n       10.6 Packet Formats.....................................\
    \ 76\n            10.6.1 Hello Packets............................... 76\n   \
    \         10.6.2 Database Description Packets................ 78\n           \
    \ 10.6.3 Link State Request Packets.................. 80\n            10.6.4 Link\
    \ State Update Packets................... 82\n            10.6.5 Link State Acknowledgment\
    \ Packets........... 83\n   11. Link State Advertisement Formats........................\
    \ 84\n       11.1 Link State Advertisement Headers................... 84\n   \
    \    11.2 Switch Link Advertisements......................... 86\n       11.3\
    \ Network Link Advertisements........................ 89\n   12. Protocol Parameters.....................................\
    \ 89\n       12.1 Architectural Constants............................ 90\n   \
    \    12.2 Configurable Parameters............................ 91\n   13. End Notes...............................................\
    \ 93\n   14. Security Considerations................................. 94\n   15.\
    \ References.............................................. 94\n   16. Author's\
    \ Address........................................ 94\n   17. Full Copyright Statement................................\
    \ 95\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   This memo is being distributed to members of the Internet\
    \ community\n   in order to solicit reactions to the proposals contained herein.\n\
    \   While the specification discussed here may not be directly relevant\n   to\
    \ the research problems of the Internet, it may be of interest to\n   researchers\
    \ and implementers.\n"
- title: 1.1 Acknowledgments
  contents:
  - "1.1 Acknowledgments\n   VLSP is derived from the OSPF link-state routing protocol\
    \ described\n   in [RFC2328], written by John Moy, formerly of Proteon, Inc.,\n\
    \   Westborough, Massachusetts.  Much of the current memo has been drawn\n   from\
    \ [RFC2328].  Therefore, this author wishes to acknowledge the\n   contribution\
    \ Mr. Moy has (unknowingly) made to this document.\n"
- title: 1.2 Data Conventions
  contents:
  - "1.2 Data Conventions\n   The methods used in this memo to describe and picture\
    \ data adhere to\n   the standards of Internet Protocol documentation [RFC1700].\
    \  In\n   particular:\n      The convention in the documentation of Internet Protocols\
    \ is to\n      express numbers in decimal and to picture data in \"big-endian\"\
    \n      order.  That is, fields are described left to right, with the most\n \
    \     significant octet on the left and the least significant octet on\n     \
    \ the right.  The order of transmission of the header and data\n      described\
    \ in this document is resolved to the octet level.\n      Whenever a diagram shows\
    \ a group of octets, the order of\n      transmission of those octets is the normal\
    \ order in which they are\n      read in English.\n      Whenever an octet represents\
    \ a numeric quantity the left most bit\n      in the diagram is the high order\
    \ or most significant bit.  That\n      is, the bit labeled 0 is the most significant\
    \ bit.\n      Similarly, whenever a multi-octet field represents a numeric\n \
    \     quantity the left most bit of the whole field is the most\n      significant\
    \ bit.  When a multi-octet quantity is transmitted the\n      most significant\
    \ octet is transmitted first.\n"
- title: 1.3 ISMP Overview
  contents:
  - "1.3 ISMP Overview\n   The InterSwitch Message Protocol (ISMP) provides a consistent\
    \ method\n   of encapsulating and transmitting control messages exchanged between\n\
    \   switches running Cabletron's SecureFast VLAN (SFVLAN) product, as\n   described\
    \ in [IDsfvlan].  ISMP provides the following services:\n   o  Topology services.\
    \  Each switch maintains a distributed topology\n      of the switch fabric by\
    \ exchanging the following interswitch\n      control messages with other switches:\n\
    \   o  Interswitch Keepalive messages are sent by each switch to announce\n  \
    \    its existence to its neighboring switches and to establish the\n      topology\
    \ of the switch fabric.  (Interswitch Keepalive messages\n      are exchanged\
    \ in accordance with Cabletron's VlanHello protocol,\n      described in [IDhello].)\n\
    \   o  Interswitch Spanning Tree BPDU messages and Interswitch Remote\n      Blocking\
    \ messages are used to determine and maintain a loop-free\n      flood path between\
    \ all network switches in the fabric.  This flood\n      path is used for all\
    \ undirected interswitch messages -- that is,\n      messages that are (potentially)\
    \ sent to all switches in the switch\n      fabric.\n   o  Interswitch Link State\
    \ messages (VLS protocol) are used to\n      determine and maintain a fully connected\
    \ mesh topology graph of\n      the switch fabric.  Call-originating switches\
    \ use the topology\n      graph to determine the path over which to route a call\
    \ connection.\n   o  Address resolution services.  Interswitch Resolve messages\
    \ are\n      used to resolve a packet destination address when the packet\n  \
    \    source and destination pair does not match a known connection.\n      Interswitch\
    \ New User messages are used to provide end-station\n      address mobility between\
    \ switches.\n   o  Tag-based flooding.  A tag-based broadcast method is used to\n\
    \      restrict the broadcast of unresolved packets to only those ports\n    \
    \  within the fabric that belong to the same VLAN as the source.\n   o  Call tapping\
    \ services.  Interswitch Tap messages are used to\n      monitor traffic moving\
    \ between two end stations.  Traffic can be\n      monitored in one or both directions\
    \ along the connection path.\n   Note:  Previous versions of VLSP treated all\
    \ links as if they were\n   broadcast (multi-access).  Thus, if VLSP determines\
    \ that a neighbor\n   switch is running an older version of the protocol software\
    \ (see\n   Section 6.1), it will change the interface type to broadcast and\n\
    \   begin exchanging Hello packets with the single neighbor switch.\n"
- title: 2. VLS Protocol Overview
  contents:
  - "2. VLS Protocol Overview\n   VLSP is a dynamic routing protocol.  It quickly\
    \ detects topological\n   changes in the switch fabric (such as, switch interface\
    \ failures) and\n   calculates new loop-free routes after a period of convergence.\
    \  This\n   period of convergence is short and involves a minimum of routing\n\
    \   traffic.\n   All switches in the fabric run the same algorithm and maintain\n\
    \   identical databases describing the switch fabric topology.  This\n   database\
    \ contains each switch's local state, including its usable\n   interfaces and\
    \ reachable neighbors.  Each switch distributes its\n   local state throughout\
    \ the switch fabric by flooding.  From the\n   topological database, each switch\
    \ constructs a set of best path trees\n   (using itself as the root) that specify\
    \ routes to all other switches\n   in the fabric.\n"
- title: 2.1 Definitions of Commonly Used Terms
  contents:
  - "2.1 Definitions of Commonly Used Terms\n   This section contains a collection\
    \ of definitions for terms that have\n   a specific meaning to the protocol and\
    \ that are used throughout the\n   text.\n   Switch ID\n      A 10-octet value\
    \ that uniquely identifies the switch within the\n      switch fabric.  The value\
    \ consists of the 6-octet base MAC address\n      of the switch, followed by 4\
    \ octets of zeroes.\n   Network link\n      The physical connection between two\
    \ switches.  A link is\n      associated with a switch interface.\n      There\
    \ are two physical types of network links supported by VLSP:\n      o  Point-to-point\
    \ links that join a single pair of switches.  A\n         serial line is an example\
    \ of a point-to-point network link.\n      o  Multi-access broadcast links that\
    \ support the attachment of\n         multiple switches, along with the capability\
    \ to address a\n         single message to all the attached switches.  An attached\n\
    \         ethernet is an example of a multi-access broadcast network\n       \
    \  link.\n         A single topology can contain both types of links.  At startup,\n\
    \         all links are assumed to be point-to-point.  A link is\n         determined\
    \ to be multi-access when more than one neighboring\n         switch is discovered\
    \ on the link.\n   Interface\n      The port over which a switch accesses one\
    \ of its links.\n      Interfaces are identified by their interface ID, a 10-octet\
    \ value\n      consisting of the 6-octet base MAC address of the switch, followed\n\
    \      by the 4-octet local port number of the interface.\n   Neighboring switches\n\
    \      Two switches attached to a common link.\n   Adjacency\n      A relationship\
    \ formed between selected neighboring switches for\n      the purpose of exchanging\
    \ routing information.  Not every pair of\n      neighboring switches become adjacent.\n\
    \   Link state advertisement\n      Describes the local state of a switch or a\
    \ link.  Each link state\n      advertisement is flooded throughout the switch\
    \ fabric.  The\n      collected link state advertisements of all switches and\
    \ links form\n      the protocol's topological database.\n   Designated switch\n\
    \      Each multi-access network link has a designated switch.  The\n      designated\
    \ switch generates a link state advertisement for the\n      link and has other\
    \ special responsibilities in the running of the\n      protocol.\n      The use\
    \ of a designated switch permits a reduction in the number\n      of adjacencies\
    \ required on multi-access links.  This in turn\n      reduces the amount of routing\
    \ protocol traffic and the size of the\n      topological database.\n      The\
    \ designated switch is selected during the discovery process.  A\n      designated\
    \ switch is not selected for a point-to-point network\n      link.\n   Backup\
    \ designated switch\n      Each multi-access network link has a backup designated\
    \ switch.\n      The backup designated switch maintains adjacencies with the same\n\
    \      switches on the link as the designated switch.  This optimizes the\n  \
    \    failover time when the backup designated switch must take over for\n    \
    \  the (failed) designated switch.\n      The backup designated switch is selected\
    \ during the Discovery\n      process.  A backup designated switch is not selected\
    \ for a point-\n      to-point network link.\n"
- title: 2.2 Differences Between VLSP and OSPF
  contents:
  - "2.2 Differences Between VLSP and OSPF\n   The VLS protocol is derived from the\
    \ OSPF link-state routing protocol\n   described in [RFC2328].\n"
- title: 2.2.1 Operation at the Physical Layer
  contents:
  - "2.2.1 Operation at the Physical Layer\n   The primary differences between the\
    \ VLS and OSPF protocols stem from\n   the fact that OSPF runs over the IP layer,\
    \ while VLSP runs at the\n   physical MAC layer.  This difference has the following\
    \ repercussions:\n   o  VLSP does not support features (such as fragmentation)\
    \ that are\n      typically provided by network layer service providers.\n   o\
    \  Due to the unrelated nature of MAC address assignments, VLSP\n      provides\
    \ no summarization of the address space (such as, classical\n      IP subnet information)\
    \ or level 2 routing (such as,\n      IS-IS Phase V DECnet).  Thus, VLSP does\
    \ not support grouping\n      switches into areas.  All switches exist in a single\
    \ area.  Since\n      a single domain exists within any switch fabric, there is\
    \ no need\n      for VLSP to provide interdomain reachability.\n   o  As mentioned\
    \ in Section 10.1.1, ISMP uses a single well-known\n      multicast address for\
    \ all packets.  However, parts of the VLS\n      protocol (as derived from OSPF)\
    \ are dependent on certain network\n      layer addresses -- in particular, the\
    \ AllSPFSwitches and\n      AllDSwitches multicast addresses that drive the distribution\
    \ of\n      link state advertisements throughout the switch fabric.  In order\n\
    \      to facilitate the implementation of the protocol at the physical\n    \
    \  MAC layer, network layer address information is encapsulated in\n      the\
    \ protocol packets (see Section 10.3).  This information is\n      unbundled and\
    \ packets are then processed as if they had been sent\n      or received on that\
    \ multicast address.\n"
- title: 2.2.2 All Links Treated as Point-to-Point
  contents:
  - "2.2.2 All Links Treated as Point-to-Point\n   When the switch first comes on\
    \ line, VLSP assumes all network links\n   are point-to-point and no more than\
    \ one neighboring switch will be\n   discovered on any one port.  Therefore, at\
    \ startup, VLSP does not\n   send its own Hello packets over its network ports,\
    \ but instead,\n   relies on the VlanHello protocol [IDhello] for the discovery\
    \ of its\n   neighbor switches.  If a second neighbor is detected on a link, the\n\
    \   link is then deemed multi-access and the interface type is changed to\n  \
    \ broadcast.  At that point, VLSP exchanges its own Hello packets with\n   the\
    \ switches on the link in order to select a designated switch and\n   designated\
    \ backup switch for the link.\n   This method eliminates unnecessary duplication\
    \ of message traffic and\n   processing, thereby increasing the overall efficiency\
    \ of the switch\n   fabric.\n   Note:  Previous versions of VLSP treated all links\
    \ as if they were\n   broadcast (multi-access).  Thus, if VLSP determines that\
    \ a neighbor\n   switch is running an older version of the protocol software (see\n\
    \   Section 6.1), it will change the interface type to broadcast and\n   begin\
    \ exchanging Hello packets with the single neighbor switch.\n"
- title: 2.2.3 Routing Path Information
  contents:
  - "2.2.3 Routing Path Information\n   Instead of providing the next hop to a destination,\
    \ VLSP calculates\n   and maintains complete end-to-end path information. On request,\
    \ a\n   list of individual port identifiers is generated describing a\n   complete\
    \ path from the source switch to the destination switch.  If\n   multiple equal-cost\
    \ routes exist to a destination switch, up to three\n   paths are calculated and\
    \ returned.\n"
- title: 2.2.4 Configurable Parameters
  contents:
  - "2.2.4 Configurable Parameters\n   OSPF supports (and requires) configurable parameters.\
    \  In fact, even\n   the default OSPF configuration requires that IP address assignments\n\
    \   be specified.  On the other hand, no configuration information is\n   ever\
    \ required for the VLS protocol.  Switches are uniquely identified\n   by their\
    \ base MAC addresses and ports are uniquely identified by the\n   base MAC address\
    \ of the switch and a port number.\n   While a developer is free to implement\
    \ configurable parameters for\n   the VLS protocol, the current version of VLSP\
    \ supports configurable\n   path metrics only.  Note that this has the following\
    \ repercussions:\n   o  All switches are assigned a switch priority of 1.  This\
    \ forces the\n      selection of the designated switch to be based solely on base\
    \ MAC\n      address.\n   o  Authentication is not supported.\n"
- title: 2.2.5 Features Not supported
  contents:
  - "2.2.5 Features Not supported\n   In addition to those features mentioned in the\
    \ previous sections, the\n   following OSPF features are not supported by the\
    \ current version of\n   VLSP:\n   o  Periodic refresh of link state advertisements.\
    \  (This optimizes\n      performance by eliminating unnecessary traffic between\
    \ the\n      switches.)\n   o  Routing based on non-zero type of service (TOS).\n\
    \   o  Use of external routing information for destinations outside the\n    \
    \  switch fabric.\n"
- title: 2.3 Functional Summary
  contents:
  - "2.3 Functional Summary\n   There are essentially four operational stages of the\
    \ VLS protocol.\n   o  Discovery Process The discovery process involves two steps:\n\
    \      o  Neighboring switches are detected by the VlanHello protocol\n      \
    \   [IDhello] which then notifies VLSP of the neighbor.\n      o  If more than\
    \ one neighbor switch is detected on a single port,\n         the link is determined\
    \ to be multi-access.  VLSP then sends its\n         own Hello packets over the\
    \ link in order to discover the full\n         set of neighbors on the link and\
    \ select a designated switch and\n         designated backup switch for the link.\
    \  Note that this\n         selection process is unnecessary on point-to-point\
    \ links.\n      The discovery process is described in more detail in Section 6.\n\
    \   o  Synchronizing the Databases\n      Adjacencies are used to simplify and\
    \ speed up the process of\n      synchronizing the topological database (also\
    \ known as the link\n      state database) maintained by each switch in the fabric.\
    \  Each\n      switch is only required to synchronize its database with those\n\
    \      neighbors to which it is adjacent. This reduces the amount of\n      routing\
    \ protocol traffic across the fabric, particularly for\n      multi-access links\
    \ with multiple switches.\n      The process of synchronizing the databases is\
    \ described in more\n      detail in Section 7.\n   o  Maintaining the Databases\n\
    \      Each switch advertises its state (also known as its link state)\n     \
    \ any time its link state changes.  Link state advertisements are\n      distributed\
    \ throughout the switch fabric using a reliable flooding\n      algorithm that\
    \ ensures that all switches in the fabric are\n      notified of any link state\
    \ changes.\n      The process of maintaining the databases is described in more\n\
    \      detail in Section 8.\n   o  Calculating the Best Paths\n      The link\
    \ state database consists of the collection of link state\n      advertisements\
    \ received from each switch.  Each switch uses its\n      link state database\
    \ to calculate a set of best paths, using itself\n      as root, to all other\
    \ switches in the fabric.\n      The process of recalculating the set of best\
    \ paths is described in\n      more detail in Section 9.\n"
- title: 2.4 Protocol Packets
  contents:
  - "2.4 Protocol Packets\n   In addition to the frame header and the ISMP packet\
    \ header described\n   in Section 10.1, all VLS protocol packets share a common\
    \ protocol\n   header, described in Section 10.4.\n   The VLSP packet types are\
    \ listed below in Table 1.  Their formats are\n   described in Section 10.6.\n\
    \      Type   Packet Name            Protocol Function\n      1      Hello   \
    \               Select DS and Backup DS\n      2      Database Description   Summarize\
    \ database contents\n      3      Link State Request     Database download\n \
    \     4      Link State Update      Database update\n      5      Link State Ack\
    \         Flooding acknowledgment\n                  Table 1: VLSP Packet Types\n\
    \   The Hello packets are used to select the designated switch and the\n   backup\
    \ designated switch on multi-access links.  The Database\n   Description and Link\
    \ State Request packets are used to form\n   adjacencies.  Link State Update and\
    \ Link State Acknowledgment packets\n   are used to update the topological database.\n\
    \   Each Link State Update packet carries a set of link state\n   advertisements.\
    \  A single Link State Update packet may contain the\n   link state advertisements\
    \ of several switches.  There are two\n   different types of link state advertisement,\
    \ as shown below in Table\n   2.\n         LS     Advertisement    Advertisement\
    \ Description\n         Type   Name\n         1      Switch link      Originated\
    \ by all switches. This\n                advertisements   advertisement describes\
    \ the collected\n                                 states of the switch's interfaces.\n\
    \         2      Network link     Originated by the designated switch.\n     \
    \           advertisements   This advertisement contains the list\n          \
    \                       of switches connected to the network\n               \
    \                  link.\n                  Table 2: VLSP Link State Advertisements\n"
- title: 2.5 Protocol Data Structures
  contents:
  - "2.5 Protocol Data Structures\n   The VLS protocol is described in this specification\
    \ in terms of its\n   operation on various protocol data structures.  Table 3\
    \ lists the\n   primary VLSP data structures, along with the section in which\
    \ they\n   are described in detail.\n         Structure Name                 \
    \       Description\n         Interface Data Structure              Section 3\n\
    \         Neighbor Data Structure               Section 4\n         Area Data\
    \ Structure                   Section 5\n                     Table 3: VLSP Data\
    \ Structures\n"
- title: 2.6 Basic Implementation Requirements
  contents:
  - "2.6 Basic Implementation Requirements\n   An implementation of the VLS protocol\
    \ requires the following pieces\n   of system support:\n   Timers\n      Two types\
    \ of timer are required.  The first type, known as a one-\n      shot timer, expires\
    \ once and triggers an event.  The second type,\n      known as an interval timer,\
    \ expires at preset intervals.  Interval\n      timers are used to trigger events\
    \ at periodic intervals.  The\n      granularity of both types of timers is one\
    \ second.\n      Interval timers should be implemented in such a way as to avoid\n\
    \      drift.  In some switch implementations, packet processing can\n      affect\
    \ timer execution.  For example, on a multi-access link with\n      multiple switches,\
    \ regular broadcasts can lead to undesirable\n      synchronization of routing\
    \ packets unless the interval timers have\n      been implemented to avoid drift.\
    \  If it is not possible to\n      implement drift-free timers, small random amounts\
    \ of time should\n      be added to or subtracted from the timer interval at each\
    \ firing.\n   List manipulation primitives\n      Much of the functionality of\
    \ VLSP is described here in terms of\n      its operation on lists of link state\
    \ advertisements.  Any\n      particular advertisement may be on many such lists.\
    \ Implementation\n      of VLSP must be able to manipulate these lists, adding\
    \ and\n      deleting constituent advertisements as necessary.\n   Tasking support\n\
    \      Certain procedures described in this specification invoke other\n     \
    \ procedures.  At times, these other procedures should be executed\n      in-line\
    \ -- that is, before the current procedure has finished.\n      This is indicated\
    \ in the text by instructions to \"execute\" a\n      procedure.  At other times,\
    \ the other procedures are to be\n      executed only when the current procedure\
    \ has finished.  This is\n      indicated by instructions to \"schedule\" a task.\
    \  Implementation of\n      VLSP must provide these two types of tasking support.\n"
- title: 2.7 Organization of the Remainder of This Document
  contents:
  - "2.7 Organization of the Remainder of This Document\n   The remainder of this\
    \ document is organized as follows:\n   o  Section 3 through Section 5 describe\
    \ the primary data structures\n      used by the protocol.  Note that this specification\
    \ is presented\n      in terms of these data structures in order to make explanations\n\
    \      more precise.  Implementations of the protocol must support the\n     \
    \ functionality described, but need not use the exact data\n      structures that\
    \ appear in this specification.\n   o  Section 6 through Section 9 describe the\
    \ four operational stages\n      of the protocol:  the discovery process, synchronizing\
    \ the\n      databases, maintaining the databases, and calculating the set of\n\
    \      best paths.\n   o  Section 10 describes the processing of VLSP packets\
    \ and presents\n      detailed descriptions of their formats.\n   o  Section 11\
    \ presents detailed descriptions of link state\n      advertisements.\n   o  Section\
    \ 12 summarizes the protocol parameters.\n"
- title: 3. Interface Data Structure
  contents:
  - "3. Interface Data Structure\n   The port over which a switch accesses a network\
    \ link is known as the\n   link interface.  Each switch maintains a separate interface\
    \ data\n   structure for each network link.\n   The following data items are associated\
    \ with each interface:\n   Type\n      The type of network to which the interface\
    \ is attached -- point-\n      to-point or broadcast (multi-access).  This data\
    \ item is\n      initialized to point-to-point when the interface becomes\n  \
    \    operational.  If a second neighbor is detected on the link after\n      the\
    \ first neighbor has been discovered, the link interface type is\n      changed\
    \ to broadcast.  The type remains as broadcast until the\n      interface is declared\
    \ down, at which time the type reverts to\n      point-to-point.\n   Note:  Previous\
    \ versions of VLSP treated all links as if they were\n   multi-access.  Thus,\
    \ if VLSP determines that a neighbor switch is\n   running an older version of\
    \ the protocol software (see Section 6.1),\n   it will change the interface type\
    \ to broadcast.\n   State\n      The functional level of the interface.  The state\
    \ of the interface\n      is included in all switch link advertisements generated\
    \ by the\n      switch, and is also used to determine whether full adjacencies\
    \ are\n      allowed on the interface.  See Section 3.1 for a complete\n     \
    \ description of interface states.\n   Interface identifier\n      A 10-octet\
    \ value that uniquely identifies the interface. This\n      value consists of\
    \ the 6-octet base MAC address of the neighbor\n      switch, followed by the\
    \ 4-octet local port number of the\n      interface.\n   Area ID\n      A 4-octet\
    \ value identifying the area.  Since VLSP does not support\n      multiple areas,\
    \ the value here is always zero.\n   HelloInterval\n      The interval, in seconds,\
    \ at which the switch sends VLSP Hello\n      packets over the interface.  This\
    \ parameter is not used on point-\n      to-point links.\n   SwitchDeadInterval\n\
    \      The length of time, in seconds, that neighboring switches will\n      wait\
    \ before declaring the local switch dNeighboring switches\n      A list of the\
    \ neighboring switches attached to this network link.\n      This list is created\
    \ during the discovery process. Adjacencies are\n      formed to one or more of\
    \ these neighbors. The set of adjacent\n      neighbors can be determined by examining\
    \ the states of the\n      neighboring switches as shown in their link state advertisements.\n\
    \   Designated switch\n      The designated switch selected for the multi-access\
    \ network link.\n      (A designated switch is not selected for a point-to-point\
    \ link.)\n      This data item is initialized to zero when the switch comes on-\n\
    \      line, indicating that no designated switch has been chosen for the\n  \
    \    link.\n   Backup designated switch\n      The backup designated switch selected\
    \ for the multi-access network\n      link.  (A backup designated switch is not\
    \ selected for a point-\n      to-point link.)  This data item is initialized\
    \ to zero when the\n      switch comes on-line, indicating that no backup designated\
    \ switch\n      has been chosen for the link.\n   Interface output cost(s)\n \
    \     The cost of sending a packet over the interface.  The link cost is\n   \
    \   expressed in the link state metric and must be greater than zero.\n   RxmtInterval\n\
    \      The number of seconds between link state advertisement\n      retransmissions,\
    \ for adjacencies belonging to this interface. This\n      value is also used\
    \ to time the retransmission of Database\n      Description and Link State Request\
    \ packets.\n"
- title: 3.1 Interface States
  contents:
  - "3.1 Interface States\n   This section describes the various states of a switch\
    \ interface. The\n   states are listed in order of progressing functionality.\
    \ For example,\n   the inoperative state is listed first, followed by a list of\
    \ the\n   intermediate states through which the interface passes before\n   attaining\
    \ the final, fully functional state.  The specification makes\n   use of this\
    \ ordering by references such as \"those interfaces in state\n   greater than\
    \ X\".\n   Figure 1 represents the interface state machine, showing the\n   progression\
    \ of interface state changes.  The arrows on the graph\n   represent the events\
    \ causing each state change.  These events are\n   described in Section 3.2. \
    \ The interface state machine is described\n   in detail in Section 3.3.\n   Down\n\
    \      This is the initial state of the interface.  In this state, the\n     \
    \ interface is unusable, and no protocol traffic is sent or received\n      on\
    \ the interface.  In this state, interface parameters are set to\n      their\
    \ initial values, all interface timers are disabled, and no\n      adjacencies\
    \ are associated with the interface.\n       +-------+\n       |  any  |  Interface\
    \   +----------+  Unloop Ind  +----------+\n       | state | -----------> |  \
    \ Down   | <----------- | Loopback |\n       +-------+    Down      +----------+\
    \              +----------+\n                                   |            \
    \             ^\n                                   | Interface Up           \
    \ |\n           +-------+  [pt-to-pt]   |                         |\n        \
    \   | Point |<------------type?              Loop Ind |\n           |  to   |\
    \               |                         |\n           | Point |            \
    \   | [broadcast]             |\n           +-------+               V        \
    \             +-------+\n                             +-----------+          \
    \     |  any  |\n                             |  Waiting  |               | state\
    \ |\n                             +-----------+               +-------+\n    \
    \                               |\n                       Backup Seen |\n    \
    \                               | Wait Timer\n                               \
    \    |\n                                   |\n      +----------+    Neighbor \
    \    V     Neighbor    +----------+\n      |    DS    | <------------> [ ] <------------>\
    \ | DS Other |\n      +----------+     Change      ^      Change     +----------+\n\
    \                                   |\n                                   |\n\
    \                   Neighbor Change |\n                                   |\n\
    \                                   V\n                              +----------+\n\
    \                              |  Backup  |\n                              +----------+\n\
    \                   Figure 1:  Interface State Machine\n   Loopback\n      In\
    \ this state, the switch interface is looped back, either in\n      hardware or\
    \ in software.  The interface is unavailable for regular\n      data traffic.\n\
    \   Point-to-Point\n      In this state, the interface is operational and is connected\
    \ to a\n      physical point-to-point link.  On entering this state, the switch\n\
    \      attempts to form an adjacency with the neighboring switch.\n   Waiting\n\
    \      In this state, the switch is attempting to identify the backup\n      designated\
    \ switch for the link by monitoring the Hello packets it\n      receives.  The\
    \ switch does not attempt to select a designated\n      switch or a backup designated\
    \ switch until it changes out of this\n      state, thereby preventing unnecessary\
    \ changes of the designated\n      switch and its backup.\n   DS Other\n     \
    \ In this state, the interface is operational and is connected to a\n      multi-access\
    \ broadcast link on which other switches have been\n      selected as the designated\
    \ switch and the backup designated\n      switch.   On entering this state, the\
    \ switch attempts to form\n      adjacencies with both the designated switch and\
    \ the backup\n      designated switch.\n   Backup\n      In this state, the switch\
    \ itself is the backup designated switch\n      on the attached multi-access broadcast\
    \ link.  It will be promoted\n      to designated switch if the current designated\
    \ switch fails.  The\n      switch establishes adjacencies with all other switches\
    \ attached to\n      the link.  (See Section 6.3 for more information on the functions\n\
    \      performed by the backup designated switch.)\n   DS\n      In this state,\
    \ this switch itself is the designated switch on the\n      attached multi-access\
    \ broadcast link.  The switch establishes\n      adjacencies with all other switches\
    \ attached to the link.  The\n      switch is responsible for originating network\
    \ link advertisements\n      for the link, containing link information for all\
    \ switches\n      attached to the link, including the designated switch itself.\n\
    \      (See Section 6.3 for more information on the functions performed\n    \
    \  by the designated switch.)\n"
- title: 3.2 Events Causing Interface State Changes
  contents:
  - "3.2 Events Causing Interface State Changes\n   The state of an interface changes\
    \ due to an interface event.  This\n   section describes these events.\n   Interface\
    \ events are shown as arrows in Figure 1, the graphic\n   representation of the\
    \ interface state machine.  For more information\n   on the interface state machine,\
    \ see Section 3.3.\n   Interface Up\n      This event is generated by the VlanHello\
    \ protocol [IDhello] when\n      it discovers a neighbor switch on the interface.\
    \  The interface is\n      now operational.  This event causes the interface to\
    \ change out of\n      the Down state.  The state it enters is determined by the\n\
    \      interface type.  If the interface type is broadcast (multi-\n      access),\
    \ this event also causes the switch to begin sending\n      periodic Hello packets\
    \ out over the interface.\n   Wait Timer\n      This event is generated when the\
    \ one-shot Wait timer expires,\n      triggering the end of the required waiting\
    \ period before the\n      switch can begin the process of selecting a designated\
    \ switch and\n      a backup designated switch on a multi-access link.\n   Backup\
    \ Seen\n      This event is generated when the switch has detected the existence\n\
    \      or non-existence of a backup designated switch for the link, as\n     \
    \ determined in one of the following two ways:\n      o  A Hello packet has been\
    \ received from a neighbor that claims to\n         be the backup designated switch.\n\
    \      o  A Hello packet has been received from a neighbor that claims to\n  \
    \       be the designated switch.  In addition, the packet indicated\n       \
    \  that there is no backup.\n   In either case, the interface must have bidirectional\
    \ communication\n   with its neighbor -- that is, the local switch must be listed\
    \ in the\n   neighbor's Hello packet.\n   This event signals the end of the Waiting\
    \ state.\n   Neighbor change\n      This event is generated when there has been\
    \ one of the following\n      changes in the set of bidirectional neighbors associated\
    \ with the\n      interface.  (See Section 4.1 for information on neighbor states.)\n\
    \      o  Bidirectional communication has been established with a\n         neighbor\
    \ -- the state of the neighbor has changed to 2-Way or\n         higher.\n   \
    \   o  Bidirectional communication with a neighbor has been lost --\n        \
    \ the state of the neighbor has changed to Init or lower.\n      o  A bidirectional\
    \ neighbor has just declared itself to be either\n         the designated switch\
    \ or the backup designated switch, as\n         detected by examination of that\
    \ neighbor's Hello packets.\n      o  A bidirectional neighbor is no longer declaring\
    \ itself to be\n         either the designated switch or the backup designated\
    \ switch,\n         as detected by examination of that neighbor's Hello packets.\n\
    \      o  The advertised switch priority of a bidirectional neighbor has\n   \
    \      changed, as detected by examination of that neighbor's Hello\n        \
    \ packets.\n      When this event occurs, the designated switch and the backup\n\
    \      designated switch must be reselected.\n      Loop Ind\n         This event\
    \ is generated when an interface enters the Loopback\n         state.  This event\
    \ can be generated by either the network\n         management service or by the\
    \ lower-level protocols.\n      Unloop Ind\n         This event is generated when\
    \ an interface leaves the Loopback\n         state.  This event can be generated\
    \ by either the network\n         management service or by the lower-level protocols.\n\
    \      Interface Down\n         This event is generated under the following two\
    \ circumstances:\n         o  The VlanHello [IDhello] protocol has determined\
    \ that the\n            interface is no longer functional.\n         o  The neighbor\
    \ state machine has detected a second neighboring\n            switch on a link\
    \ presumed to be of type point-to-point. In\n            addition to generating\
    \ the Interface Down event, the\n            neighbor state machine changes the\
    \ interface type to\n            broadcast.\n      In both instances, this event\
    \ forces the interface state to Down.\n      However, when the event is generated\
    \ by the neighbor state\n      machine, it is immediately followed by an Interface\
    \ Up event.\n      (See Section 4.3.)\n"
- title: 3.3 Interface State Machine
  contents:
  - "3.3 Interface State Machine\n   This section presents a detailed description\
    \ of the interface state\n   machine.\n   Interface states (see Section 3.1) change\
    \ as the result of various\n   events (see Section 3.2).  However, the effect\
    \ of each event can\n   vary, depending on the current state of the interface.\
    \ For this\n   reason, the state machine described in this section is organized\n\
    \   according to the current interface state and the occurring event.\n   For\
    \ each state/event pair, the new interface state is listed, along\n   with a description\
    \ of the required processing.\n   Note that when the state of an interface changes,\
    \ it may be necessary\n   to originate a new switch link advertisement.  See Section\
    \ 8.1 for\n   more information.\n   Some of the processing described here includes\
    \ generating events for\n   the neighbor state machine.  For example, when an\
    \ interface becomes\n   inoperative, all neighbor connections associated with\
    \ the interface\n   must be destroyed.  For more information on the neighbor state\n\
    \   machine, see Section 4.3.\n   State(s):  Down\n   Event:  Interface Up\n \
    \  New state:  Depends on action routine\n   Action:\n      If the interface is\
    \ a point-to-point link, set the interface state\n      to Point-to-Point.  Otherwise,\
    \ start the Hello interval timer,\n      enabling the periodic sending of Hello\
    \ packets over the interface.\n      If the switch is not eligible to become the\
    \ designated switch,\n      change the interface state to DS Other. Otherwise,\
    \ set the\n      interface state to Waiting and start the one-shot wait timer.\n\
    \      Create a new neighbor data structure for the neighbor switch,\n      initialize\
    \ all neighbor parameters and set the stateof the\n      neighbor to Down.\n \
    \  State(s):  Waiting\n   Event:  Backup Seen\n   New state:  Depends on action\
    \ routine\n   Action:\n      Select the designated switch and backup designated\
    \ switch for the\n      attached link, as described in Section 6.3.1.  As a result\
    \ of this\n      selection, set the new state of the interface to either DS Other,\n\
    \      Backup or DS.\n   State(s):  Waiting\n   Event:  Wait Timer\n   New state:\
    \  Depends on action routine\n   Action:\n      Select the designated switch and\
    \ backup designated switch for the\n      attached link, as described in Section\
    \ 6.3.1.  As a result of this\n      selection, set the new state of the interface\
    \ to either DS Other,\n      Backup or DS.\n   State(s):  DS Other, Backup or\
    \ DS\n   Event:  Neighbor Change\n   New state:  Depends on action routine\n \
    \  Action:\n      Reselect the designated switch and backup designated switch\
    \ for\n      the attached link, as described in Section 6.3.1.  As a result of\n\
    \      this selection, set the new state of the interface to either DS\n     \
    \ Other, Backup or DS.\n   State(s):  Any State\n   Event:  Interface Down\n \
    \  New state:  Down\n   Action:\n      Reset all variables in the interface data\
    \ structure and disable\n      all timers.  In addition, destroy all neighbor\
    \ connections\n      associated with the interface by generating the KillNbr event\
    \ on\n      all neighbors listed in the interface data structure.\n   State(s):\
    \  Any State\n   Event:  Loop Ind\n   New state:  Loopback\n   Action:\n     \
    \ Reset all variables in the interface data structure and disable\n      all timers.\
    \  In addition, destroy all neighbor connections\n      associated with the interface\
    \ by generating the KillNbr event on\n      all neighbors listed in the interface\
    \ data structure.\n   State(s):  Loopback\n   Event:  Unloop Ind\n   New state:\
    \  Down\n   Action:\n      No action is necessary beyond changing the interface\
    \ state to Down\n      because the interface was reset on entering the Loopback\
    \ state.\n"
- title: 4. Neighbor Data Structure
  contents:
  - "4. Neighbor Data Structure\n   Each switch conducts a conversation with its neighboring\
    \ switches and\n   each conversation is described by a neighbor data structure.\
    \  A\n   conversation is associated with a switch interface, and is identified\n\
    \   by the neighboring switch ID.\n   Note that if two switches have multiple\
    \ attached links in common,\n   multiple conversations ensue, each described by\
    \ a unique neighbor\n   data structure.  Each separate conversation is treated\
    \ as a separate\n   neighbor.\n   The neighbor data structure contains all information\
    \ relevant to any\n   adjacency formed between the two neighbors.  Remember, however,\
    \ that\n   not all neighbors become adjacent.  An adjacency can be thought of\
    \ as\n   a highly developed conversation between two switches.\n   State\n   \
    \   The functional level of the neighbor conversation.  See Section\n      4.1\
    \ for a complete description of neighbor states.\n   Inactivity timer\n      A\
    \ one-shot timer used to determine when to declare the neighbor\n      down if\
    \ no Hello packet is received from this (multi-access)\n      neighbor.  The length\
    \ of the timer is SwitchDeadInterval seconds,\n      as contained in the neighbor's\
    \ Hello packet.  This timer is not\n      used on point-to-point links.\n   Master/slave\
    \ flag\n      A flag indicating whether the local switch is to act as the master\n\
    \      or the slave in the database exchange process (see Section 7.2).\n    \
    \  The master/slave relationship is negotiated when the conversation\n      changes\
    \ to the ExStart state.\n   Sequence number\n      A 4-octet number identifying\
    \ individual Database Description\n      packets. When the neighbor state ExStart\
    \ is entered and the\n      database exchange process is started, the sequence\
    \ number is set\n      to a value not previously seen by the neighboring switch.\
    \ (One\n      possible scheme is to use the switch's time of day counter.)  The\n\
    \      sequence number is then incremented by the master with each new\n     \
    \ Database Description packet sent.  See Section 7.2 for more\n      information\
    \ on the database exchange process.\n   Neighbor ID\n      The switch ID of the\
    \ neighboring switch, as discovered by the\n      VlanHello protocol [IDhello]\
    \ or contained in the neighbor's Hello\n      packets.\n   Neighbor priority\n\
    \      The switch priority of the neighboring switch, as contained in the\n  \
    \    neighbor's Hello packets.  Switch priorities are used when\n      selecting\
    \ the designated switch for the attached multi-access\n      link.  Priority is\
    \ not used on point-to-point links.\n   Interface identifier\n      A 10-octet\
    \ value that uniquely identifies the interface over which\n      this conversation\
    \ is being held.  This value consists of the 6-\n      octet base MAC address\
    \ of the neighbor switch, followed by the 4-\n      octet local port number of\
    \ the interface.\n   Neighbor's designated switch\n      The switch ID identifying\
    \ the neighbor's idea of the designated\n      switch, as contained in the neighbor's\
    \ Hello packets.  This value\n      is used in the local selection of the designated\
    \ switch.  It is\n      not used on point-to-point links.\n   Neighbor's backup\
    \ designated switch\n      The switch ID identifying the neighbor's idea of the\
    \ backup\n      designated switch, as contained in the neighbor's Hello packets.\n\
    \      This value is used in the local selection of the backup designated\n  \
    \    switch.  It is not used on point-to-point links.\n   Link state retransmission\
    \ list\n      The list of link state advertisements that have been forwarded\n\
    \      over but not acknowledged on this adjacency.  The local switch\n      retransmits\
    \ these link state advertisements at periodic intervals\n      until they are\
    \ acknowledged or until the adjacency is destroyed.\n      (For more information\
    \ on retransmitting link state advertisements,\n      see Section 8.2.5.)\n  \
    \ Database summary list\n      The set of link state advertisement headers that\
    \ summarize the\n      local link state database.  When the conversation changes\
    \ to the\n      Exchange state, this list is sent to the neighbor via Database\n\
    \      Description packets.  (For more information on the synchronization\n  \
    \    of databases, see Section 7.)\n   Link state request list\n      The list\
    \ of link state advertisements that must be received in\n      order to synchronize\
    \ with the neighbor switch's link state\n      database.  This list is created\
    \ as Database Description packets\n      are received, and is then sent to the\
    \ neighbor in Link State\n      Request packets.  (For more information on the\
    \ synchronization of\n      databases, see Section 7.)\n"
- title: 4.1 Neighbor States
  contents:
  - "4.1 Neighbor States\n   This section describes the various states of a conversation\
    \ with a\n   neighbor switch.  The states are listed in order of progressing\n\
    \   functionality.  For example, the inoperative state is listed first,\n   followed\
    \ by a list of the intermediate states through which the\n   conversation passes\
    \ before attaining the final, fully functional\n   state.  The specification makes\
    \ use of this ordering by references\n   such as \"those neighbors/adjacencies\
    \ in state greater than X\".\n   Figure 2 represents the neighbor state machine.\
    \  The arrows on the\n   graph represent the events causing each state change.\
    \  These events\n   are described in Section 4.2.  The neighbor state machine\
    \ is\n   described in detail in Section 4.3.\n   Down\n      This is the initial\
    \ state of a neighbor conversation.\n   Init\n      In this state, the neighbor\
    \ has been discovered, but bidirectional\n      communication has not yet been\
    \ established. All neighbors in this\n      state or higher are listed in the\
    \ VLS Hello packets sent by the\n      local switch over the associated (multi-access)\
    \ interface.\n          +----------+     KillNbr, LLDown,   +-----------+\n  \
    \        |   Down   | <--------------------- | any state |\n          +----------+\
    \   or Inactivity Timer  +-----------+\n               |\n         Hello |\n \
    \         Rcvd |\n               |\n               V\n   +-----< [pt-to-pt?]\n\
    \   | yes       |\n   |           | no\n   |           V\n   |      +----------+\
    \   1-Way   +----------+\n   |      |   Init   | <-------- | >= 2-way |\n   |\
    \      +----------+           +----------+\n   |           |\n   |     2-Way |\n\
    \   |      Rcvd |                  +-------+   AdjOK? +------------+\n   |   \
    \        +----------------> | 2-Way | <------- | >= ExStart |\n   |          \
    \ | (no adjacency)   +-------+     no   +------------+\n   |           |\n   |\
    \           V\n   |      +---------+   Seq Number Mismatch  +-------------+\n\
    \   +----> | ExStart | <--------------------- | >= Exchange |\n          +---------+\
    \       or BadLSReq      +-------------+\n               |\n   Negotiation |\n\
    \       Done    |\n               V\n          +----------+\n          | Exchange\
    \ |\n          +----------+\n               |\n      Exchange |              \
    \          +--------+\n        Done   +----------------------> |  Full  |\n  \
    \             | (request list empty)   +--------+\n               |          \
    \                   ^\n               V                             |\n      \
    \    +---------+      Loading Done      |\n          | Loading | ----------------------->\n\
    \          +---------+\n                  Figure 2: Neighbor State Machine\n \
    \  2-Way\n      In this state, communication between the two switches is\n   \
    \   bidirectional.  This is the most advanced state short of beginning\n     \
    \ to establish an adjacency.  On a multi-access link, the designated\n      switch\
    \ and the backup designated switch are selected from the set\n      of neighbors\
    \ in state 2-Way or greater.\n   ExStart\n      This state indicates that the\
    \ two switches have begun to establish\n      an adjacency by determining which\
    \ switch is the master, as well as\n      the initial sequence number for Database\
    \ Descriptor packets.\n      Neighbor conversations in this state or greater are\
    \ called\n      adjacencies.\n   Exchange\n      In this state, the switches are\
    \ exchanging Database Description\n      packets.  (See Section 7.2 for a complete\
    \ description of this\n      process.)  All adjacencies in the Exchange state\
    \ or greater are\n      used by the distribution procedure (see Section 8.2),\
    \ and are\n      capable of transmitting and receiving all types of VLSP routing\n\
    \      packets.\n   Loading\n      In this state, the local switch is sending\
    \ Link State Request\n      packets to the neighbor asking for the more recent\
    \ advertisements\n      that were discovered in the Exchange state.\n   Full\n\
    \      In this state, the two switches are fully adjacent.  These\n      adjacencies\
    \ will now appear in switch link and network link\n      advertisements generated\
    \ for the link.\n"
- title: 4.2 Events Causing Neighbor State Changes
  contents:
  - "4.2 Events Causing Neighbor State Changes\n   The state of a neighbor conversation\
    \ changes due to neighbor events.\n   This section describes these events.\n \
    \  Neighbor events are shown as arrows in Figure 2, the graphic\n   representation\
    \ of the neighbor state machine.  For more information\n   on the neighbor state\
    \ machine, see Section 4.3.\n   Hello Received\n      This event is generated\
    \ when a Hello packet has been received from\n      a neighbor.\n   2-Way Received\n\
    \      This event is generated when the local switch sees its own switch\n   \
    \   ID listed in the neighbor's Hello packet, indicating that\n      bidirectional\
    \ communication has been established between the two\n      switches.\n   Negotiation\
    \ Done\n      This event is generated when the master/slave relationship has\n\
    \      been successfully negotiated and initial packet sequence numbers\n    \
    \  have been exchanged.  This event signals the start of the database\n      exchange\
    \ process (see Section 7.2).\n   Exchange Done\n      This event is generated\
    \ when the database exchange process is\n      complete and both switches have\
    \ successfully transmitted a full\n      sequence of Database Description packets.\
    \  (For more information\n      on the database exchange process, see Section\
    \ 7.2.)\n   BadLSReq\n      This event is generated when a Link State Request\
    \ has been\n      received for a link state advertisement that is not contained\
    \ in\n      the database.  This event indicates an error in the\n      synchronization\
    \ process.\n   Loading Done\n      This event is generated when all Link State\
    \ Updates have been\n      received for all out-of-date portions of the database.\
    \  (See\n      Section 7.3.)\n   AdjOK?\n      This event is generated when a\
    \ decision must be made as to whether\n      an adjacency will be established\
    \ or maintained with the neighbor.\n      This event will initiate some adjacencies\
    \ and destroy others.\n   Seq Number Mismatch\n      This event is generated when\
    \ a Database Description packet has\n      been received with any of the following\
    \ conditions:\n      o  The packet contains an unexpected sequence number.\n \
    \     o  The packet (unexpectedly) has the Init bit set.\n      o  The packet\
    \ has a different Options field than was\n         previously seen.\n      These\
    \ conditions all indicate that an error has occurred during\n      the establishment\
    \ of the adjacency.\n   1-Way\n      This event is generated when bidirectional\
    \ communication with the\n      neighbor has been lost.  That is, a Hello packet\
    \ has been received\n      from the neighbor in which the local switch is not\
    \ listed.\n   KillNbr\n      This event is generated when further communication\
    \ with the\n      neighbor is impossible.\n   Inactivity Timer\n      This event\
    \ is generated when the inactivity timer has expired,\n      indicating that no\
    \ Hello packets have been received from the\n      neighbor in SwitchDeadInterval\
    \ seconds.  This timer is used only\n      on broadcast (multi-access) links.\n\
    \   LLDown\n      This event is generated by the lower-level switch discovery\n\
    \      protocols and indicates that the neighbor is now unreachable.\n"
- title: 4.3 Neighbor State Machine
  contents:
  - "4.3 Neighbor State Machine\n   This section presents a detailed description of\
    \ the neighbor state\n   machine.\n   Neighbor states (see Section 4.1) change\
    \ as the result of various\n   events (see Section 4.2).  However, the effect\
    \ of each event can\n   vary, depending on the current state of the conversation\
    \ with the\n   neighbor.  For this reason, the state machine described in this\n\
    \   section is organized according to the current neighbor state and the\n   occurring\
    \ event.  For each state/event pair, the new neighbor state\n   is listed, along\
    \ with a description of the required processing.\n   Note that when the neighbor\
    \ state changes as a result of an interface\n   Neighbor Change event (see Section\
    \ 3.2), it may be necessary to rerun\n   the designated switch selection algorithm.\
    \ In addition, if the\n   interface associated with the neighbor conversation\
    \ is in the DS\n   state (that is, the local switch is the designated switch),\
    \ changes\n   in the neighbor state may cause a new network link advertisement\
    \ to\n   be originated (see Section 8.1).\n   When the neighbor state machine\
    \ must invoke the interface state\n   machine, it is invoked as a scheduled task.\
    \  This simplifies\n   processing, by ensuring that neither state machine executes\n\
    \   recursively.\n   State(s):  Down\n   Event:  Hello Received\n   New state:\
    \  Depends on the interface type\n   Action:\n      If the interface type of the\
    \ associated link is point-to-point,\n      change the neighbor state to ExStart.\
    \  Otherwise, change the\n      neighbor state to Init and start the inactivity\
    \ timer for the\n      neighbor.  If the timer expires before another Hello packet\
    \ is\n      received, the neighbor switch is declared dead.\n   State(s):  Init\
    \ or greater\n   Event:  Hello Received\n   New state:  No state change\n   Action:\n\
    \      If the interface type of the associated link is point-to-point,\n     \
    \ determine whether this notification is for a different neighbor\n      than\
    \ the one previously seen. If so, generate an Interface Down\n      event for\
    \ the associated interface, reset the interface type to\n      broadcast and generate\
    \ an Interface Up event.\n   Note:  This procedure of generating an Interface\
    \ Down event and\n   changing the interface type to broadcast is also executed\
    \ if the\n   neighbor for whom the notification was received is running an older\n\
    \   version of the protocol software (see Section 6.1).  In previous\n   versions\
    \ of the protocol, all interfaces were treated as if they were\n   broadcast.\n\
    \      If the interface type is broadcast, reset the inactivity timer for\n  \
    \    the neighbor.\n   State(s):  Init\n   Event:  2-Way Received\n   New state:\
    \  Depends on action routine\n   Action:\n      Determine whether an adjacency\
    \ will be formed with the neighbor\n      (see Section 6.4).  If no adjacency\
    \ is to be formed, change the\n      neighbor state to 2-Way.\n      Otherwise,\
    \ change the neighbor state to ExStart.  Initialize the\n      sequence number\
    \ for this neighbor and declare the local switch to\n      be master for the database\
    \ exchange process.  (See Section 7.2.)\n   State(s):  ExStart\n   Event:  Negotiation\
    \ Done\n   New state:  Exchange\n   Action:\n      The Negotiation Done event\
    \ signals the start of the database\n      exchange process.  See Section 7.2\
    \ for a detailed description of\n      this process.\n   State(s):  Exchange\n\
    \   Event:  Exchange Done\n   New state:  Depends on action routine\n   Action:\n\
    \      If the neighbor Link state request list is empty, change the\n      neighbor\
    \ state to Full.  This is the adjacency's final state.\n      Otherwise, change\
    \ the neighbor state to Loading.  Begin sending\n      Link State Request packets\
    \ to the neighbor requesting the most\n      recent link state advertisements,\
    \ as discovered during the\n      database exchange process.  (See Section 7.2.)\
    \ These\n      advertisements are listed in the link state request list\n    \
    \  associated with the neighbor.\n   State(s):  Loading\n   Event:  Loading Done\n\
    \   New state:  Full\n   Action:\n      No action is required beyond changing\
    \ the neighbor state to Full.\n      This is the adjacency's final state.\n  \
    \ State(s):  2-Way\n   Event:  AdjOK?\n   New state:  Depends on action routine\n\
    \   Action:\n      If no adjacency is to be formed with the neighboring switch\
    \ (see\n      Section 6.4), retain the neighbor state at 2-Way. Otherwise,\n \
    \     change the neighbor state to ExStart.  Initialize the sequence\n      number\
    \ for this neighbor and declare the local switch to be master\n      for the database\
    \ exchange process.  (See Section 7.2.)\n   State(s):  ExStart or greater\n  \
    \ Event:  AdjOK?\n   New state:  Depends on action routine\n   Action:\n     \
    \ If an adjacency should still be formed with the neighboring switch\n      (see\
    \ Section 6.4), no state change and no further action is\n      necessary.  Otherwise,\
    \ tear down the (possibly partially formed)\n      adjacency.  Clear the link\
    \ state retransmission list, database\n      summary list and link state request\
    \ list and change the neighbor\n      state to 2-Way.\n   State(s):  Exchange\
    \ or greater\n   Event:  Seq Number Mismatch\n   New state:  ExStart\n   Action:\n\
    \      Tear down the (possibly partially formed) adjacency.  Clear the\n     \
    \ link state retransmission list, database summary list and link\n      state\
    \ request list.  Change the neighbor state to ExStart and make\n      another\
    \ attempt to establish the adjacency.\n   State(s):  Exchange or greater\n   Event:\
    \  BadLSReq\n   New state:  ExStart\n   Action:\n      Tear down the (possibly\
    \ partially formed) adjacency.  Clear the\n      link state retransmission list,\
    \ database summary list and link\n      state request list.  Change the neighbor\
    \ state to ExStart and make\n      another attempt to establish the adjacency.\n\
    \   State(s):  Any state\n   Event:  KillNbr\n   New state:  Down\n   Action:\n\
    \      Terminate the neighbor conversation.  Disable the inactivity timer\n  \
    \    and clear the link state retransmission list, database summary\n      list\
    \ and link state request list.\n   State(s):  Any state\n   Event:  LLDown\n \
    \  New state:  Down\n   Action:\n      Terminate the neighbor conversation.  Disable\
    \ the inactivity timer\n      and clear the link state retransmission list, database\
    \ summary\n      list and link state request list.\n   State(s):  Any state\n\
    \   Event:  Inactivity Timer\n   New state:  Down\n   Action:\n      Terminate\
    \ the neighbor conversation.  Disable the inactivity timer\n      and clear the\
    \ link state retransmission list, database summary\n      list and link state\
    \ request list.\n   State(s):  2-Way or greater\n   Event:  1-Way Received\n \
    \  New state:  Init\n   Action:\n      Tear down the adjacency between the switches,\
    \ if any.  Clear the\n      link state retransmission list, database summary list\
    \ and link\n      state request list.\n   State(s):  2-Way or greater\n   Event:\
    \  2-Way received\n   New state:  No state change\n   Action:\n      No action\
    \ required.\n   State(s):  Init\n   Event:  1-Way received\n   New state:  No\
    \ state change\n   Action:\n            No action required.\n"
- title: 5. Area Data Structure
  contents:
  - "5. Area Data Structure\n   The area data structure contains all the information\
    \ needed to run\n   the basic routing algorithm.  One of its components is the\
    \ link state\n   database -- the collection of all switch link and network link\n\
    \   advertisements generated by the switches.\n   The area data structure contains\
    \ the following items:\n   Area ID\n      A 4-octet value identifying the area.\
    \  Since VLSP does not support\n      multiple areas, the value here is always\
    \ zero.\n   Associated switch interfaces\n      A list of interface IDs of the\
    \ local switch interfaces connected\n      to network links.\n   Link state database\n\
    \      The collection of all current link state advertisements for the\n     \
    \ switch fabric.  This collection consists of the following:\n   Switch link advertisements\n\
    \      A list of the switch link advertisements for all switches in the\n    \
    \  fabric.  Switch link advertisements describe the state of each\n      switch's\
    \ interfaces.\n   Network link advertisements\n      A list of the network link\
    \ advertisements for all multi-access\n      network links in the switch fabric.\
    \  Network link advertisements\n      describe the set of switches currently connected\
    \ to each link.\n   Best path(s)\n      A set of end-to-end hop descriptions for\
    \ all equal-cost best paths\n      from the local switch to every other switch\
    \ in the fabric.  Each\n      hop is specified by the interface ID of the next\
    \ link in the path.\n      Best paths are derived from the collected switch link\
    \ and network\n      link advertisements using the Dijkstra algorithm. [Perlman]\n"
- title: 5.1 Adding and Deleting Link State Advertisements
  contents:
  - "5.1 Adding and Deleting Link State Advertisements\n   The link state database\
    \ within the area data structure must contain,\n   at most, a single instance\
    \ of each link state advertisement.  To keep\n   the database current, a switch\
    \ adds link state advertisements to the\n   database under the following conditions:\n\
    \   o  When a link state advertisement is received during the\n      distribution\
    \ process\n      o  When the switch itself generates a link state advertisement\n\
    \   (See Section 8.2.4 for information on installing link state\n   advertisements.)\n\
    \   Likewise, a switch deletes link state advertisements from the\n   database\
    \ under the following conditions:\n   o  When a link state advertisement has been\
    \ superseded by a newer\n      instance during the flooding process\n   o  When\
    \ the switch generates a newer instance of one of its self-\n      originated\
    \ advertisements\n   Note that when an advertisement is deleted from the link\
    \ state\n   database, it must also be removed from the link state retransmission\n\
    \   list of all neighboring switches.\n"
- title: 5.2 Accessing Link State Advertisements
  contents:
  - "5.2 Accessing Link State Advertisements\n   An implementation of the VLS protocol\
    \ must provide access to\n   individual link state advertisements, based on the\
    \ advertisement's\n   type, link state identifier, and advertising switch [1].\
    \  This lookup\n   function is invoked during the link state distribution procedure\
    \ and\n   during calculation of the set of best paths.  In addition, a switch\n\
    \   can use the function to determine whether it has originated a\n   particular\
    \ link state advertisement, and if so, with what sequence\n   number.\n"
- title: 5.3 Best Path Lookup
  contents:
  - "5.3 Best Path Lookup\n   An implementation of the VLS protocol must provide access\
    \ to multiple\n   equal-cost best paths, based on the base MAC addresses of the\
    \ source\n   and destination switches.  This lookup function should return up\
    \ to\n   three equal-cost paths.  Paths should be returned as lists of end-\n\
    \   to-end hop information, with each hop specified as a interface ID of\n   the\
    \ next link in the path -- the 6-octet base MAC address of the next\n   switch\
    \ and the 4-octet local port number of the link interface.\n"
- title: 6. Discovery Process
  contents:
  - "6. Discovery Process\n   The first operational stage of the VLS protocol is the\
    \ discovery\n   process.  During this stage, each switch dynamically detects its\n\
    \   neighboring switches and establishes a relationship with each of\n   these\
    \ neighbors.  This process has the following component steps:\n   o  Neighboring\
    \ switches are detected on each functioning network\n      interface.\n   o  Bidirectional\
    \ communication is established with each neighbor\n      switch.\n   o  A designated\
    \ switch and backup designated switch are selected for\n      each multi-access\
    \ network link.\n   o  An adjacent relationship is established with selected neighbors\
    \ on\n      each link.\n"
- title: 6.1 Neighbor Discovery
  contents:
  - "6.1 Neighbor Discovery\n   When the switch first comes on line, VLSP assumes\
    \ all network links\n   are point-to-point and no more than one neighboring switch\
    \ will be\n   discovered on any one port.  Therefore, at startup, VLSP relies\
    \ on\n   the VlanHello protocol [IDhello] for the discovery of its neighbor\n\
    \   switches.\n   As each neighbor is detected, VlanHello triggers a Found Neighbor\n\
    \   event, notifying VLSP that a new neighbor has been discovered.  (See\n   [IDhello]\
    \ for a description of the Found Neighbor event and the\n   information passed.)\
    \  VLSP enters the neighbor switch ID in the list\n   of known neighbors and creates\
    \ a new neighbor data structure with a\n   neighbor status of Down.  A Hello Received\
    \ neighbor event is then\n   generated, which changes the neighbor state to ExStart.\n\
    \   There are two circumstances under which VLSP will change the type of\n   an\
    \ interface to broadcast:\n   o  If VLSP receives a subsequent notification from\
    \ VlanHello,\n      specifying a second (different) neighbor switch on the port.,\
    \ the\n      interface is then known to be multi-access.  VLSP generates an\n\
    \      Interface Down event for the interface, resets the interface type\n   \
    \   to broadcast, and then generates an Interface Up event.\n   o  If the functional\
    \ level of the neighbor switch is less than 2, the\n      neighbor is running\
    \ a previous version of the VLSP software in\n      which all links were treated\
    \ as broadcast links. VLSP immediately\n      changes the interface type to broadcast\
    \ and generates an Interface\n      Up event.\n      In both cases, VLSP assumes\
    \ control of communication over the\n      interface by exchanging its own VLSP\
    \ Hello packets with the\n      neighbors on the link.\n   Note:  These Hello\
    \ packets are in addition to the Interswitch\n   Keepalive messages sent by VlanHello.\
    \  VlanHello still continues to\n   monitor the condition of the interface and\
    \ notifies VLSP of any\n   change.\n   Each Hello packet contains the following\
    \ data used during the\n   discovery process on multi-access links:\n   o  The\
    \ switch ID and priority of the sending switch\n   o  Values specifying the interval\
    \ timers to be used for sending Hello\n      packets and deciding whether to declare\
    \ a neighbor switch Down.\n   o  The switch ID of the designated switch and the\
    \ backup designated\n      switch for the link, as understood by the sending switch\n\
    \   o  A list of switch IDs of all neighboring switches seen so far on\n     \
    \ the link\n   For a detailed description of the Hello packet format, see Section\n\
    \   10.6.1.\n   When VLSP receives a Hello packet (on a broadcast link), it first\n\
    \   attempts to identify the sending switch by matching its switch ID to\n   one\
    \ of the known neighbors listed in the interface data structure.\n   If this is\
    \ the first Hello packet received from the switch, the\n   switch ID is entered\
    \ in the list of known neighbors and a new\n   neighbor data structure is created\
    \ with a neighbor status of Down.\n   At this point, the remainder of the Hello\
    \ packet is examined and the\n   appropriate interface and neighbor events are\
    \ generated.  In all\n   cases, a neighbor Hello Received event is generated.\
    \  Other events\n   may also be generated, triggering further steps in the discovery\n\
    \   process or other actions, as appropriate.\n   For a detailed description of\
    \ the interface state machine, see\n   Section 3.3.  For a detailed description\
    \ of the neighbor state\n   machine, see Section 4.3.\n"
- title: 6.2 Bidirectional Communication
  contents:
  - "6.2 Bidirectional Communication\n   Before a conversation can proceed with a\
    \ neighbor switch,\n   bidirectional communication must be established with that\
    \ neighbor.\n   Bidirectional communication is detected in one of two ways:\n\
    \   o  On a point-to-point link, the VlanHello protocol sees its own\n      switch\
    \ ID listed in an Interswitch Keepalive message it has\n      received from the\
    \ neighbor.\n   o  On a multi-access link, VLSP sees its own switch ID listed\
    \ in a\n      VLSP Hello packet it has received from the neighbor.\n   In either\
    \ case, a neighbor 2-Way Received neighbor event is\n   generated.\n   Once bidirectional\
    \ communication has been established with a\n   neighbor, the local switch determines\
    \ whether an adjacency will be\n   formed with the neighbor.  However, if the\
    \ link is a multi-access\n   link, a designated switch and a backup designated\
    \ switch must first\n   be selected for the link.  The next section contains a\
    \ description of\n   the designated switch, the backup designated switch, and\
    \ the\n   selection process.\n"
- title: 6.3 Designated Switch
  contents:
  - "6.3 Designated Switch\n   Every multi-access network link has a designated switch.\
    \  The\n   designated switch performs the following functions for the routing\n\
    \   protocol:\n   o  The designated switch originates a network link advertisement\
    \ on\n      behalf of the link, listing the set of switches (including the\n \
    \     designated switch itself) currently attached to the link. For a\n      detailed\
    \ description of network link advertisements, see Section\n      11.3.\n   o \
    \ The designated switch becomes adjacent to all other switches on\n      the link.\
    \  Since the link state databases are synchronized across\n      adjacencies,\
    \ the designated switch plays a central part in the\n      synchronization process.\
    \  For a description of the synchronization\n      process, see Section 7.\n \
    \  Each multi-access network link also has a backup designated switch.\n   The\
    \ primary function of the backup designated switch is to act as a\n   standby\
    \ for the designated switch.  If the current designated switch\n   fails, the\
    \ backup designated switch becomes the designated switch.\n   To facilitate this\
    \ transition, the backup designated switch forms an\n   adjacency with every other\
    \ switch on the link.  Thus, when the backup\n   designated switch must take over\
    \ for the designated switch, its link\n   state database is already synchronized\
    \ with the databases of all\n   other switches on the link.\n   Note:  Point-to-point\
    \ network links have neither a designated switch\n   or a backup designated switch.\n"
- title: 6.3.1 Selecting the Designated Switch
  contents:
  - "6.3.1 Selecting the Designated Switch\n   When a multi-access link interface\
    \ first becomes functional, the\n   switch sets a one-shot Wait timer (with a\
    \ value of SwitchDeadInterval\n   seconds) for the interface.  The purpose of\
    \ this timer is to ensure\n   that all switches attached to the link have a chance\
    \ to establish\n   bidirectional communication before the designated switch and\
    \ backup\n   designated switch are selected for the link.\n   When the Wait timer\
    \ is set, the interface enters the Waiting state.\n   During this state, the switch\
    \ exchanges Hello packets with its\n   neighbors attempting to establish bidirectional\
    \ communication.  The\n   interface leaves the Waiting state under one of the\
    \ following\n   conditions:\n   o  The Wait timer expires.\n   o  A Hello packet\
    \ is received indicating that a designated switch or\n      a backup designated\
    \ switch has already been specified for the\n      interface.\n   At this point,\
    \ if the switch sees that a designated switch has\n   already been selected for\
    \ the link, the switch accepts that\n   designated switch, regardless of its own\
    \ switch priority and MAC\n   address.  This situation typically means the switch\
    \ has come up late\n   on a fully functioning link.  Although this makes it harder\
    \ to\n   predict the identity of the designated switch on a particular link,\n\
    \   it ensures that the designated switch does not change needlessly,\n   necessitating\
    \ a resynchronization of the databases.\n   If no designated switch is currently\
    \ specified for the link, the\n   switch begins the actual selection process.\
    \  Note that this selection\n   algorithm operates only on a list of neighbor\
    \ switches that are\n   eligible to become the designated switch.  A neighbor\
    \ is eligible to\n   be the designated switch if it has a switch priority greater\
    \ than\n   zero and its neighbor state is 2-Way or greater.  The local switch\n\
    \   includes itself on the list of eligible switches as long as it has a\n   switch\
    \ priority greater than zero.\n   The selection process includes the following\
    \ steps:\n   1. The current values of the link's designated switch and backup\n\
    \      designated switch are saved for use in step 6.\n   2. The new backup designated\
    \ switch is selected as follows:\n      a) Eliminate from consideration those\
    \ switches that have declared\n         themselves to be the designated switch.\n\
    \      b) If one or more of the remaining switches have declared\n         themselves\
    \ to be the backup designated switch, eliminate from\n         consideration all\
    \ other switches.\n      c) From the remaining list of eligible switches, select\
    \ the switch\n         having the highest switch priority as the backup designated\n\
    \         switch.  If multiple switches have the same (highest) priority,\n  \
    \       select the switch with the highest switch ID as the backup\n         designated\
    \ switch.\n   3. The new designated switch is selected as follows:\n      a) If\
    \ one or more of the switches have declared themselves to be\n         the designated\
    \ switch, eliminate from consideration all other\n         switches.\n      b)\
    \ From the remaining list of eligible switches, select the switch\n         having\
    \ the highest switch priority as the designated switch.\n         If multiple\
    \ switches have the same (highest) priority, select\n         the switch with\
    \ the highest switch ID as the designated switch.\n   4. If the local switch has\
    \ been newly selected as either the\n      designated switch or the backup designated\
    \ switch, or is now no\n      longer the designated switch or the backup designated\
    \ switch,\n      repeat steps 2 and 3, above, and then proceed to step 5.\n  \
    \    If the local switch is now the designated switch, it will\n      eliminate\
    \ itself from consideration at step 2a when the selection\n      of the backup\
    \ designated switch is repeated. Likewise, if the\n      local switch is now the\
    \ backup designated switch, it will\n      eliminate itself from consideration\
    \ at step 3a when the selection\n      of the designated switch is repeated. This\
    \ ensures that no switch\n      will select itself as both backup designated switch\
    \ and designated\n      switch [2].\n   5. Set the interface state to the appropriate\
    \ value, as follows:\n   o  If the local switch is now the designated switch,\
    \ set the\n      interface state to DS.\n   o  If the local switch is now the\
    \ backup designated switch, set the\n      interface state to Backup.\n   o  Otherwise,\
    \ set the interface state to DS Other.\n   6. If either the designated switch\
    \ or backup designated switch has\n      now changed, the set of adjacencies associated\
    \ with this link must\n      be modified.  Some adjacencies may need to be formed,\
    \ while others\n      may need to be broken.  Generate the neighbor AdjOK? event\
    \ for all\n      neighbors with a state of 2-Way or higher to trigger a\n    \
    \  reexamination of adjacency eligibility.\n   Caution:  If VLSP is implemented\
    \ with configurable parameters, care\n   must be exercised in specifying the switch\
    \ priorities.  Note that if\n   the local switch is not itself eligible to become\
    \ the designated\n   switch (i.e., it has a switch priority of 0), it is possible\
    \ that\n   neither a backup designated switch nor a designated switch will be\n\
    \   selected by the above procedure.  Note also that if the local switch\n   is\
    \ the only attached switch that is eligible to become the designated\n   switch,\
    \ it will select itself as designated switch and there will be\n   no backup designated\
    \ switch for the link.  For this reason, it is\n   advisable to specify a default\
    \ switch priority of 1 for all switches.\n"
- title: 6.4 Adjacencies
  contents:
  - "6.4 Adjacencies\n   VLSP creates adjacencies between neighboring switches for\
    \ the purpose\n   of exchanging routing information.  Not every two neighboring\n\
    \   switches will become adjacent.  On a multi-access link, an adjacency\n   is\
    \ only formed between two switches if one of them is either the\n   designated\
    \ switch or the backup designated switch.\n   Note that an adjacency is bound\
    \ to the network link that the two\n   switches have in common.  Therefore, if\
    \ two switches have multiple\n   links in common, they may also have multiple\
    \ adjacencies between\n   them.\n   The decision to form an adjacency occurs in\
    \ two places in the\n   neighbor state machine:\n   o  When bidirectional communication\
    \ is initially established with the\n      neighbor.\n   o  When the designated\
    \ switch  or backup designated switch on the\n      attached link changes.\n \
    \  The rules for establishing an adjacency between two neighboring\n   switches\
    \ are as follows:\n   o  On a point-to-point link, the two neighboring switches\
    \ always\n      establish an adjacency.\n   o  On a multi-access link, an adjacency\
    \ is established with the\n      neighboring switch under one of the following\
    \ conditions:\n      o  The local switch itself is the designated switch.\n  \
    \    o  The local switch itself is the backup designated switch.\n      o  The\
    \ neighboring switch is the designated switch.\n      o  The neighboring switch\
    \ is the backup designated switch.\n   If no adjacency is formed between two neighboring\
    \ switches, the state\n   of the neighbor conversation remains set to 2-Way.\n"
- title: 7. Synchronizing the Databases
  contents:
  - "7. Synchronizing the Databases\n   In an SPF-based routing algorithm, it is important\
    \ for the link state\n   databases of all switches to stay synchronized.  VLSP\
    \ simplifies this\n   process by requiring only adjacent switches to remain synchronized.\n\
    \   The synchronization process begins when the switches attempt to bring\n  \
    \ up the adjacency.  Each switch in the adjacency describes its\n   database by\
    \ sending a sequence of Database Description packets to its\n   neighbor.  Each\
    \ Database Description packet describes a set of link\n   state advertisements\
    \ belonging to the database.  When the neighbor\n   sees a link state advertisement\
    \ that is more recent than its own\n   database copy, it makes a note to request\
    \ this newer advertisement.\n   During this exchange of Database Description packets\
    \ (known as the\n   database exchange process), the two switches form a master/slave\n\
    \   relationship.  Database Description packets sent by the master are\n   known\
    \ as polls, and each poll contains a sequence number.  Polls are\n   acknowledged\
    \ by the slave by echoing the sequence number in the\n   Database Description\
    \ response packet.\n   When all Database Description packets have been sent and\n\
    \   acknowledged, the database exchange process is completed.  At this\n   point,\
    \ each switch in the exchange has a list of link state\n   advertisements for\
    \ which its neighbor has more recent instances.\n   These advertisements are requested\
    \ using Link State Request packets.\n   Once the database exchange process has\
    \ completed and all Link State\n   Requests have been satisfied, the databases\
    \ are deemed synchronized\n   and the neighbor states of the two switches are\
    \ set to Full,\n   indicating that the adjacency is fully functional. Fully functional\n\
    \   adjacencies are advertised in the link state advertisements of the\n   two\
    \ switches [3].\n"
- title: 7.1 Link State Advertisements
  contents:
  - "7.1 Link State Advertisements\n   Link state advertisements form the core of\
    \ the database from which a\n   switch calculates the set of best paths to the\
    \ other switches in the\n   fabric.\n   Each link state advertisement begins with\
    \ a standard header. This\n   header contains three data items that uniquely identify\
    \ the link\n   state advertisement.\n   o  The link state type.  Possible values\
    \ are as follows:\n      1   Switch link advertisement -- describes the collected\
    \ states of\n         the switch's interfaces.\n      2   Network link advertisement\
    \ -- describes the set of switches\n         attached to the network link.\n \
    \  o  The link state ID, defined as follows:\n      o  For a switch link advertisement\
    \ -- the switch ID of the\n         originating switch\n      o  For a network\
    \ link advertisement -- the switch ID of the\n         designated switch for the\
    \ link\n   o  The switch ID of the advertising switch -- the switch that\n   \
    \   generated the advertisement\n   The link state advertisement header also contains\
    \ three data items\n   that are used to determine which instance of a particular\
    \ link state\n   advertisement is the most current.  (See Section 7.1.1 for a\n\
    \   description of how to determine which instance of a link state\n   advertisement\
    \ is the most current.)\n   o  The link state sequence number\n   o  The link\
    \ state age, stored in seconds\n   o  The link state checksum, a 16-bit unsigned\
    \ value calculated for\n      the entire contents of the link state advertisement,\
    \ with the\n      exception of the age field\n   The remainder of each link state\
    \ advertisement contains data specific\n   to the type of the advertisement. \
    \ See Section 11 for a detailed\n   description of the link state header, as well\
    \ as the format of a\n   switch link or network link advertisement.\n"
- title: 7.1.1 Determining Which Link State Advertisement Is Newer
  contents:
  - "7.1.1 Determining Which Link State Advertisement Is Newer\n   At various times\
    \ while synchronizing or updating the link state\n   database, a switch must determine\
    \ which instance of a particular link\n   state advertisement is the most current.\
    \  This decision is made as\n   follows:\n   o  The advertisement having the greater\
    \ sequence number is the most\n      current.\n   o  If both instances have the\
    \ same sequence number, then:\n      o  If the two instances have different checksum\
    \ values, then the\n         instance having the larger checksum is considered\
    \ the most\n         current [4].\n   o  If both instances have the same sequence\
    \ number and the same\n      checksum value, then:\n      o  If one (and only\
    \ one) of the instances is of age MaxAge, then\n         the instance of age MaxAge\
    \ is considered the most current [5].\n      o  Else, if the ages of the two instances\
    \ differ by more than\n         MaxAgeDiff, the instance having the smaller (younger)\
    \ age is\n         considered the most current [6].\n      o  Else, the two instances\
    \ are considered identical.\n"
- title: 7.2 Database Exchange Process
  contents:
  - "7.2 Database Exchange Process\n   There are two stages to the database exchange\
    \ process:\n   o  Negotiating the master/slave relationship\n   o  Exchanging\
    \ database summary information\n"
- title: 7.2.1 Database Description Packets
  contents:
  - "7.2.1 Database Description Packets\n   Database Description packets are used\
    \ to describe a switch's link\n   state database during the database exchange\
    \ process.  Each Database\n   Description packet contains a list of headers of\
    \ the link state\n   advertisements currently stored in the sending switch's database.\n\
    \   (See Section 11.1 for a description of a link state advertisement\n   header.)\n\
    \   In addition to the link state headers, each Database Description\n   packet\
    \ contains the following data items:\n   o  A flag (the M-bit) indicating whether\
    \ or not more packets are to\n      follow.  Depending on the size of the local\
    \ database and the\n      maximum size of the packet, the list of headers in any\
    \ particular\n      Database Description packet may be only a partial list of\
    \ the\n      total database.  When the M-bit is set, the list of headers is\n\
    \      only a partial list and more headers are to follow in subsequent\n    \
    \  packets.\n   o  A flag (the I-bit) indicating whether or not this is the first\n\
    \      Database Description packet sent for this execution of the\n      database\
    \ exchange process.\n   o  A flag (the MS-bit) indicating whether the sending\
    \ switch thinks\n      it is the master or the slave in the database exchange\
    \ process.\n      If the flag is set, the switch thinks it is the master.\n  \
    \ o  A 4-octet sequence number for the packet.\n   While the switches are negotiating\
    \ the master/slave relationship,\n   they exchange \"empty\" Database Description\
    \ packets.  That is, packets\n   that contain no link summary information.  Instead,\
    \ the flags and\n   sequence number constitute the information required for the\n\
    \   negotiation process.\n   See Section 10.6.2 for a more detailed description\
    \ of a Database\n   Description packet.\n"
- title: 7.2.2 Negotiating the Master/Slave Relationship
  contents:
  - "7.2.2 Negotiating the Master/Slave Relationship\n   Before two switches can begin\
    \ the actual exchange of database\n   information, they must decide between themselves\
    \ who will be the\n   master in the exchange process and who will be the slave.\
    \  They must\n   also agree on the starting sequence number for the Database\n\
    \   Description packets.\n   Once a switch has decided to form an adjacency with\
    \ a neighboring\n   switch, it sets the neighbor state to ExStart and begins sending\n\
    \   empty Database Description packets to its neighbor.  These packets\n   contain\
    \ the starting sequence number the switch plans to use in the\n   exchange process.\
    \  Also, the I-bit and M-bit flags are set, as well\n   as the MS-bit.  Thus,\
    \ each switch in the exchange begins by believing\n   it will be the master.\n\
    \   Empty Database Description packets are retransmitted every\n   RxmtInterval\
    \ seconds until the neighbor responds.\n   When a switch receives an empty Database\
    \ Description packet from its\n   neighbor, it determines which switch will be\
    \ the master by comparing\n   the switch IDs.  The switch with the highest switch\
    \ ID becomes the\n   master of the exchange.  Based on this determination, the\
    \ switch\n   proceeds as follows:\n   o  If the switch is to be the slave of the\
    \ database exchange process,\n      it acknowledges that it is the slave by sending\
    \ another empty\n      Database Description packet to the master. This packet\
    \ contains\n      the master's sequence number and has the MS-bit and the I-bit\n\
    \      cleared.\n   o  The switch then generates a neighbor event of Negotiation\
    \ Done to\n      change its neighbor state to Exchange and waits for the first\n\
    \      non-empty Database Description packet from the master.\n   o  If the switch\
    \ is to be the master of the database exchange, it\n      waits to receive an\
    \ acknowledgment from its neighbor -- that is,\n      an empty Database Description\
    \ packet with the MS-bit and I-bit\n      cleared and containing the sequence\
    \ number it (the master)\n      previously sent.\n   o  When it receives the acknowledgment,\
    \ it generates a neighbor event\n      of Negotiation Done to change its neighbor\
    \ state to Exchange and\n      begin the actual exchange of Database Description\
    \ packets.\n   Note that during the negotiation process, the receipt of an\n \
    \  inconsistent packet will result in a neighbor event of Seq Number\n   Mismatch,\
    \ terminating the process.  See Section 4.3 for more\n   information.\n"
- title: 7.2.3 Exchanging Database Description Packets
  contents:
  - "7.2.3 Exchanging Database Description Packets\n   Once the neighbor state changes\
    \ to Exchange, the switches begin the\n   exchange of Database Description packets\
    \ containing link state\n   summary data.  The process proceeds as follows:\n\
    \   1. The master sends a packet containing a list of link state headers.\n  \
    \    If the packet contains only a portion of the unexchanged database\n     \
    \ -- that is, more Database Description packets are to follow -- the\n      packet\
    \ has the M-bit set.  The MS-bit is set and the I-bit is\n      clear.\n     \
    \ If the slave does not acknowledge the packet within RxmtInterval\n      seconds,\
    \ the master retransmits the packet.\n   2. When the slave receives a packet,\
    \ it first checks the sequence\n      number to see if the packet is a duplicate.\
    \  If so, it simply\n      acknowledges the packet by clearing the MS-bit and\
    \ returning the\n      packet to the master.  (Note that the slave acknowledges\
    \ all\n      Database Description packets that it receives, even those that are\n\
    \      duplicates.)\n      Otherwise, the slave processes the packet by doing\
    \ the following:\n      o  For each link state header listed in the packet, the\
    \ slave\n         searches its own link state database to determine whether it\n\
    \         has an instance of the advertisement.\n      o  If the slave does not\
    \ have an instance of the link state\n         advertisement, or if the instance\
    \ it does have is older than\n         the instance listed in the packet, it creates\
    \ an entry in its\n         link state request list in the neighbor data structure.\
    \  See\n         Section 7.1.1 for a description of how to determine which\n \
    \        instance of a link state advertisement is the newest.\n      o  When\
    \ the slave has examined all headers, it acknowledges the\n         packet by\
    \ turning the MS-bit off and returning the packet to\n         the master.\n \
    \  3. When the master receives the first acknowledgment for a particular\n   \
    \   Database Description packet, it processes the acknowledgment as\n      follows:\n\
    \      o  For each link state header listed in the packet, the master\n      \
    \   checks to see if the slave has indicated it has an instance of\n         the\
    \ link state advertisement that is newer than the instance\n         the master\
    \ has in its own database.  If so, the master creates\n         an entry in its\
    \ link state request list in the neighbor data\n         structure.\n      o \
    \ The master then increments the sequence number and sends\n         another packet\
    \ containing the next set of link state summary\n         information, if any.\n\
    \      Subsequent acknowledgments for the Database Description packet\n      (those\
    \ with the same sequence number) are discarded.\n      When the master sends the\
    \ last portion of its database summary\n      information, it clears the M-bit\
    \ in the packet to indicate that no\n      more packets are to be sent.\n   4.\
    \ When the slave receives a Database Description packet with the M-\n      bit\
    \ clear, it processes the packet, as described above in step 2.\n      After it\
    \ has completed processing and has acknowledged the packet\n      to the master,\
    \ it generates an Exchange Done neighbor event and\n      its neighbor state changes\
    \ to Loading.\n      The database exchange process is now complete for the slave,\
    \ and\n      it begins the process of requesting those link state\n      advertisements\
    \ for which the master has more current instances\n      (see Section 7.3).\n\
    \   5. When the master receives an acknowledgment for the final Database\n   \
    \   Description packet, it processes the acknowledgment as described\n      above\
    \ in step 3.  Then it generates an Exchange Done neighbor\n      event and its\
    \ neighbor state changes to Loading.\n      The database exchange process is now\
    \ complete for the master, and\n      it begins the process of requesting those\
    \ link state\n      advertisements for which the slave has more current instances\
    \ (see\n      Section 7.3).\n   Note that during this exchange, the receipt of\
    \ an inconsistent packet\n   will result in a neighbor event of Seq Number Mismatch,\
    \ terminating\n   the process.  See Section 4.3 for more information.\n"
- title: 7.3 Updating the Database
  contents:
  - "7.3 Updating the Database\n   When either switch completes the database exchange\
    \ process and its\n   neighbor state changes to Loading, it has a list of link\
    \ state\n   advertisements for which the neighboring switch has a more recent\n\
    \   instance.  This list is stored in the neighbor data structure as the\n   link\
    \ state request list.\n   To complete the synchronization of its database with\
    \ that of its\n   neighbor, the switch must obtain the most current instances\
    \ of those\n   link state advertisements.\n   The switch requests these advertisements\
    \ by sending its neighbor a\n   Link State Request packet containing the description\
    \ of one or more\n   link state advertisement, as defined by the advertisement's\
    \ type,\n   link state ID, and advertising switch.  (For a detailed description\n\
    \   of the Link State Request packet, see Section 10.6.3.)  The switch\n   continues\
    \ to retransmit this packet every RxmtInterval seconds until\n   it receives a\
    \ reply from the neighbor.\n   When the neighbor switch receives the Link State\
    \ Request packet, it\n   responds with a Link State Update packet containing its\
    \ most current\n   instance of each of the requested advertisements.  (Note that\
    \ the\n   neighboring switch can be in any of the Exchange, Loading or Full\n\
    \   neighbor states when it responds to a Link State Request packet.)\n   If the\
    \ neighbor cannot locate a particular link state advertisement\n   in its database,\
    \ something has gone wrong with the synchronization\n   process.  The switch generates\
    \ a BadLSReq neighbor event and the\n   partially formed adjacency is torn down.\
    \ See Section 4.3 for more\n   information.\n   Depending on the size of the link\
    \ state request list, it may take\n   more than one Link State Request packet\
    \ to obtain all the necessary\n   advertisements.  Note, however, that there must\
    \ at most one Link\n   State Request packet outstanding at any one time.\n"
- title: 7.4 An Example
  contents:
  - "7.4 An Example\n   Figure 3 shows an example of an adjacency being formed between\
    \ two\n   switches -- S1 and S2 -- connected to a network link.  S2 is the\n \
    \  designated switch for the link and has a higher switch ID than S1.\n   The\
    \ neighbor state changes that each switch goes through are listed\n   on the sides\
    \ of the figure.\n   +--------+                                     +--------+\n\
    \   | Switch |                                     | Switch |\n   |   S1   | \
    \                                    |   S2   |\n   +--------+               \
    \                      +--------+\n      Down                                \
    \           Down\n                     Hello (DS=0, seen=0)\n            ------------------------------------->\n\
    \                                                     Init\n                 \
    \ Hello (DS=S2, seen=...,S1)\n            <-------------------------------------\n\
    \   ExStart\n             DB Description (Seq=x, I, M, Master)\n            ------------------------------------->\n\
    \                                                     ExStart\n             DB\
    \ Description (Seq=y, I, M, Master)\n            <-------------------------------------\n\
    \   xchange\n               DB Description (Seq=y, M, Slave)\n            ------------------------------------->\n\
    \                                                     Exchange\n             DB\
    \ Description (Seq=y+1, M, Master)\n            <-------------------------------------\n\
    \              DB Description (Seq=y+1, M, Slave)\n            ------------------------------------->\n\
    \                              .\n                              .\n          \
    \                    .\n               DB Description (Seq=y+n, Master)\n    \
    \        <-------------------------------------\n                DB Description\
    \ (Seq=y+n, Slave)\n            ------------------------------------->\n   Loading\
    \                                           Full\n                       Link\
    \ State Request\n            <-------------------------------------\n        \
    \               Link State Update\n            ------------------------------------->\n\
    \                              .\n                              .\n          \
    \                    .\n                       Link State Request\n          \
    \  <-------------------------------------\n                       Link State Update\n\
    \            ------------------------------------->\n    Full\n         Figure\
    \ 3: An Example of Bringing Up an Adjacency\n   At the top of Figure 3, S1's interface\
    \ to the link becomes\n   operational, and S1 begins sending Hello packets over\
    \ the interface.\n   At this point, S1 does not yet know the identity of the designated\n\
    \   switch or of any other neighboring switches.  S2 receives the Hello\n   packet\
    \ from S1 and changes its neighbor state to Init.  In its next\n   Hello packet,\
    \ S2 indicates that it is itself the designated switch\n   and that it has received\
    \ a Hello packet from S1.  S1 receives the\n   Hello packet and changes its state\
    \ to ExStart, starting the process\n   of bringing up the adjacency.\n   S1 begins\
    \ by asserting itself as the master.  When it sees that S2 is\n   indeed the master\
    \ (because of S2's higher switch ID), S1 changes to\n   slave and adopts S2's\
    \ sequence number.  Database Description packets\n   are then exchanged, with\
    \ polls coming from the master (S2) and\n   acknowledgments from the slave (S1).\
    \  This sequence of Database\n   Description packets ends when both the poll and\
    \ associated\n   acknowledgment have the M-bit off.\n   In this example, it is\
    \ assumed that S2 has a completely up-to-date\n   database and immediately changes\
    \ to the Full state. S1 will change to\n   the Full state after updating its database\
    \ by sending Link State\n   Request packets and receiving Link State Update packets\
    \ in response.\n   Note that in this example, S1 has waited until all Database\n\
    \   Description packets have been received from S2 before sending any\n   Link\
    \ State Request packets.  However, this need not be the case.  S1\n   could interleave\
    \ the sending of Link State Request packets with the\n   reception of Database\
    \ Description packets.\n"
- title: 8. Maintaining the Databases
  contents:
  - "8. Maintaining the Databases\n   Each switch advertises its state (also known\
    \ as its link state) by\n   originating switch link advertisements.  In addition,\
    \ the designated\n   switch on each network link advertises the state of the link\
    \ by\n   originating network link advertisements.\n   As described in Section\
    \ 7.1, link state advertisements are uniquely\n   identified by their type, link\
    \ state ID, and advertising switch.\n   Link state advertisements are distributed\
    \ throughout the switch\n   fabric using a reliable flooding algorithm that ensures\
    \ that all\n   switches in the fabric are notified of any link state changes.\n"
- title: 8.1 Originating Link State Advertisements
  contents:
  - "8.1 Originating Link State Advertisements\n   A new instance of each link state\
    \ advertisement is originated any\n   time the state of the switch or link changes.\
    \  When a new instance of\n   a link state advertisement is originated, its sequence\
    \ number is\n   incremented, its age is set to zero, and its checksum is calculated.\n\
    \   The advertisement is then installed into the local link state\n   database\
    \ and forwarded out all fully operational interfaces (that is,\n   those interfaces\
    \ with a state greater than Waiting) for distribution\n   throughout the switch\
    \ fabric.  See Section 8.2.4 for a description of\n   the installation of the\
    \ advertisement into the link state database\n   and Section 8.2.5 for a description\
    \ of how advertisements are\n   forwarded.\n   A switch originates a new instance\
    \ of a link state advertisement as a\n   result of the following events:\n   o\
    \  The state of one of the switch's interfaces changes such that the\n      contents\
    \ of the associated switch link advertisement changes.\n   o  The designated switch\
    \ on any of the switch's attached network\n      links changes.  The switch originates\
    \ a new switch link\n      advertisement.  Also, if the switch itself is now the\
    \ designated\n      switch, it originates a new network link advertisement for\
    \ the\n      link.\n   o  One of the switch's neighbor states changes to or from\
    \ Full. If\n      this changes the contents of the associated switch link\n  \
    \    advertisement, a new instance is generated.  Also, if the switch\n      is\
    \ the designated switch for the attached network link, it\n      originates a\
    \ new network link advertisement for the link.\n   Two instances of the same link\
    \ state advertisement must not be\n   originated within the time period MinLSInterval.\
    \  Note that this may\n   require that the generation of the second instance to\
    \ be delayed up\n   to MinLSInterval seconds.\n"
- title: 8.1.1 Switch Link Advertisements
  contents:
  - "8.1.1 Switch Link Advertisements\n   A switch link advertisement describes the\
    \ collected states of all\n   functioning links attached to the originating switch\
    \ -- that is, all\n   attached links with an interface state greater than Down.\
    \  A switch\n   originates an empty switch link advertisement when it first becomes\n\
    \   functional.  It then generates a new instance of the advertisement\n   each\
    \ time one of its interfaces reaches a fully functioning state\n   (Point-to-Point\
    \ or better).\n   Each link in the advertisement is assigned a type, based on\
    \ the state\n   of interface, as shown in Table 4.\n            Interface state\
    \     Link type     Description\n            Point-to-Point      1           \
    \  Point-to-point link\n            DS Other*           2             Multi-access\
    \ link\n            Backup*             2             Multi-access link\n    \
    \        DS**                2             Multi-access link\n              *If\
    \ a full adjacency has been formed with the designated\n               switch.\n\
    \             **If a full adjacency has been formed with at least one\n      \
    \         other switch on the link.\n               Table 4: Link Types in a Switch\
    \ Link Advertisement\n   Each link in the advertisement is also assigned a link\
    \ identifier\n   based on its link type.  In general, this value identifies another\n\
    \   switch that also originates advertisements for the link, thereby\n   providing\
    \ a key for accessing other link state advertisements for the\n   link.  The relationship\
    \ between link type and ID is shown in Table 5.\n             Type  Description\
    \           Link ID\n            1     Point-to-point link   Switch ID of neighbor\
    \ switch\n            2     Multi-access link     Switch ID of designated switch\n\
    \               Table 5: Link IDs in a Switch Link Advertisement\n   In addition\
    \ to a type and an identifier, the description of each link\n   specifies the\
    \ interface ID of the associated network link.\n   Finally, each link description\
    \ includes the cost of sending a packet\n   over the link.  This output cost is\
    \ expressed in the link state\n   metric and must be greater than zero.\n   To\
    \ illustrate the format of a switch link advertisement, consider the\n   switch\
    \ fabric shown in Figure 4.\n   In this example, switch SW1 has 5 neighboring\
    \ switches (shown as\n   boxes) distributed over 3 network links (shown as lines).\
    \  The base\n   MAC address of each switch is also shown adjacent to each box.\
    \  On\n   switch SW1, ports 01 and 02 attach to point-to-point network links,\n\
    \   while port 03 attaches to a multi-access network link with three\n   attached\
    \ switches.  The interface state of each port is shown next to\n   the line representing\
    \ the corresponding link.\n                            00-00-1d-22-23-c5\n   \
    \                             +-------+\n                                |  SW2\
    \  |\n                                +-------+\n                            \
    \        |\n                                    | Point-to-Point\n           \
    \                         |\n                                    | 01\n      \
    \ +-------+    Loopback    +-------+\n       |  SW3  |----------------|  SW1 \
    \ | 00-00-1d-1f-05-81\n       +-------+             02 +-------+\n   00-00-1d-17-35-a4\
    \                | 03\n                                    |\n               \
    \                     | DS Other\n                                    |\n    \
    \           +--------------------+--------------------+\n               |    \
    \                |                    |\n               | DS Other           |\
    \ Backup             | DS\n               |                    |             \
    \       |\n           +-------+            +-------+            +-------+\n  \
    \         |  SW4  |            |  SW5  |            |  SW6  |\n           +-------+\
    \            +-------+            +-------+\n        00-00-1d-4a-26-b3    00-00-1d-4a-27-1c\
    \    00-00-1d-7e-84-2e\n                    Figure 4: Sample Switch Fabric\n \
    \  The switch link advertisement generated by switch SW1 would contain\n   the\
    \ following data items:\n      ; switch link advertisement for switch SW1\n  \
    \    LS age = 0               ; always true on origination\n      Options = (T-bit|E-bit)\
    \  ; options\n      LS type = 1              ; this is a switch link advert\n\
    \                               ; SW1's switch ID\n      Link State ID = 00-00-1d-1f-05-81-00-00-00-00\n\
    \      Advertising switch = 00-00-1d-1f-05-81-00-00-00-00\n      # links = 2\n\
    \         ; link on interface port 1\n         Link ID = 00-00-1d-22-23-c5-00-00-00-00\
    \    ; switch ID\n         Link Data = 00-00-1d-1f-05-81-00-00-00-01  ; interface\
    \ ID\n         Type = 1                                   ; pt-to-pt link\n  \
    \       # other metrics = 0                        ; TOS 0 only\n         TOS\
    \ 0 metric = 1\n         ; link on interface port 2 is not fully functional\n\
    \         ; link on interface port 3\n         Link ID = 00-00-1d-7e-84-2e-00-00-00-00\
    \    ; switch ID of DS\n         Link Data = 00-00-1d-1f-05-81-00-00-00-03  ;\
    \ interface ID\n         Type = 2                                   ; multi-access\n\
    \         # other metrics = 0                        ; TOS 0 only\n         TOS\
    \ 0 metric = 2\n   (See Section 11.2 for a detailed description of the format\
    \ of a\n   switch link advertisement.)\n"
- title: 8.1.2 Network Link Advertisements
  contents:
  - "8.1.2 Network Link Advertisements\n   Network link advertisements are used to\
    \ describe the switches\n   attached to each multi-access network link.\n   Note:\
    \  Network link advertisements are not generated for point-to-\n   point links.\n\
    \   A network link advertisement is originated by the designated switch\n   for\
    \ the associated multi-access link once the switch has established\n   a full\
    \ adjacency with at least one other switch on the link.  Each\n   advertisement\
    \ lists the switch IDs of those switches that are fully\n   adjacent to the designated\
    \ switch.  The designated switch includes\n   itself in this list.\n   To illustrate\
    \ the format of a network link advertisement, consider\n   again the switch fabric\
    \ shown in Figure 4.  In this example, network\n   link advertisements will be\
    \ generated only by switch SW6, the\n   designated switch of the multi-access\
    \ network link between switches\n   SW1 and switches SW4, SW5, and SW6.\n   The\
    \ network link advertisement generated by switch SW6 would contain\n   the following\
    \ data items:\n      ; network link advertisement for switch SW6\n      LS age\
    \ = 0               ; always true on origination\n      Options = (T-bit|E-bit)\
    \  ; options\n      LS type = 2              ; this is a network link advert\n\
    \                                 ; SW6's switch ID\n      Link State ID = 00-00-1d-73-84-2e-00-00-00-00\n\
    \      Advertising switch = 00-00-1d-73-84-2e-00-00-00-00\n         Attached switch\
    \ = 00-00-1d-7e-84-2e-00-00-00-00\n         Attached switch = 00-00-1d-4a-26-b3-00-00-00-00\n\
    \         Attached switch = 00-00-1d-1f-05-81-00-00-00-00\n         Attached switch\
    \ = 00-00-1d-4a-27-1c-00-00-00-00\n      (See Section 11.3 for a detailed description\
    \ of the format of a\n      network link advertisement.)\n"
- title: 8.2 Distributing Link State Advertisements
  contents:
  - "8.2 Distributing Link State Advertisements\n   Link state advertisements are\
    \ distributed throughout the switch\n   fabric encapsulated within Link State\
    \ Update packets.  A single Link\n   State Update packet may contain several distinct\
    \ advertisements.\n   To make the distribution process reliable, each advertisement\
    \ must be\n   explicitly acknowledged in a Link State Acknowledgment packet. \
    \ Note,\n   however, that multiple acknowledgments can be grouped together into\
    \ a\n   single Link State Acknowledgment packet. A sending switch retransmits\n\
    \   unacknowledged Link State Update packets at regular intervals until\n   they\
    \ are acknowledged.\n   The remainder of this section is structured as follows:\n\
    \   o  Section 8.2.1 presents an overview of the distribution process.\n   o \
    \ Section 8.2.2 describes how an incoming Link State Update packet\n      is processed.\n\
    \   o  Section 8.2.3 describes how a Link State Packet is forwarded --\n     \
    \ both by the originating switch and an intermediate receiving\n      switch.\n\
    \   o  Section 8.2.4 describes how advertisements are installed into the\n   \
    \   local database.\n   o  Section 8.2.5 describes the retransmission of unacknowledged\n\
    \      advertisements.\n    o  Section 8.2.6 describes how advertisements are\
    \ acknowledged.\n"
- title: 8.2.1 Overview
  contents:
  - "8.2.1 Overview\n   The philosophy behind the distribution of link state advertisements\n\
    \   is based on the concept of adjacencies -- that is, each switch is\n   only\
    \ required to remain synchronized with its adjacent neighbors.\n   When a switch\
    \ originates a new instance of a link state\n   advertisement, it formats the\
    \ advertisement into a Link State Update\n   packet and floods the packet out\
    \ each fully operational interface --\n   that is, each interface with a state\
    \ greater than Waiting.  However,\n   only those neighbors that are adjacent to\
    \ the sending switch need to\n   process the packet.\n   The sending switch indicates\
    \ which of its neighbor switches should\n   process the advertisement by specifying\
    \ a particular multicast\n   destination in the network layer address information\
    \ (see Section\n   10.3).  The sending switch sets the value of the network layer\n\
    \   destination switch ID field according to the state of the interface\n   over\
    \ which the packet is sent:\n   o  If the interface state is Point-to-Point, DS,\
    \ or Backup, the\n      switch is adjacent to all other switches on the link and\
    \ all\n      neighboring switches must process the packet.  Therefore, the\n \
    \     destination field is set to the multicast switch ID\n      AllSPFSwitches.\n\
    \   o  If the interface state is DS Other, the switch is only adjacent to\n  \
    \    the designated switch and the backup designated switch and only\n      those\
    \ two neighboring switches must process the packet.\n      Therefore, the destination\
    \ field is set to the multicast switch ID\n      AllDSwitches.\n   A similar logic\
    \ is used when a switch receives a Link State Update\n   packet containing a new\
    \ instance of a link state advertisement.\n   After processing and acknowledging\
    \ the packet, the receiving switch\n   forwards the Link State Update packet as\n\
    \   o  On the interface over which the original Link State Update packet\n   \
    \   was received:\n      o  If the receiving switch is the designated switch for\
    \ the\n         attached network link, the packet is forwarded to all other\n\
    \         switches on the link.  (The destination field is set to\n         AllSPFSwitches.)\
    \  The originating switch will recognize that it\n         was the advertisement\
    \ originator and discard the packet.\n      o  If the receiving switch is not\
    \ the designated switch for the\n         attached network link, the packet is\
    \ not sent back out the\n         interface over which it was received.\n   o\
    \  On all other interfaces:\n      o  If the receiving switch is the designated\
    \ switch for the\n         attached network link, the packet is forwarded to all\
    \ switches\n         on the link.  (The destination field is set to AllSPFSwitches.)\n\
    \      o  If the receiving switch is neither the designated switch or the\n  \
    \       backup designated switch for the attached network link, the\n        \
    \ packet is forwarded only to the designated switch and the\n         backup designated\
    \ switch.  (The destination field is set to\n         AllDSwitches.)\n   Each\
    \ Link State Update packet is forwarded and processed in this\n   fashion until\
    \ all switches in the fabric have received notification\n   of the new instance\
    \ of the link state advertisement.\n"
- title: 8.2.2 Processing an Incoming Link State Update Packet
  contents:
  - "8.2.2 Processing an Incoming Link State Update Packet\n   When the a Link State\
    \ Update packet is received, it is first\n   subjected to a number of consistency\
    \ checks.  In particular, the Link\n   State Update packet is associated with\
    \ a specific neighbor. If the\n   state of that neighbor is less than Exchange,\
    \ the entire Link State\n   Update packet is discarded.\n   Each link state advertisement\
    \ contained in the packet is processed as\n   follows:\n   1. Validate the advertisement's\
    \ link state checksum and type. If the\n      checksum is invalid or the type\
    \ is unknown, discard the\n      advertisement without acknowledging it.\n   2.\
    \ If the advertisement's age is equal to MaxAge and there is\n      currently\
    \ no instance of the advertisement in the local link state\n      database, then\
    \ do the following:\n      a) Acknowledge the advertisement by sending a Link\
    \ State\n         Acknowledgment packet to the sending neighbor (see Section\n\
    \         8.2.6).\n      b) Purge all outstanding requests for equal or previous\
    \ instances\n         of the advertisement from the sending neighbor's Link State\n\
    \         Request list.\n      c) If the neighbor is Exchange or Loading, install\
    \ the\n         advertisement in the link state database (see Section 8.2.4).\n\
    \         Otherwise, discard the advertisement.\n   3. If the advertisement's\
    \ age is equal to MaxAge and there is an\n      instance of the advertisement\
    \ in the local link state database,\n      then do the following:\n      a) If\
    \ the advertisement is listed in the link state retransmission\n         list\
    \ of any neighbor, remove the advertisement from the\n         retransmission\
    \ list(s) and delete the database copy of the\n         advertisement.\n     \
    \ b) Discard the received (MaxAge) advertisement without\n         acknowledging\
    \ it.\n   4. If the advertisement's age is less than MaxAge, attempt to locate\n\
    \      an instance of the advertisement in the local link state database.\n  \
    \    If there is no database copy of this advertisement, or the\n      received\
    \ advertisement is more recent than the database copy (see\n      Section 7.1.1),\
    \ do the following:\n      a) If there is already a database copy, and if the\
    \ database copy\n         was installed less than MinLSInterval seconds ago, discard\
    \ the\n         new advertisement without acknowledging it.\n      b) Otherwise,\
    \ forward the new advertisement out some subset of the\n         local interfaces\
    \ (see Section 8.2.3).  Note whether the\n         advertisement was sent back\
    \ out the receiving interface for\n         later use by the acknowledgment process.\n\
    \      c) Remove the current database copy from the Link state\n         retransmission\
    \ lists of all neighbors.\n      d) Install the new advertisement in the link\
    \ state database,\n         replacing the current database copy.  (Note that this\
    \ may cause\n         the calculation of the set of best paths to be scheduled.\
    \  See\n         Section 9.)  Timestamp the new advertisement with the time that\n\
    \         it was received to prevent installation of another instance\n      \
    \   within MinLSInterval seconds.\n      e) Acknowledge the advertisement, if\
    \ necessary, by sending a Link\n         State Acknowledgment packet back out\
    \ the receiving interface.\n         (See Section 8.2.6.)\n      f) If the link\
    \ state advertisement was initially advertised by the\n         local switch itself,\
    \ advance the advertisement sequence number\n         and issue a new instance\
    \ of the advertisement. (Receipt of a\n         newer instance of an advertisement\
    \ means that the local copy of\n         the advertisement is left over from before\
    \ the last time the\n         switch was restarted.)\n   5. If the received advertisement\
    \ is the same instance as the database\n      copy (as determined by the algorithm\
    \ described in Section 7.1.1),\n      do the following:\n      a) If the advertisement\
    \ is listed in the neighbor's link state\n         retransmission list, the local\
    \ switch is expecting an\n         acknowledgment for this advertisement.  Treat\
    \ the received\n         advertisement as an implied acknowledgment, and remove\
    \ the\n         advertisement from the link state retransmission list. Note\n\
    \         this implied acknowledgment for later use by the acknowledgment\n  \
    \       process (Section 8.2.6).\n      b) Acknowledge the advertisement, if necessary,\
    \ by sending a Link\n         State Acknowledgment packet back out the receiving\
    \ interface.\n         (See Section 8.2.6.)\n   If the database copy of the advertisement\
    \ is more recent than the\n      instance just received, do the following:\n \
    \     a) Determine whether the instance is listed in the neighbor link\n     \
    \    state request list.  If so, an error has occurred in the\n         database\
    \ exchange process.  Restart the database exchange\n         process by generating\
    \ a neighbor BadLSReq event for the sending\n         neighbor and terminate processing\
    \ of the Link State Update\n         packet.\n      b) Otherwise, generate an\
    \ unusual event to network management and\n         discard the advertisement.\n"
- title: 8.2.3 Forwarding Link State Advertisements
  contents:
  - "8.2.3 Forwarding Link State Advertisements\n   When a new instance of an advertisement\
    \ is originated or after an\n   incoming advertisement has been processed, the\
    \ switch must decide\n   over which interfaces and to which neighbors the advertisement\
    \ will\n   be forwarded.  In some instances, the switch may decide not to\n  \
    \ forward the advertisement over a particular interface because it is\n   able\
    \ to determine that the neighbors on that attached link have or\n   will receive\
    \ the advertisement from another switch on the link.\n   The decision of whether\
    \ to forward an advertisement over each of the\n   switch's interfaces is made\
    \ as follows:\n   1. Each neighboring switch attached to the interface is examined\
    \ to\n      determine whether it should receive and process the new\n      advertisement.\
    \  For each neighbor, the following steps are\n      executed:\n      a) If the\
    \ neighbor state is less than Exchange, the neighbor need\n         not receive\
    \ or process the new advertisement.\n      b) If the neighbor state is Exchange\
    \ or Loading, examine the link\n         state request list associated with the\
    \ neighbor.  If an\n         instance of the new advertisement is on the list,\
    \ the\n         neighboring switch already has an instance of the\n         advertisement.\
    \  Compare the new advertisement to the neighbor's\n         copy:\n         o\
    \  If the new advertisement is less recent, the neighbor need\n            not\
    \ receive or process the new advertisement.\n         o  If the two copies are\
    \ the same instance, delete the\n            advertisement from the link state\
    \ request list.  The\n            neighbor need not receive or process the new\
    \ advertisement\n            [7].\n         o  Otherwise, the new advertisement\
    \ is more recent.  Delete the\n            advertisement from the link state request\
    \ list.  The\n            neighbor may need to receive and process the new\n \
    \           advertisement.\n      c) If the new advertisement was received from\
    \ this neighbor, the\n         neighbor need not receive or process the advertisement.\n\
    \      d) Add the new advertisement to the link state retransmission list\n  \
    \       for the neighbor.\n   2. The switch must now decide whether to forward\
    \ the new\n      advertisement out the interface.\n      a) If the link state\
    \ advertisement was not added to any of the\n         link state retransmission\
    \ lists for neighbors attached to the\n         interface, there is no need to\
    \ forward the advertisement out\n         the interface.\n      b) If the new\
    \ advertisement was received on this interface, and it\n         was received\
    \ from either the designated switch or the backup\n         designated switch,\
    \ there is no need to forward the\n         advertisement out the interface. \
    \ Chances are all neighbors on\n         the attached network link have also received\
    \ the advertisement\n         already.\n      c) If the new advertisement was\
    \ received on this interface and the\n         state of the interface is Point-to-Point,\
    \ there is no need to\n         forward the advertisement since the received advertisement\
    \ was\n         originated by the neighbor switch.\n      d) If the new advertisement\
    \ was received on this interface, and\n         the interface state is Backup\
    \ -- that is, the switch itself is\n         the backup designated switch -- there\
    \ is no need to forward the\n         advertisement out the interface.  The designated\
    \ switch will\n         distribute advertisements on the attached network link.\n\
    \      e) Otherwise, the advertisement must be forwarded out the\n         interface.\n\
    \      To forward a link state advertisement, the switch first increments\n  \
    \    the advertisement's age by InfTransDelay seconds to account for\n      the\
    \ transmission time over the link.  The switch then copies the\n      advertisement\
    \ into a Link State Update packet\n      Forwarded advertisements are sent to\
    \ all adjacent switches\n      associated with the interface.  If the interface\
    \ state is Point-\n      to-Point, DS, or Backup, the destination switch ID field\
    \ of the\n      network layer address information is set to the multicast switch\n\
    \      ID AllSPFSwitches.  If the interface state is DS Other, the\n      destination\
    \ switch ID field is set to the multicast switch ID\n      AllDSwitches.\n"
- title: 8.2.4 Installing Link State Advertisements in the Database
  contents:
  - "8.2.4 Installing Link State Advertisements in the Database\n   When a new link\
    \ state advertisement is installed into the link state\n   database, as the result\
    \ of either originating or receiving a new\n   instance of an advertisement, the\
    \ switch must determine whether the\n   best paths need to be recalculated.  To\
    \ make this determination, do\n   the following:\n   1. Compare the contents of\
    \ the new instance with the contents of the\n      old instance (assuming the\
    \ older instance is available). Note that\n      this comparison does not include\
    \ any data from the link state\n      header.  Differences in fields within the\
    \ header (such as the\n      sequence number and checksum, which are guaranteed\
    \ to be different\n      in different instances of an advertisement) are of no\
    \ consequence\n      when deciding whether or not to recalculate the set of best\
    \ paths.\n   2. If there are no differences in the contents of the two\n     \
    \ advertisement instances, there is no need to recalculate the set\n      of best\
    \ paths.\n   3. Otherwise, the set of best paths must be recalculated.\n   Note\
    \ also that the older instance of the advertisement must be\n   removed from the\
    \ link state database when the new advertisement is\n   installed.  The older\
    \ instance must also be removed from the link\n   state retransmission lists of\
    \ all neighbors.\n"
- title: 8.2.5 Retransmitting Link State Advertisements
  contents:
  - "8.2.5 Retransmitting Link State Advertisements\n   When a switch sends a link\
    \ state advertisement to an adjacent\n   neighbor, it records the advertisement\
    \ in the neighbor's link state\n   retransmission list.  To ensure the reliability\
    \ of the distribution\n   process, the switch continues to periodically retransmit\
    \ the\n   advertisements specified in the list until they are acknowledged.\n\
    \   The interval timer used to trigger retransmission of the\n   advertisements\
    \ is set to RxmtInterval seconds, as found in the\n   interface data structure.\
    \ Note that if this value is too low,\n   needless retransmissions will ensue.\
    \  If the value is too high, the\n   speed with which the databases synchronize\
    \ across adjacencies may be\n   affected if there are lost packets.\n   When the\
    \ interval timer expires, entries in the retransmission list\n   are formatted\
    \ into one or more Link State Update packets. (Remember\n   that multiple advertisements\
    \ can fit into a single Link State Update\n   packet.)  The age field of each\
    \ advertisement is incremented by\n   InfTransDelay, as found in the interface\
    \ data structure, before the\n   advertisement is copied into the outgoing packet.\n\
    \   Link State Update packets containing retransmitted advertisements are\n  \
    \ always sent directly to the adjacent switch. That is, the destination\n   field\
    \ of the network layer addressing information is set to the\n   switch ID of the\
    \ neighboring switch.\n   If the adjacent switch goes down, retransmissions will\
    \ continue until\n   the switch failure is detected and the adjacency is torn\
    \ down by the\n   VLSP discovery process.  When the adjacency is torn down, the\
    \ link\n   state retransmission list is cleared.\n"
- title: 8.2.6 Acknowledging Link State Advertisements
  contents:
  - "8.2.6 Acknowledging Link State Advertisements\n   Each link state advertisement\
    \ received by a switch must be\n   acknowledged.  In most cases, this is done\
    \ by sending a Link State\n   Acknowledgment packet.  However, acknowledgments\
    \ can also be done\n   implicitly by sending Link State Update packets (see step\
    \ 4a of\n   Section 8.2.2).\n   Multiple acknowledgments can be grouped together\
    \ into a single Link\n   State Acknowledgment packet.\n   Sending an acknowledgment\n\
    \      Link State Acknowledgment packets are sent back out the interface\n   \
    \   over which the advertisement was received.  The packet can be sent\n     \
    \ immediately to the sending neighbor, or it can be delayed and sent\n      when\
    \ an interval timer expires.\n      o  Sending delayed acknowledgments facilitates\
    \ the formatting of\n         multiple acknowledgments into a single packet. \
    \ This enables a\n         single packet to send acknowledgments to several neighbors\
    \ at\n         once by using a multicast switch ID in the destination field of\n\
    \         the network layer addressing information (see below).  Delaying\n  \
    \       acknowledgments also randomizes the acknowledgment packets sent\n    \
    \     by the multiple switches attached to a multi-access network\n         link.\n\
    \         Note that the interval used to time delayed acknowledgments\n      \
    \   must be short (less than RxmtInterval) or needless\n         retransmissions\
    \ will ensue.\n         Delayed acknowledgments are sent to all adjacent switches\n\
    \         associated with the interface.  If the interface state is\n        \
    \ Point-to-Point, DS, or Backup, the destination field of the\n         network\
    \ layer addressing information is set to the multicast\n         switch ID AllSPFSwitches.\
    \  If the interface state is DS Other,\n         the destination field is set\
    \ to the multicast switch ID\n         AllDSwitches.\n      o  Immediate acknowledgments\
    \ are sent directly to a specific\n         neighbor in response to the receipt\
    \ of duplicate link state\n         advertisements.  These acknowledgments are\
    \ sent immediately\n         when the duplicate is received.\n      The method\
    \ used to send a Link State Acknowledgment packet --\n      either delayed or\
    \ immediate -- depends on the circumstances\n      surrounding the receipt of\
    \ the advertisement, as shown in Table 6.\n      Note that switches with an interface\
    \ state of Backup send\n      acknowledgments differently than other switches\
    \ because they play\n      a slightly different role in the distribution process\
    \ (see Section\n      8.2.3).\n                                  Action taken\
    \ in state\n      Circumstances           Backup               Other states\n\
    \      Advertisement was       No ack sent          No ack sent\n      forwarded\
    \ back out\n      receiving interface\n      Advertisement is        Delayed ack\
    \ sent     Delayed ack\n      more recent than        if advertisement     sent\n\
    \      database copy, but      received from DS,\n      was not forwarded    \
    \   else do nothing\n      back out receiving\n      interface\n      Advertisement\
    \ was a     Delayed ack sent     No ack sent\n      duplicate treated       if\
    \ advertisement\n      as an implied acknow-   received from DS,\n      ledgment\
    \ (step 4a of    else do nothing\n      Section 8.2.2)\n      Advertisement was\
    \ a     Immediate ack        Immediate ack\n      duplicate not treated   sent\
    \                 sent\n      as an implied acknow-\n      ledgment\n      Advertisement\
    \ age       Immediate ack        Immediate ack\n      equal to MaxAge and    \
    \ sent                 sent\n      no current instance\n      found in database\n\
    \               Table 6: Sending Link State Acknowledgments\n   Receiving an acknowledgment\n\
    \      When the a Link State Acknowledgment packet is received, it is\n      first\
    \ subjected to a number of consistency checks.  In particular,\n      the packet\
    \ is associated with a specific neighbor. If the state of\n      that neighbor\
    \ is less than Exchange, the entire Link State\n      Acknowledgment packet is\
    \ discarded.\n      Each acknowledgment contained in the packet is processed as\n\
    \      follows:\n      o  If the advertisement being acknowledged has an instance\
    \ in the\n         link state retransmission list for the sending neighbor, do\
    \ the\n         following:\n         o  If the acknowledgment is for the same\
    \ instance as that\n            specified in the list (as determined by the procedure\n\
    \            described in Section 7.1.1), remove the instance from the\n     \
    \       retransmission list.\n         o  Otherwise, log the acknowledgment as\
    \ questionable.\n"
- title: 8.3 Aging the Link State Database
  contents:
  - "8.3 Aging the Link State Database\n   Each link state advertisement has an age\
    \ field, containing the\n   advertisement's age, expressed in seconds.  When the\
    \ advertisement is\n   copied into a Link State Update packet for forwarding out\
    \ a\n   particular interface, the age is incremented by InfTransDelay seconds\n\
    \   to account for the transmission time over the link.  An\n   advertisement's\
    \ age is never incremented past the value MaxAge.\n   Advertisements with an age\
    \ of MaxAge are not used to calculate best\n   paths.\n   If a link state advertisement's\
    \ age reaches MaxAge, the switch\n   flushes the advertisement from the switch\
    \ fabric by doing the\n   following:\n   o  Originate a new instance of the advertisement\
    \ with the age field\n      set to MaxAge.  The distribution process will eventually\
    \ result in\n      the advertisement being removed from the retransmission lists\
    \ of\n      all switches in the fabric.\n   o  Once the advertisement is no longer\
    \ contained in the link state\n      retransmission list of any neighbor and no\
    \ neighbor is in a state\n      of Exchange or Loading, remove  the advertisement\
    \ from the local\n      link state database.\n"
- title: 8.3.1 Premature Aging of Advertisements
  contents:
  - "8.3.1 Premature Aging of Advertisements\n   A link state advertisement can be\
    \ prematurely flushed from the switch\n   fabric by forcing its age to MaxAge\
    \ and redistributing the\n   advertisement.\n   A switch that was previously the\
    \ designated switch for a multi-access\n   network link but has lost that status\
    \ due to a failover to the backup\n   designated switch prematurely ages the network\
    \ link advertisements it\n   originated for the link.\n   Premature aging also\
    \ occurs when an advertisement's sequence number\n   must wrap -- that is, when\
    \ the current advertisement instance has a\n   sequence number of 0x7fffffff.\
    \  In this circumstance, the\n   advertisement is prematurely aged so that the\
    \ next instance of the\n   advertisement can be originated with a sequence number\
    \ of 0x80000001\n   and be recognized as the most recent instance.\n   A switch\
    \ may only prematurely age those link state advertisements for\n   which it is\
    \ the advertising switch.\n"
- title: 9. Calculating the Best Paths
  contents:
  - "9. Calculating the Best Paths\n   Once an adjacency has been formed and the two\
    \ switches have\n   synchronized their databases, each switch in the adjacency\
    \ calculates\n   the best path(s) to all other switches in the fabric, using itself\
    \ as\n   the root of each path.  In this context, \"best\" path means that path\n\
    \   with the lowest total cost metric across all hops.  If there are\n   multiple\
    \ paths with the same (lowest) total cost metric, they are all\n   calculated.\
    \  Best paths are stored in the area data structure.\n   Paths are calculated\
    \ using the well-known Dijkstra algorithm. For a\n   detailed description of this\
    \ algorithm, the reader is referred to\n   [Perlman], or any of a number of standard\
    \ textbooks dealing with\n   network routing.\n   Note that whenever there is\
    \ a change in an adjacency relationship, or\n   any change that alters the topology\
    \ of the switch fabric, the set of\n   best paths must be recalculated.\n"
- title: 10. Protocol Packets
  contents:
  - "10. Protocol Packets\n   This section describes VLS protocol packets and link\
    \ state\n   advertisements.\n   There are five distinct VLSP packet types, as\
    \ listed in Table 7.\n     Type  Packet Name       Function              Description\n\
    \     1     Hello             Select DS/Backup DS   Section 10.6.1\n     2   \
    \  Database          Summarize database\n             Description     contents\
    \              Section 10.6.2\n     3     LS Request        Database download\
    \     Section 10.6.3\n     4     LS Update         Database update       Section\
    \ 10.6.4\n     5     LS Ack            Flooding acknow-\n                    \
    \         ledgment              Section 10.6.5\n                      Table 7:\
    \ VLSP Packet Types\n   All VLSP packets are encapsulated within a standard ISMP\
    \ packet, with\n   the VLS packet carried in the ISMP message body.  The ISMP\
    \ packet is\n   described in Section 10.1.\n   Since it is important that the\
    \ link state databases remain\n   synchronized throughout the switch fabric, processing\
    \ of both\n   incoming and outgoing routing protocol packets should take priority\n\
    \   over ordinary data packets.  Section 10.2 describes packet\n   processing.\n\
    \   All VLSP packets begin with network layer addressing information,\n   described\
    \ in Section 10.3, followed by a standard header, described\n   in Section 10.4.\n\
    \   With the exception of Hello packets, all VLSP packets deal with lists\n  \
    \ of link state advertisements.  The format of a link state\n   advertisement\
    \ is described in Section 11.\n"
- title: 10.1 ISMP Packet Format
  contents:
  - "10.1 ISMP Packet Format\n   All VLSP packets are encapsulated within a standard\
    \ ISMP packet. ISMP\n   packets are of variable length and have the following\
    \ general\n   structure:\n   o  Frame header\n   o  ISMP packet header\n   o \
    \ ISMP message body\n"
- title: 10.1.1 Frame Header
  contents:
  - "10.1.1 Frame Header\n   ISMP packets are encapsulated within an IEEE 802-compliant\
    \ frame\n   using a standard header as shown below:\n       0                \
    \   1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   00 |                                                               |\n   \
    \   +      Destination address      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   04 |\
    \                               |                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \        Source address         +\n   08 |                                   \
    \                            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   12 |             Type              |                               |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +\n   16 |\
    \                                                               |\n      +   \
    \                                                            +\n      :      \
    \                                                         :\n   Destination address\n\
    \      This 6-octet field contains the Media Access Control (MAC) address\n  \
    \    of the multicast channel over which all switches in the fabric\n      receive\
    \ ISMP packets.  The destination address of all ISMP packets\n      contain a\
    \ value of 01-00-1D-00-00-00.\n   Source address\n      This 6-octet field contains\
    \ the physical (MAC) address of the\n      switch originating the ISMP packet.\n\
    \   Type\n      This 2-octet field identifies the type of data carried within\
    \ the\n      frame.  The type field of ISMP packets contains the value 0x81FD.\n"
- title: 10.1.2 ISMP Packet Header
  contents:
  - "10.1.2 ISMP Packet Header\n   The ISMP packet header consists of 6 octets, as\
    \ shown below:\n       0                   1                   2             \
    \      3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   00 |///////////////////////////////////////////////////////////////|\n   \
    \   ://////// Frame header /////////////////////////////////////////:\n      +////////\
    \ (14 octets)  /////////+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   12 |///////////////////////////////|\
    \            Version            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   16 |       ISMP message type       |        Sequence number        |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   20 |\
    \                                                               |\n      +   \
    \                                                            +\n      :      \
    \                                                         :\n   Frame header\n\
    \      This 14-octet field contains the frame header.\n      Version\n      This\
    \ 2-octet field contains the version number of the InterSwitch\n      Message\
    \ Protocol to which this ISMP packet adheres.  This document\n      describes\
    \ ISMP Version 2.0.           ISMP message type\n      This 2-octet field contains\
    \ a value indicating which type of ISMP\n      message is contained within the\
    \ message body.  Valid values are as\n      follows:\n         1    (reserved)\n\
    \         2    Interswitch Keepalive messages\n         3    Interswitch Link\
    \ State messages\n         4    Interswitch Spanning Tree BPDU messages and\n\
    \              Interswitch Remote Blocking messages\n         5    Interswitch\
    \ Resolve and New User messages\n         6    (reserved)\n         7    Tag-Based\
    \ Flood messages\n         8    Interswitch Tap messages\n      All VLS protocol\
    \ messages have an ISMP message type of 3.\n   Sequence number\n      This 2-octet\
    \ field contains an internally generated sequence\n      number used by the various\
    \ protocol handlers for internal\n      synchronization of messages.\n"
- title: 10.1.3 ISMP Message Body
  contents:
  - "10.1.3 ISMP Message Body\n   The ISMP message body is a variable-length field\
    \ containing the\n   actual data of the ISMP message.  The length and content\
    \ of this\n   field are determined by the value found in the message type field.\n\
    \   VLSP packets are contained in the ISMP message body.\n"
- title: 10.2 VLSP Packet Processing
  contents:
  - "10.2 VLSP Packet Processing\n   Note that with the exception of Hello packets,\
    \ VLSP packets are sent\n   only between adjacent neighbors.  Therefore, all packets\
    \ travel a\n   single hop.\n   VLSP does not support fragmentation and reassembly\
    \ of packets.\n   Therefore, packets containing lists of link state advertisements\
    \ or\n   advertisement headers must be formatted such that they contain only\n\
    \   as many advertisements or headers as will fit within the size\n   constraints\
    \ of a standard ethernet frame.\n   When a protocol packet is received by a switch,\
    \ it must first pass\n   the following criteria before being accepted for further\
    \ processing:\n   o  The checksum number must be correct.\n   o  The destination\
    \ switch ID (as found in the network layer address\n      information) must be\
    \ the switch ID of the receiving switch, or one\n      of the multicast switch\
    \ IDs AllSPFSwitches or AllDSwitches.\n      If the destination switch ID is the\
    \ multicast switch ID\n      AllDSwitches, the state of the receiving interface\
    \ must be Point-\n      to-Point, DS, or Backup.\n   o  The source switch ID (as\
    \ found in the network layer address\n      information) must not be that of the\
    \ receiving switch.  (That is,\n      locally originated packets should be discarded.)\n\
    \   At this point, if the packet is a Hello packet, it is accepted for\n   further\
    \ processing.\n   Since all other packet types are only sent between adjacent\n\
    \   neighbors, the packet must have been sent by one of the switch's\n   active\
    \ neighbors.  If the source switch ID matches the switch ID of\n   one of the\
    \ receiving switch's active neighbors (as stored in the\n   interface data structure\
    \ associated with the inport interface), the\n   packet is accepted for further\
    \ processing.  Otherwise, the packet is\n   discarded.\n"
- title: 10.3 Network Layer Address Information
  contents:
  - "10.3 Network Layer Address Information\n   As mentioned in Section 2.2.1, portions\
    \ of the VLS protocol (as\n   derived from OSPF) are dependent on certain network\
    \ layer addresses\n   -- in particular, the AllSPFSwitches and AllDSwitches multicast\n\
    \   addresses that drive the distribution of link state advertisements\n   throughout\
    \ the switch fabric.  In order to facilitate the\n   implementation of the protocol\
    \ at the physical MAC layer, network\n   layer address information is encapsulated\
    \ in the VSLP packets.  This\n   information immediately follows the ISMP frame\
    \ and packet header and\n   immediately precedes the VLSP packet header, as shown\
    \ below:\n       0                   1                   2                   3\n\
    \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                                                               |\n      :   \
    \               frame header / ISMP header                   :\n      |      \
    \                                                         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   00 |                                                               |\n   \
    \   :                      Unused (20 octets)                       :\n      |\
    \                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   20 |                                                               |\n   \
    \   +                       Source switch ID                        +\n   24 |\
    \                                                               |\n      +   \
    \                            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   28 |      \
    \                         |                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n   32 |                                   \
    \                            |\n      +                     Destination switch\
    \ ID                     +\n   36 |                                          \
    \                     |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   40 |                                                               |\n   \
    \   :                          VLSP header                          :\n      |\
    \                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Source switch ID\n      This 10-octet field contains the switch ID of the\
    \ sending switch.\n   Destination switch ID\n      This 10-octet field contains\
    \ the switch ID of the packet\n      destination.  The value here is set as follows:\n\
    \      o  Hello packets are addressed to the multicast switch ID\n         AllSPFSwitches.\n\
    \      o  The designated switch and the backup designated switch address\n   \
    \      initial Link State Update packets and Link State Acknowledgment\n     \
    \    packets to the multicast switch ID AllSPFSwitches.\n      o  All other switches\
    \ address initial Link State Update packets\n         and Link State Acknowledgment\
    \ packets to the multicast switch\n         ID AllDSwitches.\n      o  Retransmissions\
    \ of Link State Update packets are always\n         addressed directly to the\
    \ nonresponding switch.\n      o  Database Description packets and Link State\
    \ Request are always\n         addressed directly to the other switch participating\
    \ in the\n         database exchange process.\n   VLSP header\n      This 30-octet\
    \ field contains the VLSP standard header.  See\n      Section 10.4.\n"
- title: 10.4 VLSP Packet Header
  contents:
  - "10.4 VLSP Packet Header\n   Every VLSP packet starts with a common 30-octet header.\
    \  This header,\n   along with the data found in the network layer address information,\n\
    \   contains all the data necessary to determine whether the packet\n   should\
    \ be accepted for further processing. (See Section 10.1.)\n   The format of the\
    \ VLSP header is shown below.  Note that the header\n   starts at offset 36 of\
    \ the ISMP message body, following the network\n   layer address information.\n\
    \        0                   1                   2                   3\n     \
    \  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   :                  frame header / ISMP header                   :\n      |\
    \                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   00 |                                                               |\n   \
    \   :               Network layer address information               :\n      |\
    \                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   40 |    (unused)   |     Type      |         Packet length         |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   44 |\
    \                                                               |\n      +   \
    \                    Source switch ID                        +\n   48 |      \
    \                                                         |\n      +         \
    \                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   52 |            \
    \                   |         Area ID . . .         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   56 |         Area ID . . .         |           Checksum            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   60 |\
    \            Autype             |                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \        Authentication         +\n   64 |                                   \
    \                            |\n      +                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   68 |                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Type\n      This 1-octet field contains the packet type.  Possible values\
    \ are\n      as follows:\n         1   Hello\n         2   Database Description\n\
    \         3   Link State Request\n         4   Link State Update\n         5 \
    \  Link State Acknowledgment\n   Packet length\n      This 2-octet field contains\
    \ the length of the protocol packet, in\n      bytes, calculated from the start\
    \ of the VLSP header, at offset 20\n      of the ISMP message body.  If the packet\
    \ length is not an integral\n      number of 16-bit words, the packet is padded\
    \ with an octet of zero\n      (see the description of the checksum field, below).\n\
    \   Switch ID\n      This 10-octet field contains the switch ID of the sending\
    \ switch.\n   Area ID\n      This 4-octet field contains the area identifier.\
    \  Since VLSP does\n      not support multiple areas, the value here is always\
    \ zero.\n   Checksum\n      This 2-octet field contains the packet checksum value.\
    \  The\n      checksum is calculated as the 16-bit one's complement of the one's\n\
    \      complement sum of all the 16-bit words in the packet, beginning\n     \
    \ with the VLSP header, excluding the authentication field.  If the\n      packet\
    \ length is not an integral number of 16-bit words, the\n      packet is padded\
    \ with an octet of zero before calculating the\n      checksum.\n   AuType\n \
    \     This 2-octet field identifies the authentication scheme to be used\n   \
    \   for the packet.  Since authentication is not supported by this\n      version\
    \ of VLSP, this field contains zero.\n   Authentication\n      This 8-octet field\
    \ is reserved for use by the authentication\n      scheme.  Since authentication\
    \ is not supported by this version of\n      VLSP, this field contains zeroes.\n"
- title: 10.5 Options Field
  contents:
  - "10.5 Options Field\n   Hello packets and Database Description packets, as well\
    \ as link state\n   advertisements, contain a 1-octet options field.  Using this\
    \ field, a\n   switch can communicate its optional capabilities to other VLSP\n\
    \   switches.  The receiving switch can then choose whether or not to\n   support\
    \ those optional capabilities.  Thus, switches of differing\n   capabilities potentially\
    \ can be mixed within a single VLSP routing\n   domain.\n   Two optional capabilities\
    \ are currently defined in the options field:\n   routing based on Type of Service\
    \ (TOS) and support for external\n   routing beyond the local switch fabric. \
    \ These two capabilities are\n   specified in the options field as shown below.\n\
    \                             +-+-+-+-+-+-+-+-+\n                            \
    \ |0|0|0|0|0|0|E|T|\n                             +-+-+-+-+-+-+-+-+\n        \
    \                     The options field\n   T-bit\n      The T-bit specifies the\
    \ switch's Type of Service (TOS) capability.\n      If the T-bit is set, the switch\
    \ supports routing based on nonzero\n      types of service.\n   E-bit\n     \
    \ The E-bit specifies the switch's external routing capability. If\n      the\
    \ E-bit is set, the switch supports external routing.\n   Note:  The current version\
    \ of VLSP supports neither of these\n   capabilities.  Therefore, both the T-bit\
    \ and the E-bit are clear and\n   the options field contains a value of zero.\n"
- title: 10.6 Packet Formats
  contents:
  - "10.6 Packet Formats\n   This section contains detailed descriptions of the five\
    \ VLS protocol\n   packets.\n"
- title: 10.6.1 Hello Packets
  contents:
  - "10.6.1 Hello Packets\n   Hello packets are sent periodically over multi-access\
    \ switch\n   interfaces in order to discover and maintain neighbor relationships.\n\
    \   Note:  Hello packets are not sent over point-to-point network links.\n   For\
    \ point-to-point links, the VLS protocol relies on the VlanHello\n   protocol\
    \ [IDhello] to notify it of neighboring switches.\n   Since all switches connected\
    \ to a common network link must agree on\n   certain interface parameters, these\
    \ parameters are included in each\n   Hello packet.  A switch receiving a Hello\
    \ packet that contains\n   parameters inconsistent with its own view of the interface\
    \ will not\n   establish a neighbor relationship with the sending switch.\n  \
    \ The format of a Hello packet is shown below.\n        0                   1\
    \                   2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    00 |                                                               |\n  \
    \     :              Network layer addressing / VLSP header           :\n    \
    \   |                                                               |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    70 |\
    \                      (unused -- must be 0)                    |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    74 |         HelloInt              |    Options    |   Priority    |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    78\
    \ |                            DeadInt                            |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    82 |                                                               |\n  \
    \     +                      Designated switch ID                     +\n    86\
    \ |                                                               |\n       +\
    \                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    90 |  \
    \                             |                               |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n    94 |                                  \
    \                             |\n       +                   Backup designated\
    \ switch ID                 +\n    98 |                                      \
    \                         |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   102 |                                                               |\n  \
    \     +                                                               +\n    \
    \   :                          Neighbor list                        :\n      \
    \ +                                                               +\n       |\
    \                                                               |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Network layer addressing / VLSP header\n      This 70-octet field contains\
    \ the network layer addressing\n      information and the standard VLS protocol\
    \ packet header.  The\n      packet header type field contains a value of 1.\n\
    \   HelloInt\n      This 2-octet field contains the interval, in seconds, at which\n\
    \      this switch sends Hello packets.\n   Options\n      This 1-octet field\
    \ contains the optional capabilities supported by\n      the switch, as described\
    \ in Section 10.5.\n   Priority\n      This 1-octet field contains the switch\
    \ priority used in selecting\n      the designated switch and backup designated\
    \ switch (see Section\n      6.3.1).  If the value here is zero, the switch is\
    \ ineligible to\n      become the designated switch or the backup designated switch.\n\
    \   DeadInt\n      This 4-octet field contains the length of time, in seconds,\
    \ that\n      neighboring switches will wait before declaring the interface down\n\
    \      once they stop receiving Hello packets over the interface.  The\n     \
    \ value here is equal to the value of SwitchDeadInterval, as found\n      in the\
    \ interface data structure.\n   Designated switch\n      This 10-octet field contains\
    \ the switch ID of the designated\n      switch for this network link, as currently\
    \ understood by the\n      sending switch.  This value is set to zero if the designated\n\
    \      switch selection process has not yet begun.\n   Backup designated switch\n\
    \      This 10-octet field contains the switch ID of the backup\n      designated\
    \ switch for the network link, as currently understood by\n      the sending switch.\
    \  This value is set to zero if the backup\n      designated switch selection\
    \ process has not yet begun.\n   Neighbor list\n      This variable-length field\
    \ contains a list of switch IDs of each\n      switch from which the sending switch\
    \ has received a valid Hello\n      packet within the last SwitchDeadInterval\
    \ seconds.\n"
- title: 10.6.2 Database Description Packets
  contents:
  - "10.6.2 Database Description Packets\n   Database Description packets are exchanged\
    \ while an adjacency is\n   being formed between two neighboring switches and\
    \ are used to\n   describe the contents of the topological database.  For a complete\n\
    \   description of the database exchange process, see Section 7.2.\n   The format\
    \ of a Database Description packet is shown below.\n       0                 \
    \  1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   00 |                                                               |\n   \
    \   :              Network layer addressing / VLSP header           :\n      |\
    \                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   70 |     (unused -- must be 0)     |    Options    |     Flags     |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   74 |\
    \                        Sequence number                        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   78 |                                                               |\n   \
    \   +                                                               +\n      :\
    \                 Link state advertisement headers              :\n      +   \
    \                                                            +\n      |      \
    \                                                         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Network layer addressing / VLSP header\n      This 70-octet field contains\
    \ the network layer addressing\n      information and the standard VLS protocol\
    \ packet header.  The\n      packet header type field contains a value of 2.\n\
    \   Options\n      This 1-octet field contains the optional capabilities supported\
    \ by\n      the switch, as described in Section 10.5.\n   Flags\n      This 1-octet\
    \ field contains a set of bit flags that are used to\n      coordinate the database\
    \ exchange process.  The format of this\n      octet is as follows:\n        \
    \                  +-+-+-+-+-+-+-+-+\n                          |0|0|0|0|0|I|M|MS\n\
    \                          +-+-+-+-+-+-+-+-+\n   I-bit (Init)\n      The I-bit\
    \ is used to signal the start of the exchange.  It is set\n      while the two\
    \ switches negotiate the master/slave relationship and\n      the starting sequence\
    \ number.\n   M-bit (More)\n      The M-bit is set to indicate that more Database\
    \ Description\n      packets to follow.\n   MS-bit (Master/Slave)\n      The MS-bit\
    \ is used to indicate which switch is the master of the\n      exchange.  If the\
    \ bit is set, the sending switch is the master\n      during the database exchange\
    \ process.  If the bit is clear, the\n      switch is the slave.\n   Sequence\
    \ number\n      This 4-octet field is used to sequence the Database Description\n\
    \      packets during the database exchange process.  The two switches\n     \
    \ involved in the exchange process agree on the initial value of the\n      sequence\
    \ number during the master/slave negotiation.  The number\n      is then incremented\
    \ for each Database Description packet in the\n      exchange.\n      To acknowledge\
    \ each Database Description packet sent by the\n      master, the slave sends\
    \ a Database Description packet that echoes\n      the sequence number of the\
    \ packet being acknowledged.\n   Link state advertisement headers\n      This\
    \ variable-length field contains a list of link state headers\n      that describe\
    \ a portion of the master's topological database.\n      Each header uniquely\
    \ identifies a link state advertisement and its\n      current instance.  (See\
    \ Section 11.1 for a detailed description of\n      a link state advertisement\
    \ header.)  The number of headers\n      included in the list is calculated implicitly\
    \ from the length of\n      the packet, as stored in the VLSP packet header (see\
    \ Section\n      10.4).\n"
- title: 10.6.3 Link State Request Packets
  contents:
  - "10.6.3 Link State Request Packets\n   Link State Request packets are used to\
    \ request those pieces of the\n   neighbor's database that the sending switch\
    \ has discovered (during\n   the database exchange process) are more up-to-date\
    \ than instances in\n   its own database.  Link State Request packets are sent\
    \ as the last\n   step in bringing up an adjacency.  (See Section 7.3.)\n   The\
    \ format of a Link State Request packet is shown below.\n       0            \
    \       1                   2                   3\n       0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   00 |                                                               |\n   \
    \   :              Network layer addressing / VLSP header           :\n      |\
    \                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   70 |                        Link state type                        |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   74 |\
    \                                                               |\n      +   \
    \                      Link state ID                         +\n   88 |      \
    \                                                         |\n      +         \
    \                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   82 |            \
    \                   |                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n   86 |                                   \
    \                            |\n      +                      Advertising switch\
    \ ID                    +\n   90 |                                           \
    \                    |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   94 |                                                               |\n   \
    \   :                            . . .                              :\n      |\
    \                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Network layer addressing / VLSP header\n      This 70-octet field contains\
    \ the network layer addressing\n      information and the standard VLS protocol\
    \ packet header.  The\n      packet header type field contains a value of 3.\n\
    \   Link state type\n      This 4-octet field contains the link state type of\
    \ the requested\n      link state advertisement, as stored in the advertisement\
    \ header.\n   Link state ID\n      This 10-octet field contains the link state\
    \ ID of the requested\n      link state advertisement, as stored in the advertisement\
    \ header.\n   Advertising switch\n      This 10-octet field contains the switch\
    \ ID of advertising switch\n      for the requested link state advertisement,\
    \ as stored in the\n      advertisement header.\n      Note that the last three\
    \ fields uniquely identify the\n      advertisement, but not its instance.  The\
    \ receiving switch will\n      respond with its most recent instance of the specified\n\
    \      advertisement.\n      Multiple link state advertisements can be requested\
    \ in a single\n      Link State Request packet by repeating the link state type,\
    \ ID,\n      and advertising switch for each requested advertisement.  The\n \
    \     number of advertisements requested is calculated implicitly from\n     \
    \ the length of the packet, as stored in the VLSP packet header.\n"
- title: 10.6.4 Link State Update Packets
  contents:
  - "10.6.4 Link State Update Packets\n   Link State Update packets are used to respond\
    \ to a Link State Request\n   packet or to advertise a new instance of one or\
    \ more link state\n   advertisements.  Link State Update packets are acknowledged\
    \ with Link\n   State Acknowledgment packets.  For more information on the use\
    \ of\n   Link State Update packets, see Section 7 and Section 8.\n   The format\
    \ of a Link State Update packet is shown below.\n       0                   1\
    \                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   00 |                                                               |\n   \
    \   :              Network layer addressing / VLSP header           :\n      |\
    \                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   70 |                        # advertisements                       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   74 |\
    \                                                               |\n      +   \
    \                                                            +\n      :      \
    \              Link state advertisements                  :\n      +         \
    \                                                      +\n      |            \
    \                                                   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Network layer addressing / VLSP header\n      This 70-octet field contains\
    \ the network layer addressing\n      information and the standard VLS protocol\
    \ packet header.  The\n      packet header type field contains a value of 4.\n\
    \   # advertisements\n      This 4-octet field contains the number of link state\n\
    \      advertisements included in the packet.\n   Link state advertisements\n\
    \      This variable-length field contains a list of link state\n      advertisements.\
    \  For a detailed description of the different types\n      of link state advertisements,\
    \ see Section 11.\n"
- title: 10.6.5 Link State Acknowledgment Packets
  contents:
  - "10.6.5 Link State Acknowledgment Packets\n   Link State Acknowledgment Packets\
    \ are used to explicitly acknowledge\n   one or more Link State Update packets,\
    \ thereby making the\n   distribution of link state advertisements reliable. \
    \ (See Section\n   8.2.6.)\n   The format of a Link State Acknowledgment packet\
    \ is shown below.\n       0                   1                   2          \
    \         3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   00 |                                                               |\n   \
    \   :              Network layer addressing / VLSP header           :\n      |\
    \                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   70 |                                                               |\n   \
    \   +                                                               +\n      :\
    \                 Link state advertisement headers              :\n      +   \
    \                                                            +\n      |      \
    \                                                         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Network layer addressing / VLSP header\n      This 70-octet field contains\
    \ the network layer addressing\n      information and the standard VLS protocol\
    \ packet header.  The\n      packet header type field contains a value of 5.\n\
    \   Link state advertisement headers\n      This variable-length field contains\
    \ a list of link state headers\n      that are being acknowledged by this packet.\
    \  Each header uniquely\n      identifies a link state advertisement and its current\
    \ instance.\n      (See Section 11.1 for a detailed description of a link state\n\
    \      advertisement header.)  The number of headers included in the list\n  \
    \    is calculated implicitly from the length of the packet, as stored\n     \
    \ in the VLSP packet header (see Section 10.4).\n"
- title: 11. Link State Advertisement Formats
  contents:
  - "11. Link State Advertisement Formats\n   Link state advertisements are used to\
    \ describe various pieces of the\n   routing topology within the switch fabric.\
    \  Each switch in the fabric\n   maintains a complete set of all link state advertisements\
    \ generated\n   throughout the fabric.  (Section 8.1 describes the circumstances\n\
    \   under which a link state advertisement is originated.  Section 8.2\n   describes\
    \ how advertisements are distributed throughout the switch\n   fabric.) This collection\
    \ of advertisements, known as the link state\n   (or topological) database, is\
    \ used to calculate a set of best paths\n   to all other switches in the fabric.\n\
    \   There are two types of link state advertisement, as listed in Table\n   8.\n\
    \        Type   Name            Function             Description\n        1  \
    \    Switch link     Lists all network    Section 11.2\n               advertisement\
    \   linksattached to\n                               a switch\n        2     \
    \ Network link    Lists all adjacen-   Section 11.3\n               advertisement\
    \   cies on a network\n                               link\n                Table\
    \ 8: Link State Advertisement Types\n   Each link state advertisement begins with\
    \ a standard header,\n   described in Section 11.1.\n"
- title: 11.1 Link State Advertisement Headers
  contents:
  - "11.1 Link State Advertisement Headers\n   All link state advertisements begin\
    \ with a common 32-octet header.\n   This header contains information that uniquely\
    \ identifies the\n   advertisement -- its type, link state ID, and the switch\
    \ ID of its\n   advertising switch.  Also, since multiple instances of a link\
    \ state\n   advertisement can exist concurrently in the switch fabric, the header\n\
    \   contains information that permits a switch to determine which\n   instance\
    \ is the most recent -- the age, sequence number and checksum.\n   The format\
    \ of the link state advertisement header is shown below.\n       0           \
    \        1                   2                   3\n       0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   00 |              Age              |    Options    |    LS Type    |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   04 |\
    \                                                               |\n      +   \
    \                      Link state ID                         +\n   08 |      \
    \                                                         |\n      +         \
    \                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   12 |            \
    \                   |                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n   16 |                                   \
    \                            |\n      +                      Advertising switch\
    \ ID                    +\n   20 |                                           \
    \                    |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   24 |                         Sequence number                       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   28 |\
    \           Checksum            |             Length            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Age\n      This 2-octet field contains the time, in seconds, since this\n\
    \      instance of the link state advertisement was originated.\n   Options\n\
    \      This 1-octet field contains the optional capabilities supported by\n  \
    \    the advertising switch, as described in Section 10.5.\n   LS type\n     \
    \ This 1-octet field contains the type of the link state\n      advertisement.\
    \  Possible values are:\n         1   Switch link advertisement\n         2  \
    \ Network link advertisement\n   Link state ID\n      This 10-octet field identifies\
    \ the switch that originates\n      advertisements for the link.  The content\
    \ of this field depends on\n      the advertisement's type.\n      o  For a switch\
    \ link advertisement, this field contains the switch\n         ID of the originating\
    \ switch\n         o  For a network link advertisement, this field contains the\n\
    \         switch ID of the designated switch for the link\n   Note:  In VLSP,\
    \ the link state ID of an advertisement is always the\n   same as the advertising\
    \ switch.  This level of redundancy results\n   from the fact that OSPF uses additional\
    \ types of link state\n   advertisements for which the originating switch is not\
    \ the\n   advertising switch.\n   Advertising switch\n      This 10-octet field\
    \ contains the switch ID of the switch that\n      originated the link state advertisement.\n\
    \   Sequence number\n      This 4-octet field is used to sequence the instances\
    \ of a\n      particular link state advertisement.  The number is incremented\n\
    \      for each new instance.\n   Checksum\n      This 2-octet field contains\
    \ the checksum of the complete contents\n      of the link state advertisement,\
    \ excluding the age field.  The\n      checksum used is commonly referred to as\
    \ the Fletcher checksum and\n      is documented in [RFC905].  Note that since\
    \ this checksum is\n      calculated for each separate advertisement, a protocol\
    \ packet\n      containing lists of advertisements or advertisement headers will\n\
    \      contain multiple checksum values.\n   Length\n      This 2-octet field\
    \ contains the total length, in octets, of the\n      link state advertisement,\
    \ including the header.\n"
- title: 11.2 Switch Link Advertisements
  contents:
  - "11.2 Switch Link Advertisements\n   A switch link advertisement is used to describe\
    \ all functioning\n   network links of a switch, including the cost of using each\
    \ link.\n   Each functioning switch in the fabric originates one, and only one,\n\
    \   switch link advertisement -- all of the switch's links must be\n   described\
    \ in a single advertisement.  A switch originates its first\n   switch link advertisement\
    \ (containing no links) when it first becomes\n   functional.  It then originates\
    \ a new instance of the advertisement\n   each time any of its neighbor states\
    \ changes such that the contents\n   of the advertisement changes.   See Section\
    \ 8.1 for details on\n   originating a switch link advertisement.\n   The format\
    \ of a switch link advertisement is shown below.\n       0                   1\
    \                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   00 |                                                               |\n   \
    \   :                       Link state header                       :\n      |\
    \                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   32 |      (unused -- must be 0)    |            # links            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   36 |\
    \                                                               |\n      +   \
    \                         Link ID                            +\n   40 |      \
    \                                                         |\n      +         \
    \                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   44 |            \
    \                   |                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\
    \                               +\n   48 |                                   \
    \                            |\n      +                           Link data  \
    \                         +\n   52 |                                         \
    \                      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   56 |   Link type   |     # TOS     |         TOS 0 metric          |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   60 |\
    \                                                               |\n      :   \
    \                         . . .                              :\n      |      \
    \                                                         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Link state header\n      This 32-octet field contains the standard link state\
    \ advertisement\n      header.  The type field contains a 1, and the link state\
    \ ID field\n      contains the switch ID of the advertising switch.\n   # links\n\
    \      This 2-octet field contains the number of links described by this\n   \
    \   advertisement.  This value must be equal to the total number of\n      functioning\
    \ network links attached to the switch.\n   Link ID\n      This 10-octet field\
    \ identifies the other switch that originates\n      link state advertisements\
    \ for the link, providing a key for\n      accessing other link state advertisements\
    \ for the link.  The value\n      here is based on the link type, as follows:\n\
    \      o  For point-to-point links, this field contains the switch ID of\n   \
    \      the neighbor switch connected to the other end of the link.\n      o  For\
    \ multi-access links, this field contains the switch ID of\n         the designated\
    \ switch for the link.\n   Link data\n      This 10-octet field contains additional\
    \ data necessary to\n      calculate the set of best paths.  Typically, this field\
    \ contains\n      the interface ID of the link.\n   Link type\n      This 1-octet\
    \ field contains the type of link being described.\n      Possible values are\
    \ as follows:\n         1   Point-to-point link\n         2   Multi-access link\n\
    \   # TOS\n      This 1-octet field contains the number of nonzero type of service\n\
    \      metrics specified for the link.  Since the current version of VLSP\n  \
    \    does not support routing based on nonzero types of service, this\n      field\
    \ contains a value of zero.\n   TOS 0 metric\n      This 2-octet field contains\
    \ the cost of using this link for the\n      zero TOS.  This value is expressed\
    \ in the link state metric and\n      must be greater than zero.\n   Note that\
    \ the last five fields are repeated for all functioning\n   network links attached\
    \ to the advertising switch.  If the interface\n   state of attached link changes,\
    \ the switch must originate a new\n   instance of the switch link advertisement.\n"
- title: 11.3 Network Link Advertisements
  contents:
  - "11.3 Network Link Advertisements\n   A network link advertisement is originated\
    \ by the designated switch\n   of each multi-access network link.  The advertisement\
    \ describes all\n   switches attached to the link that are currently fully adjacent\
    \ to\n   the designated switch, including the designated switch itself.  See\n\
    \   Section 8.1 for details on originating a switch link advertisement.\n   Network\
    \ link advertisements are not generated for point-to-point\n   network links.\n\
    \   The format of a network link advertisement is show below.\n       0      \
    \             1                   2                   3\n       0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   00 |                                                               |\n   \
    \   :                       Link state header                       :\n      |\
    \                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   32 |                           (unused)                            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   36 |\
    \                                                               |\n      +   \
    \                                                            +\n      :      \
    \                    Switch list                          :\n      +         \
    \                                                      +\n      |            \
    \                                                   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Link state header\n      This 32-octet field contains the standard link state\
    \ advertisement\n      header.  The type field contains a 2, and the link state\
    \ ID field\n      contains the switch ID of the designated switch.\n   Switch\
    \ list\n      The switch IDs of all switches attached to the network link that\n\
    \      are currently fully adjacent to the designated switch. The\n      designated\
    \ switch includes itself in this list.\n"
- title: 12. Protocol Parameters
  contents:
  - "12. Protocol Parameters\n   This section contains a compendium of the parameters\
    \ used in the VLS\n   protocol.\n"
- title: 12.1 Architectural Constants
  contents:
  - "12.1 Architectural Constants\n   Several VLS protocol parameters have fixed architectural\
    \ values. The\n   name of each architectural constant follows, together with its\
    \ value\n   and a short description of its function.\n   AllSPFSwitches\n    \
    \  The multicast switch ID to which Hello packets and certain other\n      protocol\
    \ packets are addressed, as specified in the destination\n      switch ID field\
    \ of the network layer address information (see\n      Section 10.3).  The value\
    \ of AllSPFSwitches is E0-00-00-05-00-00-\n      00-00.\n   AllDSwitches\n   \
    \   The multicast switch ID to which Link State Update packets and\n      Link\
    \ State Acknowledgment packets are addressed, as specified in\n      the destination\
    \ switch ID field of the network layer address\n      information (see Section\
    \ 10.3), when they are destined for the\n      designated switch or the backup\
    \ designated switch of a network\n      link.  The value of AllDSwitches is E0-00-00-06-00-00-00-00.\n\
    \   LSRefreshTime\n      The interval at which the set of best paths recalculated\
    \ if no\n      other state changes have forced a recalculation.  The value of\n\
    \      LSRefreshTime is set to 1800 seconds (30 minutes).\n   MinLSInterval\n\
    \      The minimum time between distinct originations of any particular\n    \
    \  link state advertisement.  The value of MinLSInterval is set to 5\n      seconds.\n\
    \   MaxAge\n      The maximum age that a link state advertisement can attain.\
    \ When\n      an advertisement's age reaches MaxAge, it is redistributed\n   \
    \   throughout the switch fabric.  When the originating switch\n      receives\
    \ an acknowledgment for the advertisement, indicating that\n      the advertisement\
    \ has been removed from all neighbor Link state\n      retransmission lists, the\
    \ advertisement is removed from the\n      originating switch's database.  Advertisements\
    \ having age MaxAge\n      are not used to calculate the set of best paths.  The\
    \ value of\n      MaxAge must be greater than LSRefreshTime.  The value of MaxAge\
    \ is\n      set to 3600 seconds (1 hour).\n   MaxAgeDiff\n      The maximum time\
    \ disparity in ages that can occur for a single\n      link state instance as\
    \ it is distributed throughout the switch\n      fabric.  Most of this time is\
    \ accounted for by the time the\n      advertisement sits on switch output queues\
    \ (and therefore not\n      aging) during the distribution process. The value\
    \ of MaxAgeDiff is\n      set to 900 seconds (15 minutes).\n   LSInfinity\n  \
    \    The link state metric value indicating that the destination is\n      unreachable.\
    \  It is defined to be a binary value of all ones.\n"
- title: 12.2 Configurable Parameters
  contents:
  - "12.2 Configurable Parameters\n   Many of the switch interface parameters used\
    \ by VLSP may be made\n   configurable if the implementer so desires.  These parameters\
    \ are\n   listed below.  Sample default values are given for some of the\n   parameters.\n\
    \   Note that some of these parameters specify properties of the\n   individual\
    \ interfaces and their attached network links.  These\n   parameters must be consistent\
    \ across all the switches attached to\n   that link.\n   Interface output cost(s)\n\
    \      The cost of sending a packet over the interface, expressed in the\n   \
    \   link state metric.  This is advertised as the link cost for this\n      interface\
    \ in the switch's switch link advertisement. The interface\n      output cost\
    \ must always be greater than zero.\n   RxmtInterval\n      The number of seconds\
    \ between link state advertisement\n      retransmissions for adjacencies established\
    \ on this interface.\n      This value is also used when retransmitting Database\
    \ Description\n      packets and Link State Request packets. This value must be\
    \ greater\n      than the expected round-trip delay between any two switches on\
    \ the\n      attached link.  However, the value should be conservative or\n  \
    \    needless retransmissions will result.  A typical value for a local\n    \
    \  area network would be 5 seconds.\n   InfTransDelay\n      The estimated number\
    \ of seconds it takes to transmit a Link State\n      Update packet over this\
    \ interface.  Link state advertisements\n      contained in the Link State Update\
    \ packet must have their age\n      incremented by this amount before transmission.\
    \  This value must\n      take into account the transmission and propagation delays\
    \ for the\n      interface and must be greater than zero.  A typical value for\
    \ a\n      local area network would be 1 second.\n   Switch priority\n      An\
    \ 8-bit unsigned integer.  When two switches attached to the same\n      network\
    \ link contend for selection as the designated switch, the\n      switch with\
    \ the highest priority takes precedence.  If both\n      switches have the same\
    \ priority, the switch with the highest base\n      MAC address becomes the designated\
    \ switch.  A switch whose switch\n      priority is set to zero is ineligible\
    \ to become the designated\n      switch on the attached link.\n   HelloInterval\n\
    \      The length of time, in seconds, between the Hello packets that the\n  \
    \    switch sends over the interface.  This value is advertised in the\n     \
    \ switch's Hello packets.  It must be the same for all switches\n      attached\
    \ to a common network link.  The smaller this value is set,\n      the faster\
    \ topological changes will be detected.  However, a\n      smaller interval will\
    \ also generate more routing traffic.  A\n      typical value for a local area\
    \ network would be 10 seconds.\n   SwitchDeadInterval\n      The length of time,\
    \ in seconds, that neighboring switches will\n      wait before declaring the\
    \ interface down once they stop receiving\n      Hello packets over the interface.\
    \  This value is advertised in the\n      switch's Hello packets.  It must be\
    \ the same for all switches\n      attached to a common network link and should\
    \ be some multiple of\n      the HelloInterval parameter.  A typical value would\
    \ be 4 times\n      HelloInterval.\n"
- title: 13. End Notes
  contents:
  - "13. End Notes\n   [1] During calculation of the set of best paths, a network\
    \ link\n   advertisement must be located based solely on its link state ID.\n\
    \   Note, however, that the lookup in this case is still well defined,\n   since\
    \ no two network advertisements can have the same link state ID.\n   [2] It is\
    \ instructive to see what happens when the designated switch\n   for a network\
    \ link fails.  Call the designated switch for the link S1\n   and the backup designated\
    \ switch S2.  If switch S1 fails (or its\n   interface to the link goes down),\
    \ the other switches on the link will\n   detect S1's absence within SwitchDeadInterval\
    \ seconds.  All switches\n   may not detect this condition at precisely the same\
    \ time.  The\n   switches that detect S1's absence before S2 does will temporarily\n\
    \   select S2 as both designated switch and backup designated switch.\n   When\
    \ S2 detects that S1 is down, it will move itself to designated\n   switch.  At\
    \ this time, the remaining switch with the highest switch\n   priority will be\
    \ selected as the backup designated switch.\n   [3] Note that it is possible for\
    \ a switch to resynchronize any of its\n   fully established adjacencies by setting\
    \ the neighbor state back to\n   ExStart.  This causes the switch on the other\
    \ end of the adjacency to\n   process a SeqNumberMismatch event and also revert\
    \ to the ExStart\n   state.\n   [4] When two advertisements have different checksum\
    \ values, they are\n   assumed to be separate instances.  This can occur when\
    \ a switch\n   restarts and loses track of its previous sequence number. In this\n\
    \   case, since the two advertisements have the same sequence number, it\n   is\
    \ not possible to determine which advertisement is actually newer.\n   If the\
    \ wrong advertisement is accepted as newer, the originating\n   switch will originate\
    \ another instance.\n   [5] An instance of an advertisement is originated with\
    \ an age of\n   MaxAge only when it is to be flushed from the database.  This\
    \ is done\n   either when the advertisement has naturally aged to MaxAge, or (more\n\
    \   typically) when the sequence number must wrap. Therefore, a received\n   instance\
    \ with an age of MaxAge must be processed as the most recent\n   in order to flush\
    \ it properly from the database.\n   [6] MaxAgeDiff is an architectural constant\
    \ that defines the maximum\n   disparity in ages, in seconds, that can occur for\
    \ a single link state\n   instance as it is distributed throughout the switch\
    \ fabric.  If two\n   advertisements differ by more than this amount, they are\
    \ assumed to\n   be different instances of the same advertisement. This can occur\
    \ when\n   a switch restarts and loses track of its previous sequence number.\n\
    \   [7] This is how the link state request list is emptied, causing the\n   neighbor\
    \ state to change to Full.\n"
- title: 14. Security Considerations
  contents:
  - "14. Security Considerations\n   Security concerns are not addressed in this document.\n"
- title: 15. References
  contents:
  - "15. References\n   [Perlman]    Perlman, R.,  Interconnections: Bridges and Routers.\n\
    \                Addison-Wesley Publishing Company.  1992.\n   [RFC905]     McKenzie,\
    \ A., \"ISO Transport Protocol specification ISO\n                DP 8073\", RFC\
    \ 905, April 1984.\n   [RFC2328]    Moy, J., \"OSPF Version 2\", STD 54, RFC 2328,\
    \ April 1998.\n   [RFC1700]    Reynolds, J. and J. Postel, \"Assigned Numbers\"\
    , STD 2,\n                RFC 1700, October 1994.\n   [IDsfvlan]   Ruffen, D.,\
    \ Len, T. and J. Yanacek, \"Cabletron's\n                SecureFast VLAN Operational\
    \ Model\", RFC 2643, August\n                1999.\n   [IDhello]    Hamilton,\
    \ D. and D. Ruffen, \"Cabletron's VlanHello\n                Protocol Specification\"\
    , RFC 2641, August 1999.\n"
- title: 16. Author's Address
  contents:
  - "16. Author's Address\n   Laura Kane\n   Cabletron Systems, Inc.\n   Post Office\
    \ Box 5005\n   Rochester, NH  03866-5005\n   Phone:(603) 332-9400\n   EMail: \
    \ lkane@ctron.com\n"
- title: 17.  Full Copyright Statement
  contents:
  - "17.  Full Copyright Statement\n   Copyright (C) The Internet Society (1999).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
