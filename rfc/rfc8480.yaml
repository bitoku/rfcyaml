- title: __initial_text__
  contents:
  - '             6TiSCH Operation Sublayer (6top) Protocol (6P)

    '
- title: Abstract
  contents:
  - "Abstract\n   This document defines the \"IPv6 over the TSCH mode of IEEE 802.15.4e\"\
    \n   (6TiSCH) Operation Sublayer (6top) Protocol (6P), which enables\n   distributed\
    \ scheduling in 6TiSCH networks.  6P allows neighbor nodes\n   to add/delete Time-Slotted\
    \ Channel Hopping (TSCH) cells to/on one\n   another.  6P is part of the 6TiSCH\
    \ Operation Sublayer (6top), the\n   layer just above the IEEE Std 802.15.4 TSCH\
    \ Medium Access Control\n   layer.  6top is composed of one or more Scheduling\
    \ Functions (SFs)\n   and the 6top Protocol defined in this document.  A 6top\
    \ SF decides\n   when to add/delete cells, and it triggers 6P Transactions.  The\n\
    \   definition of SFs is out of scope for this document; however, this\n   document\
    \ provides the requirements for an SF.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 7841.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8480.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2018 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \      1.1. Requirements Language ......................................5\n  \
    \ 2. 6TiSCH Operation Sublayer (6top) ................................5\n    \
    \  2.1. Hard/Soft Cells ............................................6\n      2.2.\
    \ Using 6P with the Minimal 6TiSCH Configuration .............6\n   3. 6top Protocol\
    \ (6P) ..............................................7\n      3.1. 6P Transactions\
    \ ............................................7\n           3.1.1. 2-Step 6P Transaction\
    \ ...............................8\n           3.1.2. 3-Step 6P Transaction ..............................10\n\
    \      3.2. Message Format ............................................12\n  \
    \         3.2.1. 6top Information Element (IE) ......................12\n    \
    \       3.2.2. Generic 6P Message Format ..........................12\n      \
    \     3.2.3. 6P CellOptions .....................................13\n        \
    \   3.2.4. 6P CellList ........................................16\n      3.3.\
    \ 6P Commands and Operations ................................17\n           3.3.1.\
    \ Adding Cells .......................................17\n           3.3.2. Deleting\
    \ Cells .....................................19\n           3.3.3. Relocating\
    \ Cells ...................................21\n           3.3.4. Counting Cells\
    \ .....................................27\n           3.3.5. Listing Cells ......................................28\n\
    \           3.3.6. Clearing the Schedule ..............................30\n  \
    \         3.3.7. Generic Signaling between SFs ......................31\n    \
    \  3.4. Protocol Functional Details ...............................31\n      \
    \     3.4.1. Version Checking ...................................31\n        \
    \   3.4.2. SFID Checking ......................................32\n          \
    \ 3.4.3. Concurrent 6P Transactions .........................32\n           3.4.4.\
    \ 6P Timeout .........................................33\n           3.4.5. Aborting\
    \ a 6P Transaction ..........................33\n           3.4.6. SeqNum Management\
    \ ..................................33\n           3.4.7. Handling Error Responses\
    \ ...........................40\n      3.5. Security ..................................................40\n\
    \   4. Requirements for 6top Scheduling Function (SF) Specifications ..41\n  \
    \    4.1. SF Identifier (SFID) ......................................41\n    \
    \  4.2. Requirements for an SF Specification ......................41\n   5. Security\
    \ Considerations ........................................42\n   6. IANA Considerations\
    \ ............................................43\n      6.1. IETF IE Subtype 6P\
    \ ........................................43\n      6.2. 6TiSCH Parameters Subregistries\
    \ ...........................43\n           6.2.1. 6P Version Numbers .................................43\n\
    \           6.2.2. 6P Message Types ...................................44\n  \
    \         6.2.3. 6P Command Identifiers .............................44\n    \
    \       6.2.4. 6P Return Codes ....................................45\n      \
    \     6.2.5. 6P Scheduling Function Identifiers .................46\n        \
    \   6.2.6. 6P CellOptions Bitmap ..............................47\n   7. References\
    \ .....................................................48\n      7.1. Normative\
    \ References ......................................48\n      7.2. Informative\
    \ References ....................................48\n   Appendix A. Recommended\
    \ Structure of an SF Specification ..........49\n   Authors' Addresses ................................................50\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   All communication in an \"IPv6 over the TSCH mode of IEEE\
    \ 802.15.4e\"\n   (6TiSCH) network is orchestrated by a schedule [RFC7554].  The\n\
    \   schedule is composed of cells, each identified by a\n   [slotOffset,channelOffset]\
    \ (Section 3.2.4).  This specification\n   defines the 6TiSCH Operation Sublayer\
    \ (6top) Protocol (6P), which is\n   terminated by 6top.  6P allows a node to\
    \ communicate with a neighbor\n   node to add/delete Time-Slotted Channel Hopping\
    \ (TSCH) cells to/on\n   one another.  This results in distributed schedule management\
    \ in a\n   6TiSCH network.  6top is composed of one or more Scheduling Functions\n\
    \   (SFs) and the 6top Protocol defined in this document.  The definition\n  \
    \ of SFs is out of scope for this document; however, this document\n   provides\
    \ the requirements for an SF.\n   The example network depicted in Figure 1 is\
    \ used to describe the\n   interaction between nodes.  We consider the canonical\
    \ case where\n   node \"A\" issues 6P Requests (also referred to as \"commands\"\
    \ in this\n   document) to node \"B\".  We use this example throughout this document:\n\
    \   node A always represents the node that issues a 6P Request, and\n   node B\
    \ represents the node that receives this request.\n                          \
    \          (R)\n                                    / \\\n                   \
    \                /   \\\n                                (B)-----(C)\n       \
    \                          |       |\n                                 |     \
    \  |\n                                (A)     (D)\n                     Figure\
    \ 1: A Simple 6TiSCH Network\n   We consider that node A monitors the communication\
    \ cells it has in\n   its schedule to node B:\n   o  If node A determines that\
    \ the number of link-layer frames it is\n      sending to node B per unit of time\
    \ exceeds the capacity offered by\n      the TSCH cells it has scheduled to node\
    \ B, it triggers a 6P\n      Transaction with node B to add one or more cells\
    \ to the TSCH\n      schedule of both nodes.\n   o  If the traffic is lower than\
    \ the capacity offered by the TSCH\n      cells it has scheduled to node B, node\
    \ A triggers a 6P Transaction\n      with node B to delete one or more cells in\
    \ the TSCH schedule of\n      both nodes.\n   o  Node A MAY also monitor statistics\
    \ to determine whether collisions\n      are happening on a particular cell to\
    \ node B.  If this feature is\n      enabled, node A communicates with node B\
    \ to \"relocate\" this\n      particular cell to a different [slotOffset,channelOffset]\
    \ location\n      in the TSCH schedule.\n   This results in distributed schedule\
    \ management in a 6TiSCH network.\n   The 6top SF defines when to add/delete a\
    \ cell to/on a neighbor.\n   Different applications require different SFs; this\
    \ topic is out of\n   scope for this document.  Different SFs are expected to\
    \ be defined in\n   future companion specifications.  A node MAY implement multiple\
    \ SFs\n   and run them at the same time.  At least one SF MUST be running.  The\n\
    \   SFID field contained in all 6P messages allows a node to invoke the\n   appropriate\
    \ SF on a per-6P Transaction basis.\n   Section 2 describes 6top.  Section 3 defines\
    \ 6P.  Section 4 provides\n   guidelines on how to define an SF.\n"
- title: 1.1.  Requirements Language
  contents:
  - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted\
    \ as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear\
    \ in all\n   capitals, as shown here.\n"
- title: 2.  6TiSCH Operation Sublayer (6top)
  contents:
  - "2.  6TiSCH Operation Sublayer (6top)\n   As depicted in Figure 2, 6top is the\
    \ layer just above the IEEE Std\n   802.15.4 TSCH Medium Access Control (MAC)\
    \ layer [IEEE802154].  We use\n   \"802.15.4\" as a short version of \"IEEE Std\
    \ 802.15.4\" in this\n   document.\n                                   .\n   \
    \            |                   .                      |\n               |  \
    \           higher layers                |\n               +------------------------------------------+\n\
    \               |                 6top                     |\n               +------------------------------------------+\n\
    \               |          IEEE Std 802.15.4 TSCH          |\n               |\
    \                   .                      |\n                               \
    \    .\n                   Figure 2: 6top in the Protocol Stack\n   The roles\
    \ of 6top are to:\n   o  Terminate 6P, which allows neighbor nodes to communicate\
    \ to\n      add/delete cells to/on one another.\n   o  Run one or multiple 6top\
    \ SFs, which define the rules that decide\n      when to add/delete cells.\n"
- title: 2.1.  Hard/Soft Cells
  contents:
  - "2.1.  Hard/Soft Cells\n   Each cell in the schedule is either \"hard\" or \"\
    soft\":\n   o  A soft cell can be read, added, deleted, or updated by 6top.\n\
    \   o  A hard cell is read-only for 6top.\n   In the context of this specification,\
    \ all the cells used by 6top are\n   soft cells.  Hard cells can be used, for\
    \ example, when \"hard-coding\"\n   a schedule [RFC8180].\n"
- title: 2.2.  Using 6P with the Minimal 6TiSCH Configuration
  contents:
  - "2.2.  Using 6P with the Minimal 6TiSCH Configuration\n   6P MAY be used alongside\
    \ the minimal 6TiSCH configuration [RFC8180].\n   In this case, it is RECOMMENDED\
    \ to use two slotframes, as depicted in\n   Figure 3:\n   o  Slotframe 0 is used\
    \ for traffic defined in the minimal 6TiSCH\n      configuration.  In Figure 3,\
    \ Slotframe 0 is five slots long, but\n      it can be shorter or longer.\n  \
    \ o  6P allocates cells from Slotframe 1.  In Figure 3, Slotframe 1 is\n     \
    \ 10 slots long, but it can be shorter or longer.\n                    | 0   \
    \ 1    2    3    4  | 0    1    2    3    4  |\n                    +------------------------+------------------------+\n\
    \        Slotframe 0 |    |    |    |    |    |    |    |    |    |    |\n   \
    \    5 slots long | EB |    |    |    |    | EB |    |    |    |    |\n   (Minimal\
    \ 6TiSCH) |    |    |    |    |    |    |    |    |    |    |\n              \
    \      +-------------------------------------------------+\n                 \
    \   | 0    1    2    3    4    5    6    7    8    9  |\n                    +-------------------------------------------------+\n\
    \        Slotframe 1 |    |    |    |    |    |    |    |    |    |    |\n   \
    \   10 slots long |    |A->B|    |    |    |    |    |    |B->A|    |\n      \
    \         (6P) |    |    |    |    |    |    |    |    |    |    |\n         \
    \           +-------------------------------------------------+\n        Figure\
    \ 3: 2-Slotframe Structure when Using 6P alongside the\n                     \
    \  Minimal 6TiSCH Configuration\n   The minimal 6TiSCH configuration cell SHOULD\
    \ be allocated from a\n   slotframe of higher priority than the slotframe used\
    \ by 6P for\n   dynamic cell allocation.  This way, dynamically allocated cells\n\
    \   cannot \"mask\" the cells used by the minimal 6TiSCH configuration.\n   6top\
    \ MAY support additional slotframes; how to use additional\n   slotframes is out\
    \ of scope for this document.\n"
- title: 3.  6top Protocol (6P)
  contents:
  - "3.  6top Protocol (6P)\n   6P enables two neighbor nodes to add/delete/relocate\
    \ cells in their\n   TSCH schedule.  Conceptually, two neighbor nodes \"negotiate\"\
    \ the\n   location of the cells to add, delete, or relocate in their TSCH\n  \
    \ schedule.\n"
- title: 3.1.  6P Transactions
  contents:
  - "3.1.  6P Transactions\n   We call \"6P Transaction\" a complete negotiation between\
    \ two neighbor\n   nodes.  A particular 6P Transaction is executed between two\
    \ nodes as\n   a result of an action triggered by one SF.  For a 6P Transaction\
    \ to\n   succeed, both nodes must use the same SF to handle the particular\n \
    \  transaction.  A 6P Transaction starts when a node wishes to\n   add/delete/relocate\
    \ one or more cells with one of its neighbors.  A\n   6P Transaction ends when\
    \ (1) the cell(s) has been added/deleted/\n   relocated in the schedule of both\
    \ nodes or (2) the 6P Transaction has\n   failed.\n   6P messages exchanged between\
    \ nodes A and B during a 6P Transaction\n   SHOULD be exchanged on non-shared\
    \ unicast cells (\"dedicated\" cells)\n   between nodes A and B.  If no dedicated\
    \ cells are scheduled between\n   nodes A and B, shared cells MAY be used.\n \
    \  Keeping consistency between the schedules of the two neighbor nodes\n   is\
    \ important.  A loss of consistency can cause loss of connectivity.\n   One example\
    \ is when node A has a transmit cell to node B but node B\n   does not have the\
    \ corresponding reception cell.  To verify\n   consistency, neighbor nodes maintain\
    \ a sequence number (SeqNum).\n   Neighbor nodes exchange the SeqNum as part of\
    \ each 6P Transaction to\n   detect a possible inconsistency.  This mechanism\
    \ is explained in\n   Section 3.4.6.2.\n   An implementation MUST include a mechanism\
    \ to associate each\n   scheduled cell with the SF that scheduled it.  This mechanism\
    \ is\n   implementation specific and is out of scope for this document.\n   A\
    \ 6P Transaction can consist of two or three steps.  A 2-step\n   transaction\
    \ is used when node A selects the cells to be allocated.  A\n   3-step transaction\
    \ is used when node B selects the cells to be\n   allocated.  An SF MUST specify\
    \ whether to use 2-step transactions,\n   3-step transactions, or both.\n   We\
    \ illustrate 2-step and 3-step transactions using the topology in\n   Figure 1.\n"
- title: 3.1.1.  2-Step 6P Transaction
  contents:
  - "3.1.1.  2-Step 6P Transaction\n   Figure 4 shows an example 2-step 6P Transaction.\
    \  In a 2-step\n   transaction, node A selects the candidate cells.  Several elements\n\
    \   are left out so that the diagram is easier to understand.\n              \
    \  +----------+                           +----------+\n                |  Node\
    \ A  |                           |  Node B  |\n                +----+-----+  \
    \                         +-----+----+\n                     |               \
    \                        |\n                     | 6P ADD Request            \
    \            |\n                     |   Type         = REQUEST              |\n\
    \                     |   Code         = ADD                  |\n            \
    \         |   SeqNum       = 123                  |\n      cells          |  \
    \ NumCells     = 2                    |\n      locked         |   CellList   \
    \  = [(1,2),(2,2),(3,5)]  |\n       +--           |-------------------------------------->|\n\
    \       |             |                                L2 ACK |\n       |  6P\
    \ Timeout |<- - - - - - - - - - - - - - - - - - - |\n       |        |    |  \
    \                                     |\n       |        |    | 6P Response  \
    \                         |\n       |        |    |   Type         = RESPONSE\
    \             |\n       |        |    |   Code         = RC_SUCCESS          \
    \ |\n       |        |    |   SeqNum       = 123                  | cells\n  \
    \     |        |    |   CellList     = [(2,2),(3,5)]        | locked\n       +->\
    \      X    |<--------------------------------------| --+\n                  \
    \   | L2 ACK                                |   |\n                     | - -\
    \ - - - - - - - - - - - - - - - - ->| <-+\n                     |            \
    \                           |\n                Figure 4: An Example 2-Step 6P\
    \ Transaction\n   In this example, the 2-step transaction occurs as follows:\n\
    \   1.  The SF running on node A determines that two extra cells need to\n   \
    \    be scheduled to node B.\n   2.  The SF running on node A selects candidate\
    \ cells for node B to\n       choose from.  Node A MUST select at least as many\
    \ candidate cells\n       as the number of cells to add.  Here, node A selects\
    \ three\n       candidate cells.  Node A locks those candidate cells in its\n\
    \       schedule until it receives a 6P Response.\n   3.  Node A sends a 6P ADD\
    \ Request to node B, indicating that it\n       wishes to add two cells (the \"\
    NumCells\" value) and specifying the\n       list of three candidate cells (the\
    \ \"CellList\" value).  Each cell\n       in the CellList is a [slotOffset,channelOffset]\
    \ tuple.  This 6P\n       ADD Request is link-layer acknowledged by node B (labeled\
    \ \"L2\n       ACK\" in Figure 4).\n   4.  After having successfully sent the\
    \ 6P ADD Request (i.e.,\n       receiving the link-layer acknowledgment), node\
    \ A starts a 6P\n       Timeout to abort the 6P Transaction in the event that\
    \ no response\n       is received from node B.\n   5.  The SF running on node\
    \ B selects two out of the three cells from\n       the CellList of the 6P ADD\
    \ Request.  Node B locks those cells in\n       its schedule until the transmission\
    \ is successful (i.e., node B\n       receives a link-layer ACK from node A).\
    \  Node B sends back a 6P\n       Response to node A, indicating the cells it\
    \ has selected.  The\n       response is link-layer acknowledged by node A.\n\
    \   6.  Upon completion of this 6P Transaction, two cells from node A to\n   \
    \    node B have been added to the TSCH schedule of both nodes A\n       and B.\n\
    \   7.  An inconsistency in the schedule can happen if the 6P Timeout\n      \
    \ expires when the 6P Response is in the air, if the last\n       link-layer ACK\
    \ for the 6P Response is lost, or if one of the\n       nodes is power-cycled\
    \ during the transaction.  6P provides an\n       inconsistency detection mechanism\
    \ to cope with such situations;\n       see Section 3.4.6.2 for details.\n"
- title: 3.1.2.  3-Step 6P Transaction
  contents:
  - "3.1.2.  3-Step 6P Transaction\n   Figure 5 shows an example 3-step 6P Transaction.\
    \  In a 3-step\n   transaction, node B selects the candidate cells.  Several elements\n\
    \   are left out so that the diagram is easier to understand.\n            +----------+\
    \                           +----------+\n            |  Node A  |           \
    \                |  Node B  |\n            +----+-----+                      \
    \     +-----+----+\n                 |                                       |\n\
    \                 | 6P ADD Request                        |\n                \
    \ |   Type         = REQUEST              |\n                 |   Code       \
    \  = ADD                  |\n                 |   SeqNum       = 178         \
    \         |\n                 |   NumCells     = 2                    |\n    \
    \             |   CellList     = []                   |\n                 |-------------------------------------->|\n\
    \                 |                                L2 ACK |\n      6P Timeout\
    \ |<- - - - - - - - - - - - - - - - - - - |\n            |    |              \
    \                         |\n            |    | 6P Response                  \
    \         |\n            |    |   Type         = RESPONSE             |\n    \
    \        |    |   Code         = RC_SUCCESS           |\n            |    |  \
    \ SeqNum       = 178                  |         cells\n            |    |   CellList\
    \     = [(1,2),(2,2),(3,5)]  |        locked\n            X    |<--------------------------------------|\
    \          --+\n                 | L2 ACK                                |   \
    \         |\n                 | - - - - - - - - - - - - - - - - - - ->| 6P Timeout\
    \ |\n                 |                                       |    |       |\n\
    \                 | 6P Confirmation                       |    |       |\n   \
    \              |   Type         = CONFIRMATION         |    |       |\n      \
    \           |   Code         = RC_SUCCESS           |    |       |\n    cells\
    \        |   SeqNum       = 178                  |    |       |\n    locked  \
    \     |   CellList     = [(2,2),(3,5)]        |    |       |\n     +--       \
    \  |-------------------------------------->|    X    <--+\n     |           |\
    \                                L2 ACK |\n     +->         |<- - - - - - - -\
    \ - - - - - - - - - - - |\n                 |                                \
    \       |\n                Figure 5: An Example 3-Step 6P Transaction\n   In this\
    \ example, the 3-step transaction occurs as follows:\n   1.  The SF running on\
    \ node A determines that two extra cells need to\n       be scheduled to node\
    \ B.  The SF uses a 3-step transaction, so it\n       does not select candidate\
    \ cells.\n   2.  Node A sends a 6P ADD Request to node B, indicating that it\n\
    \       wishes to add two cells (the \"NumCells\" value), with an empty\n    \
    \   \"CellList\".  This 6P ADD Request is link-layer acknowledged by\n       node\
    \ B.\n   3.  After having successfully sent the 6P ADD Request, node A starts\n\
    \       a 6P Timeout to abort the transaction in the event that no 6P\n      \
    \ Response is received from node B.\n   4.  The SF running on node B selects three\
    \ candidate cells and locks\n       them.  Node B sends back a 6P Response to\
    \ node A, indicating the\n       three cells it has selected.  The response is\
    \ link-layer\n       acknowledged by node A.\n   5.  After having successfully\
    \ sent the 6P Response, node B starts a\n       6P Timeout to abort the transaction\
    \ in the event that no 6P\n       Confirmation is received from node A.\n   6.\
    \  The SF running on node A selects two cells from the CellList\n       field\
    \ in the 6P Response and locks them.  Node A sends back a 6P\n       Confirmation\
    \ to node B, indicating the cells it selected.  The\n       confirmation is link-layer\
    \ acknowledged by node B.\n   7.  Upon completion of the 6P Transaction, two cells\
    \ from node A to\n       node B have been added to the TSCH schedule of both nodes\
    \ A\n       and B.\n   8.  An inconsistency in the schedule can happen if the\
    \ 6P Timeout\n       expires when the 6P Confirmation is in the air, if the last\n\
    \       link-layer ACK for the 6P Confirmation is lost, or if one of the\n   \
    \    nodes is power-cycled during the transaction.  6P provides an\n       inconsistency\
    \ detection mechanism to cope with such situations;\n       see Section 3.4.6.2\
    \ for details.\n"
- title: 3.2.  Message Format
  contents:
  - '3.2.  Message Format

    '
- title: 3.2.1.  6top Information Element (IE)
  contents:
  - "3.2.1.  6top Information Element (IE)\n   6P messages travel over a single hop.\
    \  6P messages are carried as\n   payload of an 802.15.4 Payload Information Element\
    \ (IE) [IEEE802154].\n   The messages are encapsulated within the Payload IE header.\
    \  The\n   Group ID is set to the IETF IE value defined in [RFC8137].  The\n \
    \  content is encapsulated by a subtype ID, as defined in [RFC8137].\n   Since\
    \ 6P messages are carried in IEs, IEEE bit/byte ordering applies.\n   Bits within\
    \ each field in the \"6top IE\" subtype are numbered from 0\n   (leftmost and\
    \ least significant) to k-1 (rightmost and most\n   significant), where the length\
    \ of the field is k bits.  Fields that\n   are longer than a single octet are\
    \ copied to the packet in the order\n   from the octet containing the lowest-numbered\
    \ bits to the octet\n   containing the highest-numbered bits (little endian).\n\
    \   This document defines the 6top IE, a subtype of the IETF IE defined\n   in\
    \ [RFC8137], with subtype SUBID_6TOP.  The subtype content of the\n   6top IE\
    \ is defined in Section 3.2.2.  The length of the 6top IE\n   content is variable.\n"
- title: 3.2.2.  Generic 6P Message Format
  contents:
  - "3.2.2.  Generic 6P Message Format\n   All 6P messages follow the generic format\
    \ shown in Figure 6.\n                          1                   2        \
    \           3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |Version| T | R |     Code      |     SFID      |     SeqNum    |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     | Other\
    \ Fields...\n     +-+-+-+-+-+-+-+-+-\n                    Figure 6: Generic 6P\
    \ Message Format\n   6P Version (Version):  The version of 6P.  Only version 0\
    \ is defined\n         in this document.  Future specifications may define subsequent\n\
    \         versions of 6P.\n   Type (T):  The type of message.  The message types\
    \ are defined in\n         Section 6.2.2.\n   Reserved (R):  Reserved bits.  These\
    \ two bits SHOULD be set to zero\n         when sending the message and MUST be\
    \ ignored upon reception.\n   Code:  The Code field contains a 6P command identifier\
    \ when the 6P\n         message has a Type value of REQUEST.  Section 6.2.3 lists\
    \ the\n         6P command identifiers.  The Code field contains a 6P return\n\
    \         code when the 6P message has a Type value of RESPONSE or\n         CONFIRMATION.\
    \  Section 6.2.4 lists the 6P return codes.  The\n         same return codes are\
    \ used in both 6P Response and 6P\n         Confirmation messages.\n   6top Scheduling\
    \ Function Identifier (SFID):  The identifier of the SF\n         to use to handle\
    \ this message.  The SFID is defined in\n         Section 4.1.\n   SeqNum:  The\
    \ sequence number associated with the 6P Transaction.\n         Used to match\
    \ the 6P Request, 6P Response, and 6P Confirmation\n         of the same 6P Transaction.\
    \  The value of SeqNum MUST be\n         different for each new 6P Request issued\
    \ to the same neighbor\n         and using the same SF.  The SeqNum is also used\
    \ to ensure\n         consistency between the schedules of the two neighbors.\n\
    \         Section 3.4.6 details how the SeqNum is managed.\n   Other Fields: \
    \ The list of other fields and how they are used are\n         detailed in Section\
    \ 3.3.\n   6P Request, 6P Response, and 6P Confirmation messages for a given\n\
    \   transaction MUST share the same Version, SFID, and SeqNum values.\n   Future\
    \ versions of the 6P message SHOULD maintain the format of the\n   6P Version,\
    \ Type, and Code fields for backward compatibility.\n"
- title: 3.2.3.  6P CellOptions
  contents:
  - "3.2.3.  6P CellOptions\n   An 8-bit 6P CellOptions bitmap is present in the following\
    \ 6P\n   Requests: ADD, DELETE, COUNT, LIST, and RELOCATE.  The format and\n \
    \  meaning of this field MAY be redefined by the SF; the routine that\n   parses\
    \ this field is therefore associated with a specific SF.\n   o  In the 6P ADD\
    \ Request, the 6P CellOptions bitmap is used to\n      specify what type of cell\
    \ to add.\n   o  In the 6P DELETE Request, the 6P CellOptions bitmap is used to\n\
    \      specify what type of cell to delete.\n   o  In the 6P RELOCATE Request,\
    \ the 6P CellOptions bitmap is used to\n      specify what type of cell to relocate.\n\
    \   o  In the 6P COUNT and LIST Requests, the 6P CellOptions bitmap is\n     \
    \ used as a selector of a particular type of cells.\n   The content of the 6P\
    \ CellOptions bitmap applies to all elements in\n   the CellList field.  The possible\
    \ values of the 6P CellOptions are as\n   follows:\n   o  TX = 1 (resp. 0) refers\
    \ to macTxType = TRUE (resp. FALSE) in the\n      macLinkTable of 802.15.4 [IEEE802154].\n\
    \   o  RX = 1 (resp. 0) refers to macRxType = TRUE (resp. FALSE) in the\n    \
    \  macLinkTable of 802.15.4.\n   o  S = 1 (resp. 0) refers to macSharedType =\
    \ TRUE (resp. FALSE) in\n      the macLinkTable of 802.15.4.\n   Section 6.2.6\
    \ provides the format of the 6P CellOptions bitmap; this\n   format applies unless\
    \ redefined by the SF.  Figure 7 shows the\n   meaning of the 6P CellOptions bitmap\
    \ for the 6P ADD, DELETE, and\n   RELOCATE Requests (unless redefined by the SF).\
    \  Figure 8 shows the\n   meaning of the 6P CellOptions bitmap for the 6P COUNT\
    \ and LIST\n   Requests (unless redefined by the SF).\n    Note: Here, we assume\
    \ that node A issues the 6P command to node B.\n   +-------------+-----------------------------------------------------+\n\
    \   | CellOptions | The type of cells B adds/deletes/relocates to its   |\n  \
    \ | Value       | schedule when receiving a 6P ADD/DELETE/RELOCATE    |\n   |\
    \             | Request from A                                      |\n   +-------------+-----------------------------------------------------+\n\
    \   |TX=0,RX=0,S=0| Invalid combination.  RC_ERR is returned            |\n  \
    \ +-------------+-----------------------------------------------------+\n   |TX=1,RX=0,S=0|\
    \ Add/delete/relocate RX cells at B (TX cells at A)   |\n   +-------------+-----------------------------------------------------+\n\
    \   |TX=0,RX=1,S=0| Add/delete/relocate TX cells at B (RX cells at A)   |\n  \
    \ +-------------+-----------------------------------------------------+\n   |TX=1,RX=1,S=0|\
    \ Add/delete/relocate TX|RX cells at B (and at A)     |\n   +-------------+-----------------------------------------------------+\n\
    \   |TX=0,RX=0,S=1| Invalid combination.  RC_ERR is returned            |\n  \
    \ +-------------+-----------------------------------------------------+\n   |TX=1,RX=0,S=1|\
    \ Add/delete/relocate RX|SHARED cells at B            |\n   |             | (TX|SHARED\
    \ cells at A)                              |\n   +-------------+-----------------------------------------------------+\n\
    \   |TX=0,RX=1,S=1| Add/delete/relocate TX|SHARED cells at B            |\n  \
    \ |             | (RX|SHARED cells at A)                              |\n   +-------------+-----------------------------------------------------+\n\
    \   |TX=1,RX=1,S=1| Add/delete/relocate TX|RX|SHARED cells at B         |\n  \
    \ |             | (and at A)                                          |\n   +-------------+-----------------------------------------------------+\n\
    \          Figure 7: Meaning of the 6P CellOptions Bitmap for the\n          \
    \         6P ADD, DELETE, and RELOCATE Requests\n    Note: Here, we assume that\
    \ node A issues the 6P command to node B.\n   +-------------+-----------------------------------------------------+\n\
    \   | CellOptions | The type of cells B selects from its schedule when  |\n  \
    \ | Value       | receiving a 6P COUNT or LIST Request from A,        |\n   |\
    \             | from all the cells B has scheduled with A           |\n   +-------------+-----------------------------------------------------+\n\
    \   |TX=0,RX=0,S=0| All cells                                           |\n  \
    \ +-------------+-----------------------------------------------------+\n   |TX=1,RX=0,S=0|\
    \ All cells marked as RX only                         |\n   +-------------+-----------------------------------------------------+\n\
    \   |TX=0,RX=1,S=0| All cells marked as TX only                         |\n  \
    \ +-------------+-----------------------------------------------------+\n   |TX=1,RX=1,S=0|\
    \ All cells marked as TX and RX only                  |\n   +-------------+-----------------------------------------------------+\n\
    \   |TX=0,RX=0,S=1| All cells marked as SHARED (regardless of TX, RX)   |\n  \
    \ +-------------+-----------------------------------------------------+\n   |TX=1,RX=0,S=1|\
    \ All cells marked as RX and SHARED only              |\n   +-------------+-----------------------------------------------------+\n\
    \   |TX=0,RX=1,S=1| All cells marked as TX and SHARED only              |\n  \
    \ +-------------+-----------------------------------------------------+\n   |TX=1,RX=1,S=1|\
    \ All cells marked as TX, RX, and SHARED              |\n   +-------------+-----------------------------------------------------+\n\
    \          Figure 8: Meaning of the 6P CellOptions Bitmap for the\n          \
    \              6P COUNT and LIST Requests\n   The CellOptions constitute an opaque\
    \ set of bits, sent unmodified to\n   the SF.  The SF MAY redefine the format\
    \ and meaning of the\n   CellOptions field.\n"
- title: 3.2.4.  6P CellList
  contents:
  - "3.2.4.  6P CellList\n   A CellList field MAY be present in a 6P ADD Request,\
    \ a 6P DELETE\n   Request, a 6P RELOCATE Request, a 6P Response, or a 6P Confirmation.\n\
    \   It is composed of a concatenation of zero or more 6P Cells as defined\n  \
    \ in Figure 9.  The content of the CellOptions field specifies the\n   options\
    \ associated with all cells in the CellList.  This necessarily\n   means that\
    \ the same options are associated with all cells in the\n   CellList.\n   A 6P\
    \ Cell is a 4-byte field; its default format is:\n                          1\
    \                   2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |          slotOffset           |         channelOffset         |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \                 Figure 9: 6P Cell Format\n      slotOffset: The slot offset\
    \ of the cell.\n      channelOffset: The channel offset of the cell.\n   The CellList\
    \ is an opaque set of bytes, sent unmodified to the SF.\n   The length of the\
    \ CellList field is implicit and is determined by the\n   IE Length field of the\
    \ Payload IE header as defined in 802.15.4.  The\n   SF MAY redefine the format\
    \ of the CellList field; the routine that\n   parses this field is therefore associated\
    \ with a specific SF.\n"
- title: 3.3.  6P Commands and Operations
  contents:
  - '3.3.  6P Commands and Operations

    '
- title: 3.3.1.  Adding Cells
  contents:
  - "3.3.1.  Adding Cells\n   Cells are added by using the 6P ADD command.  The Type\
    \ field (T) is\n   set to REQUEST.  The Code field is set to ADD.  Figure 10 defines\
    \ the\n   format of a 6P ADD Request.\n                          1           \
    \        2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |Version| T | R |     Code      |     SFID      |     SeqNum    |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \         Metadata            |  CellOptions  |   NumCells    |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     | CellList ...\n     +-+-+-+-+-+-+-+-+-\n                     Figure 10:\
    \ 6P ADD Request Format\n   Metadata:  Used as extra signaling to the SF.  The\
    \ contents of the\n         Metadata field are an opaque set of bytes passed unmodified\
    \ to\n         the SF.  The meaning of this field depends on the SF and is out\n\
    \         of scope for this document.  For example, Metadata can specify\n   \
    \      in which slotframe to add the cells.\n   CellOptions:  Indicates the options\
    \ to associate with the cells to be\n         added.  If more than one cell is\
    \ added (NumCells > 1), the same\n         options are associated with each one.\
    \  This necessarily means\n         that if node A needs to add multiple cells\
    \ with different\n         options it needs to initiate multiple 6P ADD Transactions.\n\
    \   NumCells:  The number of additional cells node A wants to schedule to\n  \
    \       node B.\n   CellList:  A list of zero or multiple candidate cells.  Its\
    \ length is\n         implicit and is determined by the Length field of the Payload\n\
    \         IE header.\n   Figure 11 defines the format of a 6P ADD Response and\
    \ Confirmation.\n                          1                   2             \
    \      3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |Version| T | R |     Code      |     SFID      |     SeqNum    |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     | CellList\
    \ ...\n     +-+-+-+-+-+-+-+-+-\n            Figure 11: 6P ADD Response and Confirmation\
    \ Format\n   CellList:  A list of zero or more 6P Cells.\n   Consider the topology\
    \ in Figure 1; in this case, the SF on node A\n   decides to add NumCells cells\
    \ to node B.\n   Node A's SF selects NumCandidate cells from its schedule.  These\
    \ are\n   cells that are candidates to be scheduled with node B.  The\n   CellOptions\
    \ field specifies the type of these cells.  NumCandidate\n   MUST be greater than\
    \ or equal to NumCells.  How many cells node A\n   selects (NumCandidate) and\
    \ how that selection is done are specified\n   in the SF and are out of scope\
    \ for this document.  Node A sends a 6P\n   ADD Request to node B that contains\
    \ the CellOptions, the value of\n   NumCells, and a selection of NumCandidate\
    \ cells in the CellList.  If\n   the NumCandidate cells do not fit in a single\
    \ packet, this operation\n   MUST be split into multiple independent 6P ADD Requests,\
    \ each for a\n   subset of the number of cells that eventually need to be added.\
    \  In\n   the case of a 3-step transaction, the SF is responsible for ensuring\n\
    \   that the returned Candidate CellList fits into the 6P Response.\n   Upon receiving\
    \ the request, node B checks to see whether the\n   CellOptions are set to a valid\
    \ value as noted by Figure 7.  If this\n   is not the case, a Response with code\
    \ RC_ERR is returned.  If the\n   number of cells in the received CellList in\
    \ node B is smaller than\n   NumCells, node B MUST return a 6P Response with the\
    \ RC_ERR_CELLLIST\n   code.  Otherwise, node B's SF verifies which of the cells\
    \ in the\n   CellList it can install in node B's schedule, following the specified\n\
    \   CellOptions field.  How that selection is done is specified in the SF\n  \
    \ and is out of scope for this document.  The verification can succeed\n   (NumCells\
    \ cells from the CellList can be used), fail (none of the\n   cells from the CellList\
    \ can be used), or partially succeed (fewer\n   than NumCells cells from the CellList\
    \ can be used).  In all cases,\n   node B MUST send a 6P Response that includes\
    \ a return code set to\n   RC_SUCCESS and that specifies the list of cells that\
    \ were scheduled\n   following the CellOptions field.  That list can contain NumCells\n\
    \   elements (succeed), 0 elements (fail), or between 0 and NumCells\n   elements\
    \ (partially succeed).\n   Upon receiving the response, node A adds the cells\
    \ specified in the\n   CellList according to the CellOptions field.\n"
- title: 3.3.2.  Deleting Cells
  contents:
  - "3.3.2.  Deleting Cells\n   Cells are deleted by using the 6P DELETE command.\
    \  The Type field (T)\n   is set to REQUEST.  The Code field is set to DELETE.\
    \  Figure 12\n   defines the format of a 6P DELETE Request.\n                \
    \          1                   2                   3\n      0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |Version| T | R |     Code      |     SFID      |    SeqNum     |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \         Metadata            |  CellOptions  |   NumCells    |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     | CellList ...\n     +-+-+-+-+-+-+-+-+-\n                    Figure 12:\
    \ 6P DELETE Request Format\n   Metadata:  Same usage as for the 6P ADD command;\
    \ see Section 3.3.1.\n         Its format is the same as that in the 6P ADD command,\
    \ but its\n         content could be different.\n   CellOptions:  Indicates the\
    \ options that need to be associated with\n         the cells to delete.  Only\
    \ cells matching the CellOptions can\n         be deleted.\n   NumCells:  The\
    \ number of cells from the specified CellList the sender\n         wants to delete\
    \ from the schedule of both sender and receiver.\n   CellList:  A list of zero\
    \ or more 6P Cells.  Its length is determined\n         by the Length field of\
    \ the Payload IE header.\n   Figure 13 defines the format of a 6P DELETE Response\
    \ and\n   Confirmation.\n                          1                   2     \
    \              3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |Version| T | R |     Code      |     SFID      |     SeqNum    |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     | CellList\
    \ ...\n     +-+-+-+-+-+-+-+-+-\n           Figure 13: 6P DELETE Response and Confirmation\
    \ Format\n   CellList:  A list of zero or more 6P Cells.\n   The behavior for\
    \ deleting cells is equivalent to that of adding cells\n   except that:\n   o\
    \  The nodes delete the cells they agree upon rather than adding\n      them.\n\
    \   o  All cells in the CellList MUST already be scheduled between the\n     \
    \ two nodes and MUST match the CellOptions field.  If node A puts\n      cells\
    \ in its CellList that are not already scheduled between the\n      two nodes\
    \ and match the CellOptions field, node B MUST reply with\n      a RC_ERR_CELLLIST\
    \ return code.\n   o  The CellList in a 6P Request (2-step transaction) or 6P\
    \ Response\n      (3-step transaction) MUST be empty, contain exactly NumCells\n\
    \      cells, or contain more than NumCells cells.  The case where the\n     \
    \ CellList is not empty but contains fewer than NumCells cells is\n      not supported;\
    \ the RC_ERR_CELLLIST code MUST be returned when the\n      CellList contains\
    \ fewer than NumCells cells.  If the CellList is\n      empty, the SF on the receiving\
    \ node MUST choose NumCells cells\n      scheduled to the sender matching the\
    \ CellOptions field and delete\n      them.  If the CellList contains more than\
    \ NumCells cells, the SF\n      on the receiving node chooses exactly NumCells\
    \ cells from the\n      CellList to delete.\n"
- title: 3.3.3.  Relocating Cells
  contents:
  - "3.3.3.  Relocating Cells\n   Cell relocation consists of moving a cell to a different\n\
    \   [slotOffset,channelOffset] location in the schedule.  The Type field\n   (T)\
    \ is set to REQUEST.  The Code field is set to RELOCATE.  Figure 14\n   defines\
    \ the format of a 6P RELOCATE Request.\n                          1          \
    \         2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |Version| T | R |     Code      |     SFID      |     SeqNum    |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \         Metadata            |  CellOptions  |   NumCells    |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     | Relocation CellList          ...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n\
    \     | Candidate CellList           ...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n\
    \                   Figure 14: 6P RELOCATE Request Format\n   Metadata:  Same\
    \ usage as for the 6P ADD command; see Section 3.3.1.\n   CellOptions:  Indicates\
    \ the options that need to be associated with\n         cells to be relocated.\n\
    \   NumCells:  The number of cells to relocate.  MUST be greater than or\n   \
    \      equal to 1.\n   Relocation CellList:  The list of NumCells 6P Cells to\
    \ relocate.\n   Candidate CellList:  A list of NumCandidate candidate cells for\n\
    \         node B to pick from.  NumCandidate MUST be 0, equal to\n         NumCells,\
    \ or greater than NumCells.  Its length is determined\n         by the Length\
    \ field of the Payload IE header.\n   In a 2-step 6P RELOCATE Transaction, node\
    \ A specifies both (1) the\n   cells it needs to relocate and (2) the list of\
    \ candidate cells to\n   relocate to.  The Relocation CellList MUST contain exactly\
    \ NumCells\n   entries.  The Candidate CellList MUST contain at least NumCells\n\
    \   entries (NumCandidate >= NumCells).\n   In a 3-step 6P RELOCATE Transaction,\
    \ node A specifies only the cells\n   it needs to relocate -- not the list of\
    \ candidate cells to relocate\n   to.  The Candidate CellList MUST therefore be\
    \ empty.\n   Figure 15 defines the format of a 6P RELOCATE Response and\n   Confirmation.\n\
    \                          1                   2                   3\n      0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |Version| T | R |     Code      |     SFID      |     SeqNum    |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     | CellList\
    \ ...\n     +-+-+-+-+-+-+-+-+-\n          Figure 15: 6P RELOCATE Response and\
    \ Confirmation Format\n   CellList:  A list of zero or more 6P Cells.\n   Node\
    \ A's SF wants to relocate NumCells cells.  Node A creates a 6P\n   RELOCATE Request\
    \ and indicates the cells it wants to relocate in the\n   Relocation CellList.\
    \  It also selects NumCandidate cells from its\n   schedule as candidate cells\
    \ to relocate the cells to, and it puts\n   them in the Candidate CellList.  The\
    \ CellOptions field specifies the\n   type of the cell(s) to relocate.  NumCandidate\
    \ MUST be greater than\n   or equal to NumCells.  How many cells it selects (NumCandidate)\
    \ and\n   how that selection is done are specified in the SF and are out of\n\
    \   scope for this document.  Node A sends the 6P RELOCATE Request to\n   node\
    \ B.\n   Upon receiving the request, node B checks to see if the length of the\n\
    \   Candidate CellList is greater than or equal to NumCells.  Node B's SF\n  \
    \ verifies that all the cells in the Relocation CellList are scheduled\n   with\
    \ node A and are associated with the options specified in the\n   CellOptions\
    \ field.  If either check fails, node B MUST send a 6P\n   Response to node A\
    \ with return code RC_ERR_CELLLIST.  If both checks\n   pass, node B's SF verifies\
    \ which of the cells in the Candidate\n   CellList it can install in its schedule.\
    \  How that selection is done\n   is specified in the SF and is out of scope for\
    \ this document.  That\n   verification for the Candidate CellList can succeed\
    \ (NumCells cells\n   from the Candidate CellList can be used), fail (none of\
    \ the cells\n   from the Candidate CellList can be used), or partially succeed\
    \ (fewer\n   than NumCells cells from the Candidate CellList can be used).  In\
    \ all\n   cases, node B MUST send a 6P Response that includes a return code set\n\
    \   to RC_SUCCESS and that specifies the list of cells that will be\n   rescheduled\
    \ following the CellOptions field.  That list can contain\n   NumCells elements\
    \ (succeed), 0 elements (fail), or between 0 and\n   NumCells elements (partially\
    \ succeed).  If N < NumCells cells appear\n   in the CellList, this means that\
    \ the first N cells in the Relocation\n   CellList have been relocated and the\
    \ remainder have not.\n   Upon receiving the response with code RC_SUCCESS, node\
    \ A relocates\n   the cells specified in the Relocation CellList of its RELOCATE\n\
    \   Request to the new locations specified in the CellList of the 6P\n   Response,\
    \ in the same order.  If the received return code is\n   RC_ERR_CELLLIST, the\
    \ transaction is aborted and no cell is relocated.\n   In the case of a 2-step\
    \ transaction, node B relocates the selected\n   cells upon receiving the link-layer\
    \ ACK for the 6P Response.  In the\n   case of a 3-step transaction, node B relocates\
    \ the selected cells\n   upon receiving the 6P Confirmation.\n   The SF SHOULD\
    \ NOT relocate all cells between two nodes at the same\n   time, as this might\
    \ result in the schedules of both nodes diverging\n   significantly.\n   Figure\
    \ 16 shows an example of a successful 2-step 6P RELOCATE\n   Transaction.\n  \
    \          +----------+                           +----------+\n            |\
    \  Node A  |                           |  Node B  |\n            +----+-----+\
    \                           +-----+----+\n                 |                 \
    \                      |\n                 | 6P RELOCATE Request             \
    \      |\n                 |   Type         = REQUEST              |\n       \
    \          |   Code         = RELOCATE             |\n                 |   SeqNum\
    \       = 11                   |\n                 |   NumCells     = 2      \
    \              |\n                 |   R.CellList   = [(1,2),(2,2)]        |\n\
    \                 |   C.CellList   = [(3,3),(4,3),(5,3)]  |\n                \
    \ |-------------------------------------->| B prepares\n                 |   \
    \                             L2 ACK | to relocate\n                 |<- - - -\
    \ - - - - - - - - - - - - - - - | (1,2)->(5,3)\n                 |           \
    \                            | and\n                 |                       \
    \                | (2,2)->(3,3)\n                 | 6P Response              \
    \             |\n                 |   Code         = RC_SUCCESS           |\n\
    \                 |   SeqNum       = 11                   |\n                \
    \ |   CellList     = [(5,3),(3,3)]        |\n     A relocates |<--------------------------------------|\n\
    \    (1,2)->(5,3) | L2 ACK                                |\n             and\
    \ | - - - - - - - - - - - - - - - - - - ->| B relocates\n    (2,2)->(3,3) |  \
    \                                     | (1,2)->(5,3)\n                 |     \
    \                                  | and\n                 |                 \
    \                      | (2,2)->(3,3)\n     Figure 16: Example of a Successful\
    \ 2-Step 6P RELOCATE Transaction\n   Figure 17 shows an example of a partially\
    \ successful 2-step 6P\n   RELOCATE Transaction.\n           +----------+    \
    \                       +----------+\n           |  Node A  |                \
    \           |  Node B  |\n           +----+-----+                           +-----+----+\n\
    \                |                                       |\n                |\
    \ 6P RELOCATE Request                   |\n                |   Type         =\
    \ REQUEST              |\n                |   Code         = RELOCATE        \
    \     |\n                |   SeqNum       = 199                  |\n         \
    \       |   NumCells     = 2                    |\n                |   R.CellList\
    \   = [(1,2),(2,2)]        |\n                |   C.CellList   = [(3,3),(4,3),(5,3)]\
    \  | B prepares\n                |-------------------------------------->| to\
    \ relocate\n                |                                L2 ACK | (1,2)->(4,3)\n\
    \                |<- - - - - - - - - - - - - - - - - - - | but cannot\n      \
    \          |                                       | relocate (2,2)\n        \
    \        | 6P Response                           |\n                |   Type \
    \        = RESPONSE             |\n                |   Code         = RC_SUCCESS\
    \           |\n                |   SeqNum       = 199                  |\n   \
    \             |   CellList     = [(4,3)]              |\n    A relocates |<--------------------------------------|\n\
    \   (1,2)->(4,3) | L2 ACK                                |\n                |\
    \ - - - - - - - - - - - - - - - - - - ->| B relocates\n                |     \
    \                                  | (1,2)->(4,3)\n                |         \
    \                              |\n                |                          \
    \             |\n          Figure 17: Example of a Partially Successful 2-Step\
    \ 6P\n                           RELOCATE Transaction\n   Figure 18 shows an example\
    \ of a failed 2-step 6P RELOCATE\n   Transaction.\n           +----------+   \
    \                        +----------+\n           |  Node A  |               \
    \            |  Node B  |\n           +----+-----+                           +-----+----+\n\
    \                |                                       |\n                |\
    \ 6P RELOCATE Request                   |\n                |   Type         =\
    \ REQUEST              |\n                |   Code         = RELOCATE        \
    \     |\n                |   SeqNum       = 53                   |\n         \
    \       |   NumCells     = 2                    |\n                |   R.CellList\
    \   = [(1,2),(2,2)]        |\n                |   C.CellList   = [(3,3),(4,3),(5,3)]\
    \  |\n                |-------------------------------------->| B cannot\n   \
    \             |                                L2 ACK | relocate\n           \
    \     |<- - - - - - - - - - - - - - - - - - - | (1,2)\n                |     \
    \                                  | or (2,2)\n                | 6P Response \
    \                          |\n                |   Type         = RESPONSE    \
    \         |\n                |   Code         = RC_SUCCESS           |\n     \
    \           |   SeqNum       = 53                   |\n                |   CellList\
    \     = []                   |\n                |<--------------------------------------|\
    \ B does not\n                | L2 ACK                                | relocate\n\
    \     A does not | - - - - - - - - - - - - - - - - - - ->|\n       relocate |\
    \                                       |\n                |                 \
    \                      |\n         Figure 18: Failed 2-Step 6P RELOCATE Transaction\
    \ Example\n   Figure 19 shows an example of a successful 3-step 6P RELOCATE\n\
    \   Transaction.\n           +----------+                           +----------+\n\
    \           |  Node A  |                           |  Node B  |\n           +----+-----+\
    \                           +-----+----+\n                |                  \
    \                     |\n                | 6P RELOCATE Request               \
    \    |\n                |   Type         = REQUEST              |\n          \
    \      |   Code         = RELOCATE             |\n                |   SeqNum \
    \      = 11                   |\n                |   NumCells     = 2        \
    \            |\n                |   R.CellList   = [(1,2),(2,2)]        |\n  \
    \              |   C.CellList   = []                   |\n                |-------------------------------------->|\n\
    \                |                                L2 ACK |\n                |<-\
    \ - - - - - - - - - - - - - - - - - - | B identifies\n                |      \
    \                                 | candidate\n                |             \
    \                          | cells\n                | 6P Response            \
    \               | (3,3),\n                |   Code         = RC_SUCCESS      \
    \     | (4,3), and\n                |   SeqNum       = 11                   |\
    \ (5,3)\n                |   CellList     = [(3,3),(4,3),(5,3)]  |\n     A prepares\
    \ |<--------------------------------------|\n    to relocate | L2 ACK        \
    \                        |\n   (1,2)->(5,3) | - - - - - - - - - - - - - - - -\
    \ - - ->|\n            and |                                       |\n   (2,2)->(3,3)\
    \ | 6P Confirmation                       |\n                |   Code        \
    \ = RC_SUCCESS           |\n                |   SeqNum       = 11            \
    \       |\n                |   CellList     = [(5,3),(3,3)]        |\n       \
    \         |-------------------------------------->| B relocates\n            \
    \    |                                L2 ACK | (1,2)->(5,3)\n    A relocates |<-\
    \ - - - - - - - - - - - - - - - - - - | and\n   (1,2)->(5,3) |               \
    \                        | (2,2)->(3,3)\n            and |                   \
    \                    |\n   (2,2)->(3,3) |                                    \
    \   |\n                |                                       |\n     Figure\
    \ 19: Example of a Successful 3-Step 6P RELOCATE Transaction\n"
- title: 3.3.4.  Counting Cells
  contents:
  - "3.3.4.  Counting Cells\n   To retrieve the number of scheduled cells node A has\
    \ with B, node A\n   issues a 6P COUNT command.  The Type field (T) is set to\
    \ REQUEST.\n   The Code field is set to COUNT.  Figure 20 defines the format of\
    \ a 6P\n   COUNT Request.\n                          1                   2   \
    \                3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |Version| T | R |     Code      |     SFID      |     SeqNum    |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \         Metadata            |  CellOptions  |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    Figure 20: 6P COUNT Request Format\n   Metadata:  Same usage\
    \ as for the 6P ADD command; see Section 3.3.1.\n         Its format is the same\
    \ as that in the 6P ADD command, but its\n         content could be different.\n\
    \   CellOptions:  Specifies which type of cell to be counted.\n   Figure 21 defines\
    \ the format of a 6P COUNT Response.\n                          1            \
    \       2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |Version| T | R |     Code      |     SFID      |     SeqNum    |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \         NumCells            |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \                Figure 21: 6P COUNT Response Format\n   NumCells:  The number\
    \ of cells that correspond to the fields of the\n         request.\n   Node A\
    \ issues a COUNT command to node B, specifying some cell\n   options.  Upon receiving\
    \ the 6P COUNT Request, node B goes through\n   its schedule and counts the number\
    \ of cells scheduled with node A in\n   its own schedule that match the cell options\
    \ in the CellOptions field\n   of the request.  Section 3.2.3 details the use\
    \ of the CellOptions\n   field.\n   Node B issues a 6P Response to node A with\
    \ return code RC_SUCCESS and\n   with NumCells containing the number of cells\
    \ that match the request.\n"
- title: 3.3.5.  Listing Cells
  contents:
  - "3.3.5.  Listing Cells\n   To retrieve a list of scheduled cells node A has with\
    \ node B, node A\n   issues a 6P LIST command.  The Type field (T) is set to REQUEST.\
    \  The\n   Code field is set to LIST.  Figure 22 defines the format of a 6P LIST\n\
    \   Request.\n                          1                   2                \
    \   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \ |Version| T | R |     Code      |     SFID      |     SeqNum    |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |           Metadata            |  CellOptions  |   Reserved    |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \         Offset              |          MaxNumCells          |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                     Figure 22: 6P LIST Request Format\n   Metadata:  Same usage\
    \ as for the 6P ADD command; see Section 3.3.1.\n         Its format is the same\
    \ as that in the 6P ADD command, but its\n         content could be different.\n\
    \   CellOptions:  Specifies which type of cell to be listed.\n   Reserved:  Reserved\
    \ bits.  These bits SHOULD be set to zero when\n         sending the message and\
    \ MUST be ignored upon reception.\n   Offset:  The offset of the first scheduled\
    \ cell that is requested.\n         The mechanism assumes that cells are ordered\
    \ according to a\n         rule defined in the SF.  The rule MUST always order\
    \ the cells\n         in the same way.\n   MaxNumCells:  The maximum number of\
    \ cells to be listed.  Node B MAY\n         return fewer than MaxNumCells cells\
    \ -- for example, if\n         MaxNumCells cells do not fit in the frame.\n  \
    \ Figure 23 defines the format of a 6P LIST Response.\n                      \
    \    1                   2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |Version| T | R |     Code      |     SFID      |     SeqNum    |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     | CellList\
    \ ...\n     +-+-+-+-+-+-+-+-+-\n                    Figure 23: 6P LIST Response\
    \ Format\n   CellList:  A list of zero or more 6P Cells.\n   When receiving a\
    \ LIST command, node B returns the cells scheduled\n   with A in its schedule\
    \ that match the CellOptions field as specified\n   in Section 3.2.3.\n   When\
    \ node B receives a LIST Request, the returned CellList in the 6P\n   Response\
    \ contains between 0 and MaxNumCells cells, starting from the\n   specified offset.\
    \  Node B SHOULD include as many cells as will fit in\n   the frame.  If the response\
    \ contains the last cell, node B MUST set\n   the Code field in the response to\
    \ RC_EOL (\"End of List\", as per\n   Figure 38 in Section 6.2.4), indicating\
    \ to node A that there are no\n   more cells that match the request.  Node B MUST\
    \ return at least one\n   cell, unless the specified offset is beyond the end\
    \ of B's cell list\n   in its schedule.  If node B has fewer than Offset cells\
    \ that match\n   the request, node B returns an empty CellList and a Code field\
    \ set\n   to RC_EOL.\n"
- title: 3.3.6.  Clearing the Schedule
  contents:
  - "3.3.6.  Clearing the Schedule\n   To clear the schedule between nodes A and B\
    \ (for example, after a\n   schedule inconsistency is detected), node A issues\
    \ a CLEAR command.\n   The Type field (T) is set to REQUEST.  The Code field is\
    \ set to\n   CLEAR.  Figure 24 defines the format of a 6P CLEAR Request.\n   \
    \                       1                   2                   3\n      0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |Version| T | R |     Code      |     SFID      |     SeqNum    |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \         Metadata            |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \                Figure 24: 6P CLEAR Request Format\n   Metadata:  Same usage\
    \ as for the 6P ADD command; see Section 3.3.1.\n         Its format is the same\
    \ as that in the 6P ADD command, but its\n         content could be different.\n\
    \   Figure 25 defines the format of a 6P CLEAR Response.\n                   \
    \       1                   2                   3\n      0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |Version| T | R |     Code      |     SFID      |     SeqNum    |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        \
    \            Figure 25: 6P CLEAR Response Format\n   When a 6P CLEAR command is\
    \ issued from node A to node B, both nodes A\n   and B MUST remove all the cells\
    \ scheduled between them.  That is,\n   node A MUST remove all the cells scheduled\
    \ with node B, and node B\n   MUST remove all the cells scheduled with node A.\
    \  In a 6P CLEAR\n   command, the SeqNum MUST NOT be checked.  In particular,\
    \ even if the\n   request contains a SeqNum value that would normally cause node\
    \ B to\n   detect a schedule inconsistency, the transaction MUST NOT be aborted.\n\
    \   Upon 6P CLEAR completion, the value of SeqNum MUST be reset to 0.\n   The\
    \ return code sent in response to a 6P CLEAR command SHOULD be\n   RC_SUCCESS\
    \ unless the operation cannot be executed.  When the CLEAR\n   operation cannot\
    \ be executed, the return code MUST be set to\n   RC_RESET.\n"
- title: 3.3.7.  Generic Signaling between SFs
  contents:
  - "3.3.7.  Generic Signaling between SFs\n   The 6P SIGNAL message allows the SF\
    \ implementations on two neighbor\n   nodes to exchange generic commands.  The\
    \ payload in a received SIGNAL\n   message is an opaque set of bytes passed unmodified\
    \ to the SF.  The\n   length of the payload is determined by the Length field\
    \ of the\n   Payload IE header.  How the generic SIGNAL command is used is\n \
    \  specified by the SF and is outside the scope of this document.  The\n   Type\
    \ field (T) is set to REQUEST.  The Code field is set to SIGNAL.\n   Figure 26\
    \ defines the format of a 6P SIGNAL Request.\n                          1    \
    \               2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |Version| T | R |     Code      |     SFID      |     SeqNum    |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     |  \
    \         Metadata            |  payload ...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                    Figure 26: 6P SIGNAL Request Format\n   Metadata:  Same usage\
    \ as for the 6P ADD command; see Section 3.3.1.\n         Its format is the same\
    \ as that in the 6P ADD command, but its\n         content could be different.\n\
    \   Figure 27 defines the format of a 6P SIGNAL Response.\n                  \
    \        1                   2                   3\n      0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |Version| T | R |     Code      |     SFID      |     SeqNum    |\n    \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     | payload\
    \ ...\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                   Figure 27: 6P\
    \ SIGNAL Response Format\n"
- title: 3.4.  Protocol Functional Details
  contents:
  - '3.4.  Protocol Functional Details

    '
- title: 3.4.1.  Version Checking
  contents:
  - "3.4.1.  Version Checking\n   All messages contain a Version field.  If multiple\
    \ protocol versions\n   of 6P have been defined (in future specifications for\
    \ Version values\n   different from 0), a node MAY implement multiple protocol\
    \ versions at\n   the same time.  When a node receives a 6P message with a version\n\
    \   number it does not implement, the node MUST reply with a 6P Response\n   with\
    \ a return code field set to RC_ERR_VERSION.  The format of this\n   6P Response\
    \ message MUST be compliant with version 0 and MUST be\n   supported by all future\
    \ versions of the protocol.  This ensures that\n   when node B sends a 6P Response\
    \ to node A indicating that it does not\n   implement the 6P version in the 6P\
    \ Request, node A can successfully\n   parse that response.\n   When a node supports\
    \ a version number received in a 6P Request\n   message, the Version field in\
    \ the 6P Response MUST be the same as the\n   Version field in the corresponding\
    \ 6P Request.  Similarly, in a\n   3-step transaction, the Version field in the\
    \ 6P Confirmation MUST\n   match that of the 6P Request and 6P Response of the\
    \ same transaction.\n"
- title: 3.4.2.  SFID Checking
  contents:
  - "3.4.2.  SFID Checking\n   All messages contain an SFID field.  A node MAY support\
    \ multiple SFs\n   at the same time.  When receiving a 6P message with an unsupported\n\
    \   SFID, a node MUST reply with a 6P Response with a return code of\n   RC_ERR_SFID.\
    \  The SFID field in the 6P Response MUST be the same as\n   the SFID field in\
    \ the corresponding 6P Request.  In a 3-step\n   transaction, the SFID field in\
    \ the 6P Confirmation MUST match that of\n   the 6P Request and the 6P Response\
    \ of the same transaction.\n"
- title: 3.4.3.  Concurrent 6P Transactions
  contents:
  - "3.4.3.  Concurrent 6P Transactions\n   Only a single 6P Transaction at a time\
    \ in a given direction can take\n   place between two neighbors.  That is, a node\
    \ MUST NOT issue a new 6P\n   Request to a given neighbor before the previous\
    \ 6P Transaction it\n   initiated has finished (or possibly timed out).  If a\
    \ node receives a\n   6P Request from a given neighbor before having sent the\
    \ 6P Response\n   to the previous 6P Request from that neighbor, it MUST send\
    \ back a 6P\n   Response with a return code of RC_RESET (as per Figure 38 in\n\
    \   Section 6.2.4) and discard this ongoing second transaction.  A node\n   receiving\
    \ a RC_RESET code MUST abort the second transaction and treat\n   it as though\
    \ it never happened (i.e., reverting changes to the\n   schedule or SeqNum done\
    \ by this transaction).\n   Nodes A and B MAY support having two transactions\
    \ going on at the\n   same time, one in each direction.  Similarly, a node MAY\
    \ support\n   concurrent 6P Transactions with different neighbors.  In this case,\n\
    \   the cells involved in an ongoing 6P Transaction MUST be \"locked\"\n   until\
    \ the transaction finishes.  For example, in Figure 1, node C can\n   have a different\
    \ ongoing 6P Transaction with nodes B and R.  If a\n   node does not have enough\
    \ resources to handle concurrent 6P\n   Transactions from different neighbors,\
    \ it MUST reply with a 6P\n   Response with return code RC_ERR_BUSY (as per Figure\
    \ 38 in\n   Section 6.2.4).  If the requested cells are locked, it MUST reply\
    \ to\n   that request with a 6P Response with return code RC_ERR_LOCKED (as\n\
    \   per Figure 38).  The node receiving RC_ERR_BUSY or RC_ERR_LOCKED MAY\n   implement\
    \ a retry mechanism as defined by the SF.\n"
- title: 3.4.4.  6P Timeout
  contents:
  - "3.4.4.  6P Timeout\n   A timeout occurs when the node that successfully sent\
    \ a 6P Request\n   does not receive the corresponding 6P Response within an amount\
    \ of\n   time specified by the SF.  In a 3-step transaction, a timeout also\n\
    \   occurs when a node sending the 6P Response does not receive a 6P\n   Confirmation.\
    \  When a timeout occurs, the transaction MUST be\n   canceled at the node where\
    \ the timeout occurs.  The value of the 6P\n   Timeout should be greater than\
    \ the longest possible time it takes to\n   receive the 6P Response or Confirmation.\
    \  The value of the 6P Timeout\n   hence depends on the number of cells scheduled\
    \ between the neighbor\n   nodes, the maximum number of link-layer retransmissions,\
    \ etc.  The SF\n   MUST determine the value of the timeout.  The value of the\
    \ timeout is\n   out of scope for this document.\n"
- title: 3.4.5.  Aborting a 6P Transaction
  contents:
  - "3.4.5.  Aborting a 6P Transaction\n   If the receiver of a 6P Request fails during\
    \ a 6P Transaction and is\n   unable to complete it, it SHOULD reply to that request\
    \ with a 6P\n   Response with return code RC_RESET.  Upon receiving this 6P Response,\n\
    \   the initiator of the 6P Transaction MUST consider the 6P Transaction\n   as\
    \ having failed.\n   Similarly, in the case of a 3-step transaction, when the\
    \ receiver of\n   a 6P Response fails during the 6P Transaction and is unable\
    \ to\n   complete it, it MUST reply to that 6P Response with a 6P Confirmation\n\
    \   with return code RC_RESET.  Upon receiving this 6P Confirmation, the\n   sender\
    \ of the 6P Response MUST consider the 6P Transaction as having\n   failed.\n"
- title: 3.4.6.  SeqNum Management
  contents:
  - "3.4.6.  SeqNum Management\n   The SeqNum is the field in the 6top IE header used\
    \ to match Request,\n   Response, and Confirmation messages for a given transaction.\
    \  The\n   SeqNum is used to detect and handle duplicate commands\n   (Section\
    \ 3.4.6.1) and inconsistent schedules (Section 3.4.6.2).  Each\n   node remembers\
    \ the last used SeqNum for each neighbor.  That is, a\n   node stores as many\
    \ SeqNum values as it has neighbors.  In the case\n   of supporting multiple SFs\
    \ at a time, a SeqNum value is maintained\n   per SF and per neighbor.  In the\
    \ remainder of this section, we\n   describe the use of SeqNum between two neighbors;\
    \ the same happens\n   for each other neighbor, independently.\n   When a node\
    \ resets, or after a CLEAR Transaction, it MUST reset\n   SeqNum to 0.  The 6P\
    \ Response and 6P Confirmation for a transaction\n   MUST use the same SeqNum\
    \ value as that in the request.  After every\n   transaction, the SeqNum MUST\
    \ be incremented by exactly 1.\n   Specifically, if node A receives the link-layer\
    \ acknowledgment for\n   its 6P Request, it will increment the SeqNum by exactly\
    \ 1 after the\n   6P Transaction ends.  This ensures that, for the next 6P Transaction\n\
    \   where it sends a 6P Request, the 6P Request will have a different\n   SeqNum.\n\
    \   Similarly, node B increments the SeqNum by exactly 1 after having\n   received\
    \ the link-layer acknowledgment for the 6P Response (2-step 6P\n   Transaction)\
    \ or after having sent the link-layer acknowledgment for\n   the 6P Confirmation\
    \ (3-step 6P Transaction).\n   When node B receives a 6P Request from node A with\
    \ SeqNum equal to 0,\n   it checks the stored SeqNum for A.  If A is a new neighbor,\
    \ the\n   stored SeqNum in B will be 0.  The transaction can continue.  If the\n\
    \   stored SeqNum for A in B is different than 0, a potential\n   inconsistency\
    \ is detected.  In this case, B MUST return RC_ERR_SEQNUM\n   with SeqNum=0. \
    \ The SF of node A MAY decide what to do next, as\n   described in Section 3.4.6.2.\n\
    \   The SeqNum MUST be implemented as a lollipop counter: it rolls over\n   from\
    \ 0xFF to 0x01 (not to 0x00).  This is used to detect a neighbor\n   reset.  Figure\
    \ 28 lists the possible values of the SeqNum.\n               +-----------+------------------------------+\n\
    \               |   Value   | Meaning                      |\n               +-----------+------------------------------+\n\
    \               |      0x00 | Clear, or after device reset |\n               |\
    \ 0x01-0xFF | Lollipop counter values      |\n               +-----------+------------------------------+\n\
    \                 Figure 28: Possible Values of the SeqNum\n"
- title: 3.4.6.1.  Detecting and Handling Duplicate 6P Messages
  contents:
  - "3.4.6.1.  Detecting and Handling Duplicate 6P Messages\n   All 6P commands are\
    \ link-layer acknowledged.  A duplicate message\n   means that a node receives\
    \ a second 6P Request, Response, or\n   Confirmation.  This happens when the link-layer\
    \ acknowledgment is not\n   received and a link-layer retransmission happens.\
    \  Duplicate messages\n   are normal and unavoidable.\n   Figure 29 shows an example\
    \ 2-step transaction in which node A\n   receives a duplicate 6P Response.\n \
    \          +----------+                           +----------+\n           | \
    \ Node A  |                           |  Node B  |\n           +----+-----+  \
    \                         +-----+----+\n                |                    \
    \                   |\n                | 6P Request (SeqNum=456)             \
    \  |\n                |-------------------------------------->|\n            \
    \    |                                L2 ACK |\n                |<- - - - - -\
    \ - - - - - - - - - - - - - |\n                |                             \
    \          |\n                | 6P Response  (SeqNum=456)             |\n    \
    \            |<--------------------------------------|\n                | L2 ACK\
    \                                |\n                | - - - - - - - - - - -X \
    \               | no ACK:\n                |                                 \
    \      | link-layer\n                | 6P Response  (SeqNum=456)             |\
    \ retransmit\n      duplicate |<--------------------------------------|\n    6P\
    \ Response | L2 ACK                                |\n       received | - - -\
    \ - - - - - - - - - - - - - - - ->|\n                |                       \
    \                |\n                  Figure 29: Example Duplicate 6P Message\n\
    \   Figure 30 shows an example 3-step transaction in which node A\n   receives\
    \ an out-of-order duplicate 6P Response after having sent a 6P\n   Confirmation.\n\
    \           +----------+                           +----------+\n           |\
    \  Node A  |                           |  Node B  |\n           +----+-----+ \
    \                          +-----+----+\n                |                   \
    \                    |\n                | 6P Request  (SeqNum=123)           \
    \   |\n                |-------------------------------------->|\n           \
    \     |                                L2 ACK |\n                |<- - - - - -\
    \ - - - - - - - - - - - - - |\n                |                             \
    \          |\n                | 6P Response  (SeqNum=123)             |\n    \
    \            |<--------------------------------------|\n                | L2 ACK\
    \                                |\n                | - - - - - - - - - - -X \
    \               | no ACK:\n                |                                 \
    \      | link-layer\n                | 6P Confirmation  (SeqNum=123)         |\
    \ retransmit\n                |-------------------------------------->|    |\n\
    \                |                                L2 ACK |    |\n            \
    \    |<- - - - - - - - - - - - - - - - - - - |  frame\n                |     \
    \                                  |  queued\n                | 6P Response  (SeqNum=123)\
    \             |    |\n      duplicate |<--------------------------------------|\
    \ <--+\n   out-of-order | L2 ACK                                |\n    6P Response\
    \ | - - - - - - - - - - - - - - - - - - ->|\n       received |               \
    \                        |\n           Figure 30: Example Out-of-Order Duplicate\
    \ 6P Message\n   A node detects a duplicate 6P message when it has the same SeqNum\
    \ and\n   type as the last frame received from the same neighbor.  When\n   receiving\
    \ a duplicate 6P message, a node MUST send a link-layer\n   acknowledgment but\
    \ MUST silently ignore the 6P message at 6top.\n"
- title: 3.4.6.2.  Detecting and Handling a Schedule Inconsistency
  contents:
  - "3.4.6.2.  Detecting and Handling a Schedule Inconsistency\n   A schedule inconsistency\
    \ happens when the schedules of nodes A and B\n   are inconsistent -- for example,\
    \ when node A has a transmit cell to\n   node B, but node B does not have the\
    \ corresponding receive cell and\n   therefore isn't listening to node A on that\
    \ cell.  A schedule\n   inconsistency results in loss of connectivity.\n   The\
    \ SeqNum field, which is present in each 6P message, is used to\n   detect an\
    \ inconsistency.  The SeqNum field increments by 1 in each\n   message, as detailed\
    \ in Section 3.4.6.  A node computes the expected\n   SeqNum field for the next\
    \ 6P Transaction.  If a node receives a 6P\n   Request with a SeqNum value that\
    \ is not the expected value, it has\n   detected an inconsistency.\n   There are\
    \ two cases in which a schedule inconsistency happens.\n   The first case is when\
    \ a node loses state -- for example, when it is\n   power-cycled (turned off,\
    \ then on).  In that case, its SeqNum value\n   is reset to 0.  Since the SeqNum\
    \ is a lollipop counter, its neighbor\n   detects an inconsistency in the next\
    \ 6P Transaction.  This is\n   illustrated in Figures 31 and 32.\n           +----------+\
    \                           +----------+\n           |  Node A  |            \
    \               |  Node B  |\n           +----+-----+                        \
    \   +-----+----+\n      SeqNum=87 |                                       | SeqNum=87\n\
    \                |                                       |\n                |\
    \ 6P Request  (SeqNum=87)               |\n                |-------------------------------------->|\n\
    \                |                                L2 ACK |\n                |<-\
    \ - - - - - - - - - - - - - - - - - - |\n                |                   \
    \                    |\n                | 6P Response  (SeqNum=87)           \
    \   |\n                |<--------------------------------------|\n           \
    \     | L2 ACK                                |\n                | - - - - - -\
    \ - - - - - - - - - - - - ->|\n                |                             \
    \        ==== power-cycle\n                |                                 \
    \      |\n      SeqNum=88 |                                       | SeqNum=0\n\
    \                |                                       |\n                |\
    \ 6P Request (SeqNum=88)                |\n                |-------------------------------------->|\
    \ Inconsistency\n                |                                L2 ACK | detected\n\
    \                |<- - - - - - - - - - - - - - - - - - - |\n                |\
    \                                       |\n                | 6P Response (SeqNum=0,\
    \ RC_ERR_SEQNUM) |\n                |<--------------------------------------|\n\
    \                | L2 ACK                                |\n                |\
    \ - - - - - - - - - - - - - - - - - - ->|\n         Figure 31: Example of Inconsistency\
    \ Because Node B Resets\n                           (Detected by Node B)\n   \
    \         +----------+                           +----------+\n            | \
    \ Node A  |                           |  Node B  |\n            +----+-----+ \
    \                          +-----+----+\n       SeqNum=97 |                  \
    \                     | SeqNum=97\n                 |                        \
    \               |\n                 | 6P Request  (SeqNum=97)               |\n\
    \                 |-------------------------------------->|\n                \
    \ |                                L2 ACK |\n                 |<- - - - - - -\
    \ - - - - - - - - - - - - |\n                 |                              \
    \         |\n                 | 6P Response  (SeqNum=97)              |\n    \
    \             |<--------------------------------------|\n                 | L2\
    \ ACK                                |\n                 | - - - - - - - - - -\
    \ - - - - - - - - ->|\n                 |                                    \
    \ ==== power-cycle\n                 |                                       |\n\
    \       SeqNum=98 |                                       | SeqNum=0\n       \
    \          |                                       |\n                 | 6P Request\
    \ (SeqNum=0)                 |\n   Inconsistency |<--------------------------------------|\n\
    \        detected | L2 ACK                                |\n                \
    \ |- - - - - - - - - - - - - - - - - - - >|\n                 |              \
    \                         |\n                 | 6P Response (SeqNum=0, RC_ERR_SEQNUM)\
    \ |\n                 |-------------------------------------->|\n            \
    \     | L2 ACK                                |\n                 |<- - - - -\
    \ - - - - - - - - - - - - - - |\n         Figure 32: Example of Inconsistency\
    \ Because Node B Resets\n                           (Detected by Node A)\n   The\
    \ second case is when the maximum number of link-layer\n   retransmissions is\
    \ reached on the 6P Response of a 2-step transaction\n   (or, equivalently, on\
    \ a 6P Confirmation of a 3-step transaction).\n   This is illustrated in Figure\
    \ 33.\n          +----------+                           +----------+\n       \
    \   |  Node A  |                           |  Node B  |\n          +----+-----+\
    \                           +-----+----+\n     SeqNum=87 |                   \
    \                    | SeqNum=87\n               |                           \
    \            |\n               | 6P Request  (SeqNum=87)               |\n   \
    \            |-------------------------------------->|\n               |     \
    \                           L2 ACK |\n               |<- - - - - - - - - - - -\
    \ - - - - - - - |\n               |                                       |\n\
    \               | 6P Response  (SeqNum=87)              |\n               |<--------------------------------------|\n\
    \               | L2 ACK                                |\n               | -\
    \ - - - - - - - X                     |\n     SeqNum=88 |                    \
    \                   | no ACK:\n               | 6P Response  (SeqNum=87)     \
    \         | retrans. 1\n   (duplicate) |<--------------------------------------|\n\
    \               | L2 ACK                                |\n               | -\
    \ - - - - - - - X                     |\n               |                    \
    \                   | no ACK:\n               | 6P Response  (SeqNum=87)     \
    \         | retrans. 2\n   (duplicate) |<--------------------------------------|\n\
    \               | L2 ACK                                |\n               | -\
    \ - - - - - - - X                     |\n               |                    \
    \                   | max. retrans.:\n               |                       \
    \                | inconsistency\n               |                           \
    \            | detected\n      Figure 33: Example Inconsistency Because of Maximum\
    \ Link-Layer\n                    Retransmissions (where Maximum = 2)\n   In both\
    \ cases, node B detects the inconsistency.\n   If the inconsistency is detected\
    \ during a 6P Transaction (Figure 31),\n   the node that has detected it MUST\
    \ send back a 6P Response or 6P\n   Confirmation with an error code of RC_ERR_SEQNUM.\
    \  In this 6P\n   Response or 6P Confirmation, the SeqNum field MUST be set to\
    \ the\n   value of the sender of the message (0 in the example in Figure 31).\n\
    \   The SF of the node that has detected the inconsistency MUST define\n   how\
    \ to handle the inconsistency.  Three possible ways to do this are\n   as follows:\n\
    \   o  Issue a 6P CLEAR Request to clear the schedule, and then rebuild.\n   o\
    \  Issue a 6P LIST Request to retrieve the schedule.\n   o  Internally \"roll\
    \ back\" the schedule.\n   How to handle an inconsistency is out of scope for\
    \ this document.\n   The SF defines how to handle an inconsistency.\n"
- title: 3.4.7.  Handling Error Responses
  contents:
  - "3.4.7.  Handling Error Responses\n   A return code marked as Yes in the \"Is\
    \ Error?\" column in Figure 38\n   (Section 6.2.4) indicates an error.  When a\
    \ node receives a 6P\n   Response or 6P Confirmation with an error, it MUST consider\
    \ the 6P\n   Transaction as having failed.  In particular, if this was a response\n\
    \   to a 6P ADD, DELETE, or RELOCATE Request, the node MUST NOT add,\n   delete,\
    \ or relocate any of the cells involved in this 6P Transaction.\n   Similarly,\
    \ a node sending a 6P Response or a 6P Confirmation with an\n   error code MUST\
    \ NOT add, delete, or relocate any cells as part of\n   that 6P Transaction. \
    \ If a node receives an unrecognized return code,\n   the 6P Transaction MUST\
    \ be considered as having failed.  In\n   particular, in a 3-step 6P Transaction,\
    \ when receiving a 6P Response\n   with a return code that it does not recognize,\
    \ the requester (node A)\n   MUST send a 6P Confirmation to the responder (node\
    \ B) with return\n   code RC_ERR and consider the transaction failed.  Upon reception\
    \ of a\n   6P Confirmation with return code RC_ERR, the responder MUST consider\n\
    \   the transaction failed as well.  Defining what to do after an error\n   has\
    \ occurred is out of scope for this document.  The SF defines what\n   to do after\
    \ an error has occurred.\n"
- title: 3.5.  Security
  contents:
  - "3.5.  Security\n   6P messages MUST be secured through link-layer security. \
    \ This is\n   possible because 6P messages are carried as Payload IEs.\n"
- title: 4.  Requirements for 6top Scheduling Function (SF) Specifications
  contents:
  - '4.  Requirements for 6top Scheduling Function (SF) Specifications

    '
- title: 4.1.  SF Identifier (SFID)
  contents:
  - "4.1.  SF Identifier (SFID)\n   Each SF has a 1-byte identifier.  Section 6.2.5\
    \ defines the rules for\n   applying for an SFID.\n"
- title: 4.2.  Requirements for an SF Specification
  contents:
  - "4.2.  Requirements for an SF Specification\n   The specification for an SF\n\
    \   o  MUST specify an identifier for that SF.\n   o  MUST specify the rule for\
    \ a node to decide when to add/delete one\n      or more cells to/on a neighbor.\n\
    \   o  MUST specify the rule for a transaction source to select cells to\n   \
    \   add to the CellList field in the 6P ADD Request.\n   o  MUST specify the rule\
    \ for a transaction destination to select\n      cells from the CellList to add\
    \ to its schedule.\n   o  MUST specify a value for the 6P Timeout or a rule/equation\
    \ to\n      calculate it.\n   o  MUST specify the rule for ordering cells.\n \
    \  o  MUST specify a meaning for the Metadata field in the 6P ADD\n      Request.\n\
    \   o  MUST specify the SF behavior of a node when it boots.\n   o  MUST specify\
    \ how to handle a schedule inconsistency.\n   o  MUST specify what to do after\
    \ an error has occurred (the node\n      either sent a 6P Response with an error\
    \ code or received one).\n   o  MUST specify the list of statistics to gather.\
    \  Example statistics\n      include the number of transmitted frames to each\
    \ neighbor.  If the\n      SF does not require that statistics be gathered, the\
    \ SF\n      specification MUST explicitly say so.\n   o  SHOULD clearly state\
    \ the application domain the SF is created for.\n   o  SHOULD contain examples\
    \ that highlight normal and error scenarios.\n   o  SHOULD contain a list of current\
    \ implementations, at least during\n      the Internet-Draft (I-D) state of the\
    \ document, per [RFC7942].\n   o  SHOULD contain a performance evaluation of the\
    \ scheme, possibly\n      through references to external documents.\n   o  SHOULD\
    \ define the format of the SIGNAL command payload and\n      its use.\n   o  MAY\
    \ redefine the format of the CellList field.\n   o  MAY redefine the format of\
    \ the CellOptions field.\n   o  MAY redefine the meaning of the CellOptions field.\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   6P messages are carried inside 802.15.4 Payload\
    \ Information Elements\n   (IEs).  Those Payload IEs are encrypted and authenticated\
    \ at the link\n   layer through CCM* [CCM-Star] (\"CCM\" stands for \"Cipher block\n\
    \   Chaining -- Message authentication code\").  6P benefits from the same\n \
    \  level of security as any other Payload IE.  6P does not define its\n   own\
    \ security mechanisms.  In particular, although a key management\n   solution\
    \ is out of scope for this document, 6P will benefit from the\n   key management\
    \ solution used in the network.  This is relevant, as\n   security attacks such\
    \ as forgery and misattribution attacks become\n   more damaging when a single\
    \ key is shared amongst a group of more\n   than two participants.\n   6P does\
    \ not provide protection against DoS attacks.  Example attacks\n   include not\
    \ sending confirmation messages in 3-step transactions and\n   sending incorrectly\
    \ formatted requests.  These cases SHOULD be\n   handled by an appropriate policy,\
    \ such as rate-limiting or\n   time-limited blacklisting of the attacker after\
    \ several attempts.\n   The effect on the overall network is mostly localized\
    \ to the two\n   nodes in question, as communication happens in dedicated cells.\n"
- title: 6.  IANA Considerations
  contents:
  - '6.  IANA Considerations

    '
- title: 6.1.  IETF IE Subtype 6P
  contents:
  - "6.1.  IETF IE Subtype 6P\n   This document adds the following number to the \"\
    IEEE Std 802.15.4\n   IETF IE Subtype IDs\" registry defined by [RFC8137]:\n \
    \                   +--------+------------+-----------+\n                    |\
    \ Value  | Subtype ID | Reference |\n                    +--------+------------+-----------+\n\
    \                    |   1    | SUBID_6TOP | RFC 8480  |\n                   \
    \ +---------------------+-----------+\n                   Figure 34: IETF IE Subtype\
    \ SUBID_6TOP\n"
- title: 6.2.  6TiSCH Parameters Subregistries
  contents:
  - "6.2.  6TiSCH Parameters Subregistries\n   This section defines subregistries\
    \ within the \"IPv6 Over the TSCH\n   Mode of IEEE 802.15.4e (6TiSCH)\" parameters\
    \ registry, hereafter\n   referred to as the \"6TiSCH parameters\" registry. \
    \ Each subregistry is\n   described in a subsection.\n"
- title: 6.2.1.  6P Version Numbers
  contents:
  - "6.2.1.  6P Version Numbers\n   The name of the subregistry is \"6P Version Numbers\"\
    .\n   The following note is included in this registry: \"In the 6top\n   Protocol\
    \ (6P) [RFC8480], there is a field to identify the version of\n   the protocol.\
    \  This field is 4 bits in size.\"\n   Each entry in the subregistry must include\
    \ the version in the\n   range 0-15 and a reference to the 6P version's documentation.\n\
    \   The initial entry in this subregistry is as follows:\n                   \
    \       +---------+-----------+\n                          | Version | Reference\
    \ |\n                          +---------+-----------+\n                     \
    \     |       0 | RFC 8480  |\n                          +---------+-----------+\n\
    \                    Figure 35: 6P Version Number Entry\n   All other version\
    \ numbers are Unassigned.\n   The IANA policy for future additions to this subregistry\
    \ is \"IETF\n   Review\" or \"IESG Approval\" as described in [RFC8126].\n"
- title: 6.2.2.  6P Message Types
  contents:
  - "6.2.2.  6P Message Types\n   The name of the subregistry is \"6P Message Types\"\
    .\n   The following note is included in this registry: \"In version 0 of the\n\
    \   6top Protocol (6P) [RFC8480], there is a field to identify the type\n   of\
    \ message.  This field is 2 bits in size.\"\n   Each entry in the subregistry\
    \ must include the message type in the\n   range b00-b11, the corresponding name,\
    \ and a reference to the 6P\n   message type's documentation.\n   Initial entries\
    \ in this subregistry are as follows:\n                   +------+--------------+-----------+\n\
    \                   | Type | Name         | Reference |\n                   +------+--------------+-----------+\n\
    \                   | b00  | REQUEST      | RFC 8480  |\n                   |\
    \ b01  | RESPONSE     | RFC 8480  |\n                   | b10  | CONFIRMATION\
    \ | RFC 8480  |\n                   +------+--------------+-----------+\n    \
    \                    Figure 36: 6P Message Types\n   All other message types are\
    \ Unassigned.\n   The IANA policy for future additions to this subregistry is\
    \ \"IETF\n   Review\" or \"IESG Approval\" as described in [RFC8126].\n"
- title: 6.2.3.  6P Command Identifiers
  contents:
  - "6.2.3.  6P Command Identifiers\n   The name of the subregistry is \"6P Command\
    \ Identifiers\".\n   The following note is included in this registry: \"In version\
    \ 0 of the\n   6top Protocol (6P) [RFC8480], there is a Code field that is 8 bits\
    \ in\n   size.  In a 6P Request, the value of this Code field is used to\n   identify\
    \ the command.\"\n   Each entry in the subregistry must include an identifier\
    \ in the\n   range 0-255, the corresponding name, and a reference to the 6P\n\
    \   command identifier's documentation.\n   Initial entries in this subregistry\
    \ are as follows:\n                  +------------+------------+-----------+\n\
    \                  | Identifier | Name       | Reference |\n                 \
    \ +------------+------------+-----------+\n                  |          0 | Reserved\
    \   | RFC 8480  |\n                  |          1 | ADD        | RFC 8480  |\n\
    \                  |          2 | DELETE     | RFC 8480  |\n                 \
    \ |          3 | RELOCATE   | RFC 8480  |\n                  |          4 | COUNT\
    \      | RFC 8480  |\n                  |          5 | LIST       | RFC 8480 \
    \ |\n                  |          6 | SIGNAL     | RFC 8480  |\n             \
    \     |          7 | CLEAR      | RFC 8480  |\n                  |      8-254\
    \ | Unassigned |           |\n                  |        255 | Reserved   | RFC\
    \ 8480  |\n                  +------------+------------+-----------+\n       \
    \              Figure 37: 6P Command Identifiers\n   The IANA policy for future\
    \ additions to this subregistry is \"IETF\n   Review\" or \"IESG Approval\" as\
    \ described in [RFC8126].\n"
- title: 6.2.4.  6P Return Codes
  contents:
  - "6.2.4.  6P Return Codes\n   The name of the subregistry is \"6P Return Codes\"\
    .\n   The following note is included in this registry: \"In version 0 of the\n\
    \   6top Protocol (6P) [RFC8480], there is a Code field that is 8 bits in\n  \
    \ size.  In a 6P Response or 6P Confirmation, the value of this Code\n   field\
    \ is used to identify the return code.\"\n   Each entry in the subregistry must\
    \ include a return code in the\n   range 0-255, the corresponding name, the corresponding\
    \ description,\n   and a reference to the 6P return code's documentation.  If\
    \ the return\n   code corresponds to a Response error, the \"Is Error?\" entry\
    \ must\n   indicate \"Yes\".  Otherwise, \"No\" must be used.\n   Initial entries\
    \ in this subregistry are as follows:\n     +------+-----------------+---------------------------+-----------+\n\
    \     | Code | Name            | Description               | Is Error? |\n   \
    \  +------+-----------------+---------------------------+-----------+\n     |\
    \    0 | RC_SUCCESS      | operation succeeded       |        No |\n     |   \
    \ 1 | RC_EOL          | end of list               |        No |\n     |    2 |\
    \ RC_ERR          | generic error             |       Yes |\n     |    3 | RC_RESET\
    \        | critical error, reset     |       Yes |\n     |    4 | RC_ERR_VERSION\
    \  | unsupported 6P version    |       Yes |\n     |    5 | RC_ERR_SFID     |\
    \ unsupported SFID          |       Yes |\n     |    6 | RC_ERR_SEQNUM   | schedule\
    \ inconsistency    |       Yes |\n     |    7 | RC_ERR_CELLLIST | cellList error\
    \            |       Yes |\n     |    8 | RC_ERR_BUSY     | busy             \
    \         |       Yes |\n     |    9 | RC_ERR_LOCKED   | cells are locked    \
    \      |       Yes |\n     +------+-----------------+---------------------------+-----------+\n\
    \                        Figure 38: 6P Return Codes\n   All other message types\
    \ are Unassigned.\n   The IANA policy for future additions to this subregistry\
    \ is \"IETF\n   Review\" or \"IESG Approval\" as described in [RFC8126].\n"
- title: 6.2.5.  6P Scheduling Function Identifiers
  contents:
  - "6.2.5.  6P Scheduling Function Identifiers\n   The name of the subregistry is\
    \ \"6P Scheduling Function Identifiers\".\n   The following note is included in\
    \ this registry: \"In version 0 of the\n   6top Protocol (6P) [RFC8480], there\
    \ is a field to identify the\n   Scheduling Function to handle the message.  This\
    \ field is 8 bits\n   in size.\"\n   Each entry in the subregistry must include\
    \ an SFID in the\n   range 0-255, the corresponding name, and a reference to the\
    \ 6P\n   Scheduling Function's documentation.\n   There are currently no entries\
    \ in this subregistry.\n   +------+---------------------------------+--------------------------+\n\
    \   | SFID | Name                            | Reference                |\n  \
    \ +------+---------------------------------+--------------------------+\n   |\
    \ 0-255| Unassigned                      |                          |\n   +------+---------------------------------+--------------------------+\n\
    \                   Figure 39: SF Identifier (SFID) Entry\n   All message types\
    \ are Unassigned.\n   The IANA policy for future additions to this subregistry\
    \ depends on\n   the value of the SFID, as shown in Figure 40.  These specifications\n\
    \   must follow the guidelines of Section 4.\n                +-----------+------------------------------+\n\
    \                |     Range | Registration Procedures      |\n              \
    \  +-----------+------------------------------+\n                |     0-127 |\
    \ IETF Review or IESG Approval |\n                |   128-255 | Expert Review\
    \                |\n                +-----------+------------------------------+\n\
    \          Figure 40: SF Identifier (SFID): Registration Procedure\n"
- title: 6.2.6.  6P CellOptions Bitmap
  contents:
  - "6.2.6.  6P CellOptions Bitmap\n   The name of the subregistry is \"6P CellOptions\
    \ Bitmap\".\n   The following note is included in this registry: \"In version\
    \ 0 of the\n   6top Protocol (6P) [RFC8480], there is an optional CellOptions\
    \ field\n   that is 8 bits in size.\"\n   Each entry in the subregistry must include\
    \ a bit position in the\n   range 0-7, the corresponding name, and a reference\
    \ to the bit's\n   documentation.\n   Initial entries in this subregistry are\
    \ as follows:\n                    +-----+---------------+-----------+\n     \
    \               | bit | Name          | Reference |\n                    +-----+---------------+-----------+\n\
    \                    |   0 | TX (Transmit) | RFC 8480  |\n                   \
    \ |   1 | RX (Receive)  | RFC 8480  |\n                    |   2 | SHARED    \
    \    | RFC 8480  |\n                    | 3-7 | Reserved      |           |\n\
    \                    +-----+---------------+-----------+\n                   \
    \  Figure 41: 6P CellOptions Bitmap\n   All other message types are Unassigned.\n\
    \   The IANA policy for future additions to this subregistry is \"IETF\n   Review\"\
    \ or \"IESG Approval\" as described in [RFC8126].\n"
- title: 7.  References
  contents:
  - '7.  References

    '
- title: 7.1.  Normative References
  contents:
  - "7.1.  Normative References\n   [IEEE802154]\n              IEEE, \"IEEE Standard\
    \ for Low-Rate Wireless Networks\",\n              IEEE 802.15.4, DOI 10.1109/IEEESTD.2016.7460875.\n\
    \   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n        \
    \      Requirement Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119,\
    \ March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC8137]\
    \  Kivinen, T. and P. Kinney, \"IEEE 802.15.4 Information\n              Element\
    \ for the IETF\", RFC 8137, DOI 10.17487/RFC8137,\n              May 2017, <https://www.rfc-editor.org/info/rfc8137>.\n\
    \   [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in\n         \
    \     RFC 2119 Key Words\", BCP 14, RFC 8174,\n              DOI 10.17487/RFC8174,\
    \ May 2017,\n              <https://www.rfc-editor.org/info/rfc8174>.\n"
- title: 7.2.  Informative References
  contents:
  - "7.2.  Informative References\n   [CCM-Star] Struik, R., \"Formal Specification\
    \ of the CCM* Mode of\n              Operation\", IEEE P802.15-4/0537r2, September\
    \ 2005.\n   [RFC7554]  Watteyne, T., Ed., Palattella, M., and L. Grieco, \"Using\n\
    \              IEEE 802.15.4e Time-Slotted Channel Hopping (TSCH) in the\n   \
    \           Internet of Things (IoT): Problem Statement\", RFC 7554,\n       \
    \       DOI 10.17487/RFC7554, May 2015,\n              <https://www.rfc-editor.org/info/rfc7554>.\n\
    \   [RFC7942]  Sheffer, Y. and A. Farrel, \"Improving Awareness of Running\n \
    \             Code: The Implementation Status Section\", BCP 205,\n          \
    \    RFC 7942, DOI 10.17487/RFC7942, July 2016,\n              <https://www.rfc-editor.org/info/rfc7942>.\n\
    \   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, \"Guidelines for\n      \
    \        Writing an IANA Considerations Section in RFCs\", BCP 26,\n         \
    \     RFC 8126, DOI 10.17487/RFC8126, June 2017,\n              <https://www.rfc-editor.org/info/rfc8126>.\n\
    \   [RFC8180]  Vilajosana, X., Ed., Pister, K., and T. Watteyne, \"Minimal\n \
    \             IPv6 over the TSCH Mode of IEEE 802.15.4e (6TiSCH)\n           \
    \   Configuration\", BCP 210, RFC 8180, DOI 10.17487/RFC8180,\n              May\
    \ 2017, <https://www.rfc-editor.org/info/rfc8180>.\n"
- title: Appendix A.  Recommended Structure of an SF Specification
  contents:
  - "Appendix A.  Recommended Structure of an SF Specification\n   The following section\
    \ structure for an SF document is RECOMMENDED:\n   o  Introduction\n   o  RFC\
    \ 2119 Requirements Language (if applicable)\n   o  Scheduling Function Identifier\n\
    \   o  Rules for Adding/Deleting Cells\n   o  Rules for CellList\n   o  6P Timeout\
    \ Value\n   o  Rule for Ordering Cells\n   o  Meaning of the Metadata Field\n\
    \   o  Node Behavior at Boot\n   o  Schedule Inconsistency Handling\n   o  6P\
    \ Error Handling\n   o  Examples\n   o  Implementation Status\n   o  Security\
    \ Considerations\n   o  IANA Considerations\n   o  Normative References (if applicable)\n\
    \   o  Informative References (if applicable)\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Qin Wang (editor)\n   Univ. of Sci. and Tech. Beijing\n\
    \   30 Xueyuan Road\n   Beijing, Hebei  100083\n   China\n   Email: wangqin@ies.ustb.edu.cn\n\
    \   Xavier Vilajosana\n   Universitat Oberta de Catalunya\n   156 Rambla Poblenou\n\
    \   Barcelona, Catalonia  08018\n   Spain\n   Email: xvilajosana@uoc.edu\n   Thomas\
    \ Watteyne\n   Analog Devices\n   32990 Alvarado-Niles Road, Suite 910\n   Union\
    \ City, CA  94587\n   United States of America\n   Email: thomas.watteyne@analog.com\n"
