- title: __initial_text__
  contents:
  - "                   Information Model for Describing\n                Network\
    \ Device QoS Datapath Mechanisms\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2004).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   The purpose of this document is to define an information model to\n\
    \   describe the quality of service (QoS) mechanisms inherent in\n   different\
    \ network devices, including hosts.  Broadly speaking, these\n   mechanisms describe\
    \ the properties common to selecting and\n   conditioning traffic through the\
    \ forwarding path (datapath) of a\n   network device.  This selection and conditioning\
    \ of traffic in the\n   datapath spans both major QoS architectures: Differentiated\
    \ Services\n   and Integrated Services.\n   This document should be used with\
    \ the QoS Policy Information Model\n   (QPIM) to model how policies can be defined\
    \ to manage and configure\n   the QoS mechanisms (i.e., the classification, marking,\
    \ metering,\n   dropping, queuing, and scheduling functionality) of devices.\n\
    \   Together, these two documents describe how to write QoS policy rules\n   to\
    \ configure and manage the QoS mechanisms present in the datapaths\n   of devices.\n\
    \   This document, as well as QPIM, are information models.  That is,\n   they\
    \ represent information independent of a binding to a specific\n   type of repository.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  4\n       1.1.  Policy Management Conceptual Model . . . . . .\
    \ . . . . .  6\n       1.2.  Purpose and Relation to Other Policy Work. . . .\
    \ . . . .  7\n       1.3.  Typical Examples of Policy Usage . . . . . . . . .\
    \ . . .  7\n   2.  Approach . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . .  8\n       2.1.  Common Needs Of DiffServ and IntServ . . . . . . . . .\
    \ .  8\n       2.2.  Specific Needs Of DiffServ . . . . . . . . . . . . . . .\
    \  9\n       2.3.  Specific Needs Of IntServ. . . . . . . . . . . . . . . .  9\n\
    \   3.  Methodology. . . . . . . . . . . . . . . . . . . . . . . . . . 10\n  \
    \     3.1.  Level of Abstraction for Expressing QoS Policies . . . . 10\n    \
    \   3.2.  Specifying Policy Parameters . . . . . . . . . . . . . . 11\n      \
    \ 3.3.  Specifying Policy Services . . . . . . . . . . . . . . . 12\n       3.4.\
    \  Level of Abstraction for Defining QoS Attributes and\n             Classes.\
    \ . . . . . . . . . . . . . . . . . . . . . . . . 13\n       3.5.  Characterization\
    \ of QoS Properties . . . . . . . . . . . 14\n       3.6.  QoS Information Model\
    \ Derivation . . . . . . . . . . . . 15\n       3.7.  Attribute Representation\
    \ . . . . . . . . . . . . . . . . 16\n       3.8.  Mental Model . . . . . . .\
    \ . . . . . . . . . . . . . . . 17\n             3.8.1.  The QoSService Class\
    \ . . . . . . . . . . . . . . 17\n             3.8.2.  The ConditioningService\
    \ Class. . . . . . . . . . 18\n             3.8.3.  Preserving QoS Information\
    \ from Ingress to\n                     Egress . . . . . . . . . . . . . . . .\
    \ . . . . . 19\n       3.9.  Classifiers, FilterLists, and Filter Entries . .\
    \ . . . . 21\n       3.10. Modeling of Droppers . . . . . . . . . . . . . . .\
    \ . . . 23\n             3.10.1. Configuring Head and Tail Droppers . . . . .\
    \ . . 23\n             3.10.2. Configuring RED Droppers . . . . . . . . . . .\
    \ . 24\n       3.11. Modeling of Queues and Schedulers. . . . . . . . . . . .\
    \ 25\n             3.11.1. Simple Hierarchical Scheduler. . . . . . . . . . 25\n\
    \             3.11.2. Complex Hierarchical Scheduler . . . . . . . . . 27\n  \
    \           3.11.3. Excess Capacity Scheduler. . . . . . . . . . . . 29\n    \
    \         3.11.4. Hierarchical CBQ Scheduler . . . . . . . . . . . 31\n   4. \
    \ The Class Hierarchy. . . . . . . . . . . . . . . . . . . . . . 33\n       4.1.\
    \  Associations and Aggregations. . . . . . . . . . . . . . 33\n       4.2.  The\
    \ Structure of the Class Hierarchies . . . . . . . . . 34\n       4.3.  Class\
    \ Definitions. . . . . . . . . . . . . . . . . . . . 38\n             4.3.1. \
    \ The Abstract Class ManagedElement. . . . . . . . 38\n             4.3.2.  The\
    \ Abstract Class ManagedSystemElement. . . . . 39\n             4.3.3.  The Abstract\
    \ Class LogicalElement. . . . . . . . 39\n             4.3.4.  The Abstract Class\
    \ Service . . . . . . . . . . . 39\n             4.3.5.  The Class ConditioningService.\
    \ . . . . . . . . . 39\n             4.3.6.  The Class ClassifierService. . .\
    \ . . . . . . . . 40\n             4.3.7.  The Class ClassifierElement. . . .\
    \ . . . . . . . 41\n             4.3.8.  The Class MeterService . . . . . . .\
    \ . . . . . . 42\n             4.3.9.  The Class AverageRateMeterService. . .\
    \ . . . . . 44\n             4.3.10. The Class EWMAMeterService . . . . . . .\
    \ . . . . 44\n             4.3.11. The Class TokenBucketMeterService. . . . .\
    \ . . . 46\n             4.3.12. The Class MarkerService. . . . . . . . . . .\
    \ . . 47\n             4.3.13. The Class PreambleMarkerService. . . . . . . .\
    \ . 47\n             4.3.14. The Class ToSMarkerService . . . . . . . . . . .\
    \ 48\n             4.3.15. The Class DSCPMarkerService. . . . . . . . . . . 49\n\
    \             4.3.16. The Class 8021QMarkerService . . . . . . . . . . 49\n  \
    \           4.3.17. The Class DropperService . . . . . . . . . . . . 50\n    \
    \         4.3.18. The Class HeadTailDropperService . . . . . . . . 52\n      \
    \       4.3.19. The Class REDDropperService. . . . . . . . . . . 52\n        \
    \     4.3.20. The Class QueuingService . . . . . . . . . . . . 54\n          \
    \   4.3.21. The Class PacketSchedulingService. . . . . . . . 55\n            \
    \ 4.3.22. The Class NonWorkConservingSchedulingService . . 56\n             4.3.23.\
    \ The Class QoSService . . . . . . . . . . . . . . 57\n             4.3.24. The\
    \ Class DiffServService. . . . . . . . . . . . 58\n             4.3.25. The Class\
    \ AFService. . . . . . . . . . . . . . . 59\n             4.3.26. The Class FlowService.\
    \ . . . . . . . . . . . . . 60\n             4.3.27. The Class DropThresholdCalculationService.\
    \ . . . 60\n             4.3.28. The Abstract Class FilterEntryBase . . . . .\
    \ . . 61\n             4.3.29. The Class IPHeaderFilter . . . . . . . . . . .\
    \ . 62\n             4.3.30. The Class 8021Filter . . . . . . . . . . . . . .\
    \ 62\n             4.3.31. The Class PreambleFilter . . . . . . . . . . . . 62\n\
    \             4.3.32. The Class FilterList . . . . . . . . . . . . . . 63\n  \
    \           4.3.33. The Abstract Class ServiceAccessPoint. . . . . . 63\n    \
    \         4.3.34. The Class ProtocolEndpoint . . . . . . . . . . . 63\n      \
    \       4.3.35. The Abstract Class Collection. . . . . . . . . . 65\n        \
    \     4.3.36. The Abstract Class CollectionOfMSEs. . . . . . . 65\n          \
    \   4.3.37. The Class BufferPool . . . . . . . . . . . . . . 65\n            \
    \ 4.3.38. The Abstract Class SchedulingElement . . . . . . 65\n             4.3.39.\
    \ The Class AllocationSchedulingElement. . . . . . 66\n             4.3.40. The\
    \ Class WRRSchedulingElement . . . . . . . . . 67\n             4.3.41. The Class\
    \ PrioritySchedulingElement. . . . . . . 69\n             4.3.42. The Class BoundedPrioritySchedulingElement\
    \ . . . 70\n       4.4.  Association Definitions. . . . . . . . . . . . . . .\
    \ . . 70\n             4.4.1.  The Abstract Association Dependency. . . . . .\
    \ . 71\n             4.4.2.  The Association ServiceSAPDependency . . . . . .\
    \ 71\n             4.4.3.  The Association\n                     IngressConditioningServiceOnEndpoint\
    \ . . . . . . 71\n             4.4.4.  The Association\n                     EgressConditioningServiceOnEndpoint.\
    \ . . . . . . 72\n             4.4.5.  The Association HeadTailDropQueueBinding\
    \ . . . . 72\n             4.4.6.  The Association CalculationBasedOnQueue. .\
    \ . . . 73\n             4.4.7.  The Association ProvidesServiceToElement . .\
    \ . . 74\n             4.4.8.  The Association ServiceServiceDependency . . .\
    \ . 74\n             4.4.9.  The Association CalculationServiceForDropper . .\
    \ 75\n             4.4.10. The Association QueueAllocation. . . . . . . . . 75\n\
    \             4.4.11. The Association ClassifierElementUsesFilterList. 76\n  \
    \           4.4.12. The Association AFRelatedServices. . . . . . . . 77\n    \
    \         4.4.13. The Association NextService. . . . . . . . . . . 78\n      \
    \       4.4.14. The Association\n                     NextServiceAfterClassifierElement.\
    \ . . . . . . . 79\n             4.4.15. The Association NextScheduler. . . .\
    \ . . . . . . 80\n             4.4.16. The Association FailNextScheduler. . .\
    \ . . . . . 81\n             4.4.17. The Association NextServiceAfterMeter. .\
    \ . . . . 82\n             4.4.18. The Association QueueToSchedule. . . . . .\
    \ . . . 83\n             4.4.19. The Association SchedulingServiceToSchedule.\
    \ . . 84\n             4.4.20. The Aggregation MemberOfCollection . . . . . .\
    \ . 85\n             4.4.21. The Aggregation CollectedBufferPool. . . . . . .\
    \ 85\n             4.4.22. The Abstract Aggregation Component . . . . . . . 86\n\
    \             4.4.23. The Aggregation ServiceComponent . . . . . . . . 86\n  \
    \           4.4.24. The Aggregation QoSSubService. . . . . . . . . . 86\n    \
    \         4.4.25. The Aggregation QoSConditioningSubService. . . . 87\n      \
    \       4.4.26. The Aggregation\n                     ClassifierElementInClassifierService\
    \ . . . . . . 88\n             4.4.27. The Aggregation EntriesInFilterList. .\
    \ . . . . . 89\n             4.4.28. The Aggregation ElementInSchedulingService\
    \ . . . 90\n   5.  Intellectual Property Statement. . . . . . . . . . . . . .\
    \ . . 91\n   6.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . .\
    \ . 91\n   7.  Security Considerations. . . . . . . . . . . . . . . . . . . .\
    \ 91\n   8.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 92\n\
    \       8.1. Normative References. . . . . . . . . . . . . . . . . . . 92\n  \
    \     8.2. Informative References  . . . . . . . . . . . . . . . . . 92\n   9.\
    \  Appendix A:  Naming Instances in a Native CIM Implementation . 94\n       9.1.\
    \ Naming Instances of the Classes Derived from Service. . . 94\n       9.2. Naming\
    \ Instances of Subclasses of FilterEntryBase . . . . 94\n       9.3. Naming Instances\
    \ of ProtocolEndpoint. . . . . . . . . . . 94\n       9.4. Naming Instances of\
    \ BufferPool. . . . . . . . . . . . . . 95\n             9.4.1.  The Property\
    \ CollectionID. . . . . . . . . . . . 95\n             9.4.2.  The Property CreationClassName\
    \ . . . . . . . . . 95\n       9.5. Naming Instances of SchedulingElement . .\
    \ . . . . . . . . 95\n   10. Authors' Addresses . . . . . . . . . . . . . . .\
    \ . . . . . . . 96\n   11. Full Copyright Statement . . . . . . . . . . . . .\
    \ . . . . . . 97\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   The purpose of this document is to define an information\
    \ model to\n   describe the quality of service (QoS) mechanisms inherent in\n\
    \   different network devices, including hosts.  Broadly speaking, these\n   mechanisms\
    \ describe the attributes common to selecting and\n   conditioning traffic through\
    \ the forwarding path (datapath) of a\n   network device.  This selection and\
    \ conditioning of traffic in the\n   datapath spans both major QoS architectures:\
    \ Differentiated Services\n   (see [R2475]) and Integrated Services (see [R1633]).\n\
    \   This document is intended to be used with the QoS Policy Information\n   Model\
    \ [QPIM] to model how policies can be defined to manage and\n   configure the\
    \ QoS mechanisms (i.e., the classification, marking,\n   metering, dropping, queuing,\
    \ and scheduling functionality) of\n   devices.  Together, these two documents\
    \ describe how to write QoS\n   policy rules to configure and manage the QoS mechanisms\
    \ present in\n   the datapaths of devices.\n   This document, as well as [QPIM],\
    \ are information models.  That is,\n   they represent information independent\
    \ of a binding to a specific\n   type of repository.  A separate document could\
    \ be written to provide\n   a mapping of the data contained in this document to\
    \ a form suitable\n   for implementation in a directory that uses (L)DAP as its\
    \ access\n   protocol.  Similarly, a document could be written to provide a\n\
    \   mapping of the data in [QPIM] to a directory. Together, these four\n   documents\
    \ (information models and directory schema mappings) would\n   then describe how\
    \ to write QoS policy rules that can be used to store\n   information in directories\
    \ to configure device QoS mechanisms.\n   The approach taken in this document\
    \ defines a common set of classes\n   that can be used to model QoS in a device\
    \ datapath. Vendors can then\n   map these classes, either directly or using an\
    \ intervening format\n   like a COP-PR PIB, to their own device-specific implementations.\n\
    \   Note that the admission control element of Integrated Services is not\n  \
    \ included in the scope of this model.\n   The design of the class, association,\
    \ and aggregation hierarchies\n   described in this document is influenced by\
    \ the Network QoS submodel\n   defined by the Distributed Management Task Force\
    \ (DMTF) - see [CIM].\n   These hierarchies are not derived from the Policy Core\
    \ Information\n   Model [PCIM].  This is because the modeling of the QoS mechanisms\
    \ of\n   a device is separate and distinct from the modeling of policies that\n\
    \   manage those mechanisms.  Hence, there is a need to separate QoS\n   mechanisms\
    \ (this document) from their control (specified using the\n   generic policy document\
    \ [PCIM] augmented by the QoS Policy document\n   [QPIM]).\n   While it is not\
    \ a policy model per se, this document does have a\n   dependency on the Policy\
    \ Core Information Model Extensions document\n   [PCIME].  The device-level packet\
    \ filtering, through which a\n   Classifier splits a traffic stream into multiple\
    \ streams, is based on\n   the FilterEntryBase and FilterList classes defined\
    \ in [PCIME].\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in BCP\
    \ 14, RFC 2119\n   [R2119].\n"
- title: 1.1.  Policy Management Conceptual Model
  contents:
  - "1.1.  Policy Management Conceptual Model\n   The Policy Core Information Model\
    \ [PCIM] describes a general\n   methodology for constructing policy rules.  PCIM\
    \ Extensions [PCIME]\n   updates and extends the original PCIM.  A policy rule\
    \ aggregates a\n   set of policy conditions and an ordered set of policy actions.\
    \  The\n   semantics of a policy rule are such that if the set of conditions\n\
    \   evaluates to TRUE, then the set of actions are executed.\n   Policy conditions\
    \ and actions have two principal components: operands\n   and operators.  Operands\
    \ can be constants or variables. To specify a\n   policy, it is necessary to specify:\n\
    \   o  the operands to be examined (also known as state variables);\n   o  the\
    \ operands to be changed (also known as configuration\n      variables);\n   o\
    \  the relationships between these two sets of operands.\n   Operands can be specified\
    \ at a high-level, such as Joe (a user) or\n   Gold (a service).  Operands can\
    \ also be specified at a much finer\n   level of detail, one that is much closer\
    \ to the operation of the\n   device.  Examples of the latter include an IP Address\
    \ or a queue's\n   bandwidth allocation.  Implicit in the use of operands is the\
    \ binding\n   of legal values or ranges of values to an operand.  For example,\
    \ the\n   value of an IP address cannot be an integer.  The concepts of\n   operands\
    \ and their ranges are defined in [PCIME].\n   The second component of policy\
    \ conditions and actions is a set of\n   operators.  Operators can express both\
    \ relationships (greater than,\n   member of a set, Boolean OR, etc.) and assignments.\
    \  Together,\n   operators and operands can express a variety of conditions and\n\
    \   actions, such as:\n      If Bob is an Engineer...\n      If the source IP\
    \ address is in the Marketing Subnet...\n      Set Joe's IP address to 192.0.2.100\n\
    \      Limit the bandwidth of application x to 10 Mb\n   We recognize that the\
    \ definition of operator semantics is critical to\n   the definition of policies.\
    \  However, the definition of these\n   operators is beyond the scope of this\
    \ document.  Rather, this\n   document (with [QPIM]) takes the first steps in\
    \ identifying and\n   standardizing a set of properties (operands) for use in\
    \ defining\n   policies for Differentiated and Integrated Services.\n"
- title: 1.2.  Purpose and Relation to Other Policy Work
  contents:
  - "1.2.  Purpose and Relation to Other Policy Work\n   This model establishes a\
    \ canonical model of the QoS mechanisms of a\n   network device (e.g., a router,\
    \ switch, or host) that is independent\n   of any specific type of network device.\
    \  This enables traffic\n   conditioning to be described using a common set of\
    \ abstractions,\n   modeled as a set of services and sub-services.\n   When the\
    \ concepts of this document are used in conjunction with the\n   concepts of [QPIM],\
    \ one is able to define policies that bind the\n   services in a network to the\
    \ needs of applications using that\n   network.  In other words, the business\
    \ requirements of an\n   organization can be reflected in one set of policies,\
    \ and those\n   policies can be translated to a lower-level set of policies that\n\
    \   control and manage the configuration and operation of network\n   devices.\n"
- title: 1.3.  Typical Examples of Policy Usage
  contents:
  - "1.3.  Typical Examples of Policy Usage\n   Policies could be implemented as low-level\
    \ rules using the\n   information model described in this specification.  For\
    \ example, in a\n   low-level policy, a condition could be represented as an evaluation\n\
    \   of a specific attribute from this model.  Therefore, a condition such\n  \
    \ as \"If filter = HTTP\" would be interpreted as a test determining\n   whether\
    \ any HTTP filters have been defined for the device.  A high-\n   level policy,\
    \ such as \"If protocol = HTTP, then mark with\n   Differentiated Services Code\
    \ Point (DSCP) 24,\" would be expressed as\n   a series of actions in a low-level\
    \ policy using the classes and\n   attributes described below:\n   1.  Create\
    \ HTTP filter\n   2.  Create DSCP marker with the value of 24\n   3.  Bind the\
    \ HTTP filter to the DSCP marker\n   Note that unlike \"mark with DSCP 24,\" these\
    \ low-level actions are not\n   performed on a packet as it passes through the\
    \ device. Rather, they\n   are configuration actions performed on the device itself,\
    \ to make it\n   ready to perform the correct action(s) on the correct packet(s).\
    \  The\n   act of moving from a high-level policy rule to the correct set of\n\
    \   low-level device configuration actions is an example of what\n   [POLTERM]\
    \ characterizes as \"policy translation\" or \"policy\n   conversion\".\n"
- title: 2.  Approach
  contents:
  - "2.  Approach\n   QoS activities in the IETF have mainly focused in two areas,\n\
    \   Integrated Services (IntServ) and Differentiated Services (DiffServ)\n   (see\
    \ [POLTERM], [R1633] and [R2475]).  This document focuses on the\n   specification\
    \ of QoS properties and classes for modeling the datapath\n   where packet traffic\
    \ is conditioned. However, the framework defined\n   by the classes in this document\
    \ has been designed with the needs of\n   the admission control portion of IntServ\
    \ in mind as well.\n"
- title: 2.1.  Common Needs Of DiffServ and IntServ
  contents:
  - "2.1.  Common Needs Of DiffServ and IntServ\n   First, let us consider IntServ.\
    \  IntServ has two principal\n   components.  One component is embedded in the\
    \ datapath of the\n   networking device.  Its functions include the classification\
    \ and\n   policing of individual flows, and scheduling admitted packets for the\n\
    \   outbound link.  The other component of IntServ is admission control,\n   which\
    \ focuses on the management of the signaling protocol (e.g., the\n   PATH and\
    \ RESV messages of RSVP).  This component processes\n   reservation requests,\
    \ manages bandwidth, outsources decision making\n   to policy servers, and interacts\
    \ with the Routing Table manager.\n   We will consider RSVP when defining the\
    \ structure of this information\n   model.  As this document focuses on the datapath,\
    \ elements of RSVP\n   applicable to the datapath will be considered in the structure\
    \ of the\n   classes.  The complete IntServ device model will, as we have\n  \
    \ indicated earlier, be addressed in a subsequent document.\n   This document\
    \ models a small subset of the QoS policy problem, in\n   hopes of constructing\
    \ a methodology that can be adapted for other\n   aspects of QoS in particular,\
    \ and of policy construction in general.\n   The focus in this document is on\
    \ QoS for devices that implement\n   traffic conditioning in the datapath.\n \
    \  DiffServ operates exclusively in the datapath.  It has all of the\n   same\
    \ components of the IntServ datapath, with two major differences.\n   First, DiffServ\
    \ classifies packets based solely on their DSCP field,\n   whereas IntServ examines\
    \ a subset of a standard flow's addressing 5-\n   tuple.  The exception to this\
    \ rule occurs in a router or host at the\n   boundary of a DiffServ domain.  A\
    \ device in this position may examine\n   a packet's DSCP, its addressing 5-tuple,\
    \ other fields in the packet,\n   or even information wholly outside the packet,\
    \ in determining the\n   DSCP value with which to mark the packet prior to its\
    \ transfer into\n   the DiffServ domain.  However, routers in the interior of\
    \ a DiffServ\n   domain will only need to classify based on the DSCP field.\n\
    \   The second difference between IntServ and DiffServ is that the\n   signaling\
    \ protocol used in IntServ (e.g., RSVP) affects the\n   configuration of the datapath\
    \ in a more dynamic fashion.  This is\n   because each newly admitted RSVP reservation\
    \ requires a\n   reconfiguration of the datapath.  In contrast, DiffServ requires\
    \ far\n   fewer changes to the datapath after the Per Hop Behaviors (PHBs) have\n\
    \   been configured.\n   The approach advocated in this document for the creation\
    \ of policies\n   that control the various QoS mechanisms of networking devices\
    \ is to\n   first identify the attributes with which policies are to be\n   constructed.\
    \  These attributes are the parameters used in expressions\n   that are necessary\
    \ to construct policies.  There is also a parallel\n   desire to define the operators,\
    \ relations, and precedence constructs\n   necessary to construct the conditions\
    \ and actions that constitute\n   these policies.  However, these efforts are\
    \ beyond the scope of this\n   document.\n"
- title: 2.2.  Specific Needs Of DiffServ
  contents:
  - "2.2.  Specific Needs Of DiffServ\n   DiffServ-specific rules focus on two particular\
    \ areas: the core and\n   the edges of the network.  As explained in the DiffServ\
    \ Architecture\n   document [R2475], devices at the edge of the network classify\
    \ traffic\n   into different traffic streams.  The core of the network then\n\
    \   forwards traffic from different streams by using a set of Per Hop\n   Behaviors\
    \ (PHBs).  A DSCP identifies each PHB. The DSCP is part of\n   the IP header of\
    \ each packet (as described in [R2474]).  This enables\n   multiple traffic streams\
    \ to be aggregated into a small number of\n   aggregated traffic streams, where\
    \ each aggregate traffic stream is\n   identified by a particular DSCP, and forwarded\
    \ using a particular\n   PHB.\n   The attributes used to manipulate QoS capabilities\
    \ in the core of the\n   network primarily address the behavioral characteristics\
    \ of each\n   supported PHB.  At the edges of the DiffServ network, the additional\n\
    \   complexities of flow classification, policing, RSVP mappings,\n   remarkings,\
    \ and other factors have to be considered. Additional\n   modeling will be required\
    \ in this area.  However, first, the\n   standards for edges of the DiffServ network\
    \ need more detail - to\n   allow the edges to be incorporated into the policy\
    \ model.\n"
- title: 2.3.  Specific Needs Of IntServ
  contents:
  - "2.3.  Specific Needs Of IntServ\n   This document focuses exclusively on the\
    \ forwarding aspects of\n   network QoS.  Therefore, while the forwarding aspects\
    \ of IntServ are\n   considered, the management of IntServ is not considered.\
    \ This topic\n   will be addressed in a future document.\n"
- title: 3.  Methodology
  contents:
  - "3.  Methodology\n   There is a clear need to define attributes and behavior that\
    \ together\n   define how traffic should be conditioned.  This document defines\
    \ a\n   set of classes and relationships that represent the QoS mechanisms\n \
    \  used to condition traffic; [QPIM] is used to define policies to\n   control\
    \ the QoS mechanisms defined in this document.\n   However, some very basic issues\
    \ need to be considered when combining\n   these documents.  Considering these\
    \ issues should help in\n   constructing a schema for managing the operation and\
    \ configuration of\n   network QoS mechanisms through the use of QoS policies.\n"
- title: 3.1.  Level of Abstraction for Expressing QoS Policies
  contents:
  - "3.1.  Level of Abstraction for Expressing QoS Policies\n   The first issue requiring\
    \ consideration is the level of abstraction\n   at which QoS policies should be\
    \ expressed.  If we consider policies\n   as a set of rules used to react to events\
    \ and manipulate attributes\n   or generate new events, we realize that policy\
    \ represents a continuum\n   of specifications that relate business goals and\
    \ rules to the\n   conditioning of traffic done by a device or a set of devices.\
    \  An\n   example of a business level policy might be: from 1:00 pm PST to 7:00\n\
    \   am EST, sell off 40% of the network capacity on the open market.  In\n   contrast,\
    \ a device-specific policy might be: if the queue depth grows\n   at a geometric\
    \ rate over a specified duration, trigger a potential\n   link failure event.\n\
    \   A general model for this continuum is shown in Figure 1 below.\n   +---------------------+\n\
    \   | High-Level Business |    Not directly related to device\n   |     Policies\
    \        |    operation and configuration details\n   +---------------------+\n\
    \             |\n             |\n   +---------V-----------+\n   | Device-Independent\
    \  |    Translate high-level policies to\n   |       Policies      |    generic\
    \ device operational and\n   +---------------------+    configuration information\n\
    \             |\n             |\n   +---------V-----------+\n   |   Device-Dependent\
    \  |    Translate generic device information\n   |       Policies      |    to\
    \ specify how particular devices\n   +---------------------+    should operate\
    \ and be configured\n   Figure 1.  The Policy Continuum\n   High-level business\
    \ policies are used to express the requirements of\n   the different applications,\
    \ and prioritize which applications get\n   \"better\" treatment when the network\
    \ is congested.  The goal, then, is\n   to use policies to relate the operational\
    \ and configuration needs of\n   a device directly to the business rules that\
    \ the network\n   administrator is trying to implement in the network that the\
    \ device\n   belongs to.\n   Device-independent policies translate business policies\
    \ into a set of\n   generalized operational and configuration policies that are\n\
    \   independent of any specific device, but dependent on a particular set\n  \
    \ of QoS mechanisms, such as random early detection (RED) dropping or\n   weighted\
    \ round robin scheduling.  Not only does this enable different\n   types of devices\
    \ (routers, switches, hosts, etc.) to be controlled by\n   QoS policies, it also\
    \ enables devices made by different vendors that\n   use the same types of QoS\
    \ mechanisms to be controlled.  This enables\n   these different devices to each\
    \ supply the correct relative\n   conditioning to the same type of traffic.\n\
    \   In contrast, device-dependent policies translate device-independent\n   policies\
    \ into ones that are specific for a given device.  The reason\n   that a distinction\
    \ is made between device-independent and device-\n   dependent policies is that\
    \ in a given network, many different devices\n   having many different capabilities\
    \ need to be controlled together.\n   Device-independent policies provide a common\
    \ layer of abstraction for\n   managing multiple devices of different capabilities,\
    \ while device-\n   dependent policies implement the specific conditioning that\
    \ is\n   required.  This document provides a common set of abstractions for\n\
    \   representing QoS mechanisms in a device-independent way.\n   This document\
    \ is focused on the device-independent representation of\n   QoS mechanisms. \
    \ QoS mechanisms are modeled in sufficient detail to\n   provide a common device-independent\
    \ representation of QoS policies.\n   They can also be used to provide a basis\
    \ for specialization, enabling\n   each vendor to derive a set of vendor-specific\
    \ classes that represent\n   how traffic conditioning is done for that vendor's\
    \ set of devices.\n"
- title: 3.2.  Specifying Policy Parameters
  contents:
  - "3.2.  Specifying Policy Parameters\n   Policies are a function of parameters\
    \ (attributes) and operators\n   (boolean, arithmetic, relational, etc.).  Therefore,\
    \ both need to be\n   defined as part of the same policy in order to correctly\
    \ condition\n   the traffic.  If the parameters of the policy are specified too\n\
    \   narrowly, they will reflect the individual implementations of QoS in\n   each\
    \ device.  As there is currently little consensus in the industry\n   on what\
    \ the correct implementation model for QoS is, most defined\n   attributes would\
    \ only be applicable to the unique characteristics of\n   a few individual devices.\
    \  Moreover, standardizing all of these\n   potential implementation alternatives\
    \ would be a never-ending task as\n   new implementations continued to appear\
    \ on the market.\n   On the other hand, if the parameters of the policy are specified\
    \ too\n   broadly, it is impossible to develop meaningful policies. For\n   example,\
    \ if we concentrate on the so-called Olympic set of policies,\n   a business policy\
    \ like \"Bob gets Gold Service,\" is clearly\n   meaningless to the large majority\
    \ of existing devices. This is\n   because the device has no way of determining\
    \ who Bob is, or what QoS\n   mechanisms should be configured in what way to provide\
    \ Gold service.\n   Furthermore, Gold service may represent a single service,\
    \ or it may\n   identify a set of services that are related to each other. In\
    \ the\n   latter case, these services may have different conditioning\n   characteristics.\n\
    \   This document defines a set of parameters that fit into a canonical\n   model\
    \ for modeling the elements in the forwarding path of a device\n   implementing\
    \ QoS traffic conditioning.  By defining this model in a\n   device-independent\
    \ way, the needed parameters can be appropriately\n   abstracted.\n"
- title: 3.3.  Specifying Policy Services
  contents:
  - "3.3.  Specifying Policy Services\n   Administrators want the flexibility to be\
    \ able to define traffic\n   conditioning without having to have a low-level understanding\
    \ of the\n   different QoS mechanisms that implement that conditioning.\n   Furthermore,\
    \ administrators want the flexibility to group different\n   services together,\
    \ describing a higher-level concept such as \"Gold\n   Service\".  This higher-level\
    \ service could be viewed as providing the\n   processing to deliver \"Gold\"\
    \ quality of service.\n   These two goals dictate the need for the following set\
    \ of\n   abstractions:\n   o  a flexible way to describe a service\n   o  must\
    \ be able to group different services that may use different\n      technologies\
    \ (e.g., DiffServ and IEEE 802.1Q) together\n   o  must be able to define a set\
    \ of sub-services that together make up\n      a higher-level service\n   o  must\
    \ be able to associate a service and the set of QoS mechanisms\n      that are\
    \ used to condition traffic for that service\n   o  must be able to define policies\
    \ that manage the QoS mechanisms\n      used to implement a service.\n   This\
    \ document addresses this set of problems by defining a set of\n   classes and\
    \ associations that can represent abstract concepts like\n   \"Gold Service,\"\
    \ and bind each of these abstract services to a\n   specific set of QoS mechanisms\
    \ that implement the conditioning that\n   they require.  Furthermore, this document\
    \ defines the concept of\n   \"sub-services,\" to enable Gold Service to be defined\
    \ either as a\n   single service or as a set of services that together should\
    \ be\n   treated as an atomic entity.\n   Given these abstractions, policies (as\
    \ defined in [QPIM]) can be\n   written to control the QoS mechanisms and services\
    \ defined in this\n   document.\n"
- title: 3.4.  Level of Abstraction for Defining QoS Attributes and Classes
  contents:
  - "3.4.  Level of Abstraction for Defining QoS Attributes and Classes\n   This document\
    \ defines a set of classes and properties to support\n   policies that configure\
    \ device QoS mechanisms.  This document\n   concentrates on the representation\
    \ of services in the datapath that\n   support both DiffServ (for aggregate traffic\
    \ conditioning) and\n   IntServ (for flow-based traffic conditioning).  Classes\
    \ and\n   properties for modeling IntServ admission control services may be\n\
    \   defined in a future document.\n   The classes and properties in this document\
    \ are designed to be used\n   in conjunction with the QoS policy classes and properties\
    \ defined in\n   [QPIM].  For example, to preserve the delay characteristics committed\n\
    \   to an end-user, a network administrator may wish to create policies\n   that\
    \ monitor the queue depths in a device, and adjust resource\n   allocations when\
    \ delay budgets are at risk (perhaps as a result of a\n   network topology change).\
    \  The classes and properties in this\n   document define the specific services\
    \ and mechanisms required to\n   implement those services. The classes and properties\
    \ defined in\n   [QPIM] provide the overall structure of the policy that manages\
    \ and\n   configures this service.\n   This combination of low-level specification\
    \ (using this document) and\n   high-level structuring (using [QPIM]) of network\
    \ services enables\n   network administrators to define new services required\
    \ of the\n   network, that are directly related to business goals, while ensuring\n\
    \   that such services can be managed.  However, this goal (of creating\n   and\
    \ managing service-oriented policies) can only be realized if\n   policies can\
    \ be constructed that are capable of supporting diverse\n   implementations of\
    \ QoS.  The solution is to model the QoS\n   capabilities of devices at the behavioral\
    \ level. This means that for\n   traffic conditioning services realized in the\
    \ datapath, the model\n   must support the following characteristics:\n   o  modeling\
    \ of a generic network service that has QoS capabilities\n   o  modeling of how\
    \ the traffic conditioning itself is defined\n   o  modeling of how statistics\
    \ are gathered to monitor QoS traffic\n      conditioning services - this facet\
    \ of the model will be added in a\n      future document.\n   This document models\
    \ a network service, and associates it with one or\n   more QoS mechanisms that\
    \ are used to implement that service.  It also\n   models in a canonical form\
    \ the various components that are used to\n   condition traffic, such that standard\
    \ as well as custom traffic\n   conditioning services may be described.\n"
- title: 3.5.  Characterization of QoS Properties
  contents:
  - "3.5.  Characterization of QoS Properties\n   The QoS properties and classes will\
    \ be described in more detail in\n   Section 4.  However, we should consider the\
    \ basic characteristics of\n   these properties, to understand the methodology\
    \ for representing\n   them.\n   There are essentially two types of properties,\
    \ state and\n   configuration.  Configuration properties describe the desired\
    \ state\n   of a device, and include properties and classes for representing\n\
    \   desired or proposed thresholds, bandwidth allocations, and how to\n   classify\
    \ traffic.  State properties describe the actual state of the\n   device.  These\
    \ include properties to represent the current\n   operational values of the attributes\
    \ in devices configured via the\n   configuration properties, as well as properties\
    \ that represent state\n   (queue depths, excess capacity consumption, loss rates,\
    \ and so\n   forth).\n   In order to be correlated and used together, these two\
    \ types of\n   properties must be modeled using a common information model.  The\n\
    \   possibility of modeling state properties and their corresponding\n   configuration\
    \ settings is accomplished using the same classes in this\n   model - although\
    \ individual instances of the classes would have to be\n   appropriately named\
    \ or placed in different containers to distinguish\n   current state values from\
    \ desired configuration settings.\n   State information is addressed in a very\
    \ limited fashion by QDDIM.\n   Currently, only CurrentQueueDepth is proposed\
    \ as an attribute on\n   QueuingService.  The majority of the model is related\
    \ to\n   configuration.  Given this fact, it is assumed that this model is a\n\
    \   direct memory map into a device.  All manipulation of model classes\n   and\
    \ properties directly affects the state of the device.  If it is\n   desired to\
    \ also use these classes to represent desired configuration,\n   that is left\
    \ to the discretion of the implementor.\n   It is acknowledged that additional\
    \ properties are needed to\n   completely model current state.  However, many\
    \ of the properties\n   defined in this document represent exactly the state variables\
    \ that\n   will be configured by the configuration properties.  Thus, the\n  \
    \ definition of the configuration properties has an exact\n   correspondence with\
    \ the state properties, and can be used in modeling\n   both actual (state) and\
    \ desired/proposed configuration.\n"
- title: 3.6.  QoS Information Model Derivation
  contents:
  - "3.6.  QoS Information Model Derivation\n   The question of context also leads\
    \ to another question: how does the\n   information specified in the core and\
    \ QoS policy models ([PCIM],\n   [PCIME], and [QPIM], respectively) integrate\
    \ with the information\n   defined in this document?  To put it another way, where\
    \ should\n   device-independent concepts that lead to device-specific QoS\n  \
    \ attributes be derived from?\n   Past thinking was that QoS was part of the policy\
    \ model.  This view\n   is not completely accurate, and it leads to confusion.\
    \  QoS is a set\n   of services that can be controlled using policy.  These services\
    \ are\n   represented as device mechanisms.  An important point here is that\n\
    \   QoS services, as well as other types of services (e.g., security),\n   are\
    \ provided by the mechanisms inherent in a given device.  This\n   means that\
    \ not all devices are indeed created equal.  For example,\n   although two devices\
    \ may have the same type of mechanism (e.g., a\n   queue), one may be a simple\
    \ implementation (i.e., a FIFO queue)\n   whereas one may be much more complex\
    \ and robust (e.g., class-based\n   weighted fair queuing (CBWFQ)).  However,\
    \ both of these devices can\n   be used to deliver QoS services, and both need\
    \ to be controlled by\n   policy.  Thus, a device-independent policy can instruct\
    \ the devices\n   to queue certain traffic, and a device-specific policy can be\
    \ used to\n   control the queuing in each device.\n   Furthermore, policy is used\
    \ to control these mechanisms, not to\n   represent them.  For example, QoS services\
    \ are implemented with\n   classifiers, meters, markers, droppers, queues, and\
    \ schedulers.\n   Similarly, security is also a characteristic of devices, as\n\
    \   authentication and encryption capabilities represent services that\n   networked\
    \ devices perform (irrespective of interactions with policy\n   servers).  These\
    \ security services may use some of the same\n   mechanisms that are used by QoS\
    \ services, such as the concepts of\n   filters.  However, they will mostly require\
    \ different mechanisms than\n   the ones used by QoS, even though both sets of\
    \ services are\n   implemented in the same devices.\n   Thus, the similarity between\
    \ the QoS model and models for other\n   services is not so much that they contain\
    \ a few common mechanisms.\n   Rather, they model how a device implements their\
    \ respective services.\n   As such, the modeling of QoS should be part of a networking\
    \ device\n   schema rather than a policy schema.  This allows the networking\n\
    \   device schema to concentrate on modeling device mechanisms, and the\n   policy\
    \ schema to focus on the semantics of representing the policy\n   itself (conditions,\
    \ actions, operators, etc.).  While this document\n   concentrates on defining\
    \ an information model to represent QoS\n   services in a device datapath, the\
    \ ultimate goal is to be able to\n   apply policies that control these services\
    \ in network devices.\n   Furthermore, these two schemata (device and policy)\
    \ must be tightly\n   integrated in order to enable policy to control QoS services.\n"
- title: 3.7.  Attribute Representation
  contents:
  - "3.7.  Attribute Representation\n   The last issue to be considered is the question\
    \ of how attributes are\n   represented.  If QoS attributes are represented as\
    \ absolute numbers\n   (e.g., Class AF2 gets 2 Mbs of bandwidth), it is more difficult\
    \ to\n   make them uniform across multiple ports in a device or across\n   multiple\
    \ devices, because of the broad variation in link capacities.\n   However, expressing\
    \ attributes in relative or proportional terms\n   (e.g., Class AF2 gets 5% of\
    \ the total link bandwidth) makes it more\n   difficult to express certain types\
    \ of conditions and actions, such\n   as:\n      (If ConsumedBandwidth = AssignedBandwidth\
    \ Then ...)\n   There are really three approaches to addressing this problem:\n\
    \   o  Multiple properties can be defined to express the same value in\n     \
    \ various forms.  This idea has been rejected because of the\n      difficulty\
    \ in keeping these different properties synchronized\n      (e.g., when one property\
    \ changes, the others all have to be\n      updated).\n   o  Multi-modal properties\
    \ can be defined to express the same value,\n      in different terms, based on\
    \ the access or assignment mode.  This\n      option was rejected because it significantly\
    \ complicates the model\n      and is impossible to express in current directory\
    \ access protocols\n      (e.g., (L)DAP).\n   o  Properties can be expressed as\
    \ \"absolutes\", but the operators in\n      the policy schema would need to be\
    \ more sophisticated.  Thus, to\n      represent a percentage, division and multiplication\
    \ operators are\n      required (e.g., Class AF2 gets .05 * the total link bandwidth).\n\
    \      This is the approach that has been taken in this document.\n"
- title: 3.8.  Mental Model
  contents:
  - "3.8.  Mental Model\n   The mental model for constructing this schema is based\
    \ on the work\n   done in the Differentiated Services working group.  This schema\
    \ is\n   based on information provided in the current versions of the DiffServ\n\
    \   Informal Management Model [DSMODEL], the DiffServ MIB [DSMIB], the\n   PIB\
    \ [PIB], as well as on information in the set of RFCs that\n   constitute the\
    \ basic definition of DiffServ itself ([R2475], [R2474],\n   [R2597], and [R3246]).\
    \  In addition, a common set of terminology is\n   available in [POLTERM].\n \
    \  This model is built around two fundamental class hierarchies that are\n   bound\
    \ together using a set of associations.  The two class\n   hierarchies derive\
    \ from the QoSService and ConditioningService base\n   classes.  A set of associations\
    \ relate lower-level QoSService\n   subclasses to higher-level QoS services, relate\
    \ different types of\n   conditioning services together in processing a traffic\
    \ class, and\n   relate a set of conditioning services to a specific QoS service.\n\
    \   This combination of associations enables us to view the device as\n   providing\
    \ a set of services that can be configured, in a modular\n   building block fashion,\
    \ to construct application-specific services.\n   Thus, this document can be used\
    \ to model existing and future standard\n   as well as application-specific network\
    \ QoS services.\n"
- title: 3.8.1.  The QoSService Class
  contents:
  - "3.8.1.  The QoSService Class\n   The first of the classes defined here, QoSService,\
    \ is used to\n   represent higher-level network services that require special\n\
    \   conditioning of their traffic.  An instance of QoSService (or one of\n   its\
    \ subclasses) is used to bring together a group of conditioning\n   services that,\
    \ from the perspective of the system manager, are all\n   used to deliver a common\
    \ service.  Thus, the set of classifiers,\n   markers, and related conditioning\
    \ services that provide premium\n   service to the \"selected\" set of user traffic\
    \ may be grouped together\n   into a premium QoS service.\n   QoSService has a\
    \ set of subclasses that represent different\n   approaches to delivering IP services.\
    \  The currently defined set of\n   subclasses are a FlowService for flow-oriented\
    \ QoS delivery and a\n   DiffServService for DiffServ aggregate-oriented QoS service\
    \ delivery.\n   The QoS services can be related to each other as peers, or they\
    \ can\n   be implemented as subservient services to each other.  The\n   QoSSubService\
    \ aggregation indicates that one or more QoSService\n   objects are subservient\
    \ to a particular QoSService object.  For\n   example, this enables us to define\
    \ Gold Service as a combination of\n   two DiffServ services, one for high quality\
    \ traffic treatment, and\n   one for servicing the rest of the traffic.  Each\
    \ of these\n   DiffServService objects would be associated with a set of\n   classifiers,\
    \ markers, etc, such that the high quality traffic would\n   get EF marking and\
    \ appropriate queuing.\n   The DiffServService class itself has an AFService subclass.\
    \  This\n   subclass is used to represent the specific notion that several\n \
    \  related markings within the AF PHB Group work together to provide a\n   single\
    \ service.  When other DiffServ PHB Groups are defined that use\n   more than\
    \ one code point, these will be likely candidates for\n   additional DiffServService\
    \ subclasses.\n   Technology-specific mappings of these services, representing\
    \ the\n   specific use of PHB marking or 802.1Q marking, are captured within\n\
    \   the ConditioningService hierarchy, rather than in the subclasses of\n   QoSService.\n\
    \   These concepts are depicted in Figure 2.  Note that both of the\n   associations\
    \ are aggregations: a QoSService object aggregates both\n   the set of QoSService\
    \ objects subservient to it, and the set of\n   ConditioningService objects that\
    \ realize it.  See Section 4 for class\n   and association definitions.\n    \
    \            /\\______\n           0..1 \\/      |\n   +--------------+     |\
    \ QoSSubService     +---------------+\n   |              |0..n |             \
    \      |               |\n   |  QoSService  |-----                    | Conditioning\
    \  |\n   |              |                         |   Service     |\n   |    \
    \          |                         |               |\n   |              |0..n\
    \                 0..n|               |\n   |              | /\\______________________|\
    \               |\n   |              | \\/  QoSConditioning     |            \
    \   |\n   +--------------+       SubService        +---------------+\n   Figure\
    \ 2.  QoSService and its Aggregations\n"
- title: 3.8.2.  The ConditioningService Class
  contents:
  - "3.8.2.  The ConditioningService Class\n   The goal of the ConditioningService\
    \ classes is to describe the\n   sequence of traffic conditioning that is applied\
    \ to a given traffic\n   stream on the ingress interface through which it enters\
    \ a device, and\n   then on the egress interface through which it leaves the device.\n\
    \   This is done using a set of classes and relationships.  The routing\n   decision\
    \ in the device core, which selects which egress interface a\n   particular packet\
    \ will use, is not represented in this model.\n   A single base class, ConditioningService,\
    \ is the superclass for a set\n   of subclasses representing the mechanisms that\
    \ condition traffic.\n   These subclasses define device-independent conditioning\
    \ primitives\n   (including classifiers, meters, markers, droppers, queues, and\n\
    \   schedulers) that together implement the conditioning of traffic on an\n  \
    \ interface.  This model abstracts these services into a common set of\n   modular\
    \ building blocks that can be used, regardless of device\n   implementation, to\
    \ model the traffic conditioning internal to a\n   device.\n   The different conditioning\
    \ mechanisms need to be related to each\n   other to describe how traffic is conditioned.\
    \  Several important\n   variations of how these services are related together\
    \ exist:\n   o  A particular ingress or egress interface may not require all the\n\
    \      types of ConditioningServices.\n   o  Multiple instances of the same mechanism\
    \ may be required on an\n      ingress or egress interface.\n   o  There is no\
    \ set order of application for the ConditioningServices\n      on an ingress or\
    \ egress interface.\n   Therefore, this model does not dictate a fixed ordering\
    \ among the\n   subclasses of ConditioningService, or identify a subclass of\n\
    \   ConditioningService that must appear first or last among the\n   ConditioningServices\
    \ on an ingress or egress interface.  Instead,\n   this model ties together the\
    \ various ConditioningService instances on\n   an ingress or egress interface\
    \ using the NextService,\n   NextServiceAfterMeter, and NextServiceAfterConditioningElement\n\
    \   associations.  There are also separate associations, called\n   IngressConditioningServiceOnEndpoint\
    \ and\n   EgressConditioningServiceOnEndpoint, which, respectively, tie an\n \
    \  ingress interface to its first ConditioningService, and tie an egress\n   interface\
    \ to its last ConditioningService(s).\n"
- title: 3.8.3.  Preserving QoS Information from Ingress to Egress
  contents:
  - "3.8.3.  Preserving QoS Information from Ingress to Egress\n   There is one important\
    \ way in which the QDDIM model diverges from the\n   [DSMODEL].  In [DSMODEL],\
    \ traffic passes through a network device in\n   three stages:\n   o  It comes\
    \ in on an ingress interface, where it may receive QoS\n      conditioning.\n\
    \   o  It traverses the routing core, where logic outside the scope of\n     \
    \ QoS determines which egress interface it will use to leave the\n      device.\n\
    \   o  It may receive further QoS conditioning on the selected egress\n      interface,\
    \ and then it leaves the device.\n   In this model, no information about the QoS\
    \ conditioning that a\n   packet receives on the ingress interface is communicated\
    \ with the\n   packet across the routing core to the egress interface.\n   The\
    \ QDDIM model relaxes this restriction, to allow information about\n   the treatment\
    \ that a packet received on an ingress interface to be\n   communicated along\
    \ with the packet to the egress interface.  (This\n   relaxation adds a capability\
    \ that is present in many network\n   devices.)  QDDIM represents this information\
    \ transfer in terms of a\n   packet preamble, which is how many devices implement\
    \ it.  But\n   implementations are free to use other mechanisms to achieve the\
    \ same\n   result.\n       +---------+\n       | Meter-A |\n    a  |         |\
    \ b      d\n   --->|      In-|---PM-1--->\n       |         | c      e\n     \
    \  |     Out-|---PM-2--->\n       +---------+\n   Figure 3:  Meter Followed by\
    \ Two Preamble Markers\n   Figure 3 shows an example in which meter results are\
    \ captured in a\n   packet preamble.  The arrows labeled with single letters represent\n\
    \   instances of either the NextService association (a, d, and e), or of\n   its\
    \ peer association NextServiceAfterMeter (b and c).  PreambleMarker\n   PM-1 adds\
    \ to the packet preamble an indication that the packet exited\n   Meter A as conforming\
    \ traffic. Similarly, PreambleMarker PM-2 adds to\n   the preambles of packets\
    \ that come through it indications that they\n   exited Meter A as nonconforming\
    \ traffic.  A PreambleMarker appends\n   its information to whatever is already\
    \ present in a packet preamble,\n   as opposed to overwriting what is already\
    \ there.\n   To foster interoperability, the basic format of the information\n\
    \   captured by a PreambleMarker is specified.  (Implementations, of\n   course,\
    \ are free to represent this information in a different way\n   internally - this\
    \ is just how it is represented in the model.) The\n   information is represented\
    \ by an ordered, multi-valued string\n   property FilterItemList, where each individual\
    \ value of the property\n   is of the form \"<type>,<value>\".  When a PreambleMarker\
    \ \"appends\" its\n   information to the information that was already present\
    \ in a packet\n   preamble, it does so by adding additional items of the indicated\n\
    \   format to the end of the list.\n   QDDIM provides a limited set of <type>'s\
    \ that a PreambleMarker may\n   use:\n   o  ConformingFromMeter: the value is\
    \ the name of the meter.\n   o  PartConformingFromMeter: the value is the name\
    \ of the meter.\n   o  NonConformingFromMeter: the value is the name of the meter.\n\
    \   o  VlanId: the value is the virtual LAN identifier (VLAN ID).\n   Implementations\
    \ may recognize other <type>'s in addition to these.\n   If collisions of implementation-specific\
    \ <type>'s become a problem,\n   it is possible that <type>'s may become an IANA-administered\
    \ range in\n   a future revision of this document.\n   To make use of the information\
    \ that a PreambleMarker stores in a\n   packet preamble, a specific subclass PreambleFilter\
    \ of\n   FilterEntryBase is defined, to match on the \"<type>,<value>\" strings.\n\
    \   To simplify the case where there's just a single level of metering in\n  \
    \ a device, but different individual meters on each ingress interface,\n   PreambleFilter\
    \ allows a wildcard \"any\" for the <value> part of the\n   three meter-related\
    \ filters.  With this wildcard, an administrator\n   can specify a Classifier\
    \ to select all packets that were found to be\n   conforming (or partially conforming,\
    \ or non-conforming) by their\n   respective meters, without having to name each\
    \ meter individually in\n   a separate ClassifierElement.\n   Once a meter result\
    \ has been stored in a packet preamble, it is\n   available for any subsequent\
    \ Classifier to use.  So while the\n   motivation for this capability has been\
    \ described in terms of\n   preserving QoS conditioning information from an ingress\
    \ interface to\n   an egress interface, a prior meter result may also be used\
    \ for\n   classifying packets later in the datapath on the same interface where\n\
    \   the meter resides.\n"
- title: 3.9.  Classifiers, FilterLists, and Filter Entries
  contents:
  - "3.9.  Classifiers, FilterLists, and Filter Entries\n   This document uses a number\
    \ of classes to model the classifiers\n   defined in [DSMODEL]: ClassifierService,\
    \ ClassifierElement,\n   FilterList, FilterEntryBase, and various subclasses of\n\
    \   FilterEntryBase.  There are also two associations involved:\n   ClassifierElementUsesFilterList\
    \ and EntriesInFilterList.  The QDDIM\n   model makes no use of CIM's FilterEntry\
    \ class.\n   In [DSMODEL], a single traffic stream coming into a classifier is\n\
    \   split into multiple traffic streams leaving it, based on which of an\n   ordered\
    \ set of filters each packet in the incoming stream matches.  A\n   filter matches\
    \ either a field in the packet itself, or possibly other\n   attributes associated\
    \ with the packet.  In the case of a multi-field\n   (MF) classifier, packets\
    \ are assigned to output streams based on the\n   contents of multiple fields\
    \ in the packet header.  For example, an MF\n   classifier might assign packets\
    \ to an output stream based on their\n   complete IP-addressing 5-tuple.\n   To\
    \ optimize the representation of MF classifiers, subclasses of\n   FilterEntryBase\
    \ are introduced, which allow multiple related packet\n   header fields to be\
    \ represented in a single object.  These subclasses\n   are IPHeaderFilter and\
    \ 8021Filter.  With IPHeaderFilter, for example,\n   criteria for selecting packets\
    \ based on all five of the IP 5-tuple\n   header fields and the DiffServ DSCP\
    \ can be represented by a\n   FilterList containing one IPHeaderFilter object.\
    \  Because these two\n   classes have applications beyond those considered in\
    \ this document,\n   they, as well as the abstract class FilterEntryBase, are\
    \ defined in\n   the more general document [PCIME] rather than here.\n   The FilterList\
    \ object is always needed, even if it contains only one\n   filter entry (that\
    \ is, one FilterEntryBase subclass) object. This is\n   because a ClassifierElement\
    \ can only be associated with a Filter\n   List, as opposed to an individual FilterEntry.\
    \  FilterList is also\n   defined in [PCIME].\n   The EntriesInFilterList aggregation\
    \ (also defined in [PCIME]) has a\n   property EntrySequence, which in the past\
    \ (in CIM) could be used to\n   specify an evaluation order on the filter entries\
    \ in a FilterList.\n   Now, however, the EntrySequence property supports only\
    \ a single\n   value: '0'.  This value indicates that the FilterEntries are ANDed\n\
    \   together to determine whether a packet matches the MF selector that\n   the\
    \ FilterList represents.\n   A ClassifierElement specifies the starting point\
    \ for a specific\n   policy or data path.  Each ClassifierElement uses the\n \
    \  NextServiceAfterClassifierElement association to determine the next\n   conditioning\
    \ service to apply for packets to.\n   A ClassifierService defines a grouping\
    \ of ClassifierElements. There\n   are certain instances where a ClassifierService\
    \ actually specifies an\n   aggregation of ClassifierServices.  One practical\
    \ case would be where\n   each ClassifierService specifies a group of policies\
    \ associated with\n   a particular application and another ClassifierService groups\
    \ the\n   application-specific ClassifierService instances.  In this particular\n\
    \   case, the application-specific ClassifierService instances are\n   specified\
    \ once, but unique combinations of these ClassifierServices\n   are specified,\
    \ as needed, using other ClassifierService instances.\n   ClassifierService instances\
    \ grouping other ClassifierService\n   instances may not specify a FilterList\
    \ using the\n   ClassifierElementUsesFilterList association.  This special use\
    \ of\n   ClassifierService serves just as a Classifier collecting function.\n"
- title: 3.10.  Modeling of Droppers
  contents:
  - "3.10.  Modeling of Droppers\n   In [DSMODEL], a distinction is made between absolute\
    \ droppers and\n   algorithmic droppers.  In QDDIM, both of these types of droppers\
    \ are\n   modeled with the DropperService class, or with one of its subclasses.\n\
    \   In both cases, the queue from which the dropper drops packets is tied\n  \
    \ to the dropper by an instance of the NextService association.  The\n   dropper\
    \ always plays the PrecedingService role in these associations,\n   and the queue\
    \ always plays the FollowingService role.  There is\n   always exactly one queue\
    \ from which a dropper drops packets.\n   Since an absolute dropper drops all\
    \ packets in its queue, it needs no\n   configuration beyond a NextService tie\
    \ to that queue. For an\n   algorithmic dropper, however, further configuration\
    \ is needed:\n   o  a specific drop algorithm;\n   o  parameters for the algorithm\
    \ (for example, token bucket size);\n   o  the source(s) of input(s) to the algorithm;\n\
    \   o  possibly per-input parameters for the algorithm.\n   The first two of these\
    \ items are represented by properties of the\n   DropperService class, or properties\
    \ of one of its subclasses. The\n   last two, however, involve additional classes\
    \ and associations.\n"
- title: 3.10.1.  Configuring Head and Tail Droppers
  contents:
  - "3.10.1.  Configuring Head and Tail Droppers\n   The HeadTailDropQueueBinding\
    \ is the association that identifies the\n   inputs for the algorithm executed\
    \ by a tail dropper.  This\n   association is not used for a head dropper, because\
    \ a head dropper\n   always has exactly one input to its drop algorithm, and this\
    \ input is\n   always the queue from which it drops packets.  For a tail dropper,\n\
    \   this association is defined to have a many-to-many cardinality.\n   There\
    \ are, however, two distinct cases:\n   One dropper bound to many queues: This\
    \ represents the case where the\n   drop algorithm for the dropper involves inputs\
    \ from more than one\n   queue.  The dropper still drops from only one queue,\
    \ the one to which\n   it is tied by a NextService association.  But the drop\
    \ decision may\n   be influenced by the state of several queues.  For the classes\n\
    \   HeadTailDropper and HeadTailDropQueueBinding, the rule for combining\n   the\
    \ multiple inputs is simple addition: if the sum of the lengths of\n   the monitored\
    \ queues exceeds the dropper's QueueThreshold value, then\n   packets are dropped.\
    \  This rule for combining inputs may, however, be\n   overridden by a different\
    \ rule in subclasses of one or both of these\n   classes.\n   One queue bound\
    \ to many droppers: This represents the case where the\n   state of one queue\
    \ (which is typically also the queue from which\n   packets are dropped) provides\
    \ an input to multiple droppers' drop\n   algorithms.  A use case here is a classifier\
    \ that splits a traffic\n   stream into, say, four parts, representing four classes\
    \ of traffic.\n   Each of the parts goes through a separate HeadTailDropper, then\n\
    \   they're re-merged onto the same queue.  The net is a single queue\n   containing\
    \ packets of four traffic types, with, say, the following\n   drop thresholds:\n\
    \      o    Class 1 - 90% full\n      o    Class 2 - 80% full\n      o    Class\
    \ 3 - 70% full\n      o    Class 4 - 50% full\n   Here the percentages represent\
    \ the overall state of the queue. With\n   this configuration, when the queue\
    \ in question becomes 50% full,\n   Class 4 packets will be dropped rather than\
    \ joining the queue, when\n   it becomes 70% full, Class 3 and 4 packets will\
    \ be dropped, etc.\n   The two cases described here can also occur together, if\
    \ a dropper\n   receives inputs from multiple queues, one or more of which are\
    \ also\n   providing inputs to other droppers.\n"
- title: 3.10.2.  Configuring RED Droppers
  contents:
  - "3.10.2.  Configuring RED Droppers\n   Like a tail dropper, a RED dropper, represented\
    \ by an instance of the\n   REDDropperService class, may take as its inputs the\
    \ states of\n   multiple queues.  In this case, however, there is an additional\
    \ step:\n   each of these inputs may be smoothed before the RED dropper uses it,\n\
    \   and the smoothing process itself must be parameterized. Consequently,\n  \
    \ in addition to REDDropperService and QueuingService, a third class,\n   DropThresholdCalculationService,\
    \ is introduced, to represent the\n   per-queue parameterization of this smoothing\
    \ process.\n   The following instance diagram illustrates how these classes work\n\
    \   with each other:\n           RDSvc-A\n           |  |  |\n     +-----+  |\
    \  +-----+\n     |        |        |\n   DTCS-1   DTCS-2   DTCS-3\n     |    \
    \    |        |\n    Q-1      Q-2      Q-3\n   Figure 4. Inputs for a RED Dropper\n\
    \   So REDDropperService-A (RDSvc-A) is using inputs from three queues to\n  \
    \ make its drop decision.  (As always, RDSvc-A is linked to the queue\n   from\
    \ which it drops packets via the NextService association.)  For\n   each of these\
    \ three queues, there is a\n   (DropThresholdCalculationService) DTCS instance\
    \ that represents the\n   smoothing weight and time interval to use when looking\
    \ at that queue.\n   Thus each DTCS instance is tied to exactly one queue, although\
    \ a\n   single queue may be examined (with different weight and time values)\n\
    \   by multiple DTCS instances.  Also, a DTCS instance and the queue\n   behind\
    \ it can be thought of as a \"unit of reusability\".  So a single\n   DTCS can\
    \ be referred to by multiple RDSvc's.\n   Unless it is overridden by a different\
    \ rule in a subclass of\n   REDDropperService, the rule that a RED dropper uses\
    \ to combine the\n   smoothed inputs from the DTCS's to create a value to use\
    \ in making\n   its drop decision is simple addition.\n"
- title: 3.11.  Modeling of Queues and Schedulers
  contents:
  - "3.11.  Modeling of Queues and Schedulers\n   In order to appreciate the rationale\
    \ behind this rather complex model\n   for scheduling, we must consider the rather\
    \ complex nature of\n   schedulers, as well as the extreme variations in algorithms\
    \ and\n   implementations.  Although these variations are broad, we have\n   identified\
    \ four examples that serve to test the model and justify its\n   complexity.\n"
- title: 3.11.1.  Simple Hierarchical Scheduler
  contents:
  - "3.11.1.  Simple Hierarchical Scheduler\n   A simple, hierarchical scheduler has\
    \ the following properties. First,\n   when a scheduling opportunity is given\
    \ to a set of queues, a single,\n   viable queue is determined based on some scheduling\
    \ criteria, such as\n   bandwidth or priority.  The output of the scheduler is\
    \ the input to\n   another scheduler that treats the first scheduler (and its\
    \ queues) as\n   a single logical queue.  Hence, if the first scheduler determined\
    \ the\n   appropriate packet to release based on a priority assigned to each\n\
    \   queue, the second scheduler might specify a bandwidth\n   limit/allocation\
    \ for the entire set of queues aggregated by the first\n   scheduler.\n   +----------+\
    \                              NextService\n   |QueuingSvc+----------------------------------------------+\n\
    \   | Name=EF1 |                                              |\n   |        \
    \  | QueueTo    +--------------+ ElementSched     |\n   |          +------------+PrioritySched\
    \ +---------------+  |\n   +----------+ Schedule   |Element       | Service  \
    \     |  |\n                           | Name=EF1-Pri |               |  v\n \
    \                          | Priority=1   |    +-----------+-+-+\n           \
    \                +--------------+    |SchedulingSvc  +\n                     \
    \                          | Name=PriSched1+\n                           +--------------+\
    \    +----------+--+-+\n                           |PrioritySched | ElementSched\
    \  |  ^\n   +----------+            |Element       +---------------+  |\n   |QueuingSvc|\
    \ QueueTo    | Name=AF1x-Pri| Service          |\n   | Name=AF1x+------------+\
    \ Priority=2   |                  |\n   |          | Schedule   +--------------+\
    \                  |\n   |          |                              NextService\
    \     |\n   |          +----------------------------------------------+\n   +----------+\n\
    \   :\n   +---------------+            NextScheduler\n   |SchedulingSvc  +--------------------------------------------+\n\
    \   | Name=PriSched1|                                            |\n   +-------+-------+\
    \       +--------------------+ElementSchedSvc|\n           | SchedToSched  |AllocationScheduling+--------+\
    \      |\n           +---------------+Element             |        |      |\n\
    \                           | Name=PriSched1-Band|        |      |\n         \
    \                  | Units=Bytes        |        |      v\n                  \
    \         | Bandwidth=100      | +------+------+--+\n                        \
    \   +--------------------+ |SchedulingSvc   |\n                              \
    \                    | Name=BandSched1|\n                           +--------------------+\
    \ +------+------+--+\n                           |AllocationScheduling|      \
    \  |      ^\n   +---------------+       |Element             +--------+      |\n\
    \   |QueuingService |       | Name=BE-Band       |ElementSchedSvc|\n   | Name=BE\
    \       |QueueTo+ Units=Bytes        |               |\n   |               |-------+\
    \ Bandwidth=50       |               |\n   |               |Sched  +--------------------+\
    \               |\n   |               |                             NextService\
    \    |\n   |               +--------------------------------------------+\n  \
    \ +---------------+\n   Figure 5. Example 1: Simple Hierarchical Scheduler\n \
    \  Figure 5 illustrates the example and how it would be instantiated\n   using\
    \ the model.  In the figure, NextService determines the first\n   scheduler after\
    \ the queue.  NextScheduler determines the\n   subsequent ordering of schedulers.\
    \  In addition, the\n   ElementSchedulingService association determines the set\
    \ of\n   scheduling parameters used by a specific scheduler.  Scheduling\n   parameters\
    \ can be bound either to queues or to schedulers.  In\n   the case of the SchedulingElement\
    \ EF1-Pri, the binding is to a\n   queue, so the QueueToSchedule association is\
    \ used.  In the case\n   of the SchedulingElement PriSched1-Band, the binding\
    \ is to\n   another scheduler, so the SchedulerToSchedule association is\n   used.\
    \  Note that due to space constraints of the document, the\n   SchedulingService\
    \ PRISched1 is represented twice, to show how it\n   is connected to all the other\
    \ objects.\n"
- title: 3.11.2.  Complex Hierarchical Scheduler
  contents:
  - "3.11.2.  Complex Hierarchical Scheduler\n   A complex, hierarchical scheduler\
    \ has the same characteristics as\n   a simple scheduler, except that the criteria\
    \ for the second\n   scheduler are determined on a per queue basis rather than\
    \ on an\n   aggregate basis.  One scenario might be a set of bounded priority\n\
    \   schedulers.  In this case, each queue is assigned a relative\n   priority.\
    \  However, each queue is also not allowed to exceed a\n   bandwidth allocation\
    \ that is unique to that queue.  In order to\n   support this scenario, the queue\
    \ must be bound to two separate\n   schedulers.  Figure 6 illustrates this situation,\
    \ by describing\n   an EF queue and a best effort (BE) queue both pointing to\
    \ a\n   priority scheduler via the NextService association.  The\n   NextScheduler\
    \ association between the priority scheduler and the\n   bandwidth scheduler in\
    \ turn defines the ordering of the\n   scheduling hierarchy.  Also note that each\
    \ scheduler has a\n   distinct set of scheduling parameters that are bound back\
    \ to each\n   queue.  This demonstrates the need to support two or more\n   parameter\
    \ sets on a per queue basis.\n   +----------------+\n   |QueuingService  |\n \
    \  | Name=EF        |\n   |                |QueueTo   +----------------+ElementSchedSvc\n\
    \   |                +----------+AllocationSched +--------+\n   ++---+-----------+Schedule\
    \  |Element         |        |\n    |   |                      | Name=BandEF \
    \   |        |\n    |   |QueueTo               | Units=Bytes    |        |\n \
    \   |   |Schedule              | Bandwidth=100  |        |\n    |   |        \
    \              +----------------+ +------+---------+\n    |   |              \
    \                           |SchedulingSvc   |\n    |   |      +------------------+\
    \               | Name=BandSched |\n    |   +------+PriorityScheduling|      \
    \         +------------+--++\n    |          |Element           |            \
    \                ^  |\n    |          | Name=PriEF       |ElementSchedSvc    \
    \         |  |\n    |          | Priority=1       +---------------------+    \
    \  |  |\n    |          +------------------+                     |      |  |\n\
    \    |NextService                                        |      |  |\n    +-------------------------------------------------+\
    \ |      |  |\n                                                      | |     \
    \ |  |\n     NextService                                      | |      |  |\n\
    \    +-----------------------------------------------+ | |      |  |\n    |  \
    \                                             | | |      |  |\n    |         \
    \ +------------------+ElementSchedSvc  | | |      |  |\n    |          |PriorityScheduling+--------+\
    \        | | |      |  |\n    |          |Element           |        |       \
    \ | | |      |  |\n    |          | Name=PriBE       |        |        v v | \
    \     |  |\n    |   +------+ Priority=2       |    +---+--------+-+-+-+Next| \
    \ |\n    |   |      +------------------+    |SchedulingService +----+  |\n   \
    \ |   |                              | Name=PriSched    |Sched  |\n    |   | \
    \                             +------------------+       |\n    |   |QueueTo \
    \                                                 |\n    |   |Schedule       \
    \       +----------------+                 |\n    |   |                      |AllocationSched\
    \ |ElementSchedSvc  |\n   +----+---------+            |Element         +-----------------+\n\
    \   |QueuingService|QueueTo     | Name=BandBE    |\n   | Name=BE      +------------+\
    \ Units=Bytes    |\n   |              |Schedule    | Bandwidth=50   |\n   |  \
    \            |            +----------------+\n   +--------------+\n   Figure 6.\
    \ Example 2: Complex Hierarchical Scheduler\n"
- title: 3.11.3.  Excess Capacity Scheduler
  contents:
  - "3.11.3.  Excess Capacity Scheduler\n   An excess capacity scheduler offers a\
    \ similar requirement to support\n   two scheduling parameter sets per queue.\
    \  However, in this scenario\n   the reasons are a little different.  Suppose\
    \ a set of queues have\n   each been assigned bandwidth limits to ensure that\
    \ no traffic class\n   starves out another traffic class.  The result may be that\
    \ one or\n   more queues have exceeded their allocation while the queues that\n\
    \   deserve scheduling opportunities are empty.\n   The question then is how is\
    \ the excess (idle) bandwidth allocated.\n   Conceivably, the scheduling criteria\
    \ for excess capacity are\n   completely different from the criteria that determine\
    \ allocations\n   under uniform load.  This could be supported with a scheduling\n\
    \   hierarchy.  However, the problem is that the criteria for using the\n   subsequent\
    \ scheduler are different from those in the last two cases.\n   Specifically,\
    \ the next scheduler should only be used if a scheduling\n   opportunity exists\
    \ that was passed over by the prior scheduler.\n   When a scheduler chooses to\
    \ forgo a scheduling decision, it is\n   behaving as a non-work conserving scheduler.\
    \  Work conserving\n   schedulers, by definition, will always take advantage of\
    \ a scheduling\n   opportunity, irrespective of which queue is being serviced\
    \ and how\n   much bandwidth it has consumed in the past. This point leads to\
    \ an\n   interesting insight.  The semantics of a non-work conserving\n   scheduler\
    \ are equivalent to those of a meter, in that if a packet is\n   in profile it\
    \ is given the scheduling opportunity, and if it is out\n   of profile it does\
    \ not get a scheduling opportunity.  However, with\n   meters there are semantics\
    \ that determine the next action behavior\n   when the packet is in profile and\
    \ when the packet is out of profile.\n   Similarly, with the non-work conserving\
    \ scheduler, there needs to be\n   a means for determining the next scheduler\
    \ when a scheduler chooses\n   not to utilize a scheduling opportunity.\n   Figure\
    \ 7 illustrates this last scenario.  It appears very similar to\n   Figure 6,\
    \ except that the binding between the allocation scheduler\n   and the WRR scheduler\
    \ is using a FailNextScheduler association.  This\n   association is explicitly\
    \ indicating the fact that the only time the\n   WRR scheduler would be used is\
    \ when there are non-empty queues that\n   the allocation scheduler rejected for\
    \ scheduling consideration.  Note\n   that Figure 7 is incomplete, in that typically\
    \ there would be several\n   more queues that are bound to an allocation scheduler\
    \ and a WRR\n   scheduler.\n   +------------+\n   |QueuingSvc  |\n   | Name=EF\
    \    |\n   |            |\n   |            |\n   ++-+---------+\n    | |\n   \
    \ | |QueueTo\n    | |Schedule                                     +--------------+\n\
    \    | |                                             |SchedulingSvc |\n    | |\
    \      +------------------+                   | Name=WRRSched|\n    | +------+AllocationSched\
    \   |                   +----------+-+-+\n    |        |Element           |  \
    \                            ^ |\n    |        | Name=BandEF      |ElementSchedSvc\
    \               | |\n    |        | Units=Bytes      +--------------------+  \
    \       | |\n    |        | Bandwidth=100    |                    |         |\
    \ |\n    |        +------------------+                    |         | |\n    |NextService\
    \                                     |         | |\n    +----------------------------------------------+\
    \ |         | |\n                                                   | |      \
    \   | |\n     NextService                                   | |         | |\n\
    \    +--------------------------------------------+ | |         | |\n    |   \
    \                                         | | |         | |\n    |        +------------------+ElementSchedSvc\
    \ | | |         | |\n    |        |AllocationSched   +--------+       | | |  \
    \       | |\n    |        |Element           |        |       | | |         |\
    \ |\n    |        | Name=BandwidthAF1|        |       | | |         | |\n    |\
    \        | Units=Bytes      |        |       v v |         | |\n    | +------+\
    \ Bandwidth=50     |  +--+----------+-+-++FailNext| |\n    | |      +------------------+\
    \  |SchedulingService +--------+ |\n    | |QueueTo                     | Name=BandSched\
    \   |Scheduler |\n    | |Schedule                    +------------------+    \
    \      |\n    | |                                                          |\n\
    \    | |                       +---------------------+            |\n   ++-+-----------+\
    \           | WRRSchedulingElement|            |\n   |QueuingService|QueueTo \
    \   | Name=WRRBE          +------------+\n   | Name=BE      +-----------+ Weight=30\
    \           |ElementSchedSvc\n   +--------------+Schedule   +---------------------+\n\
    \   Figure 7.  Example 3: Excess Capacity Scheduler\n"
- title: 3.11.4.  Hierarchical CBQ Scheduler
  contents:
  - "3.11.4.  Hierarchical CBQ Scheduler\n   A hierarchical class-based queuing (CBQ)\
    \ scheduler is the fourth\n   scenario to be considered.  In hierarchical CBQ,\
    \ each queue is\n   allocated a specific bandwidth allocation.  Queues are grouped\n\
    \   together into a logical scheduler.  This logical scheduler in turn\n   has\
    \ an aggregate bandwidth allocation that equals the sum of the\n   queues it is\
    \ scheduling.  In turn, logical schedulers can be\n   aggregated into higher-level\
    \ logical schedulers.  Changing\n   perspectives and looking top down, the top-most\
    \ logical scheduler has\n   100% of the link capacity.  This allocation is parceled\
    \ out to\n   logical schedulers below it such that the sum of the allocations\
    \ is\n   equal to 100%.  These second tier schedulers may in turn parcel out\n\
    \   their allocation across a third tier of schedulers and so forth until\n  \
    \ the lowest tier that parcels out their allocations to specific queues\n   representing\
    \ relatively fine-grained classes of traffic.  The unique\n   aspect of hierarchical\
    \ CBQ is that when there is insufficient\n   bandwidth for a specific allocation,\
    \ schedulers higher in the tree\n   are tested to see if another portion of the\
    \ tree has capacity to\n   spare.\n   Figure 8 demonstrates this example with\
    \ two tiers.  The example is\n   split in half because of space constraints, resulting\
    \ in the CBQTier1\n   scheduling service instance being represented twice. Note\
    \ that the\n   total allocation at the top tier is 50 Mb.  The voice allocation\
    \ is\n   22 Mb.  The remaining 23 Mb is split between FTP and Web.  Hence, if\n\
    \   Web traffic is actually consuming 20 Mb (5 Mb in excess of the\n   allocation).\
    \  If FTP is consuming 5 Mb, then it is possible for the\n   CBQTier1 scheduler\
    \ to offer 3Mb of its allocation to Web traffic.\n   However, this is not enough,\
    \ so the FailNextScheduler association\n   needs to be traversed to determine\
    \ if there is any excess capacity\n   available from the voice class.  If the\
    \ voice class is only consuming\n   15 Mb of its 22 Mb allocation, there are sufficient\
    \ resources to\n   allow the web traffic through.  Note that FailNextScheduler\
    \ is used\n   as the association.  The reason is because the CBQTier1 scheduler\
    \ in\n   fact failed to schedule a packet because of insufficient resources.\n\
    \   It is conceivable that a variant of hierarchical CBQ allows a\n   hierarchy\
    \ for successful scheduling as well.  Hence, both\n   associations are necessary.\n\
    \   Note that due to space constraints of the document, the\n   SchedulingService\
    \ CBQTier1 is represented twice, to show how it is\n   connected to all the other\
    \ objects.\n   +-----------+                        NextService\n   |QueuingSvc\
    \ +-------------------------------------------+\n   | Name=Web  |            \
    \                               |\n   |           |QueueTo+----------------+ ElementSchedSvc\
    \  |\n   |           +-------+AllocationSched +----------------+ |\n   +-----------+Sched\
    \  |Element         |                | |\n                       | Name=Web-Alloc\
    \ |                | v\n                       | Bandwidth=15   |    +-----------+-+-+\n\
    \                       +----------------+    |SchedulingSvc  +\n            \
    \                                 | Name=CBQTier1 +\n                       +----------------+\
    \    +-----------+-+-+\n                       |AllocationSched | ElementSchedSvc|\
    \ ^\n   +-----------+       |Element         +----------------+ |\n   |QueuingSvc\
    \ |QueueTo| Name=FTP-Alloc |                  |\n   | Name=FTP  +-------+ Bandwidth=8\
    \    |                  |\n   |           |Sched  +----------------+         \
    \         |\n   |           |                        NextService        |\n  \
    \ |           +-------------------------------------------+\n   +-----------+\n\
    \   :\n   +---------------+                    FailNextScheduler\n   |SchedulingSvc\
    \  +---------------------------------------------+\n   | Name=CBQTier1 |     \
    \                                        |\n   +-------+-------+       +---------------------+ElementSchedSvc|\n\
    \           | SchedToSched  |AllocationScheduling +--------+      |\n        \
    \   +---------------+Element              |        |      |\n                \
    \           | Name=LowPri-Alloc   |        |      |\n                        \
    \   | Bandwidth=23        |        |      v\n                           +---------------------+\
    \  +-----+------+-+\n                                                    |SchedulingSvc\
    \ |\n                                                    | Name=CBQTop  |\n  \
    \                      +---------------------+     +----------+-+-+\n        \
    \                |AllocationScheduling |ElementSchedSvc | ^\n   +------------+\
    \       |Element              +----------------+ |\n   |QueuingSvc  |QueueTo|\
    \ Name=BE-Band        |                  |\n   | Name=Voice +-------+ Bandwidth=22\
    \        |                  |\n   |            |Sched  +---------------------+\
    \                  |\n   |            |                       NextService    \
    \          |\n   |            +------------------------------------------------+\n\
    \   +------------+\n   Figure 8.  Example 4: Hierarchical CBQ Scheduler\n"
- title: 4.  The Class Hierarchy
  contents:
  - "4.  The Class Hierarchy\n   The following sections present the class and association\
    \ hierarchies\n   that together comprise the information model for modeling QoS\n\
    \   capabilities at the device level.\n"
- title: 4.1.  Associations and Aggregations
  contents:
  - "4.1.  Associations and Aggregations\n   Associations and aggregations are a means\
    \ of representing\n   relationships between two (or theoretically more) objects.\n\
    \   Dependency, aggregation, and other relationships are modeled as\n   classes\
    \ containing two (or more) object references.  It should be\n   noted that aggregations\
    \ represent either \"whole-part\" or \"collection\"\n   relationships.  For example,\
    \ aggregation can be used to represent the\n   containment relationship between\
    \ a system and the components that\n   constitute the system.\n   Since associations\
    \ and aggregations are classes, they can benefit\n   from all of the object-oriented\
    \ features that other non-relationship\n   classes have.  For example, they can\
    \ contain properties and methods,\n   and inheritance can be used to refine their\
    \ semantics such that they\n   represent more specialized types of their superclasses.\n\
    \   Note that an association (or an aggregation) object is treated as an\n   atomic\
    \ unit (individual instance), even though it relates/collects/is\n   comprised\
    \ of multiple objects.  This is a defining feature of an\n   association (or an\
    \ aggregation) - although the individual elements\n   that are related to other\
    \ objects have their own identities, the\n   association (or aggregation) object\
    \ that is constructed using these\n   objects has its own identity and name as\
    \ well.\n   It is important to note that associations and aggregations form an\n\
    \   inheritance hierarchy that is separate from the class inheritance\n   hierarchy.\
    \  Although associations and aggregations are typically bi-\n   directional, there\
    \ is nothing that prevents higher order associations\n   or aggregations from\
    \ being defined. However, such associations and\n   aggregations are inherently\
    \ more complex to define, understand, and\n   use.  In practice, associations\
    \ and aggregations of orders higher\n   than binary are rarely used, because of\
    \ their greatly increased\n   complexity and lack of generality.  All of the associations\
    \ and\n   aggregations defined in this model are binary.\n   Note also that by\
    \ definition, associations and aggregations cannot be\n   unary.\n   Finally,\
    \ note that associations and aggregations that are defined\n   between two classes\
    \ do not affect the classes themselves.  That is,\n   the addition or deletion\
    \ of an association or an aggregation does not\n   affect the interfaces of the\
    \ classes that it is connecting.\n"
- title: 4.2.  The Structure of the Class Hierarchies
  contents:
  - "4.2.  The Structure of the Class Hierarchies\n   The structure of the class,\
    \ association, and aggregation class\n   inheritance hierarchies for managing\
    \ the datapaths of QoS devices is\n   shown, respectively, in Figure 9, Figure\
    \ 10, and Figure 11. The\n   notation (CIMCORE) identifies a class defined in\
    \ the CIM Core model.\n   Please refer to [CIM] for the definitions of these classes.\n\
    \   Similarly, the notation [PCIME] identifies a class defined in the\n   Policy\
    \ Core Information Model Extensions document. This model has\n   been influenced\
    \ by [CIM], and is compatible with the Directory\n   Enabled Networks (DEN) effort.\n\
    \   +--ManagedElement (CIMCORE)\n      |\n      +--ManagedSystemElement (CIMCORE)\n\
    \      |  |\n      |  +--LogicalElement (CIMCORE)\n      |     |\n      |    \
    \ +--Service (CIMCORE)\n      |     |  |\n      |     |  +--ConditioningService\n\
    \      |     |  |  |\n      |     |  |  +--ClassifierService\n      |     |  |\
    \  |  |\n      |     |  |  |  +--ClassifierElement\n      |     |  |  |\n    \
    \  |     |  |  +--MeterService\n      |     |  |  |  |\n      |     |  |  |  +--AverageRateMeterService\n\
    \      |     |  |  |  |\n      |     |  |  |  +--EWMAMeterService\n      |   \
    \  |  |  |  |\n      |     |  |  |  +--TokenBucketMeterService\n      |     |\
    \  |  |\n      |     |  |  +--MarkerService\n      |     |  |  |  |\n      | \
    \    |  |  |  +--PreambleMarkerService\n      |     |  |  |  |\n      |     |\
    \  |  |  +--TOSMarkerService\n      |     |  |  |  |\n      |     |  |  |  +--DSCPMarkerService\n\
    \      |     |  |  |  |\n   (continued from previous page;\n    the first four\
    \ elements are repeated for convenience)\n   +--ManagedElement (CIMCORE)\n   \
    \   |\n      +--ManagedSystemElement (CIMCORE)\n      |  |\n      |  +--LogicalElement\
    \ (CIMCORE)\n      |     |\n      |     +--Service (CIMCORE)\n      |     |  |\
    \  |  +--8021QMarkerService\n      |     |  |  |\n      |     |  |  +--DropperService\n\
    \      |     |  |  |  |\n      |     |  |  |  +--HeadTailDropperService\n    \
    \  |     |  |  |  |\n      |     |  |  |  +--RedDropperService\n      |     |\
    \  |  |\n      |     |  |  +--QueuingService\n      |     |  |  |\n      |   \
    \  |  |  +--PacketSchedulingService\n      |     |  |     |\n      |     |  |\
    \     +--NonWorkConservingSchedulingService\n      |     |  |\n      |     | \
    \ +--QoSService\n      |     |  |  |\n      |     |  |  +--DiffServService\n \
    \     |     |  |  |   |\n      |     |  |  |   +--AFService\n      |     |  |\
    \  |\n      |     |  |  +--FlowService\n      |     |  |\n      |     |  +--DropThresholdCalculationService\n\
    \      |     |\n      |     +--FilterEntryBase [PCIME]\n      |     |  |\n   \
    \   |     |  +--IPHeaderFilter [PCIME]\n      |     |  |\n      |     |  +--8021Filter\
    \ [PCIME]\n      |     |  |\n      |     |  +--PreambleFilter\n      |     |\n\
    \      |     +--FilterList [PCIME]\n      |     |\n      |     +--ServiceAccessPoint\
    \ (CIMCORE)\n      |        |\n      |        +--ProtocolEndpoint\n   (continued\
    \ from previous page;\n    the first four elements are repeated for convenience)\n\
    \   +--ManagedElement (CIMCORE)\n      |\n      +--ManagedSystemElement (CIMCORE)\n\
    \      |  |\n      |  +--LogicalElement (CIMCORE)\n      |     |\n      |    \
    \ +--Service (CIMCORE)\n      |\n      +--Collection (CIMCORE)\n      |  |\n \
    \     |  +--CollectionOfMSEs (CIMCORE)\n      |     |\n      |     +--BufferPool\n\
    \      |\n      +--SchedulingElement\n         |\n         +--AllocationSchedulingElement\n\
    \         |\n         +--WRRSchedulingElement\n         |\n         +--PrioritySchedulingElement\n\
    \            |\n            +--BoundedPrioritySchedulingElement\n   Figure 9.\
    \  Class Inheritance Hierarchy\n   The inheritance hierarchy for the associations\
    \ defined in this\n   document is shown in Figure 10.\n   +--Dependency (CIMCORE)\n\
    \   |  |\n   |  +--ServiceSAPDependency (CIMCORE)\n   |  |  |\n   |  |  +--IngressConditioningServiceOnEndpoint\n\
    \   |  |  |\n   |  |  +--EgressConditioningServiceOnEndpoint\n   |  |\n   |  +--HeadTailDropQueueBinding\n\
    \   |  |\n   |  +--CalculationBasedOnQueue\n   |  |\n   |  +--ProvidesServiceToElement\
    \ (CIMCORE)\n   |  |  |\n   |  |  +--ServiceServiceDependency (CIMCORE)\n   |\
    \  |     |\n   |  |     +--CalculationServiceForDropper\n   |  |\n   |  +--QueueAllocation\n\
    \   |  |\n   |  +--ClassifierElementUsesFilterList\n   |\n   +--AFRelatedServices\n\
    \   |\n   +--NextService\n   |  |\n   |  +--NextServiceAfterClassifierElement\n\
    \   |  |\n   |  +--NextScheduler\n   |    |\n   |    +--FailNextScheduler\n  \
    \ |\n   +--NextServiceAfterMeter\n   |\n   +--QueueToSchedule\n   |\n   +--SchedulingServiceToSchedule\n\
    \   Figure 10.  Association Class Inheritance Hierarchy\n   The inheritance hierarchy\
    \ for the aggregations defined in this\n   document is shown in Figure 11.\n \
    \  +--MemberOfCollection (CIMCORE)\n   |  |\n   |  +--CollectedBufferPool\n  \
    \ |\n   +--Component (CIMCORE)\n   |  |\n   |  +--ServiceComponent (CIMCORE)\n\
    \   |  |  |\n   |  |  +--QoSSubService\n   |  |  |\n   |  |  +--QoSConditioningSubService\n\
    \   |  |  |\n   |  |  +--ClassifierElementInClassifierService\n   |  |\n   | \
    \ +--EntriesInFilterList [PCIME]\n   |\n   +--ElementInSchedulingService\n   Figure\
    \ 11.  Aggregation Class Inheritance Hierarchy\n"
- title: 4.3.  Class Definitions
  contents:
  - "4.3.  Class Definitions\n   This section presents the classes and properties\
    \ that make up the\n   Information Model for describing QoS-related functionality\
    \ in network\n   devices, including hosts.  These definitions are derived from\n\
    \   definitions in the CIM Core model [CIM].  Only the QoS-related\n   classes\
    \ are defined in this document.  However, other classes drawn\n   from the CIM\
    \ Core model, as well as from [PCIME], are described\n   briefly.  The reader\
    \ is encouraged to look at [CIM] and at [PCIME]\n   for further information. \
    \ Associations and aggregations are defined\n   in Section 4.4.\n"
- title: 4.3.1.  The Abstract Class ManagedElement
  contents:
  - "4.3.1.  The Abstract Class ManagedElement\n   This is an abstract class defined\
    \ in the Core Model of CIM.  It is\n   the root of the entire class inheritance\
    \ hierarchy in CIM. Among the\n   associations that refer to it are two that are\
    \ subclassed in this\n   document: Dependency and MemberOfCollection, which is\
    \ an aggregation.\n   ManagedElement's properties are Caption and Description.\
    \  Both are\n   free-form strings to describe an instantiated object.  Please\
    \ refer\n   to [CIM] for the full definition of this class.\n"
- title: 4.3.2.  The Abstract Class ManagedSystemElement
  contents:
  - "4.3.2.  The Abstract Class ManagedSystemElement\n   This is an abstract class\
    \ defined in the Core Model of CIM; it is a\n   subclass of ManagedElement.  ManagedSystemElement\
    \ serves as the base\n   class for the PhysicalElement and LogicalElement class\
    \ hierarchies.\n   LogicalElement, in turn, is the base class for a number of\
    \ important\n   CIM hierarchies, including System.  Any distinguishable component\
    \ of\n   a System is a candidate for inclusion in this class hierarchy,\n   including\
    \ physical components (e.g., chips and cards) and logical\n   components (e.g.,\
    \ software components, services, and other objects).\n   None of the associations\
    \ in which this class participates is used\n   directly in the QoS device state\
    \ model.  However, the aggregation\n   Component, which relates one ManagedSystemElement\
    \ to another, is the\n   base class for the two aggregations that form the core\
    \ of the QoS\n   device state model: QoSSubService and QoSConditioningSubService.\n\
    \   Similarly, the association ProvidesServiceToElement, which relates a\n   ManagedSystemElement\
    \ to a Service, is the base class for the model's\n   CalculationServiceForDropper\
    \ association.\n   Please refer to [CIM] for the full definition of this class.\n"
- title: 4.3.3.  The Abstract Class LogicalElement
  contents:
  - "4.3.3.  The Abstract Class LogicalElement\n   This is an abstract class defined\
    \ in the Core Model of CIM.  It is a\n   subclass of the ManagedSystemElement\
    \ class, and is the base class for\n   all logical components of a managed System,\
    \ such as Files, Processes,\n   or system capabilities in the form of Logical\
    \ Devices and Services.\n   None of the associations in which this class participates\
    \ is relevant\n   to the QoS device state model. Please refer to [CIM] for the\
    \ full\n   definition of this class.\n"
- title: 4.3.4.  The Abstract Class Service
  contents:
  - "4.3.4.  The Abstract Class Service\n   This is an abstract class defined in the\
    \ Core Model of CIM.  It is a\n   subclass of the LogicalElement class, and is\
    \ the base class for all\n   objects that represent a \"service\" or functionality\
    \ in a System.  A\n   Service is a general-purpose object that is used to configure\
    \ and\n   manage the implementation of functionality.  As noted above in\n   section\
    \ 4.3.2, this class participates in the\n   ProvidesServiceToElement association.\
    \  Please refer to [CIM] for the\n   full definition of this class.\n"
- title: 4.3.5.  The Class ConditioningService
  contents:
  - "4.3.5.  The Class ConditioningService\n   This is a concrete subclass of the\
    \ CIM Core class Service; it\n   represents the ability to define how traffic\
    \ is conditioned in the\n   data-forwarding path of a device.  The subclasses\
    \ of\n   ConditioningService define the particular types of conditioning that\n\
    \   are done.  Six fundamental types of conditioning are defined in this\n   document.\
    \  These are the services performed by a classifier, a meter,\n   a marker, a\
    \ dropper, a queue, and a scheduler.  Other, more\n   sophisticated types of conditioning\
    \ may be defined in future\n   documents.\n   ConditioningService is a concrete\
    \ class because at the time it was\n   defined in CIM, its superclass was concrete.\
    \  While this class can be\n   instantiated, an instance of it would not accomplish\
    \ anything,\n   because the nature of the conditioning, and the parameters that\n\
    \   control it, are specified only in the subclasses of\n   ConditioningService.\n\
    \   Two associations in which ConditioningService participates are\n   critical\
    \ to its usage in QoS - QoSConditioningSubService and\n   NextService.  QoSConditioningSubService\
    \ aggregates\n   ConditioningServices into a particular QoS service (such as AF),\
    \ to\n   describe the specific conditioning functionality that underlies that\n\
    \   QoS service in a particular device.  NextService indicates the\n   subsequent\
    \ conditioning service(s) for different traffic streams.\n   The class definition\
    \ is as follows:\n      NAME                ConditioningService\n      DESCRIPTION\
    \         A concrete class to define how traffic\n                          is\
    \ conditioned in the data forwarding\n                          path of a host\
    \ or network device.\n      DERIVED FROM        Service\n      TYPE          \
    \      Concrete\n      PROPERTIES          (none)\n"
- title: 4.3.6.  The Class ClassifierService
  contents:
  - "4.3.6.  The Class ClassifierService\n   The concept of a Classifier comes from\
    \ [DSMODEL]. ClassifierService\n   is a concrete class that represents a logical\
    \ entity in an ingress or\n   egress interface of a device, that takes a single\
    \ input stream, and\n   sorts it into one or more output streams.  The sorting\
    \ is done by a\n   set of filters that select packets based on the packet contents,\
    \ or\n   possibly based on other attributes associated with the packet.  Each\n\
    \   output stream is the result of matching a particular filter.\n   The representation\
    \ of classifiers in QDDIM is closely related to that\n   presented in [DSMIB]\
    \ and [DSMODEL].  Rather than being linked\n   directly to its FilterLists, a\
    \ classifier is modeled here as an\n   aggregation of ClassifierElements.  Each\
    \ of these ClassifierElements\n   is then linked to a single FilterList, by the\
    \ association\n   ClassifierElementUsesFilterList.\n   A Classifier is modeled\
    \ as a subclass of ConditioningService so that\n   it can be aggregated into a\
    \ QoSService (using the\n   QoSConditioningSubService aggregation), and can use\
    \ the NextService\n   association to identify the subsequent ConditioningService\
    \ objects\n   for the different traffic streams.\n   ClassifierService is designed\
    \ to allow hierarchical classification.\n   When hierarchical classification is\
    \ used, a ClassifierElement may\n   point to another ClassifierService.  When\
    \ used for this purpose, the\n   ClassifierElement must not use the ClassifierElementUsesFilterList\n\
    \   association.\n   The class definition is as follows:\n      NAME         \
    \       ClassifierService\n      DESCRIPTION         A concrete class describing\
    \ how an input\n                          traffic stream is sorted into multiple\n\
    \                          output streams using one or more\n                \
    \          filters.\n      DERIVED FROM        ConditioningService\n      TYPE\
    \                Concrete\n      PROPERTIES          (none)\n"
- title: 4.3.7.  The Class ClassifierElement
  contents:
  - "4.3.7.  The Class ClassifierElement\n   The concept of a ClassifierElement comes\
    \ from [DSMIB].  This concrete\n   class represents the linkage, within a single\
    \ ClassifierService,\n   between a FilterList that specifies a set of criteria\
    \ for selecting\n   packets from the stream of packets coming into the ClassifierService,\n\
    \   and the next ConditioningService to which the selected packets go\n   after\
    \ they leave the ClassifierService.  ClassifierElement has no\n   properties of\
    \ its own.  It is present to serve as the anchor for an\n   aggregation with its\
    \ classifier, and for associations with its\n   FilterList and its next ConditioningService.\n\
    \   When a ClassifierElement is associated with a ClassifierService\n   through\
    \ the NextServiceAfterClassifierElement association, the\n   ClassifierElement\
    \ may not use the ClassifierElementUsesFilterList\n   association.  Further, when\
    \ a ClassifierElement is associated with a\n   ClassifierService as described\
    \ above, the order of processing of the\n   associated ClassifierService is a\
    \ function of the ClassifierOrder\n   property of the ClassifierElementInClassifierService\
    \ aggregation.\n   For example, lets assume the following:\n   1. ClassifierService\
    \ (C1) aggregates ClassifierElements (E1), (E2)\n      and (E3), with relative\
    \ ClassifierOrder values of 1, 2, and 3.\n   2. ClassifierElements (E1) and (E3)\
    \ associations to FilterLists (F1)\n      and (F3) respectively using the ClassifierElementUsesFilterList\n\
    \      association.\n   3. (E1) & (E3) are associated with Meters (M1) and (M3)\
    \ through their\n      respective NextServiceAfterClassifierElement associations.\n\
    \   4. (E2) is associated with ClassifierService (C2) through its\n      NextServiceAfterClassifierElement\
    \ association.\n   5. ClassifierService (C2) aggregates ClassifierElements (E4)\
    \ and (E5)\n      with relative ClassifierOrder values of 1 and 2.\n   6. ClassifierElements\
    \ (E4) and (E5) have associations to FilterLists\n      (F4) and (F5) respectively\
    \ using the\n      ClassifierElementUsesFilterList association.\n   In this example,\
    \ packet processing would match FilterLists in the\n   order of (F1), (F4), (F5),\
    \ and (F3).\n   The class definition is as follows:\n      NAME              \
    \  ClassifierElement\n      DESCRIPTION         A concrete class representing\n\
    \                          the process by which a classifier\n               \
    \           uses a filter to select packets\n                          to forward\
    \ to a specific next\n                          conditioning service.\n      DERIVED\
    \ FROM        ClassifierService\n      TYPE                Concrete\n      PROPERTIES\
    \          (none)\n"
- title: 4.3.8.  The Class MeterService
  contents:
  - "4.3.8.  The Class MeterService\n   This is a concrete class that represents the\
    \ metering of network\n   traffic.  Metering is the function of monitoring the\
    \ arrival times of\n   packets of a traffic stream, and determining the level\
    \ of conformance\n   of each packet with respect to a pre-established traffic\
    \ profile.  A\n   meter has the ability to invoke different ConditioningServices\
    \ for\n   conforming and non-conforming traffic. Traffic leaving a meter may be\n\
    \   further conditioned (e.g., dropped or queued) by routing the packet\n   to\
    \ another conditioning element. Please see [DSMODEL] for more\n   information\
    \ on metering.\n   This class is the base class for defining different types of\
    \ meters.\n   As such, it contains common properties that all meter subclasses\n\
    \   share.  It is modeled as a ConditioningService so that it can be\n   aggregated\
    \ into a QoSService (using the QoSConditioningSubService\n   association), to\
    \ indicate that its functionality underlies that QoS\n   service.  MeterService\
    \ also participates in the NextServiceAfterMeter\n   association, to identify\
    \ the subsequent ConditioningService objects\n   for conforming and non-conforming\
    \ traffic.\n   The class definition is as follows:\n      NAME               \
    \ MeterService\n      DESCRIPTION         A concrete class describing the\n  \
    \                        monitoring of traffic with respect to a\n           \
    \               pre-established traffic profile.\n      DERIVED FROM        ConditioningService\n\
    \      TYPE                Concrete\n      PROPERTIES          MeterType, OtherMeterType,\n\
    \                          ConformanceLevels\n   Note: The MeterType property\
    \ and the MeterService subclasses provide\n   similar information.  The MeterType\
    \ property is defined for query\n   purposes and for future expansion.  It is\
    \ possible that not all\n   MeterServices will require a subclass to define them.\
    \  In these\n   cases, MeterService will be instantiated directly, and the MeterType\n\
    \   property will provide the only way of identifying the type of the\n   meter.\n"
- title: 4.3.8.1.  The Property MeterType
  contents:
  - "4.3.8.1.  The Property MeterType\n   This property is an enumerated 16-bit unsigned\
    \ integer that is used\n   to specify the particular type of meter represented\
    \ by an instance of\n   MeterService.  The following enumeration values are defined:\n\
    \      1 - Other\n      2 - Average Rate Meter\n      3 - Exponentially Weighted\
    \ Moving Average Meter\n      4 - Token Bucket Meter\n   Note: if the value of\
    \ MeterType is not one of these four values, it\n   SHOULD be interpreted as if\
    \ it had the value '1' (Other).\n"
- title: 4.3.8.2.  The Property OtherMeterType
  contents:
  - "4.3.8.2.  The Property OtherMeterType\n   This is a string property that defines\
    \ a vendor-specific description\n   of a type of meter.  It is used when the value\
    \ of the MeterType\n   property in the instance is equal to 1.\n"
- title: 4.3.8.3.  The Property ConformanceLevels
  contents:
  - "4.3.8.3.  The Property ConformanceLevels\n   This property is a 16-bit unsigned\
    \ integer.  It indicates the number\n   of conformance levels supported by the\
    \ meter.  For example, when only\n   \"in profile\" versus \"out of profile\"\
    \ metering is supported,\n   ConformanceLevels is equal to 2.\n"
- title: 4.3.9.  The Class AverageRateMeterService
  contents:
  - "4.3.9.  The Class AverageRateMeterService\n   This is a concrete subclass of\
    \ MeterService that represents a simple\n   meter, called an Average Rate Meter.\
    \  This type of meter measures the\n   average rate at which packets are submitted\
    \ to it over a specified\n   time.  Packets are defined as conformant if their\
    \ average arrival\n   rate does not exceed the specified measuring rate of the\
    \ meter.  Any\n   packet that causes the specified measuring rate to be exceeded\
    \ is\n   defined to be non-conforming.  For more information, please see\n   [DSMODEL].\n\
    \   The class definition is as follows:\n      NAME                AverageRateMeterService\n\
    \      DESCRIPTION         A concrete class classifying traffic as\n         \
    \                 either conforming or non-conforming,\n                     \
    \     depending on whether the arrival of a\n                          packet\
    \ causes the average arrival rate\n                          to exceed a pre-determined\
    \ value.\n      DERIVED FROM        MeterService\n      TYPE                Concrete\n\
    \      PROPERTIES          AverageRate, DeltaInterval\n"
- title: 4.3.9.1.  The Property AverageRate
  contents:
  - "4.3.9.1.  The Property AverageRate\n   This is an unsigned 32-bit integer that\
    \ defines the rate used to\n   determine whether admitted packets are in conformance\
    \ or not. The\n   value is specified in kilobits per second.\n"
- title: 4.3.9.2.  The Property DeltaInterval
  contents:
  - "4.3.9.2.  The Property DeltaInterval\n   This is an unsigned 64-bit integer that\
    \ defines the time period over\n   which the average measurement should be taken.\
    \  The value is\n   specified in microseconds.\n"
- title: 4.3.10.  The Class EWMAMeterService
  contents:
  - "4.3.10.  The Class EWMAMeterService\n   This is a concrete subclass of the MeterService\
    \ class that represents\n   an exponentially weighted moving average meter.  This\
    \ meter is a\n   simple low-pass filter that measures the rate of incoming packets\n\
    \   over a small, fixed sampling interval.  Any admitted packet that\n   pushes\
    \ the average rate over a pre-defined limit is defined to be\n   non-conforming.\
    \  Please see [DSMODEL] for more information.\n   The class definition is as follows:\n\
    \      NAME                EWMAMeterService\n      DESCRIPTION         A concrete\
    \ class classifying admitted\n                          traffic as either conforming\
    \ or non-\n                          conforming, depending on whether the\n  \
    \                        arrival of a packet causes the average\n            \
    \              arrival rate in a small fixed\n                          sampling\
    \ interval to exceed a\n                          pre-determined value or not.\n\
    \      DERIVED FROM        MeterService\n      TYPE                Concrete\n\
    \      PROPERTIES          AverageRate, DeltaInterval, Gain\n"
- title: 4.3.10.1.  The Property AverageRate
  contents:
  - "4.3.10.1.  The Property AverageRate\n   This property is an unsigned 32-bit integer\
    \ that defines the average\n   rate against which the sampled arrival rate of\
    \ packets should be\n   measured.  Any packet that causes the sampled rate to\
    \ exceed this\n   rate is deemed non-conforming.  The value is specified in kilobits\n\
    \   per second.\n"
- title: 4.3.10.2.  The Property DeltaInterval
  contents:
  - "4.3.10.2.  The Property DeltaInterval\n   This property is an unsigned 64-bit\
    \ integer that defines the sampling\n   interval used to measure the arrival rate.\
    \  The calculated rate is\n   averaged over this interval and checked against\
    \ the AverageRate\n   property.  All packets whose computed average arrival rate\
    \ is less\n   than the AverageRate are deemed conforming.\n   The value is specified\
    \ in microseconds.\n"
- title: 4.3.10.3.  The Property Gain
  contents:
  - "4.3.10.3.  The Property Gain\n   This property is an unsigned 32-bit integer\
    \ representing the\n   reciprocal of the time constant (e.g., frequency response)\
    \ of what is\n   essentially a simple low-pass filter.  For example, the value\
    \ 64 for\n   this property represents a time constant value of 1/64.\n"
- title: 4.3.11.  The Class TokenBucketMeterService
  contents:
  - "4.3.11.  The Class TokenBucketMeterService\n   This is a concrete subclass of\
    \ the MeterService class that represents\n   the metering of network traffic using\
    \ a token bucket meter.  Two\n   types of token bucket meters are defined using\
    \ this class - a simple,\n   two-parameter bucket meter, and a multi-stage meter.\n\
    \   A simple token bucket usually has two parameters, an average token\n   rate\
    \ and a burst size, and has two conformance levels: \"conforming\"\n   and \"\
    non-conforming\".  This class also defines an excess burst size,\n   which enables\
    \ the meter to have three conformance levels\n   (\"conforming\", \"partially\
    \ conforming\", and \"non-conforming\").  In\n   this case, packets that exceed\
    \ the excess burst size are deemed non-\n   conforming, while packets that exceed\
    \ the smaller burst size but are\n   less than the excess burst size are deemed\
    \ partially conforming.\n   Operation of these meters is described in [DSMODEL].\n\
    \   The class definition is as follows:\n      NAME                TokenBucketMeterService\n\
    \      DESCRIPTION         A concrete class classifying admitted\n           \
    \               traffic with respect to a token bucket.\n                    \
    \      Either two or three levels of\n                          conformance can\
    \ be defined.\n      DERIVED FROM        MeterService\n      TYPE            \
    \    Concrete\n      PROPERTIES          AverageRate, PeakRate,\n            \
    \              BurstSize, ExcessBurstSize\n"
- title: 4.3.11.1.  The Property AverageRate
  contents:
  - "4.3.11.1.  The Property AverageRate\n   This property is an unsigned 32-bit integer\
    \ that specifies the\n   committed rate of the meter.  The value is expressed\
    \ in kilobits per\n   second.\n"
- title: 4.3.11.2.  The Property PeakRate
  contents:
  - "4.3.11.2.  The Property PeakRate\n   This property is an unsigned 32-bit integer\
    \ that specifies the peak\n   rate of the meter.  The value is expressed in kilobits\
    \ per second.\n"
- title: 4.3.11.3.  The Property BurstSize
  contents:
  - "4.3.11.3.  The Property BurstSize\n   This property is an unsigned 32-bit integer\
    \ that specifies the\n   maximum number of tokens available for the committed\
    \ rate (specified\n   by the AverageRate property).  The value is expressed in\
    \ kilobytes.\n"
- title: 4.3.11.4.  The Property ExcessBurstSize
  contents:
  - "4.3.11.4.  The Property ExcessBurstSize\n   This property is an unsigned 32-bit\
    \ integer that specifies the\n   maximum number of tokens available for the peak\
    \ rate (specified by\n   the PeakRate property).  The value is expressed in kilobytes.\n"
- title: 4.3.12.  The Class MarkerService
  contents:
  - "4.3.12.  The Class MarkerService\n   This is a concrete class that represents\
    \ the general process of\n   marking some field in a network packet with some\
    \ value. Subclasses of\n   MarkerService identify particular fields to be marked,\
    \ and introduce\n   properties to represent the values to be used in marking these\n\
    \   fields.  Markers are usually invoked as a result of a preceding\n   classifier\
    \ match.  Operation of markers of various types is described\n   in [DSMODEL].\n\
    \   MarkerService is a concrete class because at the time it was defined\n   in\
    \ CIM, its superclass was concrete.  While this class can be\n   instantiated,\
    \ an instance of it would not accomplish anything,\n   because both the field\
    \ to be marked and the value to be used to mark\n   it are specified only in subclasses\
    \ of MarkerService.\n   MarkerService is modeled as a ConditioningService so that\
    \ it can be\n   aggregated into a QoSService (using the QoSConditioningSubService\n\
    \   association) to indicate that its functionality underlies that QoS\n   service.\
    \  It participates in the NextService association to identify\n   the subsequent\
    \ ConditioningService object that acts on traffic after\n   it has been marked\
    \ by the marker.\n   The class definition is as follows:\n      NAME         \
    \       MarkerService\n      DESCRIPTION         A concrete class representing\
    \ the\n                          general process of marking a selected\n     \
    \                     field in a packet with a specified\n                   \
    \       value.  Packets are marked in order\n                          to control\
    \ the conditioning that\n                          they will subsequently receive.\n\
    \      DERIVED FROM        ConditioningService\n      TYPE                Concrete\n\
    \      PROPERTIES          (none)\n"
- title: 4.3.13.  The Class PreambleMarkerService
  contents:
  - "4.3.13.  The Class PreambleMarkerService\n   This is a concrete class that models\
    \ the storing of traffic-\n   conditioning results in a packet preamble.  See\
    \ Section 3.8.3 for a\n   discussion of how, and why, QDDIM models the capability\
    \ to store\n   these results in a packet preamble.  An instance of\n   PreambleMarkerService\
    \ appends to a packet preamble a two-part string\n   of the form \"<type>,<value>\"\
    .  Section 3.8.3 provides a list of the\n   <type> strings defined by QDDIM. \
    \ Implementations may support other\n   <type>'s in addition to these.\n   The\
    \ class definition is as follows:\n      NAME                PreambleMarkerService\n\
    \      DESCRIPTION         A concrete class representing the saving\n        \
    \                  of traffic-conditioning results in a\n                    \
    \      packet preamble.\n      DERIVED FROM        MarkerService\n      TYPE \
    \               Concrete\n      PROPERTIES          FilterItemList[ ]\n"
- title: 4.3.13.1.  The Multi-valued Property FilterItemList
  contents:
  - "4.3.13.1.  The Multi-valued Property FilterItemList\n   This property is an ordered\
    \ list of strings, where each string has\n   the format \"<type>,<value>\".  See\
    \ Section 3.8.3 for a list of\n   <type>'s defined in QDDIM, and the nature of\
    \ the associated <value>\n   for each of these types.\n"
- title: 4.3.14.  The Class ToSMarkerService
  contents:
  - "4.3.14.  The Class ToSMarkerService\n   This is a concrete class that represents\
    \ the marking of the ToS field\n   in the IPv4 packet header [R791].  Following\
    \ common practice, the\n   value to be written into the field is represented as\
    \ an unsigned 8-\n   bit integer.\n   The class definition is as follows:\n  \
    \    NAME                ToSMarkerService\n      DESCRIPTION         A concrete\
    \ class representing the\n                          process of marking the type\
    \ of service\n                          (ToS) field in the IPv4 packet header\n\
    \                          with a specified value.  Packets are\n            \
    \              marked in order to control the\n                          conditioning\
    \ that they will subsequently\n                          receive.\n      DERIVED\
    \ FROM        MarkerService\n      TYPE                Concrete\n      PROPERTIES\
    \          ToSValue\n"
- title: 4.3.14.1.  The Property ToSValue
  contents:
  - "4.3.14.1.  The Property ToSValue\n   This property is an unsigned 8-bit integer,\
    \ representing a value to\n   be used for marking the type of service (ToS) field\
    \ in the IPv4\n   packet header.  The ToS field is defined to be a complete octet,\
    \ so\n   the range for this property is 0..255.  Some implementations,\n   however,\
    \ require that the lowest-order bit in the ToS field always be\n   '0'.  Such\
    \ an implementation is consequently unable to support an odd\n   TosValue.\n"
- title: 4.3.15.  The Class DSCPMarkerService
  contents:
  - "4.3.15.  The Class DSCPMarkerService\n   This is a concrete class that represents\
    \ the marking of the\n   differentiated services codepoint (DSCP) within the DS\
    \ field in the\n   IPv4 and IPv6 packet headers, as defined in [R2474]. Following\
    \ common\n   practice, the value to be written into the field is represented as\
    \ an\n   unsigned 8-bit integer.\n   The class definition is as follows:\n   \
    \   NAME                DSCPMarkerService\n      DESCRIPTION         A concrete\
    \ class representing the\n                          process of marking the DSCP\
    \ field\n                          in a packet with a specified\n            \
    \              value.  Packets are marked in order\n                         \
    \ to control the conditioning that\n                          they will subsequently\
    \ receive.\n      DERIVED FROM        MarkerService\n      TYPE              \
    \  Concrete\n      PROPERTIES          DSCPValue\n"
- title: 4.3.15.1.  The Property DSCPValue
  contents:
  - "4.3.15.1.  The Property DSCPValue\n   This property is an unsigned 8-bit integer,\
    \ representing a value to\n   be used for marking the DSCP within the DS field\
    \ in an IPv4 or IPv6\n   packet header.  Since the DSCP consists of 6 bits, the\
    \ values for\n   this property are limited to the range 0..63.  When the DSCP\
    \ is\n   marked, the remaining two bit in the DS field are left unchanged.\n"
- title: 4.3.16.  The Class 8021QMarkerService
  contents:
  - "4.3.16.  The Class 8021QMarkerService\n   This is a concrete class that represents\
    \ the marking of the user\n   priority field defined in the IEEE 802.1Q specification\
    \ [IEEE802Q].\n   Following common practice, the value to be written into the\
    \ field is\n   represented as an unsigned 8-bit integer.\n   The class definition\
    \ is as follows:\n      NAME                8021QMarkerService\n      DESCRIPTION\
    \         A concrete class representing the\n                          process\
    \ of marking the Priority\n                          field in an 802.1Q-compliant\
    \ frame\n                          with a specified value.  Frames are\n     \
    \                     marked in order to control the\n                       \
    \   conditioning that they will\n                          subsequently receive.\n\
    \      DERIVED FROM        MarkerService\n      TYPE                Concrete\n\
    \      PROPERTIES          PriorityValue\n"
- title: 4.3.16.1.  The Property PriorityValue
  contents:
  - "4.3.16.1.  The Property PriorityValue\n   This property is an unsigned 8-bit\
    \ integer, representing a value to\n   be used for marking the Priority field\
    \ in the 802.1Q header. Since\n   the Priority field consists of 3 bits, the values\
    \ for this property\n   are limited to the range 0..7.  When the Priority field\
    \ is marked,\n   the remaining bits in its octet are left unchanged.\n"
- title: 4.3.17.  The Class DropperService
  contents:
  - "4.3.17.  The Class DropperService\n   This is a concrete class that represents\
    \ the ability to selectively\n   drop network traffic, or to invoke another ConditioningService\
    \ for\n   further processing of traffic that is not dropped.  This is the base\n\
    \   class for different types of droppers. Droppers are distinguished by\n   the\
    \ algorithm that they use to drop traffic.  Please see [DSMODEL]\n   for more\
    \ information about the various types of droppers.  Note that\n   this class encompasses\
    \ both Absolute Droppers and Algorithmic\n   Droppers from [DSMODEL].\n   DropperService\
    \ is modeled as a ConditioningService so that it can be\n   aggregated into a\
    \ QoSService (using the QoSConditioningSubService\n   association) to indicate\
    \ that its functionality underlies that QoS\n   service.  It participates in the\
    \ NextService association to identify\n   the subsequent ConditioningService object\
    \ that acts on any remaining\n   traffic that is not dropped.\n   NextService\
    \ has special semantics for droppers, in addition to the\n   general \"what happens\
    \ next\" semantics that apply to all\n   ConditioningServices.  The queue(s) from\
    \ which a particular dropper\n   drops packets are identified by following chain(s)\
    \ of NextService\n   associations \"rightwards\" from the dropper until they reach\
    \ a queue.\n   The class definition is as follows:\n      NAME               \
    \ DropperService\n      DESCRIPTION         A concrete base class describing the\n\
    \                          common characteristics of droppers.\n      DERIVED\
    \ FROM        ConditioningService\n      TYPE                Concrete\n      PROPERTIES\
    \          DropperType, OtherDropperType, DropFrom\n   Note: The DropperType property\
    \ and the DropperService subclasses\n   provide similar information.  The DropperType\
    \ property is defined for\n   query purposes, as well as for those cases where\
    \ a subclass of\n   DropperService is not needed to model a particular type of\
    \ dropper.\n   For example, the Absolute Dropper defined in [DSMODEL] is modeled\
    \ as\n   an instance of the DropperService class with its DropperType set to\n\
    \   '4' (\"Absolute Dropper\").\n"
- title: 4.3.17.1.  The Property DropperType
  contents:
  - "4.3.17.1.  The Property DropperType\n   This is an enumerated 16-bit unsigned\
    \ integer that defines the type\n   of dropper.  Values include:\n      1 - Other\n\
    \      2 - Random\n      3 - HeadTail\n      4 - Absolute Dropper\n   Note: if\
    \ the value of DropperType is not one of these four values, it\n   SHOULD be interpreted\
    \ as if it had the value '1' (Other).\n"
- title: 4.3.17.2.  The Property OtherDropperType
  contents:
  - "4.3.17.2.  The Property OtherDropperType\n   This string property is used in\
    \ conjunction with the DropperType\n   property.  When the value of DropperType\
    \ is '1' (i.e., Other), then\n   the name of the type of dropper appears in this\
    \ property.\n"
- title: 4.3.17.3.  The Property DropFrom
  contents:
  - "4.3.17.3.  The Property DropFrom\n   This is an unsigned 16-bit integer enumeration\
    \ that indicates the\n   point in the associated queue from which packets should\
    \ be dropped.\n   Defined enumeration values are:\n      o  unknown(0)\n     \
    \ o  head(1)\n      o  tail(2)\n   Note: if the value of DropFrom is '0' (unknown),\
    \ or if it is not one\n   of the three values listed here, then packets MAY be\
    \ dropped from any\n   location in the associated queue.\n"
- title: 4.3.18.  The Class HeadTailDropperService
  contents:
  - "4.3.18.  The Class HeadTailDropperService\n   This is a concrete class that represents\
    \ the threshold information of\n   a head or tail dropper.  The inherited property\
    \ DropFrom indicates\n   whether a particular instance of this class represents\
    \ a head dropper\n   or a tail dropper.\n   A head dropper always examines the\
    \ same queue from which it drops\n   packets, and this queue is always related\
    \ to the dropper as the\n   following service in the NextService association.\n\
    \   The class definition is as follows:\n      NAME                HeadTailDropperService\n\
    \      DESCRIPTION         A concrete class used to describe\n               \
    \           a head or tail dropper.\n      DERIVED FROM        DropperService\n\
    \      TYPE                Concrete\n      PROPERTIES          QueueThreshold\n"
- title: 4.3.18.1.  The Property QueueThreshold
  contents:
  - "4.3.18.1.  The Property QueueThreshold\n   This is an unsigned 32-bit integer\
    \ that indicates the queue depth at\n   which traffic will be dropped.  For a\
    \ tail dropper, all newly\n   arriving traffic is dropped.  For a head dropper,\
    \ packets at the\n   front of the queue are dropped to make room for new packets,\
    \ which\n   are added at the end.  The value is expressed in bytes.\n"
- title: 4.3.19.  The Class REDDropperService
  contents:
  - "4.3.19.  The Class REDDropperService\n   This is a concrete class that represents\
    \ the ability to drop network\n   traffic using a Random Early Detection (RED)\
    \ algorithm. This\n   algorithm is described in [RED].  The purpose of a RED algorithm\
    \ is\n   to avoid congestion (as opposed to managing congestion).  Instead of\n\
    \   waiting for the queues to fill up, and then dropping large numbers of\n  \
    \ packets, RED works by monitoring the average queue depth.  When the\n   queue\
    \ depth exceeds a minimum threshold, packets are randomly\n   discarded.  These\
    \ discards cause TCP to slow its transmission rate\n   for those connections that\
    \ experienced the packet discards.  Other\n   TCP connections are not affected\
    \ by these discards.  Please see\n   [DSMODEL] for more information about a dropper.\n\
    \   A RED dropper always drops packets from a single queue, which is\n   related\
    \ to the dropper as the following service in the NextService\n   association.\
    \  The queue(s) examined by the drop algorithm are found\n   by following the\
    \ CalculationServiceForDropper association to find the\n   dropper's DropThresholdCalculationService,\
    \ and then following the\n   CalculationBasedOnQueue association(s) to find the\
    \ queue(s) being\n   watched.\n   The class definition is as follows:\n      NAME\
    \                REDDropperService\n      DESCRIPTION         A concrete class\
    \ used to describe\n                          dropping using the RED algorithm\
    \ (or\n                          one of its variants).\n      DERIVED FROM   \
    \     DropperService\n      TYPE                Concrete\n      PROPERTIES   \
    \       MinQueueThreshold, MaxQueueThreshold,\n                          ThresholdUnits,\
    \ StartProbability,\n                          StopProbability\n   NOTE:  In [DSMIB],\
    \ there is a single diffServRandomDropTable, which\n   represents the general\
    \ category of random dropping.  (RED is one type\n   of random dropping, but there\
    \ are also types of random dropping\n   distinct from RED.)  The REDDropperService\
    \ class corresponds to the\n   columns in the table that apply to the RED algorithm\
    \ in particular.\n"
- title: 4.3.19.1.  The Property MinQueueThreshold
  contents:
  - "4.3.19.1.  The Property MinQueueThreshold\n   This is an unsigned 32-bit integer\
    \ that defines the minimum average\n   queue depth at which packets are subject\
    \ to being dropped.  The units\n   are identified by the ThresholdUnits property.\
    \  The slope of the drop\n   probability function is described by the Start/StopProbability\n\
    \   properties.\n"
- title: 4.3.19.2.  The Property MaxQueueThreshold
  contents:
  - "4.3.19.2.  The Property MaxQueueThreshold\n   This is an unsigned 32-bit integer\
    \ that defines the maximum average\n   queue length at which packets are subject\
    \ to always being dropped,\n   regardless of the dropping algorithm and probabilities\
    \ being used.\n   The units are identified by the ThresholdUnits property.\n"
- title: 4.3.19.3.  The Property ThresholdUnits
  contents:
  - "4.3.19.3.  The Property ThresholdUnits\n   This is an unsigned 16-bit integer\
    \ enumeration that identifies the\n   units for the MinQueueThreshold and MaxQueueThreshold\
    \ properties.\n   Defined enumeration values are:\n      o    bytes(1)\n     \
    \ o    packets(2)\n   Note: if the value of ThresholdUnits is not one of these\
    \ two values,\n   it SHOULD be interpreted as if it had the value '1' (bytes).\n"
- title: 4.3.19.4.  The Property StartProbability
  contents:
  - "4.3.19.4.  The Property StartProbability\n   This is an unsigned 32-bit integer;\
    \ in conjunction with the\n   StopProbability property, it defines the slope of\
    \ the drop\n   probability function.  This function governs the rate at which\n\
    \   packets are subject to being dropped, as a function of the queue\n   length.\n\
    \   This property expresses a drop probability in drops per thousand\n   packets.\
    \  For example, the value 100 indicates a drop probability of\n   100 per 1000\
    \ packets, that is, 10%.  Min and max values are 0 to\n   1000.\n"
- title: 4.3.19.5.  The Property StopProbability
  contents:
  - "4.3.19.5.  The Property StopProbability\n   This is an unsigned 32-bit integer;\
    \ in conjunction with the\n   StartProbability property, it defines the slope\
    \ of the drop\n   probability function.  This function governs the rate at which\n\
    \   packets are subject to being dropped, as a function of the queue\n   length.\n\
    \   This property expresses a drop probability in drops per thousand\n   packets.\
    \  For example, the value 100 indicates a drop probability of\n   100 per 1000\
    \ packets, that is, 10%.  Min and max values are 0 to\n   1000.\n"
- title: 4.3.20.  The Class QueuingService
  contents:
  - "4.3.20.  The Class QueuingService\n   This is a concrete class that represents\
    \ the ability to queue network\n   traffic, and to specify the characteristics\
    \ for determining long-term\n   congestion.  Please see [DSMODEL] for more information\
    \ about queuing\n   functionality.\n   QueuingService is modeled as a ConditioningService\
    \ so that it can be\n   aggregated into a QoSService (using the QoSConditioningSubService\n\
    \   association) to indicate that its functionality underlies that QoS\n   service.\n\
    \   The class definition is as follows:\n      NAME                QueuingService\n\
    \      DESCRIPTION         A concrete class describing the ability\n         \
    \                 to queue network traffic and to specify\n                  \
    \        the characteristics for determining\n                          long-term\
    \ congestion.\n      DERIVED FROM        ConditioningService\n      TYPE     \
    \           Concrete\n      PROPERTIES          CurrentQueueDepth, DepthUnits\n"
- title: 4.3.20.1.  The Property CurrentQueueDepth
  contents:
  - "4.3.20.1.  The Property CurrentQueueDepth\n   This is an unsigned 32-bit integer,\
    \ which functions as a (read-only)\n   gauge representing the current depth of\
    \ this one queue.  This value\n   may be important in diagnosing unexpected behavior\
    \ by a\n   DropThresholdCalculationService.\n"
- title: 4.3.20.2.  The Property DepthUnits
  contents:
  - "4.3.20.2.  The Property DepthUnits\n   This is an unsigned 16-bit integer enumeration\
    \ that identifies the\n   units for the CurrentQueueDepth property.  Defined enumeration\
    \ values\n   are:\n      o    bytes(1)\n      o    packets(2)\n   Note: if the\
    \ value of DepthUnits is not one of these two values, it\n   SHOULD be interpreted\
    \ as if it had the value '1' (bytes).  The\n"
- title: 4.3.21.  Class PacketSchedulingService
  contents:
  - "4.3.21.  Class PacketSchedulingService\n   This is a concrete class that represents\
    \ a scheduling service, which\n   is a process that determines when a queued packet\
    \ should be removed\n   from a queue and sent to an output interface.  Note that\
    \ output\n   interfaces can be physical network interfaces or interfaces to\n\
    \   components internal to systems, such as crossbars or back planes.  In\n  \
    \ either case, if multiple queues are involved, schedulers are used to\n   provide\
    \ access to the interface.\n   Each instance of a PacketSchedulingService describes\
    \ a scheduler from\n   the perspective of the queues that it is servicing.  Please\
    \ see\n   [DSMODEL] for more information about a scheduler.\n   PacketSchedulingService\
    \ is modeled as a ConditioningService so that\n   it can be aggregated into a\
    \ QoSService (using the\n   QoSConditioningSubService association) to indicate\
    \ that its\n   functionality underlies that QoS service.  It participates in the\n\
    \   NextService association to identify the subsequent\n   ConditioningService\
    \ object, if any, that acts on traffic after it has\n   been processed by the\
    \ scheduler.\n   The class definition is as follows:\n      NAME             \
    \   PacketSchedulingService\n      DESCRIPTION         A concrete class used to\
    \ determine when\n                          a packet should be removed from a\n\
    \                          queue and sent to an output interface.\n      DERIVED\
    \ FROM        ConditioningService\n      TYPE                Concrete\n      PROPERTIES\
    \          SchedulerType, OtherSchedulerType\n"
- title: 4.3.21.1.  The Property SchedulerType
  contents:
  - "4.3.21.1.  The Property SchedulerType\n   This property is an enumerated 16-bit\
    \ unsigned integer, and defines\n   the type of scheduler.  Values are:\n    \
    \  1 - Other\n      2 - FIFO\n      3 - Priority\n      4 - Allocation\n     \
    \ 5 - Bounded Priority\n      6 - Weighted Round Robin Packet\n   Note: if the\
    \ value of SchedulerType is not one of these six values,\n   it SHOULD be interpreted\
    \ as if it had the value '2' (FIFO).\n"
- title: 4.3.21.2.  The Property OtherSchedulerType
  contents:
  - "4.3.21.2.  The Property OtherSchedulerType\n   This string property is used in\
    \ conjunction with the SchedulerType\n   property.  When the value of SchedulerType\
    \ is 1 (i.e., Other), then\n   the type of scheduler is specified in this property.\n"
- title: 4.3.22.  The Class NonWorkConservingSchedulingService
  contents:
  - "4.3.22.  The Class NonWorkConservingSchedulingService\n   This class does not\
    \ add any properties beyond those it inherits from\n   its superclass, PacketSchedulingService.\
    \  It does, however,\n   participate in one additional association, FailNextScheduler.\n\
    \   The class definition is as follows:\n      NAME                NonWorkConservingSchedulingService\n\
    \      DESCRIPTION         A concrete class representing a\n                 \
    \         scheduler that is capable of operating\n                          in\
    \ a non-work conserving manner.\n      DERIVED FROM        PacketSchedulingService\n\
    \      TYPE                Concrete\n      PROPERTIES          (none)\n"
- title: 4.3.23.  The Class QoSService
  contents:
  - "4.3.23.  The Class QoSService\n   This is a concrete class that represents the\
    \ ability to conceptualize\n   a QoS service as a set of coordinated sub-services.\
    \ This enables the\n   network administrator to map business rules to the network,\
    \ and the\n   network designer to engineer the network such that it can provide\n\
    \   different functions for different traffic streams.\n   This class has two\
    \ main purposes.  First, it serves as a common base\n   class for defining the\
    \ various sub-services needed to build higher-\n   level QoS services.  Second,\
    \ it serves as a way to consolidate the\n   relationships between different types\
    \ of QoS services and different\n   types of ConditioningServices.\n   For example,\
    \ Gold Service may be defined as a QoSService which\n   aggregates two QoS services\
    \ together.  Each of these QoS services\n   could be represented by an instance\
    \ of the class DiffServService, one\n   for servicing of very high demand packets\
    \ (represented by an instance\n   of DiffServService itself), and one for the\
    \ service given to most of\n   the packets, represented by an instance of AFService,\
    \ which is a\n   subclass of DiffServService.  The high demand DiffServService\n\
    \   instance will then use the QoSConditioningSubService aggregation to\n   aggregate\
    \ together the necessary classifiers to indicate which\n   traffic it applies\
    \ to, and the appropriate meters for contract\n   limits, the marker to mark the\
    \ EF PHB in the packets, and the\n   queuing-related conditioning services.  The\
    \ AFService instance will\n   also use the QoSConditioningSubService aggregation,\
    \ to aggregate its\n   classifiers and meters, the several markers used to mark\
    \ the\n   different AF PHBs in the packets, and the queuing-related\n   conditioning\
    \ services needed to deliver the packet treatment.\n   QoSService is modeled as\
    \ a type of Service, which is used as the\n   anchor point for defining a set\
    \ of sub-services that implement the\n   desired conditioning characteristics\
    \ for different types of flows.\n   It will direct the specific type of conditioning\
    \ services to be used\n   in order to implement this service.\n   The class definition\
    \ is as follows:\n      NAME                QoSService\n      DESCRIPTION    \
    \     A concrete class used to represent a QoS\n                          service\
    \ or set of services, as defined\n                          by a network administrator.\n\
    \      DERIVED FROM        Service\n      TYPE                Concrete\n     \
    \ PROPERTIES          (none)\n"
- title: 4.3.24.  The Class DiffServService
  contents:
  - "4.3.24.  The Class DiffServService\n   This is a concrete class representing\
    \ the use of standard or custom\n   DiffServ services to implement a (higher-level)\
    \ QoS service.  Note\n   that a DiffServService object may be just one of a set\
    \ of coordinated\n   QoSSubServices objects that together implement a higher-level\
    \ QoS\n   service.\n   DiffServService is modeled as a subclass of QoSService.\
    \  This enables\n   it to be related to a higher-level QoS service via QoSSubService,\
    \ as\n   well as to specific ConditioningService objects (e.g., metering,\n  \
    \ dropping, queuing, and others) via QoSConditioningSubService.\n   The class\
    \ definition is as follows:\n      NAME                DiffServService\n     \
    \ DESCRIPTION         A concrete class used to represent a\n                 \
    \         DiffServ service associated with a\n                          particular\
    \ Per Hop Behavior.\n      DERIVED FROM        QoSService\n      TYPE        \
    \        Concrete\n      PROPERTIES          PHBID\n"
- title: 4.3.24.1.  The Property PHBID
  contents:
  - "4.3.24.1.  The Property PHBID\n   This property is a 16-bit unsigned integer,\
    \ which identifies a\n   particular per hop behavior, or family of per hop behaviors.\
    \  The\n   value here is a Per Hop Behavior Identification Code, as defined in\n\
    \   [R3140].  Note that as defined, these identification codes use the\n   default,\
    \ recommended, code points for PHBs as part of their\n   structure.  These values\
    \ may well be different from the actual value\n   used in the marker, as the marked\
    \ value is a domain-dependent value.\n   The ability to indicate the PHB Identification\
    \ Code associated with a\n   service is helpful for tying the QoS Service to reference\
    \ documents,\n   and for inter-domain coordination and operation.\n"
- title: 4.3.25.  The Class AFService
  contents:
  - "4.3.25.  The Class AFService\n   This is a concrete class that represents a specialization\
    \ of the\n   general concept of forwarding network traffic, by adding specific\n\
    \   semantics that characterize the operation of the Assured Forwarding\n   (AF)\
    \ Service ([R2597]).\n   [R2597] defines four different AF classes, to represent\
    \ four\n   different treatments of traffic.  A different amount of forwarding\n\
    \   resources, such as buffer space and bandwidth, are allocated to each\n   AF\
    \ class.  Within each AF class, IP packets are marked with one of\n   three possible\
    \ drop precedence values.  The drop precedence of a\n   packet determines the\
    \ relative importance of that packet compared to\n   other packets within the\
    \ same AF class, if congestion occurs.  A\n   congested interface will try to\
    \ avoid dropping packets marked with a\n   lower drop precedence value, by instead\
    \ discarding packets marked\n   with a higher drop precedence value.\n   Note\
    \ that [R2597] defines 12 DSCPs that together represent the AF Per\n   Hop Behavior\
    \ (PHB) group.  Implementations are free to extend this\n   (e.g., add more classes\
    \ and/or drop precedences).\n   The AFService class is modeled as a specialization\
    \ of\n   DiffServService, which is in turn a specialization of QoSService.\n \
    \  This enables it to be related to higher-level QoS services, as well\n   as\
    \ to lower-level conditioning sub-services (e.g., classification,\n   metering,\
    \ dropping, queuing, and others).\n   The class definition is as follows:\n  \
    \    NAME                AFService\n      DESCRIPTION         A concrete class\
    \ for describing the\n                          common characteristics of differentiated\n\
    \                          services that are used to affect\n                \
    \          traffic forwarding, using the AF\n                          PHB Group.\n\
    \      DERIVED FROM        DiffServService\n      TYPE                Concrete\n\
    \      PROPERTIES          ClassNumber, DropperNumber\n"
- title: 4.3.25.1.  The Property ClassNumber
  contents:
  - "4.3.25.1.  The Property ClassNumber\n   This property is an 8-bit unsigned integer\
    \ that indicates the number\n   of AF classes that this AF implementation uses.\
    \  Among the instances\n   aggregated using the QoSConditioningSubService aggregation\
    \ with an\n   instance of AFService, one SHOULD find markers with as many distinct\n\
    \   values as the ClassNumber of the AFService instance.\n"
- title: 4.3.25.2.  The Property DropperNumber
  contents:
  - "4.3.25.2.  The Property DropperNumber\n   This property is an 8-bit unsigned\
    \ integer that indicates the number\n   of drop precedence values that this AF\
    \ implementation uses.  The\n   number of drop precedence values is the number\
    \ PER AF CLASS.  The\n   corresponding droppers will be found in the collection\
    \ of\n   conditioning services aggregated with the QoSConditioningSubService\n\
    \   aggregation.\n"
- title: 4.3.26.  The Class FlowService
  contents:
  - "4.3.26.  The Class FlowService\n   This class represents a service that supports\
    \ a particular microflow.\n   The microflow is identified by the string-valued\
    \ property FlowID.  In\n   some implementations, an instance of this class corresponds\
    \ to an\n   entry in the implementation's flow table.\n   The class definition\
    \ is as follows:\n      NAME                FlowService\n      DESCRIPTION   \
    \      A concrete class representing a\n                          microflow.\n\
    \      DERIVED FROM        QoSService\n      TYPE                Concrete\n  \
    \    PROPERTIES          FlowID\n"
- title: 4.3.26.1.  The Property FlowID
  contents:
  - "4.3.26.1.  The Property FlowID\n   This property is a string containing an identifier\
    \ for a microflow.\n"
- title: 4.3.27.  The Class DropThresholdCalculationService
  contents:
  - "4.3.27.  The Class DropThresholdCalculationService\n   This class represents\
    \ a logical entity that calculates an average\n   queue depth for a queue, based\
    \ on a smoothing weight and a sampling\n   time interval.  It does this calculation\
    \ on behalf of a RED dropper,\n   to allow the dropper to make its decisions whether\
    \ to drop packets\n   based on a smoothed average queue depth for the queue.\n\
    \   The class definition is as follows:\n      NAME                DropThresholdCalculationService\n\
    \      DESCRIPTION         A concrete class representing a logical\n         \
    \                 entity that calculates an average queue\n                  \
    \        depth for a queue, based on a smoothing\n                          weight\
    \ and a sampling time interval.\n                          The latter are properties\
    \ of this\n                          Service, describing how it operates and\n\
    \                          its necessary parameters.\n      DERIVED FROM     \
    \   Service\n      TYPE                Concrete\n      PROPERTIES          SmoothingWeight,\
    \ TimeInterval\n"
- title: 4.3.27.1.  The Property SmoothingWeight
  contents:
  - "4.3.27.1.  The Property SmoothingWeight\n   This property is a 32-bit unsigned\
    \ integer, ranging between 0 and\n   100,000 - specified in thousandths.  It defines\
    \ the weighting of past\n   history in affecting the calculation of the current\
    \ average queue\n   depth.  The current queue depth calculation uses the inverse\
    \ of this\n   value as its factor, and one minus that inverse as the factor for\
    \ the\n   historical average.  The calculation takes the form:\n      average\
    \ = (old_average*(1-inverse of SmoothingWeight))\n           + (current_queue_depth*inverse\
    \ of SmoothingWeight)\n   Implementations may choose to limit the acceptable set\
    \ of values to a\n   specified set, such as powers of 2.\n   Min and max values\
    \ are 0 and 100000.\n"
- title: 4.3.27.2.  The Property TimeInterval
  contents:
  - "4.3.27.2.  The Property TimeInterval\n   This property is a 32-bit unsigned integer,\
    \ defining the number of\n   nanoseconds between each calculation of average/smoothed\
    \ queue depth.\n   If this property is not specified, the CalculationService may\n\
    \   determine an appropriate interval.\n"
- title: 4.3.28.  The Abstract Class FilterEntryBase
  contents:
  - "4.3.28.  The Abstract Class FilterEntryBase\n   FilterEntryBase is the abstract\
    \ base class from which all filter\n   entry classes are derived.  It serves as\
    \ the endpoint for the\n   EntriesInFilterList aggregation, which groups filter\
    \ entries into\n   filter lists.  Its properties include CIM naming properties\
    \ and an\n   IsNegated boolean property (to easily \"NOT\" the match information\n\
    \   specified in an instance of one of its subclasses).\n   Because FilterEntryBase\
    \ has general applicability, it is defined in\n   [PCIME].  See [PCIME] for the\
    \ definition of this class.\n"
- title: 4.3.29.  The Class IPHeaderFilter
  contents:
  - "4.3.29.  The Class IPHeaderFilter\n   This concrete class makes it possible to\
    \ represent an entire IP\n   header filter in a single object.  A property IpVersion\
    \ identifies\n   whether the IP addresses in an instance are IPv4 or IPv6 addresses.\n\
    \   (Since the source and destination IP addresses come from the same\n   packet\
    \ header, they will always be of the same type.)\n   See [PCIME] for the definition\
    \ of this class.\n"
- title: 4.3.30.  The Class 8021Filter
  contents:
  - "4.3.30.  The Class 8021Filter\n   This concrete class allows 802.1.source and\
    \ destination MAC\n   addresses, as well as the 802.1 protocol ID, priority, and\
    \ VLAN\n   identifier fields, to be expressed in a single object\n   See [PCIME]\
    \ for the definition of this class.\n"
- title: 4.3.31.  The Class PreambleFilter
  contents:
  - "4.3.31.  The Class PreambleFilter\n   This is a concrete class that models classifying\
    \ packets using\n   traffic-conditioning results stored in a packet preamble by\
    \ a\n   PreambleMarkerService.  See Section 3.8.3 for a discussion of how,\n \
    \  and why, QDDIM models the capability to store these results in a\n   packet\
    \ preamble.  An instance of PreambleFilter is used to select\n   packets based\
    \ on a two-part string identifying a specific result.\n   The logic for this match\
    \ is \"at least one\".  That is, a packet with\n   multiple results in its preamble\
    \ matches a filter if at least one of\n   these results matches the filter.\n\
    \   The class definition is as follows:\n      NAME                PreambleFilter\n\
    \      DESCRIPTION         A concrete class representing criteria\n          \
    \                for selecting packets based on prior\n                      \
    \    traffic-conditioning results stored in\n                          a packet\
    \ preamble.\n      DERIVED FROM        FilterEntryBase\n      TYPE           \
    \     Concrete\n      PROPERTIES          FilterItemList[ ]\n"
- title: 4.3.31.1.  The Multi-valued Property FilterItemList
  contents:
  - "4.3.31.1.  The Multi-valued Property FilterItemList\n   This property is an ordered\
    \ list of strings, where each string has\n   the format \"<type>,<value>\".  See\
    \ Section 3.8.3 for a list of\n   <type>'s defined in QDDIM, and the nature of\
    \ the associated <value>\n   for each of these types.\n   Note that there are\
    \ two parallel terminologies for characterizing\n   meter results.  The enumeration\
    \ value \"conforming(1)\" is sometimes\n   described as \"in profile,\" and the\
    \ value \"nonConforming(3)\" is\n   sometimes described as \"out of profile\"\
    .\n"
- title: 4.3.32.  The Class FilterList
  contents:
  - "4.3.32.  The Class FilterList\n   This is a concrete class that aggregates instances\
    \ of (subclasses of)\n   FilterEntryBase via the aggregation EntriesInFilterList.\
    \  It is\n   possible to aggregate different types of filters into a single\n\
    \   FilterList - for example, packet header filters (represented by the\n   IPHeaderFilter\
    \ class) and security filters (represented by subclasses\n   of FilterEntryBase\
    \ defined by IPsec).\n   The aggregation property EntriesInFilterList.EntrySequence\
    \ is always\n   set to 0, to indicate that the aggregated filter entries are ANDed\n\
    \   together to form a selector for a class of traffic.\n   See [PCIME] for the\
    \ definition of this class.\n"
- title: 4.3.33.  The Abstract Class ServiceAccessPoint
  contents:
  - "4.3.33.  The Abstract Class ServiceAccessPoint\n   This is an abstract class\
    \ defined in the Core Model of CIM.  It is a\n   subclass of the LogicalElement\
    \ class, and is the base class for all\n   objects that manage access to CIM_Services.\
    \  It represents the\n   management of utilizing or invoking a Service. Please\
    \ refer to [CIM]\n   for the full definition of this class.\n"
- title: 4.3.34.  The Class ProtocolEndpoint
  contents:
  - "4.3.34.  The Class ProtocolEndpoint\n   This is a concrete class derived from\
    \ ServiceAccessPoint, which\n   describes a communication point from which the\
    \ services of the\n   network or the system's protocol stack may be accessed.\
    \  Please refer\n   to [CIM] for the full definition of this class.\n"
- title: 4.3.35.  The Abstract Class Collection
  contents:
  - "4.3.35.  The Abstract Class Collection\n   This is an abstract class defined\
    \ in the Core Model of CIM.  It is\n   the superclass for all classes that represent\
    \ groupings or bags, and\n   that carry no status or \"state\".  (The latter would\
    \ be more correctly\n   modeled as ManagedSystemElements.)  Please refer to [CIM]\
    \ for the\n   full definition of this class.\n"
- title: 4.3.36.  The Abstract Class CollectionOfMSEs
  contents:
  - "4.3.36.  The Abstract Class CollectionOfMSEs\n   This is an abstract class defined\
    \ in the Core Model of CIM.  It is a\n   subclass of the Collection superclass,\
    \ restricting the contents of\n   the Collection to ManagedSystemElements.  Please\
    \ refer to [CIM] for\n   the full definition of this class.\n"
- title: 4.3.37.  The Class BufferPool
  contents:
  - "4.3.37.  The Class BufferPool\n   This is a concrete class that represents the\
    \ collection of buffers\n   used by a QueuingService.  (The association QueueAllocation\n\
    \   represents this usage.)  The existence and management of individual\n   buffers\
    \ may be modeled in a future document.  At the current level of\n   abstraction,\
    \ modeling the existence of the BufferPool is necessary.\n   Long term, it is\
    \ not sufficient.\n   In implementations where there are multiple buffer sizes,\
    \ an instance\n   of BufferPool should be defined for each set of buffers with\n\
    \   identical or similar sizes.  These instances of buffer pools can then\n  \
    \ be grouped together using the CollectedBuffersPool aggregation.\n   Note that\
    \ this class is derived from CollectionOfMSEs, and not from\n   Forwarding or\
    \ ConditioningService.  A BufferPool is only a collection\n   of storage, and\
    \ is NOT a Service.\n   The class definition is as follows:\n      NAME      \
    \          BufferPool\n      DESCRIPTION         A concrete class representing\n\
    \                          a collection of buffers.\n      DERIVED FROM      \
    \  CollectionOfMSEs\n      TYPE                Concrete\n      PROPERTIES    \
    \      Name, BufferSize, TotalBuffers,\n                          AvailableBuffers,\
    \ SharedBuffers\n"
- title: 4.3.37.1.  The Property Name
  contents:
  - "4.3.37.1.  The Property Name\n   This property is a string with a maximum length\
    \ of 256 characters.\n   It is the common name or label by which the object is\
    \ known.\n"
- title: 4.3.37.2.  The Property BufferSize
  contents:
  - "4.3.37.2.  The Property BufferSize\n   This property is a 32-bit unsigned integer,\
    \ identifying the\n   approximate number of bytes in each buffer in the buffer\
    \ pool. An\n   implementation will typically group buffers of roughly the same\
    \ size\n   together, to reduce the number of buffer pools it needs to manage.\n\
    \   This model does not specify the degree to which buffers in the same\n   buffer\
    \ pool may differ in size.\n"
- title: 4.3.37.3.  The Property TotalBuffers
  contents:
  - "4.3.37.3.  The Property TotalBuffers\n   This property is a 32-bit unsigned integer,\
    \ reporting the total\n   number of individual buffers in the pool.\n"
- title: 4.3.37.4.  The Property AvailableBuffers
  contents:
  - "4.3.37.4.  The Property AvailableBuffers\n   This property is a 32-bit unsigned\
    \ integer, reporting the number of\n   buffers in the Pool that are currently\
    \ not allocated to any instance\n   of a QueuingService.  Buffers allocated to\
    \ a QueuingService could\n   either be in use (that is, currently contain packet\
    \ data), or be\n   allocated to a queue pending the arrival of new packet data.\n"
- title: 4.3.37.5.  The Property SharedBuffers
  contents:
  - "4.3.37.5.  The Property SharedBuffers\n   This property is a 32-bit unsigned\
    \ integer, reporting the number of\n   buffers in the Pool that have been simultaneously\
    \ allocated to\n   multiple instances of QueuingService.\n"
- title: 4.3.38.  The Abstract Class SchedulingElement
  contents:
  - "4.3.38.  The Abstract Class SchedulingElement\n   This is an abstract class that\
    \ represents the configuration\n   information that a PacketSchedulingService\
    \ has for one of the\n   elements that it is scheduling.  The scheduled element\
    \ is either a\n   QueuingService or another PacketSchedulingService.\n   Among\
    \ the subclasses of this class, some are defined in such a way\n   that all of\
    \ their instances are work conserving.  Other subclasses,\n   however, may have\
    \ instances that either are or are not work\n   conserving.  In this class, the\
    \ boolean property WorkConserving\n   indicates whether an instance is or is not\
    \ work conserving.  The\n   range of values for WorkConserving is restricted to\
    \ TRUE in the\n   subclasses that are inherently work conserving, since instances\
    \ of\n   these classes cannot be anything other than work conserving.\n   The\
    \ class definition is as follows:\n      NAME                SchedulingElement\n\
    \      DESCRIPTION         An abstract class representing the\n              \
    \            configuration information that a\n                          PacketSchedulingService\
    \ has for one of\n                          the elements that it is scheduling.\n\
    \      DERIVED FROM        ManagedElement\n      TYPE                Abstract\n\
    \      PROPERTIES          WorkConserving\n"
- title: 4.3.38.1.  The Property WorkConserving
  contents:
  - "4.3.38.1.  The Property WorkConserving\n   This boolean property indicates whether\
    \ the PacketSchedulingService\n   tied to this instance by the ElementInSchedulingService\
    \ aggregation\n   is treating the input tied to this instance by the QueueToSchedule\
    \ or\n   SchedulingServiceToSchedule association in a work-conserving manner.\n\
    \   Note that this property is writable, indicating that an administrator\n  \
    \ can change the behavior of the SchedulingElement - but only for those\n   elements\
    \ that can operate in a non-workconserving mode.\n"
- title: 4.3.39.  The Class AllocationSchedulingElement
  contents:
  - "4.3.39.  The Class AllocationSchedulingElement\n   This class is a subclass of\
    \ the abstract class SchedulingElement. It\n   introduces five new properties\
    \ to support bandwidth-based scheduling.\n   As is the case with all subclasses\
    \ of SchedulingElement, the input\n   associated with an instance of AllocationSchedulingElement\
    \ is of one\n   of two types: either a queue, or another scheduler.\n   The class\
    \ definition is as follows:\n      NAME                AllocationSchedulingElement\n\
    \      DESCRIPTION         A concrete class containing parameters\n          \
    \                for controlling bandwidth-based\n                          scheduling.\n\
    \      DERIVED FROM        SchedulingElement\n      TYPE                Concrete\n\
    \      PROPERTIES          AllocationUnits, BandwidthAllocation,\n           \
    \               BurstAllocation, CanShare,\n                          WorkFlexible\n"
- title: 4.3.39.1.  The Property AllocationUnits
  contents:
  - "4.3.39.1.  The Property AllocationUnits\n   This property is a 16-bit unsigned\
    \ integer enumeration that\n   identifies the units in which the BandwidthAllocation\
    \ and\n   BurstAllocation properties are expressed.  The following values are\n\
    \   defined:\n      o bytes(1)\n      o packets(2)\n      o cells(3)       --\
    \ fixed-size, for example, ATM\n   Note: if the value of AllocationUnits is not\
    \ one of these three\n   values, it SHOULD be interpreted as if it had the value\
    \ '1' (bytes).\n"
- title: 4.3.39.2.  The Property BandwidthAllocation
  contents:
  - "4.3.39.2.  The Property BandwidthAllocation\n   This property is a 32-bit unsigned\
    \ integer that defines the number of\n   units/second that should be allocated\
    \ to the associated input.  The\n   units are identified by the AllocationUnits\
    \ property.\n"
- title: 4.3.39.3.  The Property BurstAllocation
  contents:
  - "4.3.39.3.  The Property BurstAllocation\n   This property is a 32-bit unsigned\
    \ integer that specifies the amount\n   of temporary or short-term bandwidth (in\
    \ units per second) that can\n   be allocated to an input, beyond the amount of\
    \ bandwidth allocated\n   through the BandwidthAllocation property.  If the maximum\
    \ actual\n   bandwidth allocation for the input were to be measured, it would\
    \ be\n   the sum of the BurstAllocation and the BandwidthAllocation\n   properties.\
    \  The units are identified by the AllocationUnits\n   property.\n"
- title: 4.3.39.4.  The Property CanShare
  contents:
  - "4.3.39.4.  The Property CanShare\n   This is a boolean property that, if TRUE,\
    \ enables unused bandwidth\n   from the associated input to be allocated to other\
    \ inputs serviced by\n   the Scheduler.\n"
- title: 4.3.39.5.  The Property WorkFlexible
  contents:
  - "4.3.39.5.  The Property WorkFlexible\n   This is a boolean property that, if\
    \ TRUE, indicates that the behavior\n   of the scheduler relative to this input\
    \ can be altered by changing\n   the value of the inherited property WorkConserving.\n"
- title: 4.3.40.  The Class WRRSchedulingElement
  contents:
  - "4.3.40.  The Class WRRSchedulingElement\n   This class is a subclass of the abstract\
    \ class SchedulingElement,\n   representing a weighted round robin (WRR) scheduling\
    \ discipline. It\n   introduces a new property WeightingFactor, to give some inputs\
    \ a\n   higher probability of being serviced than other inputs.  It also\n   introduces\
    \ a property Priority, to serve as a tiebreaker to be used\n   when inputs have\
    \ equal weighting factors.  As is the case with all\n   subclasses of SchedulingElement,\
    \ the input associated with an\n   instance of WRRSchedulingElement is of one\
    \ of two types: either a\n   queue, or another scheduler.\n   Because scheduling\
    \ of this type is always work conserving, the\n   inherited boolean property WorkConserving\
    \ is restricted to the value\n   TRUE in this class.\n   The class definition\
    \ is as follows:\n      NAME              WRRSchedulingElement\n      DESCRIPTION\
    \       This class specializes the\n                        SchedulingElement\
    \ class to add\n                        a per-input weight.  This is used\n  \
    \                      by a weighted round robin packet\n                    \
    \    scheduler when it handles its\n                        associated inputs.\
    \  It also adds a\n                        second property to serve as a tie-breaker\n\
    \                        in the case where multiple inputs have\n            \
    \            been assigned the same weight.\n      DERIVED FROM      SchedulingElement\n\
    \      TYPE              Concrete\n      PROPERTIES        WeightingFactor, Priority\n"
- title: 4.3.40.1.  The Property WeightingFactor
  contents:
  - "4.3.40.1.  The Property WeightingFactor\n   This property is a 32-bit unsigned\
    \ integer, which defines the\n   weighting factor that offers some inputs a higher\
    \ probability of\n   being serviced than other inputs.  This property represents\
    \ this\n   probability.  Its minimum value is 0, its maximum value is 100000,\n\
    \   and its units are in thousandths.\n"
- title: 4.3.40.2.  The Property Priority
  contents:
  - "4.3.40.2.  The Property Priority\n   This property is a 16-bit unsigned integer,\
    \ which serves as a\n   tiebreaker, in the event that two or more inputs have\
    \ equal weights.\n   A larger value represents a higher priority.  If this property\
    \ is\n   specified for any of the WRRSchedulingElements associated with a\n  \
    \ PacketSchedulingService, then it must be specified for all\n   WRRSchedulingElements\
    \ for that PacketSchedulingService, and the\n   property values for these WRRSchedulingElements\
    \ must all be\n   different.\n   While this condition may not occur in some implementations\
    \ of a\n   weighted round-robin scheduler, many implementations require a\n  \
    \ priority to resolve an equal-weight condition.  In instances where\n   this\
    \ behavior is not necessary or is undesirable, this property may\n   be left unspecified.\n"
- title: 4.3.41.  The Class PrioritySchedulingElement
  contents:
  - "4.3.41.  The Class PrioritySchedulingElement\n   This class is a subclass of\
    \ the abstract class SchedulingElement. It\n   indicates that a scheduler is taking\
    \ packets from a set of inputs\n   using the priority scheduling discipline. \
    \ As is the case with all\n   subclasses of SchedulingElement, the input associated\
    \ with an\n   instance of PrioritySchedulingElement is of one of two types: either\n\
    \   a queue, or another scheduler.  The property Priority in\n   PrioritySchedulingElement\
    \ represents the priority for an input,\n   relative to the priorities of all\
    \ the other inputs to which the\n   scheduler that aggregates this PrioritySchedulingElement\
    \ is\n   associated.  Inputs to which the scheduler is related via other\n   scheduling\
    \ disciplines do not figure in this prioritization.\n   Because scheduling of\
    \ this type is always work conserving, the\n   inherited boolean property WorkConserving\
    \ is restricted to the value\n   TRUE in this class.\n   The class definition\
    \ is as follows:\n      NAME             PrioritySchedulingElement\n      DESCRIPTION\
    \      A concrete class that specializes the\n                       SchedulingElement\
    \ class to add a\n                       Priority property.  This property is\n\
    \                       used by a SchedulingService that is doing\n          \
    \             priority scheduling for a set of  inputs.\n      DERIVED FROM  \
    \   SchedulingElement\n      TYPE             Concrete\n      PROPERTIES     \
    \  Priority\n"
- title: 4.3.41.1.  The Property Priority
  contents:
  - "4.3.41.1.  The Property Priority\n   This property is a 16-bit unsigned integer\
    \ that indicates the\n   priority level of a scheduler input relative to the other\
    \ inputs\n   serviced by this PacketSchedulingService.  A larger value represents\n\
    \   a higher priority.\n"
- title: 4.3.42.  The Class BoundedPrioritySchedulingElement
  contents:
  - "4.3.42.  The Class BoundedPrioritySchedulingElement\n   This class is a subclass\
    \ of the class PrioritySchedulingElement,\n   which is itself derived from the\
    \ abstract class SchedulingElement.\n   As is the case with all subclasses of\
    \ SchedulingElement, the input\n   associated with an instance of BoundedPrioritySchedulingElement\
    \ is of\n   one of two types: either a queue, or another scheduler.\n   BoundedPrioritySchedulingElement\
    \ adds an upper bound (in kilobits per\n   second) on how much traffic can be\
    \ handled from an input.  This data\n   is specific to that one input.  It is\
    \ needed when bounded strict\n   priority scheduling is performed.\n   This class\
    \ inherits from its superclass PrioritySchedulingElement the\n   restriction of\
    \ the inherited boolean property WorkConserving to the\n   value TRUE.\n   The\
    \ class definition is as follows:\n      NAME              BoundedPrioritySchedulingElement\n\
    \      DESCRIPTION       This concrete class specializes the\n               \
    \         PrioritySchedulingElement class to add\n                        a BandwidthBound\
    \ property.  This property\n                        bounds the rate at which traffic\
    \ from the\n                        associated input can be handled.\n      DERIVED\
    \ FROM      PrioritySchedulingElement\n      TYPE              Concrete\n    \
    \  PROPERTIES        BandwidthBound\n"
- title: 4.3.42.1.  The Property BandwidthBound
  contents:
  - "4.3.42.1.  The Property BandwidthBound\n   This property is a 32-bit unsigned\
    \ integer that defines the upper\n   limit on the amount of traffic that can be\
    \ handled from the input.\n   This is not a shaped upper bound, since bursts can\
    \ occur. It is a\n   strict bound, limiting the impact of the input.  The units\
    \ are\n   kilobits per second.\n"
- title: 4.4.  Association Definitions
  contents:
  - "4.4.  Association Definitions\n   This section details the QoS device datapath\
    \ associations, including\n   the aggregations, which were shown earlier in Figures\
    \ 4 and 5.  These\n   associations are defined as classes in the Information Model.\
    \  Each\n   of these classes has two properties referring to instances of the\
    \ two\n   classes that the association links.  Some of the association classes\n\
    \   have additional properties as well.\n"
- title: 4.4.1.  The Abstract Association Dependency
  contents:
  - "4.4.1.  The Abstract Association Dependency\n   This abstract association defines\
    \ two object references (named\n   Antecedent and Dependent) that establish general\
    \ dependency\n   relationships between different managed objects in the information\n\
    \   model.  The Antecedent reference identifies the independent object in\n  \
    \ the association, while the Dependent reference identifies the entity\n   that\
    \ IS dependent.\n   The association's cardinality is many to many.\n   The association\
    \ is defined in the Core Model of CIM.  Please refer to\n   [CIM] for the full\
    \ definition of this class.\n"
- title: 4.4.2.  The Association ServiceSAPDependency
  contents:
  - "4.4.2.  The Association ServiceSAPDependency\n   This association defines two\
    \ object references that establish a\n   general dependency relationship between\
    \ a Service object and a\n   ServiceAccessPoint object.  This relationship indicates\
    \ that the\n   referenced Service uses the ServiceAccessPoint of ANOTHER Service.\n\
    \   The Service is the Dependent reference, relying on the\n   ServiceAccessPoint\
    \ to gain access to another Service.\n   The association's cardinality is many\
    \ to many.\n   The association is defined in the Core Model of CIM.  Please refer\
    \ to\n   [CIM] for the full definition of this class.\n"
- title: 4.4.3.  The Association IngressConditioningServiceOnEndpoint
  contents:
  - "4.4.3.  The Association IngressConditioningServiceOnEndpoint\n   This association\
    \ is derived from the association\n   ServiceSAPDependency, and represents the\
    \ binding, in the ingress\n   direction, between a protocol endpoint and the first\n\
    \   ConditioningService that processes packets received via that protocol\n  \
    \ endpoint.  Since there can only be one \"first\" ConditioningService\n   for\
    \ a protocol endpoint, the cardinality for the Dependent object\n   reference\
    \ is narrowed from 0..n to 0..1. Since, on the other hand, a\n   single ConditioningService\
    \ can be the first to process packets\n   received via multiple protocol endpoints,\
    \ the cardinality of the\n   Antecedent object reference remains 0..n.\n   The\
    \ class definition is as follows:\n      NAME              IngressConditioningServiceOnEndpoint\n\
    \      DESCRIPTION       An association that establishes a\n                 \
    \       dependency relationship between a protocol\n                        endpoint\
    \ and the first conditioning\n                        service that processes traffic\
    \ arriving\n                        via that protocol endpoint.\n      DERIVED\
    \ FROM      ServiceSAPDependency\n      ABSTRACT          False\n      PROPERTIES\
    \        Antecedent[ref ProtocolEndpoint[0..n]],\n                        Dependent[ref\
    \ ConditioningService[0..1]]\n"
- title: 4.4.4.  The Association EgressConditioningServiceOnEndpoint
  contents:
  - "4.4.4.  The Association EgressConditioningServiceOnEndpoint\n   This association\
    \ is derived from the association\n   ServiceSAPDependency, and represents the\
    \ binding, in the egress\n   direction, between a protocol endpoint and the last\n\
    \   ConditioningService that processes packets before they leave a\n   network\
    \ device via that protocol endpoint.  (This \"last\"\n   ConditioningService is\
    \ ordinarily a scheduler, but it doesn't have to\n   be.)  Since there can be\
    \ multiple \"last\" ConditioningServices for a\n   protocol endpoint in the case\
    \ of a fallback scheduler, the\n   cardinality for the Dependent object reference\
    \ remains 0..n.  Since,\n   however, a single ConditioningService cannot be the\
    \ last one to\n   process packets for multiple protocol endpoints, the cardinality\
    \ of\n   the Antecedent object reference is narrowed from 0..n to 0..1.\n   The\
    \ class definition is as follows:\n      NAME              EgressConditioningServiceOnEndpoint\n\
    \      DESCRIPTION       An association that establishes a\n                 \
    \       dependency relationship between a protocol\n                        endpoint\
    \ and the last conditioning\n                        service(s) that process traffic\
    \ to be\n                        transmitted via that protocol endpoint.\n   \
    \   DERIVED FROM      ServiceSAPDependency\n      ABSTRACT          False\n  \
    \    PROPERTIES        Antecedent[ref ProtocolEndpoint[0..1]],\n             \
    \           Dependent[ref ConditioningService[0..n]]\n"
- title: 4.4.5.  The Association HeadTailDropQueueBinding
  contents:
  - "4.4.5.  The Association HeadTailDropQueueBinding\n   This association is a subclass\
    \ of Dependency, describing the\n   association between a head or tail dropper\
    \ and a queue that it\n   monitors to determine when to drop traffic.  The referenced\
    \ queue is\n   the one whose queue depth is compared against the Dropper's\n \
    \  threshold.  The cardinality is 1..n on the queue side, since a\n   head/tail\
    \ dropper must monitor at least one queue.  For the classes\n   HeadTailDropper\
    \ and HeadTailDropQueueBinding, the rule for combining\n   the inputs from multiple\
    \ queues is simple addition: if the sum of the\n   lengths of the monitored queues\
    \ exceeds the dropper's QueueThreshold\n   value, then packets are dropped.  This\
    \ rule for combining inputs may,\n   however, be overridden by a different rule\
    \ in subclasses of one or\n   both of these classes.\n   The class definition\
    \ is as follows:\n      NAME              HeadTailDropQueueBinding\n      DESCRIPTION\
    \       A generic association used to establish a\n                        dependency\
    \ relationship between a\n                        head or tail dropper and a queue\
    \ that it\n                        monitors.\n      DERIVED FROM      Dependency\n\
    \      ABSTRACT          False\n      PROPERTIES        Antecedent[ref QueuingService[1..n]],\n\
    \                        Dependent[ref\n                           HeadTailDropperService\
    \ [0..n]]\n"
- title: 4.4.6.  The Association CalculationBasedOnQueue
  contents:
  - "4.4.6.  The Association CalculationBasedOnQueue\n   This association is a subclass\
    \ of Dependency, which defines two\n   object references that establish a dependency\
    \ relationship between a\n   QueuingService and an instance of the DropThresholdCalculationService\n\
    \   class.  The queue's current depth is used by the calculation service\n   in\
    \ calculating an average queue depth.\n   The class definition is as follows:\n\
    \      NAME              CalculationBasedOnQueue\n      DESCRIPTION       A generic\
    \ association used to establish a\n                        dependency relationship\
    \ between a\n                        QueuingService object and a\n           \
    \             DropThresholdCalculationService object.\n      DERIVED FROM    \
    \  ServiceServiceDependency\n      ABSTRACT          False\n      PROPERTIES \
    \       Antecedent[ref QueuingService[1..1]],\n                        Dependent[ref\n\
    \                           DropThresholdCalculationService [0..n]]\n"
- title: 4.4.6.1.  The Reference Antecedent
  contents:
  - "4.4.6.1.  The Reference Antecedent\n   This property is inherited from the Dependency\
    \ association, and\n   overridden to serve as an object reference to a QueuingService\
    \ object\n   (instead of to the more general ManagedElement).  This reference\n\
    \   identifies the queue that the DropThresholdCalculationService will\n   use\
    \ in its calculation of average queue depth.\n"
- title: 4.4.6.2.  The Reference Dependent
  contents:
  - "4.4.6.2.  The Reference Dependent\n   This property is inherited from the Dependency\
    \ association, and\n   overridden to serve as an object reference to a\n   DropThresholdCalculationService\
    \ object (instead of to the more\n   general ManagedElement).  This reference\
    \ identifies a\n   DropThresholdCalculationService that uses the referenced queue's\n\
    \   current depth as one of the inputs to its calculation of average\n   queue\
    \ depth.\n"
- title: 4.4.7.  The Association ProvidesServiceToElement
  contents:
  - "4.4.7.  The Association ProvidesServiceToElement\n   This association defines\
    \ two object references that establish a\n   dependency relationship in which\
    \ a ManagedSystemElement depends on\n   the functionality of one or more Services.\
    \  The association's\n   cardinality is many to many.\n   The association is defined\
    \ in the Core Model of CIM.  Please refer to\n   [CIM] for the full definition\
    \ of this class.\n"
- title: 4.4.8.  The Association ServiceServiceDependency
  contents:
  - "4.4.8.  The Association ServiceServiceDependency\n   This association defines\
    \ two object references that establish a\n   dependency relationship between two\
    \ Service objects.  The particular\n   type of dependency is represented by the\
    \ TypeOfDependency property;\n   typical examples include that one Service is\
    \ required to be present\n   or required to have completed for the other Service\
    \ to operate.\n   This association is very similar to the ServiceSAPDependency\n\
    \   relationship.  For the latter, the Service is dependent on an\n   AccessPoint\
    \ to get at another Service.  In this relationship, it\n   directly identifies\
    \ its Service dependency.  Both relationships\n   should not be instantiated,\
    \ since their information is repetitive.\n   The association's cardinality is\
    \ many to many.\n   The association is defined in the Core Model of CIM.  Please\
    \ refer to\n   [CIM] for the full definition of this class.\n"
- title: 4.4.9.  The Association CalculationServiceForDropper
  contents:
  - "4.4.9.  The Association CalculationServiceForDropper\n   This association is\
    \ a subclass of ServiceServiceDependency, which\n   defines two object references\
    \ that represent the reliance of a\n   REDDropperService on a DropThresholdCalculationService\
    \ - calculating\n   an average queue depth based on the observed depths of one\
    \ or more\n   queues.\n   The class definition is as follows:\n      NAME    \
    \          CalculationServiceForDropper\n      DESCRIPTION       A generic association\
    \ used to establish a\n                        dependency relationship between\
    \ a\n                        calculation service and a\n                     \
    \   REDDropperSrevice for which it performs\n                        average queue\
    \ depth calculations\n      DERIVED FROM      ServiceServiceDependency\n     \
    \ ABSTRACT          False\n      PROPERTIES        Antecedent[ref\n          \
    \                 DropThresholdCalculationService[1..n]],\n                  \
    \      Dependent[ref REDDropperService[0..n]]\n"
- title: 4.4.9.1.  The Reference Antecedent
  contents:
  - "4.4.9.1.  The Reference Antecedent\n   This property is inherited from the ServiceServiceDependency\n\
    \   association, and overridden to serve as an object reference to a\n   DropThresholdCalculationService\
    \ object (instead of to the more\n   general Service object).  The cardinality\
    \ of the object reference is\n   1..n, indicating that a RED dropper may be served\
    \ by one or more\n   calculation services.\n"
- title: 4.4.9.2.  The Reference Dependent
  contents:
  - "4.4.9.2.  The Reference Dependent\n   This property is inherited from the ServiceServiceDependency\n\
    \   association, and overridden to serve as an object reference to a\n   REDDropperService\
    \ object (instead of to the more general Service\n   object).  This reference\
    \ identifies a RED dropper served by a\n   DropThresholdCalculationService.\n"
- title: 4.4.10.  The Association QueueAllocation
  contents:
  - "4.4.10.  The Association QueueAllocation\n   This association is a subclass of\
    \ Dependency, which defines two\n   object references that establish a dependency\
    \ relationship between a\n   QueuingService and a BufferPool that provides storage\
    \ space for the\n   packets in the queue.\n   The class definition is as follows:\n\
    \      NAME              QueueAllocation\n      DESCRIPTION       A generic association\
    \ used to establish a\n                        dependency relationship between\
    \ a\n                        QueuingService object and a BufferPool\n        \
    \                object.\n      DERIVED FROM      Dependency\n      ABSTRACT \
    \         False\n      PROPERTIES        Antecedent[ref BufferPool[0..n]],\n \
    \                       Dependent[ref QueuingService[0..n]]\n                \
    \        AllocationPercentage\n"
- title: 4.4.10.1.  The Reference Antecedent
  contents:
  - "4.4.10.1.  The Reference Antecedent\n   This property is inherited from the Dependency\
    \ association, and\n   overridden to serve as an object reference to a BufferPool\
    \ object.\n   This reference identifies the BufferPool in which packets on the\n\
    \   QueuingService's queue are stored.\n"
- title: 4.4.10.2.  The Reference Dependent
  contents:
  - "4.4.10.2.  The Reference Dependent\n   This property is inherited from the Dependency\
    \ association, and\n   overridden to serve as an object reference to a QueuingService\n\
    \   object.  This reference identifies the QueuingService whose packets\n   are\
    \ being stored in the BufferPool's buffers.\n"
- title: 4.4.10.3.  The Property AllocationPercentage
  contents:
  - "4.4.10.3.  The Property AllocationPercentage\n   This property is an 8-bit unsigned\
    \ integer with minimum value of zero\n   and maximum value of 100.  It defines\
    \ the percentage of the\n   BufferPool that should be allocated to the referenced\
    \ QueuingService.\n   If absolute sizes are desired, this would be accomplished\
    \ by defining\n   individual BufferPools of the specified sizes, with\n   QueueAllocation.AllocationPercentages\
    \ set to 100.\n"
- title: 4.4.11.  The Association ClassifierElementUsesFilterList
  contents:
  - "4.4.11.  The Association ClassifierElementUsesFilterList\n   This association\
    \ is a subclass of the Dependency association.  It\n   relates one or more ClassifierElements\
    \ with a FilterList representing\n   the criteria for selecting packets for each\
    \ of the ClassifierElements\n   to process.\n   In the QDDIM model, a classifier\
    \ is always modeled as a\n   ClassifierService that aggregates a set of ClassifierElements.\
    \ When\n   ClassifierElements use the NextServiceAfterClassifierElement\n   association\
    \ to bind to another ClassifierService (to construct a\n   hierarchical classifier),\
    \ the ClassifierElementUsesFilterList\n   association must not be specified.\n\
    \   The class definition is as follows:\n      NAME              ClassifierElementUsesFilterList\n\
    \      DESCRIPTION       An association relating a\n                        ClassifierElement\
    \ to the FilterList\n                        representing the criteria for selecting\n\
    \                        packets for that\n                        ClassifierElement\
    \ to process.\n      DERIVED FROM      Dependency\n      ABSTRACT          False\n\
    \      PROPERTIES        Antecedent[ref FilterList [0..1]],\n                \
    \        Dependent[ref ClassifierElement [0..n]]\n"
- title: 4.4.11.1.  The Reference Antecedent
  contents:
  - "4.4.11.1.  The Reference Antecedent\n   This property is inherited from the Dependency\
    \ association, and\n   overridden to serve as an object reference to a FilterList\
    \ object,\n   instead of to the more general ManagedElement object. Also, its\n\
    \   cardinality is restricted to 0 and 1, indicating that a\n   ClassifierElement\
    \ uses either one FilterList to select packets for it\n   or no FilterList when\
    \ the ClassifierElement uses the\n   NextServiceAfterClassifierElement association\
    \ to bind to another\n   ClassifierService to form a hierarchical classifier.\n"
- title: 4.4.11.2.  The Reference Dependent
  contents:
  - "4.4.11.2.  The Reference Dependent\n   This property is inherited from the Dependency\
    \ association, and\n   overridden to serve as an object reference to a ClassifierElement\n\
    \   object, instead of to the more general ManagedElement object. This\n   reference\
    \ identifies a ClassifierElement that depends on the\n   associated FilterList\
    \ object to represent its packet-selection\n   criteria.\n"
- title: 4.4.12.  The Association AFRelatedServices
  contents:
  - "4.4.12.  The Association AFRelatedServices\n   This association defines two object\
    \ references that establish a\n   dependency relationship between two AFService\
    \ objects.  This\n   dependency is the precedence of the individual AF drop-related\n\
    \   Services within an AF IP packet-forwarding class.\n   The class definition\
    \ is as follows:\n      NAME              AFRelatedServices\n      DESCRIPTION\
    \       An association used to establish\n                        a dependency\
    \ relationship between two\n                        AFService objects.\n     \
    \ DERIVED FROM      Nothing\n      ABSTRACT          False\n      PROPERTIES \
    \       AFLowerDropPrecedence[ref\n                          AFService[0..1]],\n\
    \                        AFHigherDropPrecedence[ref\n                        \
    \  AFService[0..n]]\n"
- title: 4.4.12.1.  The Reference AFLowerDropPrecedence
  contents:
  - "4.4.12.1.  The Reference AFLowerDropPrecedence\n   This property serves as an\
    \ object reference to an AFService object\n   that has the lower probability of\
    \ dropping packets.\n"
- title: 4.4.12.2.  The Reference AFHigherDropPrecedence
  contents:
  - "4.4.12.2.  The Reference AFHigherDropPrecedence\n   This property serves as an\
    \ object reference to an AFService object\n   that has the higher probability\
    \ of dropping packets.\n"
- title: 4.4.13.  The Association NextService
  contents:
  - "4.4.13.  The Association NextService\n   This association defines two object\
    \ references that establish a\n   predecessor-successor relationship between two\
    \ ConditioningService\n   objects.  This association is used to indicate the sequence\
    \ of\n   ConditioningServices required to process a particular type of\n   traffic.\n\
    \   Instances of this dependency describe the various relationships\n   between\
    \ different ConditioningServices (such as classifiers, meters,\n   droppers, etc.)\
    \ that are used collectively to condition traffic.\n   Both one-to-one and more\
    \ complicated fan-in and/or fan-out\n   relationships can be described.  The ConditioningServices\
    \ may feed\n   one another directly, or they may be mapped to multiple \"next\"\
    \n   Services based on the characteristics of the packet.\n   The class definition\
    \ is as follows:\n      NAME              NextService\n      DESCRIPTION     \
    \  An association used to establish\n                        a predecessor-successor\
    \ relationship\n                        between two ConditioningService objects.\n\
    \      DERIVED FROM      Nothing\n      ABSTRACT          False\n      PROPERTIES\
    \        PrecedingService[ref\n                          ConditioningService[0..n]],\n\
    \                        FollowingService[ref\n                          ConditioningService[0..n]]\n"
- title: 4.4.13.1.  The Reference PrecedingService
  contents:
  - "4.4.13.1.  The Reference PrecedingService\n   This property serves as an object\
    \ reference to a ConditioningService\n   object that occurs earlier in the processing\
    \ sequence for a given\n   type of traffic.\n"
- title: 4.4.13.2.  The Reference FollowingService
  contents:
  - "4.4.13.2.  The Reference FollowingService\n   This property serves as an object\
    \ reference to a ConditioningService\n   object that occurs later in the processing\
    \ sequence for a given type\n   of traffic, immediately after the ConditioningService\
    \ identified by\n   the PrecedingService object reference.\n"
- title: 4.4.14.  The Association NextServiceAfterClassifierElement
  contents:
  - "4.4.14.  The Association NextServiceAfterClassifierElement\n   This association\
    \ refines the definition of its superclass, the\n   NextService association, in\
    \ two ways:\n   o  It restricts the PrecedingService object reference to the class\n\
    \      ClassifierElement.\n   o  It restricts the cardinality of the FollowingService\
    \ object\n      reference to exactly 1.\n   The class definition is as follows:\n\
    \      NAME              NextServiceAfterClassifierElement\n      DESCRIPTION\
    \       An association used to establish\n                        a predecessor-successor\
    \ relationship\n                        between a single ClassifierElement within\n\
    \                        a Classifier and the next\n                        ConditioningService\
    \ object that is\n                        responsible for further processing of\n\
    \                        the traffic selected by that\n                      \
    \  ClassifierElement.\n      DERIVED FROM      NextService\n      ABSTRACT   \
    \       False\n      PROPERTIES        PrecedingService\n                    \
    \      [ref ClassifierElement[0..n]],\n                        FollowingService\n\
    \                          [ref ConditioningService[1..1]\n"
- title: 4.4.14.1.  The Reference PrecedingService
  contents:
  - "4.4.14.1.  The Reference PrecedingService\n   This property is inherited from\
    \ the NextService association.  It is\n   overridden in this subclass to restrict\
    \ the object reference to a\n   ClassifierElement, as opposed to the more general\
    \ ConditioningService\n   defined in the NextService superclass.\n   This property\
    \ serves as an object reference to a ClassifierElement,\n   which is a component\
    \ of a single ClassifierService.  Packets selected\n   by this ClassifierElement\
    \ are always passed to the\n   ConditioningService identified by the FollowingService\
    \ object\n   reference.\n"
- title: 4.4.14.2.  The Reference FollowingService
  contents:
  - "4.4.14.2.  The Reference FollowingService\n   This property is inherited from\
    \ the NextService association.  It is\n   overridden in this subclass to restrict\
    \ the cardinality of the\n   reference to exactly 1.  This reflects the requirement\
    \ that the\n   behavior of a DiffServ classifier must be deterministic: the packets\n\
    \   selected by a given ClassifierElement in a given ClassifierService\n   must\
    \ always go to one and only one next ConditioningService.\n"
- title: 4.4.15.  The Association NextScheduler
  contents:
  - "4.4.15.  The Association NextScheduler\n   This association is a subclass of\
    \ NextService, and defines two object\n   references that establish a predecessor-successor\
    \ relationship\n   between PacketSchedulingServices.  In a hierarchical queuing\n\
    \   configuration where a second scheduler treats the output of a first\n   scheduler\
    \ as a single, aggregated input, the two schedulers are\n   related via the NextScheduler\
    \ association.\n   The class definition is as follows:\n      NAME           \
    \   NextScheduler\n      DESCRIPTION       An association used to establish\n\
    \                        predecessor-successor relationships\n               \
    \         between PacketSchedulingService objects\n                        for\
    \ simple hierarchical scheduling.\n      DERIVED FROM      NextService\n     \
    \ ABSTRACT          False\n      PROPERTIES        PrecedingService[ref\n    \
    \                       PacketSchedulingService[0..n]],\n                    \
    \    FollowingService[ref\n                           PacketSchedulingService[0..1]]\n"
- title: 4.4.15.1.  The Reference PrecedingService
  contents:
  - "4.4.15.1.  The Reference PrecedingService\n   This property is inherited from\
    \ the NextService association, and\n   overridden to serve as an object reference\
    \ to a\n   PacketSchedulingService object (instead of to the more general\n  \
    \ ConditioningService object).  This reference identifies a scheduler\n   whose\
    \ output is being treated as a single, aggregated input by the\n   scheduler identified\
    \ by the FollowingService reference.  The [0..n]\n   cardinality indicates that\
    \ a single FollowingService scheduler may\n   bring together the aggregated outputs\
    \ of multiple prior schedulers.\n"
- title: 4.4.15.2.  The Reference FollowingService
  contents:
  - "4.4.15.2.  The Reference FollowingService\n   This property is inherited from\
    \ the NextService association, and\n   overridden to serve as an object reference\
    \ to a\n   PacketSchedulingService object (instead of to the more general\n  \
    \ ConditioningService object).  This reference identifies a scheduler\n   that\
    \ includes among its inputs the aggregated outputs of one or more\n   PrecedingService\
    \ schedulers.\n"
- title: 4.4.16.  The Association FailNextScheduler
  contents:
  - "4.4.16.  The Association FailNextScheduler\n   This association is a subclass\
    \ of the NextScheduler association.\n   FailNextScheduler represents the relationship\
    \ between two schedulers\n   when the first scheduler passes up a scheduling opportunity\
    \ (thereby\n   behaving in a non-work conserving manner), and makes the resulting\n\
    \   bandwidth available to the second scheduler for its use.  See\n   Sections\
    \ 3.11.3 and 3.11.4 for examples of where this association\n   might be used.\n\
    \   The class definition is as follows:\n      NAME              FailNextScheduler\n\
    \      DESCRIPTION       This association specializes the\n                  \
    \      NextScheduler association.  It\n                        establishes a relationship\
    \ between a\n                        non-work-conserving scheduler and a\n   \
    \                     second scheduler to which it makes\n                   \
    \     available the bandwidth that it elects\n                        not to use.\n\
    \      DERIVED FROM      NextScheduler\n      ABSTRACT          False\n      PROPERTIES\
    \        PrecedingService[ref\n                         NonWorkConservingSchedulingService[0..n]]\n"
- title: 4.4.16.1.  The Reference PrecedingService
  contents:
  - "4.4.16.1.  The Reference PrecedingService\n   This property is inherited from\
    \ the NextScheduler association, and\n   overridden to serve as an object reference\
    \ to a\n   NonWorkConservingSchedulingService object (instead of to the more\n\
    \   general PacketSchedulingService object).  This reference identifies a\n  \
    \ non-work-conserving scheduler whose excess bandwidth is being made\n   available\
    \ to the scheduler identified by the FollowingService\n   reference.  The [0..n]\
    \ cardinality indicates that a single\n   FollowingService scheduler may have\
    \ the opportunity to use the unused\n   bandwidth of multiple prior non-work-conserving\
    \ schedulers.\n"
- title: 4.4.17.  The Association NextServiceAfterMeter
  contents:
  - "4.4.17.  The Association NextServiceAfterMeter\n   This association describes\
    \ a predecessor-successor relationship\n   between a MeterService and one or more\
    \ ConditioningService objects\n   that process traffic from the meter.  For example,\
    \ for devices that\n   implement preamble marking, the FollowingService reference\
    \ (after the\n   meter) is a PreambleMarkerService, to record the results of the\n\
    \   metering in the preamble.\n   It might be expected that the NextServiceAfterMeter\
    \ association would\n   subclass from NextService.  However, meters are 1:n fan-out\
    \ elements,\n   and require a mechanism to distinguish between the different\n\
    \   results/outputs of the meter.  Therefore, this association defines a\n   new\
    \ key property, MeterResult, which is used to record the result and\n   identify\
    \ the output through which this traffic left the meter.\n   Because of this additional\
    \ key, NextServiceAfterMeter cannot be a\n   subclass of NextService.\n   The\
    \ class definition is as follows:\n      NAME              NextServiceAfterMeter\n\
    \      DESCRIPTION       An association used to establish\n                  \
    \      a predecessor-successor relationship\n                        between a\
    \ particular output of a\n                        MeterService and the next\n\
    \                        ConditioningService object that is\n                \
    \        responsible for further processing of\n                        the traffic.\n\
    \      DERIVED FROM      Nothing\n      ABSTRACT          False\n      PROPERTIES\
    \        PrecedingService[ref MeterService[0..n]],\n                        FollowingService[ref\n\
    \                          ConditioningService[0..n]],\n                     \
    \   MeterResult\n"
- title: 4.4.17.1.  The Reference PrecedingService
  contents:
  - "4.4.17.1.  The Reference PrecedingService\n   The preceding MeterService, 'earlier'\
    \ in the processing sequence for\n   a packet.  Since Meters are 1:n fan-out devices,\
    \ this relationship\n   associates a particular output of a MeterService (identified\
    \ by the\n   MeterResult property) to the next ConditioningService that is used\
    \ to\n   further process the traffic.\n"
- title: 4.4.17.2.  The Reference FollowingService
  contents:
  - "4.4.17.2.  The Reference FollowingService\n   The 'next' or following ConditioningService.\n"
- title: 4.4.17.3.  The Property MeterResult
  contents:
  - "4.4.17.3.  The Property MeterResult\n   This property is an enumerated 16-bit\
    \ unsigned integer, and\n   represents information describing the result of the\
    \ metering. Traffic\n   is distinguished as being conforming, non-conforming,\
    \ or partially\n   conforming.  More complicated metering can be built either\
    \ by\n   extending the enumeration or by cascading meters.\n   The enumerated\
    \ values are: \"Unknown\" (0), \"Conforming\" (1),\n   \"PartiallyConforming\"\
    \ (2), \"NonConforming\" (3).\n"
- title: 4.4.18.  The Association QueueToSchedule
  contents:
  - "4.4.18.  The Association QueueToSchedule\n   This is a top-level association,\
    \ representing the relationship\n   between a queue (QueuingService) and a SchedulingElement.\
    \  The\n   SchedulingElement, in turn, represents the information in a packet\n\
    \   scheduling service that is specific to this queue, such as relative\n   priority\
    \ or allocated bandwidth.\n   It cannot be expressed formally with the association\
    \ cardinalities,\n   but there is an additional constraint on participation in\
    \ this\n   association.  A particular instance of (a subclass of)\n   SchedulingElement\
    \ always participates either in exactly one instance\n   of this association,\
    \ or in exactly one instance of the association\n   SchedulingServiceToSchedule.\n\
    \   The class definition is as follows:\n      NAME              QueueToSchedule\n\
    \      DESCRIPTION       This association relates a queue to\n               \
    \         the SchedulingElement containing\n                        information\
    \ specific to the queue.\n      DERIVED FROM      Nothing\n      ABSTRACT    \
    \      False\n      PROPERTIES        Queue[ref QueuingService[0..1]],\n     \
    \                   SchedElement[ref\n                           SchedulingElement[0..n]]\n"
- title: 4.4.18.1.  The Reference Queue
  contents:
  - "4.4.18.1.  The Reference Queue\n   This property serves as an object reference\
    \ to a QueuingService\n   object.  A QueuingService object may be associated 0\
    \ or more\n   SchedulingElement objects.\n"
- title: 4.4.18.2.  The Reference SchedElement
  contents:
  - "4.4.18.2.  The Reference SchedElement\n   This property serves as an object reference\
    \ to a SchedulingElement\n   object.  A SchedulingElement is always associated\
    \ either with exactly\n   one QueuingService or with exactly one upstream scheduler\n\
    \   (PacketSchedulingService).\n"
- title: 4.4.19.  The Association SchedulingServiceToSchedule
  contents:
  - "4.4.19.  The Association SchedulingServiceToSchedule\n   This is a top-level\
    \ association, representing the relationship\n   between a scheduler (PacketSchedulingService)\
    \ and a\n   SchedulingElement, in a configuration involving cascaded schedulers.\n\
    \   The SchedulingElement, in turn, represents the information in a\n   subsequent\
    \ packet scheduling service that is specific to this\n   scheduler, such as relative\
    \ priority or allocated bandwidth.\n   It cannot be expressed formally with the\
    \ association cardinalities,\n   but there is an additional constraint on participation\
    \ in this\n   association.  A particular instance of (a subclass of)\n   SchedulingElement\
    \ always participates either in exactly one instance\n   of this association,\
    \ or in exactly one instance of the association\n   QueueToSchedule.\n   The class\
    \ definition is as follows:\n      NAME              SchedulingServiceToSchedule\n\
    \      DESCRIPTION       This association relates a scheduler to\n           \
    \             the SchedulingElement in a subsequent\n                        scheduler\
    \ containing information specific\n                        to this scheduler.\n\
    \      DERIVED FROM      Nothing\n      ABSTRACT          False\n      PROPERTIES\
    \        SchedService[ref\n                           PacketSchedulingService[0..1]],\n\
    \                        SchedElement[ref\n                           SchedulingElement[0..n]]\n"
- title: 4.4.19.1.  The Reference SchedService
  contents:
  - "4.4.19.1.  The Reference SchedService\n   This property serves as an object reference\
    \ to a\n   PacketSchedulingService object.  A PacketSchedulingService object may\n\
    \   be associated 0 or more SchedulingElement objects.\n"
- title: 4.4.19.2.  The Reference SchedElement
  contents:
  - "4.4.19.2.  The Reference SchedElement\n   This property serves as an object reference\
    \ to a SchedulingElement\n   object.  A SchedulingElement is always associated\
    \ either with exactly\n   one QueuingService or with exactly one upstream scheduler\n\
    \   (PacketSchedulingService).\n"
- title: 4.4.20.  The Aggregation MemberOfCollection
  contents:
  - "4.4.20.  The Aggregation MemberOfCollection\n   This aggregation is a generic\
    \ relationship used to model the\n   aggregation of a set of ManagedElements in\
    \ a generalized Collection\n   object.  The aggregation's cardinality is many\
    \ to many.\n   MemberOfCollection is defined in the Core Model of CIM.  Please\
    \ refer\n   to [CIM] for the full definition of this class.\n"
- title: 4.4.21.  The Aggregation CollectedBufferPool
  contents:
  - "4.4.21.  The Aggregation CollectedBufferPool\n   This aggregation models the\
    \ ability to treat a set of buffers as a\n   pool, or collection, that can in\
    \ turn be contained in a \"higher-\n   level\" buffer pool.  This class overrides\
    \ the more generic\n   MemberOfCollection aggregation to restrict both the aggregate\
    \ and the\n   part component objects to be instances only of the BufferPool class.\n\
    \   The class definition for the aggregation is as follows:\n      NAME      \
    \        CollectedBufferPool\n      DESCRIPTION       A generic association used\
    \ to aggregate\n                        a set of related buffers into a\n    \
    \                    higher-level buffer pool.\n      DERIVED FROM      MemberOfCollection\n\
    \      ABSTRACT          False\n      PROPERTIES        Collection[ref BufferPool[0..1]],\n\
    \                        Member[ref BufferPool[0..n]]\n"
- title: 4.4.21.1.  The Reference Collection
  contents:
  - "4.4.21.1.  The Reference Collection\n   This property represents the parent,\
    \ or aggregate, object in the\n   relationship.  It is a BufferPool object.\n"
- title: 4.4.21.2.  The Reference Member
  contents:
  - "4.4.21.2.  The Reference Member\n   This property represents the child, or lower\
    \ level pool, in the\n   relationship.  It is one of the set of BufferPools that\
    \ together make\n   up the higher-level pool.\n"
- title: 4.4.22.  The Abstract Aggregation Component
  contents:
  - "4.4.22.  The Abstract Aggregation Component\n   This abstract aggregation is\
    \ a generic relationship used to establish\n   \"part-of\" relationships between\
    \ managed objects (named GroupComponent\n   and PartComponent).  The association's\
    \ cardinality is many to many.\n   The association is defined in the Core Model\
    \ of CIM.  Please refer to\n   [CIM] for the full definition of this class.\n"
- title: 4.4.23.  The Aggregation ServiceComponent
  contents:
  - "4.4.23.  The Aggregation ServiceComponent\n   This aggregation is used to model\
    \ a set of subordinate Services that\n   are aggregated together to form a higher-level\
    \ Service. This\n   aggregation is derived from the more generic Component superclass\
    \ to\n   restrict the types of objects that can participate in this\n   relationship.\
    \  The association's cardinality is many to many.\n   The association is defined\
    \ in the Core Model of CIM.  Please refer to\n   [CIM] for the full definition\
    \ of this class.\n"
- title: 4.4.24.  The Aggregation QoSSubService
  contents:
  - "4.4.24.  The Aggregation QoSSubService\n   This aggregation represents a set\
    \ of subordinate QoSService objects\n   (that is, a set of instances of subclasses\
    \ of the QoSService class)\n   that are aggregated together to form a higher-level\
    \ QoSService.  A\n   QoSService is a specific type of Service that conceptualizes\
    \ QoS\n   functionality as a set of coordinated sub-services.\n   This aggregation\
    \ is derived from the more generic ServiceComponent\n   superclass to restrict\
    \ the types of objects that can participate in\n   this relationship to QoSService\
    \ objects, instead of a more generic\n   Service object.  It also restricts the\
    \ cardinality of the aggregate\n   to 0-or-1 (instead of the more generic 0-or-more).\n\
    \   The class definition for the aggregation is as follows:\n      NAME      \
    \        QoSSubService\n      DESCRIPTION       A generic association used to\
    \ establish\n                        \"part-of\" relationships between a\n   \
    \                     higher-level QoSService object and the\n               \
    \         set of lower-level QoSServices that\n                        are aggregated\
    \ to create/form it.\n      DERIVED FROM      ServiceComponent\n      ABSTRACT\
    \          False\n      PROPERTIES        GroupComponent[ref QoSService[0..1]],\n\
    \                        PartComponent[ref QoSService[0..n]]\n"
- title: 4.4.24.1.  The Reference GroupComponent
  contents:
  - "4.4.24.1.  The Reference GroupComponent\n   This property is overridden in this\
    \ aggregation to represent an\n   object reference to a QoSService object (instead\
    \ of to the more\n   generic Service object defined in its superclass).  This\
    \ object\n   represents the parent, or aggregate, object in the relationship.\n"
- title: 4.4.24.2.  The Reference PartComponent
  contents:
  - "4.4.24.2.  The Reference PartComponent\n   This property is overridden in this\
    \ aggregation to represent an\n   object reference to a QoSService object (instead\
    \ of to the more\n   generic Service object defined in its superclass).  This\
    \ object\n   represents the child, or \"component\", object in the relationship.\n"
- title: 4.4.25.  The Aggregation QoSConditioningSubService
  contents:
  - "4.4.25.  The Aggregation QoSConditioningSubService\n   This aggregation identifies\
    \ the set of conditioning services that\n   together condition traffic for a particular\
    \ QoS service.\n   This aggregation is derived from the more generic ServiceComponent\n\
    \   superclass; it restricts the types of objects that can participate in\n  \
    \ it to ConditioningService and QoSService objects, instead of the more\n   generic\
    \ Service objects.\n   The class definition for the aggregation is as follows:\n\
    \      NAME              QoSConditioningSubService\n      DESCRIPTION       A\
    \ generic aggregation used to establish\n                        \"part-of\" relationships\
    \ between a set\n                        of ConditioningService objects and the\n\
    \                        particular QoSService object(s) that they\n         \
    \               provide traffic conditioning for.\n      DERIVED FROM      ServiceComponent\n\
    \      ABSTRACT          False\n      PROPERTIES        GroupComponent[ref QoSService[0..n]],\n\
    \                        PartComponent[ref\n                          ConditioningService[0..n]]\n"
- title: 4.4.25.1.  The Reference GroupComponent
  contents:
  - "4.4.25.1.  The Reference GroupComponent\n   This property is overridden in this\
    \ aggregation to represent an\n   object reference to a QoSService object (instead\
    \ of to the more\n   generic Service object defined in its superclass).  The cardinality\n\
    \   of the reference remains 0..n, to indicate that a given\n   ConditioningService\
    \ may provide traffic conditioning for 0, 1, or\n   more than 1 QoSService objects.\n\
    \   This object represents the parent, or aggregate, object in the\n   association.\
    \  In this case, this object represents the QoSService\n   that aggregates one\
    \ or more ConditioningService objects to implement\n   the appropriate traffic\
    \ conditioning for its traffic.\n"
- title: 4.4.25.2.  The Reference PartComponent
  contents:
  - "4.4.25.2.  The Reference PartComponent\n   This property is overridden in this\
    \ aggregation to represent an\n   object reference to a ConditioningService object\
    \ (instead of to the\n   more generic Service object defined in its superclass).\
    \  This object\n   represents the child, or \"component\", object in the relationship.\
    \  In\n   this case, this object represents one or more ConditioningService\n\
    \   objects that together indicate how traffic for a specific QoSService\n   is\
    \ conditioned.\n"
- title: 4.4.26.  The Aggregation ClassifierElementInClassifierService
  contents:
  - "4.4.26.  The Aggregation ClassifierElementInClassifierService\n   This aggregation\
    \ represents the relationship between a classifier and\n   the classifier elements\
    \ that provide the fan-out function for the\n   classifier.  A classifier typically\
    \ aggregates multiple classifier\n   elements.  A classifier element, however,\
    \ is aggregated only by a\n   single classifier.  See [DSMODEL] and [DSMIB] for\
    \ more about\n   classifiers and classifier elements.\n   The class definition\
    \ for the aggregation is as follows:\n      NAME              ClassifierElementInClassifierService\n\
    \      DESCRIPTION       An aggregation representing the\n                   \
    \     relationship between a classifier\n                        and its classifier\
    \ elements.\n      DERIVED FROM      ServiceComponent\n      ABSTRACT        \
    \  False\n      PROPERTIES        GroupComponent[ref\n                       \
    \    ClassifierService[1..1]],\n                        PartComponent[ref\n  \
    \                         ClassifierElement[0..n],\n                        ClassifierOrder\n"
- title: 4.4.26.1.  The Reference GroupComponent
  contents:
  - "4.4.26.1.  The Reference GroupComponent\n   This property is overridden in this\
    \ aggregation to represent an\n   object reference to a ClassifierService object\
    \ (instead of to the\n   more generic Service object defined in its superclass).\
    \  It also\n   restricts the cardinality of the aggregate to 1..1 (instead of\
    \ the\n   more generic 0-or-more), representing the fact that a\n   ClassifierElement\
    \ always exists within the context of exactly one\n   ClassifierService.\n"
- title: 4.4.26.2.  The Reference PartComponent
  contents:
  - "4.4.26.2.  The Reference PartComponent\n   This property is overridden in this\
    \ aggregation to represent an\n   object reference to a ClassifierElement object\
    \ (instead of to the\n   more generic Service object defined in its superclass).\
    \  This object\n   represents a single traffic selector for the classifier. A\n\
    \   ClassifierElement usually has an association to a FilterList that\n   provides\
    \ selection criteria for packets from the traffic stream\n   coming into the classifier,\
    \ and to a ConditioningService to which\n   packets selected by these criteria\
    \ are next forwarded.\n"
- title: 4.4.26.3.  The Property ClassifierOrder
  contents:
  - "4.4.26.3.  The Property ClassifierOrder\n   Because the filters for a classifier\
    \ can overlap, it is necessary to\n   specify the order in which the ClassifierElements\
    \ aggregated by a\n   ClassifierService are presented with packets coming into\
    \ the\n   classifier.  This property is an unsigned 32-bit integer representing\n\
    \   this order.  Values are represented in ascending order: first '1',\n   then\
    \ '2', and so on.  Different values MUST be assigned for each of\n   the ClassifierElements\
    \ aggregated by a given ClassifierService.\n"
- title: 4.4.27.  The Aggregation EntriesInFilterList
  contents:
  - "4.4.27.  The Aggregation EntriesInFilterList\n   This aggregation is a specialization\
    \ of the Component aggregation; it\n   is used to define a set of filter entries\
    \ (subclasses of\n   FilterEntryBase) that are aggregated by a FilterList.\n \
    \  The cardinalities of the aggregation itself are 0..1 on the\n   FilterList\
    \ end, and 0..n on the FilterEntryBase end.  Thus in the\n   general case, a filter\
    \ entry can exist without being aggregated into\n   any FilterList.  However,\
    \ the only way a filter entry can figure in\n   the QoS Device model is by being\
    \ aggregated into a FilterList by this\n   aggregation.\n   See [PCIME] for the\
    \ definition of this aggregation.\n"
- title: 4.4.28.  The Aggregation ElementInSchedulingService
  contents:
  - "4.4.28.  The Aggregation ElementInSchedulingService\n   This concrete aggregation\
    \ represents the relationship between a\n   PacketSchedulingService and the set\
    \ of SchedulingElements that tie it\n   to its inputs.\n   The class definition\
    \ for the aggregation is as follows:\n      NAME              ElementInSchedulingService\n\
    \      DESCRIPTION       An aggregation used to tie a\n                      \
    \  PacketSchedlingService to the\n                        configuration information\
    \ for one of\n                        the elements (either a QueuingService or\n\
    \                        another PacketSchedulingService) that it\n          \
    \              schedules.\n      DERIVED FROM      Component\n      ABSTRACT \
    \         False\n      PROPERTIES        GroupComponent[ref\n                \
    \          PacketSchedulingService[0..1]],\n                        PartComponent[ref\n\
    \                           SchedulingElement[1..n]\n"
- title: 4.4.28.1.  The Reference GroupComponent
  contents:
  - "4.4.28.1.  The Reference GroupComponent\n   This property is overridden in this\
    \ aggregation to represent an\n   object reference to a PacketSchedulingService\
    \ object (instead of to\n   the more generic Service object defined in its superclass).\
    \ It also\n   restricts the cardinality of the aggregate to 0..1 (instead of the\n\
    \   more generic 0-or-more), representing the fact that a\n   SchedulingElement\
    \ exists within the context of at most one\n   PacketSchedulingService.\n"
- title: 4.4.28.2.  The Reference PartComponent
  contents:
  - "4.4.28.2.  The Reference PartComponent\n   This property is overridden in this\
    \ aggregation to represent an\n   object reference to a SchedulingElement object\
    \ (instead of to the\n   more generic Service object defined in its superclass).\
    \  This object\n   represents a single scheduling element for the scheduler. It\
    \ also\n   restricts the cardinality of the SchedulingElement to 1..n (instead\n\
    \   of the more generic 0-or-more), representing the fact that a\n   PacketSchedulingService\
    \ always includes at least one\n   SchedulingElement.\n"
- title: 5.  Intellectual Property Statement
  contents:
  - "5.  Intellectual Property Statement\n   The IETF takes no position regarding\
    \ the validity or scope of any\n   intellectual property or other rights that\
    \ might be claimed to\n   pertain to the implementation or use of the technology\
    \ described in\n   this document or the extent to which any license under such\
    \ rights\n   might or might not be available; neither does it represent that it\n\
    \   has made any effort to identify any such rights. Information on the\n   IETF's\
    \ procedures with respect to rights in standards-track and\n   standards-related\
    \ documentation can be found in BCP-11.\n   Copies of claims of rights made available\
    \ for publication and any\n   assurances of licenses to be made available, or\
    \ the result of an\n   attempt made to obtain a general license or permission\
    \ for the use of\n   such proprietary rights by implementers or users of this\n\
    \   specification can be obtained from the IETF Secretariat.\n   The IETF invites\
    \ any interested party to bring to its attention any\n   copyrights, patents or\
    \ patent applications, or other proprietary\n   rights which may cover technology\
    \ that may be required to practice\n   this standard.  Please address the information\
    \ to the IETF Executive\n   Director.\n"
- title: 6.  Acknowledgements
  contents:
  - "6.  Acknowledgements\n   The authors wish to thank the participants of the Policy\
    \ Framework\n   and Differentiated Services working groups for their many helpful\n\
    \   comments and suggestions.  Special thanks to Joel Halpern, who\n   provided\
    \ some key technical direction during the latter stages of the\n   document's\
    \ development.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   Like [PCIM] and [PCIME], this document defines\
    \ an information model\n   that cannot be implemented directly.  Consequently,\
    \ security issues\n   do not arise until it is mapped to an actual, implementable\
    \ data\n   model such as a MIB, PIB, or LDAP schema.  See [PCIM] for a general\n\
    \   discussion of security considerations for information models.  See\n   also\
    \ [DSMIB] (which in fact is a data model that corresponds to a\n   large extent\
    \ with the QDDIM information model), for a discussion of\n   the security implications\
    \ of specific objects in the model.\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [CIM]      Common Information Model (CIM) Schema,\
    \ version 2.5.\n              Distributed Management Task Force, Inc., available\
    \ at\n              http://www.dmtf.org/standards/cim_schema_v25.php.\n   [IEEE802Q]\
    \ Virtual Bridged Local Area Networks, ANSI/IEEE std 802.1Q,\n              1998\
    \ edition.  Approved December 8, 1998\n   [PCIM]     Moore, B., Ellesson, E.,\
    \ Strassner, J. and A. Westerinen,\n              \"Policy Core Information Model\
    \ - Version 1 Specification\",\n              RFC 3060, February 2001.\n   [PCIME]\
    \    Moore, B., Ed., \"Policy Core Information Model (PCIM)\n              Extensions\"\
    , RFC 3460, January 2003.\n   [R791]     Postel, J., \"Internet Protocol\", STD\
    \ 5, RFC 791, September\n              1981.\n   [R2119]    Bradner, S., \"Key\
    \ words for use in RFCs to Indicate\n              Requirement Levels\", BCP 14,\
    \ RFC 2119, March 1997.\n   [R2474]    Nichols, K., Blake, S., Baker, F. and D.\
    \ Black,\n              \"Definition of the Differentiated Services Field (DS\n\
    \              Field) in the IPv4 and IPv6 Headers\", RFC 2474, December\n   \
    \           1998.\n   [R2597]    Heinanen, J., Baker, F., Weiss, W. and J. Wroclawski,\n\
    \              \"Assured Forwarding PHB Group\", RFC 2597, June 1999.\n   [R3140]\
    \    Black, D., Brim, S., Carpenter, B. and F. Le Faucheur,\n              \"\
    Per Hop Behavior Identification Codes\", RFC 3140, June\n              2001.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [DSMIB]    Baker, F., Chan, K. and A. Smith,\
    \ \"Management Information\n              Base for the Differentiated Services\
    \ Architecture\", RFC\n              3289, May 2002.\n   [DSMODEL]  Bernet, Y.,\
    \ Blake, S., Grossman, D. and A. Smith, \"An\n              Informal Management\
    \ Model for DiffServ Routers\", RFC 3290,\n              May 2002.\n   [PIB] \
    \     Chan, K., Sahita, R., Hahn, S. and K. McCloghrie,\n              \"Differentiated\
    \ Services Quality of Service Policy\n              Information Base\", RFC 3317,\
    \ March 2003.\n   [POLTERM]  Westerinen, A., Schnizlein, J., Strassner, J., Scherling,\n\
    \              M., Quinn, B., Herzog, S., Huynh, A., Carlson, M., Perry,\n   \
    \           J. and S. Waldbusser, \"Terminology for Policy-Based\n           \
    \   Management\", RFC 3198, November 2001.\n   [QPIM]     Snir, Y., Ramberg, Y.,\
    \ Strassner, J., Cohen, R. and B.\n              Moore, \"Policy Quality of Service\
    \ (QoS) Information\n              Model\", RFC 3644, November 2003.\n   [R1633]\
    \    Braden, R., Clark, D. and S. Shenker, \"Integrated Services\n           \
    \   in the Internet Architecture: An Overview\",  RFC 1633,\n              June\
    \ 1994.\n   [R2475]    Blake, S., Black, D., Carlson, M., Davies, E., Wang, Z.\n\
    \              and W. Weiss, \"An Architecture for Differentiated\n          \
    \    Service\", RFC 2475, December 1998.\n   [R3246]    Davie, B., Charny, A.,\
    \ Bennet, J.C.R., Benson, K., Le\n              Boudec, J.Y., Courtney, W., Davari,\
    \ S., Firoiu, V. and D.\n              Stiliadis, \"An Expedited Forwarding PHB\
    \ (Per-Hop\n              Behavior)\", RFC 3246, March 2002.\n   [RED]      See\
    \ http://www.aciri.org/floyd/red.html\n"
- title: '9.  Appendix A:  Naming Instances in a Native CIM Implementation'
  contents:
  - "9.  Appendix A:  Naming Instances in a Native CIM Implementation\n   Following\
    \ the precedent established in [PCIM], this document has\n   placed the details\
    \ of how to name instances of its classes in a\n   native CIM implementation here\
    \ in an appendix.  Since Appendix A in\n   [PCIM] has a lengthy discussion of\
    \ the general principles of CIM\n   naming, this appendix does not repeat that\
    \ information here.  Readers\n   interested in a more global discussion of how\
    \ instances are named in\n   a native CIM implementation should refer to [PCIM].\n"
- title: 9.1.  Naming Instances of the Classes Derived from Service
  contents:
  - "9.1.  Naming Instances of the Classes Derived from Service\n   Most of the classes\
    \ defined in this model are derived from the CIM\n   class Service.  Although\
    \ Service is an abstract class, it\n   nevertheless has key properties included\
    \ as part of its definition.\n   The purpose of including key properties in an\
    \ abstract class is to\n   have instances of all of its instantiable subclasses\
    \ named in the\n   same way.  Thus, the majority of the classes in this model\
    \ name their\n   instances in exactly the same way: with the two key properties\n\
    \   CreationClassName and Name that they inherit from Service.\n"
- title: 9.2.  Naming Instances of Subclasses of FilterEntryBase
  contents:
  - "9.2.  Naming Instances of Subclasses of FilterEntryBase\n   Like Service, FilterEntryBase\
    \ (defined in [PCIME]) is an abstract\n   class that includes key properties in\
    \ its definition.\n   FilterEntryBase has four key properties.  Two of them,\n\
    \   SystemCreationClassName and SystemName, are propagated to it via the\n   weak\
    \ association FilterEntryInSystem.  The other two,\n   CreationClassName and Name,\
    \ are native to FilterEntryBase.\n   Thus, instances of all of the subclasses\
    \ of FilterEntryBase,\n   including the PreambleFilter class defined here, are\
    \ named in the\n   same way: with the four key properties they inherit from\n\
    \   FilterEntryBase.\n"
- title: 9.3.  Naming Instances of ProtocolEndpoint
  contents:
  - "9.3.  Naming Instances of ProtocolEndpoint\n   The class ProtocolEndpoint inherits\
    \ its key properties from its\n   superclass, ServiceAccessPoint.  These key properties\
    \ provide the\n   same naming structure that we've seen before: two propagated\
    \ key\n   properties SystemCreationClassName and SystemName, plus two native\n\
    \   key properties CreationClassName and Name.\n"
- title: 9.4.  Naming Instances of BufferPool
  contents:
  - "9.4.  Naming Instances of BufferPool\n   Unlike the other classes in this model,\
    \ BufferPool is not derived\n   from Service.  Consequently, it does not inherit\
    \ its key properties\n   from Service.  Instead, it inherits one of its key properties,\n\
    \   CollectionID, from its superclass Collection, and adds its other key\n   property,\
    \ CreationClassName, in its own definition.\n"
- title: 9.4.1.  The Property CollectionID
  contents:
  - "9.4.1.  The Property CollectionID\n   CollectionID is a string property with\
    \ a maximum length of 256\n   characters.  It identifies the buffer pool.  Note\
    \ that this property\n   is defined in the BufferPool class's superclass, CollectionOfMSEs,\n\
    \   but not as a key property.  It is overridden in BufferPool, to make\n   it\
    \ part of this class's composite key.\n"
- title: 9.4.2.  The Property CreationClassName
  contents:
  - "9.4.2.  The Property CreationClassName\n   This property is a string property\
    \ of with a maximum length of 256\n   characters.  It is set to \"CIM_BufferPool\"\
    \ if this class is directly\n   instantiated, or to the class name of the BufferPool\
    \ subclass that is\n   created.\n"
- title: 9.5.  Naming Instances of SchedulingElement
  contents:
  - "9.5.  Naming Instances of SchedulingElement\n   This class has not yet been incorporated\
    \ into the CIM model, so it\n   does not have any CIM naming properties yet. \
    \ If the normal pattern\n   is followed, however, instances will be named with\
    \ two properties\n   CreationClassName and Name.\n"
- title: 10.  Authors' Addresses
  contents:
  - "10.  Authors' Addresses\n   Bob Moore\n   P. O. Box 12195, BRQA/B501/G206\n \
    \  3039 Cornwallis Rd.\n   Research Triangle Park, NC  27709-2195\n   Phone: (919)\
    \ 254-4436\n   EMail: remoore@us.ibm.com\n   David Durham\n   Intel\n   2111 NE\
    \ 25th Avenue\n   Hillsboro, OR 97124\n   Phone: (503) 264-6232\n   EMail: david.durham@intel.com\n\
    \   John Strassner\n   INTELLIDEN, Inc.\n   90 South Cascade Avenue\n   Colorado\
    \ Springs, CO  80903\n   Phone: (719) 785-0648\n   EMail: john.strassner@intelliden.com\n\
    \   Andrea Westerinen\n   Cisco Systems, Bldg 20\n   725 Alder Drive\n   Milpitas,\
    \ CA 95035\n   EMail: andreaw@cisco.com\n   Walter Weiss\n   Ellacoya Networks\n\
    \   7 Henry Clay Dr.\n   Merrimack, NH 03054\n   Phone: (603) 879-7364\n   EMail:\
    \ walterweiss@attbi.com\n"
- title: 11.  Full Copyright Statement
  contents:
  - "11.  Full Copyright Statement\n   Copyright (C) The Internet Society (2004).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assignees.\n\
    \   This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
