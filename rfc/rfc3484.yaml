- title: __initial_text__
  contents:
  - '   Default Address Selection for Internet Protocol version 6 (IPv6)

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes two algorithms, for source address selection\n\
    \   and for destination address selection.  The algorithms specify\n   default\
    \ behavior for all Internet Protocol version 6 (IPv6)\n   implementations.  They\
    \ do not override choices made by applications\n   or upper-layer protocols, nor\
    \ do they preclude the development of\n   more advanced mechanisms for address\
    \ selection.  The two algorithms\n   share a common context, including an optional\
    \ mechanism for allowing\n   administrators to provide policy that can override\
    \ the default\n   behavior.  In dual stack implementations, the destination address\n\
    \   selection algorithm can consider both IPv4 and IPv6 addresses -\n   depending\
    \ on the available source addresses, the algorithm might\n   prefer IPv6 addresses\
    \ over IPv4 addresses, or vice-versa.\n   All IPv6 nodes, including both hosts\
    \ and routers, must implement\n   default address selection as defined in this\
    \ specification.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.    Introduction................................................2\n\
    \         1.1.  Conventions Used in This Document.....................4\n   2.\
    \    Context in Which the Algorithms Operate.....................4\n         2.1.\
    \  Policy Table..........................................5\n         2.2.  Common\
    \ Prefix Length..................................6\n   3.    Address Properties..........................................6\n\
    \         3.1.  Scope Comparisons.....................................7\n    \
    \     3.2.  IPv4 Addresses and IPv4-Mapped Addresses..............7\n        \
    \ 3.3.  Other IPv6 Addresses with Embedded IPv4 Addresses.....8\n         3.4.\
    \  IPv6 Loopback Address and Other Format Prefixes.......8\n         3.5.  Mobility\
    \ Addresses....................................8\n   4.    Candidate Source Addresses..................................8\n\
    \   5.    Source Address Selection...................................10\n   6.\
    \    Destination Address Selection..............................12\n   7.    Interactions\
    \ with Routing..................................14\n   8.    Implementation Considerations..............................15\n\
    \   9.    Security Considerations....................................15\n   10.\
    \   Examples...................................................16\n         10.1.\
    \ Default Source Address Selection.....................16\n         10.2. Default\
    \ Destination Address Selection................17\n         10.3. Configuring\
    \ Preference for IPv6 or IPv4..............18\n         10.4. Configuring Preference\
    \ for Scoped Addresses..........19\n         10.5. Configuring a Multi-Homed Site.......................19\n\
    \   Normative References.............................................21\n   Informative\
    \ References...........................................22\n   Acknowledgments..................................................23\n\
    \   Author's Address.................................................23\n   Full\
    \ Copyright Statement.........................................24\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   The IPv6 addressing architecture [1] allows multiple unicast\n\
    \   addresses to be assigned to interfaces.  These addresses may have\n   different\
    \ reachability scopes (link-local, site-local, or global).\n   These addresses\
    \ may also be \"preferred\" or \"deprecated\" [2].  Privacy\n   considerations\
    \ have introduced the concepts of \"public addresses\" and\n   \"temporary addresses\"\
    \ [3].  The mobility architecture introduces\n   \"home addresses\" and \"care-of\
    \ addresses\" [8].  In addition, multi-\n   homing situations will result in more\
    \ addresses per node.  For\n   example, a node may have multiple interfaces, some\
    \ of them tunnels or\n   virtual interfaces, or a site may have multiple ISP attachments\
    \ with\n   a global prefix per ISP.\n   The end result is that IPv6 implementations\
    \ will very often be faced\n   with multiple possible source and destination addresses\
    \ when\n   initiating communication.  It is desirable to have default\n   algorithms,\
    \ common across all implementations, for selecting source\n   and destination\
    \ addresses so that developers and administrators can\n   reason about and predict\
    \ the behavior of their systems.\n   Furthermore, dual or hybrid stack implementations,\
    \ which support both\n   IPv6 and IPv4, will very often need to choose between\
    \ IPv6 and IPv4\n   when initiating communication.  For example, when DNS name\
    \ resolution\n   yields both IPv6 and IPv4 addresses and the network protocol\
    \ stack\n   has available both IPv6 and IPv4 source addresses.  In such cases,\
    \ a\n   simple policy to always prefer IPv6 or always prefer IPv4 can produce\n\
    \   poor behavior.  As one example, suppose a DNS name resolves to a\n   global\
    \ IPv6 address and a global IPv4 address.  If the node has\n   assigned a global\
    \ IPv6 address and a 169.254/16 auto-configured IPv4\n   address [9], then IPv6\
    \ is the best choice for communication.  But if\n   the node has assigned only\
    \ a link-local IPv6 address and a global\n   IPv4 address, then IPv4 is the best\
    \ choice for communication.  The\n   destination address selection algorithm solves\
    \ this with a unified\n   procedure for choosing among both IPv6 and IPv4 addresses.\n\
    \   The algorithms in this document are specified as a set of rules that\n   define\
    \ a partial ordering on the set of addresses that are available\n   for use. \
    \ In the case of source address selection, a node typically\n   has multiple addresses\
    \ assigned to its interfaces, and the source\n   address ordering rules in section\
    \ 5 define which address is the\n   \"best\" one to use.  In the case of destination\
    \ address selection, the\n   DNS may return a set of addresses for a given name,\
    \ and an\n   application needs to decide which one to use first, and in what order\n\
    \   to try others should the first one not be reachable.  The destination\n  \
    \ address ordering rules in section 6, when applied to the set of\n   addresses\
    \ returned by the DNS, provide such a recommended ordering.\n   This document\
    \ specifies source address selection and destination\n   address selection separately,\
    \ but using a common context so that\n   together the two algorithms yield useful\
    \ results.  The algorithms\n   attempt to choose source and destination addresses\
    \ of appropriate\n   scope and configuration status (preferred or deprecated in\
    \ the RFC\n   2462 sense).  Furthermore, this document suggests a preferred method,\n\
    \   longest matching prefix, for choosing among otherwise equivalent\n   addresses\
    \ in the absence of better information.\n   This document also specifies policy\
    \ hooks to allow administrative\n   override of the default behavior.  For example,\
    \ using these hooks an\n   administrator can specify a preferred source prefix\
    \ for use with a\n   destination prefix, or prefer destination addresses with\
    \ one prefix\n   over addresses with another prefix.  These hooks give an\n  \
    \ administrator flexibility in dealing with some multi-homing and\n   transition\
    \ scenarios, but they are certainly not a panacea.\n   The selection rules specified\
    \ in this document MUST NOT be construed\n   to override an application or upper-layer's\
    \ explicit choice of a\n   legal destination or source address.\n"
- title: 1.1. Conventions Used in This Document
  contents:
  - "1.1. Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in BCP 14, RFC 2119 [4].\n"
- title: 2. Context in Which the Algorithms Operate
  contents:
  - "2. Context in Which the Algorithms Operate\n   Our context for address selection\
    \ derives from the most common\n   implementation architecture, which separates\
    \ the choice of\n   destination address from the choice of source address.  Consequently,\n\
    \   we have two separate algorithms for these tasks.  The algorithms are\n   designed\
    \ to work well together and they share a mechanism for\n   administrative policy\
    \ override.\n   In this implementation architecture, applications use APIs [10]\
    \ like\n   getaddrinfo() that return a list of addresses to the application.\n\
    \   This list might contain both IPv6 and IPv4 addresses (sometimes\n   represented\
    \ as IPv4-mapped addresses).  The application then passes a\n   destination address\
    \ to the network stack with connect() or sendto().\n   The application would then\
    \ typically try the first address in the\n   list, looping over the list of addresses\
    \ until it finds a working\n   address.  In any case, the network layer is never\
    \ in a situation\n   where it needs to choose a destination address from several\n\
    \   alternatives.  The application might also specify a source address\n   with\
    \ bind(), but often the source address is left unspecified.\n   Therefore the\
    \ network layer does often choose a source address from\n   several alternatives.\n\
    \   As a consequence, we intend that implementations of getaddrinfo()\n   will\
    \ use the destination address selection algorithm specified here\n   to sort the\
    \ list of IPv6 and IPv4 addresses that they return.\n   Separately, the IPv6 network\
    \ layer will use the source address\n   selection algorithm when an application\
    \ or upper-layer has not\n   specified a source address.  Application of this\
    \ specification to\n   source address selection in an IPv4 network layer may be\
    \ possible but\n   this is not explored further here.\n   Well-behaved applications\
    \ SHOULD iterate through the list of\n   addresses returned from getaddrinfo()\
    \ until they find a working\n   address.\n   The algorithms use several criteria\
    \ in making their decisions.  The\n   combined effect is to prefer destination/source\
    \ address pairs for\n   which the two addresses are of equal scope or type, prefer\
    \ smaller\n   scopes over larger scopes for the destination address, prefer non-\n\
    \   deprecated source addresses, avoid the use of transitional addresses\n   when\
    \ native addresses are available, and all else being equal prefer\n   address\
    \ pairs having the longest possible common prefix.  For source\n   address selection,\
    \ public addresses [3] are preferred over temporary\n   addresses.  In mobile\
    \ situations [8], home addresses are preferred\n   over care-of addresses.  If\
    \ an address is simultaneously a home\n   address and a care-of address (indicating\
    \ the mobile node is \"at\n   home\" for that address), then the home/care-of\
    \ address is preferred\n   over addresses that are solely a home address or solely\
    \ a care-of\n   address.\n   This specification optionally allows for the possibility\
    \ of\n   administrative configuration of policy that can override the default\n\
    \   behavior of the algorithms.  The policy override takes the form of a\n   configurable\
    \ table that specifies precedence values and preferred\n   source prefixes for\
    \ destination prefixes.  If an implementation is\n   not configurable, or if an\
    \ implementation has not been configured,\n   then the default policy table specified\
    \ in this document SHOULD be\n   used.\n"
- title: 2.1. Policy Table
  contents:
  - "2.1. Policy Table\n   The policy table is a longest-matching-prefix lookup table,\
    \ much like\n   a routing table.  Given an address A, a lookup in the policy table\n\
    \   produces two values:  a precedence value Precedence(A) and a\n   classification\
    \ or label Label(A).\n   The precedence value Precedence(A) is used for sorting\
    \ destination\n   addresses.  If Precedence(A) > Precedence(B), we say that address\
    \ A\n   has higher precedence than address B, meaning that our algorithm will\n\
    \   prefer to sort destination address A before destination address B.\n   The\
    \ label value Label(A) allows for policies that prefer a particular\n   source\
    \ address prefix for use with a destination address prefix.  The\n   algorithms\
    \ prefer to use a source address S with a destination\n   address D if Label(S)\
    \ = Label(D).\n   IPv6 implementations SHOULD support configurable address selection\n\
    \   via a mechanism at least as powerful as the policy tables defined\n   here.\
    \  Note that at the time of this writing there is only limited\n   experience\
    \ with the use of policies that select from a set of\n   possible IPv6 addresses.\
    \  As more experience is gained, the\n   recommended default policies may change.\
    \  Consequently it is\n   important that implementations provide a way to change\
    \ the default\n   policies as more experience is gained.  Sections 10.3 and 10.4\n\
    \   provide examples of the kind of changes that might be needed.\n   If an implementation\
    \ is not configurable or has not been configured,\n   then it SHOULD operate according\
    \ to the algorithms specified here in\n   conjunction with the following default\
    \ policy table:\n      Prefix        Precedence Label\n      ::1/128         \
    \      50     0\n      ::/0                  40     1\n      2002::/16       \
    \      30     2\n      ::/96                 20     3\n      ::ffff:0:0/96   \
    \      10     4\n   One effect of the default policy table is to prefer using\
    \ native\n   source addresses with native destination addresses, 6to4 [5] source\n\
    \   addresses with 6to4 destination addresses, and v4-compatible [1]\n   source\
    \ addresses with v4-compatible destination addresses.  Another\n   effect of the\
    \ default policy table is to prefer communication using\n   IPv6 addresses to\
    \ communication using IPv4 addresses, if matching\n   source addresses are available.\n\
    \   Policy table entries for scoped address prefixes MAY be qualified\n   with\
    \ an optional zone index.  If so, a prefix table entry only\n   matches against\
    \ an address during a lookup if the zone index also\n   matches the address's\
    \ zone index.\n"
- title: 2.2. Common Prefix Length
  contents:
  - "2.2. Common Prefix Length\n   We define the common prefix length CommonPrefixLen(A,\
    \ B) of two\n   addresses A and B as the length of the longest prefix (looking\
    \ at the\n   most significant, or leftmost, bits) that the two addresses have\
    \ in\n   common.  It ranges from 0 to 128.\n"
- title: 3. Address Properties
  contents:
  - "3. Address Properties\n   In the rules given in later sections, addresses of\
    \ different types\n   (e.g., IPv4, IPv6, multicast and unicast) are compared against\
    \ each\n   other.  Some of these address types have properties that aren't\n \
    \  directly comparable to each other.  For example, IPv6 unicast\n   addresses\
    \ can be \"preferred\" or \"deprecated\" [2], while IPv4\n   addresses have no\
    \ such notion.  To compare such addresses using the\n   ordering rules (e.g.,\
    \ to use \"preferred\" addresses in preference to\n   \"deprecated\" addresses),\
    \ the following mappings are defined.\n"
- title: 3.1. Scope Comparisons
  contents:
  - "3.1. Scope Comparisons\n   Multicast destination addresses have a 4-bit scope\
    \ field that\n   controls the propagation of the multicast packet.  The IPv6\n\
    \   addressing architecture defines scope field values for interface-\n   local\
    \ (0x1), link-local (0x2), subnet-local (0x3), admin-local (0x4),\n   site-local\
    \ (0x5), organization-local (0x8), and global (0xE)\n   scopes [11].\n   Use of\
    \ the source address selection algorithm in the presence of\n   multicast destination\
    \ addresses requires the comparison of a unicast\n   address scope with a multicast\
    \ address scope.  We map unicast link-\n   local to multicast link-local, unicast\
    \ site-local to multicast site-\n   local, and unicast global scope to multicast\
    \ global scope.  For\n   example, unicast site-local is equal to multicast site-local,\
    \ which\n   is smaller than multicast organization-local, which is smaller than\n\
    \   unicast global, which is equal to multicast global.\n   We write Scope(A)\
    \ to mean the scope of address A.  For example, if A\n   is a link-local unicast\
    \ address and B is a site-local multicast\n   address, then Scope(A) < Scope(B).\n\
    \   This mapping implicitly conflates unicast site boundaries and\n   multicast\
    \ site boundaries [11].\n"
- title: 3.2. IPv4 Addresses and IPv4-Mapped Addresses
  contents:
  - "3.2. IPv4 Addresses and IPv4-Mapped Addresses\n   The destination address selection\
    \ algorithm operates on both IPv6 and\n   IPv4 addresses.  For this purpose, IPv4\
    \ addresses should be\n   represented as IPv4-mapped addresses [1].  For example,\
    \ to lookup the\n   precedence or other attributes of an IPv4 address in the policy\n\
    \   table, lookup the corresponding IPv4-mapped IPv6 address.\n   IPv4 addresses\
    \ are assigned scopes as follows.  IPv4 auto-\n   configuration addresses [9],\
    \ which have the prefix 169.254/16, are\n   assigned link-local scope.  IPv4 private\
    \ addresses [12], which have\n   the prefixes 10/8, 172.16/12, and 192.168/16,\
    \ are assigned site-local\n   scope.  IPv4 loopback addresses [12, section 4.2.2.11],\
    \ which have\n   the prefix 127/8, are assigned link-local scope (analogously\
    \ to the\n   treatment of the IPv6 loopback address [11, section 4]).  Other IPv4\n\
    \   addresses are assigned global scope.\n   IPv4 addresses should be treated\
    \ as having \"preferred\" (in the RFC\n   2462 sense) configuration status.\n"
- title: 3.3. Other IPv6 Addresses with Embedded IPv4 Addresses
  contents:
  - "3.3. Other IPv6 Addresses with Embedded IPv4 Addresses\n   IPv4-compatible addresses\
    \ [1], IPv4-mapped [1], IPv4-translatable [6]\n   and 6to4 addresses [5] contain\
    \ an embedded IPv4 address.  For the\n   purposes of this document, these addresses\
    \ should be treated as\n   having global scope.\n   IPv4-compatible, IPv4-mapped,\
    \ and IPv4-translatable addresses should\n   be treated as having \"preferred\"\
    \ (in the RFC 2462 sense)\n   configuration status.\n"
- title: 3.4. IPv6 Loopback Address and Other Format Prefixes
  contents:
  - "3.4. IPv6 Loopback Address and Other Format Prefixes\n   The loopback address\
    \ should be treated as having link-local scope\n   [11, section 4] and \"preferred\"\
    \ (in the RFC 2462 sense) configuration\n   status.\n   NSAP addresses and other\
    \ addresses with as-yet-undefined format\n   prefixes should be treated as having\
    \ global scope and \"preferred\" (in\n   the RFC 2462) configuration status. \
    \ Later standards may supersede\n   this treatment.\n"
- title: 3.5. Mobility Addresses
  contents:
  - "3.5. Mobility Addresses\n   Some nodes may support mobility using the concepts\
    \ of a home address\n   and a care-of address (for example see [8]). Conceptually,\
    \ a home\n   address is an IP address assigned to a mobile node and used as the\n\
    \   permanent address of the mobile node. A care-of address is an IP\n   address\
    \ associated with a mobile node while visiting a foreign link.\n   When a mobile\
    \ node is on its home link, it may have an address that\n   is simultaneously\
    \ a home address and a care-of address.\n   For the purposes of this document,\
    \ it is sufficient to know whether\n   or not one's own addresses are designated\
    \ as home addresses or care-\n   of addresses.  Whether or not an address should\
    \ be designated a home\n   address or care-of address is outside the scope of\
    \ this document.\n"
- title: 4. Candidate Source Addresses
  contents:
  - "4. Candidate Source Addresses\n   The source address selection algorithm uses\
    \ the concept of a\n   \"candidate set\" of potential source addresses for a given\
    \ destination\n   address.  The candidate set is the set of all addresses that\
    \ could be\n   used as a source address; the source address selection algorithm\
    \ will\n   pick an address out of that set.  We write CandidateSource(A) to\n\
    \   denote the candidate set for the address A.\n   It is RECOMMENDED that the\
    \ candidate source addresses be the set of\n   unicast addresses assigned to the\
    \ interface that will be used to send\n   to the destination.  (The \"outgoing\"\
    \ interface.)  On routers, the\n   candidate set MAY include unicast addresses\
    \ assigned to any interface\n   that forwards packets, subject to the restrictions\
    \ described below.\n      Discussion:  The Neighbor Discovery Redirect mechanism\
    \ [14]\n      requires that routers verify that the source address of a packet\n\
    \      identifies a neighbor before generating a Redirect, so it is\n      advantageous\
    \ for hosts to choose source addresses assigned to the\n      outgoing interface.\
    \  Implementations that wish to support the use\n      of global source addresses\
    \ assigned to a loopback interface should\n      behave as if the loopback interface\
    \ originates and forwards the\n      packet.\n   In some cases the destination\
    \ address may be qualified with a zone\n   index or other information that will\
    \ constrain the candidate set.\n   For multicast and link-local destination addresses,\
    \ the set of\n   candidate source addresses MUST only include addresses assigned\
    \ to\n   interfaces belonging to the same link as the outgoing interface.\n  \
    \    Discussion:  The restriction for multicast destination addresses\n      is\
    \ necessary because currently-deployed multicast forwarding\n      algorithms\
    \ use Reverse Path Forwarding (RPF) checks.\n   For site-local destination addresses,\
    \ the set of candidate source\n   addresses MUST only include addresses assigned\
    \ to interfaces\n   belonging to the same site as the outgoing interface.\n  \
    \ In any case, anycast addresses, multicast addresses, and the\n   unspecified\
    \ address MUST NOT be included in a candidate set.\n   If an application or upper-layer\
    \ specifies a source address that is\n   not in the candidate set for the destination,\
    \ then the network layer\n   MUST treat this as an error.  The specified source\
    \ address may\n   influence the candidate set, by affecting the choice of outgoing\n\
    \   interface.  If the application or upper-layer specifies a source\n   address\
    \ that is in the candidate set for the destination, then the\n   network layer\
    \ MUST respect that choice.  If the application or\n   upper-layer does not specify\
    \ a source address, then the network layer\n   uses the source address selection\
    \ algorithm specified in the next\n   section.\n   On IPv6-only nodes that support\
    \ SIIT [6, especially section 5], if\n   the destination address is an IPv4-mapped\
    \ address then the candidate\n   set MUST contain only IPv4-translatable addresses.\
    \  If the\n   destination address is not an IPv4-mapped address, then the candidate\n\
    \   set MUST NOT contain IPv4-translatable addresses.\n"
- title: 5. Source Address Selection
  contents:
  - "5. Source Address Selection\n   The source address selection algorithm produces\
    \ as output a single\n   source address for use with a given destination address.\
    \  This\n   algorithm only applies to IPv6 destination addresses, not IPv4\n \
    \  addresses.\n   The algorithm is specified here in terms of a list of pair-wise\n\
    \   comparison rules that (for a given destination address D) imposes a\n   \"\
    greater than\" ordering on the addresses in the candidate set\n   CandidateSource(D).\
    \  The address at the front of the list after the\n   algorithm completes is the\
    \ one the algorithm selects.\n   Note that conceptually, a sort of the candidate\
    \ set is being\n   performed, where a set of rules define the ordering among addresses.\n\
    \   But because the output of the algorithm is a single source address,\n   an\
    \ implementation need not actually sort the set; it need only\n   identify the\
    \ \"maximum\" value that ends up at the front of the sorted\n   list.\n   The\
    \ ordering of the addresses in the candidate set is defined by a\n   list of eight\
    \ pair-wise comparison rules, with each rule placing a\n   \"greater than,\" \"\
    less than\" or \"equal to\" ordering on two source\n   addresses with respect\
    \ to each other (and that rule).  In the case\n   that a given rule produces a\
    \ tie, i.e., provides an \"equal to\" result\n   for the two addresses, the remaining\
    \ rules are applied (in order) to\n   just those addresses that are tied to break\
    \ the tie.  Note that if a\n   rule produces a single clear \"winner\" (or set\
    \ of \"winners\" in the\n   case of ties), those addresses not in the winning\
    \ set can be\n   discarded from further consideration, with subsequent rules applied\n\
    \   only to the remaining addresses.  If the eight rules fail to choose a\n  \
    \ single address, some unspecified tie-breaker should be used.\n   When comparing\
    \ two addresses SA and SB from the candidate set, we say\n   \"prefer SA\" to\
    \ mean that SA is \"greater than\" SB, and similarly we\n   say \"prefer SB\"\
    \ to mean that SA is \"less than\" SB.\n   Rule 1:  Prefer same address.\n   If\
    \ SA = D, then prefer SA.  Similarly, if SB = D, then prefer SB.\n   Rule 2: \
    \ Prefer appropriate scope.\n   If Scope(SA) < Scope(SB): If Scope(SA) < Scope(D),\
    \ then prefer SB\n   and otherwise prefer SA.  Similarly, if Scope(SB) < Scope(SA):\
    \ If\n   Scope(SB) < Scope(D), then prefer SA and otherwise prefer SB.\n   Rule\
    \ 3:  Avoid deprecated addresses.\n   The addresses SA and SB have the same scope.\
    \  If one of the two\n   source addresses is \"preferred\" and one of them is\
    \ \"deprecated\" (in\n   the RFC 2462 sense), then prefer the one that is \"preferred.\"\
    \n   Rule 4:  Prefer home addresses.\n   If SA is simultaneously a home address\
    \ and care-of address and SB is\n   not, then prefer SA.  Similarly, if SB is\
    \ simultaneously a home\n   address and care-of address and SA is not, then prefer\
    \ SB.\n   If SA is just a home address and SB is just a care-of address, then\n\
    \   prefer SA.  Similarly, if SB is just a home address and SA is just a\n   care-of\
    \ address, then prefer SB.\n   Implementations should provide a mechanism allowing\
    \ an application to\n   reverse the sense of this preference and prefer care-of\
    \ addresses\n   over home addresses (e.g., via appropriate API extensions).  Use\
    \ of\n   the mechanism should only affect the selection rules for the invoking\n\
    \   application.\n   Rule 5:  Prefer outgoing interface.\n   If SA is assigned\
    \ to the interface that will be used to send to D\n   and SB is assigned to a\
    \ different interface, then prefer SA.\n   Similarly, if SB is assigned to the\
    \ interface that will be used to\n   send to D and SA is assigned to a different\
    \ interface, then prefer\n   SB.\n   Rule 6:  Prefer matching label.\n   If Label(SA)\
    \ = Label(D) and Label(SB) <> Label(D), then prefer SA.\n   Similarly, if Label(SB)\
    \ = Label(D) and Label(SA) <> Label(D), then\n   prefer SB.\n   Rule 7:  Prefer\
    \ public addresses.\n   If SA is a public address and SB is a temporary address,\
    \ then prefer\n   SA.  Similarly, if SB is a public address and SA is a temporary\n\
    \   address, then prefer SB.\n   Implementations MUST provide a mechanism allowing\
    \ an application to\n   reverse the sense of this preference and prefer temporary\
    \ addresses\n   over public addresses (e.g., via appropriate API extensions).\
    \  Use of\n   the mechanism should only affect the selection rules for the invoking\n\
    \   application. This rule avoids applications potentially failing due to\n  \
    \ the relatively short lifetime of temporary addresses or due to the\n   possibility\
    \ of the reverse lookup of a temporary address either\n   failing or returning\
    \ a randomized name.  Implementations for which\n   privacy considerations outweigh\
    \ these application compatibility\n   concerns MAY reverse the sense of this rule\
    \ and by default prefer\n   temporary addresses over public addresses.\n   Rule\
    \ 8:  Use longest matching prefix.\n   If CommonPrefixLen(SA, D) > CommonPrefixLen(SB,\
    \ D), then prefer SA.\n   Similarly, if CommonPrefixLen(SB, D) > CommonPrefixLen(SA,\
    \ D), then\n   prefer SB.\n   Rule 8 may be superseded if the implementation has\
    \ other means of\n   choosing among source addresses.  For example, if the implementation\n\
    \   somehow knows which source address will result in the \"best\"\n   communications\
    \ performance.\n   Rule 2 (prefer appropriate scope) MUST be implemented and given\
    \ high\n   priority because it can affect interoperability.\n"
- title: 6. Destination Address Selection
  contents:
  - "6. Destination Address Selection\n   The destination address selection algorithm\
    \ takes a list of\n   destination addresses and sorts the addresses to produce\
    \ a new list.\n   It is specified here in terms of the pair-wise comparison of\n\
    \   addresses DA and DB, where DA appears before DB in the original list.\n  \
    \ The algorithm sorts together both IPv6 and IPv4 addresses.  To find\n   the\
    \ attributes of an IPv4 address in the policy table, the IPv4\n   address should\
    \ be represented as an IPv4-mapped address.\n   We write Source(D) to indicate\
    \ the selected source address for a\n   destination D.  For IPv6 addresses, the\
    \ previous section specifies\n   the source address selection algorithm.  Source\
    \ address selection for\n   IPv4 addresses is not specified in this document.\n\
    \   We say that Source(D) is undefined if there is no source address\n   available\
    \ for destination D.  For IPv6 addresses, this is only the\n   case if CandidateSource(D)\
    \ is the empty set.\n   The pair-wise comparison of destination addresses consists\
    \ of ten\n   rules, which should be applied in order.  If a rule determines a\n\
    \   result, then the remaining rules are not relevant and should be\n   ignored.\
    \  Subsequent rules act as tie-breakers for earlier rules.\n   See the previous\
    \ section for a lengthier description of how pair-wise\n   comparison tie-breaker\
    \ rules can be used to sort a list.\n   Rule 1:  Avoid unusable destinations.\n\
    \   If DB is known to be unreachable or if Source(DB) is undefined, then\n   prefer\
    \ DA.  Similarly, if DA is known to be unreachable or if\n   Source(DA) is undefined,\
    \ then prefer DB.\n      Discussion:  An implementation may know that a particular\n\
    \      destination is unreachable in several ways.  For example, the\n      destination\
    \ may be reached through a network interface that is\n      currently unplugged.\
    \  For example, the implementation may retain\n      for some period of time information\
    \ from Neighbor Unreachability\n      Detection [14].  In any case, the determination\
    \ of unreachability\n      for the purposes of this rule is implementation-dependent.\n\
    \   Rule 2:  Prefer matching scope.\n   If Scope(DA) = Scope(Source(DA)) and Scope(DB)\
    \ <> Scope(Source(DB)),\n   then prefer DA.  Similarly, if Scope(DA) <> Scope(Source(DA))\
    \ and\n   Scope(DB) = Scope(Source(DB)), then prefer DB.\n   Rule 3:  Avoid deprecated\
    \ addresses.\n   If Source(DA) is deprecated and Source(DB) is not, then prefer\
    \ DB.\n   Similarly, if Source(DA) is not deprecated and Source(DB) is\n   deprecated,\
    \ then prefer DA.\n   Rule 4:  Prefer home addresses.\n   If Source(DA) is simultaneously\
    \ a home address and care-of address\n   and Source(DB) is not, then prefer DA.\
    \  Similarly, if Source(DB) is\n   simultaneously a home address and care-of address\
    \ and Source(DA) is\n   not, then prefer DB.\n   If Source(DA) is just a home\
    \ address and Source(DB) is just a care-of\n   address, then prefer DA.  Similarly,\
    \ if Source(DA) is just a care-of\n   address and Source(DB) is just a home address,\
    \ then prefer DB.\n   Rule 5:  Prefer matching label.\n   If Label(Source(DA))\
    \ = Label(DA) and Label(Source(DB)) <> Label(DB),\n   then prefer DA.  Similarly,\
    \ if Label(Source(DA)) <> Label(DA) and\n   Label(Source(DB)) = Label(DB), then\
    \ prefer DB.\n   Rule 6:  Prefer higher precedence.\n   If Precedence(DA) > Precedence(DB),\
    \ then prefer DA.  Similarly, if\n   Precedence(DA) < Precedence(DB), then prefer\
    \ DB.\n   Rule 7:  Prefer native transport.\n   If DA is reached via an encapsulating\
    \ transition mechanism (e.g.,\n   IPv6 in IPv4) and DB is not, then prefer DB.\
    \  Similarly, if DB\n   is reached via encapsulation and DA is not, then prefer\
    \ DA.\n      Discussion:  6-over-4 [15], ISATAP [16], and configured tunnels\n\
    \      [17] are examples of encapsulating transition mechanisms for which\n  \
    \    the destination address does not have a specific prefix and hence\n     \
    \ can not be assigned a lower precedence in the policy table.  An\n      implementation\
    \ MAY generalize this rule by using a concept of\n      interface preference,\
    \ and giving virtual interfaces (like the\n      IPv6-in-IPv4 encapsulating interfaces)\
    \ a lower preference than\n      native interfaces (like ethernet interfaces).\n\
    \   Rule 8:  Prefer smaller scope.\n   If Scope(DA) < Scope(DB), then prefer DA.\
    \  Similarly, if Scope(DA) >\n   Scope(DB), then prefer DB.\n   Rule 9:  Use longest\
    \ matching prefix.\n   When DA and DB belong to the same address family (both\
    \ are IPv6 or\n   both are IPv4): If CommonPrefixLen(DA, Source(DA)) >\n   CommonPrefixLen(DB,\
    \ Source(DB)), then prefer DA.  Similarly, if\n   CommonPrefixLen(DA, Source(DA))\
    \ < CommonPrefixLen(DB, Source(DB)),\n   then prefer DB.\n   Rule 10:  Otherwise,\
    \ leave the order unchanged.\n   If DA preceded DB in the original list, prefer\
    \ DA.  Otherwise prefer\n   DB.\n   Rules 9 and 10 may be superseded if the implementation\
    \ has other\n   means of sorting destination addresses.  For example, if the\n\
    \   implementation somehow knows which destination addresses will result\n   in\
    \ the \"best\" communications performance.\n"
- title: 7. Interactions with Routing
  contents:
  - "7. Interactions with Routing\n   This specification of source address selection\
    \ assumes that routing\n   (more precisely, selecting an outgoing interface on\
    \ a node with\n   multiple interfaces) is done before source address selection.\n\
    \   However, implementations may use source address considerations as a\n   tiebreaker\
    \ when choosing among otherwise equivalent routes.\n   For example, suppose a\
    \ node has interfaces on two different links,\n   with both links having a working\
    \ default router.  Both of the\n   interfaces have preferred (in the RFC 2462\
    \ sense) global addresses.\n   When sending to a global destination address, if\
    \ there's no routing\n   reason to prefer one interface over the other, then an\
    \ implementation\n   may preferentially choose the outgoing interface that will\
    \ allow it\n   to use the source address that shares a longer common prefix with\
    \ the\n   destination.\n   Implementations may also use the choice of router to\
    \ influence the\n   choice of source address.  For example, suppose a host is\
    \ on a link\n   with two routers.  One router is advertising a global prefix A\
    \ and\n   the other router is advertising global prefix B.  Then when sending\n\
    \   via the first router, the host may prefer source addresses with\n   prefix\
    \ A and when sending via the second router, prefer source\n   addresses with prefix\
    \ B.\n"
- title: 8. Implementation Considerations
  contents:
  - "8. Implementation Considerations\n   The destination address selection algorithm\
    \ needs information about\n   potential source addresses.  One possible implementation\
    \ strategy is\n   for getaddrinfo() to call down to the network layer with a list\
    \ of\n   destination addresses, sort the list in the network layer with full\n\
    \   current knowledge of available source addresses, and return the\n   sorted\
    \ list to getaddrinfo().  This is simple and gives the best\n   results but it\
    \ introduces the overhead of another system call.  One\n   way to reduce this\
    \ overhead is to cache the sorted address list in\n   the resolver, so that subsequent\
    \ calls for the same name do not need\n   to resort the list.\n   Another implementation\
    \ strategy is to call down to the network layer\n   to retrieve source address\
    \ information and then sort the list of\n   addresses directly in the context\
    \ of getaddrinfo().  To reduce\n   overhead in this approach, the source address\
    \ information can be\n   cached, amortizing the overhead of retrieving it across\
    \ multiple\n   calls to getaddrinfo().  In this approach, the implementation may\
    \ not\n   have knowledge of the outgoing interface for each destination, so it\n\
    \   MAY use a looser definition of the candidate set during destination\n   address\
    \ ordering.\n   In any case, if the implementation uses cached and possibly stale\n\
    \   information in its implementation of destination address selection,\n   or\
    \ if the ordering of a cached list of destination addresses is\n   possibly stale,\
    \ then it should ensure that the destination address\n   ordering returned to\
    \ the application is no more than one second out\n   of date.  For example, an\
    \ implementation might make a system call to\n   check if any routing table entries\
    \ or source address assignments that\n   might affect these algorithms have changed.\
    \  Another strategy is to\n   use an invalidation counter that is incremented\
    \ whenever any\n   underlying state is changed.  By caching the current invalidation\n\
    \   counter value with derived state and then later comparing against the\n  \
    \ current value, the implementation could detect if the derived state\n   is potentially\
    \ stale.\n"
- title: 9. Security Considerations
  contents:
  - "9. Security Considerations\n   This document has no direct impact on Internet\
    \ infrastructure\n   security.\n   Note that most source address selection algorithms,\
    \ including the one\n   specified in this document, expose a potential privacy\
    \ concern.  An\n   unfriendly node can infer correlations among a target node's\n\
    \   addresses by probing the target node with request packets that force\n   the\
    \ target host to choose its source address for the reply packets.\n   (Perhaps\
    \ because the request packets are sent to an anycast or\n   multicast address,\
    \ or perhaps the upper-layer protocol chosen for the\n   attack does not specify\
    \ a particular source address for its reply\n   packets.)  By using different\
    \ addresses for itself, the unfriendly\n   node can cause the target node to expose\
    \ the target's own addresses.\n"
- title: 10. Examples
  contents:
  - "10. Examples\n   This section contains a number of examples, first of default\
    \ behavior\n   and then demonstrating the utility of policy table configuration.\n\
    \   These examples are provided for illustrative purposes; they should\n   not\
    \ be construed as normative.\n"
- title: 10.1. Default Source Address Selection
  contents:
  - "10.1. Default Source Address Selection\n   The source address selection rules,\
    \ in conjunction with the default\n   policy table, produce the following behavior:\n\
    \   Destination: 2001::1\n   Candidate Source Addresses: 3ffe::1 or fe80::1\n\
    \   Result: 3ffe::1 (prefer appropriate scope)\n   Destination: 2001::1\n   Candidate\
    \ Source Addresses: fe80::1 or fec0::1\n   Result: fec0::1 (prefer appropriate\
    \ scope)\n   Destination: fec0::1\n   Candidate Source Addresses: fe80::1 or 2001::1\n\
    \   Result: 2001::1 (prefer appropriate scope)\n   Destination: ff05::1\n   Candidate\
    \ Source Addresses: fe80::1 or fec0::1 or 2001::1\n   Result: fec0::1 (prefer\
    \ appropriate scope)\n   Destination: 2001::1\n   Candidate Source Addresses:\
    \ 2001::1 (deprecated) or 2002::1\n   Result: 2001::1 (prefer same address)\n\
    \   Destination: fec0::1\n   Candidate Source Addresses: fec0::2 (deprecated)\
    \ or 2001::1\n   Result: fec0::2 (prefer appropriate scope)\n   Destination: 2001::1\n\
    \   Candidate Source Addresses: 2001::2 or 3ffe::2\n   Result: 2001::2 (longest-matching-prefix)\n\
    \   Destination: 2001::1\n   Candidate Source Addresses: 2001::2 (care-of address)\
    \ or 3ffe::2\n   (home address)\n   Result: 3ffe::2 (prefer home address)\n  \
    \ Destination: 2002:836b:2179::1\n   Candidate Source Addresses: 2002:836b:2179::d5e3:7953:13eb:22e8\n\
    \   (temporary) or 2001::2\n   Result: 2002:836b:2179::d5e3:7953:13eb:22e8 (prefer\
    \ matching label)\n   Destination: 2001::d5e3:0:0:1\n   Candidate Source Addresses:\
    \ 2001::2 or 2001::d5e3:7953:13eb:22e8\n   (temporary)\n   Result: 2001::2 (prefer\
    \ public address)\n"
- title: 10.2. Default Destination Address Selection
  contents:
  - "10.2. Default Destination Address Selection\n   The destination address selection\
    \ rules, in conjunction with the\n   default policy table and the source address\
    \ selection rules, produce\n   the following behavior:\n   Candidate Source Addresses:\
    \ 2001::2 or fe80::1 or 169.254.13.78\n   Destination Address List: 2001::1 or\
    \ 131.107.65.121\n   Result: 2001::1 (src 2001::2) then 131.107.65.121 (src\n\
    \   169.254.13.78) (prefer matching scope)\n   Candidate Source Addresses: fe80::1\
    \ or 131.107.65.117\n   Destination Address List: 2001::1 or 131.107.65.121\n\
    \   Result: 131.107.65.121 (src 131.107.65.117) then 2001::1 (src\n   fe80::1)\
    \ (prefer matching scope)\n   Candidate Source Addresses: 2001::2 or fe80::1 or\
    \ 10.1.2.4\n   Destination Address List: 2001::1 or 10.1.2.3\n   Result: 2001::1\
    \ (src 2001::2) then 10.1.2.3 (src 10.1.2.4) (prefer\n   higher precedence)\n\
    \   Candidate Source Addresses: 2001::2 or fec0::2 or fe80::2\n   Destination\
    \ Address List: 2001::1 or fec0::1 or fe80::1\n   Result: fe80::1 (src fe80::2)\
    \ then fec0::1 (src fec0::2) then\n   2001::1 (src 2001::2) (prefer smaller scope)\n\
    \   Candidate Source Addresses: 2001::2 (care-of address) or 3ffe::1\n   (home\
    \ address) or fec0::2 (care-of address) or fe80::2 (care-of\n   address)\n   Destination\
    \ Address List: 2001::1 or fec0::1\n   Result: 2001:1 (src 3ffe::1) then fec0::1\
    \ (src fec0::2) (prefer home\n   address)\n   Candidate Source Addresses: 2001::2\
    \ or fec0::2 (deprecated) or\n   fe80::2\n   Destination Address List: 2001::1\
    \ or fec0::1\n   Result: 2001::1 (src 2001::2) then fec0::1 (src fec0::2) (avoid\n\
    \   deprecated addresses)\n   Candidate Source Addresses: 2001::2 or 3f44::2 or\
    \ fe80::2\n   Destination Address List: 2001::1 or 3ffe::1\n   Result: 2001::1\
    \ (src 2001::2) then 3ffe::1 (src 3f44::2) (longest\n   matching prefix)\n   Candidate\
    \ Source Addresses: 2002:836b:4179::2 or fe80::2\n   Destination Address List:\
    \ 2002:836b:4179::1 or 2001::1\n   Result: 2002:836b:4179::1 (src 2002:836b:4179::2)\
    \ then 2001::1 (src\n   2002:836b:4179::2) (prefer matching label)\n   Candidate\
    \ Source Addresses: 2002:836b:4179::2 or 2001::2 or fe80::2\n   Destination Address\
    \ List: 2002:836b:4179::1 or 2001::1\n   Result: 2001::1 (src 2001::2) then 2002:836b:4179::1\
    \ (src\n   2002:836b:4179::2) (prefer higher precedence)\n"
- title: 10.3. Configuring Preference for IPv6 or IPv4
  contents:
  - "10.3. Configuring Preference for IPv6 or IPv4\n   The default policy table gives\
    \ IPv6 addresses higher precedence than\n   IPv4 addresses.  This means that applications\
    \ will use IPv6 in\n   preference to IPv4 when the two are equally suitable. \
    \ An\n   administrator can change the policy table to prefer IPv4 addresses by\n\
    \   giving the ::ffff:0.0.0.0/96 prefix a higher precedence:\n      Prefix   \
    \     Precedence Label\n      ::1/128               50     0\n      ::/0     \
    \             40     1\n      2002::/16             30     2\n      ::/96    \
    \             20     3\n      ::ffff:0:0/96        100     4\n   This change to\
    \ the default policy table produces the following\n   behavior:\n   Candidate\
    \ Source Addresses: 2001::2 or fe80::1 or 169.254.13.78\n   Destination Address\
    \ List: 2001::1 or 131.107.65.121\n   Unchanged Result: 2001::1 (src 2001::2)\
    \ then 131.107.65.121 (src\n   169.254.13.78) (prefer matching scope)\n   Candidate\
    \ Source Addresses: fe80::1 or 131.107.65.117\n   Destination Address List: 2001::1\
    \ or 131.107.65.121\n   Unchanged Result: 131.107.65.121 (src 131.107.65.117)\
    \ then 2001::1\n   (src fe80::1) (prefer matching scope)\n   Candidate Source\
    \ Addresses: 2001::2 or fe80::1 or 10.1.2.4\n   Destination Address List: 2001::1\
    \ or 10.1.2.3\n   New Result: 10.1.2.3 (src 10.1.2.4) then 2001::1 (src 2001::2)\n\
    \   (prefer higher precedence)\n"
- title: 10.4. Configuring Preference for Scoped Addresses
  contents:
  - "10.4. Configuring Preference for Scoped Addresses\n   The destination address\
    \ selection rules give preference to\n   destinations of smaller scope.  For example,\
    \ a site-local destination\n   will be sorted before a global scope destination\
    \ when the two are\n   otherwise equally suitable.  An administrator can change\
    \ the policy\n   table to reverse this preference and sort global destinations\
    \ before\n   site-local destinations, and site-local destinations before link-\n\
    \   local destinations:\n      Prefix        Precedence Label\n      ::1/128 \
    \              50     0\n      ::/0                  40     1\n      fec0::/10\
    \             37     1\n      fe80::/10             33     1\n      2002::/16\
    \             30     2\n      ::/96                 20     3\n      ::ffff:0:0/96\
    \         10     4\n   This change to the default policy table produces the following\n\
    \   behavior:\n   Candidate Source Addresses: 2001::2 or fec0::2 or fe80::2\n\
    \   Destination Address List: 2001::1 or fec0::1 or fe80::1\n   New Result: 2001::1\
    \ (src 2001::2) then fec0::1 (src fec0::2) then\n   fe80::1 (src fe80::2) (prefer\
    \ higher precedence)\n   Candidate Source Addresses: 2001::2 (deprecated) or fec0::2\
    \ or\n   fe80::2\n   Destination Address List: 2001::1 or fec0::1\n   Unchanged\
    \ Result: fec0::1 (src fec0::2) then 2001::1 (src 2001::2)\n   (avoid deprecated\
    \ addresses)\n"
- title: 10.5. Configuring a Multi-Homed Site
  contents:
  - "10.5. Configuring a Multi-Homed Site\n   Consider a site A that has a business-critical\
    \ relationship with\n   another site B.  To support their business needs, the\
    \ two sites have\n   contracted for service with a special high-performance ISP.\
    \  This is\n   in addition to the normal Internet connection that both sites have\n\
    \   with different ISPs.  The high-performance ISP is expensive and the\n   two\
    \ sites wish to use it only for their business-critical traffic\n   with each\
    \ other.\n   Each site has two global prefixes, one from the high-performance\
    \ ISP\n   and one from their normal ISP.  Site A has prefix 2001:aaaa:aaaa::/48\n\
    \   from the high-performance ISP and prefix 2007:0:aaaa::/48 from its\n   normal\
    \ ISP.  Site B has prefix 2001:bbbb:bbbb::/48 from the high-\n   performance ISP\
    \ and prefix 2007:0:bbbb::/48 from its normal ISP.  All\n   hosts in both sites\
    \ register two addresses in the DNS.\n   The routing within both sites directs\
    \ most traffic to the egress to\n   the normal ISP, but the routing directs traffic\
    \ sent to the other\n   site's 2001 prefix to the egress to the high-performance\
    \ ISP.  To\n   prevent unintended use of their high-performance ISP connection,\
    \ the\n   two sites implement ingress filtering to discard traffic entering\n\
    \   from the high-performance ISP that is not from the other site.\n   The default\
    \ policy table and address selection rules produce the\n   following behavior:\n\
    \   Candidate Source Addresses: 2001:aaaa:aaaa::a or 2007:0:aaaa::a or\n   fe80::a\n\
    \   Destination Address List: 2001:bbbb:bbbb::b or 2007:0:bbbb::b\n   Result:\
    \ 2007:0:bbbb::b (src 2007:0:aaaa::a) then 2001:bbbb:bbbb::b\n   (src 2001:aaaa:aaaa::a)\
    \ (longest matching prefix)\n   In other words, when a host in site A initiates\
    \ a connection to a\n   host in site B, the traffic does not take advantage of\
    \ their\n   connections to the high-performance ISP.  This is not their desired\n\
    \   behavior.\n   Candidate Source Addresses: 2001:aaaa:aaaa::a or 2007:0:aaaa::a\
    \ or\n   fe80::a\n   Destination Address List: 2001:cccc:cccc::c or 2006:cccc:cccc::c\n\
    \   Result: 2001:cccc:cccc::c (src 2001:aaaa:aaaa::a) then\n   2006:cccc:cccc::c\
    \ (src 2007:0:aaaa::a) (longest matching prefix)\n   In other words, when a host\
    \ in site A initiates a connection to a\n   host in some other site C, the reverse\
    \ traffic may come back through\n   the high-performance ISP.  Again, this is\
    \ not their desired behavior.\n   This predicament demonstrates the limitations\
    \ of the longest-\n   matching-prefix heuristic in multi-homed situations.\n \
    \  However, the administrators of sites A and B can achieve their\n   desired\
    \ behavior via policy table configuration.  For example, they\n   can use the\
    \ following policy table:\n      Prefix              Precedence Label\n      ::1\
    \                         50     0\n      2001:aaaa:aaaa::/48         45     5\n\
    \      2001:bbbb:bbbb::/48         45     5\n      ::/0                      \
    \  40     1\n      2002::/16                   30     2\n      ::/96         \
    \              20     3\n      ::ffff:0:0/96               10     4\n   This policy\
    \ table produces the following behavior:\n   Candidate Source Addresses: 2001:aaaa:aaaa::a\
    \ or 2007:0:aaaa::a or\n   fe80::a\n   Destination Address List: 2001:bbbb:bbbb::b\
    \ or 2007:0:bbbb::b\n   New Result: 2001:bbbb:bbbb::b (src 2001:aaaa:aaaa::a)\
    \ then\n   2007:0:bbbb::b (src 2007:0:aaaa::a) (prefer higher precedence)\n  \
    \ In other words, when a host in site A initiates a connection to a\n   host in\
    \ site B, the traffic uses the high-performance ISP as desired.\n   Candidate\
    \ Source Addresses: 2001:aaaa:aaaa::a or 2007:0:aaaa::a or\n   fe80::a\n   Destination\
    \ Address List: 2001:cccc:cccc::c or 2006:cccc:cccc::c\n   New Result: 2006:cccc:cccc::c\
    \ (src 2007:0:aaaa::a) then\n   2001:cccc:cccc::c (src 2007:0:aaaa::a) (longest\
    \ matching prefix)\n   In other words, when a host in site A initiates a connection\
    \ to a\n   host in some other site C, the traffic uses the normal ISP as\n   desired.\n"
- title: Normative References
  contents:
  - "Normative References\n   [1]  Hinden, R. and S. Deering, \"IP Version 6 Addressing\n\
    \        Architecture\", RFC 2373, July 1998.\n   [2]  Thompson, S. and T. Narten,\
    \ \"IPv6 Stateless Address\n        Autoconfiguration\", RFC 2462 , December 1998.\n\
    \   [3]  Narten, T. and R. Draves, \"Privacy Extensions for Stateless\n      \
    \  Address Autoconfiguration in IPv6\", RFC 3041, January 2001.\n   [4]  Bradner,\
    \ S., \"Key words for use in RFCs to Indicate Requirement\n        Levels\", BCP\
    \ 14, RFC 2119, March 1997.\n   [5]  Carpenter, B. and K. Moore, \"Connection\
    \ of IPv6 Domains via IPv4\n        Clouds\", RFC 3056, February 2001.\n   [6]\
    \  Nordmark, E., \"Stateless IP/ICMP Translation Algorithm (SIIT)\",\n       \
    \ RFC 2765, February 2000.\n"
- title: Informative References
  contents:
  - "Informative References\n   [7]  Bradner, S., \"The Internet Standards Process\
    \ -- Revision 3\", BCP\n        9, RFC 2026, October 1996.\n   [8]  Johnson, D.\
    \ and C. Perkins, \"Mobility Support in IPv6\", Work in\n        Progress.\n \
    \  [9]  S. Cheshire, B. Aboba, \"Dynamic Configuration of IPv4 Link-local\n  \
    \      Addresses\", Work in Progress.\n   [10] Gilligan, R., Thomson, S., Bound,\
    \ J. and W. Stevens, \"Basic\n        Socket Interface Extensions for IPv6\",\
    \ RFC 2553, March 1999.\n   [11] S. Deering et. al, \"IP Version 6 Scoped Address\
    \ Architecture\",\n        Work in Progress.\n   [12] Rekhter, Y., Moskowitz,\
    \ B., Karrenberg, D., de Groot, G. and E.\n        Lear, \"Address Allocation\
    \ for Private Internets\", BCP 5, RFC\n        1918, February 1996.\n   [13] Baker,\
    \ F, \"Requirements for IP Version 4 Routers\", RFC 1812,\n        June 1995.\n\
    \   [14] Narten, T. and E. Nordmark, and W. Simpson, \"Neighbor Discovery\n  \
    \      for IP Version 6\", RFC 2461, December 1998.\n   [15] Carpenter, B. and\
    \ C. Jung, \"Transmission of IPv6 over IPv4\n        Domains without Explicit\
    \ Tunnels\", RFC 2529, March 1999.\n   [16] F. Templin et. al, \"Intra-Site Automatic\
    \ Tunnel Addressing\n        Protocol (ISATAP)\", Work in Progress.\n   [17] Gilligan,\
    \ R. and E. Nordmark, \"Transition Mechanisms for IPv6\n        Hosts and Routers\"\
    , RFC 1933, April 1996.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   The author would like to acknowledge the contributions of\
    \ the IPng\n   Working Group, particularly Marc Blanchet, Brian Carpenter, Matt\n\
    \   Crawford, Alain Durand, Steve Deering, Robert Elz, Jun-ichiro itojun\n   Hagino,\
    \ Tony Hain, M.T. Hollinger, JINMEI Tatuya, Thomas Narten, Erik\n   Nordmark,\
    \ Ken Powell, Markku Savela, Pekka Savola, Hesham Soliman,\n   Dave Thaler, Mauro\
    \ Tortonesi, Ole Troan, and Stig Venaas.  In\n   addition, the anonymous IESG\
    \ reviewers had many great comments and\n   suggestions for clarification.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Richard Draves\n   Microsoft Research\n   One Microsoft\
    \ Way\n   Redmond, WA 98052\n   Phone: +1 425 706 2268\n   EMail: richdr@microsoft.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2003).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
