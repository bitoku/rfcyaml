- contents:
  - '    TCP Candidates with Interactive Connectivity Establishment (ICE)

    '
  title: __initial_text__
- contents:
  - "Abstract\n   Interactive Connectivity Establishment (ICE) defines a mechanism
    for\n   NAT traversal for multimedia communication protocols based on the\n   offer/answer
    model of session negotiation.  ICE works by providing a\n   set of candidate transport
    addresses for each media stream, which are\n   then validated with peer-to-peer
    connectivity checks based on Session\n   Traversal Utilities for NAT (STUN).  ICE
    provides a general framework\n   for describing candidates but only defines UDP-based
    media streams.\n   This specification extends ICE to TCP-based media, including
    the\n   ability to offer a mix of TCP and UDP-based candidates for a single\n
    \  stream.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6544.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2012 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n
    \  2. Terminology .....................................................5\n   3.
    Overview of Operation ...........................................5\n   4. Sending
    the Initial Offer .......................................7\n      4.1. Gathering
    Candidates .......................................7\n      4.2. Prioritization
    .............................................8\n      4.3. Choosing Default Candidates
    ...............................10\n      4.4. Lite Implementation Requirements
    ..........................10\n      4.5. Encoding the SDP ..........................................11\n
    \  5. Candidate Collection Techniques ................................12\n      5.1.
    Host Candidates ...........................................12\n      5.2. Server
    Reflexive Candidates ...............................13\n      5.3. NAT-Assisted
    Candidates ...................................13\n      5.4. UDP-Tunneled Candidates
    ...................................14\n      5.5. Relayed Candidates ........................................15\n
    \  6. Receiving the Initial Offer and Answer .........................15\n      6.1.
    Considerations with Two Lite Agents .......................16\n      6.2. Forming
    the Check Lists ...................................16\n   7. Connectivity Checks
    ............................................17\n      7.1. STUN Client Procedures
    ....................................17\n      7.2. STUN Server Procedures ....................................18\n
    \  8. Concluding ICE Processing ......................................18\n   9.
    Subsequent Offer/Answer Exchanges ..............................18\n      9.1.
    Updated Offer .............................................18\n      9.2. ICE
    Restarts ..............................................19\n   10. Media Handling
    ................................................19\n      10.1. Sending Media
    ............................................19\n      10.2. Receiving Media ..........................................20\n
    \  11. Connection Management .........................................20\n      11.1.
    Connections Formed during Connectivity Checks ............20\n      11.2. Connections
    Formed for Gathering Candidates ..............21\n   12. Security Considerations
    .......................................22\n   13. IANA Considerations ...........................................23\n
    \  14. Acknowledgements ..............................................23\n   15.
    References ....................................................23\n      15.1.
    Normative References .....................................23\n      15.2. Informative
    References ...................................24\n   Appendix A.  Limitations
    of ICE TCP ...............................26\n   Appendix B.  Implementation Considerations
    for BSD Sockets ........27\n   Appendix C.  SDP Examples .........................................28\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Interactive Connectivity Establishment (ICE) [RFC5245] defines
    a\n   mechanism for NAT traversal for multimedia communication protocols\n   based
    on the offer/answer model [RFC3264] of session negotiation.\n   ICE works by providing
    a set of candidate transport addresses for\n   each media stream, which are then
    validated with peer-to-peer\n   connectivity checks based on Session Traversal
    Utilities for NAT\n   (STUN) [RFC5389].  However, ICE only defines procedures
    for UDP-based\n   transport protocols.\n   There are many reasons why ICE support
    for TCP is important.  First,\n   there are media protocols that only run over
    TCP.  Such protocols are\n   used, for example, for screen sharing and instant
    messaging\n   [RFC4975].  For these protocols to work in the presence of NAT,\n
    \  unless they define their own NAT traversal mechanisms, ICE support\n   for
    TCP is needed.  In addition, RTP can also run over TCP [RFC4571].\n   Typically,
    it is preferable to run RTP over UDP, and not TCP.\n   However, in a variety of
    network environments, overly restrictive NAT\n   and firewall devices prevent
    UDP-based communications altogether, but\n   general TCP-based communications
    are permitted.  In such\n   environments, sending RTP over TCP, and thus establishing
    the media\n   session, may be preferable to having it fail altogether.  With this\n
    \  specification, agents can gather UDP and TCP candidates for a media\n   stream,
    list the UDP ones with higher priority, and then only use the\n   TCP-based ones
    if the UDP ones fail.  This provides a fallback\n   mechanism that allows multimedia
    communications to be highly\n   reliable.\n   The usage of RTP over TCP is particularly
    useful when combined with\n   Traversal Using Relays around NAT (TURN) [RFC5766].
    \ In this case,\n   one of the agents would connect to its TURN server using TCP
    and\n   obtain a TCP-based relayed candidate.  It would offer this to its\n   peer
    agent as a candidate.  The other agent would initiate a TCP\n   connection towards
    the TURN server.  When that connection is\n   established, media can flow over
    the connections, through the TURN\n   server.  The benefit of this usage is that
    it only requires the\n   agents to make outbound TCP connections to a server on
    the public\n   network.  This kind of operation is broadly interoperable through
    NAT\n   and firewall devices.  Since it is a goal of ICE and this extension\n
    \  to provide highly reliable communications that \"just work\" in as\n   broad
    a set of network deployments as possible, this use case is\n   particularly important.\n
    \  This specification extends ICE by defining its usage with TCP\n   candidates.
    \ It also defines how ICE can be used with RTP and Secure\n   RTP (SRTP) to provide
    both TCP and UDP candidates.  This\n   specification does so by following the
    outline of ICE itself and\n   calling out the additions and changes to support
    TCP candidates in\n   ICE.  The base behavior of ICE [RFC5245] remains unchanged
    except for\n   the extensions in this document that define the usage of ICE with
    TCP\n   candidates.\n   It should be noted that since TCP NAT traversal is more
    complicated\n   than with UDP, ICE TCP is not generally as efficient as UDP-based\n
    \  ICE.  Discussion about this topic can be found in Appendix A.\n"
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\",
    \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described
    in RFC\n   2119 [RFC2119].\n   This document uses the same terminology as ICE
    (see Section 3 of\n   [RFC5245]).\n"
  title: 2.  Terminology
- contents:
  - "3.  Overview of Operation\n   The usage of ICE with TCP is relatively straightforward.
    \ This\n   specification mainly deals with how and when connections are opened\n
    \  and how those connections relate to candidate pairs.\n   When agents perform
    address allocations to gather TCP-based\n   candidates, three types of candidates
    can be obtained: active\n   candidates, passive candidates, and simultaneous-open
    (S-O)\n   candidates.  An active candidate is one for which the agent will\n   attempt
    to open an outbound connection but will not receive incoming\n   connection requests.
    \ A passive candidate is one for which the agent\n   will receive incoming connection
    attempts but not attempt a\n   connection.  An S-O candidate is one for which
    the agent will attempt\n   to open a connection simultaneously with its peer.\n
    \  When gathering candidates from a host interface, the agent typically\n   obtains
    active, passive, and S-O candidates.  Similarly, one can use\n   different techniques
    for obtaining, e.g., server reflexive, NAT-\n   assisted, tunneled, or relayed
    candidates of these three types (see\n   Section 5).  Connections to servers used
    for relayed and server\n   reflexive candidates are kept open during ICE processing.\n
    \  When encoding these candidates into offers and answers, the type of\n   the
    candidate is signaled.  In the case of active candidates, both IP\n   address
    and port are present, but the port is meaningless (it is\n   there only for making
    encoding of active candidates consistent with\n   the other candidate types and
    is ignored by the peer).  As a\n   consequence, active candidates do not need
    to be physically allocated\n   at the time of address gathering.  Rather, the
    physical allocations,\n   which occur as a consequence of a connection attempt,
    occur at the\n   time of the connectivity checks.\n   When the candidates are
    paired together, active candidates are always\n   paired with passive, and S-O
    candidates with each other.  When a\n   connectivity check is to be made on a
    candidate pair, each agent\n   determines whether it is to make a connection attempt
    for this pair.\n   The actual process of generating connectivity checks, managing
    the\n   state of the check list, and updating the Valid list works\n   identically
    for TCP as it does for UDP.\n   ICE requires an agent to demultiplex STUN and
    application-layer\n   traffic, since they appear on the same port.  This demultiplexing
    is\n   described in [RFC5245] and is done using the magic cookie and other\n   fields
    of the message.  Stream-oriented transports introduce another\n   wrinkle, since
    they require a way to frame the connection so that the\n   application and STUN
    packets can be extracted in order to\n   differentiate STUN packets from application-layer
    traffic.  For this\n   reason, TCP media streams utilizing ICE use the basic framing\n
    \  provided in RFC 4571 [RFC4571], even if the application layer\n   protocol
    is not RTP.\n   When Transport Layer Security (TLS) or Datagram Transport Layer\n
    \  Security (DTLS) is used, they are also run over the RFC 4571 framing\n   shim,
    while STUN runs outside of the (D)TLS connection.  The\n   resulting ICE TCP protocol
    stack is shown in Figure 1, with (D)TLS on\n   the left side and without it on
    the right side.\n                       +----------+\n                       |
    \         |\n                       |    App   |\n            +----------+----------+
    \    +----------+----------+\n            |          |          |     |          |
    \         |\n            |   STUN   |  (D)TLS  |     |   STUN   |    App   |\n
    \           +----------+----------+     +----------+----------+\n            |
    \                    |     |                     |\n            |      RFC 4571
    \      |     |      RFC 4571       |\n            +---------------------+     +---------------------+\n
    \           |                     |     |                     |\n            |
    \        TCP         |     |         TCP         |\n            +---------------------+
    \    +---------------------+\n            |                     |     |                     |\n
    \           |         IP          |     |         IP          |\n            +---------------------+
    \    +---------------------+\n              Figure 1: ICE TCP Stack with and without
    (D)TLS\n   The implication of this is that, for any media stream protected by\n
    \  (D)TLS, the agent will first run ICE procedures, exchanging STUN\n   messages.
    \ Then, once ICE completes, (D)TLS procedures begin.  ICE\n   and (D)TLS are thus
    \"peers\" in the protocol stack.  The STUN messages\n   are not sent over the
    (D)TLS connection, even ones sent for the\n   purposes of keepalive in the middle
    of the media session.\n"
  title: 3.  Overview of Operation
- contents:
  - "4.  Sending the Initial Offer\n   For offerers making use of ICE for TCP streams,
    the procedures below\n   are used.  The main differences compared to UDP candidates
    are the\n   new methods for gathering candidates, how TCP candidates are\n   prioritized,
    and how they are encoded in the Session Description\n   Protocol (SDP) offer and
    answer.\n"
  - contents:
    - "4.1.  Gathering Candidates\n   Providers of real-time communications services
      may decide that it is\n   preferable to have no media at all rather than to
      have media over\n   TCP.  To allow for choice, it is RECOMMENDED that it be
      possible to\n   configure agents to either obtain or not obtain TCP candidates
      for\n   real-time media.\n   Having it be configurable, and then configuring
      it to be off, is far\n   better than not having the capability at all.  An important
      goal of\n   this specification is to provide a single mechanism that can be
      used\n   across all types of endpoints.  As such, it is preferable to account\n
      \  for provider and network variation through configuration instead of\n   hard-coded
      limitations in an implementation.  Besides, network\n   characteristics and
      connectivity assumptions can, and will, change\n   over time.  Just because
      an agent is communicating with a server on\n   the public network today doesn't
      mean that it won't need to\n   communicate with one behind a NAT tomorrow.  Just
      because an agent is\n   behind a NAT with endpoint-independent mapping today
      doesn't mean\n   that tomorrow it won't pick up its agent and take it to a public\n
      \  network access point where there is a NAT with address- and port-\n   dependent
      mapping properties or one that only allows outbound TCP.\n   The way to handle
      these cases and build a reliable system is for\n   agents to implement a diverse
      set of techniques for allocating\n   addresses, so that at least one of them
      is almost certainly going to\n   work in any situation.  Implementors should
      consider very carefully\n   any assumptions made about deployments before electing
      not to\n   implement one of the mechanisms for address allocation.  In\n   particular,
      implementors should consider whether the elements in the\n   system may be mobile
      and connect through different networks with\n   different connectivity.  They
      should also consider whether endpoints\n   that are under their control, in
      terms of location and network\n   connectivity, would always be under their
      control.  In environments\n   where mobility and user control are possible,
      a multiplicity of\n   techniques is essential for reliability.\n   First, agents
      SHOULD obtain host candidates as described in\n   Section 5.1.  Then, each agent
      SHOULD \"obtain\" (allocate a\n   placeholder for) an active host candidate
      for each component of each\n   TCP-capable media stream on each interface that
      the host has.  The\n   agent does not yet have to actually allocate a port for
      these\n   candidates, but they are used for the creation of the check lists.\n
      \  The agent SHOULD then obtain server reflexive, NAT-assisted, and/or\n   UDP-tunneled
      candidates (see Section 5.2, Section 5.3, and\n   Section 5.4).  The mechanisms
      for establishing these candidates and\n   the number of candidates to collect
      vary from technique to technique.\n   These considerations are discussed in
      the relevant sections.\n   Next, agents SHOULD obtain passive (and possibly
      S-O) relayed\n   candidates for each component as described in Section 5.5.
      \ Each\n   agent SHOULD also allocate a placeholder for an active relayed\n
      \  candidate for each component of each TCP-capable media stream.\n   It is
      highly RECOMMENDED that a host obtains at least one set of host\n   candidates
      and one set of relayed candidates.  Obtaining additional\n   candidates will
      increase the chance of successfully creating a direct\n   connection.\n   Once
      the candidates have been obtained, the agent MUST keep the TCP\n   connections
      open until ICE processing has completed.  See Appendix B\n   for important implementation
      guidelines.\n   If a media stream is UDP-based (such as RTP), an agent MAY use
      an\n   additional host TCP candidate to request a UDP-based candidate from a\n
      \  TURN server (or some other relay with similar functionality).  Usage\n   of
      such UDP candidates follows the procedures defined in ICE for UDP\n   candidates.\n
      \  Like its UDP counterparts, TCP-based STUN transactions are paced out\n   at
      one every Ta milliseconds (see Section 16 of [RFC5245]).  This\n   pacing refers
      strictly to STUN transactions (both Binding and\n   Allocate requests).  If
      performance of the transaction requires\n   establishment of a TCP connection,
      then the connection gets opened\n   when the transaction is performed.\n"
    title: 4.1.  Gathering Candidates
  - contents:
    - "4.2.  Prioritization\n   The transport protocol itself is a criteria for choosing
      one\n   candidate over another.  If a particular media stream can run over\n
      \  UDP or TCP, the UDP candidates might be preferred over the TCP\n   candidates.
      \ This allows ICE to use the lower latency UDP\n   connectivity if it exists
      but fallback to TCP if UDP doesn't work.\n   In Section 4.1.2.1 of [RFC5245],
      a recommended formula for UDP ICE\n   candidate prioritization is defined.  For
      TCP candidates, the same\n   formula and candidate type preferences SHOULD be
      used, and the\n   RECOMMENDED type preferences for the new candidate types defined
      in\n   this document (see Section 5) are 105 for NAT-assisted candidates and\n
      \  75 for UDP-tunneled candidates.\n   When both UDP and TCP candidates are
      offered for the same media\n   stream, and one transport protocol should be
      preferred over the\n   other, the type preferences for the preferred transport
      protocol\n   candidates SHOULD be increased and/or the type preferences for
      the\n   other transport protocol candidates SHOULD be decreased.  How much\n
      \  the values should be increased or decreased depends on whether it is\n   more
      important to choose a certain transport protocol or a certain\n   candidate
      type.  If the candidate type is more important (e.g., even\n   if UDP is preferred,
      TCP host candidates are preferred over UDP\n   server reflexive candidates)
      changing type preference values by one\n   for the other transport protocol
      candidates is enough.  On the other\n   hand, if the transport protocol is more
      important (e.g., any UDP\n   candidate is preferred over any TCP candidate),
      all the preferred\n   transport protocol candidates SHOULD have type preference
      higher than\n   the other transport protocol candidates.  However, it is RECOMMENDED\n
      \  that the relayed candidates are still preferred lower than the other\n   candidate
      types.  For RTP-based media streams, it is RECOMMENDED that\n   UDP candidates
      are preferred over TCP candidates.\n   With TCP candidates, the local preference
      part of the recommended\n   priority formula is updated to also include the
      directionality\n   (active, passive, or simultaneous-open) of the TCP connection.
      \ The\n   RECOMMENDED local preference is then defined as:\n      local preference
      = (2^13) * direction-pref + other-pref\n   The direction-pref MUST be between
      0 and 7 (both inclusive), with 7\n   being the most preferred.  The other-pref
      MUST be between 0 and 8191\n   (both inclusive), with 8191 being the most preferred.
      \ It is\n   RECOMMENDED that the host, UDP-tunneled, and relayed TCP candidates\n
      \  have the direction-pref assigned as follows: 6 for active, 4 for\n   passive,
      and 2 for S-O.  For the NAT-assisted and server reflexive\n   candidates, the
      RECOMMENDED values are: 6 for S-O, 4 for active, and\n   2 for passive.\n   The
      preference priorities listed here are simply recommendations that\n   try to
      strike a balance between success probability and the resulting\n   path's efficiency.
      \ Depending on the scenario where ICE TCP is used,\n   different values may
      be appropriate.  For example, if the overhead of\n   a UDP tunnel is not an
      issue, those candidates should be prioritized\n   higher since they are likely
      to have a high success probability.\n   Also, simultaneous-open is prioritized
      higher than active and passive\n   candidates for NAT-assisted and server reflexive
      candidates since if\n   TCP S-O is supported by the operating systems of both
      endpoints, it\n   should work at least as well as the active-passive approach.
      \ If an\n   implementation is uncertain whether S-O candidates are supported,
      it\n   may be reasonable to prioritize them lower.  For host, UDP-tunneled,\n
      \  and relayed candidates, the S-O candidates are prioritized lower than\n   active
      and passive since active-passive candidates should work with\n   them at least
      as well as the S-O candidates.\n   If any two candidates have the same type-preference
      and direction-\n   pref, they MUST have a unique other-pref.  With this specification,\n
      \  this usually only happens with multi-homed hosts, in which case\n   other-pref
      is the preference for the particular IP address from which\n   the candidate
      was obtained.  When there is only a single IP address,\n   this value SHOULD
      be set to the maximum allowed value (8191).\n"
    title: 4.2.  Prioritization
  - contents:
    - "4.3.  Choosing Default Candidates\n   The default candidate is chosen primarily
      based on the likelihood of\n   it working with a non-ICE peer.  When media streams
      supporting mixed\n   modes (both TCP and UDP) are used with ICE, it is RECOMMENDED
      that,\n   for real-time streams (such as RTP), the default candidates be UDP-\n
      \  based.  However, the default SHOULD NOT be a simultaneous-open\n   candidate.\n
      \  If a media stream is inherently TCP-based, it is RECOMMENDED for an\n   offering
      full agent to select an active candidate as the default\n   candidate and use
      [RFC4145] \"setup\" attribute value \"active\".  This\n   increases the chances
      for a successful NAT traversal even without ICE\n   support if the agent is
      behind a NAT and the peer is not.  For the\n   same reason, for a lite agent,
      it is RECOMMENDED to use a passive\n   candidate and \"setup\" attribute value
      \"passive\" in the offer.\n"
    title: 4.3.  Choosing Default Candidates
  - contents:
    - "4.4.  Lite Implementation Requirements\n   If an offerer meets the criteria
      for the lite mode as described in\n   Appendix A of [RFC5245] (i.e., it will
      always have a public, globally\n   unique IP address), it MAY use the lite mode
      of ICE for TCP\n   candidates.  In the lite mode, for TCP candidates, only passive
      host\n   candidates are gathered, unless active candidates are needed as the\n
      \  default candidates.  Otherwise, the procedures described for lite\n   mode
      in [RFC5245] also apply to TCP candidates.  If UDP and TCP\n   candidates are
      mixed in a media stream, the mode (lite or full)\n   applies to both UDP and
      TCP candidates.\n"
    title: 4.4.  Lite Implementation Requirements
  - contents:
    - "4.5.  Encoding the SDP\n   TCP-based candidates are encoded into a=candidate
      lines like the UDP\n   candidates described in [RFC5245].  However, the transport
      protocol\n   (i.e., value of the transport-extension token defined in [RFC5245],\n
      \  Section 15.1) is set to \"TCP\" and the connection type (active,\n   passive,
      or S-O) is encoded using a new extension attribute.  With\n   TCP candidates,
      the candidate-attribute syntax with Augmented BNF\n   [RFC5234] is then:\n   candidate-attribute
      \  = \"candidate\" \":\" foundation SP component-id SP\n                           \"TCP\"
      SP\n                           priority SP\n                           connection-address
      SP\n                           port SP\n                           cand-type\n
      \                          [SP rel-addr]\n                           [SP rel-port]\n
      \                          SP tcp-type-ext\n                           *(SP
      extension-att-name SP\n                                extension-att-value)\n
      \  tcp-type-ext          = \"tcptype\" SP tcp-type\n   tcp-type              =
      \"active\" / \"passive\" / \"so\"\n   The connection-address encoded into the
      candidate-attribute for\n   active candidates MUST be set to the IP address
      that will be used for\n   the attempt, but the port(s) MUST be set to 9 (i.e.,
      Discard).  For\n   active relayed candidates, the value for connection-address
      MUST be\n   identical to the IP address of a passive or simultaneous-open\n
      \  candidate from the same relay server.\n   If the default candidate is TCP-based,
      the agent MUST include the\n   a=setup and a=connection attributes from RFC
      4145 [RFC4145],\n   following the procedures defined there as if ICE were not
      in use.  In\n   particular, if an agent is the answerer, the a=setup attribute
      MUST\n   meet the constraints in RFC 4145 based on the value in the offer.\n
      \  If an agent is utilizing SRTP [RFC3711], it MAY include a mix of UDP\n   and
      TCP candidates.  If ICE selects a TCP candidate pair, it is\n   RECOMMENDED
      that the agent still utilizes SRTP but runs it over the\n   connection established
      by ICE.  The alternative, RTP over TLS, breaks\n   RTP header compression and
      on-path RTP analysis tools and hence\n   SHOULD be avoided.  In the case of
      DTLS-SRTP [RFC5764], the\n   directionality attributes (a=setup) are utilized
      strictly to\n   determine the direction of the DTLS handshake.  Directionality
      of the\n   TCP connection establishment is determined by the ICE attributes
      and\n   procedures defined here.\n   If an agent is securing non-RTP media over
      TCP/TLS, the SDP MUST be\n   constructed as described in RFC 4572 [RFC4572].
      \ The directionality\n   attributes (a=setup) are utilized strictly to determine
      the direction\n   of the TLS handshake.  Directionality of the TCP connection\n
      \  establishment is determined by the ICE attributes and procedures\n   defined
      here.\n   Examples of SDP offers and answers with ICE TCP extensions are shown\n
      \  in Appendix C.\n"
    title: 4.5.  Encoding the SDP
  title: 4.  Sending the Initial Offer
- contents:
  - "5.  Candidate Collection Techniques\n   The following sections discuss a number
    of techniques that can be\n   used to obtain candidates for use with ICE TCP.
    \ It is important to\n   note that this list is not intended to be exhaustive,
    nor is\n   implementation of any specific technique beyond host candidates\n   (Section
    5.1) considered mandatory.\n   Implementors are encouraged to implement as many
    of the following\n   techniques from the following list as is practical, as well
    as to\n   explore additional NAT-traversal techniques beyond those discussed in\n
    \  this document.  However, to get a reasonable success ratio, one\n   SHOULD
    implement at least one relayed technique (e.g., TURN) and one\n   technique for
    discovering the address given for the host by a NAT\n   (e.g., STUN).\n   To increase
    the success probability with the techniques described\n   below and to aid with
    transition to IPv6, implementors SHOULD take\n   particular care to include both
    IPv4 and IPv6 candidates as part of\n   the process of gathering candidates.  If
    the local network or host\n   does not support IPv6 addressing, then clients SHOULD
    make use of\n   other techniques, e.g., TURN-IPv6 [RFC6156], Teredo [RFC4380],
    or\n   SOCKS IPv4-IPv6 gatewaying [RFC3089], for obtaining IPv6 candidates.\n
    \  While implementations SHOULD support as many techniques as feasible,\n   they
    SHOULD also consider which of them to use if multiple options\n   are available.
    \ Since different candidates are paired with each\n   other, offering a large
    number of candidates results in a large check\n   list and potentially long-lasting
    connectivity checks.  For example,\n   using multiple NAT-assisted techniques
    with the same NAT usually\n   results only in redundant candidates.  Similarly,
    using just one of\n   the multiple UDP tunneling or relaying techniques is often
    enough.\n"
  - contents:
    - "5.1.  Host Candidates\n   Host candidates are the most simple candidates since
      they only\n   require opening TCP sockets on the host's interfaces and sending/\n
      \  receiving connectivity checks from them.  However, if the hosts are\n   behind
      different NATs, host candidates usually fail to work.  On the\n   other hand,
      if there are no NATs between the hosts, host candidates\n   are the most efficient
      method since they require no additional NAT\n   traversal protocols or techniques.\n
      \  For each TCP-capable media stream the agent wishes to use (including\n   ones
      like RTP that can be either UDP or TCP), the agent SHOULD obtain\n   two host
      candidates (each on a different port) for each component of\n   the media stream
      on each interface that the host has -- one for the\n   simultaneous-open and
      one for the passive candidate.  If an agent is\n   not capable of acting in
      one of these modes, it would omit those\n   candidates.\n"
    title: 5.1.  Host Candidates
  - contents:
    - "5.2.  Server Reflexive Candidates\n   Server reflexive techniques aim to discover
      the address a NAT has\n   given for the host by asking that from a server on
      the other side of\n   the NAT and then creating proper bindings (unless such
      already exist)\n   on the NATs with connectivity checks sent between the hosts.
      \ Success\n   of these techniques depends on the NATs' mapping and filtering\n
      \  behavior [RFC5382] and also on whether the NATs and hosts support the\n   TCP
      simultaneous-open technique.\n   Obtaining server reflexive passive candidates
      may require initiating\n   connections from host's passive candidates; see Appendix
      B for\n   implementation details on this.  Server reflexive active candidates\n
      \  can be derived from passive or S-O candidates by using the same IP\n   addresses
      and interfaces as those candidates.  It is useful to obtain\n   both server
      reflexive passive and S-O candidates since which one\n   actually works better
      depends on the hosts and NATs.  Furthermore,\n   some techniques (e.g., TURN
      relaying) require knowing the IP address\n   of the peer's active candidates
      beforehand, so active server\n   reflexive candidates are needed for such techniques
      to function\n   properly.\n   A widely used protocol for obtaining server reflexive
      candidates is\n   STUN.  Its TCP-specific behavior is described in [RFC5389],
      Section\n   7.2.2.\n"
    title: 5.2.  Server Reflexive Candidates
  - contents:
    - "5.3.  NAT-Assisted Candidates\n   NAT-assisted techniques communicate with
      the NATs directly and, in\n   this way, discover the address that the NAT has
      given to the host.\n   NAT-assisted techniques also create proper bindings on
      the NATs.  The\n   benefit of these techniques over the server reflexive techniques
      is\n   that the NATs can adjust their mapping and filtering behavior so that\n
      \  connections can be successfully created.  A downside of NAT-assisted\n   techniques
      is that they commonly allow communicating only with a NAT\n   that is in the
      same subnet as the host and thus often fail in\n   scenarios with multiple layers
      of NATs.  These techniques also rely\n   on NATs supporting the specific protocols
      and allowing the users to\n   modify their behavior.\n   These candidates are
      encoded in the ICE offer and answer like the\n   server reflexive candidates,
      but they (commonly) use a higher\n   priority (as described in Section 4.2)
      and hence are tested before\n   the server reflexive candidates.\n   Currently,
      the Universal Plug and Play (UPnP) forum's Internet\n   Gateway Device (IGD)
      protocol [UPnP-IGD] and the NAT Port Mapping\n   Protocol (PMP) [NAT-PMP] are
      widely supported NAT-assisted\n   techniques.  Other known protocols include
      Port Control Protocol\n   (PCP) [PCP-BASE], SOCKS [RFC1928], Realm Specific
      IP (RSIP)\n   [RFC3103], and Simple Middlebox Configuration (SIMCO) [RFC4540].\n
      \  Also, the Middlebox Communications (MIDCOM) MIB [RFC5190] defines a\n   mechanism
      based on the Simple Network Management Protocol (SNMP) for\n   controlling NATs.\n"
    title: 5.3.  NAT-Assisted Candidates
  - contents:
    - "5.4.  UDP-Tunneled Candidates\n   UDP-tunneled NAT traversal techniques utilize
      the fact that UDP NAT\n   traversal is simpler and more efficient than TCP NAT
      traversal.  With\n   these techniques, the TCP packets (or possibly complete
      IP packets)\n   are encapsulated in UDP packets.  Because of the encapsulation,
      these\n   techniques increase the overhead for the connection and may require\n
      \  support from both of the endpoints, but on the other hand, UDP\n   tunneling
      commonly results in reliable and fairly simple TCP NAT\n   traversal.\n   UDP-tunneled
      candidates can be encoded in the ICE offer and answer\n   either as relayed
      or server reflexive candidates, depending on\n   whether the tunneling protocol
      utilizes a relay between the hosts.\n   The UDP-tunneled candidates may appear
      to applications as host\n   candidates from a local pseudo-interface.  Treating
      these candidates\n   as host candidates results in incorrect prioritization
      and possibly\n   non-optimal candidate selection.  Implementations may attempt
      to\n   detect pseudo-interfaces, e.g., from the address prefix of the\n   interface,
      but detection details vary from technique to technique.\n   For example, the
      Teredo protocol [RFC4380] [RFC6081] provides\n   automatic UDP tunneling and
      IPv6 interworking.  The Teredo UDP tunnel\n   is visible to the host application
      as an IPv6 address; thus, Teredo\n   candidates are encoded as IPv6 addresses.\n"
    title: 5.4.  UDP-Tunneled Candidates
  - contents:
    - "5.5.  Relayed Candidates\n   Relaying packets through a relay server is often
      the NAT traversal\n   technique that has the highest success probability: communicating
      via\n   a relay that is in the public Internet looks like normal client-\n   server
      communication for the NATs and is supported in practice by all\n   existing
      NATs, regardless of their filtering and mapping behavior.\n   However, using
      a relay has several drawbacks, e.g., it usually\n   results in a sub-optimal
      path for the packets, the relay needs to\n   exist and it needs to be discovered,
      the relay is a possible single\n   point of failure, relaying consumes potentially
      a lot of resources of\n   the relay server, etc.  Therefore, relaying is often
      used as the last\n   resort when no direct path can be created with other NAT
      traversal\n   techniques.\n   With relayed candidates, the host commonly needs
      to obtain only a\n   passive candidate since any of the peer's server reflexive
      (and NAT-\n   assisted if the peer can communicate with the outermost NAT) active\n
      \  candidates should work with the passive relayed candidate.  However,\n   if
      the relay is behind a NAT or a firewall, also using active and S-O\n   candidates
      will increase success probability.\n   Relaying protocols capable of relaying
      TCP connections include TURN\n   TCP [RFC6062] and SOCKS [RFC1928] (which can
      also be used for IPv4-\n   IPv6 gatewaying [RFC3089]).  It is also possible
      to use a Secure\n   SHell (SSH) [RFC4251] tunnel as a relayed candidate if a
      suitable\n   server is available and the server permits this.\n"
    title: 5.5.  Relayed Candidates
  title: 5.  Candidate Collection Techniques
- contents:
  - "6.  Receiving the Initial Offer and Answer\n   Handling an ICE offer with TCP
    candidates works in a similar way as\n   with UDP candidates.  First, ICE support
    is verified (including the\n   check for ice-mismatch described in Section 5.1
    of [RFC5245]) and\n   agent roles are determined.  Candidates are gathered using
    the\n   techniques described in Section 5 and prioritized as described in\n   Section
    4.2.  Default candidates are selected taking into account the\n   considerations
    in Section 4.3.  The SDP answer is encoded as in\n   Section 4.3 of [RFC5245],
    with the exception of TCP candidates whose\n   encoding is described in Section
    4.5.\n   When the offerer receives the initial answer, it also verifies ICE\n
    \  support and determines its role.  If both of the agents use lite\n   implementations,
    the offerer takes the controlling role and uses the\n   procedures defined in
    [RFC4145] to select the most preferred\n   candidate pair with a new offer.\n"
  - contents:
    - "6.1.  Considerations with Two Lite Agents\n   If both agents are using the
      lite mode and if the offerer uses the\n   a=setup:active attribute [RFC4145]
      in the new offer, the offerer MAY\n   initiate the TCP connection on the selected
      pair in parallel with the\n   new offer to speed up the connection establishment.
      \ Consequently,\n   the answerer MUST still accept incoming TCP connections
      to any of the\n   passive candidates it listed in the answer, from any of the
      IP\n   addresses the offerer listed in the initial offer.\n   If the answerer
      receives the new offer matching the candidate pair\n   where a connection was
      already created in parallel with the new\n   offer, it MUST accept the offer
      and respond to it while keeping the\n   already-created connection.  If the
      connection that was created in\n   parallel with the new offer does not match
      the candidate pair in the\n   new offer, the connection MUST be closed, and
      ICE restart SHOULD be\n   performed.\n   Since the connection endpoints are
      not authenticated using the\n   connectivity checks in the scenario where both
      agents use the lite\n   mode, unless media-level security (e.g., TLS) is used,
      it is\n   RECOMMENDED to use the full mode instead.  For more lite versus full\n
      \  implementation considerations, see Appendix A of [RFC5245].\n"
    title: 6.1.  Considerations with Two Lite Agents
  - contents:
    - "6.2.  Forming the Check Lists\n   As with UDP, check lists are formed only
      by full ICE implementations.\n   When forming candidate pairs, the following
      types of TCP candidates\n   can be paired with each other:\n   Local           Remote\n
      \  Candidate       Candidate\n   ---------------------------\n   tcp-so          tcp-so\n
      \  tcp-active      tcp-passive\n   tcp-passive     tcp-active\n   When the agent
      prunes the check list, it MUST also remove any pair\n   for which the local
      candidate is a passive TCP candidate.  With\n   pruning, the NAT-assisted candidates
      are treated like server\n   reflexive candidates if the base is also used as
      a host candidate.\n   The remainder of check list processing works in the same
      way as the\n   UDP case.\n"
    title: 6.2.  Forming the Check Lists
  title: 6.  Receiving the Initial Offer and Answer
- contents:
  - "7.  Connectivity Checks\n   The TCP connectivity checks, like with UDP, are generated
    only by\n   full implementations.  The TCP candidate pairs are in the same check\n
    \  list with the UDP candidate pairs, and they are scheduled for\n   connectivity
    checks, as described in Section 5.8 of [RFC5245], based\n   on the priority order.\n"
  - contents:
    - "7.1.  STUN Client Procedures\n   When an agent wants to send a TCP-based connectivity
      check, it first\n   opens a TCP connection, if none yet exists, for the 5-tuple
      defined\n   by the candidate pair for which the check is to be sent.  This\n
      \  connection is opened from the local candidate of the pair to the\n   remote
      candidate of the pair.  If the local candidate is tcp-active,\n   the agent
      MUST open a connection from the interface associated with\n   that local candidate.
      \ This connection SHOULD be opened from an\n   unallocated port.  For host candidates,
      this is readily done by\n   connecting from the local candidate's interface.
      \ For relayed, NAT-\n   assisted, and UDP-tunneled candidates, the agent may
      need to use\n   additional procedures specific to the protocol.\n   Once the
      connection is established, the agent MUST utilize the shim\n   defined in RFC
      4571 [RFC4571] for the duration this connection\n   remains open.  The STUN
      Binding requests and responses are sent on\n   top of this shim, so that the
      length field defined in RFC 4571\n   precedes each STUN message.  If TLS or
      DTLS-SRTP is to be utilized\n   for the media session, the TLS or DTLS-SRTP
      handshakes will take\n   place on top of this shim as well.  However, they only
      start once ICE\n   processing has completed.  In essence, the TLS or DTLS-SRTP\n
      \  handshakes are considered a part of the media protocol.  STUN is\n   never
      run within the TLS or DTLS-SRTP session as part of the ICE\n   procedures.\n
      \  If the TCP connection cannot be established, the check is considered\n   to
      have failed, and a full-mode agent MUST update the pair state to\n   Failed
      in the check list.  See Section 7.2.2 of [RFC5389] for more\n   details on STUN
      over TCP.\n   Once the connection is established, client procedures are identical\n
      \  to those for UDP candidates.  However, retransmissions of the STUN\n   connectivity
      check messages are not needed, since TCP takes care of\n   reliable delivery
      of the messages.  Note also that STUN responses\n   received on an active TCP
      candidate will typically produce a peer\n   reflexive candidate.  If the response
      to the first connectivity check\n   on the established TCP connection is something
      other than a STUN\n   message, the remote candidate address apparently was not
      one of the\n   peer's addresses, and the agent SHOULD close the connection and\n
      \  consider all pairs with that remote candidate as failed.\n"
    title: 7.1.  STUN Client Procedures
  - contents:
    - "7.2.  STUN Server Procedures\n   An ICE TCP agent, full or lite, MUST be prepared
      to receive incoming\n   TCP connection requests on the base of any TCP candidate
      that is\n   simultaneous-open or passive.  When the connection request is\n
      \  received, the agent MUST accept it.  The agent MUST utilize the\n   framing
      defined in RFC 4571 [RFC4571] for the lifetime of this\n   connection.  Due
      to this framing, the agent will receive data in\n   discrete frames.  Each frame
      could be media (such as RTP or SRTP),\n   TLS, DTLS, or STUN packets.  The STUN
      packets are extracted as\n   described in Section 10.2.\n   Once the connection
      is established, STUN server procedures are\n   identical to those for UDP candidates.
      \ Note that STUN requests\n   received on a passive TCP candidate will typically
      produce a remote\n   peer reflexive candidate.\n"
    title: 7.2.  STUN Server Procedures
  title: 7.  Connectivity Checks
- contents:
  - "8.  Concluding ICE Processing\n   If there are TCP candidates for a media stream,
    a controlling agent\n   MUST use the regular selection algorithm.\n   When ICE
    processing for a media stream completes, each agent SHOULD\n   close all TCP connections
    (that were opened due to this ICE session)\n   except the ones between the candidate
    pairs selected by ICE.\n   These two rules are related; the closure of connection
    on completion\n   of ICE implies that a regular selection algorithm has to be
    used.\n   This is because aggressive selection might cause transient pairs to\n
    \  be selected.  Once such a pair is selected, the agents would close\n   the
    other connections, one of which may be about to be selected as a\n   better choice.
    \ This race condition may result in TCP connections\n   being accidentally closed
    for the pair that ICE selects.\n"
  title: 8.  Concluding ICE Processing
- contents:
  - '9.  Subsequent Offer/Answer Exchanges

    '
  - contents:
    - "9.1.  Updated Offer\n   When an updated offer is generated by the controlling
      endpoint after\n   the connectivity checks have succeeded, the SDP extensions
      for\n   connection-oriented media [RFC4145] are used to signal that an\n   existing
      connection should be used, rather than opening a new one.\n"
    title: 9.1.  Updated Offer
  - contents:
    - "9.2.  ICE Restarts\n   If an ICE restart occurs for a media stream with TCP
      candidate pairs\n   that have been selected by ICE, the agents MUST NOT close
      the\n   connections after the restart.  In the offer or answer that causes\n
      \  the restart, an agent MAY include a simultaneous-open candidate whose\n   transport
      address matches the previously selected candidate.  If both\n   agents do this,
      the result will be a simultaneous-open candidate pair\n   matching an existing
      TCP connection.  In this case, the agents MUST\n   NOT attempt to open a new
      connection (or start new TLS or DTLS-SRTP\n   procedures).  Instead, that existing
      connection is reused, and STUN\n   checks are performed.\n   Once the restart
      completes, if the selected pair does not match the\n   previously selected pair,
      the TCP connection for the previously\n   selected pair SHOULD be closed by
      the agent.\n"
    title: 9.2.  ICE Restarts
  title: 9.  Subsequent Offer/Answer Exchanges
- contents:
  - '10.  Media Handling

    '
  - contents:
    - "10.1.  Sending Media\n   When sending media, if the selected candidate pair
      matches an\n   existing TCP connection, that connection MUST be used for sending\n
      \  media.\n   The framing defined in RFC 4571 MUST be used when sending media.
      \ For\n   media streams that are not RTP-based and do not normally use RFC\n
      \  4571, the agent treats the media stream as a byte stream and assumes\n   that
      it has its own framing of some sort, if needed.  It then takes\n   an arbitrary
      number of bytes from the byte stream and places that as\n   a payload in the
      RFC 4571 frames, including the length.  Next, the\n   sender checks to see if
      the resulting set of bytes would be viewed as\n   a STUN packet based on the
      rules in Sections 6 and 8 of [RFC5389].\n   This includes a check on the most
      significant two bits, the magic\n   cookie, the length, and the fingerprint.
      \ If, based on those rules,\n   the bytes would be viewed as a STUN message,
      the sender MUST utilize\n   a different number of bytes so that the length checks
      will fail.\n   Though it is normally highly unlikely that an arbitrary number
      of\n   bytes from a byte stream would resemble a STUN packet based on all of\n
      \  the checks, it can happen if the content of the application stream\n   happens
      to contain a STUN message (for example, a file transfer of\n   logs from a client
      that includes STUN messages).\n   If TLS or DTLS-SRTP procedures are being utilized
      to protect the\n   media stream, those procedures start at the point that media
      is\n   permitted to flow, as defined in the ICE specification [RFC5245].\n   The
      TLS or DTLS-SRTP handshakes occur on top of the RFC 4571 shim and\n   are considered
      part of the media stream for the purposes of this\n   specification.\n"
    title: 10.1.  Sending Media
  - contents:
    - "10.2.  Receiving Media\n   The framing defined in RFC 4571 MUST be used when
      receiving media.\n   For media streams that are not RTP-based and do not normally
      use RFC\n   4571, the agent extracts the payload of each RFC 4571 frame and\n
      \  determines if it is a STUN or an application-layer data based on the\n   procedures
      in ICE [RFC5245].  If media is being protected with DTLS-\n   SRTP, the DTLS,
      RTP, and STUN packets are demultiplexed as described\n   in Section 5.1.2 of
      [RFC5764].\n   For non-STUN data, the agent appends this to the ongoing byte
      stream\n   collected from the frames.  It then parses the byte stream as if
      it\n   had been directly received over the TCP connection.  This allows for\n
      \  ICE TCP to work without regard to the framing mechanism used by the\n   application-layer
      protocol.\n"
    title: 10.2.  Receiving Media
  title: 10.  Media Handling
- contents:
  - '11.  Connection Management

    '
  - contents:
    - "11.1.  Connections Formed during Connectivity Checks\n   Once a TCP or TCP/TLS
      connection is opened by ICE for the purpose of\n   connectivity checks, its
      life cycle depends on how it is used.  If\n   that candidate pair is selected
      by ICE for usage for media, an agent\n   SHOULD keep the connection open until:\n
      \  o  the session terminates,\n   o  the media stream is removed, or\n   o  an
      ICE restart takes place, resulting in the selection of a\n      different candidate
      pair.\n   In any of these cases, the agent SHOULD close the connection when\n
      \  that event occurs.  This applies to both agents in a session, in\n   which
      case one of the agents will usually end up closing the\n   connection first.\n
      \  If a connection has been selected by ICE, an agent MAY close it\n   anyway.
      \ As described in the next paragraph, this will cause it to be\n   reopened
      almost immediately, and in the interim, media cannot be\n   sent.  Consequently,
      such closures have a negative effect and are NOT\n   RECOMMENDED.  However,
      there may be cases where an agent needs to\n   close a connection for some reason.\n
      \  If an agent needs to send media on the selected candidate pair, and\n   its
      TCP connection has closed, then:\n   o  If the agent's local candidate is tcp-active
      or tcp-so, it MUST\n      reopen a connection to the remote candidate of the
      selected pair.\n   o  If the agent's local candidate is tcp-passive, the agent
      MUST\n      await an incoming connection request and, consequently, will not\n
      \     be able to send media until it has been opened.\n   If the TCP connection
      is established, the framing of RFC 4571 is\n   utilized.  If the agent opened
      the connection and is a full agent, it\n   MUST send a STUN connectivity check.
      \ An agent MUST be prepared to\n   receive a connectivity check over a connection
      it opened or accepted\n   (note that this is true in general; ICE requires that
      an agent be\n   prepared to receive a connectivity check at any time, even after
      ICE\n   processing completes).  If a full agent receives a connectivity check\n
      \  after re-establishment of the connection, it MUST generate a\n   triggered
      check over that connection in response if it has not\n   already sent a check.
      \ Once an agent has sent a check and received a\n   successful response, the
      connection is considered Valid, and media\n   can be sent (which includes a
      TLS or DTLS-SRTP session resumption or\n   restart).\n   If the TCP connection
      cannot be established, the controlling agent\n   SHOULD restart ICE for this
      media stream.  This will happen in cases\n   where one of the agents is behind
      a NAT with connection-dependent\n   mapping properties [RFC5382].\n"
    title: 11.1.  Connections Formed during Connectivity Checks
  - contents:
    - "11.2.  Connections Formed for Gathering Candidates\n   If the agent opened
      a connection to a STUN server, or another similar\n   server, for the purposes
      of gathering a server reflexive candidate,\n   that connection SHOULD be closed
      by the client once ICE processing\n   has completed.  This happens regardless
      of whether the candidate\n   learned from the server was selected by ICE.\n
      \  If the agent opened a connection to a TURN server for the purposes of\n   gathering
      a relayed candidate, that connection MUST be kept open by\n   the client for
      the duration of the media session if a relayed\n   candidate from the TURN server
      was selected by ICE.  Otherwise, the\n   connection to the TURN server SHOULD
      be closed once ICE processing\n   completes.\n   If, despite efforts of the
      client, a TCP connection to a TURN server\n   fails during the lifetime of the
      media session utilizing a transport\n   address allocated by that server, the
      client SHOULD reconnect to the\n   TURN server, obtain a new allocation, and
      restart ICE for that media\n   stream.  Similar measures SHOULD apply also to
      other types of\n   relaying servers.\n"
    title: 11.2.  Connections Formed for Gathering Candidates
  title: 11.  Connection Management
- contents:
  - "12.  Security Considerations\n   The main threat in ICE is hijacking of connections
    for the purposes\n   of directing media streams to denial-of-service (DoS) targets
    or to\n   malicious users.  When full implementations are used, ICE TCP\n   prevents
    that by only using TCP connections that have been validated.\n   Validation requires
    a STUN transaction to take place over the\n   connection.  This transaction cannot
    complete without both\n   participants knowing a shared secret exchanged in the
    rendezvous\n   protocol used with ICE, such as SIP [RFC3261].  This shared secret,\n
    \  in turn, is protected by that protocol exchange.  In the case of SIP,\n   the
    usage of the SIP Secure (SIPS) [RFC3261] mechanism is\n   RECOMMENDED.  When this
    is done, an attacker, even if it knows or can\n   guess the port on which an agent
    is listening for incoming TCP\n   connections, will not be able to open a connection
    and send media to\n   the agent.\n   If the rendezvous protocol exchange is compromised,
    the shared secret\n   can be learned by an attacker, and the attacker may be able
    to fake\n   the connectivity check validation and open a TCP connection to the\n
    \  target.  Hence, using additional security mechanisms (e.g.,\n   application-layer
    security) that mitigate these risks is RECOMMENDED.\n   A STUN amplification attack
    is described in Section 18.5.2 of\n   [RFC5245].  The same considerations apply
    to TCP, but the\n   amplification effect with TCP is larger due to need for establishing\n
    \  a TCP connection before any checks are performed.  Therefore, an ICE\n   agent
    SHOULD NOT have more than 5 outstanding TCP connection attempts\n   with the same
    peer to the same IP address.\n   If both agents use the lite mode, no connectivity
    checks are sent,\n   and additional procedures (e.g., media-level security) are
    needed to\n   validate the connection.  The lack of connectivity checks is\n   especially
    problematic if one of the hosts is behind a NAT and has an\n   address from a
    private address space: the peer may accidentally\n   connect to a host in a different
    subnet that uses the same private\n   address space.  This is one of the reasons
    why the lite mode is not\n   appropriate for an ICE agent located behind a NAT.\n
    \  A more detailed analysis of different attacks and the various ways\n   ICE
    prevents them are described in [RFC5245].  Those considerations\n   apply to this
    specification.\n"
  title: 12.  Security Considerations
- contents:
  - "13.  IANA Considerations\n   IANA has created a new sub-registry \"ICE Transport
    Protocols\" in the\n   \"Interactive Connectivity Establishment (ICE)\" registry
    for ICE\n   candidate-attribute transport extensions.  Initial values are given\n
    \  below; future assignments are to be made through IETF Review or IESG\n   Approval
    [RFC5226].  Assignments consist of an extension token (as\n   defined in Section
    15.1 of [RFC5245]) and a reference to the document\n   defining the extension.\n
    \  Token   Reference\n   -----   ---------\n   UDP     RFC 5245, Section 15.1\n
    \  TCP     RFC 6544, Section 4.5\n"
  title: 13.  IANA Considerations
- contents:
  - "14.  Acknowledgements\n   The authors would like to thank Tim Moore, Saikat Guha,
    Francois\n   Audet, Roni Even, Simon Perreault, Alfred Heggestad, Hadriel Kaplan,\n
    \  Jonathan Lennox, Flemming Andreasen, Dan Wing, and Vijay Gurbani for\n   the
    reviews and input on this document.  Special thanks to Marc\n   Petit-Huguenin
    for providing the SDP examples.\n"
  title: 14.  Acknowledgements
- contents:
  - '15.  References

    '
  - contents:
    - "15.1.  Normative References\n   [RFC2119]   Bradner, S., \"Key words for use
      in RFCs to Indicate\n               Requirement Levels\", BCP 14, RFC 2119,
      March 1997.\n   [RFC3261]   Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,\n
      \              A., Peterson, J., Sparks, R., Handley, M., and E.\n               Schooler,
      \"SIP: Session Initiation Protocol\", RFC 3261,\n               June 2002.\n
      \  [RFC3264]   Rosenberg, J. and H. Schulzrinne, \"An Offer/Answer Model\n               with
      Session Description Protocol (SDP)\", RFC 3264,\n               June 2002.\n
      \  [RFC3711]   Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K.\n               Norrman,
      \"The Secure Real-time Transport Protocol\n               (SRTP)\", RFC 3711,
      March 2004.\n   [RFC4145]   Yon, D. and G. Camarillo, \"TCP-Based Media Transport
      in\n               the Session Description Protocol (SDP)\", RFC 4145,\n               September
      2005.\n   [RFC4571]   Lazzaro, J., \"Framing Real-time Transport Protocol (RTP)\n
      \              and RTP Control Protocol (RTCP) Packets over Connection-\n               Oriented
      Transport\", RFC 4571, July 2006.\n   [RFC4572]   Lennox, J., \"Connection-Oriented
      Media Transport over the\n               Transport Layer Security (TLS) Protocol
      in the Session\n               Description Protocol (SDP)\", RFC 4572, July
      2006.\n   [RFC5226]   Narten, T. and H. Alvestrand, \"Guidelines for Writing
      an\n               IANA Considerations Section in RFCs\", BCP 26, RFC 5226,\n
      \              May 2008.\n   [RFC5234]   Crocker, D. and P. Overell, \"Augmented
      BNF for Syntax\n               Specifications: ABNF\", STD 68, RFC 5234, January
      2008.\n   [RFC5245]   Rosenberg, J., \"Interactive Connectivity Establishment\n
      \              (ICE): A Protocol for Network Address Translator (NAT)\n               Traversal
      for Offer/Answer Protocols\", RFC 5245,\n               April 2010.\n   [RFC5389]
      \  Rosenberg, J., Mahy, R., Matthews, P., and D. Wing,\n               \"Session
      Traversal Utilities for NAT (STUN)\", RFC 5389,\n               October 2008.\n
      \  [RFC5764]   McGrew, D. and E. Rescorla, \"Datagram Transport Layer\n               Security
      (DTLS) Extension to Establish Keys for the\n               Secure Real-time
      Transport Protocol (SRTP)\", RFC 5764,\n               May 2010.\n   [RFC5766]
      \  Mahy, R., Matthews, P., and J. Rosenberg, \"Traversal\n               Using
      Relays around NAT (TURN): Relay Extensions to\n               Session Traversal
      Utilities for NAT (STUN)\", RFC 5766,\n               April 2010.\n"
    title: 15.1.  Normative References
  - contents:
    - "15.2.  Informative References\n   [IMC05]     Guha, S. and P. Francis, \"Characterization
      and\n               Measurement of TCP Traversal through NATs and Firewalls\",\n
      \              Proceedings of the 5th ACM SIGCOMM Conference on Internet\n               Measurement,
      2005.\n   [NAT-PMP]   Cheshire, S., Krochmal, M., and K. Sekar, \"NAT Port\n
      \              Mapping Protocol (NAT-PMP)\", Work in Progress,\n               April
      2008.\n   [PCP-BASE]  Wing, D., Cheshire, S., Boucadair, M., Penno, R., and
      P.\n               Selkirk, \"Port Control Protocol (PCP)\", Work in Progress,\n
      \              March 2012.\n   [RFC1928]   Leech, M., Ganis, M., Lee, Y., Kuris,
      R., Koblas, D., and\n               L. Jones, \"SOCKS Protocol Version 5\",
      RFC 1928,\n               March 1996.\n   [RFC3089]   Kitamura, H., \"A SOCKS-based
      IPv6/IPv4 Gateway\n               Mechanism\", RFC 3089, April 2001.\n   [RFC3103]
      \  Borella, M., Grabelsky, D., Lo, J., and K. Taniguchi,\n               \"Realm
      Specific IP: Protocol Specification\", RFC 3103,\n               October 2001.\n
      \  [RFC4251]   Ylonen, T. and C. Lonvick, \"The Secure Shell (SSH)\n               Protocol
      Architecture\", RFC 4251, January 2006.\n   [RFC4380]   Huitema, C., \"Teredo:
      Tunneling IPv6 over UDP through\n               Network Address Translations
      (NATs)\", RFC 4380,\n               February 2006.\n   [RFC4540]   Stiemerling,
      M., Quittek, J., and C. Cadar, \"NEC's Simple\n               Middlebox Configuration
      (SIMCO) Protocol Version 3.0\",\n               RFC 4540, May 2006.\n   [RFC4975]
      \  Campbell, B., Mahy, R., and C. Jennings, \"The Message\n               Session
      Relay Protocol (MSRP)\", RFC 4975, September 2007.\n   [RFC5190]   Quittek,
      J., Stiemerling, M., and P. Srisuresh,\n               \"Definitions of Managed
      Objects for Middlebox\n               Communication\", RFC 5190, March 2008.\n
      \  [RFC5382]   Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P.\n               Srisuresh,
      \"NAT Behavioral Requirements for TCP\",\n               BCP 142, RFC 5382,
      October 2008.\n   [RFC6062]   Perreault, S. and J. Rosenberg, \"Traversal Using
      Relays\n               around NAT (TURN) Extensions for TCP Allocations\",\n
      \              RFC 6062, November 2010.\n   [RFC6081]   Thaler, D., \"Teredo
      Extensions\", RFC 6081, January 2011.\n   [RFC6156]   Camarillo, G., Novo, O.,
      and S. Perreault, \"Traversal\n               Using Relays around NAT (TURN)
      Extension for IPv6\",\n               RFC 6156, April 2011.\n   [UPnP-IGD]  Warrier,
      U., Iyer, P., Pennerath, F., Marynissen, G.,\n               Schmitz, M., Siddiqi,
      W., and M. Blaszczak, \"Internet\n               Gateway Device (IGD) Standardized
      Device Control Protocol\n               V 1.0\", November 2001.\n"
    title: 15.2.  Informative References
  title: 15.  References
- contents:
  - "Appendix A.  Limitations of ICE TCP\n   Compared to UDP-based ICE, ICE TCP has,
    in general, lower success\n   probability for enabling connectivity without a
    relay if both of the\n   hosts are behind a NAT.  This happens because many of
    the currently\n   deployed NATs have endpoint-dependent mapping behavior, or they
    do\n   not support the flow of TCP handshake packets seen in the case of TCP\n
    \  simultaneous-open, e.g., some NATs do not allow incoming TCP SYN\n   packets
    from an address where a SYN packet has been sent to recently\n   or the subsequent
    SYN-ACK is not processed properly.\n   It has been reported in [IMC05] that with
    the population of NATs\n   deployed at the time of the measurements (2005), one
    of the NAT\n   traversal techniques described here, TCP simultaneous-open, worked
    in\n   roughly 45% of the cases.  Also, not all operating systems implement\n
    \  TCP simultaneous-open properly and thus are not able to use such\n   candidates.
    \ However, when more NATs comply with the requirements set\n   by [RFC5382] and
    operating system TCP stacks are fixed, the success\n   probability of simultaneous-open
    is likely to increase.  Also, it is\n   important to implement additional techniques
    with higher success\n   ratios, such as Teredo, whose success in different scenarios
    is\n   described in Figure 1 of [RFC6081].\n   Finally, it should be noted that
    implementing various techniques\n   listed in Section 5 should increase the success
    probability, but many\n   of these techniques require support from the endpoints
    and/or from\n   some network elements (e.g., from the NATs).  Without comprehensive\n
    \  experimental data on how well different techniques are supported, the\n   actual
    increase of success probability is hard to evaluate.\n"
  title: Appendix A.  Limitations of ICE TCP
- contents:
  - "Appendix B.  Implementation Considerations for BSD Sockets\n   This specification
    requires unusual handling of TCP connections, the\n   implementation of which
    is non-trivial in traditional BSD socket\n   APIs.\n   In particular, ICE requires
    an agent to obtain a local TCP candidate,\n   bound to a local IP and port, then
    initiate a TCP connection from\n   that local port (e.g., to the STUN server in
    order to obtain server\n   reflexive candidates, to the TURN server to obtain
    a relayed\n   candidate, or to the peer as part of a connectivity check), and
    be\n   prepared to receive incoming TCP connections (for passive and\n   simultaneous-open
    candidates).  A \"typical\" BSD socket is used either\n   for initiating or receiving
    connections, and not for both.  The code\n   required to allow incoming and outgoing
    connections on the same local\n   IP and port is non-obvious.  The following pseudocode,
    contributed by\n   Saikat Guha, has been found to work on many platforms:\n   for
    i in 0 to MAX\n      sock_i = socket()\n      set(sock_i, SO_REUSEADDR)\n      bind(sock_i,
    local)\n   listen(sock_0)\n   connect(sock_1, stun)\n   connect(sock_2, remote_a)\n
    \  connect(sock_3, remote_b)\n   The key here is that, prior to the listen() call,
    the full set of\n   sockets that need to be utilized for outgoing connections
    must be\n   allocated and bound to the local IP address and port.  This number,\n
    \  MAX, represents the maximum number of TCP connections to different\n   destinations
    that might need to be established from the same local\n   candidate.  This number
    can be potentially large for simultaneous-\n   open candidates.  If a request
    forks, ICE procedures may take place\n   with multiple peers.  Furthermore, for
    each peer, connections would\n   need to be established to each passive or simultaneous-open
    candidate\n   for the same component.  If we assume a worst case of 5 forked\n
    \  branches, and for each peer, five simultaneous-open candidates, that\n   results
    in MAX=25.\n"
  title: Appendix B.  Implementation Considerations for BSD Sockets
- contents:
  - "Appendix C.  SDP Examples\n  This section shows two examples of SDP offer and
    answer when the ICE\n  TCP extension is used.  Both examples are based on the
    simplified\n  topology of Figure 8 in [RFC5245], with the same IP addresses.  The\n
    \ examples shown here should be considered strictly informative.\n  In the first
    example, the offer contains only TCP candidates (lines\n  are folded in examples
    to satisfy RFC formatting rules):\n  v=0\n  o=jdoe 2890844526 2890842807 IN IP4
    10.0.1.1\n  s=\n  c=IN IP4 192.0.2.3\n  t=0 0\n  a=ice-pwd:asd88fgpdd777uzjYhagZg\n
    \ a=ice-ufrag:8hhY\n  m=audio 45664 TCP/RTP/AVP 0\n  b=RS:0\n  b=RR:0\n  a=rtpmap:0
    PCMU/8000\n  a=setup:active\n  a=connection:new\n  a=candidate:1 1 TCP 2128609279
    10.0.1.1 9 typ host tcptype active\n  a=candidate:2 1 TCP 2124414975 10.0.1.1
    8998 typ host tcptype passive\n  a=candidate:3 1 TCP 2120220671 10.0.1.1 8999
    typ host tcptype so\n  a=candidate:4 1 TCP 1688207359 192.0.2.3 9 typ srflx raddr
    10.0.1.1\n    rport 9 tcptype active\n  a=candidate:5 1 TCP 1684013055 192.0.2.3
    45664 typ srflx raddr\n    10.0.1.1 rport 8998 tcptype passive\n  a=candidate:6
    1 TCP 1692401663 192.0.2.3 45687 typ srflx raddr\n    10.0.1.1 rport 8999 tcptype
    so\n  The answer to that offer could look like this:\n  v=0\n  o=bob 2808844564
    2808844564 IN IP4 192.0.2.1\n  s=\n  c=IN IP4 192.0.2.1\n  t=0 0\n  a=ice-pwd:YH75Fviy6338Vbrhrlp8Yh\n
    \ a=ice-ufrag:9uB6\n  m=audio 3478 TCP/RTP/AVP 0\n  b=RS:0\n  b=RR:0\n  a=setup:passive\n
    \ a=connection:new\n  a=rtpmap:0 PCMU/8000\n  a=candidate:1 1 TCP 2128609279 192.0.2.1
    9 typ host tcptype active\n  a=candidate:2 1 TCP 2124414975 192.0.2.1 3478 typ
    host tcptype passive\n  a=candidate:3 1 TCP 2120220671 192.0.2.1 3482 typ host
    tcptype so\n  In the second example, UDP and TCP media streams are mixed, but
    S-O\n  candidates are omitted due to hosts not supporting TCP simultaneous-\n
    \ open, and UDP candidates are preferred (but preference order for\n  candidate
    types is kept the same) by decreasing the TCP candidate type\n  preferences by
    one (i.e., using type preference 125 for the host\n  candidates and 99 for the
    server reflexive candidates):\n  v=0\n  o=jdoe 2890844526 2890842807 IN IP4 10.0.1.1\n
    \ s=\n  c=IN IP4 192.0.2.3\n  t=0 0\n  a=ice-pwd:asd88fgpdd777uzjYhagZg\n  a=ice-ufrag:8hhY\n
    \ m=audio 45664 RTP/AVP 0\n  b=RS:0\n  b=RR:0\n  a=rtpmap:0 PCMU/8000\n  a=candidate:1
    1 TCP 2111832063 10.0.1.1 9 typ host tcptype active\n  a=candidate:2 1 TCP 2107637759
    10.0.1.1 9012 typ host tcptype passive\n  a=candidate:3 1 TCP 1671430143 192.0.2.3
    9 typ srflx raddr 10.0.1.1\n    rport 9 tcptype active\n  a=candidate:4 1 TCP
    1667235839 192.0.2.3 44642 typ srflx raddr\n    10.0.1.1 rport 9012 tcptype passive\n
    \ a=candidate:5 1 UDP 2130706431 10.0.1.1 8998 typ host\n  a=candidate:6 1 UDP
    1694498815 192.0.2.3 45664 typ srflx raddr\n    10.0.1.1 rport 8998\n  The corresponding
    answer could look like this:\n  v=0\n  o=bob 2808844564 2808844564 IN IP4 192.0.2.1\n
    \ s=\n  c=IN IP4 192.0.2.1\n  t=0 0\n  a=ice-pwd:YH75Fviy6338Vbrhrlp8Yh\n  a=ice-ufrag:9uB6\n
    \ m=audio 3478 RTP/AVP 0\n  b=RS:0\n  b=RR:0\n  a=rtpmap:0 PCMU/8000\n  a=candidate:1
    1 TCP 2111832063 192.0.2.1 9 typ host tcptype active\n  a=candidate:2 1 TCP 2107637759
    192.0.2.1 3478 typ host tcptype passive\n  a=candidate:3 1 UDP 2130706431 192.0.2.1
    3478 typ host\n"
  title: Appendix C.  SDP Examples
- contents:
  - "Authors' Addresses\n   Jonathan Rosenberg\n   jdrosen.net\n   EMail: jdrosen@jdrosen.net\n
    \  URI:   http://www.jdrosen.net\n   Ari Keranen\n   Ericsson\n   Hirsalantie
    11\n   02420 Jorvas\n   Finland\n   EMail: ari.keranen@ericsson.com\n   Bruce
    B. Lowekamp\n   Skype\n   EMail: bbl@lowekamp.net\n   Adam Roach\n   Tekelec\n
    \  17210 Campbell Rd., Suite 250\n   Dallas, TX 75252\n   US\n   EMail: adam@nostrum.com\n"
  title: Authors' Addresses
