- contents:
  - '    Transport Layer Security (TLS) Extensions: Extension Definitions

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document provides specifications for existing TLS extensions.\n
    \  It is a companion document for RFC 5246, \"The Transport Layer\n   Security
    (TLS) Protocol Version 1.2\".  The extensions specified are\n   server_name, max_fragment_length,
    client_certificate_url,\n   trusted_ca_keys, truncated_hmac, and status_request.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6066.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \     1.1. Specific Extensions Covered ................................3\n      1.2.
    Conventions Used in This Document ..........................5\n   2. Extensions
    to the Handshake Protocol ............................5\n   3. Server Name Indication
    ..........................................6\n   4. Maximum Fragment Length Negotiation
    .............................8\n   5. Client Certificate URLs .........................................9\n
    \  6. Trusted CA Indication ..........................................12\n   7.
    Truncated HMAC .................................................13\n   8. Certificate
    Status Request .....................................14\n   9. Error Alerts ...................................................16\n
    \  10. IANA Considerations ...........................................17\n      10.1.
    pkipath MIME Type Registration ...........................17\n      10.2. Reference
    for TLS Alerts, TLS HandshakeTypes, and\n            ExtensionTypes ...........................................19\n
    \  11. Security Considerations .......................................19\n      11.1.
    Security Considerations for server_name ..................19\n      11.2. Security
    Considerations for max_fragment_length ..........20\n      11.3. Security Considerations
    for client_certificate_url .......20\n      11.4. Security Considerations for
    trusted_ca_keys ..............21\n      11.5. Security Considerations for truncated_hmac
    ...............21\n      11.6. Security Considerations for status_request ...............22\n
    \  12. Normative References ..........................................22\n   13.
    Informative References ........................................23\n   Appendix
    A. Changes from RFC 4366 .................................24\n   Appendix B. Acknowledgements
    ......................................25\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The Transport Layer Security (TLS) Protocol Version 1.2
    is specified\n   in [RFC5246].  That specification includes the framework for\n
    \  extensions to TLS, considerations in designing such extensions (see\n   Section
    7.4.1.4 of [RFC5246]), and IANA Considerations for the\n   allocation of new extension
    code points; however, it does not specify\n   any particular extensions other
    than Signature Algorithms (see\n   Section 7.4.1.4.1 of [RFC5246]).\n   This document
    provides the specifications for existing TLS\n   extensions.  It is, for the most
    part, the adaptation and editing of\n   material from RFC 4366, which covered
    TLS extensions for TLS 1.0 (RFC\n   2246) and TLS 1.1 (RFC 4346).\n"
  - contents:
    - "1.1.  Specific Extensions Covered\n   The extensions described here focus on
      extending the functionality\n   provided by the TLS protocol message formats.
      \ Other issues, such as\n   the addition of new cipher suites, are deferred.\n
      \  The extension types defined in this document are:\n      enum {\n          server_name(0),
      max_fragment_length(1),\n          client_certificate_url(2), trusted_ca_keys(3),\n
      \         truncated_hmac(4), status_request(5), (65535)\n      } ExtensionType;\n
      \  Specifically, the extensions described in this document:\n   -  Allow TLS
      clients to provide to the TLS server the name of the\n      server they are
      contacting.  This functionality is desirable in\n      order to facilitate secure
      connections to servers that host\n      multiple 'virtual' servers at a single
      underlying network address.\n   -  Allow TLS clients and servers to negotiate
      the maximum fragment\n      length to be sent.  This functionality is desirable
      as a result of\n      memory constraints among some clients, and bandwidth constraints\n
      \     among some access networks.\n   -  Allow TLS clients and servers to negotiate
      the use of client\n      certificate URLs.  This functionality is desirable
      in order to\n      conserve memory on constrained clients.\n   -  Allow TLS
      clients to indicate to TLS servers which certification\n      authority (CA)
      root keys they possess.  This functionality is\n      desirable in order to
      prevent multiple handshake failures\n      involving TLS clients that are only
      able to store a small number\n      of CA root keys due to memory limitations.\n
      \  -  Allow TLS clients and servers to negotiate the use of truncated\n      Message
      Authentication Codes (MACs).  This functionality is\n      desirable in order
      to conserve bandwidth in constrained access\n      networks.\n   -  Allow TLS
      clients and servers to negotiate that the server sends\n      the client certificate
      status information (e.g., an Online\n      Certificate Status Protocol (OCSP)
      [RFC2560] response) during a\n      TLS handshake.  This functionality is desirable
      in order to avoid\n      sending a Certificate Revocation List (CRL) over a
      constrained\n      access network and therefore saving bandwidth.\n   TLS clients
      and servers may use the extensions described in this\n   document.  The extensions
      are designed to be backwards compatible,\n   meaning that TLS clients that support
      the extensions can talk to TLS\n   servers that do not support the extensions,
      and vice versa.\n   Note that any messages associated with these extensions
      that are sent\n   during the TLS handshake MUST be included in the hash calculations\n
      \  involved in \"Finished\" messages.\n   Note also that all the extensions
      defined in this document are\n   relevant only when a session is initiated.
      \ A client that requests\n   session resumption does not in general know whether
      the server will\n   accept this request, and therefore it SHOULD send the same
      extensions\n   as it would send if it were not attempting resumption.  When
      a client\n   includes one or more of the defined extension types in an extended\n
      \  client hello while requesting session resumption:\n   -  The server name
      indication extension MAY be used by the server\n      when deciding whether
      or not to resume a session as described in\n      Section 3.\n   -  If the resumption
      request is denied, the use of the extensions is\n      negotiated as normal.\n
      \  -  If, on the other hand, the older session is resumed, then the\n      server
      MUST ignore the extensions and send a server hello\n      containing none of
      the extension types.  In this case, the\n      functionality of these extensions
      negotiated during the original\n      session initiation is applied to the resumed
      session.\n"
    title: 1.1.  Specific Extensions Covered
  - contents:
    - "1.2.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST
      NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\",
      \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this
      document are to be interpreted as described in\n   [RFC2119].\n"
    title: 1.2.  Conventions Used in This Document
  title: 1.  Introduction
- contents:
  - "2.  Extensions to the Handshake Protocol\n   This document specifies the use
    of two new handshake messages,\n   \"CertificateURL\" and \"CertificateStatus\".
    \ These messages are\n   described in Sections 5 and 8, respectively.  The new
    handshake\n   message structure therefore becomes:\n   enum {\n       hello_request(0),
    client_hello(1), server_hello(2),\n       certificate(11), server_key_exchange
    (12),\n       certificate_request(13), server_hello_done(14),\n       certificate_verify(15),
    client_key_exchange(16),\n       finished(20), certificate_url(21), certificate_status(22),\n
    \      (255)\n   } HandshakeType;\n   struct {\n       HandshakeType msg_type;
    \   /* handshake type */\n       uint24 length;             /* bytes in message
    */\n       select (HandshakeType) {\n           case hello_request:       HelloRequest;\n
    \          case client_hello:        ClientHello;\n           case server_hello:
    \       ServerHello;\n           case certificate:         Certificate;\n           case
    server_key_exchange: ServerKeyExchange;\n           case certificate_request:
    CertificateRequest;\n           case server_hello_done:   ServerHelloDone;\n           case
    certificate_verify:  CertificateVerify;\n           case client_key_exchange:
    ClientKeyExchange;\n           case finished:            Finished;\n           case
    certificate_url:     CertificateURL;\n           case certificate_status:  CertificateStatus;\n
    \      } body;\n   } Handshake;\n"
  title: 2.  Extensions to the Handshake Protocol
- contents:
  - "3.  Server Name Indication\n   TLS does not provide a mechanism for a client
    to tell a server the\n   name of the server it is contacting.  It may be desirable
    for clients\n   to provide this information to facilitate secure connections to\n
    \  servers that host multiple 'virtual' servers at a single underlying\n   network
    address.\n   In order to provide any of the server names, clients MAY include
    an\n   extension of type \"server_name\" in the (extended) client hello.  The\n
    \  \"extension_data\" field of this extension SHALL contain\n   \"ServerNameList\"
    where:\n      struct {\n          NameType name_type;\n          select (name_type)
    {\n              case host_name: HostName;\n          } name;\n      } ServerName;\n
    \     enum {\n          host_name(0), (255)\n      } NameType;\n      opaque HostName<1..2^16-1>;\n
    \     struct {\n          ServerName server_name_list<1..2^16-1>\n      } ServerNameList;\n
    \  The ServerNameList MUST NOT contain more than one name of the same\n   name_type.
    \ If the server understood the ClientHello extension but\n   does not recognize
    the server name, the server SHOULD take one of two\n   actions: either abort the
    handshake by sending a fatal-level\n   unrecognized_name(112) alert or continue
    the handshake.  It is NOT\n   RECOMMENDED to send a warning-level unrecognized_name(112)
    alert,\n   because the client's behavior in response to warning-level alerts is\n
    \  unpredictable.  If there is a mismatch between the server name used\n   by
    the client application and the server name of the credential\n   chosen by the
    server, this mismatch will become apparent when the\n   client application performs
    the server endpoint identification, at\n   which point the client application
    will have to decide whether to\n   proceed with the communication.  TLS implementations
    are encouraged\n   to make information available to application callers about
    warning-\n   level alerts that were received or sent during a TLS handshake.  Such\n
    \  information can be useful for diagnostic purposes.\n      Note: Earlier versions
    of this specification permitted multiple\n      names of the same name_type.  In
    practice, current client\n      implementations only send one name, and the client
    cannot\n      necessarily find out which name the server selected.  Multiple\n
    \     names of the same name_type are therefore now prohibited.\n   Currently,
    the only server names supported are DNS hostnames;\n   however, this does not
    imply any dependency of TLS on DNS, and other\n   name types may be added in the
    future (by an RFC that updates this\n   document).  The data structure associated
    with the host_name NameType\n   is a variable-length vector that begins with a
    16-bit length.  For\n   backward compatibility, all future data structures associated
    with\n   new NameTypes MUST begin with a 16-bit length field.  TLS MAY treat\n
    \  provided server names as opaque data and pass the names and types to\n   the
    application.\n   \"HostName\" contains the fully qualified DNS hostname of the
    server,\n   as understood by the client.  The hostname is represented as a byte\n
    \  string using ASCII encoding without a trailing dot.  This allows the\n   support
    of internationalized domain names through the use of A-labels\n   defined in [RFC5890].
    \ DNS hostnames are case-insensitive.  The\n   algorithm to compare hostnames
    is described in [RFC5890], Section\n   2.3.2.4.\n   Literal IPv4 and IPv6 addresses
    are not permitted in \"HostName\".\n   It is RECOMMENDED that clients include
    an extension of type\n   \"server_name\" in the client hello whenever they locate
    a server by a\n   supported name type.\n   A server that receives a client hello
    containing the \"server_name\"\n   extension MAY use the information contained
    in the extension to guide\n   its selection of an appropriate certificate to return
    to the client,\n   and/or other aspects of security policy.  In this event, the
    server\n   SHALL include an extension of type \"server_name\" in the (extended)\n
    \  server hello.  The \"extension_data\" field of this extension SHALL be\n   empty.\n
    \  When the server is deciding whether or not to accept a request to\n   resume
    a session, the contents of a server_name extension MAY be used\n   in the lookup
    of the session in the session cache.  The client SHOULD\n   include the same server_name
    extension in the session resumption\n   request as it did in the full handshake
    that established the session.\n   A server that implements this extension MUST
    NOT accept the request\n   to resume the session if the server_name extension
    contains a\n   different name.  Instead, it proceeds with a full handshake to\n
    \  establish a new session.  When resuming a session, the server MUST\n   NOT
    include a server_name extension in the server hello.\n   If an application negotiates
    a server name using an application\n   protocol and then upgrades to TLS, and
    if a server_name extension is\n   sent, then the extension SHOULD contain the
    same name that was\n   negotiated in the application protocol.  If the server_name
    is\n   established in the TLS session handshake, the client SHOULD NOT\n   attempt
    to request a different server name at the application layer.\n"
  title: 3.  Server Name Indication
- contents:
  - "4.  Maximum Fragment Length Negotiation\n   Without this extension, TLS specifies
    a fixed maximum plaintext\n   fragment length of 2^14 bytes.  It may be desirable
    for constrained\n   clients to negotiate a smaller maximum fragment length due
    to memory\n   limitations or bandwidth limitations.\n   In order to negotiate
    smaller maximum fragment lengths, clients MAY\n   include an extension of type
    \"max_fragment_length\" in the (extended)\n   client hello.  The \"extension_data\"
    field of this extension SHALL\n   contain:\n      enum{\n          2^9(1), 2^10(2),
    2^11(3), 2^12(4), (255)\n      } MaxFragmentLength;\n   whose value is the desired
    maximum fragment length.  The allowed\n   values for this field are: 2^9, 2^10,
    2^11, and 2^12.\n   Servers that receive an extended client hello containing a\n
    \  \"max_fragment_length\" extension MAY accept the requested maximum\n   fragment
    length by including an extension of type\n   \"max_fragment_length\" in the (extended)
    server hello.  The\n   \"extension_data\" field of this extension SHALL contain
    a\n   \"MaxFragmentLength\" whose value is the same as the requested maximum\n
    \  fragment length.\n   If a server receives a maximum fragment length negotiation
    request\n   for a value other than the allowed values, it MUST abort the\n   handshake
    with an \"illegal_parameter\" alert.  Similarly, if a client\n   receives a maximum
    fragment length negotiation response that differs\n   from the length it requested,
    it MUST also abort the handshake with\n   an \"illegal_parameter\" alert.\n   Once
    a maximum fragment length other than 2^14 has been successfully\n   negotiated,
    the client and server MUST immediately begin fragmenting\n   messages (including
    handshake messages) to ensure that no fragment\n   larger than the negotiated
    length is sent.  Note that TLS already\n   requires clients and servers to support
    fragmentation of handshake\n   messages.\n   The negotiated length applies for
    the duration of the session\n   including session resumptions.\n   The negotiated
    length limits the input that the record layer may\n   process without fragmentation
    (that is, the maximum value of\n   TLSPlaintext.length; see [RFC5246], Section
    6.2.1).  Note that the\n   output of the record layer may be larger.  For example,
    if the\n   negotiated length is 2^9=512, then, when using currently defined\n
    \  cipher suites (those defined in [RFC5246] and [RFC2712]) and null\n   compression,
    the record-layer output can be at most 805 bytes: 5\n   bytes of headers, 512
    bytes of application data, 256 bytes of\n   padding, and 32 bytes of MAC.  This
    means that in this event a TLS\n   record-layer peer receiving a TLS record-layer
    message larger than\n   805 bytes MUST discard the message and send a \"record_overflow\"\n
    \  alert, without decrypting the message.  When this extension is used\n   with
    Datagram Transport Layer Security (DTLS), implementations SHOULD\n   NOT generate
    record_overflow alerts unless the packet passes message\n   authentication.\n"
  title: 4.  Maximum Fragment Length Negotiation
- contents:
  - "5.  Client Certificate URLs\n   Without this extension, TLS specifies that when
    client authentication\n   is performed, client certificates are sent by clients
    to servers\n   during the TLS handshake.  It may be desirable for constrained\n
    \  clients to send certificate URLs in place of certificates, so that\n   they
    do not need to store their certificates and can therefore save\n   memory.\n   In
    order to negotiate sending certificate URLs to a server, clients\n   MAY include
    an extension of type \"client_certificate_url\" in the\n   (extended) client hello.
    \ The \"extension_data\" field of this\n   extension SHALL be empty.\n   (Note
    that it is necessary to negotiate the use of client certificate\n   URLs in order
    to avoid \"breaking\" existing TLS servers.)\n   Servers that receive an extended
    client hello containing a\n   \"client_certificate_url\" extension MAY indicate
    that they are willing\n   to accept certificate URLs by including an extension
    of type\n   \"client_certificate_url\" in the (extended) server hello.  The\n
    \  \"extension_data\" field of this extension SHALL be empty.\n   After negotiation
    of the use of client certificate URLs has been\n   successfully completed (by
    exchanging hellos including\n   \"client_certificate_url\" extensions), clients
    MAY send a\n   \"CertificateURL\" message in place of a \"Certificate\" message
    as\n   follows (see also Section 2):\n      enum {\n          individual_certs(0),
    pkipath(1), (255)\n      } CertChainType;\n      struct {\n          CertChainType
    type;\n          URLAndHash url_and_hash_list<1..2^16-1>;\n      } CertificateURL;\n
    \     struct {\n          opaque url<1..2^16-1>;\n          unint8 padding;\n
    \         opaque SHA1Hash[20];\n      } URLAndHash;\n   Here, \"url_and_hash_list\"
    contains a sequence of URLs and hashes.\n   Each \"url\" MUST be an absolute URI
    reference according to [RFC3986]\n   that can be immediately used to fetch the
    certificate(s).\n   When X.509 certificates are used, there are two possibilities:\n
    \  -  If CertificateURL.type is \"individual_certs\", each URL refers to a\n      single
    DER-encoded X.509v3 certificate, with the URL for the\n      client's certificate
    first.\n   -  If CertificateURL.type is \"pkipath\", the list contains a single\n
    \     URL referring to a DER-encoded certificate chain, using the type\n      PkiPath
    described in Section 10.1.\n   When any other certificate format is used, the
    specification that\n   describes use of that format in TLS should define the encoding
    format\n   of certificates or certificate chains, and any constraint on their\n
    \  ordering.\n   The \"padding\" byte MUST be 0x01.  It is present to make the
    structure\n   backwards compatible.\n   The hash corresponding to each URL is
    the SHA-1 hash of the\n   certificate or certificate chain (in the case of X.509
    certificates,\n   the DER-encoded certificate or the DER-encoded PkiPath).\n   Note
    that when a list of URLs for X.509 certificates is used, the\n   ordering of URLs
    is the same as that used in the TLS Certificate\n   message (see [RFC5246], Section
    7.4.2), but opposite to the order in\n   which certificates are encoded in PkiPath.
    \ In either case, the self-\n   signed root certificate MAY be omitted from the
    chain, under the\n   assumption that the server must already possess it in order
    to\n   validate it.\n   Servers receiving \"CertificateURL\" SHALL attempt to
    retrieve the\n   client's certificate chain from the URLs and then process the\n
    \  certificate chain as usual.  A cached copy of the content of any URL\n   in
    the chain MAY be used, provided that the SHA-1 hash matches the\n   hash of the
    cached copy.\n   Servers that support this extension MUST support the 'http' URI\n
    \  scheme for certificate URLs and MAY support other schemes.  Use of\n   other
    schemes than 'http', 'https', or 'ftp' may create unexpected\n   problems.\n   If
    the protocol used is HTTP, then the HTTP server can be configured\n   to use the
    Cache-Control and Expires directives described in\n   [RFC2616] to specify whether
    and for how long certificates or\n   certificate chains should be cached.\n   The
    TLS server MUST NOT follow HTTP redirects when retrieving the\n   certificates
    or certificate chain.  The URLs used in this extension\n   MUST NOT be chosen
    to depend on such redirects.\n   If the protocol used to retrieve certificates
    or certificate chains\n   returns a MIME-formatted response (as HTTP does), then
    the following\n   MIME Content-Types SHALL be used: when a single X.509v3 certificate\n
    \  is returned, the Content-Type is \"application/pkix-cert\" [RFC2585],\n   and
    when a chain of X.509v3 certificates is returned, the Content-\n   Type is \"application/pkix-pkipath\"
    (Section 10.1).\n   The server MUST check that the SHA-1 hash of the contents
    of the\n   object retrieved from that URL (after decoding any MIME Content-\n
    \  Transfer-Encoding) matches the given hash.  If any retrieved object\n   does
    not have the correct SHA-1 hash, the server MUST abort the\n   handshake with
    a bad_certificate_hash_value(114) alert.  This alert\n   is always fatal.\n   Clients
    may choose to send either \"Certificate\" or \"CertificateURL\"\n   after successfully
    negotiating the option to send certificate URLs.\n   The option to send a certificate
    is included to provide flexibility\n   to clients possessing multiple certificates.\n
    \  If a server is unable to obtain certificates in a given\n   CertificateURL,
    it MUST send a fatal certificate_unobtainable(111)\n   alert if it requires the
    certificates to complete the handshake.  If\n   the server does not require the
    certificates, then the server\n   continues the handshake.  The server MAY send
    a warning-level alert\n   in this case.  Clients receiving such an alert SHOULD
    log the alert\n   and continue with the handshake if possible.\n"
  title: 5.  Client Certificate URLs
- contents:
  - "6.  Trusted CA Indication\n   Constrained clients that, due to memory limitations,
    possess only a\n   small number of CA root keys may wish to indicate to servers
    which\n   root keys they possess, in order to avoid repeated handshake\n   failures.\n
    \  In order to indicate which CA root keys they possess, clients MAY\n   include
    an extension of type \"trusted_ca_keys\" in the (extended)\n   client hello.  The
    \"extension_data\" field of this extension SHALL\n   contain \"TrustedAuthorities\"
    where:\n      struct {\n          TrustedAuthority trusted_authorities_list<0..2^16-1>;\n
    \     } TrustedAuthorities;\n      struct {\n          IdentifierType identifier_type;\n
    \         select (identifier_type) {\n              case pre_agreed: struct {};\n
    \             case key_sha1_hash: SHA1Hash;\n              case x509_name: DistinguishedName;\n
    \             case cert_sha1_hash: SHA1Hash;\n          } identifier;\n      }
    TrustedAuthority;\n      enum {\n          pre_agreed(0), key_sha1_hash(1), x509_name(2),\n
    \         cert_sha1_hash(3), (255)\n      } IdentifierType;\n      opaque DistinguishedName<1..2^16-1>;\n
    \  Here, \"TrustedAuthorities\" provides a list of CA root key identifiers\n   that
    the client possesses.  Each CA root key is identified via\n   either:\n   -  \"pre_agreed\":
    no CA root key identity supplied.\n   -  \"key_sha1_hash\": contains the SHA-1
    hash of the CA root key.  For\n      Digital Signature Algorithm (DSA) and Elliptic
    Curve Digital\n      Signature Algorithm (ECDSA) keys, this is the hash of the\n
    \     \"subjectPublicKey\" value.  For RSA keys, the hash is of the big-\n      endian
    byte string representation of the modulus without any\n      initial zero-valued
    bytes.  (This copies the key hash formats\n      deployed in other environments.)\n
    \  -  \"x509_name\": contains the DER-encoded X.509 DistinguishedName of\n      the
    CA.\n   -  \"cert_sha1_hash\": contains the SHA-1 hash of a DER-encoded\n      Certificate
    containing the CA root key.\n   Note that clients may include none, some, or all
    of the CA root keys\n   they possess in this extension.\n   Note also that it
    is possible that a key hash or a Distinguished Name\n   alone may not uniquely
    identify a certificate issuer (for example, if\n   a particular CA has multiple
    key pairs).  However, here we assume\n   this is the case following the use of
    Distinguished Names to identify\n   certificate issuers in TLS.\n   The option
    to include no CA root keys is included to allow the client\n   to indicate possession
    of some pre-defined set of CA root keys.\n   Servers that receive a client hello
    containing the \"trusted_ca_keys\"\n   extension MAY use the information contained
    in the extension to guide\n   their selection of an appropriate certificate chain
    to return to the\n   client.  In this event, the server SHALL include an extension
    of type\n   \"trusted_ca_keys\" in the (extended) server hello.  The\n   \"extension_data\"
    field of this extension SHALL be empty.\n"
  title: 6.  Trusted CA Indication
- contents:
  - "7.  Truncated HMAC\n   Currently defined TLS cipher suites use the MAC construction
    HMAC\n   [RFC2104] to authenticate record-layer communications.  In TLS, the\n
    \  entire output of the hash function is used as the MAC tag.  However,\n   it
    may be desirable in constrained environments to save bandwidth by\n   truncating
    the output of the hash function to 80 bits when forming\n   MAC tags.\n   In order
    to negotiate the use of 80-bit truncated HMAC, clients MAY\n   include an extension
    of type \"truncated_hmac\" in the extended client\n   hello.  The \"extension_data\"
    field of this extension SHALL be empty.\n   Servers that receive an extended hello
    containing a \"truncated_hmac\"\n   extension MAY agree to use a truncated HMAC
    by including an extension\n   of type \"truncated_hmac\", with empty \"extension_data\",
    in the\n   extended server hello.\n   Note that if new cipher suites are added
    that do not use HMAC, and\n   the session negotiates one of these cipher suites,
    this extension\n   will have no effect.  It is strongly recommended that any new
    cipher\n   suites using other MACs consider the MAC size an integral part of the\n
    \  cipher suite definition, taking into account both security and\n   bandwidth
    considerations.\n   If HMAC truncation has been successfully negotiated during
    a TLS\n   handshake, and the negotiated cipher suite uses HMAC, both the client\n
    \  and the server pass this fact to the TLS record layer along with the\n   other
    negotiated security parameters.  Subsequently during the\n   session, clients
    and servers MUST use truncated HMACs, calculated as\n   specified in [RFC2104].
    \ That is, SecurityParameters.mac_length is 10\n   bytes, and only the first 10
    bytes of the HMAC output are transmitted\n   and checked.  Note that this extension
    does not affect the\n   calculation of the pseudo-random function (PRF) as part
    of\n   handshaking or key derivation.\n   The negotiated HMAC truncation size
    applies for the duration of the\n   session including session resumptions.\n"
  title: 7.  Truncated HMAC
- contents:
  - "8.  Certificate Status Request\n   Constrained clients may wish to use a certificate-status
    protocol\n   such as OCSP [RFC2560] to check the validity of server certificates,\n
    \  in order to avoid transmission of CRLs and therefore save bandwidth\n   on
    constrained networks.  This extension allows for such information\n   to be sent
    in the TLS handshake, saving roundtrips and resources.\n   In order to indicate
    their desire to receive certificate status\n   information, clients MAY include
    an extension of type\n   \"status_request\" in the (extended) client hello.  The\n
    \  \"extension_data\" field of this extension SHALL contain\n   \"CertificateStatusRequest\"
    where:\n      struct {\n          CertificateStatusType status_type;\n          select
    (status_type) {\n              case ocsp: OCSPStatusRequest;\n          } request;\n
    \     } CertificateStatusRequest;\n      enum { ocsp(1), (255) } CertificateStatusType;\n
    \     struct {\n          ResponderID responder_id_list<0..2^16-1>;\n          Extensions
    \ request_extensions;\n      } OCSPStatusRequest;\n      opaque ResponderID<1..2^16-1>;\n
    \     opaque Extensions<0..2^16-1>;\n   In the OCSPStatusRequest, the \"ResponderIDs\"
    provides a list of OCSP\n   responders that the client trusts.  A zero-length
    \"responder_id_list\"\n   sequence has the special meaning that the responders
    are implicitly\n   known to the server, e.g., by prior arrangement.  \"Extensions\"
    is a\n   DER encoding of OCSP request extensions.\n   Both \"ResponderID\" and
    \"Extensions\" are DER-encoded ASN.1 types as\n   defined in [RFC2560].  \"Extensions\"
    is imported from [RFC5280].  A\n   zero-length \"request_extensions\" value means
    that there are no\n   extensions (as opposed to a zero-length ASN.1 SEQUENCE,
    which is not\n   valid for the \"Extensions\" type).\n   In the case of the \"id-pkix-ocsp-nonce\"
    OCSP extension, [RFC2560] is\n   unclear about its encoding; for clarification,
    the nonce MUST be a\n   DER-encoded OCTET STRING, which is encapsulated as another
    OCTET\n   STRING (note that implementations based on an existing OCSP client\n
    \  will need to be checked for conformance to this requirement).\n   Servers that
    receive a client hello containing the \"status_request\"\n   extension MAY return
    a suitable certificate status response to the\n   client along with their certificate.
    \ If OCSP is requested, they\n   SHOULD use the information contained in the extension
    when selecting\n   an OCSP responder and SHOULD include request_extensions in
    the OCSP\n   request.\n   Servers return a certificate response along with their
    certificate by\n   sending a \"CertificateStatus\" message immediately after the\n
    \  \"Certificate\" message (and before any \"ServerKeyExchange\" or\n   \"CertificateRequest\"
    messages).  If a server returns a\n   \"CertificateStatus\" message, then the
    server MUST have included an\n   extension of type \"status_request\" with empty
    \"extension_data\" in the\n   extended server hello.  The \"CertificateStatus\"
    message is conveyed\n   using the handshake message type \"certificate_status\"
    as follows (see\n   also Section 2):\n      struct {\n          CertificateStatusType
    status_type;\n          select (status_type) {\n              case ocsp: OCSPResponse;\n
    \         } response;\n      } CertificateStatus;\n      opaque OCSPResponse<1..2^24-1>;\n
    \  An \"ocsp_response\" contains a complete, DER-encoded OCSP response\n   (using
    the ASN.1 type OCSPResponse defined in [RFC2560]).  Only one\n   OCSP response
    may be sent.\n   Note that a server MAY also choose not to send a \"CertificateStatus\"\n
    \  message, even if has received a \"status_request\" extension in the\n   client
    hello message and has sent a \"status_request\" extension in the\n   server hello
    message.\n   Note in addition that a server MUST NOT send the \"CertificateStatus\"\n
    \  message unless it received a \"status_request\" extension in the client\n   hello
    message and sent a \"status_request\" extension in the server\n   hello message.\n
    \  Clients requesting an OCSP response and receiving an OCSP response in\n   a
    \"CertificateStatus\" message MUST check the OCSP response and abort\n   the handshake
    if the response is not satisfactory with\n   bad_certificate_status_response(113)
    alert.  This alert is always\n   fatal.\n"
  title: 8.  Certificate Status Request
- contents:
  - "9.  Error Alerts\n   Four new error alerts are defined for use with the TLS extensions\n
    \  defined in this document.  To avoid \"breaking\" existing clients and\n   servers,
    these alerts MUST NOT be sent unless the sending party has\n   received an extended
    hello message from the party they are\n   communicating with.  These error alerts
    are conveyed using the\n   following syntax.  The new alerts are the last four,
    as indicated by\n   the comments on the same line as the error alert number.\n
    \     enum {\n          close_notify(0),\n          unexpected_message(10),\n
    \         bad_record_mac(20),\n          decryption_failed(21),\n          record_overflow(22),\n
    \         decompression_failure(30),\n          handshake_failure(40),\n          /*
    41 is not defined, for historical reasons */\n          bad_certificate(42),\n
    \         unsupported_certificate(43),\n          certificate_revoked(44),\n          certificate_expired(45),\n
    \         certificate_unknown(46),\n          illegal_parameter(47),\n          unknown_ca(48),\n
    \         access_denied(49),\n          decode_error(50),\n          decrypt_error(51),\n
    \         export_restriction(60),\n          protocol_version(70),\n          insufficient_security(71),\n
    \         internal_error(80),\n          user_canceled(90),\n          no_renegotiation(100),\n
    \         unsupported_extension(110),\n          certificate_unobtainable(111),
    \       /* new */\n          unrecognized_name(112),               /* new */\n
    \         bad_certificate_status_response(113), /* new */\n          bad_certificate_hash_value(114),
    \     /* new */\n          (255)\n      } AlertDescription;\n   \"certificate_unobtainable\"
    is described in Section 5.\n   \"unrecognized_name\" is described in Section 3.\n
    \  \"bad_certificate_status_response\" is described in Section 8.\n   \"bad_certificate_hash_value\"
    is described in Section 5.\n"
  title: 9.  Error Alerts
- contents:
  - "10.  IANA Considerations\n   IANA Considerations for TLS extensions and the creation
    of a registry\n   are covered in Section 12 of [RFC5246] except for the registration
    of\n   MIME type application/pkix-pkipath, which appears below.\n   The IANA TLS
    extensions and MIME type application/pkix-pkipath\n   registry entries that reference
    RFC 4366 have been updated to\n   reference this document.\n"
  - contents:
    - "10.1.  pkipath MIME Type Registration\n   MIME media type name: application\n
      \  MIME subtype name: pkix-pkipath\n   Required parameters: none\n   Optional
      parameters: version (default value is \"1\")\n   Encoding considerations:\n
      \     Binary; this MIME type is a DER encoding of the ASN.1 type\n      PkiPath,
      defined as follows:\n        PkiPath ::= SEQUENCE OF Certificate\n        PkiPath
      is used to represent a certification path.  Within the\n        sequence, the
      order of certificates is such that the subject of\n        the first certificate
      is the issuer of the second certificate,\n        etc.\n      This is identical
      to the definition published in [X509-4th-TC1];\n      note that it is different
      from that in [X509-4th].\n      All Certificates MUST conform to [RFC5280].
      \ (This should be\n      interpreted as a requirement to encode only PKIX-conformant\n
      \     certificates using this type.  It does not necessarily require\n      that
      all certificates that are not strictly PKIX-conformant must\n      be rejected
      by relying parties, although the security consequences\n      of accepting any
      such certificates should be considered\n      carefully.)\n      DER (as opposed
      to BER) encoding MUST be used.  If this type is\n      sent over a 7-bit transport,
      base64 encoding SHOULD be used.\n   Security considerations:\n      The security
      considerations of [X509-4th] and [RFC5280] (or any\n      updates to them) apply,
      as well as those of any protocol that uses\n      this type (e.g., TLS).\n      Note
      that this type only specifies a certificate chain that can be\n      assessed
      for validity according to the relying party's existing\n      configuration
      of trusted CAs; it is not intended to be used to\n      specify any change to
      that configuration.\n   Interoperability considerations:\n      No specific
      interoperability problems are known with this type,\n      but for recommendations
      relating to X.509 certificates in general,\n      see [RFC5280].\n   Published
      specification: This document and [RFC5280].\n   Applications that use this media
      type:\n      TLS.  It may also be used by other protocols or for general\n      interchange
      of PKIX certificate chains.\n   Additional information:\n      Magic number(s):
      DER-encoded ASN.1 can be easily recognized.\n        Further parsing is required
      to distinguish it from other ASN.1\n        types.\n      File extension(s):
      .pkipath\n      Macintosh File Type Code(s): not specified\n   Person & email
      address to contact for further information:\n      Magnus Nystrom <mnystrom@microsoft.com>\n
      \  Intended usage: COMMON\n   Change controller: IESG <iesg@ietf.org>\n"
    title: 10.1.  pkipath MIME Type Registration
  - contents:
    - "10.2.  Reference for TLS Alerts, TLS HandshakeTypes, and ExtensionTypes\n   The
      following values in the TLS Alert Registry have been updated to\n   reference
      this document:\n      111 certificate_unobtainable\n      112 unrecognized_name\n
      \     113 bad_certificate_status_response\n      114 bad_certificate_hash_value\n
      \  The following values in the TLS HandshakeType Registry have been\n   updated
      to reference this document:\n      21 certificate_url\n      22 certificate_status\n
      \  The following ExtensionType values have been updated to reference\n   this
      document:\n      0 server_name\n      1 max_fragment_length\n      2 client_certificate_url\n
      \     3 trusted_ca_keys\n      4 truncated_hmac\n      5 status_request\n"
    title: 10.2.  Reference for TLS Alerts, TLS HandshakeTypes, and ExtensionTypes
  title: 10.  IANA Considerations
- contents:
  - "11.  Security Considerations\n   General security considerations for TLS extensions
    are covered in\n   [RFC5246].  Security Considerations for particular extensions\n
    \  specified in this document are given below.\n   In general, implementers should
    continue to monitor the state of the\n   art and address any weaknesses identified.\n"
  - contents:
    - "11.1.  Security Considerations for server_name\n   If a single server hosts
      several domains, then clearly it is\n   necessary for the owners of each domain
      to ensure that this satisfies\n   their security needs.  Apart from this, server_name
      does not appear\n   to introduce significant security issues.\n   Since it is
      possible for a client to present a different server_name\n   in the application
      protocol, application server implementations that\n   rely upon these names
      being the same MUST check to make sure the\n   client did not present a different
      name in the application protocol.\n   Implementations MUST ensure that a buffer
      overflow does not occur,\n   whatever the values of the length fields in server_name.\n"
    title: 11.1.  Security Considerations for server_name
  - contents:
    - "11.2.  Security Considerations for max_fragment_length\n   The maximum fragment
      length takes effect immediately, including for\n   handshake messages.  However,
      that does not introduce any security\n   complications that are not already
      present in TLS, since TLS requires\n   implementations to be able to handle
      fragmented handshake messages.\n   Note that, as described in Section 4, once
      a non-null cipher suite\n   has been activated, the effective maximum fragment
      length depends on\n   the cipher suite and compression method, as well as on
      the negotiated\n   max_fragment_length.  This must be taken into account when
      sizing\n   buffers and checking for buffer overflow.\n"
    title: 11.2.  Security Considerations for max_fragment_length
  - contents:
    - "11.3.  Security Considerations for client_certificate_url\n   Support for client_certificate_url
      involves the server's acting as a\n   client in another URI-scheme-dependent
      protocol.  The server\n   therefore becomes subject to many of the same security
      concerns that\n   clients of the URI scheme are subject to, with the added concern
      that\n   the client can attempt to prompt the server to connect to some\n   (possibly
      weird-looking) URL.\n   In general, this issue means that an attacker might
      use the server to\n   indirectly attack another host that is vulnerable to some
      security\n   flaw.  It also introduces the possibility of denial-of-service\n
      \  attacks in which an attacker makes many connections to the server,\n   each
      of which results in the server's attempting a connection to the\n   target of
      the attack.\n   Note that the server may be behind a firewall or otherwise able
      to\n   access hosts that would not be directly accessible from the public\n
      \  Internet.  This could exacerbate the potential security and denial-\n   of-service
      problems described above, as well as allow the existence\n   of internal hosts
      to be confirmed when they would otherwise be\n   hidden.\n   The detailed security
      concerns involved will depend on the URI\n   schemes supported by the server.
      \ In the case of HTTP, the concerns\n   are similar to those that apply to a
      publicly accessible HTTP proxy\n   server.  In the case of HTTPS, loops and
      deadlocks may be created,\n   and this should be addressed.  In the case of
      FTP, attacks arise that\n   are similar to FTP bounce attacks.\n   As a result
      of this issue, it is RECOMMENDED that the\n   client_certificate_url extension
      should have to be specifically\n   enabled by a server administrator, rather
      than be enabled by default.\n   It is also RECOMMENDED that URI schemes be enabled
      by the\n   administrator individually, and only a minimal set of schemes be\n
      \  enabled.  Unusual protocols that offer limited security or whose\n   security
      is not well understood SHOULD be avoided.\n   As discussed in [RFC3986], URLs
      that specify ports other than the\n   default may cause problems, as may very
      long URLs (which are more\n   likely to be useful in exploiting buffer overflow
      bugs).\n   This extension continues to use SHA-1 (as in RFC 4366) and does not\n
      \  provide algorithm agility.  The property required of SHA-1 in this\n   case
      is second pre-image resistance, not collision resistance.\n   Furthermore, even
      if second pre-image attacks against SHA-1 are found\n   in the future, an attack
      against client_certificate_url would require\n   a second pre-image that is
      accepted as a valid certificate by the\n   server and contains the same public
      key.\n   Also note that HTTP caching proxies are common on the Internet, and\n
      \  some proxies do not check for the latest version of an object\n   correctly.
      \ If a request using HTTP (or another caching protocol)\n   goes through a misconfigured
      or otherwise broken proxy, the proxy may\n   return an out-of-date response.\n"
    title: 11.3.  Security Considerations for client_certificate_url
  - contents:
    - "11.4.  Security Considerations for trusted_ca_keys\n   Potentially, the CA
      root keys a client possesses could be regarded as\n   confidential information.
      \ As a result, the CA root key indication\n   extension should be used with
      care.\n   The use of the SHA-1 certificate hash alternative ensures that each\n
      \  certificate is specified unambiguously.  This context does not\n   require
      a cryptographic hash function, so the use of SHA-1 is\n   considered acceptable,
      and no algorithm agility is provided.\n"
    title: 11.4.  Security Considerations for trusted_ca_keys
  - contents:
    - "11.5.  Security Considerations for truncated_hmac\n   It is possible that truncated
      MACs are weaker than \"un-truncated\"\n   MACs.  However, no significant weaknesses
      are currently known or\n   expected to exist for HMAC with MD5 or SHA-1, truncated
      to 80 bits.\n   Note that the output length of a MAC need not be as long as
      the\n   length of a symmetric cipher key, since forging of MAC values cannot\n
      \  be done off-line: in TLS, a single failed MAC guess will cause the\n   immediate
      termination of the TLS session.\n   Since the MAC algorithm only takes effect
      after all handshake\n   messages that affect extension parameters have been
      authenticated by\n   the hashes in the Finished messages, it is not possible
      for an active\n   attacker to force negotiation of the truncated HMAC extension
      where\n   it would not otherwise be used (to the extent that the handshake\n
      \  authentication is secure).  Therefore, in the event that any security\n   problems
      were found with truncated HMAC in the future, if either the\n   client or the
      server for a given session were updated to take the\n   problem into account,
      it would be able to veto use of this extension.\n"
    title: 11.5.  Security Considerations for truncated_hmac
  - contents:
    - "11.6.  Security Considerations for status_request\n   If a client requests
      an OCSP response, it must take into account that\n   an attacker's server using
      a compromised key could (and probably\n   would) pretend not to support the
      extension.  In this case, a client\n   that requires OCSP validation of certificates
      SHOULD either contact\n   the OCSP server directly or abort the handshake.\n
      \  Use of the OCSP nonce request extension (id-pkix-ocsp-nonce) may\n   improve
      security against attacks that attempt to replay OCSP\n   responses; see Section
      4.4.1 of [RFC2560] for further details.\n"
    title: 11.6.  Security Considerations for status_request
  title: 11.  Security Considerations
- contents:
  - "12.  Normative References\n   [RFC2104]      Krawczyk, H., Bellare, M., and R.
    Canetti, \"HMAC:\n                  Keyed-Hashing for Message Authentication\",
    RFC 2104,\n                  February 1997.\n   [RFC2119]      Bradner, S., \"Key
    words for use in RFCs to Indicate\n                  Requirement Levels\", BCP
    14, RFC 2119, March 1997.\n   [RFC2560]      Myers, M., Ankney, R., Malpani, A.,
    Galperin, S., and\n                  C. Adams, \"X.509 Internet Public Key Infrastructure\n
    \                 Online Certificate Status Protocol - OCSP\", RFC 2560,\n                  June
    1999.\n   [RFC2585]      Housley, R. and P. Hoffman, \"Internet X.509 Public Key\n
    \                 Infrastructure Operational Protocols: FTP and HTTP\",\n                  RFC
    2585, May 1999.\n   [RFC2616]      Fielding, R., Gettys, J., Mogul, J., Frystyk,
    H.,\n                  Masinter, L., Leach, P., and T. Berners-Lee,\n                  \"Hypertext
    Transfer Protocol -- HTTP/1.1\", RFC 2616,\n                  June 1999.\n   [RFC3986]
    \     Berners-Lee, T., Fielding, R., and L. Masinter,\n                  \"Uniform
    Resource Identifier (URI): Generic Syntax\",\n                  STD 66, RFC 3986,
    January 2005.\n   [RFC5246]      Dierks, T. and E. Rescorla, \"The Transport Layer\n
    \                 Security (TLS) Protocol Version 1.2\", RFC 5246, August\n                  2008.\n
    \  [RFC5280]      Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\n                  Housley,
    R., and W. Polk, \"Internet X.509 Public Key\n                  Infrastructure
    Certificate and Certificate Revocation\n                  List (CRL) Profile\",
    RFC 5280, May 2008.\n   [RFC5890]      Klensin, J., \"Internationalized Domain
    Names for\n                  Applications (IDNA): Definitions and Document\n                  Framework\",
    RFC 5890, August 2010.\n"
  title: 12.  Normative References
- contents:
  - "13.  Informative References\n   [RFC2712]      Medvinsky, A. and M. Hur, \"Addition
    of Kerberos Cipher\n                  Suites to Transport Layer Security (TLS)\",
    RFC 2712,\n                  October 1999.\n   [X509-4th]     ITU-T Recommendation
    X.509 (2000) | ISO/IEC\n                  9594-8:2001, \"Information Systems -
    Open Systems\n                  Interconnection - The Directory: Public key and\n
    \                 attribute certificate frameworks\".\n   [X509-4th-TC1] ITU-T
    Recommendation X.509(2000) Corrigendum 1(2001) |\n                  ISO/IEC 9594-8:2001/Cor.1:2002,
    Technical Corrigendum\n                  1 to ISO/IEC 9594:8:2001.\n"
  title: 13.  Informative References
- contents:
  - "Appendix A.  Changes from RFC 4366\n   The significant changes between RFC 4366
    and this document are\n   described below.\n   RFC 4366 described both general
    extension mechanisms (for the TLS\n   handshake and client and server hellos)
    as well as specific\n   extensions.  RFC 4366 was associated with RFC 4346, TLS
    1.1.  The\n   client and server hello extension mechanisms have been moved into
    RFC\n   5246, TLS 1.2, so this document, which is associated with RFC 5246,\n
    \  includes only the handshake extension mechanisms and the specific\n   extensions
    from RFC 4366.  RFC 5246 also specifies the unknown\n   extension error and new
    extension specification considerations, so\n   that material has been removed
    from this document.\n   The Server Name extension now specifies only ASCII representation,\n
    \  eliminating UTF-8.  It is provided that the ServerNameList can\n   contain
    more than only one name of any particular name_type.  If a\n   server name is
    provided but not recognized, the server should either\n   continue the handshake
    without an error or send a fatal error.\n   Sending a warning-level message is
    not recommended because client\n   behavior will be unpredictable.  Provision
    was added for the user\n   using the server_name extension in deciding whether
    or not to resume\n   a session.  Furthermore, this extension should be the same
    in a\n   session resumption request as it was in the full handshake that\n   established
    the session.  Such a resumption request must not be\n   accepted if the server_name
    extension is different, but instead a\n   full handshake must be done to possibly
    establish a new session.\n   The Client Certificate URLs extension has been changed
    to make the\n   presence of a hash mandatory.\n   For the case of DTLS, the requirement
    to report an overflow of the\n   negotiated maximum fragment length is made conditional
    on passing\n   authentication.\n   TLS servers are now prohibited from following
    HTTP redirects when\n   retrieving certificates.\n   The material was also re-organized
    in minor ways.  For example,\n   information as to which errors are fatal is moved
    from the \"Error\n   Alerts\" section to the individual extension specifications.\n"
  title: Appendix A.  Changes from RFC 4366
- contents:
  - "Appendix B.  Acknowledgements\n   This document is based on material from RFC
    4366 for which the\n   authors were S. Blake-Wilson, M. Nystrom, D. Hopwood, J.
    Mikkelsen,\n   and T. Wright.  Other contributors include Joseph Salowey, Alexey\n
    \  Melnikov, Peter Saint-Andre, and Adrian Farrel.\n"
  title: Appendix B.  Acknowledgements
- contents:
  - "Author's Address\n   Donald Eastlake 3rd\n   Huawei\n   155 Beaver Street\n   Milford,
    MA 01757 USA\n   Phone: +1-508-333-2270\n   EMail: d3e3e3@gmail.com\n"
  title: Author's Address
