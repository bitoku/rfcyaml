Abstract This memo defines a portion of the Management Information Base (MIB) for use with network management protocols in the Internet community.
In particular, it describes managed objects used for managing multiple logical and physical entities managed by a single SNMP agent.
This document specifies version 3 of the Entity MIB, which obsoletes version 2 (RFC 2737).
For a detailed overview of the documents that describe the current Internet Standard Management Framework, please refer to section 7 of RFC 3410 [RFC3410].
Managed objects are accessed via a virtual information store, termed the Management Information Base or MIB.
MIB objects are generally accessed through the Simple Network Management Protocol (SNMP).
Objects in the MIB are defined using the mechanisms defined in the Structure of Management Information (SMI).
This memo specifies a MIB module that is compliant to the SMIv2, which is described in STD 58, RFC 2578 [RFC2578], STD 58
, RFC 2579 [RFC2579] and STD 58, RFC 2580
There is a need for a standardized way of representing a single agent, which supports multiple instances of one MIB.
This is presently true for at least 3 standard MIBs, and is likely to become true for more and more MIBs as time passes.
For example: multiple instances of a bridge supported within a single device that has a single agent; multiple repeaters supported by a single agent; multiple OSPF backbone areas, each operating as part of its own Autonomous System, and each identified by the same area id (e.g., 0.0.0.0), supported inside a single router with one agent.
The single agent present in each of these cases implies a relationship binds these entities.
Effectively, there is some "overall" physical entity which houses the sum of the things managed by that one agent, i.e., there are multiple "logical" entities within a single physical entity.
Sometimes, the overall physical entity contains multiple (smaller) physical entities, and each logical entity is associated with a particular physical entity.
Sometimes, the overall physical entity is a "compound" of multiple physical entities (e.g., a stack of stackable hubs).
What is needed is a way to determine exactly which logical entities are managed by the agent (with some version of SNMP) in order to communicate with the agent about a particular logical entity.
When different logical entities are associated with different physical entities within the overall physical entity, it is also useful to be able to use this information to distinguish between logical entities.
In these situations, there is no need for varbinds for multiple logical entities to be referenced in the same SNMP message (although that might be useful in the future).
Rather, it is sufficient, and in some situations preferable, to have the context/community in the message identify the logical entity to which the varbinds apply.
Version 2 of this MIB addresses new requirements, which have emerged since the publication of the first Entity MIB (RFC 2037 [RFC2037]).
There is a need for a standardized way of providing non volatile, administratively assigned identifiers for physical components represented with the Entity MIB.
There is also a need to align the Entity MIB with the SNMPv3 administrative framework (STD 62, RFC 3411 [RFC3411]).
Implementation experience has shown that additional physical component attributes are also desirable.
Version 3 of this MIB addresses new requirements, which have emerged since the publication of the second Entity MIB (RFC 2737 [RFC2737]).
There is a need to identify physical entities that are central processing units (CPUs) and a need to provide a textual convention that identifies an entPhysicalIndex value or zero, where the value zero has application specific semantics.
Two new objects have been added to the entPhysicalTable to identify the manufacturing date and provide additional URIs for a particular physical entity.
Some new terms are used throughout this document:
A "naming scope" represents the set of information that may be potentially accessed through a single SNMP operation.
All instances within the naming scope share the same unique identifier space.
For SNMPv1, a naming scope is identified by the value of the associated 'entLogicalCommunity' instance.
For SNMPv3, the term 'context' is used instead of 'naming scope'.
The complete definition of an SNMP context can be found in section 3.3.1 of RFC 3411 [RFC3411].
Multi Scoped Object A MIB object, for which identical instance values identify different managed information in different naming scopes, is called a "multi scoped" MIB object.
A MIB object, for which identical instance values identify the same managed information in different naming scopes, is called a "single scoped" MIB object.
Logical Entity A managed system contains one or more logical entities, each represented by at most one instantiation of each of a particular set of MIB objects.
A set of management functions is associated with each logical entity.
Examples of logical entities include routers, bridges, print servers, etc.
Physical Entity A "physical entity" or "physical component" represents an identifiable physical resource within a managed system.
Zero or more logical entities may utilize a physical resource at any given time.
Determining which physical components are represented by an agent in the EntPhysicalTable is an implementation specific matter.
Typically, physical resources (e.g., communications ports, backplanes, sensors, daughter cards, power supplies, the overall chassis), which can be managed via functions associated with one or more logical entities, are included in the MIB.
Each physical component may be modeled as 'contained' within another physical component.
A "containment tree" is the conceptual sequence of entPhysicalIndex values that uniquely specifies the exact physical location of a physical component within the managed system.
It is generated by 'following and recording' each 'entPhysicalContainedIn' instance 'up the tree towards the root', until a value of zero indicating no further containment is found.
For community based SNMP, differentiating logical entities is one (but not the only) purpose of the community string
This is accommodated by representing each community string as a logical entity.
Note that different logical entities may share the same naming scope and, therefore, the same values of entLogicalCommunity.
This is possible, providing they have no need for the same instance of a MIB object to represent different managed information.
to SNMP Contexts Version 2 of the Entity
MIB contains support for associating SNMPv3 contexts with logical entities.
Two new MIB objects, defining an SnmpEngineID and ContextName pair, are used together to identify an SNMP context associated with a logical entity.
This context can be used (in conjunction with the entLogicalTAddress and entLogicalTDomain MIB objects) to send SNMPv3 messages on behalf of a particular logical entity.
The Entity MIB is designed to allow functional component discovery.
The administrative relationships between different logical entities are not visible in any Entity MIB tables.
A Network Management System (NMS) cannot determine whether MIB instances in different naming scopes are realized locally or remotely (e.g., via some proxy mechanism) by examining any particular Entity MIB objects.
The management of administrative framework functions is not an explicit goal of the Entity MIB WG at this time.
This new area of functionality may be revisited after some operational experience with the Entity MIB is gained.
Note that for community based versions of SNMP, a network administrator will likely be able to associate community strings with naming scopes that have proprietary mechanisms, as a matter of configuration.
There are no mechanisms for managing naming scopes defined in this MIB.
Relationship to a Chassis MIB
Some readers may recall that a previous IETF working group attempted to define a Chassis MIB.
No consensus was reached by that working group, possibly because its scope was too broad.
As such, it is not the purpose of this MIB to be a "Chassis MIB replacement", nor is it within the scope of this MIB to contain all the information which might be necessary to manage a "chassis".
On the other hand, the entities represented by an implementation of this MIB might well be contained in a chassis.
Relationship to the Interfaces MIB
The Entity MIB contains a mapping table identifying physical components that have 'external values' (e.g., ifIndex) associated with them within a given naming scope.
This table can be used to identify the physical location of each interface in the ifTable (RFC 2863 [RFC2863]).
Because ifIndex values in different contexts are not related to one another, the interface to physical component associations are relative to the same logical entity within the agent.
The Entity MIB also contains 'entPhysicalName' and 'entPhysicalAlias' objects, which approximate the semantics of the 'ifName' and 'ifAlias' objects (respectively) from the Interfaces MIB [RFC2863], for all types of physical components.
Relationship to the Other MIBs
The Entity MIB contains a mapping table identifying physical components that have identifiers from other standard MIBs associated with them.
For example, this table can be used along with the physical mapping table to identify the physical location of each repeater port in the rptrPortTable, or each interface in the ifTable.
There is some question as to which MIB objects may be returned within a given naming scope.
MIB objects which are not multi scoped within a managed system are likely to ignore context information in implementation.
In such a case, it is likely such objects will be returned in all naming scopes (e.g., not just the 'default' naming scope or the SNMPv3 default context).
For example, a community string used to access the management information for logical device 'bridge2' may allow access to all the non bridge related objects in the 'default' naming scope, as well as a second instance of the Bridge MIB (RFC 1493 [RFC1493]).
The isolation of single scoped MIB objects by the agent is an implementation specific matter.
An agent may wish to limit the objects returned in a particular naming scope to only the multi  scoped objects in that naming scope (e.g., system group and the Bridge MIB).
In this case, all single scoped management information would belong to a common naming scope (e.g., 'default'), which itself may contain some multi scoped objects (e.g., system group).
Multiple Instances of the Entity
It is possible that more than one agent may exist in a managed system.
In such cases, multiple instances of the Entity MIB (representing the same managed objects) may be available to an NMS.
In order to reduce complexity for agent implementation, multiple instances of the Entity MIB are not required to be equivalent or even consistent.
An NMS may be able to 'align' instances returned by different agents by examining the columns of each table, but vendor  specific identifiers and (especially) index values are likely to be different.
Each agent may be managing different subsets of the entire chassis as well.
When all of a physically modular device is represented by a single agent, the entry (for which entPhysicalContainedIn has the value zero) would likely have 'chassis' as the value of its entPhysicalClass.
Alternatively, for an agent on a module where the agent represents only the physical entities on that module (not those on other modules), the entry (for which entPhysicalContainedIn has the value zero) would likely have 'module' as the value of its entPhysicalClass.
An agent implementation of the entLogicalTable is not required to contain information about logical entities managed primarily by other agents.
That is, the entLogicalTAddress and entLogicalTDomain objects in the entLogicalTable are provided to support an historical multiplexing mechanism, not to identify other SNMP agents.
Note that the Entity MIB is a single scoped MIB, in the event an agent represents the MIB in different naming scopes.
Most of the MIB objects defined in this
MIB have, at most, a read  only MAX ACCESS clause.
This is a conscious decision by the working group to limit this MIB's scope.
The second version of the Entity MIB allows a network administrator to configure some common attributes of physical components.
Textual Convention Change Version 1 of the Entity
MIB contains three MIB objects defined with the (now obsolete)
In version 2 of the Entity MIB, the syntax for these objects has been updated to use the (now preferred)
The working group realizes that this change is not strictly supported by SMIv2.
In our judgment, the alternative of deprecating the old objects and defining new objects would have a more adverse impact on backward compatibility and interoperability, given the particular semantics of these objects.
The Entity MIB contains five groups of MIB objects: entityPhysical group Describes the physical entities managed by a single agent.
entityLogical group Describes the logical entities managed by a single agent.
entityMapping group Describes the associations between the physical entities, logical entities, interfaces, and non interface ports managed by a single agent.
entityGeneral group Describes general system attributes shared by potentially all types of entities managed by a single agent.
entityNotifications group Contains status indication notifications.
This group contains a single table to identify physical system components, called the entPhysicalTable.
Each row is indexed by an arbitrary, small integer, and contains a description and type of the physical entity.
It also optionally contains the index number of another entPhysicalEntry, indicating a containment relationship between the two.
Version 2 of the Entity MIB provides additional MIB objects for each physical entity.
Some common read only attributes have been added, as well as three writable string objects.
entPhysicalAlias This string can be used by an NMS as a non volatile identifier for the physical component.
Maintaining a non volatile string for every physical component represented in the entPhysicalTable can be costly and unnecessary.
An agent may algorithmically generate 'entPhysicalAlias' strings for particular entries (e.g., based on the entPhysicalClass value).
This string is provided to store a user specific asset identifier for removable physical components.
In order to reduce the non  volatile storage needed by a particular agent, a network administrator should only assign asset identifiers to physical entities that are field replaceable (i.e., not permanently contained within another physical entity).
This string is provided to store a vendor specific serial number string for physical components.
This writable object is used when an agent cannot identify the serial numbers of all installed physical entities, and a network administrator wishes to configure the non volatile serial number strings manually (via an NMS application).
Version 3 of the Entity MIB provides two additional MIB objects for each physical entity:
entPhysicalMfgDate This object contains the date of manufacturing of the managed entity.
If the manufacturing date is unknown or not supported the object is not instantiated.
The special value '0000000000000000'H may also be returned in this case.
entPhysicalUris This object provides additional identification information about the physical entity.
This object contains one or more Uniform Resource Identifiers (URIs) and, therefore, the syntax of this object must conform to RFC 3986 [RFC3986] section 2.
Uniform Resource Names (URNs), RFC 3406 [RFC3406], are resource identifiers with the specific requirements for enabling location independent identification of a resource, as well as longevity of reference.
URNs are part of the larger URI family with the specific goal of providing persistent naming of resources.
URI schemes and URN name spaces are registered by IANA (see http://www.iana.org/assignments/uri schemes and http://www.iana.org/assignments/urn namespaces).
For example, the entPhysicalUris object may be used to encode a URI containing a Common Language Equipment Identifier (CLEI) URN for the managed physical entity.
The URN name space for CLEIs is defined in [RFC4152], and the CLEI format is defined in [T1.213][T1.213a].
For example, an entPhysicalUris instance may have the value of URN
[RFC3986] and [RFC4152] identify this as a URI in the CLEI URN name space.
The specific CLEI code, D4CE18B7AA, is based on the example provided in [T1.213a].
Multiple URIs may be present and are separated by white space characters.
Leading and trailing white space characters are ignored.
If no additional identification information is known about the physical entity or supported, the object is not instantiated.
This group contains a single table to identify logical entities, called the entLogicalTable.
The entLogicalTable contains one row per logical entity.
Each row is indexed by an arbitrary, small integer and contains a name, description, and type of the logical entity.
It also contains information to allow access to the MIB information for the logical entity.
This includes SNMP versions that use a community name (with some form of implied context representation) and SNMP versions that use the SNMP ARCH [RFC3411] method of context identification.
If an agent represents multiple logical entities with this MIB, then this group must be implemented for all logical entities known to the agent.
If an agent represents a single logical entity, or multiple logical entities within a single naming scope, then implementation of this group may be omitted by the agent.
This group contains three tables to identify associations between different system components.
entLPMappingTable This table contains mappings between entLogicalIndex values (logical entities) and entPhysicalIndex
values (the physical components supporting that entity).
A logical entity can map to more than one physical component, and more than one logical entity can map to (share)
If an agent represents a single logical entity, or multiple logical entities within a single naming scope, then implementation of this table may be omitted by the agent.
entAliasMappingTable This table contains mappings between entLogicalIndex, entPhysicalIndex pairs, and 'alias' object identifier values.
This allows resources managed with other MIBs (e.g., repeater ports, bridge ports, physical and logical interfaces) to be identified in the physical entity hierarchy.
Note that each alias identifier is only relevant in a particular naming scope.
If an agent represents a single logical entity, or multiple logical entities within a single naming scope, then implementation of this table may be omitted by the agent.
entPhysicalContainsTable This table contains simple mappings between 'entPhysicalContainedIn' values for each container/'containee' relationship in the managed system.
The indexing of this table allows an NMS to quickly discover the 'entPhysicalIndex' values for all children of a given physical entity.
This group contains general information relating to the other object groups.
At this time, the entGeneral group contains a single scalar object (entLastChangeTime), which represents the value of sysUptime when any part of the Entity MIB configuration last changed.
This group contains notification definitions relating to the overall status of the Entity MIB instantiation.
Even though a primary motivation for this MIB is to represent the multiple logical entities supported by a single agent, another motivation is to represent multiple logical entities supported by multiple agents (in the same "overall" physical entity).
Indeed, it is implicit in the SNMP architecture that the number of agents is transparent to a network management station.
However, there is no agreement at this time as to the degree of cooperation that should be expected for agent implementations.
Therefore, multiple agents within the same managed system are free to implement the Entity MIB independently.
(For more information, refer to Section 2.9, "Multiple Instances of the Entity MIB".)
Changes Since RFC 2037 2.14.1.
The PhysicalClass TC text has been clarified, and a new enumeration to support 'stackable' components has been added.
The SnmpEngineIdOrNone TC has been added to support SNMPv3.
New entPhysicalTable Objects The entPhysicalHardwareRev, entPhysicalFirmwareRev, and entPhysicalSoftwareRev objects have been added for revision identification.
The entPhysicalSerialNum, entPhysicalMfgName, entPhysicalModelName, and entPhysicalIsFru objects have been added for better vendor identification for physical components.
In the event the agent cannot identify this information, the entPhysicalSerialNum object can be set by a management station.
The entPhysicalAlias and entPhysicalAssetID objects have been added for better user component identification.
These objects are intended to be set by a management station and preserved by the agent across restarts.
The entLogicalContextEngineID and entLogicalContextName objects have been added to provide an SNMP context for SNMPv3 access on behalf of a logical entity.
A bug was fixed in the entLogicalCommunity object.
The subrange was incorrect (1..255) and is now (0..255).
The description clause has also been clarified.
This object is now deprecated.
The entLastChangeTime object description has been changed to generalize the events that cause an update to the last change timestamp.
The syntax was changed from DisplayString to SnmpAdminString for the entPhysicalDescr, entPhysicalName, and entLogicalDescr objects.
Changes Since RFC 2737 2.15.1.
The PhysicalIndexOrZero TC has been added to allow objects to reference an entPhysicalIndex value or zero.
The PhysicalClass TC has been extended to support a new enumeration for central processing units.
The entPhysicalMfgDate object has been added to the entPhysicalTable to provide the date of manufacturing of the managed entity.
The entPhysicalUris object has been added to the entPhysicalTable to provide additional identification information about the physical entity, such as a Common Language Equipment Identifier (CLEI)
The syntax was changed from INTEGER to Integer32 for the entPhysicalParentRelPos, entLogicalIndex, and entAliasLogicalIndexOrZero objects, and from INTEGER to PhysicalIndexOrZero for the entPhysicalContainedIn object.
Definitions ENTITY MIB DEFINITIONS ::
IMPORTS MODULE IDENTITY, OBJECT TYPE, mib 2,
NOTIFICATION TYPE, Integer32 FROM SNMPv2
SMI TDomain, TAddress, TEXTUAL CONVENTION, AutonomousType, RowPointer, TimeStamp, TruthValue, DateAndTime FROM SNMPv2
TC MODULE COMPLIANCE, OBJECT GROUP, NOTIFICATION GROUP FROM SNMPv2
CONF SnmpAdminString FROM SNMP FRAMEWORK MIB;
entityMIB MODULE IDENTITY LAST UPDATED
http://www.ietf.org/mailman/listinfo/entmib Andy Bierman ietf@andybierman.com Keith McCloghrie Cisco Systems Inc. 170 West Tasman Drive San Jose, CA 95134
1 408 526 5260 kzm@cisco.com
" DESCRIPTION "The MIB module for representing multiple logical entities supported by a single SNMP agent.
This version of this MIB module is part of RFC 4133; see the RFC itself for full legal notices."
This revision obsoletes RFC 2737.
Additions: cpu(12) enumeration added to PhysicalClass TC DISPLAY HINT clause to PhysicalIndex TC PhysicalIndexOrZero TC
object Changes: entPhysicalContainedIn SYNTAX changed from INTEGER to PhysicalIndexOrZero
This version published as RFC 4133."
This revision obsoletes RFC 2037.
This version published as RFC 2737."
"An arbitrary value that uniquely identifies the physical entity.
The value should be a small, positive integer.
Index values for different physical entities are not necessarily contiguous."
"This textual convention is an extension of the PhysicalIndex convention, which defines a greater than zero value used to identify a physical entity.
This extension permits the additional value of zero.
The semantics of the value zero are object specific and must, therefore, be defined as part of the description of any object that uses this syntax.
Examples of the usage of this extension are situations where none or all physical entities need to be referenced."
There are no restrictions as to the number of entPhysicalEntries of each entPhysicalClass, which must be instantiated by an agent.
The enumeration 'other' is applicable if the physical entity class is known, but does not match any of the supported values.
The enumeration 'unknown' is applicable if the physical entity class is unknown to the agent.
The enumeration 'chassis' is applicable if the physical entity class is an overall container for networking equipment.
Any class of physical entity, except a stack, may be contained within a chassis; and a chassis may only be contained within a stack.
The enumeration 'backplane' is applicable if the physical entity class is some sort of device for aggregating and forwarding networking traffic, such as a shared backplane in a modular ethernet switch.
Note that an agent may model a backplane as a single physical entity, which is actually implemented as multiple discrete physical components (within a chassis or stack).
The enumeration 'container' is applicable if the physical entity class is capable of containing one or more removable physical entities, possibly of different types.
For example, each (empty or full) slot in a chassis will be modeled as a container.
Note that all removable physical entities should be modeled within a container entity, such as field replaceable modules, fans, or power supplies.
Note that all known containers should be modeled by the agent, including empty containers.
The enumeration 'powerSupply' is applicable if the physical entity class is a power supplying component.
The enumeration 'fan' is applicable if the physical entity class is a fan or other heat reduction component.
The enumeration 'sensor' is applicable if the physical entity class is some sort of sensor, such as a temperature sensor within a router chassis.
The enumeration 'module' is applicable if the physical entity class is some sort of self contained sub system.
If the enumeration 'module' is removable, then it should be modeled within a container entity, otherwise it should be modeled directly within another physical entity (e.g., a chassis or another module).
The enumeration 'port' is applicable if the physical entity class is some sort of networking port, capable of receiving and/or transmitting networking traffic.
The enumeration 'stack' is applicable if the physical entity class is some sort of super container (possibly virtual), intended to group together multiple chassis entities.
A stack may be realized by a 'virtual' cable, a real interconnect cable, attached to multiple chassis, or may in fact be comprised of multiple interconnect cables.
A stack should not be modeled within any other physical entities, but a stack may be contained within another stack.
Only chassis entities should be contained within a stack.
The enumeration 'cpu' is applicable if the physical entity class is some sort of central processing unit.
A specially formatted SnmpEngineID string for use with the Entity MIB.
If an instance of an object of SYNTAX SnmpEngineIdOrNone has a non zero length, then the object encoding and semantics are defined by the SnmpEngineID textual convention (see STD 62, RFC 3411 [RFC3411]).
If an instance of an object of SYNTAX SnmpEngineIdOrNone contains a zero length string, then no appropriate SnmpEngineID is associated with the logical entity (i.e., SNMPv3 is not supported).
"This table contains one row per physical entity.
There is always at least one row for an 'overall' physical entity."
current DESCRIPTION "Information about a particular physical entity.
Each entry provides objects (entPhysicalDescr, entPhysicalVendorType, and entPhysicalClass) to help an NMS identify and characterize the entry, and objects (entPhysicalContainedIn and entPhysicalParentRelPos) to help an NMS relate the particular entry to other entries in this table.
"The index for this entry."
"A textual description of physical entity.
This object should contain a string that identifies the manufacturer's name for the physical entity, and should be set to a distinct value for each version or model of the physical entity."
{ entPhysicalEntry 2 } entPhysicalVendorType OBJECT
"An indication of the vendor specific hardware type of the physical entity.
Note that this is different from the definition of MIB II's sysObjectID.
An agent should set this object to an enterprise specific registration identifier value indicating the specific equipment type in detail.
The associated instance of entPhysicalClass is used to indicate the general type of hardware device.
If no vendor specific registration identifier exists for this physical entity, or the value is unknown by this agent, then the value { 0 0 } is returned."
"The value of entPhysicalIndex for the physical entity which 'contains' this physical entity.
A value of zero indicates this physical entity is not contained in any other physical entity.
Note that the set of 'containment' relationships define a strict hierarchy; that is, recursion is not allowed.
"An indication of the general hardware type of the physical entity.
An agent should set this object to the standard enumeration value that most accurately indicates the general class of the physical entity, or the primary class if there is more than one entity.
If no appropriate standard registration identifier exists for this physical entity, then the value 'other(1)' is returned.
If the value is unknown by this agent, then the value 'unknown(2)' is returned."
"An indication of the relative position of this 'child' component among all its 'sibling' components.
Sibling components are defined as entPhysicalEntries that share the same instance values of each of the entPhysicalContainedIn and entPhysicalClass objects.
An NMS can use this object to identify the relative ordering for all sibling components of a particular parent (identified by the entPhysicalContainedIn instance in each sibling entry).
If possible, this value should match any external labeling of the physical component.
For example, for a container (e.g., card slot) labeled as 'slot #3', entPhysicalParentRelPos should have the value '3'.
Note that the entPhysicalEntry for the module plugged in slot 3 should have an entPhysicalParentRelPos value of '1'.
If the physical position of this component does not match any external numbering or clearly visible ordering, then user documentation or other external reference material should be used to determine the parent relative position.
If this is not possible, then the agent should assign a consistent (but possibly arbitrary) ordering to a given set of 'sibling' components, perhaps based on internal representation of the components.
If the agent cannot determine the parent relative position for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value ' 1' is returned.
Otherwise, a non negative integer is returned, indicating the parent relative position of this physical entity.
Parent relative ordering normally starts from '1' and continues to 'N', where 'N' represents the highest positioned child entity.
However, if the physical entities (e.g., slots) are labeled from a starting position of zero, then the first sibling should be associated with an entPhysicalParentRelPos value of '0'.
Note that this ordering may be sparse or dense, depending on agent implementation.
The actual values returned are not globally meaningful, as each 'parent' component may use different numbering algorithms.
The ordering is only meaningful among siblings of the same parent component.
The agent should retain parent relative position values across reboots, either through algorithmic assignment or use of non volatile storage."
"The textual name of the physical entity.
The value of this object should be the name of the component as assigned by the local device and should be suitable for use in commands entered at the device's `console'.
This might be a text name (e.g., `console') or a simple component number (e.g., port or module number, such as `1'), depending on the physical component naming syntax of the device.
If there is no local name, or if this object is otherwise not applicable, then this object contains a zero length string.
"The vendor specific hardware revision string for the physical entity.
The preferred value is the hardware revision identifier actually printed on the component itself (if present).
Note that if revision information is stored internally in a non printable (e.g., binary) format, then the agent must convert such information to a printable format, in an implementation specific manner.
If no specific hardware revision string is associated with the physical component, or if this information is unknown to the agent, then this object will contain a zero length string."
Note that if revision information is stored internally in a non printable (e.g., binary) format, then the agent must convert such information to a printable format, in an implementation specific manner.
If no specific firmware programs are associated with the physical component, or if this information is unknown to the agent, then this object will contain a zero length string."
Note that if revision information is stored internally in a non printable (e.g., binary) format, then the agent must convert such information to a printable format, in an implementation specific manner.
If no specific software programs are associated with the physical component, or if this information is unknown to the agent, then this object will contain a zero length string."
entPhysicalEntry 10 } entPhysicalSerialNum   OBJECT
MAX ACCESS  read write STATUS
"The vendor specific serial number string for the physical entity.
The preferred value is the serial number string actually printed on the component itself (if present).
On the first instantiation of an physical entity, the value of entPhysicalSerialNum associated with that entity is set to the correct vendor assigned serial number, if this information is available to the agent.
If a serial number is unknown or non existent, the entPhysicalSerialNum will be set to a zero length string instead.
Note that implementations that can correctly identify the serial numbers of all installed physical entities do not need to provide write access to the entPhysicalSerialNum object.
Agents which cannot provide non volatile storage for the entPhysicalSerialNum strings are not required to implement write access for this object.
Not every physical component will have a serial number, or even need one.
Physical entities for which the associated value of the entPhysicalIsFRU object is equal to 'false(2)' (e.g., the repeater ports within a repeater module), do not need their own unique serial number.
An agent does not have to provide write access for such entities, and may return a zero length string.
If write access is implemented for an instance of entPhysicalSerialNum, and a value is written into the instance, the agent must retain the supplied value in the entPhysicalSerialNum instance (associated with the same physical entity) for as long as that entity remains instantiated.
This includes instantiations across all re initializations/reboots of the network management system, including those resulting in a change of the physical entity's entPhysicalIndex value."
"The name of the manufacturer of this physical component.
The preferred value is the manufacturer name string actually printed on the component itself (if present).
Note that comparisons between instances of the entPhysicalModelName, entPhysicalFirmwareRev, entPhysicalSoftwareRev, and the entPhysicalSerialNum objects, are only meaningful amongst entPhysicalEntries with the same value of entPhysicalMfgName.
If the manufacturer name string associated with the physical component is unknown to the agent, then this object will contain a zero length string."
The preferred value is the customer visible part number, which may be printed on the component itself.
If the model name string associated with the physical component is unknown to the agent, then this object will contain a zero length string."
MAX ACCESS  read write STATUS
"This object is an 'alias' name for the physical entity, as specified by a network manager, and provides a non volatile 'handle' for the physical entity.
On the first instantiation of a physical entity, the value of entPhysicalAlias associated with that entity is set to the zero length string.
However, the agent may set the value to a locally unique default value, instead of a zero length string.
If write access is implemented for an instance of entPhysicalAlias, and a value is written into the instance, the agent must retain the supplied value in the entPhysicalAlias instance (associated with the same physical entity) for as long as that entity remains instantiated.
This includes instantiations across all re initializations/reboots of the network management system, including those resulting in a change of the physical entity's entPhysicalIndex value."
MAX ACCESS  read write STATUS
"This object is a user assigned asset tracking identifier (as specified by a network manager) for the physical entity, and provides non volatile storage of this information.
On the first instantiation of a physical entity, the value of entPhysicalAssetID associated with that entity is set to the zero length string.
Not every physical component will have an asset tracking identifier, or even need one.
Physical entities for which the associated value of the entPhysicalIsFRU object is equal to 'false(2)' (e.g., the repeater ports within a repeater module), do not need their own unique asset tracking identifier.
An agent does not have to provide write access for such entities, and may instead return a zero length string.
If write access is implemented for an instance of entPhysicalAssetID, and a value is written into the instance, the agent must retain the supplied value in the entPhysicalAssetID instance (associated with the same physical entity) for as long as that entity remains instantiated.
This includes instantiations across all re initializations/reboots of the network management system, including those resulting in a change of the physical entity's entPhysicalIndex value.
If no asset tracking information is associated with the physical component, then this object will contain a zero length string."
"This object indicates whether or not this physical entity is considered a 'field replaceable unit' by the vendor.
If this object contains the value 'true(1)' then this entPhysicalEntry identifies a field replaceable unit.
For all entPhysicalEntries that represent components permanently contained within a field replaceable unit, the value 'false(2)'
should be returned for this object."
"This object contains the date of manufacturing of the managed entity.
If the manufacturing date is unknown or not supported, the object is not instantiated.
The special value '0000000000000000'H may also be returned in this case."
"This object contains additional identification information about the physical entity.
The object contains URIs and, therefore, the syntax of this object must conform to RFC 3986, section 2.
Multiple URIs may be present and are separated by white space characters.
Leading and trailing white space characters are ignored.
If no additional identification information is known about the physical entity or supported, the object is not instantiated.
A zero length octet string may also be returned in this case.
REFERENCE "RFC 3986, Uniform Resource Identifiers (URI):
"This table contains one row per logical entity.
For agents that implement more than one naming scope, at least one entry must exist.
Agents which instantiate all MIB objects within a single naming scope are not required to implement this table."
current DESCRIPTION "Information about a particular logical entity.
Entities may be managed by this agent or other SNMP agents (possibly) in the same chassis.
"The value of this object uniquely identifies the logical entity.
The value should be a small positive integer; index values for different logical entities are not necessarily contiguous."
"A textual description of the logical entity.
This object should contain a string that identifies the manufacturer's name for the logical entity, and should be set to a distinct value for each version of the logical entity."
"An indication of the type of logical entity.
This will typically be the OBJECT IDENTIFIER name of the node in the SMI's naming hierarchy which represents the major MIB module, or the majority of the MIB modules, supported by the logical entity.
For example: a logical entity of a regular host/router   mib 2 a logical entity of a 802.1d bridge   dot1dBridge a logical entity of a 802.3 repeater
If an appropriate node in the SMI's naming hierarchy cannot be identified, the value 'mib 2' should be used."
MAX ACCESS  read only STATUS
deprecated DESCRIPTION "An SNMPv1 or SNMPv2C community string, which can be used to access detailed management information for this logical entity.
The agent should allow read access with this community string (to an appropriate subset of all managed objects) and may also return a community string based on the privileges of the request used to read this object.
Note that an agent may return a community string with read only privileges, even if this object is accessed with a read write community string.
However, the agent must take care not to return a community string that allows more privileges than the community string used to access this object.
A compliant SNMP agent may wish to conserve naming scopes by representing multiple logical entities in a single 'default' naming scope.
This is possible when the logical entities, represented by the same value of entLogicalCommunity, have no object instances in common.
For example, 'bridge1' and 'repeater1' may be part of the main naming scope, but at least one additional community string is needed to represent 'bridge2' and 'repeater2'.
Logical entities 'bridge1' and 'repeater1' would be represented by sysOREntries associated with the 'default' naming scope.
For agents not accessible via SNMPv1 or SNMPv2C, the value of this object is the empty string.
This object may also contain an empty string if a community string has not yet been assigned by the agent, or if no community string with suitable access rights can be returned for a particular SNMP request.
Note that this object is deprecated.
Agents which implement SNMPv3 access should use the entLogicalContextEngineID and entLogicalContextName objects to identify the context associated with each logical entity.
SNMPv3 agents may return a zero length string for this object, or may continue to return a community string (e.g., tri lingual agent support)."
The transport service address by which the logical entity receives network management traffic, formatted according to the corresponding value of entLogicalTDomain.
For snmpUDPDomain, a TAddress is 6 octets long: the initial 4 octets contain the IP address in network byte order and the last 2 contain the UDP port in network byte order.
Consult 'Transport Mappings for the Simple Network Management Protocol' (STD 62, RFC 3417 [RFC3417]) for further information on snmpUDPDomain."
"Indicates the kind of transport service by which the logical entity receives network management traffic.
Possible values for this object are presently found in the Transport Mappings for Simple Network Management Protocol' (STD 62, RFC 3417 [RFC3417])."
The authoritative contextEngineID that can be used to send an SNMP message concerning information held by this logical entity, to the address specified by the associated 'entLogicalTAddress/entLogicalTDomain' pair.
This object, together with the associated entLogicalContextName object, defines the context associated with a particular logical entity, and allows access to SNMP engines identified by a contextEngineId and contextName pair.
If no value has been configured by the agent, a zero length string is returned, or the agent may choose not to instantiate this object at all."
The contextName that can be used to send an SNMP message concerning information held by this logical entity, to the address specified by the associated 'entLogicalTAddress/entLogicalTDomain' pair.
This object, together with the associated entLogicalContextEngineID object, defines the context associated with a particular logical entity, and allows access to SNMP engines identified by a contextEngineId and contextName pair.
If no value has been configured by the agent, a zero length string is returned, or the agent may choose not to instantiate this object at all."
"This table contains zero or more rows of logical entity to physical equipment associations.
For each logical entity known by this agent, there are zero or more mappings to the physical resources, which are used to realize that logical entity.
An agent should limit the number and nature of entries in this table such that only meaningful and non redundant information is returned.
For example, in a system that contains a single power supply, mappings between logical entities and the power supply are not useful and should not be included.
Also, only the most appropriate physical component, which is closest to the root of a particular containment tree, should be identified in an entLPMapping entry.
For example, suppose a bridge is realized on a particular module, and all ports on that module are ports on this bridge.
A mapping between the bridge and the module would be useful, but additional mappings between the bridge and each of the ports on that module would be redundant (because the entPhysicalContainedIn hierarchy can provide the same information).
On the other hand, if more than one bridge were utilizing ports on this module, then mappings between each bridge and the ports it used would be appropriate.
Also, in the case of a single backplane repeater, a mapping for the backplane to the single repeater entity is not necessary."
current DESCRIPTION "Information about a particular logical entity to physical equipment association.
Note that the nature of the association is not specifically identified in this entry.
It is expected that sufficient information exists in the MIBs used to manage a particular logical entity to infer how physical component information is utilized.
"The value of this object identifies the index value of a particular entPhysicalEntry associated with the indicated entLogicalEntity."
"This table contains zero or more rows, representing mappings of logical entity and physical component to external MIB identifiers.
Each physical port in the system may be associated with a mapping to an external identifier, which itself is associated with a particular logical entity's naming scope.
A 'wildcard' mechanism is provided to indicate that an identifier is associated with more than one logical entity."
current DESCRIPTION "Information about a particular physical equipment, logical entity to external identifier binding.
Each logical entity/physical component pair may be associated with one alias mapping.
The logical entity index may also be used as a 'wildcard' (refer to the entAliasLogicalIndexOrZero object DESCRIPTION clause for details.)
Note that only entPhysicalIndex values that represent physical ports (i.e., associated entPhysicalClass value is 'port(10)') are permitted to exist in this table.
"The value of this object identifies the logical entity that defines the naming scope for the associated instance of the 'entAliasMappingIdentifier' object.
If this object has a non zero value, then it identifies the logical entity named by the same value of entLogicalIndex.
If this object has a value of zero, then the mapping between the physical component and the alias identifier for this entAliasMapping entry is associated with all unspecified logical entities.
That is, a value of zero (the default mapping) identifies any logical entity that does not have an explicit entry in this table for a particular entPhysicalIndex/entAliasMappingIdentifier pair.
For example, to indicate that a particular interface (e.g., physical component 33) is identified by the same value of ifIndex for all logical entities, the following instance might exist:
In the event an entPhysicalEntry is associated differently for some logical entities, additional entAliasMapping entries may exist, e.g.:
entAliasMappingIdentifier.33.10   ifIndex.12 Note that entries with non zero entAliasLogicalIndexOrZero index values have precedence over zero indexed entries.
In this example, all logical entities except 4, 5, and 10, associate physical entity 33 with ifIndex.6."
"The value of this object identifies a particular conceptual row associated with the indicated entPhysicalIndex and entLogicalIndex pair.
Because only physical ports are modeled in this table, only entries that represent interfaces or ports are allowed.
If an ifEntry exists on behalf of a particular physical port, then this object should identify the associated 'ifEntry'.
For repeater ports, the appropriate row in the 'rptrPortGroupTable' should be identified instead.
For example, suppose a physical port was represented by entPhysicalEntry.3
, entLogicalEntry.15 existed for a repeater, and entLogicalEntry.22 existed for a bridge.
Then there might be two related instances of entAliasMappingIdentifier: entAliasMappingIdentifier.3.15   rptrPortGroupIndex.5.2 entAliasMappingIdentifier.3.22
It is possible that other mappings (besides interfaces and repeater ports) may be defined in the future, as required.
Bridge ports are identified by examining the Bridge MIB and appropriate ifEntries associated with each 'dot1dBasePort', and are thus not represented in this table."
SEQUENCE OF EntPhysicalContainsEntry MAX ACCESS
A table that exposes the container/'containee' relationships between physical entities.
This table provides all the information found by constructing the virtual containment tree for a given entPhysicalTable, but in a more direct format.
In the event a physical entity is contained by more than one other physical entity (e.g., double wide modules), this table should include these additional mappings, which cannot be represented in the entPhysicalTable virtual containment tree."
current DESCRIPTION "A single container/'containee' relationship.
"The value of entPhysicalIndex for the contained physical entity."
"An entConfigChange notification is generated when the value of entLastChangeTime changes.
It can be utilized by an NMS to trigger logical/physical entity table maintenance polls.
An agent should not generate more than one entConfigChange 'notification event' in a given time interval (five seconds is the suggested default).
A 'notification event' is the transmission of a single trap or inform PDU to a list of notification destinations.
If additional configuration changes occur within the throttling period, then notification events for these changes should be suppressed by the agent until the current throttling period expires.
At the end of a throttling period, one notification event should be generated if any configuration changes occurred since the start of the throttling period.
In such a case, another throttling period is started right away.
An NMS should periodically check the value of entLastChangeTime to detect any missed entConfigChange notification events, e.g., due to throttling or transmission loss."
compliance statements entityCompliance MODULE COMPLIANCE STATUS
The compliance statement for SNMP entities that implement version 1 of the Entity MIB."
The compliance statement for SNMP entities that implement version 2 of the Entity MIB."
MODULE    this module MANDATORY GROUPS { entityPhysicalGroup, entityPhysical2Group
, entityGeneralGroup, entityNotificationsGroup } GROUP entityLogical2Group DESCRIPTION "Implementation of this group is not mandatory for agents that model all MIB object instances within a single naming scope."
GROUP entityMappingGroup DESCRIPTION "Implementation of the entPhysicalContainsTable is mandatory for all agents.
Implementation of the entLPMappingTable and entAliasMappingTables are not mandatory for agents that model all MIB object instances within a single naming scope.
Note that the entAliasMappingTable may be useful for all agents; however, implementation of the entityLogicalGroup or entityLogical2Group is required to support this table."
"Read and write access is not required for agents that cannot identify serial number information for physical entities, and/or cannot provide non volatile storage for NMS assigned serial numbers.
Write access is not required for agents that can identify serial number information for physical entities, but cannot provide non volatile storage for NMS assigned serial numbers.
Write access is not required for physical entities for which the associated value of the entPhysicalIsFRU object is equal to 'false(2)'.
"Write access is required only if the associated entPhysicalClass value is equal to 'chassis(3)'.
"Read and write access is not required for agents that cannot provide non volatile storage for NMS assigned asset identifiers.
Write access is not required for physical entities for which the associated value of the entPhysicalIsFRU object is equal to 'false(2)'.
OBJECT entPhysicalClass SYNTAX INTEGER { other(1), unknown(2)
, fan(7), sensor(8), module(9), port(10)
) } DESCRIPTION "Implementation of the 'cpu(12)' enumeration is not required."
MODULE COMPLIANCE STATUS  current DESCRIPTION
"The compliance statement for SNMP entities that implement version 3 of the Entity MIB."
MODULE    this module MANDATORY GROUPS { entityPhysicalGroup, entityPhysical2Group, entityPhysical3Group
, entityGeneralGroup, entityNotificationsGroup } GROUP entityLogical2Group DESCRIPTION "Implementation of this group is not mandatory for agents that model all MIB object instances within a single naming scope."
GROUP entityMappingGroup DESCRIPTION "Implementation of the entPhysicalContainsTable is mandatory for all agents.
Implementation of the entLPMappingTable and entAliasMappingTables are not mandatory for agents that model all MIB object instances within a single naming scope.
Note that the entAliasMappingTable may be useful for all agents; however, implementation of the entityLogicalGroup or entityLogical2Group is required to support this table."
"Read and write access is not required for agents that cannot identify serial number information for physical entities, and/or cannot provide non volatile storage for NMS assigned serial numbers.
Write access is not required for agents that can identify serial number information for physical entities, but cannot provide non volatile storage for NMS assigned serial numbers.
Write access is not required for physical entities for which the associated value of the entPhysicalIsFRU object is equal to 'false(2)'.
"Write access is required only if the associated entPhysicalClass value is equal to 'chassis(3)'.
"Read and write access is not required for agents that cannot provide non volatile storage for NMS assigned asset identifiers.
Write access is not required for physical entities for which the associated value of entPhysicalIsFRU is equal to 'false(2)'.
OBJECT GROUP OBJECTS { entPhysicalDescr, entPhysicalVendorType, entPhysicalContainedIn, entPhysicalClass, entPhysicalParentRelPos,
entPhysicalName } STATUS  current DESCRIPTION
"The collection of objects used to represent physical system components, for which a single agent provides management information."
OBJECT GROUP OBJECTS { entLastChangeTime
"The collection of objects used to represent general entity information, for which a single agent provides management information."
The collection of notifications used to indicate Entity MIB data consistency and general status information."
OBJECT GROUP OBJECTS { entPhysicalHardwareRev, entPhysicalFirmwareRev, entPhysicalSoftwareRev, entPhysicalSerialNum, entPhysicalMfgName, entPhysicalModelName,
entPhysicalAlias, entPhysicalAssetID, entPhysicalIsFRU } STATUS  current DESCRIPTION
"The collection of objects used to represent physical system components, for which a single agent provides management information.
OBJECT GROUP OBJECTS { entLogicalDescr, entLogicalType, entLogicalTAddress, entLogicalTDomain, entLogicalContextEngineID, entLogicalContextName } STATUS  current DESCRIPTION
"The collection of objects used to represent the list of logical entities, for which a single SNMP entity provides management information."
OBJECT GROUP OBJECTS { entPhysicalMfgDate, entPhysicalUris } STATUS  current DESCRIPTION
"The collection of objects used to represent physical system components, for which a single agent provides management information.
The following sections iterate the instance values for two example networking devices.
These examples are kept simple to make them more understandable.
Auxiliary components such as fans, sensors, empty slots, and sub modules are not shown, but might be modeled in real implementations.
The first example is a router containing two slots.
Each slot contains a 3 port router/bridge module.
Each port is represented in the ifTable.
There are two logical instances of OSPF running and two logical bridges:
Physical entities   entPhysicalTable: 1 Field replaceable physical chassis:
CNME120ARA' 2 slots within the chassis
entLogicalTable; no SNMPv3 support 2 OSPF instances:
: uses module 2 port 1 entLPPhysicalIndex.2.9
9 1st bridge group: uses module 1, all ports [ed.
Note that these mappings are included in the table because another logical entity (1st OSPF) utilizes one of the ports.
If this were not the case, then a single mapping to the module (e.g., entLPPhysicalIndex.3.4) would be present instead.]
11 Physical to Logical to MIB Alias Mappings
ifIndex values are global to all logical entities
ifIndex values are not shared by all logical entities; (Bridge 1 uses ifIndex values 101 103 and Bridge 2 uses ifIndex values 204 206.)
7 module 2 has 3 ports: entPhysicalChildIndex.8.9
The second example is a 3 slot Hub with 2 backplane ethernet segments.
Slot three is empty, and the remaining slots contain ethernet repeater modules.
Note that this example assumes an older Repeater MIB implementation, (RFC 1516 [RFC1516]) rather than the new Repeater MIB (RFC 2108 [RFC2108]).
The new version contains an object called 'rptrPortRptrId', which should be used to identify repeater port groupings, rather than using community strings or contexts.
Physical entities   entPhysicalTable: 1 Field replaceable physical chassis:
) 2 Chassis Ethernet Backplanes:
Acme Ethernet Backplane Type A'
3 slots within the chassis:
Slot 1 contains a plug in module with 4 10 BaseT ports:
'Acme 10Base T Port RB'
Slot 2 contains another ethernet module with 2 ports.
'Acme 10Base T Module Model 4'
: repeater1 uses backplane 1, slot 1 ports 1 & 2, slot 2 port
Note that a mapping to the module is not included, because this example represents a port switchable hub.
Even though all ports on the module could belong to the same repeater as a matter of configuration, the LP port mappings should not be replaced dynamically with a single mapping for the module (e.g., entLPPhysicalIndex.1.7).
If all ports on the module shared a single backplane connection, then a single mapping for the module would be more appropriate.]
slot 1 ports 3 & 4, slot 2 port 2 entLPPhysicalIndex.2.3
Physical to Logical to MIB Alias Mappings
6 container 1 has a module: entPhysicalChildIndex.4.7
7 container 2 has a module entPhysicalChildIndex.5.12
in this example, container 3 is empty.]
module 1 has 4 ports: entPhysicalChildIndex.7.8
10 entPhysicalChildIndex.7.11    11 module 2 has 2 ports:
There are a number of management objects defined in this MIB that have a MAX ACCESS clause of read write and/or read create.
Such objects may be considered sensitive or vulnerable in some network environments.
The support for SET operations in a non secure environment without proper protection can have a negative effect on network operations.
There are a number of managed objects in this MIB that may contain sensitive information.
These are: entPhysicalDescr entPhysicalVendorType entPhysicalHardwareRev entPhysicalFirmwareRev entPhysicalSoftwareRev entPhysicalSerialNum
These objects expose information about the physical entities within a managed system, which may be used to identify the vendor, model, and version information of each system component.
This object can allow asset identifiers for various system components to be exposed, in the event this MIB object is actually configured by an NMS application.
entLogicalType These objects expose the type of logical entities present in the managed system.
entLogicalCommunity This object exposes community names associated with particular logical entities within the system.
entLogicalTAddress entLogicalTDomain These objects expose network addresses that can be used to communicate with an SNMP agent on behalf of particular logical entities within the system.
These objects identify the authoritative SNMP engine that contains information on behalf of particular logical entities within the system.
It is thus important to control even GET access to these objects and possibly to even encrypt the values of these object when sending them over the network via SNMP.
Not all versions of SNMP provide features for such a secure environment.
by itself is not a secure environment.
Even if the network itself is secure (for example by using IPSec), even then, there is no control as to who on the secure network is allowed to access and
the objects in this MIB.
It is recommended that the implementers consider the security features as provided by the SNMPv3 framework.
Specifically, the use of the User based Security Model RFC 3414 [RFC3414] and the View based Access Control Model RFC 3415 [RFC3415] is recommended.
It is then a customer/user responsibility to ensure that the SNMP entity giving access to an instance of this MIB, is properly configured to give access to the objects only to those principals (users) that have legitimate rights to indeed GET or SET
The MIB module in this document uses the following IANA assigned OBJECT IDENTIFIER values recorded in the SMI Numbers registry:
