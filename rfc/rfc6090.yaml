- title: __initial_text__
  contents:
  - '           Fundamental Elliptic Curve Cryptography Algorithms

    '
- title: Abstract
  contents:
  - "Abstract\n   This note describes the fundamental algorithms of Elliptic Curve\n\
    \   Cryptography (ECC) as they were defined in some seminal references\n   from\
    \ 1994 and earlier.  These descriptions may be useful for\n   implementing the\
    \ fundamental algorithms without using any of the\n   specialized methods that\
    \ were developed in following years.  Only\n   elliptic curves defined over fields\
    \ of characteristic greater than\n   three are in scope; these curves are those\
    \ used in Suite B.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc6090.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  3\n     1.1.  Conventions Used in This Document  . . . . . . .\
    \ . . . . .  4\n   2.  Mathematical Background  . . . . . . . . . . . . . . .\
    \ . . . .  4\n     2.1.  Modular Arithmetic . . . . . . . . . . . . . . . . .\
    \ . . .  4\n     2.2.  Group Operations . . . . . . . . . . . . . . . . . . .\
    \ . .  5\n     2.3.  The Finite Field Fp  . . . . . . . . . . . . . . . . . .\
    \ .  6\n   3.  Elliptic Curve Groups  . . . . . . . . . . . . . . . . . . . .\
    \  7\n     3.1.  Homogeneous Coordinates  . . . . . . . . . . . . . . . . .  8\n\
    \     3.2.  Other Coordinates  . . . . . . . . . . . . . . . . . . . .  9\n  \
    \   3.3.  ECC Parameters . . . . . . . . . . . . . . . . . . . . . .  9\n    \
    \   3.3.1.  Discriminant . . . . . . . . . . . . . . . . . . . . . 10\n      \
    \ 3.3.2.  Security . . . . . . . . . . . . . . . . . . . . . . . 10\n   4.  Elliptic\
    \ Curve Diffie-Hellman (ECDH) . . . . . . . . . . . . . 10\n     4.1.  Data Types\
    \ . . . . . . . . . . . . . . . . . . . . . . . . 11\n     4.2.  Compact Representation\
    \ . . . . . . . . . . . . . . . . . . 11\n   5.  Elliptic Curve ElGamal Signatures\
    \  . . . . . . . . . . . . . . 11\n     5.1.  Background . . . . . . . . . . .\
    \ . . . . . . . . . . . . . 11\n     5.2.  Hash Functions . . . . . . . . . .\
    \ . . . . . . . . . . . . 12\n     5.3.  KT-IV Signatures . . . . . . . . . .\
    \ . . . . . . . . . . . 12\n       5.3.1.  Keypair Generation . . . . . . . .\
    \ . . . . . . . . . . 12\n       5.3.2.  Signature Creation . . . . . . . . .\
    \ . . . . . . . . . 13\n       5.3.3.  Signature Verification . . . . . . . .\
    \ . . . . . . . . 13\n     5.4.  KT-I Signatures  . . . . . . . . . . . . . .\
    \ . . . . . . . 14\n       5.4.1.  Keypair Generation . . . . . . . . . . . .\
    \ . . . . . . 14\n       5.4.2.  Signature Creation . . . . . . . . . . . . .\
    \ . . . . . 14\n       5.4.3.  Signature Verification . . . . . . . . . . . .\
    \ . . . . 14\n     5.5.  Converting KT-IV Signatures to KT-I Signatures . . .\
    \ . . . 15\n     5.6.  Rationale  . . . . . . . . . . . . . . . . . . . . . .\
    \ . . 15\n   6.  Converting between Integers and Octet Strings  . . . . . . .\
    \ . 16\n     6.1.  Octet-String-to-Integer Conversion . . . . . . . . . . . .\
    \ 17\n     6.2.  Integer-to-Octet-String Conversion . . . . . . . . . . . . 17\n\
    \   7.  Interoperability . . . . . . . . . . . . . . . . . . . . . . . 17\n  \
    \   7.1.  ECDH . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n    \
    \ 7.2.  KT-I and ECDSA . . . . . . . . . . . . . . . . . . . . . . 18\n   8. \
    \ Validating an Implementation . . . . . . . . . . . . . . . . . 18\n     8.1.\
    \  ECDH . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n     8.2.  KT-I\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n   9.  Intellectual\
    \ Property  . . . . . . . . . . . . . . . . . . . . 20\n     9.1.  Disclaimer\
    \ . . . . . . . . . . . . . . . . . . . . . . . . 20\n   10. Security Considerations\
    \  . . . . . . . . . . . . . . . . . . . 21\n     10.1. Subgroups  . . . . . .\
    \ . . . . . . . . . . . . . . . . . . 21\n     10.2. Diffie-Hellman . . . . .\
    \ . . . . . . . . . . . . . . . . . 22\n     10.3. Group Representation and Security\
    \  . . . . . . . . . . . . 22\n     10.4. Signatures . . . . . . . . . . . . .\
    \ . . . . . . . . . . . 23\n   11. Acknowledgements . . . . . . . . . . . . .\
    \ . . . . . . . . . . 23\n   12. References . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . 23\n     12.1. Normative References . . . . . . . . . . .\
    \ . . . . . . . . 23\n     12.2. Informative References . . . . . . . . . . .\
    \ . . . . . . . 25\n   Appendix A.  Key Words . . . . . . . . . . . . . . . .\
    \ . . . . . . 29\n   Appendix B.  Random Integer Generation . . . . . . . . .\
    \ . . . . . 29\n   Appendix C.  Why Compact Representation Works  . . . . . .\
    \ . . . . 30\n   Appendix D.  Example ECC Parameter Set . . . . . . . . . . .\
    \ . . . 31\n   Appendix E.  Additive and Multiplicative Notation  . . . . . .\
    \ . . 32\n   Appendix F.  Algorithms  . . . . . . . . . . . . . . . . . . . .\
    \ . 32\n     F.1.  Affine Coordinates . . . . . . . . . . . . . . . . . . . .\
    \ 32\n     F.2.  Homogeneous Coordinates  . . . . . . . . . . . . . . . . . 33\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   ECC is a public-key technology that offers performance advantages\
    \ at\n   higher security levels.  It includes an elliptic curve version of the\n\
    \   Diffie-Hellman key exchange protocol [DH1976] and elliptic curve\n   versions\
    \ of the ElGamal Signature Algorithm [E1985].  The adoption of\n   ECC has been\
    \ slower than had been anticipated, perhaps due to the\n   lack of freely available\
    \ normative documents and uncertainty over\n   intellectual property rights.\n\
    \   This note contains a description of the fundamental algorithms of ECC\n  \
    \ over finite fields with characteristic greater than three, based\n   directly\
    \ on original references.  Its intent is to provide the\n   Internet community\
    \ with a summary of the basic algorithms that\n   predate any specialized or optimized\
    \ algorithms.  The summary is\n   detailed enough for use as a normative reference.\
    \  The original\n   descriptions and notations were followed as closely as possible.\n\
    \   There are several standards that specify or incorporate ECC\n   algorithms,\
    \ including the Internet Key Exchange (IKE), ANSI X9.62,\n   and IEEE P1363. \
    \ The algorithms in this note can interoperate with\n   some of the algorithms\
    \ in these standards, with a suitable choice of\n   parameters and options.  The\
    \ specifics are itemized in Section 7.\n   The rest of the note is organized as\
    \ follows.  Sections 2.1, 2.2, and\n   2.3 furnish the necessary terminology and\
    \ notation from modular\n   arithmetic, group theory, and the theory of finite\
    \ fields,\n   respectively.  Section 3 defines the groups based on elliptic curves\n\
    \   over finite fields of characteristic greater than three.  Section 4\n   presents\
    \ the fundamental Elliptic Curve Diffie-Hellman (ECDH)\n   algorithm.  Section\
    \ 5 presents elliptic curve versions of the ElGamal\n   signature method.  The\
    \ representation of integers as octet strings is\n   specified in Section 6. \
    \ Sections 2 through 6, inclusive, contain all\n   of the normative text (the\
    \ text that defines the norm for\n   implementations conforming to this specification),\
    \ and all of the\n   following sections are purely informative.  Interoperability\
    \ is\n   discussed in Section 7.  Validation testing is described in\n   Section\
    \ 8.  Section 9 reviews intellectual property issues.\n   Section 10 summarizes\
    \ security considerations.  Appendix B describes\n   random number generation,\
    \ and other appendices provide clarifying\n   details.\n"
- title: 1.1.  Conventions Used in This Document
  contents:
  - "1.1.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in Appendix A.\n"
- title: 2.  Mathematical Background
  contents:
  - "2.  Mathematical Background\n   This section reviews mathematical preliminaries\
    \ and establishes\n   terminology and notation that are used below.\n"
- title: 2.1.  Modular Arithmetic
  contents:
  - "2.1.  Modular Arithmetic\n   This section reviews modular arithmetic.  Two integers\
    \ x and y are\n   said to be congruent modulo n if x - y is an integer multiple\
    \ of n.\n   Two integers x and y are coprime when their greatest common divisor\n\
    \   is 1; in this case, there is no third number z > 1 such that z\n   divides\
    \ x and z divides y.\n   The set Zq = { 0, 1, 2, ..., q-1 } is closed under the\
    \ operations of\n   modular addition, modular subtraction, modular multiplication,\
    \ and\n   modular inverse.  These operations are as follows.\n      For each pair\
    \ of integers a and b in Zq, a + b mod q is equal to\n      a + b if a + b < q,\
    \ and is equal to a + b - q otherwise.\n      For each pair of integers a and\
    \ b in Zq, a - b mod q is equal to\n      a - b if a - b >= 0, and is equal to\
    \ a - b + q otherwise.\n      For each pair of integers a and b in Zq, a * b mod\
    \ q is equal to\n      the remainder of a * b divided by q.\n      For each integer\
    \ x in Zq that is coprime with q, the inverse of x\n      modulo q is denoted\
    \ as 1/x mod q, and can be computed using the\n      extended Euclidean algorithm\
    \ (see Section 4.5.2 of [K1981v2], for\n      example).\n   Algorithms for these\
    \ operations are well known; for instance, see\n   Chapter 4 of [K1981v2].\n"
- title: 2.2.  Group Operations
  contents:
  - "2.2.  Group Operations\n   This section establishes some terminology and notation\
    \ for\n   mathematical groups, which are needed later on.  Background\n   references\
    \ abound; see [D1966], for example.\n   A group is a set of elements G together\
    \ with an operation that\n   combines any two elements in G and returns a third\
    \ element in G.  The\n   operation is denoted as * and its application is denoted\
    \ as a * b,\n   for any two elements a and b in G.  The operation is associative,\n\
    \   that is, for all a, b, and c in G, a * (b * c) is identical to (a *\n   b)\
    \ * c.  Repeated application of the group operation N-1 times to the\n   element\
    \ a is denoted as a^N, for any element a in G and any positive\n   integer N.\
    \  That is, a^2 = a * a, a^3 = a * a * a, and so on.  The\n   associativity of\
    \ the group operation ensures that the computation of\n   a^n is unambiguous;\
    \ any grouping of the terms gives the same result.\n   The above definition of\
    \ a group operation uses multiplicative\n   notation.  Sometimes an alternative\
    \ called additive notation is used,\n   in which a * b is denoted as a + b, and\
    \ a^N is denoted as N * a.  In\n   multiplicative notation, a^N is called exponentiation,\
    \ while the\n   equivalent operation in additive notation is called scalar\n \
    \  multiplication.  In this document, multiplicative notation is used\n   throughout\
    \ for consistency.  Appendix E elucidates the correspondence\n   between the two\
    \ notations.\n   Every group has a special element called the identity element,\
    \ which\n   we denote as e.  For each element a in G, e * a = a * e = a.  By\n\
    \   convention, a^0 is equal to the identity element for any a in G.\n   Every\
    \ group element a has a unique inverse element b such that\n   a * b = b * a =\
    \ e.  The inverse of a is denoted as a^-1 in\n   multiplicative notation.  (In\
    \ additive notation, the inverse of a is\n   denoted as -a.)\n   For any positive\
    \ integer X, a^(-X) is defined to be (a^-1)^(X).\n   Using this convention, exponentiation\
    \ behaves as one would expect,\n   namely for any integers X and Y:\n      a^(X+Y)\
    \ = (a^X)*(a^Y)\n      (a^X)^Y = a^(XY) = (a^Y)^X.\n   In cryptographic applications,\
    \ one typically deals with finite groups\n   (groups with a finite number of elements),\
    \ and for such groups, the\n   number of elements of the group is also called\
    \ the order of the\n   group.  A group element a is said to have finite order\
    \ if a^X = e for\n   some positive integer X, and the order of a is the smallest\
    \ such X.\n   If no such X exists, a is said to have infinite order.  All elements\n\
    \   of a finite group have a finite order, and the order of an element is\n  \
    \ always a divisor of the group order.\n   If a group element a has order R, then\
    \ for any integers X and Y,\n      a^X = a^(X mod R),\n      a^X = a^Y if and\
    \ only if X is congruent to Y mod R,\n      the set H = { a, a^2, a^3, ... , a^R=e\
    \ } forms a subgroup of G,\n      called the cyclic subgroup generated by a, and\
    \ a is said to be a\n      generator of H.\n   Typically, there are several group\
    \ elements that generate H.  Any\n   group element of the form a^M, with M relatively\
    \ prime to R, also\n   generates H.  Note that a^M is equal to g^(M modulo R)\
    \ for any non-\n   negative integer M.\n   Given the element a of order R, and\
    \ an integer i between 1 and R-1,\n   inclusive, the element a^i can be computed\
    \ by the \"square and\n   multiply\" method outlined in Section 2.1 of [M1983]\
    \ (see also Knuth,\n   Vol. 2, Section 4.6.3), or other methods.\n"
- title: 2.3.  The Finite Field Fp
  contents:
  - "2.3.  The Finite Field Fp\n   This section establishes terminology and notation\
    \ for finite fields\n   with prime characteristic.\n   When p is a prime number,\
    \ then the set Zp, with the addition,\n   subtraction, multiplication, and division\
    \ operations, is a finite\n   field with characteristic p.  Each nonzero element\
    \ x in Zp has an\n   inverse 1/x.  There is a one-to-one correspondence between\
    \ the\n   integers between zero and p-1, inclusive, and the elements of the\n\
    \   field.  The field Zp is sometimes denoted as Fp or GF(p).\n   Equations involving\
    \ field elements do not explicitly denote the \"mod\n   p\" operation, but it\
    \ is understood to be implicit.  For example, the\n   statement that x, y, and\
    \ z are in Fp and\n      z = x + y\n   is equivalent to the statement that x,\
    \ y, and z are in the set\n   { 0, 1, ..., p-1 } and\n      z = x + y mod p.\n"
- title: 3.  Elliptic Curve Groups
  contents:
  - "3.  Elliptic Curve Groups\n   This note only covers elliptic curves over fields\
    \ with characteristic\n   greater than three; these are the curves used in Suite\
    \ B [SuiteB].\n   For other fields, the definition of the elliptic curve group\
    \ would be\n   different.\n   An elliptic curve over a field Fp is defined by\
    \ the curve equation\n      y^2 = x^3 + a*x + b,\n   where x, y, a, and b are\
    \ elements of the field Fp [M1985], and the\n   discriminant is nonzero (as described\
    \ in Section 3.3.1).  A point on\n   an elliptic curve is a pair (x,y) of values\
    \ in Fp that satisfies the\n   curve equation, or it is a special point (@,@)\
    \ that represents the\n   identity element (which is called the \"point at infinity\"\
    ).  The\n   order of an elliptic curve group is the number of distinct points.\n\
    \   Two elliptic curve points (x1,y1) and (x2,y2) are equal whenever\n   x1=x2\
    \ and y1=y2, or when both points are the point at infinity.  The\n   inverse of\
    \ the point (x1,y1) is the point (x1,-y1).  The point at\n   infinity is its own\
    \ inverse.\n   The group operation associated with the elliptic curve group is\
    \ as\n   follows [BC1989].  To an arbitrary pair of points P and Q specified\n\
    \   by their coordinates (x1,y1) and (x2,y2), respectively, the group\n   operation\
    \ assigns a third point P*Q with the coordinates (x3,y3).\n   These coordinates\
    \ are computed as follows:\n      (x3,y3) = (@,@) when P is not equal to Q and\
    \ x1 is equal to x2.\n      x3 = ((y2-y1)/(x2-x1))^2 - x1 - x2 and\n      y3 =\
    \ (x1-x3)*(y2-y1)/(x2-x1) - y1 when P is not equal to Q and\n      x1 is not equal\
    \ to x2.\n      (x3,y3) = (@,@) when P is equal to Q and y1 is equal to 0.\n \
    \     x3 = ((3*x1^2 + a)/(2*y1))^2 - 2*x1 and\n      y3 = (x1-x3)*(3*x1^2 + a)/(2*y1)\
    \ - y1 if P is equal to Q and y1 is\n      not equal to 0.\n   In the above equations,\
    \ a, x1, x2, x3, y1, y2, and y3 are elements of\n   the field Fp; thus, computation\
    \ of x3 and y3 in practice must reduce\n   the right-hand-side modulo p.  Pseudocode\
    \ for the group operation is\n   provided in Appendix F.1.\n   The representation\
    \ of elliptic curve points as a pair of integers in\n   Zp is known as the affine\
    \ coordinate representation.  This\n   representation is suitable as an external\
    \ data representation for\n   communicating or storing group elements, though\
    \ the point at infinity\n   must be treated as a special case.\n   Some pairs\
    \ of integers are not valid elliptic curve points.  A valid\n   pair will satisfy\
    \ the curve equation, while an invalid pair will not.\n"
- title: 3.1.  Homogeneous Coordinates
  contents:
  - "3.1.  Homogeneous Coordinates\n   An alternative way to implement the group operation\
    \ is to use\n   homogeneous coordinates [K1987] (see also [KMOV1991]).  This method\n\
    \   is typically more efficient because it does not require a modular\n   inversion\
    \ operation.\n   An elliptic curve point (x,y) (other than the point at infinity\n\
    \   (@,@)) is equivalent to a point (X,Y,Z) in homogeneous coordinates\n   whenever\
    \ x=X/Z mod p and y=Y/Z mod p.\n   Let P1=(X1,Y1,Z1) and P2=(X2,Y2,Z2) be points\
    \ on an elliptic curve,\n   and suppose that the points P1 and P2 are not equal\
    \ to (@,@), P1 is\n   not equal to P2, and P1 is not equal to P2^-1.  Then the\
    \ product\n   P3=(X3,Y3,Z3) = P1 * P2 is given by\n      X3 = v * (Z2 * (Z1 *\
    \ u^2 - 2 * X1 * v^2) - v^3) mod p\n      Y3 = Z2 * (3 * X1 * u * v^2 - Y1 * v^3\
    \ - Z1 * u^3) + u * v^3 mod p\n      Z3 = v^3 * Z1 * Z2 mod p\n   where u = Y2\
    \ * Z1 - Y1 * Z2 mod p and v = X2 * Z1 - X1 * Z2 mod p.\n   When the points P1\
    \ and P2 are equal, then (X1/Z1, Y1/Z1) is equal to\n   (X2/Z2, Y2/Z2), which\
    \ is true if and only if u and v are both equal\n   to zero.\n   The product P3=(X3,Y3,Z3)\
    \ = P1 * P1 is given by\n      X3 = 2 * Y1 * Z1 * (w^2 - 8 * X1 * Y1^2 * Z1) mod\
    \ p\n      Y3 = 4 * Y1^2 * Z1 * (3 * w * X1 - 2 * Y1^2 * Z1) - w^3 mod p\n   \
    \   Z3 = 8 * (Y1 * Z1)^3 mod p\n   where w = 3 * X1^2 + a * Z1^2 mod p.  In the\
    \ above equations, a, u,\n   v, w, X1, X2, X3, Y1, Y2, Y3, Z1, Z2, and Z3 are\
    \ integers in the set\n   Fp.  Pseudocode for the group operation in homogeneous\
    \ coordinates is\n   provided in Appendix F.2.\n   When converting from affine\
    \ coordinates to homogeneous coordinates,\n   it is convenient to set Z to 1.\
    \  When converting from homogeneous\n   coordinates to affine coordinates, it\
    \ is necessary to perform a\n   modular inverse to find 1/Z mod p.\n"
- title: 3.2.  Other Coordinates
  contents:
  - "3.2.  Other Coordinates\n   Some other coordinate systems have been described;\
    \ several are\n   documented in [CC1986], including Jacobi coordinates.\n"
- title: 3.3.  ECC Parameters
  contents:
  - "3.3.  ECC Parameters\n   In cryptographic contexts, an elliptic curve parameter\
    \ set consists\n   of a cyclic subgroup of an elliptic curve together with a preferred\n\
    \   generator of that subgroup.  When working over a prime order finite\n   field\
    \ with characteristic greater than three, an elliptic curve group\n   is completely\
    \ specified by the following parameters:\n      The prime number p that indicates\
    \ the order of the field Fp.\n      The value a used in the curve equation.\n\
    \      The value b used in the curve equation.\n      The generator g of the subgroup.\n\
    \      The order n of the subgroup generated by g.\n   An example of an ECC parameter\
    \ set is provided in Appendix D.\n   Parameter generation is out of scope for\
    \ this note.\n   Each elliptic curve point is associated with a particular parameter\n\
    \   set.  The elliptic curve group operation is only defined between two\n   points\
    \ in the same group.  It is an error to apply the group\n   operation to two elements\
    \ that are from different groups, or to apply\n   the group operation to a pair\
    \ of coordinates that is not a valid\n   point.  (A pair (x,y) of coordinates\
    \ in Fp is a valid point only when\n   it satisfies the curve equation.)  See\
    \ Section 10.3 for further\n   information.\n"
- title: 3.3.1.  Discriminant
  contents:
  - "3.3.1.  Discriminant\n   For each elliptic curve group, the discriminant -16*(4*a^3\
    \ + 27*b^2)\n   must be nonzero modulo p [S1986]; this requires that\n      4*a^3\
    \ + 27*b^2 != 0 mod p.\n"
- title: 3.3.2.  Security
  contents:
  - "3.3.2.  Security\n   Security is highly dependent on the choice of these parameters.\
    \  This\n   section gives normative guidance on acceptable choices.  See also\n\
    \   Section 10 for informative guidance.\n   The order of the group generated\
    \ by g MUST be divisible by a large\n   prime, in order to preclude easy solutions\
    \ of the discrete logarithm\n   problem [K1987].\n   With some parameter choices,\
    \ the discrete log problem is\n   significantly easier to solve.  This includes\
    \ parameter sets in which\n   b = 0 and p = 3 (mod 4), and parameter sets in which\
    \ a = 0 and\n   p = 2 (mod 3) [MOV1993].  These parameter choices are inferior\
    \ for\n   cryptographic purposes and SHOULD NOT be used.\n"
- title: 4.  Elliptic Curve Diffie-Hellman (ECDH)
  contents:
  - "4.  Elliptic Curve Diffie-Hellman (ECDH)\n   The Diffie-Hellman (DH) key exchange\
    \ protocol [DH1976] allows two\n   parties communicating over an insecure channel\
    \ to agree on a secret\n   key.  It was originally defined in terms of operations\
    \ in the\n   multiplicative group of a field with a large prime characteristic.\n\
    \   Massey [M1983] observed that it can be easily generalized so that it\n   is\
    \ defined in terms of an arbitrary cyclic group.  Miller [M1985] and\n   Koblitz\
    \ [K1987] analyzed the DH protocol over an elliptic curve\n   group.  We describe\
    \ DH following the former reference.\n   Let G be a group, and g be a generator\
    \ for that group, and let t\n   denote the order of G.  The DH protocol runs as\
    \ follows.  Party A\n   chooses an exponent j between 1 and t-1, inclusive, uniformly\
    \ at\n   random, computes g^j, and sends that element to B.  Party B chooses\n\
    \   an exponent k between 1 and t-1, inclusive, uniformly at random,\n   computes\
    \ g^k, and sends that element to A.  Each party can compute\n   g^(j*k); party\
    \ A computes (g^k)^j, and party B computes (g^j)^k.\n   See Appendix B regarding\
    \ generation of random integers.\n"
- title: 4.1.  Data Types
  contents:
  - "4.1.  Data Types\n   Each run of the ECDH protocol is associated with a particular\n\
    \   parameter set (as defined in Section 3.3), and the public keys g^j\n   and\
    \ g^k and the shared secret g^(j*k) are elements of the cyclic\n   subgroup associated\
    \ with the parameter set.\n   An ECDH private key z is an integer in Zt, where\
    \ t is the order of\n   the subgroup.\n"
- title: 4.2.  Compact Representation
  contents:
  - "4.2.  Compact Representation\n   As described in the final paragraph of [M1985],\
    \ the x-coordinate of\n   the shared secret value g^(j*k) is a suitable representative\
    \ for the\n   entire point whenever exponentiation is used as a one-way function.\n\
    \   In the ECDH key exchange protocol, after the element g^(j*k) has been\n  \
    \ computed, the x-coordinate of that value can be used as the shared\n   secret.\
    \  We call this compact output.\n   Following [M1985] again, when compact output\
    \ is used in ECDH, only\n   the x-coordinate of an elliptic curve point needs\
    \ to be transmitted,\n   instead of both coordinates as in the typical affine\
    \ coordinate\n   representation.  We call this the compact representation.  Its\n\
    \   mathematical background is explained in Appendix C.\n   ECDH can be used with\
    \ or without compact output.  Both parties in a\n   particular run of the ECDH\
    \ protocol MUST use the same method.  ECDH\n   can be used with or without compact\
    \ representation.  If compact\n   representation is used in a particular run of\
    \ the ECDH protocol, then\n   compact output MUST be used as well.\n"
- title: 5.  Elliptic Curve ElGamal Signatures
  contents:
  - '5.  Elliptic Curve ElGamal Signatures

    '
- title: 5.1.  Background
  contents:
  - "5.1.  Background\n   The ElGamal signature algorithm was introduced in 1984 [E1984a]\n\
    \   [E1984b] [E1985].  It is based on the discrete logarithm problem, and\n  \
    \ was originally defined for the multiplicative group of the integers\n   modulo\
    \ a large prime number.  It is straightforward to extend it to\n   use other finite\
    \ groups, such as the multiplicative group of the\n   finite field GF(2^w) [AMV1990]\
    \ or an elliptic curve group [A1992].\n   An ElGamal signature consists of a pair\
    \ of components.  There are\n   many possible generalizations of ElGamal signature\
    \ methods that have\n   been obtained by different rearrangements of the equation\
    \ for the\n   second component; see [HMP1994], [HP1994], [NR1994], [A1992], and\n\
    \   [AMV1990].  These generalizations are independent of the mathematical\n  \
    \ group used, and have been described for the multiplicative group\n   modulo\
    \ a prime number, the multiplicative group of GF(2^w), and\n   elliptic curve\
    \ groups [HMP1994] [NR1994] [AMV1990] [A1992].\n   The Digital Signature Algorithm\
    \ (DSA) [FIPS186] is an important\n   ElGamal signature variant.\n"
- title: 5.2.  Hash Functions
  contents:
  - "5.2.  Hash Functions\n   ElGamal signatures must use a collision-resistant hash\
    \ function, so\n   that it can sign messages of arbitrary length and can avoid\n\
    \   existential forgery attacks; see Section 10.4.  (This is true for all\n  \
    \ ElGamal variants [HMP1994].)  We denote the hash function as h().\n   Its input\
    \ is a bit string of arbitrary length, and its output is a\n   non-negative integer.\n\
    \   Let H() denote a hash function whose output is a fixed-length bit\n   string.\
    \  To use H in an ElGamal signature method, we define the\n   mapping between\
    \ that output and the non-negative integers; this\n   realizes the function h()\
    \ described above.  Given a bit string m, the\n   function h(m) is computed as\
    \ follows:\n   1.  H(m) is evaluated; the result is a fixed-length bit string.\n\
    \   2.  Convert the resulting bit string to an integer i by treating its\n   \
    \    leftmost (initial) bit as the most significant bit of i, and\n       treating\
    \ its rightmost (final) bit as the least significant bit\n       of i.\n"
- title: 5.3.  KT-IV Signatures
  contents:
  - "5.3.  KT-IV Signatures\n   Koyama and Tsuruoka described a signature method based\
    \ on Elliptic\n   Curve ElGamal, in which the first signature component is the\n\
    \   x-coordinate of an elliptic curve point reduced modulo q [KT1994].\n   In\
    \ this section, we recall that method, which we refer to as KT-IV.\n   The algorithm\
    \ uses an elliptic curve group, as described in\n   Section 3.3, with prime field\
    \ order p and curve equation parameters a\n   and b.  We denote the generator\
    \ as alpha, and the order of the\n   generator as q.  We follow [FIPS186] in checking\
    \ for exceptional\n   cases.\n"
- title: 5.3.1.  Keypair Generation
  contents:
  - "5.3.1.  Keypair Generation\n   The private key z is an integer between 1 and\
    \ q-1, inclusive,\n   generated uniformly at random.  (See Appendix B regarding\
    \ random\n   integers.)  The public key is the group element Y = alpha^z.  Each\n\
    \   public key is associated with a particular parameter set as per\n   Section\
    \ 3.3.\n"
- title: 5.3.2.  Signature Creation
  contents:
  - "5.3.2.  Signature Creation\n   To compute a KT-IV signature for a message m using\
    \ the private key z:\n   1.  Choose an integer k uniformly at random from the\
    \ set of all\n       integers between 1 and q-1, inclusive.  (See Appendix B regarding\n\
    \       random integers.)\n   2.  Calculate R = (r_x, r_y) = alpha^k.\n   3. \
    \ Calculate s1 = r_x mod q.\n   4.  Check if h(m) + z * s1 = 0 mod q; if so, a\
    \ new value of k MUST be\n       generated and the signature MUST be recalculated.\
    \  As an option,\n       one MAY check if s1 = 0; if so, a new value of k SHOULD\
    \ be\n       generated and the signature SHOULD be recalculated.  (It is\n   \
    \    extremely unlikely that s1 = 0 or h(m) + z * s1 = 0 mod q if\n       signatures\
    \ are generated properly.)\n   5.  Calculate s2 = k/(h(m) + z*s1) mod q.\n   The\
    \ signature is the ordered pair (s1, s2).  Both signature\n   components are non-negative\
    \ integers.\n"
- title: 5.3.3.  Signature Verification
  contents:
  - "5.3.3.  Signature Verification\n   Given the message m, the generator g, the\
    \ group order q, the public\n   key Y, and the signature (s1, s2), verification\
    \ is as follows:\n   1.  Check to see that 0 < s1 < q and 0 < s2 < q; if either\
    \ condition\n       is violated, the signature SHALL be rejected.\n   2.  Compute\
    \ the non-negative integers u1 and u2, where\n          u1 = h(m) * s2 mod q,\
    \ and\n          u2 = s1 * s2 mod q.\n   3.  Compute the elliptic curve point\
    \ R' = alpha^u1 * Y^u2.\n   4.  If the x-coordinate of R' mod q is equal to s1,\
    \ then the\n       signature and message pass the verification; otherwise, they\n\
    \       fail.\n"
- title: 5.4.  KT-I Signatures
  contents:
  - "5.4.  KT-I Signatures\n   Horster, Michels, and Petersen categorized many different\
    \ ElGamal\n   signature methods, demonstrated their equivalence, and showed how\
    \ to\n   convert signatures of one type to another type [HMP1994].  In their\n\
    \   terminology, the signature method of Section 5.3 and [KT1994] is a\n   Type\
    \ IV method, which is why it is denoted as KT-IV.\n   A Type I KT signature method\
    \ has a second component that is computed\n   in the same manner as that of the\
    \ Digital Signature Algorithm.  In\n   this section, we describe this method,\
    \ which we refer to as KT-I.\n"
- title: 5.4.1.  Keypair Generation
  contents:
  - "5.4.1.  Keypair Generation\n   Keypairs and keypair generation are exactly as\
    \ in Section 5.3.1.\n"
- title: 5.4.2.  Signature Creation
  contents:
  - "5.4.2.  Signature Creation\n   To compute a KT-I signature for a message m using\
    \ the private key z:\n   1.  Choose an integer k uniformly at random from the\
    \ set of all\n       integers between 1 and q-1, inclusive.  (See Appendix B regarding\n\
    \       random integers.)\n   2.  Calculate R = (r_x, r_y) = alpha^k.\n   3. \
    \ Calculate s1 = r_x mod q.\n   4.  Calculate s2 = (h(m) + z*s1)/k mod q.\n  \
    \ 5.  As an option, one MAY check if s1 = 0 or s2 = 0.  If either\n       s1 =\
    \ 0 or s2 = 0, a new value of k SHOULD be generated and the\n       signature\
    \ SHOULD be recalculated.  (It is extremely unlikely that\n       s1 = 0 or s2\
    \ = 0 if signatures are generated properly.)\n   The signature is the ordered\
    \ pair (s1, s2).  Both signature\n   components are non-negative integers.\n"
- title: 5.4.3.  Signature Verification
  contents:
  - "5.4.3.  Signature Verification\n   Given the message m, the public key Y, and\
    \ the signature (s1, s2),\n   verification is as follows:\n   1.  Check to see\
    \ that 0 < s1 < q and 0 < s2 < q; if either condition\n       is violated, the\
    \ signature SHALL be rejected.\n   2.  Compute s2_inv = 1/s2 mod q.\n   3.  Compute\
    \ the non-negative integers u1 and u2, where\n          u1 = h(m) * s2_inv mod\
    \ q, and\n          u2 = s1 * s2_inv mod q.\n   4.  Compute the elliptic curve\
    \ point R' = alpha^u1 * Y^u2.\n   5.  If the x-coordinate of R' mod q is equal\
    \ to s1, then the\n       signature and message pass the verification; otherwise,\
    \ they\n       fail.\n"
- title: 5.5.  Converting KT-IV Signatures to KT-I Signatures
  contents:
  - "5.5.  Converting KT-IV Signatures to KT-I Signatures\n   A KT-IV signature for\
    \ a message m and a public key Y can easily be\n   converted into a KT-I signature\
    \ for the same message and public key.\n   If (s1, s2) is a KT-IV signature for\
    \ a message m, then\n   (s1, 1/s2 mod q) is a KT-I signature for the same message\
    \ [HMP1994].\n   The conversion operation uses only public information, and it\
    \ can be\n   performed by the creator of the pre-conversion KT-IV signature, the\n\
    \   verifier of the post-conversion KT-I signature, or by any other\n   entity.\n\
    \   An implementation MAY use this method to compute KT-I signatures.\n"
- title: 5.6.  Rationale
  contents:
  - "5.6.  Rationale\n   This subsection is not normative for this specification and\
    \ is\n   provided only as background information.\n   [HMP1994] presents many\
    \ generalizations of ElGamal signatures.\n   Equation (5) of that reference shows\
    \ the general signature equation\n      A = x_A * B + k * C (mod q)\n   where\
    \ x_A is the private key, k is the secret value, and A, B, and C\n   are determined\
    \ by the Type of the equation, as shown in Table 1 of\n   [HMP1994].  DSA [FIPS186]\
    \ is an EG-I.1 signature method (as is KT-I),\n   with A = m, B = -r, and C =\
    \ s.  (Here we use the notation of\n   [HMP1994] in which the first signature\
    \ component is r and the second\n   signature component is s; in KT-I and KT-IV\
    \ these components are\n   denoted as s1 and s2, respectively.  The private key\
    \ x_A corresponds\n   to the private key z.)  Its signature equation is\n    \
    \  m = -r * z + s * k (mod q).\n   The signature method of [KT1994] and Section\
    \ 5.3 is an EG-IV.1\n   method, with A = m * s, B = -r * s, C = 1.  Its signature\
    \ equation is\n      m * s = -r * s * z + k (mod q)\n   The functions f and g\
    \ mentioned in Table 1 of [HMP1994] are merely\n   multiplication, as described\
    \ under the heading \"Fifth\n   generalization\".\n   In the above equations,\
    \ we rely on the implicit conversion of the\n   message m from a bit string to\
    \ an integer.  No hash function is shown\n   in these equations, but, as described\
    \ in Section 10.4, a hash\n   function should be applied to the message prior\
    \ to signing in order\n   to prevent existential forgery attacks.\n   Nyberg and\
    \ Rueppel [NR1994] studied many different ElGamal signature\n   methods and defined\
    \ \"strong equivalence\" as follows:\n      Two signature methods are called strongly\
    \ equivalent if the\n      signature of the first scheme can be transformed efficiently\
    \ into\n      signatures of the second scheme and vice versa, without knowledge\n\
    \      of the private key.\n   KT-I and KT-IV signatures are obviously strongly\
    \ equivalent.\n   A valid signature with s2=0 leaks the secret key, since in that\
    \ case\n   z = -h(m) / s1 mod q.  We follow [FIPS186] in checking for this\n \
    \  exceptional case and the case that s1=0.  The s2=0 check was\n   suggested\
    \ by Rivest [R1992] and is discussed in [BS1992].\n   [KT1994] uses \"a positive\
    \ integer q' that does not exceed q\" when\n   computing the signature component\
    \ s1 from the x-coordinate r_x of the\n   elliptic curve point R = (r_x, r_y).\
    \  The value q' is also used\n   during signature validation when comparing the\
    \ x-coordinate of a\n   computed elliptic curve point to the value to s1.  In\
    \ this note, we\n   use the simplifying convention that q' = q.\n"
- title: 6.  Converting between Integers and Octet Strings
  contents:
  - "6.  Converting between Integers and Octet Strings\n   A method for the conversion\
    \ between integers and octet strings is\n   specified in this section, following\
    \ the established conventions of\n   public key cryptography [R1993].  This method\
    \ allows integers to be\n   represented as octet strings that are suitable for\
    \ transmission or\n   storage.  This method SHOULD be used when representing an\
    \ elliptic\n   curve point or an elliptic curve coordinate as they are defined\
    \ in\n   this note.\n"
- title: 6.1.  Octet-String-to-Integer Conversion
  contents:
  - "6.1.  Octet-String-to-Integer Conversion\n   The octet string S shall be converted\
    \ to an integer x as follows.\n   Let S1, ..., Sk be the octets of S from first\
    \ to last.  Then the\n   integer x shall satisfy\n                          k\n\
    \                    x =  SUM  2^(8(k-i)) Si .\n                        i = 1\n\
    \   In other words, the first octet of S has the most significance in the\n  \
    \ integer and the last octet of S has the least significance.\n   Note: the integer\
    \ x satisfies 0 <= x < 2^(8*k).\n"
- title: 6.2.  Integer-to-Octet-String Conversion
  contents:
  - "6.2.  Integer-to-Octet-String Conversion\n   The integer x shall be converted\
    \ to an octet string S of length k as\n   follows.  The string S shall satisfy\n\
    \                          k\n                    y =  SUM  2^(8(k-i)) Si .\n\
    \                        i = 1\n   where S1, ..., Sk are the octets of S from\
    \ first to last.\n   In other words, the first octet of S has the most significance\
    \ in the\n   integer, and the last octet of S has the least significance.\n"
- title: 7.  Interoperability
  contents:
  - "7.  Interoperability\n   The algorithms in this note can be used to interoperate\
    \ with some\n   other ECC specifications.  This section provides details for each\n\
    \   algorithm.\n"
- title: 7.1.  ECDH
  contents:
  - "7.1.  ECDH\n   Section 4 can be used with the Internet Key Exchange (IKE) versions\n\
    \   one [RFC2409] or two [RFC5996].  These algorithms are compatible with\n  \
    \ the ECP groups defined by [RFC5903], [RFC5114], [RFC2409], and\n   [RFC2412].\
    \  The group definition in this protocol uses an affine\n   coordinate representation\
    \ of the public key.  [RFC5903] uses the\n   compact output of Section 4.2, while\
    \ [RFC4753] (which was obsoleted\n   by RFC 5903) does not.  Neither of those\
    \ RFCs use compact\n   representation.  Note that some groups indicate that the\
    \ curve\n   parameter \"a\" is negative; these values are to be interpreted modulo\n\
    \   the order of the field.  For example, a parameter of a = -3 is equal\n   to\
    \ p - 3, where p is the order of the field.  The test cases in\n   Section 8 of\
    \ [RFC5903] can be used to test an implementation; these\n   cases use the multiplicative\
    \ notation, as does this note.  The KEi\n   and KEr payloads are equal to g^j\
    \ and g^k, respectively, with 64 bits\n   of encoding data prepended to them.\n\
    \   The algorithms in Section 4 can be used to interoperate with the IEEE\n  \
    \ [P1363] and ANSI [X9.62] standards for ECDH based on fields of\n   characteristic\
    \ greater than three.  IEEE P1363 ECDH can be used in a\n   manner that will interoperate\
    \ with this note, with the following\n   options and parameter choices from that\
    \ specification:\n      prime curves with a cofactor of 1,\n      the ECSVDP-DH\
    \ (Elliptic Curve Secret Value Derivation Primitive,\n      Diffie-Hellman version),\n\
    \      the Key Derivation Function (KDF) must be the \"identity\" function\n \
    \     (equivalently, the KDF step should be omitted and the shared\n      secret\
    \ value should be output directly).\n"
- title: 7.2.  KT-I and ECDSA
  contents:
  - "7.2.  KT-I and ECDSA\n   The Digital Signature Algorithm (DSA) is based on the\
    \ discrete\n   logarithm problem over the multiplicative subgroup of the finite\n\
    \   field with large prime order [DSA1991] [FIPS186].  The Elliptic Curve\n  \
    \ Digital Signature Algorithm (ECDSA) [P1363] [X9.62] is an elliptic\n   curve\
    \ version of DSA.\n   KT-I is mathematically and functionally equivalent to ECDSA,\
    \ and can\n   interoperate with the IEEE [P1363] and ANSI [X9.62] standards for\n\
    \   Elliptic Curve DSA (ECDSA) based on fields of characteristic greater\n   than\
    \ three.  KT-I signatures can be verified using the ECDSA\n   verification algorithm,\
    \ and ECDSA signatures can be verified using\n   the KT-I verification algorithm.\n"
- title: 8.  Validating an Implementation
  contents:
  - "8.  Validating an Implementation\n   It is essential to validate the implementation\
    \ of a cryptographic\n   algorithm.  This section outlines tests that should be\
    \ performed on\n   the algorithms defined in this note.\n   A known answer test,\
    \ or KAT, uses a fixed set of inputs to test an\n   algorithm; the output of the\
    \ algorithm is compared with the expected\n   output, which is also a fixed value.\
    \  KATs for ECDH and KT-I are set\n   out in the following subsections.\n   A\
    \ consistency test generates inputs for one algorithm being tested\n   using a\
    \ second algorithm that is also being tested, then checks the\n   output of the\
    \ first algorithm.  A signature creation algorithm can be\n   tested for consistency\
    \ against a signature verification algorithm.\n   Implementations of KT-I should\
    \ be tested in this way.  Their\n   signature generation processes are non-deterministic,\
    \ and thus cannot\n   be tested using a KAT.  Signature verification algorithms,\
    \ on the\n   other hand, are deterministic and should be tested via a KAT.  This\n\
    \   combination of tests provides coverage for all of the operations,\n   including\
    \ keypair generation.  Consistency testing should also be\n   applied to ECDH.\n"
- title: 8.1.  ECDH
  contents:
  - "8.1.  ECDH\n   An ECDH implementation can be validated using the known answer\
    \ test\n   cases from [RFC5903] or [RFC5114].  The correspondence between the\n\
    \   notation in RFC 5903 and the notation in this note is summarized in\n   the\
    \ following table.  (Refer to Sections 3.3 and 4; the generator g\n   is expressed\
    \ in affine coordinate representation as (gx, gy)).\n     +----------------------+---------------------------------------+\n\
    \     | ECDH                 | RFC 5903                              |\n     +----------------------+---------------------------------------+\n\
    \     | order p of field Fp  | p                                     |\n     |\
    \ curve coefficient a  | -3                                    |\n     | curve\
    \ coefficient b  | b                                     |\n     | generator g\
    \          | g=(gx, gy)                            |\n     | private keys j and\
    \ k | i and r                               |\n     | public keys g^j, g^k | g^i\
    \ = (gix, giy) and g^r = (grx, gry) |\n     +----------------------+---------------------------------------+\n\
    \   The correspondence between the notation in RFC 5114 and the notation\n   in\
    \ this note is summarized in the following table.\n           +-----------------------+---------------------------+\n\
    \           | ECDH                  | RFC 5114                  |\n          \
    \ +-----------------------+---------------------------+\n           | order p\
    \ of field Fp   | p                         |\n           | curve coefficient\
    \ a   | a                         |\n           | curve coefficient b   | b  \
    \                       |\n           | generator g           | g=(gx, gy)   \
    \             |\n           | group order n         | n                      \
    \   |\n           | private keys j and k  | dA and dB                 |\n    \
    \       | public keys g^j, g^k  | g^(dA) = (x_qA, y_qA) and |\n           |  \
    \                     | g^(dB) = (x_qB, y_qB)     |\n           | shared secret\
    \ g^(j*k) | g^(dA*dB) = (x_Z, y_Z)    |\n           +-----------------------+---------------------------+\n"
- title: 8.2.  KT-I
  contents:
  - "8.2.  KT-I\n   A KT-I implementation can be validated using the known answer\
    \ test\n   cases from [RFC4754].  The correspondence between the notation in\n\
    \   that RFC and the notation in this note is summarized in the following\n  \
    \ table.\n                +---------------------+------------------+\n       \
    \         | KT-I                | RFC 4754         |\n                +---------------------+------------------+\n\
    \                | order p of field Fp | p                |\n                |\
    \ curve coefficient a | -3               |\n                | curve coefficient\
    \ b | b                |\n                | generator alpha     | g          \
    \      |\n                | group order q       | q                |\n       \
    \         | private key z       | w                |\n                | public\
    \ key Y        | g^w = (gwx,gwy)  |\n                | random k            | ephem\
    \ priv k     |\n                | s1                  | r                |\n \
    \               | s2                  | s                |\n                |\
    \ s2_inv              | sinv             |\n                | u1             \
    \     | u = h*sinv mod q |\n                | u2                  | v = r*sinv\
    \ mod q |\n                +---------------------+------------------+\n"
- title: 9.  Intellectual Property
  contents:
  - "9.  Intellectual Property\n   Concerns about intellectual property have slowed\
    \ the adoption of ECC\n   because a number of optimizations and specialized algorithms\
    \ have\n   been patented in recent years.\n   All of the normative references\
    \ for ECDH (as defined in Section 4)\n   were published during or before 1989,\
    \ and those for KT-I were\n   published during or before May 1994.  All of the\
    \ normative text for\n   these algorithms is based solely on their respective\
    \ references.\n"
- title: 9.1.  Disclaimer
  contents:
  - "9.1.  Disclaimer\n   This document is not intended as legal advice.  Readers\
    \ are advised\n   to consult their own legal advisers if they would like a legal\n\
    \   interpretation of their rights.\n   The IETF policies and processes regarding\
    \ intellectual property and\n   patents are outlined in [RFC3979] and [RFC4879]\
    \ and at\n   https://datatracker.ietf.org/ipr/about/.\n"
- title: 10.  Security Considerations
  contents:
  - "10.  Security Considerations\n   The security level of an elliptic curve cryptosystem\
    \ is determined by\n   the cryptanalytic algorithm that is the least expensive\
    \ for an\n   attacker to implement.  There are several algorithms to consider.\n\
    \   The Pohlig-Hellman method is a divide-and-conquer technique [PH1978].\n  \
    \ If the group order n can be factored as\n      n = q1 * q2 * ... * qz,\n   then\
    \ the discrete log problem over the group can be solved by\n   independently solving\
    \ a discrete log problem in groups of order q1,\n   q2, ..., qz, then combining\
    \ the results using the Chinese remainder\n   theorem.  The overall computational\
    \ cost is dominated by that of the\n   discrete log problem in the subgroup with\
    \ the largest order.\n   Shanks' algorithm [K1981v3] computes a discrete logarithm\
    \ in a group\n   of order n using O(sqrt(n)) operations and O(sqrt(n)) storage.\
    \  The\n   Pollard rho algorithm [P1978] computes a discrete logarithm in a\n\
    \   group of order n using O(sqrt(n)) operations, with a negligible\n   amount\
    \ of storage, and can be efficiently parallelized [VW1994].\n   The Pollard lambda\
    \ algorithm [P1978] can solve the discrete logarithm\n   problem using O(sqrt(w))\
    \ operations and O(log(w)) storage, when the\n   exponent is known to lie in an\
    \ interval of width w.\n   The algorithms described above work in any group. \
    \ There are\n   specialized algorithms that specifically target elliptic curve\n\
    \   groups.  There are no known subexponential algorithms against general\n  \
    \ elliptic curve groups, though there are methods that target certain\n   special\
    \ elliptic curve groups; see [MOV1993] and [FR1994].\n"
- title: 10.1.  Subgroups
  contents:
  - "10.1.  Subgroups\n   A group consisting of a nonempty set of elements S with\
    \ associated\n   group operation * is a subgroup of the group with the set of\
    \ elements\n   G, if the latter group uses the same group operation and S is a\n\
    \   subset of G.  For each elliptic curve equation, there is an elliptic\n   curve\
    \ group whose group order is equal to the order of the elliptic\n   curve; that\
    \ is, there is a group that contains every point on the\n   curve.\n   The order\
    \ m of the elliptic curve is divisible by the order n of the\n   group associated\
    \ with the generator; that is, for each elliptic curve\n   group, m = n * c for\
    \ some number c.  The number c is called the\n   \"cofactor\" [P1363].  Each ECC\
    \ parameter set as in Section 3.3 is\n   associated with a particular cofactor.\n\
    \   It is possible and desirable to use a cofactor equal to 1.\n"
- title: 10.2.  Diffie-Hellman
  contents:
  - "10.2.  Diffie-Hellman\n   Note that the key exchange protocol as defined in Section\
    \ 4 does not\n   protect against active attacks; Party A must use some method\
    \ to\n   ensure that (g^k) originated with the intended communicant B, rather\n\
    \   than an attacker, and Party B must do the same with (g^j).\n   It is not sufficient\
    \ to authenticate the shared secret g^(j*k), since\n   this leaves the protocol\
    \ open to attacks that manipulate the public\n   keys.  Instead, the values of\
    \ the public keys g^x and g^y that are\n   exchanged should be directly authenticated.\
    \  This is the strategy\n   used by protocols that build on Diffie-Hellman and\
    \ that use end-\n   entity authentication to protect against active attacks, such\
    \ as\n   OAKLEY [RFC2412] and the Internet Key Exchange [RFC2409] [RFC4306]\n\
    \   [RFC5996].\n   When the cofactor of a group is not equal to 1, there are a\
    \ number of\n   attacks that are possible against ECDH.  See [VW1996], [AV1996],\
    \ and\n   [LL1997].\n"
- title: 10.3.  Group Representation and Security
  contents:
  - "10.3.  Group Representation and Security\n   The elliptic curve group operation\
    \ does not explicitly incorporate\n   the parameter b from the curve equation.\
    \  This opens the possibility\n   that a malicious attacker could learn information\
    \ about an ECDH\n   private key by submitting a bogus public key [BMM2000].  An\
    \ attacker\n   can craft an elliptic curve group G' that has identical parameters\
    \ to\n   a group G that is being used in an ECDH protocol, except that b is\n\
    \   different.  An attacker can submit a point on G' into a run of the\n   ECDH\
    \ protocol that is using group G, and gain information from the\n   fact that\
    \ the group operations using the private key of the device\n   under attack are\
    \ effectively taking place in G' instead of G.\n   This attack can gain useful\
    \ information about an ECDH private key\n   that is associated with a static public\
    \ key, i.e., a public key that\n   is used in more than one run of the protocol.\
    \  However, it does not\n   gain any useful information against ephemeral keys.\n\
    \   This sort of attack is thwarted if an ECDH implementation does not\n   assume\
    \ that each pair of coordinates in Zp is actually a point on the\n   appropriate\
    \ elliptic curve.\n   These considerations also apply when ECDH is used with compact\n\
    \   representation (see Appendix C).\n"
- title: 10.4.  Signatures
  contents:
  - "10.4.  Signatures\n   Elliptic curve parameters should only be used if they come\
    \ from a\n   trusted source; otherwise, some attacks are possible [AV1996]\n \
    \  [V1996].\n   If no hash function is used in an ElGamal signature system, then\
    \ the\n   system is vulnerable to existential forgeries, in which an attacker\n\
    \   who does not know a private key can generate valid signatures for the\n  \
    \ associated public key, but cannot generate a signature for a message\n   of\
    \ its own choosing.  (See [E1985] for instance.)  The use of a\n   collision-resistant\
    \ hash function eliminates this vulnerability.\n   In principle, any collision-resistant\
    \ hash function is suitable for\n   use in KT signatures.  To facilitate interoperability,\
    \ we recognize\n   the following hashes as suitable for use as the function H\
    \ defined in\n   Section 5.2:\n      SHA-256, which has a 256-bit output.\n  \
    \    SHA-384, which has a 384-bit output.\n      SHA-512, which has a 512-bit\
    \ output.\n   All of these hash functions are defined in [FIPS180-2].\n   The\
    \ number of bits in the output of the hash used in KT signatures\n   should be\
    \ equal or close to the number of bits needed to represent\n   the group order.\n"
- title: 11.  Acknowledgements
  contents:
  - "11.  Acknowledgements\n   The author expresses his thanks to the originators\
    \ of elliptic curve\n   cryptography, whose work made this note possible, and\
    \ all of the\n   reviewers, who provided valuable constructive feedback.  Thanks\
    \ are\n   especially due to Howard Pinder, Andrey Jivsov, Alfred Hoenes (who\n\
    \   contributed the algorithms in Appendix F), Dan Harkins, and Tina\n   Tsou.\n"
- title: 12.  References
  contents:
  - '12.  References

    '
- title: 12.1.  Normative References
  contents:
  - "12.1.  Normative References\n   [AMV1990]    Agnew, G., Mullin, R., and S. Vanstone,\
    \ \"Improved\n                Digital Signature Scheme based on Discrete\n   \
    \             Exponentiation\", Electronics Letters Vol. 26, No. 14,\n       \
    \         July, 1990.\n   [BC1989]     Bender, A. and G. Castagnoli, \"On the\
    \ Implementation of\n                Elliptic Curve Cryptosystems\", Advances\
    \ in Cryptology -\n                CRYPTO '89 Proceedings, Springer Lecture Notes\
    \ in\n                Computer Science (LNCS), volume 435, 1989.\n   [CC1986]\
    \     Chudnovsky, D. and G. Chudnovsky, \"Sequences of numbers\n             \
    \   generated by addition in formal groups and new primality\n               \
    \ and factorization tests\", Advances in Applied\n                Mathematics,\
    \ Volume 7, Issue 4, December 1986.\n   [D1966]      Deskins, W., \"Abstract Algebra\"\
    , MacMillan Company New\n                York, 1966.\n   [DH1976]     Diffie,\
    \ W. and M. Hellman, \"New Directions in\n                Cryptography\", IEEE\
    \ Transactions in Information\n                Theory IT-22, pp. 644-654, 1976.\n\
    \   [FR1994]     Frey, G. and H. Ruck, \"A remark concerning\n               \
    \ m-divisibility and the discrete logarithm in the divisor\n                class\
    \ group of curves.\", Mathematics of Computation Vol.\n                62, No.\
    \ 206, pp. 865-874, 1994.\n   [HMP1994]    Horster, P., Michels, M., and H. Petersen,\
    \ \"Meta-ElGamal\n                signature schemes\", University of Technology\
    \ Chemnitz-\n                Zwickau Department of Computer Science, Technical\n\
    \                Report TR-94-5, May 1994.\n   [K1981v2]    Knuth, D., \"The Art\
    \ of Computer Programming, Vol. 2:\n                Seminumerical Algorithms\"\
    , Addison Wesley , 1981.\n   [K1987]      Koblitz, N., \"Elliptic Curve Cryptosystems\"\
    , Mathematics\n                of Computation, Vol. 48, 1987, pp. 203-209, 1987.\n\
    \   [KT1994]     Koyama, K. and Y. Tsuruoka, \"Digital signature system\n    \
    \            based on elliptic curve and signer device and verifier\n        \
    \        device for said system\", Japanese Unexamined Patent\n              \
    \  Application Publication H6-43809, February 18, 1994.\n   [M1983]      Massey,\
    \ J., \"Logarithms in finite cyclic groups -\n                cryptographic issues\"\
    , Proceedings of the 4th Symposium\n                on Information Theory, 1983.\n\
    \   [M1985]      Miller, V., \"Use of elliptic curves in cryptography\",\n   \
    \             Advances in Cryptology - CRYPTO '85\n                Proceedings,\
    \ Springer Lecture Notes in Computer Science\n                (LNCS), volume 218,\
    \ 1985.\n   [MOV1993]    Menezes, A., Vanstone, S., and T. Okamoto, \"Reducing\n\
    \                Elliptic Curve Logarithms to Logarithms in a Finite\n       \
    \         Field\", IEEE Transactions on Information Theory Vol. 39,\n        \
    \        No. 5, pp. 1639-1646, September, 1993.\n   [R1993]      RSA Laboratories,\
    \ \"PKCS#1: RSA Encryption Standard\",\n                Technical Note version\
    \ 1.5, 1993.\n   [S1986]      Silverman, J., \"The Arithmetic of Elliptic Curves\"\
    ,\n                Springer-Verlag, New York, 1986.\n"
- title: 12.2.  Informative References
  contents:
  - "12.2.  Informative References\n   [A1992]      Anderson, J., \"Response to the\
    \ proposed DSS\",\n                Communications of the ACM, v. 35, n. 7, p.\
    \ 50-52,\n                July 1992.\n   [AV1996]     Anderson, R. and S. Vaudenay,\
    \ \"Minding Your P's and\n                Q's\", Advances in Cryptology - ASIACRYPT\
    \ '96\n                Proceedings, Springer Lecture Notes in Computer Science\n\
    \                (LNCS), volume 1163, 1996.\n   [BMM2000]    Biehl, I., Meyer,\
    \ B., and V. Muller, \"Differential fault\n                analysis on elliptic\
    \ curve cryptosystems\", Advances in\n                Cryptology - CRYPTO 2000\
    \ Proceedings, Springer Lecture\n                Notes in Computer Science (LNCS),\
    \ volume 1880, 2000.\n   [BS1992]     Branstad, D. and M. Smid, \"Response to\
    \ Comments on the\n                NIST Proposed Digital Signature Standard\"\
    , Advances in\n                Cryptology - CRYPTO '92 Proceedings, Springer Lecture\n\
    \                Notes in Computer Science (LNCS), volume 740,\n             \
    \   August 1992.\n   [DSA1991]    U.S. National Institute of Standards and Technology,\n\
    \                \"DIGITAL SIGNATURE STANDARD\", Federal Register, Vol. 56,\n\
    \                August 1991.\n   [E1984a]     ElGamal, T., \"Cryptography and\
    \ logarithms over finite\n                fields\", Stanford University, UMI Order\
    \ No. DA 8420519,\n                1984.\n   [E1984b]     ElGamal, T., \"Cryptography\
    \ and logarithms over finite\n                fields\", Advances in Cryptology\
    \ - CRYPTO '84\n                Proceedings, Springer Lecture Notes in Computer\
    \ Science\n                (LNCS), volume 196, 1984.\n   [E1985]      ElGamal,\
    \ T., \"A public key cryptosystem and a signature\n                scheme based\
    \ on discrete logarithms\", IEEE Transactions\n                on Information\
    \ Theory, Vol. 30, No. 4, pp. 469-472,\n                1985.\n   [FIPS180-2]\
    \  U.S. National Institute of Standards and Technology,\n                \"SECURE\
    \ HASH STANDARD\", Federal Information Processing\n                Standard (FIPS)\
    \ 180-2, August 2002.\n   [FIPS186]    U.S. National Institute of Standards and\
    \ Technology,\n                \"DIGITAL SIGNATURE STANDARD\", Federal Information\n\
    \                Processing Standard FIPS-186, May 1994.\n   [HP1994]     Horster,\
    \ P. and H. Petersen, \"Verallgemeinerte ElGamal-\n                Signaturen\"\
    , Proceedings der Fachtagung SIS '94, Verlag\n                der Fachvereine,\
    \ Zurich, 1994.\n   [K1981v3]    Knuth, D., \"The Art of Computer Programming,\
    \ Vol. 3:\n                Sorting and Searching\", Addison Wesley, 1981.\n  \
    \ [KMOV1991]   Koyama, K., Maurer, U., Vanstone, S., and T. Okamoto,\n       \
    \         \"New Public-Key Schemes Based on Elliptic Curves over\n           \
    \     the Ring Zn\", Advances in Cryptology - CRYPTO '91\n                Proceedings,\
    \ Springer Lecture Notes in Computer Science\n                (LNCS), volume 576,\
    \ 1991.\n   [L1969]      Lehmer, D., \"Computer technology applied to the theory\n\
    \                of numbers\", M.A.A. Studies in Mathematics, 180-2, 1969.\n \
    \  [LL1997]     Lim, C. and P. Lee, \"A Key Recovery Attack on Discrete\n    \
    \            Log-based Schemes Using a Prime Order Subgroup\",\n             \
    \   Advances in Cryptology - CRYPTO '97\n                Proceedings, Springer\
    \ Lecture Notes in Computer Science\n                (LNCS), volume 1294, 1997.\n\
    \   [NR1994]     Nyberg, K. and R. Rueppel, \"Message Recovery for\n         \
    \       Signature Schemes Based on the Discrete Logarithm\n                Problem\"\
    , Advances in Cryptology - EUROCRYPT '94\n                Proceedings, Springer\
    \ Lecture Notes in Computer Science\n                (LNCS), volume 950, May 1994.\n\
    \   [P1363]      \"Standard Specifications for Public Key Cryptography\",\n  \
    \              Institute of Electric and Electronic Engineers\n              \
    \  (IEEE), P1363, 2000.\n   [P1978]      Pollard, J., \"Monte Carlo methods for\
    \ index computation\n                mod p\", Mathematics of Computation, Vol.\
    \ 32, 1978.\n   [PH1978]     Pohlig, S. and M. Hellman, \"An Improved Algorithm\
    \ for\n                Computing Logarithms over GF(p) and its Cryptographic\n\
    \                Significance\", IEEE Transactions on Information\n          \
    \      Theory, Vol. 24, pp. 106-110, 1978.\n   [R1988]      Rose, H., \"A Course\
    \ in Number Theory\", Oxford\n                University Press, 1988.\n   [R1992]\
    \      Rivest, R., \"Response to the proposed DSS\",\n                Communications\
    \ of the ACM, v. 35, n. 7, p. 41-47,\n                July 1992.\n   [RFC2119]\
    \    Bradner, S., \"Key words for use in RFCs to Indicate\n                Requirement\
    \ Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2409]    Harkins, D. and D.\
    \ Carrel, \"The Internet Key Exchange\n                (IKE)\", RFC 2409, November\
    \ 1998.\n   [RFC2412]    Orman, H., \"The OAKLEY Key Determination Protocol\"\
    ,\n                RFC 2412, November 1998.\n   [RFC3979]    Bradner, S., \"Intellectual\
    \ Property Rights in IETF\n                Technology\", BCP 79, RFC 3979, March\
    \ 2005.\n   [RFC4086]    Eastlake, D., Schiller, J., and S. Crocker, \"Randomness\n\
    \                Requirements for Security\", BCP 106, RFC 4086,\n           \
    \     June 2005.\n   [RFC4306]    Kaufman, C., \"Internet Key Exchange (IKEv2)\
    \ Protocol\",\n                RFC 4306, December 2005.\n   [RFC4753]    Fu, D.\
    \ and J. Solinas, \"ECP Groups For IKE and IKEv2\",\n                RFC 4753,\
    \ January 2007.\n   [RFC4754]    Fu, D. and J. Solinas, \"IKE and IKEv2 Authentication\n\
    \                Using the Elliptic Curve Digital Signature Algorithm\n      \
    \          (ECDSA)\", RFC 4754, January 2007.\n   [RFC4879]    Narten, T., \"\
    Clarification of the Third Party Disclosure\n                Procedure in RFC\
    \ 3979\", BCP 79, RFC 4879, April 2007.\n   [RFC5114]    Lepinski, M. and S. Kent,\
    \ \"Additional Diffie-Hellman\n                Groups for Use with IETF Standards\"\
    , RFC 5114,\n                January 2008.\n   [RFC5903]    Fu, D. and J. Solinas,\
    \ \"Elliptic Curve Groups modulo a\n                Prime (ECP Groups) for IKE\
    \ and IKEv2\", RFC 5903,\n                June 2010.\n   [RFC5996]    Kaufman,\
    \ C., Hoffman, P., Nir, Y., and P. Eronen,\n                \"Internet Key Exchange\
    \ Protocol Version 2 (IKEv2)\",\n                RFC 5996, September 2010.\n \
    \  [SuiteB]     U. S. National Security Agency (NSA), \"NSA Suite B\n        \
    \        Cryptography\", <http://www.nsa.gov/ia/programs/\n                suiteb_cryptography/index.shtml>.\n\
    \   [V1996]      Vaudenay, S., \"Hidden Collisions on DSS\", Advances in\n   \
    \             Cryptology - CRYPTO '96 Proceedings, Springer Lecture\n        \
    \        Notes in Computer Science (LNCS), volume 1109, 1996.\n   [VW1994]   \
    \  van Oorschot, P. and M. Wiener, \"Parallel Collision\n                Search\
    \ with Application to Hash Functions and Discrete\n                Logarithms\"\
    , Proceedings of the 2nd ACM Conference on\n                Computer and communications\
    \ security, pp. 210-218, 1994.\n   [VW1996]     van Oorschot, P. and M. Wiener,\
    \ \"On Diffie-Hellman key\n                agreement with short exponents\", Advances\
    \ in Cryptology\n                - EUROCRYPT '96 Proceedings, Springer Lecture\
    \ Notes in\n                Computer Science (LNCS), volume 1070, 1996.\n   [X9.62]\
    \      \"Public Key Cryptography for the Financial Services\n                Industry:\
    \ The Elliptic Curve Digital Signature Algorithm\n                (ECDSA)\", American\
    \ National Standards Institute (ANSI)\n                X9.62.\n"
- title: Appendix A.  Key Words
  contents:
  - "Appendix A.  Key Words\n   The definitions of these key words are quoted from\
    \ [RFC2119] and are\n   commonly used in Internet standards.  They are reproduced\
    \ in this\n   note in order to avoid a normative reference from after 1994.\n\
    \   1.  MUST - This word, or the terms \"REQUIRED\" or \"SHALL\", means that\n\
    \       the definition is an absolute requirement of the specification.\n   2.\
    \  MUST NOT - This phrase, or the phrase \"SHALL NOT\", means that the\n     \
    \  definition is an absolute prohibition of the specification.\n   3.  SHOULD\
    \ - This word, or the adjective \"RECOMMENDED\", means that\n       there may\
    \ exist valid reasons in particular circumstances to\n       ignore a particular\
    \ item, but the full implications must be\n       understood and carefully weighed\
    \ before choosing a different\n       course.\n   4.  SHOULD NOT - This phrase,\
    \ or the phrase \"NOT RECOMMENDED\", means\n       that there may exist valid\
    \ reasons in particular circumstances\n       when the particular behavior is\
    \ acceptable or even useful, but\n       the full implications should be understood\
    \ and the case carefully\n       weighed before implementing any behavior described\
    \ with this\n       label.\n   5.  MAY - This word, or the adjective \"OPTIONAL\"\
    , means that an item\n       is truly optional.  One vendor may choose to include\
    \ the item\n       because a particular marketplace requires it or because the\n\
    \       vendor feels that it enhances the product while another vendor\n     \
    \  may omit the same item.  An implementation which does not include\n       a\
    \ particular option MUST be prepared to interoperate with another\n       implementation\
    \ which does include the option, though perhaps with\n       reduced functionality.\
    \  In the same vein an implementation which\n       does include a particular\
    \ option MUST be prepared to interoperate\n       with another implementation\
    \ which does not include the option\n       (except, of course, for the feature\
    \ the option provides.)\n"
- title: Appendix B.  Random Integer Generation
  contents:
  - "Appendix B.  Random Integer Generation\n   It is easy to generate an integer\
    \ uniformly at random between zero\n   and (2^t)-1, inclusive, for some positive\
    \ integer t.  Generate a\n   random bit string that contains exactly t bits, and\
    \ then convert the\n   bit string to a non-negative integer by treating the bits\
    \ as the\n   coefficients in a base-2 expansion of an integer.\n   It is sometimes\
    \ necessary to generate an integer r uniformly at\n   random so that r satisfies\
    \ a certain property P, for example, lying\n   within a certain interval.  A simple\
    \ way to do this is with the\n   rejection method:\n   1.  Generate a candidate\
    \ number c uniformly at random from a set that\n       includes all numbers that\
    \ satisfy property P (plus some other\n       numbers, preferably not too many)\n\
    \   2.  If c satisfies property P, then return c.  Otherwise, return to\n    \
    \   Step 1.\n   For example, to generate a number between 1 and n-1, inclusive,\n\
    \   repeatedly generate integers between zero and (2^t)-1, inclusive,\n   stopping\
    \ at the first integer that falls within that interval.\n   Recommendations on\
    \ how to generate random bit strings are provided in\n   [RFC4086].\n"
- title: Appendix C.  Why Compact Representation Works
  contents:
  - "Appendix C.  Why Compact Representation Works\n   In the affine representation,\
    \ the x-coordinate of the point P^i does\n   not depend on the y-coordinate of\
    \ the point P, for any non-negative\n   exponent i and any point P.  This fact\
    \ can be seen as follows.  When\n   given only the x-coordinate of a point P,\
    \ it is not possible to\n   determine exactly what the y-coordinate is, but the\
    \ y value will be a\n   solution to the curve equation\n      y^2 = x^3 + a*x\
    \ + b (mod p).\n   There are at most two distinct solutions y = w and y = -w mod\
    \ p, and\n   the point P must be either Q=(x,w) or Q^-1=(x,-w).  Thus P^n is equal\n\
    \   to either Q^n or (Q^-1)^n = (Q^n)^-1.  These values have the same\n   x-coordinate.\
    \  Thus, the x-coordinate of a point P^i can be computed\n   from the x-coordinate\
    \ of a point P by computing one of the possible\n   values of the y coordinate\
    \ of P, then computing the ith power of P,\n   and then ignoring the y-coordinate\
    \ of that result.\n   In general, it is possible to compute a square root modulo\
    \ p by using\n   Shanks' method [K1981v2]; simple methods exist for some values\
    \ of p.\n   When p = 3 (mod 4), the square roots of z mod p are w and -w mod p,\n\
    \   where\n      w = z ^ ((p+1)/4) (mod p);\n   this observation is due to Lehmer\
    \ [L1969].  When p satisfies this\n   property, y can be computed from the curve\
    \ equation, and either y = w\n   or y = -w mod p, where\n      w = (x^3 + a*x\
    \ + b)^((p+1)/4) (mod p).\n   Square roots modulo p only exist for a quadratic\
    \ residue modulo p,\n   [R1988]; if z is not a quadratic residue, then there is\
    \ no number w\n   such that w^2 = z (mod p).  A simple way to verify that z is\
    \ a\n   quadratic residue after computing w is to verify that\n   w * w = z (mod\
    \ p).  If this relation does not hold for the above\n   equation, then the value\
    \ x is not a valid x-coordinate for a valid\n   elliptic curve point.  This is\
    \ an important consideration when ECDH\n   is used with compact output; see Section\
    \ 10.3.\n   The primes used in the P-256, P-384, and P-521 curves described in\n\
    \   [RFC5903] all have the property that p = 3 (mod 4).\n"
- title: Appendix D.  Example ECC Parameter Set
  contents:
  - "Appendix D.  Example ECC Parameter Set\n   For concreteness, we recall an elliptic\
    \ curve defined by Solinas and\n   Fu in [RFC5903] and referred to as P-256, which\
    \ is believed to\n   provide a 128-bit security level.  We use the notation of\n\
    \   Section 3.3, and express the generator in the affine coordinate\n   representation\
    \ g=(gx,gy), where the values gx and gy are in Fp.\n   p: FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\n\
    \   a: - 3\n   b: 5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\n\
    \   n: FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551\n   gx:\
    \ 6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\n   gy: 4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\n\
    \   Note that p can also be expressed as\n      p = 2^(256)-2^(224)+2^(192)+2^(96)-1.\n"
- title: Appendix E.  Additive and Multiplicative Notation
  contents:
  - "Appendix E.  Additive and Multiplicative Notation\n   The early publications\
    \ on elliptic curve cryptography used\n   multiplicative notation, but most modern\
    \ publications use additive\n   notation.  This section includes a table mapping\
    \ between those two\n   conventions.  In this section, a and b are elements of\
    \ an elliptic\n   curve group, and N is an integer.\n            +-------------------------+-----------------------+\n\
    \            | Multiplicative Notation | Additive Notation     |\n           \
    \ +-------------------------+-----------------------+\n            | multiplication\
    \          | addition              |\n            | a * b                   |\
    \ a + b                 |\n            | squaring                | doubling  \
    \            |\n            | a * a = a^2             | a + a = 2a           \
    \ |\n            | exponentiation          | scalar multiplication |\n       \
    \     | a^N = a * a * ... * a   | Na = a + a + ... + a  |\n            | inverse\
    \                 | inverse               |\n            | a^-1              \
    \      | -a                    |\n            +-------------------------+-----------------------+\n"
- title: Appendix F.  Algorithms
  contents:
  - "Appendix F.  Algorithms\n   This section contains a pseudocode description of\
    \ the elliptic curve\n   group operation.  Text that follows the symbol \"//\"\
    \ is to be\n   interpreted as comments rather than instructions.\n"
- title: F.1.  Affine Coordinates
  contents:
  - "F.1.  Affine Coordinates\n   To an arbitrary pair of elliptic curve points P\
    \ and Q specified by\n   their affine coordinates P=(x1,y1) and Q=(x2,y2), the\
    \ group operation\n   assigns a third point R = P*Q with the coordinates (x3,y3).\
    \  These\n   coordinates are computed as follows:\n     if P is (@,@),\n     \
    \   R = Q\n     else if Q is (@,@),\n        R = P\n     else if P is not equal\
    \ to Q and x1 is equal to x2,\n        R = (@,@)\n     else if P is not equal\
    \ to Q and x1 is not equal to x2,\n        x3 = ((y2-y1)/(x2-x1))^2 - x1 - x2\
    \ mod p and\n        y3 = (x1-x3)*(y2-y1)/(x2-x1) - y1 mod p\n     else if P is\
    \ equal to Q and y1 is equal to 0,\n        R = (@,@)\n     else    // P is equal\
    \ to Q and y1 is not equal to 0\n        x3 = ((3*x1^2 + a)/(2*y1))^2 - 2*x1 mod\
    \ p and\n        y3 = (x1-x3)*(3*x1^2 + a)/(2*y1) - y mod p.\n   From the first\
    \ and second case, it follows that the point at infinity\n   is the neutral element\
    \ of this operation, which is its own inverse.\n   From the curve equation, it\
    \ follows that for a given curve point P =\n   (x,y) distinct from the point at\
    \ infinity, (x,-y) also is a curve\n   point, and from the third and the fifth\
    \ case it follows that this is\n   the inverse of P, P^-1.\n   Note: The fifth\
    \ and sixth case are known as \"point squaring\".\n"
- title: F.2.  Homogeneous Coordinates
  contents:
  - "F.2.  Homogeneous Coordinates\n   An elliptic curve point (x,y) (other than the\
    \ point at infinity\n   (@,@)) is equivalent to a point (X,Y,Z) in homogeneous\
    \ coordinates\n   (with X, Y, and Z in Fp and not all three being zero at once)\n\
    \   whenever x=X/Z and y=Y/Z. \"Homogenous coordinates\" means that two\n   triples\
    \ (X,Y,Z) and (X',Y',Z') are regarded as \"equal\" (i.e.,\n   representing the\
    \ same point) if there is some nonzero s in Fp such\n   that X'=s*X, Y'=s*Y, and\
    \ Z'=s*Z.  The point at infinity (@,@) is\n   regarded as equivalent to the homogenous\
    \ coordinates (0,1,0), i.e.,\n   it can be represented by any triple (0,Y,0) with\
    \ nonzero Y in Fp.\n   Let P1=(X1,Y1,Z1) and P2=(X2,Y2,Z2) be points on the elliptic\
    \ curve,\n   and let u = Y2 * Z1 - Y1 * Z2 and v = X2 * Z1 - X1 * Z2.\n   We observe\
    \ that the points P1 and P2 are equal if and only if u and v\n   are both equal\
    \ to zero.  Otherwise, if either P1 or P2 are equal to\n   the point at infinity,\
    \ v is zero and u is nonzero (but the converse\n   implication does not hold).\n\
    \   Then, the product P3=(X3,Y3,Z3) = P1 * P2 is given by:\n     if P1 is the\
    \ point at infinity,\n        P3 = P2\n     else if P2 is the point at infinity,\n\
    \        P3 = P1\n     else if u is not equal to 0 but v is equal to 0,\n    \
    \    P3 = (0,1,0)\n     else if both u and v are not equal to 0,\n        X3 =\
    \ v * (Z2 * (Z1 * u^2 - 2 * X1 * v^2) - v^3)\n        Y3 = Z2 * (3 * X1 * u *\
    \ v^2 - Y1 * v^3 - Z1 * u^3) + u * v^3\n        Z3 = v^3 * Z1 * Z2\n     else\
    \    // P2 equals P1, P3 = P1 * P1\n         w = 3 * X1^2 + a * Z1^2\n       \
    \ X3 = 2 * Y1 * Z1 * (w^2 - 8 * X1 * Y1^2 * Z1)\n        Y3 = 4 * Y1^2 * Z1 *\
    \ (3 * w * X1 - 2 * Y1^2 * Z1) - w^3\n        Z3 = 8 * (Y1 * Z1)^3\n   It thus\
    \ turns out that the point at infinity is the identity element\n   and for P1=(X,Y,Z)\
    \ not equal to this point at infinity, P2=(X,-Y,Z)\n   represents P1^-1.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   David A. McGrew\n   Cisco Systems\n   510 McCarthy Blvd.\n\
    \   Milpitas, CA  95035\n   USA\n   Phone: (408) 525 8651\n   EMail: mcgrew@cisco.com\n\
    \   URI:   http://www.mindspring.com/~dmcgrew/dam.htm\n   Kevin M. Igoe\n   National\
    \ Security Agency\n   Commercial Solutions Center\n   United States of America\n\
    \   EMail: kmigoe@nsa.gov\n   Margaret Salter\n   National Security Agency\n \
    \  9800 Savage Rd.\n   Fort Meade, MD  20755-6709\n   USA\n   EMail: msalter@restarea.ncsc.mil\n"
