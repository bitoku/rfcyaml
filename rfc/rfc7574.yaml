- title: __initial_text__
  contents:
  - '              Peer-to-Peer Streaming Peer Protocol (PPSPP)

    '
- title: Abstract
  contents:
  - "Abstract\n   The Peer-to-Peer Streaming Peer Protocol (PPSPP) is a protocol for\n\
    \   disseminating the same content to a group of interested parties in a\n   streaming\
    \ fashion.  PPSPP supports streaming of both prerecorded (on-\n   demand) and\
    \ live audio/video content.  It is based on the peer-to-\n   peer paradigm, where\
    \ clients consuming the content are put on equal\n   footing with the servers\
    \ initially providing the content, to create a\n   system where everyone can potentially\
    \ provide upload bandwidth.  It\n   has been designed to provide short time-till-playback\
    \ for the end\n   user and to prevent disruption of the streams by malicious peers.\n\
    \   PPSPP has also been designed to be flexible and extensible.  It can\n   use\
    \ different mechanisms to optimize peer uploading, prevent\n   freeriding, and\
    \ work with different peer discovery schemes\n   (centralized trackers or Distributed\
    \ Hash Tables).  It supports\n   multiple methods for content integrity protection\
    \ and chunk\n   addressing.  Designed as a generic protocol that can run on top\
    \ of\n   various transport protocols, it currently runs on top of UDP using\n\
    \   Low Extra Delay Background Transport (LEDBAT) for congestion control.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7574.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2015 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................5\n\
    \      1.1. Purpose ....................................................5\n  \
    \    1.2. Requirements Language ......................................6\n    \
    \  1.3. Terminology ................................................6\n   2. Overall\
    \ Operation ...............................................9\n      2.1. Example:\
    \ Joining a Swarm ...................................9\n      2.2. Example: Exchanging\
    \ Chunks ................................10\n      2.3. Example: Leaving a Swarm\
    \ ..................................10\n   3. Messages .......................................................11\n\
    \      3.1. HANDSHAKE .................................................11\n  \
    \         3.1.1. Handshake Procedure ................................12\n    \
    \  3.2. HAVE ......................................................14\n      3.3.\
    \ DATA ......................................................15\n      3.4. ACK\
    \ .......................................................15\n      3.5. INTEGRITY\
    \ .................................................15\n      3.6. SIGNED_INTEGRITY\
    \ ..........................................16\n      3.7. REQUEST ...................................................16\n\
    \      3.8. CANCEL ....................................................16\n  \
    \    3.9. CHOKE and UNCHOKE .........................................17\n    \
    \  3.10. Peer Address Exchange ....................................17\n      \
    \     3.10.1. PEX_REQ and PEX_RES Messages ......................17\n      3.11.\
    \ Channels .................................................19\n      3.12. Keep\
    \ Alive Signaling .....................................20\n   4. Chunk Addressing\
    \ Schemes .......................................21\n      4.1. Start-End Ranges\
    \ ..........................................21\n           4.1.1. Chunk Ranges\
    \ .......................................21\n           4.1.2. Byte Ranges ........................................21\n\
    \      4.2. Bin Numbers ...............................................22\n  \
    \    4.3. In Messages ...............................................23\n    \
    \       4.3.1. In HAVE Messages ...................................23\n      \
    \     4.3.2. In ACK Messages ....................................24\n   5. Content\
    \ Integrity Protection ...................................24\n      5.1. Merkle\
    \ Hash Tree Scheme ...................................25\n      5.2. Content Integrity\
    \ Verification ............................26\n      5.3. The Atomic Datagram\
    \ Principle .............................27\n      5.4. INTEGRITY Messages ........................................28\n\
    \      5.5. Discussion and Overhead ...................................28\n  \
    \    5.6. Automatic Detection of Content Size .......................29\n    \
    \       5.6.1. Peak Hashes ........................................29\n      \
    \     5.6.2. Procedure ..........................................31\n   6. Live\
    \ Streaming .................................................32\n      6.1. Content\
    \ Authentication ....................................32\n           6.1.1. Sign\
    \ All ...........................................33\n           6.1.2. Unified\
    \ Merkle Tree ................................33\n                  6.1.2.1. Signed\
    \ Munro Hashes .......................34\n                  6.1.2.2. Munro Signature\
    \ Calculation ...............36\n                  6.1.2.3. Procedure .................................37\n\
    \                  6.1.2.4. Secure Tune In ............................37\n  \
    \    6.2. Forgetting Chunks .........................................38\n   7.\
    \ Protocol Options ...............................................38\n      7.1.\
    \ End Option ................................................39\n      7.2. Version\
    \ ...................................................39\n      7.3. Minimum Version\
    \ ...........................................40\n      7.4. Swarm Identifier ..........................................40\n\
    \      7.5. Content Integrity Protection Method .......................41\n  \
    \    7.6. Merkle Tree Hash Function .................................41\n    \
    \  7.7. Live Signature Algorithm ..................................42\n      7.8.\
    \ Chunk Addressing Method ...................................42\n      7.9. Live\
    \ Discard Window .......................................43\n      7.10. Supported\
    \ Messages .......................................44\n      7.11. Chunk Size ...............................................44\n\
    \   8. UDP Encapsulation ..............................................45\n  \
    \    8.1. Chunk Size ................................................45\n    \
    \  8.2. Datagrams and Messages ....................................46\n      8.3.\
    \ Channels ..................................................47\n      8.4. HANDSHAKE\
    \ .................................................47\n      8.5. HAVE ......................................................48\n\
    \      8.6. DATA ......................................................48\n  \
    \    8.7. ACK .......................................................49\n    \
    \  8.8. INTEGRITY .................................................50\n      8.9.\
    \ SIGNED_INTEGRITY ..........................................51\n      8.10. REQUEST\
    \ ..................................................52\n      8.11. CANCEL ...................................................52\n\
    \      8.12. CHOKE and UNCHOKE ........................................53\n  \
    \    8.13. PEX_REQ, PEX_RESv4, PEX_RESv6, and PEX_REScert ...........53\n    \
    \  8.14. KEEPALIVE ................................................55\n      8.15.\
    \ Flow and Congestion Control ..............................56\n      8.16. Example\
    \ of Operation .....................................57\n   9. Extensibility ..................................................61\n\
    \      9.1. Chunk Picking Algorithms ..................................61\n  \
    \    9.2. Reciprocity Algorithms ....................................62\n   10.\
    \ IANA Considerations ...........................................62\n      10.1.\
    \ PPSPP Message Type Registry ..............................62\n      10.2. PPSPP\
    \ Option Registry ....................................62\n      10.3. PPSPP Version\
    \ Number Registry ............................62\n      10.4. PPSPP Content Integrity\
    \ Protection Method Registry .......62\n      10.5. PPSPP Merkle Hash Tree Function\
    \ Registry .................63\n      10.6. PPSPP Chunk Addressing Method Registry\
    \ ...................63\n   11. Manageability Considerations ..................................63\n\
    \      11.1. Operations ...............................................63\n  \
    \         11.1.1. Installation and Initial Setup ....................63\n    \
    \       11.1.2. Migration Path ....................................64\n      \
    \     11.1.3. Requirements on Other Protocols and\n                   Functional\
    \ Components .............................64\n           11.1.4. Impact on Network\
    \ Operation .......................64\n           11.1.5. Verifying Correct Operation\
    \ .......................65\n           11.1.6. Configuration .....................................65\n\
    \      11.2. Management Considerations ................................66\n  \
    \         11.2.1. Management Interoperability and Information .......67\n    \
    \       11.2.2. Fault Management ..................................67\n      \
    \     11.2.3. Configuration Management ..........................67\n        \
    \   11.2.4. Accounting Management .............................68\n          \
    \ 11.2.5. Performance Management ............................68\n           11.2.6.\
    \ Security Management ...............................68\n   12. Security Considerations\
    \ .......................................68\n      12.1. Security of the Handshake\
    \ Procedure ......................68\n           12.1.1. Protection against Attack\
    \ 1 .......................69\n           12.1.2. Protection against Attack 2\
    \ .......................70\n           12.1.3. Protection against Attack 3 .......................70\n\
    \      12.2. Secure Peer Address Exchange .............................71\n  \
    \         12.2.1. Protection against the Amplification Attack .......71\n    \
    \       12.2.2. Example: Tracker as Certification Authority .......72\n      \
    \     12.2.3. Protection against Eclipse Attacks ................73\n      12.3.\
    \ Support for Closed Swarms ................................73\n      12.4. Confidentiality\
    \ of Streamed Content ......................74\n      12.5. Strength of the Hash\
    \ Function for Merkle Hash Trees ......74\n      12.6. Limit Potential Damage\
    \ and Resource Exhaustion by\n            Bad or Broken Peers ......................................74\n\
    \           12.6.1. HANDSHAKE .........................................75\n  \
    \         12.6.2. HAVE ..............................................75\n    \
    \       12.6.3. DATA ..............................................75\n      \
    \     12.6.4. ACK ...............................................75\n        \
    \   12.6.5. INTEGRITY and SIGNED_INTEGRITY ....................76\n          \
    \ 12.6.6. REQUEST ...........................................76\n           12.6.7.\
    \ CANCEL ............................................76\n           12.6.8. CHOKE\
    \ .............................................77\n           12.6.9. UNCHOKE\
    \ ...........................................77\n           12.6.10. PEX_RES ..........................................77\n\
    \           12.6.11. Unsolicited Messages in General ..................77\n  \
    \    12.7. Exclude Bad or Broken Peers ..............................77\n   13.\
    \ References ....................................................78\n      13.1.\
    \ Normative References .....................................78\n      13.2. Informative\
    \ References ...................................79\n   Acknowledgements ..................................................84\n\
    \   Authors' Addresses ................................................85\n"
- title: 1.  Introduction
  contents:
  - '1.  Introduction

    '
- title: 1.1.  Purpose
  contents:
  - "1.1.  Purpose\n   This document describes the Peer-to-Peer Streaming Peer Protocol\n\
    \   (PPSPP), designed for disseminating the same content to a group of\n   interested\
    \ parties in a streaming fashion.  PPSPP supports streaming\n   of both prerecorded\
    \ (on-demand) and live audio/video content.  It is\n   based on the peer-to-peer\
    \ paradigm where clients consuming the\n   content are put on equal footing with\
    \ the servers initially providing\n   the content, to create a system where everyone\
    \ can potentially\n   provide upload bandwidth.\n   PPSPP has been designed to\
    \ provide short time-till-playback for the\n   end user and to prevent disruption\
    \ of the streams by malicious peers.\n   Central in this design is a simple method\
    \ of identifying content\n   based on self-certification.  In particular, content\
    \ in PPSPP is\n   identified by a single cryptographic hash that is the root hash\
    \ in a\n   Merkle hash tree calculated recursively from the content [MERKLE]\n\
    \   [ABMRKL].  This self-certifying hash tree allows every peer to\n   directly\
    \ detect when a malicious peer tries to distribute fake\n   content.  The tree\
    \ can be used for both static and live content.\n   Moreover, it ensures only\
    \ a small amount of information is needed to\n   start a download and to verify\
    \ incoming chunks of content, thus\n   ensuring short start-up times.\n   PPSPP\
    \ has also been designed to be extensible for different\n   transports and use\
    \ cases.  Hence, PPSPP is a generic protocol that\n   can run directly on top\
    \ of UDP, TCP, or other protocols.  As such,\n   PPSPP defines a common set of\
    \ messages that make up the protocol,\n   which can have different representations\
    \ on the wire depending on the\n   lower-level protocol used.  When the lower-level\
    \ transport allows,\n   PPSPP can also use different congestion control algorithms.\n\
    \   At present, PPSPP is set to run on top of UDP using LEDBAT for\n   congestion\
    \ control [RFC6817].  Using LEDBAT enables PPSPP to serve\n   the content after\
    \ playback (seeding) without disrupting the user who\n   may have moved to different\
    \ tasks that use its network connection.\n   PPSPP is also flexible and extensible\
    \ in the mechanisms it uses to\n   promote client contribution and prevent freeriding,\
    \ that is, how to\n   deal with peers that only download content but never upload\
    \ to\n   others.  It also allows different schemes for chunk addressing and\n\
    \   content integrity protection, if the defaults are not fit for a\n   particular\
    \ use case.  In addition, it can work with different peer\n   discovery schemes,\
    \ such as centralized trackers or fast Distributed\n   Hash Tables [JIM11].  Finally,\
    \ in this default setup, PPSPP maintains\n   only a small amount of state per\
    \ peer.  A reference implementation of\n   PPSPP over UDP is available [SWIFTIMPL].\n\
    \   The protocol defined in this document assumes that a peer has already\n  \
    \ discovered a list of (initial) peers using, for example, a\n   centralized tracker\
    \ [PPSP-TP].  Once a peer has this list of peers,\n   PPSPP allows the peer to\
    \ connect to other peers, request chunks of\n   content, and discover other peers\
    \ disseminating the same content.\n   The design of PPSPP is based on our research\
    \ into making BitTorrent\n   [BITTORRENT] suitable for streaming content [P2PWIKI].\
    \  Most PPSPP\n   messages have corresponding BitTorrent messages and vice versa.\n\
    \   However, PPSPP is specifically targeted towards streaming audio/video\n  \
    \ content and optimizes time-till-playback.  It was also designed to be\n   more\
    \ flexible and extensible.\n"
- title: 1.2.  Requirements Language
  contents:
  - "1.2.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [RFC2119].\n"
- title: 1.3.  Terminology
  contents:
  - "1.3.  Terminology\n   message\n       The basic unit of PPSPP communication.\
    \  A message will have\n       different representations on the wire depending\
    \ on the transport\n       protocol used.  Messages are typically multiplexed\
    \ into a\n       datagram for transmission.\n   datagram\n       A sequence of\
    \ messages that is offered as a unit to the\n       underlying transport protocol\
    \ (UDP, etc.).  The datagram is\n       PPSPP's Protocol Data Unit (PDU).\n  \
    \ content\n       Either a live transmission or a prerecorded multimedia file.\n\
    \   chunk\n       The basic unit in which the content is divided.  For example,\
    \ a\n       block of N kilobytes.  A chunk may be of variable size.\n   chunk\
    \ ID\n       Unique identifier for a chunk of content (e.g., an integer).  Its\n\
    \       type depends on the chunk addressing scheme used.\n   chunk specification\n\
    \       An expression that denotes one or more chunk IDs.\n   chunk addressing\
    \ scheme\n       Scheme for identifying chunks and expressing the chunk\n    \
    \   availability map of a peer in a compact fashion.\n   chunk availability map\n\
    \       The set of chunks a peer has successfully downloaded and checked\n   \
    \    the integrity of.\n   bin\n       A number denoting a specific binary interval\
    \ of the content\n       (i.e., one or more consecutive chunks) in the bin numbers\
    \ chunk\n       addressing scheme (see Section 4).\n   content integrity protection\
    \ scheme\n       Scheme for protecting the integrity of the content while it is\n\
    \       being distributed via the peer-to-peer network.  That is, methods\n  \
    \     for receiving peers to detect whether a requested chunk has been\n     \
    \  modified, either maliciously by the sending peer or accidentally\n       in\
    \ transit.\n   hash\n       The result of applying a cryptographic hash function,\
    \ more\n       specifically a Modification Detection Code (MDC) [HAC01], such\
    \ as\n       SHA-256 [FIPS180-4], to a piece of data.\n   Merkle hash tree\n \
    \      A tree of hashes whose base is formed by the hashes of the chunks\n   \
    \    of content, and its higher nodes are calculated by recursively\n       computing\
    \ the hash of the concatenation of the two child hashes\n       (see Section 5.1).\n\
    \   root hash\n       The root in a Merkle hash tree calculated recursively from\
    \ the\n       content (see Section 5.1).\n   munro hash\n       The hash of a\
    \ subtree that is the unit of signing in the Unified\n       Merkle Tree content\
    \ authentication scheme for live streaming (see\n       Section 6.1.2.1).\n  \
    \ swarm\n       A group of peers participating in the distribution of the same\n\
    \       content.\n   swarm ID\n       Unique identifier for a swarm of peers,\
    \ in PPSPP a sequence of\n       bytes.  For video on demand with content integrity\
    \ protection\n       enabled, the identifier is the so-called root hash of a Merkle\n\
    \       hash tree over the content.  For live streaming, the swarm ID is\n   \
    \    a public key.\n   tracker\n       An entity that records the addresses of\
    \ peers participating in a\n       swarm, usually for a set of swarms, and makes\
    \ this membership\n       information available to other peers on request.\n \
    \  choking\n       When Peer A is choking Peer B, it means that A is currently\
    \ not\n       willing to accept requests for content from B.\n   seeding\n   \
    \    Peer A is said to be seeding when A has downloaded a static\n       content\
    \ file completely and is now offering it for others to\n       download.\n   leeching\n\
    \       Peer A is said to be leeching when A has not completely\n       downloaded\
    \ a static content file yet or is not offering to upload\n       it to others.\n\
    \   channel\n       A logical connection between two peers.  The channel concept\n\
    \       allows peers to use the same transport address for communicating\n   \
    \    with different peers.\n   channel ID\n       Unique, randomly chosen identifier\
    \ for a channel, local to each\n       peer.  So the two peers logically connected\
    \ by a channel each\n       have a different channel ID for that channel.\n  \
    \ heavy payload\n       A datagram has a heavy payload when it contains DATA messages,\n\
    \       SIGNED_INTEGRITY messages, or a large number of smaller messages.\n  \
    \ In this document the prefixes kilo-, mega-, etc., denote base 1024.\n"
- title: 2.  Overall Operation
  contents:
  - "2.  Overall Operation\n   The basic unit of communication in PPSPP is the message.\
    \  Multiple\n   messages are multiplexed into a single datagram for transmission.\
    \  A\n   datagram (and hence the messages it contains) will have different\n \
    \  representations on the wire depending on the transport protocol used\n   (see\
    \ Section 8).\n   The overall operation of PPSPP is illustrated in the following\n\
    \   examples.  The examples assume that the content distributed is\n   static,\
    \ UDP is used for transport, the Merkle Hash Tree scheme is\n   used for content\
    \ integrity protection, and that a specific policy is\n   used for selecting which\
    \ chunks to download.\n"
- title: '2.1.  Example: Joining a Swarm'
  contents:
  - "2.1.  Example: Joining a Swarm\n   Consider a user who wants to watch a video.\
    \  To play the video, the\n   user clicks on the play button of a HTML5 <video>\
    \ element shown in\n   his PPSPP-enabled browser.  Imagine this element has a\
    \ PPSPP URL (to\n   be defined elsewhere) identifying the video as its source.\
    \  The\n   browser passes this URL to its peer-to-peer streaming protocol\n  \
    \ handler.  Let's call this protocol handler Peer A.  Peer A parses the\n   URL\
    \ to retrieve the transport address of a peer-to-peer streaming\n   protocol tracker\
    \ and swarm metadata of the content.  The tracker\n   address may be optional\
    \ in the presence of a decentralized tracking\n   mechanism.  The mechanisms for\
    \ tracking peers are outside of the\n   scope of this document.\n   Peer A now\
    \ registers with the tracker following the peer-to-peer\n   streaming protocol\
    \ tracker specification [PPSP-TP] and receives the\n   IP address and port of\
    \ peers already in the swarm, say, Peers B, C,\n   and D.  At this point, the\
    \ PPSPP starts operating.  Peer A now sends\n   a datagram containing a PPSPP\
    \ HANDSHAKE message to Peers B, C, and D.\n   This message conveys protocol options.\
    \  In particular, Peer A\n   includes the ID of the swarm (part of the swarm metadata)\
    \ as a\n   protocol option because the destination peers can listen for multiple\n\
    \   swarms on the same transport address.\n   Peers B and C respond with datagrams\
    \ containing a PPSPP HANDSHAKE\n   message and one or more HAVE messages.  A HAVE\
    \ message conveys (part\n   of) the chunk availability of a peer; thus, it contains\
    \ a chunk\n   specification that denotes what chunks of the content Peers B and\
    \ C\n   have, respectively.  Peer D sends a datagram with a HANDSHAKE and\n  \
    \ HAVE messages, but also with a CHOKE message.  The latter indicates\n   that\
    \ Peer D is not willing to upload chunks to Peer A at present.\n"
- title: '2.2.  Example: Exchanging Chunks'
  contents:
  - "2.2.  Example: Exchanging Chunks\n   In response to Peers B and C, Peer A sends\
    \ new datagrams to Peers B\n   and C containing REQUEST messages.  A REQUEST message\
    \ indicates the\n   chunks that a peer wants to download; thus, it contains a\
    \ chunk\n   specification.  The REQUEST messages to Peers B and C refer to\n \
    \  disjoint sets of chunks.  Peers B and C respond with datagrams\n   containing\
    \ HAVE, DATA, and, in this example, INTEGRITY messages.  In\n   the Merkle hash\
    \ tree content protection scheme (see Section 5.1), the\n   INTEGRITY messages\
    \ contain all cryptographic hashes that Peer A needs\n   to verify the integrity\
    \ of the content chunk sent in the DATA\n   message.  Using these hashes, Peer\
    \ A verifies that the chunks\n   received from Peers B and C are correct against\
    \ the trusted swarm ID.\n   Peer A also updates the chunk availability of Peers\
    \ B and C using the\n   information in the received HAVE messages.  In addition,\
    \ it passes\n   the chunks of video to the user's browser for rendering.\n   After\
    \ processing, Peer A sends a datagram containing HAVE messages\n   for the chunks\
    \ it just received to all its peers.  In the datagram to\n   Peers B and C, it\
    \ includes an ACK message acknowledging the receipt\n   of the chunks and adds\
    \ REQUEST messages for new chunks.  ACK messages\n   are not used when a reliable\
    \ transport protocol is used.  When, for\n   example, Peer C finds that Peer A\
    \ obtained a chunk (from Peer B) that\n   Peer C did not yet have, Peer C's next\
    \ datagram includes a REQUEST\n   for that chunk.\n   Peer D also sends HAVE messages\
    \ to Peer A when it downloads chunks\n   from other peers.  When Peer D is willing\
    \ to accept REQUESTs from\n   Peer A, Peer D sends a datagram with an UNCHOKE\
    \ message to inform\n   Peer A.  If Peer B or C decides to choke Peer A, they\
    \ send a CHOKE\n   message and Peer A should then re-request from other peers.\
    \  Peers B\n   and C may continue to send HAVE, REQUEST, or periodic keep-alive\n\
    \   messages such that Peer A keeps sending them HAVE messages.\n   Once Peer\
    \ A has received all content (video-on-demand use case), it\n   stops sending\
    \ messages to all other peers that have all content\n   (a.k.a. seeders).  Peer\
    \ A can also contact the tracker or another\n   source again to obtain more peer\
    \ addresses.\n"
- title: '2.3.  Example: Leaving a Swarm'
  contents:
  - "2.3.  Example: Leaving a Swarm\n   To leave a swarm in a graceful way, Peer A\
    \ sends a specific HANDSHAKE\n   message to all its peers (see Section 8.4) and\
    \ deregisters from the\n   tracker following the tracker specification [PPSP-TP].\
    \  Peers\n   receiving the datagram should remove Peer A from their current peer\n\
    \   list.  If Peer A crashes ungracefully, peers should remove Peer A\n   from\
    \ their peer list when they detect it no longer sends messages\n   (see Section\
    \ 3.12).\n"
- title: 3.  Messages
  contents:
  - "3.  Messages\n   No error codes or responses are used in the protocol; absence\
    \ of any\n   response indicates an error.  Invalid messages are discarded, and\n\
    \   further communication with the peer SHOULD be stopped.  The rationale\n  \
    \ is that it is sufficient to classify peers as either good or bad and\n   only\
    \ use the good ones.  A good peer is a peer that responds with\n   chunks; a peer\
    \ that does not respond, or does not respond in time is\n   classified as bad.\
    \  The idea is that, in PPSPP, the content is\n   available from multiple sources\
    \ (unlike HTTP), so a peer should not\n   invest too much effort in trying to\
    \ obtain it from a particular\n   source.  This classification in good or bad\
    \ allows a peer to deal\n   with slow, crashed, and (silent) malicious peers.\n\
    \   Multiple messages MUST be multiplexed into a single datagram for\n   transmission.\
    \  Messages in a single datagram MUST be processed in the\n   strict order in\
    \ which they appear in the datagram.  If an invalid\n   message is found in a\
    \ datagram, the remaining messages MUST be\n   discarded.\n   For the sake of\
    \ simplicity, one swarm of peers deals with one content\n   file or stream only.\
    \  There is a single division of the content into\n   chunks that all peers in\
    \ the swarm adhere to, determined by the\n   content publisher.  Distribution\
    \ of a collection of files can be done\n   either by using multiple swarms or\
    \ by using an external storage\n   mapping from the linear byte space of a single\
    \ swarm to different\n   files, transparent to the protocol.  In other words,\
    \ the audio/video\n   container format used is outside the scope of this document.\n"
- title: 3.1.  HANDSHAKE
  contents:
  - "3.1.  HANDSHAKE\n   For Peer P to establish communication with Peer Q in Swarm\
    \ S, the\n   peers must first exchange HANDSHAKE messages by means of a handshake\n\
    \   procedure.  The initiating Peer P needs to know the metadata of Swarm\n  \
    \ S, which consists of:\n   (a)  the swarm ID of the content (see Sections 5.1\
    \ and 6),\n   (b)  the chunk size used,\n   (c)  the chunk addressing method used,\n\
    \   (d)  the content integrity protection method used, and\n   (e)  the Merkle\
    \ hash tree function used (if applicable).\n   (f)  If automatic content size\
    \ detection (see Section 5.6) is not\n        used, the content length is also\
    \ part of the metadata (for\n        static content.)\n   This document assumes\
    \ the swarm metadata is obtained from a trusted\n   source.  In addition, Peer\
    \ P needs to know a transport address for\n   Peer Q, obtained from a peer discovery/tracking\
    \ protocol.\n   The payload of the HANDSHAKE message contains a sequence of protocol\n\
    \   options.  The protocol options encode the swarm metadata just\n   described\
    \ to enable an end-to-end check to see whether the peers are\n   in the right\
    \ swarm.  Additionally, the options encode a number of\n   per-peer configuration\
    \ parameters.  The complete set of protocol\n   options are specified in Section\
    \ 7.  The HANDSHAKE message also\n   contains a channel ID for multiplexing communication\
    \ and security\n   (see Sections 3.11 and 12.1).  A HANDSHAKE message MUST always\
    \ be the\n   first message in a datagram.\n"
- title: 3.1.1.  Handshake Procedure
  contents:
  - "3.1.1.  Handshake Procedure\n   The handshake procedure for a peer, Peer P, to\
    \ start communication\n   with another peer, Peer Q, in Swarm S is now as follows.\n\
    \   1.  The first datagram the initiating Peer P sends to Peer Q MUST\n      \
    \ start with a HANDSHAKE message.  This HANDSHAKE message MUST\n       contain:\n\
    \       *  A channel ID, chanP, randomly chosen as specified in\n          Section\
    \ 12.1.\n       *  The metadata of Swarm S, encoded as protocol options, as\n\
    \          specified in Section 7.  In particular, the initiating Peer P\n   \
    \       MUST include the swarm ID.\n       *  The capabilities of Peer P, in particular,\
    \ its supported\n          protocol versions, \"Live Discard Window\" (in case\
    \ of a live\n          swarm) and \"Supported Messages\", encoded as protocol\
    \ options.\n       This first datagram MUST be prefixed with the (destination)\n\
    \       channel ID 0; see Section 3.11.  Hence, the datagram contains two\n  \
    \     channel IDs: the destination channel ID prefixed to the datagram\n     \
    \  and the channel ID chanP included in the HANDSHAKE message inside\n       the\
    \ datagram.  This datagram MAY also contain some minor\n       additional payload,\
    \ e.g., HAVE messages to indicate Peer P's\n       current progress, but it MUST\
    \ NOT include any heavy payload\n       (defined in Section 1.3), such as a DATA\
    \ message.  Allowing minor\n       payload minimizes the number of initialization\
    \ round trips, thus\n       improving time-till-playback.  Forbidding heavy payload\
    \ prevents\n       an amplification attack (see Section 12.1).\n   2.  The receiving\
    \ Peer Q checks the HANDSHAKE message from Peer P.\n       If any check by Peer\
    \ Q fails, or if Peers P and Q are not in the\n       same swarm, Peer Q MUST\
    \ NOT send a HANDSHAKE (or any other)\n       message back, as the message from\
    \ Peer P may have been spoofed\n       (see Section 12.1).  Otherwise, if Peer\
    \ Q is interested in\n       communicating with Peer P, Peer Q MUST send a datagram\
    \ to Peer P\n       that starts with a HANDSHAKE message.  This reply HANDSHAKE\
    \ MUST\n       contain:\n       *  A channel ID, chanQ, randomly chosen as specified\
    \ in\n          Section 12.1.\n       *  The metadata of Swarm S, encoded as protocol\
    \ options, as\n          specified in Section 7.  In particular, the responding\
    \ Peer Q\n          MAY include the swarm ID.\n       *  The capabilities of Peer\
    \ Q, in particular, its supported\n          protocol versions, its \"Live Discard\
    \ Window\" (in case of a\n          live swarm) and \"Supported Messages\", encoded\
    \ as protocol\n          options.\n       This reply datagram MUST be prefixed\
    \ with the channel ID chanP\n       sent by Peer P in the first HANDSHAKE message\
    \ (see Section 3.11).\n       This reply datagram MAY also contain some minor\
    \ additional\n       payload, e.g., HAVE messages to indicate Peer Q's current\n\
    \       progress, or REQUEST messages (see Section 3.7), but it MUST NOT\n   \
    \    include any heavy payload.\n   3.  The initiating Peer P checks the reply\
    \ datagram from Peer Q.  If\n       the reply datagram is not prefixed with (destination)\
    \ channel ID\n       chanP, Peer P MUST discard the datagram.  Peer P SHOULD continue\n\
    \       to process datagrams from Peer Q that do meet this requirement.\n    \
    \   This check prevents interference by spoofing, see Section 12.1.\n       If\
    \ Peer P's channel ID is echoed correctly, the initiator Peer P\n       knows\
    \ that the addressed Peer Q really responds.\n   4.  Next, Peer P checks the HANDSHAKE\
    \ message in the datagram from\n       Peer Q.  If any check by Peer P fails,\
    \ or Peer P is no longer\n       interested in communicating with Peer Q, Peer\
    \ P MAY send a\n       HANDSHAKE message to inform Peer Q it will cease communication.\n\
    \       This closing HANDSHAKE message MUST contain an all zeros channel\n   \
    \    ID and a list of protocol options.  The list MUST either be empty\n     \
    \  or contain the maximum version number Peer P supports, following\n       the\
    \ min/max versioning scheme defined in [RFC6709], Section 4.1.\n       The datagram\
    \ containing this closing HANDSHAKE message MUST be\n       prefixed with the\
    \ (destination) channel ID chanQ.  Peer P MAY\n       also simply cease communication.\n\
    \   5.  If the addressed peer, Peer Q, does not respond to initiating\n      \
    \ Peer P's first datagram, Peer P MAY resend that datagram until\n       Peer\
    \ Q is considered dead, according to the rules specified in\n       Section 3.12.\n\
    \   6.  If the reply datagram by Peer Q does pass the checks by Peer P,\n    \
    \   and Peer P wants to continue interacting with Peer Q, Peer P can\n       now\
    \ send REQUEST, PEX_REQ, and other messages to Peer Q.\n       Datagrams carrying\
    \ these messages MUST be prefixed with the\n       channel ID chanQ sent by Peer\
    \ Q.  More specifically, because Peer\n       P knows that Peer Q really responds,\
    \ Peer P MAY start sending\n       Peer Q messages with heavy payload.  That means\
    \ that Peer P MAY\n       start responding to any REQUEST messages that Peer Q\
    \ may have\n       sent in this first reply datagram with DATA messages.  Hence,\n\
    \       transfer of chunks can start soon in PPSPP.\n   7.  If Peer Q receives\
    \ any datagram (apparently) from Peer P that\n       does not contain channel\
    \ ID chanQ, Peer Q MUST discard the\n       datagram but SHOULD continue to process\
    \ datagrams from Peer P\n       that do meet this requirement.  Once Peer Q receives\
    \ a datagram\n       from Peer P that does contain the channel ID chanQ, Peer\
    \ Q knows\n       that Peer P really received its reply datagram, and the three-way\n\
    \       handshake and channel establishment is complete.  Peer Q MAY now\n   \
    \    also start sending messages with heavy payload to Peer P.\n   8.  If Peer\
    \ P decides it no longer wants to communicate with Peer Q,\n       or vice versa,\
    \ the peer SHOULD send a closing HANDSHAKE message\n       to the other, as described\
    \ above.\n"
- title: 3.2.  HAVE
  contents:
  - "3.2.  HAVE\n   The HAVE message is used to convey which chunks a peer has available\n\
    \   for download.  The set of chunks it has available may be expressed\n   using\
    \ different chunk addressing and availability map compression\n   schemes, described\
    \ in Section 4.  HAVE messages can be used both for\n   sending a complete overview\
    \ of a peer's chunk availability as well as\n   for updates to that set.\n   In\
    \ particular, whenever a receiving Peer P has successfully checked\n   the integrity\
    \ of a chunk, or interval of chunks, it MUST send a HAVE\n   message to all peers\
    \ Q1..Qn it wants to allow to download those\n   chunks.  A policy in Peer P determines\
    \ when the HAVE is sent.  Peer P\n   may send it directly, or Peer P may wait\
    \ either until it has other\n   data to send to Peer Qi or until it has received\
    \ and checked multiple\n   chunks.  The policy will depend on how urgent it is\
    \ to distribute\n   this information to the other peers.  This urgency is generally\n\
    \   determined in turn by the chunk picking policy (see Section 9.1).  In\n  \
    \ general, the HAVE messages can be piggybacked onto other messages.\n   Peers\
    \ that do not receive HAVE messages are effectively prevented\n   from downloading\
    \ the newly available chunks; hence, the HAVE message\n   can be used as a method\
    \ of choking.\n   The HAVE message MUST contain the chunk specification of the\
    \ received\n   and verified chunks.  A receiving peer MUST NOT send a HAVE message\n\
    \   to peers for which the handshake procedure is still incomplete, see\n   Section\
    \ 12.1.  A peer SHOULD NOT send a HAVE message to peers that\n   have the complete\
    \ content already (e.g., in video-on-demand\n   scenarios).\n"
- title: 3.3.  DATA
  contents:
  - "3.3.  DATA\n   The DATA message is used to transfer chunks of content.  The DATA\n\
    \   message MUST contain the chunk ID of the chunk and chunk itself.  A\n   peer\
    \ MAY send the DATA messages for multiple chunks in the same\n   datagram.  The\
    \ DATA message MAY contain additional information if\n   needed by the specific\
    \ congestion control mechanism used.  At\n   present, PPSPP uses LEDBAT [RFC6817]\
    \ for congestion control, which\n   requires the current system time to be sent\
    \ along with the DATA\n   message, so the current system time MUST be included.\n"
- title: 3.4.  ACK
  contents:
  - "3.4.  ACK\n   ACK messages MUST be sent to acknowledge received chunks if PPSPP\
    \ is\n   run over an unreliable transport protocol.  ACK messages MAY be sent\n\
    \   if a reliable transport protocol is used.  In the former case, a\n   receiving\
    \ peer that has successfully checked the integrity of a\n   chunk, or interval\
    \ of chunks C, MUST send an ACK message containing a\n   chunk specification for\
    \ C.  As LEDBAT is used, an ACK message MUST\n   contain the one-way delay, computed\
    \ from the peer's current system\n   time received in the DATA message.  A peer\
    \ MAY delay sending ACK\n   messages as defined in the LEDBAT specification [RFC6817].\n"
- title: 3.5.  INTEGRITY
  contents:
  - "3.5.  INTEGRITY\n   The INTEGRITY message carries information required by the\
    \ receiver to\n   verify the integrity of a chunk.  Its payload depends on the\
    \ content\n   integrity protection scheme used.  When the Merkle Hash Tree scheme\n\
    \   is used, an INTEGRITY message MUST contain a cryptographic hash of a\n   subtree\
    \ of the Merkle hash tree and the chunk specification that\n   identifies the\
    \ subtree.\n   As a typical example, when a peer wants to send a chunk and Merkle\n\
    \   hash trees are used, it creates a datagram that consists of several\n   INTEGRITY\
    \ messages containing the hashes the receiver needs to verify\n   the chunk and\
    \ the actual chunk itself encoded in a DATA message.\n   What are the necessary\
    \ hashes and the exact rules for encoding them\n   into datagrams is specified\
    \ in Sections 5.3, and 5.4, respectively.\n"
- title: 3.6.  SIGNED_INTEGRITY
  contents:
  - "3.6.  SIGNED_INTEGRITY\n   The SIGNED_INTEGRITY message carries digitally signed\
    \ information\n   required by the receiver to verify the integrity of a chunk\
    \ in live\n   streaming.  It logically contains a chunk specification, a timestamp,\n\
    \   and a digital signature.  Its exact payload depends on the live\n   content\
    \ integrity protection scheme used, see Section 6.1.\n"
- title: 3.7.  REQUEST
  contents:
  - "3.7.  REQUEST\n   While bulk download protocols normally do explicit requests\
    \ for\n   certain ranges of data (i.e., use a pull model, for example,\n   BitTorrent\
    \ [BITTORRENT]), live streaming protocols quite often use a\n   push model without\
    \ requests to save round trips.  PPSPP supports both\n   models of operation.\n\
    \   The REQUEST message is used to request one or more chunks from\n   another\
    \ peer.  A REQUEST message MUST contain the specification of\n   the chunks the\
    \ requester wants to download.  A peer receiving a\n   REQUEST message MAY send\
    \ out the requested chunks (by means of DATA\n   messages).  When Peer Q receives\
    \ multiple REQUESTs from the same Peer\n   P, Peer Q SHOULD process the REQUESTs\
    \ in the order received.\n   Multiple REQUEST messages MAY be sent in one datagram,\
    \ for example,\n   when a peer wants to request several rare chunks at once.\n\
    \   When live streaming via a push model, a peer receiving REQUESTs also\n   MAY\
    \ send some other chunks in case it runs out of requests or for\n   some other\
    \ reason.  In that case, the only purpose of REQUEST\n   messages is to provide\
    \ hints and coordinate peers to avoid\n   unnecessary data retransmission.\n"
- title: 3.8.  CANCEL
  contents:
  - "3.8.  CANCEL\n   When downloading on-demand or live streaming content, a peer\
    \ can\n   request urgent data from multiple peers to increase the probability\n\
    \   of it being delivered on time.  In particular, when the specific\n   chunk\
    \ picking algorithm (see Section 9.1), detects that a request for\n   urgent data\
    \ might not be served on time, a request for the same data\n   can be sent to\
    \ a different peer.  When a Peer P decides to request\n   urgent data from a Peer\
    \ Q, Peer P SHOULD send a CANCEL message to all\n   the peers to which the data\
    \ has been previously requested.  The\n   CANCEL message contains the specification\
    \ of the chunks Peer P no\n   longer wants to request.  In addition, when Peer\
    \ Q receives a HAVE\n   message for the urgent data from Peer P, Peer Q MUST also\
    \ cancel the\n   previous REQUEST(s) from Peer P.  In other words, the HAVE message\n\
    \   acts as an implicit CANCEL.\n"
- title: 3.9.  CHOKE and UNCHOKE
  contents:
  - "3.9.  CHOKE and UNCHOKE\n   Peer A can send a CHOKE message to Peer B to signal\
    \ it will no longer\n   be responding to REQUEST messages from Peer B, for example,\
    \ because\n   Peer A's upload capacity is exhausted.  Peer A MAY send a subsequent\n\
    \   UNCHOKE message to signal that it will respond to new REQUESTs from\n   Peer\
    \ B again (Peer A SHOULD discard old requests).  When Peer B\n   receives a CHOKE\
    \ message from Peer A, it MUST NOT send new REQUEST\n   messages and it cannot\
    \ expect answers to any outstanding ones, as the\n   transfer of chunks is choked.\
    \  When Peer B is choked but receives a\n   HAVE message from Peer A, it is not\
    \ automatically unchoked and MUST\n   NOT send any new REQUEST messages.  The\
    \ CHOKE and UNCHOKE messages\n   are informational as responding to REQUESTs is\
    \ OPTIONAL, see\n   Section 3.7.\n"
- title: 3.10.  Peer Address Exchange
  contents:
  - '3.10.  Peer Address Exchange

    '
- title: 3.10.1.  PEX_REQ and PEX_RES Messages
  contents:
  - "3.10.1.  PEX_REQ and PEX_RES Messages\n   Peer Exchange (PEX) messages are common\
    \ in many peer-to-peer\n   protocols.  They allow peers to exchange the transport\
    \ addresses of\n   the peers they are currently interacting with, thereby reducing\
    \ the\n   need to contact a central tracker (or Distributed Hash Table) to\n \
    \  discovery new peers.  The strength of this mechanism is therefore\n   that\
    \ it enables decentralized peer discovery: after an initial\n   bootstrap, a central\
    \ tracker is no longer needed.  Its weakness is\n   that it enables a number of\
    \ attacks, so it should not be used on the\n   Internet unless extra security\
    \ measures are in place.\n   PPSPP supports peer-address exchange on the Internet\
    \ and in benign\n   private networks as an OPTIONAL feature (not mandatory to\
    \ implement)\n   under certain conditions.  The general mechanism works as follows.\n\
    \   To obtain some peer addresses, a Peer A MAY send a PEX_REQ message to\n  \
    \ Peer B.  Peer B MAY respond with one or more PEX_REScert messages.\n   Logically,\
    \ a PEX_REScert reply message contains the address of a\n   single peer Ci.  Peer\
    \ B MUST have exchanged messages with Peer Ci in\n   the last 60 seconds to guarantee\
    \ liveliness.  Upon receipt, Peer A\n   may contact any or none of the returned\
    \ peers Ci.  Alternatively,\n   peers MAY ignore PEX_REQ and PEX_REScert messages\
    \ if uninterested in\n   obtaining new peers or because of security considerations\
    \ (rate\n   limiting) or any other reason.  The PEX messages can be used to\n\
    \   construct a dedicated tracker peer.\n   To use PEX in PPSPP on the Internet,\
    \ two conditions must be met:\n   1.  Peer transport addresses must be relatively\
    \ stable.\n   2.  A peer must not obtain all its peer addresses through PEX.\n\
    \   The full security analysis for PEX messages can be found in\n   Section 12.2.\
    \  Physically, a PEX_REScert message carries a swarm-\n   membership certificate\
    \ rather than an IP address and port.  A\n   membership certificate for Peer C\
    \ states that Peer C at address\n   (ipC,portC) is part of Swarm S at Time T and\
    \ is cryptographically\n   signed by an issuer.  The receiver Peer A can check\
    \ the certificate\n   for a valid signature by a trusted issuer, the right swarm,\
    \ and\n   liveliness and only then consider contacting C.  These swarm-\n   membership\
    \ certificates correspond to signed node descriptors in\n   secure decentralized\
    \ peer sampling services [SPS].\n   Several designs are possible for the security\
    \ environment for these\n   membership certificates.  That is, there are different\
    \ designs\n   possible for who signs the membership certificates and how public\n\
    \   keys are distributed.  Section 12.2.2 describes an example where a\n   central\
    \ tracker acts as the Certification Authority.\n   In a hostile environment, such\
    \ as the Internet, peers must also\n   ensure that they do not end up interacting\
    \ only with malicious peers\n   when using the peer-address exchange feature.\
    \  To this extent, peers\n   MUST ensure that part of their connections are to\
    \ peers whose\n   addresses came from a trusted and secured tracker (see\n   Section\
    \ 12.2.3).\n   In addition to the PEX_REScert, there are two other PEX reply\n\
    \   messages.  The PEX_RESv4 message contains a single IPv4 address and\n   port.\
    \  The PEX_RESv6 message contains a single IPv6 address and port.\n   They MUST\
    \ only be used in a benign environment, such as a private\n   network, as they\
    \ provide no guarantees that the host addressed\n   actually participates in a\
    \ PPSPP swarm.\n   Once a PPSPP implementation has obtained a list of peers (either\
    \ via\n   PEX, from a central tracker, or via a Distributed Hash Table (DHT)),\n\
    \   it has to determine which peers to actually contact.  In this\n   process,\
    \ a PPSPP implementation can benefit from information by\n   network or content\
    \ providers to help improve network usage and boost\n   PPSPP performance.  How\
    \ a peer-to-peer (P2P) system like PPSPP can\n   perform these optimizations using\
    \ the Application-Layer Traffic\n   Optimization (ALTO) protocol is described\
    \ in detail in [RFC7285],\n   Section 7.\n"
- title: 3.11.  Channels
  contents:
  - "3.11.  Channels\n   It is increasingly complex for peers to enable communication\
    \ between\n   each other due to NATs and firewalls.  Therefore, PPSPP uses a\n\
    \   multiplexing scheme, called channels, to allow multiple swarms to use\n  \
    \ the same transport address.  Channels loosely correspond to TCP\n   connections\
    \ and each channel belongs to a single swarm, as\n   illustrated in Figure 1.\
    \  As with TCP connections, a channel is\n   identified by a unique identifier\
    \ local to the peer at each end of\n   the connection (cf.  TCP port), which MUST\
    \ be randomly chosen.  In\n   other words, the two peers connected by a channel\
    \ use different IDs\n   to denote the same channel.  The IDs are different and\
    \ random for\n   security reasons, see Section 12.1.\n   In the PPSP-over-UDP\
    \ encapsulation (Section 8.3), when a Channel C\n   has been established between\
    \ Peer A and Peer B, the datagrams\n   containing messages from Peer A to Peer\
    \ B are prefixed with the four-\n   byte channel ID allocated by Peer B, and vice\
    \ versa for datagrams\n   from Peer B to A.  The channel IDs used are exchanged\
    \ as part of the\n   handshake procedure, see Section 8.4.  In that procedure,\
    \ the channel\n   ID with value 0 is used for the datagram that initiates the\n\
    \   handshake.  PPSPP can be used in combination with Session Traversal\n   Utilities\
    \ for NAT (STUN) [RFC5389].\n               _________    _________          _________\n\
    \               |       |    |       |          |       |\n               | Swarm\
    \ |    | Swarm |          | Swarm |\n               |  Mgr  |    |   A   |   \
    \       |   B   |\n               |_______|    |_______|          |_______|\n\
    \                   |            |                /   \\\n                   |\
    \            |               /     \\\n               ____|____    ____|____ \
    \   ______/__    _\\_______\n               |       |    |       |    |      \
    \ |    |       |\n               | Chan  |    | Chan  |    | Chan  |    | Chan\
    \  |\n               |   0   |    |  481  |    |  836  |    |  372  |\n      \
    \         |_______|    |_______|    |_______|    |_______|\n                 \
    \  |            |            |            |\n                   |            |\
    \            |            |\n               ____|____________|____________|____________|____\n\
    \               |                                              |\n           \
    \    |                      UDP                     |\n               |      \
    \             port 6778                  |\n               |______________________________________________|\n\
    \   Network stack of a PPSPP peer that is reachable on UDP port 6778 and\n   is\
    \ connected via channel 481 to one peer in Swarm A and two peers in\n     Swarm\
    \ B via channels 836 and 372, respectively.  Channel ID 0 is\n               \
    \    special and is used for handshaking.\n                                 Figure\
    \ 1\n"
- title: 3.12.  Keep Alive Signaling
  contents:
  - "3.12.  Keep Alive Signaling\n   A peer SHOULD send a \"keep alive\" message periodically\
    \ to each peer\n   it is interested in, but has no other messages to send to them\
    \ at\n   present.  The goal of the keep alives is to keep a signaling channel\n\
    \   open to peers that are of interest.  Which peers those are is\n   determined\
    \ by a policy that decides which peers are of interest now\n   and in the near\
    \ future.  This document does not prescribe a policy,\n   but examples of interesting\
    \ peers are (a) peers that have chunks on\n   offer that this client needs or\
    \ (b) peers that currently do not have\n   interesting chunks on offer (because\
    \ they are still downloading\n   themselves, or in live streaming) but gave good\
    \ performance in the\n   past.  When these peers have new chunks to offer, the\
    \ peer that kept\n   a signaling channel open can use them again.  Periodically\
    \ sending\n   \"keep alive\" messages prevents other peers declaring the peer\
    \ dead.\n   A guideline for declaring a peer dead when using UDP consists of a\n\
    \   three minute delay since that last packet has been received from that\n  \
    \ peer and at least three datagrams having been sent to that peer\n   during the\
    \ same period.  When a peer is declared dead, the channel to\n   it is closed,\
    \ no more messages will be sent to that peer and the\n   local administration\
    \ about the peer is discarded.  Busy servers can\n   force idle clients to disconnect\
    \ by not sending keep alives.  PPSPP\n   does not define an explicit message type\
    \ for \"keep alive\" messages.\n   In the PPSP-over-UDP encapsulation they are\
    \ implemented as simple\n   datagrams consisting of a four-byte channel ID only,\
    \ see Sections 8.3\n   and 8.4.\n"
- title: 4.  Chunk Addressing Schemes
  contents:
  - "4.  Chunk Addressing Schemes\n   PPSPP can use different methods of chunk addressing,\
    \ that is, support\n   different ways of identifying chunks and different ways\
    \ of expressing\n   the chunk availability map of a peer in a compact fashion.\n\
    \   All peers in a swarm MUST use the same chunk addressing method.\n"
- title: 4.1.  Start-End Ranges
  contents:
  - "4.1.  Start-End Ranges\n   A chunk specification consists of a single (start\
    \ specification,end\n   specification) pair that identifies a range of chunks\
    \ (end\n   inclusive).  The start and end specifications can use one of multiple\n\
    \   addressing schemes.  Two schemes are currently defined: chunk ranges\n   and\
    \ byte ranges.\n"
- title: 4.1.1.  Chunk Ranges
  contents:
  - "4.1.1.  Chunk Ranges\n   The start and end specification are both chunk identifiers.\
    \  Chunk\n   identifiers are 32-bit or 64-bit unsigned integers.  A PPSPP peer\n\
    \   MUST support this scheme.\n    0                   1                   2 \
    \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ~                    Start chunk (32 or 64)                     ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ~                    End chunk (32 or 64)                       ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 4.1.2.  Byte Ranges
  contents:
  - "4.1.2.  Byte Ranges\n   The start and end specification are 64-bit byte offsets\
    \ in the\n   content.  The support for this scheme is OPTIONAL.\n    0       \
    \            1                   2                   3\n    0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Start byte offset (64)                     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    End byte offset (64)                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 4.2.  Bin Numbers
  contents:
  - "4.2.  Bin Numbers\n   PPSPP introduces a novel method of addressing chunks of\
    \ content\n   called \"bin numbers\" (or \"bins\" for short).  Bin numbers allow\
    \ the\n   addressing of a binary interval of data using a single integer.  This\n\
    \   reduces the amount of state that needs to be recorded per peer and\n   the\
    \ space needed to denote intervals on the wire, making the protocol\n   lightweight.\
    \  In general, this numbering system allows PPSPP to work\n   with simpler data\
    \ structures, e.g., to use arrays instead of binary\n   trees, thus reducing complexity.\
    \  The support for this scheme is\n   OPTIONAL.\n   In bin addressing, the smallest\
    \ binary interval is a single chunk\n   (e.g., a block of bytes that may be of\
    \ variable size), the largest\n   interval is a complete range of 2**63 chunks.\
    \  In a novel addition to\n   the classical scheme, these intervals are numbered\
    \ in a way that lays\n   them out into a vector nicely, which is called bin numbering,\
    \ as\n   follows.  Consider a chunk interval of width W.  To derive the bin\n\
    \   numbers of the complete interval and the subintervals, a minimal\n   balanced\
    \ binary tree is built that is at least W chunks wide at the\n   base.  The leaves\
    \ from left-to-right correspond to the chunks 0..W-1\n   in the interval, and\
    \ have bin number I*2 where I is the index of the\n   chunk (counting beyond W-1\
    \ to balance the tree).  The bin number of\n   higher-level node P in the tree\
    \ is calculated as follows:\n       binP = (binL + binR) / 2\n   where binL is\
    \ the bin of node P's left-hand child and binR is the bin\n   of node P's right-hand\
    \ child.  Given that each node in the tree\n   represents a subinterval of the\
    \ original interval, each such\n   subinterval now is addressable by a bin number,\
    \ a single integer.\n   The bin number tree of an interval of width W=8 looks\
    \ like this:\n                                   7\n                         \
    \         / \\\n                                /     \\\n                   \
    \           /         \\\n                            /             \\\n     \
    \                      3                11\n                          / \\   \
    \           / \\\n                         /   \\            /   \\\n        \
    \                /     \\          /     \\\n                       1       5\
    \        9       13\n                      / \\     / \\      / \\      / \\\n\
    \                     0   2   4   6    8   10  12   14\n                     C0\
    \  C1  C2  C3   C4  C5  C6   C7\n              The bin number tree of an interval\
    \ of width W=8\n                                 Figure 2\n   So bin 7 represents\
    \ the complete interval, bin 3 represents the\n   interval of chunk C0..C3, bin\
    \ 1 represents the interval of chunks C0\n   and C1, and bin 2 represents chunk\
    \ C1.  The special numbers\n   0xFFFFFFFF (32-bit) or 0xFFFFFFFFFFFFFFFF (64-bit)\
    \ stands for an\n   empty interval, and 0x7FFF...FFF stands for \"everything\"\
    .\n   When bin numbering is used, the ID of a chunk is its corresponding\n   (leaf)\
    \ bin number in the tree, and the chunk specification in HAVE\n   and ACK messages\
    \ is equal to a single bin number (32-bit or 64-bit),\n   as follows.\n    0 \
    \                  1                   2                   3\n    0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ~                    Bin number (32 or 64)                      ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 4.3.  In Messages
  contents:
  - '4.3.  In Messages

    '
- title: 4.3.1.  In HAVE Messages
  contents:
  - "4.3.1.  In HAVE Messages\n   When a receiving peer has successfully checked the\
    \ integrity of a\n   chunk or interval of chunks, it MUST send a HAVE message\
    \ to all peers\n   it wants to allow download of those chunk(s) from.  The ability\
    \ to\n   withhold HAVE messages allows them to be used as a method of choking.\n\
    \   The HAVE message MUST contain the chunk specification of the biggest\n   complete\
    \ interval of all chunks the receiver has received and checked\n   so far that\
    \ fully includes the interval of chunks just received.  So\n   the chunk specification\
    \ MUST denote at least the interval received,\n   but the receiver is supposed\
    \ to aggregate and acknowledge bigger\n   intervals, when possible.\n   As a result,\
    \ every single chunk is acknowledged a logarithmic number\n   of times.  That\
    \ provides some necessary redundancy of\n   acknowledgements and sufficiently\
    \ compensates for unreliable\n   transport protocols.\n   Implementation note:\n\
    \       To record which chunks a peer has in the state that an\n       implementation\
    \ keeps for each peer, an implementation MAY use the\n       efficient \"binmap\"\
    \ data structure, which is a hybrid of a bitmap\n       and a binary tree, discussed\
    \ in detail in [BINMAP].\n"
- title: 4.3.2.  In ACK Messages
  contents:
  - "4.3.2.  In ACK Messages\n   PPSPP peers MUST use ACK messages to acknowledge\
    \ received chunks if\n   an unreliable transport protocol is used.  When a receiving\
    \ peer has\n   successfully checked the integrity of a chunk or interval of chunks\n\
    \   C, it MUST send an ACK message containing the chunk specification of\n   its\
    \ biggest, complete interval covering C to the sending peer (see\n   HAVE).\n"
- title: 5.  Content Integrity Protection
  contents:
  - "5.  Content Integrity Protection\n   PPSPP can use different methods for protecting\
    \ the integrity of the\n   content while it is being distributed via the peer-to-peer\
    \ network.\n   More specifically, PPSPP can use different methods for receiving\n\
    \   peers to detect whether a requested chunk has been maliciously\n   modified\
    \ by the sending peer.  In benign environments, content\n   integrity protection\
    \ can be disabled.\n   For static content, PPSPP currently defines one method\
    \ for protecting\n   integrity, called the Merkle Hash Tree scheme.  If PPSPP\
    \ operates\n   over the Internet, this scheme MUST be used.  If PPSPP operates\
    \ in a\n   benign environment, this scheme MAY be used.  So the scheme is\n  \
    \ mandatory to implement, to satisfy the requirement of strong security\n   for\
    \ an IETF protocol [RFC3365].  An extended version of the scheme is\n   used to\
    \ efficiently protect dynamically generated content (live\n   streams), as explained\
    \ below and in Section 6.1.\n   The Merkle Hash Tree scheme can work with different\
    \ chunk addressing\n   schemes.  All it requires is the ability to address a range\
    \ of\n   chunks.  In the following description abstract node IDs are used to\n\
    \   identify nodes in the tree.  On the wire, these are translated to the\n  \
    \ corresponding range of chunks in the chosen chunk addressing scheme.\n"
- title: 5.1.  Merkle Hash Tree Scheme
  contents:
  - "5.1.  Merkle Hash Tree Scheme\n   PPSPP uses a method of naming content based\
    \ on self-certification.\n   In particular, content in PPSPP is identified by\
    \ a single\n   cryptographic hash that is the root hash in a Merkle hash tree\n\
    \   calculated recursively from the content [ABMRKL].  This self-\n   certifying\
    \ hash tree allows every peer to directly detect when a\n   malicious peer tries\
    \ to distribute fake content.  It also ensures\n   only a small the amount of\
    \ information is needed to start a download\n   (the root hash and some peer addresses).\
    \  For live streaming, a\n   dynamic tree and a public key are used, see below.\n\
    \   The Merkle hash tree of a content file that is divided into N chunks\n   is\
    \ constructed as follows.  Note the construction does not assume\n   chunks of\
    \ content to be of a fixed size.  Given a cryptographic hash\n   function, more\
    \ specifically an MDC [HAC01], such as SHA-256, the\n   hashes of all the chunks\
    \ of the content are calculated.  Next, a\n   binary tree of sufficient height\
    \ is created.  Sufficient height means\n   that the lowest level in the tree has\
    \ enough nodes to hold all chunk\n   hashes in the set, as with bin numbering.\
    \  The figure below shows the\n   tree for a content file consisting of 7 chunks.\
    \  As with the content\n   addressing scheme, the leaves of the tree correspond\
    \ to a chunk and,\n   in this case, are assigned the hash of that chunk, starting\
    \ at the\n   leftmost leaf.  As the base of the tree may be wider than the number\n\
    \   of chunks, any remaining leaves in the tree are assigned an empty\n   hash\
    \ value of all zeros.  Finally, the hash values of the higher\n   levels in the\
    \ tree are calculated, by concatenating the hash values\n   of the two children\
    \ (again left to right) and computing the hash of\n   that aggregate.  If the\
    \ two children are empty hashes, the parent is\n   an empty all-zeros hash as\
    \ well (to save computation).  This process\n   ends in a hash value for the root\
    \ node, which is called the \"root\n   hash\".  Note the root hash only depends\
    \ on the content and any\n   modification of the content will result in a different\
    \ root hash.\n                               7 = root hash\n                 \
    \             / \\\n                            /     \\\n                   \
    \       /         \\\n                        /             \\\n             \
    \         3*               11\n                     / \\              / \\\n \
    \                   /   \\            /   \\\n                   /     \\    \
    \      /     \\\n                  1       5        9       13* = uncle hash\n\
    \                 / \\     / \\      / \\      / \\\n                0   2   4\
    \   6    8   10* 12   14\n                C0  C1  C2  C3   C4  C5  C6   E\n  \
    \              =chunk index     ^^           = empty hash\n            Merkle\
    \ hash tree of a content file with N=7 chunks\n                              \
    \   Figure 3\n"
- title: 5.2.  Content Integrity Verification
  contents:
  - "5.2.  Content Integrity Verification\n   Assuming a peer receives the root hash\
    \ of the content it wants to\n   download from a trusted source, it can check\
    \ the integrity of any\n   chunk of that content it receives as follows.  It first\
    \ calculates\n   the hash of the chunk it received, for example, chunk C4 in the\n\
    \   previous figure.  Along with this chunk, it MUST receive the hashes\n   required\
    \ to check the integrity of that chunk.  In principle, these\n   are the hash\
    \ of the chunk's sibling (C5) and that of its \"uncles\".  A\n   chunk's uncles\
    \ are the sibling Y of its parent X, and the uncle of\n   that Y, recursively\
    \ until the root is reached.  For chunk C4, the\n   uncles are nodes 13 and 3\
    \ and the sibling is 10; all marked with a *\n   in the figure.  Using this information,\
    \ the peer recalculates the\n   root hash of the tree and compares it to the root\
    \ hash it received\n   from the trusted source.  If they match, the chunk of content\
    \ has\n   been positively verified to be the requested part of the content.\n\
    \   Otherwise, the sending peer sent either the wrong content or the\n   wrong\
    \ sibling or uncle hashes.  For simplicity, the set of sibling\n   and uncle hashes\
    \ is collectively referred to as the \"uncle hashes\".\n   In the case of live\
    \ streaming, the tree of chunks grows dynamically\n   and the root hash is undefined\
    \ or, more precisely, transient, as long\n   as new data is generated by the live\
    \ source.  Section 6.1.2 defines a\n   method for content integrity verification\
    \ for live streams that works\n   with such a dynamic tree.  Although the tree\
    \ is dynamic, content\n   verification works the same for both live and predefined\
    \ content,\n   resulting in a unified method for both types of streaming.\n"
- title: 5.3.  The Atomic Datagram Principle
  contents:
  - "5.3.  The Atomic Datagram Principle\n   As explained above, a datagram consists\
    \ of a sequence of messages.\n   Ideally, every datagram sent must be independent\
    \ of other datagrams:\n   each datagram SHOULD be processed separately, and a\
    \ loss of one\n   datagram must not disrupt the flow of datagrams between two\
    \ peers.\n   Thus, as a datagram carries zero or more messages, both messages\
    \ and\n   message interdependencies SHOULD NOT span over multiple datagrams.\n\
    \   This principle implies that as any chunk is verified using its uncle\n   hashes,\
    \ the necessary hashes SHOULD be put into the same datagram as\n   the chunk's\
    \ data.  If this is not possible because of a limitation on\n   datagram size,\
    \ the necessary hashes MUST be sent first in one or more\n   datagrams.  As a\
    \ general rule, if some additional data is still\n   missing to process a message\
    \ within a datagram, the message SHOULD be\n   dropped.\n   The hashes necessary\
    \ to verify a chunk are, in principle, its\n   sibling's hash and all its uncle\
    \ hashes, but the set of hashes to\n   send can be optimized.  Before sending\
    \ a packet of data to the\n   receiver, the sender inspects the receiver's previous\n\
    \   acknowledgements (HAVE or ACK) to derive which hashes the receiver\n   already\
    \ has for sure.  Suppose the receiver had acknowledged chunks\n   C0 and C1 (the\
    \ first two chunks of the file), then it must already\n   have uncle hashes 5,\
    \ 11, and so on.  That is because those hashes are\n   necessary to check C0 and\
    \ C1 against the root hash.  Then, hashes 3,\n   7, and so on must also be known\
    \ as they are calculated in the process\n   of checking the uncle hash chain.\
    \  Hence, to send chunk C7, the\n   sender needs to include just the hashes for\
    \ nodes 14 and 9, which let\n   the data be checked against hash 11, which is\
    \ already known to the\n   receiver.\n   The sender MAY optimistically skip hashes\
    \ that were sent out in\n   previous, still-unacknowledged datagrams.  It is an\
    \ optimization\n   trade-off between redundant hash transmission and the possibility\
    \ of\n   collateral data loss in the case in which some necessary hashes were\n\
    \   lost in the network so some delivered data cannot be verified and\n   thus\
    \ had to be dropped.  In either case, the receiver builds the\n   Merkle hash\
    \ tree on-demand, incrementally, starting from the root\n   hash, and uses it\
    \ for data validation.\n   In short, the sender MUST put into the datagram the\
    \ hashes he\n   believes are necessary for the receiver to verify the chunk. \
    \ The\n   receiver MUST remember all the hashes it needs to verify missing\n \
    \  chunks that it still wants to download.  Note that the latter implies\n   that\
    \ a hardware-limited receiver MAY forget some hashes if it does\n   not plan to\
    \ announce possession of these chunks to others (i.e., does\n   not plan to send\
    \ HAVE messages.)\n"
- title: 5.4.  INTEGRITY Messages
  contents:
  - "5.4.  INTEGRITY Messages\n   Concretely, a peer that wants to send a chunk of\
    \ content creates a\n   datagram that MUST consist of a list of INTEGRITY messages\
    \ followed\n   by a DATA message.  If the INTEGRITY messages and DATA message\
    \ cannot\n   be put into a single datagram because of a limitation on datagram\n\
    \   size, the INTEGRITY messages MUST be sent first in one or more\n   datagrams.\
    \  The list of INTEGRITY messages sent MUST contain an\n   INTEGRITY message for\
    \ each hash the receiver misses for integrity\n   checking.  An INTEGRITY message\
    \ for a hash MUST contain the chunk\n   specification corresponding to the node\
    \ ID of the hash and the hash\n   data itself.  The chunk specification corresponding\
    \ to a node ID is\n   defined as the range of chunks formed by the leaves of the\
    \ subtree\n   rooted at the node.  For example, node 3 in Figure 3 denotes chunks\n\
    \   0, 2, 4, and 6, so the chunk specification should denote that\n   interval.\
    \  The list of INTEGRITY messages MUST be sorted in order of\n   the tree height\
    \ of the nodes, descending (the leaves are at height\n   0).  The DATA message\
    \ MUST contain the chunk specification of the\n   chunk and the chunk itself.\
    \  A peer MAY send the required messages\n   for multiple chunks in the same datagram,\
    \ depending on the\n   encapsulation.\n"
- title: 5.5.  Discussion and Overhead
  contents:
  - "5.5.  Discussion and Overhead\n   The current method for protecting content integrity\
    \ in BitTorrent\n   [BITTORRENT] is not suited for streaming.  It involves providing\n\
    \   clients with the hashes of the content's chunks before the download\n   commences\
    \ by means of metadata files (called .torrent files in\n   BitTorrent.)  However,\
    \ when chunks are small, as in the current UDP\n   encapsulation of PPSPP, this\
    \ implies having to download a large\n   number of hashes before content download\
    \ can begin.  This, in turn,\n   increases time-till-playback for end users, making\
    \ this method\n   unsuited for streaming.\n   The overhead of using Merkle hash\
    \ trees is limited.  The size of the\n   hash tree expressed as the total number\
    \ of nodes depends on the\n   number of chunks the content is divided (and hence\
    \ the size of\n   chunks) following this formula:\n       nnodes = math.pow(2,math.log(nchunks,2)+1)\n\
    \   In principle, the hash values of all these nodes will have to be sent\n  \
    \ to a peer once for it to verify all of the chunks.  Hence, the\n   maximum on-the-wire\
    \ overhead is hashsize * nnodes.  However, the\n   actual number of hashes transmitted\
    \ can be optimized as described in\n   Section 5.3.\n   To see a peer can verify\
    \ all chunks whilst receiving not all hashes,\n   consider the example tree in\
    \ Section 5.1.  In the case of a simple\n   progressive download, of chunks 0,\
    \ 2, 4, 6, etc., the sending peer\n   will send the following hashes:\n      \
    \    +-------+---------------------------------------------+\n          | Chunk\
    \ | Node IDs of hashes sent                     |\n          +-------+---------------------------------------------+\n\
    \          |   0   | 2,5,11                                      |\n         \
    \ |   2   | - (receiver already knows all)              |\n          |   4   |\
    \ 6                                           |\n          |   6   | -       \
    \                                    |\n          |   8   | 10,13 (hash 3 can\
    \ be calculated from 0,2,5) |\n          |   10  | -                         \
    \                  |\n          |   12  | 14                                 \
    \         |\n          |   14  | -                                           |\n\
    \          | Total | # hashes        7                           |\n         \
    \ +-------+---------------------------------------------+\n                  Table\
    \ 1: Overhead for the Example Tree\n   So the number of hashes sent in total (7)\
    \ is less than the total\n   number of hashes in the tree (16), as a peer does\
    \ not need to send\n   hashes that are calculated and verified as part of earlier\
    \ chunks.\n"
- title: 5.6.  Automatic Detection of Content Size
  contents:
  - "5.6.  Automatic Detection of Content Size\n   In PPSPP, the size of a static\
    \ content file, such as a video file,\n   can be reliably and automatically derived\
    \ from information received\n   from the network when fixed-size chunks are used.\
    \  As a result, it is\n   not necessary to include the size of the content file\
    \ as the metadata\n   of the content for such files.  Implementations of PPSPP\
    \ MAY use this\n   automatic detection feature.  Note this feature is the only\
    \ feature\n   of PPSPP that requires that a fixed-size chunk is used.  This feature\n\
    \   builds on the Merkle hash tree and the trusted root hash as swarm ID\n   as\
    \ follows.\n"
- title: 5.6.1.  Peak Hashes
  contents:
  - "5.6.1.  Peak Hashes\n   The ability for a newcomer peer to detect the size of\
    \ the content\n   depends heavily on the concept of peak hashes.  The concept\
    \ of peak\n   hashes depends on the concepts of filled and incomplete nodes.\n\
    \   Recall that when constructing the binary trees for content\n   verification\
    \ and addressing the base of the tree may have more leaves\n   than the number\
    \ of chunks in the content.  In the Merkle hash tree,\n   these leaves were assigned\
    \ empty all-zero hashes to be able to\n   calculate the higher-level hashes. \
    \ A filled node is now defined as a\n   node that corresponds to an interval of\
    \ leaves that consists only of\n   hashes of content chunks, not empty hashes.\
    \  Reversely, an incomplete\n   (not filled) node corresponds to an interval that\
    \ also contains empty\n   hashes, typically, an interval that extends past the\
    \ end of the file.\n   In the following figure, nodes 7, 11, 13, and 14 are incomplete:\
    \ the\n   rest is filled.\n   Formally, a peak hash is the hash of a filled node\
    \ in the Merkle hash\n   tree, whose sibling is an incomplete node.  Practically,\
    \ suppose a\n   file is 7162 bytes long and a chunk is 1 kilobyte.  That file\
    \ fits\n   into 7 chunks, the tail chunk being 1018 bytes long.  The Merkle hash\n\
    \   tree for that file is shown in Figure 4.  Following the definition,\n   the\
    \ peak hashes of this file are in nodes 3, 9, and 12, denoted with\n   an *. E\
    \ denotes an empty hash.\n                                  7\n              \
    \                   / \\\n                               /     \\\n          \
    \                   /         \\\n                           /             \\\n\
    \                         3*               11\n                        / \\  \
    \            / \\\n                       /   \\            /   \\\n         \
    \             /     \\          /     \\\n                     1       5     \
    \   9*      13\n                    / \\     / \\      / \\      / \\\n      \
    \             0   2   4   6    8   10  12*  14\n                   C0  C1  C2\
    \  C3   C4  C5  C6   E\n                                            = 1018 bytes\n\
    \                     Peak hashes in a Merkle hash tree\n                    \
    \             Figure 4\n   Peak hashes can be explained by the binary representation\
    \ of the\n   number of chunks the file occupies.  The binary representation for\
    \ 7\n   is 111.  Every \"1\" in binary representation of the file's packet\n \
    \  length corresponds to a peak hash.  For this particular file, there\n   are\
    \ indeed three peaks: nodes 3, 9, and 12.  Therefore, the number of\n   peak hashes\
    \ for a file is also, at most, logarithmic with its size.\n   A peer knowing which\
    \ nodes contain the peak hashes for the file can\n   therefore calculate the number\
    \ of chunks it consists of; thus, it\n   gets an estimate of the file size (given\
    \ all chunks but the last are\n   of a fixed size).  Which nodes are the peaks\
    \ can be securely\n   communicated from one (untrusted) peer, Peer A, to another\
    \ peer, Peer\n   B, by letting Peer A send the peak hashes and their node IDs\
    \ to Peer\n   B.  It can be shown that the root hash that Peer B obtained from\
    \ a\n   trusted source is sufficient to verify that these are indeed the\n   right\
    \ peak hashes, as follows.\n   Lemma: Peak hashes can be checked against the root\
    \ hash.\n   Proof: (a) Any peak hash is always the left sibling.  Otherwise, if\n\
    \   it is the right sibling, its left neighbor/sibling must also be a\n   filled\
    \ node, because of the way chunks are laid out in the leaves,\n   which contradicts\
    \ the definition of a peak hash. (b) For the\n   rightmost peak hash, its right\
    \ sibling is zero. (c) For any peak\n   hash, the right sibling might be calculated\
    \ using peak hashes to the\n   left and zeros for empty nodes. (d) Once the right\
    \ sibling of the\n   leftmost peak hash is calculated, its parent might be calculated.\
    \ (e)\n   Once that parent is calculated, we might trivially get to the root\n\
    \   hash by concatenating the hash with zeros and hashing it repeatedly.\n   Informally,\
    \ the Lemma might be expressed as follows: peak hashes\n   cover all data, so\
    \ the remaining hashes are either trivial (zeros) or\n   might be calculated from\
    \ peak hashes and zero hashes.\n   Finally, once Peer B has obtained the number\
    \ of chunks in the\n   content, it can determine the exact file size as follows.\
    \  Given that\n   all chunks except the last are of a fixed size, Peer B just\
    \ needs to\n   know the size of the last chunk.  Knowing the number of chunks,\
    \ Peer\n   B can calculate the node ID of the last chunk and download it.  As\n\
    \   always, Peer B verifies the integrity of this chunk against the\n   trusted\
    \ root hash.  As there is only one chunk of data that leads to\n   a successful\
    \ verification, the size of this chunk must be correct.\n   Peer B can then determine\
    \ the exact file size as:\n       (number of chunks -1) * fixed chunk size + size\
    \ of last chunk\n"
- title: 5.6.2.  Procedure
  contents:
  - "5.6.2.  Procedure\n   A PPSPP implementation that wants to use automatic size\
    \ detection\n   MUST operate as follows.  When Peer A sends a DATA message for\
    \ the\n   first time to Peer B, Peer A MUST first send all the peak hashes for\n\
    \   the content, in INTEGRITY messages, unless Peer B has already\n   signaled\
    \ that it knows the peak hashes by having acknowledged any\n   chunk.  If they\
    \ are needed, the peak hashes MUST be sent as an extra\n   list of uncle hashes\
    \ for the chunk, before the list of actual uncle\n   hashes of the chunk as described\
    \ in Section 5.3.  The receiver, Peer\n   B, MUST check the peak hashes against\
    \ the root hash to determine the\n   approximate content size.  To obtain the\
    \ definite content size, Peer\n   B MUST download the last chunk of the content\
    \ from any peer that\n   offers it.\n   As an example, let's consider a 7162-byte\
    \ file, which fits in 7\n   chunks of 1 kilobyte, distributed by Peer A.  Figure\
    \ 4 shows the\n   relevant Merkle hash tree.  Peer B, which only knows the root\
    \ hash of\n   the file after successfully connecting to Peer A, requests the first\n\
    \   chunk of data, C0 in Figure 4.  Peer A replies to Peer B by including\n  \
    \ in the datagram the following messages in this specific order: first,\n   the\
    \ three peak hashes of this particular file, the hashes of nodes 3,\n   9, and\
    \ 12; second, the uncle hashes of C0, followed by the DATA\n   message containing\
    \ the actual content of C0.  Upon receiving the peak\n   hashes, Peer B checks\
    \ them against the root hash determining that the\n   file is 7 chunks long. \
    \ To establish the exact size of the file, Peer\n   B needs to request and retrieve\
    \ the last chunk containing data, C6 in\n   Figure 4.  Once the last chunk has\
    \ been retrieved and verified, Peer\n   B concludes that it is 1018 bytes long,\
    \ hence determining that the\n   file is exactly 7162 bytes long.\n"
- title: 6.  Live Streaming
  contents:
  - "6.  Live Streaming\n   The set of messages defined above can be used for live\
    \ streaming as\n   well.  In a pull-based model, a live streaming injector can\
    \ announce\n   the chunks it generates via HAVE messages, and peers can retrieve\n\
    \   them via REQUEST messages.  Areas that need special attention are\n   content\
    \ authentication and chunk addressing (to achieve an infinite\n   stream of chunks).\n"
- title: 6.1.  Content Authentication
  contents:
  - "6.1.  Content Authentication\n   For live streaming, PPSPP supports two methods\
    \ for a peer to\n   authenticate the content it receives from another peer, called\
    \ \"Sign\n   All\" and \"Unified Merkle Tree\".\n   In the \"Sign All\" method,\
    \ the live injector signs each chunk of\n   content using a private key.  Upon\
    \ receiving the chunk, peers check\n   the signature using the corresponding public\
    \ key obtained from a\n   trusted source.  Support for this method is OPTIONAL.\n\
    \   In the \"Unified Merkle Tree\" method, PPSPP combines the Merkle Hash\n  \
    \ Tree scheme for static content with signatures to unify the video-on-\n   demand\
    \ and live streaming scenarios.  The use of Merkle hash trees\n   reduces the\
    \ number of signing and verification operations, hence\n   providing a similar\
    \ signature amortization to the approach described\n   in [SIGMCAST].  If PPSPP\
    \ operates over the Internet, the \"Unified\n   Merkle Tree\" method MUST be used.\
    \  If the protocol operates in a\n   benign environment, the \"Unified Merkle\
    \ Tree\" method MAY be used.  So\n   this method is mandatory to implement.\n\
    \   In both methods, the swarm ID consists of a public key encoded as in\n   a\
    \ DNSSEC DNSKEY resource record without Base64 encoding [RFC4034].\n   In particular,\
    \ the swarm ID consists of a 1-byte Algorithm field that\n   identifies the public\
    \ key's cryptographic algorithm and determines\n   the format of the Public Key\
    \ field that follows.  The value of this\n   Algorithm field is one of the values\
    \ in the \"Domain Name System\n   Security (DNSSEC) Algorithm Numbers\" registry\
    \ [IANADNSSECALGNUM].\n   The RSASHA1 [RFC4034], RSASHA256 [RFC5702], ECDSAP256SHA256\
    \ and\n   ECDSAP384SHA384 [RFC6605] algorithms are mandatory to implement.\n \
    \   0                   1                   2                   3\n    0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Algo Number(8)|                                               ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ~                DNSSEC Public Key (variable)                   ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 6.1.1.  Sign All
  contents:
  - "6.1.1.  Sign All\n   In the \"Sign All\" method, the live injector signs each\
    \ chunk of\n   content using a private key and peers, upon receiving the chunk,\n\
    \   check the signature using the corresponding public key obtained from\n   a\
    \ trusted source.  In particular, in PPSPP, the swarm ID of the live\n   stream\
    \ is that public key.\n   A peer that wants to send a chunk of content creates\
    \ a datagram that\n   MUST contain a SIGNED_INTEGRITY message with the chunk's\
    \ signature,\n   followed by a DATA message with the actual chunk.  If the\n \
    \  SIGNED_INTEGRITY message and DATA message cannot be contained into a\n   single\
    \ datagram, because of a limitation on datagram size, the\n   SIGNED_INTEGRITY\
    \ message MUST be sent first in a separate datagram.\n   The SIGNED_INTEGRITY\
    \ message consists of the chunk specification, the\n   timestamp, and the digital\
    \ signature.\n   The digital signature algorithm that is used, is determined by\
    \ the\n   Live Signature Algorithm protocol option, see Section 7.7.  The\n  \
    \ signature is computed over a concatenation of the on-the-wire\n   representation\
    \ of the chunk specification, a 64-bit timestamp in NTP\n   Timestamp format [RFC5905],\
    \ and the chunk, in that order.  The\n   timestamp is the time signature that\
    \ was made at the injector in UTC.\n"
- title: 6.1.2.  Unified Merkle Tree
  contents:
  - "6.1.2.  Unified Merkle Tree\n   In this method, the chunks of content are used\
    \ as the basis for a\n   Merkle hash tree as for static content.  However, because\
    \ chunks are\n   continuously generated, this tree is not static, but dynamic.\
    \  As a\n   result, the tree does not have a root hash, or, more precisely, it\n\
    \   has a transient root hash.  Therefore, a public key serves as swarm\n   ID\
    \ of the content.  It is used to digitally sign updates to the tree\n   allowing\
    \ peers to expand it based on trusted information using the\n   following process.\n"
- title: 6.1.2.1.  Signed Munro Hashes
  contents:
  - "6.1.2.1.  Signed Munro Hashes\n   The live injector generates a number of chunks,\
    \ denoted\n   NCHUNKS_PER_SIG, corresponding to fixed power of 2\n   (NCHUNKS_PER_SIG>=2),\
    \ which are added as new leaves to the existing\n   hash tree.  As a result of\
    \ this expansion, the hash tree contains a\n   new subtree that is NCHUNKS_PER_SIG\
    \ chunks wide at the base.  The\n   root of this new subtree is referred to as\
    \ the munro of that subtree,\n   and its hash as the munro hash of the subtree,\
    \ illustrated in\n   Figure 5.  In this figure, node 5 is the new munro, labeled\
    \ with a $\n   sign.\n                                     3\n               \
    \                     / \\\n                                   /   \\\n      \
    \                            /     \\\n                                 1    \
    \   5$\n                                / \\     / \\\n                      \
    \         0   2   4   6\n   Expanded live tree.  With NCHUNKS_PER_SIG=2, node\
    \ 5 is the munro for\n      the new subtree spanning 4 and 6.  Node 1 is the munro\
    \ for the\n    subtree spanning chunks 0 and 2, created in the previous iteration.\n\
    \                                 Figure 5\n   Informally, the process now proceeds\
    \ as follows.  The injector signs\n   only the munro hash of the new subtree using\
    \ its private key.  Next,\n   the injector announces the existence of the new\
    \ subtree to its peers\n   using HAVE messages.  When a peer, in response to the\
    \ HAVE messages,\n   requests a chunk from the new subtree, the injector first\
    \ sends the\n   signed munro hash corresponding to the requested chunk.  Afterwards,\n\
    \   similar to static content, the injector sends the uncle hashes\n   necessary\
    \ to verify that chunk, as in Section 5.1.  In particular,\n   the injector sends\
    \ the uncle hashes necessary to verify the requested\n   chunk against the munro\
    \ hash.  This differs from static content,\n   where the verification takes places\
    \ against the root hash.  Finally,\n   the injector sends the actual chunk.\n\
    \   The receiving peer verifies the signature on the signed munro using\n   the\
    \ swarm ID (a public key) and updates its hash tree.  As the peer\n   now knows\
    \ the munro hash is trusted, it can verify all chunks in the\n   subtree against\
    \ this munro hash, using the accompanying uncle hashes\n   as in Section 5.1.\n\
    \   To illustrate this procedure, lets consider the next iteration in the\n  \
    \ process.  The injector has generated the current tree shown in\n   Figure 5,\
    \ and it is connected to several peers that currently have\n   the same tree and\
    \ all posses chunks 0, 2, 4, and 6.  When the\n   injector generates two new chunks,\
    \ NCHUNKS_PER_SIG=2, the hash tree\n   expands as shown in Figure 6.  The two\
    \ new chunks, 8 and 10, extend\n   the tree on the right side, and to accommodate\
    \ them, a new root is\n   created: node 7.  As this tree is wider at the base\
    \ than the actual\n   number of chunks, there are currently two empty leaves.\
    \  The munro\n   node for the new subtree is 9, labeled with a $ sign.\n     \
    \                                7\n                                    / \\\n\
    \                                  /     \\\n                                /\
    \         \\\n                              /             \\\n               \
    \             3               11\n                           / \\            \
    \  / \\\n                          /   \\            /   \\\n                \
    \         /     \\          /     \\\n                        1       5      \
    \  9$      13\n                       / \\     / \\      / \\      / \\\n    \
    \                  0   2   4   6    8   10   E   E\n    Expanded live tree.  With\
    \ NCHUNKS_PER_SIG=2, node 9 is the munro of\n             the newly added subtree\
    \ spanning chunks 8 and 10.\n                                 Figure 6\n   The\
    \ injector now needs to inform its peers of the updated tree,\n   communicating\
    \ the addition of the new munro hash 9.  Hence, it sends\n   a HAVE message with\
    \ a chunk specification for nodes 8 + 10 to its\n   peers.  As a response, Peer\
    \ P requests the newly created chunk, e.g.,\n   chunk 8, from the injector by\
    \ sending a REQUEST message.  In reply,\n   the injector sends the signed munro\
    \ hash of node 9 as an INTEGRITY\n   message with the hash of node 9, and a SIGNED_INTEGRITY\
    \ message with\n   the signature of the hash of node 9.  These messages are followed\
    \ by\n   an INTEGRITY message with the hash of node 10 and a DATA message with\n\
    \   chunk 8.\n   Upon receipt, Peer P verifies the signature of the munro and\
    \ expands\n   its view of the tree.  Next, the peer computes the hash of chunk\
    \ 8\n   and combines it with the received hash of node 10, computing the\n   expected\
    \ hash of node 9.  He can then verify the content of chunk 8\n   by comparing\
    \ the computed hash of node 9 with the munro hash of the\n   same node he just\
    \ received; hence, Peer P has successfully verified\n   the integrity of chunk\
    \ 8.\n   This procedure requires just one signing operation for every\n   NCHUNKS_PER_SIG\
    \ chunks created, and one verification operation for\n   every NCHUNKS_PER_SIG\
    \ received, making it much cheaper than \"Sign\n   All\".  A receiving peer does\
    \ additionally need to check one or more\n   hashes per chunk via the Merkle Hash\
    \ Tree scheme, but this has less\n   hardware requirements than a signature verification\
    \ for every chunk.\n   This approach is similar to signature amortization via\
    \ Merkle Tree\n   Chaining [SIGMCAST].  The downside of this scheme is in an increased\n\
    \   latency.  A peer cannot download the new chunks until the injector\n   has\
    \ computed the signature and announced the subtree.  A peer MUST\n   check the\
    \ signature before forwarding the chunks to other peers\n   [POLLIVE].\n   The\
    \ number of chunks per signature NCHUNKS_PER_SIG MUST be a fixed\n   power of\
    \ 2 for simplicity.  NCHUNKS_PER_SIG MUST be larger than 1 for\n   performance\
    \ reasons.  There are two related factors to consider when\n   choosing a value\
    \ for NCHUNKS_PER_SIG.  First, the allowed CPU load on\n   clients due to signature\
    \ verifications, given the expected bitrate of\n   the stream.  To achieve a low\
    \ CPU load in a high bitrate stream,\n   NCHUNKS_PER_SIG should be high.  Second,\
    \ the effect on latency, which\n   increases when NCHUNKS_PER_SIG gets higher,\
    \ as just discussed.  Note\n   how the procedure does not preclude the use of\
    \ variable-size chunks.\n   This method of integrity verification provides an\
    \ additional benefit.\n   If the system includes some peers that saved the complete\
    \ broadcast,\n   as soon as the broadcast ends, the content is available as a\
    \ video-\n   on-demand download using the now stabilized tree and the final root\n\
    \   hash as swarm identifier.  Peers that saved all the chunks, can now\n   announce\
    \ the root hash to the tracking infrastructure and instantly\n   seed the content.\n"
- title: 6.1.2.2.  Munro Signature Calculation
  contents:
  - "6.1.2.2.  Munro Signature Calculation\n   The digital signature algorithm used\
    \ is determined by the Live\n   Signature Algorithm protocol option, see Section\
    \ 7.7.  The signature\n   is computed over a concatenation of the on-the-wire\
    \ representation of\n   the chunk specification of the munro node (see Section\
    \ 6.1.2.1), a\n   timestamp in 64-bit NTP Timestamp format [RFC5905], and the\
    \ hash\n   associated with the munro node, in that order.  The timestamp is the\n\
    \   time signature that was made at the injector in UTC.\n"
- title: 6.1.2.3.  Procedure
  contents:
  - "6.1.2.3.  Procedure\n   Formally, the injector MUST NOT send a HAVE message for\
    \ chunks in the\n   new subtree until it has computed the signed munro hash for\
    \ that\n   subtree.\n   When Peer B requests a chunk C from Peer A (either the\
    \ injector or\n   another peer), and Peer A decides to reply, it must do so as\
    \ follows.\n   First, Peer A MUST send an INTEGRITY message with the chunk\n \
    \  specification for the munro of chunk C and the munro's hash, followed\n   by\
    \ a SIGNED_INTEGRITY message with the chunk specification for the\n   munro, timestamp,\
    \ and its signature in a single datagram, unless Peer\n   B indicated earlier\
    \ in the exchange that it already possess a chunk\n   with the same corresponding\
    \ munro (by means of HAVE or ACK messages).\n   Following these two messages (if\
    \ any), Peer A MUST send the necessary\n   missing uncles hashes needed for verifying\
    \ the chunk against its\n   munro hash, and the chunk itself, as described in\
    \ Section 5.4,\n   sharing datagrams if possible.\n"
- title: 6.1.2.4.  Secure Tune In
  contents:
  - "6.1.2.4.  Secure Tune In\n   When a peer tunes in to a live stream, it has to\
    \ determine what is\n   the last chunk the injector has generated.  To facilitate\
    \ this\n   process in the Unified Merkle Tree scheme, each peer shares its\n \
    \  knowledge about the injector's chunks with the others by exchanging\n   their\
    \ latest signed munro hashes, as follows.\n   Recall that, in PPSPP, when Peer\
    \ A initiates a channel with Peer B,\n   Peer A sends a first datagram with a\
    \ HANDSHAKE message, and Peer B\n   responds with a second datagram also containing\
    \ a HANDSHAKE message\n   (see Section 3.1).  When Peer A sends a third datagram\
    \ to Peer B, and\n   it is received by Peer B, both peers know that the other\
    \ is listening\n   on its stated transport address.  Peer B is then allowed to\
    \ send\n   heavy payload like DATA messages in the fourth datagram.  Peer A can\n\
    \   already safely do that in the third datagram.\n   In the Unified Merkle Tree\
    \ scheme, Peer A MUST send its rightmost\n   signed munro hash to Peer B in the\
    \ third datagram, and in any\n   subsequent datagrams to Peer B, until Peer B\
    \ indicates that it\n   possess a chunk with the same corresponding munro or a\
    \ more recent\n   munro (by means of a HAVE or ACK message).  Peer B may already\
    \ have\n   indicated this fact by means of HAVE messages in the second datagram.\n\
    \   Conversely, when Peer B sends the fourth datagram or any subsequent\n   datagram\
    \ to Peer A, Peer B MUST send its rightmost signed munro hash,\n   unless Peer\
    \ A indicated knowledge of it or more recent munros.  The\n   rightmost signed\
    \ munro hash of a peer is defined as the munro hash\n   signed by the injector\
    \ of the rightmost subtree of width\n   NCHUNKS_PER_SIG chunks in the peer's Merkle\
    \ hash tree.  Peer A MUST\n   NOT send the signed munro hash in the first datagram\
    \ of the HANDSHAKE\n   procedure and Peer B MUST NOT send it in the second datagram\
    \ as it is\n   considered heavy payload.\n   When a peer receives a SIGNED_INTEGRITY\
    \ message with a signed munro\n   hash but the timestamp is too old, the peer\
    \ MUST discard the message.\n   Otherwise, it SHOULD use the signed munro to update\
    \ its hash tree and\n   pick a tune-in in the live stream.  A peer may use the\
    \ information\n   from multiple peers to pick the tune-in point.\n"
- title: 6.2.  Forgetting Chunks
  contents:
  - "6.2.  Forgetting Chunks\n   As a live broadcast progresses, a peer may want to\
    \ discard the chunks\n   that it already played out.  Ideally, other peers should\
    \ be aware of\n   this fact so that they will not try to request these chunks\
    \ from this\n   peer.  This could happen in scenarios where live streams may be\n\
    \   paused by viewers, or viewers are allowed to start late in a live\n   broadcast\
    \ (e.g., start watching a broadcast at 20:35 when it actually\n   began at 20:30).\n\
    \   PPSPP provides a simple solution for peers to stay up to date with\n   the\
    \ chunk availability of a discarding peer.  A discarding peer in a\n   live stream\
    \ MUST enable the Live Discard Window protocol option,\n   specifying how many\
    \ chunks/bytes it caches before the last chunk/byte\n   it advertised as being\
    \ available (see Section 7.9).  Its peers SHOULD\n   apply this number as a sliding\
    \ window filter over the peer's chunk\n   availability as conveyed via its HAVE\
    \ messages.\n   Three factors are important when deciding for an appropriate value\n\
    \   for this option: the desired amount of playback buffer for peers, the\n  \
    \ bitrate of the stream, and the available resources of the peer.\n   Consider\
    \ the case of a fresh peer joining the stream.  The size of\n   the discard window\
    \ of the peers it connects to influences how much\n   data it can directly download\
    \ to establish its prebuffer.  If the\n   window is smaller than the desired buffer,\
    \ the fresh peer has to wait\n   until the peers downloaded more of the stream\
    \ before it can start\n   playback.  As media buffers are generally specified\
    \ in terms of a\n   number of seconds, the size of the discard window is also\
    \ related to\n   the (average) bitrate of the stream.  Finally, if a peer has\
    \ few\n   resources to store chunks and metadata, it should choose a small\n \
    \  discard window.\n"
- title: 7.  Protocol Options
  contents:
  - "7.  Protocol Options\n   The HANDSHAKE message in PPSPP can contain the following\
    \ protocol\n   options.  Unless stated otherwise, a protocol option consists of\
    \ an\n   8-bit code followed by an 8-bit value.  Larger values are all encoded\n\
    \   big-endian.  Each protocol option is explained in the following\n   subsections.\
    \  The list of protocol options MUST be sorted on code\n   value (ascending) in\
    \ a HANDSHAKE message.\n             +--------+-------------------------------------+\n\
    \             | Code   | Description                         |\n             +--------+-------------------------------------+\n\
    \             | 0      | Version                             |\n             |\
    \ 1      | Minimum Version                     |\n             | 2      | Swarm\
    \ Identifier                    |\n             | 3      | Content Integrity Protection\
    \ Method |\n             | 4      | Merkle Hash Tree Function           |\n  \
    \           | 5      | Live Signature Algorithm            |\n             | 6\
    \      | Chunk Addressing Method             |\n             | 7      | Live Discard\
    \ Window                 |\n             | 8      | Supported Messages       \
    \           |\n             | 9      | Chunk Size                          |\n\
    \             | 10-254 | Unassigned                          |\n             |\
    \ 255    | End Option                          |\n             +--------+-------------------------------------+\n\
    \                          Table 2: PPSPP Options\n"
- title: 7.1.  End Option
  contents:
  - "7.1.  End Option\n   A peer MUST conclude the list of protocol options with the\
    \ end\n   option.  Subsequent octets should be considered protocol messages.\n\
    \   The code for the end option is 255, and unlike others, it has no\n   value\
    \ octet, so the option's length is 1 octet.\n    0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+\n\
    \   |1 1 1 1 1 1 1 1|\n   +-+-+-+-+-+-+-+-+\n"
- title: 7.2.  Version
  contents:
  - "7.2.  Version\n   A peer MUST include the maximum version of the PPSPP it supports\
    \ as\n   the first protocol option in the list.  The code for this option is\n\
    \   0.  Defined values are listed in Table 3.\n           +---------+----------------------------------------+\n\
    \           | Version | Description                            |\n           +---------+----------------------------------------+\n\
    \           | 0       | Reserved                               |\n           |\
    \ 1       | Protocol as described in this document |\n           | 2-255   | Unassigned\
    \                             |\n           +---------+----------------------------------------+\n\
    \                      Table 3: PPSPP Version Numbers\n    0                 \
    \  1\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0|  Version (8)  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 7.3.  Minimum Version
  contents:
  - "7.3.  Minimum Version\n   When a peer initiates the handshake, it MUST include\
    \ the minimum\n   version of the PPSPP it supports in the list of protocol options,\n\
    \   following the min/max versioning scheme defined in [RFC6709],\n   Section\
    \ 4.1, strategy 5.  The code for this option is 1.  Defined\n   values are listed\
    \ in Table 3.\n    0                   1\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |0 0 0 0 0 0 0 1| Min. Ver. (8) |\n\
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 7.4.  Swarm Identifier
  contents:
  - "7.4.  Swarm Identifier\n   When a peer initiates the handshake, it MUST include\
    \ a single swarm\n   identifier option.  If the peer is not the initiator, it\
    \ MAY include\n   a swarm identifier option, as an end-to-end check.  This option\
    \ has\n   the following structure:\n    0                   1                \
    \   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 1 0|     Swarm ID Length (16)      |               ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ~                       Swarm Identifier (variable)             ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The Swarm ID Length field contains the length of the single Swarm\n   Identifier\
    \ that follows in bytes.  The Length field is 16 bits wide\n   to allow for large\
    \ public keys as identifiers in live streaming.\n   Each PPSPP peer knows the\
    \ IDs of the swarms it joins, so this\n   information can be immediately verified\
    \ upon receipt.\n"
- title: 7.5.  Content Integrity Protection Method
  contents:
  - "7.5.  Content Integrity Protection Method\n   A peer MUST include the content\
    \ integrity method used by a swarm.\n   The code for this option is 3.  Defined\
    \ values are listed in Table 4.\n                   +--------+-------------------------+\n\
    \                   | Method | Description             |\n                   +--------+-------------------------+\n\
    \                   | 0      | No integrity protection |\n                   |\
    \ 1      | Merkle Hash Tree        |\n                   | 2      | Sign All \
    \               |\n                   | 3      | Unified Merkle Tree     |\n \
    \                  | 4-255  | Unassigned              |\n                   +--------+-------------------------+\n\
    \            Table 4: PPSPP Content Integrity Protection Methods\n   The \"Merkle\
    \ Hash Tree\" method is the default for static content, see\n   Section 5.1. \
    \ \"Sign All\", and \"Unified Merkle Tree\" are for live\n   content, see Section\
    \ 6.1, with \"Unified Merkle Tree\" being the\n   default.\n    0            \
    \       1\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 1 1|   CIPM (8)    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 7.6.  Merkle Tree Hash Function
  contents:
  - "7.6.  Merkle Tree Hash Function\n   When the content integrity protection method\
    \ is \"Merkle Hash Tree\",\n   this option defining which hash function is used\
    \ for the tree MUST be\n   included.  The code for this option is 4.  Defined\
    \ values are listed\n   in Table 5 (see [FIPS180-4] for the function semantics).\n\
    \                        +----------+-------------+\n                        |\
    \ Function | Description |\n                        +----------+-------------+\n\
    \                        | 0        | SHA-1       |\n                        |\
    \ 1        | SHA-224     |\n                        | 2        | SHA-256     |\n\
    \                        | 3        | SHA-384     |\n                        |\
    \ 4        | SHA-512     |\n                        | 5-255    | Unassigned  |\n\
    \                        +----------+-------------+\n                   Table\
    \ 5: PPSPP Merkle Hash Functions\n   Implementations MUST support SHA-1 (see Section\
    \ 12.5) and SHA-256.\n   SHA-256 is the default.\n    0                   1\n\
    \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n \
    \  |0 0 0 0 0 1 0 0|    MHF (8)    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 7.7.  Live Signature Algorithm
  contents:
  - "7.7.  Live Signature Algorithm\n   When the content integrity protection method\
    \ is \"Sign All\" or\n   \"Unified Merkle Tree\", this option MUST be defined.\
    \  The code for\n   this option is 5.  The 8-bit value of this option is one of\
    \ the\n   values listed in the \"Domain Name System Security (DNSSEC) Algorithm\n\
    \   Numbers\" registry [IANADNSSECALGNUM].  The RSASHA1 [RFC4034],\n   RSASHA256\
    \ [RFC5702], ECDSAP256SHA256 and ECDSAP384SHA384 [RFC6605]\n   algorithms are\
    \ mandatory to implement.  Default is ECDSAP256SHA256.\n    0                \
    \   1\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 1 0 1|    LSA (8)    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 7.8.  Chunk Addressing Method
  contents:
  - "7.8.  Chunk Addressing Method\n   A peer MUST include the chunk addressing method\
    \ it uses.  The code\n   for this option is 6.  Defined values are listed in Table\
    \ 6.\n                     +--------+---------------------+\n                \
    \     | Method | Description         |\n                     +--------+---------------------+\n\
    \                     | 0      | 32-bit bins         |\n                     |\
    \ 1      | 64-bit byte ranges  |\n                     | 2      | 32-bit chunk\
    \ ranges |\n                     | 3      | 64-bit bins         |\n          \
    \           | 4      | 64-bit chunk ranges |\n                     | 5-255  |\
    \ Unassigned          |\n                     +--------+---------------------+\n\
    \                  Table 6: PPSPP Chunk Addressing Methods\n   Implementations\
    \ MUST support \"32-bit chunk ranges\" and \"64-bit chunk\n   ranges\".  Default\
    \ is \"32-bit chunk ranges\".\n    0                   1\n    0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |0 0 0 0 0 1 1 0|\
    \    CAM (8)    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 7.9.  Live Discard Window
  contents:
  - "7.9.  Live Discard Window\n   A peer in a live swarm MUST include the discard\
    \ window it uses.  The\n   code for this option is 7.  The unit of the discard\
    \ window depends on\n   the chunk addressing method used, see Table 6.  For bins\
    \ and chunk\n   ranges, it is a number of chunks; for byte ranges, it is a number\
    \ of\n   bytes.  Its data type is the same as for a bin, or one value in a\n \
    \  range specification.  In other words, its value is a 32-bit or 64-bit\n   integer\
    \ in big-endian format.  If this option is used, the Chunk\n   Addressing Method\
    \ MUST appear before it in the list.  This option has\n   the following structure:\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 1 1 1|       Live Discard Window (32 or 64)          ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ~                                                               ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   A peer that does not, under normal circumstances, discard chunks MUST\n  \
    \ set this option to the special value 0xFFFFFFFF (32-bit) or\n   0xFFFFFFFFFFFFFFFF\
    \ (64-bit).  For example, peers that record a\n   complete broadcast to offer\
    \ it directly as a static file after the\n   broadcast ends use these values (see\
    \ Section 6.1.2).  Section 6.2\n   explains how to determine a value for this\
    \ option.\n"
- title: 7.10.  Supported Messages
  contents:
  - "7.10.  Supported Messages\n   Peers may support just a subset of the PPSPP messages.\
    \  For example,\n   peers running over TCP may not accept ACK messages or peers\
    \ used with\n   a centralized tracking infrastructure may not accept PEX messages.\n\
    \   For these reasons, peers who support only a proper subset of the\n   PPSPP\
    \ messages MUST signal which subset they support by means of this\n   protocol\
    \ option.  The code for this option is 8.  The value of this\n   option is a length\
    \ octet (SupMsgLen) indicating the length, in bytes,\n   of the compressed bitmap\
    \ that follows.\n   The set of messages supported can be derived from the compressed\n\
    \   bitmap by padding it with bytes of value 0 until it is 256 bits in\n   length.\
    \  Then, a 1 bit in the resulting bitmap at position X\n   (numbering left to\
    \ right) corresponds to support for message type X,\n   see Table 7.  In other\
    \ words, to construct the compressed bitmap,\n   create a bitmap with a 1 for\
    \ each message type supported and a 0 for\n   a message type that is not, store\
    \ it as an array of bytes, and\n   truncate it to the last non-zero byte.  An\
    \ example of the first 16\n   bits of the compressed bitmap for a peer supporting\
    \ every message\n   except ACKs and PEXs is 11011001 11110000.\n    0        \
    \           1                   2                   3\n    0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 1 0 0 0| SupMsgLen (8) |                               ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ~            Supported Messages Bitmap (variable, max 256)      ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 7.11.  Chunk Size
  contents:
  - "7.11.  Chunk Size\n   A peer in a swarm MUST include the chunk size the swarm\
    \ uses.  The\n   code for this option is 9.  Its value is a 32-bit integer denoting\n\
    \   the size of the chunks in bytes in big-endian format.  When variable\n   chunk\
    \ sizes are used, this option MUST be set to the special value\n   0xFFFFFFFF.\
    \  Section 8.1 explains how content publishers can\n   determine a value for this\
    \ option.\n    0                   1                   2                   3\n\
    \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 1 0 0 1|       Chunk Size (32)                         ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ~               |\n   +-+-+-+-+-+-+-+-+\n"
- title: 8.  UDP Encapsulation
  contents:
  - "8.  UDP Encapsulation\n   PPSPP implementations MUST use UDP as transport protocol\
    \ and MUST use\n   LEDBAT for congestion control [RFC6817].  Using LEDBAT enables\
    \ PPSPP\n   to serve the content after playback (seeding) without disrupting the\n\
    \   user who may have moved to different tasks that use its network\n   connection.\
    \  Future PPSPP versions can also run over other transport\n   protocols or use\
    \ different congestion control algorithms.\n"
- title: 8.1.  Chunk Size
  contents:
  - "8.1.  Chunk Size\n   In general, a UDP datagram containing PPSPP messages SHOULD\
    \ fit\n   inside a single IP packet, so its maximum size depends on the MTU of\n\
    \   the network.  If the UDP datagram does not fit, its chance of getting\n  \
    \ lost in the network increases as the loss of a single fragment of the\n   datagram\
    \ causes the loss of the complete datagram.\n   The largest message in a PPSPP\
    \ datagram is the DATA message carrying\n   a chunk of content.  So the (maximum)\
    \ size of a chunk to choose for a\n   particular swarm depends primarily on the\
    \ expected MTU.  The chunk\n   size should be chosen such that a chunk and its\
    \ required INTEGRITY\n   messages can generally be carried inside a single datagram,\
    \ following\n   the Atomic Datagram Principle (Section 5.3).  Other considerations\n\
    \   are the hardware capabilities of the peers.  Having large chunks and\n   therefore\
    \ less chunks per megabyte of content reduces processing\n   costs.  The chunk\
    \ addressing schemes can all work with different\n   chunk sizes, see Section\
    \ 4.\n   The RECOMMENDED approach is to use fixed-size chunks of 1024 bytes,\n\
    \   as this size has a high likelihood of traveling end-to-end across the\n  \
    \ Internet without any fragmentation.  In particular, with this size, a\n   UDP\
    \ datagram with a DATA message can be transmitted as a single IP\n   packet over\
    \ an Ethernet network with 1500-byte frames.\n   A PPSPP implementation MAY use\
    \ a variant of the Packetization Layer\n   Path MTU Discovery (PLPMTUD), described\
    \ in [RFC4821], for discovering\n   the optimal MTU between sender and destination.\
    \  As in PLPMTUD,\n   progressively larger probing packets are used to detect\
    \ the optimal\n   MTU for a given path.  However, in PPSPP, probe packets SHOULD\n\
    \   contain actual messages, in particular, multiple DATA messages.  By\n   using\
    \ actual DATA messages as probe packets, the returning ACK\n   messages will confirm\
    \ the probe delivery, effectively updating the\n   MTU estimate on both ends of\
    \ the link.  To be able to scale up probe\n   packets with sensible increments,\
    \ a minimum chunk size of 512 bytes\n   SHOULD be used.  Smaller chunk sizes lead\
    \ to an inefficient protocol.\n   An implication is that PPSPP supports datagrams\
    \ over IPv4 of 576\n   bytes or more only.  This variant is not mandatory to implement.\n\
    \   The chunk size used for a particular swarm, or the fact that it is\n   variable,\
    \ MUST be part of the swarm's metadata (which then minimally\n   consists of the\
    \ swarm ID and the chunk nature and size).\n"
- title: 8.2.  Datagrams and Messages
  contents:
  - "8.2.  Datagrams and Messages\n   When using UDP, the abstract datagram described\
    \ above corresponds\n   directly to a UDP datagram.  Most messages within a datagram\
    \ have a\n   fixed length, which generally depends on the type of the message.\n\
    \   The first byte of a message denotes its type.  The currently defined\n   types\
    \ are:\n                      +----------+------------------+\n              \
    \        | Msg Type | Description      |\n                      +----------+------------------+\n\
    \                      | 0        | HANDSHAKE        |\n                     \
    \ | 1        | DATA             |\n                      | 2        | ACK    \
    \          |\n                      | 3        | HAVE             |\n        \
    \              | 4        | INTEGRITY        |\n                      | 5    \
    \    | PEX_RESv4        |\n                      | 6        | PEX_REQ        \
    \  |\n                      | 7        | SIGNED_INTEGRITY |\n                \
    \      | 8        | REQUEST          |\n                      | 9        | CANCEL\
    \           |\n                      | 10       | CHOKE            |\n       \
    \               | 11       | UNCHOKE          |\n                      | 12  \
    \     | PEX_RESv6        |\n                      | 13       | PEX_REScert   \
    \   |\n                      | 14-254   | Unassigned       |\n               \
    \       | 255      | Reserved         |\n                      +----------+------------------+\n\
    \                       Table 7: PPSPP Message Types\n   Furthermore, integers\
    \ are serialized in network (big-endian) byte\n   order.  So, consider the example\
    \ of a HAVE message (Section 3.2)\n   using bin chunk addressing.  It has a message\
    \ type of 0x03 and a\n   payload of a bin number, a 4-byte integer (say, 1); hence,\
    \ its on-\n   the-wire representation for UDP can be written in hex as\n   \"\
    0300000001\".\n   All messages are idempotent or recognizable as duplicates.\n\
    \   Idempotent means that processing a message more than once does not\n   lead\
    \ to a different state from if it was processed just once.  In\n   particular,\
    \ a peer MAY resend DATA, ACK, HAVE, INTEGRITY, PEX_*,\n   SIGNED_INTEGRITY, REQUEST,\
    \ CANCEL, CHOKE, and UNCHOKE messages\n   without problems when loss is suspected.\
    \  When a peer resends a\n   HANDSHAKE message, it can be recognized as duplicate\
    \ by the receiver,\n   because it already recorded the first connection attempt,\
    \ and be\n   dealt with.\n"
- title: 8.3.  Channels
  contents:
  - "8.3.  Channels\n   As described in Section 3.11, PPSPP uses a multiplexing scheme,\n\
    \   called channels, to allow multiple swarms to use the same UDP port.\n   In\
    \ the UDP encapsulation, each datagram from Peer A to Peer B is\n   prefixed with\
    \ the channel ID allocated by Peer B.  The peers learn\n   about each other's\
    \ channel ID during the handshake as explained in\n   Section 3.1.1.  A channel\
    \ ID consists of 4 bytes and MUST be\n   generated following the requirements\
    \ in [RFC4960] (Section 5.1.3).\n"
- title: 8.4.  HANDSHAKE
  contents:
  - "8.4.  HANDSHAKE\n   A channel is established with a handshake.  To start a handshake,\
    \ the\n   initiating peer needs to know the swarm metadata, defined in\n   Section\
    \ 3.1 and the IP address and UDP port of a peer.  A datagram\n   containing a\
    \ HANDSHAKE message then looks as follows:\n    0                   1        \
    \           2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                  Destination Channel ID (32)                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0|            Source Channel ID (32)             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               |                                               ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                   Protocol Options                          ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   where:\n      Destination Channel ID:\n         If the datagram is sent by\
    \ the initiating peer, then it MUST be\n         an all-zeros channel ID.\n  \
    \       If the datagram is sent by the responding peer, then it MUST\n       \
    \  consist of the Source Channel ID from the sender's HANDSHAKE\n         message.\n\
    \      The octet 0x00: The HANDSHAKE message type\n      Source Channel ID: A\
    \ locally unused channel ID\n      Protocol Options: A list of protocol options\
    \ encoding the swarm's\n      metadata, as defined in Section 7.\n   A peer SHOULD\
    \ explicitly close a channel by sending a HANDSHAKE\n   message that MUST contain\
    \ an all zeros Source Channel ID and a list\n   of protocol options.  The list\
    \ MUST either be empty or contain the\n   maximum version number the sender supports,\
    \ following the min/max\n   versioning scheme defined in [RFC6709], Section 4.1.\n"
- title: 8.5.  HAVE
  contents:
  - "8.5.  HAVE\n   A HAVE message (type 0x03) consists of a single chunk specification\n\
    \   that states that the sending peer has those chunks and successfully\n   checked\
    \ their integrity.  The single chunk specification represents a\n   consecutive\
    \ range of verified chunks.  A bin consists of a single\n   integer, and a chunk\
    \ or byte range of two integers, of the width\n   specified by the Chunk Addressing\
    \ protocol options, encoded big-\n   endian.\n   A HAVE message using 32-bit chunk\
    \ ranges as Chunk Addressing method:\n    0                   1              \
    \     2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 1 1|                 Start chunk (32)              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               |                  End chunk (32)               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               |\n   +-+-+-+-+-+-+-+-+\n   where the first octet is the HAVE\
    \ message (0x03) followed by the\n   start chunk and the end chunk describing\
    \ the chunk range.  Note this\n   diagram shows a message and not a datagram,\
    \ so it is not prefixed by\n   the destination Channel ID.  This holds for all\
    \ subsequent message\n   diagrams.\n"
- title: 8.6.  DATA
  contents:
  - "8.6.  DATA\n   A DATA message (type 0x01) consists of a chunk specification,\
    \ a\n   timestamp, and the actual chunk.  In case a datagram contains one\n  \
    \ DATA message, a sender MUST always put the DATA message in the tail\n   of the\
    \ datagram.  A datagram MAY contain multiple DATA messages when\n   the chunk\
    \ size is fixed and when none of the DATA messages carry the\n   last chunk, if\
    \ that is smaller than the chunk size.  As LEDBAT\n   congestion control is used,\
    \ a sender MUST include a timestamp, in\n   particular, a 64-bit integer representing\
    \ the current system time\n   with microsecond accuracy.  The timestamp MUST be\
    \ included between\n   chunk specification and the actual chunk.\n   A DATA message\
    \ using 32-bit chunk ranges as Chunk Addressing method:\n    0               \
    \    1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 1|                 Start chunk (32)              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               |                  End chunk (32)               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               |                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       Timestamp (64)                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               |                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                          Data                               ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   where the first octet is the DATA message (0x01) followed by the\n   start\
    \ chunk and the end chunk describing the single chunk, the\n   timestamp, and\
    \ the actual data.\n"
- title: 8.7.  ACK
  contents:
  - "8.7.  ACK\n   An ACK message (type 0x02) acknowledges data that was received\
    \ from\n   its addressee; to comply with the LEDBAT delay-based congestion\n \
    \  control, an ACK message consists of a chunk specification and a\n   timestamp\
    \ representing a one-way delay sample.  The one-way delay\n   sample is a 64-bit\
    \ integer with microsecond accuracy, and it is\n   computed from the timestamp\
    \ received from the previous DATA message\n   containing the chunk being acknowledged\
    \ following the LEDBAT\n   specification.\n   An ACK message using 32-bit chunk\
    \ ranges as Chunk Addressing method:\n    0                   1              \
    \     2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 1 0|                 Start chunk (32)              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               |                  End chunk (32)               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               |                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                  One-way delay sample (64)                    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               |\n   +-+-+-+-+-+-+-+-+\n   where the first octet is the ACK\
    \ message (0x02) followed by the start\n   chunk and the end chunk describing\
    \ the chunk range and the one-way\n   delay sample.\n"
- title: 8.8.  INTEGRITY
  contents:
  - "8.8.  INTEGRITY\n   An INTEGRITY message (type 0x04) consists of a chunk specification\n\
    \   and the cryptographic hash for the specified chunk or node.  The type\n  \
    \ and format of the hash depends on the protocol options.\n   An INTEGRITY message\
    \ using 32-bit chunk ranges as Chunk Addressing\n   method and a SHA-256 hash:\n\
    \    0                   1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 1 0 0|                 Start chunk (32)              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               |                  End chunk (32)               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               |                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                          Hash (256)                         ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               |\n   +-+-+-+-+-+-+-+-+\n   where the first octet is the INTEGRITY\
    \ message (0x04) followed by the\n   start chunk and the end chunk describing\
    \ the chunk range and the\n   hash.\n"
- title: 8.9.  SIGNED_INTEGRITY
  contents:
  - "8.9.  SIGNED_INTEGRITY\n   A SIGNED_INTEGRITY message (type 0x07) consists of\
    \ a chunk\n   specification, a 64-bit timestamp in NTP Timestamp format [RFC5905]\n\
    \   and a digital signature encoded as a Signature field would be in an\n   RRSIG\
    \ record in DNSSEC without the Base64 encoding [RFC4034].  The\n   signature algorithm\
    \ is defined by the Live Signature Algorithm\n   protocol option, see Section\
    \ 7.7.  The plaintext over which the\n   signature is taken depends on the content\
    \ integrity protection method\n   used, see Section 6.1.\n   A SIGNED_INTEGRITY\
    \ message using 32-bit chunk ranges as Chunk\n   Addressing method:\n    0   \
    \                1                   2                   3\n    0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 1 1 1|                 Start chunk (32)              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               |                  End chunk (32)               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               |                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       Timestamp (64)                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               |                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                     Signature                               ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   where the first octet is the SIGNED_INTEGRITY message (0x07) followed\n  \
    \ by the start chunk and the end chunk describing the chunk range, the\n   timestamp,\
    \ and the Signature.\n   The length of the digital signature can be derived from\
    \ the Live\n   Signature Algorithm protocol option and the swarm ID as follows.\
    \  The\n   first mandatory algorithms are RSASHA1 and RSASHA256.  For those\n\
    \   algorithms, the swarm ID consists of a 1-byte Algorithm field\n   followed\
    \ by an RSA public key stored as a tuple (exponent length,\n   exponent, modulus)\
    \ [RFC3110].  Given the exponent length and the\n   length of the public key tuple\
    \ in the swarm ID, the length of the\n   modulus in bytes can be calculated. \
    \ This yields the length of the\n   signature, as in RSA this is the length of\
    \ the modulus [HAC01].  The\n   other mandatory algorithms are ECDSAP256SHA256\
    \ and ECDSAP384SHA384\n   [RFC6605].  For these algorithms, the length of the\
    \ digital signature\n   is 64 and 96 bytes, respectively.\n"
- title: 8.10.  REQUEST
  contents:
  - "8.10.  REQUEST\n   A REQUEST message (type 0x08) consists of a chunk specification\
    \ for\n   the chunks the requester wants to download.\n   A REQUEST message using\
    \ 32-bit chunk ranges as Chunk Addressing\n   method:\n    0                 \
    \  1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 1 0 0 0|                 Start chunk (32)              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               |                  End chunk (32)               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               |\n   +-+-+-+-+-+-+-+-+\n   where the first octet is the REQUEST\
    \ message (0x08) followed by the\n   start chunk and the end chunk describing\
    \ the chunk range.\n"
- title: 8.11.  CANCEL
  contents:
  - "8.11.  CANCEL\n   A CANCEL message (type 0x09) consists of a chunk specification\
    \ for\n   the chunks the requester no longer is interested in.\n   A CANCEL message\
    \ using 32-bit chunk ranges as Chunk Addressing\n   method:\n    0           \
    \        1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 1 0 0 1|                 Start chunk (32)              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               |                  End chunk (32)               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               |\n   +-+-+-+-+-+-+-+-+\n   where the first octet is the CANCEL\
    \ message (0x09) followed by the\n   start chunk and the end chunk describing\
    \ the chunk range.\n"
- title: 8.12.  CHOKE and UNCHOKE
  contents:
  - "8.12.  CHOKE and UNCHOKE\n   Both CHOKE and UNCHOKE messages (types 0x0a and\
    \ 0x0b, respectively)\n   carry no payload.\n   A CHOKE message:\n    0\n    0\
    \ 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+\n   |0 0 0 0 1 0 1 0|\n   +-+-+-+-+-+-+-+-+\n\
    \   where the first octet is the CHOKE message (0x0a).\n   An UNCHOKE message:\n\
    \    0\n    0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+\n   |0 0 0 0 1 0 1 1|\n   +-+-+-+-+-+-+-+-+\n\
    \   where the first octet is the UNCHOKE message (0x0b).\n"
- title: 8.13.  PEX_REQ, PEX_RESv4, PEX_RESv6, and PEX_REScert
  contents:
  - "8.13.  PEX_REQ, PEX_RESv4, PEX_RESv6, and PEX_REScert\n   A PEX_REQ (0x06) message\
    \ has no payload.  A PEX_RESv4 (0x05) message\n   consists of an IPv4 address\
    \ in big-endian format followed by a UDP\n   port number in big-endian format.\
    \  A PEX_RESv6 (0x0c) message\n   contains a 128-bit IPv6 address instead of an\
    \ IPv4 one.  If a PEX_REQ\n   message does not originate from a private, unique-local,\
    \ link-local,\n   or multicast address [RFC1918] [RFC4193] [RFC4291], then the\
    \ PEX_RES*\n   messages sent in reply MUST NOT contain such addresses.  This is\
    \ to\n   prevent leaking of internal addresses to external peers.\n   A PEX_REQ\
    \ message:\n    0\n    0 1 2 3 4 5 6 7\n   +-+-+-+-+-+-+-+-+\n   |0 0 0 0 0 1\
    \ 1 0|\n   +-+-+-+-+-+-+-+-+\n   where the first octet is the PEX_REQ message\
    \ (0x06).\n   A PEX_RESv4 message:\n    0                   1                \
    \   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 1 0 1|              IPv4 Address (32)                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               |             Port (16)         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   where the first octet is the PEX_RESv4 message (0x05) followed by the\n  \
    \ IPv4 address and the port number.\n   A PEX_RESv6 message:\n    0          \
    \         1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 1 1 0 0|                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                   IPv6 Address (128)                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |               |             Port (16)         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   where the first octet is the PEX_RESv6 message (0x0c), followed by\n   the\
    \ IPv6 address and the port number.\n   A PEX_REScert (0x0d) message consists\
    \ of a 16-bit integer in big-\n   endian specifying the size of the membership\
    \ certificate that\n   follows, see Section 12.2.1.  This membership certificate\
    \ states that\n   Peer P at Time T is a member of Swarm S and is a X.509v3 certificate\n\
    \   [RFC5280] that is encoded using the ASN.1 distinguished encoding\n   rules\
    \ (DER) [CCITT.X690.2002].  The certificate MUST contain a\n   \"Subject Alternative\
    \ Name\" extension, marked as critical, of type\n   uniformResourceIdentifier.\n\
    \   A PEX_REScert message:\n    0                   1                   2    \
    \               3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 1 1 0 1|   Size of Memb. Cert. (16)    |               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                                                               |\n   ~  \
    \                  Membership Certificate                     ~\n   |        \
    \                                                       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   where the first octet is the PEX_REScert message (0x0d) followed by\n   the\
    \ size of the membership certificate and the membership\n   certificate.\n   The\
    \ URL contained in the name extension MUST follow the generic\n   syntax for URLs\
    \ [RFC3986], where its scheme component is \"file\", the\n   host in the authority\
    \ component is the DNS name or IP address of Peer\n   P, the port in the authority\
    \ component is the port of Peer P, and the\n   path contains the swarm identifier\
    \ for Swarm S, in hexadecimal form.\n   In particular, the preferred form of the\
    \ swarm identifier is\n   xxyyzz..., where the 'x's, 'y's, and 'z's are 2 hexadecimal\
    \ digits of\n   the 8-bit pieces of the identifier.  The validity time of the\n\
    \   certificate is set with notBefore UTCTime set to T and notAfter\n   UTCTime\
    \ set to T plus some expiry time defined by the issuer.  An\n   example URL:\n\
    \       file://192.0.2.0:6778/e5a12c7ad2d8fab33c699d1e198d66f79fa610c3\n"
- title: 8.14.  KEEPALIVE
  contents:
  - "8.14.  KEEPALIVE\n   Keep alives do not have a message type on UDP.  They are\
    \ just simple\n   datagrams consisting of the 4-byte channel ID of the destination\n\
    \   only.\n   A keep-alive datagram:\n    0                   1              \
    \     2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                       Channel ID (32)                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 8.15.  Flow and Congestion Control
  contents:
  - "8.15.  Flow and Congestion Control\n   Explicit flow control is not required\
    \ for PPSPP over UDP.  In the\n   case of video on demand, the receiver explicitly\
    \ requests the content\n   from peers, and is therefore in control of how much\
    \ data is coming\n   towards it.  In the case of live streaming, where a push\
    \ model may be\n   used, the amount of data incoming is limited to the stream\
    \ bitrate,\n   which the receiver must be able to process for a continuous playback.\n\
    \   Should, for any reason, the receiver get saturated with data, the\n   congestion\
    \ control at the sender side will detect the situation and\n   adjust the sending\
    \ rate accordingly.\n   PPSPP over UDP can support different congestion control\
    \ algorithms.\n   At present, it uses the LEDBAT congestion control algorithm\n\
    \   [RFC6817].  LEDBAT is a delay-based congestion control algorithm that\n  \
    \ is used every day by millions of users as part of the uTP\n   transmission protocol\
    \ of BitTorrent [LBT] [LCOMPL] and is suitable\n   for P2P streaming [PPSPPERF].\n\
    \   LEDBAT monitors the delay of the packets on the data path.  It uses\n   the\
    \ one-way delay variations to react early and limit the congestion\n   that the\
    \ stream may induce in the network [RFC6817].  Using LEDBAT\n   enables PPSPP\
    \ to serve the content to other interested peers after\n   the playback has finished\
    \ (seeding), without disrupting the user.\n   After the playback, the user might\
    \ move to different tasks that use\n   its network link, which are prioritized\
    \ over PPSPP traffic.  Hence,\n   the user does not notice the background PPSPP\
    \ traffic, which in turn\n   increases the chances of seeding the content for\
    \ a longer period of\n   time.\n   The property of reacting early is not a problem\
    \ in a peer-to-peer\n   system where multiple sources offer the content.  Considering\
    \ the\n   case of congestion near the sender, LEDBAT's early reaction impacts\n\
    \   the transmission of chunks to the receiver.  However, for the\n   receiver,\
    \ it is actually beneficial to learn early that the\n   transmission from a particular\
    \ source is impacted.  The receiver can\n   then choose to download time-critical\
    \ chunks from other sources\n   during its chunk picking phase.\n   If the bottleneck\
    \ is near the receiver, the receiver is indeed\n   unlucky that transmissions\
    \ from any source that runs through this\n   bottleneck will back off quite fast\
    \ due to LEDBAT.  However, for the\n   rest of the network (and the network operator),\
    \ this is beneficial as\n   the video-streaming system will back off early enough\
    \ and not\n   contribute too much to the congestion.\n   The power of LEDBAT is\
    \ that its behavior can be configured.  In the\n   case of live streaming, a PPSPP\
    \ deployer may want a more aggressive\n   behavior to ensure quality of service.\
    \  In that case, LEDBAT can be\n   configured to be more aggressive.  In particular,\
    \ LEDBAT's queuing\n   target delay value (TARGET in [RFC6817]) and other parameters\
    \ can be\n   adjusted such that it acts as aggressive as TCP (or even more).\n\
    \   Hence, LEDBAT is an algorithm that works for many scenarios in a\n   peer-to-peer\
    \ context.\n"
- title: 8.16.  Example of Operation
  contents:
  - "8.16.  Example of Operation\n   We present a small example of communication between\
    \ a leecher and a\n   seeder.  The example presents the transmission of the file\
    \ \"Hello\n   World!\", which fits within a 1024-byte chunk.  For an easy\n  \
    \ understanding, we use the message description names, as listed in\n   Table\
    \ 7, and the protocol option names as listed in Table 2, rather\n   than the actual\
    \ binary value.\n   To do the handshake, the initiating peer sends a datagram\
    \ that MUST\n   start with an all-zeros channel ID (0x00000000); followed by a\n\
    \   HANDSHAKE message, whose payload is a locally unused; a random\n   channel\
    \ ID (in this case 0x00000001); and a list of protocol options.\n   Channel IDs\
    \ MUST be randomly chosen, as described in Section 12.1.\n    0              \
    \     1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   HANDSHAKE   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 1|    Version    |0 0 0 0 0 0 0 1|  Min Version  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 1|   Swarm ID    |0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 1 0 0 0 1 1 1 1 0 1 0 0 0 0 0 0 0 0 1 0 0 1 1 1 1 1 0 0 1 1 0|\n   ~  \
    \                           .....                             ~\n   |1 0 0 0 0\
    \ 1 1 0 1 0 1 0 1 0 1 0 1 0 1 1 0 0 0 0 0 0 1 1 1 0 1 1|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Cont. Int.  |0 0 0 0 0 0 0 1| Mer.H.Tree F. |0 0 0 0 0 0 1 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   Chunk Add.  |0 0 0 0 0 0 1 0|   Chunk Size  |0 0 0 0 0 0 0 0~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ~0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0|      End      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The protocol options are:\n      Version: 1\n      Minimum supported Version:\
    \ 1\n      Swarm Identifier: A 32-byte root hash (47a0...b03b) identifying\n \
    \     the content\n      Content Integrity Protection Method: Merkle Hash Tree\n\
    \      Merkle Tree Hash Function: SHA-256\n      Chunk Addressing Method: 32-bit\
    \ chunk ranges\n      Chunk Size: 1024\n   The receiving peer MAY respond, in\
    \ which case the returned datagram\n   MUST consist of the channel ID from the\
    \ sender's HANDSHAKE message\n   (0x00000001); a HANDSHAKE message, whose payload\
    \ is a locally unused;\n   a random channel ID (0x00000008); and a list of protocol\
    \ options;\n   followed by any other messages it wants to send.\n    0       \
    \            1                   2                   3\n    0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   HANDSHAKE   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 1 0 0 0|    Version    |0 0 0 0 0 0 0 1|   Cont. Int.  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 1| Mer.H.Tree F. |0 0 0 0 0 0 1 0|   Chunk Add.  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 1 0|  Chunk Size   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ~0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0|      End      |      HAVE     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   With the protocol options, the receiving peer agrees on speaking\n   protocol\
    \ version 1, on using the Merkle Hash Tree as the Content\n   Integrity Protection\
    \ Method, SHA-256 hash as the Merkle Tree Hash\n   Function, 32-bit chunk ranges\
    \ as the Chunk Addressing Method, and\n   Chunk Size 1024.  Furthermore, it sends\
    \ a HAVE message within the\n   same datagram, announcing that it has locally\
    \ available the first\n   chunk of content.\n   At this point, the initiator knows\
    \ that the peer really responds; for\n   that purpose, channel IDs MUST be random\
    \ enough to prevent easy\n   guessing.  So, the third datagram of a handshake\
    \ MAY already contain\n   some heavy payload.  To minimize the number of initialization\
    \ round\n   trips, the first two datagrams MAY also contain some minor payload,\n\
    \   e.g., the HAVE message.\n   The initiating peer MAY send a request for the\
    \ chunks of content it\n   wants to retrieve from the receiving peer, e.g., the\
    \ first chunk\n   announced during the handshake.  It always precedes the message\
    \ with\n   the channel ID of the peer it is communicating with (0x00000008 in\n\
    \   our example), as described in Section 3.11.  Furthermore, it MAY add\n   additional\
    \ messages such as a PEX_REQ.\n    0                   1                   2 \
    \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    REQUEST    |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0|    PEX_REQ    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   When receiving the third datagram, both peers have proof that they\n   really\
    \ talk to each other; the three-way handshake is complete.  The\n   receiving\
    \ peer responds to the request by sending a DATA message\n   containing the requested\
    \ content.\n    0                   1                   2                   3\n\
    \    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |     DATA      |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 1 1 0 1 0 0 1|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 0 1 1 0 1 1 1 1 1 0 1 1 0 1 1|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 1 0 0 0 1 0 0|0 1 0 0 1 0 0 0 0 1 1 0 0 1 0 1 0 1 1 0 1 1 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ~                           .....                               ~\n   |0 1\
    \ 1 0 1 1 0 0 0 1 1 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 1 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The DATA message consists of:\n      The 32-bit chunk range: 0,0 (the first\
    \ chunk)\n      The timestamp value: 0004e94180b7db44\n      The data: 48656c6c6f20776f726c6421\
    \ (the \"Hello world!\" file)\n   Note that the above datagram does not include\
    \ the INTEGRITY message,\n   as the entire content can fit into a single message;\
    \ hence, the\n   initiating peer is able to verify it against the root hash. \
    \ Also, in\n   this example, the peer does not respond to the PEX_REQ as it does\
    \ not\n   know any third peer participating in the swarm.\n   Upon receiving the\
    \ requested data, the initiating peer responds with\n   an ACK message for the\
    \ first chunk, containing a one-way delay sample\n   (100 ms).  Furthermore, it\
    \ also adds a HAVE message for the chunk.\n    0                   1         \
    \          2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |      ACK      |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 1 1 0 0 1 0 0|      HAVE     |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   At this point, the initiating peer has successfully retrieved the\n   entire\
    \ file.  Then, it explicitly closes the connection by sending a\n   HANDSHAKE\
    \ message that contains an all-zeros Source Channel ID.\n    0               \
    \    1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   HANDSHAKE   |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |0 0 0 0 0 0 0 0|      End      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 9.  Extensibility
  contents:
  - '9.  Extensibility

    '
- title: 9.1.  Chunk Picking Algorithms
  contents:
  - "9.1.  Chunk Picking Algorithms\n   Chunk (or piece) picking entirely depends\
    \ on the receiving peer.  The\n   sending peer is made aware of preferred chunks\
    \ by the means of\n   REQUEST messages.  In some (live) scenarios, it may be beneficial\
    \ to\n   allow the sender to ignore those hints and send unrequested data.\n \
    \  The chunk picking algorithm is external to the PPSPP and will\n   generally\
    \ be a pluggable policy that uses the mechanisms provided by\n   PPSPP.  The algorithm\
    \ will handle the choices made by the user\n   consuming the content, such as\
    \ seeking or switching audio tracks or\n   subtitles.  Example policies for P2P\
    \ streaming can be found in\n   [BITOS], and [EPLIVEPERF].\n"
- title: 9.2.  Reciprocity Algorithms
  contents:
  - "9.2.  Reciprocity Algorithms\n   The role of reciprocity algorithms in peer-to-peer\
    \ systems is to\n   promote client contribution and prevent freeriding.  A peer\
    \ is said\n   to be freeriding if it only downloads content but never uploads\
    \ to\n   others.  Examples of reciprocity algorithms are tit-for-tat as used\n\
    \   in BitTorrent [TIT4TAT] and Give-to-Get [GIVE2GET].  In PPSPP,\n   reciprocity\
    \ enforcement is the sole responsibility of the sending\n   peer.\n"
- title: 10.  IANA Considerations
  contents:
  - "10.  IANA Considerations\n   IANA has created a new top-level registry called\
    \ \"Peer-to-Peer\n   Streaming Peer Protocol (PPSPP)\", which hosts the six new\
    \ sub-\n   registries defined below for the extensibility of the protocol.  For\n\
    \   all registries, assignments consist of a name and its associated\n   value.\
    \  Also, for all registries, the \"Unassigned\" ranges designated\n   are governed\
    \ by the policy \"IETF Review\" as described in [RFC5226].\n"
- title: 10.1.  PPSPP Message Type Registry
  contents:
  - "10.1.  PPSPP Message Type Registry\n   The registry name is \"PPSPP Message Type\
    \ Registry\".  Values are\n   integers in the range 0-255, with initial assignments\
    \ and\n   reservations given in Table 7.\n"
- title: 10.2.  PPSPP Option Registry
  contents:
  - "10.2.  PPSPP Option Registry\n   The registry name is \"PPSPP Option Registry\"\
    .  Values are integers in\n   the range 0-255, with initial assignments and reservations\
    \ given in\n   Table 2.\n"
- title: 10.3.  PPSPP Version Number Registry
  contents:
  - "10.3.  PPSPP Version Number Registry\n   The registry name is \"PPSPP Version\
    \ Number Registry\".  Values are\n   integers in the range 0-255, with initial\
    \ assignments and\n   reservations given in Table 3.\n"
- title: 10.4.  PPSPP Content Integrity Protection Method Registry
  contents:
  - "10.4.  PPSPP Content Integrity Protection Method Registry\n   The registry name\
    \ is \"PPSPP Content Integrity Protection Method\n   Registry\".  Values are integers\
    \ in the range 0-255, with initial\n   assignments and reservations given in Table\
    \ 4.\n"
- title: 10.5.  PPSPP Merkle Hash Tree Function Registry
  contents:
  - "10.5.  PPSPP Merkle Hash Tree Function Registry\n   The registry name is \"PPSPP\
    \ Merkle Hash Tree Function Registry\".\n   Values are integers in the range 0-255,\
    \ with initial assignments and\n   reservations given in Table 5.\n"
- title: 10.6.  PPSPP Chunk Addressing Method Registry
  contents:
  - "10.6.  PPSPP Chunk Addressing Method Registry\n   The registry name is \"PPSPP\
    \ Chunk Addressing Method Registry\".\n   Values are integers in the range 0-255,\
    \ with initial assignments and\n   reservations given in Table 6.\n"
- title: 11.  Manageability Considerations
  contents:
  - "11.  Manageability Considerations\n   This section presents operations and management\
    \ considerations\n   following the checklist in [RFC5706], Appendix A.\n   In\
    \ this section, \"PPSPP client\" is defined as a PPSPP peer acting on\n   behalf\
    \ of an end user which may not yet have a copy of the content,\n   and \"PPSPP\
    \ server\" as a PPSPP peer that provides the initial copies\n   of the content\
    \ to the swarm on behalf of a content provider.\n"
- title: 11.1.  Operations
  contents:
  - '11.1.  Operations

    '
- title: 11.1.1.  Installation and Initial Setup
  contents:
  - "11.1.1.  Installation and Initial Setup\n   A content provider wishing to use\
    \ PPSPP to distribute content should\n   set up at least one PPSPP server.  PPSPP\
    \ servers need to have access\n   to either some static content or some live audio/video\
    \ sources.  To\n   provide flexibility for implementors, this configuration process\
    \ is\n   not standardized.  The output of this process will be a list of\n   metadata\
    \ records, one for each swarm.  A metadata record consists of\n   the swarm ID,\
    \ the chunk size used, the chunk addressing method used,\n   the content integrity\
    \ protection method used, and the Merkle hash\n   tree function used (if applicable).\
    \  If automatic content size\n   detection (see Section 5.6) is not used, the\
    \ content length is also\n   part of the metadata record for static content. \
    \ Note the swarm ID\n   already contains the Live Signature Algorithm used, in\
    \ case of a live\n   stream.\n   In addition, a content provider should set up\
    \ a tracking facility for\n   the content by configuring, for example, a peer-to-peer\
    \ streaming\n   protocol tracker [PPSP-TP] or a Distributed Hash Table.  The output\n\
    \   of the latter process is a list of transport addresses for the\n   tracking\
    \ facility.\n   The list of metadata records of available content, and transport\n\
    \   address for the tracking facility, can be distributed to users in\n   various\
    \ ways.  Typically, they will be published on a website as\n   links.  When a\
    \ user clicks such a link, the PPSPP client is launched,\n   either as a standalone\
    \ application or by invoking the browser's\n   internal PPSPP protocol handler,\
    \ as exemplified in Section 2.  The\n   clients use the tracking facility to obtain\
    \ the transport address of\n   the PPSPP server(s) and other peers from the swarm,\
    \ executing the\n   peer protocol to retrieve and redistribute the content.  The\
    \ format\n   of the PPSPP URLs should be defined in an extension document.  The\n\
    \   default protocol options should be exploited to keep the URLs small.\n   The\
    \ minimal information a tracking facility must return when queried\n   for a list\
    \ of peers for a swarm is as follows.  Assuming the\n   communication between\
    \ tracking facility and requester is protected,\n   the facility must at least\
    \ return for each peer in the list its IP\n   address, transport protocol identifier\
    \ (i.e., UDP), and transport\n   protocol port number.\n"
- title: 11.1.2.  Migration Path
  contents:
  - "11.1.2.  Migration Path\n   This document does not detail a migration path since\
    \ there is no\n   previous standard protocol providing similar functionality.\n"
- title: 11.1.3.  Requirements on Other Protocols and Functional Components
  contents:
  - "11.1.3.  Requirements on Other Protocols and Functional Components\n   When using\
    \ the peer-to-peer streaming protocol tracker, PPSPP\n   requires a specific behavior\
    \ from this protocol for security reasons,\n   as detailed in Section 12.2.\n"
- title: 11.1.4.  Impact on Network Operation
  contents:
  - "11.1.4.  Impact on Network Operation\n   PPSPP is a peer-to-peer protocol that\
    \ takes advantage of the fact\n   that content is available from multiple sources\
    \ to improve\n   robustness, scalability, and performance.  At the same time,\
    \ poor\n   choices in determining which exact sources to use can lead to bad\n\
    \   experience for the end user and high costs for network operators.\n   Hence,\
    \ PPSPP can benefit from the ALTO protocol to steer peer\n   selection, as described\
    \ in Section 3.10.1.\n"
- title: 11.1.5.  Verifying Correct Operation
  contents:
  - "11.1.5.  Verifying Correct Operation\n   PPSPP is operating correctly when all\
    \ peers obtain the desired\n   content on time.  Therefore, the PPSPP client is\
    \ the ideal location\n   to verify the protocol's correct operation.  However,\
    \ it is not\n   feasible to mandate logging the behavior of PPSPP peers in all\n\
    \   implementations and deployments, for example, due to privacy reasons.\n  \
    \ There are two alternative options:\n   o  Monitoring the PPSPP servers initially\
    \ providing the content,\n      using standard metrics such as bandwidth usage,\
    \ peer connections,\n      and activity, can help identify trouble, see next section\
    \ and\n      [RFC2564].\n   o  The tracker protocol [PPSP-TP] may be used to gather\
    \ information\n      about all peers in a swarm, to obtain a global view of operation,\n\
    \      according to PPSP.OAM.REQ-3 in [RFC6972].\n   Basic operation of the protocol\
    \ can be easily verified when a tracker\n   and swarm metadata are known by starting\
    \ a PPSPP download.  Deep\n   packet inspection for DATA and ACK messages help\
    \ to establish that\n   actual content transfer is happening and that the chunk\
    \ availability\n   signaling and integrity checking are working.\n"
- title: 11.1.6.  Configuration
  contents:
  - "11.1.6.  Configuration\n   Table 8 shows the PPSPP parameters, their defaults,\
    \ and where the\n   parameter is defined.  For parameters that have no default,\
    \ the table\n   row contains the word \"var\" and refers to the section discussing\
    \ the\n   considerations to make when choosing a value.\n   +-------------------------+-----------------------+-----------------+\n\
    \   | Name                    | Default               | Definition      |\n  \
    \ +-------------------------+-----------------------+-----------------+\n   |\
    \ Chunk Size              | var, 1024 bytes       | Section 8.1     |\n   |  \
    \                       | recommended           |                 |\n   |    \
    \                     |                       |                 |\n   | Static\
    \ Content          | 1 (Merkle Hash Tree)  | Section 7.5     |\n   | Integrity\
    \ Protection    |                       |                 |\n   | Method     \
    \             |                       |                 |\n   |              \
    \           |                       |                 |\n   | Live Content Integrity\
    \  | 3 (Unified Merkle     | Section 7.5     |\n   | Protection Method       |\
    \ Tree)                 |                 |\n   |                         |  \
    \                     |                 |\n   | Merkle Hash Tree        | 2 (SHA-256)\
    \           | Section 7.6     |\n   | Function                |              \
    \         |                 |\n   |                         |                \
    \       |                 |\n   | Live Signature          | 13 (ECDSAP256SHA256)\
    \  | Section 7.7     |\n   | Algorithm               |                       |\
    \                 |\n   |                         |                       |  \
    \               |\n   | Chunk Addressing Method | 2 (32-bit chunk       | Section\
    \ 7.8     |\n   |                         | ranges)               |          \
    \       |\n   |                         |                       |            \
    \     |\n   | Live Discard Window     | var                   | Section 6.2, \
    \   |\n   |                         |                       | Section 7.9    \
    \ |\n   |                         |                       |                 |\n\
    \   | NCHUNKS_PER_SIG         | var                   | Section 6.1.2.1 |\n  \
    \ |                         |                       |                 |\n   |\
    \ Dead peer detection     | No reply in 3 minutes | Section 3.12    |\n   |  \
    \                       | + 3 datagrams         |                 |\n   +-------------------------+-----------------------+-----------------+\n\
    \                          Table 8: PPSPP Defaults\n"
- title: 11.2.  Management Considerations
  contents:
  - "11.2.  Management Considerations\n   The management considerations for PPSPP\
    \ are very similar to other\n   protocols that are used for large-scale content\
    \ distribution, in\n   particular HTTP.  How does one manage large numbers of\
    \ servers?  How\n   does one push new content out to a server farm and allows\
    \ staged\n   releases?  How are faults detected and how are servers and end-user\n\
    \   performance measured?  As standard solutions to these challenges are\n   still\
    \ being developed, this section cannot provide a definitive\n   recommendation\
    \ on how PPSPP should be managed.  Hence, it describes\n   the standard solutions\
    \ available at this time and assumes a future\n   extension document will provide\
    \ more complete guidelines.\n"
- title: 11.2.1.  Management Interoperability and Information
  contents:
  - "11.2.1.  Management Interoperability and Information\n   As just stated, PPSPP\
    \ servers providing initial copies of the content\n   are akin to WWW and FTP\
    \ servers.  They can also be deployed in large\n   numbers and thus can benefit\
    \ from standard management facilities.\n   Therefore, PPSPP servers may implement\
    \ an SNMP management interface\n   based on the APPLICATION-MIB [RFC2564], where\
    \ the file object can be\n   used to report on swarms.\n   What is missing is\
    \ the ability to remove or rate limit specific PPSPP\n   swarms on a server. \
    \ This corresponds to removing or limiting\n   specific virtual servers on a web\
    \ server.  In other words, as\n   multiple pieces of content (swarms, virtual\
    \ WWW servers) are\n   multiplexed onto a single server process, more fine-grained\n\
    \   management of that process is required.  This functionality is\n   currently\
    \ missing.\n   Logging is an important functionality for PPSPP servers and,\n\
    \   depending on the deployment, PPSPP clients.  Logging should be done\n   via\
    \ syslog [RFC5424].\n"
- title: 11.2.2.  Fault Management
  contents:
  - "11.2.2.  Fault Management\n   The facilities for verifying correct operation\
    \ and server management\n   (just discussed) appear sufficient for PPSPP fault\
    \ monitoring.  This\n   can be supplemented with host resource [RFC2790] and UDP/IP\
    \ network\n   monitoring [RFC4113], as PPSPP server failures can generally be\n\
    \   attributed directly to conditions on the host or network.\n   Since PPSPP\
    \ has been designed to work in a hostile environment, many\n   benign faults will\
    \ be handled by the mechanisms used for managing\n   attacks.  For example, when\
    \ a malfunctioning peer starts sending the\n   wrong chunks, this is detected\
    \ by the content integrity protection\n   mechanism and another source is sought.\n"
- title: 11.2.3.  Configuration Management
  contents:
  - "11.2.3.  Configuration Management\n   Large-scale deployments may benefit from\
    \ a standard way of\n   replicating a new piece of content on a set of initial\
    \ PPSPP servers.\n   This functionality may need to include controlled releasing,\
    \ such\n   that content becomes available only at a specific point in time\n \
    \  (e.g., the release of a movie trailer).  This functionality could be\n   provided\
    \ via NETCONF [RFC6241], to enable atomic configuration\n   updates over a set\
    \ of servers.  Uploading the new content could be\n   one configuration change,\
    \ making the content available for download\n   by the public another.\n"
- title: 11.2.4.  Accounting Management
  contents:
  - "11.2.4.  Accounting Management\n   Content providers may offer PPSPP hosting\
    \ for different customers and\n   will want to bill these customers, for example,\
    \ based on bandwidth\n   usage.  This situation is a common accounting scenario,\
    \ similar to\n   billing per virtual server for web servers.  PPSPP can therefore\n\
    \   benefit from general standardization efforts in this area [RFC2975]\n   when\
    \ they come to fruition.\n"
- title: 11.2.5.  Performance Management
  contents:
  - "11.2.5.  Performance Management\n   Depending on the deployment scenarios, the\
    \ application performance\n   measurement facilities of [RFC3729] and associated\
    \ [RFC4150] can be\n   used with PPSPP.\n   In addition, when the PPSPP tracker\
    \ protocol is used, it provides a\n   built-in, application-level, performance\
    \ measurement infrastructure\n   for different metrics.  See PPSP.OAM.REQ-3 in\
    \ [RFC6972].\n"
- title: 11.2.6.  Security Management
  contents:
  - "11.2.6.  Security Management\n   Malicious peers should ideally be locked out\
    \ long term.  This is\n   primarily for performance reasons, as the protocol is\
    \ robust against\n   attacks (see next section).  Section 12.7 describes a procedure\
    \ for\n   long-term exclusion.\n"
- title: 12.  Security Considerations
  contents:
  - "12.  Security Considerations\n   As any other network protocol, PPSPP faces a\
    \ common set of security\n   challenges.  An implementation must consider the\
    \ possibility of\n   buffer overruns, DoS attacks and manipulation (i.e., reflection\n\
    \   attacks).  Any guarantee of privacy seems unlikely, as the user is\n   exposing\
    \ its IP address to the peers.  A probable exception is the\n   case of the user\
    \ being hidden behind a public NAT or proxy.  This\n   section discusses the protocol's\
    \ security considerations in detail.\n"
- title: 12.1.  Security of the Handshake Procedure
  contents:
  - "12.1.  Security of the Handshake Procedure\n   Borrowing from the analysis in\
    \ [RFC5971], the PPSPP may be attacked\n   with three types of denial-of-service\
    \ attacks:\n   1.  DoS amplification attack: attackers try to use a PPSPP peer\
    \ to\n       generate more traffic to a victim.\n   2.  DoS flood attack: attackers\
    \ try to deny service to other peers by\n       allocating lots of state at a\
    \ PPSPP peer.\n   3.  Disrupt service to an individual peer: attackers send bogus,\n\
    \       e.g., REQUEST and HAVE messages appearing to come from victim\n      \
    \ Peer A to the Peers B1..Bn serving that peer.  This causes Peer A\n       to\
    \ receive chunks it did not request or to not receive the chunks\n       it requested.\n\
    \   The basic scheme to protect against these attacks is the use of a\n   secure\
    \ handshake procedure.  In the UDP encapsulation, the handshake\n   procedure\
    \ is secured by the use of randomly chosen channel IDs as\n   follows.  The channel\
    \ IDs must be generated following the\n   requirements in [RFC4960] (Section 5.1.3).\n\
    \   When UDP is used, all datagrams carrying PPSPP messages are prefixed\n   with\
    \ a 4-byte channel ID.  These channel IDs are random numbers,\n   established\
    \ during the handshake phase as follows.  Peer A initiates\n   an exchange with\
    \ Peer B by sending a datagram containing a HANDSHAKE\n   message prefixed with\
    \ the channel ID consisting of all zeros.  Peer\n   A's HANDSHAKE contains a randomly\
    \ chosen channel ID, chanA:\n   A->B: chan0 + HANDSHAKE(chanA) + ...\n   When\
    \ Peer B receives this datagram, it creates some state for Peer A,\n   that at\
    \ least contains the channel ID chanA.  Next, Peer B sends a\n   response to Peer\
    \ A, consisting of a datagram containing a HANDSHAKE\n   message prefixed with\
    \ the chanA channel ID.  Peer B's HANDSHAKE\n   contains a randomly chosen channel\
    \ ID, chanB.\n   B->A: chanA + HANDSHAKE(chanB) + ...\n   Peer A now knows that\
    \ Peer B really responds, as it echoed chanA.  So\n   the next datagram that Peer\
    \ A sends may already contain heavy\n   payload, i.e., a chunk.  This next datagram\
    \ to Peer B will be\n   prefixed with the chanB channel ID.  When Peer B receives\
    \ this\n   datagram, both peers have the proof they are really talking to each\n\
    \   other, the three-way handshake is complete.  In other words, the\n   randomly\
    \ chosen channel IDs act as tags (cf.  [RFC4960]\n   (Section 5.1)).\n   A->B:\
    \ chanB + HAVE + DATA + ...\n"
- title: 12.1.1.  Protection against Attack 1
  contents:
  - "12.1.1.  Protection against Attack 1\n   In short, PPSPP does a so-called return\
    \ routability check before\n   heavy payload is sent.  This means that attack\
    \ 1 is fended off: PPSPP\n   does not send back much more data than it received,\
    \ unless it knows\n   it is talking to a live peer.  Attackers sending a spoofed\
    \ HANDSHAKE\n   to Peer B pretending to be Peer A now need to intercept the message\n\
    \   from Peer B to Peer A to get Peer B to send heavy payload, and ensure\n  \
    \ that that heavy payload goes to the victim, something assumed too\n   hard to\
    \ be a practical attack.\n   Note the rule is that no heavy payload may be sent\
    \ until the third\n   datagram.  This has implications for PPSPP implementations\
    \ that use\n   chunk addressing schemes that are verbose.  If a PPSPP implementation\n\
    \   uses large bitmaps to convey chunk availability, these may not be\n   sent\
    \ by Peer B in the second datagram.\n"
- title: 12.1.2.  Protection against Attack 2
  contents:
  - "12.1.2.  Protection against Attack 2\n   On receiving the first datagram Peer\
    \ B will record some state about\n   Peer A.  At present, this state consists\
    \ of the chanA channel ID, and\n   the results of processing the other messages\
    \ in the first datagram.\n   In particular, if Peer A included some HAVE messages,\
    \ Peer B may add\n   a chunk availability map to Peer A's state.  In addition,\
    \ Peer B may\n   request some chunks from Peer A in the second datagram, and Peer\
    \ B\n   will maintain state about these outgoing requests.\n   So presently, PPSPP\
    \ is somewhat vulnerable to attack 2.  An attacker\n   could send many datagrams\
    \ with HANDSHAKEs and HAVEs and thus allocate\n   state at the PPSPP peer.  Therefore,\
    \ Peer A MUST respond immediately\n   to the second datagram, if it is still interested\
    \ in Peer B.\n   The reason for using this slightly vulnerable three-way handshake\n\
    \   instead of the safer handshake procedure of Stream Control\n   Transmission\
    \ Protocol (SCTP) [RFC4960] (Section 5.1) is quicker\n   response time for the\
    \ user.  In the SCTP procedure, Peers A and B\n   cannot request chunks until\
    \ datagrams 3 and 4 respectively, as\n   opposed to 2 and 1 in the proposed procedure.\
    \  This means that the\n   user has to wait less time in PPSPP between starting\
    \ the video stream\n   and seeing the first images.\n"
- title: 12.1.3.  Protection against Attack 3
  contents:
  - "12.1.3.  Protection against Attack 3\n   In general, channel IDs serve to authenticate\
    \ a peer.  Hence, to\n   attack, a malicious Peer T would need to be able to eavesdrop\
    \ on\n   conversations between victim A and a benign Peer B to obtain the\n  \
    \ channel ID Peer B assigned to Peer A, chanB.  Furthermore, attacker\n   Peer\
    \ T would need to be able to spoof, e.g., REQUEST and HAVE\n   messages from Peer\
    \ A to cause Peer B to send heavy DATA messages to\n   Peer A, or prevent Peer\
    \ B from sending them, respectively.\n   The capability to eavesdrop is not common,\
    \ so the protection afforded\n   by channel IDs will be sufficient in most cases.\
    \  If not, point-to-\n   point encryption of traffic should be used, see below.\n"
- title: 12.2.  Secure Peer Address Exchange
  contents:
  - "12.2.  Secure Peer Address Exchange\n   As described in Section 3.10, Peer A\
    \ can send Peer-Exchange messages\n   PEX_RES to Peer B, which contain the IP\
    \ address and port of other\n   peers that are supposedly also in the current\
    \ swarm.  The strength of\n   this mechanism is that it allows decentralized tracking:\
    \ after an\n   initial bootstrap, no central tracker is needed.  The vulnerability\n\
    \   of this mechanism (and DHTs) is that malicious peers can use it for\n   an\
    \ Amplification attack.\n   In particular, a malicious Peer T could send PEX_RES\
    \ messages to\n   well-behaved Peer A with addresses of Peers B1..Bn; on receipt,\
    \ Peer\n   A could send a HANDSHAKE to all these peers.  So, in the worst case,\n\
    \   a single datagram results in N datagrams.  The actual damage depends\n   on\
    \ Peer A's behavior.  For example, when Peer A already has\n   sufficient connections,\
    \ it may not connect to the offered ones at\n   all; but if it is a fresh peer,\
    \ it may connect to all directly.\n   In addition, PEX can be used in Eclipse\
    \ attacks [ECLIPSE] where\n   malicious peers try to isolate a particular peer\
    \ such that it only\n   interacts with malicious peers.  Let us distinguish two\
    \ specific\n   attacks:\n      E1.   Malicious peers try to eclipse the single\
    \ injector in live\n            streaming.\n      E2.   Malicious peers try to\
    \ eclipse a specific consumer peer.\n   Attack E1 has the most impact on the system\
    \ as it would disrupt all\n   peers.\n"
- title: 12.2.1.  Protection against the Amplification Attack
  contents:
  - "12.2.1.  Protection against the Amplification Attack\n   If peer addresses are\
    \ relatively stable, strong protection against\n   the attack can be provided\
    \ by using public key cryptography and\n   certification.  In particular, a PEX_REScert\
    \ message will carry\n   swarm-membership certificates rather than IP address\
    \ and port.  A\n   membership certificate for Peer B states that Peer B at address\n\
    \   (ipB,portB) is part of Swarm S at Time T and is cryptographically\n   signed.\
    \  The receiver Peer A can check the certificate for a valid\n   signature, the\
    \ right swarm and liveliness, and only then consider\n   contacting Peer B.  These\
    \ swarm-membership certificates correspond to\n   signed node descriptors in secure\
    \ decentralized peer sampling\n   services [SPS].\n   Several designs are possible\
    \ for the security environment for these\n   membership certificates.  That is,\
    \ there are different designs\n   possible for who signs the membership certificates\
    \ and how public\n   keys are distributed.  As an example, we describe a design\
    \ where the\n   peer-to-peer streaming protocol tracker acts as certification\n\
    \   authority.\n"
- title: '12.2.2.  Example: Tracker as Certification Authority'
  contents:
  - "12.2.2.  Example: Tracker as Certification Authority\n   Peer A wanting to join\
    \ Swarm S sends a certificate request message to\n   a Tracker X for that swarm.\
    \  Upon receipt, the tracker creates a\n   membership certificate from the request\
    \ with Swarm ID S, a Timestamp\n   T, and the external IP and port it received\
    \ the message from, signed\n   with the tracker's private key.  This certificate\
    \ is returned to Peer\n   A.\n   Peer A then includes this certificate when it\
    \ sends a PEX_REScert to\n   Peer B.  Receiver Peer B verifies it against the\
    \ tracker public key.\n   This tracker public key should be part of the swarm's\
    \ metadata, which\n   Peer B received from a trusted source.  Subsequently, Peer\
    \ B can send\n   the member certificate of Peer A to other peers in PEX_REScert\n\
    \   messages.\n   Peer A can send the certification request when it first contacts\
    \ the\n   tracker or at a later time.  Furthermore, the responses the tracker\n\
    \   sends could contain membership certificates instead of plain\n   addresses,\
    \ such that they can be gossiped securely as well.\n   We assume the tracker is\
    \ protected against attacks and does a return\n   routability check.  The latter\
    \ ensures that malicious peers cannot\n   obtain a certificate for a random host,\
    \ just for hosts where they can\n   eavesdrop on incoming traffic.\n   The load\
    \ generated on the tracker depends on churn and the lifetime\n   of a certificate.\
    \  Certificates can be fairly long lived, given that\n   the main goal of the\
    \ membership certificates is to prevent that\n   malicious Peer T can cause good\
    \ Peer A to contact *random* hosts.\n   The freshness of the timestamp just adds\
    \ extra protection in addition\n   to achieving that goal.  It protects against\
    \ malicious hosts causing\n   a good Peer A to contact hosts that previously participated\
    \ in the\n   swarm.\n   The membership certificate mechanism itself can be used\
    \ for a kind of\n   amplification attack against good peers.  Malicious Peer T\
    \ can cause\n   Peer A to spend some CPU to verify the signatures on the membership\n\
    \   certificates that Peer T sends.  To counter this, Peer A SHOULD check\n  \
    \ a few of the certificates sent and discard the rest if they are\n   defective.\n\
    \   The same membership certificates described above can be registered in\n  \
    \ a Distributed Hash Table that has been secured against the well-known\n   DHT\
    \ specific attacks [SECDHTS].\n   Note that this scheme does not work for peers\
    \ behind a symmetric\n   Network Address Translator, but neither does normal tracker\n\
    \   registration.\n"
- title: 12.2.3.  Protection against Eclipse Attacks
  contents:
  - "12.2.3.  Protection against Eclipse Attacks\n   Before we can discuss Eclipse\
    \ attacks, we first need to establish the\n   security properties of the central\
    \ tracker.  A tracker is vulnerable\n   to Amplification attacks, too.  A malicious\
    \ Peer T could register a\n   victim Peer B with the tracker, and many peers joining\
    \ the swarm will\n   contact Peer B.  Trackers can also be used in Eclipse attacks.\
    \  If\n   many malicious peers register themselves at the tracker, the\n   percentage\
    \ of bad peers in the returned address list may become high.\n   Leaving the protection\
    \ of the tracker to the peer-to-peer streaming\n   protocol tracker specification\
    \ [PPSP-TP], we assume for the following\n   discussion that it returns a true\
    \ random sample of the actual swarm\n   membership (achieved via Sybil attack\
    \ protection).  This means that\n   if 50% of the peers are bad, you'll still\
    \ get 50% good addresses from\n   the tracker.\n   Attack E1 on PEX can be fended\
    \ off by letting live injectors disable\n   PEX -- or at least, letting live injectors\
    \ ensure that part of their\n   connections are to peers whose addresses came\
    \ from the trusted\n   tracker.\n   The same measures defend against attack E2\
    \ on PEX.  They can also be\n   employed dynamically.  When the current set of\
    \ Peers B that Peer A is\n   connected to doesn't provide good quality of service,\
    \ Peer A can\n   contact the tracker to find new candidates.\n"
- title: 12.3.  Support for Closed Swarms
  contents:
  - "12.3.  Support for Closed Swarms\n   Regarding PPSP.SEC.REQ-1 in [RFC6972], the\
    \ Closed Swarms [CLOSED] and\n   Enhanced Closed Swarms [ECS] mechanisms provide\
    \ swarm-level access\n   control.  The basic idea is that a peer cannot download\
    \ from another\n   peer unless it shows a Proof-of-Access.  Enhanced Closed Swarms\n\
    \   improve on the original Closed Swarms by adding on-the-wire\n   encryption\
    \ against man-in-the-middle attacks and more flexible access\n   control rules.\n\
    \   The exact mapping of ECS to PPSPP is defined in [ECS-protocol].\n"
- title: 12.4.  Confidentiality of Streamed Content
  contents:
  - "12.4.  Confidentiality of Streamed Content\n   Regarding PPSP.SEC.REQ-1 in [RFC6972],\
    \ no extra mechanism is needed\n   to support confidentiality in PPSPP.  A content\
    \ publisher wishing\n   confidentiality should just distribute content in ciphertext\
    \ and/or\n   in a format to which Digital Rights Management (DRM) techniques have\n\
    \   been applied.  In that case, it is assumed a higher layer handles key\n  \
    \ management out-of-band.  Alternatively, pure point-to-point\n   encryption of\
    \ content and traffic can be provided by the proposed\n   Closed Swarms access\
    \ control mechanism, by DTLS [RFC6347], or by\n   IPsec [RFC4301].\n   When transmitting\
    \ over DTLS, PPSPP can obtain the PMTU estimate\n   maintained by the IP layer\
    \ to determine how much payload can be put\n   in a single datagram without fragmentation\
    \ ([RFC6347],\n   Section 4.1.1.1).  If PMTU changes and the chunk size becomes\
    \ too\n   large to fit into a single datagram, PPSPP can choose to allow\n   fragmentation\
    \ by clearing the Don't Fragment (DF) bit.\n   Alternatively, the content publisher\
    \ can decide to use smaller chunks\n   and transmit multiple in the same datagram\
    \ when the MTU allows.\n"
- title: 12.5.  Strength of the Hash Function for Merkle Hash Trees
  contents:
  - "12.5.  Strength of the Hash Function for Merkle Hash Trees\n   Implementations\
    \ MUST support SHA-1 as the hash function for content\n   integrity protection\
    \ via Merkle hash trees.  SHA-1 may be preferred\n   over stronger hash functions\
    \ by content providers because it reduces\n   on-the-wire overhead.  As such,\
    \ it presents a trade-off between\n   performance and security.  The security\
    \ considerations for SHA-1 are\n   discussed in [RFC6194].\n   In general, note\
    \ that the hash function is used in a hash tree, which\n   makes it more complex\
    \ to create collisions.  In particular, if\n   attackers manage to find a collision\
    \ for a hash, it can replace just\n   one chunk, so the impact is limited.  If\
    \ fixed-size chunks are used,\n   the collision even has to be of the same size\
    \ as the original chunk.\n   For hashes higher up in the hash tree, a collision\
    \ must be a\n   concatenation of two hashes.  In sum, finding collisions that\
    \ fit\n   with the hash tree are generally harder to find than regular\n   collisions.\n"
- title: 12.6.  Limit Potential Damage and Resource Exhaustion by Bad or Broken
  contents:
  - "12.6.  Limit Potential Damage and Resource Exhaustion by Bad or Broken\n    \
    \   Peers\n   Regarding PPSP.SEC.REQ-2 in [RFC6972], this section provides an\n\
    \   analysis of the potential damage a malicious peer can do with each\n   message\
    \ in the protocol, and how it is prevented by the protocol\n   (implementation).\n"
- title: 12.6.1.  HANDSHAKE
  contents:
  - "12.6.1.  HANDSHAKE\n   o  Secured against DoS Amplification attacks as described\
    \ in\n      Section 12.1.\n   o  Threat HS.1: An Eclipse attack where Peers T1..Tn\
    \ fill all\n      connection slots of Peer A by initiating the connection to Peer\
    \ A.\n      Solution: Peer A must not let other peers fill all its available\n\
    \      connection slots, i.e., Peer A must initiate connections itself\n     \
    \ too, to prevent isolation.\n"
- title: 12.6.2.  HAVE
  contents:
  - "12.6.2.  HAVE\n   o  Threat HAVE.1: Malicious Peer T can claim to have content\
    \ that it\n      does not.  Subsequently, Peer T won't respond to requests.\n\
    \      Solution: Peer A will consider Peer T to be a slow peer and not\n     \
    \ ask it again.\n   o  Threat HAVE.2: Malicious Peer T can claim not to have content.\n\
    \      Hence, it won't contribute.\n      Solution: Peer and chunk selection algorithms\
    \ external to the\n      protocol will implement fairness and provide sharing\
    \ incentives.\n"
- title: 12.6.3.  DATA
  contents:
  - "12.6.3.  DATA\n   o  Threat DATA.1: Peer T sending bogus chunks.\n      Solution:\
    \ The content integrity protection schemes defend against\n      this.\n   o \
    \ Threat DATA.2: Peer T sends Peer A unrequested chunks.\n      To protect against\
    \ this threat we need network-level DoS\n      prevention.\n"
- title: 12.6.4.  ACK
  contents:
  - "12.6.4.  ACK\n   o  Threat ACK.1: Peer T acknowledges wrong chunks.\n      Solution:\
    \ Peer A will detect inconsistencies with the data it sent\n      to Peer T.\n\
    \   o  Threat ACK.2: Peer T modifies timestamp in ACK to Peer A used for\n   \
    \   time-based congestion control.\n      Solution: In theory, by decreasing the\
    \ timestamp, Peer T could\n      fake that there is no congestion when in fact\
    \ there is, causing\n      Peer A to send more data than it should.  [RFC6817]\
    \ does not list\n      this as a security consideration.  Possibly, this attack\
    \ can be\n      detected by the large resulting asymmetry between round-trip time\n\
    \      and measured one-way delay.\n"
- title: 12.6.5.  INTEGRITY and SIGNED_INTEGRITY
  contents:
  - "12.6.5.  INTEGRITY and SIGNED_INTEGRITY\n   o  Threat INTEGRITY.1: An amplification\
    \ attack where Peer T sends\n      bogus INTEGRITY or SIGNED_INTEGRITY messages,\
    \ causing Peer A to\n      checks hashes or signatures, thus spending CPU unnecessarily.\n\
    \      Solution: If the hashes/signatures don't check out, Peer A will\n     \
    \ stop asking Peer T because of the atomic datagram principle and\n      the content\
    \ integrity protection.  Subsequent unsolicited traffic\n      from Peer T will\
    \ be ignored.\n   o  Threat INTEGRITY.2: An attack where Peer T sends old\n  \
    \    SIGNED_INTEGRITY messages in the Unified Merkle Tree scheme,\n      trying\
    \ to make Peer A tune in at a past point in the live stream.\n      Solution:\
    \ The timestamp in the SIGNED_INTEGRITY message protects\n      against such replays.\
    \  Subsequent traffic from Peer T will be\n      ignored.\n"
- title: 12.6.6.  REQUEST
  contents:
  - "12.6.6.  REQUEST\n   o  Threat REQUEST.1: Peer T could request lots from Peer\
    \ A, leaving\n      Peer A without resources for others.\n      Solution: A limit\
    \ is imposed on the upload capacity a single peer\n      can consume, for example,\
    \ by using an upload bandwidth scheduler\n      that takes into account the need\
    \ of multiple peers.  A natural\n      upper limit of this upload quotum is the\
    \ bitrate of the content,\n      taking into account that this may be variable.\n"
- title: 12.6.7.  CANCEL
  contents:
  - "12.6.7.  CANCEL\n   o  Threat CANCEL.1: Peer T sends CANCEL messages for content\
    \ it never\n      requested to Peer A.\n      Solution: Peer A will detect the\
    \ inconsistency of the messages and\n      ignore them.  Note that CANCEL messages\
    \ may be received\n      unexpectedly when a transport is used where REQUEST messages\
    \ may\n      be lost or reordered with respect to the subsequent CANCELs.\n"
- title: 12.6.8.  CHOKE
  contents:
  - "12.6.8.  CHOKE\n   o  Threat CHOKE.1: Peer T sends REQUEST messages after Peer\
    \ A sent\n      Peer B a CHOKE message.\n      Solution: Peer A will just discard\
    \ the unwanted REQUESTs and\n      resend the CHOKE, assuming it got lost.\n"
- title: 12.6.9.  UNCHOKE
  contents:
  - "12.6.9.  UNCHOKE\n   o  Threat UNCHOKE.1: Peer T sends an UNCHOKE message to\
    \ Peer A\n      without having sent a CHOKE message before.\n      Solution: Peer\
    \ A can easily detect this violation of protocol\n      state, and ignore it.\
    \  Note this can also happen due to loss of a\n      CHOKE message sent by a benign\
    \ peer.\n   o  Threat UNCHOKE.2: Peer T sends an UNCHOKE message to Peer A, but\n\
    \      subsequently does not respond to its REQUESTs.\n      Solution: Peer A\
    \ will consider Peer T to be a slow peer and not\n      ask it again.\n"
- title: 12.6.10.  PEX_RES
  contents:
  - "12.6.10.  PEX_RES\n   o  Secured against amplification and Eclipse attacks as\
    \ described in\n      Section 12.2.\n"
- title: 12.6.11.  Unsolicited Messages in General
  contents:
  - "12.6.11.  Unsolicited Messages in General\n   o  Threat: Peer T could send a\
    \ spoofed PEX_REQ or REQUEST from Peer B\n      to Peer A, causing Peer A to send\
    \ a PEX_RES/DATA to Peer B.\n      Solution: the message from Peer T won't be\
    \ accepted unless Peer T\n      does a handshake first, in which case the reply\
    \ goes to Peer T,\n      not victim Peer B.\n"
- title: 12.7.  Exclude Bad or Broken Peers
  contents:
  - "12.7.  Exclude Bad or Broken Peers\n   This section is regarding PPSP.SEC.REQ-2\
    \ in [RFC6972].  A receiving\n   peer can detect malicious or faulty senders as\
    \ just described, which\n   it can then subsequently ignore.  However, excluding\
    \ such a bad peer\n   from the system completely is complex.  Random monitoring\
    \ by trusted\n   peers that would blacklist bad peers as described in [DETMAL]\
    \ is one\n   option.  This mechanism does require extra capacity to run such\n\
    \   trusted peers, which must be indistinguishable from regular peers,\n   and\
    \ requires a solution for the timely distribution of this blacklist\n   to peers\
    \ in a scalable manner.\n"
- title: 13.  References
  contents:
  - '13.  References

    '
- title: 13.1.  Normative References
  contents:
  - "13.1.  Normative References\n   [CCITT.X690.2002]\n              International\
    \ Telephone and Telegraph Consultative\n              Committee, \"ASN.1 encoding\
    \ rules: Specification of basic\n              encoding Rules (BER), Canonical\
    \ encoding rules (CER) and\n              Distinguished encoding rules (DER)\"\
    , CCITT Recommendation\n              X.690, July 2002.\n   [FIPS180-4]\n    \
    \          National Institute of Standards and Technology,\n              Information\
    \ Technology Laboratory, \"Federal Information\n              Processing Standards:\
    \ Secure Hash Standard (SHS)\", FIPS\n              PUB 180-4, March 2012.\n \
    \  [IANADNSSECALGNUM]\n              IANA, \"Domain Name System Security (DNSSEC)\
    \ Algorithm\n              Numbers\", March 2014,\n              <http://www.iana.org/assignments/dns-sec-alg-numbers>.\n\
    \   [RFC1918]  Rekhter, Y., Moskowitz, B., Karrenberg, D., J. de Groot,\n    \
    \          G., and E. Lear, \"Address Allocation for Private\n              Internets\"\
    , BCP 5, RFC 1918, DOI 10.17487/RFC1918,\n              February 1996, <http://www.rfc-editor.org/info/rfc1918>.\n\
    \   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n        \
    \      Requirement Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119,\
    \ March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC3110]\
    \  Eastlake 3rd, D., \"RSA/SHA-1 SIGs and RSA KEYs in the\n              Domain\
    \ Name System (DNS)\", RFC 3110, DOI 10.17487/RFC3110,\n              May 2001,\
    \ <http://www.rfc-editor.org/info/rfc3110>.\n   [RFC3986]  Berners-Lee, T., Fielding,\
    \ R., and L. Masinter, \"Uniform\n              Resource Identifier (URI): Generic\
    \ Syntax\", STD 66, RFC\n              3986, DOI 10.17487/RFC3986, January 2005,\n\
    \              <http://www.rfc-editor.org/info/rfc3986>.\n   [RFC4034]  Arends,\
    \ R., Austein, R., Larson, M., Massey, D., and S.\n              Rose, \"Resource\
    \ Records for the DNS Security Extensions\",\n              RFC 4034, DOI 10.17487/RFC4034,\
    \ March 2005,\n              <http://www.rfc-editor.org/info/rfc4034>.\n   [RFC4291]\
    \  Hinden, R. and S. Deering, \"IP Version 6 Addressing\n              Architecture\"\
    , RFC 4291, DOI 10.17487/RFC4291, February\n              2006, <http://www.rfc-editor.org/info/rfc4291>.\n\
    \   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\n         \
    \     Housley, R., and W. Polk, \"Internet X.509 Public Key\n              Infrastructure\
    \ Certificate and Certificate Revocation List\n              (CRL) Profile\",\
    \ RFC 5280, DOI 10.17487/RFC5280, May 2008,\n              <http://www.rfc-editor.org/info/rfc5280>.\n\
    \   [RFC5702]  Jansen, J., \"Use of SHA-2 Algorithms with RSA in DNSKEY\n    \
    \          and RRSIG Resource Records for DNSSEC\", RFC 5702,\n              DOI\
    \ 10.17487/RFC5702, October 2009,\n              <http://www.rfc-editor.org/info/rfc5702>.\n\
    \   [RFC5905]  Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch,\n      \
    \        \"Network Time Protocol Version 4: Protocol and Algorithms\n        \
    \      Specification\", RFC 5905, DOI 10.17487/RFC5905, June 2010,\n         \
    \     <http://www.rfc-editor.org/info/rfc5905>.\n   [RFC6605]  Hoffman, P. and\
    \ W. Wijngaards, \"Elliptic Curve Digital\n              Signature Algorithm (DSA)\
    \ for DNSSEC\", RFC 6605,\n              DOI 10.17487/RFC6605, April 2012,\n \
    \             <http://www.rfc-editor.org/info/rfc6605>.\n   [RFC6817]  Shalunov,\
    \ S., Hazel, G., Iyengar, J., and M. Kuehlewind,\n              \"Low Extra Delay\
    \ Background Transport (LEDBAT)\", RFC 6817,\n              DOI 10.17487/RFC6817,\
    \ December 2012,\n              <http://www.rfc-editor.org/info/rfc6817>.\n"
- title: 13.2.  Informative References
  contents:
  - "13.2.  Informative References\n   [ABMRKL]   Bakker, A., \"Merkle hash torrent\
    \ extension\", BitTorrent\n              Enhancement Proposal 30, March 2009,\n\
    \              <http://bittorrent.org/beps/bep_0030.html>.\n   [BINMAP]   Grishchenko,\
    \ V. and J. Pouwelse, \"Binmaps: Hybridizing\n              Bitmaps and Binary\
    \ Trees\", Delft University of Technology\n              Parallel and Distributed\
    \ Systems Report Series, Report\n              number PDS-2011-005, ISSN 1387-2109,\
    \ April 2009.\n   [BITOS]    Vlavianos, A., Iliofotou, M., Mathieu, F., and M.\n\
    \              Faloutsos, \"BiToS: Enhancing BitTorrent for Supporting\n     \
    \         Streaming Applications\", IEEE INFOCOM Global Internet\n           \
    \   Symposium, Barcelona, Spain, April 2006.\n   [BITTORRENT]\n              Cohen,\
    \ B., \"The BitTorrent Protocol Specification\",\n              BitTorrent Enhancement\
    \ Proposal 3, February 2008,\n              <http://bittorrent.org/beps/bep_0003.html>.\n\
    \   [CLOSED]   Borch, N., Mitchell, K., Arntzen, I., and D. Gabrijelcic,\n   \
    \           \"Access Control to BitTorrent Swarms Using Closed Swarms\",\n   \
    \           ACM workshop on Advanced Video Streaming Techniques for\n        \
    \      Peer-to-Peer Networks and Social Networking (AVSTP2P '10),\n          \
    \    Florence, Italy, October 2010,\n              <http://doi.acm.org/10.1145/1877891.1877898>.\n\
    \   [DETMAL]   Shetty, S., Galdames, P., Tavanapong, W., and Ying. Cai,\n    \
    \          \"Detecting Malicious Peers in Overlay Multicast\n              Streaming\"\
    , IEEE Conference on Local Computer Networks,\n              (LCN'06), Tampa,\
    \ FL, USA, November 2006.\n   [ECLIPSE]  Sit, E. and R. Morris, \"Security Considerations\
    \ for Peer-\n              to-Peer Distributed Hash Tables\", IPTPS '01: Revised\n\
    \              Papers from the First International Workshop on Peer-to-\n    \
    \          Peer Systems, pp. 261-269, Springer-Verlag, 2002.\n   [ECS]      Jovanovikj,\
    \ V., Gabrijelcic, D., and T. Klobucar, \"Access\n              Control in BitTorrent\
    \ P2P Networks Using the Enhanced\n              Closed Swarms Protocol\", International\
    \ Conference on\n              Emerging Security Information, Systems and Technologies\n\
    \              (SECURWARE 2011), pp. 97-102, Nice, France, August 2011.\n   [ECS-protocol]\n\
    \              Gabrijelcic, D., \"Enhanced Closed Swarm protocol\", Work in\n\
    \              Progress, draft-ppsp-gabrijelcic-ecs-01, June 2013.\n   [EPLIVEPERF]\n\
    \              Bonald, T., Massoulie, L., Mathieu, F., Perino, D., and A.\n  \
    \            Twigg, \"Epidemic live streaming: optimal performance\n         \
    \     trade-offs\", Proceedings of the 2008 ACM SIGMETRICS\n              International\
    \ Conference on Measurement and Modeling of\n              Computer Systems, Annapolis,\
    \ MD, USA, June 2008.\n   [GIVE2GET] Mol, J., Pouwelse, J., Meulpolder, M., Epema,\
    \ D., and H.\n              Sips, \"Give-to-Get: Free-riding-resilient Video-on-Demand\n\
    \              in P2P Systems\", Proceedings Multimedia Computing and\n      \
    \        Networking conference (Proceedings of SPIE, Vol. 6818),\n           \
    \   San Jose, CA, USA, January 2008.\n   [HAC01]    Menezes, A., van Oorschot,\
    \ P., and S. Vanstone, \"Handbook\n              of Applied Cryptography\", CRC\
    \ Press, (Fifth Printing,\n              August 2001), October 1996.\n   [JIM11]\
    \    Jimenez, R., Osmani, F., and B. Knutsson, \"Sub-Second\n              Lookups\
    \ on a Large-Scale Kademlia-Based Overlay\", IEEE\n              International\
    \ Conference on Peer-to-Peer Computing\n              (P2P'11), Kyoto, Japan,\
    \ August 2011.\n   [LBT]      Rossi, D., Testa, C., Valenti, S., and L. Muscariello,\n\
    \              \"LEDBAT: the new BitTorrent congestion control protocol\",\n \
    \             Computer Communications and Networks (ICCCN), Zurich,\n        \
    \      Switzerland, August 2010.\n   [LCOMPL]   Testa, C. and D. Rossi, \"On the\
    \ impact of uTP on\n              BitTorrent completion time\", IEEE International\
    \ Conference\n              on Peer-to-Peer Computing (P2P'11), Kyoto, Japan,\
    \ August\n              2011.\n   [MERKLE]   Merkle, R., \"Secrecy, Authentication,\
    \ and Public Key\n              Systems\", Ph.D. thesis, Dept. of Electrical Engineering,\n\
    \              Stanford University, CA, USA, pp 40-45, 1979.\n   [P2PWIKI]  Bakker,\
    \ A., Petrocco, R., Dale, M., Gerber, J.,\n              Grishchenko, V., Rabaioli,\
    \ D., and J. Pouwelse, \"Online\n              video using BitTorrent and HTML5\
    \ applied to Wikipedia\",\n              IEEE International Conference on Peer-to-Peer\
    \ Computing\n              (P2P'10), Delft, The Netherlands, August 2010.\n  \
    \ [POLLIVE]  Dhungel, P., Hei, Xiaojun., Ross, K., and N. Saxena,\n          \
    \    \"Pollution in P2P Live Video Streaming\", International\n              Journal\
    \ of Computer Networks & Communications (IJCNC) Vol.\n              1, No. 2,\
    \ Jul 2009.\n   [PPSP-TP]  Cruz, R., Nunes, M., Yingjie, G., Xia, J., Huang, R.,\n\
    \              Taveira, J., and D. Lingli, \"PPSP Tracker Protocol-Base\n    \
    \          Protocol (PPSP-TP/1.0)\", Work in Progress,\n              draft-ietf-ppsp-base-tracker-protocol-09,\
    \ March 2015.\n   [PPSPPERF] Petrocco, R., Pouwelse, J., and D. Epema, \"Performance\n\
    \              Analysis of the Libswift P2P Streaming Protocol\", IEEE\n     \
    \         International Conference on Peer-to-Peer Computing\n              (P2P'12),\
    \ Tarragona, Spain, September 2012.\n   [RFC2564]  Kalbfleisch, C., Krupczak,\
    \ C., Presuhn, R., and J.\n              Saperia, \"Application Management MIB\"\
    , RFC 2564,\n              DOI 10.17487/RFC2564, May 1999,\n              <http://www.rfc-editor.org/info/rfc2564>.\n\
    \   [RFC2790]  Waldbusser, S. and P. Grillo, \"Host Resources MIB\", RFC\n   \
    \           2790, DOI 10.17487/RFC2790, March 2000,\n              <http://www.rfc-editor.org/info/rfc2790>.\n\
    \   [RFC2975]  Aboba, B., Arkko, J., and D. Harrington, \"Introduction to\n  \
    \            Accounting Management\", RFC 2975, DOI 10.17487/RFC2975,\n      \
    \        October 2000, <http://www.rfc-editor.org/info/rfc2975>.\n   [RFC3365]\
    \  Schiller, J., \"Strong Security Requirements for Internet\n              Engineering\
    \ Task Force Standard Protocols\", BCP 61, RFC\n              3365, DOI 10.17487/RFC3365,\
    \ August 2002,\n              <http://www.rfc-editor.org/info/rfc3365>.\n   [RFC3729]\
    \  Waldbusser, S., \"Application Performance Measurement MIB\",\n            \
    \  RFC 3729, DOI 10.17487/RFC3729, March 2004,\n              <http://www.rfc-editor.org/info/rfc3729>.\n\
    \   [RFC4113]  Fenner, B. and J. Flick, \"Management Information Base for\n  \
    \            the User Datagram Protocol (UDP)\", RFC 4113,\n              DOI\
    \ 10.17487/RFC4113, June 2005,\n              <http://www.rfc-editor.org/info/rfc4113>.\n\
    \   [RFC4150]  Dietz, R. and R. Cole, \"Transport Performance Metrics\n      \
    \        MIB\", RFC 4150, DOI 10.17487/RFC4150, August 2005,\n              <http://www.rfc-editor.org/info/rfc4150>.\n\
    \   [RFC4193]  Hinden, R. and B. Haberman, \"Unique Local IPv6 Unicast\n     \
    \         Addresses\", RFC 4193, DOI 10.17487/RFC4193, October 2005,\n       \
    \       <http://www.rfc-editor.org/info/rfc4193>.\n   [RFC4301]  Kent, S. and\
    \ K. Seo, \"Security Architecture for the\n              Internet Protocol\",\
    \ RFC 4301, DOI 10.17487/RFC4301,\n              December 2005, <http://www.rfc-editor.org/info/rfc4301>.\n\
    \   [RFC4821]  Mathis, M. and J. Heffner, \"Packetization Layer Path MTU\n   \
    \           Discovery\", RFC 4821, DOI 10.17487/RFC4821, March 2007,\n       \
    \       <http://www.rfc-editor.org/info/rfc4821>.\n   [RFC4960]  Stewart, R.,\
    \ Ed., \"Stream Control Transmission Protocol\",\n              RFC 4960, DOI\
    \ 10.17487/RFC4960, September 2007,\n              <http://www.rfc-editor.org/info/rfc4960>.\n\
    \   [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n   \
    \           IANA Considerations Section in RFCs\", BCP 26, RFC 5226,\n       \
    \       DOI 10.17487/RFC5226, May 2008,\n              <http://www.rfc-editor.org/info/rfc5226>.\n\
    \   [RFC5389]  Rosenberg, J., Mahy, R., Matthews, P., and D. Wing,\n         \
    \     \"Session Traversal Utilities for NAT (STUN)\", RFC 5389,\n            \
    \  DOI 10.17487/RFC5389, October 2008,\n              <http://www.rfc-editor.org/info/rfc5389>.\n\
    \   [RFC5424]  Gerhards, R., \"The Syslog Protocol\", RFC 5424,\n            \
    \  DOI 10.17487/RFC5424, March 2009,\n              <http://www.rfc-editor.org/info/rfc5424>.\n\
    \   [RFC5706]  Harrington, D., \"Guidelines for Considering Operations and\n \
    \             Management of New Protocols and Protocol Extensions\", RFC\n   \
    \           5706, DOI 10.17487/RFC5706, November 2009,\n              <http://www.rfc-editor.org/info/rfc5706>.\n\
    \   [RFC5971]  Schulzrinne, H. and R. Hancock, \"GIST: General Internet\n    \
    \          Signalling Transport\", RFC 5971, DOI 10.17487/RFC5971,\n         \
    \     October 2010, <http://www.rfc-editor.org/info/rfc5971>.\n   [RFC6194]  Polk,\
    \ T., Chen, L., Turner, S., and P. Hoffman, \"Security\n              Considerations\
    \ for the SHA-0 and SHA-1 Message-Digest\n              Algorithms\", RFC 6194,\
    \ DOI 10.17487/RFC6194, March 2011,\n              <http://www.rfc-editor.org/info/rfc6194>.\n\
    \   [RFC6241]  Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed.,\n  \
    \            and A. Bierman, Ed., \"Network Configuration Protocol\n         \
    \     (NETCONF)\", RFC 6241, DOI 10.17487/RFC6241, June 2011,\n              <http://www.rfc-editor.org/info/rfc6241>.\n\
    \   [RFC6347]  Rescorla, E. and N. Modadugu, \"Datagram Transport Layer\n    \
    \          Security Version 1.2\", RFC 6347, DOI 10.17487/RFC6347,\n         \
    \     January 2012, <http://www.rfc-editor.org/info/rfc6347>.\n   [RFC6709]  Carpenter,\
    \ B., Aboba, B., Ed., and S. Cheshire, \"Design\n              Considerations\
    \ for Protocol Extensions\", RFC 6709,\n              DOI 10.17487/RFC6709, September\
    \ 2012,\n              <http://www.rfc-editor.org/info/rfc6709>.\n   [RFC6972]\
    \  Zhang, Y. and N. Zong, \"Problem Statement and Requirements\n             \
    \ of the Peer-to-Peer Streaming Protocol (PPSP)\", RFC 6972,\n              DOI\
    \ 10.17487/RFC6972, July 2013,\n              <http://www.rfc-editor.org/info/rfc6972>.\n\
    \   [RFC7285]  Alimi, R., Ed., Penno, R., Ed., Yang, Y., Ed., Kiesel, S.,\n  \
    \            Previdi, S., Roome, W., Shalunov, S., and R. Woundy,\n          \
    \    \"Application-Layer Traffic Optimization (ALTO) Protocol\",\n           \
    \   RFC 7285, DOI 10.17487/RFC7285, September 2014,\n              <http://www.rfc-editor.org/info/rfc7285>.\n\
    \   [SECDHTS]  Urdaneta, G., Pierre, G., and M. van Steen, \"A Survey of\n   \
    \           DHT Security Techniques\", ACM Computing Surveys,\n              vol.\
    \ 43(2), January 2011.\n   [SIGMCAST]\n              Wong, C. and S. Lam, \"Digital\
    \ Signatures for Flows and\n              Multicasts\", IEEE/ACM Transactions\
    \ on Networking 7(4),\n              pp. 502-513, August 1999.\n   [SPS]     \
    \ Jesi, G., Montresor, A., and M. van Steen, \"Secure Peer\n              Sampling\"\
    , Computer Networks vol. 54(12), pp. 2086-2098,\n              Elsevier, August\
    \ 2010.\n   [SWIFTIMPL]\n              Grishchenko, V., Paananen, J., Pronchenkov,\
    \ A., Bakker,\n              A., and R. Petrocco, \"Swift reference implementation\"\
    ,\n              2015, <https://github.com/libswift/libswift>.\n   [TIT4TAT] \
    \ Cohen, B., \"Incentives Build Robustness in BitTorrent\",\n              1st\
    \ Workshop on Economics of Peer-to-Peer Systems,\n              Berkeley, CA,\
    \ USA, May 2003.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   Arno Bakker, Riccardo Petrocco, and Victor Grishchenko are\
    \ partially\n   supported by the P2P-Next project <http://www.p2p-next.org/>,\
    \ a\n   research project supported by the European Community under its 7th\n \
    \  Framework Programme (grant agreement no. 216217).  The views and\n   conclusions\
    \ contained herein are those of the authors and should not\n   be interpreted\
    \ as necessarily representing the official policies or\n   endorsements, either\
    \ expressed or implied, of the P2P-Next project or\n   the European Commission.\n\
    \   PPSPP was designed by Victor Grishchenko at Technische Universiteit\n   Delft\
    \ under supervision of Johan Pouwelse.  The authors would like to\n   thank the\
    \ following people for their contributions to this document:\n   the chairs (Martin\
    \ Stiemerling, Yunfei Zhang, Stefano Previdi, and\n   Ning Zong) and members of\
    \ the IETF PPSP working group, and Mihai\n   Capota, Raul Jimenez, Flutra Osmani,\
    \ and Raynor Vliegendhart.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Arno Bakker\n   Vrije Universiteit Amsterdam\n   De Boelelaan\
    \ 1081\n   Amsterdam  1081HV\n   The Netherlands\n   Email: arno@cs.vu.nl\n  \
    \ Riccardo Petrocco\n   Technische Universiteit Delft\n   Mekelweg 4\n   Delft\
    \  2628CD\n   The Netherlands\n   Email: r.petrocco@gmail.com\n   Victor Grishchenko\n\
    \   Technische Universiteit Delft\n   Mekelweg 4\n   Delft  2628CD\n   The Netherlands\n\
    \   Email: victor.grishchenko@gmail.com\n"
