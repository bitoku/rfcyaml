- title: __initial_text__
  contents:
  - '       Extensible Markup Language Evidence Record Syntax (XMLERS)

    '
- title: Abstract
  contents:
  - "Abstract\n   In many scenarios, users must be able to demonstrate the (time of)\n\
    \   existence, integrity, and validity of data including signed data for\n   long\
    \ or undetermined periods of time.  This document specifies XML\n   syntax and\
    \ processing rules for creating evidence for long-term non-\n   repudiation of\
    \ existence and integrity of data.  The Extensible\n   Markup Language Evidence\
    \ Record Syntax XMLERS provides alternative\n   syntax and processing rules to\
    \ the ASN.1 (Abstract Syntax Notation\n   One) ERS (Evidence Record Syntax) (RFC\
    \ 4998) syntax by using XML.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6283.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \      1.1. Motivation .................................................3\n  \
    \    1.2. General Overview and Requirements ..........................4\n    \
    \  1.3. Terminology ................................................6\n      1.4.\
    \ Conventions Used in This Document ..........................7\n   2. Evidence\
    \ Record .................................................7\n      2.1. Structure\
    \ ..................................................8\n      2.2. Generation ................................................12\n\
    \      2.3. Verification ..............................................13\n  \
    \ 3. Archive Time-Stamp .............................................13\n    \
    \  3.1. Structure .................................................13\n      \
    \     3.1.1. Hash Tree ..........................................13\n        \
    \   3.1.2. Time-Stamp .........................................14\n          \
    \ 3.1.3. Cryptographic Information List .....................15\n      3.2. Generation\
    \ ................................................16\n           3.2.1. Generation\
    \ of Hash Tree ............................17\n           3.2.2. Reduction of\
    \ Hash Tree .............................19\n      3.3. Verification ..............................................21\n\
    \   4. Archive Time-Stamp Sequence and Archive Time-Stamp Chain .......22\n  \
    \    4.1. Structure .................................................23\n    \
    \       4.1.1. Digest Method ......................................23\n      \
    \     4.1.2. Canonicalization Method ............................24\n      4.2.\
    \ Generation ................................................25\n           4.2.1.\
    \ Time-Stamp Renewal .................................25\n           4.2.2. Hash\
    \ Tree Renewal ..................................26\n      4.3. Verification ..............................................27\n\
    \   5. Encryption .....................................................28\n  \
    \ 6. Version ........................................................29\n   7.\
    \ Storage of Policies ............................................30\n   8. XSD\
    \ Schema for the Evidence Record .............................30\n   9. Security\
    \ Considerations ........................................34\n      9.1. Secure\
    \ Algorithms .........................................34\n      9.2. Redundancy\
    \ ................................................34\n      9.3. Secure Time-Stamps\
    \ ........................................35\n      9.4. Time-Stamp Verification\
    \ ...................................35\n   10. IANA Considerations ...........................................36\n\
    \   11. References ....................................................37\n  \
    \    11.1. Normative References .....................................37\n    \
    \  11.2. Informative References ...................................39\n   Appendix\
    \ A. Detailed Verification Process of an Evidence Record ...41\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The purpose of the document is to define XML schema and\
    \ processing\n   rules for Evidence Record Syntax in XML (Extensible Markup Language)\n\
    \   format.  The document is related to initial ASN.1 (Abstract Syntax\n   Notation\
    \ One) syntax for Evidence Record Syntax as defined in\n   [RFC4998].\n"
- title: 1.1.  Motivation
  contents:
  - "1.1.  Motivation\n   The evolution of electronic commerce and electronic data\
    \ exchange in\n   general requires introduction of non-repudiable proof of data\n\
    \   existence as well as data integrity and authenticity.  Such data and\n   non-repudiable\
    \ proof of existence must endure for long periods of\n   time, even when the initial\
    \ information to prove its existence and\n   integrity weakens or ceases to exist.\
    \  Mechanisms such as digital\n   signatures defined in [RFC5652], for example,\
    \ do not provide absolute\n   reliability on a long-term basis.  Algorithms and\
    \ cryptographic\n   material used to create a signature can become weak in the\
    \ course of\n   time, and information needed to validate digital signatures may\n\
    \   become compromised or simply cease to exist, for example, due to the\n   disbanding\
    \ of a certificate service provider.  Providing a stable\n   environment for electronic\
    \ data on a long-term basis requires the\n   introduction of additional means\
    \ to continually provide an\n   appropriate level of trust in evidence on data\
    \ existence, integrity,\n   and authenticity.\n   All integrity and authenticity\
    \ protecting techniques used today\n   suffer from the problem of degrading reliability\
    \ over time, including\n   techniques for Time-Stamping, which are generally recognized\
    \ as data\n   existence and integrity proof mechanisms.  Over long periods of\
    \ time\n   cryptographic algorithms used may become weak or encryption keys\n\
    \   compromised.  Some of the problems might not even be of technical\n   nature\
    \ like a Time-Stamping Authority going out of business and\n   ceasing its service.\
    \  To create a stable environment where proof of\n   existence and integrity can\
    \ endure well into the future a new\n   technical approach must be used.\n   Long-term\
    \ non-repudiation of data existence and demonstration of data\n   integrity techniques\
    \ have been already introduced, for example, by\n   long-term signature syntaxes\
    \ like those defined in [RFC5126].  Long-\n   term signature syntaxes and processing\
    \ rules address only the long-\n   term endurance of the digital signatures themselves,\
    \ while Evidence\n   Record Syntax broadens this approach for data of any type\
    \ or format\n   including digital signatures.\n   XMLERS (Extensible Markup Language\
    \ Evidence Record Syntax) is based\n   on Evidence Record Syntax as defined in\
    \ [RFC4998] and is addressing\n   the same problem of long-term non-repudiable\
    \ proof of data existence\n   and demonstration of data integrity on a long-term\
    \ basis.  XMLERS\n   does not supplement the [RFC4998] specification.  Following\n\
    \   extensible markup language standards and [RFC3470] guidelines it\n   introduces\
    \ the same approach but in a different format and with\n   adapted processing\
    \ rules.\n   The use of Extensible Markup Language (XML) format is already\n \
    \  recognized by a wide range of applications and services and is being\n   selected\
    \ as the de facto standard for many applications based on data\n   exchange. \
    \ The introduction of Evidence Record Syntax in XML format\n   broadens the horizon\
    \ of XML use and presents a harmonized syntax with\n   a growing community of\
    \ XML-based standards including those related to\n   security services such as\
    \ [XMLDSig] or [XAdES].\n   Due to the differences in XML processing rules and\
    \ other\n   characteristics of XML, XMLERS does not present a direct\n   transformation\
    \ of ERS in ASN.1 syntax.  XMLERS is based on different\n   processing rules as\
    \ defined in [RFC4998] and it does not support, for\n   example, the import of\
    \ ASN.1 values in XML tags.  Creating Evidence\n   Records in XML syntax must\
    \ follow the steps as defined in this\n   document.  XMLERS is a standalone document\
    \ and is based on [RFC4998]\n   conceptually only.  The content of this document\
    \ provides enough\n   information for implementation of Evidence Record Syntax\
    \ (represented\n   in XML format).  References to [RFC4998] are for informative\
    \ purposes\n   only.\n   Evidence Record Syntax in XML format is based on long-term\
    \ archive\n   service requirements as defined in [RFC4810].  XMLERS delivers the\n\
    \   same (level of) non-repudiable proof of data existence as ASN.1 ERS\n   [RFC4998].\
    \  The XML syntax supports archive data grouping (and de-\n   grouping) together\
    \ with simple or complex Time-Stamp renewal\n   processes.  Evidence Records can\
    \ be embedded in the data itself or\n   stored separately as a standalone XML\
    \ file.\n"
- title: 1.2.  General Overview and Requirements
  contents:
  - "1.2.  General Overview and Requirements\n   XMLERS specifies the XML syntax and\
    \ processing rules for creating\n   evidence for the long-term non-repudiation\
    \ of existence and integrity\n   of data in a unit called the \"Evidence Record\"\
    .  XMLERS is defined to\n   meet the requirements for data structures as set out\
    \ in [RFC4810].\n   This document also refers to the ASN.1 ERS specification as\
    \ defined\n   in [RFC4998].\n   An Evidence Record may be generated and maintained\
    \ for a single data\n   object or a group of data objects that form an archive\
    \ object.  A\n   data object (binary chunk or a file) may represent any kind of\n\
    \   document or part of it.  Dependencies among data objects, their\n   validation,\
    \ or any other relationship than \"a data object is a part\n   of particular archived\
    \ object\" are outside the scope of this\n   document.\n   Evidence Record is\
    \ closely related to Time-Stamping techniques.\n   However, Time-Stamps as defined\
    \ in [RFC3161] can cover only a single\n   unit of data and do not provide processing\
    \ rules for maintaining a\n   long-term stability of Time-Stamps applied over\
    \ a data object.\n   Evidence for an archive object is created by acquiring a\
    \ Time-Stamp\n   from a trustworthy authority for a specific value that is\n \
    \  unambiguously related to a single or more data objects.  Relationship\n   between\
    \ several data objects and a single Time-Stamped value is\n   addressed using\
    \ a hash tree, a technique first described by Merkle\n   [MER1980] and later in\
    \ [RFC4998], with data structures and procedures\n   as specified in this document.\
    \  The Evidence Record Syntax enables\n   processing of several archive objects\
    \ within a single processing pass\n   using a hash tree technique and acquiring\
    \ only one Time-Stamp to\n   protect all archive objects.  The leaves of the hash\
    \ tree are hash\n   values of the data objects in a group.  A Time-Stamp is requested\n\
    \   only for the root hash of the hash tree.  The deletion of a data\n   object\
    \ in the tree does not influence the provability of others.  For\n   any particular\
    \ data object, the hash tree can be reduced to a few\n   sets of hash values,\
    \ which are sufficient to prove the existence of a\n   single data object.  Similarly,\
    \ the hash tree can be reduced to prove\n   existence of a data group, provided\
    \ all members of the data group\n   have the same parent node in the hash tree.\
    \  Archive Time-Stamps are\n   comprised of an optional reduced hash tree and\
    \ a Time-Stamp.\n   Besides a Time-Stamp other artifacts are also preserved in\
    \ Evidence\n   Record: data necessary to verify the relationship between a time-\n\
    \   stamped value and a specific data object, packed into a structure\n   called\
    \ a \"hash tree\", and long-term proofs for the formal\n   verification of the\
    \ included Time-Stamp(s).\n   Because digest algorithms or cryptographic methods\
    \ used may become\n   weak or certificates used within a Time-Stamp (and signed\
    \ data) may\n   be revoked or expire, the collected evidence data must be monitored\n\
    \   and renewed before such events occur.  This document introduces XML-\n   based\
    \ syntax and processing rules for the creation and continuous\n   renewal of evidence\
    \ data.\n"
- title: 1.3.  Terminology
  contents:
  - "1.3.  Terminology\n   Archive Data Object: An archive data object is a data unit\
    \ that is\n   archived and has to be preserved for a long time by the long-term\n\
    \   archive service.\n   Archive Data Object Group: An archive data object group\
    \ is a set of\n   archive data objects that, for some reason, (logically) belong\n\
    \   together; e.g., a group of document files or a document file and a\n   signature\
    \ file could represent an archive data object group.\n   Archive Object (AO):\
    \ An AO is an archive data object or an archive\n   data object group.\n   Archive\
    \ Time-Stamp (ATS): An ATS contains a Time-Stamp Token, useful\n   data for validation,\
    \ and optionally a set of ordered lists of hash\n   values (a hash tree).  An\
    \ Archive Time-Stamp relates to a data object\n   if the hash value of this data\
    \ object is part of the first hash value\n   list of the Archive Time-Stamp or\
    \ its hash value matches the Time-\n   Stamped value.  An Archive Time-Stamp relates\
    \ to a data object group\n   if it relates to every data object of the group and\
    \ no other data\n   object (i.e., the hash values of all but no other data objects\
    \ of the\n   group are part of the first hash value list of the Archive Time-\n\
    \   Stamp) (see Section 3).\n   Archive Time-Stamp Chain (ATSC): An ATSC holds\
    \ a sequence of Archive\n   Time-Stamps generated during the preservation period.\n\
    \   Archive Time-Stamp Sequence (ATSSeq): AN ATSSeq is a sequence of\n   Archive\
    \ Time-Stamp Chains.\n   Canonicalization: Canonicalization refers to processing\
    \ rules for\n   transforming an XML document into its canonical form.  Two XML\n\
    \   documents may have different physical representations, but they may\n   have\
    \ the same canonical form.  For example, a sort order of\n   attributes does not\
    \ change the meaning of the document as defined in\n   [XMLC14N].\n   Cryptographic\
    \ Information: Cryptographic information is data or part\n   of data related to\
    \ the validation process of signed data, e.g.,\n   digital certificates, digital\
    \ certificate chains, and Certificate\n   Revocation Lists.\n   Digest Method:\
    \ Digest method is a digest algorithm, which is a strong\n   one-way function,\
    \ for which it is computationally infeasible to find\n   an input that corresponds\
    \ to a given output or to find two different\n   input values that correspond\
    \ to the same output.  A digest algorithm\n   transforms input data into a short\
    \ value of fixed length.  The output\n   is called digest value, hash value, or\
    \ data fingerprint.\n   Evidence: Evidence is information that may be used to\
    \ resolve a\n   dispute about various aspects of authenticity, validity, and\n\
    \   existence of archived data objects.\n   Evidence Record: An Evidence Record\
    \ is a collection of evidence\n   compiled for a given archive object over time.\
    \  An Evidence Record\n   includes ordered collection of ATSs, which are grouped\
    \ into ATSCs and\n   ATSSeqs.\n   Long-Term Archive (LTA): An LTA is a service\
    \ responsible for\n   generation, collection, and maintenance (renewal) of evidence\
    \ data.\n   An LTA may also preserve data for long periods of time, e.g.  storage\n\
    \   of archive data and associated evidences.\n   Hash Tree: A hash tree is a\
    \ collection of hash values of protected\n   objects (input data objects and generated\
    \ evidence within archival\n   period) that are unambiguously related to the Time-Stamped\
    \ value\n   within an Archive Time-Stamp.\n   Time-Stamp Token (TS): A TS is a\
    \ cryptographically secure\n   confirmation generated by a Time-Stamping Authority\
    \ (TSA), e.g.,\n   [RFC3161], which specifies a structure for Time-Stamps and\
    \ a protocol\n   for communicating with a Time-Stamp Authority.  Besides this,\
    \ other\n   data structures and protocols may also be appropriate, such as\n \
    \  defined in [ISO-18014-1.2002], [ISO-18014-2.2002],\n   [ISO-18014-3.2004],\
    \ and [ANSI.X9-95.2005].\n"
- title: 1.4.  Conventions Used in This Document
  contents:
  - "1.4.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 2.  Evidence Record
  contents:
  - "2.  Evidence Record\n   An Evidence Record is a unit of data that is to be used\
    \ to prove the\n   existence of an archive object (a single archive data object\
    \ or a\n   archive data object group) at a certain time.  Through the lifetime\n\
    \   of an archive object, an Evidence Record also demonstrates the data\n   objects'\
    \ integrity and non-repudiability.  To achieve this,\n   cryptographic means are\
    \ used, i.e., the LTA obtains Time-Stamp Tokens\n   from the Time-Stamping Authority\
    \ (TSA).  It is possible to store the\n   Evidence Record separately from the\
    \ archive object or to integrate it\n   into the data itself.\n   As cryptographic\
    \ means are used to support Evidence Records, such\n   records may lose their\
    \ value over time.  Time-Stamps obtained from\n   Time-Stamping Authorities may\
    \ become invalid for a number of reasons,\n   usually due to time constraints\
    \ of Time-Stamp validity or when\n   cryptographic algorithms lose their security\
    \ properties.  Before the\n   used Time-Stamp Tokens become unreliable, the Evidence\
    \ Record has to\n   be renewed.  This may result in a series of Time-Stamp Tokens,\
    \ which\n   are linked between themselves according to the cryptographic methods\n\
    \   and algorithms used.\n   Evidence Records can be supported with additional\
    \ information, which\n   can be used to ease the processes of Evidence Record\
    \ validation and\n   renewal.  Information such as digital certificates and Certificate\n\
    \   Revocation Lists as defined in [RFC5280] or other cryptographic\n   material\
    \ can be collected, enclosed, and processed together with\n   archive object data\
    \ (i.e., Time-Stamped).\n"
- title: 2.1.  Structure
  contents:
  - "2.1.  Structure\n   The Evidence Record contains one or several Archive Time-Stamps\n\
    \   (ATSs).  An ATS contains a Time-Stamp Token and optionally other\n   useful\
    \ data for Time-Stamp validation, e.g., certificates, CRLs\n   (Certificate Revocation\
    \ Lists), or OCSP (Online Certificate Status\n   Protocol) responses and also\
    \ specific attributes such as service\n   policies.\n   Initially, an ATS is acquired\
    \ and later, before it expires or becomes\n   invalid, a new ATS is acquired,\
    \ which prolongs the validity of the\n   archived object (its data objects together\
    \ with all previously\n   generated Archive Time-Stamps).  This process MUST continue\
    \ during\n   the desired archiving period of the archive data object(s).  A series\n\
    \   of successive Archive Time-Stamps is collected in Archive Time-Stamp\n   Chains\
    \ and a series of chains in Archive Time-Stamp Sequence.\n   In XML syntax the\
    \ Evidence Record is represented by the\n   <EvidenceRecord> root element, which\
    \ has the following structure\n   described in Pseudo-XML with the full XML schema\
    \ defined in Section 8\n   (where \"?\" denotes zero or one occurrences, \"+\"\
    \ denotes one or more\n   occurrences, and \"*\" denotes zero or more occurrences):\n\
    \   <EvidenceRecord Version>\n      <EncryptionInformation>\n         <EncryptionInformationType>\n\
    \         <EncryptionInformationValue>\n      </EncryptionInformation> ?\n   \
    \   <SupportingInformationList>\n         <SupportingInformation Type /> +\n \
    \     </SupportingInformationList> ?\n      <ArchiveTimeStampSequence>\n     \
    \    <ArchiveTimeStampChain Order>\n            <DigestMethod Algorithm />\n \
    \           <CanonicalizationMethod Algorithm />\n            <ArchiveTimeStamp\
    \ Order>\n               <HashTree /> ?\n               <TimeStamp>\n        \
    \          <TimeStampToken Type />\n                  <CryptographicInformationList>\n\
    \                     <CryptographicInformation Order Type /> +\n            \
    \      </CryptographicInformationList> ?\n               </TimeStamp>\n      \
    \         <Attributes>\n                  <Attribute Order Type /> +\n       \
    \        </Attributes> ?\n            </ArchiveTimeStamp> +\n         </ArchiveTimeStampChain>\
    \ +\n      </ArchiveTimeStampSequence>\n   </EvidenceRecord>\n   The syntax of\
    \ an Evidence Record is defined as an XML schema\n   [XMLSchema], see Section\
    \ 8.  The schema uses the following XML\n   namespace [XMLName] urn:ietf:params:xml:ns:ers\
    \ as default namespace\n   with a detailed xml schema header listed in Section\
    \ 8.\n   The XML elements and attributes have the following meanings:\n      The\
    \ \"Version\" attribute MUST be included and indicates the syntax\n      version,\
    \ for compatibility with future revisions of this\n      specification and to\
    \ distinguish it from earlier non-conformant or\n      proprietary versions of\
    \ XMLERS.  Current version of XMLERS is 1.0.\n      The used versioning scheme\
    \ is described in detail in Section 6.\n      <EncryptionInformation> element\
    \ is OPTIONAL and holds information\n      on cryptographic algorithms and cryptographic\
    \ material used to\n      encrypt archive data (in case archive data is encrypted,\
    \ e.g., for\n      privacy purposes).  This optional information is needed to\n\
    \      unambiguously re-encrypt data objects when processing Evidence\n      Records.\
    \  When omitted, data objects are not encrypted or\n      non-repudiation proof\
    \ is not needed for the unencrypted data.\n      Details on how to process encrypted\
    \ archive data and generate\n      Evidence Record(s) are described in Section\
    \ 5.\n      <SupportingInformationList> element is OPTIONAL and can hold\n   \
    \   information to support processing of Evidence Records.  An example\n     \
    \ of this supporting information may be a processing policy, like a\n      cryptographic\
    \ policy (e.g., [RFC5698]) or archiving policies,\n      which can provide input\
    \ about preservation and evidence\n      validation.  Each data object is put\
    \ into a separate child element\n      <SupportingInformation>, with an OPTIONAL\
    \ Type attribute to\n      indicate its type for processing directions.  As outlined,\
    \ Types\n      to be used must be defined in the specification of the information\n\
    \      structure to be stored or in this standard.  As outlined in\n      Section\
    \ 9.4, cryptographic information may also be stored in the\n      SupportingInformation\
    \ element, in which case its Section 3.1.3\n      defined type MUST be used. \
    \ Or as defined in Section 7\n      cryptographic policies [RFC5698] MAY be stored,\
    \ in which case the\n      used type is defined in the relevant RFC.  Note that\
    \ if supporting\n      information and policies are relevant for and already available\
    \ at\n      or before the time of individual renewal steps (e.g., to indicate\n\
    \      the DSSC crypto policy [RFC5698]) that was used at the time of the\n  \
    \    individual renewal) they SHOULD be stored in the <Attributes>\n      element\
    \ of the individual Archive Time-Stamp (see below) as this\n      is integrity\
    \ protected by the Archive Time-Stamps.  Supporting\n      information that is\
    \ relevant for the whole Evidence Record (like\n      the LTA's current Cryptographic\
    \ Algorithms Security Suitability\n      policy (DSSC, [RFC5698]) or that was\
    \ not available at the time of\n      renewal (and therefore could not later be\
    \ stored in the protected\n      <Attributes> element) can be stored in this\n\
    \      <SupportingInformation> element.\n      <ArchiveTimeStampSequence> is REQUIRED\
    \ and contains a sequence of\n      one or more <ArchiveTimeStampChain>.\n   \
    \   <ArchiveTimeStampChain> is a REQUIRED element that holds a\n      sequence\
    \ of Archive Time-Stamps generated during the preservation\n      period.  Details\
    \ on Archive Time-Stamp Chains and Archive Time-\n      Stamp Sequences are described\
    \ in Section 4.  The sequences of\n      Archive Time-Stamp Chains and Archive\
    \ Time-Stamps MUST be ordered\n      and the order MUST be indicated with \"Order\"\
    \ attribute of the\n      <ArchiveTimeStampChain> and <ArchiveTimeStamp> elements.\n\
    \      <DigestMethod> is a REQUIRED element and contains an attribute\n      \"\
    Algorithm\" that identifies the digest algorithm used within one\n      Archive\
    \ Time-Stamp Chain to calculate digest values from the\n      archive data object(s),\
    \ previous Archive Time-Stamp Sequence,\n      Time-Stamps, and within a Time-Stamp\
    \ Token.\n      <CanonicalizationMethod> is a REQUIRED element that specifies\n\
    \      which canonicalization algorithm is applied to the archive data\n     \
    \ for XML data objects or <ArchiveTimeStampSequence> or <TimeStamp>\n      elements\
    \ prior to performing digest value calculations.\n      <HashTree> is an OPTIONAL\
    \ element that holds a structure as\n      described in Section 3.1.1.\n     \
    \ <TimeStamp> is REQUIRED and holds a <TimeStampToken> element with\n      a Time-Stamp\
    \ Token (as defined in Section 3.1.2) provided by the\n      Time-Stamping Authority\
    \ and an OPTIONAL element\n      <CryptographicInformationList>.\n      <CryptographicInformationList>\
    \ is an OPTIONAL element that allows\n      the storage of data needed in the\
    \ process of Time-Stamp Token\n      validation in case when such data is not\
    \ provided by the Time-\n      Stamp Token itself.  This could include possible\
    \ trust anchors,\n      certificates, revocation information, or the current definition\
    \ of\n      the suitability of cryptographic algorithms, past and present.\n \
    \     Each data object is put into a separate child element\n      <CryptographicInformation>,\
    \ with a REQUIRED Order attribute to\n      indicate the order within its parent\
    \ element.  These items may be\n      added based on the policy used.  This data\
    \ is protected by\n      successive Time-Stamps in the sequence of the Archive\
    \ Time-Stamps.\n      <Attributes> element is OPTIONAL and contains additional\n\
    \      information that may be provided by an LTA used to support\n      processing\
    \ of Evidence Records.  An example of this supporting\n      information may be\
    \ a processing policy, like a renewal, a\n      cryptographic (e.g., [RFC5698]),\
    \ or an archiving policy.  Such\n      policies can provide inputs, which are\
    \ relevant for preservation\n      of the data object(s) and evidence validation\
    \ at a later stage.\n      Each data object is put into a separate child element\
    \ <Attribute>,\n      with a REQUIRED Order attribute to indicate the order within\
    \ the\n      parent element and an OPTIONAL Type attribute to indicate\n     \
    \ processing directions.  The type to be used must be defined in the\n      specification\
    \ of the information structure.  For example, the type\n      to be used when\
    \ storing a cryptographic policy [RFC5698] is\n      defined in Appendix A.2 of\
    \ [RFC5698].\n      The Order attribute is REQUIRED in all cases when one or more\
    \ XML\n      elements with the same name occur on the same level in XMLERS'\n\
    \      <ArchiveTimeStampSequence> structure.  Although most of the XML\n     \
    \ parsers will preserve the order of the sibling elements having the\n      same\
    \ name, within XML structure there is no definition how to\n      unambiguously\
    \ define such order.  Preserving the correct order in\n      such cases is of\
    \ significant importance for digest value\n      calculations over XML structures.\n"
- title: 2.2.  Generation
  contents:
  - "2.2.  Generation\n   The generation of an <EvidenceRecord> element MUST be as\
    \ follows:\n   1. Select an archive object (a data object or a data object group)\
    \ to\n      archive.\n   2. Create the initial <ArchiveTimeStamp>.  This is the\
    \ first ATS\n      within the initial <ArchiveTimeStampChain> element of the\n\
    \      <ArchiveTimeStampSequence> element.\n   3. Refresh the <ArchiveTimeStamp>\
    \ when necessary by Time-Stamp\n      renewal or hash tree renewal (see Section\
    \ 4).\n   The Time-Stamping service may be, for a large number of archived\n \
    \  objects, expensive and time-demanding, so the LTA may benefit from\n   acquiring\
    \ one Time-Stamp Token for many archived objects, which are\n   not otherwise\
    \ related to each other.  It is possible to collect many\n   archive objects,\
    \ build a hash tree to generate a single value to be\n   Time-Stamped, and respectively\
    \ reduce that hash tree to small subsets\n   that for each archive object provide\
    \ necessary binding with the Time-\n   Stamped hash value (see Section 3.2.1).\n\
    \   For performance reasons or in case of local Time-Stamp generation,\n   building\
    \ a hash tree (<HashTree> element) can be omitted.  It is also\n   possible to\
    \ convert existing Time-Stamps into an ATS for renewal.\n   The case when only\
    \ essential parts of documents or objects shall be\n   protected is out of scope\
    \ for this standard, and an application that\n   is not defined in this document\
    \ must ensure that the correct\n   unambiguous extraction of binary data is made\
    \ for the generation of\n   Evidence Record.\n   An application may also provide\
    \ evidence such as certificates,\n   revocation lists, etc. needed to verify and\
    \ validate signed data\n   objects or a data object group.  This evidence may\
    \ be added to the\n   archive data object group and will be protected within the\
    \ initial\n   (and successive) Time-Stamp(s).\n   Note that the <CryptographicInformationList>\
    \ element of Evidence\n   Record is not to be used to store and protect cryptographic\
    \ material\n   related to signed archive data.  The use of this element is limited\n\
    \   to cryptographic material related to the Time-Stamp(s).\n"
- title: 2.3.  Verification
  contents:
  - "2.3.  Verification\n   The overall verification of an Evidence Record MUST be\
    \ as follows:\n   1. Select an archive object (a data object or a data object\
    \ group).\n   2. Re-encrypt data object or data object group, if encryption field\n\
    \      is used (for details, see Section 5).\n   3. Verify Archive Time-Stamp\
    \ Sequence (details in Sections 3.3 and\n      4.3).\n"
- title: 3.  Archive Time-Stamp
  contents:
  - "3.  Archive Time-Stamp\n   An Archive Time-Stamp is a Time-Stamp with additional\
    \ artifacts that\n   allow the verification of the existence of several data objects\
    \ at a\n   certain time.\n   The process of construction of an ATS must support\
    \ evidence on a\n   long-term basis and prove that the archive object existed\
    \ and was\n   identical, at the time of the Time-Stamp, to the currently present\n\
    \   archive object (at the time of verification).  To achieve this, an\n   ATS\
    \ MUST be renewed before it becomes invalid (which may happen for\n   several\
    \ reasons such as, e.g., weakening used cryptographic\n   algorithms, invalidation\
    \ of digital certificate, or a TSA terminating\n   its business or ceasing its\
    \ service).\n"
- title: 3.1.  Structure
  contents:
  - "3.1.  Structure\n   An Archive Time-Stamp contains a Time-Stamp Token, with useful\
    \ data\n   for its validation (cryptographic information), such as the\n   certificate\
    \ chain or Certificate Revocation Lists, an optional\n   ordered set of ordered\
    \ lists of hash values (a hash tree) that were\n   protected with the Time-Stamp\
    \ Token and optional information\n   describing the renewal steps (<Attributes>\
    \ element).  A hash tree may\n   be used to store data needed to bind the Time-Stamped\
    \ value with\n   protected objects by the Archive Time-Stamp.  If a hash tree\
    \ is not\n   present, the ATS simply refers to a single object, either input data\n\
    \   object or a previous TS.\n"
- title: 3.1.1.  Hash Tree
  contents:
  - "3.1.1.  Hash Tree\n   Hash tree structure is an optional container for significant\
    \ values,\n   needed to unambiguously relate a Time-Stamped value to protected\
    \ data\n   objects, and is represented by the <HashTree> element.  The root hash\n\
    \   value that is generated from the values of the hash tree MUST be the\n   same\
    \ as the Time-Stamped value.\n   <HashTree>\n      <Sequence Order>\n        \
    \ <DigestValue>base64 encoded hash value</DigestValue> +\n      </Sequence> +\n\
    \   </HashTree>\n   The algorithm by which a root hash value is generated from\
    \ the\n   <HashTree> element is as follows: the content of each <DigestValue>\n\
    \   element within the first <Sequence> element is base64 ([RFC4648],\n   using\
    \ the base64 alphabet not the base64url alphabet) decoded to\n   obtain a binary\
    \ value (representing the hash value).  All collected\n   hash values from the\
    \ sequence are ordered in binary ascending order,\n   concatenated and a new hash\
    \ value is generated from that string.\n   With one exception to this rule: when\
    \ the first <Sequence> element\n   has only one <DigestValue> element, then its\
    \ binary value is added to\n   the next list obtained from the next <Sequence>\
    \ element.\n   The newly calculated hash value is added to the next list of hashes\n\
    \   obtained from the next <Sequence> element and the previous step is\n   repeated\
    \ until there is only one hash value left, i.e., when there\n   are no <Sequence>\
    \ elements left.  The last calculated hash value is\n   the root hash value. \
    \ When an archive object is a group and composed\n   of more than one data object,\
    \ the first hash list MUST contain the\n   hash values of all its data objects.\n\
    \   When a single Time-Stamp is obtained for a set of archive objects,\n   the\
    \ LTA MUST construct a hash tree to generate a single hash value to\n   bind all\
    \ archive objects from that group and then a reduced hash tree\n   MUST be calculated\
    \ from the hash tree for each archive object\n   respectively (see Section 3.2.1).\n\
    \   For example: A SHA-1 digest value is a 160-bit string.  The text\n   value\
    \ of the <DigestValue> element shall be the base64 encoding of\n   this bit string\
    \ viewed as a 20-octet octet stream.  And to continue\n   the example, using an\
    \ example message digest value of\n   A9993E364706816ABA3E25717850C26C9CD0D89D\
    \ (note this is a HEX encoded\n   value of the 160-bit message digest), its base64\
    \ representation would\n   be <DigestValue>qZk+NkcGgWq6PiVxeFDCbJzQ2J0=</DigestValue>.\n"
- title: 3.1.2.  Time-Stamp
  contents:
  - "3.1.2.  Time-Stamp\n   Time-Stamp Token is an attestation generated by a TSA\
    \ that a data\n   item existed at a certain time.  The Time-Stamp Token is a signed\n\
    \   data object that contains the hash value, the identity of the TSA,\n   and\
    \ the exact time (obtained from trusted time source) of Time-\n   Stamping.  This\
    \ proves that the given data existed before the time of\n   Time-Stamping.  For\
    \ example, [RFC3161] specifies a structure for\n   signed Time-Stamp Tokens in\
    \ ASN.1 format.  Since at the time being\n   there is no standard for an XML Time-Stamp,\
    \ the following structure\n   example is provided [TS-ENTRUST], which is a digital\
    \ signature\n   compliant to [XMLDSig] specification containing Time-Stamp specific\n\
    \   data, such as Time-Stamped value and time within the <Object> element\n  \
    \ of a signature.\n   <element name=\"TimeStampInfo\">\n      <complexType>\n\
    \         <sequence>\n            <element ref=\"Policy\" />\n            <element\
    \ ref=\"Digest\" />\n            <element ref=\"SerialNumber\" minOccurs=\"0\"\
    \ />\n            <element ref=\"CreationTime\" />\n            <element ref=\"\
    Accuracy\" minOccurs=\"0\" />\n            <element ref=\"Ordering\" minOccurs=\"\
    0\" />\n            <element ref=\"Nonce\" minOccurs=\"0\" />\n            <element\
    \ ref=\"Extensions\" minOccurs=\"0\" />\n         </sequence>\n      </complexType>\n\
    \   </element>\n   A <TimeStamp> element of ATS holds a complete structure of\
    \ Time-Stamp\n   Token as provided by a TSA.  Time-Stamp Token may be in XML or\
    \ ASN.1\n   format.  The Attribute type MUST be used to indicate the format for\n\
    \   processing purposes, with values \"XMLENTRUST\" or \"RFC3161\"\n   respectively.\
    \  For an RFC3161 type Time-Stamp Token, the <TimeStamp>\n   element MUST contain\
    \ base64 encoding of a DER-encoded ASN1 data.\n   These type values are registered\
    \ by IANA (see Section 10).  For\n   support of future types of Time-Stamps (in\
    \ particular for future XML\n   Time-Stamp standards), these need to be registered\
    \ there as well.\n   For example:\n   <TimeStamp Type=\"RFC3161\">MIAGCSqGSIb3DQEH...</TimeStamp>\n\
    \   or\n   <TimeStamp Type=\"XMLENTRUST\"><dsig:Signature>...</dsig:Signature>\n\
    \   </TimeStamp>\n"
- title: 3.1.3.  Cryptographic Information List
  contents:
  - "3.1.3.  Cryptographic Information List\n   Digital certificates, CRLs (Certificate\
    \ Revocation Lists), SCVP\n   (Server-Based Certificate Validation Protocol),\
    \ or OCSP-Responses\n   (Online Certificate Status Protocol) needed to verify\
    \ the Time-Stamp\n   Token SHOULD be stored in the Time-Stamp Token itself.  When\
    \ this is\n   not possible, such data MAY be stored in the\n   <CryptographicInformationList>\
    \ element; each data object is stored\n   into a separate <CryptographicInformation>\
    \ element, with a REQUIRED\n   Order attribute.\n   The attribute Type is REQUIRED\
    \ and is used to store processing\n   information about the type of stored cryptographic\
    \ information.  The\n   Type attribute MUST use a value registered with IANA,\
    \ as identifiers:\n   CRL, OCSP, SCVP, or CERT, and for each type the content\
    \ MUST be\n   encoded respectively:\n   o  for type CRL, a base64 encoding of\
    \ a DER-encoded X.509 CRL\n      [RFC5280]\n   o  for type OCSP, a base64 encoding\
    \ of a DER-encoded OCSPResponse\n      [RFC2560]\n   o  for type SCVP, a base64\
    \ encoding of a DER-encoded CVResponse;\n      [RFC5055]\n   o  for type CERT,\
    \ a base64 encoding of a DER-encoded X.509\n      certificate [RFC5280]\n   The\
    \ supported type identifiers are registered by IANA (see Section\n   10).  Future\
    \ supported types can be registered there (for example, to\n   support future\
    \ validation standards).\n"
- title: 3.2.  Generation
  contents:
  - "3.2.  Generation\n   An initial ATS relates to a data object or a data object\
    \ group that\n   represents an archive object.  The generation of the initial\
    \ ATS\n   element can be done in a single process pass for one or for many\n \
    \  archived objects.  It MUST be done as described in the following\n   steps:\n\
    \   1. Collect one or more archive objects to be Time-Stamped.\n   2. Select a\
    \ canonicalization method C to be used for obtaining binary\n      representation\
    \ of archive data and for Archive Time-Stamp at a\n      later stage in the renewing\
    \ process (see Section 4).  Note that\n      the selected canonicalization method\
    \ MUST be used also for archive\n      data when data is represented in XML format.\n\
    \   3. Select a valid digest algorithm H.  The selected secure hash\n      algorithm\
    \ MUST be the same as the hash algorithm used in the Time-\n      Stamp Token\
    \ and for the hash tree computations.\n   4. Generate a hash tree for selected\
    \ archive object (see Section\n      3.2.1).\n      The hash tree may be omitted\
    \ in the initial ATS, when an archive\n      object has a single data object;\
    \ then the Time-Stamped value MUST\n      match the digest value of that single\
    \ data object.\n   5. Acquire Time-Stamp token from TSA for root hash value of\
    \ a hash\n      tree (see Section 3.1.1).  If the Time-Stamp token is valid, the\n\
    \      initial Archive Time-Stamp may be generated.\n"
- title: 3.2.1.  Generation of Hash Tree
  contents:
  - "3.2.1.  Generation of Hash Tree\n   The <DigestValue> elements within the <Sequence>\
    \ element MUST be\n   ordered in binary ascending order to ensure the correct\
    \ calculation\n   of digest values at the time of renewal and later for verification\n\
    \   purposes.  Note that the text value of the <DigestValue> element is\n   base64\
    \ encoded, so it MUST be base64 decoded in order to obtain a\n   binary representation\
    \ of the hash value.\n   A hash tree MUST be generated when the Time-Stamped value\
    \ is not\n   equal to the hash value of the input data object.  This is the case\n\
    \   when either of the following is true:\n   1. When an archive object has more\
    \ than one data object (i.e., is an\n      archive data object group), its digest\
    \ value is the digest value\n      of binary ascending ordered and concatenated\
    \ digest values of all\n      its containing data objects.  Note that in this\
    \ case the first\n      list of the hash tree MUST contain hash values of all\
    \ data objects\n      and only those values.\n   2. When for more than one archive\
    \ object a single Time-Stamp Token is\n      generated, then the hash tree is\
    \ a reduced hash tree extracted\n      from the hash tree for that archive object\
    \ (see Section 3.2.2).\n   The hash tree for a set of archive objects is built\
    \ from the leaves\n   to the root.  First the leaves of the tree are collected,\
    \ each leaf\n   representing the digest value of an archive object.  You MUST\
    \ use the\n   following procedure to calculate the hash tree:\n   1. Collect archive\
    \ objects and for each archive object its\n      corresponding data objects.\n\
    \   2. Choose a secure hash algorithm H and calculate the digest values\n    \
    \  for the data objects and put them into the input list for the hash\n      tree\
    \ as follows: a digest value of an archive object is the digest\n      value of\
    \ its data object, if there is only one data object in the\n      archive object;\
    \ if there is more than one data object in the\n      archive object (i.e., it\
    \ is an archive data object group) the\n      digest value is the digest value\
    \ of binary sorted, concatenated\n      digest values of all its containing data\
    \ objects.\n      Note that for an archive object group (having more than one\
    \ data\n      object), lists of their sub-digest values are stored and later,\n\
    \      when creating a reduced hash tree for that archive object, they\n     \
    \ will become members of the first hash list.\n   3. Group together items in the\
    \ input list by the order of N (e.g.,\n      for a binary tree group in pairs,\
    \ for a tertiary tree group in\n      triplets, and so forth) and for each group:\
    \ binary ascending sort,\n      concatenate, and calculate the hash value.  The\
    \ result is a new\n      input for the next list.  For improved processing it\
    \ is\n      RECOMMENDED to have the same number of children for each node.\n \
    \     For this purpose you MAY extend the tree with arbitrary values to\n    \
    \  make every node have the same number of children.\n   4. Repeat step 3, until\
    \ only one digest value is left; this is the\n      root value of the hash tree,\
    \ which is Time-Stamped.\n   Note that the selected secure hash algorithm MUST\
    \ be the same as the\n   one defined in the <DigestMethod> element of the ATSChain.\n\
    \   Example: An input list with 18 hash values, where the h'1 is\n   generated\
    \ for a group of data objects (d4, d5, d6, and d7) and has\n   been grouped by\
    \ 3.  The group could be of any size (2, 3...).  Note\n   that the addition of\
    \ the arbitrary values h''6 and h'''3 are OPTIONAL\n   and can be used for improved\
    \ processing as outlined in step 3 above.\n                    ----------\n  \
    \                  d1  -> h1 \\\n                               \\\n       G1\
    \           d2  -> h2  |-> h''1\n   +--------+                  /       \\\n \
    \  |d4 -> h4|\\      d3  -> h3 /         \\\n   |d5 -> h5| \\     ---------- \
    \         |\n   |        | |  ->        h'1\\         |\n   |d6 -> h6| /     \
    \           \\        |\n   |d7 -> h7|/      d8  -> h8  |-> h''2 |->  h'''1\n\
    \   +--------+                  /        |         \\\n                    d9\
    \  -> h9 /         |          \\\n                    ----------          |  \
    \        |\n                    d10 -> h10\\         /          |\n          \
    \                     \\       /           |\n                    d11 -> h11 |->\
    \ h''3            |\n                               /                   |\n  \
    \                  d12 -> h12/                    |-> root hash value\n      \
    \              ----------                     |\n                    d13 -> h13\\\
    \                    |\n                               \\                   |\n\
    \                    d14 -> h14 |-> h''4            |\n                      \
    \         /       \\           |\n                    d15 -> h15/         \\ \
    \         |\n                    ----------          |->  h'''2 |\n          \
    \          d16 -> h16\\         |          |\n                               \\\
    \        |          |\n                    d17 -> h17 |-> h''5 |          |\n\
    \                               /        |          |\n                    d18\
    \ -> h18/         |          |\n                    ----------          /    \
    \      |\n                                       /           /\n             \
    \     (any arbitrary)  h''6           /\n                           (any arbitrary)\
    \   h'''3\n           Figure 1. Generation of the Merkle Hash Tree\n   Note that\
    \ there are no restrictions on the quantity of hash value\n   lists and of their\
    \ length.  Also note that it is beneficial but not\n   required to build hash\
    \ trees and reduce hash trees.  An Archive Time-\n   Stamp may consist only of\
    \ one list of hash values and a Time-Stamp or\n   in an extreme case only a Time-Stamp\
    \ with no hash value lists.\n"
- title: 3.2.2.  Reduction of Hash Tree
  contents:
  - "3.2.2.  Reduction of Hash Tree\n   The generated Merkle hash tree can be reduced\
    \ to lists of hash\n   values, necessary as a proof of existence for a single\
    \ archive object\n   as follows:\n   1. For a selected archive object (AO) select\
    \ its hash value h within\n      the leaves of the hash tree.\n   2. Put h as\
    \ base64 encoded text value of a new <DigestValue> element\n      within a first\
    \ <Sequence> element.  If the selected AO is a data\n      object group (i.e.,\
    \ has more than one data object), the first\n      <Sequence> element MUST in\
    \ this case be formed from the hash\n      values of all AOs data objects, each\
    \ within a separate\n      <DigestValue> element.\n   3. Select all hash values\
    \ that have the same father node as hash\n      value h.  Place these hash values\
    \ each as a base64 encoded text\n      value of a new <DigestValue> element within\
    \ a new <Sequence>\n      element, increasing its Order attribute value by 1.\n\
    \   4. Repeat step 3 for the parent node until the root hash value is\n      reached,\
    \ with each step create a new <Sequence> element and\n      increase its Order\
    \ attribute by one.  Note that node values are\n      not saved as they are computable.\n\
    \   The order of <DigestValue> elements within each <Sequence> element\n   MUST\
    \ be binary ascending (by base64 decoded values).\n   Reduced hash tree for data\
    \ object d4 (from the previous example,\n   presented in Figure 1):\n   <HashTree>\n\
    \     <Sequence Order='1'>\n         <DigestValue>base64 encoded h4</DigestValue>\n\
    \         <DigestValue>base64 encoded h5</DigestValue>\n         <DigestValue>base64\
    \ encoded h6</DigestValue>\n         <DigestValue>base64 encoded h7</DigestValue>\n\
    \     </Sequence>\n     <Sequence Order='2'>\n         <DigestValue>base64 encoded\
    \ h8</DigestValue>\n         <DigestValue>base64 encoded h9</DigestValue>\n  \
    \   </Sequence>\n     <Sequence Order='3'>\n         <DigestValue>base64 encoded\
    \ h''1</DigestValue>\n         <DigestValue>base64 encoded h''3</DigestValue>\n\
    \     </Sequence>\n     <Sequence Order='4'>\n         <DigestValue>base64 encoded\
    \ h'''2</DigestValue>\n     </Sequence>\n   </HashTree>\n   Reduced hash tree\
    \ for data object d2 (from the previous example,\n   presented in Figure 1):\n\
    \   <HashTree>\n     <Sequence Order='1'>\n         <DigestValue>base64 encoded\
    \ h2</DigestValue>\n     </Sequence>\n     <Sequence Order='2'>\n         <DigestValue>base64\
    \ encoded h1</DigestValue>\n         <DigestValue>base64 encoded h3</DigestValue>\n\
    \     </Sequence>\n     <Sequence Order='3'>\n         <DigestValue>base64 encoded\
    \ h''2</DigestValue>\n         <DigestValue>base64 encoded h''3</DigestValue>\n\
    \     </Sequence>\n     <Sequence Order='4'>\n         <DigestValue>base64 encoded\
    \ h'''2</DigestValue>\n     </Sequence>\n   </HashTree>\n"
- title: 3.3.  Verification
  contents:
  - "3.3.  Verification\n   The initial Archive Time-Stamp shall prove that an archive\
    \ object\n   existed at a certain time, indicated by its Time-Stamp Token.  The\n\
    \   verification procedure MUST be as follows:\n   1. Identify hash algorithm\
    \ H (from <DigestMethod> element) and\n      calculate the hash value for each\
    \ data object of the archive\n      object.\n   2. If the hash tree is present,\
    \ search for hash values in the first\n      <Sequence> element.  If hash values\
    \ are not present, terminate\n      verification process with negative result.\
    \  If the verifying party\n      also seeks additional proof that the Archive\
    \ Time-Stamp relates to\n      a data object group (e.g., a document and all its\
    \ digital\n      signatures), it SHOULD also be verified that only the hash values\n\
    \      of the data objects that are members of the given data object\n      group\
    \ are in the first hash value list.\n   3. If the hash tree is present, calculate\
    \ its root hash value.\n      Compare the root hash value with the Time-Stamped\
    \ value.  If they\n      are not equal, terminate the verification process with\
    \ negative\n      result.\n   4. If the hash tree is omitted, compare the hash\
    \ value of the single\n      data object with the Time-Stamped value.  If they\
    \ are not equal,\n      terminate the verification process with negative result.\
    \  If an\n      archive object is having more data objects and the hash tree is\n\
    \      omitted, also exit with negative result.\n   5. Check the validity of the\
    \ Time-Stamp Token.  If the needed\n      information to verify formal validity\
    \ of the Time-Stamp Token is\n      not available or found within the <TimeStampToken>\
    \ element or\n      within the <CryptographicInformationList> element or in\n\
    \      <SupportingInformationList> (see Section 9.4), exit with a\n      negative\
    \ result.\n   Information for formal verification of the Time-Stamp Token includes\n\
    \   digital certificates, Certificate Revocation Lists, Online\n   Certificate\
    \ Status Protocol responses, etc.  This information needs\n   to be collected\
    \ prior to the Time-Stamp renewal process and protected\n   with the succeeding\
    \ Time-Stamp, i.e., included in the\n   <TimeStampToken> or <CryptographicInformation>\
    \ element (see Section\n   9.4 for additional information and Section 4.2.1 for\
    \ details on the\n   Time-Stamp renewal process).  For the current (latest) Time-Stamp),\n\
    \   information for formal verification of the (latest) Time-Stamp should\n  \
    \ be provided by the Time-Stamping Authority.  This information can\n   also be\
    \ provided with the Evidence Record within the\n   <SupportingInformation> element,\
    \ which is not protected by any Time-\n   Stamp.\n"
- title: 4.  Archive Time-Stamp Sequence and Archive Time-Stamp Chain
  contents:
  - "4.  Archive Time-Stamp Sequence and Archive Time-Stamp Chain\n   An Archive Time-Stamp\
    \ proves the existence of single data objects or\n   a data object group at a\
    \ certain time.  However, the initial Evidence\n   Record created can become invalid\
    \ due to losing the validity of the\n   Time-Stamp Token for a number of reasons:\
    \ hash algorithms or public\n   key algorithms used in its hash tree or the Time-Stamp\
    \ may become\n   weak or the validity period of the Time-Stamp authority certificate\n\
    \   expires or is revoked.\n   To preserve the validity of an Evidence Record\
    \ before such events\n   occur, the Evidence Record has to be renewed.  This can\
    \ be done by\n   creating a new ATS.  Depending on the reason for renewing the\n\
    \   Evidence Record (the Time-Stamp becomes invalid or the hash algorithm\n  \
    \ of the hash tree becomes weak) two types of renewal processes are\n   possible:\n\
    \   o  Time-Stamp renewal: For this process a new Archive Time-Stamp is\n    \
    \  generated, which is applied over the last Time-Stamp created.  The\n      process\
    \ results in a series of Archive Time-Stamps, which are\n      contained within\
    \ a single Archive Time-Stamp Chain (ATSC).\n   o  Hash tree renewal: For this\
    \ process a new Archive Time-Stamp is\n      generated, which is applied to all\
    \ existing Time-Stamps and data\n      objects.  The newly generated Archive Time-Stamp\
    \ is placed in a\n      new Archive Time-Stamp Chain.  The process results in\
    \ a series of\n      Archive Time-Stamp Chains, which are contained within a single\n\
    \      Archive Time-Stamp Sequence (ATSSeq).\n   After the renewal process, only\
    \ the most recent (i.e., the last\n   generated) Archive Time-Stamp has to be\
    \ monitored for expiration or\n   validity loss.\n"
- title: 4.1.  Structure
  contents:
  - "4.1.  Structure\n   Archive Time-Stamp Chain and Archive Time-Stamp Sequence\
    \ are\n   containers for sequences of Archive Time-Stamp(s) that are generated\n\
    \   through renewal processes.  The renewal process results in a series\n   of\
    \ Evidence Record elements: the <ArchiveTimeStampSequence> element\n   contains\
    \ an ordered sequence of <ArchiveTimeStampChain> elements, and\n   the <ArchiveTimeStampChain>\
    \ element contains an ordered sequence of\n   <ArchiveTimeStamp> elements.  Both\
    \ elements MUST be sorted by time of\n   the Time-Stamp in ascending order.  Order\
    \ is indicated by the Order\n   attribute.\n   When an Archive Time-Stamp must\
    \ be renewed, a new <ArchiveTimeStamp>\n   element is generated and depending\
    \ on the generation process, it is\n   either placed:\n   o  as the last <ArchiveTimeStamp>\
    \ child element in a sequence of the\n      last <ArchiveTimeStampChain> element\
    \ in case of Time-Stamp renewal\n      or\n   o  as the first <ArchiveTimeStamp>\
    \ child element in a sequence of the\n      newly created <ArchiveTimeStampChain>\
    \ element in case of hash tree\n      renewal.\n   The ATS with the largest Order\
    \ attribute value within the ATSC with\n   the largest Order attribute value is\
    \ the latest ATS and MUST be valid\n   at the present time.\n"
- title: 4.1.1.  Digest Method
  contents:
  - "4.1.1.  Digest Method\n   Digest method is a required element that identifies\
    \ the digest\n   algorithm used to calculate hash values of archive data (and\
    \ node\n   values of hash tree).  The digest method is specified in the\n   <ArchiveTimeStampChain>\
    \ element by the required <DigestMethod>\n   element and indicates the digest\
    \ algorithm that MUST be used for all\n   hash value calculations related to the\
    \ Archive Time-Stamps within the\n   Archive Time-Stamp Chain.\n   The Algorithm\
    \ attribute contains URIs [RFC3986] for identifiers that\n   MUST be used as defined\
    \ in [RFC3275] and [RFC4051].  For example,\n   when the SHA-1 algorithm is used,\
    \ the algorithm identifier is:\n   <DigestMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#sha1\"\
    />\n   Within a single ATSC, the digest algorithms used for the hash trees\n \
    \  of its Archive Time-Stamps and the Time-Stamp Tokens MUST be the\n   same.\
    \  When algorithms used by a TSA are changed (e.g., upgraded) a\n   new ATSC MUST\
    \ be started using an equal or stronger digest algorithm.\n"
- title: 4.1.2.  Canonicalization Method
  contents:
  - "4.1.2.  Canonicalization Method\n   Prior to hash value calculations of an XML\
    \ element, a proper binary\n   representation must be extracted from its (abstract)\
    \ XML data\n   presentation.  The binary representation is determined by UTF-8\n\
    \   [RFC3629] encoding and canonicalization of the XML element.  The XML\n   element\
    \ includes the entire text of the start and end tags as well as\n   all descendant\
    \ markup and character data (i.e., the text and sub-\n   elements) between those\
    \ tags.\n   <CanonicalizationMethod> is a required element that identifies the\n\
    \   canonicalization algorithm used to obtain binary representation of an\n  \
    \ XML element or elements.  Algorithm identifiers (URIs) MUST be used\n   as defined\
    \ in [RFC3275] and [RFC4051].  For example, when Canonical\n   XML 1.0 (omits\
    \ comments) is used, algorithm identifier is\n   <CanonicalizationMethod Algorithm=\"\
    http://www.w3.org/TR/2001/REC-\n   xml-c14n-20010315\"/>\n   Canonicalization\
    \ MUST be applied over XML structured archive data and\n   MUST be applied over\
    \ elements of Evidence Record (namely, ATS and\n   ATSC in the renewing process).\n\
    \   The canonicalization method is specified in the <Algorithm> attribute\n  \
    \ of the <CanonicalizationMethod> element within the\n   <ArchiveTimeStampChain>\
    \ element and indicates the canonicalization\n   method that MUST be used for\
    \ all binary representations of the\n   Archive Time-Stamps within that Archive\
    \ Time-Stamp Chain.  In case of\n   succeeding ATSC the canonicalization method\
    \ indicated within the ATSC\n   must also be used for the calculation of the digest\
    \ value of the\n   preceding ATSC.  Note that the canonicalization method is unlikely\
    \ to\n   change over time as it does not impose the same constraints as the\n\
    \   digest method.  In theory, the same canonicalization method can be\n   used\
    \ for a whole Archive Time-Stamp Sequence.  Although alternative\n   canonicalization\
    \ methods may be used, it is recommended to use c14n-\n   20010315 [XMLC14N].\n"
- title: 4.2.  Generation
  contents:
  - "4.2.  Generation\n   Before the cryptographic algorithms used within the most\
    \ recent\n   Archive Time-Stamp become weak or the Time-Stamp certificates are\n\
    \   invalidated, the LTA has to renew the Archive Time-Stamps by\n   generating\
    \ a new Archive Time-Stamp using one of two procedures:\n   Time-Stamp renewal\
    \ or hash tree renewal.\n"
- title: 4.2.1.  Time-Stamp Renewal
  contents:
  - "4.2.1.  Time-Stamp Renewal\n   In case of Time-Stamp renewal, i.e., if the digest\
    \ algorithm (H) to\n   be used in the renewal process is the same as digest algorithm\
    \ (H')\n   used in the last Archive Time-Stamp, the complete content of the last\n\
    \   <TimeStamp> element MUST be Time-Stamped and a new <ArchiveTimeStamp>\n  \
    \ element created as follows:\n   1. If the current <ArchiveTimeStamp> element\
    \ does not contain needed\n      proof for long-term formal validation of its\
    \ Time-Stamp Token\n      within the <TimeStamp> element, collect needed data\
    \ such as root\n      certificates, Certificate Revocation Lists, etc., and include\
    \ them\n      in the <CryptographicInformationList> element of the last Archive\n\
    \      Time-Stamp (each data object into a separate\n      <CryptographicInformation>\
    \ element).\n   2. Select the canonicalization method from the\n      <CanonicalizationMethod>\
    \ element and select the digest algorithm\n      from the <DigestMethod> element.\
    \  Calculate hash value from binary\n      representation of the <TimeStamp> element\
    \ of the last\n      <ArchiveTimeStamp> element including added cryptographic\n\
    \      information.  Acquire the Time-Stamp for the calculated hash\n      value.\
    \  If the Time-Stamp is valid, the new Archive Time-Stamp may\n      be generated.\n\
    \   3. Increase the value order of the new ATS by one and place the new\n    \
    \  ATS into the last <ArchiveTimeStampChain> element.\n   The new ATS and its\
    \ hash tree MUST use the same digest algorithm as\n   the preceding one, which\
    \ is specified in the <DigestMethod> element\n   within the <ArchiveTimeStampChain>\
    \ element.  Note that the new ATS\n   MAY not contain a hash tree.  However, the\
    \ Time-Stamp renewal process\n   may be optimized to acquire one Time-Stamp for\
    \ many Archive Time-\n   Stamps using a hash tree.  Note that each hash of the\
    \ <TimeStamp>\n   element is treated as the document hash in Section 3.2.1.\n"
- title: 4.2.2.  Hash Tree Renewal
  contents:
  - "4.2.2.  Hash Tree Renewal\n   The process of hash tree renewal occurs when the\
    \ new digest algorithm\n   is different from the one used in the last Archive\
    \ Time-Stamp (H <>\n   H').  In this case the complete Archive Time-Stamp Sequence\
    \ and the\n   archive data objects covered by existing Archive Time-Stamp must\
    \ be\n   Time-Stamped as follows:\n   1. Select one or more archive objects to\
    \ be renewed and their current\n      <ArchiveTimeStamp> elements.\n   2. For\
    \ each archive object check the current <ArchiveTimeStamp>\n      element.  If\
    \ it does not contain the proof needed for long-term\n      formal validation\
    \ of its Time-Stamp Token within the Time-Stamp\n      Token, collect the needed\
    \ data such as root certificates,\n      Certificate Revocation Lists, etc., and\
    \ include them in the\n      <CryptographicInformationList> element of the last\
    \ Archive Time-\n      Stamp (each data object into a separate <CryptographicInformation>\n\
    \      element).\n   3. Select a canonicalization method C and select a new secure\
    \ hash\n      algorithm H.\n   4. For each archive object select its data objects\
    \ d(i).  Generate\n      hash values h(i) = H(d(i)), for example: h(1), h(2)..,\
    \ h(n).\n   5. For each archive object calculate a hash hseq=H(ATSSeq) from\n\
    \      binary representation of the <ArchiveTimeStampSequence> element,\n    \
    \  corresponding to that archive object.  Note that Archive Time-\n      Stamp\
    \ Chains and Archive Time-Stamps MUST be chronologically\n      ordered, each\
    \ respectively to its Order attribute, and that the\n      canonicalization method\
    \ C MUST be applied.\n   6. For each archive object sort in binary ascending order\
    \ and\n      concatenate all h(i) and the hseq.  Generate a new digest value\n\
    \      h(j)=H(h(1)..h(n),hseq).\n   7. Build a new Archive Time-Stamp for each\
    \ h(j) (hash tree generation\n      and reduction is defined in Sections 3.2.1\
    \ and 3.2.2).  Note that\n      each h(j) is treated as the document hash in Section\
    \ 3.2.1.  The\n      first hash value list in the reduced hash tree should only\
    \ contain\n      h(i) and hseq.\n   8. Create the new <ArchiveTimeStampChain>\
    \ containing the new\n      <ArchiveTimeStamp> element (with order number 1),\
    \ and place it\n      into the existing <ArchiveTimeStampSequence> as a last child\
    \ with\n      the order number increased by one.\n   Example for an archive object\
    \ with 3 data objects: Select a new hash\n   algorithm and canonicalization method.\
    \  Collect all 3 data objects\n   and currently generated Archive Time-Stamp Sequence.\n\
    \               AO\n            /  |   \\\n         d1    d2    d3\n   ATSSeq\n\
    \         ATSChain1: ATS0, ATS1\n         ATSChain2: ATS0, ATS1, ATS2\n   The\
    \ hash values MUST be calculated with the new hash algorithm H for\n   all data\
    \ objects and for the whole ATSSeq.  Note that ATSSeq MUST be\n   chronologically\
    \ ordered and canonicalized before retrieving its\n   binary representation.\n\
    \   When generating the hash tree for the new ATS, the first sequence\n   become\
    \ values: H(d1), H(d2),..., H(dn), H(ATSSeq).  Note: hash values\n   MUST be sorted\
    \ in binary ascending order.\n   <HashTree>\n      <Sequence Order='1'>\n    \
    \        <DigestValue>H(d1)</DigestValue>\n            <DigestValue>H(d2)</DigestValue>\n\
    \            <DigestValue>H(d3)</DigestValue>\n            <DigestValue>H(ATSSeq)</DigestValue>\n\
    \      </Sequence>\n   </HashTree>\n   Note that if the group processing is being\
    \ performed, the hash value\n   of the concatenation of the first sequence is\
    \ an input hash value\n   into the hash tree.\n"
- title: 4.3.  Verification
  contents:
  - "4.3.  Verification\n   An Evidence Record shall prove that an archive object\
    \ existed and has\n   not been changed from the time of the initial Time-Stamp\
    \ Token within\n   the first ATS.  In order to complete the non-repudiation proof\
    \ for an\n   archive object, the last ATS has to be valid and ATSCs and their\n\
    \   relations to each other have to be proved:\n   1. Select archive object and\
    \ re-encrypt its data object or data\n      object group, if <EncryptionInformation>\
    \ field is used.  Select\n      the initial digest algorithm specified within\
    \ the first Archive\n      Time-Stamp Chain and calculate the hash value of the\
    \ archive\n      object.  Verify that the initial Archive Time-Stamp contains\n\
    \      (identical) hash value of the AO's data object (or hash values of\n   \
    \   AO's data object group).  Note that when the hash tree is omitted,\n     \
    \ calculated AO's value MUST match the Time-Stamped value.\n   2. Verify each\
    \ Archive Time-Stamp Chain and each Archive Time-Stamp\n      within.  If the\
    \ hash tree is present within the second and the\n      next Archive Time-Stamps\
    \ of an Archive Time-Stamp Chain, the first\n      <Sequence> MUST contain the\
    \ hash value of the <TimeStamp> element\n      before.  Each Archive Time-Stamp\
    \ MUST be valid relative to the\n      time of the succeeding Archive Time-Stamp.\
    \  All Archive Time-\n      Stamps with the Archive Time-Stamp Chain MUST use\
    \ the same hash\n      algorithm, which was secure at the time of the first Archive\
    \ Time-\n      Stamp of the succeeding Archive Time-Stamp Chain.\n   3. Verify\
    \ that the first hash value list of the first Archive Time-\n      Stamp of all\
    \ succeeding Archive Time-Stamp Chains contains hash\n      values of data object\
    \ and the hash value of Archive Time-Stamp\n      Sequence of the preceding Archive\
    \ Time-Stamp Chains.  Verify that\n      Archive Time-Stamp was created when the\
    \ last Archive Time-Stamp of\n      the preceding Archive Time-Stamp Chain was\
    \ valid.\n   4. To prove the Archive Time-Stamp Sequence relates to a data object\n\
    \      group, verify that the first Archive Time-Stamp of the first\n      Archive\
    \ Time-Stamp Chain does not contain other hash values in its\n      first hash\
    \ value list than the hash values of those data objects.\n   For non-repudiation\
    \ proof for the data object, the last Archive Time-\n   Stamp MUST be valid at\
    \ the time of verification process.\n"
- title: 5.  Encryption
  contents:
  - "5.  Encryption\n   In some archive services scenarios it may be required that\
    \ clients\n   send encrypted data only, preventing information disclosure to third\n\
    \   parties, such as archive service providers.  In such scenarios it\n   must\
    \ be clear that Evidence Records generated refer to encrypted data\n   objects.\
    \  Evidence Records in general protect the bit-stream (or\n   binary representation\
    \ of XML data), which freezes the bit structure\n   at the time of archiving.\
    \  Encryption schemes in such scenarios\n   cannot be changed afterwards without\
    \ losing the integrity proof.\n   Therefore, an ERS record must hold and preserve\
    \ encryption\n   information in a consistent manner.  To avoid problems when using\n\
    \   Evidence Records in the future, additional special precautions have\n   to\
    \ be taken.\n   Encryption is a two-way process, whose result depends on the\n\
    \   cryptographic material used, e.g., encryption keys and encryption\n   algorithms.\
    \  Encryption and decryption keys as well as algorithms\n   must match in order\
    \ to reconstruct the original message or data that\n   was encrypted.  Evidence\
    \ generated to prove the existence of\n   encrypted data cannot always be relied\
    \ upon to prove the existence of\n   unencrypted data.  It may be possible to\
    \ choose different\n   cryptographic material, i.e., an algorithm or a key for\
    \ decryption\n   that is not the algorithm or key used for encryption.  In this\
    \ case,\n   the evidence record would not be a non-repudiation proof for the\n\
    \   unencrypted data.  Therefore, only encryption methods should be used\n   that\
    \ make it possible to prove that archive Time-Stamped encrypted\n   data objects\
    \ unambiguously represent unencrypted data objects.  In\n   cases when evidence\
    \ was generated to prove the existence of encrypted\n   data the corresponding\
    \ algorithm and decryption keys used for\n   encryption must become a part of\
    \ the Evidence Record and is used to\n   unambiguously represent original (unencrypted)\
    \ data that was\n   encrypted.  (Note: In addition, the long-term security of\
    \ the\n   encryption schemes should be analyzed to determine if it could be\n\
    \   used to create collision attacks.)  Cryptographic material may also\n   be\
    \ used in scenarios when a client submits encrypted data to the\n   archive service\
    \ provider for preservation but stores himself the data\n   only in an unencrypted\
    \ form.  In such scenarios cryptographic\n   material is used to re-encrypt the\
    \ unencrypted data kept by a client\n   for the purpose of performing validation\
    \ of the Evidence Record,\n   which is related to the encrypted form of client's\
    \ data.  An OPTIONAL\n   extensible structure <EncryptionInformation> is defined\
    \ to store the\n   necessary parameters of the encryption methods.  Its\n   <EncryptionInformationType>\
    \ element is used to store the type of\n   stored encryption information, e.g.,\
    \ whether it is an encryption\n   algorithm or encryption key.  The <EncryptionInformationValue>\n\
    \   element then contains the relevant encryption information itself.\n   The\
    \ use of encryption elements heavily depends on the cryptographic\n   mechanism\
    \ and has to be defined by other specifications.\n"
- title: 6.  Version
  contents:
  - "6.  Version\n   The numbering scheme for XMLERS versions is \"<major>.<minor>\"\
    .  The\n   major and minor numbers MUST be treated as separate integers and each\n\
    \   number MAY be incremented higher than a single digit.  Thus, \"2.4\"\n   would\
    \ be a lower version than \"2.13\", which in turn would be lower\n   than \"12.3\"\
    .  Leading zeros (e.g., \"6.01\") MUST be ignored by\n   recipients and MUST NOT\
    \ be sent.\n   The major version number will be incremented only if the data format\n\
    \   has changed so dramatically that an older version entity would not be\n  \
    \ able to interoperate with a newer version entity if it simply ignored\n   the\
    \ elements and attributes it did not understand and took the\n   actions defined\
    \ in the older specification.\n   The minor version number will be incremented\
    \ if significant new\n   capabilities have been added to the core format (e.g.,\
    \ new optional\n   elements).\n"
- title: 7.  Storage of Policies
  contents:
  - "7.  Storage of Policies\n   As explained above policies can be stored in the\
    \ Evidence Record in\n   the <Attribute> or the <SupportingInformation> element.\
    \  In the case\n   of storing DSSC policies [RFC5698], the types to be used in\
    \ the\n   <Attribute> or <SupportingInformation> element are defined in\n   Appendix\
    \ A.2 of [RFC5698] for both ASN.1 and XML representation.\n"
- title: 8.  XSD Schema for the Evidence Record
  contents:
  - "8.  XSD Schema for the Evidence Record\n   <?xml version=\"1.0\" encoding=\"\
    UTF-8\"?>\n   <xs:schema  xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n    \
    \           xmlns=\"urn:ietf:params:xml:ns:ers\"\n               targetNamespace=\"\
    urn:ietf:params:xml:ns:ers\"\n               elementFormDefault=\"qualified\"\n\
    \               attributeFormDefault=\"unqualified\">\n   <xs:element name=\"\
    EvidenceRecord\" type=\"EvidenceRecordType\"/>\n   <!-- TYPE DEFINITIONS-->\n\
    \   <xs:complexType name=\"EvidenceRecordType\">\n      <xs:sequence>\n      \
    \   <xs:element name=\"EncryptionInformation\"\n                     type=\"EncryptionInfo\"\
    \ minOccurs=\"0\"/>\n         <xs:element name=\"SupportingInformationList\"\n\
    \                     type=\"SupportingInformationType\" minOccurs=\"0\"/>\n \
    \        <xs:element name=\"ArchiveTimeStampSequence\"\n                     type=\"\
    ArchiveTimeStampSequenceType\"/>\n      </xs:sequence>\n      <xs:attribute name=\"\
    Version\" type=\"xs:decimal\" use=\"required\"\n                             \
    \                          fixed=\"1.0\"/>\n   </xs:complexType>\n   <xs:complexType\
    \ name=\"EncryptionInfo\">\n      <xs:sequence>\n         <xs:element name=\"\
    EncryptionInformationType\"\n                     type=\"ObjectIdentifier\"/>\n\
    \         <xs:element name=\"EncryptionInformationValue\">\n            <xs:complexType\
    \ mixed=\"true\">\n               <xs:sequence>\n                  <xs:any minOccurs=\"\
    0\"/>\n               </xs:sequence>\n            </xs:complexType>\n        \
    \ </xs:element>\n      </xs:sequence>\n   </xs:complexType>\n   <xs:complexType\
    \ name=\"ArchiveTimeStampSequenceType\">\n      <xs:sequence>\n         <xs:element\
    \ name=\"ArchiveTimeStampChain\" maxOccurs=\"unbounded\">\n            <xs:complexType>\n\
    \               <xs:sequence>\n                  <xs:element name=\"DigestMethod\"\
    \n                              type=\"DigestMethodType\"/>\n                \
    \  <xs:element name=\"CanonicalizationMethod\"\n                             \
    \ type=\"CanonicalizationMethodType\"/>\n                  <xs:element name=\"\
    ArchiveTimeStamp\"\n                              type=\"ArchiveTimeStampType\"\
    \n                              maxOccurs=\"unbounded\" />\n               </xs:sequence>\n\
    \               <xs:attribute name=\"Order\" type=\"OrderType\"\n            \
    \                 use=\"required\"/>\n            </xs:complexType>\n        \
    \ </xs:element>\n      </xs:sequence>\n   </xs:complexType>\n   <xs:complexType\
    \ name=\"ArchiveTimeStampType\">\n      <xs:sequence>\n         <xs:element name=\"\
    HashTree\" type=\"HashTreeType\" minOccurs=\"0\"/>\n         <xs:element name=\"\
    TimeStamp\" type=\"TimeStampType\"/>\n         <xs:element name=\"Attributes\"\
    \ type=\"Attributes\" minOccurs=\"0\"/>\n      </xs:sequence>\n      <xs:attribute\
    \ name=\"Order\" type=\"OrderType\" use=\"required\"/>\n   </xs:complexType>\n\
    \   <xs:complexType name=\"DigestMethodType\" mixed=\"true\">\n      <xs:sequence>\n\
    \         <xs:any namespace=\"##other\" minOccurs=\"0\"/>\n      </xs:sequence>\n\
    \      <xs:attribute name=\"Algorithm\" type=\"xs:anyURI\" use=\"required\"/>\n\
    \   </xs:complexType>\n   <xs:complexType name=\"CanonicalizationMethodType\"\
    \ mixed=\"true\">\n      <xs:sequence minOccurs=\"0\">\n         <xs:any namespace=\"\
    ##any\" minOccurs=\"0\"/>\n      </xs:sequence>\n      <xs:attribute name=\"Algorithm\"\
    \ type=\"xs:anyURI\" use=\"required\"/>\n   </xs:complexType>\n   <xs:complexType\
    \ name=\"TimeStampType\">\n      <xs:sequence>\n         <xs:element name=\"TimeStampToken\"\
    >\n            <xs:complexType mixed=\"true\">\n               <xs:complexContent\
    \ mixed=\"true\">\n                  <xs:restriction base=\"xs:anyType\">\n  \
    \                   <xs:sequence>\n                        <xs:any processContents=\"\
    lax\" minOccurs=\"0\"\n                                maxOccurs=\"unbounded\"\
    />\n                     </xs:sequence>\n                     <xs:attribute name=\"\
    Type\" type=\"xs:NMTOKEN\"\n                                   use=\"required\"\
    />\n                  </xs:restriction>\n               </xs:complexContent>\n\
    \            </xs:complexType>\n         </xs:element>\n         <xs:element name=\"\
    CryptographicInformationList\"\n                     type=\"CryptographicInformationType\"\
    \ minOccurs=\"0\"/>\n      </xs:sequence>\n   </xs:complexType>\n   <xs:complexType\
    \ name=\"HashTreeType\">\n      <xs:sequence>\n         <xs:element name=\"Sequence\"\
    \ maxOccurs=\"unbounded\">\n            <xs:complexType>\n               <xs:sequence>\n\
    \                  <xs:element name=\"DigestValue\" type=\"xs:base64Binary\"\n\
    \                              maxOccurs=\"unbounded\"/>\n               </xs:sequence>\n\
    \               <xs:attribute name=\"Order\" type=\"OrderType\"\n            \
    \                 use=\"required\"/>\n            </xs:complexType>\n        \
    \ </xs:element>\n      </xs:sequence>\n   </xs:complexType>\n   <xs:complexType\
    \ name=\"Attributes\">\n      <xs:sequence>\n         <xs:element name=\"Attribute\"\
    \ maxOccurs=\"unbounded\">\n            <xs:complexType mixed=\"true\">\n    \
    \           <xs:complexContent mixed=\"true\">\n                  <xs:restriction\
    \ base=\"xs:anyType\">\n                     <xs:sequence>\n                 \
    \       <xs:any processContents=\"lax\" minOccurs=\"0\"\n                    \
    \            maxOccurs=\"unbounded\"/>\n                     </xs:sequence>\n\
    \                     <xs:attribute name=\"Order\" type=\"OrderType\"\n      \
    \                             use=\"required\"/>\n                     <xs:attribute\
    \ name=\"Type\" type=\"xs:string\"\n                                   use=\"\
    optional\"/>\n                  </xs:restriction>\n               </xs:complexContent>\n\
    \            </xs:complexType>\n         </xs:element>\n      </xs:sequence>\n\
    \   </xs:complexType>\n   <xs:complexType name=\"CryptographicInformationType\"\
    >\n      <xs:sequence>\n         <xs:element name=\"CryptographicInformation\"\
    \n               maxOccurs=\"unbounded\">\n            <xs:complexType mixed=\"\
    true\">\n               <xs:complexContent mixed=\"true\">\n                 \
    \ <xs:restriction base=\"xs:anyType\">\n                     <xs:sequence>\n \
    \                       <xs:any processContents=\"lax\" minOccurs=\"0\"\n    \
    \                            maxOccurs=\"unbounded\"/>\n                     </xs:sequence>\n\
    \                     <xs:attribute name=\"Order\" type=\"OrderType\"\n      \
    \                             use=\"required\"/>\n                     <xs:attribute\
    \ name=\"Type\" type=\"xs:NMTOKEN\"\n                                   use=\"\
    required\"/>\n                  </xs:restriction>\n               </xs:complexContent>\n\
    \            </xs:complexType>\n         </xs:element>\n      </xs:sequence>\n\
    \   </xs:complexType>\n   <xs:complexType name=\"SupportingInformationType\">\n\
    \      <xs:sequence>\n         <xs:element name=\"SupportingInformation\"\n  \
    \             maxOccurs=\"unbounded\">\n            <xs:complexType mixed=\"true\"\
    >\n               <xs:complexContent mixed=\"true\">\n                  <xs:restriction\
    \ base=\"xs:anyType\">\n                     <xs:sequence>\n                 \
    \       <xs:any processContents=\"lax\" minOccurs=\"0\"\n                    \
    \            maxOccurs=\"unbounded\"/>\n                     </xs:sequence>\n\
    \                     <xs:attribute name=\"Type\" type=\"xs:string\"\n       \
    \                            use=\"required\"/>\n                  </xs:restriction>\n\
    \               </xs:complexContent>\n            </xs:complexType>\n        \
    \ </xs:element>\n      </xs:sequence>\n   </xs:complexType>\n   <xs:simpleType\
    \ name=\"ObjectIdentifier\">\n      <xs:restriction base=\"xs:token\">\n     \
    \    <xs:pattern value=\"[0-2](\\.[1-3]?[0-9]?(\\.\\d+)*)?\"/>\n      </xs:restriction>\n\
    \   </xs:simpleType>\n   <xs:simpleType name=\"OrderType\">\n      <xs:restriction\
    \ base=\"xs:int\">\n         <xs:minInclusive value=\"1\"/>\n      </xs:restriction>\n\
    \   </xs:simpleType>\n   </xs:schema>\n"
- title: 9.  Security Considerations
  contents:
  - '9.  Security Considerations

    '
- title: 9.1.  Secure Algorithms
  contents:
  - "9.1.  Secure Algorithms\n   Cryptographic algorithms and parameters that are\
    \ used within Archive\n   Time-Stamps must always be secure at the time of generation.\
    \  This\n   concerns the hash algorithm used in the hash lists of Archive Time-\n\
    \   Stamp as well as hash algorithms and public key algorithms of the\n   Time-Stamps.\
    \  Publications regarding security suitability of\n   cryptographic algorithms\
    \ ([NIST.800-57-Part1.2006] and\n   [ETSI-TS-102-176-1-V2.0.0]) have to be considered\
    \ during the\n   verification.  A generic solution for automatic interpretation\
    \ of\n   security suitability policies in electronic form is not the subject\n\
    \   of this specification.\n"
- title: 9.2.  Redundancy
  contents:
  - "9.2.  Redundancy\n   Evidence Records may become affected by weakening cryptographic\n\
    \   algorithms even before this is publicly known.  Retrospectively this\n   has\
    \ an impact on Archive Time-Stamps generated and renewed during the\n   archival\
    \ period.  In this case the validity of Evidence Records\n   created may end without\
    \ any options for retroactive action.\n   Many TSAs are using the same cryptographic\
    \ algorithms.  While\n   compromise of a private key of a TSA may compromise the\
    \ security of\n   only one TSA (and only one Archive Time-Stamp, for example),\n\
    \   weakening cryptographic algorithms used to generate Time-Stamp Tokens\n  \
    \ would affect many TSAs at the same time.\n   To manage such risks and to avoid\
    \ the loss of Evidence Record\n   validity due to weakening cryptographic algorithms\
    \ used, it is\n   RECOMMENDED to generate and manage at least two redundant Evidence\n\
    \   Records for a single data object.  In such scenarios redundant\n   Evidence\
    \ Records SHOULD use different hash algorithms within Archive\n   Time-Stamp Sequences\
    \ and different TSAs using different cryptographic\n   algorithms for Time-Stamp\
    \ Tokens.\n"
- title: 9.3.  Secure Time-Stamps
  contents:
  - "9.3.  Secure Time-Stamps\n   Archive Time-Stamps depend upon the security of\
    \ normal Time-Stamping\n   provided by TSA and stated in security policies.  Renewed\
    \ Archive\n   Time-Stamps MUST have the same or higher quality as the initial\n\
    \   Archive Time-Stamp of archive data.  Archive Time-Stamps used for\n   signed\
    \ archive data SHOULD have the same or higher quality than the\n   maximum quality\
    \ of the signatures.\n"
- title: 9.4.  Time-Stamp Verification
  contents:
  - "9.4.  Time-Stamp Verification\n   It is important to consider for renewal and\
    \ verification that when a\n   new Time-Stamp is applied, it MUST be ascertained\
    \ that prior to the\n   time of renewal (i.e., when the new Time-Stamp is applied)\
    \ the\n   certificate of the before current Time-Stamp was not revoked due to\
    \ a\n   key compromise.  Otherwise, in the case of a key compromise, there is\n\
    \   the risk that the authenticity of the used Time-Stamp and therefore\n   its\
    \ security in the chain of evidence cannot be guaranteed.  Other\n   revocation\
    \ reasons like the revocation for cessation of activity do\n   not necessarily\
    \ pose this risk, as in that case the private key of\n   the Time-Stamp unit would\
    \ have been previously destroyed and thus\n   cannot be used nor compromised.\n\
    \   Both elements <CryptographicInformationList> and <Attribute> are\n   protected\
    \ by future Archive Time_Stamp renewals and can store\n   information as outlined\
    \ in Section 2.1 that is available at or before\n   the time of the renewal of\
    \ the specific Archive Time-Stamp.  At the\n   time of renewal all previous Archive\
    \ Time-Stamp data structures\n   become protected by the new Archive Time-Stamp\
    \ and frozen by it,\n   i.e., no data MUST be added or modified in these elements\
    \ afterwards.\n   If, however, some supporting information is relevant for the\
    \ overall\n   Evidence Record or information that only becomes available later,\n\
    \   this can be provided in the Evidence Record in the\n   <SupportingInformationList>\
    \ element.  Data in the\n   <SupportingInformatonList> can be added later to an\
    \ Evidence Record,\n   but it must rely on its own authenticity and integrity\
    \ protection\n   mechanism, like, for example, signed by current strong cryptographic\n\
    \   means and/or provided by a trusted source (for example, this could be\n  \
    \ the LTA providing its current system DSSC policy, signed with current\n   strong\
    \ cryptographic means).\n"
- title: 10.  IANA Considerations
  contents:
  - "10.  IANA Considerations\n   For all IANA registrations related to this document,\
    \ the\n   \"Specification Required\" [RFC5226] allocation policies MUST be used.\n\
    \   This document defines the XML namespace \"urn:ietf:params:xml:ns:ers\"\n \
    \  according to the guidelines in [RFC3688].  This namespace has been\n   registered\
    \ in the IANA XML Registry.\n   This document defines an XML schema (see Section\
    \ 8) according to the\n   guidelines in [RFC3688].  This XML schema has been registered\
    \ in the\n   IANA XML Registry and can be identified with the URN\n   \"urn:ietf:params:xml:schema:ers\"\
    .\n   This specification defines a new IANA registry entitled \"XML Evidence\n\
    \   Record Syntax (XMLERS)\".  This registry contains two sub-registries\n   entitled\
    \ \"Time-Stamp Token Type\" and \"Cryptographic Information\n   Type\".  The policy\
    \ for future assignments to both sub-registries is\n   \"RFC Required\".\n   The\
    \ sub-registry \"Time-Stamp Token Type\" contains textual names and\n   description,\
    \ which should refer to the specification or standard\n   defining that type.\
    \  It serves as assistance when validating a Time-\n   Stamp Token.\n   When registering\
    \ a new Time-Stamp Token type, the following\n   information MUST be provided:\n\
    \   o  The textual name of the Time-Stamp Token type (value).  The value\n   \
    \   MUST conform to the XML datatype \"xs:NMTOKEN\".\n   o  A reference to a publicly\
    \ available specification that defines the\n      Time-Stamp Token type (description).\n\
    \   The initial values for the \"Time-Stamp Token Type\" sub-registry are:\n \
    \  Value\n     Description\n     Reference\n   -------------\n   RFC3161\n   \
    \   RFC3161 Time-Stamp\n      RFC 3161\n   XMLENTRUST\n      EnTrust XML Schema\n\
    \      http://www.si-tsa.gov.si/dokumenti/timestamp-protocol-20020207.xsd\n  \
    \ The sub-registry \"Cryptographic Information Type\" contains textual\n   names\
    \ and description, which should refer to a specification or\n   standard defining\
    \ that type.  It serves as assistance when validating\n   cryptographic information\
    \ such as digital certificates, CRLs, or\n   OCSP-Responses.\n   When registering\
    \ a new cryptographic information type, the following\n   information MUST be\
    \ provided:\n   o  The textual name of the cryptographic information type (value).\n\
    \      The value MUST conform to the XML datatype \"xs:NMTOKEN\".\n   o  A reference\
    \ to a publicly available specification that defines the\n      cryptographic\
    \ information type (description).\n   The initial values for the \"Cryptographic\
    \ Information Type\" sub-\n   registry are:\n   Value       Description      \
    \                   Reference\n   -----       ------------------             \
    \     -----------------\n   CERT        DER-encoded X.509 Certificate       RFC\
    \ 5280\n   CRL         DER-encoded X.509                   RFC 5280\n        \
    \       Certificate Revocation List\n   OCSP        DER-encoded OCSPResponse \
    \           RFC 2560\n   SCVP        DER-encoded SCVP response           RFC 5055\n\
    \               (CVResponse)\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [RFC2119]    Bradner, S., \"Key words for use\
    \ in RFCs to Indicate\n                Requirement Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [RFC2560]    Myers, M., Ankney, R., Malpani, A., Galperin, S.,\
    \ and C.\n                Adams, \"X.509 Internet Public Key Infrastructure Online\n\
    \                Certificate Status Protocol - OCSP\", RFC 2560, June\n      \
    \          1999.\n   [RFC3161]    Adams, C., Cain, P., Pinkas, D., and R. Zuccherato,\n\
    \                \"Internet X.509 Public Key Infrastructure Time-Stamp\n     \
    \           Protocol (TSP)\", RFC 3161, August 2001.\n   [RFC3688]    Mealling,\
    \ M., \"The IETF XML Registry\", BCP 81, RFC 3688,\n                January 2004.\n\
    \   [RFC3275]    Eastlake 3rd, D., Reagle, J., and D. Solo, \"(Extensible\n  \
    \              Markup Language) XML-Signature Syntax and Processing\",\n     \
    \           RFC 3275, March 2002.\n   [RFC4051]    Eastlake 3rd, D., \"Additional\
    \ XML Security Uniform\n                Resource Identifiers (URIs)\", RFC 4051,\
    \ April 2005.\n   [RFC4648]    Josefsson, S., \"The Base16, Base32, and Base64\
    \ Data\n                Encodings\", RFC 4648, October 2006.\n   [RFC4998]   \
    \ Gondrom, T., Brandner, R., and U. Pordesch, \"Evidence\n                Record\
    \ Syntax (ERS)\", RFC 4998, August 2007.\n   [RFC5055]    Freeman, T., Housley,\
    \ R., Malpani, A., Cooper, D., and\n                W. Polk, \"Server-Based Certificate\
    \ Validation Protocol\n                (SCVP)\", RFC 5055, December 2007.\n  \
    \ [RFC5280]    Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\n         \
    \       Housley, R., and W. Polk, \"Internet X.509 Public Key\n              \
    \  Infrastructure Certificate and Certificate Revocation\n                List\
    \ (CRL) Profile\", RFC 5280, May 2008.\n   [RFC5226]    Narten, T. and H. Alvestrand,\
    \ \"Guidelines for Writing an\n                IANA Considerations Section in\
    \ RFCs\", BCP 26, RFC 5226,\n                May 2008.\n   [XMLC14N]    Boyer,\
    \ J., \"Canonical XML\", W3C Recommendation, March\n                2001.\n  \
    \ [XMLDSig]    Eastlake, D., Reagle, J., Solo, D., Hirsch, F.,\n             \
    \   Roessler, T., \"XML-Signature Syntax and Processing\",\n                XMLDSig,\
    \ W3C Recommendation, July 2006.\n   [XMLName]    Layman, A., Hollander, D., Tobin,\
    \ R., and T. Bray,\n                \"Namespaces in XML 1.0 (Second Edition)\"\
    , W3C\n                Recommendation, August 2006.\n   [XMLSchema]  Thompson,\
    \ H., Beech, D., Mendelsohn, N., and M. Maloney,\n                \"XML Schema\
    \ Part 1: Structures Second Edition\", W3C\n                Recommendation, October\
    \ 2004.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [ANSI.X9-95.2005]\n                American\
    \ National Standard for Financial Services,\n                \"Trusted Timestamp\
    \ Management and Security\", ANSI X9.95,\n                June 2005.\n   [ETSI-TS-102-176-1-V2.0.0]\n\
    \                ETSI, \"Electronic Signatures and Infrastructures (ESI);\n  \
    \              Algorithms and Parameters for Secure Electronic\n             \
    \   Signatures; Part 1: Hash functions and asymmetric\n                algorithms\"\
    , ETSI TS 102 176-1 V2.0.0 (2007-11),\n                November 2007.\n   [ISO-18014-1.2002]\n\
    \                ISO/IEC JTC 1/SC 27, \"Time stamping services - Part 1:\n   \
    \             Framework\", ISO ISO-18014-1, February 2002.\n   [ISO-18014-2.2002]\n\
    \                ISO/IEC JTC 1/SC 27, \"Time stamping services - Part 2:\n   \
    \             Mechanisms producing independent tokens\", ISO\n               \
    \ ISO-18014-2, December 2002.\n   [ISO-18014-3.2004]\n                ISO/IEC\
    \ JTC 1/SC 27, \"Time stamping services - Part 3:\n                Mechanisms\
    \ producing linked tokens\", ISO ISO-18014-3,\n                February 2004.\n\
    \   [MER1980]    Merkle, R., \"Protocols for Public Key Cryptosystems,\n     \
    \           Proceedings of the 1980 IEEE Symposium on Security and\n         \
    \       Privacy (Oakland, CA, USA)\", pages 122-134, April 1980.\n   [NIST.800-57-Part1.2006]\n\
    \                National Institute of Standards and Technology,\n           \
    \     \"Recommendation for Key Management - Part 1: General\n                (Revised)\"\
    , NIST 800-57 Part1, May 2006.\n   [RFC3470]    Hollenbeck, S., Rose, M., and\
    \ L. Masinter, \"Guidelines\n                for the Use of Extensible Markup\
    \ Language (XML) within\n                IETF Protocols\", BCP 70, RFC 3470, January\
    \ 2003.\n   [RFC4810]    Wallace, C., Pordesch, U., and R. Brandner, \"Long-Term\n\
    \                Archive Service Requirements\", RFC 4810, March 2007.\n   [RFC5126]\
    \    Pinkas, D., Pope, N., and J. Ross, \"CMS Advanced\n                Electronic\
    \ Signatures (CAdES)\", RFC 5126, March 2008.\n   [TS-ENTRUST] The Slovenian Time\
    \ Stamping Authority, Entrust XML\n                Schema for Time-Stamp, http://www.si-tsa.gov.si/\n\
    \                dokumenti/timestamp-protocol-20020207.xsd.\n   [RFC3629]    Yergeau,\
    \ F., \"UTF-8, a transformation format of ISO\n                10646\", STD 63,\
    \ RFC 3629, November 2003.\n   [RFC3986]    Berners-Lee, T., Fielding, R., and\
    \ L. Masinter, \"Uniform\n                Resource Identifier (URI): Generic Syntax\"\
    , STD 66, RFC\n                3986, January 2005.\n   [XAdES]      Cruellas,\
    \ J. C., Karlinger, G., Pinkas, D., Ross, J.,\n                \"XML Advanced\
    \ Electronic Signatures\", XAdES, W3C Note,\n                February 2003.\n\
    \   [RFC5652]    Housley, R., \"Cryptographic Message Syntax (CMS)\", STD\n  \
    \              70, RFC 5652, September 2009.\n   [RFC5698]    Kunz, T., Okunick,\
    \ S., and U. Pordesch, \"Data Structure\n                for the Security Suitability\
    \ of Cryptographic Algorithms\n                (DSSC)\", RFC 5698, November 2009.\n"
- title: Appendix A.  Detailed Verification Process of an Evidence Record
  contents:
  - "Appendix A.  Detailed Verification Process of an Evidence Record\n   To verify\
    \ the validity of an Evidence Record start with the first ATS\n   till the last\
    \ ATS (ordered by attribute Order) and perform\n   verification for each ATS,\
    \ as follows:\n   1. Select corresponding archive object and its data object or\
    \ a group\n      of data objects.\n   2. Re-encrypt data object or data object\
    \ group, if the\n      <EncryptionInformation> field is used (see Section 5 for\
    \ more\n      details)\n   3. Get a canonicalization method C and a digest method\
    \ H from the\n      <DigestMethod> element of the current chain.\n   4. Make a\
    \ new list L of digest values of (binary representation of)\n      objects (data,\
    \ ATS, or sequence) that MUST be protected with this\n      ATS as follows:\n\
    \      a. If this ATS is the first in the Archive Time-Stamp Chain:\n        \
    \ i. If this is the first ATS of the first ATSC (the initial ATS)\n          \
    \  in the ATSSeq, calculate digest values of data objects with\n            H\
    \ and add each digest value to the list L.\n        ii. If this ATS is not the\
    \ initial ATS, calculate a digest value\n            with H of ordered ATSSeq\
    \ without this and successive chains.\n            Add value H and digest values\
    \ of data objects to the list L.\n      b. If this ATS is not the first in the\
    \ ATSC:\n         i. Calculate the digest value with H of the previous\n     \
    \       <TimeSatmp> element and add this digest value to the list L.\n   5. Verify\
    \ the ATS's Time-Stamped value as follows.  Get the first\n      sequence of the\
    \ hash tree for this ATS.\n      a. If this ATS has no hash tree elements then:\n\
    \        ii. If this ATS is not the first in the ATSSeq (the initial\n       \
    \     ATS), then the Time-Stamped value must be equal to the\n            digest\
    \ value of previous Time-Stamp element.  If not, exit\n            with a negative\
    \ result.\n       iii. If this ATS is the initial ATS in the ATSC, there must\
    \ be\n            only one data object of the archive object.  The digest\n  \
    \          value of that data object must be the same as its Time-\n         \
    \   Stamped value.  If not, exit with a negative result.\n      b. If this ATS\
    \ has a hash tree then: If there is a digest value in\n         the list L of\
    \ digest values of protected objects, which cannot\n         be found in the first\
    \ sequence of the hash tree or if there is\n         a hash value in the first\
    \ sequence of the hash tree which is\n         not in the list L of digest values\
    \ of protected objects, exit\n         with a negative result.\n         i. Get\
    \ the hash tree from the current ATS and use H to\n            calculate the root\
    \ hash value (see Sections 3.2.1 and\n            3.2.2).\n        ii. Get Time-Stamped\
    \ value from the Time-Stamp Token.  If\n            calculated root hash value\
    \ from the hash tree does not match\n            the Time-Stamped value, exit\
    \ with a negative result.\n      6. Verify Time-Stamp cryptographically and formally\
    \ (validate the\n         used certificate and its chain, which may be available\
    \ within\n         the Time-Stamp Token itself or <CryptographicInformation>\n\
    \         element).\n      7. If this ATS is the last ATS, check formal validity\
    \ for the\n         current time (now), or get \"valid from\" time of the next\
    \ ATS\n         and verify formal validity at that specific time.\n      8. If\
    \ the needed information to verify formal validity is not\n         found within\
    \ the Time-Stamp or within its Cryptographic\n         Information section of\
    \ ATS, exit with a negative result.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Aleksej Jerman Blazic\n   SETCCE\n   Tehnoloski park 21\n\
    \   1000 Ljubljana\n   Slovenia\n   Phone: +386 (0) 1 620 4500\n   Fax:   +386\
    \ (0) 1 620 4509\n   EMail: aljosa@setcce.si\n   Svetlana Saljic\n   SETCCE\n\
    \   Tehnoloski park 21\n   1000 Ljubljana\n   Slovenia\n   Phone: +386 (0) 1 620\
    \ 4506\n   Fax:   +386 (0) 1 620 4509\n   EMail: svetlana.saljic@setcce.si\n \
    \  Tobias Gondrom\n   Kruegerstr. 5A\n   85716 Unterschleissheim\n   Germany\n\
    \   Phone: +49 (0) 89 320 5330\n   EMail: tobias.gondrom@gondrom.org\n"
