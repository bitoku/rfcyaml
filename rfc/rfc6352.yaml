- contents:
  - "                      CardDAV: vCard Extensions to\n           Web Distributed
    Authoring and Versioning (WebDAV)\n"
  title: __initial_text__
- contents:
  - "Abstract\n   This document defines extensions to the Web Distributed Authoring
    and\n   Versioning (WebDAV) protocol to specify a standard way of accessing,\n
    \  managing, and sharing contact information based on the vCard format.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6352.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction and Overview  . . . . . . . . . . . .
    . . . . . .  4\n   2.  Conventions  . . . . . . . . . . . . . . . . . . . . .
    . . . .  5\n   3.  Requirements Overview  . . . . . . . . . . . . . . . . . .
    . .  6\n   4.  Address Book Data Model  . . . . . . . . . . . . . . . . . . .
    \ 7\n     4.1.  Address Book Server  . . . . . . . . . . . . . . . . . . .  7\n
    \  5.  Address Book Resources . . . . . . . . . . . . . . . . . . . .  7\n     5.1.
    \ Address Object Resources . . . . . . . . . . . . . . . . .  7\n       5.1.1.
    \ Data Type Conversion . . . . . . . . . . . . . . . . .  8\n         5.1.1.1.
    \ Additional Precondition for GET  . . . . . . . . .  8\n     5.2.  Address Book
    Collections . . . . . . . . . . . . . . . . .  9\n   6.  Address Book Feature
    . . . . . . . . . . . . . . . . . . . . . 10\n     6.1.  Address Book Support
    . . . . . . . . . . . . . . . . . . . 10\n       6.1.1.  Example: Using OPTIONS
    for the Discovery of\n               Support for CardDAV  . . . . . . . . . .
    . . . . . . . 10\n     6.2.  Address Book Properties  . . . . . . . . . . . .
    . . . . . 10\n       6.2.1.  CARDDAV:addressbook-description Property . . . .
    . . . 10\n       6.2.2.  CARDDAV:supported-address-data Property  . . . . . .
    . 11\n       6.2.3.  CARDDAV:max-resource-size Property . . . . . . . . . . 12\n
    \    6.3.  Creating Resources . . . . . . . . . . . . . . . . . . . . 13\n       6.3.1.
    \ Extended MKCOL Method  . . . . . . . . . . . . . . . . 13\n         6.3.1.1.
    \ Example - Successful MKCOL Request . . . . . . . . 14\n       6.3.2.  Creating
    Address Object Resources  . . . . . . . . . . 15\n         6.3.2.1.  Additional
    Preconditions for PUT, COPY, and\n                   MOVE . . . . . . . . . .
    . . . . . . . . . . . . . 16\n         6.3.2.2.  Non-Standard vCard Properties
    and Parameters . . . 17\n         6.3.2.3.  Address Object Resource Entity Tag
    . . . . . . . . 18\n   7.  Address Book Access Control  . . . . . . . . . . .
    . . . . . . 18\n     7.1.  Additional Principal Properties  . . . . . . . . .
    . . . . 18\n       7.1.1.  CARDDAV:addressbook-home-set Property  . . . . . .
    . . 19\n       7.1.2.  CARDDAV:principal-address Property . . . . . . . . . .
    19\n   8.  Address Book Reports . . . . . . . . . . . . . . . . . . . . . 20\n
    \    8.1.  REPORT Method  . . . . . . . . . . . . . . . . . . . . . . 20\n     8.2.
    \ Ordinary Collections . . . . . . . . . . . . . . . . . . . 21\n     8.3.  Searching
    Text: Collations . . . . . . . . . . . . . . . . 21\n       8.3.1.  CARDDAV:supported-collation-set
    Property . . . . . . . 22\n     8.4.  Partial Retrieval  . . . . . . . . . . .
    . . . . . . . . . 23\n     8.5.  Non-Standard Properties and Parameters . . .
    . . . . . . . 23\n     8.6.  CARDDAV:addressbook-query Report . . . . . . . .
    . . . . . 23\n       8.6.1.  Limiting Results . . . . . . . . . . . . . . . .
    . . . 25\n       8.6.2.  Truncation of Results  . . . . . . . . . . . . . . .
    . 25\n       8.6.3.  Example: Partial Retrieval of vCards Matching\n               NICKNAME
    . . . . . . . . . . . . . . . . . . . . . . . 26\n       8.6.4.  Example: Partial
    Retrieval of vCards Matching a\n               Full Name or Email Address . .
    . . . . . . . . . . . . 27\n       8.6.5.  Example: Truncated Results . . . .
    . . . . . . . . . . 29\n     8.7.  CARDDAV:addressbook-multiget Report  . . .
    . . . . . . . . 31\n       8.7.1.  Example: CARDDAV:addressbook-multiget Report
    . . . . . 32\n       8.7.2.  Example: CARDDAV:addressbook-multiget Report . .
    . . . 33\n   9.  Client Guidelines  . . . . . . . . . . . . . . . . . . . . .
    . 34\n     9.1.  Restrict the Properties Returned . . . . . . . . . . . . . 34\n
    \    9.2.  Avoiding Lost Updates  . . . . . . . . . . . . . . . . . . 35\n     9.3.
    \ Client Configuration . . . . . . . . . . . . . . . . . . . 35\n     9.4.  Finding
    Other Users' Address Books . . . . . . . . . . . . 35\n   10. XML Element Definitions
    \ . . . . . . . . . . . . . . . . . . . 36\n     10.1. CARDDAV:addressbook XML
    Element  . . . . . . . . . . . . . 36\n     10.2. CARDDAV:supported-collation
    XML Element  . . . . . . . . . 36\n     10.3. CARDDAV:addressbook-query XML Element
    \ . . . . . . . . . . 37\n     10.4. CARDDAV:address-data XML Element . . . .
    . . . . . . . . . 37\n       10.4.1. CARDDAV:allprop XML Element  . . . . . .
    . . . . . . . 39\n       10.4.2. CARDDAV:prop XML Element . . . . . . . . . .
    . . . . . 39\n     10.5. CARDDAV:filter XML Element . . . . . . . . . . . . .
    . . . 40\n       10.5.1. CARDDAV:prop-filter XML Element  . . . . . . . . . .
    . 40\n       10.5.2. CARDDAV:param-filter XML Element . . . . . . . . . . . 41\n
    \      10.5.3. CARDDAV:is-not-defined XML Element . . . . . . . . . . 42\n       10.5.4.
    CARDDAV:text-match XML Element . . . . . . . . . . . . 42\n     10.6. CARDDAV:limit
    XML Element  . . . . . . . . . . . . . . . . 43\n       10.6.1. CARDDAV:nresults
    XML Element . . . . . . . . . . . . . 44\n     10.7. CARDDAV:addressbook-multiget
    XML Element . . . . . . . . . 44\n   11. Service Discovery via SRV Records  .
    . . . . . . . . . . . . . 45\n   12. Internationalization Considerations  . .
    . . . . . . . . . . . 45\n   13. Security Considerations  . . . . . . . . . .
    . . . . . . . . . 45\n   14. IANA Consideration . . . . . . . . . . . . . . .
    . . . . . . . 46\n     14.1. Namespace Registration . . . . . . . . . . . . .
    . . . . . 46\n   15. Acknowledgments  . . . . . . . . . . . . . . . . . . . .
    . . . 46\n   16. References . . . . . . . . . . . . . . . . . . . . . . . . .
    . 47\n     16.1. Normative References . . . . . . . . . . . . . . . . . . . 47\n
    \    16.2. Informative References . . . . . . . . . . . . . . . . . . 48\n"
  title: Table of Contents
- contents:
  - "1.  Introduction and Overview\n   Address books containing contact information
    are a key component of\n   personal information management tools, such as email,
    calendaring and\n   scheduling, and instant messaging clients.  To date several
    protocols\n   have been used for remote access to contact data, including the\n
    \  Lightweight Directory Access Protocol (LDAP) [RFC4510], Internet\n   Message
    Support Protocol [IMSP], and Application Configuration Access\n   Protocol (ACAP)
    [RFC2244], together with SyncML used for\n   synchronization of such data.\n   WebDAV
    [RFC4918] offers a number of advantages as a framework or\n   basis for address
    book access and management.  Most of these\n   advantages boil down to a significant
    reduction in the costs of\n   design, implementation, interoperability testing,
    and deployment.\n   The key features of address book support with WebDAV are:\n
    \  1.  Ability to use multiple address books with hierarchical layout.\n   2.
    \ Ability to control access to individual address books and address\n       entries
    as per WebDAV Access Control List (ACL) [RFC3744].\n   3.  Principal collections
    can be used to enumerate and query other\n       users on the system as per WebDAV
    ACL [RFC3744].\n   4.  Server-side searching of address data, avoiding the need
    for\n       clients to download an entire address book in order to do a quick\n
    \      address 'expansion' operation.\n   5.  Well-defined internationalization
    support through WebDAV's use of\n       XML.\n   6.  Use of vCards [RFC2426] for
    well-defined address schema to\n       enhance client interoperability.\n   7.
    \ Many limited clients (e.g., mobile devices) contain an HTTP stack\n       that
    makes implementing WebDAV much easier than other protocols.\n   The key disadvantage
    of address book support in WebDAV is:\n   1.  Lack of change notification.  Many
    of the alternative protocols\n       also lack this ability.  However, an extension
    for push\n       notifications could easily be developed.\n   vCard is a MIME
    directory profile aimed at encapsulating personal\n   addressing and contact information
    about people.  The specification\n   of vCard was originally done by the Versit
    consortium, with a\n   subsequent 3.0 version standardized by the IETF [RFC2426].
    vCard is\n   in widespread use in email clients and mobile devices as a means
    of\n   encapsulating address information for transport via email or for\n   import/export
    and synchronization operations.\n   An update to vCard -- vCard v4 -- is currently
    being developed\n   [RFC6350] and is compatible with this specification.\n"
  title: 1.  Introduction and Overview
- contents:
  - "2.  Conventions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\"
    in this\n   document are to be interpreted as described in [RFC2119].\n   The
    term \"protected\" is used in the Conformance field of property\n   definitions
    as defined in Section 15 of [RFC4918].\n   This document uses XML DTD fragments
    ([W3C.REC-xml-20081126], Section\n   3.2) as a purely notational convention.  WebDAV
    request and response\n   bodies cannot be validated by a DTD due to the specific
    extensibility\n   rules defined in Section 17 of [RFC4918] and due to the fact
    that all\n   XML elements defined by that specification use the XML namespace
    name\n   \"DAV:\".  In particular:\n   1.  Element names use the \"DAV:\" namespace.\n
    \  2.  Element ordering is irrelevant unless explicitly stated.\n   3.  Extension
    elements (elements not already defined as valid child\n       elements) may be
    added anywhere, except when explicitly stated\n       otherwise.\n   4.  Extension
    attributes (attributes not already defined as valid for\n       this element)
    may be added anywhere, except when explicitly\n       stated otherwise.\n   The
    namespace \"urn:ietf:params:xml:ns:carddav\" is reserved for the\n   XML elements
    defined in this specification, its revisions, and\n   related CardDAV specifications.
    \ XML elements defined by individual\n   implementations MUST NOT use the \"urn:ietf:params:xml:ns:carddav\"\n
    \  namespace, and instead should use a namespace that they control.\n   When XML
    element types in the namespaces \"DAV:\" and\n   \"urn:ietf:params:xml:ns:carddav\"
    are referenced in this document\n   outside of the context of an XML fragment,
    the strings \"DAV:\" and\n   \"CARDDAV:\" will be prefixed to the element types,
    respectively.\n   This document inherits, and sometimes extends, DTD productions
    from\n   Section 14 of [RFC4918].\n   Also, note that some CardDAV XML element
    names are identical to\n   WebDAV XML element names, though their namespace differs.
    \ Care must\n   be taken not to confuse the two sets of names.\n"
  title: 2.  Conventions
- contents:
  - "3.  Requirements Overview\n   This section lists what functionality is required
    of a CardDAV\n   server.  To advertise support for CardDAV, a server:\n   o  MUST
    support vCard v3 [RFC2426] as a media type for the address\n      object resource
    format;\n   o  MUST support WebDAV Class 3 [RFC4918];\n   o  MUST support WebDAV
    ACL [RFC3744];\n   o  MUST support secure transport as defined in [RFC2818] using\n
    \     Transport Layer Security (TLS) [RFC5246] and using the certificate\n      validation
    procedures described in [RFC5280];\n   o  MUST support ETags [RFC2616] with additional
    requirements\n      specified in Section 6.3.2.3 of this document;\n   o  MUST
    support all address book reports defined in Section 8 of this\n      document;
    and\n   o  MUST advertise support on all address book collections and address\n
    \     object resources for the address book reports in the\n      DAV:supported-report-set
    property, as defined in Versioning\n      Extensions to WebDAV [RFC3253].\n   In
    addition, a server:\n   o  SHOULD support vCard v4 [RFC6350] as a media type for
    the address\n      object resource format;\n   o  SHOULD support the extended
    MKCOL method [RFC5689] to create\n      address book collections as defined in
    Section 6.3.1 of this\n      document.\n   o  SHOULD support the DAV:current-user-principal-URL
    property as\n      defined in [RFC5397] to give clients a fast way to locate user\n
    \     principals.\n"
  title: 3.  Requirements Overview
- contents:
  - "4.  Address Book Data Model\n   As a brief overview, a CardDAV address book is
    modeled as a WebDAV\n   collection with a well-defined structure; each of these
    address book\n   collections contains a number of resources representing address\n
    \  objects as their direct child resources.  Each resource representing\n   an
    address object is called an \"address object resource\".  Each\n   address object
    resource and each address book collection can be\n   individually locked and have
    individual WebDAV properties.\n   Requirements derived from this model are provided
    in Sections 5.1 and\n   5.2.\n"
  - contents:
    - "4.1.  Address Book Server\n   A CardDAV server is an address-aware engine combined
      with a WebDAV\n   server.  The server may include address data in some parts
      of its URL\n   namespace and non-address data in other parts.\n   A WebDAV server
      can advertise itself as a CardDAV server if it\n   supports the functionality
      defined in this specification at any point\n   within the root of its repository.
      \ That might mean that address data\n   is spread throughout the repository
      and mixed with non-address data\n   in nearby collections (e.g., address data
      may be found in /lisa/\n   addressbook/ as well as in /bernard/addressbook/,
      and non-address\n   data in /lisa/calendars/).  Or, it might mean that address
      data can\n   be found only in certain sections of the repository (e.g.,\n   /addressbooks/user/).
      \ Address book features are only required in the\n   repository sections that
      are or contain address objects.  So, a\n   repository confining address data
      to the /carddav/ collection would\n   only need to support the CardDAV required
      features within that\n   collection.\n   The CardDAV server is the canonical
      location for address data and\n   state information.  Clients may submit requests
      to change data or\n   download data.  Clients may store address objects offline
      and attempt\n   to synchronize at a later time.  Address data on the server
      can\n   change between the time of last synchronization and when attempting\n
      \  an update, as address book collections may be shared and accessible\n   via
      multiple clients.  Entity tags and locking help this work.\n"
    title: 4.1.  Address Book Server
  title: 4.  Address Book Data Model
- contents:
  - '5.  Address Book Resources

    '
  - contents:
    - "5.1.  Address Object Resources\n   This specification uses vCard as the default
      format for address or\n   contact information being stored on the server.  However,
      this\n   specification does allow other formats for address data provided that\n
      \  the server advertises support for those additional formats as\n   described
      below.  The requirements in this section pertain to vCard\n   address data or
      formats that follow the semantics of vCard data.\n   Address object resources
      contained in address book collections MUST\n   contain a single vCard component
      only.\n   vCard components in an address book collection MUST have a UID\n   property
      value that MUST be unique in the scope of the address book\n   collection in
      which it is contained.\n"
    - contents:
      - "5.1.1.  Data Type Conversion\n   Servers might support more than one primary
        media type for address\n   object resources, for example, vCard v3.0 and vCard
        v4.0.  In such\n   cases, servers have to accept all media types that they
        advertise via\n   the CARDDAV:supported-address-data WebDAV property (see\n
        \  Section 6.2.2).\n   However, clients can use standard HTTP content negotiation
        behavior\n   (the Accept request header defined in Section 14.1 of [RFC2616])
        to\n   request that an address object resource's data be returned in a\n   specific
        media type format.  For example, a client merely capable of\n   handling vCard
        v3.0 would only want to have address object resources\n   returned in v3.0
        format.\n   Additionally, REPORT requests, defined later in this specification,\n
        \  allow for the return of address object resource data within an XML\n   response
        body.  Again, the client can use content negotiation to\n   request that data
        be returned in a specific media type by specifying\n   appropriate attributes
        on the CARDDAV:address-data XML element used\n   in the request body (see
        Section 10.4).\n   In some cases, it might not be possible for a server to
        convert from\n   one media type to another.  When that happens, the server
        MUST return\n   the CARDDAV:supported-address-data-conversion precondition
        (see\n   below) in the response body (when the failure to convert applies
        to\n   the entire response) or use that same precondition code in the\n   DAV:response
        XML element in the response for the targeted address\n   object resource when
        one of the REPORTs defined below is used.  See\n   Section 8.7.2 for an example
        of this.\n"
      - contents:
        - "5.1.1.1.  Additional Precondition for GET\n   This specification creates
          additional preconditions for the GET\n   method.\n   The new precondition
          is:\n      (CARDDAV:supported-address-data-conversion): The resource targeted\n
          \     by the GET request can be converted to the media type specified in\n
          \     the Accept request header included with the request.\n"
        title: 5.1.1.1.  Additional Precondition for GET
      title: 5.1.1.  Data Type Conversion
    title: 5.1.  Address Object Resources
  - contents:
    - "5.2.  Address Book Collections\n   Address book collections appear to clients
      as a WebDAV collection\n   resource, identified by a URL.  An address book collection
      MUST\n   report the DAV:collection and CARDDAV:addressbook XML elements in the\n
      \  value of the DAV:resourcetype property.  The element type declaration\n   for
      CARDDAV:addressbook is:\n       <!ELEMENT addressbook EMPTY>\n   An address
      book collection can be created through provisioning (e.g.,\n   automatically
      created when a user's account is provisioned), or it\n   can be created with
      the extended MKCOL method (see Section 6.3.1).\n   This can be used by a user
      to create additional address books (e.g.,\n   \"soccer team members\") or for
      users to share an address book (e.g.,\n   \"sales team contacts\").  However,
      note that this document doesn't\n   define what extra address book collections
      are for.  Users must rely\n   on non-standard cues to find out what an address
      book collection is\n   for, or use the CARDDAV:addressbook-description property
      defined in\n   Section 6.2.1 to provide such a cue.\n   The following restrictions
      are applied to the resources within an\n   address book collection:\n   a.  Address
      book collections MUST only contain address object\n       resources and collections
      that are not address book collections.\n       That is, the only \"top-level\"
      non-collection resources allowed in\n       an address book collection are address
      object resources.  This\n       ensures that address book clients do not have
      to deal with non-\n       address data in an address book collection, though
      they do have\n       to distinguish between address object resources and collections\n
      \      when using standard WebDAV techniques to examine the contents of\n       a
      collection.\n   b.  Collections contained in address book collections MUST NOT\n
      \      contain address book collections at any depth.  That is,\n       \"nesting\"
      of address book collections within other address book\n       collections at
      any depth is not allowed.  This specification does\n       not define how collections
      contained in an address book\n       collection are used or how they relate
      to any address object\n       resources contained in the address book collection.\n
      \  Multiple address book collections MAY be children of the same\n   collection.\n"
    title: 5.2.  Address Book Collections
  title: 5.  Address Book Resources
- contents:
  - '6.  Address Book Feature

    '
  - contents:
    - "6.1.  Address Book Support\n   A server supporting the features described in
      this document MUST\n   include \"addressbook\" as a field in the DAV response
      header from an\n   OPTIONS request on any resource that supports any address
      book\n   properties, reports, or methods.  A value of \"addressbook\" in the
      DAV\n   response header MUST indicate that the server supports all MUST level\n
      \  requirements and REQUIRED features specified in this document.\n"
    - contents:
      - "6.1.1.  Example: Using OPTIONS for the Discovery of Support for CardDAV\n
        \  >> Request <<\n   OPTIONS /addressbooks/users/ HTTP/1.1\n   Host: addressbook.example.com\n
        \  >> Response <<\n   HTTP/1.1 200 OK\n   Allow: OPTIONS, GET, HEAD, POST,
        PUT, DELETE, TRACE, COPY, MOVE\n   Allow: MKCOL, PROPFIND, PROPPATCH, LOCK,
        UNLOCK, REPORT, ACL\n   DAV: 1, 2, 3, access-control, addressbook\n   DAV:
        extended-mkcol\n   Date: Sat, 11 Nov 2006 09:32:12 GMT\n   Content-Length:
        0\n   In this example, the OPTIONS response indicates that the server\n   supports
        CardDAV in this namespace; therefore, the '/addressbooks/\n   users/' collection
        may be used as a parent for address book\n   collections as the extended MKCOL
        method is available and as a\n   possible target for REPORT requests for address
        book reports.\n"
      title: '6.1.1.  Example: Using OPTIONS for the Discovery of Support for CardDAV'
    title: 6.1.  Address Book Support
  - contents:
    - '6.2.  Address Book Properties

      '
    - contents:
      - "6.2.1.  CARDDAV:addressbook-description Property\n   Name:  addressbook-description\n
        \  Namespace:  urn:ietf:params:xml:ns:carddav\n   Purpose:  Provides a human-readable
        description of the address book\n      collection.\n   Value:  Any text.\n
        \  Protected:  SHOULD NOT be protected so that users can specify a\n      description.\n
        \  COPY/MOVE behavior:  This property value SHOULD be preserved in COPY\n
        \     and MOVE operations.\n   allprop behavior:  SHOULD NOT be returned by
        a PROPFIND DAV:allprop\n      request.\n   Description:  This property contains
        a description of the address\n      book collection that is suitable for presentation
        to a user.  The\n      xml:lang attribute can be used to add a language tag
        for the value\n      of this property.\n   Definition:\n       <!ELEMENT addressbook-description
        (#PCDATA)>\n       <!-- PCDATA value: string -->\n   Example:\n       <C:addressbook-description
        xml:lang=\"fr-CA\"\n          xmlns:C=\"urn:ietf:params:xml:ns:carddav\"\n
        \      >Adresses de Oliver Daboo</C:addressbook-description>\n"
      title: 6.2.1.  CARDDAV:addressbook-description Property
    - contents:
      - "6.2.2.  CARDDAV:supported-address-data Property\n   Name:  supported-address-data\n
        \  Namespace:  urn:ietf:params:xml:ns:carddav\n   Purpose:  Specifies what
        media types are allowed for address object\n      resources in an address
        book collection.\n   Protected:  MUST be protected as it indicates the level
        of support\n      provided by the server.\n   COPY/MOVE behavior:  This property
        value MUST be preserved in COPY\n      and MOVE operations.\n   allprop behavior:
        \ SHOULD NOT be returned by a PROPFIND DAV:allprop\n      request.\n   Description:
        \ The CARDDAV:supported-address-data property is used to\n      specify the
        media type supported for the address object resources\n      contained in
        a given address book collection (e.g., vCard version\n      3.0).  Any attempt
        by the client to store address object resources\n      with a media type not
        listed in this property MUST result in an\n      error, with the CARDDAV:supported-address-data
        precondition\n      (Section 6.3.2.1) being violated.  In the absence of this\n
        \     property, the server MUST only accept data with the media type\n      \"text/vcard\"
        and vCard version 3.0, and clients can assume that is\n      all the server
        will accept.\n   Definition:\n       <!ELEMENT supported-address-data (address-data-type+)>\n
        \      <!ELEMENT address-data-type EMPTY>\n       <!ATTLIST address-data-type
        content-type CDATA \"text/vcard\"\n                             version CDATA
        \"3.0\">\n       <!-- content-type value: a MIME media type -->\n       <!--
        version value: a version string -->\n   Example:\n       <C:supported-address-data\n
        \         xmlns:C=\"urn:ietf:params:xml:ns:carddav\">\n         <C:address-data-type
        content-type=\"text/vcard\" version=\"3.0\"/>\n       </C:supported-address-data>\n"
      title: 6.2.2.  CARDDAV:supported-address-data Property
    - contents:
      - "6.2.3.  CARDDAV:max-resource-size Property\n   Name:  max-resource-size\n
        \  Namespace:  urn:ietf:params:xml:ns:carddav\n   Purpose:  Provides a numeric
        value indicating the maximum size in\n      octets of a resource that the
        server is willing to accept when an\n      address object resource is stored
        in an address book collection.\n   Value:  Any text representing a numeric
        value.\n   Protected:  MUST be protected as it indicates limits provided by
        the\n      server.\n   COPY/MOVE behavior:  This property value MUST be preserved
        in COPY\n      and MOVE operations.\n   allprop behavior:  SHOULD NOT be returned
        by a PROPFIND DAV:allprop\n      request.\n   Description:  The CARDDAV:max-resource-size
        is used to specify a\n      numeric value that represents the maximum size
        in octets that the\n      server is willing to accept when an address object
        resource is\n      stored in an address book collection.  Any attempt to store
        an\n      address book object resource exceeding this size MUST result in
        an\n      error, with the CARDDAV:max-resource-size precondition\n      (Section
        6.3.2.1) being violated.  In the absence of this\n      property, the client
        can assume that the server will allow storing\n      a resource of any reasonable
        size.\n   Definition:\n       <!ELEMENT max-resource-size (#PCDATA)>\n       <!--
        PCDATA value: a numeric value (positive decimal integer) -->\n   Example:\n
        \      <C:max-resource-size xmlns:C=\"urn:ietf:params:xml:ns:carddav\"\n       >102400</C:max-resource-size>\n"
      title: 6.2.3.  CARDDAV:max-resource-size Property
    title: 6.2.  Address Book Properties
  - contents:
    - "6.3.  Creating Resources\n   Address book collections and address object resources
      may be created\n   by either a CardDAV client or the CardDAV server.  This specification\n
      \  defines restrictions and a data model that both clients and servers\n   MUST
      adhere to when manipulating such address data.\n"
    - contents:
      - "6.3.1.  Extended MKCOL Method\n   An HTTP request using the extended MKCOL
        method [RFC5689] can be used\n   to create a new address book collection resource.
        \ A server MAY\n   restrict address book collection creation to particular
        collections.\n   To create an address book, the client sends an extended MKCOL
        request\n   to the server and in the body of the request sets the\n   DAV:resourcetype
        property to the resource type for an address book\n   collection as defined
        in Section 5.2.\n   Support for creating address books on the server is only
        RECOMMENDED\n   and not REQUIRED because some address book stores only support
        one\n   address book per user (or principal), and those are typically pre-\n
        \  created for each account.  However, servers and clients are strongly\n
        \  encouraged to support address book creation whenever possible to\n   allow
        users to create multiple address book collections to help\n   organize their
        data better.\n   The DAV:displayname property can be used for a human-readable
        name of\n   the address book.  Clients can either specify the value of the\n
        \  DAV:displayname property in the request body of the extended MKCOL\n   request
        or, alternatively, issue a PROPPATCH request to change the\n   DAV:displayname
        property to the appropriate value immediately after\n   using the extended
        MKCOL request.  When displaying address book\n   collections to users, clients
        SHOULD check the DAV:displayname\n   property and use that value as the name
        of the address book.  In the\n   event that the DAV:displayname property is
        not set, the client MAY\n   use the last part of the address book collection
        URI as the name;\n   however, that path segment may be \"opaque\" and not
        represent any\n   meaningful human-readable text.\n"
      - contents:
        - "6.3.1.1.  Example - Successful MKCOL Request\n   This example creates an
          address book collection called /home/lisa/\n   addressbook/ on the server
          addressbook.example.com with specific\n   values for the properties DAV:resourcetype,
          DAV:displayname, and\n   CARDDAV:addressbook-description.\n   >> Request
          <<\n   MKCOL /home/lisa/addressbook/ HTTP/1.1\n   Host: addressbook.example.com\n
          \  Content-Type: text/xml; charset=\"utf-8\"\n   Content-Length: xxx\n   <?xml
          version=\"1.0\" encoding=\"utf-8\" ?>\n   <D:mkcol xmlns:D=\"DAV:\"\n                 xmlns:C=\"urn:ietf:params:xml:ns:carddav\">\n
          \    <D:set>\n       <D:prop>\n         <D:resourcetype>\n           <D:collection/>\n
          \          <C:addressbook/>\n         </D:resourcetype>\n         <D:displayname>Lisa's
          Contacts</D:displayname>\n         <C:addressbook-description xml:lang=\"en\"\n
          \  >My primary address book.</C:addressbook-description>\n       </D:prop>\n
          \    </D:set>\n   </D:mkcol>\n   >> Response <<\n   HTTP/1.1 201 Created\n
          \  Cache-Control: no-cache\n   Date: Sat, 11 Nov 2006 09:32:12 GMT\n   Content-Type:
          application/xml; charset=\"utf-8\"\n   Content-Length: xxxx\n   <?xml version=\"1.0\"
          encoding=\"utf-8\" ?>\n   <D:mkcol-response xmlns:D=\"DAV:\"\n                 xmlns:C=\"urn:ietf:params:xml:ns:carddav\">\n
          \    <D:propstat>\n       <D:prop>\n         <D:resourcetype/>\n         <D:displayname/>\n
          \        <C:addressbook-description/>\n       </D:prop>\n       <D:status>HTTP/1.1
          200 OK</D:status>\n     </D:propstat>\n   </D:mkcol-response>\n"
        title: 6.3.1.1.  Example - Successful MKCOL Request
      title: 6.3.1.  Extended MKCOL Method
    - contents:
      - "6.3.2.  Creating Address Object Resources\n   Clients populate address book
        collections with address object\n   resources.  The URL for each address object
        resource is entirely\n   arbitrary and does not need to bear a specific relationship
        (but\n   might) to the address object resource's vCard properties or other\n
        \  metadata.  New address object resources MUST be created with a PUT\n   request
        targeted at an unmapped URI.  A PUT request targeted at a\n   mapped URI updates
        an existing address object resource.\n   When servers create new resources,
        it's not hard for the server to\n   choose a unique URL.  It's slightly tougher
        for clients, because a\n   client might not want to examine all resources
        in the collection and\n   might not want to lock the entire collection to
        ensure that a new one\n   isn't created with a name collision.  However, there
        is an HTTP\n   feature to mitigate this.  If the client intends to create
        a new\n   address resource, the client SHOULD use the HTTP header \"If-None-\n
        \  Match: *\" on the PUT request.  The Request-URI on the PUT request\n   MUST
        include the target collection, where the resource is to be\n   created, plus
        the name of the resource in the last path segment.  The\n   \"If-None-Match\"
        header ensures that the client will not inadvertently\n   overwrite an existing
        resource even if the last path segment turned\n   out to already be used.\n
        \  >> Request <<\n   PUT /lisa/addressbook/newvcard.vcf HTTP/1.1\n   If-None-Match:
        *\n   Host: addressbook.example.com\n   Content-Type: text/vcard\n   Content-Length:
        xxx\n   BEGIN:VCARD\n   VERSION:3.0\n   FN:Cyrus Daboo\n   N:Daboo;Cyrus\n
        \  ADR;TYPE=POSTAL:;2822 Email HQ;Suite 2821;RFCVille;PA;15213;USA\n   EMAIL;TYPE=INTERNET,PREF:cyrus@example.com\n
        \  NICKNAME:me\n   NOTE:Example VCard.\n   ORG:Self Employed\n   TEL;TYPE=WORK,VOICE:412
        605 0499\n   TEL;TYPE=FAX:412 605 0705\n   URL:http://www.example.com\n   UID:1234-5678-9000-1\n
        \  END:VCARD\n   >> Response <<\n   HTTP/1.1 201 Created\n   Date: Thu, 02
        Sep 2004 16:53:32 GMT\n   Content-Length: 0\n   ETag: \"123456789-000-111\"\n
        \  The request to change an existing address object resource without\n   overwriting
        a change made on the server uses a specific ETag in an\n   \"If-Match\" header,
        rather than the \"If-None-Match\" header.\n   File names for vCards are commonly
        suffixed by \".vcf\", and clients\n   may choose to use the same convention
        for URLs.\n"
      - contents:
        - "6.3.2.1.  Additional Preconditions for PUT, COPY, and MOVE\n   This specification
          creates additional preconditions for the PUT,\n   COPY, and MOVE methods.
          \ These preconditions apply:\n   o  When a PUT operation of an address object
          resource into an address\n      book collection occurs.\n   o  When a COPY
          or MOVE operation of an address object resource into\n      an address book
          collection occurs.\n   The new preconditions are:\n      (CARDDAV:supported-address-data):
          The resource submitted in the\n      PUT request, or targeted by a COPY
          or MOVE request, MUST be a\n      supported media type (i.e., vCard) for
          address object resources.\n      (CARDDAV:valid-address-data): The resource
          submitted in the PUT\n      request, or targeted by a COPY or MOVE request,
          MUST be valid data\n      for the media type being specified (i.e., MUST
          contain valid vCard\n      data).\n      (CARDDAV:no-uid-conflict): The
          resource submitted in the PUT\n      request, or targeted by a COPY or MOVE
          request, MUST NOT specify a\n      vCard UID property value already in use
          in the targeted address\n      book collection or overwrite an existing
          address object resource\n      with one that has a different UID property
          value.  Servers SHOULD\n      report the URL of the resource that is already
          making use of the\n      same UID property value in the DAV:href element.\n
          \         <!ELEMENT no-uid-conflict (DAV:href)>\n      (CARDDAV:addressbook-collection-location-ok):
          In a COPY or MOVE\n      request, when the Request-URI is an address book
          collection, the\n      URI targeted by the Destination HTTP Request header
          MUST identify\n      a location where an address book collection can be
          created.\n      (CARDDAV:max-resource-size): The resource submitted in the
          PUT\n      request, or targeted by a COPY or MOVE request, MUST have a size\n
          \     in octets less than or equal to the value of the\n      CARDDAV:max-resource-size
          property value (Section 6.2.3) on the\n      address book collection where
          the resource will be stored.\n"
        title: 6.3.2.1.  Additional Preconditions for PUT, COPY, and MOVE
      - contents:
        - "6.3.2.2.  Non-Standard vCard Properties and Parameters\n   vCard provides
          a \"standard mechanism for doing non-standard things\".\n   This extension
          support allows implementers to make use of non-\n   standard vCard properties
          and parameters whose names are prefixed\n   with the text \"X-\".\n   Servers
          MUST support the use of non-standard properties and\n   parameters in address
          object resources stored via the PUT method.\n   Servers may need to enforce
          rules for their own \"private\" properties\n   or parameters, so servers
          MAY reject any attempt by the client to\n   change those or use values for
          those outside of any restrictions the\n   server may have.  A server SHOULD
          ensure that any \"private\"\n   properties or parameters it uses follow
          the convention of including a\n   vendor ID in the \"X-\" name, as described
          in Section 3.8 of [RFC2426],\n   e.g., \"X-ABC-PRIVATE\".\n"
        title: 6.3.2.2.  Non-Standard vCard Properties and Parameters
      - contents:
        - "6.3.2.3.  Address Object Resource Entity Tag\n   The DAV:getetag property
          MUST be defined and set to a strong entity\n   tag on all address object
          resources.\n   A response to a GET request targeted at an address object
          resource\n   MUST contain an ETag response header field indicating the current\n
          \  value of the strong entity tag of the address object resource.\n   Servers
          SHOULD return a strong entity tag (ETag header) in a PUT\n   response when
          the stored address object resource is equivalent by\n   octet equality to
          the address object resource submitted in the body\n   of the PUT request.
          \ This allows clients to reliably use the returned\n   strong entity tag
          for data synchronization purposes.  For instance,\n   the client can do
          a PROPFIND request on the stored address object\n   resource, have the DAV:getetag
          property returned, compare that value\n   with the strong entity tag it
          received on the PUT response, and know\n   that if they are equal, then
          the address object resource on the\n   server has not been changed.\n   In
          the case where the data stored by a server as a result of a PUT\n   request
          is not equivalent by octet equality to the submitted address\n   object
          resource, the behavior of the ETag response header is not\n   specified
          here, with the exception that a strong entity tag MUST NOT\n   be returned
          in the response.  As a result, a client may need to\n   retrieve the modified
          address object resource (and ETag) as a basis\n   for further changes, rather
          than use the address object resource it\n   had sent with the PUT request.\n"
        title: 6.3.2.3.  Address Object Resource Entity Tag
      title: 6.3.2.  Creating Address Object Resources
    title: 6.3.  Creating Resources
  title: 6.  Address Book Feature
- contents:
  - "7.  Address Book Access Control\n   CardDAV servers MUST support and adhere to
    the requirements of WebDAV\n   ACL [RFC3744].  WebDAV ACL provides a framework
    for an extensible set\n   of privileges that can be applied to WebDAV collections
    and ordinary\n   resources.\n"
  - contents:
    - "7.1.  Additional Principal Properties\n   This section defines additional properties
      for WebDAV principal\n   resources as defined in [RFC3744].\n"
    - contents:
      - "7.1.1.  CARDDAV:addressbook-home-set Property\n   Name:  addressbook-home-set\n
        \  Namespace:  urn:ietf:params:xml:ns:carddav\n   Purpose:  Identifies the
        URL of any WebDAV collections that contain\n      address book collections
        owned by the associated principal\n      resource.\n   Protected:  MAY be
        protected if the server has fixed locations in\n      which address books
        are created.\n   COPY/MOVE behavior:  This property value MUST be preserved
        in COPY\n      and MOVE operations.\n   allprop behavior:  SHOULD NOT be returned
        by a PROPFIND DAV:allprop\n      request.\n   Description:  The CARDDAV:addressbook-home-set
        property is meant to\n      allow users to easily find the address book collections
        owned by\n      the principal.  Typically, users will group all the address
        book\n      collections that they own under a common collection.  This\n      property
        specifies the URL of collections that are either address\n      book collections
        or ordinary collections that have child or\n      descendant address book
        collections owned by the principal.\n   Definition:\n       <!ELEMENT addressbook-home-set
        (DAV:href*)>\n   Example:\n       <C:addressbook-home-set xmlns:D=\"DAV:\"\n
        \         xmlns:C=\"urn:ietf:params:xml:ns:carddav\">\n         <D:href>/bernard/addresses/</D:href>\n
        \      </C:addressbook-home-set>\n"
      title: 7.1.1.  CARDDAV:addressbook-home-set Property
    - contents:
      - "7.1.2.  CARDDAV:principal-address Property\n   Name:  principal-address\n
        \  Namespace:  urn:ietf:params:xml:ns:carddav\n   Purpose:  Identifies the
        URL of an address object resource that\n      corresponds to the user represented
        by the principal.\n   Protected:  MAY be protected if the server provides
        a fixed location\n      for principal addresses.\n   COPY/MOVE behavior:  This
        property value MUST be preserved in COPY\n      and MOVE operations.\n   allprop
        behavior:  SHOULD NOT be returned by a PROPFIND DAV:allprop\n      request.\n
        \  Description:  The CARDDAV:principal-address property is meant to\n      allow
        users to easily find contact information for users\n      represented by principals
        on the system.  This property specifies\n      the URL of the resource containing
        the corresponding contact\n      information.  The resource could be an address
        object resource in\n      an address book collection, or it could be a resource
        in a\n      \"regular\" collection.\n   Definition:\n       <!ELEMENT principal-address
        (DAV:href)>\n   Example:\n       <C:principal-address xmlns:D=\"DAV:\"\n          xmlns:C=\"urn:ietf:params:xml:ns:carddav\">\n
        \         <D:href>/system/cyrus.vcf</D:href>\n       </C:principal-address>\n"
      title: 7.1.2.  CARDDAV:principal-address Property
    title: 7.1.  Additional Principal Properties
  title: 7.  Address Book Access Control
- contents:
  - "8.  Address Book Reports\n   This section defines the reports that CardDAV servers
    MUST support on\n   address book collections and address object resources.\n   CardDAV
    servers MUST advertise support for these reports on all\n   address book collections
    and address object resources with the\n   DAV:supported-report-set property defined
    in Section 3.1.5 of\n   [RFC3253].  CardDAV servers MAY also advertise support
    for these\n   reports on ordinary collections.\n   Some of these reports allow
    address data (from possibly multiple\n   resources) to be returned.\n"
  - contents:
    - "8.1.  REPORT Method\n   The REPORT method (defined in Section 3.6 of [RFC3253])
      provides an\n   extensible mechanism for obtaining information about a resource.\n
      \  Unlike the PROPFIND method, which returns the value of one or more\n   named
      properties, the REPORT method can involve more complex\n   processing.  REPORT
      is valuable in cases where the server has access\n   to all of the information
      needed to perform the complex request (such\n   as a query), and where it would
      require multiple requests for the\n   client to retrieve the information needed
      to perform the same\n   request.\n   A server that supports this specification
      MUST support the\n   DAV:expand-property report (defined in Section 3.8 of [RFC3253]).\n"
    title: 8.1.  REPORT Method
  - contents:
    - "8.2.  Ordinary Collections\n   Servers MAY support the reports defined in this
      document on ordinary\n   collections (collections that are not address book
      collections) in\n   addition to address book collections or address object resources.
      \ In\n   computing responses to the reports on ordinary collections, servers\n
      \  MUST only consider address object resources contained in address book\n   collections
      that are targeted by the REPORT based on the value of the\n   Depth request
      header.\n"
    title: 8.2.  Ordinary Collections
  - contents:
    - "8.3.  Searching Text: Collations\n   Some of the reports defined in this section
      do text matches of\n   character strings provided by the client and compared
      to stored\n   address data.  Since vCard data is by default encoded in the UTF-8\n
      \  charset and may include characters outside of the US-ASCII charset\n   range
      in some property and parameter values, there is a need to\n   ensure that text
      matching follows well-defined rules.\n   To deal with this, this specification
      makes use of the IANA Collation\n   Registry defined in [RFC4790] to specify
      collations that may be used\n   to carry out the text comparison operations
      with a well-defined rule.\n   Collations supported by the server MUST support
      \"equality\" and\n   \"substring\" match operations as per [RFC4790], Section
      4.2, including\n   the \"prefix\" and \"suffix\" options for \"substring\" matching.
      \ CardDAV\n   uses these match options for \"equals\", \"contains\", \"starts-with\",
      and\n   \"ends-with\" match operations.\n   CardDAV servers are REQUIRED to
      support the \"i;ascii-casemap\"\n   [RFC4790] and \"i;unicode-casemap\" [RFC5051]
      collations and MAY\n   support other collations.\n   Servers MUST advertise
      the set of collations that they support via\n   the CARDDAV:supported-collation-set
      property defined on any resource\n   that supports reports that use collations.\n
      \  In the absence of a collation explicitly specified by the client, or\n   if
      the client specifies the \"default\" collation identifier (as\n   defined in
      [RFC4790], Section 3.1), the server MUST default to using\n   \"i;unicode-casemap\"
      as the collation.\n   Wildcards (as defined in [RFC4790], Section 3.2) MUST
      NOT be used in\n   the collation identifier.\n   If the client chooses a collation
      not supported by the server, the\n   server MUST respond with a CARDDAV:supported-collation
      precondition\n   error response.\n"
    - contents:
      - "8.3.1.  CARDDAV:supported-collation-set Property\n   Name:  supported-collation-set\n
        \  Namespace:  urn:ietf:params:xml:ns:carddav\n   Purpose:  Identifies the
        set of collations supported by the server\n      for text matching operations.\n
        \  Protected:  MUST be protected as it indicates support provided by the\n
        \     server.\n   COPY/MOVE behavior:  This property value MUST be preserved
        in COPY\n      and MOVE operations.\n   allprop behavior:  SHOULD NOT be returned
        by a PROPFIND DAV:allprop\n      request.\n   Description:  The CARDDAV:supported-collation-set
        property contains\n      two or more CARDDAV:supported-collation elements
        that specify the\n      identifiers of the collations supported by the server.\n
        \  Definition:\n         <!ELEMENT supported-collation-set (\n               supported-collation\n
        \              supported-collation\n               supported-collation*)>\n
        \        <!-- Both \"i;ascii-casemap\" and \"i;unicode-casemap\"\n              will
        be present -->\n         <!ELEMENT supported-collation (#PCDATA)>\n   Example:\n
        \     <C:supported-collation-set\n        xmlns:C=\"urn:ietf:params:xml:ns:carddav\">\n
        \       <C:supported-collation>i;ascii-casemap</C:supported-collation>\n        <C:supported-collation>i;octet</C:supported-collation>\n
        \       <C:supported-collation>i;unicode-casemap</C:supported-collation>\n
        \     </C:supported-collation-set>\n"
      title: 8.3.1.  CARDDAV:supported-collation-set Property
    title: '8.3.  Searching Text: Collations'
  - contents:
    - "8.4.  Partial Retrieval\n   Some address book reports defined in this document
      allow partial\n   retrieval of address object resources.  A CardDAV client can
      specify\n   what information to return in the body of an address book REPORT\n
      \  request.\n   A CardDAV client can request particular WebDAV property values,
      all\n   WebDAV property values, or a list of the names of the resource's\n   WebDAV
      properties.  A CardDAV client can also request address data to\n   be returned
      and whether all vCard properties should be returned or\n   only particular ones.
      \ See CARDDAV:address-data in Section 10.4.\n"
    title: 8.4.  Partial Retrieval
  - contents:
    - "8.5.  Non-Standard Properties and Parameters\n   Servers MUST support the use
      of non-standard vCard property or\n   parameter names in the CARDDAV:address-data
      XML element in address\n   book REPORT requests to allow clients to request
      that non-standard\n   properties and parameters be returned in the address data
      provided in\n   the response.\n   Servers MAY support the use of non-standard
      vCard property or\n   parameter names in the CARDDAV:prop-filter and CARDDAV:param-filter\n
      \  XML elements specified in the CARDDAV:filter XML element of address\n   book
      REPORT requests.\n   Servers MUST fail with the CARDDAV:supported-filter precondition
      if\n   an address book REPORT request uses a CARDDAV:prop-filter or\n   CARDDAV:param-filter
      XML element that makes reference to a non-\n   standard vCard property or parameter
      name on which the server does\n   not support queries.\n"
    title: 8.5.  Non-Standard Properties and Parameters
  - contents:
    - "8.6.  CARDDAV:addressbook-query Report\n   The CARDDAV:addressbook-query REPORT
      performs a search for all\n   address object resources that match a specified
      filter.  The response\n   of this report will contain all the WebDAV properties
      and address\n   object resource data specified in the request.  In the case
      of the\n   CARDDAV:address-data XML element, one can explicitly specify the\n
      \  vCard properties that should be returned in the address object\n   resource
      data that matches the filter.\n   The format of this report is modeled on the
      PROPFIND method.  The\n   request and response bodies of the CARDDAV:addressbook-query
      report\n   use XML elements that are also used by PROPFIND.  In particular,
      the\n   request can include XML elements to request WebDAV properties to be\n
      \  returned.  When that occurs, the response should follow the same\n   behavior
      as PROPFIND with respect to the DAV:multistatus response\n   elements used to
      return specific WebDAV property results.  For\n   instance, a request to retrieve
      the value of a WebDAV property that\n   does not exist is an error and MUST
      be noted with a response XML\n   element that contains a 404 (Not Found) status
      value.\n   Support for the CARDDAV:addressbook-query REPORT is REQUIRED.\n   Marshalling:\n
      \     The request body MUST be a CARDDAV:addressbook-query XML element\n      as
      defined in Section 10.3.\n      The request MUST include a Depth header.  The
      scope of the query\n      is determined by the value of the Depth header.  For
      example, to\n      query all address object resources in an address book collection,\n
      \     the REPORT would use the address book collection as the Request-\n      URI
      and specify a Depth of 1 or infinity.\n      The response body for a successful
      request MUST be a\n      DAV:multistatus XML element (i.e., the response uses
      the same\n      format as the response for PROPFIND).  In the case where there
      are\n      no response elements, the returned DAV:multistatus XML element is\n
      \     empty.\n      The response body for a successful CARDDAV:addressbook-query\n
      \     REPORT request MUST contain a DAV:response element for each\n      address
      object that matched the search filter.  Address data is\n      returned in the
      CARDDAV:address-data XML element inside the\n      DAV:propstat XML element.\n
      \  Preconditions:\n      (CARDDAV:supported-address-data): The attributes \"content-type\"\n
      \     and \"version\" of the CARDDAV:address-data XML element (see\n      Section
      10.4) specify a media type supported by the server for\n      address object
      resources.\n      (CARDDAV:supported-filter): The CARDDAV:prop-filter (see\n
      \     Section 10.5.1) and CARDDAV:param-filter (see Section 10.5.2) XML\n      elements
      used in the CARDDAV:filter XML element (see Section 10.5)\n      in the REPORT
      request only make reference to vCard properties and\n      parameters for which
      queries are supported by the server.  That\n      is, if the CARDDAV:filter
      element attempts to reference an\n      unsupported vCard property or parameter,
      this precondition is\n      violated.  A server SHOULD report the CARDDAV:prop-filter
      or\n      CARDDAV:param-filter for which it does not provide support.\n          <!ELEMENT
      supported-filter (prop-filter*,\n                                      param-filter*)>\n
      \     (CARDDAV:supported-collation): Any XML attribute specifying a\n      collation
      MUST specify a collation supported by the server as\n      described in Section
      8.3.\n   Postconditions:\n      (DAV:number-of-matches-within-limits): The number
      of matching\n      address object resources must fall within server-specific,\n
      \     predefined limits.  For example, this condition might be triggered\n      if
      a search specification would cause the return of an extremely\n      large number
      of responses.\n"
    - contents:
      - "8.6.1.  Limiting Results\n   A client can limit the number of results returned
        by the server\n   through use of the CARDDAV:limit element in the request
        body.  This\n   is useful when clients are only interested in a few matches
        or only\n   have limited space to display results to users and thus don't
        need\n   the overhead of receiving more than that.  When the results are\n
        \  truncated by the server, the server MUST follow the rules below for\n   indicating
        a result set truncation to the client.\n"
      title: 8.6.1.  Limiting Results
    - contents:
      - "8.6.2.  Truncation of Results\n   A server MAY limit the number of resources
        in a response, for\n   example, to limit the amount of work expended in processing
        a query,\n   or as the result of an explicit limit set by the client.  If
        the\n   result set is truncated because of such a limit, the response MUST\n
        \  use status code 207 (Multi-Status), return a DAV:multistatus response\n
        \  body, and indicate a status of 507 (Insufficient Storage) for the\n   Request-URI.
        \ That DAV:response element SHOULD include a DAV:error\n   element with the
        DAV:number-of-matches-within-limits precondition, as\n   defined in [RFC3744],
        Section 9.2.\n   The server SHOULD also include the partial results in additional\n
        \  DAV:response elements.  If a client-requested limit is being applied,\n
        \  the 507 response for the Request-URI MUST NOT be included in\n   calculating
        the limit (e.g., if the client requests that only a\n   single result be returned,
        and multiple matches are present, then the\n   DAV:multistatus response will
        include one DAV:response for the\n   matching resource and one DAV:response
        for the 507 status on the\n   Request-URI).\n"
      title: 8.6.2.  Truncation of Results
    - contents:
      - "8.6.3.  Example: Partial Retrieval of vCards Matching NICKNAME\n   In this
        example, the client requests that the server search for\n   address object
        resources that contain a NICKNAME property whose value\n   equals some specific
        text and return specific vCard properties for\n   those vCards found.  In
        addition, the DAV:getetag property is also\n   requested and returned as part
        of the response.\n   >> Request <<\n   REPORT /home/bernard/addressbook/ HTTP/1.1\n
        \  Host: addressbook.example.com\n   Depth: 1\n   Content-Type: text/xml;
        charset=\"utf-8\"\n   Content-Length: xxxx\n   <?xml version=\"1.0\" encoding=\"utf-8\"
        ?>\n   <C:addressbook-query xmlns:D=\"DAV:\"\n                     xmlns:C=\"urn:ietf:params:xml:ns:carddav\">\n
        \    <D:prop>\n       <D:getetag/>\n       <C:address-data>\n         <C:prop
        name=\"VERSION\"/>\n         <C:prop name=\"UID\"/>\n         <C:prop name=\"NICKNAME\"/>\n
        \        <C:prop name=\"EMAIL\"/>\n         <C:prop name=\"FN\"/>\n       </C:address-data>\n
        \    </D:prop>\n     <C:filter>\n       <C:prop-filter name=\"NICKNAME\">\n
        \        <C:text-match collation=\"i;unicode-casemap\"\n                       match-type=\"equals\"\n
        \        >me</C:text-match>\n       </C:prop-filter>\n     </C:filter>\n   </C:addressbook-query>\n
        \  >> Response <<\n   HTTP/1.1 207 Multi-Status\n   Date: Sat, 11 Nov 2006
        09:32:12 GMT\n   Content-Type: text/xml; charset=\"utf-8\"\n   Content-Length:
        xxxx\n   <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n   <D:multistatus xmlns:D=\"DAV:\"\n
        \                 xmlns:C=\"urn:ietf:params:xml:ns:carddav\">\n     <D:response>\n
        \      <D:href>/home/bernard/addressbook/v102.vcf</D:href>\n       <D:propstat>\n
        \        <D:prop>\n           <D:getetag>\"23ba4d-ff11fb\"</D:getetag>\n           <C:address-data>BEGIN:VCARD\n
        \  VERSION:3.0\n   NICKNAME:me\n   UID:34222-232@example.com\n   FN:Cyrus
        Daboo\n   EMAIL:daboo@example.com\n   END:VCARD\n   </C:address-data>\n         </D:prop>\n
        \        <D:status>HTTP/1.1 200 OK</D:status>\n       </D:propstat>\n     </D:response>\n
        \  </D:multistatus>\n"
      title: '8.6.3.  Example: Partial Retrieval of vCards Matching NICKNAME'
    - contents:
      - "8.6.4.  Example: Partial Retrieval of vCards Matching a Full Name or\n        Email
        Address\n   In this example, the client requests that the server search for\n
        \  address object resources that contain a FN property whose value\n   contains
        some specific text or that contain an EMAIL property whose\n   value contains
        other text and return specific vCard properties for\n   those vCards found.
        \ In addition, the DAV:getetag property is also\n   requested and returned
        as part of the response.\n   >> Request <<\n   REPORT /home/bernard/addressbook/
        HTTP/1.1\n   Host: addressbook.example.com\n   Depth: 1\n   Content-Type:
        text/xml; charset=\"utf-8\"\n   Content-Length: xxxx\n   <?xml version=\"1.0\"
        encoding=\"utf-8\" ?>\n   <C:addressbook-query xmlns:D=\"DAV:\"\n                     xmlns:C=\"urn:ietf:params:xml:ns:carddav\">\n
        \    <D:prop>\n       <D:getetag/>\n       <C:address-data>\n         <C:prop
        name=\"VERSION\"/>\n         <C:prop name=\"UID\"/>\n         <C:prop name=\"NICKNAME\"/>\n
        \        <C:prop name=\"EMAIL\"/>\n         <C:prop name=\"FN\"/>\n       </C:address-data>\n
        \    </D:prop>\n     <C:filter test=\"anyof\">\n       <C:prop-filter name=\"FN\">\n
        \        <C:text-match collation=\"i;unicode-casemap\"\n                       match-type=\"contains\"\n
        \        >daboo</C:text-match>\n       </C:prop-filter>\n       <C:prop-filter
        name=\"EMAIL\">\n         <C:text-match collation=\"i;unicode-casemap\"\n
        \                      match-type=\"contains\"\n         >daboo</C:text-match>\n
        \      </C:prop-filter>\n     </C:filter>\n   </C:addressbook-query>\n   >>
        Response <<\n   HTTP/1.1 207 Multi-Status\n   Date: Sat, 11 Nov 2006 09:32:12
        GMT\n   Content-Type: text/xml; charset=\"utf-8\"\n   Content-Length: xxxx\n
        \  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n   <D:multistatus xmlns:D=\"DAV:\"\n
        \                 xmlns:C=\"urn:ietf:params:xml:ns:carddav\">\n     <D:response>\n
        \      <D:href>/home/bernard/addressbook/v102.vcf</D:href>\n       <D:propstat>\n
        \        <D:prop>\n           <D:getetag>\"23ba4d-ff11fb\"</D:getetag>\n           <C:address-data>BEGIN:VCARD\n
        \  VERSION:3.0\n   NICKNAME:me\n   UID:34222-232@example.com\n   FN:David
        Boo\n   EMAIL:daboo@example.com\n   END:VCARD\n   </C:address-data>\n         </D:prop>\n
        \        <D:status>HTTP/1.1 200 OK</D:status>\n       </D:propstat>\n     </D:response>\n
        \    <D:response>\n       <D:href>/home/bernard/addressbook/v104.vcf</D:href>\n
        \      <D:propstat>\n         <D:prop>\n           <D:getetag>\"23ba4d-ff11fc\"</D:getetag>\n
        \          <C:address-data>BEGIN:VCARD\n   VERSION:3.0\n   NICKNAME:oliver\n
        \  UID:34222-23222@example.com\n   FN:Oliver Daboo\n   EMAIL:oliver@example.com\n
        \  END:VCARD\n   </C:address-data>\n         </D:prop>\n         <D:status>HTTP/1.1
        200 OK</D:status>\n       </D:propstat>\n     </D:response>\n   </D:multistatus>\n"
      title: '8.6.4.  Example: Partial Retrieval of vCards Matching a Full Name or'
    - contents:
      - "8.6.5.  Example: Truncated Results\n   In this example, the client requests
        that the server search for\n   address object resources that contain a FN
        property whose value\n   contains some specific text and return the DAV:getetag
        property for\n   two results only.  The server response includes a 507 status
        for the\n   Request-URI indicating that there were more than two resources
        that\n   matched the query, but that the server truncated the result set as\n
        \  requested by the client.\n   >> Request <<\n   REPORT /home/bernard/addressbook/
        HTTP/1.1\n   Host: addressbook.example.com\n   Depth: 1\n   Content-Type:
        text/xml; charset=\"utf-8\"\n   Content-Length: xxxx\n   <?xml version=\"1.0\"
        encoding=\"utf-8\" ?>\n   <C:addressbook-query xmlns:D=\"DAV:\"\n                     xmlns:C=\"urn:ietf:params:xml:ns:carddav\">\n
        \    <D:prop>\n       <D:getetag/>\n     </D:prop>\n     <C:filter test=\"anyof\">\n
        \      <C:prop-filter name=\"FN\">\n         <C:text-match collation=\"i;unicode-casemap\"\n
        \                      match-type=\"contains\"\n         >daboo</C:text-match>\n
        \      </C:prop-filter>\n     </C:filter>\n     <C:limit>\n       <C:nresults>2</C:nresults>\n
        \    </C:limit>\n   </C:addressbook-query>\n   >> Response <<\n   HTTP/1.1
        207 Multi-Status\n   Date: Sat, 11 Nov 2006 09:32:12 GMT\n   Content-Type:
        text/xml; charset=\"utf-8\"\n   Content-Length: xxxx\n   <?xml version=\"1.0\"
        encoding=\"utf-8\" ?>\n   <D:multistatus xmlns:D=\"DAV:\"\n                  xmlns:C=\"urn:ietf:params:xml:ns:carddav\">\n
        \    <D:response>\n       <D:href>/home/bernard/addressbook/</D:href>\n       <D:status>HTTP/1.1
        507 Insufficient Storage</D:status>\n       <D:error><D:number-of-matches-within-limits/></D:error>\n
        \      <D:responsedescription xml:lang=\"en\">\n         Only two matching
        records were returned\n       </D:responsedescription>\n     </D:response>\n
        \    <D:response>\n       <D:href>/home/bernard/addressbook/v102.vcf</D:href>\n
        \      <D:propstat>\n         <D:prop>\n           <D:getetag>\"23ba4d-ff11fb\"</D:getetag>\n
        \        </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n       </D:propstat>\n
        \    </D:response>\n     <D:response>\n       <D:href>/home/bernard/addressbook/v104.vcf</D:href>\n
        \      <D:propstat>\n         <D:prop>\n           <D:getetag>\"23ba4d-ff11fc\"</D:getetag>\n
        \        </D:prop>\n         <D:status>HTTP/1.1 200 OK</D:status>\n       </D:propstat>\n
        \    </D:response>\n   </D:multistatus>\n"
      title: '8.6.5.  Example: Truncated Results'
    title: 8.6.  CARDDAV:addressbook-query Report
  - contents:
    - "8.7.  CARDDAV:addressbook-multiget Report\n   The CARDDAV:addressbook-multiget
      REPORT is used to retrieve specific\n   address object resources from within
      a collection, if the Request-URI\n   is a collection, or to retrieve a specific
      address object resource,\n   if the Request-URI is an address object resource.
      \ This report is\n   similar to the CARDDAV:addressbook-query REPORT (see Section
      8.6),\n   except that it takes a list of DAV:href elements instead of a\n   CARDDAV:filter
      element to determine which address object resources to\n   return.\n   Support
      for the addressbook-multiget REPORT is REQUIRED.\n   Marshalling:\n      The
      request body MUST be a CARDDAV:addressbook-multiget XML\n      element (see
      Section 10.7), which MUST contain at least one\n      DAV:href XML element and
      one optional CARDDAV:address-data element\n      as defined in Section 10.4.
      \ If DAV:href elements are present, the\n      scope of the request is the set
      of resources identified by these\n      elements, which all need to be members
      (not necessarily internal\n      members) of the resource identified by the
      Request-URI.\n      Otherwise, the scope is the resource identified by the Request-URI\n
      \     itself.\n      The request MUST include a Depth: 0 header; however, the
      actual\n      scope of the REPORT is determined as described above.\n      The
      response body for a successful request MUST be a\n      DAV:multistatus XML
      element.\n      The response body for a successful CARDDAV:addressbook-multiget\n
      \     REPORT request MUST contain a DAV:response element for each\n      address
      object resource referenced by the provided set of DAV:href\n      elements.
      \ Address data is returned in the CARDDAV:address-data\n      element inside
      the DAV:prop element.\n      In the case of an error accessing any of the provided
      DAV:href\n      resources, the server MUST return the appropriate error status\n
      \     code in the DAV:status element of the corresponding DAV:response\n      element.\n
      \  Preconditions:\n      (CARDDAV:supported-address-data): The attributes \"content-type\"\n
      \     and \"version\" of the CARDDAV:address-data XML elements (see\n      Section
      10.4) specify a media type supported by the server for\n      address object
      resources.\n   Postconditions:\n      None.\n"
    - contents:
      - "8.7.1.  Example: CARDDAV:addressbook-multiget Report\n   In this example,
        the client requests the server to return specific\n   vCard properties of
        the address components referenced by specific\n   URIs.  In addition, the
        DAV:getetag property is also requested and\n   returned as part of the response.
        \ Note that, in this example, the\n   resource at\n   http://addressbook.example.com/home/bernard/addressbook/vcf1.vcf
        does\n   not exist, resulting in an error status response.\n   >> Request
        <<\n   REPORT /home/bernard/addressbook/ HTTP/1.1\n   Host: addressbook.example.com\n
        \  Depth: 1\n   Content-Type: text/xml; charset=\"utf-8\"\n   Content-Length:
        xxxx\n   <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n   <C:addressbook-multiget
        xmlns:D=\"DAV:\"\n                        xmlns:C=\"urn:ietf:params:xml:ns:carddav\">\n
        \    <D:prop>\n       <D:getetag/>\n       <C:address-data>\n         <C:prop
        name=\"VERSION\"/>\n         <C:prop name=\"UID\"/>\n         <C:prop name=\"NICKNAME\"/>\n
        \        <C:prop name=\"EMAIL\"/>\n         <C:prop name=\"FN\"/>\n       </C:address-data>\n
        \    </D:prop>\n     <D:href>/home/bernard/addressbook/vcf102.vcf</D:href>\n
        \    <D:href>/home/bernard/addressbook/vcf1.vcf</D:href>\n   </C:addressbook-multiget>\n
        \  >> Response <<\n   HTTP/1.1 207 Multi-Status\n   Date: Sat, 11 Nov 2006
        09:32:12 GMT\n   Content-Type: text/xml; charset=\"utf-8\"\n   Content-Length:
        xxxx\n   <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n   <D:multistatus xmlns:D=\"DAV:\"\n
        \                 xmlns:C=\"urn:ietf:params:xml:ns:carddav\">\n     <D:response>\n
        \      <D:href>/home/bernard/addressbook/vcf102.vcf</D:href>\n       <D:propstat>\n
        \        <D:prop>\n           <D:getetag>\"23ba4d-ff11fb\"</D:getetag>\n           <C:address-data>BEGIN:VCARD\n
        \  VERSION:3.0\n   NICKNAME:me\n   UID:34222-232@example.com\n   FN:Cyrus
        Daboo\n   EMAIL:daboo@example.com\n   END:VCARD\n   </C:address-data>\n         </D:prop>\n
        \        <D:status>HTTP/1.1 200 OK</D:status>\n       </D:propstat>\n     </D:response>\n
        \    <D:response>\n       <D:href>/home/bernard/addressbook/vcf1.vcf</D:href>\n
        \      <D:status>HTTP/1.1 404 Resource not found</D:status>\n     </D:response>\n
        \  </D:multistatus>\n"
      title: '8.7.1.  Example: CARDDAV:addressbook-multiget Report'
    - contents:
      - "8.7.2.  Example: CARDDAV:addressbook-multiget Report\n   In this example,
        the client requests the server to return vCard v4.0\n   data of the address
        components referenced by specific URIs.  In\n   addition, the DAV:getetag
        property is also requested and returned as\n   part of the response.  Note
        that, in this example, the resource at\n   http://addressbook.example.com/home/bernard/addressbook/vcf3.vcf\n
        \  exists but in a media type format that the server is unable to\n   convert,
        resulting in an error status response.\n   >> Request <<\n   REPORT /home/bernard/addressbook/
        HTTP/1.1\n   Host: addressbook.example.com\n   Depth: 1\n   Content-Type:
        text/xml; charset=\"utf-8\"\n   Content-Length: xxxx\n   <?xml version=\"1.0\"
        encoding=\"utf-8\" ?>\n   <C:addressbook-multiget xmlns:D=\"DAV:\"\n                        xmlns:C=\"urn:ietf:params:xml:ns:carddav\">\n
        \    <D:prop>\n       <D:getetag/>\n       <C:address-data content-type='text/vcard'
        version='4.0'/>\n     </D:prop>\n     <D:href>/home/bernard/addressbook/vcf3.vcf</D:href>\n
        \  </C:addressbook-multiget>\n   >> Response <<\n   HTTP/1.1 207 Multi-Status\n
        \  Date: Sat, 11 Nov 2006 09:32:12 GMT\n   Content-Type: text/xml; charset=\"utf-8\"\n
        \  Content-Length: xxxx\n   <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n
        \  <D:multistatus xmlns:D=\"DAV:\"\n                  xmlns:C=\"urn:ietf:params:xml:ns:carddav\">\n
        \    <D:response>\n       <D:href>/home/bernard/addressbook/vcf3.vcf</D:href>\n
        \      <D:status>HTTP/1.1 415 Unsupported Media Type</D:status>\n       <D:error><C:supported-address-data-conversion/></D:error>\n
        \      <D:responsedescription>Unable to convert from vCard v3.0\n       to
        vCard v4.0</D:responsedescription>\n     </D:response>\n   </D:multistatus>\n"
      title: '8.7.2.  Example: CARDDAV:addressbook-multiget Report'
    title: 8.7.  CARDDAV:addressbook-multiget Report
  title: 8.  Address Book Reports
- contents:
  - '9.  Client Guidelines

    '
  - contents:
    - "9.1.  Restrict the Properties Returned\n   Clients may not need all the properties
      in a vCard object when\n   presenting information to the user, or looking up
      specific items for\n   their email address, for example.  Since some property
      data can be\n   large (e.g., PHOTO or SOUND with in-line content) clients can
      choose\n   to ignore those by only requesting the specific items it knows it\n
      \  will use, through use of the CARDDAV:address-data XML element in the\n   relevant
      reports.\n   However, if a client needs to make a change to a vCard, it can
      only\n   change the entire vCard data via a PUT request.  There is no way to\n
      \  incrementally make a change to a set of properties within a vCard\n   object
      resource.  As a result, the client will have to cache the\n   entire set of
      properties on a resource that is being changed.\n"
    title: 9.1.  Restrict the Properties Returned
  - contents:
    - "9.2.  Avoiding Lost Updates\n   When resources are accessed by multiple clients,
      the possibility of\n   clients overwriting each other's changes exists.  To
      alleviate this,\n   clients SHOULD use the If-Match request header on PUT requests
      with\n   the ETag of the previously retrieved resource data to check whether\n
      \  the resource was modified since it was previously retrieved.  If a\n   precondition
      failure occurs, clients need to reload the resource and\n   go through their
      own merge or conflict resolution process before\n   writing back the data (again
      using the If-Match check).\n"
    title: 9.2.  Avoiding Lost Updates
  - contents:
    - "9.3.  Client Configuration\n   When CardDAV clients need to be configured,
      the key piece of\n   information that they require is the principal-URL of the
      user whose\n   address book information is desired.  Servers SHOULD support
      the\n   DAV:current-user-principal-URL property as defined in [RFC5397] to\n
      \  give clients a fast way to locate user principals.\n   Given support for
      SRV records (Section 11) and DAV:current-user-\n   principal-URL [RFC5397],
      users only need enter a user identifier,\n   host name, and password to configure
      their client.  The client would\n   take the host name and do an SRV lookup
      to locate the CardDAV server,\n   then execute an authenticated PROPFIND on
      the root/resource looking\n   for the DAV:current-user-principal-URL property.
      \ The value returned\n   gives the client direct access to the user's principal-URL
      and from\n   there all the related CardDAV properties needed to locate address\n
      \  books.\n"
    title: 9.3.  Client Configuration
  - contents:
    - "9.4.  Finding Other Users' Address Books\n   For use cases of address book
      sharing, one might wish to find the\n   address book belonging to another user.
      \ To find other users' address\n   books on the same server, the DAV:principal-property-search
      REPORT\n   [RFC3744] can be used to search principals for matching properties\n
      \  and return specified properties for the matching principal resources.\n   To
      search for an address book owned by a user named \"Laurie\", the\n   REPORT
      request body would look like this:\n   <?xml version=\"1.0\" encoding=\"utf-8\"
      ?>\n   <D:principal-property-search xmlns:D=\"DAV:\">\n     <D:property-search>\n
      \      <D:prop>\n         <D:displayname/>\n       </D:prop>\n       <D:match>Laurie</D:match>\n
      \    </D:property-search>\n     <D:prop>\n       <C:addressbook-home-set\n          xmlns:C=\"urn:ietf:params:xml:ns:carddav\"/>\n
      \      <D:displayname/>\n     </D:prop>\n   </D:principal-property-search>\n
      \  The server performs a case-sensitive or caseless search for a\n   matching
      string subset of \"Laurie\" within the DAV:displayname\n   property.  Thus,
      the server might return \"Laurie Dusseault\", \"Laurier\n   Desruisseaux\",
      or \"Wilfrid Laurier\" all as matching DAV:displayname\n   values, and the address
      books for each of these.\n"
    title: 9.4.  Finding Other Users' Address Books
  title: 9.  Client Guidelines
- contents:
  - '10.  XML Element Definitions

    '
  - contents:
    - "10.1.  CARDDAV:addressbook XML Element\n   Name:  addressbook\n   Namespace:
      \ urn:ietf:params:xml:ns:carddav\n   Purpose:  Specifies the resource type of
      an address book collection.\n   Description:  See Section 5.2.\n   Definition:\n
      \      <!ELEMENT addressbook EMPTY>\n"
    title: 10.1.  CARDDAV:addressbook XML Element
  - contents:
    - "10.2.  CARDDAV:supported-collation XML Element\n   Name:  supported-collation\n
      \  Namespace:  urn:ietf:params:xml:ns:carddav\n   Purpose:  Identifies a single
      collation via its collation identifier\n      as defined by [RFC4790].\n   Description:
      \ The CARDDAV:supported-collation contains the text of a\n      collation identifier
      as described in Section 8.3.1.\n   Definition:\n       <!ELEMENT supported-collation
      (#PCDATA)>\n       <!-- PCDATA value: collation identifier -->\n"
    title: 10.2.  CARDDAV:supported-collation XML Element
  - contents:
    - "10.3.  CARDDAV:addressbook-query XML Element\n   Name:  addressbook-query\n
      \  Namespace:  urn:ietf:params:xml:ns:carddav\n   Purpose:  Defines a report
      for querying address book data\n   Description:  See Section 8.6.\n   Definition:\n
      \      <!ELEMENT addressbook-query ((DAV:allprop |\n                                     DAV:propname
      |\n                                     DAV:prop)?, filter, limit?)>\n"
    title: 10.3.  CARDDAV:addressbook-query XML Element
  - contents:
    - "10.4.  CARDDAV:address-data XML Element\n   Name:  address-data\n   Namespace:
      \ urn:ietf:params:xml:ns:carddav\n   Purpose:  Specifies one of the following:\n
      \     1.  The parts of an address object resource that should be\n          returned
      by a given address book REPORT request, and the media\n          type and version
      for the returned data; or\n      2.  The content of an address object resource
      in a response to an\n          address book REPORT request.\n   Description:
      \ When used in an address book REPORT request, the\n      CARDDAV:address-data
      XML element specifies which parts of address\n      object resources need to
      be returned in the response.  If the\n      CARDDAV:address-data XML element
      doesn't contain any CARDDAV:prop\n      elements, address object resources will
      be returned in their\n      entirety.  Additionally, a media type and version
      can be specified\n      to request that the server return the data in that format
      if\n      possible.\n      Finally, when used in an address book REPORT response,
      the\n      CARDDAV:address-data XML element specifies the content of an\n      address
      object resource.  Given that XML parsers normalize the\n      two-character
      sequence CRLF (US-ASCII decimal 13 and US-ASCII\n      decimal 10) to a single
      LF character (US-ASCII decimal 10), the CR\n      character (US-ASCII decimal
      13) MAY be omitted in address object\n      resources specified in the CARDDAV:address-data
      XML element.\n      Furthermore, address object resources specified in the\n
      \     CARDDAV:address-data XML element MAY be invalid per their media\n      type
      specification if the CARDDAV:address-data XML element part of\n      the address
      book REPORT request did not specify required vCard\n      properties (e.g.,
      UID, etc.) or specified a CARDDAV:prop XML\n      element with the \"novalue\"
      attribute set to \"yes\".\n   Note:  The CARDDAV:address-data XML element is
      specified in requests\n      and responses inside the DAV:prop XML element as
      if it were a\n      WebDAV property.  However, the CARDDAV:address-data XML
      element is\n      not a WebDAV property and as such it is not returned in PROPFIND\n
      \     responses nor used in PROPPATCH requests.\n   Note:  The address data
      embedded within the CARDDAV:address-data XML\n      element MUST follow the
      standard XML character data encoding\n      rules, including use of &lt;, &gt;,
      &amp; etc., entity encoding or\n      the use of a <![CDATA[ ... ]]> construct.
      \ In the latter case, the\n      vCard data cannot contain the character sequence
      \"]]>\", which is\n      the end delimiter for the CDATA section.\n   Definition:\n
      \      <!ELEMENT address-data (allprop | prop*)>\n       when nested in the
      DAV:prop XML element in an address book\n       REPORT request to specify which
      parts of address object\n       resources should be returned in the response;\n
      \      <!ELEMENT address-data (#PCDATA)>\n       <!-- PCDATA value: address
      data -->\n       when nested in the DAV:prop XML element in an address book\n
      \      REPORT response to specify the content of a returned\n       address
      object resource.\n       <!ATTLIST address-data content-type CDATA \"text/vcard\"\n
      \                            version CDATA \"3.0\">\n       <!-- content-type
      value: a MIME media type -->\n       <!-- version value: a version string -->\n
      \      attributes can be used on each variant of the\n       CALDAV:address-data
      XML element.\n"
    - contents:
      - "10.4.1.  CARDDAV:allprop XML Element\n   Name:  allprop\n   Namespace:  urn:ietf:params:xml:ns:carddav\n
        \  Purpose:  Specifies that all vCard properties shall be returned.\n   Description:
        \ This element can be used when the client wants all\n      vCard properties
        of components returned by a report.\n   Definition:\n       <!ELEMENT allprop
        EMPTY>\n   Note: The CARDDAV:allprop element defined here has the same name
        as\n   the DAV:allprop element defined in WebDAV.  However, the\n   CARDDAV:allprop
        element defined here uses the\n   \"urn:ietf:params:xml:ns:carddav\" namespace,
        as opposed to the \"DAV:\"\n   namespace used for the DAV:allprop element
        defined in WebDAV.\n"
      title: 10.4.1.  CARDDAV:allprop XML Element
    - contents:
      - "10.4.2.  CARDDAV:prop XML Element\n   Name:  prop\n   Namespace:  urn:ietf:params:xml:ns:carddav\n
        \  Purpose:  Defines which vCard properties to return in the response.\n   Description:
        \ The \"name\" attribute specifies the name of the vCard\n      property to
        return (e.g., \"NICKNAME\").  The \"novalue\" attribute\n      can be used
        by clients to request that the actual value of the\n      property not be
        returned (if the \"novalue\" attribute is set to\n      \"yes\").  In that
        case, the server will return just the vCard\n      property name and any vCard
        parameters and a trailing \":\" without\n      the subsequent value data.\n
        \     vCard allows a \"group\" prefix to appear before a property name in\n
        \     the vCard data.  When the \"name\" attribute does not specify a\n      group
        prefix, it MUST match properties in the vCard data without a\n      group
        prefix or with any group prefix.  When the \"name\" attribute\n      includes
        a group prefix, it MUST match properties that have\n      exactly the same
        group prefix and name.  For example, a \"name\" set\n      to \"TEL\" will
        match \"TEL\", \"X-ABC.TEL\", and \"X-ABC-1.TEL\" vCard\n      properties.
        \ A \"name\" set to \"X-ABC.TEL\" will match an \"X-ABC.TEL\"\n      vCard
        property only; it will not match \"TEL\" or \"X-ABC-1.TEL\".\n   Definition:\n
        \      <!ELEMENT prop EMPTY>\n       <!ATTLIST prop name CDATA #REQUIRED\n
        \                 novalue (yes | no) \"no\">\n       <!-- name value: a vCard
        property name -->\n       <!-- novalue value: \"yes\" or \"no\" -->\n   Note:
        The CARDDAV:prop element defined here has the same name as the\n   DAV:prop
        element defined in WebDAV.  However, the CARDDAV:prop\n   element defined
        here uses the \"urn:ietf:params:xml:ns:carddav\"\n   namespace, as opposed
        to the \"DAV:\" namespace used for the DAV:prop\n   element defined in WebDAV.\n"
      title: 10.4.2.  CARDDAV:prop XML Element
    title: 10.4.  CARDDAV:address-data XML Element
  - contents:
    - "10.5.  CARDDAV:filter XML Element\n   Name:  filter\n   Namespace:  urn:ietf:params:xml:ns:carddav\n
      \  Purpose:  Determines which matching objects are returned.\n   Description:
      \ The \"filter\" element specifies the search filter used\n      to match address
      objects that should be returned by a report.  The\n      \"test\" attribute
      specifies whether any (logical OR) or all\n      (logical AND) of the prop-filter
      tests need to match in order for\n      the overall filter to match.\n   Definition:\n
      \      <!ELEMENT filter (prop-filter*)>\n       <!ATTLIST filter test (anyof
      | allof) \"anyof\">\n       <!-- test value:\n                 anyof logical
      OR for prop-filter matches\n                 allof logical AND for prop-filter
      matches -->\n"
    - contents:
      - "10.5.1.  CARDDAV:prop-filter XML Element\n   Name:  prop-filter\n   Namespace:
        \ urn:ietf:params:xml:ns:carddav\n   Purpose:  Limits the search to specific
        vCard properties.\n   Description:  The CARDDAV:prop-filter XML element specifies
        search\n      criteria on a specific vCard property (e.g., \"NICKNAME\").
        \ An\n      address object is said to match a CARDDAV:prop-filter if:\n      *
        \ A vCard property of the type specified by the \"name\" attribute\n         exists,
        and the CARDDAV:prop-filter is empty, or it matches any\n         specified
        CARDDAV:text-match or CARDDAV:param-filter\n         conditions.  The \"test\"
        attribute specifies whether any\n         (logical OR) or all (logical AND)
        of the text-filter and param-\n         filter tests need to match in order
        for the overall filter to\n         match.\n      or:\n      *  A vCard property
        of the type specified by the \"name\" attribute\n         does not exist,
        and the CARDDAV:is-not-defined element is\n         specified.\n      vCard
        allows a \"group\" prefix to appear before a property name in\n      the vCard
        data.  When the \"name\" attribute does not specify a\n      group prefix,
        it MUST match properties in the vCard data without a\n      group prefix or
        with any group prefix.  When the \"name\" attribute\n      includes a group
        prefix, it MUST match properties that have\n      exactly the same group prefix
        and name.  For example, a \"name\" set\n      to \"TEL\" will match \"TEL\",
        \"X-ABC.TEL\", \"X-ABC-1.TEL\" vCard\n      properties.  A \"name\" set to
        \"X-ABC.TEL\" will match an \"X-ABC.TEL\"\n      vCard property only, it will
        not match \"TEL\" or \"X-ABC-1.TEL\".\n   Definition:\n       <!ELEMENT prop-filter
        (is-not-defined |\n                              (text-match*, param-filter*))>\n
        \      <!ATTLIST prop-filter name CDATA #REQUIRED\n                             test
        (anyof | allof) \"anyof\">\n       <!-- name value: a vCard property name
        (e.g., \"NICKNAME\")\n         test value:\n             anyof logical OR
        for text-match/param-filter matches\n             allof logical AND for text-match/param-filter
        matches -->\n"
      title: 10.5.1.  CARDDAV:prop-filter XML Element
    - contents:
      - "10.5.2.  CARDDAV:param-filter XML Element\n   Name:  param-filter\n   Namespace:
        \ urn:ietf:params:xml:ns:carddav\n   Purpose:  Limits the search to specific
        parameter values.\n   Description:  The CARDDAV:param-filter XML element specifies
        search\n      criteria on a specific vCard property parameter (e.g., TYPE)
        in\n      the scope of a given CARDDAV:prop-filter.  A vCard property is\n
        \     said to match a CARDDAV:param-filter if:\n      *  A parameter of the
        type specified by the \"name\" attribute\n         exists, and the CARDDAV:param-filter
        is empty, or it matches\n         the CARDDAV:text-match conditions if specified.\n
        \     or:\n      *  A parameter of the type specified by the \"name\" attribute
        does\n         not exist, and the CARDDAV:is-not-defined element is specified.\n
        \  Definition:\n       <!ELEMENT param-filter (is-not-defined | text-match)?>\n
        \      <!ATTLIST param-filter name CDATA #REQUIRED>\n       <!-- name value:
        a property parameter name (e.g., \"TYPE\") -->\n"
      title: 10.5.2.  CARDDAV:param-filter XML Element
    - contents:
      - "10.5.3.  CARDDAV:is-not-defined XML Element\n   Name:  is-not-defined\n   Namespace:
        \ urn:ietf:params:xml:ns:carddav\n   Purpose:  Specifies that a match should
        occur if the enclosing vCard\n      property or parameter does not exist.\n
        \  Description:  The CARDDAV:is-not-defined XML element specifies that a\n
        \     match occurs if the enclosing vCard property or parameter value\n      specified
        in an address book REPORT request does not exist in the\n      address data
        being tested.\n   Definition:\n       <!ELEMENT is-not-defined EMPTY>\n"
      title: 10.5.3.  CARDDAV:is-not-defined XML Element
    - contents:
      - "10.5.4.  CARDDAV:text-match XML Element\n   Name:  text-match\n   Namespace:
        \ urn:ietf:params:xml:ns:carddav\n   Purpose:  Specifies a substring match
        on a vCard property or\n      parameter value.\n   Description:  The CARDDAV:text-match
        XML element specifies text used\n      for a substring match against the vCard
        property or parameter\n      value specified in an address book REPORT request.\n
        \     The \"collation\" attribute is used to select the collation that the\n
        \     server MUST use for character string matching.  In the absence of\n
        \     this attribute, the server MUST use the \"i;unicode-casemap\"\n      collation.\n
        \     The \"negate-condition\" attribute is used to indicate that this\n      test
        returns a match if the text matches, when the attribute value\n      is set
        to \"no\", or return a match if the text does not match, if\n      the attribute
        value is set to \"yes\".  For example, this can be\n      used to match components
        with a CATEGORIES property not set to\n      PERSON.\n      The \"match-type\"
        attribute is used to indicate the type of match\n      operation to use.  Possible
        choices are:\n         \"equals\" - an exact match to the target string\n
        \        \"contains\" - a substring match, matching anywhere within the\n
        \        target string\n         \"starts-with\" - a substring match, matching
        only at the start\n         of the target string\n         \"ends-with\" -
        a substring match, matching only at the end of\n         the target string\n
        \  Definition:\n       <!ELEMENT text-match (#PCDATA)>\n       <!-- PCDATA
        value: string -->\n       <!ATTLIST text-match\n          collation        CDATA
        \"i;unicode-casemap\"\n          negate-condition (yes | no) \"no\"\n          match-type
        (equals|contains|starts-with|ends-with) \"contains\">\n"
      title: 10.5.4.  CARDDAV:text-match XML Element
    title: 10.5.  CARDDAV:filter XML Element
  - contents:
    - "10.6.  CARDDAV:limit XML Element\n   Name:  limit\n   Namespace:  urn:ietf:params:xml:ns:carddav\n
      \  Purpose:  Specifies different types of limits that can be applied to\n      the
      results returned by the server.\n   Description:  The CARDDAV:limit XML element
      can be used to specify\n      different types of limits that the client can
      request the server\n      to apply to the results returned by the server.  Currently,
      only\n      the CARDDAV:nresults limit can be used; other types of limit could\n
      \     be defined in the future.\n   Definition:\n       <!ELEMENT limit (nresults)>\n"
    - contents:
      - "10.6.1.  CARDDAV:nresults XML Element\n   Name:  nresults\n   Namespace:
        \ urn:ietf:params:xml:ns:carddav\n   Purpose:  Specifies a limit on the number
        of results returned by the\n      server.\n   Description:  The CARDDAV:nresults
        XML element contains a requested\n      maximum number of DAV:response elements
        to be returned in the\n      response body of a query.  The server MAY disregard
        this limit.\n      The value of this element is an unsigned integer.\n   Definition:\n
        \      <!ELEMENT nresults (#PCDATA)>\n       <!-- nresults value: unsigned
        integer, must be digits -->\n"
      title: 10.6.1.  CARDDAV:nresults XML Element
    title: 10.6.  CARDDAV:limit XML Element
  - contents:
    - "10.7.  CARDDAV:addressbook-multiget XML Element\n   Name:  addressbook-multiget\n
      \  Namespace:  urn:ietf:params:xml:ns:carddav\n   Purpose:  CardDAV report used
      to retrieve specific address objects\n      via their URIs.\n   Description:
      \ See Section 8.7.\n   Definition:\n       <!ELEMENT addressbook-multiget ((DAV:allprop
      |\n                                        DAV:propname |\n                                        DAV:prop)?,\n
      \                                       DAV:href+)>\n"
    title: 10.7.  CARDDAV:addressbook-multiget XML Element
  title: 10.  XML Element Definitions
- contents:
  - "11.  Service Discovery via SRV Records\n   [RFC2782] defines a DNS-based service
    discovery protocol that has\n   been widely adopted as a means of locating particular
    services within\n   a local area network and beyond, using SRV RRs.\n   This specification
    adds two service types for use with SRV records:\n   carddav:  Identifies a CardDAV
    server that uses HTTP without TLS\n      [RFC2818].\n   carddavs:  Identifies
    a CardDAV server that uses HTTP with TLS\n      [RFC2818].\n   Example: non-TLS
    service record\n       _carddav._tcp     SRV 0 1 80 addressbook.example.com.\n
    \  Example: TLS service\n       _carddavs._tcp    SRV 0 1 443 addressbook.example.com.\n"
  title: 11.  Service Discovery via SRV Records
- contents:
  - "12.  Internationalization Considerations\n   CardDAV allows internationalized
    strings to be stored and retrieved\n   for the description of address book collections
    (see Section 6.2.1).\n   The CARDDAV:addressbook-query REPORT (Section 8.6) includes
    a text\n   searching option controlled by the CARDDAV:text-match element and\n
    \  details of character handling are covered in the description of that\n   element
    (see Section 10.5.4).\n"
  title: 12.  Internationalization Considerations
- contents:
  - "13.  Security Considerations\n   HTTP protocol transactions are sent in the clear
    over the network\n   unless protection from snooping is negotiated.  This can
    be\n   accomplished by use of TLS as defined in [RFC2818].  In particular,\n   if
    HTTP Basic authentication [RFC2617] is available, the server MUST\n   allow TLS
    to be used at the same time, and it SHOULD prevent use of\n   Basic authentication
    when TLS is not in use.  Clients SHOULD use TLS\n   whenever possible.\n   With
    the ACL extension [RFC3744] present, WebDAV allows control over\n   who can access
    (read or write) any resource on the WebDAV server.  In\n   addition, WebDAV ACL
    provides for an \"inheritance\" mechanism, whereby\n   resources may inherit access
    privileges from other resources.  Often,\n   the \"other\" resource is a parent
    collection of the resource itself.\n   Servers are able to support address books
    that are \"private\"\n   (accessible only to the \"owner\"), \"shared\" (accessible
    to the owner\n   and other specified authenticated users), and \"public\" (accessible
    to\n   any authenticated or unauthenticated users).  When provisioning\n   address
    books of a particular type, servers MUST ensure that the\n   correct privileges
    are applied on creation.  In particular, private\n   and shared address books
    MUST NOT be accessible by unauthenticated\n   users (to prevent data from being
    automatically searched or indexed\n   by web \"crawlers\").\n   Clients SHOULD
    warn users in an appropriate fashion when they copy or\n   move address data from
    a private address book to a shared address\n   book or public address book.  Clients
    SHOULD provide a clear\n   indication as to which address books are private, shared,
    or public.\n   Clients SHOULD provide an appropriate warning when changing access\n
    \  privileges for a private or shared address book with data so as to\n   allow
    unauthenticated users access.\n   This specification currently relies on standard
    HTTP authentication\n   mechanisms for identifying users.  These comprise Basic
    and Digest\n   authentication [RFC2617] as well as TLS [RFC2818] using client-side\n
    \  certificates.\n"
  title: 13.  Security Considerations
- contents:
  - "14.  IANA Consideration\n   This document uses a URN to describe a new XML namespace
    conforming\n   to the registry mechanism described in [RFC3688].\n"
  - contents:
    - "14.1.  Namespace Registration\n   Registration request for the carddav namespace:\n
      \  URI: urn:ietf:params:xml:ns:carddav\n   Registrant Contact: The IESG <iesg@ietf.org>\n
      \  XML: None - not applicable for namespace registrations.\n"
    title: 14.1.  Namespace Registration
  title: 14.  IANA Consideration
- contents:
  - "15.  Acknowledgments\n   Thanks go to Lisa Dusseault and Bernard Desruisseaux
    for their work\n   on CalDAV, on which CardDAV is heavily based.  The following\n
    \  individuals contributed their ideas and support for writing this\n   specification:
    Mike Douglass, Stefan Eissing, Helge Hess, Arnaud\n   Quillaud, Julian Reschke,
    Elias Sinderson, Greg Stein, Wilfredo\n   Sanchez, and Simon Vaillancourt.\n"
  title: 15.  Acknowledgments
- contents:
  - '16.  References

    '
  - contents:
    - "16.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March
      1997.\n   [RFC2426]  Dawson, F. and T. Howes, \"vCard MIME Directory Profile\",\n
      \             RFC 2426, September 1998.\n   [RFC2616]  Fielding, R., Gettys,
      J., Mogul, J., Frystyk, H.,\n              Masinter, L., Leach, P., and T. Berners-Lee,
      \"Hypertext\n              Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.\n
      \  [RFC2617]  Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,\n              Leach,
      P., Luotonen, A., and L. Stewart, \"HTTP\n              Authentication: Basic
      and Digest Access Authentication\",\n              RFC 2617, June 1999.\n   [RFC2782]
      \ Gulbrandsen, A., Vixie, P., and L. Esibov, \"A DNS RR for\n              specifying
      the location of services (DNS SRV)\", RFC 2782,\n              February 2000.\n
      \  [RFC2818]  Rescorla, E., \"HTTP Over TLS\", RFC 2818, May 2000.\n   [RFC3253]
      \ Clemm, G., Amsden, J., Ellison, T., Kaler, C., and J.\n              Whitehead,
      \"Versioning Extensions to WebDAV\n              (Web Distributed Authoring
      and Versioning)\", RFC 3253,\n              March 2002.\n   [RFC3688]  Mealling,
      M., \"The IETF XML Registry\", BCP 81, RFC 3688,\n              January 2004.\n
      \  [RFC3744]  Clemm, G., Reschke, J., Sedlar, E., and J. Whitehead, \"Web\n
      \             Distributed Authoring and Versioning (WebDAV)\n              Access
      Control Protocol\", RFC 3744, May 2004.\n   [RFC4790]  Newman, C., Duerst, M.,
      and A. Gulbrandsen, \"Internet\n              Application Protocol Collation
      Registry\", RFC 4790,\n              March 2007.\n   [RFC4918]  Dusseault, L.,
      \"HTTP Extensions for Web Distributed\n              Authoring and Versioning
      (WebDAV)\", RFC 4918, June 2007.\n   [RFC5051]  Crispin, M., \"i;unicode-casemap
      - Simple Unicode Collation\n              Algorithm\", RFC 5051, October 2007.\n
      \  [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)
      Protocol Version 1.2\", RFC 5246, August 2008.\n   [RFC5280]  Cooper, D., Santesson,
      S., Farrell, S., Boeyen, S.,\n              Housley, R., and W. Polk, \"Internet
      X.509 Public Key\n              Infrastructure Certificate and Certificate Revocation
      List\n              (CRL) Profile\", RFC 5280, May 2008.\n   [RFC5397]  Sanchez,
      W. and C. Daboo, \"WebDAV Current Principal\n              Extension\", RFC
      5397, December 2008.\n   [RFC5689]  Daboo, C., \"Extended MKCOL for Web Distributed
      Authoring\n              and Versioning (WebDAV)\", RFC 5689, September 2009.\n
      \  [RFC6350]  Perreault, S., \"vCard Format Specification\", RFC 6350,\n              August
      2011.\n   [W3C.REC-xml-20081126]\n              Bray, T., Paoli, J., Sperberg-McQueen,
      C., Maler, E., and\n              F. Yergeau, \"Extensible Markup Language (XML)
      1.0 (Fifth\n              Edition)\", World Wide Web Consortium Recommendation
      REC-\n              xml-20081126, November 2008,\n              <http://www.w3.org/TR/2008/REC-xml-20081126>.\n"
    title: 16.1.  Normative References
  - contents:
    - "16.2.  Informative References\n   [IMSP]     Myers, J., \"IMSP - Internet Message
      Support Protocol\",\n              Work in Progress, June 1995.\n   [RFC2244]
      \ Newman, C. and J. Myers, \"ACAP -- Application\n              Configuration
      Access Protocol\", RFC 2244, November 1997.\n   [RFC4510]  Zeilenga, K., \"Lightweight
      Directory Access Protocol\n              (LDAP): Technical Specification Road
      Map\", RFC 4510,\n              June 2006.\n"
    title: 16.2.  Informative References
  title: 16.  References
- contents:
  - "Author's Address\n   Cyrus Daboo\n   Apple, Inc.\n   1 Infinite Loop\n   Cupertino,
    CA  95014\n   USA\n   EMail: cyrus@daboo.name\n   URI:   http://www.apple.com/\n"
  title: Author's Address
