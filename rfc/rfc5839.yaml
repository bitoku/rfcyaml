- contents:
  - "        An Extension to Session Initiation Protocol (SIP) Events\n                   for
    Conditional Event Notification\n"
  title: __initial_text__
- contents:
  - "Abstract\n   The Session Initiation Protocol (SIP) events framework enables\n
    \  receiving asynchronous notification of various events from other SIP\n   user
    agents.  This framework defines the procedures for creating,\n   refreshing, and
    terminating subscriptions, as well as fetching and\n   periodic polling of resource
    state.  These procedures provide no\n   tools to avoid replaying event notifications
    that have already been\n   received by a user agent.  This memo defines an extension
    to SIP\n   events that allows the subscriber to condition the subscription\n   request
    to whether the state has changed since the previous\n   notification was received.
    \ When such a condition is true, either the\n   body of a resulting event notification
    or the entire notification\n   message is suppressed.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5839.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  4\n     1.1.  Document Conventions . . . . . . . . . . . . . . .
    . . . .  5\n     1.2.  Terminology  . . . . . . . . . . . . . . . . . . . . .
    . .  5\n   2.  Motivations and Background . . . . . . . . . . . . . . . . . .
    \ 5\n     2.1.  Overview . . . . . . . . . . . . . . . . . . . . . . . . .  5\n
    \    2.2.  Problem Description  . . . . . . . . . . . . . . . . . . .  5\n     2.3.
    \ Requirements . . . . . . . . . . . . . . . . . . . . . . .  6\n   3.  Overview
    of Operation  . . . . . . . . . . . . . . . . . . . .  7\n   4.  Resource Model
    for Entity-Tags . . . . . . . . . . . . . . . . 10\n   5.  Subscriber Behavior
    \ . . . . . . . . . . . . . . . . . . . . . 12\n     5.1.  Detecting Support for
    Conditional Notification . . . . . . 13\n     5.2.  Generating SUBSCRIBE Requests
    \ . . . . . . . . . . . . . . 13\n     5.3.  Receiving NOTIFY Requests  . . .
    . . . . . . . . . . . . . 14\n     5.4.  Polling or Fetching Resource State .
    . . . . . . . . . . . 15\n     5.5.  Resuming a Subscription  . . . . . . . .
    . . . . . . . . . 17\n     5.6.  Refreshing a Subscription  . . . . . . . . .
    . . . . . . . 18\n     5.7.  Terminating a Subscription . . . . . . . . . . .
    . . . . . 18\n     5.8.  Handling Transient Errors  . . . . . . . . . . . . .
    . . . 19\n   6.  Notifier Behavior  . . . . . . . . . . . . . . . . . . . . .
    . 20\n     6.1.  Generating Entity-tags . . . . . . . . . . . . . . . . . . 20\n
    \    6.2.  Suppressing NOTIFY Bodies  . . . . . . . . . . . . . . . . 20\n     6.3.
    \ Suppressing NOTIFY Requests  . . . . . . . . . . . . . . . 21\n     6.4.  State
    Differentials  . . . . . . . . . . . . . . . . . . . 21\n     6.5.  List Subscriptions
    . . . . . . . . . . . . . . . . . . . . 22\n   7.  Protocol Element Definitions
    . . . . . . . . . . . . . . . . . 22\n     7.1.  204 (No Notification) Response
    Code  . . . . . . . . . . . 22\n     7.2.  Suppress-If-Match Header Field . .
    . . . . . . . . . . . . 22\n     7.3.  Grammar  . . . . . . . . . . . . . . .
    . . . . . . . . . . 22\n   8.  IANA Considerations  . . . . . . . . . . . . .
    . . . . . . . . 23\n     8.1.  204 (No Notification) Response Code  . . . . .
    . . . . . . 23\n     8.2.  Suppress-If-Match Header Field . . . . . . . . . .
    . . . . 23\n   9.  Security Considerations  . . . . . . . . . . . . . . . . .
    . . 24\n   10. Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . .
    24\n   11. References . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n
    \    11.1. Normative References . . . . . . . . . . . . . . . . . . . 24\n     11.2.
    Informative References . . . . . . . . . . . . . . . . . . 24\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The Session Initiation Protocol (SIP) events framework provides
    an\n   extensible facility for requesting notification of certain events\n   from
    other SIP user agents.  This framework includes procedures for\n   creating, refreshing,
    and terminating subscriptions, as well as the\n   possibility to fetch or periodically
    poll the event resource.\n   Several instantiations of this framework, called
    event packages have\n   been defined, e.g., for presence [RFC3856], message waiting\n
    \  indications [RFC3842], and registrations [RFC3680].\n   By default, every SUBSCRIBE
    request generates a NOTIFY request\n   containing the latest event state.  Typically,
    a SUBSCRIBE request is\n   issued by the subscriber whenever it needs a subscription
    to be\n   installed, periodically refreshed, or terminated.  Once the\n   subscription
    has been installed, the majority of the NOTIFYs\n   generated by the subscription
    refreshes are superfluous; the\n   subscriber usually is in possession of the
    event state already,\n   except in the unlikely case where a state change exactly
    coincides\n   with the periodic subscription refresh.  In most cases, the final\n
    \  event state generated upon terminating the subscription similarly\n   contains
    resource state that the subscriber already has.\n   Fetching or polling of resource
    state behaves in a similarly\n   suboptimal way in cases where the state has not
    changed since the\n   previous poll occurred.  In general, the problem lies with
    the\n   inability to persist state across a SUBSCRIBE request.\n   This memo defines
    an extension to optimize the SIP events framework.\n   This extension allows a
    notifier to tag notifications (called entity-\n   tags hereafter) and the subscriber
    to condition its subsequent\n   SUBSCRIBE requests for actual changes since a
    notification carrying\n   that entity-tag was issued.  The solution is similar
    to conditional\n   requests defined in the Hypertext Transfer Protocol (HTTP)
    [RFC2616],\n   and follows the mechanism already defined for the PUBLISH [RFC3903]\n
    \  method for issuing conditional event publications.\n   This memo is structured
    as follows.  Section 2 explains the\n   background, motivations, and requirements
    for the work; Section 3\n   gives a general overview of the mechanism; Section
    4 explains the\n   underlying model for resources and entities as they apply to\n
    \  conditional notification; Section 5 defines the subscriber behavior;\n   Section
    6 defines the notifier behavior; Section 7 includes the\n   protocol element definitions;
    Section 8 includes the IANA\n   considerations; and Section 9 includes the security
    considerations.\n"
  - contents:
    - "1.1.  Document Conventions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
      and \"OPTIONAL\" in this\n   document are to be interpreted as described in
      BCP 14, RFC 2119\n   [RFC2119] and indicate requirement levels for compliant\n
      \  implementations.\n"
    title: 1.1.  Document Conventions
  - contents:
    - "1.2.  Terminology\n   In addition to the terminology introduced in [RFC3261],
      [RFC3265],\n   and [RFC3903], this specification uses these additional terms
      to\n   describe the objects of conditional notification:\n   resource\n      An
      object identified by a URI whose resource state can be accessed\n      using
      the SIP Event Notification framework.  There is a single\n      authoritative
      notifier responsible for communicating the resource\n      state.\n   entity\n
      \     The representation of resource state.  An entity consists of the\n      state
      data carried in the body of a NOTIFY message, as well as\n      related meta-data
      in the message header.  There may be many\n      versions of an entity, one
      current and the others stale.  Each\n      version of an entity is identified
      by an entity-tag, which is\n      guaranteed to be unique across all versions
      of all entities for a\n      resource and event package.\n"
    title: 1.2.  Terminology
  title: 1.  Introduction
- contents:
  - '2.  Motivations and Background

    '
  - contents:
    - "2.1.  Overview\n   A SUBSCRIBE request creates a subscription with a finite
      lifetime.\n   This lifetime is negotiated using the Expires header field, and\n
      \  unless the subscription is refreshed by the subscriber before the\n   expiration
      is met, the subscription is terminated.  The frequency of\n   these subscription
      refreshes depends on the event package, and\n   typically ranges from minutes
      to hours.\n"
    title: 2.1.  Overview
  - contents:
    - "2.2.  Problem Description\n   The SIP events framework does not include different
      protocol methods\n   for initiating and terminating of subscriptions, subscription\n
      \  refreshes, and fetches inside and outside of the SIP dialog.  The\n   SUBSCRIBE
      method is overloaded to perform all of these functions.\n   The difference between
      a fetch that does not create a (lasting)\n   subscription and a SUBSCRIBE that
      creates one is in the Expires\n   header field value of the SUBSCRIBE; a zero-expiry
      SUBSCRIBE only\n   generates a single NOTIFY, after which the subscription immediately\n
      \  terminates.  Lasting subscriptions typically have relatively short\n   expiry
      periods, requiring periodic sending of new SUBSCRIBE requests\n   in order to
      refresh the subscription.\n   Each new SUBSCRIBE request generates a NOTIFY
      request containing the\n   latest resource state.  Even if the state has not
      changed, it is sent\n   again in response to each poll or subscription refresh.
      \ This is very\n   similar to the HTTP [RFC2616] problem of repeated GET operations
      on a\n   resource.  HTTP solves the problem using conditional requests.  The\n
      \  server versions each entity with an entity-tag that identifies a\n   specific
      instance of that entity.  Clients making GET requests can\n   then include the
      entity-tag for the version of the entity that they\n   believe to be current
      in an \"If-None-Match\" header field.  The server\n   can compare this entity-tag
      to the entity it believes to be current\n   and suppress resending the entity
      in the response if the server\n   believes the client's version matches.  In
      other words, the server\n   doesn't resend information that the client has already
      received.\n   The SIP PUBLISH [RFC3903] method uses a similar mechanism, where
      a\n   refresh of a publication is done by reference to its assigned entity-\n
      \  tag, instead of retransmitting the event state each time the\n   publication
      expiration is extended.\n"
    title: 2.2.  Problem Description
  - contents:
    - "2.3.  Requirements\n   As a summary, here is the required functionality to
      solve the\n   presented issues:\n   REQ1:   It must be possible to suppress
      the NOTIFY request (or at a\n           minimum, the event body therein) if
      the subscriber is already\n           in possession of (or has previously received
      and discarded)\n           the latest event state of the resource.\n   REQ2:
      \  This mechanism must apply to initial subscriptions in which\n           the
      subscriber is attempting to resume an earlier\n           subscription that
      has been paused.\n   REQ3:   This mechanism must apply to refreshing a subscription.\n
      \  REQ4:   This mechanism must apply to terminating a subscription\n           (i.e.,
      an unsubscribe).\n   REQ5:   This mechanism must apply to fetching or polling
      of resource\n           state.\n"
    title: 2.3.  Requirements
  title: 2.  Motivations and Background
- contents:
  - "3.  Overview of Operation\n   Whenever a subscriber initiates a subscription,
    it issues a SUBSCRIBE\n   request.  The SUBSCRIBE request is sent, routed, and
    processed by the\n   notifier normally, i.e., according to the Session Initiation
    Protocol\n   [RFC3261] and SIP-Specific Event Notification [RFC3265].\n   If the
    notifier receiving the SUBSCRIBE request supports conditional\n   subscriptions,
    it generates an entity-tag for the current entity, and\n   includes it in a SIP-ETag
    header field of the NOTIFY request.  The\n   entity-tag is unique across all versions
    of all entities for a\n   resource and event package.  See Section 4 for more
    on this.\n   Entity-tags are independent of subscriptions.  This allows\n   notifications
    generated to a fetch or a poll to have valid entity-\n   tags even across subsequent
    fetches or polls.\n   The subscriber will store the entity-tag received in the
    notification\n   along with the resource state.  It can then later use this entity-tag\n
    \  to make a SUBSCRIBE contain a condition in the form of a \"Suppress-\n   If-Match\"
    header field.  Unlike the \"If-Match\" condition in a PUBLISH\n   [RFC3903] request,
    which applies to whether the PUBLISH succeeds or\n   returns an error, this condition
    applies to the stream of\n   notifications that are sent after the SUBSCRIBE request
    has been\n   processed.\n   The Suppress-If-Match header field contains the last
    entity-tag seen\n   by the subscriber.  This condition, if true, instructs the
    notifier\n   to suppress either the body of a subsequent notification, or the\n
    \  entire notification.\n   The condition is evaluated by matching the value of
    the header field\n   against the entity-tag of the entity that would normally
    be sent in\n   the associated NOTIFY message.  There is also a wildcard entity-tag\n
    \  with a special value of \"*\" that always matches.\n      Subscriber                               Notifier\n
    \     ----------                               --------\n      (1) SUBSCRIBE       -------->\n
    \         Expires: 3600\n                          <--------       (2) 200 (or
    202)\n                          <--------       (3) NOTIFY\n                                              Subscription-State:
    active\n                                              SIP-ETag: ffee2\n      (4)
    200             -------->\n           ... time passes ...\n      (5) SUBSCRIBE
    \      -------->                \\ if \"ffee2\"\n          Suppress-If-Match:
    ffee2                 |   matches\n          Expires: 3600                            |
    \  local\n                                                   |   entity-tag\n
    \                                                  |\n                          <--------
    \      (6) 204  / then\n         ... time passes and resource state (entity) changes...\n
    \                         <--------       (7) NOTIFY\n                                              Subscription-State:
    active\n                                              SIP-ETag: ca89a\n      (8)
    200             -------->\n         ... time passes ...\n      (9) SUBSCRIBE       -------->
    \               \\ if \"ca89\"\n          Suppress-If-Match: ca89a                 |
    \  matches\n          Expires: 0                               |   local\n                                                   |
    \  entity-tag\n                                                   |\n                          <--------
    \     (10) 204  / then\n                      Figure 1: Example Message Flow\n
    \  Figure 1 describes a typical message flow for conditional\n   notification:\n
    \  (1)   The subscriber initiates a subscription by sending a SUBSCRIBE\n         request
    for a resource.\n   (2)   After proper authentication and authorization, the notifier\n
    \        accepts the subscription.\n   (3)   The notifier then immediately sends
    the initial event\n         notification, including a unique entity-tag in a SIP-ETag\n
    \        header field.\n   (4)   The subscriber accepts the notification and stores
    the entity-\n         tag value along with the resource state.\n   (5)   Later,
    the subscriber refreshes the subscription, and includes\n         an entity-tag
    in a Suppress-If-Match header field.\n   (6)   The notifier evaluates the condition
    by matching its local\n         entity-tag value for the resource against the
    value of the\n         Suppress-If-Match header field.  If the condition evaluates
    to\n         true, the notifier informs the subscriber that the notification\n
    \        will not be sent.\n   (7)   At some point, the state of the resource
    changes, e.g., the\n         presence status of a user changes from online to
    busy.  This\n         triggers an event notification with a new value in the SIP-ETag\n
    \        header field.\n   (8)   The subscriber accepts the notification and stores
    the new\n         entity-tag along with the resource state.\n   (9)   After a
    while, the subscriber decides to terminate the\n         subscription.  It adds
    a condition for Suppress-If-Match, and\n         includes the entity-tag it received
    in the previous NOTIFY.\n   (10)  The notifier evaluates the condition by matching
    its entity-tag\n         for the resource against the value of the Suppress-If-Match\n
    \        header field.  If the condition evaluates to true, the notifier\n         informs
    the subscriber that no notification will be sent.  This\n         concludes the
    subscription.\n   The benefit of using conditional notification in this example
    is in\n   the reduction of the number of NOTIFY requests the subscriber can\n
    \  expect to receive.  Each event notification that the subscriber has\n   already
    seen is suppressed by the notifier.  This example illustrates\n   only one use
    case for the mechanism; the same principles can be used\n   to optimize the flow
    of messages related to other event notification\n   use cases.\n"
  title: 3.  Overview of Operation
- contents:
  - "4.  Resource Model for Entity-Tags\n   The key to understanding how conditional
    notification works is\n   understanding the underlying resource model of event
    notification.\n   In general, this model is similar to the resource model of HTTP
    with\n   some key differences.  This section explains in detail the model as\n
    \  it applies to SIP events.  Figure 2 illustrates the model.\n                     +-----+\n
    \    ............    |     |\n     .          .    | URI |\n     . Represen .
    \   |     |\n     . tation   .    +-----+\n     .          .       |*\n     ............
    \      |\n          .             |\n          .             V\n          .        +----------+
    \           +---------+\n       composition |          |*           |  Event  |\n
    \         +------<>| Resource |----------->| Package |<----.\n          |        |
    \         |            |         |     |\n          |        +----------+            +----.----+
    \    |\n          |                                    /_\\         |\n          |*
    \                                   | classification\n      +--------+                                |
    \         |\n      |        |        .----------------.------'          |\n      |
    Entity |        |                |                 |\n      |        |        |
    \               |                 |*\n      +--------+   +----------+    +------------+
    \    +----------+\n          ^        |          |    |            |     |          |\n
    \         |        | Presence |    | Conference |     | Template |\n          |
    \       |          |    |            |     |          |\n          |1..*    +----------+
    \   +------------+     +----.-----+\n     +---------+                                          /_\\\n
    \    |         |                                           |\n     | Version |
    \                                          |\n     |         |                                      +---------+\n
    \    +---------+                                      | Watcher |\n          |1
    \                                         |  Info   |\n          |                                           |
    \        |\n          V                                           +---------+\n
    \    +---------+\n     | Entity- |\n     |   Tag   |\n     |         |\n     +---------+\n
    \                    Figure 2: Resource Model Diagram\n   For a given event package,
    there is a single authoritative agent\n   responsible for zero or more resources.
    \ That is, even for a\n   distributed agent, the resource state is uniform across
    all\n   instances.  The resource itself can be a list of resources [RFC4662].\n
    \  Conditional notification for list subscriptions is addressed in\n   Section
    6.5.\n   A resource is identified by zero or more URIs, which can be SIP URIs,\n
    \  pres URIs [RFC3859], or similar.  Subscribers use this URI to\n   subscribe
    to the resource for certain types of events, identified by\n   the event package.\n
    \  With a successful subscription, a subscriber receives event\n   notifications
    that communicate the resource state and the changes\n   thereto.  Each event notification
    carries a representation of the\n   current resource state.  This representation
    is influenced by many\n   factors, e.g., authorization and filtering rules, and
    the event\n   composition rules of the notifier.\n   This representation is realized
    in an \"entity\".  Each resource may be\n   associated with zero or more entities.
    \ For example, there may be\n   multiple subscribers to the presence information
    of a single user (a\n   resource), and each subscriber may have a different filtered
    view of\n   that resource, producing one entity per subscriber.  However, each\n
    \  entity is associated with one and only one resource; there is no\n   \"compositing\"
    of resources at the entity level.  Resources may\n   themselves be made up of
    information from other resources (be\n   \"composite resources\"), but this does
    not change the one-resource-\n   per-entity rule.\n   An entity consists of the
    data carried in the body of a NOTIFY\n   message and related meta-data in the
    message header.  Whenever the\n   data in the body or any of the meta-data changes,
    the notifier MUST\n   produce a new entity-tag.  This meta-data MUST include,
    but is not\n   limited to the following SIP header fields defined in the Session\n
    \  Initiation Protocol [RFC3261] and SIP Specific Event Notification\n   [RFC3265]:\n
    \     1.  Content-Disposition\n      2.  Content-Encoding\n      3.  Content-Language\n
    \     4.  Content-Length\n      5.  Content-Type\n      6.  Event\n   Note that
    the Subscription-State is explicitly not part of the\n   entity.  In the future,
    event packages may define additional fields\n   that implementations need to consider
    as part of the entity.\n   An entity has one or more versions of which only one
    is current and\n   all others stale.  Each version has an entity-tag, which uniquely\n
    \  identifies it across all versions of all entities pertaining to a\n   single
    resource and event package.\n   Note that two entity-tags for different resources
    being equal does\n   not indicate identical entities.  In other words, if an entity-tag\n
    \  received for a subscription to a first resource matches an entity-tag\n   received
    for a subscription to a second resource, the subscriber\n   cannot assume that
    the two entity values are equal.\n   With partial event notification, the NOTIFY
    message only carries the\n   delta state, or the set of changes to the previous
    version of the\n   entity.  In that case, implementations MUST consider the full
    event\n   state as the version of the entity to which the entity-tag in the\n
    \  NOTIFY message applies.\n   The conditional notification mechanism is independent
    of the way in\n   which subscriptions are installed.  In other words, the mechanism\n
    \  supports implicit subscriptions, such as those associated with the\n   REFER
    method [RFC3515].\n   It is possible that the same resource is in some shape or
    form\n   accessible through another mechanism in addition to SIP Event\n   Notification,
    e.g., HTTP or the SIP PUBLISH method.  In general,\n   implementations MUST NOT
    expect the entity-tags to be shared between\n   the mechanisms, unless event packages
    or specific applications of SIP\n   events explicitly define such dependencies.\n"
  title: 4.  Resource Model for Entity-Tags
- contents:
  - "5.  Subscriber Behavior\n   This section augments the subscriber behavior defined
    in RFC 3265\n   [RFC3265].  It first discusses general issues related to indicating\n
    \  support for the mechanism (Section 5.1) and creating conditions in\n   SUBSCRIBE
    requests (Section 5.2).  Next, it describes subscriber\n   behavior for receiving
    NOTIFY requests (Section 5.3), and specific\n   client workflows for polling resource
    state (Section 5.4), resuming a\n   subscription (Section 5.5), refreshing a subscription
    (Section 5.6),\n   and terminating a subscription (Section 5.7).  Finally, handling
    of\n   transient errors is discussed (Section 5.8).\n"
  - contents:
    - "5.1.  Detecting Support for Conditional Notification\n   The mechanism defined
      in this memo is backwards compatible with SIP\n   events [RFC3265] in that a
      notifier supporting this mechanism will\n   insert a SIP entity-tag in its NOTIFY
      requests, and a subscriber that\n   understands this mechanism will know how
      to use it in creating a\n   conditional request.\n   Unaware subscribers will
      simply ignore the entity-tag, make requests\n   without conditions, and receive
      the default treatment from the\n   notifier.  Unaware notifiers will simply
      ignore the conditional\n   header fields and continue normal operation.\n"
    title: 5.1.  Detecting Support for Conditional Notification
  - contents:
    - "5.2.  Generating SUBSCRIBE Requests\n   When creating a conditional SUBSCRIBE
      request, the subscriber MUST\n   include a single conditional header field including
      an entity-tag in\n   the request.  The condition is evaluated by comparing the
      entity-tag\n   of the subscribed resource with the entity-tag carried in the\n
      \  conditional header field.  If they match, the condition evaluates to\n   true.\n
      \  Unlike the condition introduced for the SIP PUBLISH [RFC3903] method,\n   these
      conditions do not apply to the SUBSCRIBE request itself, but to\n   the resulting
      NOTIFY requests.  When true, the condition drives the\n   notifier to change
      its behavior with regard to sending the\n   notifications after the SUBSCRIBE.\n
      \  This specification defines a new header field called Suppress-If-\n   Match.
      \ This header field introduces a condition to the SUBSCRIBE\n   request.  If
      true, it instructs the notifier either to omit the body\n   of the resulting
      NOTIFY message (if the SUBSCRIBE is not sent within\n   an existing dialog)
      or to suppress (i.e., block) the NOTIFY request\n   that would otherwise be
      triggered by the SUBSCRIBE (for an\n   established dialog).  In the latter case,
      the SUBSCRIBE message will\n   be answered with a 204 (No Notification) response.
      \ As long as the\n   condition remains true, it also instructs the notifier
      either to\n   suppress any subsequent NOTIFY request or, if there are reportable\n
      \  changes in the NOTIFY header, e.g., the Subscription-State has\n   changed,
      to suppress the body of any subsequent NOTIFY request.\n   If the condition
      is false, the notifier follows its default behavior.\n   If the subscriber receives
      a 204 (No Notification) response to an in-\n   dialog SUBSCRIBE, the subscriber
      MUST consider the event state and\n   the subscription state unchanged.\n   The
      value of the Suppress-If-Match header field is an entity-tag,\n   which is an
      opaque token that the subscriber simply copies (byte-\n   wise) from a previously
      received NOTIFY request.  Inclusion of an\n   entity-tag in a Suppress-If-Match
      header field of a SUBSCRIBE request\n   indicates that the client has a copy
      of, or is capable of recreating\n   a copy of, the entity associated with that
      entity-tag.\n   Example:\n      Suppress-If-Match: b4cf7\n   The header field
      can also be wildcarded using the special \"*\" entity-\n   tag value.  Such
      a condition always evaluates to true regardless of\n   the value of the current
      entity-tag for the resource.\n   Example:\n      Suppress-If-Match: *\n   Such
      a wildcard condition effectively quenches a subscription; the\n   only notifications
      received are those reporting changes to the\n   subscription state and those
      in response to a SUBSCRIBE message sent\n   outside of an existing dialog.  In
      both cases, the notifications will\n   not contain a body.\n      A subscription
      with a wildcard Suppress-If-Match condition is\n      useful in scenarios where
      the subscriber wants to temporarily put\n      a subscription in dormant mode.
      \ For example, a host may want to\n      conserve bandwidth and power when it
      detects from screen or input\n      device inactivity that the user isn't actively
      monitoring the\n      presence statuses of contacts.\n"
    title: 5.2.  Generating SUBSCRIBE Requests
  - contents:
    - "5.3.  Receiving NOTIFY Requests\n   When a subscriber receives a NOTIFY request
      that contains a SIP-ETag\n   header field, it MUST store the entity-tag if it
      wishes to make use\n   of the conditional notification mechanism.  The subscriber
      MUST be\n   prepared to receive a NOTIFY with any entity-tag value, including
      a\n   value that matches any previous value that the subscriber might have\n
      \  seen.\n   The subscriber MUST NOT infer any meaning from the value of an\n
      \  entity-tag; specifically, the subscriber MUST NOT assume identical\n   entities
      (i.e., event state) for NOTIFYs with identical entity-tag\n   values when those
      NOTIFYs result from subscription to different\n   resources.\n      Note that
      there are valid cases for which identical entity-tag\n      values on different
      resources may occur.  For example, it is\n      possible to generate entity-tag
      values using a one-way hash\n      function, resulting in the possibility that
      two different\n      resources having the same entity-value will also have the
      same\n      entity-tag.  Clients however MUST NOT assume that this is the\n
      \     case, as the algorithm for the generation of entity-tags is\n      notifier-dependent
      and not negotiated with the subscriber.\n      Consequently, the subscriber
      cannot differentiate between two\n      entity-tags that have the same value
      because they are similar\n      hashes of identical entities, or because two
      notifiers happen to\n      have used the same sequential number as an entity-tag.
      \ Entity\n      tags are only required to be unique for a given resource, not\n
      \     globally unique.\n"
    title: 5.3.  Receiving NOTIFY Requests
  - contents:
    - "5.4.  Polling or Fetching Resource State\n   Polling with conditional notification
      allows a user agent to\n   efficiently poll resource state.  This is accomplished
      using the\n   Suppress-If-Match condition:\n   Subscriber                               Notifier\n
      \  ----------                               --------\n  (1) SUBSCRIBE       -------->\n
      \     Expires: 0\n                      <--------       (2) 202\n                      <--------
      \      (3) NOTIFY\n                                          Subscription-State:
      terminated\n                                          SIP-ETag: f2e45\n                                          Content-Length:
      17539\n  (4) 200             -------->\n  ... poll interval elapses ...\n  (5)
      SUBSCRIBE       -------->\n      Suppress-If-Match: f2e45\n      Expires: 0\n
      \                     <--------       (6) 202\n                      <--------
      \      (7) NOTIFY\n                                          Subscription-State:
      terminated\n                                          SIP-ETag: f2e45\n                                          Content-Length:
      0\n  (8) 200             -------->\n                     Figure 3: Polling Resource
      State\n   (1)  The subscriber polls for resource state by sending a SUBSCRIBE\n
      \       with zero expiry (expires immediately).\n   (2)  The notifier accepts
      the SUBSCRIBE with a 202 (Accepted)\n        response.\n   (3)  The notifier
      then immediately sends a first (and last) NOTIFY\n        request with the current
      resource state and the current entity-\n        tag in the SIP-ETag header field.\n
      \  (4)  The subscriber accepts the notification with a 200 (OK)\n        response.\n
      \  (5)  After some arbitrary poll interval, the subscriber sends another\n        SUBSCRIBE
      with a Suppress-If-Match header field that includes\n        the entity-tag
      received in the previous NOTIFY.\n   (6)  The notifier accepts the SUBSCRIBE
      with a 202 (Accepted)\n        response.  (202 would be used to indicate that
      the subscription\n        request was understood without also indicating that
      it was\n        authorized, as per Section 3.1.6.1 of SIP-Specific Event\n        Notification
      [RFC3265].)\n   (7)  Since the resource state has not changed since the previous
      poll\n        occurred, the notifier sends a NOTIFY message with no body.  It\n
      \       also mirrors the current entity-tag of the resource in the SIP-\n        ETag
      header field.\n   (8)  The subscriber accepts the notification with a 200 (OK)\n
      \       response.\n"
    title: 5.4.  Polling or Fetching Resource State
  - contents:
    - "5.5.  Resuming a Subscription\n   Resuming a subscription means the ability
      to continue an earlier\n   subscription that either closed abruptly or was explicitly\n
      \  terminated.  When resuming, the subscription is established without\n   transmitting
      the resource state.  This is accomplished with\n   conditional notification
      and the Suppress-If-Match header field:\n          Subscriber                               Notifier\n
      \         ----------                               --------\n      (1) SUBSCRIBE
      \      -------->\n          Suppress-If-Match: ega23\n          Expires: 3600\n
      \                         <--------       (2) 202\n                          <--------
      \      (3) NOTIFY\n                                              Subscription-State:
      active\n                                              SIP-ETag: ega23\n                                              Content-Length:
      0\n      (4) 200             -------->\n                     Figure 4: Resuming
      a Subscription\n   (1)  The subscriber attempts to resume an earlier subscription
      by\n        including a Suppress-If-Match header field with the entity-tag\n
      \       it last received.\n   (2)  The notifier accepts the subscription after
      proper\n        authentication and authorization, by sending a 202 (Accepted)\n
      \       response.\n   (3)  Since the condition is true, the notifier then immediately
      sends\n        an initial NOTIFY request that has no body.  It also mirrors
      the\n        current entity-tag of the resource in the SIP-ETag header field.\n
      \  (4)  The subscriber accepts the NOTIFY and sends a 200 (OK) response.\n   Had
      the entity-tag not been valid any longer, the condition would\n   have evaluated
      to false, and the NOTIFY would have had a body\n   containing the latest resource
      state.\n"
    title: 5.5.  Resuming a Subscription
  - contents:
    - "5.6.  Refreshing a Subscription\n   To refresh a subscription using conditional
      notification, the\n   subscriber creates a subscription refresh before the subscription\n
      \  expires, and uses the Suppress-If-Match header field:\n          Subscriber
      \                              Notifier\n          ----------                               --------\n
      \         (1) SUBSCRIBE       -------->\n              Suppress-If-Match: aba91\n
      \             Expires: 3600\n                              <--------       (2)
      204\n                                                  Expires: 3600\n                    Figure
      5: Refreshing a Subscription\n   (1)  Before the subscription expires, the subscriber
      sends a\n        SUBSCRIBE request that includes the Suppress-If-Match header\n
      \       field with the latest entity-tag it has seen.\n   (2)  If the condition
      evaluates to true, the notifier sends a 204 (No\n        Notification) response
      and sends no NOTIFY request.  The Expires\n        header field of the 204 (No
      Notification) response indicates the\n        new expiry time.\n"
    title: 5.6.  Refreshing a Subscription
  - contents:
    - "5.7.  Terminating a Subscription\n   To terminate a subscription using conditional
      notification, the\n   subscriber creates a SUBSCRIBE request with a Suppress-If-Match\n
      \  condition:\n          Subscriber                               Notifier\n
      \         ----------                               --------\n          (1) SUBSCRIBE
      \      -------->\n              Suppress-If-Match: ega23\n              Expires:
      0\n                              <--------       (2) 204\n                   Figure
      6: Terminating a Subscription\n   (1)  The subscriber decides to terminate the
      subscription and sends a\n        SUBSCRIBE request with the Suppress-If-Match
      condition with the\n        entity-tag it has last seen.\n   (2)  If the condition
      evaluates to true, the notifier sends a 204 (No\n        Notification) response,
      which concludes the subscription, and\n        the subscriber can clear all
      state related to the subscription.\n"
    title: 5.7.  Terminating a Subscription
  - contents:
    - "5.8.  Handling Transient Errors\n   This section is non-normative.\n   In some
      deployments, there may be Back-to-Back User Agent (B2BUA)\n   devices that track
      SIP dialogs such as subscription dialogs.  These\n   devices may be unaware
      of the conditional notification mechanism.\n   It is possible that some B2BUA
      devices may treat a NOTIFY with\n   suppressed body as an error, or may expect
      all SUBSCRIBE messages to\n   have an associated NOTIFY message.\n   In general,
      there is very little that an endpoint can do to recover\n   from such transient
      errors.  The most that can be done is to try to\n   detect such errors, and
      define a fallback behavior.\n   If subscribers encounter transient errors in
      conditional\n   notification, they should disable the feature and fall back
      to normal\n   subscription behavior.\n"
    title: 5.8.  Handling Transient Errors
  title: 5.  Subscriber Behavior
- contents:
  - "6.  Notifier Behavior\n   This section augments the notifier behavior as specified
    in RFC 3265\n   [RFC3265].\n"
  - contents:
    - "6.1.  Generating Entity-tags\n   An entity-tag is a token carried in the SIP-ETag
      header field, and it\n   is opaque to the client.  The notifier is free to decide
      on any means\n   for generating the entity-tag.  It can have any value, except
      for\n   \"*\".  For example, one possible method is to implement the entity-tag\n
      \  as a simple counter, incrementing it by one for each generated\n   notification
      per resource.\n   A notifier MUST generate entity-tags for event notifications
      of all\n   resources for which it is responsible.  The entity-tag MUST be unique\n
      \  across all versions of all entities for each state of a resource as\n   reported
      by a given event package.  Otherwise said, for any\n   subscription or sequence
      of subscriptions to a specific resource\n   using a singular event package,
      each entity-tag produced MUST map to\n   one and only one presentation of resource
      state (entity).  Two\n   identical entities for a specific resource might or
      might not have\n   identical entity-tags; this decision is left to the notifier.\n
      \  An entity-tag is considered valid for as long as the entity exists.\n   An
      entity becomes stale when its version is no longer the current\n   one.  The
      notifier MUST remember (or be able to recalculate) the\n   entity-tag of an
      entity as long as the version of the entity is\n   current.  The notifier MAY
      remember the entity-tag longer than this,\n   e.g., for implementing journaled
      state differentials (Section 6.4).\n   The entity-tag values used in publications
      are not necessarily shared\n   with the entity-tag values used in subscriptions.
      \ This is because\n   there may not always be a one-to-one mapping between a
      publication\n   and a notification of state change; there may be several sources
      to\n   the event composition process, and a publication into a resource may\n
      \  not affect the resulting entity.\n"
    title: 6.1.  Generating Entity-tags
  - contents:
    - "6.2.  Suppressing NOTIFY Bodies\n   When a condition in a SUBSCRIBE request
      for suppressing notifications\n   is true (i.e., the local entity-tag for the
      resource state and the\n   entity-tag in a Suppress-If-Match header field are
      byte-wise\n   identical) but there are reportable changes in the NOTIFY header\n
      \  (e.g., the Subscription-State has changed), the notifier MUST\n   suppress
      the body of the NOTIFY request.  That is, the resulting\n   NOTIFY contains
      no Content-Type header field, the Content-Length is\n   set to zero, and no
      payload is attached to the message.\n   Additionally, when a condition in a
      SUBSCRIBE request for suppressing\n   notifications is true and the SUBSCRIBE
      message is not sent within an\n   established dialog, the notifier MUST send
      a NOTIFY request with a\n   suppressed entity body.\n   Suppressing the entity
      body of a NOTIFY does not change the current\n   entity-tag of the resource.
      \ Hence, the NOTIFY MUST contain a SIP-\n   ETag header field that contains
      the unchanged entity-tag of the\n   resource state.\n   A Suppress-If-Match
      header field that includes an entity-tag with the\n   value of \"*\" MUST always
      evaluate to true.\n"
    title: 6.2.  Suppressing NOTIFY Bodies
  - contents:
    - "6.3.  Suppressing NOTIFY Requests\n   When a condition in a SUBSCRIBE request
      to suppress notifications is\n   true (i.e., the local entity-tag of the resource
      and the entity-tag\n   in a Suppress-If-Match header field match), and the SUBSCRIBE
      is sent\n   within an established dialog, then the notifier MUST suppress the\n
      \  resulting NOTIFY request, and generate a 204 (No Notification)\n   response.
      \ As long as the condition remains true, and there are no\n   reportable changes
      in the NOTIFY header, all subsequent NOTIFY\n   requests MUST also be suppressed.\n
      \  Notifiers MUST NOT suppress a NOTIFY unless the corresponding\n   SUBSCRIBE
      message was sent in an established dialog.\n   A successful conditional SUBSCRIBE
      request MUST extend the\n   subscription expiry time.\n   Suppressing the entire
      NOTIFY has no effect on the entity-tag of the\n   resource.  In other words,
      it remains unchanged.\n   A Suppress-If-Match header field that includes an
      entity-tag with the\n   value of \"*\" MUST always evaluate to true.\n"
    title: 6.3.  Suppressing NOTIFY Requests
  - contents:
    - "6.4.  State Differentials\n   Some event packages support a scheme where notifications
      contain\n   state differentials, or state deltas [RFC3265], instead of complete\n
      \  resource state.\n   Further extensions could define means for notifiers to
      keep track of\n   the state changes of a resource, e.g., storing the changes
      in a\n   journal.  If a condition fails, the notifier would then send a state\n
      \  differential in the NOTIFY rather than the full state of the event\n   resource.
      \ This is only possible if the event package and the\n   subscriber both support
      a payload format that has this capability.\n   When state differentials are
      sent, the SIP-ETag header field MUST\n   contain an entity-tag that corresponds
      to the full resource state.\n"
    title: 6.4.  State Differentials
  - contents:
    - "6.5.  List Subscriptions\n   The Event Notification Extension for Resource
      Lists [RFC4662] defines\n   a mechanism for subscribing to a homogeneous list
      of resources using\n   the SIP events framework.\n   A list subscription delivers
      event notifications that contain both\n   Resource List Meta-Information (RLMI)
      documents as well as the\n   resource state of the individual resources on the
      list.\n   Implementations MUST consider the full resource state of a resource\n
      \  list including RLMI and the entity-header as the entity to which the\n   entity-tag
      applies.\n"
    title: 6.5.  List Subscriptions
  title: 6.  Notifier Behavior
- contents:
  - "7.  Protocol Element Definitions\n   This section describes the protocol extensions
    required for\n   conditional notification.\n"
  - contents:
    - "7.1.  204 (No Notification) Response Code\n   The 204 (No Notification) response
      code indicates that the request\n   was successful, but the notification associated
      with the request will\n   not be sent.  It is valid only in response to a SUBSCRIBE
      message\n   sent within an established dialog.\n   The response code is added
      to the \"Success\" production rule in the\n   SIP [RFC3261] message grammar.\n"
    title: 7.1.  204 (No Notification) Response Code
  - contents:
    - "7.2.  Suppress-If-Match Header Field\n   The Suppress-If-Match header field
      is added to the definition of the\n   \"message-header\" rule in the SIP [RFC3261]
      grammar.  Its use is\n   described in Sections 5, 6.3, and 6.2.\n   This header
      field is allowed to appear in any request, but its\n   behavior is only defined
      for the SUBSCRIBE request.\n"
    title: 7.2.  Suppress-If-Match Header Field
  - contents:
    - "7.3.  Grammar\n   This section defines the formal syntax for extensions described
      in\n   this memo in Augmented BNF (ABNF) [RFC5234].  The rules defined here\n
      \  augment and reference the syntax defined in RFC 3261 [RFC3261] and\n   RFC
      3903 [RFC3903].\n   Success            =/ \"204\"  ;  No Notification\n         ;
      Success is defined in RFC 3261.\n   message-header     =/ Suppress-If-Match\n
      \        ; message-header is defined in RFC 3261.\n   Suppress-If-Match  =  \"Suppress-If-Match\"
      HCOLON ( entity-tag / \"*\" )\n         ; entity-tag is defined in RFC 3903.\n"
    title: 7.3.  Grammar
  title: 7.  Protocol Element Definitions
- contents:
  - "8.  IANA Considerations\n   This document registers a new response code and a
    new header field\n   name.\n"
  - contents:
    - "8.1.  204 (No Notification) Response Code\n   This document registers a new
      response code.  This response code is\n   defined by the following information,
      which has been added to the\n   methods and response-codes sub-registry available
      from\n   http://www.iana.org.\n   This information has been added under \"Successful
      2xx\" category.\n                    +---------------------+-----------+\n                    |
      Response Code       | Reference |\n                    +---------------------+-----------+\n
      \                   | 204 No Notification | [RFC5839] |\n                    +---------------------+-----------+\n"
    title: 8.1.  204 (No Notification) Response Code
  - contents:
    - "8.2.  Suppress-If-Match Header Field\n   This document registers a new SIP
      header field called Suppress-If-\n   Match.  This header field is defined by
      the following information,\n   which has been added to the header fields sub-registry
      available from\n   http://www.iana.org.\n                +-------------------+---------+-----------+\n
      \               | Header Name       | Compact | Reference |\n                +-------------------+---------+-----------+\n
      \               | Suppress-If-Match |         | [RFC5839] |\n                +-------------------+---------+-----------+\n"
    title: 8.2.  Suppress-If-Match Header Field
  title: 8.  IANA Considerations
- contents:
  - "9.  Security Considerations\n   The security considerations for SIP event notification
    are\n   extensively discussed in RFC 3265 [RFC3265].  This specification\n   introduces
    an optimization to SIP event notification, which in itself\n   does not alter
    the security properties of the protocol.\n"
  title: 9.  Security Considerations
- contents:
  - "10.  Acknowledgments\n   The following people have contributed corrections and
    suggestions to\n   this document: Adam Roach, Sean Olson, Johnny Vrancken, Pekka
    Pessi,\n   Eva Leppanen, Krisztian Kiss, Peili Xu, Avshalom Houri, David\n   Viamonte,
    Jonathan Rosenberg, Qian Sun, Dale Worley, Tolga Asveren,\n   Brian Stucker, Eric
    Rescorla, Arun Arunachalam, and the SIP and\n   SIMPLE working groups.\n"
  title: 10.  Acknowledgments
- contents:
  - '11.  References

    '
  - contents:
    - "11.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March
      1997.\n   [RFC3261]  Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,\n
      \             A., Peterson, J., Sparks, R., Handley, M., and E.\n              Schooler,
      \"SIP: Session Initiation Protocol\", RFC 3261,\n              June 2002.\n
      \  [RFC3265]  Roach, A., \"Session Initiation Protocol (SIP)-Specific\n              Event
      Notification\", RFC 3265, June 2002.\n   [RFC3903]  Niemi, A., \"Session Initiation
      Protocol (SIP) Extension\n              for Event State Publication\", RFC 3903,
      October 2004.\n   [RFC5234]  Crocker, D. and P. Overell, \"Augmented BNF for
      Syntax\n              Specifications: ABNF\", STD 68, RFC 5234, January 2008.\n"
    title: 11.1.  Normative References
  - contents:
    - "11.2.  Informative References\n   [RFC2616]  Fielding, R., Gettys, J., Mogul,
      J., Frystyk, H.,\n              Masinter, L., Leach, P., and T. Berners-Lee,
      \"Hypertext\n              Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.\n
      \  [RFC3515]  Sparks, R., \"The Session Initiation Protocol (SIP) Refer\n              Method\",
      RFC 3515, April 2003.\n   [RFC3680]  Rosenberg, J., \"A Session Initiation Protocol
      (SIP) Event\n              Package for Registrations\", RFC 3680, March 2004.\n
      \  [RFC3842]  Mahy, R., \"A Message Summary and Message Waiting\n              Indication
      Event Package for the Session Initiation\n              Protocol (SIP)\", RFC
      3842, August 2004.\n   [RFC3856]  Rosenberg, J., \"A Presence Event Package
      for the Session\n              Initiation Protocol (SIP)\", RFC 3856, August
      2004.\n   [RFC3859]  Peterson, J., \"Common Profile for Presence (CPP)\",\n
      \             RFC 3859, August 2004.\n   [RFC4662]  Roach, A., Campbell, B.,
      and J. Rosenberg, \"A Session\n              Initiation Protocol (SIP) Event
      Notification Extension for\n              Resource Lists\", RFC 4662, August
      2006.\n"
    title: 11.2.  Informative References
  title: 11.  References
- contents:
  - "Authors' Addresses\n   Aki Niemi\n   Nokia\n   P.O. Box 407\n   NOKIA GROUP,
    FIN  00045\n   Finland\n   Phone: +358 50 389 1644\n   EMail: aki.niemi@nokia.com\n
    \  Dean Willis (editor)\n   Softarmor Systems\n   3100 Independence Pkwy #311-164\n
    \  Plano, TX  75075\n   USA\n   Phone: +1 214 504 1987\n   EMail: dean.willis@softarmor.com\n"
  title: Authors' Addresses
