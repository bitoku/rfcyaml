The Security Evaluated Standardized Password Authenticated Key Exchange (SESPAKE)
This document describes the Security Evaluated Standardized Password  Authenticated Key Exchange (SESPAKE) protocol.
The SESPAKE protocol provides password authenticated key exchange for usage in systems for protection of sensitive information.
The security proofs of the protocol were made for situations involving an active adversary in the channel, including man in the middle (MitM) attacks and attacks based on the impersonation of one of the subjects.
This document is not an Internet Standards Track specification; it is published for informational purposes.
This is a contribution to the RFC Series, independently of any other RFC stream.
The RFC Editor has chosen to publish this document at its discretion and makes no statement about its value for implementation or deployment.
Documents approved for publication by the RFC Editor are not a candidate for any level of Internet Standard; see Section 2 of RFC 7841.
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc editor.org/info/rfc8133.
Copyright Notice Copyright (c) 2017
IETF Trust and the persons identified as the document authors.
This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license info) in effect on the date of publication of this document.
Please review these documents carefully, as they describe your rights and restrictions with respect to this document.
Construction of Points {Q 1,...
15 Appendix A. Test Examples for GOST Based Protocol Implementation ..
This document describes the Security Evaluated Standardized Password  Authenticated Key Exchange (SESPAKE) protocol.
The SESPAKE protocol provides password authenticated key exchange for usage in systems for protection of sensitive information.
The protocol is intended to be used to establish keys that are then used to organize a secure channel for protection of sensitive information.
The security proofs of the protocol were made for situations involving an active adversary in the channel, including man in the middle (MitM) attacks and attacks based on the impersonation of one of the subjects.
Conventions Used in This Document
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "
SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119].
This memo uses the following functions:
HASH    the underlying hash function; HMAC    the function for calculating a message authentication code (MAC), based on a HASH function in accordance with [RFC2104]; F(PW, salt, n)
the value of the function PBKDF2(PW, salt, n, len), where PBKDF2(PW, salt, n, len) is calculated according to [RFC8018].
The parameter len is considered equal to the minimum integer that is a multiple of 8 and satisfies the following condition: len >  floor(log 2(q)).
,c n2) is an element of B (n1   n2); int(A)  for the byte string A
in B n, an integer int(A)   256^(n
the byte string A in B n, such that int(A)
X, where X is an integer and 0 <  X < 256^n; BYTES(Q) for Q in E, the byte string bytes n(X)
bytes n(Y), where X, Y are standard Weierstrass coordinates of point Q and n   ceil(log {256}(p)).
The main point of the SESPAKE protocol is that parties sharing a weak key (a password) generate a strong common key.
An active adversary who has access to a channel is not able to obtain any information that can be used to find a key in offline mode, i.e., without interaction with legitimate participants.
The protocol is used by subjects A (client) and B (server) that share some secret parameter that was established in an out of band mechanism: a client is a participant who stores a password as a secret parameter, and a server is a participant who stores a password based computed point of the elliptic curve.
The SESPAKE protocol consists of two steps: the key agreement step and the key confirmation step.
During the first step (the key agreement step), the parties exchange keys using Diffie Hellman with public components masked by an element that depends on the password   one of the predefined elliptic curve points multiplied by the password based coefficient.
This approach provides an implicit key authentication, which means that after this step, one party is assured that no other party, aside from a specifically identified second party, may gain access to the generated secret key.
During the second step (the key confirmation step), the parties exchange strings that strongly depend on the generated key.
After this step, the parties are assured that a legitimate party, and no one else, actually has possession of the secret key.
To protect against online guessing attacks, counters that indicate the number of failed connections were introduced in the SESPAKE protocol.
There is also a special technique for small order point processing and a mechanism that provides protection against reflection attacks by using different operations for different sides.
Various elliptic curves can be used in the protocol.
For each elliptic curve supported by clients, the following values MUST be defined:  the protocol parameters identifier, ID ALG (which can also define a HASH function, a pseudorandom function (PRF) used in the PBKDF2 function, etc.), which is a byte string of an arbitrary length;  the point P, which is a generator point of the subgroup of order q of the curve;  the set of distinct curve points {Q 1,Q 2,...
N} of order q, where the total number of points, N, is defined for the protocol instance.
N} is described in Section 5.
The following protocol parameters are used by subject A: 1.
The secret password value PW, which is a byte string that is uniformly randomly chosen from a subset of cardinality 10^10 or greater of the set B k, where k >  6 is the password length.
The list of curve identifiers supported by A. 3.
Sets of points {Q 1,Q 2,
...,Q N}, corresponding to curves supported by A. 4.
The C 1^A counter, which tracks the total number of unsuccessful authentication trials in a row, and a value of CLim 1 that stores the maximum possible number of such events.
C 2^A counter, which tracks the total number of unsuccessful authentication events during the period of usage of the specific PW, and a value of CLim 2 that stores the maximum possible number of such events.
The C 3^A counter, which tracks the total number of authentication events (successful and unsuccessful) during the period of usage of the specific PW, and a value of CLim 3 that stores the maximum possible number of such events.
The unique identifier, ID A, of subject A (OPTIONAL), which is a byte string of an arbitrary length.
The following protocol parameters are used by subject B:
The values ind and salt, where ind is in {1,...
The point Q PW, satisfying the following equation: Q PW   int(F(PW, salt, 2000))
It is possible that the point Q PW is not stored and is calculated using PW in the beginning of the protocol.
The C 1^B counter, which tracks the total number of unsuccessful authentication trials in a row, and a value of CLim 1 that stores the maximum possible number of such events.
The C 2^B counter, which tracks the total number of unsuccessful authentication events during the period of usage of the specific PW, and a value of CLim 2 that stores the maximum possible number of such events.
The C 3^B counter, which tracks the total number of authentication events (successful and unsuccessful) during the period of usage of the specific PW, and a value of CLim 3 that stores the maximum possible number of such events.
The unique identifier, ID B, of subject B (OPTIONAL), which is a byte string of an arbitrary length.
Initial Values of the Protocol Counters After the setup of a new password value PW, the values of the counters MUST be assigned as follows:
CLim 1, where CLim 1 is in {3,...
,5};  C 2^A   C 2^B
CLim 2, where CLim 2 is in {7,...
CLim 3, where CLim 3 is in {10
if C 1^B or C 2^B or
if u 1 not in E  > quit
if u 2 not in E
U 1    U 2    ID
The full description of the protocol consists of the following steps: 1.
If any of the counters C 1^A, C 2^A, or C 3^A is equal to 0, A finishes the protocol with an informational error regarding exceeding the number of trials that is controlled by the corresponding counter.
A decrements each of the counters C 1^A, C 2^A, and C 3^A
by 1, requests open authentication information from B, and sends the ID A identifier.
If any of the counters C 1^B, C 2^B, or C 3^B is equal to 0, B finishes the protocol with an informational error regarding exceeding the number of trials that is controlled by the corresponding counter.
B decrements each of the counters C 1^B, C 2^B, and C 3^B
B sends the values of ind, salt, and the ID ALG identifier to A. B also can OPTIONALLY send the ID B identifier to A.
All subsequent calculations are done by B in the elliptic curve group defined by the ID ALG identifier.
A sets the curve defined by the received ID ALG identifier as the used elliptic curve.
All subsequent calculations are done by A in this elliptic curve group.
A sends the value u 1   alpha P Q PW^A to B. 10.
After receiving u 1, B checks to see if u 1 is in E.
If it is not, B finishes with an error and considers the authentication process unsuccessful.
assigns z B   0, and chooses randomly (according to the uniform distribution) the value beta
O, B assigns Q B
beta P and z B
B calculates K B   HASH(BYTES(( m/q beta (mod q))
B sends the value u 2   beta P   Q PW to A. 15.
After receiving u 2, A checks to see if u 2 is in E.
If it is not, A finishes with an error and considers the authentication process unsuccessful.
u 2 Q PW^A. 17.
O, then A assigns Q A   alpha P and z
A calculates K A   HASH(BYTES(( m/q
BYTES(u 1), U 2   BYTES(u 2).
(if it is not used, then DATA A is considered to be of zero length).
A sends DATA A, MAC A to B. 22.
BYTES(u 1), U 2   BYTES(u 2).
If they are not, it finishes with an error and considers the authentication process unsuccessful.
If z B   1, B finishes with an error and considers the authentication process unsuccessful.
B sets the value of C 1^B to CLim 1 and increments C 2^B by 1. 26.
ID B    ind    salt    U 1    U 2    ID ALG (OPTIONAL)
DATA A    DATA B), where DATA B is an OPTIONAL string that is authenticated with MAC B
(if it is not used, then DATA B is considered to be of zero length).
B sends DATA B, MAC B to A. 28.
If they are not, it finishes with an error and considers the authentication process unsuccessful.
If z A   1, A finishes with an error and considers the authentication process unsuccessful.
A sets the value of C 1^A to CLim 1 and increments C 2^A by 1.
After the procedure finishes successfully, subjects A and B are mutually authenticated, and each subject has an explicitly authenticated value of K
K A   K B. Notes: 1.
In cases where the interaction process can be initiated by any subject (client or server), the ID A and ID B options MUST be used, and the receiver MUST check to see if the identifier he had received is not equal to his own; otherwise, it finishes the protocol.
If an OPTIONAL parameter ID A (or ID B) is not used in the protocol, it SHOULD be considered equal to a fixed byte string (a zero length string is allowed) defined by a specific implementation.
The ind, ID A, ID B, and salt parameters can be agreed upon in advance.
If some parameter is agreed upon in advance, it is possible not to send it during a corresponding step.
Nevertheless, all parameters MUST be used as corresponding inputs to the HMAC function during Steps 20, 23, 26, and 28.
The ID ALG parameter can be fixed or agreed upon in advance.
It is RECOMMENDED that the ID ALG parameter be used in HMAC during Steps 20, 23, 26, and 28. 5.
Continuation of protocol interaction in a case where any of the counters C 1^A or C 1^B is equal to zero MAY be done without changing the password.
In this case, these counters can be used for protection against denial of service attacks.
For example, continuation of interaction can be allowed after a certain delay period.
Continuation of protocol interaction in a case where any of the counters C 2^A, C 3^A, C 2^B, or C 3^B is equal to zero MUST be done only after changing the password.
It is RECOMMENDED that during Steps 9 and 14 the points u 1 and u 2 be sent in a non compressed format (BYTES(u 1) and BYTES(u 2)).
However, point compression MAY be used.
The use of several Q points can reinforce the independence of the data streams when working with several applications   for example, when two high level protocols can use two different points.
However, the use of more than one point is OPTIONAL.
Construction of Points {Q 1,...
This section provides an example of a possible algorithm for the generation of each point
Q i in the set {Q 1,...
N} that corresponds to the given elliptic curve E.
The algorithm is based on choosing points with coordinates with known preimages of a cryptographic hash function H, which is the GOST R 34.11 2012 hash function (see [RFC6986]) with 256 bit output
254 < q < 2^256, and the GOST R 34.11 2012 hash function (see [RFC6986])
508 < q < 2^512.
The algorithm consists of the following steps: 1.
Set i   1, SEED   0, s
Check to see if the value of X^3   aX   b is a quadratic residue in the field F p.
If it is not, set SEED   SEED   1 and return to Step 2.
Choose the value of Y   min{r1, r2}, where r1, r2 from {0,1,...
,p 1} are such that r1 !
R mod p for R   X^3
Check to see if the following relations hold for the point Q
If they do, go to Step 6; if not, set SEED   SEED   1 and return to Step 2.
If i < N, then set i
i   1 and go to Step 2; otherwise, finish.
With the defined algorithm for any elliptic curve E, point sets {Q 1,...
Constructed points in one set MUST have distinct X coordinates.
Note: The knowledge of a hash function preimage prevents knowledge of the multiplicity of any point related to generator point P.
It is of primary importance, because such knowledge could be used to implement an attack against the protocol with an exhaustive search for the password.
Any cryptographic algorithms   particularly HASH functions and HMAC functions   that are used in the SESPAKE protocol MUST be carefully designed and MUST be able to withstand all known types of cryptanalytic attacks.
It is RECOMMENDED that the HASH function satisfy the following condition:  hashlen <  log 2(q)   4, where hashlen is the length of the HASH function output.
It is RECOMMENDED that the output length of hash functions used in the SESPAKE protocol be greater than or equal to 256 bits.
and P MUST be chosen in such a way that they are provably pseudorandom.
N} (see Section 5) ensures that the multiplicity of any point under any other point is unknown.
Using N   1 is RECOMMENDED.
Note: The specific adversary models for the protocol discussed in this document can be found in [SESPAKE SECURITY], which contains the security proofs.
This document does not require any IANA actions.
Signature and verification processes of [electronic] digital signature", GOST R 34.10 2012, Federal Agency on Technical Regulating and Metrology (in Russian), 2012.
Hashing function", GOST R 34.11 2012, Federal Agency on Technical Regulating and Metrology (in Russian), 2012.
[RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, "HMAC:
Keyed Hashing for Message Authentication", RFC 2104, DOI 10.17487/RFC2104, February 1997
Key words for use in RFCs to Indicate Requirement Levels", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc editor.org/info/rfc2119>.
[RFC6090]  McGrew, D., Igoe, K., and M. Salter, "Fundamental Elliptic Curve Cryptography Algorithms", RFC 6090,
[RFC6986]  Dolmatov, V., Ed., and A. Degtyarev, "GOST R 34.11 2012:
Hash Function", RFC 6986, DOI 10.17487/RFC6986, August 2013, <http://www.rfc editor.org/info/rfc6986>.
[RFC7091]  Dolmatov, V., Ed., and A. Degtyarev, "GOST R 34.10 2012: Digital Signature Algorithm", RFC 7091,
[RFC7836]  Smyshlyaev, S., Ed., Alekseev, E., Oshkin, I., Popov, V., Leontiev, S., Podobaev, V., and D. Belyavsky, "Guidelines on the Cryptographic Algorithms to Accompany the Usage of Standards GOST R 34.10 2012 and GOST R 34.11 2012", RFC 7836, DOI 10.17487/RFC7836, March 2016, <http://www.rfc editor.org/info/rfc7836
[RFC8018]  Moriarty, K., Ed., Kaliski, B., and A. Rusch, "PKCS #5:
Password Based Cryptography Specification Version 2.1", RFC 8018,
Informative References [RFC4357]  Popov, V., Kurepkin, I., and S. Leontiev, "Additional Cryptographic Algorithms for Use with GOST 28147 89, GOST R 34.10 94, GOST R 34.10 2001, and GOST R 34.11 94 Algorithms", RFC 4357,
[SESPAKE SECURITY] Smyshlyaev, S., Oshkin, I., Alekseev, E., and L. Ahmetzyanova, "On the Security of One Password Authenticated Key Exchange Protocol", 2015,
Appendix A.  Test Examples for GOST Based Protocol Implementation
The following test examples are made for the protocol implementation that is based on the Russian national standards GOST R 34.10 2012 [GOST3410 2012] and GOST R 34.11 2012
The English versions of these standards can be found in [RFC7091] and [RFC6986].
Examples of Points There is one point Q 1 for each of the elliptic curves below.
These points were constructed using the method described in Section 5 for N   1 and the GOST R 34.11 2012 hash function (see [RFC6986]).
q < 2^256, the GOST R 34.11 2012 hash function with 256 bit output is used, and if 2^
508 < q < 2
512, the GOST R 34.11 2012 hash function with 512 bit output is used.
Each of the points complies with the GOST R 34.10 2012
[GOST3410 2012] standard and is represented by a pair of (X, Y) coordinates in the canonical form and also by a pair of (U, V) coordinates in the twisted Edwards form in accordance with [RFC7836] for the curves that have equivalent representations in this form.
There is a SEED value for each point, by which it was generated.
CryptoPro B ParamSet, etc. are defined in [RFC4357].
512 paramSetB, etc. are defined in [RFC7836].
CryptoPro A ParamSet Point Q 1
Y   0x137478a9f721c73932ea06b45cf72e37eb78a63f29a542e563c614650c8b6399 SEED   0x0006 A.1.4.
2012 512 paramSetA Point Q 1
2012 512 paramSetB Point Q 1
0x2cc89998b875d4463805ba0d858a196592db20ab161558ff2f4ef7a85725d209 53967ae621afdeae89bb77c83a2528ef6fce02f68bda4679d7f2704947dbc408 SEED   0x0000 A.1.6.
2012 256 paramSetA Point Q 1
512 paramSetC Point Q 1
This protocol implementation uses the GOST R 34.11 2012 hash function (see [RFC6986]) with 256 bit output as the H function and the HMAC GOSTR3411 2012 512 function defined in [RFC7836] as a PRF for the F function.
The parameter len is considered equal to 256 if 2^
254 < q < 2^256, and equal to 512 if 2^
508 < q < 2
The test examples for the point of each curve in Appendix A.1 are given below.
The input protocol parameters in this example take the following values:
N   1 ind   1 ID A: 00 00 00 00 ID B: 00 00 00 00 PW: 31 32 33 34 35 36 ('123456')
salt: 29 23 BE 84 E1 6C D6 AE 52
90 49 F1 F1 BB E9 EB Q ind:
The function F(PW, salt, 2000) takes the following values: F(PW, salt, 2000):
BD 04 67 3F 71 49 B1 8E 98 15 5B D1 E2 72 4E
A2 51 74 F7 92 D3 32 6C
6F 18 12 70 67
The coordinates of the point Q PW are:
During the calculation of u 1 on subject A, the parameter alpha, the point alpha P, and u 1 take the following values:
When processing u 1, calculating the K B key, and calculating u 2 on subject B, the parameters beta, src, K B   HASH(src), beta P, and u 2 take the following values:
2E 01 A3 D8 4F DB 7E 94 7B B8 92 9B E9 36 3D F5 F7 25 D6 40 1A A5 59 D4 1A 67 24 F8 D5 F1 8E 2C A0 DB A9 31 05 CD DA F4 BF AE A3 90
6F DD 71 9D BE
B2 97 B6 A1 7F 4F BD 96 DC C7 23 EA 34 72 A9 K B:
1A 62 65 54 92 1D C2 E9 2B 4D D8 D6 7D BE 5A 56 62
E5 62 99 37 3F 06
35 AD 26 09 4E CA A3 beta P:
When processing u 2 and calculating the key on subject A, the K A key takes the following values:
K A: 1A 62 65 54 92 1D C2 E9 2B 4D D8 D6 7D
E5 62 99 37 3F 06
79 95 35 AD 26 09 4E CA A3
The message MAC A   HMAC(K A, 0x01
ID A    ind    salt    u 1    u 2)
from subject A takes the following values:
23 7A 03 C3 5F 49 17
CE 86 B3 58 94 45 F1 1E 1A 6F 10 8B 2F DD 0A A9 E8 10 66 4B 25
The message MAC B   HMAC(K B, 0x02    ID B    ind    salt
u 1    u 2) from subject B takes the following values: MAC B: 9E E0 E8 73 3B 06 98 50 80
98 73 1D CD 1C FF E8 7A 3B 15 1F 0A E8 3E A9 6A FB 4F FC 31 E4 A.2.2.
The input protocol parameters in this example take the following values:
N   1 ind   1 ID A: 00 00 00 00 ID B: 00 00 00 00 PW: 31 32 33 34 35 36 ('123456')
salt: 29 23 BE 84 E1 6C D6 AE 52
90 49 F1 F1 BB E9 EB Q ind:
The function F(PW, salt, 2000) takes the following values: F(PW, salt, 2000):
BD 04 67 3F 71 49 B1 8E 98 15 5B D1 E2 72 4E
A2 51 74 F7 92 D3 32 6C
6F 18 12 70 67
The coordinates of the point Q PW are:
During the calculation of u 1 on subject A, the parameter alpha, the point alpha P, and u 1 take the following values:
When processing u 1, calculating the K B key, and calculating u 2 on subject B, the parameters beta, src, K B   HASH(src), beta P, and u 2 take the following values
50 14 0A 5D ED 33 43 EF C8 25 7B 79 E6 46 D9 F0 DF 43 82 8C 04
91 9B D4 60 C9 7A D1 4B A3 A8 6B 00 C4 06 B5 74
4D 8E B1 49 DC 8E 7F C8 40 64
D8 53 20 25 3E 57 A9 B6 B1 3D 0D
38 FE A8 EE 5E 0A K B:
A6 26 DE 01 B1 68 0F F7 51 30
09 12 2B CE E1 89 68 83 39 4F 96 03 01
72 45 5C 9A E0 60 CC E4 4A beta P:
When processing u 2 and calculating the key on subject A, the K A key takes the following values
A6 26 DE 01 B1 68 0F F7 51 30
09 12 2B CE E1 89 68 83 39 4F 96 03 01
72 45 5C 9A E0 60 CC E4 4A
The message MAC A   HMAC(K A
ID A    ind    salt    u 1    u 2)
from subject A takes the following values: MAC A: B9 1F 43
90 2A FA 90 D3 E5 C6 91 CB DC 43 8A 1E BF 54 7F 4C 2C B4 14 43 CC
38 79 7B E2 47 A7 D0
0x02    ID B    ind    salt
u 1    u 2) from subject B takes the following values: MAC B: 79 D5 54 83 FD 99 B1 2B CC A5 ED C6 BB E1 D7 B9 15 CE 04 51 B0 89 1E 77 5D 4A 61 CB 16 E3 3F CC A.2.3.
The input protocol parameters in this example take the following values:
N   1 ind   1 ID A: 00 00 00 00 ID B: 00 00 00 00 PW: 31 32 33 34 35 36 ('123456')
salt: 29 23 BE 84 E1 6C D6 AE 52
90 49 F1 F1 BB E9 EB Q ind:
The function F(PW, salt, 2000) takes the following values: F(PW, salt, 2000):
BD 04 67 3F 71 49 B1 8E 98 15 5B D1 E2 72 4E
A2 51 74 F7 92 D3 32 6C
6F 18 12 70 67
The coordinates of the point Q PW are:
During the calculation of u 1 on subject A, the parameter alpha, the point alpha P, and u 1 take the following values:
When processing u 1, calculating the K B key, and calculating u 2 on subject B, the parameters beta, src, K B   HASH(src), beta P, and u 2 take the following values:
88 54 7E 1C 90 06 BA A0 08 E8 CB EC C9 D1 68
91 ED C8 36 CF B7 5F 8E B9 56 FA 76
11 94 D2 8E 25 DA D3 81 8D 16 3C
49 4B 05 9A 8C 70 A5 A1 B8 8A 7F 80 A2 EE 35 49 30 18 46 54 2C
: BE 7E 7E 47 B4 11 16 F2 C7 7E 3B 8F CE
40 30 72 CA 82 45 0D 65 DE FC
71 A9 56 49 E4 DE EA EC EE beta P:
When processing u 2 and calculating the key on subject A, the K A key takes the following values: K A: BE 7E 7E 47 B4 11 16 F2 C7 7E 3B 8F CE
40 30 72 CA 82 45 0D 65 DE FC 71 A9 56 49 E4 DE EA EC EE
The message MAC A   HMAC(K A, 0x01    ID A
u 1    u 2) from subject A takes the following values:
MAC A: D3 B4 1A E2 C9 43
11 36 06 3E 6D 08 A6 1B
E9 63 BD 5E D6 A1 FF F9 37 FA 8B 09
0A 98 E1 62 BF ED
0x02    ID B    ind    salt
u 1    u 2) from subject B takes the following values: MAC B: D6 B3 9A 44 99 BE D3 E0 4F AC F9
50 2D 16 B2 CB 67 4A 20
5F AC 3C D8 3D 54 EC 2F D5 FC E2 58 A.2.4.
The input protocol parameters in this example take the following values:
N   1 ind   1 ID A: 00 00 00 00 ID B: 00 00 00 00 PW: 31 32 33 34 35 36 ('123456')
salt: 29 23 BE 84 E1 6C D6 AE 52
90 49 F1 F1 BB E9 EB Q ind:
The function F(PW, salt, 2000) takes the following values: F(PW, salt, 2000):
BD 04 67 3F 71 49 B1 8E 98 15 5B D1 E2 72 4E
A2 51 74 F7 92 D3 32 6C
18 12 70 67 1C 62 13 E3 93 0E FD DA 26
45 17 92 C6 20 81 22 EE 60 D2 00 52 0D 69 5D FD 9F 5F 0F D5 AB A7 02
The coordinates of the point Q PW are:
During the calculation of u 1 on subject A, the parameter alpha, the point alpha P, and u 1 take the following values:
When processing u 1, calculating the K B key, and calculating u 2 on subject B, the parameters beta, src, K B   HASH(src), beta P, and u 2 take the following values: beta 0xB5C286A79AA8E97EC0E19BC1959A1D15F12F8C97870BA9D68CC12811A56A3BB1
1440610825796A49D468CDC9C2D02D76598A27973D5960C5F50BCE28D8D345F4 src: 84 59 C2 0C B5 C5 32 41 6D B9 28 EB 50 C0 52 0F B2 1B 9C D3 9A 4E 76
06 B2 21 BE 15 CA 1D 02 DA 08 15 DE C4 49 79 C0 8C
7D 23 07 AF 24 7D DA 1F
89 EC 81 20 69 F5 D9 CD E3 06 AF F0 BC 3F D2 6E
D2 01 B9 53 52 A2 56 06 B6 43 E8 88
FC 8D 3E 95 1E 3E B4 68 4A DB 5C 05 7B 8F 8C 89 B6 CC 0D EE D1 00 06
5B 51 8A 1C 71 7F
82 FF 61 2B BC 79 8E C7 B2 49 0F B7 00 3F 94 33
1D K B: 53 24 DE F8 48 B6 63 CC 26
42 2F 5E 45 EE C3 4C 51 D2 43 61 B1
65 60 CA 58 A3 D3 28 45 86 CB 7A
When processing u 2 and calculating the key on subject A, the K A key takes the following values:
K A: 53 24 DE F8 48 B6 63 CC 26 42 2F 5E 45 EE C3 4C 51 D2 43 61 B1 65 60 CA 58 A3 D3 28 45 86 CB 7A
ID A    ind    salt    u 1    u 2)
from subject A takes the following values: MAC A: E8 EF 9E A8 F1 E6 B1 26 68 E5 8C D2 2D D8 EE C6 4A 16 71 00
39 FA A6 B6 03 99 22 20 FA FE 56 14
0x02    ID B    ind    salt
u 1    u 2) from subject B takes the following values: MAC B: 61 14 34 60 83 6B 23 5C EC D0 B4 9B 58 7E A4 5D
51 3C 3A 38 78 3F 1C 9D 3B
97 0A 95 6A 55 BA A.2.5.
tc26 gost 3410 2012 512 paramSetB
The input protocol parameters in this example take the following values:
N   1 ind   1 ID A: 00 00 00 00 ID B: 00 00 00 00 PW: 31 32 33 34 35 36 ('123456')
salt: 29 23 BE 84 E1 6C D6 AE 52
90 49 F1 F1 BB E9 EB Q ind:
The function F(PW, salt, 2000) takes the following values: F(PW, salt, 2000):
BD 04 67 3F 71 49 B1 8E 98 15 5B D1 E2 72 4E
A2 51 74 F7 92 D3 32 6C
18 12 70 67 1C 62 13 E3 93 0E FD DA 26
45 17 92 C6 20 81 22 EE 60 D2 00 52 0D 69 5D FD 9F 5F 0F D5 AB A7 02
The coordinates of the point Q PW are:
During the calculation of u 1 on subject A, the parameter alpha, the point alpha P, and u 1 take the following values: alpha 0x715E893FA639BF341296E0623E6D29DADF26B163C278767A7982A989462A3863 FE12AEF8BD403D59C4DC4720570D4163DB0805C7C10C4E818F9CB785B04B9997
When processing u 1, calculating the K B key, and calculating u 2 on subject B, the parameters beta, src, K B   HASH(src), beta P, and u 2 take the following values:
3F 04 02 E4 0A 9D 59 63 20 5B CD F4 FD 89 77 91 9B BA F4 80 F8 E4 FB D1 25 5A EC E6
4B D0 A2 87 98 4F 59 D1 02 04 B5 F4 5E 4D 77 F3 CF 8A 63 B3 1B EB 2D F5 9F 8A F7 3C
20 9C CA 8B 50 B4 18
D8 01 E4 90 AE
13 3F 04 F4 F3 F4 D8 FE 8E
19 64 6A 1B AF 44 D2 36 FC C2 1B 7F 4D 8F C6 A1 E2 9D 6B 69 AC CE ED 4E 62 AB B2 0D AD 78 AC F4 FE B0 ED 83
8E D9 1E 92 12 AB A3 89 71 4E 56 0C
K B: D5 90 E0 5E F5 AE CE 8B 7C FB
FC 71 BE 45 5F 29
A5 CC 66 6F 85
CD B1 7E 7C C7 16 C5 9F
F1 70 E9 beta P:
When processing u 2 and calculating the key on subject A, the K A key takes the following values
D5 90 E0 5E F5 AE CE 8B 7C FB
FC 71 BE 45 5F 29
A5 CC 66 6F 85
CD B1 7E 7C C7 16 C5 9F F1 70 E9
The message MAC A   HMAC(K A, 0x01
ID A    ind    salt    u 1    u 2)
from subject A takes the following values:
DE 46 BB 4C 8C E0 8A 6E F3 B8 DF AC CC 1A 39 B0 8D 8C 27 B6 CB 0F
CF 59 23 86 A6 48 F4 E5 BD 8C
0x02    ID B    ind    salt
u 1    u 2) from subject B takes the following values: MAC B:
EC B1 1D E2 06 1C 55 F1 D1 14 59 CB 51 CE 31 40 99 99 99 2F CA A1 22 2F B1 4F CE AB 96 EE 7A AC A.2.6.
The input protocol parameters in this example take the following values:
N   1 ind   1 ID A: 00 00 00 00 ID B: 00 00 00 00 PW: 31 32 33 34 35 36 ('123456')
salt: 29 23 BE 84 E1 6C D6 AE 52
90 49 F1 F1 BB E9 EB Q ind:
The function F(PW, salt, 2000) takes the following values: F(PW, salt, 2000):
BD 04 67 3F 71 49 B1 8E 98 15 5B D1 E2 72 4E
A2 51 74 F7 92 D3 32 6C
6F 18 12 70 67
The coordinates of the point Q PW are:
During the calculation of u 1 on subject A, the parameter alpha, the point alpha P, and u 1 take the following values:
When processing u 1, calculating the K B key, and calculating u 2 on subject B, the parameters beta, src, K B   HASH(src), beta P, and u 2 take the following values
: beta 0x30D5CFADAA0E31B405E6734C03EC4C5DF0F02F4BA25C9A3B320EE6453567B4CB src: A3 39 A0 B8 9C EF 1A 6F FD 4C A1 28 04
9E 06 84 DF 4A 97 75 B6 89 A3 37 84 1B F7 D7 91 20 7F 35 11 86 28 F7 28 8E AA 0F 7E C8 1D A2 0A 24 FF 1E 69 93 C6 3D 9D D2 6A
90 B7 4D D1 A2 66 28
7D F7 1A C3 27 ED 51 7D 0D E4 03 E8 17 C6 20
4B C1 91 65 B9 D1 00 2B 9F
10 88 A6 CD A6 EA CF 27
When processing u 2 and calculating the key on subject A, the K A key takes the following values
7D F7 1A C3 27 ED 51 7D 0D E4 03 E8 17 C6 20
4B C1 91 65 B9 D1 00 2B 9F 10 88 A6 CD A6 EA CF 27
ID A    ind    salt    u 1    u 2)
from subject A takes the following values:
MAC A: F9 29 B6 1A 3C 83 39 85 B8 29 F2 68 55 7F A8 11
00 9F 82 0A B1 A7 30 B5 AA 33 4C 3E 6B A3 17 7F
0x02    ID B    ind    salt
u 1    u 2) from subject B takes the following values: MAC B:
A2 92 8A 5C F6 20
BB C4 90 0D E4 03 F7
80 B6 8B E0 46 D0 B5 D9 B4 AE 6A BF A8 0B D6 A.2.7.
The input protocol parameters in this example take the following values:
N   1 ind   1 ID A: 00 00 00 00 ID B: 00 00 00 00 PW: 31 32 33 34 35 36 ('123456')
salt: 29 23 BE 84 E1 6C D6 AE 52
90 49 F1 F1 BB E9 EB Q ind:
The function F(PW, salt, 2000) takes the following values: F(PW, salt, 2000):
BD 04 67 3F 71 49 B1 8E 98 15 5B D1 E2 72 4E
A2 51 74 F7 92 D3 32 6C
18 12 70 67 1C 62 13 E3 93 0E FD DA 26
45 17 92 C6 20 81 22 EE 60 D2 00 52 0D 69 5D FD 9F 5F 0F D5 AB A7 02
The coordinates of the point Q PW are:
During the calculation of u 1 on subject A, the parameter alpha, the point alpha P, and u 1 take the following values: alpha 0x332F930421D14CFE260042159F18E49FD5A54167E94108AD80B1DE60B13DE799 9A34D611E63F3F870E5110247DF8EC7466E648ACF385E52CCB889ABF491EDFF0
When processing u 1, calculating the K B key, and calculating u 2 on subject B, the parameters beta, src, K B   HASH(src), beta P, and u 2 take the following values: beta 0x38481771E7D054F96212686B613881880BD8A6C89DDBC656178F014D2C093432 A033EE10415F13A160D44C2AD61E6E2E05A7F7EC286BCEA3EA4D4D53F8634FA2 src:
4F 4D 64 B5 D0 70 08 E9 E6 85
87 4F 88 2C 3E 1E 60 A6 67 5E ED 42
16 3F DE B4 4C 69 18 B7 BC CE AB 88 A0 F3 FB 78 8D A8 DB 10 18 51 FF 1A
41 68 22 BA 37 C3 53 CE C4 C5 A5 23 95 B7 72 AC 93 C0 54 E3 F4 05 5C ED 6F F0 BE E4 A6 A2 4E D6 8B 86 FE FA 70 DE 4A 2B
16 08 51 42 A4 DF F0 5D 32 EC 7D DF E3 04 F5 C7 04 FD FA 06 0F 64 E9 E8 32 14 00 25 F3 92
0E 3F B6 2C AC K B:
A0 83 84 A6 2F 4B E1 AE 48 98 FC A3 6D AA 3F AA 45 1B 3E C5 B5 9C E3 75 F8 9E 92 9F 4B 13
When processing u 2 and calculating the key on subject A, the K A key takes the following values
A0 83 84 A6 2F 4B E1 AE 48
FC A3 6D AA 3F AA 45 1B 3E C5 B5 9C E3 75 F8 9E 92 9F 4B 13 25 8C
The message MAC A   HMAC(K A, 0x01
ID A    ind    salt    u 1    u 2)
from subject A takes the following values:
MAC A: 12 63 F2 89 0E 90 EE 42 6B 9B A0 8A B9 EA 7F 1F FF 26 E1 60
5C C6 5D E2 96 96 91 15 E5 31 76 87
0x02    ID B    ind    salt
u 1    u 2) from subject B takes the following values: MAC B: 6D FD 06 04 5D 6D 97 A0 E4 19 B0 0E 00
35 B9 D2 E3 AB 09 8B 7C A4 AD
52 54 60 FA B6 21 85 AA 57 Appendix B.  Point Verification Script
The points from Appendix A.1 were generated with the following point verification script in Python:
\ 0xAE07D0396E9A9ADDC40FL, "n":64 } ]
[] for c in s: res
" % data[ i ]
( r ) class Stribog:  A
[ 0x8e20faa72ba0b470, 0x47107ddd9b505a38, 0xad08b0e0c3282d1c, 0xd8045870ef14980e, 0x6c022c38f90a4c07, 0x3601161cf205268d, 0x1b8e0b0e798c13c8, 0x83478b07b2468764, 0xa011d380818e8f40, 0x5086e740ce47c920, 0x2843fd2067adea10, 0x14aff010bdd87508, 0x0ad97808d06cb404, 0x05e23c0468365a02, 0x8c711e02341b2d01, 0x46b60f011a83988e, 0x90dab52a387ae76f, 0x486dd4151c3dfdb9, 0x24b86a840e90f0d2, 0x125c354207487869, 0x092e94218d243cba, 0x8a174a9ec8121e5d, 0x4585254f64090fa0, 0xaccc9ca9328a8950, 0x9d4df05d5f661451, 0xc0a878a0a1330aa6, 0x60543c50de970553, 0x302a1e286fc58ca7, 0x18150f14b9ec46dd, 0x0c84890ad27623e0, 0x0642ca05693b9f70, 0x0321658cba93c138, 0x86275df09ce8aaa8, 0x439da0784e745554, 0xafc0503c273aa42a, 0xd960281e9d1d5215, 0xe230140fc0802984, 0x71180a8960409a42, 0xb60c05ca30204d21, 0x5b068c651810a89e, 0x456c34887a3805b9, 0xac361a443d1c8cd2, 0x561b0d22900e4669, 0x2b838811480723ba, 0x9bcf4486248d9f5d, 0xc3e9224312c8c1a0, 0xeffa11af0964ee50, 0xf97d86d98a327728, 0xe4fa2054a80b329c,
0x727d102a548b194e, 0x39b008152acb8227, 0x9258048415eb419d, 0x492c024284fbaec0, 0xaa16012142f35760, 0x550b8e9e21f7a530, 0xa48b474f9ef5dc18, 0x70a6a56e2440598e, 0x3853dc371220a247, 0x1ca76e95091051ad, 0x0edd37c48a08a6d8, 0x07e095624504536c, 0x8d70c431ac02a736, 0xc83862965601dd1b, 0x641c314b2b8ee083 ]
[ 0xFC, 0xEE, 0xDD, 0x11, 0xCF, 0x6E, 0x31, 0x16, 0xFB, 0xC4, 0xFA, 0xDA, 0x23, 0xC5, 0x04, 0x4D, 0xE9, 0x77, 0xF0, 0xDB, 0x93, 0x2E, 0x99, 0xBA, 0x17, 0x36, 0xF1, 0xBB, 0x14, 0xCD, 0x5F, 0xC1, 0xF9, 0x18, 0x65, 0x5A, 0xE2, 0x5C, 0xEF, 0x21, 0x81, 0x1C, 0x3C, 0x42, 0x8B, 0x01, 0x8E, 0x4F, 0x05, 0x84, 0x02, 0xAE,
0xE3, 0x6A, 0x8F, 0xA0, 0x06, 0x0B, 0xED, 0x98, 0x7F, 0xD4, 0xD3, 0x1F, 0xEB, 0x34, 0x2C, 0x51, 0xEA, 0xC8, 0x48, 0xAB, 0xF2, 0x2A, 0x68, 0xA2, 0xFD, 0x3A, 0xCE, 0xCC, 0xB5, 0x70, 0x0E, 0x56, 0x08, 0x0C, 0x76, 0x12, 0xBF, 0x72, 0x13, 0x47, 0x9C, 0xB7, 0x5D, 0x87, 0x15, 0xA1, 0x96, 0x29, 0x10, 0x7B, 0x9A, 0xC7, 0xF3, 0x91, 0x78, 0x6F, 0x9D, 0x9E, 0xB2, 0xB1, 0x32, 0x75, 0x19, 0x3D, 0xFF, 0x35, 0x8A, 0x7E, 0x6D, 0x54, 0xC6, 0x80, 0xC3, 0xBD, 0x0D, 0x57, 0xDF,
0xF5, 0x24, 0xA9, 0x3E, 0xA8, 0x43, 0xC9, 0xD7, 0x79, 0xD6, 0xF6, 0x7C, 0x22, 0xB9, 0x03, 0xE0, 0x0F, 0xEC, 0xDE, 0x7A, 0x94, 0xB0,
0xBC, 0xDC, 0xE8, 0x28, 0x50, 0x4E, 0x33, 0x0A, 0x4A, 0xA7, 0x97, 0x60, 0x73, 0x1E, 0x00, 0x62, 0x44, 0x1A, 0xB8, 0x38, 0x82, 0x64, 0x9F, 0x26, 0x41, 0xAD, 0x45, 0x46, 0x92, 0x27, 0x5E, 0x55, 0x2F, 0x8C, 0xA3, 0xA5, 0x7D, 0x69, 0xD5, 0x95, 0x3B, 0x07, 0x58, 0xB3, 0x40, 0x86, 0xAC, 0x1D, 0xF7, 0x30, 0x37, 0x6B, 0xE4, 0x88, 0xD9, 0xE7, 0x89, 0xE1, 0x1B, 0x83, 0x49, 0x4C, 0x3F, 0xF8, 0xFE, 0x8D, 0x53, 0xAA, 0x90, 0xCA, 0xD8, 0x85, 0x61, 0x20, 0x71, 0x67, 0xA4, 0x2D, 0x2B, 0x09, 0x5B, 0xCB, 0x9B, 0x25, 0xD0, 0xBE, 0xE5, 0x6C, 0x52, 0x59, 0xA6, 0x74, 0xD2, 0xE6, 0xF4, 0xB4, 0xC0, 0xD1, 0x66, 0xAF, 0xC2, 0x39, 0x4B, 0x63, 0xB6 ]
[ 0,  8, 16, 24, 32, 40, 48, 56, 1,  9, 17, 25, 33, 41, 49, 57, 2, 10, 18, 26, 34, 42, 50, 58, 3, 11, 19, 27, 35, 43, 51, 59, 4, 12, 20, 28, 36, 44, 52, 60, 5, 13, 21, 29, 37, 45, 53, 61, 6, 14, 22, 30, 38, 46, 54, 62, 7, 15, 23, 31, 39, 47, 55, 63 ]
0xe9, 0xeb, 0xcb, 0x2f, 0x81, 0xc0, 0x65, 0x7c, 0x1f, 0x2f, 0x6a, 0x76, 0x43, 0x2e, 0x45, 0xd0, 0x16, 0x71, 0x4e,
0xb8, 0x8d, 0x75, 0x85, 0xc4, 0xfc
, 0x4b, 0x7c, 0xe0, 0x91, 0x92, 0x67, 0x69, 0x01, 0xa2, 0x42, 0x2a, 0x08, 0xa4
, 0x60, 0xd3, 0x15, 0x05, 0x76, 0x74, 0x36, 0xcc, 0x74, 0x4d, 0x23, 0xdd, 0x80, 0x65, 0x59, 0xf2, 0xa6, 0x45, 0x07 ]
, [ 0x6f, 0xa3, 0xb5, 0x8a, 0xa9, 0x9d, 0x2f, 0x1a, 0x4f, 0xe3, 0x9d, 0x46, 0x0f, 0x70, 0xb5,
0xd7, 0xf3, 0xfe, 0xea, 0x72, 0x0a, 0x23,
0xd5, 0x5e, 0x0f, 0x16, 0xb5, 0x01, 0x31, 0x9a, 0xb5, 0x17, 0x6b, 0x12, 0xd6, 0x99, 0x58, 0x5c, 0xb5, 0x61, 0xc2, 0xdb,
0xdd, 0xa2, 0x1b, 0xd7, 0xcb, 0xcd
, 0x56, 0xe6, 0x79, 0x04, 0x70, 0x21,
, 0x39, 0xfc, 0x28, 0x6a, 0x3d, 0x84, 0x35, 0x06, 0xf1, 0x5e, 0x5f, 0x52,
0x9c, 0x1f, 0x8b, 0xf2, 0xea, 0x75, 0x14, 0xb1, 0x29, 0x7b,
0x7b, 0xd3, 0xe2, 0x0f, 0xe4, 0x90, 0x35, 0x9e,
0xb1, 0xc1, 0xc9, 0x3a, 0x37, 0x60, 0x62, 0xdb, 0x09
, 0xc2, 0xb6, 0xf4, 0x43, 0x86, 0x7a, 0xdb, 0x31, 0x99, 0x1e, 0x96, 0xf5, 0x0a
0xd2, 0xf9, 0x48, 0xe1, 0xa0, 0x5d, 0x71, 0xe4,
0xdd, 0x48, 0x8e, 0x85, 0x7e, 0x33, 0x5c, 0x3c, 0x7d, 0x9d, 0x72, 0x1c, 0xad, 0x68, 0x5e, 0x35, 0x3f, 0xa9, 0xd7,
0x2c, 0x82, 0xed, 0x03, 0xd6, 0x75,
0xd8, 0xb7, 0x13, 0x33, 0x93, 0x52, 0x03, 0xbe,
0x34, 0x53, 0xea, 0xa1, 0x93,
0xe8, 0x37, 0xf1, 0x22, 0x0c,
0xbe, 0xbc, 0x84, 0xe3, 0xd1, 0x2e ]
, [ 0x4b, 0xea, 0x6b, 0xac, 0xad, 0x47
, 0x47, 0x99, 0x9a, 0x3f, 0x41, 0x0c, 0x6c, 0xa9, 0x23, 0x63, 0x7f, 0x15, 0x1c, 0x1f, 0x16, 0x86, 0x10, 0x4a, 0x35, 0x9e, 0x35, 0xd7, 0x80, 0x0f, 0xff, 0xbd, 0xbf, 0xcd,
0x17, 0x47, 0x25, 0x3a, 0xf5, 0xa3, 0xdf, 0xff
, 0x00, 0xb7, 0x23, 0x27, 0x1a, 0x16, 0x7a, 0x56, 0xa2, 0x7e, 0xa9, 0xea, 0x63, 0xf5, 0x60, 0x17, 0x58
0x6f, 0xa4, 0xc3, 0x3b, 0x7a, 0x30, 0x39, 0xc0, 0x2d, 0x66, 0xc4,
0xf9, 0x51, 0x42, 0xa4, 0x6c, 0x18,
, 0x8e, 0xc6, 0xcf, 0xfa, 0xa6, 0xb7, 0x1c, 0x9a, 0xb7, 0xb4, 0x0a, 0xf2,
, 0xbe, 0xc6, 0xb6, 0xbf, 0x71, 0xc5, 0x72, 0x36, 0x90, 0x4f, 0x35, 0xfa, 0x68, 0x40, 0x7a, 0x46, 0x64, 0x7d, 0x6e ],
[ 0xf4, 0xc7, 0x0e, 0x16, 0xee, 0xaa
, 0xc5, 0xec, 0x51, 0xac, 0x86, 0xfe, 0xbf, 0x24, 0x09, 0x54, 0x39, 0x9e, 0xc6, 0xc7, 0xe6, 0xbf, 0x87, 0xc9, 0xd3
, 0x47, 0x3e, 0x33, 0x19, 0x7a, 0x93, 0xc9, 0x09, 0x92, 0xab, 0xc5, 0x2d, 0x82, 0x2c, 0x37, 0x06, 0x47, 0x69, 0x83, 0x28, 0x4a, 0x05, 0x04, 0x35, 0x17, 0x45, 0x4c, 0xa2
, 0x3c, 0x4a, 0xf3, 0x88, 0x86, 0x56, 0x4d,
0x3a, 0x14, 0xd4, 0x93 ]
, [ 0x9b, 0x1f, 0x5b, 0x42, 0x4d, 0x93, 0xc9, 0xa7, 0x03, 0xe7, 0xaa, 0x02, 0x0c, 0x6e, 0x41, 0x41, 0x4e, 0xb7, 0xf8, 0x71, 0x9c, 0x36, 0xde,
0x1e, 0x89, 0xb4, 0x44, 0x3b, 0x4d,
0xdb, 0xc4, 0x9a, 0xf4, 0x89, 0x2b,
0xa5, 0xc4, 0x2f, 0x36, 0xac, 0xc2, 0x35, 0x59, 0x51, 0xa8, 0xd9, 0xa4
0x0d, 0xd4, 0xbf, 0x02, 0xe7, 0x1e ]
, [ 0x37, 0x8f, 0x5a, 0x54, 0x16, 0x31, 0x22, 0x9b, 0x94, 0x4c, 0x9a, 0xd8
, 0xec, 0x16, 0x5f, 0xde, 0x3a, 0x7d, 0x3a, 0x1b, 0x25, 0x89, 0x42, 0x24, 0x3c,
0xd9, 0x55, 0xb7, 0xe0, 0x0d, 0x09, 0x84, 0x80, 0x0a, 0x44, 0x0b, 0xdb,
0xb2, 0xce, 0xb1, 0x7b, 0x2b, 0x8a, 0x9a, 0xa6, 0x07, 0x9c, 0x54, 0x0e, 0x38,
0xdc, 0x92, 0xcb, 0x1f, 0x2a, 0x60, 0x72, 0x61, 0x44, 0x51, 0x83, 0x23, 0x5a, 0xdb ]
, [ 0xab, 0xbe, 0xde, 0xa6
, 0x80, 0x05, 0x6f, 0x52, 0x38,
0xb2, 0xe4, 0xf3, 0xf3, 0x89, 0x41, 0xe7, 0x1c, 0xff, 0x8a, 0x78, 0xdb, 0x1f, 0xff, 0xe1, 0x8a
, 0x1b, 0x33, 0x61, 0x03, 0x9f, 0xe7, 0x67, 0x02, 0xaf, 0x69,
0x33, 0x4b, 0x7a, 0x1e, 0x6c, 0x30, 0x3b, 0x76, 0x52, 0xf4
0xb6, 0xc3, 0x74, 0xb4, 0xc7, 0xfb, 0x98, 0x45,
0x21, 0x14, 0x84, 0x66, 0x79, 0x8a, 0x1d, 0x71, 0xef,
, 0x48, 0xb9, 0xca, 0xef, 0xba, 0xcd,
0x1d, 0x7d, 0x47, 0x6e, 0x98, 0xde, 0xa2, 0x59, 0x4a,
, 0xd8, 0x5d, 0x6b, 0xca, 0xa4,
0xb0, 0x04, 0x49, 0xb1, 0x7a
, 0xcd, 0xa4, 0x3c, 0x32, 0xbc, 0xdf, 0x1d, 0x77, 0xf8, 0x20, 0x12
, 0xd4, 0x30, 0x21, 0x9f, 0x9b, 0x5d, 0x80, 0xef, 0x9d, 0x18, 0x91, 0xcc, 0x86
, 0xe7, 0x1d, 0xa4, 0xaa, 0x88, 0xe1, 0x28, 0x52,
0xfa, 0xf4, 0x17, 0xd5, 0xd9, 0xb2, 0x1b, 0x99, 0x48, 0xbc, 0x92, 0x4a, 0xf1, 0x1b, 0xd7, 0x20 ] ]
def  AddModulo(self, A, B): result   [0]   64 t   0 for i in reversed(range(0, 64))
t & 0xFF return result def
[0]   64 for i in range(0, 64): result[i]
S(self, state): result   [0]   64 for i in range(0, 64): result[i]   self.
: result   [0]   64 for i in range(0, 64): result[i]   state[self.
: result   [0]   64 for i in range(0, 8):
j] for k in range(0, 8):
AddXor(K, m) for i in range(0, 12)
AddXor(state, K) return state def
, N, h, m): K   self.
G n(N, h, padded message)
N len   [0]   64 N len[63]
AddModulo(Sigma, padded message) return (h, N, Sigma
) def digest( self, message, out 512 ): return list2str( self.
GetHash( str2list( message ), out ) )
def GetHash(self, message, out 512, no pad False):
[0]   64 if out   512
: h   [0]   64 elif out   256: h   [0x01]   64 else: print("Wrong hash out length!")
[:: 1] while (length bits >  512): tmp
[:: 1] if (len(last)   0 and no pad)
: pass else: h, N,
G n(N 0, h, Sigma)
: return h[:: 1] elif out   256: return (h[0:32])
def hash(self, str message, out 512, no pad False): return list2str(self.
GetHash(str2list(str message), out, no pad))
S   Stribog() return S.hash(msg, out 256) def H512(msg):
" for i in range(n): res    chr(s & 0xFF) s >
,x,y], where g is GCD(a,b) and
x,y satisfy the equation g
"" a1 1; b1 0; a2 0; b2 1; aneg 1; bneg 1; swap   False if(a < 0): a    a;
aneg  1 if(b < 0): b    b; bneg  1 if(b > a): swap   True [a,b]
a   a % b a1   a1
b1   b1   quot b2 if(a   0): if(swap): return [b, b2 bneg, a2 aneg] else: return [b, a2 aneg, b2 bneg] quot
) b   b % a a2
b2   b2   quot b1 if(b   0)
: return [a, b1 bneg, a1 aneg] else: return [a, a1 aneg,
b1 bneg] def getMultByMask( elems, mask ):
r   1 for i in range
if mask & 1: r    elems[ n 1 i ] mask   mask >>
1 return r def subF(P,
other, p): return (P other) % p def divF(P, other, p)
invF(other, p), p) def addF(P, other, p): return (P   other) % p def
mulF(P, other, p): return (P   other
) % p def invF(R, p): assert (R !  0) return XGCD(R, p)[1]
% p def negF(R, p)
: return ( R) % p def powF(R, m, p): assert R !
None assert type(m) in (int, long)
if m   0: assert R !
return 1 elif m < 0
: t   invF(R, p) return powF(t, ( m), p)
i   m.bit length() 1 r   1 while i > 0:
if (m >> i) & 1: r   (r   R) % p r   (r   r) % p i    1 if m & 1: r   (r   R) % p return r def add(Px, Py, Qx, Qy, p, a, b): if Qx   Qy   None: return [Px, Py] if Px   Py   None
: return [Qx, Qy] if (Px   Qx)
and (Py   negF(Qy, p)): return [None, None] if (Px   Qx)
0 return duplicate(Px, Py, p, a) else:
( Qy, Py, p )
, subF( Qx, Px, p ), p )
( l, 2, p ), Px, p ), Qx, p ) resY
subF( Px, resX, p ), p ), Py, p ) return [resX
, resY] def duplicate(Px, Py, p, a):
if (Px   None) and (Py   None)
if Py   0: return [None, None]
l   divF(addF(mulF(powF(Px, 2, p), 3, p), a, p), mulF(Py, 2, p), p)
resX   subF(powF(l, 2, p), mulF(Px, 2, p), p) resY
subF(mulF(l, subF(Px, resX, p), p), Py, p) return [resX, resY]
def mul(Px, Py, s, p, a, b): assert
if (s >> i) & 1: resX, resY   add(resX, resY, X, Y, p, a, b) resX, resY   duplicate(resX,
resX, resY   add(resX, resY, X, Y, p, a, b) return [resX
, resY] def Ord(Px, Py, m, q, p, a, b)
(q !  None) assert mul(Px, Py, m, p, a, b)
m for mask in range(1 << len(q))
Rx, Ry   mul(X, Y, t, p, a, b)
if (Rx   None) and (Ry   None): r
min(r, t) return r def
if R   0: assert False temp   powF(R, ((p 1) / 2), p)
if temp   (p 1): return False else: assert temp   1 return True def getRandomQuadraticNonresidue(p): from random import randint r
% p while isQuadraticResidue(r, p)
: r   (randint(2, p 1))
% p return r def
( R, p ): assert R !
None assert isQuadraticResidue(R, p) if p % 4   3: res   powF(R, (p   1) / 4, p) if powF(res, 2, p) !
None return [res, negF(res, p)]
else: ainvF   invF(R, p) s   p 1 alpha   0
: alpha    1 s   s /
2 b   powF(getRandomQuadraticNonresidue(p), s, p)
powF(R, (s   1) / 2, p)
bj   1 for k in range(0, alpha 1):
x   powF(mulF(powF(mulF(bj, r, p), 2, p), ainvF, p), d, p)
: bj   mulF(bj, powF(b, (2    k), p), p) res   mulF(bj, r, p) return [res, negF(res, p)]
( p, pByteSize, a, b, m, q, orderDivisors, Px, Py, N ):
( 256 / 8, 512 / 8 ) PxBytes   num2le
m / q seed   0
while len( Qs ) !
QxBytes   H256( hashSrc ) else: QxBytes   H512( hashSrc )
seed    1 continue Qy sqrt
Qy   min(Qy sqrt) if co factor   Ord(Qx, Qy, m, orderDivisors, p, a, b) !
3410 2012 512 paramSetC" in curve["OID"]: Q, S, Hash src,
else: Q, S, Hash src, Hash res
j   1 for q, s, hash src, hash res in zip(Q, S, Hash src, Hash res): print "Point Q "
str(j) j    1 print "X ", hex(q[0])
[: 1] print "Y ", hex(q[1])
We thank Lolita Sonina, Georgiy Borodin, Sergey Agafin, and Ekaterina Smyshlyaeva for their careful readings and useful comments.
Authors' Addresses Stanislav Smyshlyaev (editor)
CRYPTO PRO 18, Suschevsky val
Russian Federation Phone:  7 (495)
995 48 20 Email: svs@cryptopro.ru Evgeny Alekseev CRYPTO PRO 18, Suschevsky val
Russian Federation Phone:  7 (495)
995 48 20 Email: alekseev@cryptopro.ru
Igor Oshkin CRYPTO PRO 18, Suschevsky val
Russian Federation Phone:  7 (495)
995 48 20 Email: oshkin@cryptopro.ru Vladimir Popov CRYPTO PRO 18, Suschevsky val
Russian Federation Phone:  7 (495)
995 48 20 Email: vpopov@cryptopro.ru
