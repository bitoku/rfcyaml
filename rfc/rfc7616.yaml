- title: __initial_text__
  contents:
  - '                   HTTP Digest Access Authentication

    '
- title: Abstract
  contents:
  - "Abstract\n   The Hypertext Transfer Protocol (HTTP) provides a simple challenge-\n\
    \   response authentication mechanism that may be used by a server to\n   challenge\
    \ a client request and by a client to provide authentication\n   information.\
    \  This document defines the HTTP Digest Authentication\n   scheme that can be\
    \ used with the HTTP authentication mechanism.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7616.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2015 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   4\n     1.1.  Terminology . . . . . . . . . . . . . . . . . . .\
    \ . . . .   4\n   2.  Syntax Convention . . . . . . . . . . . . . . . . . . .\
    \ . . .   4\n     2.1.  Examples  . . . . . . . . . . . . . . . . . . . . . .\
    \ . .   4\n     2.2.  ABNF  . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ .   4\n   3.  Digest Access Authentication Scheme . . . . . . . . . . . . .\
    \   5\n     3.1.  Overall Operation . . . . . . . . . . . . . . . . . . . .  \
    \ 5\n     3.2.  Representation of Digest Values . . . . . . . . . . . . .   5\n\
    \     3.3.  The WWW-Authenticate Response Header Field  . . . . . . .   5\n  \
    \   3.4.  The Authorization Header Field  . . . . . . . . . . . . .   9\n    \
    \   3.4.1.  Response  . . . . . . . . . . . . . . . . . . . . . .  11\n      \
    \ 3.4.2.  A1  . . . . . . . . . . . . . . . . . . . . . . . . .  11\n       3.4.3.\
    \  A2  . . . . . . . . . . . . . . . . . . . . . . . . .  12\n       3.4.4.  Username\
    \ Hashing  . . . . . . . . . . . . . . . . . .  12\n       3.4.5.  Parameter Values\
    \ and Quoted-String  . . . . . . . . .  12\n       3.4.6.  Various Considerations\
    \  . . . . . . . . . . . . . . .  13\n     3.5.  The Authentication-Info and Proxy-Authentication-Info\n\
    \           Header Fields . . . . . . . . . . . . . . . . . . . . . .  14\n  \
    \   3.6.  Digest Operation  . . . . . . . . . . . . . . . . . . . .  15\n    \
    \ 3.7.  Security Protocol Negotiation . . . . . . . . . . . . . .  16\n     3.8.\
    \  Proxy-Authenticate and Proxy-Authorization  . . . . . . .  17\n     3.9.  Examples\
    \  . . . . . . . . . . . . . . . . . . . . . . . .  18\n       3.9.1.  Example\
    \ with SHA-256 and MD5  . . . . . . . . . . . .  18\n       3.9.2.  Example with\
    \ SHA-512-256, Charset, and Userhash . . .  19\n   4.  Internationalization Considerations\
    \ . . . . . . . . . . . . .  20\n   5.  Security Considerations . . . . . . .\
    \ . . . . . . . . . . . .  21\n     5.1.  Limitations . . . . . . . . . . . .\
    \ . . . . . . . . . . .  21\n     5.2.  Storing Passwords . . . . . . . . . .\
    \ . . . . . . . . . .  21\n     5.3.  Authentication of Clients Using Digest Authentication\
    \ . .  22\n     5.4.  Limited-Use Nonce Values  . . . . . . . . . . . . . . .\
    \ .  23\n     5.5.  Replay Attacks  . . . . . . . . . . . . . . . . . . . . .\
    \  23\n     5.6.  Weakness Created by Multiple Authentication Schemes . . .  24\n\
    \     5.7.  Online Dictionary Attacks . . . . . . . . . . . . . . . .  24\n  \
    \   5.8.  Man-in-the-Middle Attacks . . . . . . . . . . . . . . . .  25\n    \
    \ 5.9.  Chosen Plaintext Attacks  . . . . . . . . . . . . . . . .  25\n     5.10.\
    \ Precomputed Dictionary Attacks  . . . . . . . . . . . . .  26\n     5.11. Batch\
    \ Brute-Force Attacks . . . . . . . . . . . . . . . .  26\n     5.12. Parameter\
    \ Randomness  . . . . . . . . . . . . . . . . . .  26\n     5.13. Summary . .\
    \ . . . . . . . . . . . . . . . . . . . . . . .  26\n   6.  IANA Considerations\
    \ . . . . . . . . . . . . . . . . . . . . .  27\n     6.1.  Hash Algorithms for\
    \ HTTP Digest Authentication  . . . . .  27\n     6.2.  Digest Scheme Registration\
    \  . . . . . . . . . . . . . . .  28\n   7.  References  . . . . . . . . . . .\
    \ . . . . . . . . . . . . . .  28\n     7.1.  Normative References  . . . . .\
    \ . . . . . . . . . . . . .  28\n     7.2.  Informative References  . . . . .\
    \ . . . . . . . . . . . .  30\n   Appendix A.  Changes from RFC 2617  . . . .\
    \ . . . . . . . . . . .  31\n   Acknowledgments . . . . . . . . . . . . . . .\
    \ . . . . . . . . . .  31\n   Authors' Addresses  . . . . . . . . . . . . . .\
    \ . . . . . . . . .  32\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   HTTP provides a simple challenge-response authentication\
    \ mechanism\n   that may be used by a server to challenge a client request and\
    \ by a\n   client to provide authentication information.  This document defines\n\
    \   the HTTP Digest Authentication scheme that can be used with the HTTP\n   authentication\
    \ mechanism.\n   This document extends but is generally backward compatible with\n\
    \   [RFC2617].  See Appendix A for the new capabilities introduced by\n   this\
    \ specification.\n   The details of the challenge-response authentication mechanism\
    \ are\n   specified in the \"Hypertext Transfer Protocol (HTTP/1.1):\n   Authentication\"\
    \ [RFC7235].\n   The combination of this document with the definition of the \"\
    Basic\"\n   authentication scheme [RFC7617], \"HTTP Authentication-Info and Proxy-\n\
    \   Authentication-Info Response Header Fields\" [RFC7615], and \"Hypertext\n\
    \   Transfer Protocol (HTTP/1.1): Authentication\" [RFC7235] obsolete\n   [RFC2617].\n"
- title: 1.1.  Terminology
  contents:
  - "1.1.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"\
    SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT\
    \ RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted\
    \ as described in\n   [RFC2119].\n"
- title: 2.  Syntax Convention
  contents:
  - '2.  Syntax Convention

    '
- title: 2.1.  Examples
  contents:
  - "2.1.  Examples\n   In the interest of clarity and readability, the extended parameters\n\
    \   or the header fields and parameters in the examples in this document\n   might\
    \ be broken into multiple lines.  Any line that is indented in\n   this document\
    \ is a continuation of the preceding line.\n"
- title: 2.2.  ABNF
  contents:
  - "2.2.  ABNF\n   This specification uses the Augmented Backus-Naur Form (ABNF)\n\
    \   notation of [RFC5234] and the ABNF List Extension of [RFC7230].\n"
- title: 3.  Digest Access Authentication Scheme
  contents:
  - '3.  Digest Access Authentication Scheme

    '
- title: 3.1.  Overall Operation
  contents:
  - "3.1.  Overall Operation\n   The Digest scheme is based on a simple challenge-response\
    \ paradigm.\n   The Digest scheme challenges using a nonce value and might indicate\n\
    \   that username hashing is supported.  A valid response contains an\n   unkeyed\
    \ digest of the username, the password, the given nonce value,\n   the HTTP method,\
    \ and the requested URI.  In this way, the password is\n   never sent in the clear,\
    \ and the username can be hashed, depending on\n   the indication received from\
    \ the server.  The username and password\n   must be prearranged in some fashion\
    \ not addressed by this document.\n"
- title: 3.2.  Representation of Digest Values
  contents:
  - "3.2.  Representation of Digest Values\n   An optional header field allows the\
    \ server to specify the algorithm\n   used to create the unkeyed digest or digest.\
    \  This document adds\n   SHA-256 and SHA-512/256 algorithms.  To maintain backwards\n\
    \   compatibility with [RFC2617], the MD5 algorithm is still supported\n   but\
    \ NOT RECOMMENDED.\n   The size of the digest depends on the algorithm used. \
    \ The bits in\n   the digest are converted from the most significant to the least\n\
    \   significant bit, four bits at a time, to the ASCII representation as\n   follows.\
    \  Each sequence of four bits is represented by its familiar\n   hexadecimal notation\
    \ from the characters 0123456789abcdef; that is,\n   binary 0000 is represented\
    \ by the character '0', 0001 by '1' and so\n   on up to the representation of\
    \ 1111 as 'f'.  If the MD5 algorithm is\n   used to calculate the digest, then\
    \ the MD5 digest will be represented\n   as 32 hexadecimal characters, while SHA-256\
    \ and SHA-512/256 are\n   represented as 64 hexadecimal characters.\n"
- title: 3.3.  The WWW-Authenticate Response Header Field
  contents:
  - "3.3.  The WWW-Authenticate Response Header Field\n   If a server receives a request\
    \ for an access-protected object, and an\n   acceptable Authorization header field\
    \ is not sent, the server\n   responds with a \"401 Unauthorized\" status code\
    \ and a WWW-Authenticate\n   header field with Digest scheme as per the framework\
    \ defined above.\n   The value of the header field can include parameters from\
    \ the\n   following list:\n   realm\n      A string to be displayed to users so\
    \ they know which username and\n      password to use.  This string should contain\
    \ at least the name of\n      the host performing the authentication and might\
    \ additionally\n      indicate the collection of users who might have access.\
    \  An\n      example is \"registered_users@example.com\".  (See Section 2.2 of\n\
    \      [RFC7235] for more details.)\n   domain\n      A quoted, space-separated\
    \ list of URIs, as specified in [RFC3986],\n      that define the protection space.\
    \  If a URI is a path-absolute, it\n      is relative to the canonical root URL.\
    \  (See Section 2.2 of\n      [RFC7235].)  An absolute-URI in this list may refer\
    \ to a different\n      server than the web-origin [RFC6454].  The client can\
    \ use this\n      list to determine the set of URIs for which the same\n     \
    \ authentication information may be sent: any URI that has a URI in\n      this\
    \ list as a prefix (after both have been made absolute) MAY be\n      assumed\
    \ to be in the same protection space.  If this parameter is\n      omitted or\
    \ its value is empty, the client SHOULD assume that the\n      protection space\
    \ consists of all URIs on the web-origin.\n      This parameter is not meaningful\
    \ in Proxy-Authenticate header\n      fields, for which the protection space is\
    \ always the entire proxy;\n      if present, it MUST be ignored.\n   nonce\n\
    \      A server-specified string which should be uniquely generated each\n   \
    \   time a 401 response is made.  It is advised that this string be\n      Base64\
    \ or hexadecimal data.  Specifically, since the string is\n      passed in the\
    \ header field lines as a quoted string, the double-\n      quote character is\
    \ not allowed, unless suitably escaped.\n      The contents of the nonce are implementation\
    \ dependent.  The\n      quality of the implementation depends on a good choice.\
    \  A nonce\n      might, for example, be constructed as the Base64 encoding of\n\
    \            timestamp H(timestamp \":\" ETag \":\" secret-data)\n      where\
    \ timestamp is a server-generated time, which preferably\n      includes micro-\
    \ or nanoseconds, or other non-repeating values;\n      ETag is the value of the\
    \ HTTP ETag header field associated with\n      the requested entity; and secret-data\
    \ is data known only to the\n      server.  With a nonce of this form, a server\
    \ would recalculate the\n      hash portion after receiving the client authentication\
    \ header\n      field and reject the request if it did not match the nonce from\n\
    \      that header field or if the timestamp value is not recent enough.\n   \
    \   In this way, the server can limit the time of the nonce's\n      validity.\
    \  The inclusion of the ETag prevents a replay request for\n      an updated version\
    \ of the resource.  Including the IP address of\n      the client in the nonce\
    \ would appear to offer the server the\n      ability to limit the reuse of the\
    \ nonce to the same client that\n      originally got it.  However, that would\
    \ break because requests\n      from a single user often go through different\
    \ proxies.  Also, IP\n      address spoofing is not that hard.\n      An implementation\
    \ might choose not to accept a previously used\n      nonce or a previously used\
    \ digest, in order to protect against a\n      replay attack.  Or, an implementation\
    \ might choose to use one-time\n      nonces or digests for POST or PUT requests\
    \ and a timestamp for GET\n      requests.  For more details on the issues involved,\
    \ see Section 5\n      of this document.\n      The nonce is opaque to the client.\n\
    \   opaque\n      A string of data, specified by the server, that SHOULD be returned\n\
    \      by the client unchanged in the Authorization header field of\n      subsequent\
    \ requests with URIs in the same protection space.  It is\n      RECOMMENDED that\
    \ this string be Base64 or hexadecimal data.\n   stale\n      A case-insensitive\
    \ flag indicating that the previous request from\n      the client was rejected\
    \ because the nonce value was stale.  If\n      stale is true, the client may\
    \ wish to simply retry the request\n      with a new encrypted response, without\
    \ re-prompting the user for a\n      new username and password.  The server SHOULD\
    \ only set stale to\n      true if it receives a request for which the nonce is\
    \ invalid.  If\n      stale is false, or anything other than true, or the stale\n\
    \      parameter is not present, the username and/or password are\n      invalid,\
    \ and new values MUST be obtained.\n   algorithm\n      A string indicating an\
    \ algorithm used to produce the digest and an\n      unkeyed digest.  If this\
    \ is not present, it is assumed to be\n      \"MD5\".  If the algorithm is not\
    \ understood, the challenge SHOULD\n      be ignored (and a different one used,\
    \ if there is more than one).\n      When used with the Digest mechanism, each\
    \ one of the algorithms\n      has two variants: Session variant and non-Session\
    \ variant.  The\n      non-Session variant is denoted by \"<algorithm>\", e.g.,\
    \ \"SHA-256\",\n      and the Session variant is denoted by \"<algorithm>-sess\"\
    , e.g.,\n      \"SHA-256-sess\".\n      In this document, the string obtained\
    \ by applying the digest\n      algorithm to the data \"data\" with secret \"\
    secret\" will be denoted\n      by KD(secret, data), and the string obtained by\
    \ applying the\n      unkeyed digest algorithm to the data \"data\" will be denoted\n\
    \      H(data).  KD stands for Keyed Digest, and the notation unq(X)\n      means\
    \ the value of the quoted-string X without the surrounding\n      quotes and with\
    \ quoting slashes removed.\n        For \"<algorithm>\" and \"<algorithm>-sess\"\
    \n            H(data) = <algorithm>(data)\n        and\n            KD(secret,\
    \ data) = H(concat(secret, \":\", data))\n      For example:\n        For the\
    \ \"SHA-256\" and \"SHA-256-sess\" algorithms\n            H(data) = SHA-256(data)\n\
    \      i.e., the digest is the \"<algorithm>\" of the secret concatenated\n  \
    \    with a colon concatenated with the data.  The \"<algorithm>-sess\"\n    \
    \  is intended to allow efficient third-party authentication servers;\n      for\
    \ the difference in usage, see the description in Section 3.4.2.\n   qop\n   \
    \   This parameter MUST be used by all implementations.  It is a\n      quoted\
    \ string of one or more tokens indicating the \"quality of\n      protection\"\
    \ values supported by the server.  The value \"auth\"\n      indicates authentication;\
    \ the value \"auth-int\" indicates\n      authentication with integrity protection.\
    \  See the descriptions\n      below for calculating the response parameter value\
    \ for the\n      application of this choice.  Unrecognized options MUST be ignored.\n\
    \   charset\n      This is an OPTIONAL parameter that is used by the server to\n\
    \      indicate the encoding scheme it supports.  The only allowed value\n   \
    \   is \"UTF-8\".\n   userhash\n      This is an OPTIONAL parameter that is used\
    \ by the server to\n      indicate that it supports username hashing.  Valid values\
    \ are:\n      \"true\" or \"false\".  Default value is \"false\".\n   For historical\
    \ reasons, a sender MUST only generate the quoted string\n   syntax values for\
    \ the following parameters: realm, domain, nonce,\n   opaque, and qop.\n   For\
    \ historical reasons, a sender MUST NOT generate the quoted string\n   syntax\
    \ values for the following parameters: stale and algorithm.\n"
- title: 3.4.  The Authorization Header Field
  contents:
  - "3.4.  The Authorization Header Field\n   The client is expected to retry the\
    \ request, passing an Authorization\n   header field line with Digest scheme,\
    \ which is defined according to\n   the framework above.  The values of the opaque\
    \ and algorithm fields\n   must be those supplied in the WWW-Authenticate response\
    \ header field\n   for the entity being requested.\n   The request can include\
    \ parameters from the following list:\n   response\n      A string of the hex\
    \ digits computed as defined below; it proves\n      that the user knows a password.\n\
    \   username\n      The user's name in the specified realm.  The quoted string\n\
    \      contains the name in plaintext or the hash code in hexadecimal\n      notation.\
    \  If the username contains characters not allowed inside\n      the ABNF quoted-string\
    \ production, the username* parameter can be\n      used.  Sending both username\
    \ and username* in the same header\n      option MUST be treated as an error.\n\
    \   username*\n      If the userhash parameter value is set \"false\" and the\
    \ username\n      contains characters not allowed inside the ABNF quoted-string\n\
    \      production, the user's name can be sent with this parameter, using\n  \
    \    the extended notation defined in [RFC5987].\n   realm\n      See \"realm\"\
    \ definition in Section 3.3.\n   uri\n      The Effective Request URI (Section\
    \ 5.5 of [RFC7230]) of the HTTP\n      request; duplicated here because proxies\
    \ are allowed to change the\n      request target (\"request-target\", Section\
    \ 3.1.1 of [RFC7230]) in\n      transit.\n   qop\n      Indicates what \"quality\
    \ of protection\" the client has applied to\n      the message.  Its value MUST\
    \ be one of the alternatives the server\n      indicated it supports in the WWW-Authenticate\
    \ header field.  These\n      values affect the computation of the response. \
    \ Note that this is\n      a single token, not a quoted list of alternatives as\
    \ in WWW-\n      Authenticate.\n   cnonce\n      This parameter MUST be used by\
    \ all implementations.  The cnonce\n      value is an opaque quoted ASCII-only\
    \ string value provided by the\n      client and used by both client and server\
    \ to avoid chosen\n      plaintext attacks, to provide mutual authentication,\
    \ and to\n      provide some message integrity protection.  See the descriptions\n\
    \      below of the calculation of the rspauth and response values.\n   nc\n \
    \     This parameter MUST be used by all implementations.  The nc\n      parameter\
    \ stands for \"nonce count\".  The nc value is the\n      hexadecimal count of\
    \ the number of requests (including the current\n      request) that the client\
    \ has sent with the nonce value in this\n      request.  For example, in the first\
    \ request sent in response to a\n      given nonce value, the client sends \"\
    nc=00000001\".  The purpose of\n      this parameter is to allow the server to\
    \ detect request replays by\n      maintaining its own copy of this count -- if\
    \ the same nc value is\n      seen twice, then the request is a replay.  See the\
    \ description\n      below of the construction of the response value.\n   userhash\n\
    \      This OPTIONAL parameter is used by the client to indicate that the\n  \
    \    username has been hashed.  Valid values are: \"true\" or \"false\".\n   \
    \   Default value is \"false\".\n   For historical reasons, a sender MUST only\
    \ generate the quoted string\n   syntax for the following parameters: username,\
    \ realm, nonce, uri,\n   response, cnonce, and opaque.\n   For historical reasons,\
    \ a sender MUST NOT generate the quoted string\n   syntax for the following parameters:\
    \ algorithm, qop, and nc.\n   If a parameter or its value is improper, or required\
    \ parameters are\n   missing, the proper response is a 4xx error code.  If the\
    \ response is\n   invalid, then a login failure SHOULD be logged, since repeated\
    \ login\n   failures from a single client may indicate an attacker attempting\
    \ to\n   guess passwords.  The server implementation SHOULD be careful with\n\
    \   the information being logged so that it won't put a cleartext\n   password\
    \ (e.g., entered into the username field) into the log.\n   The definition of\
    \ the response above indicates the encoding for its\n   value.  The following\
    \ definitions show how the value is computed.\n"
- title: 3.4.1.  Response
  contents:
  - "3.4.1.  Response\n   If the qop value is \"auth\" or \"auth-int\":\n        \
    \ response = <\"> < KD ( H(A1), unq(nonce)\n                                 \
    \     \":\" nc\n                                      \":\" unq(cnonce)\n    \
    \                                  \":\" unq(qop)\n                          \
    \            \":\" H(A2)\n                             ) <\">\n   See below for\
    \ the definitions for A1 and A2.\n"
- title: 3.4.2.  A1
  contents:
  - "3.4.2.  A1\n   If the algorithm parameter's value is \"<algorithm>\", e.g., \"\
    SHA-256\",\n   then A1 is:\n         A1       = unq(username) \":\" unq(realm)\
    \ \":\" passwd\n   where\n         passwd   = < user's password >\n   If the algorithm\
    \ parameter's value is \"<algorithm>-sess\", e.g., \"SHA-\n   256-sess\", then\
    \ A1 is calculated using the nonce value provided in\n   the challenge from the\
    \ server, and cnonce value from the request by\n   the client following receipt\
    \ of a WWW-Authenticate challenge from the\n   server.  It uses the server nonce\
    \ from that challenge, herein called\n   nonce-prime, and the client nonce value\
    \ from the response, herein\n   called cnonce-prime, to construct A1 as follows:\n\
    \         A1       = H( unq(username) \":\" unq(realm) \":\" passwd )\n      \
    \                  \":\" unq(nonce-prime) \":\" unq(cnonce-prime)\n   This creates\
    \ a \"session key\" for the authentication of subsequent\n   requests and responses\
    \ that is different for each \"authentication\n   session\", thus limiting the\
    \ amount of material hashed with any one\n   key.  (Note: see further discussion\
    \ of the authentication session in\n   Section 3.6.)  Because the server needs\
    \ only use the hash of the user\n   credentials in order to create the A1 value,\
    \ this construction could\n   be used in conjunction with a third-party authentication\
    \ service so\n   that the web server would not need the actual password value.\
    \  The\n   specification of such a protocol is beyond the scope of this\n   specification.\n"
- title: 3.4.3.  A2
  contents:
  - "3.4.3.  A2\n   If the qop parameter's value is \"auth\" or is unspecified, then\
    \ A2 is:\n         A2       = Method \":\" request-uri\n   If the qop value is\
    \ \"auth-int\", then A2 is:\n         A2       = Method \":\" request-uri \":\"\
    \ H(entity-body)\n"
- title: 3.4.4.  Username Hashing
  contents:
  - "3.4.4.  Username Hashing\n   To protect the transport of the username from the\
    \ client to the\n   server, the server SHOULD set the userhash parameter with\
    \ the value\n   of \"true\" in the WWW-Authentication header field.\n   If the\
    \ client supports the userhash parameter, and the userhash\n   parameter value\
    \ in the WWW-Authentication header field is set to\n   \"true\", then the client\
    \ MUST calculate a hash of the username after\n   any other hash calculation and\
    \ include the userhash parameter with\n   the value of \"true\" in the Authorization\
    \ header field.  If the client\n   does not provide the username as a hash value\
    \ or the userhash\n   parameter with the value of \"true\", the server MAY reject\
    \ the\n   request.\n   The following is the operation that the client will perform\
    \ to hash\n   the username, using the same algorithm used to hash the credentials:\n\
    \      username = H( unq(username) \":\" unq(realm) )\n"
- title: 3.4.5.  Parameter Values and Quoted-String
  contents:
  - "3.4.5.  Parameter Values and Quoted-String\n   Note that the value of many of\
    \ the parameters, such as username\n   value, are defined as a \"quoted-string\"\
    .  However, the \"unq\" notation\n   indicates that surrounding quotation marks\
    \ are removed in forming the\n   string A1.  Thus, if the Authorization header\
    \ field includes the\n   fields\n      username=\"Mufasa\", realm=\"myhost@example.com\"\
    \n   and the user Mufasa has password \"Circle Of Life\", then H(A1) would\n \
    \  be H(Mufasa:myhost@example.com:Circle Of Life) with no quotation\n   marks\
    \ in the digested string.\n   No white space is allowed in any of the strings\
    \ to which the digest\n   function H() is applied, unless that white space exists\
    \ in the quoted\n   strings or entity body whose contents make up the string to\
    \ be\n   digested.  For example, the string A1 illustrated above must be\n   \
    \   Mufasa:myhost@example.com:Circle Of Life\n   with no white space on either\
    \ side of the colons, but with the white\n   space between the words used in the\
    \ password value.  Likewise, the\n   other strings digested by H() must not have\
    \ white space on either\n   side of the colons that delimit their fields, unless\
    \ that white space\n   was in the quoted strings or entity body being digested.\n\
    \   Also, note that if integrity protection is applied (qop=auth-int),\n   the\
    \ H(entity-body) is the hash of the entity body, not the message\n   body -- it\
    \ is computed before any transfer encoding is applied by the\n   sender and after\
    \ it has been removed by the recipient.  Note that\n   this includes multipart\
    \ boundaries and embedded header fields in each\n   part of any multipart content-type.\n"
- title: 3.4.6.  Various Considerations
  contents:
  - "3.4.6.  Various Considerations\n   The \"Method\" value is the HTTP request method,\
    \ in US-ASCII letters,\n   as specified in Section 3.1.1 of [RFC7230].  The \"\
    request-target\"\n   value is the request-target from the request line as specified\
    \ in\n   Section 3.1.1 of [RFC7230].  This MAY be \"*\", an \"absolute-URI\",\
    \ or\n   an \"absolute-path\" as specified in Section 2.7 of [RFC7230], but it\n\
    \   MUST agree with the request-target.  In particular, it MUST be an\n   \"absolute-URI\"\
    \ if the request-target is an \"absolute-URI\".  The\n   cnonce value is a client-chosen\
    \ value whose purpose is to foil chosen\n   plaintext attacks.\n   The authenticating\
    \ server MUST assure that the resource designated by\n   the \"uri\" parameter\
    \ is the same as the resource specified in the\n   Request-Line; if they are not,\
    \ the server SHOULD return a 400 Bad\n   Request error.  (Since this may be a\
    \ symptom of an attack, server\n   implementers may want to consider logging such\
    \ errors.)  The purpose\n   of duplicating information from the request URL in\
    \ this field is to\n   deal with the possibility that an intermediate proxy may\
    \ alter the\n   client's Request-Line.  This altered (but presumably semantically\n\
    \   equivalent) request would not result in the same digest as that\n   calculated\
    \ by the client.\n   Implementers should be aware of how authenticated transactions\
    \ need\n   to interact with shared caches (see [RFC7234]).\n"
- title: 3.5.  The Authentication-Info and Proxy-Authentication-Info Header
  contents:
  - "3.5.  The Authentication-Info and Proxy-Authentication-Info Header\n      Fields\n\
    \   The Authentication-Info header field and the Proxy-Authentication-\n   Info\
    \ header field [RFC7615] are generic fields that MAY be used by a\n   server to\
    \ communicate some information regarding the successful\n   authentication of\
    \ a client response.\n   The Digest Authentication scheme MAY add the Authentication-Info\n\
    \   header field in the confirmation request and include parameters from\n   the\
    \ following list:\n   nextnonce\n      The value of the nextnonce parameter is\
    \ the nonce the server\n      wishes the client to use for a future authentication\
    \ response.\n      The server MAY send the Authentication-Info header field with\
    \ a\n      nextnonce field as a means of implementing one-time nonces or\n   \
    \   otherwise changing nonces.  If the nextnonce field is present, the\n     \
    \ client SHOULD use it when constructing the Authorization header\n      field\
    \ for its next request.  Failure of the client to do so MAY\n      result in a\
    \ request to re-authenticate from the server with the\n      \"stale=true\".\n\
    \         Server implementations SHOULD carefully consider the\n         performance\
    \ implications of the use of this mechanism;\n         pipelined requests will\
    \ not be possible if every response\n         includes a nextnonce parameter that\
    \ MUST be used on the next\n         request received by the server.  Consideration\
    \ SHOULD be given\n         to the performance vs. security tradeoffs of allowing\
    \ an old\n         nonce value to be used for a limited time to permit request\n\
    \         pipelining.  Use of the nc parameter can retain most of the\n      \
    \   security advantages of a new server nonce without the\n         deleterious\
    \ effects on pipelining.\n   qop\n      Indicates the \"quality of protection\"\
    \ options applied to the\n      response by the server.  The value \"auth\" indicates\n\
    \      authentication; the value \"auth-int\" indicates authentication with\n\
    \      integrity protection.  The server SHOULD use the same value for\n     \
    \ the qop parameter in the response as was sent by the client in the\n      corresponding\
    \ request.\n   rspauth\n      The optional response digest in the rspauth parameter\
    \ supports\n      mutual authentication -- the server proves that it knows the\n\
    \      user's secret, and with qop=auth-int also provides limited\n      integrity\
    \ protection of the response.  The rspauth value is\n      calculated as for the\
    \ response in the Authorization header field,\n      except that if qop is set\
    \ to \"auth\" or is not specified in the\n      Authorization header field for\
    \ the request, A2 is\n         A2       = \":\" request-uri\n      and if \"qop=auth-int\"\
    , then A2 is\n         A2       = \":\" request-uri \":\" H(entity-body)\n   cnonce\
    \ and nc\n      The cnonce value and nc value MUST be the ones for the client\n\
    \      request to which this message is the response.  The rspauth,\n      cnonce,\
    \ and nc parameters MUST be present if \"qop=auth\" or\n      \"qop=auth-int\"\
    \ is specified.\n   The Authentication-Info header field is allowed in the trailer\
    \ of an\n   HTTP message transferred via chunked transfer coding.\n   For historical\
    \ reasons, a sender MUST only generate the quoted string\n   syntax for the following\
    \ parameters: nextnonce, rspauth, and cnonce.\n   For historical reasons, a sender\
    \ MUST NOT generate the quoted string\n   syntax for the following parameters:\
    \ qop and nc.\n   For historical reasons, the nc value MUST be exactly 8 hexadecimal\n\
    \   digits.\n"
- title: 3.6.  Digest Operation
  contents:
  - "3.6.  Digest Operation\n   Upon receiving the Authorization header field, the\
    \ server MAY check\n   its validity by looking up the password that corresponds\
    \ to the\n   submitted username.  Then, the server MUST perform the same digest\n\
    \   operation (e.g., MD5, SHA-256) performed by the client and compare\n   the\
    \ result to the given response value.\n   Note that the HTTP server does not actually\
    \ need to know the user's\n   cleartext password.  As long as H(A1) is available\
    \ to the server, the\n   validity of an Authorization header field can be verified.\n\
    \   The client response to a WWW-Authenticate challenge for a protection\n   space\
    \ starts an authentication session with that protection space.\n   The authentication\
    \ session lasts until the client receives another\n   WWW-Authenticate challenge\
    \ from any server in the protection space.\n   A client SHOULD remember the username,\
    \ password, nonce, nonce count,\n   and opaque values associated with an authentication\
    \ session to use to\n   construct the Authorization header field in future requests\
    \ within\n   that protection space.  The Authorization header field MAY be\n \
    \  included preemptively; doing so improves server efficiency and avoids\n   extra\
    \ round trips for authentication challenges.  The server MAY\n   choose to accept\
    \ the old Authorization header field information, even\n   though the nonce value\
    \ included might not be fresh.  Alternatively,\n   the server MAY return a 401\
    \ response with a new nonce value in the\n   WWW-Authenticate header field, causing\
    \ the client to retry the\n   request; by specifying \"stale=true\" with this\
    \ response, the server\n   tells the client to retry with the new nonce, but without\
    \ prompting\n   for a new username and password.\n   Because the client is required\
    \ to return the value of the opaque\n   parameter given to it by the server for\
    \ the duration of a session,\n   the opaque data can be used to transport authentication\
    \ session state\n   information.  (Note that any such use can also be accomplished\
    \ more\n   easily and safely by including the state in the nonce.)  For example,\n\
    \   a server could be responsible for authenticating content that\n   actually\
    \ sits on another server.  It would achieve this by having the\n   first 401 response\
    \ include a domain parameter whose value includes a\n   URI on the second server,\
    \ and an opaque parameter whose value\n   contains the state information.  The\
    \ client will retry the request,\n   at which time the server might respond with\
    \ \"HTTP Redirection\"\n   (Section 6.4 of [RFC7231]), pointing to the URI on\
    \ the second server.\n   The client will follow the redirection and pass an Authorization\n\
    \   header field, including the <opaque> data.\n   Proxies MUST be completely\
    \ transparent in the Digest access\n   authentication scheme.  That is, they MUST\
    \ forward the WWW-\n   Authenticate, Authentication-Info, and Authorization header\
    \ fields\n   untouched.  If a proxy wants to authenticate a client before a\n\
    \   request is forwarded to the server, it can be done using the Proxy-\n   Authenticate\
    \ and Proxy-Authorization header fields described in\n   Section 3.8 below.\n"
- title: 3.7.  Security Protocol Negotiation
  contents:
  - "3.7.  Security Protocol Negotiation\n   It is useful for a server to be able\
    \ to know which security schemes a\n   client is capable of handling.\n   It is\
    \ possible that a server wants to require Digest as its\n   authentication method,\
    \ even if the server does not know that the\n   client supports it.  A client\
    \ is encouraged to fail gracefully if the\n   server specifies only authentication\
    \ schemes it cannot handle.\n   When a server receives a request to access a resource,\
    \ the server\n   might challenge the client by responding with \"401 Unauthorized\"\
    \n   response and include one or more WWW-Authenticate header fields.  If\n  \
    \ the server responds with multiple challenges, then each one of these\n   challenges\
    \ MUST use a different digest algorithm.  The server MUST\n   add these challenges\
    \ to the response in order of preference, starting\n   with the most preferred\
    \ algorithm, followed by the less preferred\n   algorithm.\n   This specification\
    \ defines the following algorithms:\n   o  SHA2-256 (mandatory to implement)\n\
    \   o  SHA2-512/256 (as a backup algorithm)\n   o  MD5 (for backward compatibility).\n\
    \   When the client receives the first challenge, it SHOULD use the first\n  \
    \ challenge it supports, unless a local policy dictates otherwise.\n"
- title: 3.8.  Proxy-Authenticate and Proxy-Authorization
  contents:
  - "3.8.  Proxy-Authenticate and Proxy-Authorization\n   The Digest Authentication\
    \ scheme can also be used for authenticating\n   users to proxies, proxies to\
    \ proxies, or proxies to origin servers by\n   use of the Proxy-Authenticate and\
    \ Proxy-Authorization header fields.\n   These header fields are instances of\
    \ the Proxy-Authenticate and\n   Proxy-Authorization header fields specified in\
    \ Sections 4.3 and 4.4\n   of the HTTP/1.1 specification [RFC7235], and their\
    \ behavior is\n   subject to restrictions described there.  The transactions for\
    \ proxy\n   authentication are very similar to those already described.  Upon\n\
    \   receiving a request that requires authentication, the proxy/server\n   MUST\
    \ issue the \"407 Proxy Authentication Required\" response with a\n   \"Proxy-Authenticate\"\
    \ header field.  The digest-challenge used in the\n   Proxy-Authenticate header\
    \ field is the same as that for the WWW-\n   Authenticate header field as defined\
    \ above in Section 3.3.\n   The client/proxy MUST then reissue the request with\
    \ a Proxy-\n   Authorization header field, with parameters as specified for the\n\
    \   Authorization header field in Section 3.4 above.\n   On subsequent responses,\
    \ the server sends Proxy-Authentication-Info\n   with parameters the same as those\
    \ for the Authentication-Info header\n   field.\n   Note that, in principle, a\
    \ client could be asked to authenticate\n   itself to both a proxy and an end-server,\
    \ but never in the same\n   response.\n"
- title: 3.9.  Examples
  contents:
  - '3.9.  Examples

    '
- title: 3.9.1.  Example with SHA-256 and MD5
  contents:
  - "3.9.1.  Example with SHA-256 and MD5\n   The following example assumes that an\
    \ access-protected document is\n   being requested from the server via a GET request.\
    \  The URI of the\n   document is \"http://www.example.org/dir/index.html\". \
    \ Both client and\n   server know that the username for this document is \"Mufasa\"\
    \ and the\n   password is \"Circle of Life\" (with one space between each of the\n\
    \   three words).\n   The first time the client requests the document, no Authorization\n\
    \   header field is sent, so the server responds with:\n   HTTP/1.1 401 Unauthorized\n\
    \   WWW-Authenticate: Digest\n       realm=\"http-auth@example.org\",\n      \
    \ qop=\"auth, auth-int\",\n       algorithm=SHA-256,\n       nonce=\"7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v\"\
    ,\n       opaque=\"FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS\"\n   WWW-Authenticate:\
    \ Digest\n       realm=\"http-auth@example.org\",\n       qop=\"auth, auth-int\"\
    ,\n       algorithm=MD5,\n       nonce=\"7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v\"\
    ,\n       opaque=\"FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS\"\n   The client\
    \ can prompt the user for their username and password, after\n   which it will\
    \ respond with a new request, including the following\n   Authorization header\
    \ field if the client chooses MD5 digest:\n   Authorization: Digest username=\"\
    Mufasa\",\n       realm=\"http-auth@example.org\",\n       uri=\"/dir/index.html\"\
    ,\n       algorithm=MD5,\n       nonce=\"7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v\"\
    ,\n       nc=00000001,\n       cnonce=\"f2/wE4q74E6zIJEtWaHKaf5wv/H5QzzpXusqGemxURZJ\"\
    ,\n       qop=auth,\n       response=\"8ca523f5e9506fed4657c9700eebdbec\",\n \
    \      opaque=\"FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS\"\n   If the client\
    \ chooses to use the SHA-256 algorithm for calculating\n   the response, the client\
    \ responds with a new request including the\n   following Authorization header\
    \ field:\n   Authorization: Digest username=\"Mufasa\",\n       realm=\"http-auth@example.org\"\
    ,\n       uri=\"/dir/index.html\",\n       algorithm=SHA-256,\n       nonce=\"\
    7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v\",\n       nc=00000001,\n       cnonce=\"\
    f2/wE4q74E6zIJEtWaHKaf5wv/H5QzzpXusqGemxURZJ\",\n       qop=auth,\n       response=\"\
    753927fa0e85d155564e2e272a28d1802ca10daf449\n          6794697cf8db5856cb6c1\"\
    ,\n       opaque=\"FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS\"\n"
- title: 3.9.2.  Example with SHA-512-256, Charset, and Userhash
  contents:
  - "3.9.2.  Example with SHA-512-256, Charset, and Userhash\n   The following example\
    \ assumes that an access-protected document is\n   being requested from the server\
    \ via a GET request.  The URI for the\n   request is \"http://api.example.org/doe.json\"\
    .  Both client and server\n   know the userhash of the username, support the UTF-8\
    \ character\n   encoding scheme, and use the SHA-512-256 algorithm.  The username\
    \ for\n   the request is a variation of \"Jason Doe\", where the 'a' actually\
    \ is\n   Unicode code point U+00E4 (\"LATIN SMALL LETTER A WITH DIAERESIS\"),\n\
    \   and the first 'o' is Unicode code point U+00F8 (\"LATIN SMALL LETTER O\n \
    \  WITH STROKE\"), leading to the octet sequence using the UTF-8 encoding\n  \
    \ scheme:\n      J  U+00E4 s  U+00F8 n      D  o  e\n      4A C3A4   73 C3B8 \
    \  6E 20 44  6F 65\n   The password is \"Secret, or not?\".\n   The first time\
    \ the client requests the document, no Authorization\n   header field is sent,\
    \ so the server responds with:\n   HTTP/1.1 401 Unauthorized\n   WWW-Authenticate:\
    \ Digest\n       realm=\"api@example.org\",\n       qop=\"auth\",\n       algorithm=SHA-512-256,\n\
    \       nonce=\"5TsQWLVdgBdmrQ0XsxbDODV+57QdFR34I9HAbC/RVvkK\",\n       opaque=\"\
    HRPCssKJSGjCrkzDg8OhwpzCiGPChXYjwrI2QmXDnsOS\",\n       charset=UTF-8,\n     \
    \  userhash=true\n   The client can prompt the user for the required credentials\
    \ and send\n   a new request with following Authorization header field:\n   Authorization:\
    \ Digest\n       username=\"488869477bf257147b804c45308cd62ac4e25eb717\n     \
    \     b12b298c79e62dcea254ec\",\n       realm=\"api@example.org\",\n       uri=\"\
    /doe.json\",\n       algorithm=SHA-512-256,\n       nonce=\"5TsQWLVdgBdmrQ0XsxbDODV+57QdFR34I9HAbC/RVvkK\"\
    ,\n       nc=00000001,\n       cnonce=\"NTg6RKcb9boFIAS3KrFK9BGeh+iDa/sm6jUMp2wds69v\"\
    ,\n       qop=auth,\n       response=\"ae66e67d6b427bd3f120414a82e4acff38e8ecd9101d\n\
    \          6c861229025f607a79dd\",\n       opaque=\"HRPCssKJSGjCrkzDg8OhwpzCiGPChXYjwrI2QmXDnsOS\"\
    ,\n       userhash=true\n   If the client cannot provide a hashed username for\
    \ any reason, the\n   client can try a request with this Authorization header\
    \ field:\n   Authorization: Digest\n       username*=UTF-8''J%C3%A4s%C3%B8n%20Doe,\n\
    \       realm=\"api@example.org\",\n       uri=\"/doe.json\",\n       algorithm=SHA-512-256,\n\
    \       nonce=\"5TsQWLVdgBdmrQ0XsxbDODV+57QdFR34I9HAbC/RVvkK\",\n       nc=00000001,\n\
    \       cnonce=\"NTg6RKcb9boFIAS3KrFK9BGeh+iDa/sm6jUMp2wds69v\",\n       qop=auth,\n\
    \       response=\"ae66e67d6b427bd3f120414a82e4acff38e8ecd9101d\n          6c861229025f607a79dd\"\
    ,\n       opaque=\"HRPCssKJSGjCrkzDg8OhwpzCiGPChXYjwrI2QmXDnsOS\",\n       userhash=false\n"
- title: 4.  Internationalization Considerations
  contents:
  - "4.  Internationalization Considerations\n   In challenges, servers SHOULD use\
    \ the \"charset\" authentication\n   parameter (case-insensitive) to express the\
    \ character encoding they\n   expect the user agent to use when generating A1\
    \ (see Section 3.4.2)\n   and username hashing (see Section 3.4.4).\n   The only\
    \ allowed value is \"UTF-8\", to be matched case-insensitively\n   (see Section\
    \ 2.3 in [RFC2978]).  It indicates that the server expects\n   the username and\
    \ password to be converted to Unicode Normalization\n   Form C (\"NFC\", see Section\
    \ 3 of [RFC5198]) and to be encoded into\n   octets using the UTF-8 character\
    \ encoding scheme [RFC3629].\n   For the username, recipients MUST support all\
    \ characters defined in\n   the \"UsernameCasePreserved\" profile defined in Section\
    \ 3.3 of\n   [RFC7613], with the exception of the colon (\":\") character.\n \
    \  For the password, recipients MUST support all characters defined in\n   the\
    \ \"OpaqueString\" profile defined in Section 4.2 of [RFC7613].\n   If the user\
    \ agent does not support the encoding indicated by the\n   server, it can fail\
    \ the request.\n   When usernames cannot be sent hashed and include non-ASCII\n\
    \   characters, clients can include the username* parameter instead\n   (using\
    \ the value encoding defined in [RFC5987]).\n"
- title: 5.  Security Considerations
  contents:
  - '5.  Security Considerations

    '
- title: 5.1.  Limitations
  contents:
  - "5.1.  Limitations\n   HTTP Digest Authentication, when used with human-memorable\
    \ passwords,\n   is vulnerable to dictionary attacks.  Such attacks are much easier\n\
    \   than cryptographic attacks on any widely used algorithm, including\n   those\
    \ that are no longer considered secure.  In other words,\n   algorithm agility\
    \ does not make this usage any more secure.\n   As a result, Digest Authentication\
    \ SHOULD be used only with passwords\n   that have a reasonable amount of entropy,\
    \ e.g., 128-bit or more.\n   Such passwords typically cannot be memorized by humans\
    \ but can be\n   used for automated web services.\n   If Digest Authentication\
    \ is being used, it SHOULD be over a secure\n   channel like HTTPS [RFC2818].\n"
- title: 5.2.  Storing Passwords
  contents:
  - "5.2.  Storing Passwords\n   Digest Authentication requires that the authenticating\
    \ agent (usually\n   the server) store some data derived from the user's name\
    \ and password\n   in a \"password file\" associated with a given realm.  Normally,\
    \ this\n   might contain pairs consisting of username and H(A1), where H(A1) is\n\
    \   the digested value of the username, realm, and password as described\n   above.\n\
    \   The security implications of this are that if this password file is\n   compromised,\
    \ then an attacker gains immediate access to documents on\n   the server using\
    \ this realm.  Unlike, say, a standard UNIX password\n   file, this information\
    \ needs not be decrypted in order to access\n   documents in the server realm\
    \ associated with this file.  On the\n   other hand, decryption, or more likely\
    \ a brute-force attack, would be\n   necessary to obtain the user's password.\
    \  This is the reason that the\n   realm is part of the digested data stored in\
    \ the password file.  It\n   means that if one Digest Authentication password\
    \ file is compromised,\n   it does not automatically compromise others with the\
    \ same username\n   and password (though it does expose them to brute-force attack).\n\
    \   There are two important security consequences of this.  First, the\n   password\
    \ file must be protected as if it contained unencrypted\n   passwords, because,\
    \ for the purpose of accessing documents in its\n   realm, it effectively does.\n\
    \   A second consequence of this is that the realm string SHOULD be\n   unique\
    \ among all realms that any single user is likely to use.  In\n   particular,\
    \ a realm string SHOULD include the name of the host doing\n   the authentication.\
    \  The inability of the client to authenticate the\n   server is a weakness of\
    \ Digest Authentication.\n"
- title: 5.3.  Authentication of Clients Using Digest Authentication
  contents:
  - "5.3.  Authentication of Clients Using Digest Authentication\n   Digest Authentication\
    \ does not provide a strong authentication\n   mechanism, when compared to public-key-based\
    \ mechanisms, for example.\n   However, it is significantly stronger than, e.g.,\
    \ CRAM-MD5, which has\n   been proposed for use with Lightweight Directory Access\
    \ Protocol\n   (LDAP) [RFC4513] and IMAP/POP (see [RFC2195]).  It was intended\
    \ to\n   replace the much weaker and even more dangerous Basic mechanism.\n  \
    \ Digest Authentication offers no confidentiality protection beyond\n   protecting\
    \ the actual username and password.  All of the rest of the\n   request and response\
    \ are available to an eavesdropper.\n   Digest Authentication offers only limited\
    \ integrity protection for\n   the messages in either direction.  If the \"qop=auth-int\"\
    \ mechanism is\n   used, those parts of the message used in the calculation of\
    \ the WWW-\n   Authenticate and Authorization header field response parameter\
    \ values\n   (see Section 3.2 above) are protected.  Most header fields and their\n\
    \   values could be modified as a part of a man-in-the-middle attack.\n   Many\
    \ needs for secure HTTP transactions cannot be met by Digest\n   Authentication.\
    \  For those needs, TLS is a more appropriate protocol.\n   In particular, Digest\
    \ Authentication cannot be used for any\n   transaction requiring confidentiality\
    \ protection.  Nevertheless, many\n   functions remain for which Digest Authentication\
    \ is both useful and\n   appropriate.\n"
- title: 5.4.  Limited-Use Nonce Values
  contents:
  - "5.4.  Limited-Use Nonce Values\n   The Digest scheme uses a server-specified\
    \ nonce to seed the\n   generation of the response value (as specified in Section\
    \ 3.4.1\n   above).  As shown in the example nonce in Section 3.3, the server\
    \ is\n   free to construct the nonce such that it MAY only be used from a\n  \
    \ particular client, for a particular resource, for a limited period of\n   time\
    \ or number of uses, or any other restrictions.  Doing so\n   strengthens the\
    \ protection provided against, for example, replay\n   attacks (see Section 5.5).\
    \  However, it should be noted that the\n   method chosen for generating and checking\
    \ the nonce also has\n   performance and resource implications.  For example,\
    \ a server MAY\n   choose to allow each nonce value to be used only once by maintaining\n\
    \   a record of whether or not each recently issued nonce has been\n   returned\
    \ and sending a next-nonce parameter in the Authentication-\n   Info header field\
    \ of every response.  This protects against even an\n   immediate replay attack,\
    \ but it has a high cost due to checking nonce\n   values; perhaps more important,\
    \ it will cause authentication failures\n   for any pipelined requests (presumably\
    \ returning a stale nonce\n   indication).  Similarly, incorporating a request-specific\
    \ element\n   such as the ETag value for a resource limits the use of the nonce\
    \ to\n   that version of the resource and also defeats pipelining.  Thus, it\n\
    \   MAY be useful to do so for methods with side effects but have\n   unacceptable\
    \ performance for those that do not.\n"
- title: 5.5.  Replay Attacks
  contents:
  - "5.5.  Replay Attacks\n   A replay attack against Digest Authentication would\
    \ usually be\n   pointless for a simple GET request since an eavesdropper would\n\
    \   already have seen the only document he could obtain with a replay.\n   This\
    \ is because the URI of the requested document is digested in the\n   client request,\
    \ and the server will only deliver that document.  By\n   contrast, under Basic\
    \ Authentication, once the eavesdropper has the\n   user's password, any document\
    \ protected by that password is open to\n   him.\n   Thus, for some purposes,\
    \ it is necessary to protect against replay\n   attacks.  A good Digest implementation\
    \ can do this in various ways.\n   The server-created \"nonce\" value is implementation\
    \ dependent, but if\n   it contains a digest of the client IP, a timestamp, the\
    \ resource\n   ETag, and a private server key (as recommended above), then a replay\n\
    \   attack is not simple.  An attacker must convince the server that the\n   request\
    \ is coming from a false IP address and must cause the server\n   to deliver the\
    \ document to an IP address different from the address\n   to which it believes\
    \ it is sending the document.  An attack can only\n   succeed in the period before\
    \ the timestamp expires.  Digesting the\n   client IP and timestamp in the nonce\
    \ permits an implementation that\n   does not maintain state between transactions.\n\
    \   For applications where no possibility of replay attack can be\n   tolerated,\
    \ the server can use one-time nonce values that will not be\n   honored for a\
    \ second use.  This requires the overhead of the server\n   remembering which\
    \ nonce values have been used until the nonce\n   timestamp (and hence the digest\
    \ built with it) has expired, but it\n   effectively protects against replay attacks.\n\
    \   An implementation must give special attention to the possibility of\n   replay\
    \ attacks with POST and PUT requests.  Unless the server employs\n   one-time\
    \ or otherwise limited-use nonces and/or insists on the use of\n   the integrity\
    \ protection of \"qop=auth-int\", an attacker could replay\n   valid credentials\
    \ from a successful request with counterfeit data or\n   other message body. \
    \ Even with the use of integrity protection, most\n   metadata in header fields\
    \ is not protected.  Proper nonce generation\n   and checking provides some protection\
    \ against replay of previously\n   used valid credentials, but see Section 5.8.\n"
- title: 5.6.  Weakness Created by Multiple Authentication Schemes
  contents:
  - "5.6.  Weakness Created by Multiple Authentication Schemes\n   An HTTP/1.1 server\
    \ MAY return multiple challenges with a 401\n   (Authenticate) response, and each\
    \ challenge MAY use a different auth-\n   scheme.  A user agent MUST choose to\
    \ use the strongest auth-scheme it\n   understands and request credentials from\
    \ the user based upon that\n   challenge.\n   When the server offers choices of\
    \ authentication schemes using the\n   WWW-Authenticate header field, the strength\
    \ of the resulting\n   authentication is only as good as that of the of the weakest\
    \ of the\n   authentication schemes.  See Section 5.7 below for discussion of\n\
    \   particular attack scenarios that exploit multiple authentication\n   schemes.\n"
- title: 5.7.  Online Dictionary Attacks
  contents:
  - "5.7.  Online Dictionary Attacks\n   If the attacker can eavesdrop, then it can\
    \ test any overheard nonce/\n   response pairs against a list of common words.\
    \  Such a list is\n   usually much smaller than the total number of possible passwords.\n\
    \   The cost of computing the response for each password on the list is\n   paid\
    \ once for each challenge.\n   The server can mitigate this attack by not allowing\
    \ users to select\n   passwords that are in a dictionary.\n"
- title: 5.8.  Man-in-the-Middle Attacks
  contents:
  - "5.8.  Man-in-the-Middle Attacks\n   Digest Authentication is vulnerable to man-in-the-middle\
    \ (MITM)\n   attacks, for example, from a hostile or compromised proxy.  Clearly,\n\
    \   this would present all the problems of eavesdropping.  But, it also\n   offers\
    \ some additional opportunities to the attacker.\n   A possible man-in-the-middle\
    \ attack would be to add a weak\n   authentication scheme to the set of choices,\
    \ hoping that the client\n   will use one that exposes the user's credentials\
    \ (e.g., password).\n   For this reason, the client SHOULD always use the strongest\
    \ scheme\n   that it understands from the choices offered.\n   An even better\
    \ MITM attack would be to remove all offered choices,\n   replacing them with\
    \ a challenge that requests only Basic\n   authentication, then uses the cleartext\
    \ credentials from the Basic\n   authentication to authenticate to the origin\
    \ server using the\n   stronger scheme it requested.  A particularly insidious\
    \ way to mount\n   such a MITM attack would be to offer a \"free\" proxy caching\
    \ service\n   to gullible users.\n   User agents should consider measures such\
    \ as presenting a visual\n   indication at the time of the credentials request\
    \ of what\n   authentication scheme is to be used, or remembering the strongest\n\
    \   authentication scheme ever requested by a server and producing a\n   warning\
    \ message before using a weaker one.  It might also be a good\n   idea for the\
    \ user agent to be configured to demand Digest\n   authentication in general or\
    \ from specific sites.\n   Or, a hostile proxy might spoof the client into making\
    \ a request the\n   attacker wanted rather than one the client wanted.  Of course,\
    \ this\n   is still much harder than a comparable attack against Basic\n   Authentication.\n"
- title: 5.9.  Chosen Plaintext Attacks
  contents:
  - "5.9.  Chosen Plaintext Attacks\n   With Digest Authentication, a MITM or a malicious\
    \ server can\n   arbitrarily choose the nonce that the client will use to compute\
    \ the\n   response.  This is called a \"chosen plaintext\" attack.  The ability\n\
    \   to choose the nonce is known to make cryptanalysis much easier.\n   However,\
    \ a method to analyze the one-way functions used by Digest\n   using chosen plaintext\
    \ is not currently known.\n   The countermeasure against this attack is for clients\
    \ to use the\n   cnonce parameter; this allows the client to vary the input to\
    \ the\n   hash in a way not chosen by the attacker.\n"
- title: 5.10.  Precomputed Dictionary Attacks
  contents:
  - "5.10.  Precomputed Dictionary Attacks\n   With Digest Authentication, if the\
    \ attacker can execute a chosen\n   plaintext attack, the attacker can precompute\
    \ the response for many\n   common words to a nonce of its choice and store a\
    \ dictionary of\n   response/password pairs.  Such precomputation can often be\
    \ done in\n   parallel on many machines.  It can then use the chosen plaintext\n\
    \   attack to acquire a response corresponding to that challenge and just\n  \
    \ look up the password in the dictionary.  Even if most passwords are\n   not\
    \ in the dictionary, some might be.  Since the attacker gets to\n   pick the challenge,\
    \ the cost of computing the response for each\n   password on the list can be\
    \ amortized over finding many passwords.  A\n   dictionary with 100 million password/response\
    \ pairs would take about\n   3.2 gigabytes of disk storage.\n   The countermeasure\
    \ against this attack is for clients to use the\n   cnonce parameter.\n"
- title: 5.11.  Batch Brute-Force Attacks
  contents:
  - "5.11.  Batch Brute-Force Attacks\n   With Digest Authentication, a MITM can execute\
    \ a chosen plaintext\n   attack and can gather responses from many users to the\
    \ same nonce.\n   It can then find all the passwords within any subset of password\n\
    \   space that would generate one of the nonce/response pairs in a single\n  \
    \ pass over that space.  It also reduces the time to find the first\n   password\
    \ by a factor equal to the number of nonce/response pairs\n   gathered.  This\
    \ search of the password space can often be done in\n   parallel on many machines,\
    \ and even a single machine can search large\n   subsets of the password space\
    \ very quickly -- reports exist of\n   searching all passwords with six or fewer\
    \ letters in a few hours.\n   The countermeasure against this attack is for clients\
    \ to use the\n   cnonce parameter.\n"
- title: 5.12.  Parameter Randomness
  contents:
  - "5.12.  Parameter Randomness\n   The security of this protocol is critically dependent\
    \ on the\n   randomness of the randomly chosen parameters, such as client and\n\
    \   server nonces.  These should be generated by a strong random or\n   properly\
    \ seeded pseudorandom source (see [RFC4086]).\n"
- title: 5.13.  Summary
  contents:
  - "5.13.  Summary\n   By modern cryptographic standards, Digest Authentication is\
    \ weak.\n   But, for a large range of purposes, it is valuable as a replacement\n\
    \   for Basic Authentication.  It remedies some, but not all, weaknesses\n   of\
    \ Basic Authentication.  Its strength may vary depending on the\n   implementation.\
    \  In particular, the structure of the nonce (which is\n   dependent on the server\
    \ implementation) may affect the ease of\n   mounting a replay attack.  A range\
    \ of server options is appropriate\n   since, for example, some implementations\
    \ may be willing to accept the\n   server overhead of one-time nonces or digests\
    \ to eliminate the\n   possibility of replay.  Others may be satisfied with a\
    \ nonce like the\n   one recommended above, i.e., restricted to a single IP address\
    \ and a\n   single ETag or with a limited lifetime.\n   The bottom line is that\
    \ *any* compliant implementation will be\n   relatively weak by cryptographic\
    \ standards, but *any* compliant\n   implementation will be far superior to Basic\
    \ Authentication.\n"
- title: 6.  IANA Considerations
  contents:
  - '6.  IANA Considerations

    '
- title: 6.1.  Hash Algorithms for HTTP Digest Authentication
  contents:
  - "6.1.  Hash Algorithms for HTTP Digest Authentication\n   This specification creates\
    \ a new IANA registry named \"Hash Algorithms\n   for HTTP Digest Authentication\"\
    \ under the existing \"Hypertext\n   Transfer Protocol (HTTP) Digest Algorithm\
    \ Values\" category.  This\n   registry lists the hash algorithms that can be\
    \ used in HTTP Digest\n   Authentication.\n   When registering a new hash algorithm,\
    \ the following information MUST\n   be provided:\n   Hash Algorithm\n      The\
    \ textual name of the hash algorithm.\n   Digest Size\n      The size of the algorithm's\
    \ output in bits.\n   Reference\n      A reference to the specification adding\
    \ the algorithm to this\n      registry.\n   The update policy for this registry\
    \ shall be Specification Required\n   [RFC5226].\n   The initial registry contains\
    \ the following entries:\n               +----------------+-------------+-----------+\n\
    \               | Hash Algorithm | Digest Size | Reference |\n               +----------------+-------------+-----------+\n\
    \               | \"MD5\"          | 128         | RFC 7616  |\n             \
    \  | \"SHA-512-256\"  | 256         | RFC 7616  |\n               | \"SHA-256\"\
    \      | 256         | RFC 7616  |\n               +----------------+-------------+-----------+\n\
    \   Each one of the algorithms defined in the registry might have a\n   \"-sess\"\
    \ variant, e.g., MD5-sess, SHA-256-sess, etc.\n   To clarify the purpose of the\
    \ existing \"HTTP Digest Algorithm Values\"\n   registry and to avoid confusion\
    \ between the two registries, IANA has\n   added the following description to\
    \ the existing \"HTTP Digest\n   Algorithm Values\" registry:\n      This registry\
    \ lists the algorithms that can be used when creating\n      digests of an HTTP\
    \ message body, as specified in RFC 3230.\n"
- title: 6.2.  Digest Scheme Registration
  contents:
  - "6.2.  Digest Scheme Registration\n   This specification updates the existing\
    \ entry of the Digest scheme in\n   the \"Hypertext Transfer Protocol (HTTP) Authentication\
    \ Scheme\n   Registry\" and adds a new reference to this specification.\n    \
    \  Authentication Scheme Name: Digest\n      Pointer to specification text: RFC\
    \ 7616\n"
- title: 7.  References
  contents:
  - '7.  References

    '
- title: 7.1.  Normative References
  contents:
  - "7.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n  \
    \            DOI 10.17487/RFC2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC2978]  Freed, N. and J. Postel, \"IANA Charset Registration\n        \
    \      Procedures\", BCP 19, RFC 2978, DOI 10.17487/RFC2978,\n              October\
    \ 2000, <http://www.rfc-editor.org/info/rfc2978>.\n   [RFC3629]  Yergeau, F.,\
    \ \"UTF-8, a transformation format of ISO\n              10646\", STD 63, RFC\
    \ 3629, DOI 10.17487/RFC3629, November\n              2003, <http://www.rfc-editor.org/info/rfc3629>.\n\
    \   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n   \
    \           Resource Identifier (URI): Generic Syntax\", STD 66,\n           \
    \   RFC 3986, DOI 10.17487/RFC3986, January 2005,\n              <http://www.rfc-editor.org/info/rfc3986>.\n\
    \   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,\n             \
    \ \"Randomness Requirements for Security\", BCP 106, RFC 4086,\n             \
    \ DOI 10.17487/RFC4086, June 2005,\n              <http://www.rfc-editor.org/info/rfc4086>.\n\
    \   [RFC5198]  Klensin, J. and M. Padlipsky, \"Unicode Format for Network\n  \
    \            Interchange\", RFC 5198, DOI 10.17487/RFC5198, March 2008,\n    \
    \          <http://www.rfc-editor.org/info/rfc5198>.\n   [RFC5234]  Crocker, D.,\
    \ Ed. and P. Overell, \"Augmented BNF for Syntax\n              Specifications:\
    \ ABNF\", STD 68, RFC 5234,\n              DOI 10.17487/RFC5234, January 2008,\n\
    \              <http://www.rfc-editor.org/info/rfc5234>.\n   [RFC5987]  Reschke,\
    \ J., \"Character Set and Language Encoding for\n              Hypertext Transfer\
    \ Protocol (HTTP) Header Field\n              Parameters\", RFC 5987, DOI 10.17487/RFC5987,\
    \ August 2010,\n              <http://www.rfc-editor.org/info/rfc5987>.\n   [RFC6454]\
    \  Barth, A., \"The Web Origin Concept\", RFC 6454,\n              DOI 10.17487/RFC6454,\
    \ December 2011,\n              <http://www.rfc-editor.org/info/rfc6454>.\n  \
    \ [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n   \
    \           Protocol (HTTP/1.1): Message Syntax and Routing\",\n             \
    \ RFC 7230, DOI 10.17487/RFC7230, June 2014,\n              <http://www.rfc-editor.org/info/rfc7230>.\n\
    \   [RFC7231]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n \
    \             Protocol (HTTP/1.1): Semantics and Content\", RFC 7231,\n      \
    \        DOI 10.17487/RFC7231, June 2014,\n              <http://www.rfc-editor.org/info/rfc7231>.\n\
    \   [RFC7234]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,\n     \
    \         Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Caching\",\n        \
    \      RFC 7234, DOI 10.17487/RFC7234, June 2014,\n              <http://www.rfc-editor.org/info/rfc7234>.\n\
    \   [RFC7235]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n \
    \             Protocol (HTTP/1.1): Authentication\", RFC 7235,\n             \
    \ DOI 10.17487/RFC7235, June 2014,\n              <http://www.rfc-editor.org/info/rfc7235>.\n\
    \   [RFC7613]  Saint-Andre, P. and A. Melnikov, \"Preparation,\n             \
    \ Enforcement, and Comparison of Internationalized Strings\n              Representing\
    \ Usernames and Passwords\", RFC 7613,\n              DOI 10.17487/RFC7613, August\
    \ 2015,\n              <http://www.rfc-editor.org/info/rfc7613>.\n   [RFC7615]\
    \  Reschke, J., \"HTTP Authentication-Info and Proxy-\n              Authentication-Info\
    \ Response Header Fields\", RFC 7615,\n              DOI 10.17487/RFC7615, September\
    \ 2015,\n              <http://www.rfc-editor.org/info/rfc7615>.\n"
- title: 7.2.  Informative References
  contents:
  - "7.2.  Informative References\n   [RFC2195]  Klensin, J., Catoe, R., and P. Krumviede,\
    \ \"IMAP/POP\n              AUTHorize Extension for Simple Challenge/Response\"\
    ,\n              RFC 2195, DOI 10.17487/RFC2195, September 1997,\n           \
    \   <http://www.rfc-editor.org/info/rfc2195>.\n   [RFC2617]  Franks, J., Hallam-Baker,\
    \ P., Hostetler, J., Lawrence, S.,\n              Leach, P., Luotonen, A., and\
    \ L. Stewart, \"HTTP\n              Authentication: Basic and Digest Access Authentication\"\
    ,\n              RFC 2617, DOI 10.17487/RFC2617, June 1999,\n              <http://www.rfc-editor.org/info/rfc2617>.\n\
    \   [RFC2818]  Rescorla, E., \"HTTP Over TLS\", RFC 2818,\n              DOI 10.17487/RFC2818,\
    \ May 2000,\n              <http://www.rfc-editor.org/info/rfc2818>.\n   [RFC4513]\
    \  Harrison, R., Ed., \"Lightweight Directory Access Protocol\n              (LDAP):\
    \ Authentication Methods and Security Mechanisms\",\n              RFC 4513, DOI\
    \ 10.17487/RFC4513, June 2006,\n              <http://www.rfc-editor.org/info/rfc4513>.\n\
    \   [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n   \
    \           IANA Considerations Section in RFCs\", BCP 26, RFC 5226,\n       \
    \       DOI 10.17487/RFC5226, May 2008,\n              <http://www.rfc-editor.org/info/rfc5226>.\n\
    \   [RFC7617]  Reschke, J., \"The 'Basic' HTTP Authentication Scheme\",\n    \
    \          RFC 7617, DOI 10.17487/RFC7617, September 2015,\n              <http://www.rfc-editor.org/info/rfc7617>.\n"
- title: Appendix A.  Changes from RFC 2617
  contents:
  - "Appendix A.  Changes from RFC 2617\n   This document introduces the following\
    \ changes:\n   o  Adds support for two new algorithms, SHA2-256 as mandatory and\n\
    \      SHA2-512/256 as a backup, and defines the proper algorithm\n      negotiation.\
    \  The document keeps the MD5 algorithm support but\n      only for backward compatibility.\n\
    \   o  Introduces the username hashing capability and the parameter\n      associated\
    \ with that, mainly for privacy reasons.\n   o  Adds various internationalization\
    \ considerations that impact the\n      A1 calculation and username and password\
    \ encoding.\n   o  Introduces a new IANA registry, \"Hash Algorithms for HTTP\
    \ Digest\n      Authentication\", that lists the hash algorithms that can be used\n\
    \      in HTTP Digest Authentication.\n   o  Deprecates backward compatibility\
    \ with RFC 2069.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   To provide a complete description for the Digest mechanism\
    \ and its\n   operation, this document borrows text heavily from [RFC2617].  The\n\
    \   authors of this document would like to thank John Franks, Phillip M.\n   Hallam-Baker,\
    \ Jeffery L. Hostetler, Scott D. Lawrence, Paul J. Leach,\n   Ari Luotonen, and\
    \ Lawrence C. Stewart for their work on that\n   specification.\n   Special thanks\
    \ to Julian Reschke for his many reviews, comments,\n   suggestions, and text\
    \ provided to various areas in this document.\n   The authors would like to thank\
    \ Stephen Farrell, Yoav Nir, Phillip\n   Hallam-Baker, Manu Sporny, Paul Hoffman,\
    \ Yaron Sheffer, Sean Turner,\n   Geoff Baskwill, Eric Cooper, Bjoern Hoehrmann,\
    \ Martin Durst, Peter\n   Saint-Andre, Michael Sweet, Daniel Stenberg, Brett Tate,\
    \ Paul Leach,\n   Ilari Liusvaara, Gary Mort, Alexey Melnikov, Benjamin Kaduk,\
    \ Kathleen\n   Moriarty, Francis Dupont, Hilarie Orman, and Ben Campbell for their\n\
    \   careful review and comments.\n   The authors would like to thank Jonathan\
    \ Stoke, Nico Williams, Harry\n   Halpin, and Phil Hunt for their comments on\
    \ the mailing list when\n   discussing various aspects of this document.\n   The\
    \ authors would like to thank Paul Kyzivat and Dale Worley for\n   their careful\
    \ review and feedback on some aspects of this document.\n   The authors would\
    \ like to thank Barry Leiba for his help with the\n   registry.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Rifaat Shekh-Yusef (editor)\n   Avaya\n   250 Sidney Street\n\
    \   Belleville, Ontario\n   Canada\n   Phone: +1-613-967-5267\n   Email: rifaat.ietf@gmail.com\n\
    \   David Ahrens\n   Independent\n   California\n   United States\n   Email: ahrensdc@gmail.com\n\
    \   Sophie Bremer\n   Netzkonform\n   Germany\n   Email: sophie.bremer@netzkonform.de\n"
