- title: __initial_text__
  contents:
  - ''
- title: Internet Architecture Board (IAB)                         D. Thaler, Ed.
  contents:
  - "Internet Architecture Board (IAB)                         D. Thaler, Ed.\n  \
    \       Issues in Identifier Comparison for Security Purposes\n"
- title: Abstract
  contents:
  - "Abstract\n   Identifiers such as hostnames, URIs, IP addresses, and email\n \
    \  addresses are often used in security contexts to identify security\n   principals\
    \ and resources.  In such contexts, an identifier presented\n   via some protocol\
    \ is often compared using some policy to make\n   security decisions such as whether\
    \ the security principal may access\n   the resource, what level of authentication\
    \ or encryption is required,\n   etc.  If the parties involved in a security decision\
    \ use different\n   algorithms to compare identifiers, then failure scenarios\
    \ ranging\n   from denial of service to elevation of privilege can result.  This\n\
    \   document provides a discussion of these issues that designers should\n   consider\
    \ when defining identifiers and protocols, and when\n   constructing architectures\
    \ that use multiple protocols.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Architecture Board (IAB)\n   and represents information that\
    \ the IAB has deemed valuable to\n   provide for permanent record.  It represents\
    \ the consensus of the\n   Internet Architecture Board (IAB).  Documents approved\
    \ for\n   publication by the IAB are not a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc6943.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \      1.1. Classes of Identifiers .....................................5\n  \
    \    1.2. Canonicalization ...........................................5\n   2.\
    \ Identifier Use in Security Policies and Decisions ...............6\n      2.1.\
    \ False Positives and Negatives ..............................7\n      2.2. Hypothetical\
    \ Example .......................................8\n   3. Comparison Issues with\
    \ Common Identifiers .......................9\n      3.1. Hostnames ..................................................9\n\
    \           3.1.1. IPv4 Literals ......................................11\n  \
    \         3.1.2. IPv6 Literals ......................................12\n    \
    \       3.1.3. Internationalization ...............................13\n      \
    \     3.1.4. Resolution for Comparison ..........................14\n      3.2.\
    \ Port Numbers and Service Names ............................14\n      3.3. URIs\
    \ ......................................................15\n           3.3.1.\
    \ Scheme Component ...................................16\n           3.3.2. Authority\
    \ Component ................................16\n           3.3.3. Path Component\
    \ .....................................17\n           3.3.4. Query Component ....................................17\n\
    \           3.3.5. Fragment Component .................................17\n  \
    \         3.3.6. Resolution for Comparison ..........................18\n    \
    \  3.4. Email Address-Like Identifiers ............................18\n   4. General\
    \ Issues .................................................19\n      4.1. Conflation\
    \ ................................................19\n      4.2. Internationalization\
    \ ......................................20\n      4.3. Scope .....................................................21\n\
    \      4.4. Temporality ...............................................21\n  \
    \ 5. Security Considerations ........................................22\n   6.\
    \ Acknowledgements ...............................................22\n   7. IAB\
    \ Members at the Time of Approval ............................23\n   8. Informative\
    \ References .........................................23\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   In computing and the Internet, various types of \"identifiers\"\
    \ are\n   used to identify humans, devices, content, etc.  This document\n   provides\
    \ a discussion of some security issues that designers should\n   consider when\
    \ defining identifiers and protocols, and when\n   constructing architectures\
    \ that use multiple protocols.  Before\n   discussing these security issues, we\
    \ first give some background on\n   some typical processes involving identifiers.\
    \  Terms such as\n   \"identifier\", \"identity\", and \"principal\" are used\
    \ as defined in\n   [RFC4949].\n   As depicted in Figure 1, there are multiple\
    \ processes relevant to our\n   discussion.\n   1.  An identifier is first generated.\
    \  If the identifier is intended\n       to be unique, the generation process\
    \ must include some mechanism,\n       such as allocation by a central authority\
    \ or verification among\n       the members of a distributed authority, to help\
    \ ensure\n       uniqueness.  However, the notion of \"unique\" involves determining\n\
    \       whether a putative identifier matches any other identifier that\n    \
    \   has already been allocated.  As we will see, for many types of\n       identifiers,\
    \ this is not simply an exact binary match.\n       After generating the identifier,\
    \ it is often stored in two\n       locations: with the requester or \"holder\"\
    \ of the identifier, and\n       with some repository of identifiers (e.g., DNS).\
    \  For example, if\n       the identifier was allocated by a central authority,\
    \ the\n       repository might be that authority.  If the identifier identifies\n\
    \       a device or content on a device, the repository might be that\n      \
    \ device.\n   2.  The identifier is distributed, either by the holder of the\n\
    \       identifier or by a repository of identifiers, to others who could\n  \
    \     use the identifier.  This distribution might be electronic, but\n      \
    \ sometimes it is via other channels such as voice, business card,\n       billboard,\
    \ or other form of advertisement.  The identifier itself\n       might be distributed\
    \ directly, or it might be used to generate a\n       portion of another type\
    \ of identifier that is then distributed.\n       For example, a URI or email\
    \ address might include a server name,\n       and hence distributing the URI\
    \ or email address also inherently\n       distributes the server name.\n   3.\
    \  The identifier is used by some party.  Generally, the user\n       supplies\
    \ the identifier, which is (directly or indirectly) sent\n       to the repository\
    \ of identifiers.  The repository of identifiers\n       must then attempt to\
    \ match the user-supplied identifier with an\n       identifier in its repository.\n\
    \       For example, using an email address to send email to the holder\n    \
    \   of an identifier may result in the email arriving at the holder's\n      \
    \ email server, which has access to the mail stores.\n                       \
    \   +------------+\n                          |  Holder of |     1. Generation\n\
    \                          | identifier +<---------+\n                       \
    \   +----+-------+          |\n                               |              \
    \    | Match\n                               |                  v/\n         \
    \                      |          +-------+-------+\n                        \
    \       +----------+ Repository of |\n                               |       \
    \   |  identifiers  |\n                               |          +-------+-------+\n\
    \               2. Distribution |                  ^\\\n                     \
    \          |                  | Match\n                               v      \
    \            |\n                     +---------+-------+          |\n        \
    \             |      User of    |          |\n                     |    identifier\
    \   +----------+\n                     +-----------------+    3. Use\n       \
    \           Figure 1: Typical Identifier Processes\n   Another variation is where\
    \ a user is given the identifier of a\n   resource (e.g., a web site) to access\
    \ securely, sometimes known as a\n   \"reference identifier\" [RFC6125], and the\
    \ server hosting the resource\n   then presents its identity at the time of use.\
    \  In this case, the\n   user application attempts to match the presented identity\
    \ against the\n   reference identifier.\n   One key aspect is that the identifier\
    \ values passed in generation,\n   distribution, and use may all be in different\
    \ forms.  For example, an\n   identifier might be exchanged in printed form at\
    \ generation time,\n   distributed to a user via voice, and then used electronically.\
    \  As\n   such, the match process can be complicated.\n   Furthermore, in many\
    \ cases, the relationship between holder,\n   repositories, and users may be more\
    \ involved.  For example, when a\n   hierarchy of web caches exists, each cache\
    \ is itself a repository of\n   a sort, and the match process is usually intended\
    \ to be the same as\n   on the origin server.\n   Another aspect to keep in mind\
    \ is that there can be multiple\n   identifiers that refer to the same object\
    \ (i.e., resource, human,\n   device, etc.).  For example, a human might have\
    \ a passport number and\n   a drivers license number, and an RFC might be available\
    \ at multiple\n   locations (rfc-editor.org and ietf.org).  In this document,\
    \ we focus\n   on comparing two identifiers to see whether they are the same\n\
    \   identifier, rather than comparing two different identifiers to see\n   whether\
    \ they refer to the same entity (although a few issues with the\n   latter are\
    \ touched on in several places, such as Sections 3.1.4 and\n   3.3.6).\n"
- title: 1.1.  Classes of Identifiers
  contents:
  - "1.1.  Classes of Identifiers\n   In this document, we will refer to the following\
    \ classes of\n   identifiers:\n   o  Absolute: identifiers that can be compared\
    \ byte-by-byte for\n      equality.  Two identifiers that have different bytes\
    \ are defined\n      to be different.  For example, binary IP addresses are in\
    \ this\n      class.\n   o  Definite: identifiers that have a single well-defined\
    \ comparison\n      algorithm.  For example, URI scheme names are required to\
    \ be\n      US-ASCII [USASCII] and are defined to match in a case-insensitive\n\
    \      way; the comparison is thus definite, since there is a well-\n      specified\
    \ algorithm (Section 9.2.1 of [RFC4790]) on how to do a\n      case-insensitive\
    \ match among ASCII strings.\n   o  Indefinite: identifiers that have no single\
    \ well-defined\n      comparison algorithm.  For example, human names are in this\
    \ class.\n      Everyone might want the comparison to be tailored for their\n\
    \      locale, for some definition of \"locale\".  In some cases, there may\n\
    \      be limited subsets of parties that might be able to agree (e.g.,\n    \
    \  ASCII users might all agree on a common comparison algorithm,\n      whereas\
    \ users of other Roman-derived scripts, such as Turkish, may\n      not), but\
    \ identifiers often tend to leak out of such limited\n      environments.\n"
- title: 1.2.  Canonicalization
  contents:
  - "1.2.  Canonicalization\n   Perhaps the most common algorithm for comparison involves\
    \ first\n   converting each identifier to a canonical form (a process known as\n\
    \   \"canonicalization\" or \"normalization\") and then testing the resulting\n\
    \   canonical representations for bitwise equality.  In so doing, it is\n   thus\
    \ critical that all entities involved agree on the same canonical\n   form and\
    \ use the same canonicalization algorithm so that the overall\n   comparison process\
    \ is also the same.\n   Note that in some contexts, such as in internationalization,\
    \ the\n   terms \"canonicalization\" and \"normalization\" have a precise meaning.\n\
    \   In this document, however, we use these terms synonymously in their\n   more\
    \ generic form, to mean conversion to some standard form.\n   While the most common\
    \ method of comparison includes canonicalization,\n   comparison can also be done\
    \ by defining an equivalence algorithm,\n   where no single form is canonical.\
    \  However, in most cases, a\n   canonical form is useful for other purposes,\
    \ such as output, and so\n   in such cases defining a canonical form suffices\
    \ to define a\n   comparison method.\n"
- title: 2.  Identifier Use in Security Policies and Decisions
  contents:
  - "2.  Identifier Use in Security Policies and Decisions\n   Identifiers such as\
    \ hostnames, URIs, and email addresses are used in\n   security contexts to identify\
    \ security principals (i.e., entities\n   that can be authenticated) and resources\
    \ as well as other security\n   parameters such as types and values of claims.\
    \  Those identifiers are\n   then used to make security decisions based on an\
    \ identifier presented\n   via some protocol.  For example:\n   o  Authentication:\
    \ a protocol might match a security principal's\n      identifier to look up expected\
    \ keying material and then match\n      keying material.\n   o  Authorization:\
    \ a protocol might match a resource name against some\n      policy.  For example,\
    \ it might look up an access control list\n      (ACL) and then look up the security\
    \ principal's identifier (or a\n      surrogate for it) in that ACL.\n   o  Accounting:\
    \ a system might create an accounting record for a\n      security principal's\
    \ identifier or resource name, and then might\n      later need to match a presented\
    \ identifier to (for example) add\n      new filtering rules based on the records\
    \ in order to stop an\n      attack.\n   If the parties involved in a security\
    \ decision use different matching\n   algorithms for the same identifiers, then\
    \ failure scenarios ranging\n   from denial of service to elevation of privilege\
    \ can result, as we\n   will see.\n   This is especially complicated in cases\
    \ involving multiple parties\n   and multiple protocols.  For example, there are\
    \ many scenarios where\n   some form of \"security token service\" is used to\
    \ grant to a requester\n   permission to access a resource, where the resource\
    \ is held by a\n   third party that relies on the security token service (see\
    \ Figure 2).\n   The protocol used to request permission (e.g., Kerberos or OAuth)\
    \ may\n   be different from the protocol used to access the resource (e.g.,\n\
    \   HTTP).  Opportunities for security problems arise when two protocols\n   define\
    \ different comparison algorithms for the same type of\n   identifier, or when\
    \ a protocol is ambiguously specified and two\n   endpoints (e.g., a security\
    \ token service and a resource holder)\n   implement different algorithms within\
    \ the same protocol.\n         +----------+\n         | security |\n         |\
    \  token   |\n         | service  |\n         +----------+\n              ^\n\
    \              | 1. supply credentials and\n              |    get token for resource\n\
    \              |                                             +--------+\n    \
    \     +----------+  2. supply token and access resource  |resource|\n        \
    \ |requester |=------------------------------------->| holder |\n         +----------+\
    \                                       +--------+\n                    Figure\
    \ 2: Simple Security Exchange\n   In many cases, the situation is more complex.\
    \  With X.509 Public Key\n   Infrastructure (PKIX) certificates [RFC6125], for\
    \ example, the name\n   in a certificate gets compared against names in ACLs or\
    \ other things.\n   In the case of web site security, the name in the certificate\
    \ gets\n   compared to a portion of the URI that a user may have typed into a\n\
    \   browser.  The fact that many different people are doing the typing,\n   on\
    \ many different types of systems, complicates the problem.\n   Add to this the\
    \ certificate enrollment step, and the certificate\n   issuance step, and two\
    \ more parties have an opportunity to adjust the\n   encoding, or worse, the software\
    \ that supports them might make\n   changes that the parties are unaware are happening.\n"
- title: 2.1.  False Positives and Negatives
  contents:
  - "2.1.  False Positives and Negatives\n   It is first worth discussing in more\
    \ detail the effects of errors in\n   the comparison algorithm.  A \"false positive\"\
    \ results when two\n   identifiers compare as if they were equal but in reality\
    \ refer to two\n   different objects (e.g., security principals or resources).\
    \  When\n   privilege is granted on a match, a false positive thus results in\
    \ an\n   elevation of privilege -- for example, allowing execution of an\n   operation\
    \ that should not have been permitted otherwise.  When\n   privilege is denied\
    \ on a match (e.g., matching an entry in a\n   block/deny list or a revocation\
    \ list), a permissible operation is\n   denied.  At best, this can cause worse\
    \ performance (e.g., a cache\n   miss or forcing redundant authentication) and\
    \ at worst can result in\n   a denial of service.\n   A \"false negative\" results\
    \ when two identifiers that in reality refer\n   to the same thing compare as\
    \ if they were different, and the effects\n   are the reverse of those for false\
    \ positives.  That is, when\n   privilege is granted on a match, the result is\
    \ at best worse\n   performance and at worst a denial of service; when privilege\
    \ is\n   denied on a match, elevation of privilege results.\n   Figure 3 summarizes\
    \ these effects.\n                      | \"Grant on match\"       | \"Deny on\
    \ match\"\n       ---------------+------------------------+-----------------------\n\
    \       False positive | Elevation of privilege | Denial of service\n       ---------------+------------------------+-----------------------\n\
    \       False negative | Denial of service      | Elevation of privilege\n   \
    \    ---------------+------------------------+-----------------------\n      \
    \     Figure 3: Worst Effects of False Positives/Negatives\n   When designing\
    \ a comparison algorithm, one can typically modify it to\n   increase the likelihood\
    \ of false positives and decrease the\n   likelihood of false negatives, or vice\
    \ versa.  Which outcome is\n   better depends on the context.\n   Elevation of\
    \ privilege is almost always seen as far worse than denial\n   of service.  Hence,\
    \ for URIs, for example, Section 6.1 of [RFC3986]\n   states that \"comparison\
    \ methods are designed to minimize false\n   negatives while strictly avoiding\
    \ false positives\".\n   Thus, URIs were defined with a \"grant privilege on match\"\
    \ paradigm in\n   mind, where it is critical to prevent elevation of privilege\
    \ while\n   minimizing denial of service.  Using URIs in a \"deny privilege on\n\
    \   match\" system can thus be problematic.\n"
- title: 2.2.  Hypothetical Example
  contents:
  - "2.2.  Hypothetical Example\n   In this example, both security principals and\
    \ resources are\n   identified using URIs.  Foo Corp has paid example.com for\
    \ access to\n   the Stuff service.  Foo Corp allows its employees to create accounts\n\
    \   on the Stuff service.  Alice gets the account\n   \"http://example.com/Stuff/FooCorp/alice\"\
    \ and Bob gets\n   \"http://example.com/Stuff/FooCorp/bob\".  It turns out, however,\
    \ that\n   Foo Corp's URI canonicalizer includes URI fragment components in\n\
    \   comparisons whereas example.com's does not, and Foo Corp does not\n   disallow\
    \ the # character in the account name.  So Chuck, who is a\n   malicious employee\
    \ of Foo Corp, asks to create an account at\n   example.com with the name alice#stuff.\
    \  Foo Corp's URI logic checks\n   its records for accounts it has created with\
    \ stuff and sees that\n   there is no account with the name alice#stuff.  Hence,\
    \ in its\n   records, it associates the account alice#stuff with Chuck and will\n\
    \   only issue tokens good for use with\n   \"http://example.com/Stuff/FooCorp/alice#stuff\"\
    \ to Chuck.\n   Chuck, the attacker, goes to a security token service at Foo Corp\
    \ and\n   asks for a security token good for\n   \"http://example.com/Stuff/FooCorp/alice#stuff\"\
    .  Foo Corp issues the\n   token, since Chuck is the legitimate owner (in Foo\
    \ Corp's view) of\n   the alice#stuff account.  Chuck then submits the security\
    \ token in a\n   request to \"http://example.com/Stuff/FooCorp/alice\".\n   But\
    \ example.com uses a URI canonicalizer that, for the purposes of\n   checking\
    \ equality, ignores fragments.  So when example.com looks in\n   the security\
    \ token to see if the requester has permission from Foo\n   Corp to access the\
    \ given account, it successfully matches the URI in\n   the security token, \"\
    http://example.com/Stuff/FooCorp/alice#stuff\",\n   with the requested resource\
    \ name\n   \"http://example.com/Stuff/FooCorp/alice\".\n   Leveraging the inconsistencies\
    \ in the canonicalizers used by Foo Corp\n   and example.com, Chuck is able to\
    \ successfully launch an elevation-\n   of-privilege attack and access Alice's\
    \ resource.\n   Furthermore, consider an attacker using a similar corporation,\
    \ such\n   as \"foocorp\" (or any variation containing a non-ASCII character that\n\
    \   some humans might expect to represent the same corporation).  If the\n   resource\
    \ holder treats them as different but the security token\n   service treats them\
    \ as the same, then elevation of privilege can\n   occur in this scenario as well.\n"
- title: 3.  Comparison Issues with Common Identifiers
  contents:
  - "3.  Comparison Issues with Common Identifiers\n   In this section, we walk through\
    \ a number of common types of\n   identifiers and discuss various issues related\
    \ to comparison that may\n   affect security whenever they are used to identify\
    \ security\n   principals or resources.  These examples illustrate common patterns\n\
    \   that may arise with other types of identifiers.\n"
- title: 3.1.  Hostnames
  contents:
  - "3.1.  Hostnames\n   Hostnames (composed of dot-separated labels) are commonly\
    \ used either\n   directly as identifiers, or as components in identifiers such\
    \ as in\n   URIs and email addresses.  Another example is in Sections 7.2 and\
    \ 7.3\n   of [RFC5280] (and updated in Section 3 of [RFC6818]), which specify\n\
    \   use in PKIX certificates.\n   In this section, we discuss a number of issues\
    \ in comparing strings\n   that appear to be some form of hostname.\n   It is\
    \ first worth pointing out that the term \"hostname\" itself is\n   often ambiguous,\
    \ and hence it is important that any use clarify which\n   definition is intended.\
    \  Some examples of definitions include:\n   a.  A Fully Qualified Domain Name\
    \ (FQDN),\n   b.  An FQDN that is associated with address records in the DNS,\n\
    \   c.  The leftmost label in an FQDN, or\n   d.  The leftmost label in an FQDN\
    \ that is associated with address\n       records.\n   The use of different definitions\
    \ in different places results in\n   questions such as whether \"example\" and\
    \ \"example.com\" are considered\n   equal or not, and hence it is important when\
    \ writing new\n   specifications to be clear about which definition is meant.\n\
    \   Section 3 of [RFC6055] discusses the differences between a \"hostname\"\n\
    \   and a \"DNS name\", where the former is a subset of the latter by using\n\
    \   a restricted set of characters (letters, digits, and hyphens).  If\n   one\
    \ canonicalizer uses the \"DNS name\" definition whereas another uses\n   a \"\
    hostname\" definition, a name might be valid in the former but\n   invalid in\
    \ the latter.  As long as invalid identifiers are denied\n   privilege, this difference\
    \ will not result in elevation of privilege.\n   Section 3.1 of [RFC1034] discusses\
    \ the difference between a\n   \"complete\" domain name, which ends with a dot\
    \ (such as\n   \"example.com.\"), and a multi-label relative name such as\n  \
    \ \"example.com\" that assumes the root (\".\") is in the suffix search\n   list.\
    \  In most contexts, these are considered equal, but there may be\n   issues if\
    \ different entities in a security architecture have\n   different interpretations\
    \ of a relative domain name.\n   [IAB1123] briefly discusses issues with the ambiguity\
    \ around whether\n   a label will be \"alphabetic\" -- including, among other\
    \ issues, how\n   \"alphabetic\" should be interpreted in an internationalized\n\
    \   environment -- and whether a hostname can be interpreted as an IP\n   address.\
    \  We explore this last issue in more detail below.\n"
- title: 3.1.1.  IPv4 Literals
  contents:
  - "3.1.1.  IPv4 Literals\n   Section 2.1 of [RFC1123] states:\n      Whenever a\
    \ user inputs the identity of an Internet host, it SHOULD\n      be possible to\
    \ enter either (1) a host domain name or (2) an IP\n      address in dotted-decimal\
    \ (\"#.#.#.#\") form.  The host SHOULD check\n      the string syntactically for\
    \ a dotted-decimal number before\n      looking it up in the Domain Name System.\n\
    \   and\n      This last requirement is not intended to specify the complete\n\
    \      syntactic form for entering a dotted-decimal host number; that is\n   \
    \   considered to be a user-interface issue.\n   In specifying the inet_addr()\
    \ API, the Portable Operating System\n   Interface (POSIX) standard [IEEE-1003.1]\
    \ defines \"IPv4 dotted decimal\n   notation\" as allowing not only strings of\
    \ the form \"10.0.1.2\" but\n   also allowing octal and hexadecimal, and addresses\
    \ with less than\n   four parts.  For example, \"10.0.258\", \"0xA000102\", and\
    \ \"012.0x102\"\n   all represent the same IPv4 address in standard \"IPv4 dotted\
    \ decimal\"\n   notation.  We will refer to this as the \"loose\" syntax of an\
    \ IPv4\n   address literal.\n   In Section 6.1 of [RFC3493], getaddrinfo() is\
    \ defined to support the\n   same (loose) syntax as inet_addr():\n      If the\
    \ specified address family is AF_INET or AF_UNSPEC, address\n      strings using\
    \ Internet standard dot notation as specified in\n      inet_addr() are valid.\n\
    \   In contrast, Section 6.3 of the same RFC states, specifying\n   inet_pton():\n\
    \      If the af argument of inet_pton() is AF_INET, the src string shall\n  \
    \    be in the standard IPv4 dotted-decimal form:\n            ddd.ddd.ddd.ddd\n\
    \      where \"ddd\" is a one to three digit decimal number between 0 and\n  \
    \    255.  The inet_pton() function does not accept other formats (such\n    \
    \  as the octal numbers, hexadecimal numbers, and fewer than four\n      numbers\
    \ that inet_addr() accepts).\n   As shown above, inet_pton() uses what we will\
    \ refer to as the\n   \"strict\" form of an IPv4 address literal.  Some platforms\
    \ also use\n   the strict form with getaddrinfo() when the AI_NUMERICHOST flag\
    \ is\n   passed to it.\n   Both the strict and loose forms are standard forms,\
    \ and hence a\n   protocol specification is still ambiguous if it simply defines\
    \ a\n   string to be in the \"standard IPv4 dotted decimal form\".  And, as a\n\
    \   result of these differences, names such as \"10.11.12\" are ambiguous\n  \
    \ as to whether they are an IP address or a hostname, and even\n   \"10.11.12.13\"\
    \ can be ambiguous because of the \"SHOULD\" in the above\n   text from RFC 1123,\
    \ making it optional whether to treat it as an\n   address or a DNS name.\n  \
    \ Protocols and data formats that can use addresses in string form for\n   security\
    \ purposes need to resolve these ambiguities.  For example,\n   for the host component\
    \ of URIs, Section 3.2.2 of [RFC3986] resolves\n   the first ambiguity by only\
    \ allowing the strict form and resolves the\n   second ambiguity by specifying\
    \ that it is considered an IPv4 address\n   literal.  New protocols and data formats\
    \ should similarly consider\n   using the strict form rather than the loose form\
    \ in order to better\n   match user expectations.\n   A string might be valid\
    \ under the \"loose\" definition but invalid\n   under the \"strict\" definition.\
    \  As long as invalid identifiers are\n   denied privilege, this difference will\
    \ not result in elevation of\n   privilege.  Some protocols, however, use strings\
    \ that can be either\n   an IP address literal or a hostname.  Such strings are\
    \ at best\n   Definite identifiers, and often turn out to be Indefinite\n   identifiers.\
    \  (See Section 4.1 for more discussion.)\n"
- title: 3.1.2.  IPv6 Literals
  contents:
  - "3.1.2.  IPv6 Literals\n   IPv6 addresses similarly have a wide variety of alternate\
    \ but\n   semantically identical string representations, as defined in\n   Section\
    \ 2.2 of [RFC4291] and Section 2 of [RFC6874].  As discussed in\n   Section 3.2.5\
    \ of [RFC5952], this fact causes problems in security\n   contexts if comparison\
    \ (such as in PKIX certificates) is done between\n   strings rather than between\
    \ the binary representations of addresses.\n   [RFC5952] specified a recommended\
    \ canonical string format as an\n   attempt to solve this problem, but it may\
    \ not be ubiquitously\n   supported at present.  And, when strings can contain\
    \ non-ASCII\n   characters, the same issues (and more, since hexadecimal and colons\n\
    \   are allowed) arise as with IPv4 literals.\n   Whereas (binary) IPv6 addresses\
    \ are Absolute identifiers, IPv6\n   address literals are Definite identifiers,\
    \ since string-to-address\n   conversion for IPv6 address literals is unambiguous.\n"
- title: 3.1.3.  Internationalization
  contents:
  - "3.1.3.  Internationalization\n   The IETF policy on character sets and languages\
    \ [RFC2277] requires\n   support for UTF-8 in protocols, and as a result many\
    \ protocols now do\n   support non-ASCII characters.  When a hostname is sent\
    \ in a UTF-8\n   field, there are a number of ways it may be encoded.  For example,\n\
    \   hostname labels might be encoded directly in UTF-8, or they might\n   first\
    \ be Punycode-encoded [RFC3492] or even percent-encoded from\n   UTF-8.\n   For\
    \ example, in URIs, Section 3.2.2 of [RFC3986] specifically allows\n   for the\
    \ use of percent-encoded UTF-8 characters in the hostname as\n   well as the use\
    \ of Internationalized Domain Names in Applications\n   (IDNA) encoding [RFC3490]\
    \ using the Punycode algorithm.\n   Percent-encoding is unambiguous for hostnames,\
    \ since the percent\n   character cannot appear in the strict definition of a\
    \ \"hostname\",\n   though it can appear in a DNS name.\n   Punycode-encoded labels\
    \ (or \"A-labels\"), on the other hand, can be\n   ambiguous if hosts are actually\
    \ allowed to be named with a name\n   starting with \"xn--\", and false positives\
    \ can result.  While this may\n   be extremely unlikely for normal scenarios,\
    \ it nevertheless provides\n   a possible vector for an attacker.\n   A hostname\
    \ comparator thus needs to decide whether a Punycode-encoded\n   label should\
    \ or should not be considered a valid hostname label, and\n   if so, then whether\
    \ it should match a label encoded in some other\n   form such as a percent-encoded\
    \ Unicode label (U-label).\n   For example, Section 3 of \"Transport Layer Security\
    \ (TLS) Extensions:\n   Extension Definitions\" [RFC6066] states:\n      \"HostName\"\
    \ contains the fully qualified DNS hostname of the\n      server, as understood\
    \ by the client.  The hostname is represented\n      as a byte string using ASCII\
    \ encoding without a trailing dot.\n      This allows the support of internationalized\
    \ domain names through\n      the use of A-labels defined in [RFC5890].  DNS hostnames\
    \ are case-\n      insensitive.  The algorithm to compare hostnames is described\
    \ in\n      [RFC5890], Section 2.3.2.4.\n   For some additional discussion of\
    \ security issues that arise with\n   internationalization, see Section 4.2 and\
    \ [TR36].\n"
- title: 3.1.4.  Resolution for Comparison
  contents:
  - "3.1.4.  Resolution for Comparison\n   Some systems (specifically Java URLs [JAVAURL])\
    \ use the rule that if\n   two hostnames resolve to the same IP address(es) then\
    \ the hostnames\n   are considered equal.  That is, the canonicalization algorithm\n\
    \   involves name resolution with an IP address being the canonical form.\n  \
    \ For example, if resolution was done via DNS, and DNS contained:\n          \
    \             example.com.  IN A 10.0.0.6\n                       example.net.\
    \  CNAME example.com.\n                       example.org.  IN A 10.0.0.6\n  \
    \ then the algorithm might treat all three names as equal, even though\n   the\
    \ third name might refer to a different entity.\n   With the introduction of dynamic\
    \ IP addresses; private IP addresses;\n   multiple IP addresses per name; multiple\
    \ address families (e.g., IPv4\n   vs. IPv6); devices that roam to new locations;\
    \ commonly deployed DNS\n   tricks that result in the answer depending on factors\
    \ such as the\n   requester's location and the load on the server whose address\
    \ is\n   returned; etc., this method of comparison cannot be relied upon.\n  \
    \ There is no guarantee that two names for the same host will resolve\n   the\
    \ name to the same IP addresses; nor that the addresses resolved\n   refer to\
    \ the same entity, such as when the names resolve to private\n   IP addresses;\
    \ nor even that the system has connectivity (and the\n   willingness to wait for\
    \ the delay) to resolve names at the time the\n   answer is needed.  The lifetime\
    \ of the identifier, and of any cached\n   state from a previous resolution, also\
    \ affects security (see\n   Section 4.4).\n   In addition, a comparison mechanism\
    \ that relies on the ability to\n   resolve identifiers such as hostnames to other\
    \ identifiers such as IP\n   addresses leaks information about security decisions\
    \ to outsiders if\n   these queries are publicly observable.  (See [PRIVACY-CONS]\
    \ for a\n   deeper discussion of information disclosure.)\n   Finally, it is worth\
    \ noting that resolving two identifiers to\n   determine if they refer to the\
    \ same entity can be thought of as a use\n   of such identifiers, as opposed to\
    \ actually comparing the identifiers\n   themselves, which is the focus of this\
    \ document.\n"
- title: 3.2.  Port Numbers and Service Names
  contents:
  - "3.2.  Port Numbers and Service Names\n   Port numbers and service names are discussed\
    \ in depth in [RFC6335].\n   Historically, there were port numbers, service names\
    \ used in SRV\n   records, and mnemonic identifiers for assigned port numbers\
    \ (known as\n   port \"keywords\" at [IANA-PORT]).  The latter two are now unified,\
    \ and\n   various protocols use one or more of these types in strings.  For\n\
    \   example, the common syntax used by many URI schemes allows port\n   numbers\
    \ but not service names.  Some implementations of the\n   getaddrinfo() API support\
    \ strings that can be either port numbers or\n   port keywords (but not service\
    \ names).\n   For protocols that use service names that must be resolved, the\n\
    \   issues are the same as those for resolution of addresses in\n   Section 3.1.4.\
    \  In addition, Section 5.1 of [RFC6335] clarifies that\n   service names/port\
    \ keywords must contain at least one letter.  This\n   prevents confusion with\
    \ port numbers in strings where both are\n   allowed.\n"
- title: 3.3.  URIs
  contents:
  - "3.3.  URIs\n   This section looks at issues related to using URIs for security\n\
    \   purposes.  For example, Section 7.4 of [RFC5280] specifies comparison\n  \
    \ of URIs in certificates.  Examples of URIs in security-token-based\n   access\
    \ control systems include WS-*, SAML 2.0 [OASIS-SAMLv2-CORE],\n   and OAuth Web\
    \ Resource Authorization Profiles (WRAP) [OAuth-WRAP].\n   In such systems, a\
    \ variety of participants in the security\n   infrastructure are identified by\
    \ URIs.  For example, requesters of\n   security tokens are sometimes identified\
    \ with URIs.  The issuers of\n   security tokens and the relying parties who are\
    \ intended to consume\n   security tokens are frequently identified by URIs. \
    \ Claims in\n   security tokens often have their types defined using URIs, and\
    \ the\n   values of the claims can also be URIs.\n   URIs are defined with multiple\
    \ components, each of which has its own\n   rules.  We cover each in turn below.\
    \  However, it is also important\n   to note that there exist multiple comparison\
    \ algorithms.  Section 6.2\n   of [RFC3986] states:\n      A variety of methods\
    \ are used in practice to test URI equivalence.\n      These methods fall into\
    \ a range, distinguished by the amount of\n      processing required and the degree\
    \ to which the probability of\n      false negatives is reduced.  As noted above,\
    \ false negatives\n      cannot be eliminated.  In practice, their probability\
    \ can be\n      reduced, but this reduction requires more processing and is not\n\
    \      cost-effective for all applications.\n      If this range of comparison\
    \ practices is considered as a ladder,\n      the following discussion will climb\
    \ the ladder, starting with\n      practices that are cheap but have a relatively\
    \ higher chance of\n      producing false negatives, and proceeding to those that\
    \ have\n      higher computational cost and lower risk of false negatives.\n \
    \  The ladder approach has both pros and cons.  On the pro side, it\n   allows\
    \ some uses to optimize for security, and other uses to optimize\n   for cost,\
    \ thus allowing URIs to be applicable to a wide range of\n   uses.  A disadvantage\
    \ is that when different approaches are taken by\n   different components in the\
    \ same system using the same identifiers,\n   the inconsistencies can result in\
    \ security issues.\n"
- title: 3.3.1.  Scheme Component
  contents:
  - "3.3.1.  Scheme Component\n   [RFC3986] defines URI schemes as being case-insensitive\
    \ US-ASCII and\n   in Section 6.2.2.1 specifies that scheme names should be normalized\n\
    \   to lowercase characters.\n   New schemes can be defined over time.  In general,\
    \ however, two URIs\n   with an unrecognized scheme cannot be safely compared.\
    \  This is\n   because the canonicalization and comparison rules for the other\n\
    \   components may vary by scheme.  For example, a new URI scheme might\n   have\
    \ a default port of X, and without that knowledge, a comparison\n   algorithm\
    \ cannot know whether \"example.com\" and \"example.com:X\"\n   should be considered\
    \ to match in the authority component.  Hence, for\n   security purposes, it is\
    \ safest for unrecognized schemes to be\n   treated as invalid identifiers.  However,\
    \ if the URIs are only used\n   with a \"grant access on match\" paradigm, then\
    \ unrecognized schemes\n   can be supported by doing a generic case-sensitive\
    \ comparison, at the\n   expense of some false negatives.\n"
- title: 3.3.2.  Authority Component
  contents:
  - "3.3.2.  Authority Component\n   The authority component is scheme-specific, but\
    \ many schemes follow a\n   common syntax that allows for userinfo, host, and\
    \ port.\n"
- title: 3.3.2.1.  Host
  contents:
  - "3.3.2.1.  Host\n   Section 3.1 discusses issues with hostnames in general.  In\
    \ addition,\n   Section 3.2.2 of [RFC3986] allows future changes using the IPvFuture\n\
    \   production.  As with IPv4 and IPv6 literals, IPvFuture formats may\n   have\
    \ issues with multiple semantically identical string\n   representations and may\
    \ also be semantically identical to an IPv4 or\n   IPv6 address.  As such, false\
    \ negatives may be common if IPvFuture is\n   used.\n"
- title: 3.3.2.2.  Port
  contents:
  - "3.3.2.2.  Port\n   See discussion in Section 3.2.\n"
- title: 3.3.2.3.  Userinfo
  contents:
  - "3.3.2.3.  Userinfo\n   [RFC3986] defines the userinfo production that allows\
    \ arbitrary data\n   about the user of the URI to be placed before '@' signs in\
    \ URIs.  For\n   example, \"ftp://alice:bob@example.com/bar\" has the value \"\
    alice:bob\"\n   as its userinfo.  When comparing URIs in a security context, one\
    \ must\n   decide whether to treat the userinfo as being significant or not.\n\
    \   Some URI comparison services, for example, treat\n   \"ftp://alice:ick@example.com\"\
    \ and \"ftp://example.com\" as being equal.\n   When the userinfo is treated as\
    \ being significant, it has additional\n   considerations (e.g., whether or not\
    \ it is case sensitive), which we\n   cover in Section 3.4.\n"
- title: 3.3.3.  Path Component
  contents:
  - "3.3.3.  Path Component\n   [RFC3986] supports the use of path segment values\
    \ such as \"./\" or\n   \"../\" for relative URIs.  As discussed in Section 6.2.2.3\
    \ of\n   [RFC3986], they are intended only for use within a reference relative\n\
    \   to some other base URI, but Section 5.2.4 of [RFC3986] nevertheless\n   defines\
    \ an algorithm to remove them as part of URI normalization.\n   Unless a scheme\
    \ states otherwise, the path component is defined to be\n   case sensitive.  However,\
    \ if the resource is stored and accessed\n   using a filesystem using case-insensitive\
    \ paths, there will be many\n   paths that refer to the same resource.  As such,\
    \ false negatives can\n   be common in this case.\n"
- title: 3.3.4.  Query Component
  contents:
  - "3.3.4.  Query Component\n   There is the question as to whether \"http://example.com/foo\"\
    ,\n   \"http://example.com/foo?\", and \"http://example.com/foo?bar\" are each\n\
    \   considered equal or different.\n   Similarly, it is unspecified whether the\
    \ order of values matters.\n   For example, should \"http://example.com/blah?ick=bick&foo=bar\"\
    \ be\n   considered equal to \"http://example.com/blah?foo=bar&ick=bick\"?  And\n\
    \   if a domain name is permitted to appear in a query component (e.g.,\n   in\
    \ a reference to another URI), the same issues in Section 3.1 apply.\n"
- title: 3.3.5.  Fragment Component
  contents:
  - "3.3.5.  Fragment Component\n   Some URI formats include fragment identifiers.\
    \  These are typically\n   handles to locations within a resource and are used\
    \ for local\n   reference.  A classic example is the use of fragments in HTTP\
    \ URIs\n   where a URI of the form \"http://example.com/blah.html#ick\" means\n\
    \   retrieve the resource \"http://example.com/blah.html\" and, once it has\n\
    \   arrived locally, find the HTML anchor named \"ick\" and display that.\n  \
    \ So, for example, when a user clicks on the link\n   \"http://example.com/blah.html#baz\"\
    , a browser will check its cache by\n   doing a URI comparison for \"http://example.com/blah.html\"\
    \ and, if the\n   resource is present in the cache, a match is declared.\n   Hence,\
    \ comparisons for security purposes typically ignore the\n   fragment component\
    \ and treat all fragments as equal to the full\n   resource.  However, if one\
    \ were actually trying to compare the piece\n   of a resource that was identified\
    \ by the fragment identifier,\n   ignoring it would result in potential false\
    \ positives.\n"
- title: 3.3.6.  Resolution for Comparison
  contents:
  - "3.3.6.  Resolution for Comparison\n   It may be tempting to define a URI comparison\
    \ algorithm based on\n   whether URIs resolve to the same content, along the lines\
    \ of\n   resolving hostnames as described in Section 3.1.4.  However, such an\n\
    \   algorithm would result in similar problems, including content that\n   dynamically\
    \ changes over time or that is based on factors such as the\n   requester's location,\
    \ potential lack of external connectivity at the\n   time or place that comparison\
    \ is done, introduction of potentially\n   undesirable delay, etc.\n   In addition,\
    \ as noted in Section 3.1.4, resolution leaks information\n   about security decisions\
    \ to outsiders if the queries are publicly\n   observable.\n"
- title: 3.4.  Email Address-Like Identifiers
  contents:
  - "3.4.  Email Address-Like Identifiers\n   Section 3.4.1 of [RFC5322] defines the\
    \ syntax of an email address-\n   like identifier, and Section 3.2 of [RFC6532]\
    \ updates it to support\n   internationalization.  Section 7.5 of [RFC5280] further\
    \ discusses the\n   use of internationalized email addresses in certificates.\n\
    \   Regarding the security impact of internationalized email headers,\n   [RFC6532]\
    \ points to Section 14 of [RFC6530], which contains a\n   discussion of many issues\
    \ resulting from internationalization.\n   Email address-like identifiers have\
    \ a local part and a domain part.\n   The issues with the domain part are essentially\
    \ the same as with\n   hostnames, as covered earlier in Section 3.1.\n   The local\
    \ part is left for each domain to define.  People quite\n   commonly use email\
    \ addresses as usernames with web sites such as\n   banks or shopping sites, but\
    \ the site doesn't know whether\n   foo@example.com is the same person as FOO@example.com.\
    \  Thus, email\n   address-like identifiers are typically Indefinite identifiers.\n\
    \   To avoid false positives, some security mechanisms (such as those\n   described\
    \ in [RFC5280]) compare the local part using an exact match.\n   Hence, like URIs,\
    \ email address-like identifiers are designed for use\n   in grant-on-match security\
    \ schemes, not in deny-on-match schemes.\n   Furthermore, when such identifiers\
    \ are actually used as email\n   addresses, Section 2.4 of [RFC5321] states that\
    \ the local part of a\n   mailbox must be treated as case sensitive, but if a\
    \ mailbox is stored\n   and accessed using a filesystem using case-insensitive\
    \ paths, there\n   may be many paths that refer to the same mailbox.  As such,\
    \ false\n   negatives can be common in this case.\n"
- title: 4.  General Issues
  contents:
  - '4.  General Issues

    '
- title: 4.1.  Conflation
  contents:
  - "4.1.  Conflation\n   There are a number of examples (some in the preceding sections)\
    \ of\n   strings that conflate two types of identifiers, using some heuristic\n\
    \   to try to determine which type of identifier is given.  Similarly,\n   two\
    \ ways of encoding the same type of identifier might be conflated\n   within the\
    \ same string.\n   Some examples include:\n   1.  A string that might be an IPv4\
    \ address literal or an IPv6 address\n       literal\n   2.  A string that might\
    \ be an IP address literal or a hostname\n   3.  A string that might be a port\
    \ number or a service name\n   4.  A DNS label that might be literal or be Punycode-encoded\n\
    \   Strings that allow such conflation can only be considered Definite if\n  \
    \ there exists a well-defined rule to determine which identifier type\n   is meant.\
    \  One way to do so is to ensure that the valid syntax for\n   the two is disjoint\
    \ (e.g., distinguishing IPv4 vs. IPv6 address\n   literals by the use of colons\
    \ in the latter).  A second way to do so\n   is to define a precedence rule that\
    \ results in some identifiers being\n   inaccessible via a conflated string (e.g.,\
    \ a host literally named\n   \"xn--de-jg4avhby1noc0d\" may be inaccessible due\
    \ to the \"xn--\" prefix\n   denoting the use of Punycode encoding).  In some\
    \ cases, such\n   inaccessible space may be reserved so that the actual set of\n\
    \   identifiers in use is unambiguous.  For example, Section 2.5.5.2 of\n   [RFC4291]\
    \ defines a range of the IPv6 address space for representing\n   IPv4 addresses.\n"
- title: 4.2.  Internationalization
  contents:
  - "4.2.  Internationalization\n   In addition to the issues with hostnames discussed\
    \ in Section 3.1.3,\n   there are a number of internationalization issues that\
    \ apply to many\n   types of Definite and Indefinite identifiers.\n   First, there\
    \ is no DNS mechanism for identifying whether\n   non-identical strings would\
    \ be seen by a human as being equivalent.\n   There are problematic examples even\
    \ with US-ASCII (Basic Latin)\n   strings, including regional spelling variations\
    \ such as \"color\" and\n   \"colour\", and with many non-English cases, including\
    \ partially\n   numeric strings in Arabic script contexts, Chinese strings in\n\
    \   Simplified and Traditional forms, and so on.  Attempts to produce\n   such\
    \ alternate forms algorithmically could produce false positives\n   and hence\
    \ have an adverse effect on security.\n   Second, some strings are visually confusable\
    \ with others, and hence\n   if a security decision is made by a user based on\
    \ visual inspection,\n   many opportunities for false positives exist.  As such,\
    \ using visual\n   inspection for security is unreliable.  In addition to the\
    \ security\n   issues, visual confusability also adversely affects the usability\
    \ of\n   identifiers distributed via visual media.  Similar issues can arise\n\
    \   with audible confusability when using audio (e.g., for radio\n   distribution,\
    \ accessibility to the blind, etc.) in place of a visual\n   medium.  Furthermore,\
    \ when strings conflate two types of identifiers\n   as discussed in Section 4.1,\
    \ allowing non-ASCII characters can cause\n   one type of identifier to appear\
    \ to a human as another type of\n   identifier.  For example, characters that\
    \ may look like digits and\n   dots may appear to be an IPv4 literal to a human\
    \ (especially to one\n   who might expect digits to appear in his or her native\
    \ script).\n   Hence, conflation often increases the chance of confusability.\n\
    \   Determining whether a string is a valid identifier should typically\n   be\
    \ done after, or as part of, canonicalization.  Otherwise, an\n   attacker might\
    \ use the canonicalization algorithm to inject (e.g.,\n   via percent encoding,\
    \ Normalization Form KC (NFKC), or non-shortest-\n   form UTF-8) delimiters such\
    \ as '@' in an email address-like\n   identifier, or a '.' in a hostname.\n  \
    \ Any case-insensitive comparisons need to define how comparison is\n   done,\
    \ since such comparisons may vary by the locale of the endpoint.\n   As such,\
    \ using case-insensitive comparisons in general often results\n   in identifiers\
    \ being either Indefinite or, if the legal character set\n   is restricted (e.g.,\
    \ to US-ASCII), Definite.\n   See also [WEBER] for a more visual discussion of\
    \ many of these\n   issues.\n   Finally, the set of permitted characters and the\
    \ canonical form of\n   the characters (and hence the canonicalization algorithm)\
    \ sometimes\n   vary by protocol today, even when the intent is to use the same\n\
    \   identifier, such as when one protocol passes identifiers to the\n   other.\
    \  See [RFC6885] for further discussion.\n"
- title: 4.3.  Scope
  contents:
  - "4.3.  Scope\n   Another issue arises when an identifier (e.g., \"localhost\"\
    ,\n   \"10.11.12.13\", etc.) is not globally unique.  Section 1.1 of\n   [RFC3986]\
    \ states:\n      URIs have a global scope and are interpreted consistently\n \
    \     regardless of context, though the result of that interpretation\n      may\
    \ be in relation to the end-user's context.  For example,\n      \"http://localhost/\"\
    \ has the same interpretation for every user of\n      that reference, even though\
    \ the network interface corresponding to\n      \"localhost\" may be different\
    \ for each end-user: interpretation is\n      independent of access.\n   Whenever\
    \ an identifier that is not globally unique is passed to\n   another entity outside\
    \ of the scope of uniqueness, it will refer to a\n   different resource and can\
    \ result in a false positive.  This problem\n   is often addressed by using the\
    \ identifier together with some other\n   unique identifier of the context.  For\
    \ example, \"alice\" may uniquely\n   identify a user within a system but must\
    \ be used with \"example.com\"\n   (as in \"alice@example.com\") to uniquely identify\
    \ the context outside\n   of that system.\n   It is also worth noting that IPv6\
    \ addresses that are not globally\n   scoped can be written with, or otherwise\
    \ associated with, a \"zone ID\"\n   to identify the context (see [RFC4007] for\
    \ more information).\n   However, zone IDs are only unique within a host, so they\
    \ typically\n   narrow, rather than expand, the scope of uniqueness of the resulting\n\
    \   identifier.\n"
- title: 4.4.  Temporality
  contents:
  - "4.4.  Temporality\n   Often, identifiers are not unique across all time but have\
    \ some\n   lifetime associated with them after which they may be reassigned to\n\
    \   another entity.  For example, bob@example.com might be assigned to an\n  \
    \ employee of the Example company, but if he leaves and another Bob is\n   later\
    \ hired, the same identifier might be reused.  As another\n   example, IP address\
    \ 203.0.113.1 might be assigned to one subscriber\n   and then later reassigned\
    \ to another subscriber.  Security issues can\n   arise if updates are not made\
    \ in all entities that store the\n   identifier (e.g., in an access control list\
    \ as discussed in\n   Section 2, or in a resolution cache as discussed in Section\
    \ 3.1.4).\n   This issue is similar to the issue of scope discussed in Section\
    \ 4.3,\n   except that the scope of uniqueness is temporal rather than\n   topological.\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   This entire document is about security considerations.\n\
    \   To minimize issues related to elevation of privilege, any system that\n  \
    \ requires the ability to use both deny and allow operations within the\n   same\
    \ identifier space should avoid the use of Indefinite identifiers\n   in security\
    \ comparisons.\n   To minimize future security risks, any new identifiers being\
    \ designed\n   should specify an Absolute or Definite comparison algorithm, and\
    \ if\n   extensibility is allowed (e.g., as new schemes in URIs allow), then\n\
    \   the comparison algorithm should remain invariant so that unrecognized\n  \
    \ extensions can be compared.  That is, security risks can be reduced\n   by specifying\
    \ the comparison algorithm, making sure to resolve any\n   ambiguities pointed\
    \ out in this document (e.g., \"standard dotted\n   decimal\").\n   Some issues\
    \ (such as unrecognized extensions) can be mitigated by\n   treating such identifiers\
    \ as invalid.  Validity checking of\n   identifiers is further discussed in [RFC3696].\n\
    \   Perhaps the hardest issues arise when multiple protocols are used\n   together,\
    \ such as in Figure 2, where the two protocols are defined or\n   implemented\
    \ using different comparison algorithms.  When constructing\n   an architecture\
    \ that uses multiple such protocols, designers should\n   pay attention to any\
    \ differences in comparison algorithms among the\n   protocols in order to fully\
    \ understand the security risks.  How to\n   deal with such security risks in\
    \ current systems is an area for\n   future work.\n"
- title: 6.  Acknowledgements
  contents:
  - "6.  Acknowledgements\n   Yaron Goland contributed to the discussion on URIs.\
    \  Patrik Faltstrom\n   contributed to the background on identifiers.  John Klensin\n\
    \   contributed text in a number of different sections.  Additional\n   helpful\
    \ feedback and suggestions came from Bernard Aboba, Fred Baker,\n   Leslie Daigle,\
    \ Mark Davis, Jeff Hodges, Bjoern Hoehrmann, Russ\n   Housley, Christian Huitema,\
    \ Magnus Nystrom, Tom Petch, and Chris\n   Weber.\n"
- title: 7.  IAB Members at the Time of Approval
  contents:
  - "7.  IAB Members at the Time of Approval\n   Bernard Aboba\n   Jari Arkko\n  \
    \ Marc Blanchet\n   Ross Callon\n   Alissa Cooper\n   Spencer Dawkins\n   Joel\
    \ Halpern\n   Russ Housley\n   David Kessens\n   Danny McPherson\n   Jon Peterson\n\
    \   Dave Thaler\n   Hannes Tschofenig\n"
- title: 8.  Informative References
  contents:
  - "8.  Informative References\n   [IAB1123]  Internet Architecture Board, \"IAB\
    \ Statement: 'The\n              interpretation of rules in the ICANN gTLD Applicant\n\
    \              Guidebook'\", February 2012, <http://www.iab.org/documents/\n \
    \             correspondence-reports-documents/2012-2/iab-statement-the-\n   \
    \           interpretation-of-rules-in-the-icann-gtld-applicant-\n           \
    \   guidebook>.\n   [IANA-PORT]\n              IANA, \"Service Name and Transport\
    \ Protocol Port Number\n              Registry\", March 2013,\n              <http://www.iana.org/assignments/service-names-port-\n\
    \              numbers/>.\n   [IEEE-1003.1]\n              IEEE and The Open Group,\
    \ \"The Open Group Base\n              Specifications, Issue 6, IEEE Std 1003.1,\
    \ 2004 Edition\",\n              IEEE Std 1003.1, 2004.\n   [JAVAURL]  Oracle,\
    \ \"Class URL\", Java(TM) Platform Standard Ed. 7,\n              2013, <http://docs.oracle.com/javase/7/docs/api/java/net/\n\
    \              URL.html>.\n   [OASIS-SAMLv2-CORE]\n              Cantor, S., Ed.,\
    \ Kemp, J., Ed., Philpott, R., Ed., and E.\n              Maler, Ed., \"Assertions\
    \ and Protocols for the OASIS\n              Security Assertion Markup Language\
    \ (SAML) V2.0\", OASIS\n              Standard saml-core-2.0-os, March 2005,\n\
    \              <http://docs.oasis-open.org/security/saml/v2.0/\n             \
    \ saml-core-2.0-os.pdf>.\n   [OAuth-WRAP]\n              Hardt, D., Ed., Tom,\
    \ A., Eaton, B., and Y. Goland, \"OAuth\n              Web Resource Authorization\
    \ Profiles\", Work in Progress,\n              January 2010.\n   [PRIVACY-CONS]\n\
    \              Cooper, A., Tschofenig, H., Aboba, B., Peterson, J.,\n        \
    \      Morris, J., Hansen, M., and R. Smith, \"Privacy\n              Considerations\
    \ for Internet Protocols\", Work in Progress,\n              April 2013.\n   [RFC1034]\
    \  Mockapetris, P., \"Domain names - concepts and facilities\",\n            \
    \  STD 13, RFC 1034, November 1987.\n   [RFC1123]  Braden, R., \"Requirements\
    \ for Internet Hosts - Application\n              and Support\", STD 3, RFC 1123,\
    \ October 1989.\n   [RFC2277]  Alvestrand, H.T., \"IETF Policy on Character Sets\
    \ and\n              Languages\", BCP 18, RFC 2277, January 1998.\n   [RFC3490]\
    \  Faltstrom, P., Hoffman, P., and A. Costello,\n              \"Internationalizing\
    \ Domain Names in Applications (IDNA)\",\n              RFC 3490, March 2003.\n\
    \   [RFC3492]  Costello, A., \"Punycode: A Bootstring encoding of Unicode\n  \
    \            for Internationalized Domain Names in Applications\n            \
    \  (IDNA)\", RFC 3492, March 2003.\n   [RFC3493]  Gilligan, R., Thomson, S., Bound,\
    \ J., McCann, J., and W.\n              Stevens, \"Basic Socket Interface Extensions\
    \ for IPv6\",\n              RFC 3493, February 2003.\n   [RFC3696]  Klensin,\
    \ J., \"Application Techniques for Checking and\n              Transformation\
    \ of Names\", RFC 3696, February 2004.\n   [RFC3986]  Berners-Lee, T., Fielding,\
    \ R., and L. Masinter, \"Uniform\n              Resource Identifier (URI): Generic\
    \ Syntax\", STD 66,\n              RFC 3986, January 2005.\n   [RFC4007]  Deering,\
    \ S., Haberman, B., Jinmei, T., Nordmark, E., and\n              B. Zill, \"IPv6\
    \ Scoped Address Architecture\", RFC 4007,\n              March 2005.\n   [RFC4291]\
    \  Hinden, R. and S. Deering, \"IP Version 6 Addressing\n              Architecture\"\
    , RFC 4291, February 2006.\n   [RFC4790]  Newman, C., Duerst, M., and A. Gulbrandsen,\
    \ \"Internet\n              Application Protocol Collation Registry\", RFC 4790,\n\
    \              March 2007.\n   [RFC4949]  Shirey, R., \"Internet Security Glossary,\
    \ Version 2\",\n              RFC 4949, August 2007.\n   [RFC5280]  Cooper, D.,\
    \ Santesson, S., Farrell, S., Boeyen, S.,\n              Housley, R., and W. Polk,\
    \ \"Internet X.509 Public Key\n              Infrastructure Certificate and Certificate\
    \ Revocation List\n              (CRL) Profile\", RFC 5280, May 2008.\n   [RFC5321]\
    \  Klensin, J., \"Simple Mail Transfer Protocol\", RFC 5321,\n              October\
    \ 2008.\n   [RFC5322]  Resnick, P., Ed., \"Internet Message Format\", RFC 5322,\n\
    \              October 2008.\n   [RFC5952]  Kawamura, S. and M. Kawashima, \"\
    A Recommendation for IPv6\n              Address Text Representation\", RFC 5952,\
    \ August 2010.\n   [RFC6055]  Thaler, D., Klensin, J., and S. Cheshire, \"IAB\
    \ Thoughts on\n              Encodings for Internationalized Domain Names\", RFC\
    \ 6055,\n              February 2011.\n   [RFC6066]  Eastlake, D., \"Transport\
    \ Layer Security (TLS) Extensions:\n              Extension Definitions\", RFC\
    \ 6066, January 2011.\n   [RFC6125]  Saint-Andre, P. and J. Hodges, \"Representation\
    \ and\n              Verification of Domain-Based Application Service Identity\n\
    \              within Internet Public Key Infrastructure Using X.509\n       \
    \       (PKIX) Certificates in the Context of Transport Layer\n              Security\
    \ (TLS)\", RFC 6125, March 2011.\n   [RFC6335]  Cotton, M., Eggert, L., Touch,\
    \ J., Westerlund, M., and S.\n              Cheshire, \"Internet Assigned Numbers\
    \ Authority (IANA)\n              Procedures for the Management of the Service\
    \ Name and\n              Transport Protocol Port Number Registry\", BCP 165,\n\
    \              RFC 6335, August 2011.\n   [RFC6530]  Klensin, J. and Y. Ko, \"\
    Overview and Framework for\n              Internationalized Email\", RFC 6530,\
    \ February 2012.\n   [RFC6532]  Yang, A., Steele, S., and N. Freed, \"Internationalized\n\
    \              Email Headers\", RFC 6532, February 2012.\n   [RFC6818]  Yee, P.,\
    \ \"Updates to the Internet X.509 Public Key\n              Infrastructure Certificate\
    \ and Certificate Revocation List\n              (CRL) Profile\", RFC 6818, January\
    \ 2013.\n   [RFC6874]  Carpenter, B., Cheshire, S., and R. Hinden, \"Representing\n\
    \              IPv6 Zone Identifiers in Address Literals and Uniform\n       \
    \       Resource Identifiers\", RFC 6874, February 2013.\n   [RFC6885]  Blanchet,\
    \ M. and A. Sullivan, \"Stringprep Revision and\n              Problem Statement\
    \ for the Preparation and Comparison of\n              Internationalized Strings\
    \ (PRECIS)\", RFC 6885, March 2013.\n   [TR36]     Unicode Consortium, \"Unicode\
    \ Security Considerations\",\n              Unicode Technical Report #36, Revision\
    \ 11, July 2012,\n              <http://www.unicode.org/reports/tr36/>.\n   [USASCII]\
    \  American National Standards Institute, \"Coded Character\n              Sets\
    \ -- 7-bit American Standard Code for Information\n              Interchange (7-bit\
    \ ASCII)\", ANSI X3.4, 1986.\n   [WEBER]    Weber, C., \"Attacking Software Globalization\"\
    , March 2010,\n              <http://www.lookout.net/files/\n              Chris_Weber_Character%20Transformations%20v1.7_IUC33.pdf>.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Dave Thaler (editor)\n   Microsoft Corporation\n   One Microsoft\
    \ Way\n   Redmond, WA  98052\n   USA\n   Phone: +1 425 703 8835\n   EMail: dthaler@microsoft.com\n"
