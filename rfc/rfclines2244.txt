Abstract The Application Configuration Access Protocol (ACAP) is designed to support remote storage and access of program option, configuration and preference information.
The data store model is designed to allow a client relatively simple access to interesting data, to allow new information to be easily added without server re configuration, and to promote the use of both standardized data and custom or proprietary data.
Key features include "inheritance" which can be used to manage default values for configuration settings and access control lists which allow interesting personal information to be shared and group information to be restricted.
Conventions Used in this Document
In examples, "C:" and "S:" indicate lines sent by the client and server respectively.
If such lines are wrapped without a new "C:" or "S:" label, then the wrapping is for editorial clarity and is not part of the command.
The key words "REQUIRED", "MUST", "MUST NOT", "SHOULD", "SHOULD NOT", and "MAY" in this document are to be interpreted as described in "Key words for use in RFCs to Indicate Requirement Levels" [KEYWORDS].
An ACAP server exports a hierarchical tree of entries.
Each level of the tree is called a dataset, and each dataset is made up of a list of entries.
Each entry has a unique name and may contain any number of named attributes.
Each attribute within an entry may be single valued or multi valued and may have associated metadata to assist access and interpretation of the value.
The rules with which a client interprets the data within a portion of ACAP's tree of entries are called a dataset class.
ACAP Design Goals ACAP's primary purpose is to allow users access to their configuration data from multiple network connected computers.
Users can then sit down in front of any network connected computer, run any ACAP enabled application and have access to their own configuration data.
Because it is hoped that many applications will become ACAP  enabled, client simplicity was preferred to server or protocol simplicity whenever reasonable.
ACAP is designed to be easily manageable.
For this reason, it includes "inheritance" which allows one dataset to inherit default attributes from another dataset.
In addition, access control lists are included to permit delegation of management and quotas are included to control storage.
Finally, an ACAP server which is conformant to this base specification should be able to support most dataset classes defined in the future without requiring a server reconfiguration or upgrade.
ACAP is designed to operate well with a client that only has intermittent access to an ACAP server.
For this reason, each entry has a server maintained modification time so that the client may detect changes.
In addition, the client may ask the server for a list of entries which have been removed since it last accessed the server.
ACAP presumes that a dataset may be potentially large and/or the client's network connection may be slow, and thus offers server sorting, selective fetching and change notification for entries within a dataset.
As required for most Internet protocols, security, scalability and internationalization were important design goals.
Given these design goals, an attempt was made to keep ACAP as simple as possible.
It is a traditional Internet text based protocol which massively simplifies protocol debugging.
It was designed based on the successful IMAP [IMAP4] protocol framework, with a few refinements.
Validation By default, any value may be stored in any attribute for which the user has appropriate permission and quota.
This rule is necessary to allow the addition of new simple dataset classes without reconfiguring or upgrading the server.
In some cases, such as when the value has special meaning to the server, it is useful to have the server enforce validation by returning the INVALID response code to a STORE command.
These cases MUST be explicitly identified in the dataset class specification which SHOULD include specific fixed rules for validation.
Since a given ACAP server may be unaware of any particular dataset class specification, clients MUST NOT depend on the presence of enforced validation on the server.
Definitions access control list (ACL)
A set of identifier, rights pairs associated with an object.
An ACL is used to determine which operations a user is permitted to perform on that object.
attribute A named value within an entry.
comparator A named function which can be used to perform one or more of three comparison operations: ordering, equality and substring matching.
An ordered subset of entries in a dataset, created by a SEARCH command with a MAKECONTEXT modifier.
dataset One level of hierarchy in ACAP's tree of entries.
The rules which allow a client to interpret the data within a portion of ACAP's tree of entries.
entry A set of attributes with a unique entry name.
metadata Information describing an attribute, its value and any access controls associated with that attribute.
This represents the non existence of a particular data item.
NUL  A control character encoded as 0 in US ASCII [US ASCII].
octet An 8 bit value.
On most modern computer systems, an octet is one byte.
SASL Simple Authentication and Security Layer [SASL].
UTC  Universal Coordinated Time as maintained by the Bureau International des Poids et Mesures (BIPM).
UTF 8 An 8 bit transformation format of the Universal Character Set [UTF8].
Note that an incompatible change was made to the coded character set referenced by [UTF8],
so for the purpose of this document, UTF 8 refers to the UTF 8 encoding as defined by version 2.0 of Unicode [UNICODE 2], or ISO 10646 [ISO 10646] including amendments one through seven.
The AUTHENTICATE, NOOP, LANG and LOGOUT commands provide basic protocol services.
The SEARCH command is used to select, sort, fetch and monitor changes to attribute values and metadata.
The UPDATECONTEXT and FREECONTEXT commands are also used to assist in monitoring changes in attribute values and metadata.
The STORE command is used to add, modify and delete entries and attributes.
The DELETEDSINCE command is used to assist a client in re synchronizing a cache with the server.
The GETQUOTA, SETACL, DELETEACL, LISTRIGHTS and MYRIGHTS commands are used to examine storage quotas and examine or modify access permissions.
The ACAP protocol assumes a reliable data stream such as provided by TCP.
When TCP is used, an ACAP server listens on port 674.
An ACAP session consists of the establishment of a client/server connection, an initial greeting from the server, and client/server interactions.
These client/server interactions consist of a client command, server data, and a server completion result.
ACAP is a text based line oriented protocol.
In general, interactions transmitted by clients and servers are in the form of lines; that is, sequences of characters that end with a CRLF.
The protocol receiver of an ACAP client or server is either reading a line, or is reading a sequence of octets with a known count (a literal) followed by a line.
Both clients and servers must be capable of handling lines of arbitrary length.
Client Protocol Sender and Server Protocol Receiver
The client command begins an operation.
Each client command is prefixed with a identifier (an alphanumeric string of no more than 32 characters, e.g., A0001, A0002, etc.) called a "tag".
A different tag SHOULD be generated by the client for each command.
There are two cases in which a line from the client does not represent a complete command.
In one case, a command argument is quoted with an octet count (see the description of literal in section 2.6.3); in the other case, the command arguments require server feedback (see the AUTHENTICATE command).
In some of these cases, the server sends a command continuation request if it is ready for the next part of the command.
Note: If, instead, the server detected an error in a command, it sends a BAD completion response with tag matching the command (as described below) to reject the command and prevent the client from sending any more of the command.
It is also possible for the server to send a completion or intermediate response for some other command (if multiple commands are in progress), or untagged data.
In either case, the command continuation request is still pending; the client takes the appropriate action for the response, and reads another response from the server.
The ACAP server reads a command line from the client, parses the command and its arguments, and transmits server data and a server command completion result.
Server Protocol Sender and Client Protocol Receiver Data transmitted by the server to the client come in four forms:
command continuation requests, command completion results, intermediate responses, and untagged responses.
A command completion result indicates the success or failure of the operation.
It is tagged with the same tag as the client command which began the operation.
Thus, if more than one command is in progress, the tag in a server completion response identifies the command to which the response applies.
There are three possible server completion responses: OK (indicating success), NO (indicating failure), or BAD (indicating protocol error such as unrecognized command or command syntax error).
An intermediate response returns data which can only be interpreted within the context of a command in progress.
It is tagged with the same tag as the client command which began the operation.
Thus, if more than one command is in progress, the tag in an intermediate response identifies the command to which the response applies.
A tagged response other than "OK", "NO", or "BAD" is an intermediate response.
An untagged response returns data or status messages which may be interpreted outside the context of a command in progress.
Untagged data may be sent as a result of a client command, or may be sent unilaterally by the server.
There is no syntactic difference between untagged data that resulted from a specific command and untagged data that were sent unilaterally.
The protocol receiver of an ACAP client reads a response line from the server.
A client MUST be prepared to accept any server response at all times.
This includes untagged data that it may not have requested.
This topic is discussed in greater detail in the Server Responses section.
An ACAP server is in one of three states.
Most commands are valid in only certain states.
It is a protocol error for the client to attempt a command while the server is in an inappropriate state for that command.
In this case, a server will respond with a BAD command completion result.
In non authenticated state, the user must supply authentication credentials before most commands will be permitted.
This state is entered when a connection starts.
In authenticated state, the user is authenticated and most commands will be permitted.
This state is entered when acceptable authentication credentials have been provided.
In logout state, the session is being terminated, and the server will close the connection.
This state can be entered as a result of a client request or by unilateral server decision.
(2) rejected connection (BYE greeting)
(3) successful AUTHENTICATE command (4) LOGOUT command, server shutdown, or connection closed 2.4.
At any time, a server can send data that the client did not request.
Response when No Command in Progress Server implementations are permitted to send an untagged response while there is no command in progress.
Server implementations that send such responses MUST deal with flow control considerations.
Specifically, they must either (1) verify that the size of the data does not exceed the underlying transport's available window size, or (2) use non blocking writes.
If a server has an inactivity auto logout timer, that timer MUST be of at least 30 minutes duration.
The receipt of ANY command from the client during that interval MUST suffice to reset the auto logout timer.
The client is not required to wait for the completion result of a command before sending another command, subject to flow control constraints on the underlying data stream.
Similarly, a server is not required to process a command to completion before beginning processing of the next command, unless an ambiguity would result because of a command that would affect the results of other commands.
If there is such an ambiguity, the server executes commands to completion in the order given by the client.
This indicates that the server is ready to accept the continuation of a command from the client.
This response is used in the AUTHENTICATE command to transmit server data to the client, and request additional client data.
This response is also used if an argument to any command is a synchronizing literal (see section 2.6.3).
The client is not permitted to send the octets of a synchronizing literal unless the server indicates that it expects it.
This permits the server to process commands and reject errors on a line by line basis, assuming it checks for non synchronizing literals at the end of each line.
The remainder of the command, including the CRLF that terminates a command, follows the octets of the literal.
If there are any additional command arguments the literal octets are followed by a space and those arguments.
"Ready for additional command text" C: FRED C:
A099 OK "FREECONTEXT completed" C:
{102856} S: A044 BAD "No such command as 'BLURDYBLOOP'" 2.6.
Data Formats ACAP uses textual commands and responses.
Data in ACAP can be in one of five forms: atom, number, string, parenthesized list or NIL.
An atom consists of one to 1024 non special characters.
It must begin with a letter.
Atoms are used for protocol keywords.
A number consists of one or more digit characters, and represents a numeric value.
Numbers are restricted to the range of an unsigned 32 bit integer:
0 < number < 4,294,967,296.
A string is in one of two forms: literal and quoted string.
The literal form is the general form of string.
The quoted string form is an alternative that avoids the overhead of processing a literal at the cost of restrictions of what may be in a quoted string.
In the case of literals transmitted from server to client, the CRLF is immediately followed by the octet data.
There are two forms of literals transmitted from client to server.
When sending a synchronizing literal, the client must wait to receive a command continuation request before sending the octet data (and the remainder of the command).
The other form of literal, the non synchronizing literal, is used to transmit a string from client to server without waiting for a command continuation request.
and by having the octet data immediately following the CRLF.
Note: Even if the octet count is 0, a client transmitting a synchronizing literal must wait to receive a command continuation request.
8 bit and Binary Strings Most strings in ACAP are restricted to UTF 8 characters and may not contain NUL octets.
Attribute values MAY contain any octets including NUL.
Parenthesized List Data structures are represented as a "parenthesized list"; a sequence of data items, delimited by space, and bounded at each end by parentheses.
A parenthesized list can contain other parenthesized lists, using multiple levels of parentheses to indicate nesting.
The empty list is represented as ()
a parenthesized list with no members.
The special atom "NIL" represents the non existence of a particular data item that is represented as a string or parenthesized list, as distinct from the empty string "" or the empty parenthesized list ().
This section defines data formats and other protocol elements used throughout the ACAP protocol.
A slash separated list of entries, one at each level of the hierarchy, forms the full path to an entry.
Each entry is made up of a set of attributes.
The value of an attribute is either single or multi valued.
A single value is NIL (has no value), or a string of zero or more octets.
A multi value is a list of zero or more strings, each of zero or more octets.
Invalid attribute names result in a BAD response.
Invalid entry names in the entry field of a command result in a BAD response.
Use of non visible UTF 8 characters in attribute and entry names is discouraged.
The following attributes are defined by the ACAP protocol.
entry Contains the name of the entry.
Attempts to use illegal or multi valued values for the entry attribute are protocol errors and MUST result in a BAD completion response.
This is a special case.
modtime Contains the date and time
any read write metadata in the entry was last modified.
This value MUST be in UTC, MUST be automatically updated by the server.
The value consists of 14 or more US ASCII digits.
The first four indicate the year, the next two indicate the month, the next two indicate the day of month, the next two indicate the hour (0 23), the next two indicate the minute, and the next two indicate the second.
Any further digits indicate fractions of a second.
The time, particularly fractions of a second, need not be accurate.
It is REQUIRED, however, that any two entries in a dataset changed by successive modifications have strictly ascending modtime values.
In addition, each STORE command within a dataset (including simultaneous stores from different connections) MUST use different modtime values.
This attribute has enforced validation, so any attempt to STORE a value in this attribute MAY result in a NO response with an INVALID response code.
If this attribute is set, it indicates the existence of a sub  dataset of this entry.
The value consists of a list of relative ACAP URLs (see section 3.2) which may be used to locate the sub dataset.
" indicates a subdataset is located directly under this one.
Multiple values indicate replicated copies of the subdataset.
For example, if the dataset "/folder/site/" has an entry "public folder" with a subdataset attribute of ".
", then there exists a dataset "/folder/site/public folder/".
If the value of the subdataset attribute was instead "//other.acap.domain//folder/site/public folder/", that would indicate the dataset is actually located on a different ACAP server.
This attribute has enforced syntax validation.
Specifically, if an attempt is made to STORE a non list value (other than NIL), an empty list, or one of the values does not follow the URL syntax rules [BASIC URL, REL URL], then this will result in a NO response with an INVALID response code.
Each attribute is made up of metadata items which describe that attribute, its value and any associated access controls.
Metadata items may be either read only, in which case the client is never permitted to modify the item, or read write, in which case the client may modify the item if the access control list (ACL) permits.
The following metadata items are defined in this specification:
The access control list for the attribute, if one exists.
If the attribute does not have an ACL, NIL is returned.
See section 3.5 for the contents of an ACL.
The set of rights that the client has to the attribute.
See section 3.5 for the possible rights.
This is the length of the value.
In the case of a multi value, this is a list of lengths for each of the values.
For a multi value, this is a list of single values.
Additional items of metadata may be defined in extensions to this protocol.
Servers MUST respond to unrecognized metadata by returning a BAD command completion result.
ACAP URL scheme ACAP URLs are used within the ACAP protocol for the "subdataset" attribute, referrals and inheritance.
They provide a convenient syntax for referring to other ACAP datasets.
The ACAP URL follows the common Internet scheme syntax as defined in [BASIC URL] except that plaintext passwords are not permitted.
If :<port> is omitted, the port defaults to 674.
> element includes the hostname, and optional user name, authentication mechanism and port number.
> element contains the name of an entry path encoded according to the rules in [BASIC URL].
The <url filter> element is an optional list of interesting attribute names.
If omitted, the URL refers to all attributes of the named entry.
The <url extension> element is reserved for extensions to this URL scheme.
" MUST be hex encoded as described in the URL specification [BASIC URL].
Hex encoded octets are interpreted according to UTF 8 [UTF8].
ACAP URL User Name and Authentication Mechanism
A user name and/or authentication mechanism may be supplied.
They are used in the "AUTHENTICATE" command after making the connection to the ACAP server.
If no user name or authentication mechanism is supplied, then the SASL ANONYMOUS [SASL ANON] mechanism is used by default.
If an authentication mechanism is supplied without a user name, then one SHOULD be obtained from the specified mechanism or requested from the user as appropriate.
If a user name is supplied without an authentication mechanism then ";AUTH  " is assumed.
The ";AUTH " authentication parameter is interpreted as described in the IMAP URL Scheme [IMAP URL].
The <aauth> grammar element is considered part of the user name for purposes of resolving relative ACAP URLs.
The base URL for a relative URL stored in an attribute's value is formed by taking the path to the dataset containing that attribute, appending
Contexts A context is subset of entries in a dataset or datasets, created by a SEARCH command with a MAKECONTEXT modifier.
When a client creates a context, it may request automatic notification of changes.
A client may also request enumeration of entries within a context.
Enumeration simplifies the implementation of a "virtual scrollbar" by the client.
A context exists only within the ACAP session in which it was created.
When the connection is closed, all contexts associated with that connection are automatically discarded.
A server is required to support at least 100 active contexts within a session.
If the server supports a larger limit it must advertise it in a CONTEXTLIMIT capability.
Comparators A comparator is a named function which takes two input values and can be used to perform one or more of four comparison operations: ordering, equality, prefix and substring matching.
The ordering operation is used both for the SORT search modifier and the COMPARE and COMPARESTRICT search keys.
Ordering comparators can determine the ordinal precedence of any two values.
For the purpose of ordering, a comparator may designate certain values as having an undefined ordinal precedence.
Such values always collate with equal value after all other values regardless of whether normal or reversed ordering is used.
Unless the comparator definition specifies otherwise, multi values and NIL values have an undefined ordinal precedence.
The equality operation is used for the EQUAL search modifier, and simply determines if the two values are considered equal under the comparator function.
When comparing a single value to a multi value, the two are considered equal if any one of the multiple values is equal to the single value.
The prefix match operation is used for the PREFIX search modifier, and simply determines if the search value is a prefix of the item being searched.
In the case of prefix search on a multi value, the match is successful if the value is a prefix of any one of the multiple values.
The substring match operation is used for the SUBSTRING search modifier, and simply determines if search value is a substring of the item being searched.
In the case of substring search on a multi  value, the match is successful if the value is a substring of any one of the multiple values.
Rules for naming and registering comparators will be defined in a future specification.
Servers MUST respond to unknown or improperly used comparators with a BAD command completion result.
The following comparators are defined by this standard and MUST be implemented:
Ordering, Equality, Prefix match, Substring match For collation, the i;octet comparator interprets the value of an attribute as a series of unsigned octets with ordinal values from 0 to 255.
When ordering two strings, each octet pair is compared in sequence until the octets are unequal or the end of the string is reached.
When collating two strings where the shorter is a prefix of the longer, the shorter string is interpreted as having a smaller ordinal value.
The "i;octet" or " i;octet" forms collate smaller ordinal values earlier, and the " i;octet" form collates larger ordinal values earlier.
For the equality function, two strings are equal if they are the same length and contain the same octets in the same order.
NIL is equal only to itself.
For non binary, non nil single values, i;octet ordering is equivalent to the ANSI C [ISO C]
strcmp() function applied to C string representations of the values.
For non binary, non nil single values, i;octet substring match is equivalent to the ANSI C strstr() function applied to the C string representations of the values.
Ordering, Equality, Prefix match, Substring match
The i;ascii casemap comparator first applies a mapping to the attribute values which translates all US ASCII letters to uppercase (octet values 0x61 to 0x7A
are translated to octet values 0x41 to 0x5A respectively), then applies the i;octet comparator as described above.
With this function the values "hello" and "HELLO" have the same ordinal value and are considered equal.
Equality The i;ascii numeric comparator interprets strings as decimal positive integers represented as US ASCII digits.
All values which do not begin with a US ASCII digit are considered equal with an ordinal value higher than all non NIL single valued attributes.
Otherwise, all US ASCII digits (octet values 0x30 to 0x39) are interpreted starting from the beginning of the string to the first non digit or the end of the string.
An access control list is a set of identifier, rights pairs used to restrict access to a given dataset, attribute or attribute within an entry.
An ACL is represented by a multi value with each value containing an identifier followed by a tab character followed by the rights.
The syntax is defined by the "acl" rule in the formal syntax in section 8.
Identifier is a UTF 8 string.
The identifier "anyone" is reserved to refer to the universal identity (all authentications, including anonymous).
All user name strings accepted by the AUTHENTICATE command to authenticate to the ACAP server are reserved as identifiers for the corresponding user.
All other identifiers have implementation defined meanings.
Rights is a string listing a (possibly empty) set of alphanumeric characters, each character listing a set of operations which is being controlled.
Letters are reserved for "standard" rights, listed below.
The set of standard rights may only be extended by a standards track or IESG approved experimental RFC.
Digits are reserved for implementation or site defined rights.
The currently defined standard rights are: x search (use EQUAL search key with i;octet comparator)
r read (access with SEARCH command)
w write (modify with STORE command)
i insert (perform STORE on a previously NIL value) a administer (perform SETACL or STORE on ACL attribute/metadata)
An implementation may force rights to always or never be granted.
In particular, implementations are expected to grant implicit read and administer rights to a user's personal dataset storage in order to avoid denial of service problems.
Rights are never tied, unlike the IMAP ACL extension [IMAP ACL].
It is possible for multiple identifiers in an access control list to apply to a given user (or other authentication identity).
For example, an ACL may include rights to be granted to the identifier matching the user, one or more implementation defined identifiers matching groups which include the user, and/or the identifier "anyone".
These rights are combined by taking the union of all positive rights which apply to a given user and subtracting the union of all negative rights which apply to that user.
A client MAY avoid this calculation by using the MYRIGHTS command and metadata items.
Each attribute of each entry of a dataset may potentially have an ACL.
If an attribute in an entry does not have an ACL, then access is controlled by a default ACL for that attribute in the dataset, if it exists.
If there is no default ACL for that attribute in the dataset, access is controlled by a default ACL for that dataset.
The default ACL for a dataset must exist.
In order to perform any access or manipulation on an entry in a dataset, the client must have 'r' rights on the "entry" attribute of the entry.
Implementations should take care not to reveal via error messages the existence of an entry for which the client does not have 'r' rights.
A client does not need access to the "subdataset" attribute of the parent dataset in order to access the contents of a dataset.
Many of the ACL commands and responses include an "acl object" parameter, for specifying what the ACL applies to.
This is a parenthesized list.
The list contains just the dataset name when referring to the default ACL for a dataset.
The list contains a dataset name and an attribute name when referring to the default ACL for an attribute in a dataset.
The list contains a dataset name, an attribute name, and an entry name when referring to the ACL for an attribute of an entry of a dataset.
An OK, NO, BAD, ALERT or BYE response from the server MAY contain a response code to describe the event in a more detailed machine parsable fashion.
A response code consists of data inside parentheses in the form of an atom, possibly followed by a space and arguments.
Response codes are defined when there is a specific action that a client can take based upon the additional information.
In order to support future extension, the response code is represented as a slash separated hierarchy with each level of hierarchy representing increasing detail about the error.
Clients MUST tolerate additional hierarchical response code detail which they don't understand.
The currently defined response codes are:
This response code is returned on a tagged NO result from an AUTHENTICATE command.
It indicates that site security policy forbids the use of the requested mechanism for the specified authentication identity.
This response code is returned on a tagged NO result from an AUTHENTICATE command.
It indicates that site security policy requires the use of a strong encryption mechanism for the specified authentication identity and mechanism.
This response code indicates that a STORE command included data which the server implementation does not permit.
It MUST NOT be used unless the dataset class specification for the attribute in question explicitly permits enforced server validation.
The argument is the attribute which was invalid.
This response code indicates that a conditional store failed because the modtime on the entry is later than the modtime specified with the STORE command UNCHANGEDSINCE modifier.
The argument is the entry which had been modified.
This response code indicates that a search or NOCREATE store failed because a specified dataset did not exist.
The argument is the dataset which does not exist.
A command failed due to insufficient permission based on the access control list or implicit rights.
The argument is the acl object which caused the permission failure.
QUOTA A STORE or SETACL command which would have increased the size of the dataset failed due to insufficient quota.
This response code may be returned in a tagged NO response to any command that takes a dataset name as a parameter.
It has one or more arguments with the syntax of relative URLs.
It is a referral, indicating that the command should be retried using one of the relative URLs.
This response code can occur in the tagged OK response to a successful AUTHENTICATE command and includes the optional final server response data from the server as specified by SASL [SASL].
This response code may be returned in a tagged OK response to a SEARCH command which includes the LIMIT modifier.
The argument returns the total number of matching entries.
The modtime specified in the DELETEDSINCE command is too old, so deletedsince information is no longer available.
This response code occurs on a NO response to an AUTHENTICATE command.
It indicates that the user name is valid, but the entry in the authentication database needs to be updated in order to permit authentication with the specified mechanism.
This can happen if a user has an entry in a system authentication database such as Unix /etc/passwd, but does not have credentials suitable for use by the specified mechanism.
A command failed due to a temporary server failure.
The client MAY continue using local information and try the command later.
This response code may be returned in a tagged NO response to a SEARCH command which includes the MAKECONTEXT modifier.
It indicates that a new context may not be created due to the server's limit on the number of existing contexts.
This response code may be returned in a tagged NO response to a SEARCH command which includes a HARDLIMIT search modifier.
It indicates that the SEARCH would have returned more entries than the HARDLIMIT permitted.
Additional response codes MUST be registered with IANA according to the proceedures in section 7.2.
Client implementations MUST tolerate response codes that they do not recognize.
The dataset namespace is a slash separated hierarchy.
The first component of the dataset namespace is a dataset class.
Dataset classes MUST have a vendor prefix (vendor.<vendor/product>) or be specified in a standards track or IESG approved experimental RFC.
See section 7.3 for the registration template.
The second component of the dataset name is "site", "group", "host", or "user" referring to server wide data, administrative group data, per host data and per user data respectively.
For "group", "host", and "user" areas, the third component of the path is the group name, the fully qualified host domain name, or the user name.
Dataset names which begin with "/byowner/" are reserved as an alternate view of the namespace.
This provides a way to see all the dataset classes which a particular owner uses.
Byowner provides a way to view a list of dataset classes owned by a given user; this is done using the dataset "/byowner/user/<current user>/" with the NOINHERIT SEARCH modifier.
A dataset of the form "/<dataset class>/user/" may be used to find all users which have made a dataset or entry of that class visible to the current user.
The formal syntax for a dataset name is defined by the "dataset name" rule in section 4.3.
In order to simplify client implementations, the attribute namespace is intended to be unique across all datasets.
Attributes which affect management of the dataset are prefixed with "dataset.".
In addition, a subtree of the "vendor." attribute namespace may be registered with IANA according to the rules in section 7.4.
ACAP implementors are encouraged to help define interoperable dataset classes specifications rather than using the private attribute namespace.
Some users or sites may wish to add their own private attributes to certain dataset classes.
In order to enable this, the "user.<user  name
subtrees of the attribute namespace are reserved for user specific and site specific attributes respectively and will not be standardized.
Such attributes are not interoperable so are discouraged in favor of defining standard attributes.
A future extension is expected to permit discovery of syntax for user or site specific attributes.
Clients wishing to support display of user or site specific attributes should display the value of any non NIL single valued "user.<user name>." or "site."
attribute which has valid UTF 8 syntax.
The formal syntax for an attribute name is defined by the "attribute name" rule in the next section.
Formal Syntax for Dataset and Attribute Namespace
The naming conventions for datasets and attributes are defined by the following ABNF.
Note that this grammar is not part of the ACAP protocol syntax in section 8, as dataset names and attribute names are encoded as strings within the ACAP protocol.
attribute dset    dataset std 1 (".
/" dataset sub dname component   1
name component ;; MUST be registered with IANA 5.
It is possible for one dataset to inherit data from another.
The dataset from which the data is inherited is called the base dataset.
Data in the base dataset appears in the inheriting dataset, except when overridden by a STORE to the inheriting dataset.
The base dataset is usually a system wide or group wide set of defaults.
A system wide dataset usually has one inheriting dataset per user, allowing each user to add to or modify the defaults as appropriate.
An entry which exists in both the inheriting and base dataset inherits a modtime equal to the greater of the two modtimes.
An attribute in such an entry is inherited from the base dataset if it was never modified by a STORE command in the inheriting dataset or if DEFAULT was stored to that attribute.
This permits default entries to be amended rather than replaced in the inheriting dataset.
The "subdataset" attribute is not directly inherited.
A virtual dataset is not visible if NOINHERIT is specified on the SEARCH command.
Servers MUST support at least two levels of inheritance.
This permits a user's dataset such as "/options/user/fred/common" to inherit from a group dataset such as "/options/group/dinosaur operators/common" which in turn inherits from a server wide dataset such as "/options/site/common".
The following attributes apply to management of the dataset when stored in the "" entry of a dataset.
These attributes are not inherited.
This holds the default access control list for the dataset.
This attribute is validated, so an invalid access control list in a STORE command will result in a NO response with an INVALID response code.
This holds the default access control list for an attribute within the dataset.
This attribute is validated, so an invalid access control list in a STORE command will result in a NO response with an INVALID response code.
dataset.inherit This holds the name of a dataset from which to inherit according to the rules in the previous section.
This attribute MAY refer to a non existent dataset, in which case nothing is inherited.
This attribute is validated, so illegal dataset syntax or an attempt to store a multi value will result in a NO response with an INVALID response code.
When a dataset is first created (by storing a ".
" in the subdataset attribute or storing an entry in a previously non existent dataset), the dataset attributes are initialized with the values from the parent dataset in the "/byowner/" hierarchy.
In the case of the "dataset.inherit" attribute, the appropriate hierarchy component is added.
For example, given the following entry (note that \t refers to the US ASCII horizontal tab character):
Certain dataset classes or dataset class features may only be useful if there is an active updating client or integrated server support for the feature.
The dataset class "capability" is reserved to allow clients or servers to advertise such features.
The "entry" attribute within this dataset class is the name of the dataset class whose features are being described.
The attributes are prefixed with "capability.<dataset class>." and are defined by the appropriate dataset class specification.
Since it is possible for an unprivileged user to run an active client for himself, a per user capability dataset is useful.
Clients can check the applicable quota limit and usage (in bytes) with the GETQUOTA command.
Servers can notify the client of a low quota situation with the QUOTA untagged response.
Command and Response Specifications ACAP commands and responses are described in this section.
Commands are organized first by the state in which the command is permitted, then by a general category of command type.
Command arguments, identified by "Arguments:" in the command descriptions below, are described by function, not by syntax.
The precise syntax of command arguments is described in the Formal Syntax section.
Some commands cause specific server data to be returned; these are identified by "Data:" in the command descriptions below.
See the response descriptions in the Responses section for information on these responses, and the Formal Syntax section for the precise syntax of these responses.
It is possible for server data to be transmitted as a result of any command; thus, commands that do not specifically require server data specify "no specific data for this command" instead of "none".
The "Result:" in the command description refers to the possible tagged status responses to a command, and any special interpretation of these status responses.
Initial Connection Upon session startup
, the server sends one of two untagged responses: ACAP or BYE.
The untagged BYE response is described in section 6.2.8.
The untagged ACAP response indicates the session is ready to accept commands and contains a space separated listing of capabilities that the server supports.
Each capability is represented by a list containing the capability name optionally followed by capability specific string arguments.
ACAP capability names MUST be registered with IANA according to the rules in section 7.1.
Client implementations SHOULD NOT require any capability name beyond those defined in this specification, and MUST tolerate any unknown capability names.
A client implementation MAY be configurable to require SASL mechanisms other than CRAM MD5 [CRAM MD5] for site security policy reasons.
The following initial capabilities are defined: CONTEXTLIMIT The CONTEXTLIMIT capability has one argument which is a number describing the maximum number of contexts the server supports per connection.
The number 0 indicates the server has no limit, otherwise this number MUST be greater than 100.
The IMPLEMENTATION capability has one argument which is a string describing the server implementation.
ACAP clients MUST NOT alter their behavior based on this value.
It is intended primarily for debugging purposes.
The SASL capability includes a list of the authentication mechanisms supported by the server.
Any State The following commands and responses are valid in any state.
OK noop completed BAD command unknown or arguments invalid
The NOOP command always succeeds.
It can be used to reset any inactivity auto logout timer on the server.
LANG Command Arguments:  list of language preferences Data:
OK lang completed NO no matching language available BAD command unknown or arguments
invalid One or more arguments are supplied to indicate the client's preferred languages [LANG TAGS] for error messages.
The server will match each client preference in order against its internal table of available error string languages.
If a match is found, the server returns an intermediate LANG response and an OK response.
The LANG response indicates the actual language selected and appropriate comparators for use with the languages listed in the LANG command.
If no LANG command is issued, all error text strings MUST be in the registered language
"i default" [CHARSET LANG POLICY], intended for an international audience.
C: A003 LANG "fr ca"
"fr" "en ca" "en uk"
S: A003 LANG "fr ca"
i;ascii numeric" "i;ascii casemap" "en;primary" "fr;primary" S: A003 OK "Bonjour" 6.2.3.
The LANG response indicates the language which will be used for error responses and the comparators which are appropriate for the languages listed in the LANG command.
The comparators SHOULD be in approximate order from most efficient (usually "i;octet") to most appropriate for human text in the preferred language.
OK logout completed BAD command unknown or arguments invalid
The LOGOUT command informs the server that the client is done with the session.
The server must send a BYE untagged response before the (tagged)
OK response, and then close the network connection.
BYE "ACAP Server logging out" S: A023 OK "LOGOUT completed" (Server and client then close the connection)
optional response code human readable text
The OK response indicates an information message from the server.
When tagged, it indicates successful completion of the associated command.
The human readable text may be presented to the user as an information message.
The untagged form indicates an information only message; the nature of the information MAY be indicated by a response code.
OK "Master ACAP server is back up" 6.2.6.
The NO response indicates an operational error message from the server.
When tagged, it indicates unsuccessful completion of the associated command.
The untagged form indicates a warning; the command may still complete successfully.
The human readable text describes the condition.
A010 SEARCH "/addressbook/" DEPTH 3 RETURN
"Master ACAP server is down, your data may be out of date.
A222 STORE ("/folder/site/comp.mail.misc" "folder.creation time" "19951206103412")
The BAD response indicates an error message from the server.
When tagged, it reports a protocol level error in the client's command; the tag indicates the command that caused the error.
The untagged form indicates a protocol level error for which the associated command can not be determined; it may also indicate an internal server failure.
The human readable text describes the condition.
S:   BAD "Empty command line" C:
A443 BAD "Unknown command" C: A444 NOOP Hello S:
A444 BAD "invalid arguments" 6.2.8.
The untagged BYE response indicates that the server is about to close the connection.
The human readable text may be displayed to the user in a status report by the client.
The BYE response may be sent as part of a normal logout sequence, or as a panic shutdown announcement by the server.
It is also used by some server implementations as an announcement of an inactivity auto  logout.
This response is also used as one of two possible greetings at session startup.
It indicates that the server is not willing to accept a session from this client.
The human readable text contains a special human generated alert message that MUST be presented to the user in a fashion that calls the user's attention to the message.
This is intended to be used for vital messages from the server administrator to the user, such as a warning that the server will soon be shut down for maintenance.
This ACAP server will be shut down in 10 minutes for system maintenance."
In non authenticated state, the AUTHENTICATE command establishes authentication and enters authenticated state.
The AUTHENTICATE command provides a general mechanism for a variety of authentication techniques.
Server implementations may allow non authenticated access to certain information by supporting the SASL ANONYMOUS [SASL ANON] mechanism.
Once authenticated (including as anonymous), it is not possible to re enter non authenticated state.
Only the any state commands (NOOP, LANG and LOGOUT) and the AUTHENTICATE command are valid in non authenticated state.
SASL mechanism name optional initial response Data
If the server supports the requested authentication mechanism, it performs an authentication protocol exchange to authenticate and identify the user.
Optionally, it also negotiates a security layer for subsequent protocol interactions.
If the requested authentication mechanism is not supported, the server rejects the AUTHENTICATE command by sending a tagged NO response.
The authentication protocol exchange consists of a series of server challenges and client answers that are specific to the authentication mechanism.
The client answer consists of a line consisting of a string.
If the server receives such an answer, it must reject the AUTHENTICATE command by sending a tagged BAD response.
The optional initial response argument to the AUTHENTICATE command is used to save a round trip when using authentication mechanisms that are defined to send no data in the initial challenge.
When the initial response argument is used with such a mechanism, the initial empty challenge is not sent to the client and the server uses the data in the initial response argument as if it were sent in response to the empty challenge.
If the initial response argument to the AUTHENTICATE command is used with a mechanism that sends data in the initial challenge, the server rejects the AUTHENTICATE command by sending a tagged NO response.
The service name specified by this protocol's profile of SASL is "acap".
If a security layer is negotiated through the SASL authentication exchange, it takes effect immediately following the CRLF that concludes the authentication exchange for the client, and the CRLF of the tagged OK response for the server.
All ACAP implementations MUST implement the CRAM MD5 SASL mechanism [CRAM MD5], although they MAY offer a configuration option to disable it if site security policy dictates.
The example below is the same example described in the CRAM MD5 specification.
If an AUTHENTICATE command fails with a NO response, the client may try another authentication mechanism by issuing another AUTHENTICATE command.
In other words, the client may request authentication types in decreasing order of preference.
(SASL "CRAM MD5" "KERBEROS V4")
A001 OK "CRAM MD5 authentication successful
Searching This section describes the SEARCH command, for retrieving data from datasets.
Command Arguments:  dataset or context name optional list of modifiers search criteria Data:
REFER untagged responses: ADDTO, REMOVEFROM, CHANGE
OK search completed NO search failure: can't perform search BAD command unknown or arguments invalid
The SEARCH command identifies a subset of entries in a dataset and returns information on that subset to the client.
Inherited entries and attributes are included in the search unless the NOINHERIT search modifier is included or the user does not have permission to read the attributes in the base dataset.
The first argument to SEARCH identifies what is to be searched.
A successful SEARCH command MAY result in intermediate ENTRY responses and MUST result in a MODTIME intermediate response.
Following that are zero or more modifiers to the search.
Each modifier may be specified at most once.
The defined modifiers are: DEPTH number
The SEARCH command will traverse the dataset tree up to the specified depth.
ENTRY responses will include the full path to the entry.
A value of "0" indicates that the search should traverse the entire tree.
A value of "1" is the default and indicates only the specified dataset should be searched.
If a dataset is traversed which is not located on the current server, then a REFER intermediate response is returned for that subtree and the search continues.
If the SEARCH command would result in more than number entries, the SEARCH fails with a NO completion result with a WAYTOOMANY response code.
LIMIT number number Limits the number of intermediate ENTRY responses that the search may generate.
The first numeric argument specifies the limit, the second number specifies the number of entries to return if the number of matches exceeds the limit.
If the limit is exceeded, the SEARCH command still succeeds, returning the total number of matches in a TOOMANY response code in the tagged OK response.
[NOTIFY] context Causes the SEARCH command to create a context with the name given in the argument to refer to the matching entries.
If the SEARCH is successful, the context name may then be given as an argument to subsequent SEARCH commands to search the set of matching entries.
If a context with the specified name already exists, it is first freed.
If a new context may not be created due to the server's limit on the number of existing contexts, the command fails, returning a TRYFREECONTEXT response code in the NO completion response.
The optional "ENUMERATE" and "NOTIFY" arguments may be included to request enumeration of the context (for virtual scroll bars) or change notifications for the context.
If "NOTIFY" is not requested, the context represents a snapshot of the entries at the time the SEARCH was issued.
ENUMERATE requests that the contents of the context be ordered according to the SORT modifier and that sequential numbers, starting with one, be assigned to the entries in the context.
This permits the RANGE modifier to be used to fetch portions of the ordered context.
NOTIFY requests that the server send untagged ADDTO, REMOVEFROM, CHANGE, and MODTIME responses while the context created by this SEARCH command exists.
The server MAY issue untagged ADDTO, REMOVEFROM, CHANGE and MODTIME notifications for a context at any time between the issuing of the SEARCH command with MAKECONTEXT NOTIFY and the completion of a FREECONTEXT command for the context.
Notifications are only issued for changes which occur after the server receives the SEARCH command which created the context.
After issuing a sequence of ADDTO, REMOVEFROM or CHANGE notifications, the server MUST issue an untagged MODTIME notification indicating that the client has all updates to the entries in the context up to and including the given modtime value.
Servers are permitted a reasonable delay to batch change notifications before sending them to the client.
The position arguments of the ADDTO, REMOVEFROM and CHANGE notifications are 0 if ENUMERATE is not requested.
This causes the SEARCH command to operate without inheritance.
It can be used to tell which values are explicit overrides.
If MAKECONTEXT is also specified, the created context is also not affected by inheritance.
Specifies what is to be returned in intermediate ENTRY responses.
If this modifier is not specified, no intermediate ENTRY responses are returned.
Inside the parentheses is an optional list of attributes, each optionally followed by a parenthesized list of metadata.
If the parenthesized list of metadata is not specified, it defaults to "(value)".
Results matching such an attribute pattern are grouped in parentheses.
Following the last intermediate ENTRY response, the server returns a single intermediate MODTIME response.
The SORT modifier takes as an argument a parenthesized list of one or more attribute/comparator pairs.
Attribute lists the attribute to sort on, comparator specifies the name of the collation rule to apply to the values of the attribute.
Successive attribute/comparator pairs are used to order two entries only when all preceding pairs indicate the two entries collate the same.
If the SORT modifier is used in conjunction with the MAKECONTEXT modifier, the SORT modifier specifies the ordering of entries in the created context.
If no SORT modifier is specified, or none of the attribute/comparator pairs indicates an order for the two entries, the server uses the order of the entries that exists in the context or dataset being searched.
Following the modifiers is the search criteria.
Searching criteria consist of one or more search keys.
Search keys may be combined using the AND, and OR search keys.
For example, the criteria (the newline is for readability and not part of the criteria): AND COMPARE "modtime"
" i;octet" "19951206103400" COMPARE "modtime"
" i;octet" "19960112000000" refers to all entries modified between 10:34 December 6 1995 and midnight January 12, 1996 UTC.
The currently defined search keys are as follows.
AND search key1 search key2 Entries that match both search keys.
COMPARE attribute comparator value Entries for which the value of the specified attribute collates using the specified comparator the same or later than the specified value.
COMPARESTRICT attribute comparator value Entries for which the specified attribute collates using the specified comparator later than the specified value.
EQUAL attribute comparator value Entries for which the value of the attribute is equal to the specified value using the specified comparator.
NOT search key Entries that do not match the specified search key.
OR search key1 search key2 Entries that match either search key.
PREFIX attribute comparator value Entries which begin with the specified value using the specified comparator.
If the specified comparator doesn't support substring matching, a BAD response is returned.
RANGE start end time Entries which are within the specified range of the enumerated context's ordering.
The lowest ordered entry in the context is assigned number one, the next lowest entry is assigned number two, and so on.
The numeric arguments specify the lowest and highest numbers to match.
The time specifies that the client has processed notifications for the context up to the specified time.
If the context has been modified since then, the server MUST either return a NO with a MODIFIED response code, or return the results that the SEARCH would have returned if none of the changes since that time had been made.
RANGE is only permitted on enumerated contexts.
If RANGE is used with a dataset or non enumerated context, the server MUST return a BAD response.
SUBSTRING attribute comparator value Entries which contain the specified value, using the specified comparator.
If the specified comparator doesn't support substring matching, a BAD response is returned.
The ENTRY intermediate response occurs as a result of a SEARCH or STORE command.
This is the means by which dataset entries are returned to the client.
The ENTRY response begins with the entry name, if a SEARCH command without the DEPTH modifier was issued, or the entry path in other cases.
This is followed by a set of zero or more items, one for each metadata item in the RETURN search modifier.
Results matching an attribute pattern or returning multiple metadata items are grouped in parentheses.
The MODTIME intermediate response occurs as a result of a SEARCH command.
It indicates that the just created context or the previously returned ENTRY responses include all updates to the returned entries up to and including the modtime value in the argument.
The REFER intermediate response occurs as a result of a multi level SEARCH where one of the levels is located on a different server.
The response indicates the dataset which is not located on the current server and one or more relative ACAP URLs for where that dataset may be found.
Here are some SEARCH command exchanges between the client and server
A046 SEARCH "/addressbook/" DEPTH 3 RETURN ("addressbook.
List") OR NOT EQUAL "addressbook.
Email" "i;octet" NIL NOT EQUAL "addressbook.
/user/joe/A0345" "fred" "fred@stone.org" NIL S: A046 ENTRY "/addressbook
"joe@stone.org" NIL S: A046 ENTRY "/addressbook
/group/Dinosaur Operators/A423" "saurians" NIL "1" S:
A046 OK "SEARCH completed" C: A047 SEARCH "/addressbook
" S: A047 OK "SEARCH completed" C:
A048 SEARCH "/options/~/vendor.example/" RETURN ("option.value"("size" "value" "myrights"))
A048 ENTRY "blurdybloop" (5 "ghoti" "rwia")
A048 ENTRY "buckybits" (2 "10" "rwia")
A048 ENTRY "windowSize" (7 "100x100" "rwia")
A048 OK "SEARCH completed" C: A049 SEARCH "/addressbook/~/public" RETURN ("addressbook.
MAKECONTEXT ENUMERATE "blob" LIMIT 100 1 SORT ("addressbook.
A049 ENTRY "A437" "aaguy" "aaguy@stone.org
"19970728105308" S: A049 OK (TOOMANY 347)
"Context 'blob' created" C: A050 SEARCH "blob"
" ALL S: A050 ENTRY "A238" "abguy" "
" S: A050 MODTIME "
A050 OK "SEARCH Completed" 6.5.
The following commands use contexts created by a SEARCH command with a MAKECONTEXT modifier.
no such context BAD command unknown or arguments invalid
The FREECONTEXT command causes the server to free all state associated with the named context.
The context may no longer be searched and the server will no longer issue any untagged responses for the context.
The context is no longer counted against the server's limit on the number of contexts.
A683 FREECONTEXT "blurdybloop" S: A683
Command Arguments:  list of context names Data:
ADDTO REMOVEFROM CHANGE MODTIME Result:
OK Updatecontext completed: all updates completed NO Updatecontext failed: no such context not a notify context BAD command unknown or arguments
The UPDATECONTEXT command causes the server to ensure that the client is notified of all changes known to the server for the contexts listed as arguments up to the current time.
The contexts listed in the arguments must have been previously given to a successful SEARCH command with a MAKECONTEXT NOTIFY modifier.
A MODTIME untagged response MUST be returned if any read write metadata in the context changed since the last MODTIME for that context.
This includes metadata which is not listed in the RETURN modifier for the context.
While a server may issue untagged ADDTO, REMOVEFROM, CHANGE, and MODTIME at any time, the UPDATECONTEXT command is used to "prod" the server to send any notifications it has not sent yet.
The UPDATECONTEXT command SHOULD NOT be used to poll for updates.
Z4S9 UPDATECONTEXT "blurdybloop" "blarfl" S:
Z4S9 OK "client has been notified of all changes" 6.5.3.
The untagged ADDTO response informs the client that an entry has been added to a context.
The response includes the position number of the added entry (the first entry in the context is numbered 1) and those metadata contained in the entry which match the RETURN statement when the context was created.
For enumerated contexts, the ADDTO response implicitly adds one to the position of all members of the context which had position numbers that were greater than or equal to the ADDTO position number.
For non enumerated contexts, the position field is always 0.
The untagged REMOVEFROM response informs the client that an entry has been removed from a context.
The response includes the position number that the removed entry used to have (the first entry in the context is numbered 1).
For enumerated contexts, the REMOVEFROM response implicitly subtracts one from the position numbers of all members of the context which had position numbers greater than the REMOVEFROM position number.
For non enumerated contexts, the position field is always 0.
REMOVEFROM "blurdybloop" "fred" 15 6.5.5.
The untagged CHANGE response informs the client that an entry in a context has either changed position in the context or has changed the values of one or more of the attributes specified in the RETURN modifier when the context was created.
The response includes the previous and current position numbers of the entry (which are 0 if ENUMERATE was not specified on the context) and the attribute metadata requested in the RETURN modifier when the context was created.
For enumerated contexts, the CHANGE response implicitly changes the position numbers of all entries which had position numbers between the old and new position.
If old position is less than new position, than one is subtracted from all entries which had position numbers in that range.
Otherwise one is added to all entries which had position numbers in that range.
If the old position and new position are the same, then no implicit position renumbering occurs.
CHANGE responses are not issued for entries which have changed position implicitly due to another ADDTO, REMOVEFROM or CHANGE response.
CHANGE "blurdybloop" "fred" 15 10 ("addressbook.
The untagged MODTIME response informs the client that it has received all updates to entries in the context which have modtime values less than or equal to the modtime value in the argument.
The following commands and responses handle modification of datasets.
OK store completed NO store failure: can't store that name UNCHANGEDSINCE specified and entry changed BAD command unknown or arguments
invalid invalid UTF 8 syntax in attribute name Creates, modifies, or deletes the named entries in the named datasets.
The values of metadata not specified in the command are not changed.
Setting the "value" metadata of an attribute to NIL removes that attribute from the entry.
Setting the "value" of the "entry" attribute to NIL removes that entry from the dataset and cancels inheritance for the entire entry.
Setting the "value" of the "entry" attribute to DEFAULT removes that entry from the inheriting dataset and reverts the entry and its attributes to inherited values, if any.
Changing the value of the "entry" attribute renames the entry.
Storing DEFAULT to the "value" metadata of an attribute is equivalent to storing NIL, except that inheritance is enabled for that attribute.
If a non NIL value is inherited then an ENTRY intermediate response is generated to notify the client of the this change.
The ENTRY response includes the entry path and the attribute name and value metadata for each attribute which reverted to a non NIL inherited setting.
Storing NIL to the "value" metadata of an attribute MAY be treated equivalent to storing DEFAULT to that "value" if there is a NIL value in the base dataset.
The STORE command is followed by one or more entry store lists.
Each entry store list begins with an entry path followed by STORE modifiers, followed by zero or more attribute store items.
Each attribute store item is made up of the attribute name followed by NIL (to remove the attribute's value), DEFAULT (to revert the item to any inherited value), a single value (to set the attribute's single value), or a list of metadata items to modify.
The following STORE modifiers may be specified: NOCREATE
By default, the server MUST create any datasets necessary to store the entry, including multiple hierarchy levels.
If NOCREATE is specified, the STORE command will fail with a NOEXIST error unless the parent dataset already exists.
If the "modtime" of the entry is later than the unchangedsince time, then the store fails with a MODIFIED response code.
Use of UNCHANGEDSINCE with a time of "00000101000000" will always fail if the entry exists.
Clients writing to a shared dataset are encouraged to use UNCHANGEDSINCE when modifying an existing entry.
The server MUST either make all the changes specified in a single STORE command or make none of them.
If successful, the server MUST update the "modtime" attribute for every entry which was changed.
It is illegal to list any metadata item within an attribute twice, any attribute within an entry twice or any entry path twice.
The server MUST return a BAD response if this happens.
order the strings in a multi value on STORE and MAY remove duplicate strings.
However, SEARCH MUST return multi  values and the associated size list metadata in a consistant order.
A342 OK "Store completed" C: A343 STORE ("/addressbook/user/joe/ABD42" UNCHANGEDSINCE "19970320162338" "user.joe.hair length" "10 inches")
A343 NO (MODIFIED) "'ABD42' has been changed by somebody else.
A344 STORE ("/addressbook/group/Developers/ACD54" "entry" NIL
) S: A344 OK "Store completed" C: A345 STORE ("/option/~/common/SMTPserver" "option.value
" DEFAULT) S: A345 ENTRY "/option/~/common/SMTPserver" "option.value" "smtp.server.do.main
A347 OK "Store completed" 6.6.2.
DELETEDSINCE Command Arguments:  dataset name time
OK DELETEDSINCE completed NO DELETEDSINCE failure:
can't read dataset date too far in the past BAD command unknown or arguments invalid
The DELETEDSINCE command returns in intermediate DELETED replies the names of entries that have been deleted from the named dataset since the given time.
Servers may impose a limit on the number or age of deleted entry names they keep track of.
If the server does not have information going back to the specified time, the command fails, returning a TOOOLD response code in the tagged NO response.
" 19951205103412 S: Z4S9 DELETED "blurdybloop" S: Z4S9 DELETED "anteaters" S: Z4S9 OK "DELETEDSINCE completed" C: Z4U3 DELETEDSINCE "/folder/site/
The intermediate DELETED response occurs as a result of a DELETEDSINCE command.
It returns an entry that has been deleted from the dataset specified in the DELETEDSINCE command.
The commands in this section are used to manage access control lists.
can't set acl BAD command unknown or arguments
The SETACL command changes the access control list on the specified object so that the specified identifier is granted the permissions enumerated in rights.
If the object did not previously have an access control list, one is created.
acl object optional authentication identifier Data:
no specific data for this command Result:
OK deleteacl completed NO deleteacl failure: can't delete acl BAD command unknown or arguments invalid
If given the optional identifier argument, the DELETEACL command removes any portion of the access control list on the specified object for the specified identifier.
If not given the optional identifier argument, the DELETEACL command removes the ACL from the object entirely, causing access to be controlled by a higher level default ACL.
This form of the DELETEACL command is not permitted on the default ACL for a dataset and servers
"Deleteacl complete" C: A224 DELETEACL ("/folder/site")
A224 BAD "Can't delete ACL from dataset
" C: A225 DELETEACL ("/addressbook
OK myrights completed NO myrights failure: can't get rights BAD command unknown or arguments invalid
The MYRIGHTS command returns the set of rights that the client has to the given dataset or dataset attribute.
" S: A003 OK "Myrights complete"
The MYRIGHTS response occurs as a result of a MYRIGHTS command.
The argument is the set of rights that the client has for the object referred to in the MYRIGHTS command.
LISTRIGHTS Command Arguments:  acl object authentication identifier Data:
OK listrights completed NO listrights failure: can't get rights list BAD command unknown or arguments
The LISTRIGHTS command takes an object and an identifier and returns information about what rights the current user may revoke or grant to that identifier in the ACL for that object.
"smith" S: a001 LISTRIGHTS "xra"
"w" "i" S: a001 OK Listrights completed C:
x" "r" "w" "i" S:
The first argument is a string containing the (possibly empty) set of rights the identifier will always be granted on the dataset or attribute.
Following this are zero or more strings each containing a single right which the current user may revoke or grant to the identifier in the dataset or attribute.
The same right MUST NOT be listed more than once in the LISTRIGHTS response.
The section defines the commands and responses relating to quotas.
OK Quota information returned NO Quota failure:
no resource limit BAD command unknown or arguments
The GETQUOTA command takes the name of a dataset, and returns in an untagged QUOTA response the name of the dataset, quota limit in bytes that applies to that dataset and the quota usage within that limit.
The scope of a quota limit is implementation dependent.
The QUOTA untagged response is generated as a result of a GETQUOTA command or MAY be generated by the server in response to a SEARCH or STORE command to warn about high usage of a quota.
It includes the name of the applicable dataset, the quota limit in bytes, the quota usage and some optional extension data.
Clients MUST tolerate the extension data as its use is reserved for a future extension.
In order to simplify the process of extending the protocol, clients MUST tolerate unknown server responses which meet the syntax of response extend.
In addition, clients MUST tolerate unknown server response codes which meet the syntax of resp code ext.
Availability of new commands MUST be announced via a capability on the initial greeting line and such commands SHOULD meet the syntax of command extend.
Servers MUST respond to unknown commands with a BAD command completion result.
Servers MUST skip over non synchronizing literals contained in an unknown command.
This may be done by assuming the unknown command matches the command extend syntax, or by reading a line at a time and checking for the non synchronizing literal syntax at the end of the line.
Registration Procedures ACAP's usefulness comes from providing a structured storage model for all sorts of configuration data.
However, for its potential to be achieved, it is important that the Internet community strives for the following goals: (1) Standardization.
It is very important to standardize dataset classes.
The authors hope that ACAP achieves the success that SNMP has seen with the definition of numerous standards track MIBs.
In the absence of standardization, it is important to get community review on a proposal to improve its engineering quality.
Community review is strongly recommended prior to registration.
The ACAP implementors mailing list <ietf acap@andrew.cmu.edu
> should be used for this purpose.
Registration serves a two fold purpose.
First it prevents use of the same name for different purposes, and second it provides a one stop list which can be used to locate existing extensions or dataset classes to prevent duplicate work.
The following registration templates may be used to register ACAP protocol elements with the Internet Assigned Numbers Authority (IANA).
ACAP Capabilities New ACAP capabilities MUST be registered prior to use.
Careful consideration should be made before extending the protocol, as it can lead to complexity or interoperability problems.
Review of proposals on the acap implementors mailing list is strongly encouraged prior to registration.
Registration of ACAP capability Capability name:
Capability arguments: Published Specification(s): (Optional, but strongly encouraged) Person and email address to contact for further information: 7.2.
ACAP Response Codes ACAP response codes are registered on a first come, first served basis.
Review of proposals on the acap implementors mailing list is strongly encouraged prior to registration.
Registration of ACAP response code
Arguments (use ABNF to specify syntax):
Purpose: Published Specification(s): (Optional, but strongly encouraged) Person and email address to contact for further information: 7.3.
A dataset class provides a core set of attributes for use in a specified hierarchy.
It may also define rules for the dataset hierarchy underneath that class.
Dataset class specifications must be standards track or IESG approved experimental RFCs.
Registration of ACAP dataset class Dataset class name/attribute prefix:
Purpose: Published Specification(s): (Standards track or IESG approved experimental RFC) Person and email address to contact for further information:
Vendor Subtree Vendors may reserve a portion of the ACAP namespace for private use.
Dataset class names beginning with "vendor.<company/product name>." are reserved for use by that company or product.
In addition, all attribute names beginning with "vendor.<company/product name>." are reserved for use by that company or product once registered.
Registration is on a first come, first served basis.
Whenever possible, private attributes and dataset classes should be avoided in favor of improving interoperable dataset class definitions.
Registration of ACAP vendor subtree Private Prefix: vendor.<company/product name
Person and email address to contact for further information: (company names and addresses should be included when appropriate) 8.
The following syntax specification uses the augmented Backus Naur Form (BNF) notation as specified in [ABNF].
This uses the ABNF core rules as specified in Appendix A of the ABNF specification [ABNF].
Except as noted otherwise, all alphabetic characters are case insensitive.
The use of upper or lower case characters to define token strings is for editorial clarity only.
Implementations MUST accept these strings in a case insensitive fashion.
The "initial greeting" rule below defines the initial ACAP greeting from the server.
The "command" rule below defines the syntax for commands sent by the client.
The "response" rule below defines the syntax for responses sent by the server.
/ %x23 27 / %x2A
7A / %x7C 7E ;; Any CHAR except ATOM SPECIALS ATOM
09 / %x0B 0C / %x0E
21 / %x23 5B / %x5D 7F ;; any TEXT CHAR except QUOTED SPECIALS SAFE UTF8
SAFE CHAR / UTF8 2
"DELETEACL" SP acl delobject [
"LISTRIGHTS" SP acl object command myrights
"SEARCH" SP (dataset / context)
SP search criteria ;; MUST NOT include same search modifier twice command setacl
init cap context / init cap extend
iana token [SP string list] init cap implem
;; (0 < n < 4,294,967,296
/ response entry / response extend / response listr / response lang / response mtimei / response mtimeu /
response myright / response quota / response refer / response remove / response stat response addto
" " SP "ADDTO" SP context SP entry name
SP return data list response alert
" " SP "ALERT" SP resp body CRLF
"ENTRY" SP entry SP return data list response extend
" " SP "MODTIME" SP context
SP dataset 1 (SP <">
" SP "REMOVEFROM" SP context SP entry name
resp code mod / resp code noexist /
"QUOTA" / resp code refer /
"MODIFIED" SP entry path resp
metadata / return metalist / return attr list return data list
(SP return data) return metalist
"EQUAL" SP attribute SP comparator
SP value nil searchkey comp
" SP attribute SP comparator SP value searchkey prefix
SP comparator SP value searchkey range
SP attribute SP comparator SP value searchmod depth
searchmod make / searchmod ninh / searchmod return /
1 url char) url filter
] hostport ;; See RFC 1738 for definition of "hostport" 9.
The IAB charset workshop [IAB CHARSET] came to a number of conclusions which influenced the design of ACAP.
The decision to use UTF 8 as the character encoding scheme was based on that work.
The LANG command to negotiate a language for error messages is also included.
Section 3.4.5 of the IAB charset workshop report states that there should be a way to identify the natural language for human readable strings.
Several promising proposals have been made for use within ACAP, but no clear consensus on a single method is apparent at this stage.
The following rules are likely to permit the addition of multi lingual support in the future: (1)
A work in progress called Multi Lingual String Format (MLSF) proposes a layer on top of UTF 8 which uses otherwise illegal UTF 8 sequences to store language tags.
In order to permit its addition to a future version of this standard, client side UTF 8 interpreters MUST be able to silently ignore
illegal multi byte UTF 8 characters, and treat illegal single byte UTF 8 characters as end of string markers.
Servers, for the time being, MUST be able to silently accept illegal UTF 8 characters, except in attribute names and entry names.
Clients MUST NOT send illegal UTF 8 characters to the server unless a future standard changes this rule.
(2) There is a proposal to add language tags to Unicode.
To support this, servers MUST be able to store UTF 8 characters of up to 20 bits of data.
The metadata item "language" is reserved for future use.
The AUTHENTICATE command uses SASL [SASL] to provide basic authentication, authorization, integrity and privacy services.
This is described in section 6.3.1.
When the CRAM MD5 mechanism is used, the security considerations for the CRAM MD5 SASL mechanism [CRAM MD5] apply.
The CRAM MD5 mechanism is also susceptible to passive dictionary attacks.
This means that if an authentication session is recorded by a passive observer, that observer can try common passwords through the CRAM MD5 mechanism and see if the results match.
This attack is reduced by using hard to guess passwords.
Sites are encouraged to educate users and have the password change service test candidate passwords against a dictionary.
ACAP implementations of CRAM MD5 SHOULD permit passwords of at least 64 characters in length.
ACAP protocol transactions are susceptible to passive observers or man in the middle attacks which alter the data, unless the optional encryption and integrity services of the AUTHENTICATE command are enabled, or an external security mechanism is used for protection.
It may be useful to allow configuration of both clients and servers to refuse to transfer sensitive information in the absence of strong encryption.
ACAP access control lists provide fine grained authorization for access to attributes.
A number of related security issues are described in section 3.5.
ACAP URLs have the same security considerations as IMAP URLs [IMAP URL].
ACAP clients are encouraged to consider the security problems involved with a lab computer situation.
Specifically, a client cache of ACAP configuration information MUST NOT allow access by an unauthorized user.
One way to assure this is for an ACAP client to be able to completely flush any non public cached configuration data when a user leaves.
As laptop computers can be easily stolen and a cache of configuration data may contain sensitive information, a disconnected mode ACAP client may wish to encrypt and password protect cached configuration information.
