- title: __initial_text__
  contents:
  - "       Guidelines for the Use of Extensible Markup Language (XML)\n         \
    \                within IETF Protocols\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet Best Current Practices\
    \ for the\n   Internet Community, and requests discussion and suggestions for\n\
    \   improvements.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   The Extensible Markup Language (XML) is a framework for structuring\n\
    \   data.  While it evolved from Standard Generalized Markup Language\n   (SGML)\
    \ -- a markup language primarily focused on structuring\n   documents -- XML has\
    \ evolved to be a widely-used mechanism for\n   representing structured data.\n\
    \   There are a wide variety of Internet protocols being developed; many\n   have\
    \ need for a representation for structured data relevant to their\n   application.\
    \  There has been much interest in the use of XML as a\n   representation method.\
    \  This document describes basic XML concepts,\n   analyzes various alternatives\
    \ in the use of XML, and provides\n   guidelines for the use of XML within IETF\
    \ standards-track protocols.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   Conventions Used In This Document  . . . . . . . . . .\
    \ . . . . . .  2\n   1.    Introduction and Overview  . . . . . . . . . . . .\
    \ . . . . .  2\n         1.1   Intended Audience. . . . . . . . . . . . . . .\
    \ . . . .  3\n         1.2   Scope  . . . . . . . . . . . . . . . . . . . . .\
    \ . . .  3\n         1.3   XML Evolution  . . . . . . . . . . . . . . . . . .\
    \ . .  3\n         1.4   XML Users, Support Groups, and Additional\n         \
    \      Information. . . . . . . . . . . . . . . . . . . . . .  4\n   2.    XML\
    \ Selection Considerations . . . . . . . . . . . . . . . .  4\n   3.    XML Alternatives\
    \ . . . . . . . . . . . . . . . . . . . . . .  5\n   4.    XML Use Considerations\
    \ and Recommendations . . . . . . . . .  7\n         4.1   XML Syntax and Well-Formedness\
    \ . . . . . . . . . . . .  7\n         4.2   XML Information Set  . . . . . .\
    \ . . . . . . . . . . .  7\n         4.3   Syntactic Restrictions . . . . . .\
    \ . . . . . . . . . .  8\n         4.4   XML Declarations . . . . . . . . . .\
    \ . . . . . . . . .  9\n         4.5   XML Processing Instructions  . . . . .\
    \ . . . . . . . .  9\n         4.6   XML Comments . . . . . . . . . . . . . .\
    \ . . . . . . . 10\n         4.7   Validity and Extensibility . . . . . . . .\
    \ . . . . . . 10\n         4.8   Semantics as Well as Syntax. . . . . . . . .\
    \ . . . . . 12\n         4.9   Namespaces . . . . . . . . . . . . . . . . . .\
    \ . . . . 12\n               4.9.1 Namespaces and Attributes. . . . . . . . .\
    \ . . . 13\n         4.10  Element and Attribute Design Considerations. . . .\
    \ . . 14\n         4.11  Binary Data and Text with Control Characters . . . .\
    \ . 16\n         4.12  Incremental Processing . . . . . . . . . . . . . . . .\
    \ 16\n         4.13  Entity Declarations and Entity References  . . . . . . 16\n\
    \         4.14  External References  . . . . . . . . . . . . . . . . . 17\n  \
    \       4.15  URI Processing . . . . . . . . . . . . . . . . . . . . 17\n    \
    \     4.16  White Space  . . . . . . . . . . . . . . . . . . . . . 18\n      \
    \   4.17  Interaction with the IANA  . . . . . . . . . . . . . . 19\n   5.   \
    \ Internationalization Considerations  . . . . . . . . . . . . 19\n         5.1\
    \   Character Sets and Encodings . . . . . . . . . . . . . 19\n         5.2  \
    \ Language Declaration . . . . . . . . . . . . . . . . . 20\n         5.3   Other\
    \ Internationalization Considerations  . . . . . . 20\n   6.    IANA Considerations\
    \  . . . . . . . . . . . . . . . . . . . . 21\n   7.    Security Considerations\
    \  . . . . . . . . . . . . . . . . . . 21\n   8.    Acknowledgements . . . . .\
    \ . . . . . . . . . . . . . . . . . 22\n   9.    Normative References . . . .\
    \ . . . . . . . . . . . . . . . . 22\n   10.   Informative References . . . .\
    \ . . . . . . . . . . . . . . . 23\n   11.   Authors' Addresses . . . . . . .\
    \ . . . . . . . . . . . . . . 27\n   12.   Full Copyright Statement . . . . .\
    \ . . . . . . . . . . . . . 28\n"
- title: Conventions Used In This Document
  contents:
  - "Conventions Used In This Document\n   This document recommends, as policy, what\
    \ specifications for Internet\n   protocols -- and, in particular, IETF standards\
    \ track protocol\n   documents -- should include as normative language within\
    \ them.  The\n   capitalized keywords \"SHOULD\", \"MUST\", \"REQUIRED\", etc.\
    \ are used in\n   the sense of how they would be used within other documents with\
    \ the\n   meanings as specified in BCP 14, RFC 2119 [1].\n"
- title: 1. Introduction and Overview
  contents:
  - "1. Introduction and Overview\n   The Extensible Markup Language (XML, [8]) is\
    \ a framework for\n   structuring data.  While it evolved from the Standard Generalized\n\
    \   Markup Language (SGML, [30]) -- a markup language primarily focused\n   on\
    \ structuring documents -- XML has evolved to be a widely-used\n   mechanism for\
    \ representing structured data in protocol exchanges.\n   See \"XML in 10 points\"\
    \ [47] for an introduction to XML.\n"
- title: 1.1 Intended Audience
  contents:
  - "1.1 Intended Audience\n   Many Internet protocol designers are considering using\
    \ XML and XML\n   fragments within the context of existing and new Internet protocols.\n\
    \   This document is intended as a guide to XML usage and as IETF policy\n   for\
    \ standards track documents.  Experienced XML practitioners will\n   likely already\
    \ be familiar with the background material here, but the\n   guidelines are intended\
    \ to be appropriate for those readers as well.\n"
- title: 1.2 Scope
  contents:
  - "1.2 Scope\n   This document is intended to give guidelines for the use of XML\n\
    \   content within a larger protocol.  The goal is not to suggest that\n   XML\
    \ is the \"best\" or \"preferred\" way to represent data; rather, the\n   goal\
    \ is to lay out the context for the use of XML within a protocol\n   once other\
    \ factors point to XML as a possible data representation\n   solution.  The Common\
    \ Name Resolution Protocol (CNRP, [24]) is an\n   example of a protocol that would\
    \ be addressed by these guidelines if\n   it were being newly defined.  This document\
    \ does not address the use\n   of protocols like SMTP or HTTP to send XML documents\
    \ as ordinary\n   email or web content.\n   There are a number of protocol frameworks\
    \ already in use or under\n   development which focus entirely on \"XML protocol\"\
    \ -- the exclusive\n   use of XML as the data representation in the protocol.\
    \  For example,\n   the World Wide Web Consortium (W3C) is developing an XML Protocol\n\
    \   framework based on SOAP ([45] and [46]).  The applicability of such\n   protocols\
    \ is not part of the scope of this document.\n   In addition, there are higher-level\
    \ representation frameworks, based\n   on XML, that have been designed as carriers\
    \ of certain classes of\n   information; for example, the Resource Description\
    \ Framework (RDF,\n   [38]) is an XML-based representation for logical assertions.\
    \  This\n   document does not provide guidelines for the use of such frameworks.\n"
- title: 1.3 XML Evolution
  contents:
  - "1.3 XML Evolution\n   XML 1.0 was originally published as a W3C recommendation\
    \ in February\n   1998 [35], and was revised in a 2nd edition [8] in October 2000.\n\
    \   Several additional facilities have also been defined that layer on\n   the\
    \ base specification.  Although these additions are designed to be\n   consistent\
    \ with XML 1.0, they have varying levels of stability,\n   consensus, and implementation.\
    \  Accordingly, this document identifies\n   the major evolutionary features of\
    \ XML and makes suggestions as to\n   the circumstances in which each feature\
    \ should be used.\n"
- title: 1.4 XML Users, Support Groups, and Additional Information
  contents:
  - "1.4 XML Users, Support Groups, and Additional Information\n   There are many\
    \ XML support groups, with some devoted to the entire\n   XML industry [51], some\
    \ devoted to developers [52], some devoted to\n   the business applications of\
    \ XML [53], and many, many groups devoted\n   to the use of XML in a particular\
    \ context.\n   It is beyond the scope of this document to provide a comprehensive\n\
    \   list of referrals.  Interested readers are directed to the three\n   references\
    \ above as starting points, as well as their favorite\n   Internet search engine.\n"
- title: 2. XML Selection Considerations
  contents:
  - "2. XML Selection Considerations\n   XML is a tool that provides a means towards\
    \ an end.  Choosing the\n   right tool for a given task is an essential part of\
    \ ensuring that the\n   task can be completed in a satisfactory manner.  This\
    \ section\n   describes factors to be aware of when considering XML as a tool\
    \ for\n   use in IETF protocols:\n   1.  XML is a meta-markup language that can\
    \ be used to define markup\n       languages for specific domains and problem\
    \ spaces.\n   2.  XML provides both logical structure and physical structure to\n\
    \       describe data.  Data framing is built-in.\n   3.  XML instances can be\
    \ validated against the formal definition of a\n       protocol specification.\n\
    \   4.  XML supports internationalization.\n   5.  XML is extensible.  Unlike\
    \ some other markup languages (such as\n       HTML), new tags (and thus new protocol\
    \ elements) can be defined\n       without requiring changes to XML itself.\n\
    \   6.  XML is still evolving.  The formal specifications are still being\n  \
    \     influenced and updated as use experience is gained and applied.\n   7. \
    \ XML does not provide native mechanisms to support detailed data\n       typing.\
    \  Additional mechanisms  (such as those described in\n       Section 4.7) are\
    \ required to specify abstract protocol data\n       types.\n   8.  XML is text-based,\
    \ so XML fragments are easily created, edited,\n       and managed using common\
    \ utilities.  Further, being text-based\n       means it more readily supports\
    \ incremental development,\n       debugging, and logging.  A simple \"canned\"\
    \ XML fragment can be\n       embedded within a program as a string constant,\
    \ rather than\n       having to be constructed.\n   9.  Binary data has to be\
    \ encoded into a text-based form to be\n       represented in XML.\n   10. XML\
    \ is verbose when compared with many other structured data\n       representation\
    \ languages.  A representation with element\n       extensibility and human readability\
    \ typically requires more bits\n       when compared to one optimized for efficient\
    \ machine processing.\n   11. XML implementations are still relatively new.  As\
    \ designers and\n       implementers gain experience, it is not uncommon to find\
    \ defects\n       in early and current products.\n   12. XML support is available\
    \ in a large number of software\n       development utilities, available in both\
    \ open source and\n       proprietary products.\n   13. XML processing speed can\
    \ be an issue in some environments.  XML\n       processing can be slower because\
    \ XML data streams may be larger\n       than other representations, and the use\
    \ of general purpose XML\n       parsers will add a software layer with its own\
    \ performance costs\n       (though these costs can be reduced through consistent\
    \ use of an\n       optimized parser).  In some situations, processing XML requires\n\
    \       examining every byte of the entire XML data stream, with higher\n    \
    \   overhead than with representations where uninteresting segments\n       can\
    \ be skipped.\n"
- title: 3. XML Alternatives
  contents:
  - "3. XML Alternatives\n   This document focuses on guidelines for the use of XML.\
    \  It is useful\n   to consider why one might use XML as opposed to some other\
    \ mechanism.\n   This section considers some other commonly used representation\n\
    \   mechanisms and compares XML to those alternatives.\n   For many fundamental\
    \ protocols, the extensibility requirements are\n   modest, and the performance\
    \ requirements are high enough that fixed\n   binary data blocks are the appropriate\
    \ representation; mechanisms\n   such as XML merely add bloat.  RFC 3252 [23]\
    \ describes a humorous\n   example of XML as protocol bloat.\n   In addition,\
    \ there are other representation and extensibility\n   frameworks that have been\
    \ used successfully within communication\n   protocols.  For example, Abstract\
    \ Syntax Notation 1 (ASN.1) [28]\n   along with the corresponding Basic Encoding\
    \ Rules (BER, [29]) are\n   part of the OSI communication protocol suite, and\
    \ have been used in\n   many subsequent communications standards (e.g., the ANSI\
    \ Information\n   Retrieval protocol [27] and the Simple Network Management Protocol\n\
    \   (SNMP, [13]).  The External Data Representation (XDR, [14]) and\n   variations\
    \ of it have been used in many other distributed network\n   applications (e.g.,\
    \ the Network File System (NFS) protocol [22]).\n   With some ASN.1 encoding types,\
    \ data types are explicit in the\n   representation, while with XDR, the data\
    \ types of components are\n   described externally as part of an interface specification.\n\
    \   Many other protocols use data structures directly (without data\n   encapsulation)\
    \ by describing the data structure with Backus Normal\n   Form (BNF, [25]); many\
    \ IETF protocols use an Augmented Backus-Naur\n   Form (ABNF, [16]).  The Simple\
    \ Mail Transfer Protocol (SMTP, [21]) is\n   an example of a protocol specified\
    \ using ABNF.\n   ASN.1, XDR, and BNF are described here as examples of alternatives\
    \ to\n   XML for use in IETF protocols.  There are other alternatives, but a\n\
    \   complete enumeration of all possible alternatives is beyond the scope\n  \
    \ of this document.\n   Other representation methods may differ from XML in several\
    \ important\n   ways:\n   Text Encoding and character sets: the character encoding\
    \ used to\n   represent a formal specification.  XML defines a consistent character\n\
    \   model based on the Universal Character Set (UCS, [31] and [33]), and\n   requires\
    \ that XML parsers accept at least UTF-8 [4] and UTF-16 [20],\n   and allows for\
    \ other encodings.  While ASN.1 and XDR may carry\n   strings in any encoding,\
    \ there is no common mechanism for defining\n   character encodings within them.\
    \  Typically, ABNF definitions tend to\n   be defined in terms of octets or characters\
    \ in ASCII.\n   Data Encoding: XML is defined as a sequence of characters, rather\n\
    \   than a sequence of bytes.  XML Schema [42] includes mechanisms for\n   representing\
    \ some data types (integer, date, array, etc.) but many\n   binary data types\
    \ are encoded in Base64 [15] or hexadecimal.  ASN.1\n   and XDR have rich mechanisms\
    \ for encoding a wide variety of data\n   types.\n   Extensibility: XML has a\
    \ rich extensibility model such that XML\n   specifications can frequently be\
    \ versioned independently.\n   Specifications can be extended by adding new element\
    \ names and\n   attributes (if done compatibly); other extensions can be added\
    \ by\n   defining new XML namespaces [9], though there is no standard\n   mechanism\
    \ in XML to indicating whether or not new extensions are\n   mandatory to recognize.\
    \  Similarly, there are several techniques\n   available to extend ASN.1 specifications.\
    \  XDR specifications tend to\n   not be independently extensible by different\
    \ parties because the\n   framing and data types are implicit and not self-describing.\
    \  The\n   extensibility of BNF-based protocol elements needs to be explicitly\n\
    \   planned.\n   Legibility of protocol elements: As noted above, XML is text-based,\n\
    \   and thus carries the advantages (and disadvantages) of text-based\n   protocol\
    \ elements.  Typically this is shared with (A)BNF-defined\n   protocol elements.\
    \  ASN.1 and XDR use binary encodings which are not\n   easily human readable.\n"
- title: 4. XML Use Considerations and Recommendations
  contents:
  - "4. XML Use Considerations and Recommendations\n   This section notes several\
    \ aspects of XML and makes recommendations\n   for use.  Since the 1998 publication\
    \ of XML version 1 [35], an\n   editorial second edition [8] was published in\
    \ 2000; this section\n   refers to the second edition.\n"
- title: 4.1 XML Syntax and Well-Formedness
  contents:
  - "4.1 XML Syntax and Well-Formedness\n   XML [8] is defined in terms of a concrete\
    \ syntax: a sequence of\n   characters, using the characters \"<\", \"=\", \"\
    &\", etc. as delimiters.\n   An instance is XML if and only if it is well-formed,\
    \ i.e., all\n   character and markup data conforms to the structural rules defined\
    \ in\n   section 2.1 of [8].\n   Character and markup data that is not well-formed\
    \ is not XML; well-\n   formedness is the basis for syntactic compatibility with\
    \ XML.\n   Without well-formedness, all of the advantages of using XML\n   disappear.\
    \  For this reason, it is recommended that protocol\n   specifications explicitly\
    \ require XML well-formedness (\"MUST be\n   well-formed\").\n   The IETF has\
    \ a long-standing tradition of \"be liberal in what you\n   accept\" that might\
    \ seem to be at odds with this recommendation.\n   Given that XML requires well-formedness,\
    \ conforming XML parsers are\n   intolerant of well-formedness errors.  When specifying\
    \ the handing of\n   erroneous XML protocol elements, a protocol design must never\n\
    \   recommend attempting to partially interpret non-well-formed instances\n  \
    \ of an element which is required to be XML.  Reasonable behaviors in\n   such\
    \ a scenario could include attempting retransmission or aborting\n   an in-progress\
    \ session.\n"
- title: 4.2 XML Information Set
  contents:
  - "4.2 XML Information Set\n   In addition to the concrete syntax of XML, there\
    \ is an abstract model\n   of XML content known as the \"Information Set\" (infoset)\
    \ [37].  One\n   might think of an XML parser as consuming the concrete syntax\
    \ and\n   producing an XML Information Set for further processing.\n   In typical\
    \ use of XML, the definition of allowable XML documents is\n   often defined in\
    \ terms of the Information Set of the XML and not the\n   concrete syntax.  The\
    \ notion is that any syntactic representation\n   which yielded the same information\
    \ set would be treated equivalently.\n   It some cases, protocols have been defined\
    \ solely in terms of the XML\n   Information Set, or by allowing other concrete\
    \ syntax\n   representations.  However, since the context of XML embedded within\n\
    \   other Internet protocols requires an unambiguous definition of the\n   concrete\
    \ syntax, defining an XML protocol element in terms of its XML\n   Information\
    \ Set alone and allowing other concrete syntax\n   representations is out of scope\
    \ for this document.\n"
- title: 4.3 Syntactic Restrictions
  contents:
  - "4.3 Syntactic Restrictions\n   In some circumstances a protocol designer may\
    \ be tempted to define an\n   XML-based protocol element as \"XML\", but at the\
    \ same time imposing\n   additional restrictions beyond those imposed by the XML\n\
    \   recommendation itself -- for example, restricting the document\n   character\
    \ encoding, or avoiding CDATA sections, character entity\n   references, imposing\
    \ additional restrictions on use of white space,\n   etc.  The general category\
    \ of restrictions addressed by this section\n   are ones that would allow some\
    \ but not other of the set of syntactic\n   representations which have the same\
    \ canonical representation\n   according to canonical XML described in RFC 3076\
    \ [6].\n   Making these kinds of restrictions in a protocol definition may have\n\
    \   the disadvantage that an implementer of the protocol may not be able\n   to\
    \ use an otherwise conforming XML processor to parse the XML-based\n   protocol\
    \ elements.  In some cases, the motivation for subsetting XML\n   is to allow\
    \ implementers to build special-purpose processors that are\n   lighter weight\
    \ than a full-scale conforming XML processor.  There are\n   a number of good,\
    \ conforming XML parsers that are small, fast, and\n   free, while special-purpose\
    \ processors have frequently been known to\n   fail to handle some cases of legal\
    \ XML syntax.\n   In general, such syntactic restrictions should be avoided. \
    \ In\n   circumstances where restrictions on the variability of the syntactic\n\
    \   representation of XML is necessary for one reason or another,\n   designers\
    \ should consider using \"Canonical XML\" [6] as the definition\n   of the protocol\
    \ element, since all such variability has been removed.\n   Some specific issues\
    \ are discussed in Section 4.4, Section 4.13, and\n   Section 5.1 below.\n"
- title: 4.4 XML Declarations
  contents:
  - "4.4 XML Declarations\n   An XML declaration (defined in section 2.8 of [8]) is\
    \ a small header\n   at the beginning of an XML data stream that indicates the\
    \ XML version\n   and the character encoding used.  For example,\n   <?xml version=\"\
    1.0\" encoding=\"UTF-8\"?>\n   specifies the use of XML version 1 and UTF-8 character\
    \ encoding.\n   In some uses of XML as an embedded protocol element, the XML used\
    \ is\n   a small fragment in a larger context, where the XML version is fixed\n\
    \   at \"1.0\" and the character encoding is known to be \"UTF-8\".  In those\n\
    \   cases, an XML declaration might add extra overhead.  In cases where\n   the\
    \ XML is a larger component which may find its way alone as an\n   external entity\
    \ body (transported as a MIME message, for example),\n   the XML declaration is\
    \ an important marker and is useful for\n   reliability and extensibility.  The\
    \ XML declaration is also an\n   important marker for character set/encoding (see\
    \ Section 5.1), if any\n   encoding other than UTF-8 or UTF-16 is used.  Note\
    \ that in the case\n   of UTF-16, XML requires that the entity starts with a Byte\
    \ Order Mark\n   (BOM), which is not part of the character data.  Note that the\
    \ XML\n   Declaration itself is not part of the XML document's Information Set.\n\
    \   Protocol specifications must be clear about use of XML declarations.\n   XML\
    \ [8] notes that \"XML documents should begin with an XML\n   declaration which\
    \ specifies the version of XML being used.\"  In\n   general, an XML declaration\
    \ should be encouraged (\"SHOULD be\n   present\") and must always be allowed\
    \ (\"MAY be sent\").  An XML\n   declaration should be required in cases where,\
    \ if allowed, the\n   character encoding is anything other than UTF-8 or UTF-16.\n"
- title: 4.5 XML Processing Instructions
  contents:
  - "4.5 XML Processing Instructions\n   An XML processing instruction (defined in\
    \ section 2.6 of [8]) is a\n   component of an XML document that signals extra\
    \ \"out of band\"\n   information to the receiver; a common use of XML processing\n\
    \   instructions are for document applications.  For example, the XML2RFC\n  \
    \ application used to generate this document and described in RFC 2629\n   [19]\
    \ supports a \"table of contents\" processing instruction:\n   <?rfc toc=\"yes\"\
    ?>\n   As described in section 2.6 of [8], processing instructions are not\n \
    \  part of the document's character data, but must be passed through to\n   the\
    \ application.  As a consequence, it is recommended that processing\n   instructions\
    \ be ignored when encountered in normal protocol\n   processing.  It is thus also\
    \ recommended that processing instructions\n   not be used to define normative\
    \ protocol data structures or\n   extensions for the following reasons:\n   o\
    \  Processing instructions are not namespace aware; there is no way\n      to\
    \ qualify a processing instruction target with a namespace.\n   o  Processing\
    \ instruction use can not be constrained by most schema\n      languages,\n  \
    \ o  Character references are not recognized within a processing\n      instruction.\n\
    \   o  Processing instructions don't have any XML-defined structure\n      beyond\
    \ the division between the target and everything else.  This\n      means that\
    \ applications typically have to parse the content of the\n      processing instruction\
    \ in a system-dependent way; if the content\n      was provided within an element\
    \ instead, the structure could be\n      expressed in the XML and the parsing\
    \ could be done by the XML\n      parser.\n"
- title: 4.6 XML Comments
  contents:
  - "4.6 XML Comments\n   An XML comment (defined in section 2.5 of [8]) is a component\
    \ of an\n   XML document that provides descriptive information that is not part\n\
    \   of the document's character data.  XML comments, like comments used\n   in\
    \ programming languages, are often used to provide explanatory\n   information\
    \ in human-understandable terms.  An example:\n   <!-- This is a example comment.\
    \  -->\n   XML comments can be ignored by conformant processors.  As a\n   consequence,\
    \ it is strongly recommended that comments not be used to\n   define normative\
    \ protocol data structures or extensions.  It is thus\n   also strongly recommended\
    \ that comments be ignored if encountered in\n   normal protocol processing.\n"
- title: 4.7 Validity and Extensibility
  contents:
  - "4.7 Validity and Extensibility\n   One important value of XML is that there are\
    \ formal mechanisms for\n   defining structural and data content constraints;\
    \ these constrain the\n   identity of elements or attributes or the values contained\
    \ within\n   them.  There is more than one such formalism:\n   o  A \"Document\
    \ Type Definition\" (DTD) is defined in section 2.8 of\n      [8]; the concept\
    \ came from a similar mechanism for SGML.  There is\n      significant experience\
    \ with using DTDs, including in IETF\n      protocols.\n   o  XML Schema (defined\
    \ in [41] and [42]) provides additional features\n      to allow a tighter and\
    \ more precise specification of allowable\n      protocol syntax and data type\
    \ specifications.\n   o  There are also a number of other mechanisms for describing\
    \ XML\n      instance validity; these include, for example, Schematron [49] and\n\
    \      RELAX NG [48].  Part 2 of the ISO/IEC Document Schema Definition\n    \
    \  Language (DSDL, [32]) standard is based on RELAX NG.\n   There is ongoing discussion\
    \ (and controversy) within the XML\n   community on the use and applicability\
    \ of various validity constraint\n   mechanisms.  The choice of tool depends on\
    \ the needs for\n   extensibility or for a formal language and mechanism for constraining\n\
    \   permissible values and validating adherence to the constraints.\n   There\
    \ are cases where protocols have defined validity using one or\n   another validity\
    \ mechanism, but the protocol definitions have not\n   insisted that all corresponding\
    \ protocol elements be \"valid\".  The\n   decision depends in part on the design\
    \ for protocol extensibility.\n   Each formalism has different ways of allowing\
    \ for future extensions;\n   in addition, a protocol design may have its own versioning\
    \ mechanism,\n   way of updating the schema, or pointing to a new one.  For example,\n\
    \   the use of XML namespaces (Section 4.9) with XML Schema allows other\n   kinds\
    \ of extensibility without compromising schema validity.\n   No matter what formalism\
    \ is chosen, there are usually additional\n   syntactic constraints, and inevitably\
    \ additional semantic\n   constraints, on the validity of XML elements that cannot\
    \ be expressed\n   in the formalism.\n   This document makes the following recommendations\
    \ for the definition\n   of protocols using XML:\n   o  Protocols should use an\
    \ appropriate formalism for defining\n      validity of XML protocol elements.\n\
    \   o  Protocols may or may not insist that all corresponding protocol\n     \
    \ elements be valid, according to the validity mechanism chosen; in\n      either\
    \ case, the extensibility design should be clear.  What\n      happens if the\
    \ data is not valid?\n   o  As described in Section 3 there is no standard mechanism\
    \ in XML\n      for indicating whether or not new extensions are mandatory to\n\
    \      recognize.  XML-based protocol specifications should thus\n      explicitly\
    \ describe extension mechanisms and requirements to\n      recognize or ignore\
    \ extensions.\n   An idealized model for XML processing might first check for\
    \ well-\n   formedness; if OK, apply the primary formalism and, if the instances\n\
    \   \"passes\", apply the other constraints so that the entire set (or as\n  \
    \ much as is machine processable) can be checked at the same time.\n   However,\
    \ it is reasonable to allow conforming implementations to\n   avoid doing validation\
    \ at run-time and rely instead on ad-hoc code to\n   avoid the higher expense,\
    \ for example, of schema validation,\n   especially given that there will likely\
    \ be additional hand-crafted\n   semantic validation.\n"
- title: 4.8 Semantics as Well as Syntax
  contents:
  - "4.8 Semantics as Well as Syntax\n   While the definition of an XML protocol element\
    \ using a validity\n   formalism is useful, it is not sufficient.  XML by itself\
    \ does not\n   supply semantics.  Any document defining a protocol element with\
    \ XML\n   MUST also have sufficient prose in the document describing the\n   semantics\
    \ of whatever XML the document has elected to define.\n"
- title: 4.9 Namespaces
  contents:
  - "4.9 Namespaces\n   XML namespaces, defined in [9], provide a means of assigning\
    \ markup\n   to a specific vocabulary.  If two elements or attributes from\n \
    \  different vocabularies have the same name, they can be distinguished\n   unambiguously\
    \ if they belong to different namespaces.  Additionally,\n   namespaces provide\
    \ significant support for protocol extensibility as\n   they can be defined, reused,\
    \ and processed dynamically.\n   Markup vocabulary collisions are very possible\
    \ when namespaces are\n   not used to separate and uniquely identify vocabularies.\
    \  Protocol\n   definitions should use existing XML namespaces where appropriate.\n\
    \   When a new namespace is needed, the \"namespace name\" is a URI that is\n\
    \   used to identify the namespace; it's also useful for that URI to\n   point\
    \ to a description of the namespace.  Typically (and recommended\n   practice\
    \ in W3C) is to assign namespace names using persistent http\n   URIs.\n   In\
    \ the case of namespaces in IETF standards-track documents, it would\n   be useful\
    \ if there were some permanent part of the IETF's own web\n   space that could\
    \ be used for this purpose.  In lieu of such, other\n   permanent URIs can be\
    \ used, e.g., URNs in the IETF URN namespace (see\n   [11] and [12]).  Although\
    \ there are instances of IETF specifications\n   creating new URI schemes to define\
    \ XML namespaces, this practice is\n   strongly discouraged.\n"
- title: 4.9.1 Namespaces and Attributes
  contents:
  - "4.9.1 Namespaces and Attributes\n   There is a frequently misunderstood aspect\
    \ of the relationship\n   between unprefixed attributes and the default XML namespace\
    \ - the\n   natural assumption is that an unprefixed attribute is qualified by\n\
    \   the default namespace, but this is not true.  Rather, the unprefixed\n   attribute\
    \ belongs to no namespace at all.  Thus, in the following\n   example:\n   <ns1:fox\
    \ a=\"xxx\" ns1:b=\"qqq\"\n    xmlns=\"http://example.org\"/>\n   <fox a=\"xxx\"\
    \ ns1:b=\"qqq\"\n    xmlns=\"http://example.org\" xmlns:ns1=\"http://example.org\"\
    />\n   the attribute \"a\" is in no namespace, while \"ns1:b\" is the same\n \
    \  namespace as the containing element.  A specific description of the\n   relationship\
    \ between default namespaces and attributes can be found\n   in section 5.2 of\
    \ [9].  The practical implication of the relationship\n   between namespaces and\
    \ attributes is that care must be taken to\n   ensure that no element contains\
    \ multiple attributes that have\n   identical names or have qualified names with\
    \ the same local part and\n   with prefixes which have been bound to namespace\
    \ names that are\n   identical.\n   In XML applications, the choice between prefixed\
    \ and non-prefixed\n   attributes frequently is based on whether they always appear\
    \ inside\n   elements of the same namespace (in which case non-prefixed and\n\
    \   thereby non-namespaced names are used) or whether it's required that\n   they\
    \ can be applied to elements in other arbitrary namespaces (in\n   which case\
    \ a prefixed name is used).  Both situations occur in the\n   XSLT [43] language:\
    \ while attributes are unprefixed when they occur\n   inside elements in the XSLT\
    \ namespace, such as:\n   <xsl:value-of select=\".\"/>\n   they are prefixed when\
    \ they appear in non-XSLT elements, such as the\n   \"xsl:version\" attribute\
    \ when using \"literal result element\n   stylesheets\":\n   <html xsl:version=\"\
    1.0\"\n    xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n    xmlns=\"http://www.w3.org/TR/xhtml1/strict\"\
    >\n     <head>\n       <title>Expense Report Summary</title>\n     </head>\n \
    \    <body>\n       <p>Total: <xsl:value-of select=\"exp-rep/total\"/></p>\n \
    \    </body>\n   </html>\n"
- title: 4.10 Element and Attribute Design Considerations
  contents:
  - "4.10 Element and Attribute Design Considerations\n   XML provides much flexibility\
    \ in allowing a designer to use either\n   elements, attributes, or element content\
    \ to carry data.  This section\n   gives a flavor of the design considerations;\
    \ there is much written\n   about this in the XML literature.  Consistent use\
    \ of elements,\n   attributes, and values is an important characteristic of a\
    \ sound\n   design.\n   Attributes are generally intended to contain meta-data\
    \ that describes\n   the element, and as such they are subject to the following\n\
    \   restrictions:\n   o  Attributes are unordered,\n   o  There can be no more\
    \ than one instance of a given attribute within\n      a given element, though\
    \ an attribute may contain several values\n      separated by white space ([8],\
    \ section 2.3 and 3.3.1),\n   o  Attribute values can have no internal XML markup\
    \ for providing\n      internal structure, and\n   o  Attribute values are normalized\
    \ ([8], section 3.3) before\n      processing\n   Consider the following example\
    \ that describes an IP address using an\n   attribute to describe the address\
    \ value:\n   <address addrType=\"ipv4\">10.1.2.3</address>\n   One might encode\
    \ the same information using an <addrType> element\n   instead of an \"addrType\"\
    \ attribute:\n   <address>\n     <addrType>ipv4</addrType>\n     <value>10.1.2.3</value>\n\
    \   </address>\n   Another way of encoding the same information would be to use\
    \ markup\n   for the \"addrType\":\n   <address>\n     <addrType><ipv4/></addrType>\n\
    \     <value>10.1.2.3</value>\n   </address>\n   Choosing between these designs\
    \ involves tradeoffs concerning, among\n   other considerations, the likely extensibility\
    \ patterns and the\n   ability of the formalism to constrain the values appropriately.\
    \  In\n   the first example, the attribute can be thought of as meta-data to\n\
    \   the element which it modifies, and provides for a kind of \"element\n   extensibility\"\
    .  The third example allows for a different kind of\n   extensibility: the \"\
    ipv4\" space can be extended using other\n   namespaces, and the <ipv4> element\
    \ can include additional markup.\n   Many protocols include parameters that are\
    \ selected from an\n   enumerated set of values.  Such enumerated values can be\
    \ encoded as\n   elements, attributes, or strings within element values.  Any\
    \ protocol\n   design should consider how the set of enumerated values is to be\n\
    \   extended: by revising the protocol, by including different values in\n   different\
    \ XML namespaces, or by establishing an IANA registry (as per\n   RFC 2434 [18]).\
    \  In addition, a common practice in XML is to use a\n   URI as an XML attribute\
    \ value or content.\n   Languages that describe syntactic validity (including\
    \ XML Schema and\n   DTDs) often provide a mechanism for specifying \"default\"\
    \ values for\n   an attribute.  If an element does not specify a value for the\n\
    \   attribute, then the \"default\" value is used.  The use of default\n   values\
    \ for attributes is discouraged by this document.  Although the\n   use of this\
    \ feature can reduce both the size and clutter of XML\n   documents, it has a\
    \ negative impact on software which doesn't know\n   the document's validity constraints\
    \ (e.g., for packet tracing or\n   digital signature).\n"
- title: 4.11 Binary Data and Text with Control Characters
  contents:
  - "4.11 Binary Data and Text with Control Characters\n   XML is defined as a character\
    \ stream rather than a stream of octets.\n   There is no way to embed raw binary\
    \ data directly within an XML data\n   stream; all binary data must be encoded\
    \ as characters.  There are a\n   number of possible encodings; for example, XML\
    \ Schema [42] defines\n   encodings using decimal digits for integers, Base64\
    \ [15], or\n   hexadecimal digits.  In addition, binary data might be transmitted\n\
    \   using some other communication channel, and referenced within the XML\n  \
    \ data itself using a URI.\n   Protocols that need a container that can hold both\
    \ structural data\n   and large quantities of binary data should consider carefully\
    \ whether\n   XML is appropriate, since the Base64 and hex encodings are\n   inefficient.\
    \  Otherwise, protocols should use the mechanisms of XML\n   Schema to represent\
    \ binary data; the Base64 encoding is best for\n   larger quantities of data.\n\
    \   XML does not allow \"control\" characters (0x00-0x1F) except for TAB\n   (0x09),\
    \ CR (0x0A), and LF (0x0D).  They can not be specified even\n   using character\
    \ entity references.  There is currently no common way\n   of encoding them within\
    \ what is otherwise ordinary text.  This means\n   that strings that might be\
    \ considered \"text\" within an ABNF-defined\n   protocol element may need to\
    \ be treated as binary data within an XML\n   representation, or some other encoding\
    \ mechanism might need to be\n   invented.\n"
- title: 4.12 Incremental Processing
  contents:
  - "4.12 Incremental Processing\n   In some situations, it is possible to incrementally\
    \ process an XML\n   document as each tag is received; this is analogous to the\
    \ process by\n   which browsers incrementally render HTML pages as they are received.\n\
    \   Note that incremental processing is difficult to implement if\n   interspersed\
    \ across multiple interactions.  In other words, if a\n   protocol requires incremental\
    \ processing across both directions of a\n   bidirectional stream, then it may\
    \ place an unusual burden on protocol\n   implementers.\n"
- title: 4.13 Entity Declarations and Entity References
  contents:
  - "4.13 Entity Declarations and Entity References\n   In addition to its role as\
    \ a validity mechanism, an XML DTD provides\n   a facility for \"entity declarations\"\
    \ ([8], section 4.2).  An entity\n   declaration defines, in the DTD, a kind of\
    \ macro capability where an\n   \"entity reference\" may be used to call up and\
    \ include the content of\n   the entity declaration.\n   This feature adds complexity\
    \ to XML processing, and seems more\n   appropriate for use of XML in document\
    \ processing than in data\n   representation.  As such, this document recommends\
    \ avoiding entity\n   declarations in protocol specifications.\n   On the other\
    \ hand, there are five standard entity references built\n   into XML: \"&amp;\"\
    , \"&lt;\", \"&gt;\", \"&apos;\", and \"&quot;\".  XML also\n   has the ability\
    \ to write character data using numeric entity\n   references (using the Unicode\
    \ [33] value for the character).  Entity\n   references are normally expanded\
    \ before the XML Information Set is\n   computed.  Restricting the use of these\
    \ entity references would\n   introduce an additional syntactic restriction (see\
    \ Section 4.3)\n   unnecessarily; these entity references should be allowed.\n"
- title: 4.14 External References
  contents:
  - "4.14 External References\n   When using XML in the context of a stateless protocol,\
    \ be it the\n   protocol itself (e.g., SOAP), or simply as content transferred\
    \ by an\n   existing protocol (e.g., XML/HTTP), care must be taken to not make\n\
    \   the meaning of a message depend on information outside the message\n   itself.\
    \  XML provides external entities (see Section 4.13), which are\n   an easy way\
    \ to make the meaning of a message depend on something\n   external.  Using schema\
    \ languages that can change the Infoset, like\n   XML Schema, is another way.\n"
- title: 4.15 URI Processing
  contents:
  - "4.15 URI Processing\n   The XML Base specification [36] defines an attribute\
    \ \"xml:base\" in\n   the XML namespace that is intended to affect the \"base\"\
    \ to be used\n   for relative URI processing described in RFC 2396 [17].  The\n\
    \   facilities of xml:base for controlling URI processing may be useful\n   to\
    \ protocol designers, but if xml:base is allowed the interaction\n   with any\
    \ other protocol facilities for establishing URI context must\n   be specified\
    \ clearly.  Note that use of relative URIs in namespace\n   declarations has been\
    \ deprecated by the W3C; some specific issues\n   with relative URIs in namespace\
    \ declarations and canonical XML can be\n   found in section 1.3 of RFC 3076 [6].\n\
    \   Note also that, in many cases, the term \"URI\" and the syntactic use\n  \
    \ of URIs within XML allows non-ASCII characters within URIs.  For\n   example,\
    \ the XML Schema \"anyURI\" datatype ([42] section 3.2.17)\n   allows for direct\
    \ encoding of characters outside of the US-ASCII\n   range.  Most current IETF\
    \ protocols and specifications do not allow\n   this syntax.  Protocol specifications\
    \ should be clear about the range\n   of characters specified, e.g., by adding\
    \ a restriction to the range\n   of characters allowed in the anyURI schema datatype,\
    \ or by specifying\n   that characters outside the US-ASCII range should be escaped\
    \ when\n   passed to older protocols or APIs.\n"
- title: 4.16 White Space
  contents:
  - "4.16 White Space\n   XML's prescribed white space handling behavior can be a\
    \ source of\n   confusion between protocol designers and implementers.  In XML\n\
    \   instances all white space is considered significant and is by default\n  \
    \ visible to processing applications.  Consider this example from\n   Section\
    \ 4.10:\n   <address>\n     <addrType><ipv4/></addrType>\n     <value>10.1.2.3</value>\n\
    \   </address>\n   This fragment contains an <address> element and two child elements.\n\
    \   It also contains white space for pretty-printing purposes:\n   o  at least\
    \ three line separators, which will be converted by the XML\n      processor to\
    \ newline (U+000A) characters (see section 2.11 of\n      [8]), and\n   o  one\
    \ or more white space characters prefixing the <addrType> and\n      <value> elements,\
    \ which an XML processor will make visible to\n      software reading the instance.\n\
    \   Implementers might safely assume that they can ignore the white space\n  \
    \ in the example above, but white space used for pretty-printing can be\n   a\
    \ source of confusion in other situations.  Consider a minor change\n   to the\
    \ <value> element:\n   <value>\n     10.1.2.3\n   </value>\n   where white space\
    \ is found on both sides of the IP address.  XML\n   processors treat the white\
    \ space surrounding \"10.1.2.3\" as an\n   integral part of the <value> element.\
    \  A failure to recognize this\n   behavior can lead to confusion and errors in\
    \ both design and\n   implementation.\n   All white space is considered significant\
    \ in XML instances.  As a\n   consequence, it is recommended that protocol designers\
    \ provide\n   specific guidelines to address white space handling within protocols\n\
    \   that use XML.\n"
- title: 4.17 Interaction with the IANA
  contents:
  - "4.17 Interaction with the IANA\n   When XML is used in an IETF protocol there\
    \ are multiple factors that\n   might require IANA action, including:\n   o  XML\
    \ media types.  A piece of XML in a protocol element is\n      sometimes intrinsically\
    \ bound to the protocol context in which it\n      appears, and in particular\
    \ might be directly derived from and/or\n      input to protocol state-machine\
    \ implementations.  In cases where\n      the XML content has no relevant meaning\
    \ outside it's original\n      protocol context, there is no reason to register\
    \ a MIME type.\n      When it is possible that XML content can be interpreted\
    \ outside of\n      its original context (such as when that XML content is being\n\
    \      stored in a file system or tunneled over another protocol), then a\n  \
    \    MIME type can be registered to specify the specific format for the\n    \
    \  data and to provide a hint as to how it might be processed.\n      If MIME\
    \ labeling is needed, then the advice of RFC 3023 [5]\n      applies.  In particular,\
    \ if the XML represents a new language or\n      document type, a new MIME media\
    \ type should be registered for the\n      reasons described in RFC 3023 sections\
    \ 7 and A.1.  In situations\n      where XML is used to encode generic structured\
    \ data (e.g., a\n      document-oriented application that involves combining XML\
    \ with a\n      stylesheet), \"application/xml\" might be appropriate (\"MAY be\n\
    \      used\").  The \"text/xml\" media type is not recommended (\"SHOULD NOT\n\
    \      be used\") because of issues involving display behavior and default\n \
    \     charsets.\n   o  URI registration.  There is an ongoing effort ([11], [12])\
    \ to\n      create a URN namespace explicitly for defining URIs for namespace\n\
    \      names and other URI-designated protocol elements for use within\n     \
    \ IETF standards track documents; it might also establish IETF\n      policy for\
    \ such use.\n"
- title: 5. Internationalization Considerations
  contents:
  - "5. Internationalization Considerations\n   This section describes internationalization\
    \ considerations for the\n   use of XML to represent data in IETF protocols. \
    \ In addition to the\n   recommendations here, IETF policy on the use of character\
    \ sets and\n   languages described in RFC 2277 [3] also applies.\n"
- title: 5.1 Character Sets and Encodings
  contents:
  - "5.1 Character Sets and Encodings\n   IETF protocols frequently speak of the \"\
    character set\" or \"charset\"\n   of a string, which is used to denote both the\
    \ character repertoire\n   and the encoding used to represent sequences of characters\
    \ as\n   sequences of bytes.\n   XML performs all character processing in terms\
    \ of the Universal\n   Character Set (UCS, [31] and [33]).  XML requires all XML\
    \ processors\n   to support both the UTF-8 [4] and UTF-16 [20] encodings of UCS,\n\
    \   although other encodings (charsets) compatible with UCS may be\n   allowed.\
    \  Documents and external parsed entities encoded in UTF-16\n   are required to\
    \ begin with a Byte Order Mark ([8] section 4.3.3).\n   IETF policy [3] requires\
    \ that the UTF-8 charset be allowed for all\n   text.\n   This document requires\
    \ that IETF protocols using XML allow for the\n   UTF-8 encoding of XML data.\
    \  Since conforming XML processors are\n   mandated to also accept UTF-16 encoding,\
    \ also allowing for UTF-16\n   encoding (with the mandated Byte Order Mark) is\
    \ recommended.  Some\n   XML applications are using a Byte Order Mark with UTF-8\
    \ encoding, but\n   this use should not be encouraged and isn't appropriate for\
    \ XML\n   embedded in other protocols.\n   Restricting XML data to only be expressed\
    \ in UTF-8 is an additional\n   syntactic restriction (see Section 4.3) which,\
    \ depending on\n   circumstances, might add additional implementation complexity.\
    \  When\n   encodings other than UTF-8 or UTF-16 are used, the encoding must be\n\
    \   specified using an \"encoding\" attribute in the XML declaration (see\n  \
    \ Section 4.4), even if there might be other protocol mechanisms for\n   designating\
    \ the encoding.\n"
- title: 5.2 Language Declaration
  contents:
  - "5.2 Language Declaration\n   Text encapsulated in XML can be represented in many\
    \ different human\n   languages, and it is often useful to explicitly identify\
    \ the language\n   used to present the text.  XML defines a special attribute\
    \ in the\n   \"xml\" namespace, xml:lang, that can be used to specify the language\n\
    \   used to represent data in an XML document.  The xml:lang attribute\n   (which\
    \ has to be explicitly declared for use within a DTD or XML\n   Schema) and the\
    \ values it can assume are defined in section 2.12 of\n   [8].\n   It is strongly\
    \ recommended that protocols representing data in a\n   human language mandate\
    \ use of an xml:lang attribute if the XML\n   instance might be interpreted in\
    \ language-dependent contexts.\n"
- title: 5.3 Other Internationalization Considerations
  contents:
  - "5.3 Other Internationalization Considerations\n   There are standard mechanisms\
    \ in the typography of some human\n   languages that can be difficult to represent\
    \ using merely XML\n   character string data types.  For example, pronunciation\
    \ clues can be\n   provided using Ruby annotation [39], and embedding controls\
    \ (such as\n   those described in section 3.4 of [34]) or an XHTML [40] \"dir\"\
    \n   attribute can be used to note the proper display direction for\n   bidirectional\
    \ text.\n   There are a number of tricky issues that can arise when using\n  \
    \ extended character sets with XML document formats.  For example:\n   o  There\
    \ are different ways of representing characters consisting of\n      combining\
    \ characters, and\n   o  There has been some debate about whether URIs should\
    \ be\n      represented using a restricted US-ASCII subset or arbitrary\n    \
    \  Unicode (e.g., \"URI character sequence\" vs \"original character\n      sequence\"\
    \ in RFC 2396 [17]).\n   Some of these issues are discussed, with recommendations,\
    \ in the\n   W3C's \"Character Model for the World Wide Web\" document [44].\n\
    \   It is strongly recommended that protocols representing data in a\n   human\
    \ language reuse existing mechanisms as needed to ensure proper\n   display of\
    \ human-legible text.\n"
- title: 6. IANA Considerations
  contents:
  - "6. IANA Considerations\n   This memo, per se, has no impact on the IANA.  Section\
    \ 4.17 notes\n   some factors that might require IANA action when protocols using\
    \ XML\n   are defined.\n"
- title: 7. Security Considerations
  contents:
  - "7. Security Considerations\n   Network protocols face many different kinds of\
    \ threats, including\n   unintended disclosure, modification, and replay.  Passive\
    \ attacks,\n   such as packet sniffing, allow an attacker to capture and view\n\
    \   information intended for someone else.  Captured data can be modified\n  \
    \ and replayed to the original intended recipient, with the recipient\n   having\
    \ no way to know that the information has been compromised,\n   detect modifications,\
    \ be assured of the sender's identity, or to\n   confirm which protocol instance\
    \ is legitimate.\n   Several security service options for XML are available to\
    \ help\n   mitigate these risks.  Though XML does not include any built-in\n \
    \  security services, other protocols and protocol layers provide\n   services\
    \ that can be used to protect XML protocols.  XML encryption\n   [10] provides\
    \ privacy services to prevent unintended disclosure.\n   Canonical XML [6] and\
    \ XML digital signatures [7] provide integrity\n   services to detect modification\
    \ and authentication services to\n   confirm the identity of the data source.\
    \  Other IETF security\n   protocols (e.g., the Transport Layer Security (TLS)\
    \ protocol [2]) are\n   also available to protect data and service endpoints as\
    \ appropriate.\n   Given the lack of security services in XML, it is imperative\
    \ that\n   protocol specifications mandate additional security services to\n \
    \  counter common threats and attacks; the specific required services\n   will\
    \ depend on the protocol's threat model.\n   Experience has shown that code that\
    \ parses network traffic is often a\n   \"soft target\" for blackhats.  Accordingly,\
    \ implementers MUST take\n   great care to ensure that their XML handling code\
    \ is robust with\n   respect to malformed XML, buffer overruns, misuse of entity\n\
    \   declarations, and so on.\n   XML mechanisms that follow external references\
    \ (Section 4.14) may\n   also expose an implementation to various threats by causing\
    \ the\n   implementation to access external resources automatically.  It is\n\
    \   important to disallow arbitrary access to such external references\n   within\
    \ XML data from untrusted sources.  Many XML grammars define\n   constructs using\
    \ URIs for external references; in such cases, the\n   same precautions must be\
    \ taken.\n"
- title: 8. Acknowledgements
  contents:
  - "8. Acknowledgements\n   The authors would like to thank the following people\
    \ who have\n   provided significant contributions to the development of this\n\
    \   document:\n   Mark Baker, Tim Berners-Lee, Tim Bray, James Clark, Josh Cohen,\
    \ John\n   Cowan, Alan Crouch, Martin Duerst, Jun Fujisawa, Christian Geuer-\n\
    \   Pollmann, Yaron Goland, Graham Klyne, Dan Kohn, Rick Jeliffe, Chris\n   Lilley,\
    \ Murata Makoto, Michael Mealling, Jean-Jacques Moreau, Andrew\n   Newton, Julian\
    \ Reschke, Jonathan Rosenberg, Miles Sabin, Rich Salz,\n   Peter Saint-Andre,\
    \ Simon St Laurent, Margaret Wasserman, and Daniel\n   Veillard.\n"
- title: 9. Normative References
  contents:
  - "9. Normative References\n   [1]   Bradner, S., \"Key words for use in RFCs to\
    \ Indicate Requirement\n         Levels\", BCP 14, RFC 2119, March 1997.\n   [2]\
    \   Dierks, T. and C. Allen, \"The TLS Protocol Version 1.0\", RFC\n         2246,\
    \ January 1999.\n   [3]   Alvestrand, H., \"IETF Policy on Character Sets and\
    \ Languages\",\n         BCP 18, RFC 2277, January 1998.\n   [4]   Yergeau, F.,\
    \ \"UTF-8, a transformation format of ISO 10646\", RFC\n         2279, January\
    \ 1998.\n   [5]   Murata, M., St. Laurent, S. and D. Kohn, \"XML Media Types\"\
    , RFC\n         3023, January 2001.\n   [6]   Boyer, J., \"Canonical XML Version\
    \ 1.0\", RFC 3076, March 2001.\n   [7]   Eastlake, D., Reagle, J. and D. Solo,\
    \ \"(Extensible Markup\n         Language) XML-Signature Syntax and Processing\"\
    , RFC 3275, March\n         2002.\n   [8]   Bray, T., Paoli, J., Sperberg-McQueen,\
    \ C. and E. Maler,\n         \"Extensible Markup Language (XML) 1.0 (2nd ed)\"\
    , W3C REC-xml,\n         October 2000, <http://www.w3.org/TR/REC-xml>.\n   [9]\
    \   Bray, T., Hollander, D. and A. Layman, \"Namespaces in XML\", W3C\n      \
    \   REC-xml-names, January 1999, <http://www.w3.org/TR/REC-xml-\n         names>.\n\
    \   [10]  Imamura, T., Dillaway, B., Schaad, J. and E. Simon, \"XML\n        \
    \ Encryption Syntax and Processing\", W3C REC-xmlenc-core, October\n         2001,\
    \ <http://www.w3.org/TR/xmlenc-core/>.\n"
- title: 10. Informative References
  contents:
  - "10. Informative References\n   [11]  Masinter, L., Mealling, M., Klyne, G. and\
    \ T. Hardie, \"An IETF\n         URN Sub-namespace for Registered Protocol Parameters\"\
    , Work in\n         Progress.\n   [12]  Mealling, M., \"The IETF XML Registry\"\
    , Work in Progress.\n   [13]  Case, J., Fedor, M., Schoffstall, M. and C. Davin,\
    \ \"Simple\n         Network Management Protocol (SNMP)\", STD 15, RFC 1157, May\n\
    \         1990.\n   [14]  Srinivasan, R., \"XDR: External Data Representation\
    \ Standard\",\n         RFC 1832, August 1995.\n   [15]  Freed, N. and N. Borenstein,\
    \ \"Multipurpose Internet Mail\n         Extensions (MIME) Part One: Format of\
    \ Internet Message Bodies\",\n         RFC 2045, November 1996.\n   [16]  Crocker,\
    \ D. (Ed.) and P. Overell, \"Augmented BNF for Syntax\n         Specifications:\
    \ ABNF\", RFC 2234, November 1997.\n   [17]  Berners-Lee, T., Fielding, R. and\
    \ L. Masinter, \"Uniform\n         Resource Identifiers (URI): Generic Syntax\"\
    , RFC 2396, August\n         1998.\n   [18]  Narten, T. and H. Alvestrand, \"\
    Guidelines for Writing an IANA\n         Considerations Section in RFCs\", BCP\
    \ 26, RFC 2434, October\n         1998.\n   [19]  Rose, M., \"Writing I-Ds and\
    \ RFCs using XML\", RFC 2629, June\n         1999.\n   [20]  Hoffman, P. and F.\
    \ Yergeau, \"UTF-16, an encoding of ISO 10646\",\n         RFC 2781, February\
    \ 2000.\n   [21]  Klensin, J. (Ed.), \"Simple Mail Transfer Protocol\", RFC 2821,\n\
    \         April 2001.\n   [22]  Shepler, S., Callaghan, B., Robinson, D., Thurlow,\
    \ R., Beame,\n         C., Eisler, M. and D. Noveck, \"NFS version 4 Protocol\"\
    , RFC\n         3010, December 2000.\n   [23]  Kennedy, H., \"Binary Lexical Octet\
    \ Ad-hoc Transport\", RFC 3252,\n         April 2002.\n   [24]  Popp, N., Mealling,\
    \ M. and M. Moseley, \"Common Name Resolution\n         Protocol (CNRP)\", RFC\
    \ 3367, August 2002.\n   [25]  Backus, J., \"The syntax and semantics of the proposed\n\
    \         international algebraic language of the Zurich ACM-GAMM\n         conference\"\
    , June 1959.\n   [26]  American National Standards Institute, \"Code Extension\n\
    \         Techniques for Use with the 7-bit Coded Character Set of\n         American\
    \ National Standard Code (ASCII) for Information\n         Interchange\", ANSI\
    \ X3.41, FIPS PUB 35, 1974.\n   [27]  American National Standards Institute, \"\
    Information Retrieval:\n         Application Service Definition and Protocol Specification\"\
    ,\n         ANSI Z39.50, ISO Standard 23950, 1995.\n   [28]  International Organization\
    \ for Standardization, \"Information\n         Processing Systems - Open Systems\
    \ Interconnection -\n         Specification of Abstract Syntax Notation One (ASN.1)\"\
    , ISO\n         Standard 8824, December 1990.\n   [29]  International Organization\
    \ for Standardization, \"Information\n         Processing Systems - Open Systems\
    \ Interconnection -\n         Specification of Basic Encoding Rules for Abstract\
    \ Syntax\n         Notation One (ASN.1)\", ISO Standard 8825, December 1990.\n\
    \   [30]  International Organization for Standardization, \"Information\n    \
    \     processing - Text and office systems - Standard Generalized\n         Markup\
    \ Language (SGML)\", ISO Standard 8879, 1988.\n   [31]  International Organization\
    \ for Standardization, \"Information\n         Technology - Universal Multiple-octet\
    \ coded Character Set (UCS)\n         - Part 1: Architecture and Basic Multilingual\
    \ Plane\", ISO\n         Standard 10646-1, May 1993.\n   [32]  International Organization\
    \ for Standardization, \"DSDL Part 0 -\n         Overview\", December 2001, <http://www.jtc1.org/FTP/Public/SC34/\n\
    \         DOCREG/0275.htm>.\n   [33]  Unicode Consortium, \"The Unicode Standard,\
    \ as it may from time\n         to time be revised or amended\", March 2002, <http://\n\
    \         www.unicode.org/unicode/standard/standard.html>.\n   [34]  Duerst, M.\
    \ and A. Freytag, \"Unicode in XML and other Markup\n         Languages\", February\
    \ 2002, <http://www.w3.org/TR/unicode-xml/>.\n   [35]  Bray, T., Paoli, J. and\
    \ C. Sperberg-McQueen, \"Extensible Markup\n         Language (XML) 1.0\", W3C\
    \ REC-xml-1998, February 1998, <http://\n         www.w3.org/TR/1998/REC-xml-19980210/>.\n\
    \   [36]  Marsh, J., \"XML Base\", W3C REC-xmlbase, June 2001, <http://\n    \
    \     www.w3.org/TR/xmlbase/>.\n   [37]  Cowan, J. and R. Tobin, \"XML Information\
    \ Set\", W3C REC-infoset,\n         October 2001, <http://www.w3.org/TR/xml-infoset/>.\n\
    \   [38]  Lassila, O. and R. Swick, \"Resource Description Framework (RDF)\n \
    \        Model and Syntax Specification\", W3C REC-rdf-syntax, February\n    \
    \     1999, <http://www.w3.org/TR/REC-rdf-syntax>.\n   [39]  Suignard, M., Ishikawa,\
    \ M., Duerst, M. and T. Texin, \"Ruby\n         Annotation\", W3C REC-RUBY, May\
    \ 2001, <http://www.w3.org/TR/\n         ruby/>.\n   [40]  Pemberton, S., \"XHTML\
    \ 1.0: The Extensible HyperText Markup\n         Language\", W3C REC-XHTML, January\
    \ 2000, <http://www.w3.org/TR/\n         xhtml1/>.\n   [41]  Thompson, H., Beech,\
    \ D., Maloney, M. and N. Mendelsohn, \"XML\n         Schema Part 1: Structures\"\
    , W3C REC-xmlschema-1, May 2001,\n         <http://www.w3.org/TR/xmlschema-1/>.\n\
    \   [42]  Biron, P. and A. Malhotra, \"XML Schema Part 2: Datatypes\", W3C\n \
    \        REC-xmlschema-2, May 2001, <http://www.w3.org/TR/xmlschema-2/>.\n   [43]\
    \  Clark, J., \"XSL Transformations (XSLT) Version 1.0\", W3C REC-\n         xslt,\
    \ November 1999, <http://www.w3.org/TR/xslt>.\n   [44]  Duerst, M., Yergeau, F.,\
    \ Ishida, R., Wolf, M., Freytag, A. and\n         T. Texin, \"Character Model\
    \ for the World Wide Web 1.0\", April\n         2002, <http://www.w3.org/TR/charmod/>.\n\
    \   [45]  Gudgin, M., Hadley, M., Moreau, JJ. and H. Nielsen, \"SOAP\n       \
    \  Version 1.2 Part 1: Messaging Framework\", June 2002,\n         <http://www.w3.org/TR/soap12-part1/>.\n\
    \   [46]  Gudgin, M., Hadley, M., Moreau, JJ. and H. Nielsen, \"SOAP\n       \
    \  Version 1.2 Part 2: Adjuncts\", June 2002,\n         <http://www.w3.org/TR/soap12-part2/>.\n\
    \   [47]  W3C Communications Team, \"XML in 10 points\", November 2001,\n    \
    \     <http://www.w3.org/XML/1999/XML-in-10-points>.\n   [48]  OASIS Technical\
    \ Committee: RELAX NG, \"RELAX NG Specification\",\n         December 2001, <http://www.oasis-open.org/committees/relax-ng/\n\
    \         spec-20011203.html>.\n   [49]  Jelliffe, R., \"The Schematron\", November\
    \ 2001, <http://\n         www.ascc.net/xml/schematron/>.\n"
- title: URIs
  contents:
  - "URIs\n   [50]  <http://www.imc.org/ietf-xml-use/>\n   [51]  <http://xml.org/>\n\
    \   [52]  <http://xmlhack.com/>\n   [53]  <http://oasis-open.org/>\n"
- title: 11. Authors' Addresses
  contents:
  - "11. Authors' Addresses\n   Scott Hollenbeck\n   VeriSign, Inc.\n   21345 Ridgetop\
    \ Circle\n   Dulles, VA  20166-6503\n   US\n   Phone: +1 703 948 3257\n   EMail:\
    \ shollenbeck@verisign.com\n   Marshall T. Rose\n   Dover Beach Consulting, Inc.\n\
    \   POB 255268\n   Sacramento, CA  95865-5268\n   US\n   Phone: +1 916 483 8878\n\
    \   EMail: mrose@dbc.mtview.ca.us\n   Larry Masinter\n   Adobe Systems Incorporated\n\
    \   Mail Stop W14\n   345 Park Ave.\n   San Jose, CA  95110\n   US\n   Phone:\
    \ +1 408 536 3024\n   EMail: LMM@acm.org\n   URI:   http://larry.masinter.net\n"
- title: 12.  Full Copyright Statement
  contents:
  - "12.  Full Copyright Statement\n   Copyright (C) The Internet Society (2003).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
