- title: __initial_text__
  contents:
  - '                             RTP Topologies

    '
- title: Abstract
  contents:
  - "Abstract\n   This document discusses point-to-point and multi-endpoint topologies\n\
    \   used in environments based on the Real-time Transport Protocol (RTP).\n  \
    \ In particular, centralized topologies commonly employed in the video\n   conferencing\
    \ industry are mapped to the RTP terminology.\n   This document is updated with\
    \ additional topologies and replaces RFC\n   5117.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc7667.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2015 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   4\n   2.  Definitions . . . . . . . . . . . . . . . . . . . . .\
    \ . . . .   5\n     2.1.  Glossary  . . . . . . . . . . . . . . . . . . . . .\
    \ . . .   5\n     2.2.  Definitions Related to RTP Grouping Taxonomy  . . . .\
    \ . .   5\n   3.  Topologies  . . . . . . . . . . . . . . . . . . . . . . . .\
    \ .   6\n     3.1.  Point to Point  . . . . . . . . . . . . . . . . . . . . .\
    \   6\n     3.2.  Point to Point via Middlebox  . . . . . . . . . . . . . .  \
    \ 7\n       3.2.1.  Translators . . . . . . . . . . . . . . . . . . . . .   7\n\
    \       3.2.2.  Back-to-Back RTP sessions . . . . . . . . . . . . . .  11\n  \
    \   3.3.  Point to Multipoint Using Multicast . . . . . . . . . . .  12\n    \
    \   3.3.1.  Any-Source Multicast (ASM)  . . . . . . . . . . . . .  12\n      \
    \ 3.3.2.  Source-Specific Multicast (SSM) . . . . . . . . . . .  14\n       3.3.3.\
    \  SSM with Local Unicast Resources  . . . . . . . . . .  15\n     3.4.  Point\
    \ to Multipoint Using Mesh  . . . . . . . . . . . . .  17\n     3.5.  Point to\
    \ Multipoint Using the RFC 3550 Translator . . . .  20\n       3.5.1.  Relay -\
    \ Transport Translator  . . . . . . . . . . . .  20\n       3.5.2.  Media Translator\
    \  . . . . . . . . . . . . . . . . . .  21\n     3.6.  Point to Multipoint Using\
    \ the RFC 3550 Mixer Model  . . .  22\n       3.6.1.  Media-Mixing Mixer  . .\
    \ . . . . . . . . . . . . . . .  24\n       3.6.2.  Media-Switching Mixer . .\
    \ . . . . . . . . . . . . . .  27\n     3.7.  Selective Forwarding Middlebox \
    \ . . . . . . . . . . . . .  29\n     3.8.  Point to Multipoint Using Video-Switching\
    \ MCUs  . . . . .  33\n     3.9.  Point to Multipoint Using RTCP-Terminating MCU\
    \  . . . . .  34\n     3.10. Split Component Terminal  . . . . . . . . . . . .\
    \ . . . .  35\n     3.11. Non-symmetric Mixer/Translators . . . . . . . . . .\
    \ . . .  38\n     3.12. Combining Topologies  . . . . . . . . . . . . . . . .\
    \ . .  38\n   4.  Topology Properties . . . . . . . . . . . . . . . . . . . .\
    \ .  39\n     4.1.  All-to-All Media Transmission . . . . . . . . . . . . . .\
    \  39\n     4.2.  Transport or Media Interoperability . . . . . . . . . . .  40\n\
    \     4.3.  Per-Domain Bitrate Adaptation . . . . . . . . . . . . . .  40\n  \
    \   4.4.  Aggregation of Media  . . . . . . . . . . . . . . . . . .  41\n    \
    \ 4.5.  View of All Session Participants  . . . . . . . . . . . .  41\n     4.6.\
    \  Loop Detection  . . . . . . . . . . . . . . . . . . . . .  42\n     4.7.  Consistency\
    \ between Header Extensions and RTCP  . . . . .  42\n   5.  Comparison of Topologies\
    \  . . . . . . . . . . . . . . . . . .  42\n   6.  Security Considerations . .\
    \ . . . . . . . . . . . . . . . . .  43\n   7.  References  . . . . . . . . .\
    \ . . . . . . . . . . . . . . . .  45\n     7.1.  Normative References  . . .\
    \ . . . . . . . . . . . . . . .  45\n     7.2.  Informative References  . . .\
    \ . . . . . . . . . . . . . .  45\n   Acknowledgements  . . . . . . . . . . .\
    \ . . . . . . . . . . . . .  48\n   Authors' Addresses  . . . . . . . . . . .\
    \ . . . . . . . . . . . .  48\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Real-time Transport Protocol (RTP) [RFC3550] topologies\
    \ describe\n   methods for interconnecting RTP entities and their processing\n\
    \   behavior for RTP and the RTP Control Protocol (RTCP).  This document\n   tries\
    \ to address past and existing confusion, especially with respect\n   to terms\
    \ not defined in RTP but in common use in the communication\n   industry, such\
    \ as the Multipoint Control Unit or MCU.\n   When the Audio-Visual Profile with\
    \ Feedback (AVPF) [RFC4585] was\n   developed, the main emphasis lay in the efficient\
    \ support of\n   point-to-point and small multipoint scenarios without centralized\n\
    \   multipoint control.  In practice, however, most multipoint\n   conferences\
    \ operate utilizing centralized units referred to as MCUs.\n   MCUs may implement\
    \ mixer or translator functionality (in RTP\n   [RFC3550] terminology) and signaling\
    \ support.  They may also contain\n   additional application-layer functionality.\
    \  This document focuses on\n   the media transport aspects of the MCU that can\
    \ be realized using\n   RTP, as discussed below.  Further considered are the properties\
    \ of\n   mixers and translators, and how some types of deployed MCUs deviate\n\
    \   from these properties.\n   This document also codifies new multipoint architectures\
    \ that have\n   recently been introduced and that were not anticipated in RFC\
    \ 5117;\n   thus, this document replaces [RFC5117].  These architectures use\n\
    \   scalable video coding and simulcasting, and their associated\n   centralized\
    \ units are referred to as Selective Forwarding Middleboxes\n   (SFMs).  This\
    \ codification provides a common information basis for\n   future discussion and\
    \ specification work.\n   The new topologies are Point to Point via Middlebox\
    \ (Section 3.2),\n   Source-Specific Multicast (Section 3.3.2), SSM with Local\
    \ Unicast\n   Resources (Section 3.3.3), Point to Multipoint Using Mesh\n   (Section\
    \ 3.4), Selective Forwarding Middlebox (Section 3.7), and\n   Split Component\
    \ Terminal (Section 3.10).  The Point to Multipoint\n   Using the RFC 3550 Mixer\
    \ Model (Section 3.6) has been significantly\n   expanded to cover two different\
    \ versions, namely Media-Mixing Mixer\n   (Section 3.6.1) and Media-Switching\
    \ Mixer (Section 3.6.2).\n   The document's attempt to clarify and explain sections\
    \ of the RTP\n   spec [RFC3550] is informal.  It is not intended to update or\
    \ change\n   what is normatively specified within RFC 3550.\n"
- title: 2.  Definitions
  contents:
  - '2.  Definitions

    '
- title: 2.1.  Glossary
  contents:
  - "2.1.  Glossary\n   ASM:  Any-Source Multicast\n   AVPF:  The extended RTP profile\
    \ for RTCP-based feedback\n   CSRC:  Contributing Source\n   Link:  The data transport\
    \ to the next IP hop\n   Middlebox:  A device that is on the Path that media travel\
    \ between\n      two endpoints\n   MCU:  Multipoint Control Unit\n   Path:  The\
    \ concatenation of multiple links, resulting in an\n      end-to-end data transfer.\n\
    \   PtM:  Point to Multipoint\n   PtP:  Point to Point\n   SFM:  Selective Forwarding\
    \ Middlebox\n   SSM:  Source-Specific Multicast\n   SSRC:  Synchronization Source\n"
- title: 2.2.  Definitions Related to RTP Grouping Taxonomy
  contents:
  - "2.2.  Definitions Related to RTP Grouping Taxonomy\n   The following definitions\
    \ have been taken from [RFC7656].\n   Communication Session:  A Communication\
    \ Session is an association\n      among two or more Participants communicating\
    \ with each other via\n      one or more Multimedia Sessions.\n   Endpoint:  A\
    \ single addressable entity sending or receiving RTP\n      packets.  It may be\
    \ decomposed into several functional blocks, but\n      as long as it behaves\
    \ as a single RTP stack mentity, it is\n      classified as a single \"endpoint\"\
    .\n   Media Source:  A Media Source is the logical source of a time\n      progressing\
    \ digital media stream synchronized to a reference\n      clock.  This stream\
    \ is called a Source Stream.\n   Multimedia Session:   A Multimedia Session is\
    \ an association among a\n      group of participants engaged in communication\
    \ via one or more RTP\n      sessions.\n"
- title: 3.  Topologies
  contents:
  - "3.  Topologies\n   This subsection defines several topologies that are relevant\
    \ for\n   codec control but also RTP usage in other contexts.  The section\n \
    \  starts with point-to-point cases, with or without middleboxes.  Then\n   it\
    \ follows a number of different methods for establishing point-to-\n   multipoint\
    \ communication.  These are structured around the most\n   fundamental enabler,\
    \ i.e., multicast, a mesh of connections,\n   translators, mixers, and finally\
    \ MCUs and SFMs.  The section ends by\n   discussing decomposited terminals, asymmetric\
    \ middlebox behaviors,\n   and combining topologies.\n   The topologies may be\
    \ referenced in other documents by a shortcut\n   name, indicated by the prefix\
    \ \"Topo-\".\n   For each of the RTP-defined topologies, we discuss how RTP, RTCP,\
    \ and\n   the carried media are handled.  With respect to RTCP, we also discuss\n\
    \   the handling of RTCP feedback messages as defined in [RFC4585] and\n   [RFC5104].\n"
- title: 3.1.  Point to Point
  contents:
  - "3.1.  Point to Point\n   Shortcut name: Topo-Point-to-Point\n   The Point-to-Point\
    \ (PtP) topology (Figure 1) consists of two\n   endpoints, communicating using\
    \ unicast.  Both RTP and RTCP traffic\n   are conveyed endpoint to endpoint, using\
    \ unicast traffic only (even\n   if, in exotic cases, this unicast traffic happens\
    \ to be conveyed over\n   an IP multicast address).\n                        \
    \    +---+         +---+\n                            | A |<------->| B |\n  \
    \                          +---+         +---+\n                         Figure\
    \ 1: Point to Point\n   The main property of this topology is that A sends to\
    \ B, and only B,\n   while B sends to A, and only A.  This avoids all complexities\
    \ of\n   handling multiple endpoints and combining the requirements stemming\n\
    \   from them.  Note that an endpoint can still use multiple RTP\n   Synchronization\
    \ Sources (SSRCs) in an RTP session.  The number of RTP\n   sessions in use between\
    \ A and B can also be of any number, subject\n   only to system-level limitations\
    \ like the number range of ports.\n   RTCP feedback messages for the indicated\
    \ SSRCs are communicated\n   directly between the endpoints.  Therefore, this\
    \ topology poses\n   minimal (if any) issues for any feedback messages.  For RTP\
    \ sessions\n   that use multiple SSRCs per endpoint, it can be relevant to implement\n\
    \   support for cross-reporting suppression as defined in \"Sending\n   Multiple\
    \ Media Streams in a Single RTP Session\" [MULTI-STREAM-OPT].\n"
- title: 3.2.  Point to Point via Middlebox
  contents:
  - "3.2.  Point to Point via Middlebox\n   This section discusses cases where two\
    \ endpoints communicate but have\n   one or more middleboxes involved in the RTP\
    \ session.\n"
- title: 3.2.1.  Translators
  contents:
  - "3.2.1.  Translators\n   Shortcut name: Topo-PtP-Translator\n   Two main categories\
    \ of translators can be distinguished: Transport\n   Translators and Media Translators.\
    \  Both translator types share\n   common attributes that separate them from mixers.\
    \  For each RTP\n   stream that the translator receives, it generates an individual\
    \ RTP\n   stream in the other domain.  A translator keeps the SSRC for an RTP\n\
    \   stream across the translation, whereas a mixer can select a single\n   RTP\
    \ stream from multiple received RTP streams (in cases like audio/\n   video switching)\
    \ or send out an RTP stream composed of multiple mixed\n   media received in multiple\
    \ RTP streams (in cases like audio mixing or\n   video tiling), but always under\
    \ its own SSRC, possibly using the CSRC\n   field to indicate the source(s) of\
    \ the content.  Mixers are more\n   common in point-to-multipoint cases than in\
    \ PtP.  The reason is that\n   in PtP use cases, the primary focus of a middlebox\
    \ is enabling\n   interoperability, between otherwise non-interoperable endpoints,\
    \ such\n   as transcoding to a codec the receiver supports, which can be done\
    \ by\n   a Media Translator.\n   As specified in Section 7.1 of [RFC3550], the\
    \ SSRC space is common\n   for all participants in the RTP session, independent\
    \ of on which side\n   of the translator the session resides.  Therefore, it is\
    \ the\n   responsibility of the endpoints (as the RTP session participants) to\n\
    \   run SSRC collision detection, and the SSRC is thus a field the\n   translator\
    \ cannot change.  Any Source Description (SDES) information\n   associated with\
    \ an SSRC or CSRC also needs to be forwarded between\n   the domains for any SSRC/CSRC\
    \ used in the different domains.\n   A translator commonly does not use an SSRC\
    \ of its own and is not\n   visible as an active participant in the RTP session.\
    \  One reason to\n   have its own SSRC is when a translator acts as a quality\
    \ monitor that\n   sends RTCP reports and therefore is required to have an SSRC.\n\
    \   Another example is the case when a translator is prepared to use RTCP\n  \
    \ feedback messages.  This may, for example, occur in a translator\n   configured\
    \ to detect packet loss of important video packets, and it\n   wants to trigger\
    \ repair by the media sending endpoint, by sending\n   feedback messages.  While\
    \ such feedback could use the SSRC of the\n   target for the translator (the receiving\
    \ endpoint), this in turn\n   would require translation of the target RTCP reports\
    \ to make them\n   consistent.  It may be simpler to expose an additional SSRC\
    \ in the\n   session.  The only concern is that endpoints failing to support the\n\
    \   full RTP specification may have issues with multiple SSRCs reporting\n   on\
    \ the RTP streams sent by that endpoint, as this use case may be\n   viewed as\
    \ exotic by implementers.\n   In general, a translator implementation should consider\
    \ which RTCP\n   feedback messages or codec-control messages it needs to understand\
    \ in\n   relation to the functionality of the translator itself.  This is\n  \
    \ completely in line with the requirement to also translate RTCP\n   messages\
    \ between the domains.\n"
- title: 3.2.1.1.  Transport Relay/Anchoring
  contents:
  - "3.2.1.1.  Transport Relay/Anchoring\n   Shortcut name: Topo-PtP-Relay\n   There\
    \ exist a number of different types of middleboxes that might be\n   inserted\
    \ between two endpoints on the transport level, e.g., to\n   perform changes on\
    \ the IP/UDP headers, and are, therefore, basic\n   Transport Translators.  These\
    \ middleboxes come in many variations\n   including NAT [RFC3022] traversal by\
    \ pinning the media path to a\n   public address domain relay and network topologies\
    \ where the RTP\n   stream is required to pass a particular point for audit by\
    \ employing\n   relaying, or preserving privacy by hiding each peer's transport\n\
    \   addresses to the other party.  Other protocols or functionalities\n   that\
    \ provide this behavior are Traversal Using Relays around NAT\n   (TURN) [RFC5766]\
    \ servers, Session Border Gateways, and Media\n   Processing Nodes with media\
    \ anchoring functionalities.\n                     +---+        +---+        \
    \ +---+\n                     | A |<------>| T |<------->| B |\n             \
    \        +---+        +---+         +---+\n                 Figure 2: Point to\
    \ Point with Translator\n   A common element in these functions is that they are\
    \ normally\n   transparent at the RTP level, i.e., they perform no changes on\
    \ any\n   RTP or RTCP packet fields and only affect the lower layers.  They may\n\
    \   affect, however, the path since the RTP and RTCP packets are routed\n   between\
    \ the endpoints in the RTP session, and thereby they indirectly\n   affect the\
    \ RTP session.  For this reason, one could believe that\n   Transport Translator-type\
    \ middleboxes do not need to be included in\n   this document.  This topology,\
    \ however, can raise additional\n   requirements in the RTP implementation and\
    \ its interactions with the\n   signaling solution.  Both in signaling and in\
    \ certain RTCP fields,\n   network addresses other than those of the relay can\
    \ occur since B has\n   a different network address than the relay (T).  Implementations\
    \ that\n   cannot support this will also not work correctly when endpoints are\n\
    \   subject to NAT.\n   The Transport Relay implementations also have to take\
    \ into account\n   security considerations.  In particular, source address filtering\
    \ of\n   incoming packets is usually important in relays, to prevent attackers\n\
    \   from injecting traffic into a session, which one peer may, in the\n   absence\
    \ of adequate security in the relay, think it comes from the\n   other peer.\n"
- title: 3.2.1.2.  Transport Translator
  contents:
  - "3.2.1.2.  Transport Translator\n   Shortcut name: Topo-Trn-Translator\n   Transport\
    \ Translators (Topo-Trn-Translator) do not modify the RTP\n   stream itself but\
    \ are concerned with transport parameters.  Transport\n   parameters, in the sense\
    \ of this section, comprise the transport\n   addresses (to bridge different domains\
    \ such as unicast to multicast)\n   and the media packetization to allow other\
    \ transport protocols to be\n   interconnected to a session (in gateways).\n \
    \  Translators that bridge between different protocol worlds need to be\n   concerned\
    \ about the mapping of the SSRC/CSRC (Contributing Source)\n   concept to the\
    \ non-RTP protocol.  When designing a translator to a\n   non-RTP-based media\
    \ transport, an important consideration is how to\n   handle different sources\
    \ and their identities.  This problem space is\n   not discussed henceforth.\n\
    \   Of the Transport Translators, this memo is primarily interested in\n   those\
    \ that use RTP on both sides, and this is assumed henceforth.\n   The most basic\
    \ Transport Translators that operate below the RTP level\n   were already discussed\
    \ in Section 3.2.1.1.\n"
- title: 3.2.1.3.  Media Translator
  contents:
  - "3.2.1.3.  Media Translator\n   Shortcut name: Topo-Media-Translator\n   Media\
    \ Translators (Topo-Media-Translator) modify the media inside the\n   RTP stream.\
    \  This process is commonly known as transcoding.  The\n   modification of the\
    \ media can be as small as removing parts of the\n   stream, and it can go all\
    \ the way to a full decoding and re-encoding\n   (down to the sample level or\
    \ equivalent) utilizing a different media\n   codec.  Media Translators are commonly\
    \ used to connect endpoints\n   without a common interoperability point in the\
    \ media encoding.\n   Stand-alone Media Translators are rare.  Most commonly,\
    \ a combination\n   of Transport and Media Translator is used to translate both\
    \ the media\n   and the transport aspects of the RTP stream carrying the media\n\
    \   between two transport domains.\n   When media translation occurs, the translator's\
    \ task regarding\n   handling of RTCP traffic becomes substantially more complex.\
    \  In this\n   case, the translator needs to rewrite endpoint B's RTCP receiver\n\
    \   report before forwarding them to endpoint A.  The rewriting is needed\n  \
    \ as the RTP stream received by B is not the same RTP stream as the\n   other\
    \ participants receive.  For example, the number of packets\n   transmitted to\
    \ B may be lower than what A sends, due to the different\n   media format and\
    \ data rate.  Therefore, if the receiver reports were\n   forwarded without changes,\
    \ the extended highest sequence number would\n   indicate that B was substantially\
    \ behind in reception, while it most\n   likely would not be.  Therefore, the\
    \ translator must translate that\n   number to a corresponding sequence number\
    \ for the stream the\n   translator received.  Similar requirements exist for\
    \ most other\n   fields in the RTCP receiver reports.\n   A Media Translator may\
    \ in some cases act on behalf of the \"real\"\n   source (the endpoint originally\
    \ sending the media to the translator)\n   and respond to RTCP feedback messages.\
    \  This may occur, for example,\n   when a receiving endpoint requests a bandwidth\
    \ reduction, and the\n   Media Translator has not detected any congestion or other\
    \ reasons for\n   bandwidth reduction between the sending endpoint and itself.\
    \  In that\n   case, it is sensible that the Media Translator reacts to codec\n\
    \   control messages itself, for example, by transcoding to a lower media\n  \
    \ rate.\n   A variant of translator behavior worth pointing out is the one\n \
    \  depicted in Figure 3 of an endpoint A sending an RTP stream\n   containing\
    \ media (only) to B.  On the path, there is a device T that\n   manipulates the\
    \ RTP streams on A's behalf.  One common example is\n   that T adds a second RTP\
    \ stream containing Forward Error Correction\n   (FEC) information in order to\
    \ protect A's (non FEC-protected) RTP\n   stream.  In this case, T needs to semantically\
    \ bind the new FEC RTP\n   stream to A's media-carrying RTP stream, for example,\
    \ by using the\n   same CNAME as A.\n                 +------+        +------+\
    \         +------+\n                 |      |        |      |         |      |\n\
    \                 |  A   |------->|  T   |-------->|  B   |\n                \
    \ |      |        |      |---FEC-->|      |\n                 +------+       \
    \ +------+         +------+\n                   Figure 3: Media Translator Adding\
    \ FEC\n   There may also be cases where information is added into the original\n\
    \   RTP stream, while leaving most or all of the original RTP packets\n   intact\
    \ (with the exception of certain RTP header fields, such as the\n   sequence number).\
    \  One example is the injection of metadata into the\n   RTP stream, carried in\
    \ their own RTP packets.\n   Similarly, a Media Translator can sometimes remove\
    \ information from\n   the RTP stream, while otherwise leaving the remaining RTP\
    \ packets\n   unchanged (again with the exception of certain RTP header fields).\n\
    \   Either type of functionality where T manipulates the RTP stream, or\n   adds\
    \ an accompanying RTP stream, on behalf of A is also covered under\n   the Media\
    \ Translator definition.\n"
- title: 3.2.2.  Back-to-Back RTP sessions
  contents:
  - "3.2.2.  Back-to-Back RTP sessions\n   Shortcut name: Topo-Back-To-Back\n   There\
    \ exist middleboxes that interconnect two endpoints (A and B)\n   through themselves\
    \ (MB), but not by being part of a common RTP\n   session.  Instead, they establish\
    \ two different RTP sessions: one\n   between A and the middlebox and another\
    \ between the middlebox and B.\n   This topology is called Topo-Back-To-Back.\n\
    \                   |<--Session A-->|  |<--Session B-->|\n                 +------+\
    \        +------+         +------+\n                 |  A   |------->|  MB  |-------->|\
    \  B   |\n                 +------+        +------+         +------+\n       \
    \    Figure 4: Back-to-Back RTP Sessions through Middlebox\n   The middlebox acts\
    \ as an application-level gateway and bridges the\n   two RTP sessions.  This\
    \ bridging can be as basic as forwarding the\n   RTP payloads between the sessions\
    \ or more complex including media\n   transcoding.  The difference of this topology\
    \ relative to the single\n   RTP session context is the handling of the SSRCs\
    \ and the other\n   session-related identifiers, such as CNAMEs.  With two different\
    \ RTP\n   sessions, these can be freely changed and it becomes the middlebox's\n\
    \   responsibility to maintain the correct relations.\n   The signaling or other\
    \ above RTP-level functionalities referencing\n   RTP streams may be what is most\
    \ impacted by using two RTP sessions\n   and changing identifiers.  The structure\
    \ with two RTP sessions also\n   puts a congestion control requirement on the\
    \ middlebox, because it\n   becomes fully responsible for the media stream it\
    \ sources into each\n   of the sessions.\n   Adherence to congestion control can\
    \ be solved locally on each of the\n   two segments or by bridging statistics\
    \ from the receiving endpoint\n   through the middlebox to the sending endpoint.\
    \  From an\n   implementation point, however, the latter requires dealing with\
    \ a\n   number of inconsistencies.  First, packet loss must be detected for\n\
    \   an RTP stream sent from A to the middlebox, and that loss must be\n   reported\
    \ through a skipped sequence number in the RTP stream from the\n   middlebox to\
    \ B.  This coupling and the resulting inconsistencies are\n   conceptually easier\
    \ to handle when considering the two RTP streams as\n   belonging to a single\
    \ RTP session.\n"
- title: 3.3.  Point to Multipoint Using Multicast
  contents:
  - "3.3.  Point to Multipoint Using Multicast\n   Multicast is an IP-layer functionality\
    \ that is available in some\n   networks.  Two main flavors can be distinguished:\
    \ Any-Source\n   Multicast (ASM) [RFC1112] where any multicast group participant\
    \ can\n   send to the group address and expect the packet to reach all group\n\
    \   participants and Source-Specific Multicast (SSM) [RFC3569], where\n   only\
    \ a particular IP host sends to the multicast group.  Each of\n   these models\
    \ are discussed below in their respective sections.\n"
- title: 3.3.1.  Any-Source Multicast (ASM)
  contents:
  - "3.3.1.  Any-Source Multicast (ASM)\n   Shortcut name: Topo-ASM (was Topo-Multicast)\n\
    \                                   +-----+\n                        +---+   \
    \  /       \\    +---+\n                        | A |----/         \\---| B |\n\
    \                        +---+   /   Multi-  \\  +---+\n                     \
    \          +    cast     +\n                        +---+   \\  Network  /  +---+\n\
    \                        | C |----\\         /---| D |\n                     \
    \   +---+     \\       /    +---+\n                                   +-----+\n\
    \               Figure 5: Point to Multipoint Using Multicast\n   Point to Multipoint\
    \ (PtM) is defined here as using a multicast\n   topology as a transmission model,\
    \ in which traffic from any multicast\n   group participant reaches all the other\
    \ multicast group participants,\n   except for cases such as:\n   o  packet loss,\
    \ or\n   o  when a multicast group participant does not wish to receive the\n\
    \      traffic for a specific multicast group and, therefore, has not\n      subscribed\
    \ to the IP multicast group in question.  This scenario\n      can occur, for\
    \ example, where a Multimedia Session is distributed\n      using two or more\
    \ multicast groups, and a multicast group\n      participant is subscribed only\
    \ to a subset of these sessions.\n   In the above context, \"traffic\" encompasses\
    \ both RTP and RTCP\n   traffic.  The number of multicast group participants can\
    \ vary between\n   one and many, as RTP and RTCP scale to very large multicast\
    \ groups\n   (the theoretical limit of the number of participants in a single\
    \ RTP\n   session is in the range of billions).  The above can be realized\n \
    \  using ASM.\n   For feedback usage, it is useful to define a \"small multicast\
    \ group\"\n   as a group where the number of multicast group participants is so\
    \ low\n   (and other factors such as the connectivity is so good) that it\n  \
    \ allows the participants to use early or immediate feedback, as\n   defined in\
    \ AVPF [RFC4585].  Even when the environment would allow for\n   the use of a\
    \ small multicast group, some applications may still want\n   to use the more\
    \ limited options for RTCP feedback available to large\n   multicast groups, for\
    \ example, when there is a likelihood that the\n   threshold of the small multicast\
    \ group (in terms of multicast group\n   participants) may be exceeded during\
    \ the lifetime of a session.\n   RTCP feedback messages in multicast reach, like\
    \ media data, every\n   subscriber (subject to packet losses and multicast group\n\
    \   subscription).  Therefore, the feedback suppression mechanism\n   discussed\
    \ in [RFC4585] is typically required.  Each individual\n   endpoint that is a\
    \ multicast group participant needs to process every\n   feedback message it receives,\
    \ not only to determine if it is affected\n   or if the feedback message applies\
    \ only to some other endpoint but\n   also to derive timing restrictions for the\
    \ sending of its own\n   feedback messages, if any.\n"
- title: 3.3.2.  Source-Specific Multicast (SSM)
  contents:
  - "3.3.2.  Source-Specific Multicast (SSM)\n   Shortcut name: Topo-SSM\n   In Any-Source\
    \ Multicast, any of the multicast group participants can\n   send to all the other\
    \ multicast group participants, by sending a\n   packet to the multicast group.\
    \  In contrast, Source-Specific\n   Multicast [RFC3569][RFC4607] refers to scenarios\
    \ where only a single\n   source (Distribution Source) can send to the multicast\
    \ group,\n   creating a topology that looks like the one below:\n          +--------+\
    \       +-----+\n          |Media   |       |     |       Source-Specific\n  \
    \        |Sender 1|<----->| D S |          Multicast\n          +--------+   \
    \    | I O |  +--+----------------> R(1)\n                           | S U | \
    \ |  |                    |\n          +--------+       | T R |  |  +----------->\
    \ R(2)   |\n          |Media   |<----->| R C |->+  |           :   |    |\n  \
    \        |Sender 2|       | I E |  |  +------> R(n-1) |    |\n          +--------+\
    \       | B   |  |  |          |    |    |\n              :            | U   |\
    \  +--+--> R(n)  |    |    |\n              :            | T +-|          |  \
    \   |    |    |\n              :            | I | |<---------+     |    |    |\n\
    \          +--------+       | O |F|<---------------+    |    |\n          |Media\
    \   |       | N |T|<--------------------+    |\n          |Sender M|<----->| \
    \  | |<-------------------------+\n          +--------+       +-----+       RTCP\
    \ Unicast\n          FT = Feedback Target\n          Transport from the Feedback\
    \ Target to the Distribution\n          Source is via unicast or multicast RTCP\
    \ if they are not\n          co-located.\n       Figure 6: Point to Multipoint\
    \ Using Source-Specific Multicast\n   In the SSM topology (Figure 6), a number\
    \ of RTP sending endpoints\n   (RTP sources henceforth) (1 to M) are allowed to\
    \ send media to the\n   SSM group.  These sources send media to a dedicated Distribution\n\
    \   Source, which forwards the RTP streams to the multicast group on\n   behalf\
    \ of the original RTP sources.  The RTP streams reach the\n   receiving endpoints\
    \ (receivers henceforth) (R(1) to R(n)).  The\n   receivers' RTCP messages cannot\
    \ be sent to the multicast group, as\n   the SSM multicast group by definition\
    \ has only a single IP sender.\n   To support RTCP, an RTP extension for SSM [RFC5760]\
    \ was defined.  It\n   uses unicast transmission to send RTCP from each of the\
    \ receivers to\n   one or more Feedback Targets (FT).  The Feedback Targets relay\
    \ the\n   RTCP unmodified, or provide a summary of the participants' RTCP\n  \
    \ reports towards the whole group by forwarding the RTCP traffic to the\n   Distribution\
    \ Source.  Figure 6 only shows a single Feedback Target\n   integrated in the\
    \ Distribution Source, but for scalability the FT can\n   be distributed and each\
    \ instance can have responsibility for\n   subgroups of the receivers.  For summary\
    \ reports, however, there\n   typically must be a single Feedback Target aggregating\
    \ all the\n   summaries to a common message to the whole receiver group.\n   The\
    \ RTP extension for SSM specifies how feedback (both reception\n   information\
    \ and specific feedback events) are handled.  The more\n   general problems associated\
    \ with the use of multicast, where everyone\n   receives what the Distribution\
    \ Source sends, need to be accounted\n   for.\n   The aforementioned situation\
    \ results in common behavior for RTP\n   multicast:\n   1.  Multicast applications\
    \ often use a group of RTP sessions, not\n       one.  Each endpoint needs to\
    \ be a member of most or all of these\n       RTP sessions in order to perform\
    \ well.\n   2.  Within each RTP session, the number of media sinks is likely to\n\
    \       be much larger than the number of RTP sources.\n   3.  Multicast applications\
    \ need signaling functions to identify the\n       relationships between RTP sessions.\n\
    \   4.  Multicast applications need signaling functions to identify the\n    \
    \   relationships between SSRCs in different RTP sessions.\n   All multicast configurations\
    \ share a signaling requirement: all of\n   the endpoints need to have the same\
    \ RTP and payload type\n   configuration.  Otherwise, endpoint A could, for example,\
    \ be using\n   payload type 97 to identify the video codec H.264, while endpoint\
    \ B\n   would identify it as MPEG-2, with unpredictable but almost certainly\n\
    \   not visually pleasing results.\n   Security solutions for this type of group\
    \ communication are also\n   challenging.  First, the key management and the security\
    \ protocol\n   must support group communication.  Source authentication becomes\
    \ more\n   difficult and requires specialized solutions.  For more discussion\
    \ on\n   this, please review \"Options for Securing RTP Sessions\" [RFC7201].\n"
- title: 3.3.3.  SSM with Local Unicast Resources
  contents:
  - "3.3.3.  SSM with Local Unicast Resources\n   Shortcut name: Topo-SSM-RAMS\n \
    \  \"Unicast-Based Rapid Acquisition of Multicast RTP Sessions\" [RFC6285]\n \
    \  results in additional extensions to SSM topology.\n    -----------        \
    \                               --------------\n   |           |------------------------------------>|\
    \              |\n   |           |.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.->|     \
    \         |\n   |           |                                     |          \
    \    |\n   | Multicast |          ----------------           |              |\n\
    \   |  Source   |         | Retransmission |          |              |\n   | \
    \          |-------->|  Server (RS)   |          |              |\n   |      \
    \     |.-.-.-.->|                |          |              |\n   |           |\
    \         |  ------------  |          |              |\n    -----------      \
    \    | |  Feedback  | |<.=.=.=.=.|              |\n                         |\
    \ | Target (FT)| |<~~~~~~~~~| RTP Receiver |\n   PRIMARY MULTICAST     |  ------------\
    \  |          |   (RTP_Rx)   |\n   RTP SESSION with      |                |  \
    \        |              |\n   UNICAST FEEDBACK      |                |       \
    \   |              |\n                         |                |          | \
    \             |\n   - - - - - - - - - - - |- - - - - - - - |- - - - - |- - - -\
    \ - - - |- -\n                         |                |          |         \
    \     |\n   UNICAST BURST         |  ------------  |          |              |\n\
    \   (or RETRANSMISSION)   | |   Burst/   | |<~~~~~~~~>|              |\n   RTP\
    \ SESSION           | |  Retrans.  | |.........>|              |\n           \
    \              | |Source (BRS)| |<.=.=.=.=>|              |\n                \
    \         |  ------------  |          |              |\n                     \
    \    |                |          |              |\n                          ----------------\
    \            --------------\n      -------> Multicast RTP Stream\n      .-.-.-.>\
    \ Multicast RTCP Stream\n      .=.=.=.> Unicast RTCP Reports\n      ~~~~~~~> Unicast\
    \ RTCP Feedback Messages\n      .......> Unicast RTP Stream\n             Figure\
    \ 7: SSM with Local Unicast Resources (RAMS)\n   The rapid acquisition extension\
    \ allows an endpoint joining an SSM\n   multicast session to request media starting\
    \ with the last sync point\n   (from where media can be decoded without requiring\
    \ context\n   established by the decoding of prior packets) to be sent at high\n\
    \   speed until such time where, after the decoding of these burst-\n   delivered\
    \ media packets, the correct media timing is established,\n   i.e., media packets\
    \ are received within adequate buffer intervals for\n   this application.  This\
    \ is accomplished by first establishing a\n   unicast PtP RTP session between\
    \ the Burst/Retransmission Source (BRS)\n   (Figure 7) and the RTP Receiver. \
    \ The unicast session is used to\n   transmit cached packets from the multicast\
    \ group at higher then\n   normal speed in order to synchronize the receiver to\
    \ the ongoing\n   multicast RTP stream.  Once the RTP receiver and its decoder\
    \ have\n   caught up with the multicast session's current delivery, the receiver\n\
    \   switches over to receiving directly from the multicast group.  In\n   many\
    \ deployed applications, the (still existing) PtP RTP session is\n   used as a\
    \ repair channel, i.e., for RTP Retransmission traffic of\n   those packets that\
    \ were not received from the multicast group.\n"
- title: 3.4.  Point to Multipoint Using Mesh
  contents:
  - "3.4.  Point to Multipoint Using Mesh\n   Shortcut name: Topo-Mesh\n         \
    \                    +---+      +---+\n                             | A |<---->|\
    \ B |\n                             +---+      +---+\n                       \
    \        ^         ^\n                                \\       /\n           \
    \                      \\     /\n                                  v   v\n   \
    \                               +---+\n                                  | C |\n\
    \                                  +---+\n                 Figure 8: Point to\
    \ Multipoint Using Mesh\n   Based on the RTP session definition, it is clearly\
    \ possible to have a\n   joint RTP session involving three or more endpoints over\
    \ multiple\n   unicast transport flows, like the joint three-endpoint session\n\
    \   depicted above.  In this case, A needs to send its RTP streams and\n   RTCP\
    \ packets to both B and C over their respective transport flows.\n   As long as\
    \ all endpoints do the same, everyone will have a joint view\n   of the RTP session.\n\
    \   This topology does not create any additional requirements beyond the\n   need\
    \ to have multiple transport flows associated with a single RTP\n   session. \
    \ Note that an endpoint may use a single local port to\n   receive all these transport\
    \ flows (in which case the sending port, IP\n   address, or SSRC can be used to\
    \ demultiplex), or it might have\n   separate local reception ports for each of\
    \ the endpoints.\n         +-A--------------------+\n         |+---+         \
    \        |\n         ||CAM|                 |                 +-B-----------+\n\
    \         |+---+     +-UDP1------|                 |-UDP1------+ |\n         |\
    \  |       | +-RTP1----|                 |-RTP1----+ | |\n         |  V      \
    \ | | +-Video-|                 |-Video-+ | | |\n         |+----+    | | |   \
    \    |<----------------|BV1    | | | |\n         ||ENC |----+-+-+--->AV1|---------------->|\
    \       | | | |\n         |+----+    | | +-------|                 |-------+ |\
    \ | |\n         |  |       | +---------|                 |---------+ | |\n   \
    \      |  |       +-----------|                 |-----------+ |\n         |  |\
    \                   |                 +-------------+\n         |  |         \
    \          |\n         |  |                   |                 +-C-----------+\n\
    \         |  |       +-UDP2------|                 |-UDP2------+ |\n         |\
    \  |       | +-RTP1----|                 |-RTP1----+ | |\n         |  |      \
    \ | | +-Video-|                 |-Video-+ | | |\n         |  +-------+-+-+--->AV1|---------------->|\
    \       | | | |\n         |          | | |       |<----------------|CV1    | |\
    \ | |\n         |          | | +-------|                 |-------+ | | |\n   \
    \      |          | +---------|                 |---------+ | |\n         |  \
    \        +-----------|                 |-----------+ |\n         +----------------------+\
    \                 +-------------+\n          Figure 9: A Multi-Unicast Mesh with\
    \ a Joint RTP Session\n   Figure 9 depicts endpoint A's view of using a common\
    \ RTP session when\n   establishing the mesh as shown in Figure 8.  There is only\
    \ one RTP\n   session (RTP1) but two transport flows (UDP1 and UDP2).  The Media\n\
    \   Source (CAM) is encoded and transmitted over the SSRC (AV1) across\n   both\
    \ transport layers.  However, as this is a joint RTP session, the\n   two streams\
    \ must be the same.  Thus, a congestion control adaptation\n   needed for the\
    \ paths A to B and A to C needs to use the most\n   restricting path's properties.\n\
    \   An alternative structure for establishing the above topology is to\n   use\
    \ independent RTP sessions between each pair of peers, i.e., three\n   different\
    \ RTP sessions.  In some scenarios, the same RTP stream may\n   be sent from the\
    \ transmitting endpoint; however, it also supports\n   local adaptation taking\
    \ place in one or more of the RTP streams,\n   rendering them non-identical.\n\
    \          +-A----------------------+              +-B-----------+\n         \
    \ |+---+                   |              |             |\n          ||MIC|  \
    \     +-UDP1------|              |-UDP1------+ |\n          |+---+       | +-RTP1----|\
    \              |-RTP1----+ | |\n          | |  +----+  | | +-Audio-|         \
    \     |-Audio-+ | | |\n          | +->|ENC1|--+-+-+--->AA1|------------->|   \
    \    | | | |\n          | |  +----+  | | |       |<-------------|BA1    | | |\
    \ |\n          | |          | | +-------|              |-------+ | | |\n     \
    \     | |          | +---------|              |---------+ | |\n          | | \
    \         +-----------|              |-----------+ |\n          | |          ------------|\
    \              |-------------|\n          | |                      |         \
    \     |-------------+\n          | |                      |\n          | |   \
    \                   |              +-C-----------+\n          | |            \
    \          |              |             |\n          | |          +-UDP2------|\
    \              |-UDP2------+ |\n          | |          | +-RTP2----|         \
    \     |-RTP2----+ | |\n          | |  +----+  | | +-Audio-|              |-Audio-+\
    \ | | |\n          | +->|ENC2|--+-+-+--->AA2|------------->|       | | | |\n \
    \         |    +----+  | | |       |<-------------|CA1    | | | |\n          |\
    \            | | +-------|              |-------+ | | |\n          |         \
    \   | +---------|              |---------+ | |\n          |            +-----------|\
    \              |-----------+ |\n          +------------------------+         \
    \     +-------------+\n      Figure 10: A Multi-Unicast Mesh with an Independent\
    \ RTP Session\n   Let's review the topology when independent RTP sessions are\
    \ used from\n   A's perspective in Figure 10 by considering both how the media\
    \ is\n   handled and how the RTP sessions are set up in Figure 10.  A's\n   microphone\
    \ is captured and the audio is fed into two different\n   encoder instances, each\
    \ with a different independent RTP session,\n   i.e., RTP1 and RTP2, respectively.\
    \  The SSRCs (AA1 and AA2) in each\n   RTP session are completely independent,\
    \ and the media bitrate\n   produced by the encoders can also be tuned differently\
    \ to address any\n   congestion control requirements differing for the paths A\
    \ to B\n   compared to A to C.\n   From a topologies viewpoint, an important difference\
    \ exists in the\n   behavior around RTCP.  First, when a single RTP session spans\
    \ all\n   three endpoints A, B, and C, and their connecting RTP streams, a\n \
    \  common RTCP bandwidth is calculated and used for this single joint\n   session.\
    \  In contrast, when there are multiple independent RTP\n   sessions, each RTP\
    \ session has its local RTCP bandwidth allocation.\n   Further, when multiple\
    \ sessions are used, endpoints not directly\n   involved in a session do not have\
    \ any awareness of the conditions in\n   those sessions.  For example, in the\
    \ case of the three-endpoint\n   configuration in Figure 8, endpoint A has no\
    \ awareness of the\n   conditions occurring in the session between endpoints B\
    \ and C\n   (whereas if a single RTP session were used, it would have such\n \
    \  awareness).\n   Loop detection is also affected.  With independent RTP sessions,\
    \ the\n   SSRC/CSRC cannot be used to determine when an endpoint receives its\n\
    \   own media stream, or a mixed media stream including its own media\n   stream\
    \ (a condition known as a loop).  The identification of loops\n   and, in most\
    \ cases, their avoidance, has to be achieved by other\n   means, for example,\
    \ through signaling or the use of an RTP external\n   namespace binding SSRC/CSRC\
    \ among any communicating RTP sessions in\n   the mesh.\n"
- title: 3.5.  Point to Multipoint Using the RFC 3550 Translator
  contents:
  - "3.5.  Point to Multipoint Using the RFC 3550 Translator\n   This section discusses\
    \ some additional usages related to point to\n   multipoint of translators compared\
    \ to the point-to-point cases in\n   Section 3.2.1.\n"
- title: 3.5.1.  Relay - Transport Translator
  contents:
  - "3.5.1.  Relay - Transport Translator\n   Shortcut name: Topo-PtM-Trn-Translator\n\
    \   This section discusses Transport Translator-only usages to enable\n   multipoint\
    \ sessions.\n                        +-----+\n             +---+     /       \\\
    \     +------------+      +---+\n             | A |<---/         \\    |     \
    \       |<---->| B |\n             +---+   /           \\   |            |   \
    \   +---+\n                    +  Multicast  +->| Translator |\n             +---+\
    \   \\  Network  /   |            |      +---+\n             | C |<---\\     \
    \    /    |            |<---->| D |\n             +---+     \\       /     +------------+\
    \      +---+\n                        +-----+\n              Figure 11: Point\
    \ to Multipoint Using Multicast\n   Figure 11 depicts an example of a Transport\
    \ Translator performing at\n   least IP address translation.  It allows the (non-multicast-capable)\n\
    \   endpoints B and D to take part in an Any-Source Multicast session\n   involving\
    \ endpoints A and C, by having the translator forward their\n   unicast traffic\
    \ to the multicast addresses in use, and vice versa.\n   It must also forward\
    \ B's traffic to D, and vice versa, to provide\n   both B and D with a complete\
    \ view of the session.\n                   +---+      +------------+      +---+\n\
    \                   | A |<---->|            |<---->| B |\n                   +---+\
    \      |            |      +---+\n                              | Translator |\n\
    \                   +---+      |            |      +---+\n                   |\
    \ C |<---->|            |<---->| D |\n                   +---+      +------------+\
    \      +---+\n         Figure 12: RTP Translator (Relay) with Only Unicast Paths\n\
    \   Another translator scenario is depicted in Figure 12.  The translator\n  \
    \ in this case connects multiple endpoints through unicast.  This can\n   be implemented\
    \ using a very simple Transport Translator which, in\n   this document, is called\
    \ a relay.  The relay forwards all traffic it\n   receives, both RTP and RTCP,\
    \ to all other endpoints.  In doing so, a\n   multicast network is emulated without\
    \ relying on a multicast-capable\n   network infrastructure.\n   For RTCP feedback,\
    \ this results in a similar set of considerations to\n   those described in the\
    \ ASM RTP topology.  It also puts some\n   additional signaling requirements onto\
    \ the session establishment; for\n   example, a common configuration of RTP payload\
    \ types is required.\n   Transport Translators and relays should always consider\
    \ implementing\n   source address filtering, to prevent attackers from using the\n\
    \   listening ports on the translator to inject traffic.  The translator\n   can,\
    \ however, go one step further, especially if explicit SSRC\n   signaling is used,\
    \ to prevent endpoints from sending SSRCs other than\n   its own (that are, for\
    \ example, used by other participants in the\n   session).  This can improve the\
    \ security properties of the session,\n   despite the use of group keys that on\
    \ a cryptographic level allows\n   anyone to impersonate another in the same RTP\
    \ session.\n   A translator that doesn't change the RTP/RTCP packet content can\
    \ be\n   operated without requiring it to have access to the security contexts\n\
    \   used to protect the RTP/RTCP traffic between the participants.\n"
- title: 3.5.2.  Media Translator
  contents:
  - "3.5.2.  Media Translator\n   In the context of multipoint communications, a Media\
    \ Translator is\n   not providing new mechanisms to establish a multipoint session.\
    \  It\n   is more of an enabler, or facilitator, that ensures a given endpoint\n\
    \   or a defined subset of endpoints can participate in the session.\n   If endpoint\
    \ B in Figure 11 were behind a limited network path, the\n   translator may perform\
    \ media transcoding to allow the traffic\n   received from the other endpoints\
    \ to reach B without overloading the\n   path.  This transcoding can help the\
    \ other endpoints in the multicast\n   part of the session, by not requiring the\
    \ quality transmitted by A to\n   be lowered to the bitrates that B is actually\
    \ capable of receiving\n   (and vice versa).\n"
- title: 3.6.  Point to Multipoint Using the RFC 3550 Mixer Model
  contents:
  - "3.6.  Point to Multipoint Using the RFC 3550 Mixer Model\n   Shortcut name: Topo-Mixer\n\
    \   A mixer is a middlebox that aggregates multiple RTP streams that are\n   part\
    \ of a session by generating one or more new RTP streams and, in\n   most cases,\
    \ by manipulating the media data.  One common application\n   for a mixer is to\
    \ allow a participant to receive a session with a\n   reduced amount of resources.\n\
    \                        +-----+\n             +---+     /       \\     +-----------+\
    \      +---+\n             | A |<---/         \\    |           |<---->| B |\n\
    \             +---+   /   Multi-  \\   |           |      +---+\n            \
    \        +    cast     +->|   Mixer   |\n             +---+   \\  Network  / \
    \  |           |      +---+\n             | C |<---\\         /    |         \
    \  |<---->| D |\n             +---+     \\       /     +-----------+      +---+\n\
    \                        +-----+\n       Figure 13: Point to Multipoint Using\
    \ the RFC 3550 Mixer Model\n   A mixer can be viewed as a device terminating the\
    \ RTP streams\n   received from other endpoints in the same RTP session.  Using\
    \ the\n   media data carried in the received RTP streams, a mixer generates\n\
    \   derived RTP streams that are sent to the receiving endpoints.\n   The content\
    \ that the mixer provides is the mixed aggregate of what\n   the mixer receives\
    \ over the PtP or PtM paths, which are part of the\n   same Communication Session.\n\
    \   The mixer creates the Media Source and the source RTP stream just\n   like\
    \ an endpoint, as it mixes the content (often in the uncompressed\n   domain)\
    \ and then encodes and packetizes it for transmission to a\n   receiving endpoint.\
    \  The CSRC Count (CC) and CSRC fields in the RTP\n   header can be used to indicate\
    \ the contributors to the newly\n   generated RTP stream.  The SSRCs of the to-be-mixed\
    \ streams on the\n   mixer input appear as the CSRCs at the mixer output.  That\
    \ output\n   stream uses a unique SSRC that identifies the mixer's stream.  The\n\
    \   CSRC should be forwarded between the different endpoints to allow for\n  \
    \ loop detection and identification of sources that are part of the\n   Communication\
    \ Session.  Note that Section 7.1 of RFC 3550 requires\n   the SSRC space to be\
    \ shared between domains for these reasons.  This\n   also implies that any SDES\
    \ information normally needs to be forwarded\n   across the mixer.\n   The mixer\
    \ is responsible for generating RTCP packets in accordance\n   with its role.\
    \  It is an RTP receiver and should therefore send RTCP\n   receiver reports for\
    \ the RTP streams it receives and terminates.  In\n   its role as an RTP sender,\
    \ it should also generate RTCP sender\n   reports for those RTP streams it sends.\
    \  As specified in Section 7.3\n   of RFC 3550, a mixer must not forward RTCP\
    \ unaltered between the two\n   domains.\n   The mixer depicted in Figure 13 is\
    \ involved in three domains that\n   need to be separated: the Any-Source Multicast\
    \ network (including\n   endpoints A and C), endpoint B, and endpoint D.  Assuming\
    \ all four\n   endpoints in the conference are interested in receiving content\
    \ from\n   all other endpoints, the mixer produces different mixed RTP streams\n\
    \   for B and D, as the one to B may contain content received from D, and\n  \
    \ vice versa.  However, the mixer may only need one SSRC per media type\n   in\
    \ each domain where it is the receiving entity and transmitter of\n   mixed content.\n\
    \   In the multicast domain, a mixer still needs to provide a mixed view\n   of\
    \ the other domains.  This makes the mixer simpler to implement and\n   avoids\
    \ any issues with advanced RTCP handling or loop detection,\n   which would be\
    \ problematic if the mixer were providing non-symmetric\n   behavior.  Please\
    \ see Section 3.11 for more discussion on this topic.\n   The mixing operation,\
    \ however, in each domain could potentially be\n   different.\n   A mixer is responsible\
    \ for receiving RTCP feedback messages and\n   handling them appropriately.  The\
    \ definition of \"appropriate\" depends\n   on the message itself and the context.\
    \  In some cases, the reception\n   of a codec-control message by the mixer may\
    \ result in the generation\n   and transmission of RTCP feedback messages by the\
    \ mixer to the\n   endpoints in the other domain(s).  In other cases, a message\
    \ is\n   handled by the mixer locally and therefore not forwarded to any other\n\
    \   domain.\n   When replacing the multicast network in Figure 13 (to the left\
    \ of the\n   mixer) with individual unicast paths as depicted in Figure 14, the\n\
    \   mixer model is very similar to the one discussed in Section 3.9\n   below.\
    \  Please see the discussion in Section 3.9 about the\n   differences between\
    \ these two models.\n                   +---+      +------------+      +---+\n\
    \                   | A |<---->|            |<---->| B |\n                   +---+\
    \      |            |      +---+\n                              |   Mixer    |\n\
    \                   +---+      |            |      +---+\n                   |\
    \ C |<---->|            |<---->| D |\n                   +---+      +------------+\
    \      +---+\n               Figure 14: RTP Mixer with Only Unicast Paths\n  \
    \ We now discuss in more detail the different mixing operations that a\n   mixer\
    \ can perform and how they can affect RTP and RTCP behavior.\n"
- title: 3.6.1.  Media-Mixing Mixer
  contents:
  - "3.6.1.  Media-Mixing Mixer\n   The Media-Mixing Mixer is likely the one that\
    \ most think of when they\n   hear the term \"mixer\".  Its basic mode of operation\
    \ is that it\n   receives RTP streams from several endpoints and selects the stream(s)\n\
    \   to be included in a media-domain mix.  The selection can be through\n   static\
    \ configuration or by dynamic, content-dependent means such as\n   voice activation.\
    \  The mixer then creates a single outgoing RTP\n   stream from this mix.\n  \
    \ The most commonly deployed Media-Mixing Mixer is probably the audio\n   mixer,\
    \ used in voice conferencing, where the output consists of a\n   mixture of all\
    \ the input audio signals; this needs minimal signaling\n   to be successfully\
    \ set up.  From a signal processing viewpoint, audio\n   mixing is relatively\
    \ straightforward and commonly possible for a\n   reasonable number of endpoints.\
    \  Assume, for example, that one wants\n   to mix N streams from N different endpoints.\
    \  The mixer needs to\n   decode those N streams, typically into the sample domain,\
    \ and then\n   produce N or N+1 mixes.  Different mixes are needed so that each\n\
    \   endpoint gets a mix of all other sources except its own, as this\n   would\
    \ result in an echo.  When N is lower than the number of all\n   endpoints, one\
    \ may produce a mix of all N streams for the group that\n   are currently not\
    \ included in the mix; thus, N+1 mixes.  These audio\n   streams are then encoded\
    \ again, RTP packetized, and sent out.  In\n   many cases, audio level normalization,\
    \ noise suppression, and similar\n   signal processing steps are also required\
    \ or desirable before the\n   actual mixing process commences.\n   In video, the\
    \ term \"mixing\" has a different interpretation than\n   audio.  It is commonly\
    \ used to refer to the process of spatially\n   combining contributed video streams,\
    \ which is also known as \"tiling\".\n   The reconstructed, appropriately scaled\
    \ down videos can be spatially\n   arranged in a set of tiles, with each tile\
    \ containing the video from\n   an endpoint (typically showing a human participant).\
    \  Tiles can be of\n   different sizes so that, for example, a particularly important\n\
    \   participant, or the loudest speaker, is being shown in a larger tile\n   than\
    \ other participants.  A self-view picture can be included in the\n   tiling,\
    \ which can be either locally produced or feedback from a\n   mixer-received and\
    \ reconstructed video image.  Such remote loopback\n   allows for confidence monitoring,\
    \ i.e., it enables the participant to\n   see himself/herself in the same quality\
    \ as other participants see\n   him/her.  The tiling normally operates on reconstructed\
    \ video in the\n   sample domain.  The tiled image is encoded, packetized, and\
    \ sent by\n   the mixer to the receiving endpoints.  It is possible that a\n \
    \  middlebox with media mixing duties contains only a single mixer of\n   the\
    \ aforementioned type, in which case all participants necessarily\n   see the\
    \ same tiled video, even if it is being sent over different RTP\n   streams. \
    \ More common, however, are mixing arrangements where an\n   individual mixer\
    \ is available for each outgoing port of the\n   middlebox, allowing individual\
    \ compositions for each receiving\n   endpoint (a feature commonly referred to\
    \ as personalized layout).\n   One problem with media mixing is that it consumes\
    \ both large amounts\n   of media processing resources (for the decoding and mixing\
    \ process in\n   the uncompressed domain) and encoding resources (for the encoding\
    \ of\n   the mixed signal).  Another problem is the quality degradation\n   created\
    \ by decoding and re-encoding the media, which is the result of\n   the lossy\
    \ nature of the most commonly used media codecs.  A third\n   problem is the latency\
    \ introduced by the media mixing, which can be\n   substantial and annoyingly\
    \ noticeable in case of video, or in case of\n   audio if that mixed audio is\
    \ lip-synchronized with high-latency\n   video.  The advantage of media mixing\
    \ is that it is straightforward\n   for the endpoints to handle the single media\
    \ stream (which includes\n   the mixed aggregate of many sources), as they don't\
    \ need to handle\n   multiple decodings, local mixing, and composition.  In fact,\
    \ mixers\n   were introduced in pre-RTP times so that legacy, single stream\n\
    \   receiving endpoints (that, in some protocol environments, actually\n   didn't\
    \ need to be aware of the multipoint nature of the conference)\n   could successfully\
    \ participate in what a user would recognize as a\n   multiparty video conference.\n\
    \           +-A---------+          +-MIXER----------------------+\n          \
    \ | +-RTP1----|          |-RTP1------+        +-----+ |\n           | | +-Audio-|\
    \          |-Audio---+ | +---+  |     | |\n           | | |    AA1|--------->|---------+-+-|DEC|->|\
    \     | |\n           | | |       |<---------|MA1 <----+ | +---+  |     | |\n\
    \           | | |       |          |(BA1+CA1)|\\| +---+  |     | |\n         \
    \  | | +-------|          |---------+ +-|ENC|<-| B+C | |\n           | +---------|\
    \          |-----------+ +---+  |     | |\n           +-----------+          |\
    \                    |     | |\n                                  |          \
    \          |  M  | |\n           +-B---------+          |                    |\
    \  E  | |\n           | +-RTP2----|          |-RTP2------+        |  D  | |\n\
    \           | | +-Audio-|          |-Audio---+ | +---+  |  I  | |\n          \
    \ | | |    BA1|--------->|---------+-+-|DEC|->|  A  | |\n           | | |    \
    \   |<---------|MA2 <----+ | +---+  |     | |\n           | | +-------|      \
    \    |(AA1+CA1)|\\| +---+  |     | |\n           | +---------|          |---------+\
    \ +-|ENC|<-| A+C | |\n           +-----------+          |-----------+ +---+  |\
    \     | |\n                                  |                    |  M  | |\n\
    \           +-C---------+          |                    |  I  | |\n          \
    \ | +-RTP3----|          |-RTP3------+        |  X  | |\n           | | +-Audio-|\
    \          |-Audio---+ | +---+  |  E  | |\n           | | |    CA1|--------->|---------+-+-|DEC|->|\
    \  R  | |\n           | | |       |<---------|MA3 <----+ | +---+  |     | |\n\
    \           | | +-------|          |(AA1+BA1)|\\| +---+  |     | |\n         \
    \  | +---------|          |---------+ +-|ENC|<-| A+B | |\n           +-----------+\
    \          |-----------+ +---+  +-----+ |\n                                  +----------------------------+\n\
    \            Figure 15: Session and SSRC Details for Media Mixer\n   From an RTP\
    \ perspective, media mixing can be a very simple process,\n   as can be seen in\
    \ Figure 15.  The mixer presents one SSRC towards the\n   receiving endpoint,\
    \ e.g., MA1 to Peer A, where the associated stream\n   is the media mix of the\
    \ other endpoints.  As each peer, in this\n   example, receives a different version\
    \ of a mix from the mixer, there\n   is no actual relation between the different\
    \ RTP sessions in terms of\n   actual media or transport-level information.  There\
    \ are, however,\n   common relationships between RTP1-RTP3, namely SSRC space\
    \ and\n   identity information.  When A receives the MA1 stream, which is a\n\
    \   combination of BA1 and CA1 streams, the mixer may include CSRC\n   information\
    \ in the MA1 stream to identify the Contributing Sources\n   BA1 and CA1, allowing\
    \ the receiver to identify the Contributing\n   Sources even if this were not\
    \ possible through the media itself or\n   through other signaling means.\n  \
    \ The CSRC has, in turn, utility in RTP extensions, like the RTP header\n   extension\
    \ for Mixer-to-Client Audio Level Indication [RFC6465].  If\n   the SSRCs from\
    \ the endpoint to mixer paths are used as CSRCs in\n   another RTP session, then\
    \ RTP1, RTP2, and RTP3 become one joint\n   session as they have a common SSRC\
    \ space.  At this stage, the mixer\n   also needs to consider which RTCP information\
    \ it needs to expose in\n   the different paths.  In the above scenario, a mixer\
    \ would normally\n   expose nothing more than the SDES information and RTCP BYE\
    \ for a CSRC\n   leaving the session.  The main goal would be to enable the correct\n\
    \   binding against the application logic and other information sources.\n   This\
    \ also enables loop detection in the RTP session.\n"
- title: 3.6.2.  Media-Switching Mixer
  contents:
  - "3.6.2.  Media-Switching Mixer\n   Media-Switching Mixers are used in limited\
    \ functionality scenarios\n   where no, or only very limited, concurrent presentation\
    \ of multiple\n   sources is required by the application and also in more complex\n\
    \   multi-stream usages with receiver mixing or tiling, including\n   combined\
    \ with simulcast and/or scalability between source and mixer.\n   An RTP mixer\
    \ based on media switching avoids the media decoding and\n   encoding operations\
    \ in the mixer, as it conceptually forwards the\n   encoded media stream as it\
    \ was being sent to the mixer.  It does not\n   avoid, however, the decryption\
    \ and re-encryption cycle as it rewrites\n   RTP headers.  Forwarding media (in\
    \ contrast to reconstructing-mixing-\n   encoding media) reduces the amount of\
    \ computational resources needed\n   in the mixer and increases the media quality\
    \ (both in terms of\n   fidelity and reduced latency).\n   A Media-Switching Mixer\
    \ maintains a pool of SSRCs representing\n   conceptual or functional RTP streams\
    \ that the mixer can produce.\n   These RTP streams are created by selecting media\
    \ from one of the RTP\n   streams received by the mixer and forwarded to the peer\
    \ using the\n   mixer's own SSRCs.  The mixer can switch between available sources\
    \ if\n   that is required by the concept for the source, like the currently\n\
    \   active speaker.  Note that the mixer, in most cases, still needs to\n   perform\
    \ a certain amount of media processing, as many media formats\n   do not allow\
    \ to \"tune into\" the stream at arbitrary points in their\n   bitstream.\n  \
    \ To achieve a coherent RTP stream from the mixer's SSRC, the mixer\n   needs\
    \ to rewrite the incoming RTP packet's header.  First, the SSRC\n   field must\
    \ be set to the value of the mixer's SSRC.  Second, the\n   sequence number must\
    \ be the next in the sequence of outgoing packets\n   it sent.  Third, the RTP\
    \ timestamp value needs to be adjusted using\n   an offset that changes each time\
    \ one switches the Media Source.\n   Finally, depending on the negotiation of\
    \ the RTP payload type, the\n   value representing this particular RTP payload\
    \ configuration may have\n   to be changed if the different endpoint-to-mixer\
    \ paths have not\n   arrived on the same numbering for a given configuration.\
    \  This also\n   requires that the different endpoints support a common set of\
    \ codecs,\n   otherwise media transcoding for codec compatibility would still\
    \ be\n   required.\n   We now consider the operation of a Media-Switching Mixer\
    \ that\n   supports a video conference with six participating endpoints (A-F)\n\
    \   where the two most recent speakers in the conference are shown to\n   each\
    \ receiving endpoint.  Thus, the mixer has two SSRCs sending video\n   to each\
    \ peer, and each peer is capable of locally handling two video\n   streams simultaneously.\n\
    \         +-A---------+             +-MIXER----------------------+\n         |\
    \ +-RTP1----|             |-RTP1------+        +-----+ |\n         | | +-Video-|\
    \             |-Video---+ |        |     | |\n         | | |    AV1|------------>|---------+-+------->|\
    \  S  | |\n         | | |       |<------------|MV1 <----+-+-BV1----|  W  | |\n\
    \         | | |       |<------------|MV2 <----+-+-EV1----|  I  | |\n         |\
    \ | +-------|             |---------+ |        |  T  | |\n         | +---------|\
    \             |-----------+        |  C  | |\n         +-----------+         \
    \    |                    |  H  | |\n                                   |    \
    \                |     | |\n         +-B---------+             |             \
    \       |  M  | |\n         | +-RTP2----|             |-RTP2------+        | \
    \ A  | |\n         | | +-Video-|             |-Video---+ |        |  T  | |\n\
    \         | | |    BV1|------------>|---------+-+------->|  R  | |\n         |\
    \ | |       |<------------|MV3 <----+-+-AV1----|  I  | |\n         | | |     \
    \  |<------------|MV4 <----+-+-EV1----|  X  | |\n         | | +-------|      \
    \       |---------+ |        |     | |\n         | +---------|             |-----------+\
    \        |     | |\n         +-----------+             |                    |\
    \     | |\n                                   :                    :     : :\n\
    \                                   :                    :     : :\n         +-F---------+\
    \             |                    |     | |\n         | +-RTP6----|         \
    \    |-RTP6------+        |     | |\n         | | +-Video-|             |-Video---+\
    \ |        |     | |\n         | | |    FV1|------------>|---------+-+------->|\
    \     | |\n         | | |       |<------------|MV11 <---+-+-AV1----|     | |\n\
    \         | | |       |<------------|MV12 <---+-+-EV1----|     | |\n         |\
    \ | +-------|             |---------+ |        |     | |\n         | +---------|\
    \             |-----------+        +-----+ |\n         +-----------+         \
    \    +----------------------------+\n                   Figure 16: Media-Switching\
    \ RTP Mixer\n   The Media-Switching Mixer can, similarly to the Media-Mixing Mixer,\n\
    \   reduce the bitrate required for media transmission towards the\n   different\
    \ peers by selecting and forwarding only a subset of RTP\n   streams it receives\
    \ from the sending endpoints.  In case the mixer\n   receives simulcast transmissions\
    \ or a scalable encoding of the Media\n   Source, the mixer has more degrees of\
    \ freedom to select streams or\n   subsets of streams to forward to a receiving\
    \ endpoint, both based on\n   transport or endpoint restrictions as well as application\
    \ logic.\n   To ensure that a media receiver in an endpoint can correctly decode\n\
    \   the media in the RTP stream after a switch, a codec that uses\n   temporal\
    \ prediction needs to start its decoding from independent\n   refresh points,\
    \ or points in the bitstream offering similar\n   functionality (like \"dirty\
    \ refresh points\").  For some codecs, for\n   example, frame-based speech and\
    \ audio codecs, this is easily achieved\n   by starting the decoding at RTP packet\
    \ boundaries, as each packet\n   boundary provides a refresh point (assuming proper\
    \ packetization on\n   the encoder side).  For other codecs, particularly in video,\
    \ refresh\n   points are less common in the bitstream or may not be present at\
    \ all\n   without an explicit request to the respective encoder.  The Full\n \
    \  Intra Request [RFC5104] RTCP codec control message has been defined\n   for\
    \ this purpose.\n   In this type of mixer, one could consider fully terminating\
    \ the RTP\n   sessions between the different endpoint and mixer paths.  The same\n\
    \   arguments and considerations as discussed in Section 3.9 need to be\n   taken\
    \ into consideration and apply here.\n"
- title: 3.7.  Selective Forwarding Middlebox
  contents:
  - "3.7.  Selective Forwarding Middlebox\n   Another method for handling media in\
    \ the RTP mixer is to \"project\",\n   or make available, all potential RTP sources\
    \ (SSRCs) into a per-\n   endpoint, independent RTP session.  The middlebox can\
    \ select which of\n   the potential sources that are currently actively transmitting\
    \ media\n   will be sent to each of the endpoints.  This is similar to the Media-\n\
    \   Switching Mixer but has some important differences in RTP details.\n     \
    \     +-A---------+             +-Middlebox-----------------+\n          | +-RTP1----|\
    \             |-RTP1------+       +-----+ |\n          | | +-Video-|         \
    \    |-Video---+ |       |     | |\n          | | |    AV1|------------>|---------+-+------>|\
    \     | |\n          | | |       |<------------|BV1 <----+-+-------|  S  | |\n\
    \          | | |       |<------------|CV1 <----+-+-------|  W  | |\n         \
    \ | | |       |<------------|DV1 <----+-+-------|  I  | |\n          | | |   \
    \    |<------------|EV1 <----+-+-------|  T  | |\n          | | |       |<------------|FV1\
    \ <----+-+-------|  C  | |\n          | | +-------|             |---------+ |\
    \       |  H  | |\n          | +---------|             |-----------+       | \
    \    | |\n          +-----------+             |                   |  M  | |\n\
    \                                    |                   |  A  | |\n         \
    \ +-B---------+             |                   |  T  | |\n          | +-RTP2----|\
    \             |-RTP2------+       |  R  | |\n          | | +-Video-|         \
    \    |-Video---+ |       |  I  | |\n          | | |    BV1|------------>|---------+-+------>|\
    \  X  | |\n          | | |       |<------------|AV1 <----+-+-------|     | |\n\
    \          | | |       |<------------|CV1 <----+-+-------|     | |\n         \
    \ | | |       | :    :    : |: :  : : : : :  : :|     | |\n          | | |   \
    \    |<------------|FV1 <----+-+-------|     | |\n          | | +-------|    \
    \         |---------+ |       |     | |\n          | +---------|             |-----------+\
    \       |     | |\n          +-----------+             |                   | \
    \    | |\n                                    :                   :     : :\n\
    \                                    :                   :     : :\n         \
    \ +-F---------+             |                   |     | |\n          | +-RTP6----|\
    \             |-RTP6------+       |     | |\n          | | +-Video-|         \
    \    |-Video---+ |       |     | |\n          | | |    FV1|------------>|---------+-+------>|\
    \     | |\n          | | |       |<------------|AV1 <----+-+-------|     | |\n\
    \          | | |       | :    :    : |: :  : : : : :  : :|     | |\n         \
    \ | | |       |<------------|EV1 <----+-+-------|     | |\n          | | +-------|\
    \             |---------+ |       |     | |\n          | +---------|         \
    \    |-----------+       +-----+ |\n          +-----------+             +---------------------------+\n\
    \                 Figure 17: Selective Forwarding Middlebox\n   In the six endpoint\
    \ conference depicted above (in Figure 17), one can\n   see that endpoint A is\
    \ aware of five incoming SSRCs, BV1-FV1.  If\n   this middlebox intends to have\
    \ a similar behavior as in Section 3.6.2\n   where the mixer provides the endpoints\
    \ with the two latest speaking\n   endpoints, then only two out of these five\
    \ SSRCs need concurrently\n   transmit media to A.  As the middlebox selects the\
    \ source in the\n   different RTP sessions that transmit media to the endpoints,\
    \ each RTP\n   stream requires the rewriting of certain RTP header fields when\
    \ being\n   projected from one session into another.  In particular, the sequence\n\
    \   number needs to be consecutively incremented based on the packet\n   actually\
    \ being transmitted in each RTP session.  Therefore, the RTP\n   sequence number\
    \ offset will change each time a source is turned on in\n   an RTP session.  The\
    \ timestamp (possibly offset) stays the same.\n   The RTP sessions can be considered\
    \ independent, resulting in that the\n   SSRC numbers used can also be handled\
    \ independently.  This simplifies\n   the SSRC collision detection and avoidance\
    \ but requires tools such as\n   remapping tables between the RTP sessions.  Using\
    \ independent RTP\n   sessions is not required, as it is possible for the switching\n\
    \   behavior to also perform with a common SSRC space.  However, in this\n   case,\
    \ collision detection and handling becomes a different problem.\n   It is up to\
    \ the implementation to use a single common SSRC space or\n   separate ones.\n\
    \   Using separate SSRC spaces has some implications.  For example, the\n   RTP\
    \ stream that is being sent by endpoint B to the middlebox (BV1)\n   may use an\
    \ SSRC value of 12345678.  When that RTP stream is sent to\n   endpoint F by the\
    \ middlebox, it can use any SSRC value, e.g.,\n   87654321.  As a result, each\
    \ endpoint may have a different view of\n   the application usage of a particular\
    \ SSRC.  Any RTP-level identity\n   information, such as SDES items, also needs\
    \ to update the SSRC\n   referenced, if the included SDES items are intended to\
    \ be global.\n   Thus, the application must not use SSRC as references to RTP\
    \ streams\n   when communicating with other peers directly.  This also affects\
    \ loop\n   detection, which will fail to work as there is no common namespace\n\
    \   and identities across the different legs in the Communication Session\n  \
    \ on the RTP level.  Instead, this responsibility falls onto higher\n   layers.\n\
    \   The middlebox is also responsible for receiving any RTCP codec\n   control\
    \ requests coming from an endpoint and deciding if it can act\n   on the request\
    \ locally or needs to translate the request into the RTP\n   session/transport\
    \ leg that contains the Media Source.  Both endpoints\n   and the middlebox need\
    \ to implement conference-related codec control\n   functionalities to provide\
    \ a good experience.  Commonly used are Full\n   Intra Request to request from\
    \ the Media Source that switching points\n   be provided between the sources and\
    \ Temporary Maximum Media Bitrate\n   Request (TMMBR) to enable the middlebox\
    \ to aggregate congestion\n   control responses towards the Media Source so to\
    \ enable it to adjust\n   its bitrate (obviously, only in case the limitation\
    \ is not in the\n   source to middlebox link).\n   The Selective Forwarding Middlebox\
    \ has been introduced in recently\n   developed videoconferencing systems in conjunction\
    \ with, and to\n   capitalize on, scalable video coding as well as simulcasting.\
    \  An\n   example of scalable video coding is Annex G of H.264, but other\n  \
    \ codecs, including H.264 AVC and VP8, also exhibit scalability, albeit\n   only\
    \ in the temporal dimension.  In both scalable coding and\n   simulcast cases,\
    \ the video signal is represented by a set of two or\n   more bitstreams, providing\
    \ a corresponding number of distinct\n   fidelity points.  The middlebox selects\
    \ which parts of a scalable\n   bitstream (or which bitstream, in the case of\
    \ simulcasting) to\n   forward to each of the receiving endpoints.  The decision\
    \ may be\n   driven by a number of factors, such as available bitrate, desired\n\
    \   layout, etc.  Contrary to transcoding MCUs, SFMs have extremely low\n   delay\
    \ and provide features that are typically associated with high-\n   end systems\
    \ (personalized layout, error localization) without any\n   signal processing\
    \ at the middlebox.  They are also capable of scaling\n   to a large number of\
    \ concurrent users, and--due to their very low\n   delay--can also be cascaded.\n\
    \   This version of the middlebox also puts different requirements on the\n  \
    \ endpoint when it comes to decoder instances and handling of the RTP\n   streams\
    \ providing media.  As each projected SSRC can, at any time,\n   provide media,\
    \ the endpoint either needs to be able to handle as many\n   decoder instances\
    \ as the middlebox received, or have efficient\n   switching of decoder contexts\
    \ in a more limited set of actual decoder\n   instances to cope with the switches.\
    \  The application also gets more\n   responsibility to update how the media provided\
    \ is to be presented to\n   the user.\n   Note that this topology could potentially\
    \ be seen as a Media\n   Translator that includes an on/off logic as part of its\
    \ media\n   translation.  The topology has the property that all SSRCs present\
    \ in\n   the session are visible to an endpoint.  It also has mixer aspects,\n\
    \   as the streams it provides are not basically translated versions, but\n  \
    \ instead they have conceptual property assigned to them and can be\n   both turned\
    \ on/off as well as fully or partially delivered.  Thus,\n   this topology appears\
    \ to be some hybrid between the translator and\n   mixer model.\n   The differences\
    \ between a Selective Forwarding Middlebox and a\n   Switching-Media Mixer (Section\
    \ 3.6.2) are minor, and they share most\n   properties.  The above requirement\
    \ on having a large number of\n   decoding instances or requiring efficient switching\
    \ of decoder\n   contexts, are one point of difference.  The other is how the\n\
    \   identification is performed, where the mixer uses CSRC to provide\n   information\
    \ on what is included in a particular RTP stream that\n   represents a particular\
    \ concept.  Selective forwarding gets the\n   source information through the SSRC\
    \ and instead uses other mechanisms\n   to indicate the streams intended usage,\
    \ if needed.\n"
- title: 3.8.  Point to Multipoint Using Video-Switching MCUs
  contents:
  - "3.8.  Point to Multipoint Using Video-Switching MCUs\n   Shortcut name: Topo-Video-switch-MCU\n\
    \                   +---+      +------------+      +---+\n                   |\
    \ A |------| Multipoint |------| B |\n                   +---+      |  Control\
    \   |      +---+\n                              |   Unit     |\n             \
    \      +---+      |   (MCU)    |      +---+\n                   | C |------| \
    \           |------| D |\n                   +---+      +------------+      +---+\n\
    \        Figure 18: Point to Multipoint Using a Video-Switching MCU\n   This PtM\
    \ topology was popular in early implementations of multipoint\n   videoconferencing\
    \ systems due to its simplicity, and the\n   corresponding middlebox design has\
    \ been known as a \"video-switching\n   MCU\".  The more complex RTCP-terminating\
    \ MCUs, discussed in the next\n   section, became the norm, however, when technology\
    \ allowed\n   implementations at acceptable costs.\n   A video-switching MCU forwards\
    \ to a participant a single media\n   stream, selected from the available streams.\
    \  The criteria for\n   selection are often based on voice activity in the audio-visual\n\
    \   conference, but other conference management mechanisms (like\n   presentation\
    \ mode or explicit floor control) are known to exist as\n   well.\n   The video-switching\
    \ MCU may also perform media translation to modify\n   the content in bitrate,\
    \ encoding, or resolution.  However, it still\n   may indicate the original sender\
    \ of the content through the SSRC.  In\n   this case, the values of the CC and\
    \ CSRC fields are retained.\n   If not terminating RTP, the RTCP sender reports\
    \ are forwarded for the\n   currently selected sender.  All RTCP receiver reports\
    \ are freely\n   forwarded between the endpoints.  In addition, the MCU may also\n\
    \   originate RTCP control traffic in order to control the session and/or\n  \
    \ report on status from its viewpoint.\n   The video-switching MCU has most of\
    \ the attributes of a translator.\n   However, its stream selection is a mixing\
    \ behavior.  This behavior\n   has some RTP and RTCP issues associated with it.\
    \  The suppression of\n   all but one RTP stream results in most participants\
    \ seeing only a\n   subset of the sent RTP streams at any given time, often a\
    \ single RTP\n   stream per conference.  Therefore, RTCP receiver reports only\
    \ report\n   on these RTP streams.  Consequently, the endpoints emitting RTP\n\
    \   streams that are not currently forwarded receive a view of the\n   session\
    \ that indicates their RTP streams disappear somewhere en\n   route.  This makes\
    \ the use of RTCP for congestion control, or any\n   type of quality reporting,\
    \ very problematic.\n   To avoid the aforementioned issues, the MCU needs to implement\
    \ two\n   features.  First, it needs to act as a mixer (see Section 3.6) and\n\
    \   forward the selected RTP stream under its own SSRC and with the\n   appropriate\
    \ CSRC values.  Second, the MCU needs to modify the RTCP\n   RRs it forwards between\
    \ the domains.  As a result, it is recommended\n   that one implement a centralized\
    \ video-switching conference using a\n   mixer according to RFC 3550, instead\
    \ of the shortcut implementation\n   described here.\n"
- title: 3.9.  Point to Multipoint Using RTCP-Terminating MCU
  contents:
  - "3.9.  Point to Multipoint Using RTCP-Terminating MCU\n   Shortcut name: Topo-RTCP-terminating-MCU\n\
    \                   +---+      +------------+      +---+\n                   |\
    \ A |<---->| Multipoint |<---->| B |\n                   +---+      |  Control\
    \   |      +---+\n                              |   Unit     |\n             \
    \      +---+      |   (MCU)    |      +---+\n                   | C |<---->| \
    \           |<---->| D |\n                   +---+      +------------+      +---+\n\
    \        Figure 19: Point to Multipoint Using Content Modifying MCUs\n   In this\
    \ PtM scenario, each endpoint runs an RTP point-to-point\n   session between itself\
    \ and the MCU.  This is a very commonly deployed\n   topology in multipoint video\
    \ conferencing.  The content that the MCU\n   provides to each participant is\
    \ either:\n   a.  a selection of the content received from the other endpoints\
    \ or\n   b.  the mixed aggregate of what the MCU receives from the other PtP\n\
    \       paths, which are part of the same Communication Session.\n   In case (a),\
    \ the MCU may modify the content in terms of bitrate,\n   encoding format, or\
    \ resolution.  No explicit RTP mechanism is used to\n   establish the relationship\
    \ between the original RTP stream of the\n   media being sent and the RTP stream\
    \ the MCU sends.  In other words,\n   the outgoing RTP streams typically use a\
    \ different SSRC, and may well\n   use a different payload type (PT), even if\
    \ this different PT happens\n   to be mapped to the same media type.  This is\
    \ a result of the\n   individually negotiated RTP session for each endpoint.\n\
    \   In case (b), the MCU is the Media Source and generates the Source RTP\n  \
    \ Stream as it mixes the received content and then encodes and\n   packetizes\
    \ it for transmission to an endpoint.  According to RTP\n   [RFC3550], the SSRC\
    \ of the contributors are to be signaled using the\n   CSRC/CC mechanism.  In\
    \ practice, today, most deployed MCUs do not\n   implement this feature.  Instead,\
    \ the identification of the endpoints\n   whose content is included in the mixer's\
    \ output is not indicated\n   through any explicit RTP mechanism.  That is, most\
    \ deployed MCUs set\n   the CC field in the RTP header to zero, thereby indicating\
    \ no\n   available CSRC information, even if they could identify the original\n\
    \   sending endpoints as suggested in RTP.\n   The main feature that sets this\
    \ topology apart from what RFC 3550\n   describes is the breaking of the common\
    \ RTP session across the\n   centralized device, such as the MCU.  This results\
    \ in the loss of\n   explicit RTP-level indication of all participants.  If one\
    \ were using\n   the mechanisms available in RTP and RTCP to signal this explicitly,\n\
    \   the topology would follow the approach of an RTP mixer.  The lack of\n   explicit\
    \ indication has at least the following potential problems:\n   1.  Loop detection\
    \ cannot be performed on the RTP level.  When\n       carelessly connecting two\
    \ misconfigured MCUs, a loop could be\n       generated.\n   2.  There is no information\
    \ about active media senders available in\n       the RTP packet.  As this information\
    \ is missing, receivers cannot\n       use it.  It also deprives the client of\
    \ information related to\n       currently active senders in a machine-usable\
    \ way, thus preventing\n       clients from indicating currently active speakers\
    \ in user\n       interfaces, etc.\n   Note that many/most deployed MCUs (and\
    \ video conferencing endpoints)\n   rely on signaling-layer mechanisms for the\
    \ identification of the\n   Contributing Sources, for example, a SIP conferencing\
    \ package\n   [RFC4575].  This alleviates, to some extent, the aforementioned\n\
    \   issues resulting from ignoring RTP's CSRC mechanism.\n"
- title: 3.10.  Split Component Terminal
  contents:
  - "3.10.  Split Component Terminal\n   Shortcut name: Topo-Split-Terminal\n   In\
    \ some applications, for example, in some telepresence systems,\n   terminals\
    \ may not be integrated into a single functional unit but\n   composed of more\
    \ than one subunits.  For example, a telepresence room\n   terminal employing\
    \ multiple cameras and monitors may consist of\n   multiple video conferencing\
    \ subunits, each capable of handling a\n   single camera and monitor.  Another\
    \ example would be a video\n   conferencing terminal in which audio is handled\
    \ by one subunit, and\n   video by another.  Each of these subunits uses its own\
    \ physical\n   network interface (for example: Ethernet jack) and network address.\n\
    \   The various (media processing) subunits need (logically and\n   physically)\
    \ to be interconnected by control functionality, but their\n   media plane functionality\
    \ may be split.  These types of terminals are\n   referred to as split component\
    \ terminals.  Historically, the earliest\n   split component terminals were perhaps\
    \ the independent audio and\n   video conference software tools used over the\
    \ MBONE in the late\n   1990s.\n   An example for such a split component terminal\
    \ is depicted in\n   Figure 20.  Within split component terminal A, at least audio\
    \ and\n   video subunits are addressed by their own network addresses.  In some\n\
    \   of these systems, the control stack subunit may also have its own\n   network\
    \ address.\n   From an RTP viewpoint, each of the subunits terminates RTP and\
    \ acts\n   as an endpoint in the sense that each subunit includes its own,\n \
    \  independent RTP stack.  However, as the subunits are semantically\n   part\
    \ of the same terminal, it is appropriate that this semantic\n   relationship\
    \ is expressed in RTCP protocol elements, namely in the\n   CNAME.\n         \
    \      +---------------------+\n               | Endpoint A          |\n     \
    \          | Local Area Network  |\n               |      +------------+ |\n \
    \              |   +->| Audio      |<+-RTP---\\\n               |   |  +------------+\
    \ |        \\    +------+\n               |   |  +------------+ |         +-->|\
    \      |\n               |   +->| Video      |<+-RTP-------->|  B   |\n      \
    \         |   |  +------------+ |         +-->|      |\n               |   | \
    \ +------------+ |        /    +------+\n               |   +->| Control    |<+-SIP---/\n\
    \               |      +------------+ |\n               +---------------------+\n\
    \                    Figure 20: Split Component Terminal\n   It is further sensible\
    \ that the subunits share a common clock from\n   which RTP and RTCP clocks are\
    \ derived, to facilitate synchronization\n   and avoid clock drift.\n   To indicate\
    \ that audio and video Source Streams generated by\n   different subunits share\
    \ a common clock, and can be synchronized, the\n   RTP streams generated from\
    \ those Source Streams need to include the\n   same CNAME in their RTCP SDES packets.\
    \  The use of a common CNAME for\n   RTP flows carried in different transport-layer\
    \ flows is entirely\n   normal for RTP and RTCP senders, and fully compliant RTP\
    \ endpoints,\n   middleboxes, and other tools should have no problem with this.\n\
    \   However, outside of the split component terminal scenario (and\n   perhaps\
    \ a multihomed endpoint scenario, which is not further\n   discussed herein),\
    \ the use of a common CNAME in RTP streams sent from\n   separate endpoints (as\
    \ opposed to a common CNAME for RTP streams sent\n   on different transport-layer\
    \ flows between two endpoints) is rare.\n   It has been reported that at least\
    \ some third-party tools like some\n   network monitors do not handle gracefully\
    \ endpoints that use a common\n   CNAME across multiple transport-layer flows:\
    \ they report an error\n   condition in which two separate endpoints are using\
    \ the same CNAME.\n   Depending on the sophistication of the support staff, such\
    \ erroneous\n   reports can lead to support issues.\n   The aforementioned support\
    \ issue can sometimes be avoided if each of\n   the subunits of a split component\
    \ terminal is configured to use a\n   different CNAME, with the synchronization\
    \ between the RTP streams\n   being indicated by some non-RTP signaling channel\
    \ rather than using a\n   common CNAME sent in RTCP.  This complicates the signaling,\n\
    \   especially in cases where there are multiple SSRCs in use with\n   complex\
    \ synchronization requirements, as is the same in many current\n   telepresence\
    \ systems.  Unless one uses RTCP terminating topologies\n   such as Topo-RTCP-terminating-MCU,\
    \ sessions involving more than one\n   video subunit with a common CNAME are close\
    \ to unavoidable.\n   The different RTP streams comprising a split terminal system\
    \ can form\n   a single RTP session or they can form multiple RTP sessions,\n\
    \   depending on the visibility of their SSRC values in RTCP reports.  If\n  \
    \ the receiver of the RTP streams sent by the split terminal sends\n   reports\
    \ relating to all of the RTP flows (i.e., to each SSRC) in each\n   RTCP report,\
    \ then a single RTP session is formed.  Alternatively, if\n   the receiver of\
    \ the RTP streams sent by the split terminal does not\n   send cross-reports in\
    \ RTCP, then the audio and video form separate\n   RTP sessions.\n   For example,\
    \ in Figure 20, B will send RTCP reports to each of the\n   subunits of A.  If\
    \ the RTCP packets that B sends to the audio subunit\n   of A include reports\
    \ on the reception quality of the video as well as\n   the audio, and similarly\
    \ if the RTCP packets that B sends to the\n   video subunit of A include reports\
    \ on the reception quality of the\n   audio as well as video, then a single RTP\
    \ session is formed.\n   However, if the RTCP packets B sends to the audio subunit\
    \ of A only\n   report on the received audio, and the RTCP packets B sends to\
    \ the\n   video subunit of A only report on the received video, then there are\n\
    \   two separate RTP sessions.\n   Forming a single RTP session across the RTP\
    \ streams sent by the\n   different subunits of a split terminal gives each subunit\
    \ visibility\n   into reception quality of RTP streams sent by the other subunits.\n\
    \   This information can help diagnose reception quality problems, but at\n  \
    \ the cost of increased RTCP bandwidth use.\n   RTP streams sent by the subunits\
    \ of a split terminal need to use the\n   same CNAME in their RTCP packets if\
    \ they are to be synchronized,\n   irrespective of whether a single RTP session\
    \ is formed or not.\n"
- title: 3.11.  Non-symmetric Mixer/Translators
  contents:
  - "3.11.  Non-symmetric Mixer/Translators\n   Shortcut name: Topo-Asymmetric\n \
    \  It is theoretically possible to construct an MCU that is a mixer in\n   one\
    \ direction and a translator in another.  The main reason to\n   consider this\
    \ would be to allow topologies similar to Figure 13,\n   where the mixer does\
    \ not need to mix in the direction from B or D\n   towards the multicast domains\
    \ with A and C.  Instead, the RTP streams\n   from B and D are forwarded without\
    \ changes.  Avoiding this mixing\n   would save media processing resources that\
    \ perform the mixing in\n   cases where it isn't needed.  However, there would\
    \ still be a need to\n   mix B's media towards D.  Only in the direction B ->\
    \ multicast domain\n   or D -> multicast domain would it be possible to work as\
    \ a\n   translator.  In all other directions, it would function as a mixer.\n\
    \   The mixer/translator would still need to process and change the RTCP\n   before\
    \ forwarding it in the directions of B or D to the multicast\n   domain.  One\
    \ issue is that A and C do not know about the mixed-media\n   stream the mixer\
    \ sends to either B or D.  Therefore, any reports\n   related to these streams\
    \ must be removed.  Also, receiver reports\n   related to A's and C's RTP streams\
    \ would be missing.  To avoid A and\n   C thinking that B and D aren't receiving\
    \ A and C at all, the mixer\n   needs to insert locally generated reports reflecting\
    \ the situation\n   for the streams from A and C into B's and D's sender reports.\
    \  In the\n   opposite direction, the receiver reports from A and C about B's\
    \ and\n   D's streams also need to be aggregated into the mixer's receiver\n \
    \  reports sent to B and D.  Since B and D only have the mixer as source\n   for\
    \ the stream, all RTCP from A and C must be suppressed by the\n   mixer.\n   This\
    \ topology is so problematic, and it is so easy to get the RTCP\n   processing\
    \ wrong, that it is not recommended for implementation.\n"
- title: 3.12.  Combining Topologies
  contents:
  - "3.12.  Combining Topologies\n   Topologies can be combined and linked to each\
    \ other using mixers or\n   translators.  However, care must be taken in handling\
    \ the SSRC/CSRC\n   space.  A mixer does not forward RTCP from sources in other\
    \ domains,\n   but instead generates its own RTCP packets for each domain it mixes\n\
    \   into, including the necessary SDES information for both the CSRCs and\n  \
    \ the SSRCs.  Thus, in a mixed domain, the only SSRCs seen will be the\n   ones\
    \ present in the domain, while there can be CSRCs from all the\n   domains connected\
    \ together with a combination of mixers and\n   translators.  The combined SSRC\
    \ and CSRC space is common over any\n   translator or mixer.  It is important\
    \ to facilitate loop detection,\n   something that is likely to be even more important\
    \ in combined\n   topologies due to the mixed behavior between the domains.  Any\n\
    \   hybrid, like the Topo-Video-switch-MCU or Topo-Asymmetric, requires\n   considerable\
    \ thought on how RTCP is dealt with.\n"
- title: 4.  Topology Properties
  contents:
  - "4.  Topology Properties\n   The topologies discussed in Section 3 have different\
    \ properties.\n   This section describes these properties.  Note that, even if\
    \ a\n   certain property is supported within a particular topology concept,\n\
    \   the necessary functionality may be optional to implement.\n"
- title: 4.1.  All-to-All Media Transmission
  contents:
  - "4.1.  All-to-All Media Transmission\n   To recapitulate, multicast, and in particular\
    \ ASM, provides the\n   functionality that everyone may send to, or receive from,\
    \ everyone\n   else within the session.  SSM can provide a similar functionality\
    \ by\n   having anyone intending to participate as a sender to send its media\n\
    \   to the SSM Distribution Source.  The SSM Distribution Source forwards\n  \
    \ the media to all receivers subscribed to the multicast group.  Mesh,\n   MCUs,\
    \ mixers, Selective Forwarding Middleboxes (SFMs), and\n   translators may all\
    \ provide that functionality at least on some basic\n   level.  However, there\
    \ are some differences in which type of\n   reachability they provide.\n   The\
    \ topologies that come closest to emulating Any-Source IP\n   Multicast, with\
    \ all-to-all transmission capabilities, are the\n   Transport Translator function\
    \ called \"relay\" in Section 3.5, as well\n   as the Mesh with joint RTP sessions\
    \ (Section 3.4).  Media\n   Translators, Mesh with independent RTP Sessions, mixers,\
    \ SFUs, and\n   the MCU variants do not provide a fully meshed forwarding on the\n\
    \   transport level; instead, they only allow limited forwarding of\n   content\
    \ from the other session participants.\n   The \"all-to-all media transmission\"\
    \ requires that any media\n   transmitting endpoint considers the path to the\
    \ least-capable\n   receiving endpoint.  Otherwise, the media transmissions may\
    \ overload\n   that path.  Therefore, a sending endpoint needs to monitor the\
    \ path\n   from itself to any of the receiving endpoints, to detect the\n   currently\
    \ least-capable receiver and adapt its sending rate\n   accordingly.  As multiple\
    \ endpoints may send simultaneously, the\n   available resources may vary.  RTCP's\
    \ receiver reports help perform\n   this monitoring, at least on a medium time\
    \ scale.\n   The resource consumption for performing all-to-all transmission\n\
    \   varies depending on the topology.  Both ASM and SSM have the benefit\n   that\
    \ only one copy of each packet traverses a particular link.  Using\n   a relay\
    \ causes the transmission of one copy of a packet per\n   endpoint-to-relay path\
    \ and packet transmitted.  However, in most\n   cases, the links carrying the\
    \ multiple copies will be the ones close\n   to the relay (which can be assumed\
    \ to be part of the network\n   infrastructure with good connectivity to the backbone)\
    \ rather than\n   the endpoints (which may be behind slower access links).  The\
    \ Mesh\n   topologies causes N-1 streams of transmitted packets to traverse the\n\
    \   first-hop link from the endpoint, in a mesh with N endpoints.  How\n   long\
    \ the different paths are common is highly situation dependent.\n   The transmission\
    \ of RTCP by design adapts to any changes in the\n   number of participants due\
    \ to the transmission algorithm, defined in\n   the RTP specification [RFC3550],\
    \ and the extensions in AVPF [RFC4585]\n   (when applicable).  That way, the resources\
    \ utilized for RTCP stay\n   within the bounds configured for the session.\n"
- title: 4.2.  Transport or Media Interoperability
  contents:
  - "4.2.  Transport or Media Interoperability\n   All translators, mixers, RTCP-terminating\
    \ MCUs, and Mesh with\n   individual RTP sessions allow changing the media encoding\
    \ or the\n   transport to other properties of the other domain, thereby providing\n\
    \   extended interoperability in cases where the endpoints lack a common\n   set\
    \ of media codecs and/or transport protocols.  Selective Forwarding\n   Middleboxes\
    \ can adopt the transport and (at least) selectively\n   forward the encoded streams\
    \ that match a receiving endpoint's\n   capability.  It requires an additional\
    \ translator to change the media\n   encoding if the encoded streams do not match\
    \ the receiving endpoint's\n   capabilities.\n"
- title: 4.3.  Per-Domain Bitrate Adaptation
  contents:
  - "4.3.  Per-Domain Bitrate Adaptation\n   Endpoints are often connected to each\
    \ other with a heterogeneous set\n   of paths.  This makes congestion control\
    \ in a Point-to-Multipoint set\n   problematic.  In the ASM, SSM, Mesh with common\
    \ RTP session, and\n   Transport Relay scenarios, each individual sending endpoint\
    \ has to\n   adapt to the receiving endpoint behind the least-capable path,\n\
    \   yielding suboptimal quality for the endpoints behind the more capable\n  \
    \ paths.  This is no longer an issue when Media Translators, mixers,\n   SFMs,\
    \ or MCUs are involved, as each endpoint only needs to adapt to\n   the slowest\
    \ path within its own domain.  The translator, mixer, SFM,\n   or MCU topologies\
    \ all require their respective outgoing RTP streams\n   to adjust the bitrate,\
    \ packet rate, etc., to adapt to the least-\n   capable path in each of the other\
    \ domains.  That way one can avoid\n   lowering the quality to the least-capable\
    \ endpoint in all the domains\n   at the cost (complexity, delay, equipment) of\
    \ the mixer, SFM, or\n   translator, and potentially the media sender (multicast/layered\n\
    \   encoding and sending the different representations).\n"
- title: 4.4.  Aggregation of Media
  contents:
  - "4.4.  Aggregation of Media\n   In the all-to-all media property mentioned above\
    \ and provided by ASM,\n   SSM, Mesh with common RTP session, and relay, all simultaneous\
    \ media\n   transmissions share the available bitrate.  For endpoints with\n \
    \  limited reception capabilities, this may result in a situation where\n   even\
    \ a minimal, acceptable media quality cannot be accomplished,\n   because multiple\
    \ RTP streams need to share the same resources.  One\n   solution to this problem\
    \ is to use a mixer, or MCU, to aggregate the\n   multiple RTP streams into a\
    \ single one, where the single RTP stream\n   takes up less resources in terms\
    \ of bitrate.  This aggregation can be\n   performed according to different methods.\
    \  Mixing or selection are\n   two common methods.  Selection is almost always\
    \ possible and easy to\n   implement.  Mixing requires resources in the mixer\
    \ and may be\n   relatively easy and not impair the quality too badly (audio)\
    \ or quite\n   difficult (video tiling, which is not only computationally complex\n\
    \   but also reduces the pixel count per stream, with corresponding loss\n   in\
    \ perceptual quality).\n"
- title: 4.5.  View of All Session Participants
  contents:
  - "4.5.  View of All Session Participants\n   The RTP protocol includes functionality\
    \ to identify the session\n   participants through the use of the SSRC and CSRC\
    \ fields.  In\n   addition, it is capable of carrying some further identity information\n\
    \   about these participants using the RTCP SDES.  In topologies that\n   provide\
    \ a full all-to-all functionality, i.e., ASM, Mesh with common\n   RTP session,\
    \ and relay, a compliant RTP implementation offers the\n   functionality directly\
    \ as specified in RTP.  In topologies that do\n   not offer all-to-all communication,\
    \ it is necessary that RTCP is\n   handled correctly in domain bridging functions.\
    \  RTP includes\n   explicit specification text for translators and mixers, and\
    \ for SFMs\n   the required functionality can be derived from that text.  However,\n\
    \   the MCU described in Section 3.8 cannot offer the full functionality\n   for\
    \ session participant identification through RTP means.  The\n   topologies that\
    \ create independent RTP sessions per endpoint or pair\n   of endpoints, like\
    \ a Back-to-Back RTP session, MESH with independent\n   RTP sessions, and the\
    \ RTCP terminating MCU (Section 3.9), with an\n   exception of SFM, do not support\
    \ RTP-based identification of session\n   participants.  In all those cases, other\
    \ non-RTP-based mechanisms\n   need to be implemented if such knowledge is required\
    \ or desirable.\n   When it comes to SFM, the SSRC namespace is not necessarily\
    \ joint.\n   Instead, identification will require knowledge of SSRC/CSRC mappings\n\
    \   that the SFM performed; see Section 3.7.\n"
- title: 4.6.  Loop Detection
  contents:
  - "4.6.  Loop Detection\n   In complex topologies with multiple interconnected domains,\
    \ it is\n   possible to unintentionally form media loops.  RTP and RTCP support\n\
    \   detecting such loops, as long as the SSRC and CSRC identities are\n   maintained\
    \ and correctly set in forwarded packets.  Loop detection\n   will work in ASM,\
    \ SSM, Mesh with joint RTP session, and relay.  It is\n   likely that loop detection\
    \ works for the video-switching MCU,\n   Section 3.8, at least as long as it forwards\
    \ the RTCP between the\n   endpoints.  However, the Back-to-Back RTP sessions,\
    \ Mesh with\n   independent RTP sessions, and SFMs will definitely break the loop\n\
    \   detection mechanism.\n"
- title: 4.7.  Consistency between Header Extensions and RTCP
  contents:
  - "4.7.  Consistency between Header Extensions and RTCP\n   Some RTP header extensions\
    \ have relevance not only end to end but\n   also hop to hop, meaning at least\
    \ some of the middleboxes in the path\n   are aware of their potential presence\
    \ through signaling, intercept\n   and interpret such header extensions, and potentially\
    \ also rewrite or\n   generate them.  Modern header extensions generally follow\
    \ \"A General\n   Mechanism for RTP Header Extensions\" [RFC5285], which allows\
    \ for all\n   of the above.  Examples for such header extensions include the Media\n\
    \   ID (MID) in [SDP-BUNDLE].  At the time of writing, there was also a\n   proposal\
    \ for how to include some SDES into an RTP header extension\n   [RTCP-SDES].\n\
    \   When such header extensions are in use, any middlebox that\n   understands\
    \ it must ensure consistency between the extensions it sees\n   and/or generates\
    \ and the RTCP it receives and generates.  For\n   example, the MID of the bundle\
    \ is sent in an RTP header extension and\n   also in an RTCP SDES message.  This\
    \ apparent redundancy was\n   introduced as unaware middleboxes may choose to\
    \ discard RTP header\n   extensions.  Obviously, inconsistency between the MID\
    \ sent in the RTP\n   header extension and in the RTCP SDES message could lead\
    \ to\n   undesirable results, and, therefore, consistency is needed.\n   Middleboxes\
    \ unaware of the nature of a header extension, as specified\n   in [RFC5285],\
    \ are free to forward or discard header extensions.\n"
- title: 5.  Comparison of Topologies
  contents:
  - "5.  Comparison of Topologies\n   The table below attempts to summarize the properties\
    \ of the different\n   topologies.  The legend to the topology abbreviations are:\n\
    \   Topo-Point-to-Point (PtP), Topo-ASM (ASM), Topo-SSM (SSM), Topo-Trn-\n   Translator\
    \ (TT), Topo-Media-Translator (including Transport\n   Translator) (MT), Topo-Mesh\
    \ with joint session (MJS), Topo-Mesh with\n   individual sessions (MIS), Topo-Mixer\
    \ (Mix), Topo-Asymmetric (ASY),\n   Topo-Video-switch-MCU (VSM), Topo-RTCP-terminating-MCU\
    \ (RTM), and\n   Selective Forwarding Middlebox (SFM).  In the table below, Y\n\
    \   indicates Yes or full support, N indicates No support, (Y) indicates\n   partial\
    \ support, and N/A indicates not applicable.\n   Property             PtP  ASM\
    \ SSM  TT MT MJS MIS Mix ASY VSM RTM SFM\n   ---------------------------------------------------------------------\n\
    \   All-to-All Media      N    Y  (Y)  Y  Y   Y  (Y) (Y) (Y) (Y) (Y) (Y)\n   Interoperability\
    \      N/A  N   N   Y  Y   Y   Y   Y   Y   N   Y   Y\n   Per-Domain Adaptation\
    \ N/A  N   N   N  Y   N   Y   Y   Y   N   Y   Y\n   Aggregation of Media  N  \
    \  N   N   N  N   N   N   Y  (Y)  Y   Y   N\n   Full Session View     Y    Y \
    \  Y   Y  Y   Y   N   Y   Y  (Y)  N   Y\n   Loop Detection        Y    Y   Y \
    \  Y  Y   Y   N   Y   Y  (Y)  N   N\n   Please note that the Media Translator\
    \ also includes the Transport\n   Translator functionality.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   The use of mixers, SFMs, and translators has\
    \ impact on security and\n   the security functions used.  The primary issue is\
    \ that mixers, SFMs,\n   and translators modify packets, thus preventing the use\
    \ of integrity\n   and source authentication, unless they are trusted devices\
    \ that take\n   part in the security context, e.g., the device can send Secure\
    \ Real-\n   time Transport Protocol (SRTP) and Secure Real-time Transport Control\n\
    \   Protocol (SRTCP) [RFC3711] packets to endpoints in the Communication\n   Session.\
    \  If encryption is employed, the Media Translator, SFM, and\n   mixer need to\
    \ be able to decrypt the media to perform its function.\n   A Transport Translator\
    \ may be used without access to the encrypted\n   payload in cases where it translates\
    \ parts that are not included in\n   the encryption and integrity protection,\
    \ for example, IP address and\n   UDP port numbers in a media stream using SRTP\
    \ [RFC3711].  However, in\n   general, the translator, SFM, or mixer needs to\
    \ be part of the\n   signaling context and get the necessary security associations\
    \ (e.g.,\n   SRTP crypto contexts) established with its RTP session participants.\n\
    \   Including the mixer, SFM, and translator in the security context\n   allows\
    \ the entity, if subverted or misbehaving, to perform a number\n   of very serious\
    \ attacks as it has full access.  It can perform all\n   the attacks possible\
    \ (see RFC 3550 and any applicable profiles) as if\n   the media session were\
    \ not protected at all, while giving the\n   impression to the human session participants\
    \ that they are protected.\n   Transport Translators have no interactions with\
    \ cryptography that\n   work above the transport layer, such as SRTP, since that\
    \ sort of\n   translator leaves the RTP header and payload unaltered.  Media\n\
    \   Translators, on the other hand, have strong interactions with\n   cryptography,\
    \ since they alter the RTP payload.  A Media Translator\n   in a session that\
    \ uses cryptographic protection needs to perform\n   cryptographic processing\
    \ to both inbound and outbound packets.\n   A Media Translator may need to use\
    \ different cryptographic keys for\n   the inbound and outbound processing.  For\
    \ SRTP, different keys are\n   required, because an RFC 3550 Media Translator\
    \ leaves the SSRC\n   unchanged during its packet processing, and SRTP key sharing\
    \ is only\n   allowed when distinct SSRCs can be used to protect distinct packet\n\
    \   streams.\n   When the Media Translator uses different keys to process inbound\
    \ and\n   outbound packets, each session participant needs to be provided with\n\
    \   the appropriate key, depending on whether they are listening to the\n   translator\
    \ or the original source.  (Note that there is an\n   architectural difference\
    \ between RTP media translation, in which\n   participants can rely on the RTP\
    \ payload type field of a packet to\n   determine appropriate processing, and\
    \ cryptographically protected\n   media translation, in which participants must\
    \ use information that is\n   not carried in the packet.)\n   When using security\
    \ mechanisms with translators, SFMs, and mixers, it\n   is possible that the translator,\
    \ SFM, or mixer could create different\n   security associations for the different\
    \ domains they are working in.\n   Doing so has some implications:\n   First,\
    \ it might weaken security if the mixer/translator accepts a\n   weaker algorithm\
    \ or key in one domain rather than in another.\n   Therefore, care should be taken\
    \ that appropriately strong security\n   parameters are negotiated in all domains.\
    \  In many cases,\n   \"appropriate\" translates to \"similar\" strength.  If\
    \ a key-management\n   system does allow the negotiation of security parameters\
    \ resulting in\n   a different strength of the security, then this system should\
    \ notify\n   the participants in the other domains about this.\n   Second, the\
    \ number of crypto contexts (keys and security-related\n   state) needed (for\
    \ example, in SRTP [RFC3711]) may vary between\n   mixers, SFMs, and translators.\
    \  A mixer normally needs to represent\n   only a single SSRC per domain and therefore\
    \ needs to create only one\n   security association (SRTP crypto context) per\
    \ domain.  In contrast,\n   a translator needs one security association per participant\
    \ it\n   translates towards, in the opposite domain.  Considering Figure 11,\n\
    \   the translator needs two security associations towards the multicast\n   domain:\
    \ one for B and one for D.  It may be forced to maintain a set\n   of totally\
    \ independent security associations between itself and B and\n   D, respectively,\
    \ so as to avoid two-time pad occurrences.  These\n   contexts must also be capable\
    \ of handling all the sources present in\n   the other domains.  Hence, using\
    \ completely independent security\n   associations (for certain keying mechanisms)\
    \ may force a translator\n   to handle N*DM keys and related state, where N is\
    \ the total number of\n   SSRCs used over all domains and DM is the total number\
    \ of domains.\n   The ASM, SSM, Relay, and Mesh (with common RTP session) topologies\n\
    \   each have multiple endpoints that require shared knowledge about the\n   different\
    \ crypto contexts for the endpoints.  These multiparty\n   topologies have special\
    \ requirements on the key management as well as\n   the security functions.  Specifically,\
    \ source authentication in these\n   environments has special requirements.\n\
    \   There exist a number of different mechanisms to provide keys to the\n   different\
    \ participants.  One example is the choice between group keys\n   and unique keys\
    \ per SSRC.  The appropriate keying model is impacted\n   by the topologies one\
    \ intends to use.  The final security properties\n   are dependent on both the\
    \ topologies in use and the keying\n   mechanisms' properties and need to be considered\
    \ by the application.\n   Exactly which mechanisms are used is outside of the\
    \ scope of this\n   document.  Please review RTP Security Options [RFC7201] to\
    \ get a\n   better understanding of most of the available options.\n"
- title: 7.  References
  contents:
  - '7.  References

    '
- title: 7.1.  Normative References
  contents:
  - "7.1.  Normative References\n   [RFC3550]  Schulzrinne, H., Casner, S., Frederick,\
    \ R., and V.\n              Jacobson, \"RTP: A Transport Protocol for Real-Time\n\
    \              Applications\", STD 64, RFC 3550, DOI 10.17487/RFC3550,\n     \
    \         July 2003, <http://www.rfc-editor.org/info/rfc3550>.\n   [RFC4585] \
    \ Ott, J., Wenger, S., Sato, N., Burmeister, C., and J. Rey,\n              \"\
    Extended RTP Profile for Real-time Transport Control\n              Protocol (RTCP)-Based\
    \ Feedback (RTP/AVPF)\", RFC 4585,\n              DOI 10.17487/RFC4585, July 2006,\n\
    \              <http://www.rfc-editor.org/info/rfc4585>.\n   [RFC7656]  Lennox,\
    \ J., Gross, K., Nandakumar, S., Salgueiro, G., and\n              B. Burman,\
    \ Ed., \"A Taxonomy of Grouping Semantics and\n              Mechanisms for Real-Time\
    \ Transport Protocol (RTP)\n              Sources\", RFC 7656, November 2015,\n\
    \              <http://www.rfc-editor.org/info/rfc7656>.\n"
- title: 7.2.  Informative References
  contents:
  - "7.2.  Informative References\n   [MULTI-STREAM-OPT]\n              Lennox, J.,\
    \ Westerlund, M., Wu, W., and C. Perkins,\n              \"Sending Multiple Media\
    \ Streams in a Single RTP Session:\n              Grouping RTCP Reception Statistics\
    \ and Other Feedback\",\n              Work in Progress, draft-ietf-avtcore-rtp-multi-stream-\n\
    \              optimisation-08, October 2015.\n   [RFC1112]  Deering, S., \"Host\
    \ extensions for IP multicasting\", STD 5,\n              RFC 1112, DOI 10.17487/RFC1112,\
    \ August 1989,\n              <http://www.rfc-editor.org/info/rfc1112>.\n   [RFC3022]\
    \  Srisuresh, P. and K. Egevang, \"Traditional IP Network\n              Address\
    \ Translator (Traditional NAT)\", RFC 3022,\n              DOI 10.17487/RFC3022,\
    \ January 2001,\n              <http://www.rfc-editor.org/info/rfc3022>.\n   [RFC3569]\
    \  Bhattacharyya, S., Ed., \"An Overview of Source-Specific\n              Multicast\
    \ (SSM)\", RFC 3569, DOI 10.17487/RFC3569, July\n              2003, <http://www.rfc-editor.org/info/rfc3569>.\n\
    \   [RFC3711]  Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K.\n   \
    \           Norrman, \"The Secure Real-time Transport Protocol (SRTP)\",\n   \
    \           RFC 3711, DOI 10.17487/RFC3711, March 2004,\n              <http://www.rfc-editor.org/info/rfc3711>.\n\
    \   [RFC4575]  Rosenberg, J., Schulzrinne, H., and O. Levin, Ed., \"A\n      \
    \        Session Initiation Protocol (SIP) Event Package for\n              Conference\
    \ State\", RFC 4575, DOI 10.17487/RFC4575, August\n              2006, <http://www.rfc-editor.org/info/rfc4575>.\n\
    \   [RFC4607]  Holbrook, H. and B. Cain, \"Source-Specific Multicast for\n   \
    \           IP\", RFC 4607, DOI 10.17487/RFC4607, August 2006,\n             \
    \ <http://www.rfc-editor.org/info/rfc4607>.\n   [RFC5104]  Wenger, S., Chandra,\
    \ U., Westerlund, M., and B. Burman,\n              \"Codec Control Messages in\
    \ the RTP Audio-Visual Profile\n              with Feedback (AVPF)\", RFC 5104,\
    \ DOI 10.17487/RFC5104,\n              February 2008, <http://www.rfc-editor.org/info/rfc5104>.\n\
    \   [RFC5117]  Westerlund, M. and S. Wenger, \"RTP Topologies\", RFC 5117,\n \
    \             DOI 10.17487/RFC5117, January 2008,\n              <http://www.rfc-editor.org/info/rfc5117>.\n\
    \   [RFC5285]  Singer, D. and H. Desineni, \"A General Mechanism for RTP\n   \
    \           Header Extensions\", RFC 5285, DOI 10.17487/RFC5285, July\n      \
    \        2008, <http://www.rfc-editor.org/info/rfc5285>.\n   [RFC5760]  Ott, J.,\
    \ Chesterfield, J., and E. Schooler, \"RTP Control\n              Protocol (RTCP)\
    \ Extensions for Single-Source Multicast\n              Sessions with Unicast\
    \ Feedback\", RFC 5760,\n              DOI 10.17487/RFC5760, February 2010,\n\
    \              <http://www.rfc-editor.org/info/rfc5760>.\n   [RFC5766]  Mahy,\
    \ R., Matthews, P., and J. Rosenberg, \"Traversal Using\n              Relays\
    \ around NAT (TURN): Relay Extensions to Session\n              Traversal Utilities\
    \ for NAT (STUN)\", RFC 5766,\n              DOI 10.17487/RFC5766, April 2010,\n\
    \              <http://www.rfc-editor.org/info/rfc5766>.\n   [RFC6285]  Ver Steeg,\
    \ B., Begen, A., Van Caenegem, T., and Z. Vax,\n              \"Unicast-Based\
    \ Rapid Acquisition of Multicast RTP\n              Sessions\", RFC 6285, DOI\
    \ 10.17487/RFC6285, June 2011,\n              <http://www.rfc-editor.org/info/rfc6285>.\n\
    \   [RFC6465]  Ivov, E., Ed., Marocco, E., Ed., and J. Lennox, \"A Real-\n   \
    \           time Transport Protocol (RTP) Header Extension for Mixer-\n      \
    \        to-Client Audio Level Indication\", RFC 6465,\n              DOI 10.17487/RFC6465,\
    \ December 2011,\n              <http://www.rfc-editor.org/info/rfc6465>.\n  \
    \ [RFC7201]  Westerlund, M. and C. Perkins, \"Options for Securing RTP\n     \
    \         Sessions\", RFC 7201, DOI 10.17487/RFC7201, April 2014,\n          \
    \    <http://www.rfc-editor.org/info/rfc7201>.\n   [RTCP-SDES]\n             \
    \ Westerlund, M., Burman, B., Even, R., and M. Zanaty, \"RTP\n              Header\
    \ Extension for RTCP Source Description Items\", Work\n              in Progress,\
    \ draft-ietf-avtext-sdes-hdr-ext-02, July 2015.\n   [SDP-BUNDLE]\n           \
    \   Holmberg, C., Alvestrand, H., and C. Jennings,\n              \"Negotiating\
    \ Media Multiplexing Using the Session\n              Description Protocol (SDP)\"\
    , Work in Progress,\n              draft-ietf-mmusic-sdp-bundle-negotiation-23,\
    \ July 2015.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   The authors would like to thank Mark Baugher, Bo Burman,\
    \ Ben\n   Campbell, Umesh Chandra, Alex Eleftheriadis, Roni Even, Ladan Gharai,\n\
    \   Geoff Hunt, Suresh Krishnan, Keith Lantz, Jonathan Lennox, Scarlet\n   Liuyan,\
    \ Suhas Nandakumar, Colin Perkins, and Dan Wing for their help\n   in reviewing\
    \ and improving this document.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Magnus Westerlund\n   Ericsson\n   Farogatan 2\n   SE-164\
    \ 80 Kista\n   Sweden\n   Phone: +46 10 714 82 87\n   Email: magnus.westerlund@ericsson.com\n\
    \   Stephan Wenger\n   Vidyo\n   433 Hackensack Ave\n   Hackensack, NJ  07601\n\
    \   United States\n   Email: stewe@stewe.org\n"
