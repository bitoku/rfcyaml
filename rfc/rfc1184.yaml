- title: __initial_text__
  contents:
  - '                         Telnet Linemode Option

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo describes a Draft Standard for the Internet\
    \ community, and\n   requests discussion and suggestions for improvements.  This\
    \ RFC\n   specifies an IAB standards track protocol for the Internet community.\n\
    \   Please refer to the current edition of the \"IAB Official Protocol\n   Standards\"\
    \ for the standardization state and status of this protocol.\n   Distribution\
    \ of this memo is unlimited.\n"
- title: 'Changes from RFC1116:'
  contents:
  - "Changes from RFC1116:\n      Two new mode bits have been added, SOFT_TAB and\
    \ LIT_ECHO.  These\n      bits allow the server to give the client some advise\
    \ on how to\n      echo tabs and non-printable characters.\n      Several new\
    \ special character mappings have been added for cursor\n      motion when visual\
    \ editing is supported.  These are: Move cursor\n      one character left/right\
    \ (SLC_MCL/SLC_MCR), move cursor one word\n      left/right (SLC_MCWL/SLC_MCWR),\
    \ move cursor to begining/end of\n      line (SLC_MCBOL/SLC_MCEOL), enter insert/overstrike\
    \ mode\n      (SLC_INSRT/SLC_OVER), erase one character/word to the right\n  \
    \    (SLC_ECR/SLC_EWR), and erase to the beginning/end of the line\n      (SLC_EBOL/SLC_EEOL).\n"
- title: Overview
  contents:
  - "Overview\n   Linemode Telnet is a way of doing terminal character processing\
    \ on\n   the client side of a Telnet connection.  While in Linemode with\n   editing\
    \ enabled for the local side, network traffic is reduced to a\n   couple of packets\
    \ per command line, rather than a couple of packets\n   per character typed. This\
    \ is very useful for long delay networks,\n   because the user has local response\
    \ time while typing the command\n   line, and only incurs the network delays after\
    \ the command is typed.\n   It is also useful to reduce costs on networks that\
    \ charge on a per\n   packet basis.  Please send comments to the telnet-ietf@cray.com\n\
    \   mailing list.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.   Command Names and Codes                          \
    \              2\n   2.   Command Meanings                                   \
    \            3\n   2.1  The LINEMODE function                                \
    \          3\n   2.2  LINEMODE suboption MODE                                \
    \        4\n   2.3  LINEMODE suboption FORWARDMASK                           \
    \      5\n   2.4  LINEMODE suboption SLC, Set Local Characters               \
    \    6\n   2.5  New control characters                                       \
    \ 10\n   3.   Default Specification                                         11\n\
    \   4.   Motivation                                                    11\n  \
    \ 5.   Implementation Rules                                          13\n   5.1\
    \  User Interface                                                13\n   5.2  End\
    \ of line terminators                                       14\n   5.3  Output\
    \ processing                                             14\n   5.4  A terminal\
    \ driver in Telnet?                                  14\n   5.5  Setting of Local\
    \ Characters                                   14\n   5.6  FORWARDMASK and SLC_FORW1\
    \ and SLC_FORW2                       15\n   5.7  Valid and invalid modes and\
    \ values                            16\n   5.8  Flushing input and output    \
    \                                 16\n   5.9  State diagram for SLC          \
    \                               18\n   5.10 Example of a connection          \
    \                             19\n   6.   Other Telnet options and RFCs      \
    \                           22\n   7.   Security Considerations              \
    \                         23\n   8.   Author's Address                       \
    \                       23\n"
- title: 1.  Command Names and Codes
  contents:
  - "1.  Command Names and Codes\n       LINEMODE        34\n           MODE     \
    \        1\n               EDIT             1\n               TRAPSIG        \
    \  2\n               MODE_ACK         4\n               SOFT_TAB         8\n \
    \              LIT_ECHO        16\n           FORWARDMASK      2\n           SLC\
    \              3\n               SLC_SYNCH        1\n               SLC_BRK  \
    \        2\n               SLC_IP           3\n               SLC_AO         \
    \  4\n               SLC_AYT          5\n               SLC_EOR          6\n \
    \              SLC_ABORT        7\n               SLC_EOF          8\n       \
    \        SLC_SUSP         9\n               SLC_EC          10\n             \
    \  SLC_EL          11\n               SLC_EW          12\n               SLC_RP\
    \          13\n               SLC_LNEXT       14\n               SLC_XON     \
    \    15\n               SLC_XOFF        16\n               SLC_FORW1       17\n\
    \               SLC_FORW2       18\n               SLC_MCL         19\n      \
    \         SLC_MCR         20\n               SLC_MCWL        21\n            \
    \   SLC_MCWR        22\n               SLC_MCBOL       23\n               SLC_MCEOL\
    \       24\n               SLC_INSRT       25\n               SLC_OVER       \
    \ 26\n               SLC_ECR         27\n               SLC_EWR         28\n \
    \              SLC_EBOL        29\n               SLC_EEOL        30\n       \
    \        SLC_DEFAULT      3\n               SLC_VALUE        2\n             \
    \  SLC_CANTCHANGE   1\n               SLC_NOSUPPORT    0\n               SLC_LEVELBITS\
    \    3\n               SLC_ACK        128\n               SLC_FLUSHIN     64\n\
    \               SLC_FLUSHOUT    32\n       EOF            236\n       SUSP   \
    \        237\n       ABORT          238\n"
- title: 2.  Command Meanings
  contents:
  - '2.  Command Meanings

    '
- title: 2.1 The LINEMODE function
  contents:
  - "2.1 The LINEMODE function\n   IAC WILL LINEMODE\n      The sender of this command\
    \ REQUESTS permission to begin sub-\n      negotiation of the editing/signaling\
    \ status.  This should only be\n      sent by the client side of the connection.\n\
    \   IAC WONT LINEMODE\n      The sender of this command DEMANDS that sub-negotiation\
    \ of the\n      editing/signaling status not be allowed.\n   IAC DO LINEMODE\n\
    \      The sender of this command REQUESTS that the remote side begin\n      sub-negotiation\
    \ of the editing/signaling status.  This should only\n      be sent by the server\
    \ side of the connection.\n   IAC DONT LINEMODE\n      The sender of this command\
    \ DEMANDS that the remote side not begin\n      sub-negotiation of the editing/signaling\
    \ status.\n"
- title: 2.2 LINEMODE suboption MODE
  contents:
  - "2.2 LINEMODE suboption MODE\n   IAC SB LINEMODE MODE mask IAC SE\n      The sender\
    \ of this command CONFIRMS, or REQUESTS permission for, a\n      switch to the\
    \ mode defined by \"mask\".\n   The \"mask\" is a bit mask of various modes that\
    \ the connection can be\n   in.  Under normal operation, the server side of the\
    \ connection will\n   initiate mode changes, and the client will confirm the mode\
    \ changes.\n   The currently defined modes are:\n      EDIT     When set, the\
    \ client side of the connection should\n               process all input lines,\
    \ performing any editing functions,\n               and only send completed lines\
    \ to the remote side.  When\n               unset, client side should not process\
    \ any input from the\n               user, and the server side should take care\
    \ of all\n               character processing that needs to be done.\n      TRAPSIG\
    \  When set, the client side should translate appropriate\n               interrupts/signals\
    \ to their Telnet equivalent.  (These\n               would be IP, BRK, AYT, ABORT,\
    \ EOF, and SUSP) When unset,\n               the client should pass interrupts/signals\
    \ as their normal\n               ASCII values.\n      FLOW     Logically, this\
    \ belongs in the \"mask\".  However, this\n               would overlap the Telnet\
    \ TOGGLE-FLOW-CONTROL option, so\n               the Telnet TOGGLE-FLOW-CONTROL\
    \ option is used instead.\n               When DO/WILL LINEMODE is negotiated,\
    \ DO/WILL TOGGLE-\n               FLOW-CONTROL should also be negotiated.  See\
    \ RFC 1080,\n               \"Telnet Remote Flow Control\", for correct usage.\n\
    \      ECHO     Logically, this belongs in the \"mask\".  However, this\n    \
    \           would overlap the Telnet ECHO option, so the Telnet ECHO\n       \
    \        option is used instead.  The client side should never\n             \
    \  negotiate \"WILL ECHO\".  When the server has negotiated\n               \"\
    WILL ECHO\", the client should not echo data typed by the\n               user\
    \ back to the user.  When the server has negotiated\n               \"WONT ECHO\"\
    , the the client is responsible for echoing\n               data typed by the\
    \ user back to the user.  See RFC 857,\n               \"Telnet ECHO OPTION\"\
    \ for a complete discussion on the use\n               of the Telnet ECHO option.\n\
    \      SOFT_TAB When set, the client side should expand the Horizontal\n     \
    \          Tab (HT) code, USASCII 9, into the appropriate number of\n        \
    \       spaces to move the printer to the next horizontal tab\n              \
    \ stop.  When unset, the client side should allow the\n               Horizontal\
    \ Tab code to pass through un-modified.\n      LIT_ECHO When set, if the client\
    \ side is echoing a non-printable\n               character that the user has\
    \ typed to the users screen,\n               the character should be echoed as\
    \ the literal character.\n               If the LIT_ECHO bit is not set, then\
    \ the client side may\n               echo the character in any manner that it\
    \ desires.  (Many\n               systems echo unprintable characters as two character\n\
    \               sequences, for example, they will echo \"^A\" for an\n       \
    \        ASCII 1 value.)\n   When the client side of a connection receives a MODE\
    \ command, it MUST\n   agree with at least the state of the EDIT and TRAPSIG bits.\
    \  If a\n   MODE command is received with a mode mask that is currently in use\n\
    \   (ignoring the MODE_ACK bit), the MODE command is ignored.  If a MODE\n   command\
    \ is received that is different from the current mode mask,\n   then a reply is\
    \ sent with either the new mode mask and the MODE_ACK\n   bit set, or a subset\
    \ of the new mode mask.  The only exception is\n   that if the server receives\
    \ a MODE with either the EDIT or TRAPSIG\n   bits not set, it may set the EDIT\
    \ and TRAPSIG bits in the response,\n   and if the client receives a MODE with\
    \ the EDIT or TRAPSIG bits set,\n   it may not clear them in the response.\n \
    \  When a MODE command is received with the MODE_ACK bit set, and the\n   mode\
    \ is different that what the current mode is, the client will\n   ignore the new\
    \ mode, and the server will switch to the new mode.\n   This ensures that both\
    \ sides of the connection will resolve to the\n   same mode.  In all cases, a\
    \ response is never generated to a MODE\n   command that has the MODE_ACK bit\
    \ set.\n"
- title: 2.3 LINEMODE suboption FORWARDMASK
  contents:
  - "2.3 LINEMODE suboption FORWARDMASK\n   IAC SB LINEMODE DO FORWARDMASK mask0 mask1\
    \ ... mask31 IAC SE\n      The sender of this command request that the other side\
    \ send any\n      buffered data when any of the ASCII characters defined by the\
    \ bit\n      mask are received.  Only the side of the connection that sent DO\n\
    \      LINEMODE (the server side) may negotiate this.  The mask is up to\n   \
    \   32 octets long.  Each octet represents 8 ASCII character codes.\n      The\
    \ high order bit of mask0 corresponds to an ASCII code of 0.\n      The low order\
    \ bit of mask0 corresponds to an ASCII code of 7.  The\n      high order bit of\
    \ mask1 corresponds to an ASCII code of 8.  The\n      low order bit of mask1\
    \ corresponds to an ASCII code of 15, and so\n      on. The mask list may be terminated\
    \ before the end of the list, in\n      which case all the rest of the mask octets\
    \ are assumed to be reset\n      (equal to zero).  When the server side is in\
    \ DONT TRANSMIT-BINARY\n      mode, then only the first 16 octets of the mask\
    \ (ASCII codes 0\n      through 127) are used.  If any individual octet of the\
    \ mask is\n      equal to IAC, it must be sent as a double IAC.\n   IAC SB LINEMODE\
    \ DONT FORWARDMASK IAC SE\n      The sender of this command requests that the\
    \ other side stop using\n      the forward mask to determine when to send buffered\
    \ data.\n   IAC SB LINEMODE WILL FORWARDMASK IAC SE\n      This command is sent\
    \ in response to a DO FORWARDMASK command.  It\n      indicates that the forward\
    \ mask will be used to determine when to\n      send buffered data.\n   IAC SB\
    \ LINEMODE WONT FORWARDMASK IAC SE\n      This command is sent in response to\
    \ a DO FORWARDMASK command.  It\n      indicates that the forward mask will not\
    \ be used to determine when\n      to send buffered data.\n"
- title: 2.4 LINEMODE suboption SLC, Set Local Characters
  contents:
  - "2.4 LINEMODE suboption SLC, Set Local Characters\n   The SLC suboption uses a\
    \ list of octet triplets. The first octet\n   specifies the function, the second\
    \ octet specifies modifiers to the\n   function, and the third octet specifies\
    \ the ASCII character for the\n   function.\n   IAC SB LINEMODE SLC <list of octet\
    \ triplets> IAC SE\n      The sender of this command REQUESTS that the list of\
    \ octet\n      triplets be used to set the local character to be used to send\
    \ to\n      perform the specified function.\n      There are four levels that\
    \ a function may be set to.\n      SLC_NOSUPPORT is the lowest, SLC_CANTCHANGE\
    \ is the next higher\n      level, SLC_VALUE is above that, and SLC_DEFAULT is\
    \ the highest\n      level.\n      If the SLC_LEVELBITS in the second octet are\
    \ equal to SLC_DEFAULT,\n      then this particular function should use the system\
    \ default on the\n      other side of the connection.\n      If the SLC_LEVELBITS\
    \ in the second octet are equal to SLC_VALUE,\n      then this function is supported,\
    \ and the current value is\n      specified by the third octet.\n      If the\
    \ SLC_LEVELBITS in the second octet are equal to\n      SLC_CANTCHANGE, then this\
    \ is a function that is supported, but the\n      value for this function, specified\
    \ in the third octet, cannot be\n      changed.\n      If the SLC_LEVELBITS in\
    \ the second octet are equal to\n      SLC_NOSUPPORT, then this particular function\
    \ is not supported and\n      should be disabled by the other side.\n      If\
    \ this is a response to a previous request to change a special\n      character,\
    \ and we are agreeing to the change, then the SLC_ACK bit\n      must be set in\
    \ the second octet.\n      If the SLC_FLUSHIN bit is set in the second octet,\
    \ then whenever\n      this function is sent, a Telnet \"sync\" should be sent\
    \ at the same\n      time to flush the input stream.\n      If the SLC_FLUSHOUT\
    \ bit is set in the second octet, then whenever\n      this function is sent,\
    \ output data should be flushed.\n      Only the client may send an octet triplet\
    \ with the first octet\n      equal to zero.  In this case, the SLC_LEVELBITS\
    \ may only be set to\n      SLC_DEFAULT or SLC_VALUE, and the third octet does\
    \ not matter.\n      When the server receives 0 SLC_DEFAULT 0, it should switch\
    \ to its\n      system default special character settings, and send all those\n\
    \      special characters to the client.  When the server receives 0\n      SLC_VALUE\
    \ 0, it should just send its current special character\n      settings.  Note\
    \ that if the server does not support some of the\n      editing functions, they\
    \ should be sent as XXX SLC_DEFAULT 0,\n      rather than as XXX SLC_NOSUPPORT\
    \ 0, so that the client may choose\n      to use its own values for those functions,\
    \ rather than have to\n      disable those functions even if it supports them.\n\
    \      If any of the octets in the list of octet triplets is equal to\n      IAC,\
    \ it must be sent as a double IAC.\n   When a connection is established, it is\
    \ the responsibility of the\n   client to either request the remote default values\
    \ for the special\n   characters, or to send across what all the special characters\
    \ should\n   be set to.\n   The function values can be put into two groups, functions\
    \ that are to\n   be translated to their Telnet equivalents before being sent\
    \ across\n   the Telnet connection, and functions that are to be recognized and\n\
    \   processed locally.\n   First, we have those characters that are to be mapped\
    \ into their\n   Telnet equivalents:\n      SLC_SYNCH Synch.  See RFC 854, \"\
    TELNET PROTOCOL SPECIFICATION\",\n                for a complete description.\n\
    \      SLC_BRK   Break.  See RFC 854, \"TELNET PROTOCOL SPECIFICATION\",\n   \
    \             for a complete description.\n      SLC_IP    Interrupt Process.\
    \  See RFC 854, \"TELNET PROTOCOL\n                SPECIFICATION\", for a complete\
    \ description.\n      SLC_AO    Abort Output.  See RFC 854, \"TELNET PROTOCOL\n\
    \                SPECIFICATION\", for a complete description.\n      SLC_AYT \
    \  Are You There.  See RFC 854, \"TELNET PROTOCOL\n                SPECIFICATION\"\
    , for a complete description.\n      SLC_EOR   End of Record.  See RFC 885, \"\
    TELNET END OF RECORD\n                OPTION\" for a complete description.\n \
    \     SLC_ABORT Abort.  See section 2.5 for a complete description.\n      SLC_EOF\
    \   End of File.  See section 2.5 for a complete\n                description.\n\
    \      SLC_SUSP  Suspend.  See section 2.5 for a complete description.\n   Next,\
    \ we have the locally interpreted functions.\n      SLC_EC    Erase Character.\
    \  This is the character that is typed to\n                erase one character\
    \ from the input stream.  See RFC 854,\n                \"TELNET PROTOCOL SPECIFICATION\"\
    , for a complete\n                description.\n      SLC_EL    Erase Line.  This\
    \ is the character that is typed to\n                erase the entire contents\
    \ of the current line of input.\n                See RFC 854, \"TELNET PROTOCOL\
    \ SPECIFICATION\", for a\n                complete description.\n      SLC_EW\
    \    Erase Word.  This is the character that is typed to\n                erase\
    \ one word from the input stream.\n      SLC_RP    Reprint Line.  This is the\
    \ character that is typed to\n                cause the current line of input\
    \ to be reprinted, leaving\n                the cursor at the end of the line.\n\
    \      SLC_LNEXT Literal Next.  This is the character that is typed to\n     \
    \           indicate that the next character is to be taken\n                literally,\
    \ no character processing should be done with\n                it, and if it is\
    \ a special character that would normally\n                get mapped into a Telnet\
    \ option, that mapping should\n                not be done.\n      SLC_XON   Start\
    \ Output.  This is the character that is sent to\n                resume output\
    \ to the users terminal.\n      SLC_XOFF  Stop Output.  This is the character\
    \ that is sent to stop\n                output to the users terminal.\n      SLC_FORW1\
    \ Forwarding character.  This is a character that should\n                cause\
    \ all data currently being buffered, and this\n                character, to be\
    \ sent immediately.\n      SLC_FORW2 Forwarding character.  This is another character\
    \ that is\n                to be treated in the same manner as SLC_FORW1.\n  \
    \    SLC_MCL   Move cursor one character left.  When visual editing is\n     \
    \           supported, this is the character that, when typed, will\n        \
    \        move the cursor one character to the left in the\n                display.\n\
    \      SLC_MCR   Move cursor one character right.  When visual editing is\n  \
    \              supported, this is the character that, when typed, will\n     \
    \           move the cursor one character to the right in the\n              \
    \  display.\n      SLC_MCWL  Move cursor one word left.  When visual editing is\n\
    \                supported, this is the character that, when typed, will\n   \
    \             move the cursor one word to the left in the display.\n      SLC_MCWR\
    \  Move cursor one word right.  When visual editing is\n                supported,\
    \ this is the character that, when typed, will\n                move the cursor\
    \ one word to the right in the display.\n      SLC_MCBOL Move cursor to the begining\
    \ of the line.  When visual\n                editing is supported, this is the\
    \ character that, when\n                typed, will move the cursor to the begining\
    \ of the line\n                that is being edited.\n      SLC_MCEOL Move cursor\
    \ to the end of the line.  When visual editing\n                is supported,\
    \ this is the character that, when typed,\n                will move the cursor\
    \ to the end of the line that is\n                being edited.\n      SLC_INSRT\
    \ Enter insert mode.  When visual editing is supported,\n                after\
    \ this character is typed, all normal characters\n                that are subsequently\
    \ typed will be inserted into the\n                display.\n      SLC_OVER  Enter\
    \ overstrike mode.  When visual editing is\n                supported, after this\
    \ character is typed, all normal\n                charactersthat are subsequently\
    \ typed will overwrite\n                any characters in the current display.\
    \  If the\n                SLC_INSRT and SLC_OVER variables are set to the same\n\
    \                value, then that value is to act as a toggle between\n      \
    \          overstrike and insert mode.\n      SLC_ECR   Erase character to the\
    \ right.  When visual editing is\n                supported, this is the character\
    \ that, when typed, will\n                erase one character to the right of\
    \ the cursor.\n      SLC_EWR   Erase word to the right.  When visual editing is\n\
    \                supported, this is the character that, when typed,\n        \
    \        will erase one word to the right of the cursor.\n      SLC_EBOL  Erase\
    \ to the begining of the line.  When visual editing\n                is supported,\
    \ this is the character that, when typed,\n                will erase all the\
    \ characters to the left of the cursor.\n      SLC_EEOL  Erase to the end of the\
    \ line.  When visual editing is\n                supported, this is the character\
    \ that, when typed, will\n                erase all characters to the right of\
    \ the cursor.\n   For SLC_EEOL, SLC_EWR, and SLC_ECR, if a system has a cursor\
    \ that is\n   not diplayed between characters, but is positioned over a character,\n\
    \   that character is assumed to be to the right of the cursor.  Thus,\n   the\
    \ SLC_ECR will erase the character that is under the current cursor\n   position.\n"
- title: 2.5 New control characters
  contents:
  - "2.5 New control characters\n   IAC ABORT\n      Abort.  Similar to \"IAC IP\"\
    , but means only to abort or terminate\n      the process to which the NVT is\
    \ connected.  (The Telnet spec says\n      IP may \"suspend, interrupt, abort\
    \ or terminate\" the process.) If a\n      system does not have two methods of\
    \ interrupting a process, then\n      ABORT and IP should have the same effect.\n\
    \   IAC SUSP\n      Suspend the execution of the current process attached to the\
    \ NVT\n      in such a way that another process will take over control of the\n\
    \      NVT, and the suspended process can be resumed at a later time. If\n   \
    \   the receiving system does not support this functionality, it\n      should\
    \ be ignored.\n   IAC EOF\n      End Of File.  The recipient should notify the\
    \ process connected to\n      the NVT that an end of file has been reached.  This\
    \ is intended\n      for systems that support the ability for the user to type\
    \ in an\n      EOF character at the keyboard.\n"
- title: 3.  Default Specification
  contents:
  - "3.  Default Specification\n   The default specification for this option is\n\
    \      WONT LINEMODE\n      DONT LINEMODE\n   meaning there will not be any subnegotiation\
    \ of the mode of the\n   connection.\n   If WILL LINEMODE is negotiated, the defaults\
    \ are:\n      IAC SB LINEMODE MODE 0 IAC SE\n      IAC SB LINEMODE WONT FORWARDMASK\
    \ IAC SE\n   If DO LINEMODE is negotiated, the defaults are:\n      IAC SB LINEMODE\
    \ MODE 0 IAC SE\n      IAC SB LINEMODE DONT FORWARDMASK IAC SE\n   Character values\
    \ for SLC default to SLC_NOSUPPORT.\n"
- title: 4.  Motivation
  contents:
  - "4.  Motivation\n   With increasing Telnet usage, it has become apparent that\
    \ the ability\n   to do command line processing on the local machine and send\
    \ completed\n   lines to the remote machine is a feature necessary in several\n\
    \   environments.  First, in the case of a connection over long delay\n   equipment,\
    \ it is very frustrating to the user to have the echoing of\n   his data take\
    \ several seconds.  Second, some supercomputers, due to\n   their nature, are\
    \ not good at handling and processing single\n   character input.  For these machines,\
    \ it is better to have the front\n   end computer do the character processing,\
    \ and leave the\n   supercomputer's cycles available for doing vectorized number\n\
    \   crunching.\n   There have been attempts to make local line editing work within\
    \ the\n   existing Telnet specs.  Indeed, the 4.3 BSD tape includes a version\n\
    \   of Telnet that attempts to do this through recognition of the state\n   of\
    \ the ECHO and SUPRESS-GO-AHEAD options; other implementations do\n   this recognition\
    \ purely through the ECHO option.\n   There are problems with both of these methods.\
    \  Using just the ECHO\n   provides no mechanism to have ECHO to the user turned\
    \ off, and leave\n   local character processing on, for example, when a user is\
    \ typing a\n   password.\n   The usage of the SUPRESS-GO-AHEAD comes from reading\
    \ into RFC 858,\n   where it states:\n      \"In many TELNET implementations it\
    \ will be desirable to couple the\n      SUPRESS-GO-AHEAD option to the echo option\
    \ so that when the echo\n      option is in effect, the SUPPRESS-GO-AHEAD option\
    \ is in effect\n      simultaneously: both of these options will normally have\
    \ to be in\n      effect simultaneously to effect what it commonly understood\
    \ to be\n      character at a time echoing by the remote computer.\"\n   The reverse\
    \ reading of this is that without the ECHO option or the\n   SUPPRESS-GO-AHEAD\
    \ option, you are in line at a time mode, implying\n   local line editing.  This\
    \ has the obvious problem that that is not\n   what the SUPPRESS-GO-AHEAD option\
    \ is supposed to mean.\n   Other shortcomings are that the Telnet specification\
    \ is not rich\n   enough to handle all of the special characters that some of\
    \ the\n   current operating systems support.  For example, the ECHO/SGA\n   implementation\
    \ supports two ways of interrupting a process, by\n   borrowing the BRK option\
    \ for the second interrupt.  Some\n   implementations have taken the EOR option\
    \ to send an End-Of-File.\n   Obviously, this is using things for which they were\
    \ not intended, and\n   the correct solution would be to define new options.\n\
    \   Another problem is that some implementations of line mode buffer up\n   the\
    \ input until the end of the line, and then send the whole line\n   across, editing\
    \ characters and all.  No local editing of the line has\n   been done.\n   After\
    \ examining several implementations, it has become clear that the\n   correct\
    \ thing to do is to implement new options to enhance the\n   current Telnet specification\
    \ so that it can support local line\n   editing in a reasonable, reliable, and\
    \ consistent manner.\n   There are three states that are of interest.\n      1)\
    \ Local line editing and local signal trapping\n      2) Remote line editing,\
    \ local signal trapping\n      3) Remote line editing, remote signal trapping\n\
    \   The case of local line editing and remote signal trapping is not a\n   very\
    \ interesting case, because you don't recognize the signals, and\n   cannot send\
    \ them to the remote side for it to recognize until the\n   line has been completed.\
    \  Also, special signals usually will have an\n   effect on the line editing function,\
    \ and if they are not being\n   trapped locally the desired action will not happen.\n\
    \   Local line editing means that all normal command line character\n   processing,\
    \ like \"Erase Character\" and \"Erase Line\", happen on the\n   local system,\
    \ and only when \"CR LF\" (or some other special character)\n   is encountered\
    \ is the edited data sent to the remote system.\n   Signal trapping means, for\
    \ example, that if the user types the\n   character associated with the IP function,\
    \ then the \"IAC IP\" function\n   is sent to the remote side instead of the character\
    \ typed.  Remote\n   signal trapping means, for example, that if the user types\
    \ the\n   character associated with the IP function, then the \"IAC IP\" function\n\
    \   is not sent to the remote side, but rather the actual character typed\n  \
    \ is sent to the remote side.\n"
- title: 5.  Implementation Rules
  contents:
  - "5.  Implementation Rules\n   It is expected that any implementation that supports\
    \ the Telnet\n   LINEMODE option will support all of this specification.\n"
- title: 5.1 User Interface
  contents:
  - "5.1 User Interface\n   Normally, the entire user interface is left up to the\
    \ implementor.\n   However, there is functionality that the user should be able\
    \ to\n   specify on the client side of the connection.  During a Telnet\n   session,\
    \ the client side should allow some mechanism for the user to\n   give commands\
    \ to the local Telnet process.  These commands should at\n   least allow the user\
    \ to:\n      1)  Change the mode of the connection.  The user should be able to\n\
    \          attempt to turn EDIT, FLOW, TRAPSIG, and ECHO on and off.  The\n  \
    \        server may refuse to change the state of the EDIT and TRAPSIG\n     \
    \     bits.\n      2)  Import or export SLC.  The user should be able to tell\
    \ the\n          local Telnet process whether he wants to use the local or\n \
    \         the current or default remote definitions of the special\n         \
    \ characters.\n      3)  Manual sending of options.  The user should be able to\
    \ tell\n          the local Telnet process to explicitly send any of the Telnet\n\
    \          options (like IP, ABORT, AYT, etc).\n"
- title: 5.2 End of line terminators.
  contents:
  - "5.2 End of line terminators.\n   When LINEMODE is turned on, and when in EDIT\
    \ mode, when any normal\n   line terminator on the client side operating system\
    \ is typed, the\n   line should be transmitted with \"CR LF\" as the line terminator.\
    \  When\n   EDIT mode is turned off, a carriage return should be sent as \"CR\n\
    \   NUL\", a line feed should be sent as LF, and any other key that cannot\n \
    \  be mapped into an ASCII character, but means the line is complete\n   (like\
    \ a DOIT or ENTER key), should be sent as \"CR LF\".\n"
- title: 5.3 Output processing
  contents:
  - "5.3 Output processing\n   Regardless of what mode has been negotiated, the server\
    \ side is\n   responsible for doing all output processing.  Specificly, it should\n\
    \   send \"CR LF\" when it wants the \"newline\" function, \"CR NUL\" when it\n\
    \   wants just a carriage return, and \"LF\" when it wants just a linefeed.\n"
- title: 5.4 A terminal driver in Telnet?
  contents:
  - "5.4 A terminal driver in Telnet?\n   Conforming implementations need not do all\
    \ the line editing\n   themselves.  There is nothing wrong with letting the system\
    \ terminal\n   driver handle the line editing, and have it hand to the Telnet\n\
    \   application the completed and edited line, which is then sent to the\n   remote\
    \ system.\n"
- title: 5.5 Setting of Local Characters
  contents:
  - "5.5 Setting of Local Characters\n   When this RFC was being developed, the original\
    \ thought was that both\n   sides of the connection would use their own defaults\
    \ for the special\n   characters, even if they were not the same on both sides\
    \ of the\n   connection.  If this scheme is used, though, the view that the user\n\
    \   has is that the local special characters are being used, and the\n   remote\
    \ character settings don't matter.  It was decided that the\n   client side of\
    \ the connection should be in control of the character\n   settings.\n   When\
    \ LINEMODE is negotiated, the client must either export the local\n   character\
    \ settings to the server, or send a request (SLC 0\n   SLC_DEFAULT 0) to import\
    \ the servers special characters.  The usual\n   action would be that a client\
    \ running on a full fledged computer\n   would export the special characters,\
    \ and a client running where there\n   are no local defaults (like on some terminal\
    \ servers) would import\n   the special characters.\n   When an SLC command is\
    \ received, the action taken should be:\n      1)  Ignore it if it is the same\
    \ as the current settings.\n      2)  If the SLC_LEVELBITS are the same as the\
    \ current level bits,\n          but the value is different and the SLC_ACK bit\
    \ is set, no\n          reply is generated.  On the server side, the command is\n\
    \          ignored, and on the client side, a switch is made to the\n        \
    \  new value.  This is so that if a request to change the same\n          character\
    \ is generated by both the server and the client,\n          they will both settle\
    \ on the clients requested value.\n      3)  If we agree with the new setting,\
    \ we switch to it and reply\n          with the same value, but also set the SLC_ACK\
    \ bit.\n      4)  If we don't agree, we send a response with what we think the\n\
    \          value should be.  The SLC_ACK bit is NOT set in this case.\n      \
    \    You may only disagree with a value by sending a different\n          value\
    \ at a lower level.\n   If the remote system doesn't support some of the line\
    \ editing\n   characters, but the front end does, then the front end may use the\n\
    \   local definitions for those characters when in line mode. In this\n   case,\
    \ the server should send \"SLC xxx SLC_DEFAULT 0\" in response to a\n   \"SLC\
    \ 0 SLC_DEFAULT 0\" request, and just ack whatever value the client\n   requests\
    \ to set the function to.\n   The SLC_FORW2 character should only be used if SLC_FORW1\
    \ is already\n   in use.\n"
- title: 5.6 FORWARDMASK and SLC_FORW1 and SLC_FORW2
  contents:
  - "5.6 FORWARDMASK and SLC_FORW1 and SLC_FORW2\n   To help ease the amount of work\
    \ needed to implement the client side,\n   two methods of setting forwarding characters\
    \ are provided.  The\n   SLC_FORW1 and SLC_FORW2 allow for the setting of two\
    \ additional\n   characters on which to forward buffered input data.  Since many\n\
    \   terminal drivers have the ability to set one or more line delimiters,\n  \
    \ it is fairly easy to support these without having to implement\n   through the\
    \ local terminal driver, rather than putting a terminal\n   driver into Telnet.\
    \  If the local terminal driver has functionality\n   that maps easily into the\
    \ FORWARDMASK, then it can also be easily\n   supported.  If the local terminal\
    \ driver does not support that, then\n   it would require more work to support\
    \ FORWARDMASK.\n   Also note that the client side is required to forward data\
    \ when it\n   sees one of SLC_FORW1, SLC_FORW2, or FORWARDMASK characters, or\
    \ when\n   any normal line termination or special signal is encountered.  The\n\
    \   client side is also free to forward on other characters that it\n   chooses.\
    \  For example, if the server side sent a FORWARDMASK that\n   asked for data\
    \ to be forwarded on the first 20 control characters\n   (ASCII codes 1 through\
    \ 024), and the client side cannot have its\n   local terminal driver forward\
    \ on just the first 20 control\n   characters, but it can have the local terminal\
    \ driver forward on any\n   control character (ASCII codes 1 through 039), then\
    \ the client side\n   could validly accept the FORWARDMASK, and forward on any\
    \ control\n   character.  When in EDIT mode, care should be taken to not forward\
    \ at\n   random times, since once that data is forwarded, no more editing on\n\
    \   the forwarded part of the line can be done.  The only time (other\n   than\
    \ the normal times) that data should be forwarded when in EDIT\n   mode would\
    \ be if a single input line is too long to handle locally.\n"
- title: 5.7 Valid and invalid modes and values
  contents:
  - "5.7 Valid and invalid modes and values\n   At no time should \"DO LINEMODE\"\
    \ be negotiated in both directions of\n   the Telnet connection.  The side that\
    \ is the \"DO LINEMODE\" is\n   considered to be the server side, and the side\
    \ that is \"WILL\n   LINEMODE\" is the client side.\n   At no time should \"SB\
    \ LINEMODE DO/DONT FORWARDMASK\", be sent unless\n   \"DO LINEMODE\" has been\
    \ previously negotiated.  At no time should \"SB\n   LINEMODE WILL/WONT FORWARDMASK\"\
    , be sent unless \"WILL LINEMODE\" has\n   been previously negotiated.\n   If\
    \ an ABORT, EOF or SUSP, is received and the system does not support\n   that\
    \ functionality, it may just be ignored.\n"
- title: 5.8 Flushing input and output
  contents:
  - "5.8 Flushing input and output\n   When an IP, BRK or ABORT is sent, it is usually\
    \ desirable to be able\n   to flush the input stream, and to flush output to the\
    \ user until the\n   IP, BRK, or ABORT is processed.  The SLC_FLUSHIN and SLC_FLUSHOUT\n\
    \   bits are used to indicate what action should be done.  These bits are\n  \
    \ advisory only, but should be honored if possible.  The standard\n   method for\
    \ processing the SLC_FLUSHIN is to use the Telnet \"Synch\"\n   signal, and the\
    \ SLC_FLUSHOUT is processed using the TIMING-MARK\n   option.  If both are to\
    \ be sent, the IAC DM is sent before the DO\n   TIMING-MARK Thus, the sender would\
    \ send \"IAC XXX IAC DM IAC DO\n   TIMING-MARK\", where XXX may be IP, BRK or\
    \ ABORT, or any other special\n   character.  The IAC DM is sent as TCP urgent\
    \ data with the DM as the\n   last (or only) data octet; this is used to flush\
    \ the input stream.\n   The \"IAC DO TIMING-MARK\" is used to tell when to stop\
    \ flushing\n   output; once it is sent, all data is discarded until an \"IAC WILL\n\
    \   TIMING-MARK\" or an \"IAC WONT TIMING-MARK\" is received.\n   Since the SLC_FLUSHIN\
    \ and SLC_FLUSHOUT bit are only advisory, the\n   user interface should provide\
    \ a method so that the user can override\n   the sending (or not sending) of the\
    \ \"Synch\" and TIMING-MARK, but the\n   default action should be to send them\
    \ according to the SLC_FLUSHIN\n   and SLC_FLUSHOUT bits.\n   Whenever an IAC\
    \ AO is received, a Synch must be returned.  When ever\n   a Synch is being processed,\
    \ (by the TCP connection going into Urgent\n   mode), all data must be discarded\
    \ (but not Telnet commands!) until an\n   IAC DM is found, and the connection\
    \ goes out of Urgent mode.  See RFC\n   854, \"TELNET PROTOCOL SPECIFICATION\"\
    , for a complete description of\n   the Synch signal.\n"
- title: 5.9 State diagram for SLC
  contents:
  - "5.9 State diagram for SLC\n   +---------------------------------------------------------------+\n\
    \   |                                IDLE                           |\n   +----------------------+------+------+-------+-------+---------++\n\
    \    ^      ^     ^        |      | ^    | ^     | ^     |       ^ |\n    |  \
    \    |     |        v      v |    | |     | |     v       | |\n    |      |  \
    \   |    +------+ +---+--+ | |     | | ########### | |\n    |      |     |   \
    \ | Get  | | Send | | |     | | #   Get   # | |\n    |      |     |    | SPC0\
    \ | | SPC0 | | |     | | # 0,DEF,0 # | |\n    |      |     |    +---+--+ +------+\
    \ | |     | | ########### | |\n    |      |     |        |       ^     | |   \
    \  | |     |       | |\n    |      |     |        v       |     v |     | |  \
    \   v       | |\n    |      |     |       / \\      | *********** | | ###########\
    \ | |\n    |      |     |     /     \\    | *  Send   * | | # Switch  # | |\n\
    \    | ********** |Yes/ Same as \\  | * 0,VAL,0 * | | # to      # | |\n    | *\
    \ Change * +--<  current? > | *********** | | # default # | |\n    | * to new\
    \ *     \\         /  |             v | ########### | |\n    | * value  *    \
    \   \\     /    |     ***********     |       | |\n    | **********         \\\
    \ /      |     *  Send   *     v       | |\n    |      ^              |No    \
    \ |     * 0,DEF,0 *  #########  | |\n    |      |Yes           v       |     ***********\
    \  # Send  #--+ |\n    |     / \\            / \\      |                  # SPC-A\
    \ #    |\n    |   /     \\        /     \\    |                  #########   \
    \ |\n    | / Is ACK  \\ Yes/  Same   \\  |                     ^         |\n \
    \   |<  bit set? ><-<  level as > |                     |         |\n    | \\\
    \         /    \\ current?/  |                 ###########   |\n    |   \\   \
    \  /        \\     /    |                 #   Get   #<--+\n    |     \\ /    \
    \        \\ /    +-+---+             # 0,VAL,0 #\n    |      |No            |No\
    \   | Set |             ###########\n    |      +--------------+     | ACK |\n\
    \    |                     v     | bit |      * - Client side only\n    |    \
    \                / \\    +-----+      # - Server side only\n    |   +------+ \
    \      /     \\      ^\n    |   | Send |  No /  Do we  \\ Yes|\n    +---| SPC1\
    \ |<---<   agree?  >---+\n        +------+     \\         /\n                \
    \       \\     /\n                         \\ /\n           SPC0    Initial setting\
    \ for a special character\n           SPC1    A changed special character < SPC0\n\
    \           SPC-A   All current special character settings\n           VAL   \
    \  SLC_VALUE level\n           DEF     SLC_DEFAULT level\n   Levels: DEFAULT,\
    \ VALUE, CANT_CHANGE, NOSUPPORT\n   Flags: ACK\n           Receive           \
    \      Response\n           -------                 --------\n           f,SLC_DEFAULT,x\
    \         f,SLC_VALUE,v\n                                   f,SLC_CANTCHANGE,v\n\
    \                                   f,SLC_NOSUPPORT,x\n           f,SLC_VALUE,v\
    \           f,SLC_ACK|SLC_VALUE,v\n                                   f,SLC_CANTCHANGE,w\n\
    \                                   f,SLC_NOSUPPORT,x\n           f,SLC_CANTCHANGE,v\
    \      f,SLC_ACK|SLC_CANTCHANGE,v\n                                   f,SLC_NOSUPPORT,x\n\
    \           f,SLC_NOSUPPORT,x       f,SLC_ACK|SLC_NOSUPPORT,x\n           x,SLC_ACK|x,x\
    \           no response\n"
- title: 5.10 Examples of a connection
  contents:
  - "5.10 Examples of a connection\n   In these examples, the symbolic names are used\
    \ rather than the actual\n   values, to make them readable.  When two or more\
    \ symbolic names are\n   joined by a |, it means that the actual value will be\
    \ the logical\n   \"or\" of the values of the symbolic names.  In the interest\
    \ of\n   clarity, for these examples the leading IAC and IAC SB sequences, and\n\
    \   the trailing IAC SE sequences have been omitted.  Also, the SLC_\n   prefix\
    \ has been left off where ever it would normally occur.\n   CLIENT           \
    \                SERVER\n                                        DO TOGGLE-FLOW-CONTROL\n\
    \                                        DO LINEMODE\n       WILL TOGGLE-FLOW-CONTROL\n\
    \       WILL LINEMODE\n       [ Subnegotiation may now proceed in both directions.\
    \  The client\n         sends of the list of special characters.  ]\n       LINEMODE\
    \ SLC SYNCH DEFAULT 0 IP\n       VALUE|FLUSHIN|FLUSHOUT 3 AO\n       VALUE 15\
    \ AYT DEFAULT 0 ABORT\n       VALUE|FLUSHIN|FLUSHOUT 28 EOF\n       VALUE 4 SUSP\
    \ VALUE|FLUSHIN 26 EC\n       VALUE 127 EL VALUE 21 EW VALUE\n       23 RP VALUE\
    \ 18 LNEXT VALUE 22\n       XON VALUE 17 XOFF VALUE 19\n       [ Now that linemode\
    \ is enabled, the server sets the initial mode,\n         and acknowledges the\
    \ special characters.  ]\n                                        LINEMODE MODE\
    \ EDIT\n                                        LINEMODE SLC SYNCH NOSUPPORT 0\n\
    \                                        IP VALUE|FLUSHIN|FLUSHOUT|ACK 3\n   \
    \                                     AO NOSUPPORT 0 AYT NOSUPPORT 0\n       \
    \                                 ABORT VALUE|FLUSHIN|FLUSHOUT|ACK\n         \
    \                               28 EOF VALUE|ACK 4 SUSP NOSUP-\n             \
    \                           PORT 0 EC VALUE|ACK 127 EL\n                     \
    \                   VALUE|ACK 21 EW VALUE|ACK 23 RP\n                        \
    \                VALUE|ACK 18 LNEXT VALUE|ACK 22\n                           \
    \             XON VALUE|ACK 17 XOFF VALUE|ACK\n                              \
    \          19\n       [ The client gets the mode and ack of the special characters,\
    \ and\n         acks the mode and any special characters that the server\n   \
    \      changed.  ]\n       LINEMODE MODE EDIT|MODE_ACK\n       LINEMODE SLC SYNCH\
    \ NOSUPPORT|ACK\n       0 AO NOSUPPORT|ACK 0 AYT|ACK\n       NOSUPPORT 0 SUSP\
    \ NOSUPPORT|ACK 0\n                                        \"Login:\"\n      \
    \ \"my_account\"\n       [ Turn off echo to the user.  ]\n                   \
    \                     WILL ECHO\n       DO ECHO\n                            \
    \            \"Password:\"\n       \"my_password\"\n       [ Turn back on echo\
    \ to the user.  ]\n                                        WONT ECHO\n       DONT\
    \ ECHO\n       [ User does some stuff, and then runs an application that wants\n\
    \         to use single character mode, doing its own echoing of\n         characters,\
    \ but keep signal trapping on.  ]\n                                        WILL\
    \ ECHO\n       DO ECHO\n                                        LINEMODE MODE\
    \ TRAPSIG\n       LINEMODE MODE TRAPSIG|MODE_ACK\n       [ Application finishes\
    \ ]\n                                        WONT ECHO\n       DONT ECHO\n   \
    \                                     LINEMODE MODE EDIT|TRAPSIG\n       LINEMODE\
    \ MODE\n       EDIT|TRAPSIG|MODE_ACK\n       [ Another application, that wants\
    \ full control of everything.  ]\n                                        WILL\
    \ ECHO\n       DO ECHO\n                                        LINEMODE MODE\
    \ 0\n       LINEMODE MODE 0|MODE_ACK\n       [ Application finishes ]\n      \
    \                                  WONT ECHO\n       DONT ECHO\n             \
    \                           LINEMODE MODE EDIT|TRAPSIG\n       LINEMODE MODE\n\
    \       EDIT|TRAPSIG|MODE_ACK\n       [ The user changes his erase character to\
    \ ^H.  ]\n                                        LINEMODE SLC EC VALUE 8\n  \
    \     LINEMODE SLC EC VALUE|ACK 8\n       [ The user decides to revert to all\
    \ the original client side\n         special characters.  ]\n       LINEMODE SLC\
    \ SYNCH DEFAULT 0 IP\n       VALUE|FLUSHIN|FLUSHOUT 3 AO\n       VALUE 15 AYT\
    \ DEFAULT 0 ABORT\n       VALUE|FLUSHIN|FLUSHOUT 28 EOF\n       VALUE 4 SUSP VALUE|FLUSHIN\
    \ 26 EC\n       VALUE 127 EL VALUE 21 EW VALUE\n       23 RP VALUE 18 LNEXT VALUE\
    \ 22\n       XON VALUE 17 XOFF VALUE 19\n                                    \
    \    LINEMODE SLC SYNCH NOSUPPORT 0\n                                        AO\
    \ NOSUPPORT 15 AYT NOSUPPORT 0\n                                        SUSP NOSUPPORT|FLUSHIN\
    \ 26 EC\n                                        VALUE|ACK 127 EW VALUE|ACK 23\
    \ RP\n                                        VALUE|ACK 18 LNEXT VALUE|ACK 22\n\
    \                                        XON VALUE|ACK 17 XOFF VALUE|ACK\n   \
    \                                     19\n       LINEMODE SLC SYNCH NOSUPPORT|ACK\n\
    \       0 AO NOSUPPORT|ACK 15 AYT\n       NOSUPPORT|ACK 0 SUSP\n       NOSUPPORT|ACK|FLUSHIN\
    \ 26\n       [ The user decides to import the remote sides default special\n \
    \        characters.  ]\n       LINEMODE SLC 0 DEFAULT 0\n                   \
    \                     LINEMODE SLC IP\n                                      \
    \  VALUE|FLUSHIN|FLUSHOUT 3 ABORT\n                                        VALUE|FLUSHIN|FLUSHOUT\
    \ 28 EOF\n                                        VALUE 4 EC VALUE 127 EL VALUE\
    \ 21\n       [ Since these are the same as the current local settings, no\n  \
    \       response is generated.  ]\n       [ This next example is what would happen\
    \ if an editor was fired\n         up, that wanted to let the client side do the\
    \ echoing and\n         buffering of characters, but did not want it to do any\
    \ line\n         editing, and only forward the data when got a control\n     \
    \    character.  Note that we have preceded all the the 0377s\n         in the\
    \ forward mask with an IAC.  ]\n                                        LINEMODE\
    \ MODE 0\n                                        LINEMODE DO FORWARDMASK IAC\
    \ 0377\n                                        IAC 0377 IAC 0377 IAC 0377 0 0\
    \ 0\n                                        0 0 0 0 0 0 0 0 01\n       LINEMODE\
    \ MODE 0\n       LINEMODE WILL FORWARDMASK\n       [ Application runs to completion,\
    \ and then things are to be set\n         back to what they were before.  ]\n\
    \                                        LINEMODE MODE EDIT|TRAPSIG\n        \
    \                                LINEMODE DONT FORWARDMASK\n       LINEMODE MODE\
    \ EDIT|TRAPSIG\n       LINEMODE WONT FORWARDMASK\n"
- title: 6.  Other Telnet options and RFCs
  contents:
  - "6.  Other Telnet options and RFCs\n   The following is a list of RFCs for various\
    \ Telnet options that\n   should be supported along with LINEMODE.\n   1.  Postel,\
    \ J. and Reynolds, J., \"TELNET PROTOCOL SPECIFICATION\",\n       RFC 854, ISI,\
    \ May 1983.\n   2.  Postel, J. and Reynolds, J., \"TELNET OPTION SPECIFICATIONS\"\
    ,\n       RFC 855, ISI, May 1983.\n   3.  Postel, J. and Reynolds, J., \"TELNET\
    \ BINARY TRANSMISSION\",\n       RFC 856, ISI, May 1983.\n   4.  Postel, J. and\
    \ Reynolds, J., \"TELNET ECHO OPTION\", RFC 857,\n       ISI, May 1983.\n   5.\
    \  Postel, J. and Reynolds, J., \"TELNET SUPRESS GO AHEAD OPTION\",\n       RFC\
    \ 858, ISI, May 1983.\n   6.  Postel, J. and Reynolds, J., \"TELNET TIMING MARK\
    \ OPTION\",\n       RFC 860, ISI, May 1983.\n   7.  VanBokkeln, J., \"Telnet Terminal-Type\
    \ Option\", RFC 1091,\n       FTP Software, Inc., February 1989.\n   8.  Waitzman,\
    \ D., \"Telnet Window Size Option\", RFC 1073, BBN STC,\n       October 1988.\n\
    \   9.  Hedrick, C., \"Telnet Remote Flow Control Option\", RFC 1080,\n      \
    \ Rutgers University, November, 1988.\n  10.  Hedrick, C., \"Telnet Terminal Speed\
    \ Option\", RFC 1079, Rutgers\n       University, December, 1988.\n   The following\
    \ is a list of RFCs that need not be supported for\n   LINEMODE, but which would\
    \ enhance any TELNET implementation.\n  11.  Postel, J. and Reynolds, J., \"TELNET\
    \ STATUS OPTION\", RFC 859,\n       ISI, May 1983.\n  12.  Postel, J. and Reynolds,\
    \ J., \"TELNET END OF RECORD OPTION\",\n       RFC 885, ISI, December 1983.\n\
    \  13.  Silverman, S., \"OUTPUT MARKING TELNET OPTION\", RFC 933,\n       MITRE-Washington,\
    \ January 1985.\n  14.  Marcy, G., \"Telnet X Display Location Option\", RFC 1096,\n\
    \       Carnegie Mellon University, March 1989.\n"
- title: Security Consideratiions
  contents:
  - "Security Consideratiions\n   Security issues are not discussed in this memo.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   David A. Borman\n   Cray Research Inc.\n   655F Lone Oak\
    \ Drive\n   Eagan, MN 55123\n   Phone: (612) 452-6650\n   EMail: dab@CRAY.COM\n\
    \   IETF Telnet WG Mailing List: telnet-ietf@CRAY.COM\n"
