- title: __initial_text__
  contents:
  - '       The Reliable Multicast Design Space for Bulk Data Transfer

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   The design space for reliable multicast is rich, with many possible\n\
    \   solutions having been devised.  However, application requirements\n   serve\
    \ to constrain this design space to a relatively small solution\n   space.  This\
    \ document provides an overview of the design space and\n   the ways in which\
    \ application constraints affect possible solutions.\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The term \"general purpose reliable multicast protocol\"\
    \ is something\n   of an oxymoron.  Different applications have different requirements\n\
    \   of a reliable multicast protocol, and these requirements constrain\n   the\
    \ design space in ways that two applications with differing\n   requirements often\
    \ cannot share a single solution.  There are however\n   many successful reliable\
    \ multicast protocol designs that serve more\n   special purpose requirements\
    \ well.\n   In this document we attempt to review the design space for reliable\n\
    \   multicast protocols intended for bulk data transfer.  The term bulk\n   data\
    \ transfer should be taken as having broad meaning - the main\n   limitations\
    \ are that the data stream is continuous and long lived -\n   constraints necessary\
    \ for the forms of congestion control we\n   currently understand.  The purpose\
    \ of this review is to gather\n   together an overview of the field and to make\
    \ explicit the\n   constraints imposed by particular mechanisms. The aim is to\
    \ provide\n   guidance to the standardization process for protocols and protocol\n\
    \   building blocks.  In doing this, we cluster potential solutions into\n   a\
    \ number of loose categories - real protocols may be composed of\n   mechanisms\
    \ from more than one of these clusters.\n   The main constraint on solutions is\
    \ imposed by the need to scale to\n   large receiver sets.  For small receiver\
    \ sets the design space is\n   much less restricted.\n"
- title: 2.  Application Constraints
  contents:
  - "2.  Application Constraints\n   Application requirements for reliable multicast\
    \ (RM) are as broad and\n   varied as the applications themselves.  However, there\
    \ are a set of\n   requirements that significantly affect the design of an RM\
    \ protocol.\n   A brief list includes:\n   o  Does the application need to know\
    \ that everyone received the data?\n   o  Does the application need to constrain\
    \ differences between\n      receivers?\n   o  Does the application need to scale\
    \ to large numbers of receivers?\n   o  Does the application need to be totally\
    \ reliable?\n   o  Does the application need ordered data?\n   o  Does the application\
    \ need to provide low-delay delivery?\n   o  Does the application need to provide\
    \ time-bounded delivery?\n   o  Does the application need many interacting senders?\n\
    \   o  Is the application data flow intermittent?\n   o  Does the application\
    \ need to work in the public Internet?\n   o  Does the application need to work\
    \ without a return path (e.g.\n      satellite)?\n   o  Does the application need\
    \ to provide secure delivery?\n   In the context of standardizing bulk data transfer\
    \ protocols, we can\n   rule out applications with multiple interacting senders\
    \ and\n   intermittent data flows.  It is not that these applications are\n  \
    \ unimportant, but that we do not yet have effective congestion control\n   for\
    \ such applications.\n"
- title: 2.1.  Did everyone receive the data?
  contents:
  - "2.1.  Did everyone receive the data?\n   In many applications a logically defined\
    \ unit or units of data is to\n   be delivered to multiple clients, e.g., a file\
    \ or a set of files, a\n   software package, a stock quote or package of stock\
    \ quotes, an event\n   notification, a set of slides, a frame or block from a\
    \ video.  An\n   application data unit (ADU) is defined to be a logically separable\n\
    \   unit of data that is useful to the application. In some cases, an\n   application\
    \ data unit may be short enough to fit into a single packet\n   (e.g., an event\
    \ notification or a stock quote), whereas in other\n   cases an application data\
    \ unit may be much longer than a packet\n   (e.g., a software package).\n   A\
    \ protocol may optionally provide delivery confirmation to ensure\n   reliable\
    \ delivery, i.e., a mechanism for receivers to inform the\n   sender when data\
    \ has been delivered.  There are two types of\n   confirmation, at the application\
    \ data unit level and at the packet\n   level. Application data unit confirmation\
    \ is useful at the\n   application level, e.g., to inform the application about\
    \ receiver\n   progress and to decide when to stop sending packets about a\n \
    \  particular application data unit.  Packet confirmation is useful at\n   the\
    \ transport level, e.g., to inform the transport level when it can\n   release\
    \ buffer space being used for storing packets for which\n   delivery has been\
    \ confirmed.\n   Some applications have a strong requirement for confirmation\
    \ that all\n   the receivers got an ADU, or if not, to be informed of which specific\n\
    \   receivers failed to receive the entire ADU. Examples include\n   applications\
    \ where receivers pay for data, and reliable file-system\n   replication.  Other\
    \ applications do not have such a requirement.  An\n   example is the distribution\
    \ of free software.\n   If the application does need to know that every receiver\
    \ got the ADU,\n   then a positive acknowledgment must be received from every\
    \ receiver,\n   although it may be possible to aggregate these acknowledgments.\
    \  If\n   the application needs to know precisely which receivers failed to get\n\
    \   the ADU, additional constraints are placed on acknowledgment\n   aggregation.\n\
    \   It should be noted that different mechanisms can be used for ADU-\n   level\
    \ confirmation and packet-level confirmation in the same\n   application.  For\
    \ example, an ADU-level confirmation mechanism using\n   positive acknowledgments\
    \ may sit on top of a packet-level NACK or\n   FEC-based transport.  Typically\
    \ this only makes sense when ADUs are\n   significantly larger than a single packet.\n"
- title: 2.2.  Constraining differences
  contents:
  - "2.2.  Constraining differences\n   Some applications need to constrain differences\
    \ between receivers so\n   that the data reception characteristics for all receivers\
    \ falls\n   within some range.  An example is a stock price feed, where it is\n\
    \   unacceptable for a receiver to suffer delivery that is delayed\n   significantly\
    \ more than any other receiver.\n   This requirement is difficult to satisfy without\
    \ harming performance.\n   Typically solutions involve not sending more than a\
    \ limited amount of\n   new data until positive acknowledgments have been received\
    \ from all\n   the receivers.  Such a solution does not cope with network and\
    \ end-\n   system failures well.\n"
- title: 2.3.  Receiver Set Scaling
  contents:
  - "2.3.  Receiver Set Scaling\n   There are many applications for RM that do not\
    \ need to scale to large\n   numbers of receivers.  For such applications, a range\
    \ of solutions\n   may be available that are not available for applications where\n\
    \   scaling to large receiver sets is a requirement.\n   A protocol must achieve\
    \ good throughput of application data units to\n   receivers.  This means that\
    \ most data that is delivered to receivers\n   is useful in recovering the application\
    \ data unit that they are\n   trying to receive. A protocol must also provide\
    \ good congestion\n   control to fairly share the available network resources\
    \ between all\n   applications.  Receiver set scaling is one of the most important\n\
    \   constraints in meeting these requirements, because it strictly limits\n  \
    \ the mechanisms that can be used to achieve these requirements to\n   those that\
    \ will efficiently scale to a large receiver population.\n   Acknowledgement packets\
    \ have been employed by many systems to achieve\n   these goals, but it is important\
    \ to understand the strength and\n   limitations of different ways of using such\
    \ packets.\n   In a very small system, it may be acceptable to have the receivers\n\
    \   acknowledge every packet.  This approach provides the sender with the\n  \
    \ maximum amount of information about reception conditions at all the\n   receivers,\
    \ information that can be used both to achieve good\n   throughput and to achieve\
    \ congestion control.\n   For larger systems, such \"flat ACK\" schemes cause\
    \ acknowledge\n   implosions at the sender.  Attempts have been made to reduce\
    \ this\n   problem by sending aggregate ACKs infrequently [RMWT98, BC94], but\
    \ it\n   is very difficult to incorporate effective congestion control into\n\
    \   such protocols because of the spareceness of feedback.\n   Using negative\
    \ acknowledgments (NACKs) instead of ACKs reduces this\n   problem to one of NACK\
    \ implosion (only from the receivers missing the\n   packets), and because the\
    \ sender really only needs to know that at\n   least one receiver is missing data\
    \ in order to achieve good\n   throughput, various NACK suppression mechanisms\
    \ can be applied.\n   An alternative to NACKs is ACK aggregation, which can be\
    \ done by\n   arranging the receivers into a logical tree, so that each leaf sends\n\
    \   ACKs to its parent which aggregates them, and passes them on up the\n   tree.\
    \  Tree-based protocols scale well, but tree formation can be\n   problematic.\n\
    \   Other ACK topologies such as rings are also possible, but are often\n   more\
    \ difficult to form and maintain than trees are.  An alternative\n   strategy\
    \ is to add mechanisms to routers so that they can help out in\n   achieving good\
    \ throughput or in reducing the cost of achieving good\n   throughput.\n   All\
    \ these solutions improve receiver set scaling, but they all have\n   limits of\
    \ one form or another.  One class of solutions scales to an\n   infinite number\
    \ of receivers by having no feedback channel whatsoever\n   in order to achieve\
    \ good throughput.  These open-loop solutions take\n   the initial data and encode\
    \ it using an FEC-style mechanism.  This\n   encoded data is transmitted in a\
    \ continuous stream.  Receivers then\n   join the session and receive packets\
    \ until they have sufficient\n   packets to decode the original data, at which\
    \ point they leave the\n   session.\n   Thus, it is clear that the intended scale\
    \ of the session constrains\n   the possible solutions.  All solutions will work\
    \ for very small\n   sessions, but as the intended receive set increases, the\
    \ range of\n   possible solutions that can be deployed safely decreases.\n   It\
    \ should also be noted that hybrids of these mechanisms are\n   possible, and\
    \ that using one mechanism at the packet-level and a\n   different (typically\
    \ higher overhead) solution at the ADU level may\n   also scale reasonably if\
    \ the ADUs are large compared to packets.\n"
- title: 2.4.  Total vs Semi-reliable
  contents:
  - "2.4.  Total vs Semi-reliable\n   Many applications require delivery of application\
    \ data units to be\n   totally reliable; if any of the application data unit is\
    \ missing,\n   none of the received portion of the application data unit is useful.\n\
    \   File transfer applications are a good example of applications\n   requiring\
    \ total reliability.\n   However, some applications do not need total reliability.\
    \  An example\n   is audio broadcasting, where missing packets reduce the quality\
    \ of\n   the received audio but do not render it unusable.  Such applications\n\
    \   can sometimes get by without any additional reliability over native\n   IP\
    \ reliability, but often having a semi-reliable multicast protocol\n   is desirable.\n"
- title: 2.5.  Time-bounded Delivery
  contents:
  - "2.5.  Time-bounded Delivery\n   Many applications just require data to be delivered\
    \ to the receivers\n   as fast as possible.  They have no absolute deadline for\
    \ delivery.\n   However, some applications have hard delivery constraints - if\
    \ the\n   data does not arrive at the receiver by a certain time, there is no\n\
    \   point in delivering it at all.  Such time-boundedness may be as a\n   result\
    \ of real-time constraints such as with audio or video\n   streaming, or as the\
    \ result of new data superseding old data.  In\n   both cases, the requirement\
    \ is for the application to have a greater\n   degree of control over precisely\
    \ what the application sends at which\n   time than might be required with applications\
    \ such as file transfer.\n   Time-bounded delivery usually also implies a semi-reliable\
    \ protocol,\n   but the converse does not necessarily hold.\n"
- title: 3.  Network Constraints
  contents:
  - "3.  Network Constraints\n   The properties of the network in which the application\
    \ is being\n   deployed may themselves constrain the reliable multicast design\n\
    \   space.\n"
- title: 3.1.  Internet vs Intranet
  contents:
  - "3.1.  Internet vs Intranet\n   In principle the Internet and intranets are the\
    \ same.  In practice\n   however, the fact that an intranet is under one administration\
    \ might\n   allow for solutions to be configured that can not easily be done in\n\
    \   the public Internet.  Thus, if the data is of very high value, it\n   might\
    \ be appropriate to enhance the routers to provide assistance to\n   a reliable\
    \ multicast transport protocol.  In the public Internet, it\n   is less likely\
    \ that the additional expense required to support this\n   state in the routers\
    \ would be acceptable.\n"
- title: 3.2.  Return Path
  contents:
  - "3.2.  Return Path\n   In principle, when feedback is required from receivers,\
    \ this feedback\n   can be multicast or unicast.  Multicast feedback has advantages,\n\
    \   especially in NACK-based protocols where it is valuable for NACK\n   suppression.\
    \  However, it is not clear at this time whether all ISPs\n   will allow all members\
    \ of a session to send to that session.  If\n   multicast feedback is not allowed,\
    \ then unicast feedback can almost\n   always be substituted, although often at\
    \ the expense of additional\n   messages and mechanisms.\n   Some networks may\
    \ not allow any form of feedback however.  The\n   primary example of this occurs\
    \ with satellite broadcasts where the\n   back channel may be very narrow or even\
    \ non-existent.  For such\n   networks the solution space is very constrained\
    \ - only FEC-based\n   encodings have any real chance of working.  If the receivers\
    \ are\n   direct satellite receivers, then no congestion control is needed, but\n\
    \   it is dangerous to make such assumptions because it is possible for a\n  \
    \ satellite hop to feed downstream networks.  Thus, congestion control\n   still\
    \ needs to be considered with solutions that do not have a return\n   path.\n"
- title: 3.3.  Network Assistance
  contents:
  - "3.3.  Network Assistance\n   A reliable multicast protocol must involve mechanisms\
    \ running in end\n   hosts, and must involve routers forwarding multicast packets.\n\
    \   However under some circumstances, it is possible to rely on some\n   additional\
    \ degree of assistance from network elements.  Broadly\n   speaking we can cluster\
    \ RM protocols into four classes depending on\n   the degree of support received\
    \ from other network elements.\n   No Additional Support\n      The routers merely\
    \ forward packets, and only the sender and\n      receivers have any reliable\
    \ multicast protocol state.\n   Layered Approaches\n      Data is split across\
    \ multiple multicast groups.  Receivers join\n      appropriate groups to receive\
    \ only the traffic they require.  This\n      may in some cases require fast join\
    \ or leave functionality from\n      the routers, and may require more forwarding\
    \ state in the routers.\n   Server-based Approaches\n      Additional nodes are\
    \ used to assist with data delivery or feedback\n      aggregation.  These additional\
    \ nodes might not be normal senders\n      or receivers, and may be present on\
    \ the distribution or feedback\n      tree only to provide assistance to the reliable\
    \ multicast\n      protocol.  They would not otherwise receive the multicast traffic.\n\
    \   Router-based Approaches\n      With router-based approaches, routers on the\
    \ normal data\n      distribution tree from the sender to the receivers assist\
    \ in the\n      delivery of data or feedback aggregation or suppression.  As\n\
    \      routers can directly influence multicast routing, they have more\n    \
    \  control over which traffic goes to which group members than\n      server-based\
    \ approaches.  However routers do not normally have a\n      large amount of spare\
    \ memory or processing power, which restricts\n      how much functionality can\
    \ be placed in the routers.  In addition,\n      router code is normally more\
    \ difficult to upgrade than application\n      code, so router-based approaches\
    \ need to be very general as they\n      are more difficult to deploy and to change.\n"
- title: 4.  Good Throughput Mechanisms
  contents:
  - "4.  Good Throughput Mechanisms\n   Two main concerns that a RM protocol must\
    \ address are congestion\n   control and good throughput.  Packet loss plays a\
    \ major role with\n   respect to both concerns.  The primary symptom of congestion\
    \ in many\n   networks is packet loss. The primary obstacle that must be overcome\n\
    \   to achieve good throughput is packet loss.  Thus, measuring and\n   reacting\
    \ to packet loss is crucial to address both concerns. RM\n   solutions that address\
    \ these concerns can be roughly categorized as\n   using one or more of the following\
    \ techniques:\n   o  Data packet acknowledgment.\n   o  Negative acknowledgment\
    \ of missing data packets.\n   o  Redundancy allowing not all packets to be received.\n\
    \   These techniques themselves can be usefully subdivided, so that we\n   can\
    \ examine the parts of the requirement space in which each\n   mechanism can be\
    \ deployed.  In this section, we focus on using these\n   mechanisms for achieving\
    \ good throughput, and in the next section we\n   focus on using these mechanisms\
    \ for congestion control.\n"
- title: 4.1.  ACK-based Mechanisms
  contents:
  - "4.1.  ACK-based Mechanisms\n   The simplest ACK-based mechanism involves every\
    \ receiver sending an\n   ACK packet for every data packet it receives and resending\
    \ packets\n   that are lost by any receiver.  Such mechanisms are limited to very\n\
    \   small receiver groups by the implosion of ACKs received at the\n   sender,\
    \ and for this reason they are impractical for most\n   applications.\n   Putting\
    \ multiple ACKs into a single data packet [RMWT98] reduces the\n   implosion problem\
    \ by a constant amount, allowing slightly larger\n   receiver groups.  However\
    \ a limit is soon reached whereby feedback to\n   the sender is too infrequent\
    \ for sender-based congestion control\n   mechanisms to work reliably.\n   Arranging\
    \ the receivers into a ring [WKM94] whereby an \"ACK-token\" is\n   passed around\
    \ the ring prevents the implosion problem for data.\n   However ring creation\
    \ and maintenance may itself be problematic.\n   Also if ring creation does not\
    \ take into account network topology\n   (something which is difficult to achieve\
    \ in practice), then the\n   number of ACK packets crossing the network backbone\
    \ for each data\n   packet sent may increase O(n) with the number of receivers.\n"
- title: 4.1.1.  Tree-based ACK Mechanisms
  contents:
  - "4.1.1.  Tree-based ACK Mechanisms\n   Arranging the receivers into a tree [MWB+98,\
    \ KCW98] whereby receivers\n   generate ACKs to a parent node, which aggregates\
    \ those ACKs to its\n   parent in turn, is both more robust and more easily configured\
    \ than a\n   ring.  The ACK-tree is typically only used for ACK-aggregation -\
    \ data\n   packets are multicast from the sender to the receivers as normal.\n\
    \   Trees are easier to construct than rings because more local\n   information\
    \ can be used in their construction.  Also they can be more\n   fault tolerant\
    \ than rings because node failures only affect a subset\n   of receivers, each\
    \ of which can easily and locally decide to by-pass\n   its parent and report\
    \ directly to the node one level higher in the\n   tree.  With good ACK-tree formation,\
    \ tree-based ACK mechanisms have\n   the potential to be one of the most scalable\
    \ RM solutions.\n   To be simple to deploy, tree-based protocols must be self-organizing\n\
    \   - the receivers must form the tree themselves using local information\n  \
    \ in a scalable manner.  Such mechanisms are possible, but are not\n   trivial.\
    \  The main scaling limitations of tree-based protocols\n   therefore come from\
    \ the tree formation and maintenance mechanisms\n   rather than from the use of\
    \ ACKs.  Without such a scalable and\n   automatic tree-formation mechanism, tree-based\
    \ protocols must rely on\n   manual configuration, which significantly limits\
    \ their applicability\n   (often to intranets) and (due to the complexity of configuration)\n\
    \   their scalability.\n   Orthogonal to the issue of tree formation is the issue\
    \ of subtree\n   retransmission.  With appropriate router mechanisms, or the use\
    \ of\n   multiple multicast groups, it is possible to allow the intermediate\n\
    \   tree nodes to retransmit missing data to the nodes below them in the\n   tree\
    \ rather than relying on the original sender to retransmit the\n   data.  This\
    \ relies on there being a good correlation at the point of\n   the intermediate\
    \ node between the ACK tree and the actual data tree,\n   as well as there being\
    \ a mechanism to constrain the retransmission to\n   the subtree.  A good automatic\
    \ tree formation mechanism combined with\n   the use of administrative scoped\
    \ multicast groups might provide such\n   a solution. Without such tree formation\
    \ mechanisms, subtree\n   retransmission is difficult to deploy in large groups\
    \ in the public\n   internet.       This could also be solved by the use of transport-\n\
    \   level router mechanisms to assist or perform retransmission, although\n  \
    \ existing router mechanisms [FLST98] support NACK-based rather than\n   ACK-based\
    \ protocols.\n   Another important issue is the nature of the aggregation performed\
    \ at\n   interior nodes on the ACK-tree.  Such nodes could:\n   1. aggregate ACKs\
    \ by sending a single ACK when all their children\n      have ACKed,\n   2. aggregate\
    \ ACKs by listing all the children that have ACKed,\n   3. send an aggregated\
    \ ACK with a NACK-like exception list.\n   For data packets, 1. is clearly more\
    \ scalable, and should be\n   preferred.  However if the sender needs to know\
    \ exactly which\n   receivers received the data, 2. and 3. provide this information.\n\
    \   Fortunately, there is usually no need to do this on a per-packet\n   basis,\
    \ but rather on a per-ADU basis.  Doing 1. on a per packet\n   basis, and 3. on\
    \ a per ADU basis is the most scalable solution for\n   applications that need\
    \ this information, and suffers virtually no\n   disadvantage compared to the\
    \ other solutions used on a per-packet\n   basis.\n"
- title: 4.2.  NACK-based mechanisms
  contents:
  - "4.2.  NACK-based mechanisms\n   Instead of sending an ACK for every data packet\
    \ received, receivers\n   can send a negative acknowledgment (NACK) for every\
    \ data packet they\n   discover they did not receive.  This has a number of advantages\
    \ over\n   ACK-based mechanisms:\n   o  The sender no longer needs to know exactly\
    \ how many receivers\n      there are.  This removes the topology-building phase\
    \ needed for\n      ring- or tree-style ACK-based algorithms.\n   o  Fault-tolerance\
    \ is made somewhat simpler by making receivers\n      responsible for reliability.\n\
    \   o  Sender state can be significantly reduced because the sender does\n   \
    \   not need to keep track of the receivers state.\n   o  Only a single NACK is\
    \ needed from any receiver to indicate a\n      packet that is missing by any\
    \ number of receivers.  Thus NACK\n      suppression is possible.\n   The disadvantages\
    \ are that it is more difficult for the sender to\n   know that it can free transmission\
    \ buffers, and that additional\n   session level mechanisms are needed if the\
    \ sender really needs to\n   know if a particular receiver actually received all\
    \ the data.\n   However for many applications, neither of these is an issue.\n"
- title: 4.2.1.  NACK Suppression
  contents:
  - "4.2.1.  NACK Suppression\n   The key differences between NACK-based protocols\
    \ is in how NACK-\n   suppression is performed.  The goal is for only one NACK\
    \ to reach the\n   sender (or a node that can resend the missing data) as soon\
    \ as\n   possible after the loss is first noticed, and for only one copy of\n\
    \   the missing data to be received by those nodes needing\n   retransmission.\n\
    \   Different mechanisms come close to satisfying these goals in\n   different\
    \ ways.\n   o  SRM [FJM95] uses random timers weighted by the round trip time\n\
    \      between the sender and each node missing the data.  This is\n      effective,\
    \ but requires computing the RTT to each receiver before\n      suppression works\
    \ properly.\n   o  NTE [HC97] uses a sender-triggered mechanism based on random\
    \ keys\n      and sliding masks.  This does not require random timers, and works\n\
    \      for very large sessions, but makes it difficult to provide the\n      constant\
    \ low-level stream of feedback needed to perform congestion\n      control.\n\
    \   o  AAP [Ha99] uses exponentially distributed random timers and is\n      effective\
    \ for large sessions without needing to compute the RTT to\n      each receiver.\n\
    \   o  PGM [FLST98] and LMS [PPV98] use additional mechanisms in routers\n   \
    \   to suppress duplicate NACKs.  In the case of PGM, router\n      assistance\
    \ suppliments SRM-stype random timers and localizes the\n      suppression so\
    \ that the whole group does not need suppressing.\n   The most general of these\
    \ mechanisms is probably exponentially\n   weighted random timers.  Although SRM\
    \ style timers can reduce\n   feedback delay, they are harder to use correctly\
    \ in situations where\n   all the RTTs are not known, or where the number of respondees\
    \ is\n   unknown.  In contrast, exponentially weighted random timers work well\n\
    \   across a large range of session sizes with good worst case delay\n   characteristics.\n\
    \   Either form of random timer based mechanism can be supplemented by\n   router-support\
    \ where it is available.  Sender triggered NACK\n   mechanisms (e.g. [HC97]) are\
    \ more difficult to integrate with\n   router-based support mechanisms.\n"
- title: 4.3.  Replication
  contents:
  - "4.3.  Replication\n   Some RM protocols can be designed so as to not need explicit\n\
    \   reliability mechanisms except in comparatively rare cases.  An\n   example\
    \ is in a multicast game, where the position of a moving object\n   is continuously\
    \ multicast.  This positional stream does not require\n   additional reliability\
    \ because a new position superseding the old one\n   will be sent before any retransmission\
    \ could take place.  However,\n   when the moving object interacts with other\
    \ objects or stops moving,\n   then an explicit reliability mechanism is required\
    \ to reliably send\n   the interaction information or last position.\n   It is\
    \ not just games that can be built in this manner - the NTE\n   shared text editor[HC97]\
    \ uses just such a mechanism with changes to a\n   line of text.  For every change\
    \ the whole line is sent, and so long\n   as the user keeps typing no explicit\
    \ reliability mechanism is needed.\n   The major advantage of replication is that\
    \ it is not susceptible to\n   spatially uncorrelated packet loss.  With a traditional\
    \ ACK or NACK\n   based protocol, the probability of any particular packet being\n\
    \   received by all the receivers in a large group can be very low.  This\n  \
    \ leads to high retransmission rates.      In contrast, replicated\n   streams\
    \ do not suffer as the size of the receiver group increases -\n   different receivers\
    \ lose different packets, but this does not\n   increase network traffic.\n"
- title: 4.4.  Packet-level Forward Error Correction
  contents:
  - "4.4.  Packet-level Forward Error Correction\n   Forward Error Correction (FEC)\
    \ is a well known technique for\n   protecting data against corruption.  For reliable\
    \ multicast it is\n   most useful in the form of erasure codes.\n   The simplest\
    \ form of packet-level FEC is to take a group of packets\n   that is to be sent,\
    \ and to XOR the packets together to form a\n   newpacket which is also sent.\
    \  If there were three original packets\n   plus the XOR packet sent, then if\
    \ a receiver is missing any one of\n   the original data packets, but receives\
    \ the XOR packet, then it can\n   reproduce the missing original packet.\n   More\
    \ general erasure codes exist [BKKKLZ95], [Ri97], [LMSSS97] that\n   allow the\
    \ generation of n encoding packets from k original data\n   packets.  In such\
    \ cases, so long as at least k of the n encoding\n   packets are received, then\
    \ the k original data packets can be\n   reproduced.\n   To apply FEC the sender\
    \ groups data packets into rounds, and encoding\n   packets are produced based\
    \ on all the data packets in a round. A\n   round may consist of all data packets\
    \ in an entire application data\n   unit in some cases, whereas in other cases\
    \ it may consist of a group\n   of data packets that make up only a small portion\
    \ of an application\n   data unit.\n   Using erasure codes to repair packet loss\
    \ is a significant\n   improvement over simple retransmission because the dependency\
    \ on\n   which packets have been lost is removed.  Thus, the amount of repair\n\
    \   traffic required to repair spatially uncorrelated packet loss is\n   considerably\
    \ lessened.\n   We can divide packet-level FEC schemes into two categories: proactive\n\
    \   FEC and reactive FEC.  The difference between the two is that for\n   proactive\
    \ FEC the sender decides a priori how many encoding packets\n   to send for each\
    \ round of data packets, whereas for reactive FEC the\n   sender initially transmits\
    \ only the original data packets for each\n   round.  Then, the sender uses feedback\
    \ from the receivers to compute\n   how many packets were lost by the receiver\
    \ that experienced the most\n   loss in each round, and then only that number\
    \ of additional encoding\n   packets are sent for that round.  These encoding\
    \ packets will then\n   also serve to repair loss at the other receivers that\
    \ are missing\n   fewer packets.  The receivers report via ACKs or NACKs how many\n\
    \   packets are missing from each round. With NACKs, only the receiver\n   missing\
    \ the most packets need send a NACK for this round, so this is\n   used to weight\
    \ the random timers in the NACK calculation.\n   Proactive and reactive FEC can\
    \ be combined, e.g., a certain amount of\n   proactive FEC can be sent for each\
    \ round and if there are receivers\n   that experience more loss than can be overcome\
    \ by this for some\n   rounds then they can request and receive additional encoding\
    \ packets\n   for these rounds.\n   FEC is very effective at reducing the repair\
    \ traffic for packet loss.\n   However, it requires that the data to be sent to\
    \ be grouped into\n   rounds, which can add to end-to-end latency.  For bulk-data\n\
    \   applications this is typically not a problem, but this may be an\n   issue\
    \ for interactive applications where replication may be a better\n   solution.\n"
- title: 4.5.  Layered FEC
  contents:
  - "4.5.  Layered FEC\n   An alternative use of packet level FEC is possible when\
    \ data is\n   spread across several multicast groups [RVC98], [BLMR98].  In such\n\
    \   cases, the original k data packets are used to generate n encoding\n   packets,\
    \ where n is much larger than k.  The n encoded packets are\n   then striped across\
    \ multiple multicast groups.  When a receiver\n   wishes to receive the original\
    \ data it joins one or more of the\n   multicast groups, and receives the encoding\
    \ packets.  Once it has\n   received k different encoding packets, the receiver\
    \ can then leave\n   all the multicast groups and reconstruct the original data.\n\
    \   The primary importance of such a layering is that it allows different\n  \
    \ receivers to be able to receive the traffic at different rates\n   according\
    \ to the available capacity.  Such schemes do not require any\n   form of feedback\
    \ from the receivers to the sender to ensure good\n   throughput, and therefore\
    \ the need for good throughput does not\n   constrain the size of the receiver\
    \ set.  However, to perform adequate\n   network congestion control using receiver\
    \ joins and leaves in this\n   manner may require coordination between members\
    \ that are behind the\n   same congested link from the sender.  As described in\
    \ the next\n   section, [RVC98] suggests such a layered congestion control scheme.\n"
- title: 5.  Congestion Control Mechanisms
  contents:
  - "5.  Congestion Control Mechanisms\n   The basic delivery model of the Internet\
    \ is best-effort service.  No\n   guarantees are given as to throughput, delay\
    \ or packet loss.  End-\n   systems are expected to be adaptive, and to reduce\
    \ their transmission\n   rate to a level appropriate for the congestion state\
    \ of the network.\n   Although increasingly the Internet will start to support\
    \ reserved\n   bandwidth and differentiated service classes for specialist\n \
    \  applications, unless an end-system knows explicitly that it has\n   reserved\
    \ bandwidth, it must still perform congestion control.\n   Broadly speaking, there\
    \ are five classes of single-sender multicast\n   congestion control solution:\n\
    \   o  Sender-controlled, one group.\n      A single multicast group is used for\
    \ data distribution.  Feedback\n      from the group members is used to control\
    \ the rate of this group.\n      The goal is to transmit at a rate dictated by\
    \ the slowest\n      receiver.\n   o  Sender-controlled, multiple groups.\n  \
    \    One initial multicast group is adaptively subdivided into multiple\n    \
    \  subgroups with subdivisions centered on congestion points in the\n      network.\
    \  Application-level relays buffer data from a group nearer\n      the original\
    \ sender, and retransmit it at a slower rate into a\n      group further from\
    \ the original sender.  In this way, different\n      receivers can receiver the\
    \ data at different rates.  Sender-based\n      congestion control takes place\
    \ between the members of a subgroup\n      and their relay.\n   o  Receiver-controlled,\
    \ one group.\n      A single multicast group is used for data distribution.  The\n\
    \      receivers determine if the sender is transmitting too rapidly for\n   \
    \   the current congestion state of the network, and they leave the\n      group\
    \ if this is the case.\n   o  Receiver-controlled, layered organization.\n   \
    \   A layered approach for how to combine this scheme with a\n      congestion\
    \ control protocol that requires no receiver feedback is\n      described in [RVC98].\
    \  The sender stripes data across multiple\n      multicast groups simultaneously.\
    \  Receivers join and leave these\n      layered groups depending on their measurements\
    \ of the congestion\n      state of the network, so that the amount of data being\
    \ received is\n      always appropriate. However, this scheme relies on receivers\
    \ to\n      join and leave the different multicast groups in a coordinated\n \
    \     fashion behind a bottleneck link, and it has not yet been\n      completely\
    \ confirmed that this approach will scale in practice to\n      the Internet.\
    \  As a result, more work on this congestion control\n      mechanism would be\
    \ beneficial.\n   o  Router-based congestion control.\n      It is possible to\
    \ add additional mechanisms to multicast routers\n      to assist in multicast\
    \ congestion control.  Such mechanisms could\n      include:\n      o  Conditional\
    \ joins (a multicast join that specifies a loss rate\n         above which it\
    \ is acceptable for the router to reject the\n         join).\n      o  Router\
    \ filtering of traffic that exceeds a reasonable rate.\n         This may include\
    \ mechanisms for filtering traffic at different\n         points in the network\
    \ at different rates depending on local\n         congestion conditions [LVS99].\n\
    \      o  Fair queuing schemes combined with end-to-end adaptation.\n      Router-based\
    \ schemes generally require more state in network\n      routers than has traditionally\
    \ been acceptable for backbone\n      routers.  Thus, in the near-term, such schemes\
    \ are only likely to\n      be applicable for intranet solutions.\n   For reliable\
    \ multicast protocols, it is important to consider\n   congestion control at the\
    \ same time as reliability is being\n   considered.  The same mechanisms that\
    \ are used to provide reliability\n   will sometimes be used to provide congestion\
    \ control.\n   In the case of receiver-based congestion control, open-loop delivery\n\
    \   using FEC is the likely choice for achieving good throughput for\n   bulk-\
    \ data transfer.  This is because open-loop delivery requires no\n   feedback\
    \ from receivers, and thus it is a perfect match with a\n   receiver-based congestion-control\
    \ mechanism that operates without\n   feedback from receivers.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   Generally speaking, security considerations have\
    \ relatively little\n   effect on constraining the design space for reliable multicast\n\
    \   protocols.  The primary issues constraining the design space are all\n   related\
    \ to receiver-set scaling.  For authentication of the source\n   and of data integrity,\
    \ receiver-set scaling is not a significant\n   issue.  However, for data encryption,\
    \ key distribution and\n   particularly re-keying may be significantly affected\
    \ by receiver-set\n   scaling.  Tree and graph based re-keying solutions[WHA98,WGL97]\
    \ would\n   appear to be appropriate solutions to these problems.  It is not\n\
    \   clear however that such re-keying solutions need to directly affect\n   the\
    \ design of the data distribution part of a reliable multicast\n   protocol.\n\
    \   The primary question to consider for the security of reliable\n   multicast\
    \ protocols is the role of third-parties.  If nodes other\n   than the original\
    \ source of the data are allowed to send or resend\n   data packets, then the\
    \ security model for the protocol must take this\n   into account.  In particular,\
    \ it must be clear whether such third\n   parties are trusted or untrusted.  A\
    \ requirement for trusted third\n   parties can make protocols difficult to deploy\
    \ on the Internet.\n   Untrusted third parties (such as receivers that retransmit\
    \ the data)\n   may be used so long as the data authentication mechanisms take\
    \ this\n   into account.  Typically this means that the original sender\n   digitally\
    \ signs and timestamps the data, and that the third parties\n   resend this signed\
    \ timestamped payload unmodified.\n   Unlike unicast protocols, denial-of-service\
    \ attacks on multicast\n   transport state are easy if the protocol design does\
    \ not take such\n   attacks into account.  This is because any receiver can join\
    \ the\n   session, and can then produce feedback that influences the progress\n\
    \   of a session involving many other receivers.  Hence protection\n   against\
    \ denial-of-service attacks on reliable multicast protocols\n   must be carefully\
    \ considered.  A receiver that requests\n   retransmission of every packet, or\
    \ that refuses to acknowledge\n   packets in an ACK-based protocol can potentially\
    \ bring a reliable\n   multicast session to a standstill.  Senders must have appropriate\n\
    \   policy to deal with such conditions, and if necessary, evict the\n   receiver\
    \ from the group.  A single receiver masquerading as a large\n   number of receivers\
    \ may still be an issue under such circumstances\n   with protocols that support\
    \ NACK-like functionality.  Providing\n   unique \"keys\" to each NACKer when\
    \ they first NACK using a unicast\n   response might potentially prevent such\
    \ attacks.\n   Denial-of-service attacks caused by traffic flooding are however\n\
    \   somewhat easier to protect against than with unicast.  Unwanted\n   senders\
    \ can simply be pruned from the distribution tree using the\n   mechanisms implemented\
    \ in IGMP v3[CDT99].\n"
- title: 7.  Conclusions
  contents:
  - "7.  Conclusions\n   In this document we present an overview of the design space\
    \ for\n   reliable multicast within the context of one-to-many bulk-data\n   transfer.\
    \ Other flavors of multicast application are not considered\n   in this document,\
    \ and hence the overview given should not be\n   considered inclusive of the design\
    \ space for protocols that fall\n   outside the context of one-to-many bulk-data\
    \ transfer. During the\n   course of this overview, we have reaffirmed the notion\
    \ that the\n   process of reliable multicast protocol design is affected by a\
    \ number\n   of factors that render the generation of a \"one size fits all\n\
    \   solution\" moot. These factors are then described to show how an\n   application's\
    \ needs serve to constrain the set of available\n   techniques that may be used\
    \ to create a reliable multicast protocol.\n   We examined a number of basic techniques\
    \ and to show how well they\n   can meet the needs of certain types of applications.\n\
    \   This document is intended to provide guidance to the IETF community\n   regarding\
    \ the standardization of reliable multicast protocols for\n   bulk-data transfer.\
    \ Given the degree to which application\n   requirements constrain reliable multicast\
    \ solutions, and the diverse\n   set of applications that need to be supported,\
    \ it should be clear\n   that any standardization work should take great pains\
    \ to be future-\n   proof.  This would seem to imply not standardizing complete\
    \ reliable\n   multicast transport protocols in one pass, but rather examining\
    \ the\n   degree to which such protocols are separable into functional building\n\
    \   blocks, and standardizing these blocks separately to the maximum\n   degree\
    \ that makes sense.  Such an approach allows for protocol\n   evolution, and allows\
    \ applications with new constraints to be\n   supported with maximal reuse of\
    \ existing and tested mechanisms.\n"
- title: 8.  Acknowledgments
  contents:
  - "8.  Acknowledgments\n   This document represents an overview of the reliable\
    \ multicast design\n   space.  The ideas presented are not those of the authors,\
    \ but are\n   collected from the varied presentations and discussions in the IRTF\n\
    \   Reliable Multicast Research Group.  Although they are too numerous to\n  \
    \ list here, we thank everyone who has participated in these\n   discussions for\
    \ their contributions.\n"
- title: 9.  Authors' Addresses
  contents:
  - "9.  Authors' Addresses\n   Mark Handley\n   ATT Center for Internet Research\
    \ at ICSI,\n   International Computer Science Institute,\n   1947 Center Street,\
    \ Suite 600,\n   Berkeley, CA 94704, USA\n   EMail: mjh@aciri.org\n   Sally Floyd\n\
    \   ATT Center for Internet Research at ICSI,\n   International Computer Science\
    \ Institute,\n   1947 Center Street, Suite 600,\n   Berkeley, CA 94704, USA\n\
    \   EMail: floyd@aciri.org\n   Brian Whetten\n   Talarian Corporation,\n   333\
    \ Distel Circle,\n   Los Altos, CA 94022, USA\n   EMail: whetten@talarian.com\n\
    \   Roger Kermode\n   Motorola Australian Research Centre\n   Level 3, 12 Lord\
    \ St,\n   Botany  NSW  2019,\n   Australia\n   EMail: Roger.Kermode@motorola.com\n\
    \   Lorenzo Vicisano\n   Cisco Systems,\n   170 West Tasman Dr.\n   San Jose,\
    \ CA 95134, USA\n   EMail: lorenzo@cisco.com\n   Michael Luby\n   Digital Fountain,\
    \ Inc.\n   600 Alabama Street\n   San Francisco, CA  94110\n   EMail: luby@digitalfountain.com\n"
- title: 10.  References
  contents:
  - "10.  References\n   [BC94]     K. Birman, T. Clark.  \"Performance of the Isis\
    \ Distributed\n              Computing Toolkit.\" Technical Report TR-94-1432,\
    \ Dept. of\n              Computer Science, Cornell University.\n   [BKKKLZ95]\
    \ J. Bloemer, M. Kalfane, M. Karpinski, R. Karp, M. Luby, D.\n              Zuckerman,\
    \ \"An XOR-based Erasure Resilient Coding Scheme\",\n              ICSI Technical\
    \ Report No. TR-95-048, August 1995.\n   [BLMR98]   J. Byers, M. Luby, M. Mitzenmacher,\
    \ A. Rege, \"A Digital\n              Fountain Approach to Reliable Distribution\
    \ of Bulk Data\",\n              Proc ACM SIGCOMM 98.\n   [CDT99]    Cain, B.,\
    \ Deering, S., and A. Thyagarajan, \"Internet Group\n              Management\
    \ Protocol, Version 3\", Work in Progress.\n   [FLST98]   Farinacci, D., Lin,\
    \ S., Speakman, T. and A. Tweedly, \"PGM\n              reliable transport protocol\
    \ specification\", Work in\n              Progress.\n   [FJM95]    S. Floyd, V.\
    \ Jacobson, S. McCanne, \"A Reliable Multicast\n              Framework for Light-weight\
    \ Sessions and Application Level\n              Framing\", Proc ACM SIGCOMM 95,\
    \ Aug 1995 pp. 342-356.\n   [Ha99]     Handley, M., \"Multicast address allocation\
    \ protocol\n              (AAP)\", Work in Progress.\n   [HC97]     M. Handley\
    \ and J. Crowcroft, \"Network text editor (NTE) a\n              scalable shared\
    \ text editor for MBone,\" ACM Computer\n              Communication Review, vol.\
    \ 27, pp. 197-208, Oct. 1997. ACM\n              SIGCOMM'97, Sept. 1997.\n   [KCW98]\
    \    Kadansky, M., Chiu, D. and J. Wesley, \"Tree-based reliable\n           \
    \   multicast (TRAM)\", Work in Progress.\n   [LMSSS97]  M. Luby, M. Mitzenmacher,\
    \ A. Shokrollahi, D. Spielman, V.\n              Stemann, \"Practical Loss-Resilient\
    \ Codes\", Proc ACM\n              Symposium on Theory of Computing, 1997.\n \
    \  [MWB+98]   Montgomery, T., Whetten, B., Basavaiah, M., Paul, S.,\n        \
    \      Rastogi, N., Conlan, J. and T. Yeh, \"THE RMTP-II\n              PROTOCOL\"\
    , Work in Progress.\n   [PPV98]    C. Papadopoulos, G. Parulkar, and G. Varghese,\
    \ \"An error\n              control scheme for large-scale multicast applications,\"\
    \ in\n              Proceedings of the Conference on Computer Communications\n\
    \              (IEEE Infocom), (San Francisco, California), p. 1188,\n       \
    \       March/April 1998.\n   [Ri97]     L. Rizzo, \"Effective erasure codes for\
    \ reliable computer\n              communication protocols,\" ACM Computer Communication\n\
    \              Review, vol.  27, pp. 24-36, Apr. 1997.\n   [RV97]     L. Rizzo,\
    \ L. Vicisano, \"A Reliable Multicast data\n              Distribution Protocol\
    \ based on software FEC techniques\",\n              Proc. of The Fourth IEEE\
    \ Workshop on the Architecture and\n              Implementation of High Performance\
    \ Communication Systems\n              (HPCS'97), Sani Beach, Chalkidiki, Greece\
    \ June 23-25,\n              1997.\n   [RVC98]    L. Rizzo, L. Vicisano, J. Crowcroft,\
    \ \"The RLC multicast\n              congestion control algorithm\", submitted\
    \ to IEEE Network -\n              special issue multicast.\n   [RMWT98]   Robertson,\
    \ K., Miller, K., White, M. and A. Tweedly,\n              \"StarBurst multicast\
    \ file transfer protocol (MFTP)\n              specification\", Work in Progress.\n\
    \   [WHA98]    Wallner, D., Hardler, E. and R. Agee, \"Key Management for\n  \
    \            Multicast: Issues and Architectures\", RFC 2627, June 1999.\n   [WKM94]\
    \    Brian Whetten, Simon Kaplan, and Todd Montgomery, \"A high\n            \
    \  performance totally ordered multicast protocol,\" research\n              memorandum,\
    \ Aug. 1994.\n   [WGL97]    C.K. Wong, M. Gouda, S. Lam, \"Secure Group Communications\n\
    \              Using Key Graphs,\" Technical Report TR 97-23, Department\n   \
    \           of Computer Sciences, The University of Texas at Austin,\n       \
    \       July 1997.\n"
- title: 11.  Full Copyright Statement
  contents:
  - "11.  Full Copyright Statement\n   Copyright (C) The Internet Society (2000).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
