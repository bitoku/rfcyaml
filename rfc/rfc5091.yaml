- title: __initial_text__
  contents:
  - "            Identity-Based Cryptography Standard (IBCS) #1:\n  Supersingular\
    \ Curve Implementations of the BF and BB1 Cryptosystems\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: IESG Note
  contents:
  - "IESG Note\n   This document specifies two mathematical algorithms for identity\n\
    \   based encryption (IBE).  Due to its specialized nature, this document\n  \
    \ experienced limited review within the IETF.  Readers of this RFC\n   should\
    \ carefully evaluate its value for implementation and\n   deployment.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes the algorithms that implement Boneh-Franklin\n\
    \   (BF) and Boneh-Boyen (BB1) Identity-based Encryption.  This document\n   is\
    \ in part based on IBCS #1 v2 of Voltage Security's Identity-based\n   Cryptography\
    \ Standards (IBCS) documents, from which some irrelevant\n   sections have been\
    \ removed to create the content of this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \      1.1. Sending a Message That Is Encrypted Using IBE ..............5\n  \
    \         1.1.1. Sender Obtains Recipient's Public Parameters ........6\n    \
    \       1.1.2. Construct and Send an IBE-Encrypted Message .........6\n      1.2.\
    \ Receiving and Viewing an IBE-Encrypted Message .............7\n           1.2.1.\
    \ Recipient Obtains Public Parameters from PPS ........8\n           1.2.2. Recipient\
    \ Obtains IBE Private Key from PKG ..........8\n           1.2.3. Recipient Decrypts\
    \ IBE-Encrypted Message ............9\n   2. Notation and Definitions ........................................9\n\
    \      2.1. Notation ...................................................9\n  \
    \    2.2. Definitions ...............................................12\n   3.\
    \ Basic Elliptic Curve Algorithms ................................12\n      3.1.\
    \ The Group Action in Affine Coordinates ....................13\n           3.1.1.\
    \ Implementation for Type-1 Curves ...................13\n      3.2. Point Multiplication\
    \ ......................................14\n      3.3. Operations in Jacobian\
    \ Projective Coordinates .............17\n           3.3.1. Implementation for\
    \ Type-1 Curves ...................17\n      3.4. Divisors on Elliptic Curves\
    \ ...............................19\n           3.4.1. Implementation in F_p^2\
    \ for Type-1 Curves ..........19\n      3.5. The Tate Pairing ..........................................21\n\
    \           3.5.1. Tate Pairing Calculation ...........................21\n  \
    \         3.5.2. The Miller Algorithm for Type-1 Curves .............21\n   4.\
    \ Supporting Algorithms ..........................................24\n      4.1.\
    \ Integer Range Hashing .....................................24\n           4.1.1.\
    \ Hashing to an Integer Range ........................24\n      4.2. Pseudo-Random\
    \ Byte Generation by Hashing ..................25\n           4.2.1. Keyed Pseudo-Random\
    \ Bytes Generator ................25\n      4.3. Canonical Encodings of Extension\
    \ Field Elements ...........26\n           4.3.1. Encoding an Extension Element\
    \ as a String ..........26\n           4.3.2. Type-1 Curve Implementation ........................27\n\
    \      4.4. Hashing onto a Subgroup of an Elliptic Curve ..............28\n  \
    \         4.4.1. Hashing a String onto a Subgroup of an\n                  Elliptic\
    \ Curve .....................................28\n           4.4.2. Type-1 Curve\
    \ Implementation ........................29\n      4.5. Bilinear Mapping ..........................................29\n\
    \           4.5.1. Regular or Modified Tate Pairing ...................29\n  \
    \         4.5.2. Type-1 Curve Implementation ........................30\n    \
    \  4.6. Ratio of Bilinear Pairings ................................31\n      \
    \     4.6.1. Ratio of Regular or Modified Tate Pairings .........31\n        \
    \   4.6.2. Type-1 Curve Implementation ........................32\n   5. The Boneh-Franklin\
    \ BF Cryptosystem .............................32\n      5.1. Setup .....................................................32\n\
    \           5.1.1. Master Secret and Public Parameter Generation ......32\n  \
    \         5.1.2. Type-1 Curve Implementation ........................33\n    \
    \  5.2. Public Key Derivation .....................................34\n      \
    \     5.2.1. Public Key Derivation from an Identity and\n                  Public\
    \ Parameters ..................................34\n      5.3. Private Key Extraction\
    \ ....................................35\n           5.3.1. Private Key Extraction\
    \ from an Identity, a\n                  Set of Public ......................................35\n\
    \      5.4. Encryption ................................................36\n  \
    \         5.4.1. Encrypt a Session Key Using an Identity and\n               \
    \   Public Parameters ..................................36\n      5.5. Decryption\
    \ ................................................37\n           5.5.1. Decrypt\
    \ an Encrypted Session Key Using\n                  Public Parameters, a Private\
    \ Key ...................37\n   6. The Boneh-Boyen BB1 Cryptosystem ...............................38\n\
    \      6.1. Setup .....................................................38\n  \
    \         6.1.1. Generate a Master Secret and Public Parameters .....38\n    \
    \       6.1.2. Type-1 Curve Implementation ........................39\n      6.2.\
    \ Public Key Derivation .....................................41\n           6.2.1.\
    \ Derive a Public Key from an Identity and\n                  Public Parameters\
    \ ..................................41\n      6.3. Private Key Extraction ....................................41\n\
    \           6.3.1. Extract a Private Key from an Identity,\n                 \
    \ Public Parameters and a Master Secret ..............41\n      6.4. Encryption\
    \ ................................................42\n           6.4.1. Encrypt\
    \ a Session Key Using an Identity and\n                  Public Parameters ..................................42\n\
    \      6.5. Decryption ................................................45\n  \
    \         6.5.1. Decrypt Using Public Parameters and Private Key ....45\n   7.\
    \ Test Data ......................................................47\n      7.1.\
    \ Algorithm 3.2.2 (PointMultiply) ...........................47\n      7.2. Algorithm\
    \ 4.1.1 (HashToRange) .............................48\n      7.3. Algorithm 4.5.1\
    \ (Pairing) .................................48\n      7.4. Algorithm 5.2.1 (BFderivePubl)\
    \ ............................49\n      7.5. Algorithm 5.3.1 (BFextractPriv) ...........................49\n\
    \      7.6. Algorithm 5.4.1 (BFencrypt) ...............................50\n  \
    \    7.7. Algorithm 6.3.1 (BBextractPriv) ...........................51\n    \
    \  7.8. Algorithm 6.4.1 (BBencrypt) ...............................52\n   8. ASN.1\
    \ Module ...................................................53\n   9. Security\
    \ Considerations ........................................58\n   10. Acknowledgments\
    \ ...............................................60\n   11. References ....................................................60\n\
    \      11.1. Normative References .....................................60\n  \
    \    11.2. Informative References ...................................60\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document provides a set of specifications for implementing\n\
    \   identity-based encryption (IBE) systems based on bilinear pairings.\n   Two\
    \ cryptosystems are described: the IBE system proposed by Boneh and\n   Franklin\
    \ (BF) [BF], and the IBE system proposed by Boneh and Boyen\n   (BB1) [BB1]. \
    \ Fully secure and practical implementations are\n   described for each system,\
    \ comprising the core IBE algorithms as well\n   as ancillary hybrid components\
    \ used to achieve security against\n   active attacks.  These specifications are\
    \ restricted to a family of\n   supersingular elliptic curves over finite fields\
    \ of large prime\n   characteristic, referred to as \"type-1\" curves (see Section\
    \ 2.1).\n   Implementations based on other types of curves currently fall outside\n\
    \   the scope of this document.\n   IBE is a public-key technology, but one which\
    \ varies from other\n   public-key technologies in a slight, yet significant way.\
    \  In\n   particular, IBE keys are calculated instead of being generated\n   randomly,\
    \ which leads to a different architecture for a system using\n   IBE than for\
    \ a system using other public-key technologies.  An\n   overview of these differences\
    \ and how a system using IBE works is\n   given in [IBEARCH].\n   Identity-based\
    \ encryption (IBE) is a public-key encryption technology\n   that allows a public\
    \ key to be calculated from an identity, and the\n   corresponding private key\
    \ to be calculated from the public key.\n   Calculation of both the public and\
    \ private keys in an IBE-based\n   system can occur as needed, resulting in just-in-time\
    \ key material.\n   This contrasts with other public-key systems [P1363], in which\
    \ keys\n   are generated randomly and distributed prior to secure communication\n\
    \   commencing.  The ability to calculate a recipient's public key, in\n   particular,\
    \ eliminates the need for the sender and receiver in an\n   IBE-based messaging\
    \ system to interact with each other, either\n   directly or through a proxy such\
    \ as a directory server, before\n   sending secure messages.\n   This document\
    \ describes an IBE-based messaging system and how the\n   components of the system\
    \ work together.  The components required for\n   a complete IBE messaging system\
    \ are the following:\n   o  a Private-key Generator (PKG).  The PKG contains the\
    \ cryptographic\n      material, known as a master secret, for generating an individual's\n\
    \      IBE private key.  A PKG accepts an IBE user's private key request,\n  \
    \    and after successfully authenticating them in some way, returns\n      the\
    \ IBE private key.\n   o  a Public Parameter Server (PPS).  IBE System Parameters\
    \ include\n      publicly sharable cryptographic material, known as IBE public\n\
    \      parameters, and policy information for the PKG.  A PPS provides a\n   \
    \   well-known location for secure distribution of IBE public\n      parameters\
    \ and policy information for the IBE PKG.\n   A logical architecture would be\
    \ to have a PKG/PPS per name space,\n   such as a DNS zone.  The organization\
    \ that controls the DNS zone\n   would also control the PKG/PPS and thus the determination\
    \ of which\n   PKG/PSS to use when creating public and private keys for the\n\
    \   organization's members.  In this case the PPS URI can be uniquely\n   created\
    \ by the form of the identity that it supports.  This\n   architecture would make\
    \ it clear which set of public parameters to\n   use and where to retrieve them\
    \ for a given identity.\n   IBE-encrypted messages can use standard message formats,\
    \ such as the\n   Cryptographic Message Syntax (CMS) [CMS].  How to use IBE with\
    \ CMS is\n   described in [IBECMS].\n   Note that IBE algorithms are used only\
    \ for encryption, so if digital\n   signatures are required, they will need to\
    \ be provided by an\n   additional mechanism.\n   The key words \"MUST\", \"MUST\
    \ NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\"\
    , \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted\
    \ as described in [KEYWORDS].\n"
- title: 1.1.  Sending a Message That Is Encrypted Using IBE
  contents:
  - "1.1.  Sending a Message That Is Encrypted Using IBE\n   In order to send an encrypted\
    \ message, an IBE user must perform the\n   following steps:\n      1.  Obtain\
    \ the recipient's public parameters.\n         The recipient's IBE public parameters\
    \ allow the creation of\n         unique public and private keys.  A user of an\
    \ IBE system is\n         capable of calculating the public key of a recipient\
    \ after he\n         obtains the public parameters for their IBE system.  Once\
    \ the\n         public parameters are obtained, IBE-encrypted messages can be\n\
    \         sent.\n      2.  Construct and send an IBE-encrypted message.\n    \
    \     All that is needed, in addition to the IBE public parameters,\n        \
    \ is the recipient's identity in order to generate their public\n         key\
    \ for use in encrypting messages to them.  When this identity\n         is the\
    \ same as the identity that a message would be addressed\n         to, then no\
    \ more information is needed from a user to send\n         someone a secure message\
    \ than is needed to send them an\n         unsecured message.  This is one of\
    \ the major benefits of an\n         IBE-based secure messaging system.  Examples\
    \ of identities can\n         be an individual, group, or role identifiers.\n"
- title: 1.1.1.  Sender Obtains Recipient's Public Parameters
  contents:
  - "1.1.1.  Sender Obtains Recipient's Public Parameters\n   The sender of a message\
    \ obtains the IBE public parameters that he\n   needs for calculating the IBE\
    \ public key of the recipient from a PPS\n   that is hosted at a well-known URI.\
    \  The IBE public parameters\n   contain all of the information that the sender\
    \ needs to create an\n   IBE-encrypted message except for the identity of the\
    \ recipient.\n   [IBEARCH] describes the URI where a PPS is located, the format\
    \ of IBE\n   public parameters, and how to obtain them.  The URI from which users\n\
    \   obtain IBE public parameters MUST be authenticated in some way; PPS\n   servers\
    \ MUST support Transport Layer Security (TLS) 1.1 [TLS] to\n   satisfy this requirement\
    \ and MUST verify that the subject name in the\n   server certificate matches\
    \ the URI of the PPS.  [IBEARCH] also\n   describes the way in which identity\
    \ formats are defined and a minimum\n   interoperable format that all PPSs and\
    \ PKGs MUST support.  This step\n   is shown below in Figure 1.\n            \
    \      IBE Public Parameter Request\n                 ----------------------------->\n\
    \          Sender                                PPS\n                 <-----------------------------\n\
    \                      IBE Public Parameters\n         Figure 1.  Requesting IBE\
    \ Public Parameters\n   The sender of an IBE-encrypted message selects the PPS\
    \ and\n   corresponding PKG based on his local security policy.  Different PPSs\n\
    \   may provide public parameters that specify different IBE algorithms\n   or\
    \ different key strengths, for example, or require the use of PKGs\n   that require\
    \ different levels of authentication before granting IBE\n   private keys.\n"
- title: 1.1.2.  Construct and Send an IBE-Encrypted Message
  contents:
  - "1.1.2.  Construct and Send an IBE-Encrypted Message\n   To IBE-encrypt a message,\
    \ the sender chooses a content encryption key\n   (CEK) and uses it to encrypt\
    \ his message and then encrypts the CEK\n   with the recipient's IBE public key\
    \ (for example, as described in\n   [CMS]).  This operation is shown below in\
    \ Figure 2.  This document\n   describes the algorithms needed to implement two\
    \ forms of IBE.\n   [IBECMS] describes how to use the Cryptographic Message Syntax\
    \ (CMS)\n   to encapsulate the encrypted message along with the IBE information\n\
    \   that the recipient needs to decrypt the message.\n                  CEK ---->\
    \ Sender ----> IBE-encrypted CEK\n                              ^\n          \
    \                    |\n                              |\n                    \
    \ Recipient's Identity\n                   and IBE Public Parameters\n       \
    \  Figure 2.  Using an IBE Public-Key Algorithm to Encrypt\n"
- title: 1.2.  Receiving and Viewing an IBE-Encrypted Message
  contents:
  - "1.2.  Receiving and Viewing an IBE-Encrypted Message\n   In order to read an\
    \ encrypted message, a recipient of an\n   IBE-encrypted message parses the message\
    \ (for example, as described\n   in [IBECMS]).  This gives him the URI he needs\
    \ to obtain the IBE\n   public parameters required to perform IBE calculations\
    \ as well as the\n   identity that was used to encrypt the message.  Next, the\
    \ recipient\n   must carry out the following steps:\n      1.  Obtain the recipient's\
    \ public parameters.\n         An IBE system's public parameters allow it to uniquely\
    \ create\n         public and private keys.  The recipient of an IBE-encrypted\n\
    \         message can decrypt an IBE-encrypted message if he has both the\n  \
    \       IBE public parameters and the necessary IBE private key.  The\n      \
    \   PPS can also provide the URI of the PKG where the recipient of\n         an\
    \ IBE-encrypted message can obtain the IBE private keys.\n      2.  Obtain the\
    \ IBE private key from the PKG.\n         To decrypt an IBE-encrypted message,\
    \ in addition to the IBE\n         public parameters, the recipient needs to obtain\
    \ the private\n         key that corresponds to the public key that the sender\
    \ used.\n         The IBE private key is obtained after successfully\n       \
    \  authenticating to a private key generator (PKG), a trusted\n         third\
    \ party that calculates private keys for users.  The\n         recipient receives\
    \ the IBE private key over an HTTPS\n         connection.  The URI of a PKG MUST\
    \ be authenticated in some\n         way; PKG servers MUST support TLS 1.1 [TLS]\
    \ to satisfy this\n         requirement.\n      3.  Decrypt the IBE-encrypted\
    \ message.\n         The IBE private key decrypts the CEK, which is then used\
    \ to\n         decrypt encrypted message.\n         The PKG may allow users other\
    \ than the intended recipient to\n         receive some IBE private keys.  Giving\
    \ a mail filtering\n         appliance permission to obtain IBE private keys on\
    \ behalf of\n         users, for example, can allow the appliance to decrypt and\
    \ scan\n         encrypted messages for viruses or other malicious features.\n"
- title: 1.2.1.  Recipient Obtains Public Parameters from PPS
  contents:
  - "1.2.1.  Recipient Obtains Public Parameters from PPS\n   Before he can perform\
    \ any IBE calculations related to the message\n   that he has received, the recipient\
    \ of an IBE-encrypted message needs\n   to obtain the IBE public parameters that\
    \ were used in the encryption\n   operation.  This operation is shown below in\
    \ Figure 3.\n                 IBE Public Parameter Request\n                ----------------------------->\n\
    \      Recipient                                PPS\n                <-----------------------------\n\
    \                     IBE Public Parameters\n           Figure 3.  Requesting\
    \ IBE Public Parameters\n"
- title: 1.2.2.  Recipient Obtains IBE Private Key from PKG
  contents:
  - "1.2.2.  Recipient Obtains IBE Private Key from PKG\n   To obtain an IBE private\
    \ key, the recipient of an IBE-encrypted\n   message provides the IBE public key\
    \ used to encrypt the message and\n   their authentication credentials to a PKG\
    \ and requests the private\n   key that corresponds to the IBE public key.  Section\
    \ 4 of this\n   document defines the protocol for communicating with a PKG as\
    \ well as\n   a minimum interoperable way to authenticate to a PKG that all IBE\n\
    \   implementations MUST support.  Because the security of IBE private\n   keys\
    \ is vital to the overall security of an IBE system, IBE private\n   keys MUST\
    \ be transported to recipients over a secure protocol.  PKGs\n   MUST support\
    \ TLS 1.1 [TLS] for transport of IBE private keys.  This\n   operation is shown\
    \ below in Figure 4.\n                   IBE Private Key Request\n           \
    \     ---------------------------->\n      Recipient                         \
    \       PKG\n                <----------------------------\n                 \
    \      IBE Private Key\n           Figure 4.  Obtaining an IBE Private Key\n"
- title: 1.2.3.  Recipient Decrypts IBE-Encrypted Message
  contents:
  - "1.2.3.  Recipient Decrypts IBE-Encrypted Message\n   After obtaining the necessary\
    \ IBE private key, the recipient uses\n   that IBE private key, and the corresponding\
    \ IBE public parameters, to\n   decrypt the CEK.  This operation is shown below\
    \ in Figure 5.  He then\n   uses the CEK to decrypt the encrypted message content\
    \ (for example,\n   as specified in [IBECMS]).\n      IBE-encrypted CEK ---->\
    \ Recipient ----> CEK\n                                  ^\n                 \
    \                 |\n                                  |\n                   \
    \       IBE Private Key\n                      and IBE Public Parameters\n   \
    \      Figure 5.  Using an IBE Public-Key Algorithm to Decrypt\n"
- title: 2.  Notation and Definitions
  contents:
  - '2.  Notation and Definitions

    '
- title: 2.1.  Notation
  contents:
  - "2.1.  Notation\n   This section summarizes the notions and definitions regarding\n\
    \   identity-based cryptosystems on elliptic curves.  The reader is\n   referred\
    \ to [ECC] for the mathematical background and to [BF],\n   [IBEARCH] regarding\
    \ all notions pertaining to identity-based\n   encryption.\n   F_p denotes finite\
    \ field of prime characteristic p; F_p^2 denotes its\n   extension field of degree\
    \ 2.\n   Let E/F_p: y^2 = x^3 + a * x + b be an elliptic curve over F_p.  For\n\
    \   an extension of degree 2, the curve E/F_p defines a group (E(F_p^2),\n   +),\
    \ which is the additive group of points of affine coordinates (x,\n   y) in (F_p^2)^2\
    \ satisfying the curve equation over F_p^2, with null\n   element, or point at\
    \ infinity, denoted as 0.\n   Let q be a prime such that E(F_p) has a cyclic subgroup\
    \ G1' of order\n   q.\n   Let G1'' be a cyclic subgroup of E(F_p^2) of order q,\
    \ and G2 be a\n   cyclic subgroup of (F_p^2)* of order p.\n   Under these conditions,\
    \ a mathematical construction known as the Tate\n   pairing provides an efficiently\
    \ computable map e: G1' x G1'' -> G2\n   that is linear in both arguments and\
    \ believed hard to invert [BF].\n   If an efficiently computable non-rational\
    \ endomorphism phi: G1' ->\n   G1'' is available for the selected elliptic curve\
    \ on which the Tate\n   pairing is computed, then we can construct a function\
    \ e': G1' x G1''\n   -> G2, defined as e'(A, B) = e(A, phi(B)), called the modified\
    \ Tate\n   pairing.  We generically call a pairing either the Tate pairing e or\n\
    \   the modified Tate pairing e', depending on the chosen elliptic curve\n   used\
    \ in a particular implementation.\n   The following additional notation is used\
    \ throughout this document.\n   p - A 512-bit to 7680-bit prime, which is the\
    \ order of the finite\n   field F_p.\n   F_p - The base finite field of order\
    \ p over which the elliptic curve\n   of interest E/F_p is defined.\n   #G - The\
    \ size of the set G.\n   F* - The multiplicative group of the non-zero elements\
    \ in the field\n   F; e.g., (F_p)* is the multiplicative group of the finite field\
    \ F_p.\n   E/F_p - The equation of an elliptic curve over the field F_p, which,\n\
    \   when p is neither 2 nor 3, is of the form E/F_p: y^2 = x^3 + a * x +\n   b,\
    \ for specified a, b in F_p.\n   0 - The null element of any additive group of\
    \ points on an elliptic\n   curve, also called the point at infinity.\n   E(F_p)\
    \ - The additive group of points of affine coordinates (x, y),\n   with x, y in\
    \ F_p, that satisfy the curve equation E/F_p, including\n   the point at infinity\
    \ 0.\n   q - A 160-bit to 512-bit prime that is the order of the cyclic\n   subgroup\
    \ of interest in E(F_p).\n   k - The embedding degree of the cyclic subgroup of\
    \ order q in E(F_p).\n   For type-1 curves this is always equal to 2.\n   F_p^2\
    \ - The extension field of degree 2 of the field F_p.\n   E(F_p^2) - The group\
    \ of points of affine coordinates in F_p^2\n   satisfying the curve equation E/F_p,\
    \ including the point at infinity\n   0.\n   Z_p - The additive group of integers\
    \ modulo p.\n   lg - The base 2 logarithm function, so that 2^lg(x) = x.\n   The\
    \ term \"object identifier\" will be abbreviated \"OID.\"\n   A Solinas prime\
    \ is a prime of the form 2^a (+/-) 2^b (+/-) 1.\n   The following conventions\
    \ are assumed for curve operations.\n   Point addition - If A and B are two points\
    \ on a curve E, their sum is\n   denoted as A + B.\n   Point multiplication -\
    \ If A is a point on a curve, and n an integer,\n   the result of adding A to\
    \ itself a total of n times is denoted [n]A.\n   The following class of elliptic\
    \ curves is exclusively considered for\n   pairing operations in the present version\
    \ of this document, which are\n   referred to as \"type-1\" curves.\n   Type-1\
    \ curves - The class of curves of type-1 is defined as the class\n   of all elliptic\
    \ curves of equation E/F_p: y^2 = x^3 + 1 for all\n   primes p congruent to 11\
    \ modulo 12.  This class forms a subclass of\n   the class of supersingular curves.\
    \  These curves satisfy #E(F_p) = p\n   + 1, and the p points (x, y) in E(F_p)\
    \ \\ {0} have the property that x\n   = (y^2 - 1)^(1/3) (mod p).  Type-1 curves\
    \ always have an embedding\n   degree k = 2.\n   Groups of points on type-1 curves\
    \ are plentiful and easy to construct\n   by random selection of a prime p of\
    \ the appropriate form.  Therefore,\n   rather than to standardize upon a small\
    \ set of common values of p, it\n   is henceforth assumed that all type-1 curves\
    \ are freshly generated at\n   random for the given cryptographic application\
    \ (an example of such\n   generation will be given in Algorithm 5.1.2 (BFsetup1)\
    \ or Algorithm\n   6.1.2 (BBsetup1)).  Implementations based on different classes\
    \ of\n   curves are currently unsupported.\n   We assume that the following concrete\
    \ representations of mathematical\n   objects are used.\n   Base field elements\
    \ - The p elements of the base field F_p are\n   represented directly using the\
    \ integers from 0 to p - 1.\n   Extension field elements - The p^2 elements of\
    \ the extension field\n   F_p^2 are represented as ordered pairs of elements of\
    \ F_p.  An\n   ordered pair (a_0, a_1) is interpreted as the complex number a_0\
    \ +\n   a_1 * i, where i^2 = -1.  This allows operations on elements of F_p^2\n\
    \   to be implemented as follows.  Suppose that a = (a_0, a_1) and b =\n   (b_0,\
    \ b_1) are elements of F_p^2.  Then a + b = ((a_0 + b_0)(mod p),\n   (a_1 + b_1)(mod\
    \ p)) and a * b = ((a_1 * b_1 - a_0 * b_0)(mod p), (a_1\n   * b_0 + a_0 * b_1)(mod\
    \ p)).\n   Elliptic curve points - Points in E(F_p^2) with the point P = (x, y)\n\
    \   in F_p^2 x F_p^2 satisfying the curve equation E/F_p.  Points not\n   equal\
    \ to 0 are internally represented using the affine coordinates\n   (x, y), where\
    \ x and y are elements of F_p^2.\n"
- title: 2.2.  Definitions
  contents:
  - "2.2.  Definitions\n   The following terminology is used to describe an IBE system.\n\
    \   Public parameters - The public parameters are a set of common,\n   system-wide\
    \ parameters generated and published by the private key\n   generator (PKG).\n\
    \   Master secret - The master secret is the master key generated and\n   privately\
    \ kept by the key server and used to generate the private\n   keys of the users.\n\
    \   Identity - An identity is an arbitrary string, usually a\n   human-readable\
    \ unambiguous designator of a system user, possibly\n   augmented with a time\
    \ stamp and other attributes.\n   Public key - A public key is a string that is\
    \ algorithmically derived\n   from an identity.  The derivation may be performed\
    \ by anyone,\n   autonomously.\n   Private key - A private key is issued by the\
    \ key server to correspond\n   to a given identity (and the public key that derives\
    \ from it) under\n   the published set of public parameters.\n   Plaintext - Plaintext\
    \ is an unencrypted representation, or in the\n   clear, of any block of data\
    \ to be transmitted securely.  For the\n   present purposes, plaintexts are typically\
    \ session keys, or sets of\n   session keys, for further symmetric encryption\
    \ and authentication\n   purposes.\n   Ciphertext - Ciphertext is an encrypted\
    \ representation of any block\n   of data, including plaintext, to be transmitted\
    \ securely.\n"
- title: 3.  Basic Elliptic Curve Algorithms
  contents:
  - "3.  Basic Elliptic Curve Algorithms\n   This section describes algorithms for\
    \ performing all needed basic\n   arithmetic operations on elliptic curves.  The\
    \ presentation is\n   specialized to the type of curves under consideration for\
    \ simplicity\n   of implementation.  General algorithms may be found in [ECC].\n"
- title: 3.1.  The Group Action in Affine Coordinates
  contents:
  - '3.1.  The Group Action in Affine Coordinates

    '
- title: 3.1.1.  Implementation for Type-1 Curves
  contents:
  - "3.1.1.  Implementation for Type-1 Curves\n   Algorithm 3.1.1 (PointDouble1):\
    \ adds a point to itself on a type-1\n   elliptic curve.\n   Input:\n   o  A point\
    \ A in E(F_p^2), with A = (x, y) or 0\n   o  An elliptic curve E/F_p: y^2 = x^3\
    \ + 1\n   Output:\n   o  The point [2]A = A + A\n   Method:\n   1. If A = 0 or\
    \ y = 0, then return 0\n   2. Let lambda = (3 * x^2) / (2 * y)\n   3. Let x' =\
    \ lambda^2 - 2 * x\n   4. Let y' = (x - x') * lambda - y\n   5. Return (x', y')\n\
    \   Algorithm 3.1.2 (PointAdd1): adds two points on a type-1 elliptic\n   curve.\n\
    \   Input:\n   o  A point A in E(F_p^2), with A = (x_A, y_A) or 0\n   o  A point\
    \ B in E(F_p^2), with B = (x_B, y_B) or 0\n   o  An elliptic curve E/F_p: y^2\
    \ = x^3 + 1\n   Output:\n   o  The point A + B\n   Method:\n   1. If A = 0, return\
    \ B\n   2. If B = 0, return A\n   3. If x_A = x_B:\n      (a) If y_A = -y_B, return\
    \ 0\n      (b) Else return [2]A computed using Algorithm 3.1.1 (PointDouble1)\n\
    \   4.  Otherwise:\n      (a) Let lambda = (y_B - y_A) / (x_B - x_A)\n      (b)\
    \ Let x' = lambda^2 - x_A - x_B\n      (c) Let y' = (x_A - x') * lambda - y_A\n\
    \      (d) Return (x', y')\n"
- title: 3.2.  Point Multiplication
  contents:
  - "3.2.  Point Multiplication\n   Algorithm 3.2.1 (SignedWindowDecomposition): computes\
    \ the signed\n   m-ary window representation of a positive integer [ECC].\n  \
    \ Input:\n   o  An integer k > 0, where k has the binary representation k =\n\
    \      {Sum(k_j * 2^j, for j = 0 to l} where each k_j is either 0 or 1\n     \
    \ and k_l = 0\n   o  An integer window bit-size r > 0\n   Output:\n   o  An integer\
    \ d and the unique d-element sequence {(b_i, e_i), for i\n      = 0 to d - 1}\
    \ such that k = {Sum(b_i * 2^(e_i), for i = 0 to d -\n      1}, each b_i = +/-\
    \ 2^j for some 0 < j <= r - 1 and each e_i is a\n      non-negative integer\n\
    \   Method:\n   1. Let d = 0\n   2. Let j = 0\n   3. While j <= l, do:\n     \
    \ (a) If k_j = 0, then:\n         i. Let j = j + 1\n      (b) Else:\n        \
    \ i. Let t = min{l, j + r - 1}\n        ii. Let h_d = (k_t, k_(t - 1), ..., k_j)\
    \ (base 2)\n       iii. If h_d > 2^(r - 1), then:\n            A. Let b_d = h_d\
    \ - 2^r\n            B. Increment the number (k_l, k_(l-1),...,k_j) (base 2) by\
    \ 1\n        iv.  Else:\n            A.  Let b_d = h_d\n         v.  Let e_d =\
    \ j\n        vi.  Let d = d + 1\n       vii.  Let j = t + 1\n   4.  Return d and\
    \ the sequence {(b_0, e_0), ...,\n       (b_(d - 1), e_(d - 1))}\n   Algorithm\
    \ 3.2.2 (PointMultiply): scalar multiplication on an elliptic\n   curve using\
    \ the signed m-ary window method.\n   Input:\n   o  A point A in E(F_p^2)\n  \
    \ o  An integer l > 0\n   o  An elliptic curve E/F_p: y^2 = x^3 + a * x + b\n\
    \   Output:\n   o  The point [l]A\n   Method:\n   1.  (Window decomposition)\n\
    \      (a) Let r > 0 be an integer (fixed) bit-wise window size,\n          e.g.,\
    \ r = 5\n      (b) Let l' = l where l = {Sum(l_j * 2^j), for j = 0 to\n      \
    \    len_l} is the binary expansion of l, where len_l =\n          Ceiling(lg(l))\n\
    \      (c) Compute (d, {(b_i, e_i), for i = 0 to d - 1} =\n          SignedWindowDecomposition(l,\
    \ r), the signed 2^r-ary window\n          representation of l using Algorithm\
    \ 3.2.1\n          (SignedWindowDecomposition)\n   2.  (Precomputation)\n    \
    \  (a) Let A_1 = A\n      (b) Let A_2 = [2]A, using Algorithm 3.1.1 (PointDouble1)\n\
    \      (c) For i = 1 to 2^(r - 2) - 1, do:\n         i.  Let A_(2 * i + 1) = A_(2\
    \ * i - 1) + A_2 using\n             Algorithm 3.1.2 (PointAdd1)\n      (d) Let\
    \ Q = A_(b_(d - 1))\n   3.  Main loop\n      (a) For i = d - 2 to 0 by -1, do:\n\
    \         i. Let Q = [2^(e_(i + 1) - e_i)]Q, using repeated\n            applications\
    \ of Algorithm 3.1.1 (PointDouble1)\n            e_(i + 1) - e_i times\n     \
    \   ii. If b_i > 0, then:\n            A. Let Q = Q + A_(b_i) using Algorithm\
    \ 3.1.2\n               (PointAdd1)\n       iii. Else:\n            A. Let Q =\
    \ Q - A_(-(b_i)) using Algorithm 3.1.2\n               (PointAdd1)\n      (b)\
    \ Calculate Q = [2^(e_0)]Q using repeated applications of\n          Algorithm\
    \ 3.1.1 (PointDouble1) e_0 times\n   4.  Return Q.\n"
- title: 3.3.  Operations in Jacobian Projective Coordinates
  contents:
  - '3.3.  Operations in Jacobian Projective Coordinates

    '
- title: 3.3.1.  Implementation for Type-1 Curves
  contents:
  - "3.3.1.  Implementation for Type-1 Curves\n   Algorithm 3.3.1 (ProjectivePointDouble1):\
    \ adds a point to itself in\n   Jacobian projective coordinates for type-1 curves.\n\
    \   Input:\n   o  A point (x, y, z) = A in E(F_p^2) in Jacobian projective\n \
    \     coordinates\n   o  An elliptic curve E/F_p: y^2 = x^3 + 1\n   Output:\n\
    \   o  The point [2]A in Jacobian projective coordinates\n   Method:\n   1. If\
    \ z = 0 or y = 0, return (0, 1, 0) = 0, otherwise:\n   2. Let lambda_1 = 3 * x^2\n\
    \   3. Let z' = 2 * y * z\n   4. Let lambda_2 = y^2\n   5. Let lambda_3 = 4 *\
    \ lambda_2 * x\n   6. Let x' = lambda_1^2 - 2 * lambda_3\n   7. Let lambda_4 =\
    \ 8 * lambda_2^2\n   8. Let y' = lambda_1 * (lambda_3 - x') - lambda_4\n   9.\
    \ Return (x', y', z')\n   Algorithm 3.3.2 (ProjectivePointAccumulate1): adds a\
    \ point in affine\n   coordinates to an accumulator in Jacobian projective coordinates,\
    \ for\n   type-1 curves.\n   Input:\n   o  A point (x_A, y_A, z_A) = A in E(F_p^2)\
    \ in Jacobian\n      projective coordinates\n   o  A point (x_B, y_B) = B in E(F_p^2)\
    \ \\ {0} in affine\n      coordinates\n   o  An elliptic curve E/F_p: y^2 = x^3\
    \ + 1\n   Output:\n   o  The point A + B in Jacobian projective coordinates\n\
    \   Method:\n   1. If z_A = 0, return (x_B, y_B, 1) = B, otherwise:\n   2. Let\
    \ lambda_1 = z_A^2\n   3. Let lambda_2 = lambda_1 * x_B\n   4. Let lambda_3 =\
    \ x_A - lambda_2\n   5. If lambda_3 = 0, then return (0, 1, 0), otherwise:\n \
    \  6. Let lambda_4 = lambda_3^2\n   7. Let lambda_5 = lambda_1 * y_B * z_A\n \
    \  8. Let lambda_6 = lambda_4 - lambda_5\n   9. Let lambda_7 = x_A + lambda_2\n\
    \   10. Let lambda_8 = y_A + lambda_5\n   11. Let x' = lambda_6^2 - lambda_7 *\
    \ lambda_4\n   12. Let lambda_9 = lambda_7 * lambda_4 - 2 * x'\n   13. Let y'\
    \ = (lambda_9 * lambda_6 -\n       lambda_8 * lambda_3 * lambda_4) / 2\n   14.\
    \ Let z' = lambda_3 * z_A\n   15. Return (x', y', z')\n"
- title: 3.4.  Divisors on Elliptic Curves
  contents:
  - '3.4.  Divisors on Elliptic Curves

    '
- title: 3.4.1.  Implementation in F_p^2 for Type-1 Curves
  contents:
  - "3.4.1.  Implementation in F_p^2 for Type-1 Curves\n   Algorithm 3.4.1 (EvalVertical1):\
    \ evaluates the divisor of a vertical\n   line on a type-1 elliptic curve.\n \
    \  Input:\n   o  A point B in E(F_p^2) with B != 0\n   o  A point A in E(F_p)\n\
    \   o  A description of a type-1 elliptic curve E/F_p\n   Output:\n   o  An element\
    \ of F_p^2 that is the divisor of the vertical line going\n      through A evaluated\
    \ at B\n   Method:\n   1. Let r = x_B - x_A\n   2. Return r\n   Algorithm 3.4.2\
    \ (EvalTangent1): evaluates the divisor of a tangent on\n   a type-1 elliptic\
    \ curve.\n   Input:\n   o  A point B in E(F_p^2) with B != 0\n   o  A point A\
    \ in E(F_p)\n   o  A description of a type-1 elliptic curve E/F_p\n   Output:\n\
    \   o  An element of F_p^2 that is the divisor of the line tangent to A\n    \
    \  evaluated at B\n   Method:\n   1. (Special cases)\n      (a) If A = 0, return\
    \ 1\n      (b) If y_A = 0, return EvalVertical1(B, A) using Algorithm 3.4.1\n\
    \          (EvalVertical1)\n   2. (Line computation)\n      (a) Let a = -3 * (x_A)^2\n\
    \      (b) Let b = 2 * y_A\n      (c) Let c = -b * y_A - a * x_A\n   3. (Evaluation\
    \ at B)\n      (a) Let r = a * x_B + b * y_B + c\n   4. Return r\n   Algorithm\
    \ 3.4.3 (EvalLine1): evaluates the divisor of a line on a\n   type-1 elliptic\
    \ curve.\n   Input:\n   o  A point B in E(F_p^2) with B != 0\n   o  Two points\
    \ A', A'' in E(F_p)\n   o  A description of a type-1 elliptic curve E/F_p\n  \
    \ Output:\n   o  An element of F_p^2 that is the divisor of the line going through\n\
    \      A' and A'' evaluated at B\n   Method:\n   1. (Special cases)\n      (a)\
    \ If A' = 0, return EvalVertical1(B, A'') using Algorithm 3.4.1\n         (EvalVertical1)\n\
    \      (b) If A'' = 0, return EvalVertical1(B, A') using Algorithm 3.4.1\n   \
    \      (EvalVertical1)\n      (c) If A' = -A'', return EvalVertical1(B, A') using\
    \ Algorithm\n         3.4.1 (EvalVertical1)\n      (d) If A' = A'', return EvalTangent1(B,\
    \ A') using Algorithm 3.4.2\n         (EvalTangent1)\n   2. (Line computation)\n\
    \         (a) Let a = y_A' - y_A''\n         (b) Let b = x_A'' - x_A'\n      \
    \   (c) Let c = -b * y_A' - a * x_A'\n   3. (Evaluation at B)\n         (a) Let\
    \ r = a * x_B + b * y_B + c\n   4. Return r\n"
- title: 3.5.  The Tate Pairing
  contents:
  - '3.5.  The Tate Pairing

    '
- title: 3.5.1.  Tate Pairing Calculation
  contents:
  - "3.5.1.  Tate Pairing Calculation\n   Algorithm 3.5.1 (Tate): computes the Tate\
    \ pairing on an elliptic\n   curve.\n   Input:\n   o  A point A of order q in\
    \ E(F_p)\n   o  A point B of order q in E(F_p^2)\n   o  A description of an elliptic\
    \ curve E/F_p such that E(F_p) and\n      E(F_p^2) have a subgroup of order q\n\
    \   Output:\n   o  The value e(A, B) in F_p^2, computed using the Miller algorithm\n\
    \   Method:\n   1. For a type-1 curve E, execute Algorithm 3.5.2 (TateMillerSolinas)\n"
- title: 3.5.2.  The Miller Algorithm for Type-1 Curves
  contents:
  - "3.5.2.  The Miller Algorithm for Type-1 Curves\n   Algorithm 3.5.2 (TateMillerSolinas):\
    \ computes the Tate pairing on a\n   type-1 elliptic curve.\n   Input:\n   o \
    \ A point A of order q in E(F_p)\n   o  A point B of order q in E(F_p^2)\n   o\
    \  A description of a type-1 supersingular elliptic curve E/F_p such\n      that\
    \ E(F_p) and E(F_p^2) have a subgroup of Solinas prime order q\n      where q\
    \ = 2^a + s * 2^b + c, where c and s are limited to the\n      values +/-1\n \
    \  Output:\n   o  The value e(A, B) in F_p^2, computed using the Miller algorithm\n\
    \   Method:\n   1. (Initialization)\n      (a) Let v_num = 1 in F_p^2\n      (b)\
    \ Let v_den = 1 in F_p^2\n      (c) Let V = (x_V , y_V , z_V ) = (x_A, y_A, 1)\
    \ in (F_p)^3, being\n          the representation of (x_A, y_A) = A using Jacobian\
    \ projective\n          coordinates\n      (d) Let t_num = 1 in F_p^2\n      (e)\
    \ Let t_den = 1 in F_p^2\n   2. (Calculation of the (s * 2^b) contribution)\n\
    \      (a) (Repeated doublings) For n = 0 to b - 1:\n         i. Let t_num = t_num^2\n\
    \        ii. Let t_den = t_den^2\n       iii. Let t_num = t_num * EvalTangent1(B,\
    \ (x_V / z_V^2, y_V /\n            z_V^3)) using Algorithm 3.4.2 (EvalTangent1)\n\
    \        iv. Let V = (x_V , y_V , z_V ) = [2]V  using Algorithm 3.3.1\n      \
    \      (ProjectivePointDouble1)\n         v. Let t_den = t_den * EvalVertical1(B,\
    \ (x_V / z_V^2, y_V /\n            z_V^3)using Algorithm 3.4.1 (EvalVertical1)\n\
    \      (b) (Normalization)\n         i. Let V_b = (x_(V_b) , y_(V_b))\n      \
    \      = (x_V / z_V^2, s * y_V / z_V^3) in (F_p)^2,\n            resulting in\
    \ a point V_b in E(F_p)\n      (c) (Accumulation) Selecting on s:\n         i.\
    \ If s = -1:\n            A. Let v_num = v_num * t_den\n            B. Let v_den\
    \ = v_den * t_num * EvalVertical1(B, (x_V /\n               z_V^2, y_V / z_V^3)))\
    \ using Algorithm 3.4.1\n               (EvalVertical1)\n         ii. If s = 1:\n\
    \            A. Let v_num = v_num * t_num\n            B. Let v_den = v_den *\
    \ t_den\n   3. (Calculation of the 2^a contribution)\n      (a) (Repeated doublings)\
    \ For n = b to a - 1:\n         i. Let t_num = t_num^2\n        ii. Let t_den\
    \ = t_den^2\n       iii. Let t_num = t_num * EvalTangent1(B, (x_V / z_V^2, y_V\
    \ /\n            z_V^3))) using Algorithm 3.4.2 (EvalTangent1)\n        iv. Let\
    \ V = (x_V , y_V , z_V) = [2]V  using Algorithm 3.3.1\n            (ProjectivePointDouble1)\n\
    \         v. Let t_den = t_den * EvalVertical1(B, (x_V / z_V^2, y_V /\n      \
    \      z_V^3))) using Algorithm 3.4.1 (EvalVertical1)\n      (b) (Normalization)\n\
    \         i. Let V_a = (x_(V_a) , y_(V_a)) =\n            (x_V /z_V^2, s * x_V\
    \ / z_V^3) in (F_p)^2,\n            resulting in a point V_a in E(F_p)\n     \
    \ (c) (Accumulation)\n         i. Let v_num = v_num * t_num\n        ii. Let v_den\
    \ = v_den * t_den\n   4. (Correction for the (s * 2^b) and (c) contributions)\n\
    \      (a) Let v_num = v_num * EvalLine1(B, V_a, V_b) using Algorithm\n      \
    \    3.4.3 (EvalLine1)\n      (b) Let v_den = v_den * EvalVertical1(B, V_a + V_b)\
    \ using\n          Algorithm 3.4.1 (EvalVertical1)\n      (c) If c = -1, then:\n\
    \         i. Let v_den = v_den * EvalVertical1(B, A) using Algorithm\n       \
    \     3.4.1 (EvalVertical1)\n   5. (Correcting exponent)\n      (a) Let eta =\
    \ (p^2 - 1) / q\n   6. (Final result)\n      (a) Return (v_num / v_den)^eta\n"
- title: 4.  Supporting Algorithms
  contents:
  - "4.  Supporting Algorithms\n   This section describes a number of supporting algorithms\
    \ for encoding\n   and hashing.\n"
- title: 4.1.  Integer Range Hashing
  contents:
  - '4.1.  Integer Range Hashing

    '
- title: 4.1.1.  Hashing to an Integer Range
  contents:
  - "4.1.1.  Hashing to an Integer Range\n   HashToRange(s, n, hashfcn) takes a string\
    \ s, an integer n, and a\n   cryptographic hash function hashfcn as input and\
    \ returns an integer\n   in the range 0 to n - 1 by cryptographic hashing.  The\
    \ input n MUST\n   be less than 2^(hashlen), where hashlen is the number of octets\n\
    \   comprising the output of the hash function hashfcn.  HashToRange is\n   based\
    \ on Merkle's method for hashing [MERKLE], which is provably as\n   secure as\
    \ the underlying hash function hashfcn.\n   Algorithm 4.1.1 (HashToRange): cryptographically\
    \ hashes strings to\n   integers in a range.\n   Input:\n   o  A string s of length\
    \ |s| octets\n   o  A positive integer n represented as Ceiling(lg(n) / 8) octets.\n\
    \   o  A cryptographic hash function hashfcn\n   Output:\n   o  A positive integer\
    \ v in the range 0 to n - 1\n   Method:\n   1. Let hashlen be the number of octets\
    \ comprising the output of\n      hashfcn\n   2. Let v_0 = 0\n   3. Let h_0 =\
    \ 0x00...00, a string of null octets with a length of\n      hashlen\n   4. For\
    \ i = 1 to 2, do:\n      (a) Let t_i = h_(i - 1) || s, which is the (|s| + hashlen)-\
    \ octet\n          string concatenation of the strings h_(i - 1) and s\n     \
    \ (b) Let h_i = hashfcn(t_i), which is a hashlen-octet string\n          resulting\
    \ from the hash algorithm hashfcn on the input t_i\n      (c) Let a_i = Value(h_i)\
    \ be the integer in the range 0 to\n          256^hashlen - 1 denoted by the raw\
    \ octet string h_i\n          interpreted in the unsigned big-endian convention\n\
    \      (d) Let v_i = 256^hashlen * v_(i - 1) + a_i\n   5. Let v = v_l (mod n)\n"
- title: 4.2.  Pseudo-Random Byte Generation by Hashing
  contents:
  - '4.2.  Pseudo-Random Byte Generation by Hashing

    '
- title: 4.2.1.  Keyed Pseudo-Random Bytes Generator
  contents:
  - "4.2.1.  Keyed Pseudo-Random Bytes Generator\n   HashBytes(b, p, hashfcn) takes\
    \ an integer b, a string p, and a\n   cryptographic hash function hashfcn as input\
    \ and returns a b-octet\n   pseudo-random string r as output.  The value of b\
    \ MUST be less than\n   or equal to the number of bytes in the output of hashfcn.\
    \  HashBytes\n   is based on Merkle's method for hashing [MERKLE], which is provably\n\
    \   as secure as the underlying hash function hashfcn.\n   Algorithm 4.2.1 (HashBytes):\
    \ keyed cryptographic pseudo-random bytes\n   generator.\n   Input:\n   o  An\
    \ integer b\n   o  A string p\n   o  A cryptographic hash function hashfcn\n \
    \  Output:\n   o  A string r comprising b octets\n   Method:\n   1. Let hashlen\
    \ be the number of octets comprising the output of\n      hashfcn\n   2. Let K\
    \ = hashfcn(p)\n   3. Let h_0 = 0x00...00, a string of null octets with a length\
    \ of\n      hashlen\n   4. Let l = Ceiling(b / hashlen)\n   5. For each i in 1\
    \ to l, do:\n      (a) Let h_i = hashfcn(h_(i - 1))\n      (b) Let r_i = hashfcn(h_i\
    \ || K), where h_i || K is the (2 *\n          hashlen)-octet concatenation of\
    \ h_i and K\n   6. Let r = LeftmostOctets(b, r_1 || ... || r_l), i.e., r is formed\
    \ as\n      the concatenation of the r_i, truncated to the desired number of\n\
    \      octets\n"
- title: 4.3.  Canonical Encodings of Extension Field Elements
  contents:
  - '4.3.  Canonical Encodings of Extension Field Elements

    '
- title: 4.3.1.  Encoding an Extension Element as a String
  contents:
  - "4.3.1.  Encoding an Extension Element as a String\n   Canonical(p, k, o, v) takes\
    \ an element v in F_p^k, and returns a\n   canonical octet string of fixed length\
    \ representing v.  The parameter\n   o MUST be either 0 or 1, and specifies the\
    \ ordering of the encoding.\n   Algorithm 4.3.1 (Canonical): encodes elements\
    \ of an extension field\n   F_p^2 as strings.\n   Input:\n   o  An element v in\
    \ F_p^2\n   o  A description of F_p^2\n   o  An ordering parameter o, either 0\
    \ or 1\n   Output:\n   o  A fixed-length string s representing v\n   Method:\n\
    \   1. For a type-1 curve, execute Algorithm 4.3.2 (Canonical1)\n"
- title: 4.3.2.  Type-1 Curve Implementation
  contents:
  - "4.3.2.  Type-1 Curve Implementation\n   Canonical1(p, o, v) takes an element\
    \ v in F_p^2 and returns a\n   canonical representation of v as an octet string\
    \ s of fixed size.\n   The parameter o MUST be either 0 or 1, and specifies the\
    \ ordering of\n   the encoding.\n   Algorithm 4.3.2 (Canonical1): canonically\
    \ represents elements of an\n   extension field F_p^2.\n   Input:\n   o  An element\
    \ v in F_p^2\n   o  A description of p, where p is congruent to 3 modulo 4\n \
    \  o  A ordering parameter o, either 0 or 1\n   Output:\n   o  A string s of size\
    \ 2 * Ceiling(lg(p) / 8) octets\n   Method:\n   1. Let l = Ceiling(lg(p) / 8),\
    \ the number of octets needed to\n      represent integers in Z_p\n   2. Let v\
    \ = a + b * i, where i^2 = -1\n   3. Let a_(256^l) be the big-endian zero-padded\
    \ fixed-length octet\n      string representation of a in Z_p\n   4. Let b_(256^l)\
    \ be the big-endian zero-padded fixed-length octet\n      string representation\
    \ of b in Z_p\n   5. Depending on the choice of ordering o:\n      (a) If o =\
    \ 0, then let s = a_(256^l) || b_(256^l), which is the\n          concatenation\
    \ of a_(256^l) followed by b_(256^l)\n      (b) If o = 1, then let s = b_(256^l)\
    \ || a_(256^l), which is the\n          concatenation of b_(256^l) followed by\
    \ a_(256^l)\n   6. Return s\n"
- title: 4.4.  Hashing onto a Subgroup of an Elliptic Curve
  contents:
  - '4.4.  Hashing onto a Subgroup of an Elliptic Curve

    '
- title: 4.4.1.  Hashing a String onto a Subgroup of an Elliptic Curve
  contents:
  - "4.4.1.  Hashing a String onto a Subgroup of an Elliptic Curve\n   HashToPoint(E,\
    \ p, q, id, hashfcn) takes an identity string id, the\n   description of a subgroup\
    \ of prime order q in E(F_p) or E(F_p^2), and\n   a cryptographic hash function\
    \ hashfcn and returns a point Q_id of\n   order q in E(F_p) or E(F_p^2).\n   Algorithm\
    \ 4.4.1 (HashToPoint): cryptographically hashes strings to\n   points on elliptic\
    \ curves.\n   Input:\n   o  An elliptic curve E\n   o  A prime p\n   o  A prime\
    \ q\n   o  A string id\n   o  A cryptographic hash function hashfcn\n   Output:\n\
    \   o  A point Q_id = (x, y) of order q n E(F_p)\n   Method:\n   1. For a type-1\
    \ curve E, execute Algorithm 4.4.2 (HashToPoint1)\n"
- title: 4.4.2.  Type-1 Curve Implementation
  contents:
  - "4.4.2.  Type-1 Curve Implementation\n   HashToPoint1(p, q, id, hashfcn) takes\
    \ an identity string id and the\n   description of a subgroup of order q in E(F_p),\
    \ where E: y^2 = x^3 +\n   1 with p congruent to 11 modulo 12, and returns a point\
    \ Q_id of order\n   q in E(F_p) that is calculated using the cryptographic hash\
    \ function\n   hashfcn.  The parameters p, q and hashfcn MUST be part of a valid\
    \ set\n   of public parameters as defined in Section 5.1.2 or Section 6.1.2.\n\
    \   Algorithm 4.4.2 (HashToPoint1): cryptographically hashes strings to\n   points\
    \ on type-1 curves.\n   Input:\n   o  A prime p\n   o  A prime q\n   o  A string\
    \ id\n   o  A cryptographic hash function hashfcn\n   Output:\n   o  A point Q_id\
    \ of order q in E(F_p)\n   Method:\n   1. Let y = HashToRange(id, p, hashfcn),\
    \ using Algorithm 4.1.1\n      (HashToRange), an element of F_p\n   2. Let x =\
    \ (y^2 - 1)^((2 * p - 1) / 3) modulo p, an element of F_p\n   3. Let Q' = (x,\
    \ y), a non-zero point in E(F_p)\n   4. Let Q = [(p + 1) / q ]Q', a point of order\
    \ q in E(F_p)\n"
- title: 4.5.  Bilinear Mapping
  contents:
  - '4.5.  Bilinear Mapping

    '
- title: 4.5.1.  Regular or Modified Tate Pairing
  contents:
  - "4.5.1.  Regular or Modified Tate Pairing\n   Pairing(E, p, q, A, B) takes two\
    \ points A and B, both of order q,\n   and, in the type-1 case, returns the modified\
    \ pairing e'(A, phi(B))\n   in F_p^2 where A and B are both in E(F_p).\n   Algorithm\
    \ 4.5.1 (Pairing): computes the regular or modified Tate\n   pairing depending\
    \ on the curve type.\n   Input:\n   o  A description of an elliptic curve E/F_p\
    \ such that E(F_p) and\n      E(F_p^2) have a subgroup of order q\n   o  Two points\
    \ A and B of order q in E(F_p) or E(F_p^2)\n   Output:\n   o  On supersingular\
    \ curves, the value of e'(A, B) in F_p^2 where A\n      and B are both in E(F_p)\n\
    \   Method:\n   1. If E is a type-1 curve, execute Algorithm 4.5.2 (Pairing1)\n"
- title: 4.5.2.  Type-1 Curve Implementation
  contents:
  - "4.5.2.  Type-1 Curve Implementation\n   Algorithm 4.5.2 (Pairing1): computes\
    \ the modified Tate pairing on\n   type-1 curves.  The values of p and q MUST\
    \ be part of a valid set of\n   public parameters as defined in Section 5.1.2\
    \ or Section 6.1.2.\n   Input:\n   o  A curve E/F_p: y^2 = x^3 + 1 where p is\
    \ congruent to 11 modulo 12\n      and E(F_p) has a subgroup of order q\n   o\
    \  Two points A and B of order q in E(F_p)\n   Output:\n   o  The value of e'(A,\
    \ B) = e(A, phi(B)) in F_p^2\n   Method:\n   1. Compute B' = phi(B), as follows:\n\
    \      (a) Let (x, y) in F_p x F_p be the coordinates of B in E(F_p)\n      (b)\
    \ Let zeta = (a_zeta , b_zeta), where a_zeta = (p - 1) / 2 and\n          b_zeta\
    \ = 3^((p + 1) / 4) (mod p), an element of F_p^2\n      (c) Let x' =  x * zeta\
    \ in F_p^2\n      (d) Let B' = (x', y) in F_p^2 x F_p\n   2. Compute the Tate\
    \ pairing e(A, B') = e(A, phi(B)) in F_p^2 using\n      the Miller method, as\
    \ in Algorithm 3.5.1 (Tate) described in\n      Section 3.5\n"
- title: 4.6.  Ratio of Bilinear Pairings
  contents:
  - '4.6.  Ratio of Bilinear Pairings

    '
- title: 4.6.1.  Ratio of Regular or Modified Tate Pairings
  contents:
  - "4.6.1.  Ratio of Regular or Modified Tate Pairings\n   PairingRatio(E, p, q,\
    \ A, B, C, D) takes four points as input and\n   computes the ratio of the two\
    \ bilinear pairings, Pairing(E, p, q, A,\n   B) / Pairing(E, p, q, C, D), or,\
    \ equivalently, the product,\n   Pairing(E, p, q, A, B) * Pairing(E, p, q, C,\
    \ -D).\n   On type-1 curves, all four points are of order q in E(F_p), and the\n\
    \   result is an element of order q in the extension field F_p^2 .\n   The motivation\
    \ for this algorithm is that the ratio of two pairings\n   can be calculated more\
    \ efficiently than by computing each pairing\n   separately and dividing one into\
    \ the other, since certain\n   calculations that would normally appear in each\
    \ of the two pairings\n   can be combined and carried out at once.  Such calculations\
    \ include\n   the repeated doublings in steps 2(a)i, 2(a)ii, 3(a)i, and 3(a)ii\
    \ of\n   Algorithm 3.5.2 (TateMillerSolinas), as well as the final\n   exponentiation\
    \ in step 6(a) of Algorithm 3.5.2 (TateMillerSolinas).\n   Algorithm 4.6.1 (PairingRatio):\
    \ computes the ratio of two regular or\n   modified Tate pairings depending on\
    \ the curve type.\n   Input:\n   o  A description of an elliptic curve E/F_p such\
    \ that E(F_p) and\n      E(F_p^2) have a subgroup of order q\n   o  Four points\
    \ A, B, C, and D, of order q in E(F_p) or E(F_p^2)\n   Output:\n   o  On supersingular\
    \ curves, the value of e'(A, B) / e'(C, D) in F_p^2\n      where A, B, C, D are\
    \ all in E(F_p)\n   Method:\n   1. If E is a type-1 curve, execute Algorithm 4.6.2\
    \ (PairingRatio1)\n"
- title: 4.6.2.  Type-1 Curve Implementation
  contents:
  - "4.6.2.  Type-1 Curve Implementation\n   Algorithm 4.6.2 (PairingRatio1): computes\
    \ the ratio of two modified\n   Tate pairings on type-1 curves.  The values of\
    \ p and q MUST be part\n   of a valid set of public parameters as defined in Section\
    \ 5.1.2 or\n   Section 6.1.2.\n   Input:\n   o  A curve E/F_p: y^2 = x^3 + 1,\
    \ where p is congruent to 11 modulo 12\n      and E(F_p) has a subgroup of order\
    \ q\n   o  Four points A, B, C, and D of order q in E(F_p)\n   Output:\n   o \
    \ The value of e'(A, B) / e'(C, D) = e(A, phi(B)) / e(C, phi(D)) =\n      e(A,\
    \ phi(B)) * e(-C, phi(D)), in F_p^2\n   Method:\n   1. The step-by-step description\
    \ of the optimized algorithm is omitted\n      in this normative specification\n\
    \   The correct result can always be obtained, although more slowly, by\n   computing\
    \ the product of pairings Pairing1(E, p, q, A, B) *\n   Pairing1(E, p, q, -C,\
    \ D) by using two invocations of Algorithm 4.5.2\n   (Pairing1).\n"
- title: 5.  The Boneh-Franklin BF Cryptosystem
  contents:
  - "5.  The Boneh-Franklin BF Cryptosystem\n   This chapter describes the algorithms\
    \ constituting the Boneh-Franklin\n   identity-based cryptosystem as described\
    \ in [BF].\n"
- title: 5.1.  Setup
  contents:
  - '5.1.  Setup

    '
- title: 5.1.1.  Master Secret and Public Parameter Generation
  contents:
  - "5.1.1.  Master Secret and Public Parameter Generation\n   Algorithm 5.1.1 (BFsetup):\
    \ randomly selects a master secret and the\n   associated public parameters.\n\
    \   Input:\n   o  An integer version number\n   o  A security parameter n (MUST\
    \ take values either 1024, 2048, 3072,\n      7680, 15360)\n   Output:\n   o \
    \ A set of public parameters (version, E, p, q, P, P_pub, hashfcn)\n   o  A corresponding\
    \ master secret s\n   Method:\n   1. Depending on the selected type t:\n     \
    \ (a) If version = 2, then execute Algorithm 5.1.2 (BFsetup1)\n   2. The resulting\
    \ master secret and public parameters are separately\n      encoded as per the\
    \ application protocol requirements\n"
- title: 5.1.2.  Type-1 Curve Implementation
  contents:
  - "5.1.2.  Type-1 Curve Implementation\n   BFsetup1 takes a security parameter n\
    \ as input.  For type-1 curves,\n   the scale of n corresponds to the modulus\
    \ bit-size believed [BF] of\n   comparable security in the classical Diffie-Hellman\
    \ or RSA public-key\n   cryptosystems.\n   Algorithm 5.1.2 (BFsetup1): establishes\
    \ a master secret and public\n   parameters for type-1 curves.\n   Input:\n  \
    \ o  A security parameter n, which MUST be either 1024, 2048, 3072,\n      7680\
    \ or 15360\n   Output:\n   o  A set of common public parameters (version, p, q,\
    \ P, Ppub,\n      hashfcn)\n   o  A corresponding master secret s\n   Method:\n\
    \   1. Set the version to version = 2.\n   2. Determine the subordinate security\
    \ parameters n_p and n_q as\n      follows:\n      (a) If n = 1024, then let n_p\
    \ = 512, n_q = 160, hashfcn =\n          1.3.14.3.2.26 (SHA-1 [SHA]\n      (b)\
    \ If n = 2048, then let n_p = 1024, n_q = 224, hashfcn =\n          2.16.840.1.101.3.4.2.4\
    \ (SHA-224 [SHA])\n      (c) If n = 3072, then let n_p = 1536, n_q = 256, hashfcn\
    \ =\n          2.16.840.1.101.3.4.2.1 (SHA-256 [SHA])\n      (d) If n = 7680,\
    \ then let n_p = 3840, n_q = 384, hashfcn =\n          2.16.840.1.101.3.4.2.2\
    \ (SHA-384 [SHA])\n      (e) If n = 15360, then let n_p = 7680, n_q = 512, hashfcn\
    \ =\n          2.16.840.1.101.3.4.2.3 (SHA-512 [SHA])\n   3. Construct the elliptic\
    \ curve and its subgroup of interest, as\n      follows:\n      (a) Select an\
    \ arbitrary n_q-bit Solinas prime q\n      (b) Select a random integer r such\
    \ that p = 12 * r * q - 1 is an\n          n_p-bit prime\n   4. Select a point\
    \ P of order q in E(F_p), as follows:\n      (a) Select a random point P' of coordinates\
    \ (x', y') on the curve\n          E/F_p: y^2 = x^3 + 1 (mod p)\n      (b) Let\
    \ P = [12 * r]P'\n      (c) If P = 0, then start over in step 3a\n   5. Determine\
    \ the master secret and the public parameters as follows:\n      (a) Select a\
    \ random integer s in the range 2 to q - 1\n      (b) Let P_pub = [s]P\n   6.\
    \ (version, E, p, q, P, P_pub) are the public parameters where E:\n      y^2 =\
    \ x^3 + 1 is represented by the OID 2.16.840.1.114334.1.1.1.1.\n   7. The integer\
    \ s is the master secret\n"
- title: 5.2.  Public Key Derivation
  contents:
  - '5.2.  Public Key Derivation

    '
- title: 5.2.1.  Public Key Derivation from an Identity and Public Parameters
  contents:
  - "5.2.1.  Public Key Derivation from an Identity and Public Parameters\n   BFderivePubl\
    \ takes an identity string id and a set of public\n   parameters, and it returns\
    \ a point Q_id.  The public parameters used\n   MUST be a valid set of public\
    \ parameters as defined by Section 5.1.2.\n   Algorithm 5.2.1 (BFderivePubl):\
    \ derives the public key corresponding\n   to an identity string.\n   Input:\n\
    \   o  An identity string id\n   o  A set of public parameters (version, E, p,\
    \ q, P, P_pub, hashfcn)\n   Output:\n   o  A point Q_id of order q in E(F_p) or\
    \ E(F_p^2)\n   Method:\n   1. Q_id = HashToPoint(E, p, q, id, hashfcn), using\
    \ Algorithm 4.4.1\n      (HashToPoint)\n"
- title: 5.3.  Private Key Extraction
  contents:
  - '5.3.  Private Key Extraction

    '
- title: 5.3.1.  Private Key Extraction from an Identity, a Set of Public
  contents:
  - "5.3.1.  Private Key Extraction from an Identity, a Set of Public\n        Parameters\
    \ and a Master Secret\n   BFextractPriv takes an identity string id, a set of\
    \ public\n   parameters, and corresponding master secret, and it returns a point\n\
    \   S_id.  The public parameters used MUST be a valid set of public\n   parameters\
    \ as defined by Section 5.1.2.\n   Algorithm 5.3.1 (BFextractPriv): extracts the\
    \ private key\n   corresponding to an identity string.\n   Input:\n   o  An identity\
    \ string id\n   o  A set of public parameters (version, E, p, q, P, P_pub, hashfcn)\n\
    \   Output:\n   o  A point S_id of order q in E(F_p)\n   Method:\n   1. Let Q_id\
    \ = HashToPoint(E, p, q, id, hashfcn) using Algorithm 4.4.1\n      (HashToPoint)\n\
    \   2. Let S_id = [s]Q_id\n"
- title: 5.4.  Encryption
  contents:
  - '5.4.  Encryption

    '
- title: 5.4.1.  Encrypt a Session Key Using an Identity and Public Parameters
  contents:
  - "5.4.1.  Encrypt a Session Key Using an Identity and Public Parameters\n   BFencrypt\
    \ takes three inputs: a public parameter block, an identity\n   id, and a plaintext\
    \ m.  The plaintext MUST be a random symmetric\n   session key.  The public parameters\
    \ used MUST be a valid set of\n   public parameters as defined by Section 5.1.2.\n\
    \   Algorithm 5.4.1 (BFencrypt): encrypts a random session key for an\n   identity\
    \ string.\n   Input:\n   o  A plaintext string m of size |m| octets\n   o  A recipient\
    \ identity string id\n   o  A set of public parameters (version, E, p, q, P, P_pub,\
    \ hashfcn)\n   Output:\n   o  A ciphertext tuple (U, V, W) in E(F_p) x {0, ...\
    \ , 255}^hashlen x\n      {0, ... , 255}^|m|\n   Method:\n   1. Let hashlen be\
    \ the length of the output of the cryptographic hash\n      function hashfcn from\
    \ the public parameters.\n   2. Q_id = HashToPoint(E, p, q, id, hashfcn), using\
    \ Algorithm 4.4.1\n      (HashToPoint), which results in a point of order q in\
    \ E(F_p)\n   3. Select a random hashlen-bit vector rho, represented as (hashlen\
    \ /\n      8)-octet string in big-endian convention\n   4. Let t = hashfcn(m),\
    \ a hashlen-octet string resulting from applying\n      the hashfcn algorithm\
    \ to the input m\n   5. Let l = HashToRange(rho || t, q, hashfcn), an integer\
    \ in the range\n      0 to q - 1 resulting from applying Algorithm 4.1.1 (HashToRange)\n\
    \      to the (2 * hashlen)-octet concatenation of rho and t\n   6. Let U = [l]P,\
    \ which is a point of order q in E(F_p)\n   7. Let theta = Pairing(E, p, q, P_pub,\
    \ Q_id), which is an element of\n      the extension field F_p^2 obtained using\
    \ the modified Tate pairing\n      of Algorithm 4.5.1 (Pairing)\n   8. Let theta'\
    \ = theta^l, which is theta raised to the power of l in\n      F_p^2\n   9. Let\
    \ z = Canonical(p, k, 0, theta'), using Algorithm 4.3.1\n      (Canonical), the\
    \ result of which is a canonical string\n      representation of theta'\n   10.\
    \ Let w = hashfcn(z) using the hashfcn hashing algorithm, the\n       result of\
    \ which is a hashlen-octet string\n   11. Let V = w XOR rho, which is the hashlen-octet\
    \ long bit-wise XOR\n       of w and rho\n   12. Let W = HashBytes(|m|, rho, hashfcn)\
    \ XOR m, which is the bit-wise\n       XOR of m with the first |m| octets of the\
    \ pseudo-random bytes\n       produced by Algorithm 4.2.1 (HashBytes) with seed\
    \ rho\n   13. The ciphertext is the triple (U, V, W)\n"
- title: 5.5.  Decryption
  contents:
  - '5.5.  Decryption

    '
- title: 5.5.1.  Decrypt an Encrypted Session Key Using Public Parameters,
  contents:
  - "5.5.1.  Decrypt an Encrypted Session Key Using Public Parameters,\n        a\
    \ Private Key\n   BFdecrypt takes three inputs: a public parameter block, a private\
    \ key\n   block key, and a ciphertext parsed as (U', V', W').  The public\n  \
    \ parameters used MUST be a valid set of public parameters as defined\n   by Section\
    \ 5.1.2.\n   Algorithm 5.5.1 (BFdecrypt): decrypts an encrypted session key using\n\
    \   a private key.\n   Input:\n   o  A private key point S_id of order q in E(F_p)\n\
    \   o  A ciphertext triple (U, V, W) in E(F_p) x {0, ... , 255}^hashlen x\n  \
    \    {0, ... , 255}*\n   o  A set of public parameters (version, E, p, q, P, P_pub,\
    \ hashfcn)\n   Output:\n   o  A decrypted plaintext m, or an invalid ciphertext\
    \ flag\n   Method:\n   1. Let hashlen be the length of the output of the hash\
    \ function\n      hashlen measured in octets\n   2. Let theta = Pairing(E, p ,q,\
    \ U, S_id) by applying the modified\n      Tate pairing of Algorithm 4.5.1 (Pairing)\n\
    \   3. Let z = Canonical(p, k, 0, theta) using Algorithm 4.3.1\n      (Canonical),\
    \ the result of which is a canonical string\n      representation of theta\n \
    \  4. Let w = hashfcn(z) using the hashfcn hashing algorithm, the result\n   \
    \   of which is a hashlen-octet string\n   5. Let rho = w XOR V, the bit-wise\
    \ XOR of w and V\n   6. Let m = HashBytes(|W|, rho, hashfcn) XOR W, which is the\
    \ bit-wise\n      XOR of m with the first |W| octets of the pseudo-random bytes\n\
    \      produced by Algorithm 4.2.1 (HashBytes) with seed rho\n   7. Let t = hashfcn(m)\
    \ using the hashfcn algorithm\n   8. Let l = HashToRange(rho || t, q, hashfcn)\
    \ using Algorithm 4.1.1\n      (HashToRange) on the (2 * hashlen)-octet concatenation\
    \ of rho and\n      t\n   9. Verify that U = [l]P:\n      (a) If this is the case,\
    \ then the decrypted plaintext m is\n      returned\n      (b) Otherwise, the\
    \ ciphertext is rejected and no plaintext is\n      returned\n"
- title: 6.  The Boneh-Boyen BB1 Cryptosystem
  contents:
  - "6.  The Boneh-Boyen BB1 Cryptosystem\n   This section describes the algorithms\
    \ constituting the first of the\n   two Boneh-Boyen identity-based cryptosystems\
    \ proposed in [BB1].  The\n   description follows the practical implementation\
    \ given in [BB1].\n"
- title: 6.1.  Setup
  contents:
  - '6.1.  Setup

    '
- title: 6.1.1.  Generate a Master Secret and Public Parameters
  contents:
  - "6.1.1.  Generate a Master Secret and Public Parameters\n   Algorithm 6.1.1 (BBsetup).\
    \  Randomly selects a set of master secrets\n   and the associated public parameters.\n\
    \   Input:\n   o  An integer version number\n   o  An integer security parameter\
    \ n (MUST take values either 1024,\n      2048, 3072, 7680, or 15360)\n   Output:\n\
    \   o  A set of public parameters\n   o  A corresponding master secret\n   Method:\n\
    \   1. Depending on the version:\n      (a) If version = 2, then execute Algorithm\
    \ 6.1.2 (BBsetup1)\n"
- title: 6.1.2.  Type-1 Curve Implementation
  contents:
  - "6.1.2.  Type-1 Curve Implementation\n   BBsetup1 takes a security parameter n\
    \ as input.  For type-1 curves, n\n   corresponds to the modulus bit-size believed\
    \ [BF] of comparable\n   security in the classical Diffie-Hellman or RSA public-key\n\
    \   cryptosystems.  For this implementation, n MUST be one of 1024, 2048,\n  \
    \ 3072, 7680 or 15360, which correspond to the equivalent bit security\n   levels\
    \ of 80, 112, 128, 192 and 256 bits respectively.\n   Algorithm 6.1.2 (BBsetup1):\
    \ randomly establishes a master secret and\n   public parameters for type-1 curves.\n\
    \   Input:\n   o  A security parameter n, either 1024, 2048, 3072, 7680, or 15360\n\
    \   Output:\n   o  A set of public parameters (version, k, E, p, q, P, P_1, P_2,\
    \ P_3,\n      v, hashfcn)\n   o  A corresponding triple of master secrets (alpha,\
    \ beta, gamma)\n   Method:\n   1. Determine the subordinate security parameters\
    \ n_p and n_q as\n      follows:\n      (a) If n = 1024, then let n_p = 512, n_q\
    \ = 160, hashfcn =\n          1.3.14.3.2.26 (SHA-1 [SHA]\n      (b) If n = 2048,\
    \ then let n_p = 1024, n_q = 224, hashfcn =\n          2.16.840.1.101.3.4.2.4\
    \ (SHA-224 [SHA])\n      (c) If n = 3072, then let n_p = 1536, n_q = 256, hashfcn\
    \ =\n          2.16.840.1.101.3.4.2.1 (SHA-256 [SHA])\n      (d) If n = 7680,\
    \ then let n_p = 3840, n_q = 384, hashfcn =\n          2.16.840.1.101.3.4.2.2\
    \ (SHA-384 [SHA])\n      (e) If n = 15360, then let n_p = 7680, n_q = 512, hashfcn\
    \ =\n          2.16.840.1.101.3.4.2.3 (SHA-512 [SHA])\n   2. Construct the elliptic\
    \ curve and its subgroup of interest as\n      follows:\n      (a) Select a random\
    \ n_q-bit Solinas prime q\n      (b) Select a random integer r, such that p =\
    \ 12 * r * q - 1 is an\n          n_p-bit prime\n   3. Select a point P of order\
    \ q in E(F_p), as follows:\n      (a) Select a random point P' of coordinates\
    \ (x', y') on the curve\n          E/F_p: y^2 = x^3 + 1 (mod p)\n      (b) Let\
    \ P = [12 * r]P'\n      (c) If P = 0, then start over in step 3a\n   4. Determine\
    \ the master secret and the public parameters as follows:\n      (a) Select three\
    \ random integers alpha, beta, gamma, each of them\n          in the range 1 to\
    \ q - 1\n      (b) Let P_1 = [alpha]P\n      (c) Let P_2 = [beta]P\n      (d)\
    \ Let P_3 = [gamma]P\n      (e) Let v = Pairing(E, p, q, P_1, P_2), which is an\
    \ element of the\n          extension field F_p^2 obtained using the modified\
    \ Tate pairing\n          of Algorithm 4.5.1 (Pairing)\n   5. (version, E, p,\
    \ q, P, P_1, P_2, P_3, v, hashfcn) are the public\n      parameters\n   6. (alpha,\
    \ beta, gamma) constitute the master secret\n"
- title: 6.2.  Public Key Derivation
  contents:
  - '6.2.  Public Key Derivation

    '
- title: 6.2.1.  Derive a Public Key from an Identity and Public Parameters
  contents:
  - "6.2.1.  Derive a Public Key from an Identity and Public Parameters\n   Takes\
    \ an identity string id and a set of public parameters and\n   returns an integer\
    \ h_id.  The public parameters used MUST be a valid\n   set of public parameters\
    \ as defined by Section 6.1.2.\n   Algorithm 6.2.1 (BBderivePubl): derives the\
    \ public key corresponding\n   to an identity string.  The public parameters used\
    \ MUST be a valid\n   set of public parameters as defined by Section 6.1.2.\n\
    \   Input:\n   o  An identity string id\n   o  A set of common public parameters\
    \ (version, k, E, p, q, P, P_1,\n      P_2, P_3, v, hashfcn)\n   Output:\n   o\
    \  An integer h_id modulo q\n   Method:\n   1. Let h_id = HashToRange(id, q, hashfcn),\
    \ using Algorithm 4.1.1\n      (HashToRange)\n"
- title: 6.3.  Private Key Extraction
  contents:
  - '6.3.  Private Key Extraction

    '
- title: 6.3.1.  Extract a Private Key from an Identity, Public Parameters and a
  contents:
  - "6.3.1.  Extract a Private Key from an Identity, Public Parameters and a\n   \
    \     Master Secret\n   BBextractPriv takes an identity string id, a set of public\n\
    \   parameters, and corresponding master secrets, and it returns a\n   private\
    \ key consisting of two points D_0 and D_1.  The public\n   parameters used MUST\
    \ be a valid set of public parameters as defined\n   by Section 6.1.2.\n   Algorithm\
    \ 6.3.1 (BBextractPriv): extracts the private key\n   corresponding to an identity\
    \ string.\n   Input:\n   o  An identity string id\n   o  A set of public parameters\
    \ (version, k, E, p, q, P, P_1, P_2, P_3,\n      v, hashfcn)\n   Output:\n   o\
    \  A pair of points (D_0, D_1), each of which has order q in E(F_p)\n   Method:\n\
    \   1. Select a random integer r in the range 1 to q - 1\n   2. Calculate the\
    \ point D_0 as follows:\n      (a) Let hid = HashToRange(id, q, hashfcn) using\
    \ Algorithm 4.1.1\n          (HashToRange)\n      (b) Let y = alpha * beta + r\
    \ * (alpha * h_id + gamma) in F_q\n      (c) Let D_0 = [y]P\n   3. Calculate the\
    \ point D_1 as follows:\n      (a) Let D_1 = [r]P\n   4. The pair of points (D_0,\
    \ D_1) constitutes the private key for id\n"
- title: 6.4.  Encryption
  contents:
  - '6.4.  Encryption

    '
- title: 6.4.1.  Encrypt a Session Key Using an Identity and Public Parameters
  contents:
  - "6.4.1.  Encrypt a Session Key Using an Identity and Public Parameters\n   BBencrypt\
    \ takes three inputs: a set of public parameters, an identity\n   id, and a plaintext\
    \ m.  The plaintext MUST be a random session key.\n   The public parameters used\
    \ MUST be a valid set of public parameters\n   as defined by Section 6.1.2.\n\
    \   Algorithm 6.4.1 (BBencrypt): encrypts a session key for an identity\n   string.\n\
    \   Input:\n   o  A plaintext string m of size |m| octets\n   o  A recipient identity\
    \ string id\n   o  A set of public parameters (version, k, E, p, q, P, P_1, P_2,\
    \ P_3,\n      v, hashfcn)\n   Output:\n   o  A ciphertext tuple (u, C_0, C_1,\
    \ y) in F_q x E(F_p) x E(F_p) x\n      {0, ... , 255}^|m|\n   Method:\n   1. Select\
    \ a random integer s in the range 1 to q - 1\n   2. Let w = v^s, which is v raised\
    \ to the power of s in F_p^2, the\n      result is an element of order q in F_p^2\n\
    \   3. Calculate the point C_0 as follows:\n      (a) Let C_0 = [s]P\n   4. Calculate\
    \ the point C_1 as follows:\n      (a) Let _hid = HashToRange(id, q, hashfcn)\
    \ using Algorithm 4.1.1\n          (HashToRange)\n      (b) Let y = s * h_id in\
    \ F_q\n      (c) Let C_1 = [y]P_1 + [s]P_3\n   5. Obtain canonical string representations\
    \ of certain elements:\n      (a) Let psi = Canonical(p, k, 1, w) using Algorithm\
    \ 4.3.1\n          (Canonical), the result of which is a canonical octet string\n\
    \          representation of w\n      (b) Let l = Ceiling(lg(p) / 8), the number\
    \ of octets needed to\n          represent integers in F_p, and represent each\
    \ of these F_p\n          elements as a big-endian zero-padded octet string of\
    \ fixed\n          length l:\n          (x_0)_(256^l) to represent the x coordinate\
    \ of C_0\n          (y_0)_(256^l) to represent the y coordinate of C_0\n     \
    \     (x_1)_(256^l) to represent the x coordinate of C_1\n          (y_1)_(256^l)\
    \ to represent the y coordinate of C_1\n   6. Encrypt the message m into the string\
    \ y as follows:\n      (a) Compute an encryption key h_0 as a two-pass hash of\
    \ w via its\n          representation psi:\n            i. Let zeta = hashfcn(psi)\
    \ using the hashing algorithm\n               hashfcn\n           ii. Let xi =\
    \ hashfcn(zeta || psi) using the hashing algorithm\n               hashfcn\n \
    \         iii. Let h' = xi || zeta, the concatenation of the previous\n      \
    \         two hashfcn outputs\n      (b) Let y = HashBytes(|m|, h', hashfcn) XOR\
    \ m, which is the\n          bit-wise XOR of m with the first |m| octets of the\
    \ pseudo-\n          random bytes produced by Algorithm 4.2.1 (HashBytes) with\
    \ seed\n          h'\n   7. Create the integrity check tag u as follows:\n   \
    \   (a) Compute a one-time pad h'' as a dual-pass hash of the\n          representation\
    \ of (w, C_0, C_1, y):\n            i. Let sigma = (y_1)_(256^l) || (x_1)_(256^l)\
    \ ||\n               (y_0)_(256^l) || (x_0)_(256^l) || y || psi be the\n     \
    \          concatenation of y and the five indicated strings in the\n        \
    \       specified order\n           ii. Let eta = hashfcn(sigma) using the hashing\
    \ algorithm\n               hashfcn\n          iii. Let mu = hashfcn(eta || sigma)\
    \ using the hashfcn hashing\n               algorithm\n           iv. Let h''\
    \ = mu || eta, the concatenation of the previous\n               two outputs of\
    \ hashfcn\n      (b) Build the tag u as the encryption of the integer s with the\n\
    \          one-time pad h'':\n         i. Let rho = HashToRange(h'', q, hashfcn)\
    \ to get an integer in\n            Z_q\n        ii. Let u = s + rho (mod q)\n\
    \   8. The complete ciphertext is given by the quadruple (u, C_0, C_1, y)\n"
- title: 6.5.  Decryption
  contents:
  - '6.5.  Decryption

    '
- title: 6.5.1.  Decrypt Using Public Parameters and Private Key
  contents:
  - "6.5.1.  Decrypt Using Public Parameters and Private Key\n   BBdecrypt takes three\
    \ inputs: a set of public parameters (version, k,\n   E, p, q, P, P_1, P_2, P_3,\
    \ v, hashfcn), a private key (D_0, D_1), and\n   a ciphertext (u, C_0, C_1, y).\
    \  It outputs a message m, or signals an\n   error if the ciphertext is invalid\
    \ for the given key.  The public\n   parameters used MUST be a valid set of public\
    \ parameters as defined\n   by Section 6.1.2.\n   Algorithm 6.5.1 (BBdecrypt):\
    \ decrypts a ciphertext using public\n   parameters and a private key.\n   Input:\n\
    \   o  A private key given as a pair of points (D_0, D_1) of order q in\n    \
    \  E(F_p)\n   o  A ciphertext quadruple (u, C_0, C_1, y) in Z_q x E(F_p) x E(F_p)\
    \ x\n      {0, ... , 255}*\n   o  A set of public parameters (version, k, E, p,\
    \ q, P, P_1, P_2, P_3,\n      v, hashfcn)\n   Output:\n   o  A decrypted plaintext\
    \ m, or an invalid ciphertext flag\n   Method:\n   1. Let w = PairingRatio(E,\
    \ p, q, C_0, D_0, C_1, D_1), which computes\n      the ratio of two Tate pairings\
    \ (modified, for type-1 curves) as\n      specified in Algorithm 4.6.1 (PairingRatio)\n\
    \   2. Obtain canonical string representations of certain elements:\n      (a)\
    \ Let psi = Canonical(p, k, 1, w) using Algorithm 4.3.1\n          (Canonical);\
    \ the result is a canonical octet string\n          representation of w\n    \
    \  (b) Let l = Ceiling(lg(p) / 8), the number of octets needed to\n          represent\
    \ integers in F_p, and represent each of these F_p\n          elements as a big-endian\
    \ zero-padded octet string of fixed\n          length l:\n          (x_0)_(256^l)\
    \ to represent the x coordinate of C_0\n          (y_0)_(256^l) to represent the\
    \ y coordinate of C_0\n          (x_1)_(256^l) to represent the x coordinate of\
    \ C_1\n          (y_1)_(256^l) to represent the y coordinate of C_1\n   3. Decrypt\
    \ the message m from the string y as follows:\n      (a) Compute the decryption\
    \ key h' as a dual-pass hash of w via its\n          representation psi:\n   \
    \      i. Let zeta = hashfcn(psi) using the hashing algorithm hashfcn\n      \
    \  ii. Let xi = hashfcn(zeta || psi) using the hashing algorithm\n           \
    \ hashfcn\n       iii. Let h' = xi || zeta, the concatenation of the previous\
    \ two\n            hashfcn outputs\n      (b) Let m = HashBytes(|y|, h', hashfcn)_XOR\
    \ y, which is the\n          bit-wise XOR of y with the first |y| octets of the\
    \ pseudo-\n          random bytes produced by Algorithm 4.2.1 (HashBytes) with\
    \ seed\n          h'\n   4. Obtain the integrity check tag u as follows:\n   \
    \   (a) Recover the one-time pad h'' as a dual-pass hash of the\n          representation\
    \ of (w, C_0, C_1, y):\n         i. Let sigma = (y_1)_(256^l) || (x_1)_(256^l)\
    \ || (y_0)_(256^l)\n            || (x_0)_(256^l) || y || psi be the concatenation\
    \ of y and\n            the five indicated strings in the specified order\n  \
    \      ii. Let eta = hashfcn(sigma) using the hashing algorithm hashfcn\n    \
    \   iii. Let mu = hashfcn(eta || sigma) using the hashing algorithm\n        \
    \    hashfcn\n        iv. Let h'' = mu || eta, the concatenation of the previous\
    \ two\n            hashfcn outputs\n      (b) Unblind the encryption randomization\
    \ integer s from the tag u\n          using h'':\n         i. Let rho = HashToRange(h'',\
    \ q, hashfcn) to get an integer in\n            Z_q\n        ii. Let s = u - rho\
    \ (mod q)\n   5. Verify the ciphertext consistency according to the decrypted\n\
    \      values:\n      (a) Test whether the equality w = v^s holds\n      (b) Test\
    \ whether the equality C_0 = [s]P holds\n   6. Adjudication and final output:\n\
    \      (a) If either of the tests performed in step 5 fails, the\n          ciphertext\
    \ is rejected, and no decryption is output\n      (b) Otherwise, i.e., when both\
    \ tests performed in step 5 succeed,\n          the decrypted message is the output\n"
- title: 7.  Test Data
  contents:
  - "7.  Test Data\n   The following data can be used to verify the correct operation\
    \ of\n   selected algorithms that are defined in this document.\n"
- title: 7.1.  Algorithm 3.2.2 (PointMultiply)
  contents:
  - "7.1.  Algorithm 3.2.2 (PointMultiply)\n   Input:\n   q = 0xfffffffffffffffffffffffffffbffff\n\
    \   p = 0xbffffffffffffffffffffffffffcffff3\n   E/F_p: y^2 = x^3 + 1\n   A = (0x489a03c58dcf7fcfc97e99ffef0bb4634,\n\
    \   0x510c6972d795ec0c2b081b81de767f808)\n   l = 0xb8bbbc0089098f2769b32373ade8f0daf\n\
    \   Output:\n   [l]A = (0x073734b32a882cc97956b9f7e54a2d326,\n   0x9c4b891aab199741a44a5b6b632b949f7)\n"
- title: 7.2.  Algorithm 4.1.1 (HashToRange)
  contents:
  - "7.2.  Algorithm 4.1.1 (HashToRange)\n   Input:\n   s =\n   54:68:69:73:20:41:53:43:49:49:20:73:74:72:69:6e:67:20:77:69:74\n\
    \   :68:6f:75:74:20:6e:75:6c:6c:2d:74:65:72:6d:69:6e:61:74:6f:72\n   (\"This ASCII\
    \ string without null-terminator\")\n   n = 0xffffffffffffffffffffefffffffffffffffffff\n\
    \   hashfcn = 1.3.14.3.2.16 (SHA-1)\n   Output:\n   v = 0x79317c1610c1fc018e9c53d89d59c108cd518608\n"
- title: 7.3.  Algorithm 4.5.1 (Pairing)
  contents:
  - "7.3.  Algorithm 4.5.1 (Pairing)\n   Input:\n   q = 0xfffffffffffffffffffffffffffbffff\n\
    \   p = 0xbffffffffffffffffffffffffffcffff3\n   E/F_p: y^2 = x^3 + 1\n   A = (0x489a03c58dcf7fcfc97e99ffef0bb4634,\n\
    \   0x510c6972d795ec0c2b081b81de767f808)\n   B = (0x40e98b9382e0b1fa6747dcb1655f54f75,\n\
    \   0xb497a6a02e7611511d0db2ff133b32a3f)\n   Output:\n   e'(A, B) = (0x8b2cac13cbd422658f9e5757b85493818,\n\
    \   0xbc6af59f54d0a5d83c8efd8f5214fad3c)\n"
- title: 7.4.  Algorithm 5.2.1 (BFderivePubl)
  contents:
  - "7.4.  Algorithm 5.2.1 (BFderivePubl)\n   Input:\n   id = 6f:42:62 (\"Bob\")\n\
    \   version = 2\n   p = 0xa6a0ffd016103ffffffffff595f002fe9ef195f002fe9efb\n \
    \  q = 0xffffffffffffffffffffffeffffffffffff\n   P = (0x6924c354256acf5a0ff7f61be4f0495b54540a5bf6395b3d,\n\
    \   0x024fd8e2eb7c09104bca116f41c035219955237c0eac19ab)\n   P_pub = (0xa68412ae960d1392701066664d20b2f4a76d6ee715621108,\n\
    \   0x9e7644e75c9a131d075752e143e3f0435ff231b6745a486f)\n   Output:\n   Q_id =\
    \ (0x22fa1207e0d19e1a4825009e0e88e35eb57ba79391498f59,\n   0x982d29acf942127e0f01c881b5ec1b5fe23d05269f538836)\n"
- title: 7.5.  Algorithm 5.3.1 (BFextractPriv)
  contents:
  - "7.5.  Algorithm 5.3.1 (BFextractPriv)\n   Input:\n   s = 0x749e52ddb807e0220054417e514742b05a0\n\
    \   version = 2\n   p = 0xa6a0ffd016103ffffffffff595f002fe9ef195f002fe9efb\n \
    \  q = 0xffffffffffffffffffffffeffffffffffff\n   P = (0x6924c354256acf5a0ff7f61be4f0495b54540a5bf6395b3d,\n\
    \   0x024fd8e2eb7c09104bca116f41c035219955237c0eac19ab)\n   P_pub = (0xa68412ae960d1392701066664d20b2f4a76d6ee715621108,\n\
    \   0x9e7644e75c9a131d075752e143e3f0435ff231b6745a486f)\n   Output:\n   Q_id =\
    \ (0x8212b74ea75c841a9d1accc914ca140f4032d191b5ce5501,\n   0x950643d940aba68099bdcb40082532b6130c88d317958657)\n"
- title: 7.6.  Algorithm 5.4.1 (BFencrypt)
  contents:
  - "7.6.  Algorithm 5.4.1 (BFencrypt)\n      Note: the following values can also\
    \ be used to test\n      Algorithm 5.5.1 (BFdecrypt).\n   Input:\n   m = 48:69:20:74:68:65:72:65:21\
    \ (\"Hi there!\")\n   id = 6f:42:62 (\"Bob\")\n   version = 2\n   p = 0xa6a0ffd016103ffffffffff595f002fe9ef195f002fe9efb\n\
    \   q = 0xffffffffffffffffffffffeffffffffffff\n   P = (0x6924c354256acf5a0ff7f61be4f0495b54540a5bf6395b3d,\n\
    \   0x024fd8e2eb7c09104bca116f41c035219955237c0eac19ab)\n   P_pub = (0xa68412ae960d1392701066664d20b2f4a76d6ee715621108,\n\
    \   0x9e7644e75c9a131d075752e143e3f0435ff231b6745a486f)\n   Output:\n   Using\
    \ the random value rho =\n   0xed5397ff77b567ba5ecb644d7671d6b6f2082968, we get\
    \ the\n   following output:\n   U =\n   (0x1b5f6c461497acdfcbb6d6613ad515430c8b3fa23b61c585e9a541b199e\n\
    \   2a6cb,\n   0x9bdfbed1ae664e51e3d4533359d733ac9a600b61048a7d899104e826a0ec\n\
    \   4fa4)\n   V =\n   e0:1d:ad:81:32:6c:b1:73:af:c2:8d:72:2e:7a:32:1a:7b:29:8a:aa\n\
    \   W = f9:04:ba:40:30:e9:ce:6e:ff\n"
- title: 7.7.  Algorithm 6.3.1 (BBextractPriv)
  contents:
  - "7.7.  Algorithm 6.3.1 (BBextractPriv)\n   Input:\n   alpha = 0xa60c395285ded4d70202c8283d894bad4f0\n\
    \   beta = 0x48bf012da19f170b13124e5301561f45053\n   gamma = 0x226fba82bc38e2ce4e28e56472ccf94a499\n\
    \   version = 2\n   p = 0x91bbe2be1c8950750784befffffffffffff6e441d41e12fb\n \
    \  q = 0xfffffffffbfffffffffffffffffffffffff\n   P = (0x13cc538fe950411218d7f5c17ae58a15e58f0877b29f2fe1,\n\
    \   0x8cf7bab1a748d323cc601fabd8b479f54a60be11e28e18cf)\n   P_1 = (0x0f809a992ed2467a138d72bc1d8931c6ccdd781bedc74627,\n\
    \   0x11c933027beaaf73aa9022db366374b1c68d6bf7d7a888c2)\n   P_2 = (0x0f8ac99a55e575bf595308cfea13edb8ec673983919121b0,\n\
    \   0x3febb7c6369f5d5f18ee3ea6ca0181448a4f3c4f3385019c)\n   P_3 = (0x2c10b43991052e78fac44fdce639c45824f5a3a2550b2a45,\n\
    \   0x6d7c12d8a0681426a5bbc369c9ef54624356e2f6036a064f)\n   v = (0x38f91032de6847a89fc3c83e663ed0c21c8f30ce65c0d7d3,\n\
    \   0x44b9aa10849cc8d8987ef2421770a340056745da8b99fba2)\n   id = 6f:42:62 (\"\
    Bob\")\n   Output:\n   Using the random value r =\n   0x695024c25812112187162c08aa5f65c7a2c,\
    \ we get the following\n   output:\n   D_0 = (0x3264e13feeb7c506493888132964e79ad657a952334b9e53,\n\
    \   0x3eeaefc14ba1277a1cd6fdea83c7c882fe6d85d957055c7b)\n   D_1 = (0x8d7a72ad06909bb3bb29b67676d935018183a905e7e8cb18,\n\
    \   0x2b346c6801c1db638f270af915a21054f16044ab67f6c40e)\n"
- title: 7.8.  Algorithm 6.4.1 (BBencrypt)
  contents:
  - "7.8.  Algorithm 6.4.1 (BBencrypt)\n      Note: the following values can also\
    \ be used to test\n      Algorithm 5.5.1 (BFdecrypt).\n   Input:\n   m = 48:69:20:74:68:65:72:65:21\
    \ (\"Hi there!\")\n   id = 6f:42:62 (\"Bob\")\n   version = 2\n   E: y^2 = x^3\
    \ + 1\n   p = 0x91bbe2be1c8950750784befffffffffffff6e441d41e12fb\n   q = 0xfffffffffbfffffffffffffffffffffffff\n\
    \   P = (0x13cc538fe950411218d7f5c17ae58a15e58f0877b29f2fe1,\n   0x8cf7bab1a748d323cc601fabd8b479f54a60be11e28e18cf)\n\
    \   P_1 = (0x0f809a992ed2467a138d72bc1d8931c6ccdd781bedc74627,\n   0x11c933027beaaf73aa9022db366374b1c68d6bf7d7a888c2)\n\
    \   P_2 = (0x0f8ac99a55e575bf595308cfea13edb8ec673983919121b0,\n   0x3febb7c6369f5d5f18ee3ea6ca0181448a4f3c4f3385019c)\n\
    \   P_3 = (0x2c10b43991052e78fac44fdce639c45824f5a3a2550b2a45,\n   0x6d7c12d8a0681426a5bbc369c9ef54624356e2f6036a064f)\n\
    \   v = (0x38f91032de6847a89fc3c83e663ed0c21c8f30ce65c0d7d3,\n   0x44b9aa10849cc8d8987ef2421770a340056745da8b99fba2)\n\
    \   hashfcn = 1.3.14.3.2.26 (SHA-1)\n   Output:\n   Using the random value s =\n\
    \   0x62759e95ce1af248040e220263fb41b965e, we get the following\n   output:\n\
    \   u = 0xad1ebfa82edf0bcb5111e9dc08ff0737c68\n   C_0 = (0x79f8f35904579f1aaf51897b1e8f1d84e1c927b8994e81f9,\n\
    \   0x1cf77bb2516606681aba2e2dc14764aa1b55a45836014c62)\n   C_1 = (0x410cfeb0bccf1fa4afc607316c8b12fe464097b20250d684,\n\
    \   0x8bb76e7195a7b1980531b0a5852ce710cab5d288b2404e90)\n   y = 82:a6:42:b9:bb:e9:82:c4:57\n"
- title: 8.  ASN.1 Module
  contents:
  - "8.  ASN.1 Module\n   This section defines the ASN.1 module for the encodings\
    \ discussed in\n   this document.\n   IBCS { joint-iso-itu-t(2) country(16) us(840)\
    \ organization(1)\n      identicrypt(114334) ibcs(1) module(5) version(1) }\n\
    \   DEFINITIONS IMPLICIT TAGS ::= BEGIN\n   --\n   -- Identity-based cryptography\
    \ standards (IBCS):\n   -- supersingular curve implementations of\n   -- the BF\
    \ and BB1 cryptosystems\n   --\n   -- This version only supports IBE using\n \
    \  -- type-1 curves, i.e., the curve y^2 = x^3 + 1.\n   --\n   ibcs OBJECT IDENTIFIER\
    \ ::= {\n      joint-iso-itu-t(2) country(16) us(840) organization(1)\n      \
    \   identicrypt(114334) ibcs(1)\n   }\n   --\n   -- IBCS1\n   --\n   -- IBCS1\
    \ defines the algorithms used to implement IBE\n   --\n   ibcs1 OBJECT IDENTIFIER\
    \ ::= {\n      ibcs ibcs1(1)\n   }\n   --\n   -- An elliptic curve is specified\
    \ by an OID.\n   -- A type1curve is defined by the equation y^2 = x^3 + 1.\n \
    \  --\n   type1curve OBJECT IDENTIFIER ::= {\n      ibcs1 curve-types(1) type1-curve(1)\n\
    \   }\n   --\n   -- Supporting types\n   --\n   --\n   -- Encoding of a point\
    \ on an elliptic curve E/F_p\n   -- An FpPoint can either represent an element\
    \ of\n   -- F_p^2 or an element of (F_p)^2.\n    FpPoint ::= SEQUENCE {\n    \
    \  x  INTEGER,\n      y  INTEGER\n   }\n   --\n   -- The following hash functions\
    \ are supported:\n   --\n   -- SHA-1\n   --\n   -- id-sha1  OBJECT IDENTIFIER\
    \  ::= {\n   --   iso(1) identified-organization(3) oiw(14)\n   --   secsig(3)\
    \ algorithms(2) hashAlgorithmIdentifier(26)\n   -- }\n   --\n   -- SHA-224\n \
    \  --\n   -- id-sha224  OBJECT IDENTIFIER  ::= {\n   --   joint-iso-itu-t(2)country(16)\
    \ us(840)\n   --   organization(1) gov(101)\n   --   csor(3) nistAlgorithm(4)\
    \ hashAlgs(2) sha224(4)\n   -- }\n   --\n   -- SHA-256\n   --\n   -- id-sha256\
    \  OBJECT IDENTIFIER  ::= {\n   --   joint-iso-itu-t(2)country(16) us(840)\n \
    \  --   organization(1) gov(101)\n   --   csor(3) nistAlgorithm(4) hashAlgs(2)\
    \ sha256(1)\n   -- }\n   --\n   -- SHA-384\n   --\n   -- id-sha384  OBJECT IDENTIFIER\
    \  ::= {\n   --   joint-iso-itu-t(2)country(16) us(840)\n   --   organization(1)\
    \ gov(101)\n   --   csor(3) nistAlgorithm(4) hashAlgs(2) sha384(2)\n   -- }\n\
    \   --\n   -- SHA-512\n   --\n   -- id-sha512  OBJECT IDENTIFIER  ::= {\n   --\
    \   joint-iso-itu-t(2) country(16) us(840)\n   --   organization(1) gov(101)\n\
    \   --   csor(3) nistAlgorithm(4) hashAlgs(2) sha512(3)\n   -- }\n   --\n   --\n\
    \   -- Algorithms\n   --\n   ibe-algorithms OBJECT IDENTIFIER ::= {\n      ibcs1\
    \ ibe-algorithms(2)\n   }\n   ---\n   --- Boneh-Franklin IBE\n   ---\n   bf OBJECT\
    \ IDENTIFIER ::= { ibe-algorithms bf(1) }\n   --\n   -- Encoding of a BF public\
    \ parameters block.\n   -- The only version currently supported is version 2.\n\
    \   -- The values p and q define a subgroup of E(F_p) of order q.\n   --\n   BFPublicParameters\
    \ ::= SEQUENCE {\n      version     INTEGER { v2(2) },\n      curve       OBJECT\
    \ IDENTIFIER,\n      p           INTEGER,\n      q           INTEGER,\n      pointP\
    \      FpPoint,\n      pointPpub   FpPoint,\n      hashfcn     OBJECT IDENTIFIER\n\
    \   }\n   --\n   -- A BF private key is a point on an elliptic curve,\n   -- which\
    \ is an FpPoint.\n   -- The only version supported is version 2.\n   --\n   BFPrivateKeyBlock\
    \ ::= SEQUENCE {\n      version     INTEGER { v2(2) },\n      privateKey  FpPoint\n\
    \   }\n   --\n   -- A BF master secret is an integer.\n   -- The only version\
    \ supported is version 2.\n   --\n   BFMasterSecret ::= SEQUENCE {\n      version\
    \        INTEGER {v2(2) },\n      masterSecret   INTEGER\n   }\n   --\n   -- BF\
    \ ciphertext block\n   -- The only version supported is version 2.\n   --\n  \
    \ BFCiphertextBlock ::= SEQUENCE {\n      version  INTEGER { v2(2) },\n      u\
    \        FpPoint,\n      v        OCTET STRING,\n      w        OCTET STRING\n\
    \   }\n   --\n   -- Boneh-Boyen (BB1) IBE\n   --\n   bb1 OBJECT IDENTIFIER ::=\
    \ { ibe-algorithms bb1(2) }\n   --\n   -- Encoding of a BB1 public parameters\
    \ block.\n   -- The version is currently fixed to 2.\n   --\n   --\n   BB1PublicParameters\
    \ ::= SEQUENCE {\n      version     INTEGER { v2(2) },\n      curve       OBJECT\
    \ IDENTIFIER,\n      p           INTEGER,\n      q           INTEGER,\n      pointP\
    \      FpPoint,\n      pointP1     FpPoint,\n      pointP2     FpPoint,\n    \
    \  pointP3     FpPoint,\n      v           FpPoint,\n      hashfcn     OBJECT\
    \ IDENTIFIER\n   }\n   --\n   -- BB1 master secret block\n   -- The only version\
    \ supported is version 2.\n   --\n   BB1MasterSecret ::= SEQUENCE {\n      version\
    \  INTEGER { v2(2) },\n      alpha    INTEGER,\n      beta     INTEGER,\n    \
    \  gamma    INTEGER\n   }\n   --\n   -- BB1 private Key block\n   -- The only\
    \ version supported is version 2.\n   --\n   BB1PrivateKeyBlock ::= SEQUENCE {\n\
    \      version  INTEGER { v2(2) },\n      pointD0  FpPoint,\n      pointD1  FpPoint\n\
    \   }\n   --\n   -- BB1 ciphertext block\n   -- The only version supported is\
    \ version 2.\n   --\n   BB1CiphertextBlock ::= SEQUENCE {\n      version     INTEGER\
    \ {v2(2) },\n      pointChi0   FpPoint,\n      pointChi1   FpPoint,\n      nu\
    \          INTEGER,\n      y           OCTET STRING\n   }\n   END\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   This document describes cryptographic algorithms.\
    \  We assume that the\n   security provided by such algorithms depends entirely\
    \ on the secrecy\n   of the relevant private key, and for an adversary to defeat\
    \ the\n   security provided by the algorithms, he will need to perform\n   computationally-intensive\
    \ cryptanalytic attacks to recover the\n   private key.\n   We assume that users\
    \ of the algorithms described in this document\n   will require one of five levels\
    \ of cryptographic strength: the\n   equivalent of 80 bits, 112 bits, 128 bits,\
    \ 192 bits or, 256 bits.\n   The 80-bit level is suitable for legacy applications\
    \ and SHOULD NOT\n   be used to protect information whose useful life extends\
    \ past the\n   year 2010.  The 112-bit level is suitable for use in key transport\
    \ of\n   Triple-DES keys and should be adequate to protect information whose\n\
    \   useful life extends up to the year 2030.  The 128-bit levels and\n   higher\
    \ are suitable for use in the transport of Advanced Encryption\n   Standard (AES)\
    \ keys of the corresponding length or less and are\n   adequate to protect information\
    \ whose useful life extends past the\n   year 2030.\n   Table 1 summarizes the\
    \ security parameters for the BF and BB1\n   algorithms that will attain these\
    \ levels of security.  In this table,\n   |p| represents the number of bits in\
    \ a prime number p, and |q|\n   represents the number of bits in a subprime q.\
    \  This table assumes\n   that a Type-1 supersingular curve is used.\n   Bits\
    \ of Security   |p|    |q|\n   80                 512    160\n   112         \
    \       1024   224\n   128                1536   256\n   192                3840\
    \   384\n   256                7680   512\n   Table 1: Sizes of BF and BB1 Parameters\
    \ Required to Attain Standard\n   Levels of Bit Security [SP800-57].\n   If an\
    \ IBE key is used to transport a symmetric key that provides more\n   bits of\
    \ security than the bit strength of the IBE key, users should\n   understand that\
    \ the security of the system is then limited by the\n   strength of the weaker\
    \ IBE key. So if an IBE key that provides 112\n   bits of security is used to\
    \ transport a 128-bit AES key, then the\n   security provided is limited by the\
    \ 112 bits of security of the IBE\n   key.\n   Note that this document specifies\
    \ the use of the National Institute\n   of Standards and Technology (NIST) hashing\
    \ algorithms [SHA] to hash\n   identities to either a point on an elliptic curve\
    \ or an integer.\n   Recent attacks on SHA-1 [SHA] have discovered ways to find\
    \ collisions\n   with less work than the expected 2^80 hashes required based on\
    \ the\n   size of the output of the hash function alone.  If an attacker can\n\
    \   find a collision, then they could use the colliding preimages to\n   create\
    \ two identities that have the same IBE private key.  The\n   practical use of\
    \ such a SHA-1 [SHA] collision is extremely unlikely,\n   however.\n   Identities\
    \ are typically not random strings like the preimages of a\n   hash collision\
    \ would be.  In particular, this is true if IBE is used\n   as described in [IBECMS],\
    \ in which components of an identity are\n   defined to be an e-mail address,\
    \ a validity period, and a URI.  In\n   this case, the unpredictable results of\
    \ a collision are extremely\n   unlikely to fit the format of a valid identity,\
    \ and thus, are of no\n   use to an attacker.  Any protocol using IBE MUST define\
    \ an identity\n   in a way that makes collisions in a hash function essentially\
    \ useless\n   to an attacker.  Because random strings are rarely used as\n   identities,\
    \ this requirement should not be unduly difficult to\n   fulfill.\n   The randomness\
    \ of the random values that are required by the\n   cryptographic algorithms is\
    \ vital to the security provided by the\n   algorithms.  Any implementation of\
    \ these algorithms MUST use a source\n   of random values that provides an adequate\
    \ level of security.\n   Appropriate algorithms to generate such values include\
    \ [FIPS186-2]\n   and [X9.62].  This will ensure that the random values used to\
    \ mask\n   plaintext messages in Sections 5.4 and 6.4 are not reused with a\n\
    \   significant probability.\n   The strength of a system using the algorithms\
    \ described in this\n   document relies on the strength of the mechanism used\
    \ to authenticate\n   a user requesting a private key from a PKG, as described\
    \ in step 2 of\n   Section 1.2 of this document.  This is analogous to the way\
    \ in which\n   the strength of a system using digital certificates [X.509] is\n\
    \   limited by the strength of the authentication required of users\n   before\
    \ certificates are granted to them.  In either case, a weak\n   mechanism for\
    \ authenticating users will result in a weak system that\n   relies on the technology.\
    \  A system that uses the algorithms\n   described in this document MUST require\
    \ users to authenticate in a\n   way that is suitably strong, particularly if\
    \ IBE private keys will be\n   used for authentication.\n   Note that IBE systems\
    \ have different properties than other asymmetric\n   cryptographic schemes when\
    \ it comes to key recovery.  If a master\n   secret is maintained on a secure\
    \ PKG, then the PKG and any\n   administrator with the appropriate level of access\
    \ will be able to\n   create arbitrary private keys, so that controls around such\n\
    \   administrators and logging of all actions performed by such\n   administrators\
    \ SHOULD be part of a functioning IBE system.\n   On the other hand, it is also\
    \ possible to create IBE private keys\n   using a master secret and to then destroy\
    \ the master secret, making\n   any key recovery impossible.  If this property\
    \ is not desired, an\n   administrator of an IBE system SHOULD require that the\
    \ format of the\n   identity used by the system contain a component that is short-lived.\n\
    \   The format of identity that is defined in [IBECMS], for example,\n   contains\
    \ information about the time period of validity of the key\n   that will be calculated\
    \ from the identity.  Such an identity can\n   easily be changed to allow the\
    \ rekeying of users if their IBE private\n   key is somehow compromised.\n"
- title: 10.  Acknowledgments
  contents:
  - "10.  Acknowledgments\n   This document is based on the IBCS #1 v2 document of\
    \ Voltage\n   Security, Inc.  Any substantial use of material from this document\n\
    \   should acknowledge Voltage Security, Inc.  as the source of the\n   information.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [KEYWORDS]   Bradner, S., \"Key words for use\
    \ in RFCs to Indicate\n                Requirement Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [TLS]        Dierks, T. and E. Rescorla, \"The Transport Layer\n\
    \                Security (TLS) Protocol Version 1.1\", RFC 4346, April\n    \
    \            2006.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [BB1]        D. Boneh and X. Boyen, \"Efficient\
    \ selective-ID secure\n                identity based encryption without random\
    \ oracles,\" In\n                Proc. of EUROCRYPT 04, LNCS 3027, pp. 223-238,\
    \ 2004.\n   [BF]         D. Boneh and M. Franklin, \"Identity-based encryption\n\
    \                from the Weil pairing,\" in Proc. of CRYPTO 01, LNCS\n      \
    \          2139, pp. 213-229, 2001.\n   [CMS]        Housley, R., \"Cryptographic\
    \ Message Syntax (CMS)\", RFC\n                3852, July 2004.\n   [ECC]    \
    \    I. Blake, G. Seroussi, and N. Smart, \"Elliptic Curves in\n             \
    \   Cryptography\", Cambridge University Press, 1999.\n   [FIPS186-2]  National\
    \ Institute of Standards and Technology, \"Digital\n                Signature\
    \ Standard,\" Federal Information Processing\n                Standard 186-2,\
    \ August 2002.\n   [IBEARCH]    G. Appenzeller, L. Martin, and M. Schertler, \"\
    Identity-\n                based Encryption Architecture\", Work in Progress.\n\
    \   [IBECMS]     L. Martin and M. Schertler, \"Using the Boneh-Franklin\n    \
    \            and Boneh-Boyen identity-based encryption algorithms\n          \
    \      with the Cryptographic Message Syntax (CMS)\", Work in\n              \
    \  Progress.\n   [MERKLE]     R. Merkle, \"A fast software one-way hash function,\"\
    \n                Journal of Cryptology, Vol. 3 (1990), pp. 43-58.\n   [P1363]\
    \      IEEE P1363-2000, \"Standard Specifications for Public Key\n           \
    \     Cryptography,\" 2001.\n   [SP800-57]   E. Barker, W. Barker, W. Burr, W.\
    \ Polk and M. Smid,\n                \"Recommendation for Key Management - Part\
    \ 1: General\n                (Revised),\" NIST Special Publication 800-57, March\
    \ 2007.\n   [SHA]        National Institute for Standards and Technology, \"Secure\n\
    \                Hash Standard,\" Federal Information Processing Standards\n \
    \               Publication 180-2, August 2002, with Change Notice 1,\n      \
    \          February 2004.\n   [X9.62]      American National Standards Institute,\
    \ \"Public Key\n                Cryptography for the Financial Services Industry:\
    \ The\n                Elliptic Curve Digital Signature Algorithm (ECDSA),\"\n\
    \                American National Standard for Financial Services\n         \
    \       X9.62-2005, November 2005.\n   [X.509]      ITU-T Recommendation X.509\
    \ (2000) | ISO/IEC 9594-8:2001,\n                Information Technology - Open\
    \ Systems Interconnection -\n                The Directory:  Public-key and Attribute\
    \ Certificate\n                Frameworks.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Xavier Boyen\n   Voltage Security\n   1070 Arastradero\
    \ Rd Suite 100\n   Palo Alto, CA 94304\n   EMail: xavier@voltage.com\n   Luther\
    \ Martin\n   Voltage Security\n   1070 Arastradero Rd Suite 100\n   Palo Alto,\
    \ CA 94304\n   EMail: martin@voltage.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78\
    \ and at www.rfc-editor.org/copyright.html, and\n   except as set forth therein,\
    \ the authors retain all their rights.\n   This document and the information contained\
    \ herein are provided on an\n   \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION\
    \ HE/SHE REPRESENTS\n   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE\
    \ IETF TRUST AND\n   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,\
    \ EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE\
    \ OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n\
    \   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
