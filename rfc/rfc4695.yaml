- title: __initial_text__
  contents:
  - '                      RTP Payload Format for MIDI

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The IETF Trust (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo describes a Real-time Transport Protocol (RTP) payload\n\
    \   format for the MIDI (Musical Instrument Digital Interface) command\n   language.\
    \  The format encodes all commands that may legally appear on\n   a MIDI 1.0 DIN\
    \ cable.  The format is suitable for interactive\n   applications (such as network\
    \ musical performance) and content-\n   delivery applications (such as file streaming).\
    \  The format may be\n   used over unicast and multicast UDP and TCP, and it defines\
    \ tools for\n   graceful recovery from packet loss.  Stream behavior, including\
    \ the\n   MIDI rendering method, may be customized during session setup.  The\n\
    \   format also serves as a mode for the mpeg4-generic format, to support\n  \
    \ the MPEG 4 Audio Object Types for General MIDI, Downloadable Sounds\n   Level\
    \ 2, and Structured Audio.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   4. The Recovery Journal System ....................................22\n\
    \   5. Recovery Journal Format ........................................24\n  \
    \ 6. Session Description Protocol ...................................28\n    \
    \  6.1. Session Descriptions for Native Streams ...................29\n      6.2.\
    \ Session Descriptions for mpeg4-generic Streams ............30\n      6.3. Parameters\
    \ ................................................33\n   7. Extensibility ..................................................34\n\
    \   8. Congestion Control .............................................35\n  \
    \ 9. Security Considerations ........................................35\n   10.\
    \ Acknowledgements ..............................................36\n   11. IANA\
    \ Considerations ...........................................37\n      11.1. rtp-midi\
    \ Media Type Registration .........................37\n           11.1.1. Repository\
    \ Request for \"audio/rtp-midi\" ...........40\n      11.2. mpeg4-generic Media\
    \ Type Registration ....................41\n           11.2.1. Repository Request\
    \ for Mode rtp-midi for\n                   mpeg4-generic .....................................44\n\
    \      11.3. asc Media Type Registration ..............................46\n  \
    \ A. The Recovery Journal Channel Chapters ..........................48\n    \
    \  A.1. Recovery Journal Definitions ..............................48\n      A.2.\
    \ Chapter P: MIDI Program Change ............................52\n      A.3. Chapter\
    \ C: MIDI Control Change ............................53\n           A.3.1. Log\
    \ Inclusion Rules ................................54\n           A.3.2. Controller\
    \ Log Format ..............................55\n           A.3.3. Log List Coding\
    \ Rules ..............................57\n           A.3.4. The Parameter System\
    \ ...............................60\n      A.4. Chapter M: MIDI Parameter System\
    \ ..........................62\n           A.4.1. Log Inclusion Rules ................................64\n\
    \           A.4.2. Log Coding Rules ...................................65\n  \
    \               A.4.2.1. The Value Tool .............................67\n    \
    \             A.4.2.2. The Count Tool .............................70\n      A.5.\
    \ Chapter W: MIDI Pitch Wheel ...............................71\n      A.6. Chapter\
    \ N: MIDI NoteOff and NoteOn ........................71\n           A.6.1. Header\
    \ Structure ...................................73\n           A.6.2. Note Structures\
    \ ....................................74\n      A.7. Chapter E: MIDI Note Command\
    \ Extras .......................75\n           A.7.1. Note Log Format ....................................76\n\
    \           A.7.2. Log Inclusion Rules ................................76\n  \
    \    A.8. Chapter T: MIDI Channel Aftertouch ........................77\n    \
    \  A.9. Chapter A: MIDI Poly Aftertouch ...........................78\n   B. The\
    \ Recovery Journal System Chapters ...........................79\n      B.1. System\
    \ Chapter D: Simple System Commands ..................79\n           B.1.1. Undefined\
    \ System Commands ..........................80\n      B.2. System Chapter V: Active\
    \ Sense Command ....................83\n      B.3. System Chapter Q: Sequencer\
    \ State Commands ................83\n           B.3.1. Non-compliant Sequencers\
    \ ...........................85\n      B.4. System Chapter F: MIDI Time Code Tape\
    \ Position ............86\n           B.4.1. Partial Frames .....................................88\n\
    \      B.5. System Chapter X: System Exclusive ........................89\n  \
    \         B.5.1. Chapter Format .....................................90\n    \
    \       B.5.2. Log Inclusion Semantics ............................92\n      \
    \     B.5.3. TCOUNT and COUNT Fields ............................95\n   C. Session\
    \ Configuration Tools ....................................95\n      C.1. Configuration\
    \ Tools: Stream Subsetting ....................97\n      C.2. Configuration Tools:\
    \ The Journalling System ..............101\n           C.2.1. The j_sec Parameter\
    \ ...............................102\n           C.2.2. The j_update Parameter\
    \ ............................103\n                 C.2.2.1. The anchor Sending\
    \ Policy .................104\n                 C.2.2.2. The closed-loop Sending\
    \ Policy ............104\n                 C.2.2.3. The open-loop Sending Policy\
    \ ..............108\n           C.2.3. Recovery Journal Chapter Inclusion Parameters\
    \ .....110\n      C.3. Configuration Tools: Timestamp Semantics .................115\n\
    \           C.3.1. The comex Algorithm ...............................115\n  \
    \         C.3.2. The async Algorithm ...............................116\n    \
    \       C.3.3. The buffer Algorithm ..............................117\n      C.4.\
    \ Configuration Tools: Packet Timing Tools .................118\n           C.4.1.\
    \ Packet Duration Tools .............................119\n           C.4.2. The\
    \ guardtime Parameter ...........................120\n      C.5. Configuration\
    \ Tools: Stream Description ..................121\n      C.6. Configuration Tools:\
    \ MIDI Rendering ......................128\n           C.6.1. The multimode Parameter\
    \ ...........................129\n           C.6.2. Renderer Specification ............................129\n\
    \           C.6.3. Renderer Initialization ...........................131\n  \
    \         C.6.4. MIDI Channel Mapping ..............................133\n    \
    \             C.6.4.1. The smf_info Parameter ....................134\n      \
    \           C.6.4.2. The smf_inline, smf_url, and smf_cid\n                  \
    \        Parameters ................................136\n                 C.6.4.3.\
    \ The chanmask Parameter ....................136\n           C.6.5. The audio/asc\
    \ Media Type ..........................137\n      C.7. Interoperability .........................................139\n\
    \           C.7.1. MIDI Content Streaming Applications ...............139\n  \
    \         C.7.2. MIDI Network Musical Performance Applications .....142\n   D.\
    \ Parameter Syntax Definitions ..................................150\n   E. A\
    \ MIDI Overview for Networking Specialists ....................156\n      E.1.\
    \ Commands Types ...........................................159\n      E.2. Running\
    \ Status ...........................................159\n      E.3. Command Timing\
    \ ...........................................160\n      E.4. AudioSpecificConfig\
    \ Templates for MMA Renderers ..........160\n   References .......................................................165\n\
    \   Normative References .............................................165\n  \
    \ Informative References ...........................................166\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Internet Engineering Task Force (IETF) has developed\
    \ a set of\n   focused tools for multimedia networking ([RFC3550] [RFC4566]\n\
    \   [RFC3261] [RFC2326]).  These tools can be combined in different ways\n   to\
    \ support a variety of real-time applications over Internet Protocol\n   (IP)\
    \ networks.\n   For example, a telephony application might use the Session Initiation\n\
    \   Protocol (SIP, [RFC3261]) to set up a phone call.  Call setup would\n   include\
    \ negotiations to agree on a common audio codec [RFC3264].\n   Negotiations would\
    \ use the Session Description Protocol (SDP,\n   [RFC4566]) to describe candidate\
    \ codecs.\n   After a call is set up, audio data would flow between the parties\n\
    \   using the Real Time Protocol (RTP, [RFC3550]) under any applicable\n   profile\
    \ (for example, the Audio/Visual Profile (AVP, [RFC3551])).\n   The tools used\
    \ in this telephony example (SIP, SDP, RTP) might be\n   combined in a different\
    \ way to support a content streaming\n   application, perhaps in conjunction with\
    \ other tools, such as the\n   Real Time Streaming Protocol (RTSP, [RFC2326]).\n\
    \   The MIDI (Musical Instrument Digital Interface) command language\n   [MIDI]\
    \ is widely used in musical applications that are analogous to\n   the examples\
    \ described above.  On stage and in the recording studio,\n   MIDI is used for\
    \ the interactive remote control of musical\n   instruments, an application similar\
    \ in spirit to telephony.  On web\n   pages, Standard MIDI Files (SMFs, [MIDI])\
    \ rendered using the General\n   MIDI standard [MIDI] provide a low-bandwidth\
    \ substitute for audio\n   streaming.\n   This memo is motivated by a simple premise:\
    \ if MIDI performances\n   could be sent as RTP streams that are managed by IETF\
    \ session tools,\n   a hybridization of the MIDI and IETF application domains\
    \ may occur.\n   For example, interoperable MIDI networking may foster network\
    \ music\n   performance applications, in which a group of musicians, located at\n\
    \   different physical locations, interact over a network to perform as\n   they\
    \ would if they were located in the same room [NMP].  As a second\n   example,\
    \ the streaming community may begin to use MIDI for low-\n   bitrate audio coding,\
    \ perhaps in conjunction with normative sound\n   synthesis methods [MPEGSA].\n\
    \   To enable MIDI applications to use RTP, this memo defines an RTP\n   payload\
    \ format and its media type.  Sections 2-5 and Appendices A-B\n   define the RTP\
    \ payload format.  Section 6 and Appendices C-D define\n   the media types identifying\
    \ the payload format, the parameters needed\n   for configuration, and how the\
    \ parameters are utilized in SDP.\n   Appendix C also includes interoperability\
    \ guidelines for the example\n   applications described above: network musical\
    \ performance using SIP\n   (Appendix C.7.2) and content-streaming using RTSP\
    \ (Appendix C.7.1).\n   Another potential application area for RTP MIDI is MIDI\
    \ networking\n   for professional audio equipment and electronic musical instruments.\n\
    \   We do not offer interoperability guidelines for this application in\n   this\
    \ memo.  However, RTP MIDI has been designed with stage and studio\n   applications\
    \ in mind, and we expect that efforts to define a stage\n   and studio framework\
    \ will rely on RTP MIDI for MIDI transport\n   services.\n   Some applications\
    \ may require MIDI media delivery at a certain\n   service quality level (latency,\
    \ jitter, packet loss, etc).  RTP\n   itself does not provide service guarantees.\
    \  However, applications\n   may use lower-layer network protocols to configure\
    \ the quality of the\n   transport services that RTP uses.  These protocols may\
    \ act to reserve\n   network resources for RTP flows [RFC2205] or may simply direct\
    \ RTP\n   traffic onto a dedicated \"media network\" in a local installation.\n\
    \   Note that RTP and the MIDI payload format do provide tools that\n   applications\
    \ may use to achieve the best possible real-time\n   performance at a given service\
    \ level.\n   This memo normatively defines the syntax and semantics of the MIDI\n\
    \   payload format.  However, this memo does not define algorithms for\n   sending\
    \ and receiving packets.  An ancillary document [RFC4696]\n   provides informative\
    \ guidance on algorithms.  Supplemental\n   information may be found in related\
    \ conference publications [NMP]\n   [GRAME].\n   Throughout this memo, the phrase\
    \ \"native stream\" refers to a stream\n   that uses the rtp-midi media type.\
    \  The phrase \"mpeg4-generic stream\"\n   refers to a stream that uses the mpeg4-generic\
    \ media type (in mode\n   rtp-midi) to operate in an MPEG 4 environment [RFC3640].\
    \  Section 6\n   describes this distinction in detail.\n"
- title: 1.1.  Terminology
  contents:
  - "1.1.  Terminology\n   In this document, the key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\",\n   \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\",\n   and \"OPTIONAL\" are to be interpreted as described in BCP 14,\
    \ RFC 2119\n   [RFC2119].\n"
- title: 1.2.  Bitfield Conventions
  contents:
  - "1.2.  Bitfield Conventions\n   In this document, the packet bitfields that share\
    \ a common name often\n   have identical semantics.  As most of these bitfields\
    \ appear in\n   Appendices A-B, we define the common bitfield names in Appendix\
    \ A.1.\n   However, a few of these common names also appear in the main text of\n\
    \   this document.  For convenience, we list these definitions below:\n     o\
    \ R flag bit.  R flag bits are reserved for future use.  Senders\n       MUST\
    \ set R bits to 0.  Receivers MUST ignore R bit values.\n     o LENGTH field.\
    \  All fields named LENGTH (as distinct from LEN)\n       code the number of octets\
    \ in the structure that contains it,\n       including the header it resides in\
    \ and all hierarchical levels\n       below it.  If a structure contains a LENGTH\
    \ field, a receiver\n       MUST use the LENGTH field value to advance past the\
    \ structure\n       during parsing, rather than use knowledge about the internal\n\
    \       format of the structure.\n"
- title: 2.  Packet Format
  contents:
  - "2.  Packet Format\n   In this section, we introduce the format of RTP MIDI packets.\
    \  The\n   description includes some background information on RTP, for the\n\
    \   benefit of MIDI implementors new to IETF tools.  Implementors should\n   consult\
    \ [RFC3550] for an authoritative description of RTP.\n   This memo assumes that\
    \ the reader is familiar with MIDI syntax and\n   semantics.  Appendix E provides\
    \ a MIDI overview, at a level of detail\n   sufficient to understand most of this\
    \ memo.  Implementors should\n   consult [MIDI] for an authoritative description\
    \ of MIDI.\n   The MIDI payload format maps a MIDI command stream (16 voice channels\n\
    \   + systems) onto an RTP stream.  An RTP media stream is a sequence of\n   logical\
    \ packets that share a common format.  Each packet consists of\n   two parts:\
    \ the RTP header and the MIDI payload.  Figure 1 shows this\n   format (vertical\
    \ space delineates the header and payload).\n   We describe RTP packets as \"\
    logical\" packets to highlight the fact\n   that RTP itself is not a network-layer\
    \ protocol.  Instead, RTP\n   packets are mapped onto network protocols (such\
    \ as unicast UDP,\n   multicast UDP, or TCP) by an application [ALF].  The interleaved\
    \ mode\n   of the Real Time Streaming Protocol (RTSP, [RFC2326]) is an example\n\
    \   of an RTP mapping to TCP transport, as is [RFC4571].\n"
- title: 2.1.  RTP Header
  contents:
  - "2.1.  RTP Header\n   [RFC3550] provides a complete description of the RTP header\
    \ fields.\n   In this section, we clarify the role of a few RTP header fields\
    \ for\n   MIDI applications.  All fields are coded in network byte order (big-\n\
    \   endian).\n       0                   1                   2               \
    \    3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\
    \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   \
    \   | V |P|X|  CC   |M|     PT      |        Sequence number        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                           Timestamp                           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                             SSRC                              |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   \
    \   |                     MIDI command section ...                  |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                       Journal section ...                     |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \                   Figure 1 -- Packet format\n   The behavior of the 1-bit M\
    \ field depends on the media type of the\n   stream.  For native streams, the\
    \ M bit MUST be set to 1 if the MIDI\n   command section has a non-zero LEN field,\
    \ and MUST be set to 0\n   otherwise.  For mpeg4-generic streams, the M bit MUST\
    \ be set to 1 for\n   all packets (to conform to [RFC3640]).\n   In an RTP MIDI\
    \ stream, the 16-bit sequence number field is\n   initialized to a randomly chosen\
    \ value and is incremented by one\n   (modulo 2^16) for each packet sent in the\
    \ stream.  A related\n   quantity, the 32-bit extended packet sequence number,\
    \ may be computed\n   by tracking rollovers of the 16-bit sequence number.  Note\
    \ that\n   different receivers of the same stream may compute different extended\n\
    \   packet sequence numbers, depending on when the receiver joined the\n   session.\n\
    \   The 32-bit timestamp field sets the base timestamp value for the\n   packet.\
    \  The payload codes MIDI command timing relative to this\n   value.  The timestamp\
    \ units are set by the clock rate parameter.  For\n   example, if the clock rate\
    \ has a value of 44100 Hz, two packets whose\n   base timestamp values differ\
    \ by 2 seconds have RTP timestamp fields\n   that differ by 88200.\n   Note that\
    \ the clock rate parameter is not encoded within each RTP\n   MIDI packet.  A\
    \ receiver of an RTP MIDI stream becomes aware of the\n   clock rate as part of\
    \ the session setup process.  For example, if a\n   session management tool uses\
    \ the Session Description Protocol (SDP,\n   [RFC4566]) to describe a media session,\
    \ the clock rate parameter is\n   set using the rtpmap attribute.  We show examples\
    \ of session setup in\n   Section 6.\n   For RTP MIDI streams destined to be rendered\
    \ into audio, the clock\n   rate SHOULD be an audio sample rate of 32 KHz or higher.\
    \  This\n   recommendation is due to the sensitivity of human musical perception\n\
    \   to small timing errors in musical note sequences, and due to the\n   timbral\
    \ changes that occur when two near-simultaneous MIDI NoteOns\n   are rendered\
    \ with a different timing than that desired by the content\n   author due to clock\
    \ rate quantization.  RTP MIDI streams that are not\n   destined for audio rendering\
    \ (such as MIDI streams that control stage\n   lighting) MAY use a lower clock\
    \ rate but SHOULD use a clock rate high\n   enough to avoid timing artifacts in\
    \ the application.\n   For RTP MIDI streams destined to be rendered into audio,\
    \ the clock\n   rate SHOULD be chosen from rates in common use in professional\
    \ audio\n   applications or in consumer audio distribution.  At the time of this\n\
    \   writing, these rates include 32 KHz, 44.1 KHz, 48 KHz, 64 KHz, 88.2\n   KHz,\
    \ 96 KHz, 176.4 KHz, and 192 KHz.  If the RTP MIDI session is a\n   part of a\
    \ synchronized media session that includes another (non-MIDI)\n   RTP audio stream\
    \ with a clock rate of 32 KHz or higher, the RTP MIDI\n   stream SHOULD use a\
    \ clock rate that matches the clock rate of the\n   other audio stream.  However,\
    \ if the RTP MIDI stream is destined to\n   be rendered into audio, the RTP MIDI\
    \ stream SHOULD NOT use a clock\n   rate lower than 32 KHz, even if this second\
    \ stream has a clock rate\n   less than 32 KHz.\n   Timestamps of consecutive\
    \ packets do not necessarily increment at a\n   fixed rate, because RTP MIDI packets\
    \ are not necessarily sent at a\n   fixed rate.  The degree of packet transmission\
    \ regularity reflects\n   the underlying application dynamics.  Interactive applications\
    \ may\n   vary the packet sending rate to track the gestural rate of a human\n\
    \   performer, whereas content-streaming applications may send packets at\n  \
    \ a fixed rate.\n   Therefore, the timestamps for two sequential RTP packets may\
    \ be\n   identical, or the second packet may have a timestamp arbitrarily\n  \
    \ larger than the first packet (modulo 2^32).  Section 3 places\n   additional\
    \ restrictions on the RTP timestamps for two sequential RTP\n   packets, as does\
    \ the guardtime parameter (Appendix C.4.2).\n   We use the term \"media time\"\
    \ to denote the temporal duration of the\n   media coded by an RTP packet.  The\
    \ media time coded by a packet is\n   computed by subtracting the last command\
    \ timestamp in the MIDI\n   command section from the RTP timestamp (modulo 2^32).\
    \  If the MIDI\n   list of the MIDI command section of a packet is empty, the\
    \ media time\n   coded by the packet is 0 ms.  Appendix C.4.1 discusses media\
    \ time\n   issues in detail.\n   We now define RTP session semantics, in the context\
    \ of sessions\n   specified using the session description protocol [RFC4566].\
    \  A\n   session description media line (\"m=\") specifies an RTP session.  An\n\
    \   RTP session has an independent space of 2^32 synchronization sources.\n  \
    \ Synchronization source identifiers are coded in the SSRC header field\n   of\
    \ RTP session packets.  The payload types that may appear in the PT\n   header\
    \ field of RTP session packets are listed at the end of the\n   media line.\n\
    \   Several RTP MIDI streams may appear in an RTP session.  Each stream\n   is\
    \ distinguished by a unique SSRC value and has a unique sequence\n   number and\
    \ RTP timestamp space.  Multiple streams in the RTP session\n   may be sent by\
    \ a single party.  Multiple parties may send streams in\n   the RTP session. \
    \ An RTP MIDI stream encodes data for a single MIDI\n   command name space (16\
    \ voice channels + Systems).\n   Streams in an RTP session may use different payload\
    \ types, or they\n   may use the same payload type.  However, each party may send,\
    \ at\n   most, one RTP MIDI stream for each payload type mapped to an RTP MIDI\n\
    \   payload format in an RTP session.  Recall that dynamic binding of\n   payload\
    \ type numbers in [RFC4566] lets a party map many payload type\n   numbers to\
    \ the RTP MIDI payload format; thus a party may send many\n   RTP MIDI streams\
    \ in a single RTP session.  Pairs of streams (unicast\n   or multicast) that communicate\
    \ between two parties in an RTP session\n   and that share a payload type have\
    \ the same association as a MIDI\n   cable pair that cross-connects two devices\
    \ in a MIDI 1.0 DIN network.\n   The RTP session architecture described above\
    \ is efficient in its use\n   of network ports, as one RTP session (using a port\
    \ pair per party)\n   supports the transport of many MIDI name spaces (16 MIDI\
    \ channels +\n   systems).  We define tools for grouping and labelling MIDI name\n\
    \   spaces across streams and sessions in Appendix C.5 of this memo.\n   The RTP\
    \ header timestamps for each stream in an RTP session have\n   separately and\
    \ randomly chosen initialization values.  Receivers use\n   the timing fields\
    \ encoded in the RTP control protocol (RTCP,\n   [RFC3550]) sender reports to\
    \ synchronize the streams sent by a party.\n   The SSRC values for each stream\
    \ in an RTP session are also separately\n   and randomly chosen, as described\
    \ in [RFC3550].  Receivers use the\n   CNAME field encoded in RTCP sender reports\
    \ to verify that streams\n   were sent by the same party, and to detect SSRC collisions,\
    \ as\n   described in [RFC3550].\n   In some applications, a receiver renders\
    \ MIDI commands into audio (or\n   into control actions, such as the rewind of\
    \ a tape deck or the\n   dimming of stage lights).  In other applications, a receiver\
    \ presents\n   a MIDI stream to software programs via an Application Programmer\n\
    \   Interface (API).  Appendix C.6 defines session configuration tools to\n  \
    \ specify what receivers should do with a MIDI command stream.\n   If a multimedia\
    \ session uses different RTP MIDI streams to send\n   different classes of media,\
    \ the streams MUST be sent over different\n   RTP sessions.  For example, if a\
    \ multimedia session uses one MIDI\n   stream for audio and a second MIDI stream\
    \ to control a lighting\n   system, the audio and lighting streams MUST be sent\
    \ over different\n   RTP sessions, each with its own media line.\n   Session description\
    \ tools defined in Appendix C.5 let a sending party\n   split a single MIDI name\
    \ space (16 voice channels + systems) over\n   several RTP MIDI streams.  Split\
    \ transport of a MIDI command stream\n   is a delicate task, because correct command\
    \ stream reconstruction by\n   a receiver depends on exact timing synchronization\
    \ across the\n   streams.\n   To support split name spaces, we define the following\
    \ requirements:\n     o  A party MUST NOT send several RTP MIDI streams that share\
    \ a MIDI\n        name space in the same RTP session.  Instead, each stream MUST\n\
    \        be sent from a different RTP session.\n     o  If several RTP MIDI streams\
    \ sent by a party share a MIDI name\n        space, all streams MUST use the same\
    \ SSRC value and MUST use the\n        same randomly chosen RTP timestamp initialization\
    \ value.\n   These rules let a receiver identify streams that share a MIDI name\n\
    \   space (by matching SSRC values) and also let a receiver accurately\n   reconstruct\
    \ the source MIDI command stream (by using RTP timestamps\n   to interleave commands\
    \ from the two streams).  Care MUST be taken by\n   senders to ensure that SSRC\
    \ changes due to collisions are reflected\n   in both streams.  Receivers MUST\
    \ regularly examine the RTCP CNAME\n   fields associated with the linked streams,\
    \ to ensure that the assumed\n   link is legitimate and not the result of an SSRC\
    \ collision by another\n   sender.\n   Except for the special cases described\
    \ above, a party may send many\n   RTP MIDI streams in the same session.  However,\
    \ it is sometimes\n   advantageous for two RTP MIDI streams to be sent over different\
    \ RTP\n   sessions.  For example, two streams may need different values for RTP\n\
    \   session-level attributes (such as the sendonly and recvonly\n   attributes).\
    \  As a second example, two RTP sessions may be needed to\n   send two unicast\
    \ streams in a multimedia session that originate on\n   different computers (with\
    \ different IP numbers).  Two RTP sessions\n   are needed in this case because\
    \ transport addresses are specified on\n   the RTP-session or multimedia-session\
    \ level, not on a payload type\n   level.\n   On a final note, in some uses of\
    \ MIDI, parties send bidirectional\n   traffic to conduct transactions (such as\
    \ file exchange).  These\n   commands were designed to work over MIDI 1.0 DIN\
    \ cable networks may\n   be configured in a multicast topology, which use pure\
    \ \"party-line\"\n   signalling.  Thus, if a multimedia session ensures a multicast\n\
    \   connection between all parties, bidirectional MIDI commands will work\n  \
    \ without additional support from the RTP MIDI payload format.\n"
- title: 2.2. MIDI Payload
  contents:
  - "2.2. MIDI Payload\n   The payload (Figure 1) MUST begin with the MIDI command\
    \ section.  The\n   MIDI command section codes a (possibly empty) list of timestamped\n\
    \   MIDI commands, and provides the essential service of the payload\n   format.\n\
    \   The payload MAY also contain a journal section.  The journal section\n   provides\
    \ resiliency by coding the recent history of the stream.  A\n   flag in the MIDI\
    \ command section codes the presence of a journal\n   section in the payload.\n\
    \   Section 3 defines the MIDI command section.  Sections 4-5 and\n   Appendices\
    \ A-B define the recovery journal, the default format for\n   the journal section.\
    \  Here, we describe how these payload sections\n   operate in a stream in an\
    \ RTP session.\n   The journalling method for a stream is set at the start of\
    \ a session\n   and MUST NOT be changed thereafter.  A stream may be set to use\
    \ the\n   recovery journal, to use an alternative journal format (none are\n \
    \  defined in this memo), or not to use a journal.\n   The default journalling\
    \ method of a stream is inferred from its\n   transport type.  Streams that use\
    \ unreliable transport (such as UDP)\n   default to using the recovery journal.\
    \  Streams that use reliable\n   transport (such as TCP) default to not using\
    \ a journal.  Appendix\n   C.2.1 defines session configuration tools for overriding\
    \ these\n   defaults.  For all types of transport, a sender MUST transmit an RTP\n\
    \   packet stream with consecutive sequence numbers (modulo 2^16).\n   If a stream\
    \ uses the recovery journal, every payload in the stream\n   MUST include a journal\
    \ section.  If a stream does not use\n   journalling, a journal section MUST NOT\
    \ appear in a stream payload.\n   If a stream uses an alternative journal format,\
    \ the specification for\n   the journal format defines an inclusion policy.\n\
    \   If a stream is sent over UDP transport, the Maximum Transmission Unit\n  \
    \ (MTU) of the underlying network limits the practical size of the\n   payload\
    \ section (for example, an Ethernet MTU is 1500 octets), for\n   applications\
    \ where predictable and minimal packet transmission\n   latency is critical. \
    \ A sender SHOULD NOT create RTP MIDI UDP packets\n   whose size exceeds the MTU\
    \ of the underlying network.  Instead, the\n   sender SHOULD take steps to keep\
    \ the maximum packet size under the\n   MTU limit.\n   These steps may take many\
    \ forms.  The default closed-loop recovery\n   journal sending policy (defined\
    \ in Appendix C.2.2.2) uses RTP control\n   protocol (RTCP, [RFC3550]) feedback\
    \ to manage the RTP MIDI packet\n   size.  In addition, Section 3.2 and Appendix\
    \ B.5.2 provide specific\n   tools for managing the size of packets that code\
    \ MIDI System\n   Exclusive (0xF0) commands.  Appendix C.5 defines session\n \
    \  configuration tools that may be used to split a dense MIDI name space\n   into\
    \ several UDP streams (each sent in a different RTP session, per\n   Section 2.1)\
    \ so that the payload fits comfortably into an MTU.\n   Another option is to use\
    \ TCP.  Section 4.3 of [RFC4696] provides\n   non-normative advice for packet\
    \ size management.\n"
- title: 3.  MIDI Command Section
  contents:
  - "3.  MIDI Command Section\n   Figure 2 shows the format of the MIDI command section.\n\
    \       0                   1                   2                   3\n      \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |B|J|Z|P|LEN... |  MIDI list ...                                |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \                Figure 2 -- MIDI command section\n   The MIDI command section\
    \ begins with a variable-length header.\n   The header field LEN codes the number\
    \ of octets in the MIDI list that\n   follow the header.  If the header flag B\
    \ is 0, the header is one\n   octet long, and LEN is a 4-bit field, supporting\
    \ a maximum MIDI list\n   length of 15 octets.\n   If B is 1, the header is two\
    \ octets long, and LEN is a 12-bit field,\n   supporting a maximum MIDI list length\
    \ of 4095 octets.  LEN is coded\n   in network byte order (big-endian): the 4\
    \ bits of LEN that appear in\n   the first header octet code the most significant\
    \ 4 bits of the 12-bit\n   LEN value.\n   A LEN value of 0 is legal, and it codes\
    \ an empty MIDI list.\n   If the J header bit is set to 1, a journal section MUST\
    \ appear after\n   the MIDI command section in the payload.  If the J header bit\
    \ is set\n   to 0, the payload MUST NOT contain a journal section.\n   We define\
    \ the semantics of the P header bit in Section 3.2.\n   If the LEN header field\
    \ is nonzero, the MIDI list has the structure\n   shown in Figure 3.\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |  Delta Time 0     (1-4 octets long, or 0 octets if Z = 1)     |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \  MIDI Command 0   (1 or more octets long)                     |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |  Delta Time 1     (1-4 octets long)                           |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \  MIDI Command 1   (1 or more octets long)                     |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                              ...                              |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \  Delta Time N     (1-4 octets long)                           |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |  MIDI Command N   (0 or more octets long)                     |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \                 Figure 3 -- MIDI list structure\n   If the header flag Z is\
    \ 1, the MIDI list begins with a complete MIDI\n   command (coded in the MIDI\
    \ Command 0 field, in Figure 3) preceded by\n   a delta time (coded in the Delta\
    \ Time 0 field).  If Z is 0, the Delta\n   Time 0 field is not present in the\
    \ MIDI list, and the command coded\n   in the MIDI Command 0 field has an implicit\
    \ delta time of 0.\n   The MIDI list structure may also optionally encode a list\
    \ of N\n   additional complete MIDI commands, each coded in a MIDI Command K\n\
    \   field.  Each additional command MUST be preceded by a Delta Time K\n   field,\
    \ which codes the command's delta time.  We discuss exceptions\n   to the \"command\
    \ fields code complete MIDI commands\" rule in Section\n   3.2.\n   The final\
    \ MIDI command field (i.e., the MIDI Command N field, shown\n   in Figure 3) in\
    \ the MIDI list MAY be empty.  Moreover, a MIDI list\n   MAY consist a single\
    \ delta time (encoded in the Delta Time 0 field)\n   without an associated command\
    \ (which would have been encoded in the\n   MIDI Command 0 field).  These rules\
    \ enable MIDI coding features that\n   are explained in Section 3.1.  We delay\
    \ the explanations because an\n   understanding of RTP MIDI timestamps is necessary\
    \ to describe the\n   features.\n"
- title: 3.1.  Timestamps
  contents:
  - "3.1.  Timestamps\n   In this section, we describe how RTP MIDI encodes a timestamp\
    \ for\n   each MIDI list command.  Command timestamps have the same units as\n\
    \   RTP packet header timestamps (described in Section 2.1 and\n   [RFC3550]).\
    \  Recall that RTP timestamps have units of seconds, whose\n   scaling is set\
    \ during session configuration (see Section 6.1 and\n   [RFC4566]).\n   As shown\
    \ in Figure 3, the MIDI list encodes time using a compact\n   delta-time format.\
    \  The RTP MIDI delta time syntax is a modified form\n   of the MIDI File delta\
    \ time syntax [MIDI].  RTP MIDI delta times use\n   1-4 octet fields to encode\
    \ 32-bit unsigned integers.  Figure 4 shows\n   the encoded and decoded forms\
    \ of delta times.  Note that delta time\n   values may be legally encoded in multiple\
    \ formats; for example, there\n   are four legal ways to encode the zero delta\
    \ time (0x00, 0x8000,\n   0x808000, 0x80808000).\n   RTP MIDI uses delta times\
    \ to encode a timestamp for each MIDI\n   command.  The timestamp for MIDI Command\
    \ K is the summation (modulo\n   2^32) of the RTP timestamp and decoded delta\
    \ times 0 through K.  This\n   cumulative coding technique, borrowed from MIDI\
    \ File delta time\n   coding, is efficient because it reduces the number of multi-octet\n\
    \   delta times.\n   All command timestamps in a packet MUST be less than or equal\
    \ to the\n   RTP timestamp of the next packet in the stream (modulo 2^32).\n \
    \  This restriction ensures that a particular RTP MIDI packet in a\n   stream\
    \ is uniquely responsible for encoding time starting at the\n   moment after the\
    \ RTP timestamp encoded in the RTP packet header, and\n   ending at the moment\
    \ before the final command timestamp encoded in\n   the MIDI list.  The \"moment\
    \ before\" and \"moment after\" qualifiers\n   acknowledge the \"less than or\
    \ equal\" semantics (as opposed to\n   \"strictly less than\") in the sentence\
    \ above this paragraph.\n   Note that it is possible to \"pad\" the end of an\
    \ RTP MIDI packet with\n   time that is guaranteed to be void of MIDI commands,\
    \ by setting the\n   \"Delta Time N\" field of the MIDI list to the end of the\
    \ void time,\n   and by omitting its corresponding \"MIDI Command N\" field (a\
    \ syntactic\n   construction the preamble of Section 3 expressly made legal).\n\
    \   In addition, it is possible to code an RTP MIDI packet to express\n   that\
    \ a period of time in the stream is void of MIDI commands.  The\n   RTP timestamp\
    \ in the header would code the start of the void time.\n   The MIDI list of this\
    \ packet would consist of a \"Delta Time 0\" field\n   that coded the end of the\
    \ void time.  No other fields would be\n   present in the MIDI list (a syntactic\
    \ construction the preamble of\n   Section 3 also expressly made legal).\n   By\
    \ default, a command timestamp indicates the execution time for the\n   command.\
    \  The difference between two timestamps indicates the time\n   delay between\
    \ the execution of the commands.  This difference may be\n   zero, coding simultaneous\
    \ execution.  In this memo, we refer to this\n   interpretation of timestamps\
    \ as \"comex\" (COMmand EXecution)\n   semantics.  We formally define comex semantics\
    \ in Appendix C.3.\n   The comex interpretation of timestamps works well for transcoding\
    \ a\n   Standard MIDI File (SMF) into an RTP MIDI stream, as SMFs code a\n   timestamp\
    \ for each MIDI command stored in the file.  To transcode an\n   SMF that uses\
    \ metric time markers, use the SMF tempo map (encoded in\n   the SMF as meta-events)\
    \ to convert metric SMF timestamp units into\n   seconds-based RTP timestamp units.\n\
    \   The comex interpretation also works well for MIDI hardware\n   controllers\
    \ that are coding raw sensor data directly onto an RTP MIDI\n   stream.  Note\
    \ that this controller design is preferable to a design\n   that converts raw\
    \ sensor data into a MIDI 1.0 cable command stream\n   and then transcodes the\
    \ stream onto an RTP MIDI stream.\n   The comex interpretation of timestamps is\
    \ usually not the best\n   timestamp interpretation for transcoding a MIDI source\
    \ that uses\n   implicit command timing (such as MIDI 1.0 DIN cables) into an\
    \ RTP\n   MIDI stream.  Appendix C.3 defines alternatives to comex semantics\n\
    \   and describes session configuration tools for selecting the timestamp\n  \
    \ interpretation semantics for a stream.\n        One-Octet Delta Time:\n    \
    \       Encoded form: 0ddddddd\n           Decoded form: 00000000 00000000 00000000\
    \ 0ddddddd\n        Two-Octet Delta Time:\n           Encoded form: 1ccccccc 0ddddddd\n\
    \           Decoded form: 00000000 00000000 00cccccc cddddddd\n        Three-Octet\
    \ Delta Time:\n           Encoded form: 1bbbbbbb 1ccccccc 0ddddddd\n         \
    \  Decoded form: 00000000 000bbbbb bbcccccc cddddddd\n        Four-Octet Delta\
    \ Time:\n           Encoded form: 1aaaaaaa 1bbbbbbb 1ccccccc 0ddddddd\n      \
    \     Decoded form: 0000aaaa aaabbbbb bbcccccc cddddddd\n                  Figure\
    \ 4 -- Decoding delta time formats\n"
- title: 3.2.  Command Coding
  contents:
  - "3.2.  Command Coding\n   Each non-empty MIDI Command field in the MIDI list codes\
    \ one of the\n   MIDI command types that may legally appear on a MIDI 1.0 DIN\
    \ cable.\n   Standard MIDI File meta-events do not fit this definition and MUST\n\
    \   NOT appear in the MIDI list.  As a rule, each MIDI Command field\n   codes\
    \ a complete command, in the binary command format defined in\n   [MIDI].  In\
    \ the remainder of this section, we describe exceptions to\n   this rule.\n  \
    \ The first MIDI channel command in the MIDI list MUST include a status\n   octet.\
    \  Running status coding, as defined in [MIDI], MAY be used for\n   all subsequent\
    \ MIDI channel commands in the list.  As in [MIDI],\n   System Common and System\
    \ Exclusive messages (0xF0 ... 0xF7) cancel\n   the running status state, but\
    \ System Real-time messages (0xF8 ...\n   0xFF) do not affect the running status\
    \ state.  All System commands in\n   the MIDI list MUST include a status octet.\n\
    \   As we note above, the first channel command in the MIDI list MUST\n   include\
    \ a status octet.  However, the corresponding command in the\n   original MIDI\
    \ source data stream might not have a status octet (in\n   this case, the source\
    \ would be coding the command using running\n   status).  If the status octet\
    \ of the first channel command in the\n   MIDI list does not appear in the source\
    \ data stream, the P (phantom)\n   header bit MUST be set to 1.  In all other\
    \ cases, the P bit MUST be\n   set to 0.\n   Note that the P bit describes the\
    \ MIDI source data stream, not the\n   MIDI list encoding; regardless of the state\
    \ of the P bit, the MIDI\n   list MUST include the status octet.\n   As receivers\
    \ MUST be able to decode running status, sender\n   implementors should feel free\
    \ to use running status to improve\n   bandwidth efficiency.  However, senders\
    \ SHOULD NOT introduce timing\n   jitter into an existing MIDI command stream\
    \ through an inappropriate\n   use or removal of running status coding.  This\
    \ warning primarily\n   applies to senders whose RTP MIDI streams may be transcoded\
    \ onto a\n   MIDI 1.0 DIN cable [MIDI] by the receiver: both the timestamps and\n\
    \   the command coding (running status or not) must comply with the\n   physical\
    \ restrictions of implicit time coding over a slow serial\n   line.\n   On a MIDI\
    \ 1.0 DIN cable [MIDI], a System Real-time command may be\n   embedded inside\
    \ of another \"host\" MIDI command.  This syntactic\n   construction is not supported\
    \ in the payload format: a MIDI Command\n   field in the MIDI list codes exactly\
    \ one MIDI command (partially or\n   completely).\n   To encode an embedded System\
    \ Real-time command, senders MUST extract\n   the command from its host and code\
    \ it in the MIDI list as a separate\n   command.  The host command and System\
    \ Real-time command SHOULD appear\n   in the same MIDI list.  The delta time of\
    \ the System Real-time\n   command SHOULD result in a command timestamp that encodes\
    \ the System\n   Real-time command placement in its original embedded position.\n\
    \   Two methods are provided for encoding MIDI System Exclusive (SysEx)\n   commands\
    \ in the MIDI list.  A SysEx command may be encoded in a MIDI\n   Command field\
    \ verbatim: a 0xF0 octet, followed by an arbitrary number\n   of data octets,\
    \ followed by a 0xF7 octet.\n   Alternatively, a SysEx command may be encoded\
    \ as multiple segments.\n   The command is divided into two or more SysEx command\
    \ segments; each\n   segment is encoded in its own MIDI Command field in the MIDI\
    \ list.\n   The payload format supports segmentation in order to encode SysEx\n\
    \   commands that encode information in the temporal pattern of data\n   octets.\
    \  By encoding these commands as a series of segments, each\n   data octet may\
    \ be associated with a distinct delta time.\n   Segmentation also supports the\
    \ coding of large SysEx commands across\n   several packets.\n   To segment a\
    \ SysEx command, first partition its data octet list into\n   two or more sublists.\
    \  The last sublist MAY be empty (i.e., contain\n   no octets); all other sublists\
    \ MUST contain at least one data octet.\n   To complete the segmentation, add\
    \ the status octets defined in Figure\n   5 to the head and tail of the first,\
    \ last, and any \"middle\" sublists.\n   Figure 6 shows example segmentations\
    \ of a SysEx command.\n   A sender MAY cancel a segmented SysEx command transmission\
    \ that is in\n   progress, by sending the \"cancel\" sublist shown in Figure 5.\
    \  A\n   \"cancel\" sublist MAY follow a \"first\" or \"middle\" sublist in the\n\
    \   transmission, but MUST NOT follow a \"last\" sublist.  The cancel MUST\n \
    \  be empty (thus, 0xF7 0xF4 is the only legal cancel sublist).\n   The cancellation\
    \ feature is needed because Appendix C.1 defines\n   configuration tools that\
    \ let session parties exclude certain SysEx\n   commands in the stream.  Senders\
    \ that transcode a MIDI source onto an\n   RTP MIDI stream under these constraints\
    \ have the responsibility of\n   excluding undesired commands from the RTP MIDI\
    \ stream.\n   The cancellation feature lets a sender start the transmission of\
    \ a\n   command before the MIDI source has sent the entire command.  If a\n  \
    \ sender determines that the command whose transmission is in progress\n   should\
    \ not appear on the RTP stream, it cancels the command.  Without\n   a method\
    \ for cancelling a SysEx command transmission, senders would\n   be forced to\
    \ use a high-latency store-and-forward approach to\n   transcoding SysEx commands\
    \ onto RTP MIDI packets, in order to\n   validate each SysEx command before transmission.\n\
    \   The recommended receiver reaction to a cancellation depends on the\n   capabilities\
    \ of the receiver.  For example, a sound synthesizer that\n   is directly parsing\
    \ RTP MIDI packets and rendering them to audio will\n   be aware of the fact that\
    \ SysEx commands may be cancelled in RTP\n   MIDI.  These receivers SHOULD detect\
    \ a SysEx cancellation in the MIDI\n   list and act as if they had never received\
    \ the SysEx command.\n   As a second example, a synthesizer may be receiving MIDI\
    \ data from an\n   RTP MIDI stream via a MIDI DIN cable (or a software API emulation\
    \ of\n   a MIDI DIN cable).  In this case, an RTP-MIDI-aware system receives\n\
    \   the RTP MIDI stream and transcodes it onto the MIDI DIN cable (or its\n  \
    \ emulation).  Upon the receipt of the cancel sublist, the RTP-MIDI-\n   aware\
    \ transcoder might have already sent the first part of the SysEx\n   command on\
    \ the MIDI DIN cable to the receiver.\n   Unfortunately, the MIDI DIN cable protocol\
    \ cannot directly code\n   \"cancel SysEx in progress\" semantics.  However, MIDI\
    \ DIN cable\n   receivers begin SysEx processing after the complete command arrives.\n\
    \   The receiver checks to see if it recognizes the command (coded in the\n  \
    \ first few octets) and then checks to see if the command is the\n   correct length.\
    \  Thus, in practice, a transcoder can cancel a SysEx\n   command by sending an\
    \ 0xF7 to (prematurely) end the SysEx command --\n   the receiver will detect\
    \ the incorrect command length and discard the\n   command.\n   Appendix C.1 defines\
    \ configuration tools that may be used to prohibit\n   SysEx command cancellation.\n\
    \   The relative ordering of SysEx command segments in a MIDI list must\n   match\
    \ the relative ordering of the sublists in the original SysEx\n   command.  By\
    \ default, commands other than System Real-time MIDI\n   commands MUST NOT appear\
    \ between SysEx command segments (Appendix C.1\n   defines configuration tools\
    \ to change this default, to let other\n   commands types appear between segments).\
    \  If the command segments of\n   a SysEx command are placed in the MIDI lists\
    \ of two or more RTP\n   packets, the segment ordering rules apply to the concatenation\
    \ of all\n   affected MIDI lists.\n          -----------------------------------------------------------\n\
    \         | Sublist Position |  Head Status Octet | Tail Status Octet |\n    \
    \     |-----------------------------------------------------------|\n        \
    \ |    first         |       0xF0         |       0xF0        |\n         |-----------------------------------------------------------|\n\
    \         |    middle        |       0xF7         |       0xF0        |\n    \
    \     |-----------------------------------------------------------|\n        \
    \ |    last          |       0xF7         |       0xF7        |\n         |-----------------------------------------------------------|\n\
    \         |    cancel        |       0xF7         |       0xF4        |\n    \
    \      -----------------------------------------------------------\n         \
    \      Figure 5 -- Command segmentation status octets\n   [MIDI] permits 0xF7\
    \ octets that are not part of a (0xF0, 0xF7) pair\n   to appear on a MIDI 1.0\
    \ DIN cable.  Unpaired 0xF7 octets have no\n   semantic meaning in MIDI, apart\
    \ from cancelling running status.\n   Unpaired 0xF7 octets MUST NOT appear in\
    \ the MIDI list of the MIDI\n   Command section.  We impose this restriction to\
    \ avoid interference\n   with the command segmentation coding defined in Figure\
    \ 5.\n   SysEx commands carried on a MIDI 1.0 DIN cable may use the \"dropped\n\
    \   0xF7\" construction [MIDI].  In this coding method, the 0xF7 octet is\n  \
    \ dropped from the end of the SysEx command, and the status octet of\n   the next\
    \ MIDI command acts both to terminate the SysEx command and\n   start the next\
    \ command.  To encode this construction in the payload\n   format, follow these\
    \ steps:\n     o  Determine the appropriate delta times for the SysEx command\
    \ and\n        the command that follows the SysEx command.\n     o  Insert the\
    \ \"dropped\" 0xF7 octet at the end of the SysEx command,\n        to form the\
    \ standard SysEx syntax.\n     o  Code both commands into the MIDI list using\
    \ the rules above.\n     o  Replace the 0xF7 octet that terminates the verbatim\
    \ SysEx\n        encoding or the last segment of the segmented SysEx encoding\n\
    \        with a 0xF5 octet.  This substitution informs the receiver of\n     \
    \   the original dropped 0xF7 coding.\n   [MIDI] reserves the undefined System\
    \ Common commands 0xF4 and 0xF5\n   and the undefined System Real-time commands\
    \ 0xF9 and 0xFD for future\n   use.  By default, undefined commands MUST NOT appear\
    \ in a MIDI\n   Command field in the MIDI list, with the exception of the 0xF5\
    \ octets\n   used to code the \"dropped 0xF7\" construction and the 0xF4 octets\
    \ used\n   by SysEx \"cancel\" sublists.\n   During session configuration, a stream\
    \ may be customized to transport\n   undefined commands (Appendix C.1).  For this\
    \ case, we now define how\n   senders encode undefined commands in the MIDI list.\n\
    \   An undefined System Real-time command MUST be coded using the System\n   Real-time\
    \ rules.\n   If the undefined System Common commands are put to use in a future\n\
    \   version of [MIDI], the command will begin with an 0xF4 or 0xF5 status\n  \
    \ octet, followed by an arbitrary number of data octets (i.e., zero or\n   more\
    \ data bytes).  To encode these commands, senders MUST terminate\n   the command\
    \ with an 0xF7 octet and place the modified command into\n   the MIDI Command\
    \ field.\n   Unfortunately, non-compliant uses of the undefined System Common\n\
    \   commands may appear in MIDI implementations.  To model these\n   commands,\
    \ we assume that the command begins with an 0xF4 or 0xF5\n   status octet, followed\
    \ by zero or more data octets, followed by zero\n   or more trailing 0xF7 status\
    \ octets.  To encode the command, senders\n   MUST first remove all trailing 0xF7\
    \ status octets from the command.\n   Then, senders MUST terminate the command\
    \ with an 0xF7 octet and place\n   the modified command into the MIDI Command\
    \ field.\n   Note that we include the trailing octets in our model as a cautionary\n\
    \   measure: if such commands appeared in a non-compliant use of an\n   undefined\
    \ System Common command, an RTP MIDI encoding of the command\n   that did not\
    \ remove trailing octets could be mistaken for an encoding\n   of \"middle\" or\
    \ \"last\" sublist of a segmented SysEx commands (Figure\n   5) under certain\
    \ packet loss conditions.\n          Original SysEx command:\n              0xF0\
    \ 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0xF7\n          A two-segment segmentation:\n\
    \              0xF0 0x01 0x02 0x03 0x04 0xF0\n              0xF7 0x05 0x06 0x07\
    \ 0x08 0xF7\n          A different two-segment segmentation:\n              0xF0\
    \ 0x01 0xF0\n              0xF7 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0xF7\n    \
    \      A three-segment segmentation:\n              0xF0 0x01 0x02 0xF0\n    \
    \          0xF7 0x03 0x04 0xF0\n              0xF7 0x05 0x06 0x07 0x08 0xF7\n\
    \         The segmentation with the largest number of segments:\n            \
    \  0xF0 0x01 0xF0\n              0xF7 0x02 0xF0\n              0xF7 0x03 0xF0\n\
    \              0xF7 0x04 0xF0\n              0xF7 0x05 0xF0\n              0xF7\
    \ 0x06 0xF0\n              0xF7 0x07 0xF0\n              0xF7 0x08 0xF0\n    \
    \          0xF7 0xF7\n                     Figure 6 -- Example segmentations\n"
- title: 4.  The Recovery Journal System
  contents:
  - "4.  The Recovery Journal System\n   The recovery journal is the default resiliency\
    \ tool for unreliable\n   transport.  In this section, we normatively define the\
    \ roles that\n   senders and receivers play in the recovery journal system.\n\
    \   MIDI is a fragile code.  A single lost command in a MIDI command\n   stream\
    \ may produce an artifact in the rendered performance.  We\n   normatively classify\
    \ rendering artifacts into two categories:\n     o Transient artifacts.  Transient\
    \ artifacts produce immediate but\n       short-term glitches in the performance.\
    \  For example, a lost\n       NoteOn (0x9) command produces a transient artifact:\
    \ one note\n       fails to play, but the artifact does not extend beyond the\
    \ end of\n       that note.\n     o Indefinite artifacts.  Indefinite artifacts\
    \ produce long-lasting\n       errors in the rendered performance.  For example,\
    \ a lost NoteOff\n       (0x8) command may produce an indefinite artifact: the\
    \ note that\n       should have been ended by the lost NoteOff command may sustain\n\
    \       indefinitely.  As a second example, the loss of a Control Change\n   \
    \    (0xB) command for controller number 7 (Channel Volume) may\n       produce\
    \ an indefinite artifact: after the loss, all notes on the\n       channel may\
    \ play too softly or too loudly.\n   The purpose of the recovery journal system\
    \ is to satisfy the recovery\n   journal mandate: the MIDI performance rendered\
    \ from an RTP MIDI\n   stream sent over unreliable transport MUST NOT contain\
    \ indefinite\n   artifacts.\n   The recovery journal system does not use packet\
    \ retransmission to\n   satisfy this mandate.  Instead, each packet includes a\
    \ special\n   section, called the recovery journal.\n   The recovery journal codes\
    \ the history of the stream, back to an\n   earlier packet called the checkpoint\
    \ packet.  The range of coverage\n   for the journal is called the checkpoint\
    \ history.  The recovery\n   journal codes the information necessary to recover\
    \ from the loss of\n   an arbitrary number of packets in the checkpoint history.\
    \  Appendix\n   A.1 normatively defines the checkpoint packet and the checkpoint\n\
    \   history.\n   When a receiver detects a packet loss, it compares its own knowledge\n\
    \   about the history of the stream with the history information coded in\n  \
    \ the recovery journal of the packet that ends the loss event.  By\n   noting\
    \ the differences in these two versions of the past, a receiver\n   is able to\
    \ transform all indefinite artifacts in the rendered\n   performance into transient\
    \ artifacts, by executing MIDI commands to\n   repair the stream.\n   We now state\
    \ the normative role for senders in the recovery journal\n   system.\n   Senders\
    \ prepare a recovery journal for every packet in the stream.\n   In doing so,\
    \ senders choose the checkpoint packet identity for the\n   journal.  Senders\
    \ make this choice by applying a sending policy.\n   Appendix C.2.2 normatively\
    \ defines three sending policies: \"closed-\n   loop\", \"open-loop\", and \"\
    anchor\".\n   By default, senders MUST use the closed-loop sending policy.  If\
    \ the\n   session description overrides this default policy, by using the\n  \
    \ parameter j_update defined in Appendix C.2.2, senders MUST use the\n   specified\
    \ policy.\n   After choosing the checkpoint packet identity for a packet, the\n\
    \   sender creates the recovery journal.  By default, this journal MUST\n   conform\
    \ to the normative semantics in Section 5 and Appendices A-B in\n   this memo.\
    \  In Appendix C.2.3, we define parameters that modify the\n   normative semantics\
    \ for recovery journals.  If the session\n   description uses these parameters,\
    \ the journal created by the sender\n   MUST conform to the modified semantics.\n\
    \   Next, we state the normative role for receivers in the recovery\n   journal\
    \ system.\n   A receiver MUST detect each RTP sequence number break in a stream.\n\
    \   If the sequence number break is due to a packet loss event (as\n   defined\
    \ in [RFC3550]), the receiver MUST repair all indefinite\n   artifacts in the\
    \ rendered MIDI performance caused by the loss.  If\n   the sequence number break\
    \ is due to an out-of-order packet (as\n   defined in [RFC3550]), the receiver\
    \ MUST NOT take actions that\n   introduce indefinite artifacts (ignoring the\
    \ out-of-order packet is a\n   safe option).\n   Receivers take special precautions\
    \ when entering or exiting a\n   session.  A receiver MUST process the first received\
    \ packet in a\n   stream as if it were a packet that ends a loss event.  Upon\
    \ exiting a\n   session, a receiver MUST ensure that the rendered MIDI performance\n\
    \   does not end with indefinite artifacts.\n   Receivers are under no obligation\
    \ to perform indefinite artifact\n   repairs at the moment a packet arrives. \
    \ A receiver that uses a\n   playout buffer may choose to wait until the moment\
    \ of rendering\n   before processing the recovery journal, as the \"lost\" packet\
    \ may be a\n   late packet that arrives in time to use.\n   Next, we state the\
    \ normative role for the creator of the session\n   description in the recovery\
    \ journal system.  Depending on the\n   application, the sender, the receivers,\
    \ and other parties may take\n   part in creating or approving the session description.\n\
    \   A session description that specifies the default closed-loop sending\n   policy\
    \ and the default recovery journal semantics satisfies the\n   recovery journal\
    \ mandate.  However, these default behaviors may not\n   be appropriate for all\
    \ sessions.  If the creators of a session\n   description use the parameters defined\
    \ in Appendix C.2 to override\n   these defaults, the creators MUST ensure that\
    \ the parameters define a\n   system that satisfies the recovery journal mandate.\n\
    \   Finally, we note that this memo does not specify sender or receiver\n   recovery\
    \ journal algorithms.  Implementations are free to use any\n   algorithm that\
    \ conforms to the requirements in this section.  The\n   non-normative [RFC4696]\
    \ discusses sender and receiver algorithm\n   design.\n"
- title: 5.  Recovery Journal Format
  contents:
  - "5.  Recovery Journal Format\n   This section introduces the structure of the\
    \ recovery journal and\n   defines the bitfields of recovery journal headers.\
    \  Appendices A-B\n   complete the bitfield definition of the recovery journal.\n\
    \   The recovery journal has a three-level structure:\n     o Top-level header.\n\
    \     o Channel and system journal headers.  These headers encode\n       recovery\
    \ information for a single voice channel (channel journal)\n       or for all\
    \ systems commands (system journal).\n     o Chapters.  Chapters describe recovery\
    \ information for a single\n       MIDI command type.\n   Figure 7 shows the top-level\
    \ structure of the recovery journal.  The\n   recovery journals consists of a\
    \ 3-octet header, followed by an\n   optional system journal (labeled S-journal\
    \ in Figure 7) and an\n   optional list of channel journals.  Figure 8 shows the\
    \ recovery\n   journal header format.\n       0                   1          \
    \         2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |            Recovery journal header            | S-journal ... |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                      Channel journals ...                     |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                Figure 7 -- Top-level recovery journal format\n             \
    \ 0                   1                   2\n              0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \             |S|Y|A|H|TOTCHAN|   Checkpoint Packet Seqnum    |\n            \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                    Figure\
    \ 8 -- Recovery journal header\n   If the Y header bit is set to 1, the system\
    \ journal appears in the\n   recovery journal, directly following the recovery\
    \ journal header.\n   If the A header bit is set to 1, the recovery journal ends\
    \ with a\n   list of (TOTCHAN + 1) channel journals (the 4-bit TOTCHAN header\n\
    \   field is interpreted as an unsigned integer).\n   A MIDI channel MAY be represented\
    \ by (at most) one channel journal in\n   a recovery journal.  Channel journals\
    \ MUST appear in the recovery\n   journal in ascending channel-number order.\n\
    \   If A and Y are both zero, the recovery journal only contains its 3-\n   octet\
    \ header and is considered to be an \"empty\" journal.\n   The S (single-packet\
    \ loss) bit appears in most recovery journal\n   structures, including the recovery\
    \ journal header.  The S bit helps\n   receivers efficiently parse the recovery\
    \ journal in the common case\n   of the loss of a single packet.  Appendix A.1\
    \ defines S bit\n   semantics.\n   The H bit indicates if MIDI channels in the\
    \ stream have been\n   configured to use the enhanced Chapter C encoding (Appendix\
    \ A.3.3).\n   By default, the payload format does not use enhanced Chapter C\n\
    \   encoding.  In this default case, the H bit MUST be set to 0 for all\n   packets\
    \ in the stream.\n   If the stream has been configured so that controller numbers\
    \ for one\n   or more MIDI channels use enhanced Chapter C encoding, the H bit\
    \ MUST\n   be set to 1 in all packets in the stream.  In Appendix C.2.3, we show\n\
    \   how to configure a stream to use enhanced Chapter C encoding.\n   The 16-bit\
    \ Checkpoint Packet Seqnum header field codes the sequence\n   number of the checkpoint\
    \ packet for this journal, in network byte\n   order (big-endian).  The choice\
    \ of the checkpoint packet sets the\n   depth of the checkpoint history for the\
    \ journal (defined in Appendix\n   A.1).\n   Receivers may use the Checkpoint\
    \ Packet Seqnum field of the packet\n   that ends a loss event to verify that\
    \ the journal checkpoint history\n   covers the entire loss event.  The checkpoint\
    \ history covers the loss\n   event if the Checkpoint Packet Seqnum field is less\
    \ than or equal to\n   one plus the highest RTP sequence number previously received\
    \ on the\n   stream (modulo 2^16).\n       0                   1             \
    \      2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |S| CHAN  |H|      LENGTH       |P|C|M|W|N|E|T|A|  Chapters ... |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \               Figure 9 -- Channel journal format\n   Figure 9 shows the structure\
    \ of a channel journal: a 3-octet header,\n   followed by a list of leaf elements\
    \ called channel chapters.  A\n   channel journal encodes information about MIDI\
    \ commands on the MIDI\n   channel coded by the 4-bit CHAN header field.  Note\
    \ that CHAN uses\n   the same bit encoding as the channel nibble in MIDI Channel\
    \ Messages\n   (the cccc field in Figure E.1 of Appendix E).\n   The 10-bit LENGTH\
    \ field codes the length of the channel journal.  The\n   semantics for LENGTH\
    \ fields are uniform throughout the recovery\n   journal, and are defined in Appendix\
    \ A.1.\n   The third octet of the channel journal header is the Table of\n   Contents\
    \ (TOC) of the channel journal.  The TOC is a set of bits that\n   encode the\
    \ presence of a chapter in the journal.  Each chapter\n   contains information\
    \ about a certain class of MIDI channel command:\n      o  Chapter P: MIDI Program\
    \ Change (0xC)\n      o  Chapter C: MIDI Control Change (0xB)\n      o  Chapter\
    \ M: MIDI Parameter System (part of 0xB)\n      o  Chapter W: MIDI Pitch Wheel\
    \ (0xE)\n      o  Chapter N: MIDI NoteOff (0x8), NoteOn (0x9)\n      o  Chapter\
    \ E: MIDI Note Command Extras (0x8, 0x9)\n      o  Chapter T: MIDI Channel Aftertouch\
    \ (0xD)\n      o  Chapter A: MIDI Poly Aftertouch (0xA)\n   Chapters appear in\
    \ a list following the header, in order of their\n   appearance in the TOC.  Appendices\
    \ A.2-9 describe the bitfield format\n   for each chapter, and define the conditions\
    \ under which a chapter\n   type MUST appear in the recovery journal.  If any\
    \ chapter types are\n   required for a channel, an associated channel journal\
    \ MUST appear in\n   the recovery journal.\n   The H bit indicates if controller\
    \ numbers on a MIDI channel have been\n   configured to use the enhanced Chapter\
    \ C encoding (Appendix A.3.3).\n   By default, controller numbers on a MIDI channel\
    \ do not use enhanced\n   Chapter C encoding.  In this default case, the H bit\
    \ MUST be set to 0\n   for all channel journal headers for the channel in the\
    \ recovery\n   journal, for all packets in the stream.\n   However, if at least\
    \ one controller number for a MIDI channel has\n   been configured to use the\
    \ enhanced Chapter C encoding, the H bit for\n   its channel journal MUST be set\
    \ to 1, for all packets in the stream.\n   In Appendix C.2.3, we show how to configure\
    \ a controller number to\n   use enhanced Chapter C encoding.\n       0      \
    \             1                   2                   3\n       0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |S|D|V|Q|F|X|      LENGTH       |  System chapters ...          |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \               Figure 10 -- System journal format\n   Figure 10 shows the structure\
    \ of the system journal: a 2-octet\n   header, followed by a list of system chapters.\
    \  Each chapter codes\n   information about a specific class of MIDI Systems command:\n\
    \      o  Chapter D: Song Select (0xF3), Tune Request (0xF6), Reset\n        \
    \            (0xFF), undefined System commands (0xF4, 0xF5, 0xF9,\n          \
    \          0xFD)\n      o  Chapter V: Active Sense (0xFE)\n      o  Chapter Q:\
    \ Sequencer State (0xF2, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC)\n      o  Chapter F: MTC\
    \ Tape Position (0xF1, 0xF0 0x7F 0xcc 0x01 0x01)\n      o  Chapter X: System Exclusive\
    \ (all other 0xF0)\n   The 10-bit LENGTH field codes the size of the system journal\
    \ and\n   conforms to semantics described in Appendix A.1.\n   The D, V, Q, F,\
    \ and X header bits form a Table of Contents (TOC) for\n   the system journal.\
    \  A TOC bit that is set to 1 codes the presence of\n   a chapter in the journal.\
    \  Chapters appear in a list following the\n   header, in the order of their appearance\
    \ in the TOC.\n   Appendix B describes the bitfield format for the system chapters\
    \ and\n   defines the conditions under which a chapter type MUST appear in the\n\
    \   recovery journal.  If any system chapter type is required to appear\n   in\
    \ the recovery journal, the system journal MUST appear in the\n   recovery journal.\n"
- title: 6.  Session Description Protocol
  contents:
  - "6.  Session Description Protocol\n   RTP does not perform session management.\
    \  Instead, RTP works together\n   with session management tools, such as the\
    \ Session Initiation\n   Protocol (SIP, [RFC3261]) and the Real Time Streaming\
    \ Protocol (RTSP,\n   [RFC2326]).\n   RTP payload formats define media type parameters\
    \ for use in session\n   management (for example, this memo defines \"rtp-midi\"\
    \ as the media\n   type for native RTP MIDI streams).\n   In most cases, session\
    \ management tools use the media type parameters\n   via another standard, the\
    \ Session Description Protocol (SDP,\n   [RFC4566]).\n   SDP is a textual format\
    \ for specifying session descriptions.  Session\n   descriptions specify the network\
    \ transport and media encoding for RTP\n   sessions.  Session management tools\
    \ coordinate the exchange of\n   session descriptions between participants (\"\
    parties\").\n   Some session management tools use SDP to negotiate details of\
    \ media\n   transport (network addresses, ports, etc.).  We refer to this use\
    \ of\n   SDP as \"negotiated usage\".  One example of negotiated usage is the\n\
    \   Offer/Answer protocol ([RFC3264] and Appendix C.7.2 in this memo) as\n   used\
    \ by SIP.\n   Other session management tools use SDP to declare the media encoding\n\
    \   for the session but use other techniques to negotiate network\n   transport.\
    \  We refer to this use of SDP as \"declarative usage\".  One\n   example of declarative\
    \ usage is RTSP ([RFC2326] and Appendix C.7.1 in\n   this memo).\n   Below, we\
    \ show session description examples for native (Section 6.1)\n   and mpeg4-generic\
    \ (Section 6.2) streams.  In Section 6.3, we\n   introduce session configuration\
    \ tools that may be used to customize\n   streams.\n"
- title: 6.1.  Session Descriptions for Native Streams
  contents:
  - "6.1.  Session Descriptions for Native Streams\n   The session description below\
    \ defines a unicast UDP RTP session (via\n   a media (\"m=\") line) whose sole\
    \ payload type (96) is mapped to a\n   minimal native RTP MIDI stream.\n   v=0\n\
    \   o=lazzaro 2520644554 2838152170 IN IP4 first.example.net\n   s=Example\n \
    \  t=0 0\n   m=audio 5004 RTP/AVP 96\n   c=IN IP4 192.0.2.94\n   a=rtpmap:96 rtp-midi/44100\n\
    \   The rtpmap attribute line uses the \"rtp-midi\" media type to specify\n  \
    \ an RTP MIDI native stream.  The clock rate specified on the rtpmap\n   line\
    \ (in the example above, 44100 Hz) sets the scaling for the RTP\n   timestamp\
    \ header field (see Section 2.1, and also [RFC3550]).\n   Note that this document\
    \ does not specify a default clock rate value\n   for RTP MIDI.  When RTP MIDI\
    \ is used with SDP, parties MUST use the\n   rtpmap line to communicate the clock\
    \ rate.  Guidance for selecting\n   the RTP MIDI clock rate value appears in Section\
    \ 2.1.\n   We consider the RTP MIDI stream shown above to be \"minimal\" because\n\
    \   the session description does not customize the stream with\n   parameters.\
    \  Without such customization, a native RTP MIDI stream has\n   these characteristics:\n\
    \     1. If the stream uses unreliable transport (unicast UDP, multicast\n   \
    \     UDP, etc.), the recovery journal system is in use, and the RTP\n       \
    \ payload contains both the MIDI command section and the journal\n        section.\
    \  If the stream uses reliable transport (such as TCP),\n        the stream does\
    \ not use journalling, and the payload contains\n        only the MIDI command\
    \ section (Section 2.2).\n     2. If the stream uses the recovery journal system,\
    \ the recovery\n        journal system uses the default sending policy and the\
    \ default\n        journal semantics (Section 4).\n     3. In the MIDI command\
    \ section of the payload, command timestamps\n        use the default \"comex\"\
    \ semantics (Section 3).\n     4. The recommended temporal duration (\"media time\"\
    ) of an RTP\n        packet ranges from 0 to 200 ms, and the RTP timestamp difference\n\
    \        between sequential packets in the stream may be arbitrarily\n       \
    \ large (Section 2.1).\n     5. If more than one minimal rtp-midi stream appears\
    \ in a session,\n        the MIDI name spaces for these streams are independent:\
    \ channel\n        1 in the first stream does not reference the same MIDI channel\n\
    \        as channel 1 in the second stream (see Appendix C.5 for a\n        discussion\
    \ of the independence of minimal rtp-midi streams).\n     6. The rendering method\
    \ for the stream is not specified.  What the\n        receiver \"does\" with a\
    \ minimal native MIDI stream is \"out of\n        scope\" of this memo.  For example,\
    \ in content creation\n        environments, a user may manually configure client\
    \ software to\n        render the stream with a specific software package.\n \
    \  As in standard in RTP, RTP sessions managed by SIP are sendrecv by\n   default\
    \ (parties send and receive MIDI), and RTP sessions managed by\n   RTSP are recvonly\
    \ by default (server sends and client receives).\n   In sendrecv RTP MIDI sessions\
    \ for the session description shown\n   above, the 16 voice channel + systems\
    \ MIDI name space is unique for\n   each sender.  Thus, in a two-party session,\
    \ the voice channel 0 sent\n   by one party is distinct from the voice channel\
    \ 0 sent by the other\n   party.\n   This behavior corresponds to what occurs\
    \ when two MIDI 1.0 DIN\n   devices are cross-connected with two MIDI cables (one\
    \ cable routing\n   MIDI Out from the first device into MIDI In of the second\
    \ device, a\n   second cable routing MIDI In from the first device into MIDI Out\
    \ of\n   the second device).  We define this \"association\" formally in Section\n\
    \   2.1.\n   MIDI 1.0 DIN networks may be configured in a \"party-line\" multicast\n\
    \   topology.  For these networks, the MIDI protocol itself provides\n   tools\
    \ for addressing specific devices in transactions on a multicast\n   network,\
    \ and for device discovery.  Thus, apart from providing a 1-\n   to-many forward\
    \ path and a many-to-1 reverse path, IETF protocols do\n   not need to provide\
    \ any special support for MIDI multicast\n   networking.\n"
- title: 6.2.  Session Descriptions for mpeg4-generic Streams
  contents:
  - "6.2.  Session Descriptions for mpeg4-generic Streams\n   An mpeg4-generic [RFC3640]\
    \ RTP MIDI stream uses an MPEG 4 Audio\n   Object Type to render MIDI into audio.\
    \  Three Audio Object Types\n   accept MIDI input:\n     o General MIDI (Audio\
    \ Object Type ID 15), based on the General MIDI\n       rendering standard [MIDI].\n\
    \     o Wavetable Synthesis (Audio Object Type ID 14), based on the\n       Downloadable\
    \ Sounds Level 2 (DLS 2) rendering standard [DLS2].\n     o Main Synthetic (Audio\
    \ Object Type ID 13), based on Structured\n       Audio and the programming language\
    \ SAOL [MPEGSA].\n   The primary service of an mpeg4-generic stream is to code\
    \ Access\n   Units (AUs).  We define the mpeg4-generic RTP MIDI AU as the MIDI\n\
    \   payload shown in Figure 1 of Section 2.1 of this memo: a MIDI command\n  \
    \ section optionally followed by a journal section.\n   Exactly one RTP MIDI AU\
    \ MUST be mapped to one mpeg4-generic RTP MIDI\n   packet.  The mpeg4-generic\
    \ options for placing several AUs in an RTP\n   packet MUST NOT be used with RTP\
    \ MIDI.  The mpeg4-generic options for\n   fragmenting and interleaving AUs MUST\
    \ NOT be used with RTP MIDI.  The\n   mpeg4-generic RTP packet payload (Figure\
    \ 1 in [RFC3640]) MUST contain\n   empty AU Header and Auxiliary sections.  These\
    \ rules yield mpeg4-\n   generic packets that are structurally identical to native\
    \ RTP MIDI\n   packets, an essential property for the correct operation of the\n\
    \   payload format.\n   The session description that follows defines a unicast\
    \ UDP RTP\n   session (via a media (\"m=\") line) whose sole payload type (96)\
    \ is\n   mapped to a minimal mpeg4-generic RTP MIDI stream.  This example uses\n\
    \   the General MIDI Audio Object Type under Synthesis Profile @ Level 2.\n  \
    \ v=0\n   o=lazzaro 2520644554 2838152170 IN IP6 first.example.net\n   s=Example\n\
    \   t=0 0\n   m=audio 5004 RTP/AVP 96\n   c=IN IP6 2001:DB80::7F2E:172A:1E24\n\
    \   a=rtpmap:96 mpeg4-generic/44100\n   a=fmtp:96 streamtype=5; mode=rtp-midi;\
    \ profile-level-id=12;\n   config=7A0A0000001A4D546864000000060000000100604D54726B0000\n\
    \   000600FF2F000\n   (The a=fmtp line has been wrapped to fit the page to accommodate\
    \ memo\n   formatting restrictions; it comprises a single line in SDP.)\n   The\
    \ fmtp attribute line codes the four parameters (streamtype, mode,\n   profile-level-id,\
    \ and config) that are required in all mpeg4-generic\n   session descriptions\
    \ [RFC3640].  For RTP MIDI streams, the streamtype\n   parameter MUST be set to\
    \ 5, the \"mode\" parameter MUST be set to\n   \"rtp-midi\", and the \"profile-level-id\"\
    \ parameter MUST be set to the\n   MPEG-4 Profile Level for the stream.  For the\
    \ Synthesis Profile,\n   legal profile-level-id values are 11, 12, and 13, coding\
    \ low (11),\n   medium (12), or high (13) decoder computational complexity, as\n\
    \   defined by MPEG conformance tests.\n   In a minimal RTP MIDI session description,\
    \ the config value MUST be a\n   hexadecimal encoding [RFC3640] of the AudioSpecificConfig\
    \ data block\n   [MPEGAUDIO] for the stream.  AudioSpecificConfig encodes the\
    \ Audio\n   Object Type for the stream and also encodes initialization data (SAOL\n\
    \   programs, DLS 2 wave tables, etc.).  Standard MIDI Files encoded in\n   AudioSpecificConfig\
    \ in a minimal session description MUST be ignored\n   by the receiver.\n   Receivers\
    \ determine the rendering algorithm for the session by\n   interpreting the first\
    \ 5 bits of AudioSpecificConfig as an unsigned\n   integer that codes the Audio\
    \ Object Type.  In our example above, the\n   leading config string nibbles \"\
    7A\" yield the Audio Object Type 15\n   (General MIDI).  In Appendix E.4, we derive\
    \ the config string value\n   in the session description shown above; the starting\
    \ point of the\n   derivation is the MPEG bitstreams defined in [MPEGSA] and\n\
    \   [MPEGAUDIO].\n   We consider the stream to be \"minimal\" because the session\n\
    \   description does not customize the stream through the use of\n   parameters,\
    \ other than the 4 required mpeg4-generic parameters\n   described above.  In\
    \ Section 6.1, we describe the behavior of a\n   minimal native stream, as a numbered\
    \ list of characteristics.  Items\n   1-4 on that list also describe the minimal\
    \ mpeg4-generic stream, but\n   items 5 and 6 require restatements, as listed\
    \ below:\n     5. If more than one minimal mpeg4-generic stream appears in a\n\
    \        session, each stream uses an independent instance of the Audio\n    \
    \    Object Type coded in the config parameter value.\n     6. A minimal mpeg4-generic\
    \ stream encodes the AudioSpecificConfig\n        as an inline hexadecimal constant.\
    \  If a session description is\n        sent over UDP, it may be impossible to\
    \ transport large\n        AudioSpecificConfig blocks within the Maximum Transmission\
    \ Size\n        (MTU) of the underlying network (for Ethernet, the MTU is 1500\n\
    \        octets).  In some cases, the AudioSpecificConfig block may\n        exceed\
    \ the maximum size of the UDP packet itself.\n   The comments in Section 6.1 on\
    \ SIP and RTSP stream directional\n   defaults, sendrecv MIDI channel usage, and\
    \ MIDI 1.0 DIN multicast\n   networks also apply to mpeg4-generic RTP MIDI sessions.\n\
    \   In sendrecv sessions, each party's session description MUST use\n   identical\
    \ values for the mpeg4-generic parameters (including the\n   required streamtype,\
    \ mode, profile-level-id, and config parameters).\n   As a consequence, each party\
    \ uses an identically configured MPEG 4\n   Audio Object Type to render MIDI commands\
    \ into audio.  The preamble\n   to Appendix C discusses a way to create \"virtual\
    \ sendrecv\" sessions\n   that do not have this restriction.\n"
- title: 6.3.  Parameters
  contents:
  - "6.3.  Parameters\n   This section introduces parameters for session configuration\
    \ for RTP\n   MIDI streams.  In session descriptions, parameters modify the\n\
    \   semantics of a payload type.  Parameters are specified on an fmtp\n   attribute\
    \ line.  See the session description example in Section 6.2\n   for an example\
    \ of a fmtp attribute line.\n   The parameters add features to the minimal streams\
    \ described in\n   Sections 6.1-2, and support several types of services:\n  \
    \   o  Stream subsetting.  By default, all MIDI commands that are legal\n    \
    \    to appear on a MIDI 1.0 DIN cable may appear in an RTP MIDI\n        stream.\
    \  The cm_unused parameter overrides this default by\n        prohibiting certain\
    \ commands from appearing in the stream.  The\n        cm_used parameter is used\
    \ in conjunction with cm_unused, to\n        simplify the specification of complex\
    \ exclusion rules.  We\n        describe cm_unused and cm_used in Appendix C.1.\n\
    \     o  Journal customization.  The j_sec and j_update parameters\n        configure\
    \ the use of the journal section.  The ch_default,\n        ch_never, and ch_anchor\
    \ parameters configure the semantics of\n        the recovery journal chapters.\
    \  These parameters are described\n        in Appendix C.2 and override the default\
    \ stream behaviors 1 and\n        2, listed in Section 6.1 and referenced in Section\
    \ 6.2.\n     o  MIDI command timestamp semantics.  The tsmode, octpos, mperiod,\n\
    \        and linerate parameters customize the semantics of timestamps in\n  \
    \      the MIDI command section.  These parameters let RTP MIDI\n        accurately\
    \ encode the implicit time coding of MIDI 1.0 DIN\n        cables.  These parameters\
    \ are described in Appendix C.3 and\n        override default stream behavior\
    \ 3, listed in Section 6.1 and\n        referenced in Section 6.2\n     o  Media\
    \ time.  The rtp_ptime and rtp_maxptime parameters define\n        the temporal\
    \ duration (\"media time\") of an RTP MIDI packet.  The\n        guardtime parameter\
    \ sets the minimum sending rate of stream\n        packets.  These parameters\
    \ are described in Appendix C.4 and\n        override default stream behavior\
    \ 4, listed in Section 6.1 and\n        referenced in Section 6.2.\n     o  Stream\
    \ description.  The musicport parameter labels the MIDI\n        name space of\
    \ RTP streams in a multimedia session.  Musicport is\n        described in Appendix\
    \ C.5.  The musicport parameter overrides\n        default stream behavior 5,\
    \ in Sections 6.1 and 6.2.\n     o  MIDI rendering.  Several parameters specify\
    \ the MIDI rendering\n        method of a stream.  These parameters are described\
    \ in Appendix\n        C.6 and override default stream behavior 6, in Sections\
    \ 6.1 and\n        6.2.\n   In Appendix C.7, we specify interoperability guidelines\
    \ for two RTP\n   MIDI application areas: content-streaming using RTSP (Appendix\
    \ C.7.1)\n   and network musical performance using SIP (Appendix C.7.2).\n"
- title: 7.  Extensibility
  contents:
  - "7.  Extensibility\n   The payload format defined in this memo exclusively encodes\
    \ all\n   commands that may legally appear on a MIDI 1.0 DIN cable.\n   Many worthy\
    \ uses of MIDI over RTP do not fall within the narrow scope\n   of the payload\
    \ format.  For example, the payload format does not\n   support the direct transport\
    \ of Standard MIDI File (SMF) meta-event\n   and metric timing data.  As a second\
    \ example, the payload format does\n   not define transport tools for user-defined\
    \ commands (apart from\n   tools to support System Exclusive commands [MIDI]).\n\
    \   The payload format does not provide an extension mechanism to support\n  \
    \ new features of this nature, by design.  Instead, we encourage the\n   development\
    \ of new payload formats for specialized musical\n   applications.  The IETF session\
    \ management tools [RFC3264] [RFC2326]\n   support codec negotiation, to facilitate\
    \ the use of new payload\n   formats in a backward-compatible way.\n   However,\
    \ the payload format does provide several extensibility tools,\n   which we list\
    \ below:\n     o  Journalling.  As described in Appendix C.2, new token values\
    \ for\n        the j_sec and j_update parameters may be defined in IETF\n    \
    \    standards-track documents.  This mechanism supports the design\n        of\
    \ new journal formats and the definition of new journal sending\n        policies.\n\
    \     o  Rendering.  The payload format may be extended to support new\n     \
    \   MIDI renderers (Appendix C.6.2).  Certain general aspects of the\n       \
    \ RTP MIDI rendering process may also be extended, via the\n        definition\
    \ of new token values for the render (Appendix C.6) and\n        smf_info (Appendix\
    \ C.6.4.1) parameters.\n     o  Undefined commands.  [MIDI] reserves 4 MIDI System\
    \ commands for\n        future use (0xF4, 0xF5, 0xF9, 0xFD).  If updates to [MIDI]\n\
    \        define the reserved commands, IETF standards-track documents may\n  \
    \      be defined to provide resiliency support for the commands.\n        Opaque\
    \ LEGAL fields appear in System Chapter D for this purpose\n        (Appendix\
    \ B.1.1).\n   A final form of extensibility involves the inclusion of the payload\n\
    \   format in framework documents.  Framework documents describe how to\n   combine\
    \ protocols to form a platform for interoperable applications.\n   For example,\
    \ a stage and studio framework might define how to use SIP\n   [RFC3261], RTSP\
    \ [RFC2326], SDP [RFC4566], and RTP [RFC3550] to\n   support media networking\
    \ for professional audio equipment and\n   electronic musical instruments.\n"
- title: 8.  Congestion Control
  contents:
  - "8.  Congestion Control\n   The RTP congestion control requirements defined in\
    \ [RFC3550] apply to\n   RTP MIDI sessions, and implementors should carefully\
    \ read the\n   congestion control section in [RFC3550].  As noted in [RFC3550],\
    \ all\n   transport protocols used on the Internet need to address congestion\n\
    \   control in some way, and RTP is not an exception.\n   In addition, the congestion\
    \ control requirements defined in [RFC3551]\n   applies to RTP MIDI sessions run\
    \ under applicable profiles.  The\n   basic congestion control requirement defined\
    \ in [RFC3551] is that RTP\n   sessions that use UDP transport should monitor\
    \ packet loss (via RTCP\n   or other means) to ensure that the RTP stream competes\
    \ fairly with\n   TCP flows that share the network.\n   Finally, RTP MIDI has\
    \ congestion control issues that are unique for\n   an audio RTP payload format.\
    \  In applications such as network musical\n   performance [NMP], the packet rate\
    \ is linked to the gestural rate of\n   a human performer.  Senders MUST monitor\
    \ the MIDI command source for\n   patterns that result in excessive packet rates\
    \ and take actions\n   during RTP transcoding to reduce the RTP packet rate. \
    \ [RFC4696]\n   offers implementation guidance on this issue.\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   Implementors should carefully read the Security\
    \ Considerations\n   sections of the RTP [RFC3550], AVP [RFC3551], and other RTP\
    \ profile\n   documents, as the issues discussed in these sections directly apply\n\
    \   to RTP MIDI streams.  Implementors should also review the Secure\n   Real-time\
    \ Transport Protocol (SRTP, [RFC3711]), an RTP profile that\n   addresses the\
    \ security issues discussed in [RFC3550] and [RFC3551].\n   Here, we discuss security\
    \ issues that are unique to the RTP MIDI\n   payload format.\n   When using RTP\
    \ MIDI, authentication of incoming RTP and RTCP packets\n   is RECOMMENDED.  Per-packet\
    \ authentication may be provided by SRTP or\n   by other means.  Without the use\
    \ of authentication, attackers could\n   forge MIDI commands into an ongoing stream,\
    \ damaging speakers and\n   eardrums.  An attacker could also craft RTP and RTCP\
    \ packets to\n   exploit known bugs in the client and take effective control of\
    \ a\n   client machine.\n   Session management tools (such as SIP [RFC3261]) SHOULD\
    \ use\n   authentication during the transport of all session descriptions\n  \
    \ containing RTP MIDI media streams.  For SIP, the Security\n   Considerations\
    \ section in [RFC3261] provides an overview of possible\n   authentication mechanisms.\
    \  RTP MIDI session descriptions should use\n   authentication because the session\
    \ descriptions may code\n   initialization data using the parameters described\
    \ in Appendix C.  If\n   an attacker inserts bogus initialization data into a\
    \ session\n   description, he can corrupt the session or forge an client attack.\n\
    \   Session descriptions may also code renderer initialization data by\n   reference,\
    \ via the url (Appendix C.6.3) and smf_url (Appendix\n   C.6.4.2) parameters.\
    \  If the coded URL is spoofed, both session and\n   client are open to attack,\
    \ even if the session description itself is\n   authenticated.  Therefore, URLs\
    \ specified in url and smf_url\n   parameters SHOULD use [RFC2818].\n   Section\
    \ 2.1 allows streams sent by a party in two RTP sessions to\n   have the same\
    \ SSRC value and the same RTP timestamp initialization\n   value, under certain\
    \ circumstances.  Normally, these values are\n   randomly chosen for each stream\
    \ in a session, to make plaintext\n   guessing harder to do if the payloads are\
    \ encrypted.  Thus, Section\n   2.1 weakens this aspect of RTP security.\n"
- title: 10.  Acknowledgements
  contents:
  - "10.  Acknowledgements\n   We thank the networking, media compression, and computer\
    \ music\n   community members who have commented or contributed to the effort,\n\
    \   including Kurt B, Cynthia Bruyns, Steve Casner, Paul Davis, Robin\n   Davies,\
    \ Joanne Dow, Tobias Erichsen, Nicolas Falquet, Dominique\n   Fober, Philippe\
    \ Gentric, Michael Godfrey, Chris Grigg, Todd Hager,\n   Michel Jullian, Phil\
    \ Kerr, Young-Kwon Lim, Jessica Little, Jan van\n   der Meer, Colin Perkins, Charlie\
    \ Richmond, Herbie Robinson, Larry\n   Rowe, Eric Scheirer, Dave Singer, Martijn\
    \ Sipkema, William Stewart,\n   Kent Terry, Magnus Westerlund, Tom White, Jim\
    \ Wright, Doug Wyatt, and\n   Giorgio Zoia.  We also thank the members of the\
    \ San Francisco Bay\n   Area music and audio community for creating the context\
    \ for the work,\n   including Don Buchla, Chris Chafe, Richard Duda, Dan Ellis,\
    \ Adrian\n   Freed, Ben Gold, Jaron Lanier, Roger Linn, Richard Lyon, Dana Massie,\n\
    \   Max Mathews, Keith McMillen, Carver Mead, Nelson Morgan, Tom\n   Oberheim,\
    \ Malcolm Slaney, Dave Smith, Julius Smith, David Wessel, and\n   Matt Wright.\n"
- title: 11.  IANA Considerations
  contents:
  - "11.  IANA Considerations\n   This section makes a series of requests to IANA.\
    \  The IANA has\n   completed registration/assignments of the below requests.\n\
    \   The sub-sections that follow hold the actual, detailed requests.  All\n  \
    \ registrations in this section are in the IETF tree and follow the\n   rules\
    \ of [RFC4288] and [RFC3555], as appropriate.\n   In Section 11.1, we request\
    \ the registration of a new media type:\n   \"audio/rtp-midi\".  Paired with this\
    \ request is a request for a\n   repository for new values for several parameters\
    \ associated with\n   \"audio/rtp-midi\".  We request this repository in Section\
    \ 11.1.1.\n   In Section 11.2, we request the registration of a new value (\"\
    rtp-\n   midi\") for the \"mode\" parameter of the \"mpeg4-generic\" media type.\n\
    \   The \"mpeg4-generic\" media type is defined in [RFC3640], and [RFC3640]\n\
    \   defines a repository for the \"mode\" parameter.  However, we believe\n  \
    \ we are the first to request the registration of a \"mode\" value, so we\n  \
    \ believe the registry for \"mode\" has not yet been created by IANA.\n   Paired\
    \ with our \"mode\" parameter value request for \"mpeg4-generic\" is\n   a request\
    \ for a repository for new values for several parameters we\n   have defined for\
    \ use with the \"rtp-midi\" mode value.  We request this\n   repository in Section\
    \ 11.2.1.\n   In Section 11.3, we request the registration of a new media type:\n\
    \   \"audio/asc\".  No repository request is associated with this request.\n"
- title: 11.1.  rtp-midi Media Type Registration
  contents:
  - "11.1.  rtp-midi Media Type Registration\n   This section requests the registration\
    \ of the \"rtp-midi\" subtype for\n   the \"audio\" media type.  We request the\
    \ registration of the\n   parameters listed in the \"optional parameters\" section\
    \ below (both\n   the \"non-extensible parameters\" and the \"extensible parameters\"\
    \n   lists).  We also request the creation of repositories for the\n   \"extensible\
    \ parameters\"; the details of this request appear in\n   Section 11.1.1, below.\n\
    \   Media type name:\n       audio\n   Subtype name:\n       rtp-midi\n   Required\
    \ parameters:\n       rate: The RTP timestamp clock rate.  See Sections 2.1 and\
    \ 6.1\n       for usage details.\n   Optional parameters:\n       Non-extensible\
    \ parameters:\n          ch_anchor:    See Appendix C.2.3 for usage details.\n\
    \          ch_default:   See Appendix C.2.3 for usage details.\n          ch_never:\
    \     See Appendix C.2.3 for usage details.\n          cm_unused:    See Appendix\
    \ C.1 for usage details.\n          cm_used:      See Appendix C.1 for usage details.\n\
    \          chanmask:     See Appendix C.6.4.3 for usage details.\n          cid:\
    \          See Appendix C.6.3 for usage details.\n          guardtime:    See\
    \ Appendix C.4.2 for usage details.\n          inline:       See Appendix C.6.3\
    \ for usage details.\n          linerate:     See Appendix C.3 for usage details.\n\
    \          mperiod:      See Appendix C.3 for usage details.\n          multimode:\
    \    See Appendix C.6.1 for usage details.\n          musicport:    See Appendix\
    \ C.5 for usage details.\n          octpos:       See Appendix C.3 for usage details.\n\
    \          rinit:        See Appendix C.6.3 for usage details.\n          rtp_maxptime:\
    \ See Appendix C.4.1 for usage details.\n          rtp_ptime:    See Appendix\
    \ C.4.1 for usage details.\n          smf_cid:      See Appendix C.6.4.2 for usage\
    \ details.\n          smf_inline:   See Appendix C.6.4.2 for usage details.\n\
    \          smf_url:      See Appendix C.6.4.2 for usage details.\n          tsmode:\
    \       See Appendix C.3 for usage details.\n          url:          See Appendix\
    \ C.6.3 for usage details.\n       Extensible parameters:\n          j_sec:  \
    \      See Appendix C.2.1 for usage details.  See\n                        Section\
    \ 11.1.1 for repository details.\n          j_update:     See Appendix C.2.2 for\
    \ usage details.  See\n                        Section 11.1.1 for repository details.\n\
    \          render:       See Appendix C.6 for usage details.  See\n          \
    \              Section 11.1.1 for repository details.\n          subrender:  \
    \  See Appendix C.6.2 for usage details.  See\n                        Section\
    \ 11.1.1 for repository details.\n          smf_info:     See Appendix C.6.4.1\
    \ for usage details.  See\n                        Section 11.1.1 for repository\
    \ details.\n   Encoding considerations:\n       The format for this type is framed\
    \ and binary.\n   Restrictions on usage:\n       This type is only defined for\
    \ real-time transfers of MIDI\n       streams via RTP.  Stored-file semantics\
    \ for rtp-midi may\n       be defined in the future.\n   Security considerations:\n\
    \       See Section 9 of this memo.\n   Interoperability considerations:\n   \
    \    None.\n   Published specification:\n       This memo and [MIDI] serve as\
    \ the normative specification.  In\n       addition, references [NMP], [GRAME],\
    \ and [RFC4696] provide\n       non-normative implementation guidance.\n   Applications\
    \ that use this media type:\n       Audio content-creation hardware, such as MIDI\
    \ controller piano\n       keyboards and MIDI audio synthesizers.  Audio content-creation\n\
    \       software, such as music sequencers, digital audio workstations,\n    \
    \   and soft synthesizers.  Computer operating systems, for network\n       support\
    \ of MIDI Application Programmer Interfaces.  Content\n       distribution servers\
    \ and terminals may use this media type for\n       low bit-rate music coding.\n\
    \   Additional information:\n       None.\n   Person & email address to contact\
    \ for further information:\n       John Lazzaro <lazzaro@cs.berkeley.edu>\n  \
    \ Intended usage:\n       COMMON.\n   Author:\n       John Lazzaro <lazzaro@cs.berkeley.edu>\n\
    \   Change controller:\n       IETF Audio/Video Transport Working Group delegated\n\
    \       from the IESG.\n"
- title: 11.1.1.  Repository Request for "audio/rtp-midi"
  contents:
  - "11.1.1.  Repository Request for \"audio/rtp-midi\"\n   For the \"rtp-midi\" subtype,\
    \ we request the creation of repositories\n   for extensions to the following\
    \ parameters (which are those listed as\n   \"extensible parameters\" in Section\
    \ 11.1).\n      j_sec:\n         Registrations for this repository may only occur\n\
    \         via an IETF standards-track document.  Appendix C.2.1\n         of this\
    \ memo describes appropriate registrations for this\n         repository.\n  \
    \       Initial values for this repository appear below:\n         \"none\": \
    \ Defined in Appendix C.2.1 of this memo.\n         \"recj\":  Defined in Appendix\
    \ C.2.1 of this memo.\n      j_update:\n         Registrations for this repository\
    \ may only occur\n         via an IETF standards-track document.  Appendix C.2.2\n\
    \         of this memo describes appropriate registrations for this\n        \
    \ repository.\n         Initial values for this repository appear below:\n   \
    \      \"anchor\":  Defined in Appendix C.2.2 of this memo.\n         \"open-loop\"\
    :  Defined in Appendix C.2.2 of this memo.\n         \"closed-loop\":  Defined\
    \ in Appendix C.2.2 of this memo.\n      render:\n         Registrations for this\
    \ repository MUST include a\n         specification of the usage of the proposed\
    \ value.\n         See text in the preamble of Appendix C.6 for details\n    \
    \     (the paragraph that begins \"Other render token ...\").\n         Initial\
    \ values for this repository appear below:\n         \"unknown\":  Defined in\
    \ Appendix C.6 of this memo.\n         \"synthetic\":  Defined in Appendix C.6\
    \ of this memo.\n         \"api\":  Defined in Appendix C.6 of this memo.\n  \
    \       \"null\":  Defined in Appendix C.6 of this memo.\n      subrender:\n \
    \        Registrations for this repository MUST include a\n         specification\
    \ of the usage of the proposed value.\n         See text Appendix C.6.2 for details\
    \ (the paragraph\n         that begins \"Other subrender token ...\").\n     \
    \    Initial values for this repository appear below:\n         \"default\": \
    \ Defined in Appendix C.6.2 of this memo.\n      smf_info:\n         Registrations\
    \ for this repository MUST include a\n         specification of the usage of the\
    \ proposed value.\n         See text in Appendix C.6.4.1 for details (the\n  \
    \       paragraph that begins \"Other smf_info token ...\").\n         Initial\
    \ values for this repository appear below:\n         \"ignore\":  Defined in Appendix\
    \ C.6.4.1 of this memo.\n         \"sdp_start\":  Defined in Appendix C.6.4.1\
    \ of this memo.\n         \"identity\":  Defined in Appendix C.6.4.1 of this memo.\n"
- title: 11.2.  mpeg4-generic Media Type Registration
  contents:
  - "11.2.  mpeg4-generic Media Type Registration\n   This section requests the registration\
    \ of the \"rtp-midi\" value for\n   the \"mode\" parameter of the \"mpeg4-generic\"\
    \ media type.  The \"mpeg4-\n   generic\" media type is defined in [RFC3640],\
    \ and [RFC3640] defines a\n   repository for the \"mode\" parameter.  We are registering\
    \ mode rtp-\n   midi to support the MPEG Audio codecs [MPEGSA] that use MIDI.\n\
    \   In conjunction with this registration request, we request the\n   registration\
    \ of the parameters listed in the \"optional parameters\"\n   section below (both\
    \ the \"non-extensible parameters\" and the\n   \"extensible parameters\" lists).\
    \  We also request the creation of\n   repositories for the \"extensible parameters\"\
    ; the details of this\n   request appear in Appendix 11.2.1, below.\n   Media\
    \ type name:\n       audio\n   Subtype name:\n       mpeg4-generic\n   Required\
    \ parameters:\n       The \"mode\" parameter is required by [RFC3640].  [RFC3640]\n\
    \       requests a repository for \"mode\", so that new values for mode\n    \
    \   may be added.  We request that the value \"rtp-midi\" be\n       added to\
    \ the \"mode\" repository.\n       In mode rtp-midi, the mpeg4-generic parameter\
    \ rate is\n       a required parameter.  Rate specifies the RTP timestamp\n  \
    \     clock rate.  See Sections 2.1 and 6.2 for usage details\n       of rate\
    \ in mode rtp-midi.\n   Optional parameters:\n       We request registration of\
    \ the following parameters\n       for use in mode rtp-midi for mpeg4-generic.\n\
    \       Non-extensible parameters:\n          ch_anchor:    See Appendix C.2.3\
    \ for usage details.\n          ch_default:   See Appendix C.2.3 for usage details.\n\
    \          ch_never:     See Appendix C.2.3 for usage details.\n          cm_unused:\
    \    See Appendix C.1 for usage details.\n          cm_used:      See Appendix\
    \ C.1 for usage details.\n          chanmask:     See Appendix C.6.4.3 for usage\
    \ details.\n          cid:          See Appendix C.6.3 for usage details.\n  \
    \        guardtime:    See Appendix C.4.2 for usage details.\n          inline:\
    \       See Appendix C.6.3 for usage details.\n          linerate:     See Appendix\
    \ C.3 for usage details.\n          mperiod:      See Appendix C.3 for usage details.\n\
    \          multimode:    See Appendix C.6.1 for usage details.\n          musicport:\
    \    See Appendix C.5 for usage details.\n          octpos:       See Appendix\
    \ C.3 for usage details.\n          rinit:        See Appendix C.6.3 for usage\
    \ details.\n          rtp_maxptime: See Appendix C.4.1 for usage details.\n  \
    \        rtp_ptime:    See Appendix C.4.1 for usage details.\n          smf_cid:\
    \      See Appendix C.6.4.2 for usage details.\n          smf_inline:   See Appendix\
    \ C.6.4.2 for usage details.\n          smf_url:      See Appendix C.6.4.2 for\
    \ usage details.\n          tsmode:       See Appendix C.3 for usage details.\n\
    \          url:          See Appendix C.6.3 for usage details.\n       Extensible\
    \ parameters:\n          j_sec:        See Appendix C.2.1 for usage details. \
    \ See\n                        Section 11.2.1 for repository details.\n      \
    \    j_update:     See Appendix C.2.2 for usage details.  See\n              \
    \          Section 11.2.1 for repository details.\n          render:       See\
    \ Appendix C.6 for usage details.  See\n                        Section 11.2.1\
    \ for repository details.\n          subrender:    See Appendix C.6.2 for usage\
    \ details.  See\n                        Section 11.2.1 for repository details.\n\
    \          smf_info:     See Appendix C.6.4.1 for usage details.  See\n      \
    \                  Section 11.2.1 for repository details.\n   Encoding considerations:\n\
    \       The format for this type is framed and binary.\n   Restrictions on usage:\n\
    \       Only defined for real-time transfers of audio/mpeg4-generic\n       RTP\
    \ streams with mode=rtp-midi.\n   Security considerations:\n       See Section\
    \ 9 of this memo.\n   Interoperability considerations:\n       Except for the\
    \ marker bit (Section 2.1), the packet formats\n       for audio/rtp-midi and\
    \ audio/mpeg4-generic (mode rtp-midi)\n       are identical.  The formats differ\
    \ in use: audio/mpeg4-generic\n       is for MPEG work, and audio/rtp-midi is\
    \ for all other work.\n   Published specification:\n       This memo, [MIDI],\
    \ and [MPEGSA] are the normative references.\n       In addition, references [NMP],\
    \ [GRAME], and [RFC4696] provide\n       non-normative implementation guidance.\n\
    \   Applications that use this media type:\n       MPEG 4 servers and terminals\
    \ that support [MPEGSA].\n   Additional information:\n       None.\n   Person\
    \ & email address to contact for further information:\n       John Lazzaro <lazzaro@cs.berkeley.edu>\n\
    \   Intended usage:\n       COMMON.\n   Author:\n       John Lazzaro <lazzaro@cs.berkeley.edu>\n\
    \   Change controller:\n       IETF Audio/Video Transport Working Group delegated\n\
    \       from the IESG.\n"
- title: 11.2.1.  Repository Request for Mode rtp-midi for mpeg4-generic
  contents:
  - "11.2.1.  Repository Request for Mode rtp-midi for mpeg4-generic\n   For mode\
    \ rtp-midi of the mpeg4-generic subtype, we request the\n   creation of repositories\
    \ for extensions to the following parameters\n   (which are those listed as \"\
    extensible parameters\" in Section 11.2).\n      j_sec:\n         Registrations\
    \ for this repository may only occur\n         via an IETF standards-track document.\
    \  Appendix C.2.1\n         of this memo describes appropriate registrations for\
    \ this\n         repository.\n         Initial values for this repository appear\
    \ below:\n         \"none\":  Defined in Appendix C.2.1 of this memo.\n      \
    \   \"recj\":  Defined in Appendix C.2.1 of this memo.\n      j_update:\n    \
    \     Registrations for this repository may only occur\n         via an IETF standards-track\
    \ document.  Appendix C.2.2\n         of this memo describes appropriate registrations\
    \ for this\n         repository.\n         Initial values for this repository\
    \ appear below:\n         \"anchor\":  Defined in Appendix C.2.2 of this memo.\n\
    \         \"open-loop\":  Defined in Appendix C.2.2 of this memo.\n         \"\
    closed-loop\":  Defined in Appendix C.2.2 of this memo.\n      render:\n     \
    \    Registrations for this repository MUST include a\n         specification\
    \ of the usage of the proposed value.\n         See text in the preamble of Appendix\
    \ C.6 for details\n         (the paragraph that begins \"Other render token ...\"\
    ).\n         Initial values for this repository appear below:\n         \"unknown\"\
    :  Defined in Appendix C.6 of this memo.\n         \"synthetic\":  Defined in\
    \ Appendix C.6 of this memo.\n         \"null\":  Defined in Appendix C.6 of this\
    \ memo.\n      subrender:\n         Registrations for this repository MUST include\
    \ a\n         specification of the usage of the proposed value.\n         See\
    \ text Appendix C.6.2 for details (the paragraph\n         that begins \"Other\
    \ subrender token ...\" and\n         subsequent paragraphs).  Note that the text\
    \ in\n         Appendix C.6.2 contains restrictions on subrender\n         registrations\
    \ for mpeg4-generic (\"Registrations\n         for mpeg4-generic subrender values\
    \ ...\").\n         Initial values for this repository appear below:\n       \
    \  \"default\":  Defined in Appendix C.6.2 of this memo.\n      smf_info:\n  \
    \       Registrations for this repository MUST include a\n         specification\
    \ of the usage of the proposed value.\n         See text in Appendix C.6.4.1 for\
    \ details (the\n         paragraph that begins \"Other smf_info token ...\").\n\
    \         Initial values for this repository appear below:\n         \"ignore\"\
    :  Defined in Appendix C.6.4.1 of this memo.\n         \"sdp_start\":  Defined\
    \ in Appendix C.6.4.1 of this memo.\n         \"identity\":  Defined in Appendix\
    \ C.6.4.1 of this memo.\n"
- title: 11.3.  asc Media Type Registration
  contents:
  - "11.3.  asc Media Type Registration\n   This section registers \"asc\" as a subtype\
    \ for the \"audio\" media type.\n   We register this subtype to support the remote\
    \ transfer of the\n   \"config\" parameter of the mpeg4-generic media type [RFC3640]\
    \ when it\n   is used with mpeg4-generic mode rtp-midi (registered in Appendix\
    \ 11.2\n   above).  We explain the mechanics of using \"audio/asc\" to set the\n\
    \   config parameter in Section 6.2 and Appendix C.6.5 of this document.\n   Note\
    \ that this registration is a new subtype registration and is not\n   an addition\
    \ to a repository defined by MPEG-related memos (such as\n   [RFC3640]).  Also\
    \ note that this request for \"audio/asc\" does not\n   register parameters, and\
    \ does not request the creation of a\n   repository.\n   Media type name:\n  \
    \     audio\n   Subtype name:\n       asc\n   Required parameters:\n       None.\n\
    \   Optional parameters:\n       None.\n   Encoding considerations:\n       The\
    \ native form of the data object is binary data,\n       zero-padded to an octet\
    \ boundary.\n   Restrictions on usage:\n       This type is only defined for data\
    \ object (stored file)\n       transfer.  The most common transports for the type\
    \ are\n       HTTP and SMTP.\n   Security considerations:\n       See Section\
    \ 9 of this memo.\n   Interoperability considerations:\n       None.\n   Published\
    \ specification:\n       The audio/asc data object is the AudioSpecificConfig\n\
    \       binary data structure, which is normatively defined in\n       [MPEGAUDIO].\n\
    \   Applications that use this media type:\n       MPEG 4 Audio servers and terminals\
    \ that support\n       audio/mpeg4-generic RTP streams for mode rtp-midi.\n  \
    \ Additional information:\n       None.\n   Person & email address to contact\
    \ for further information:\n       John Lazzaro <lazzaro@cs.berkeley.edu>\n  \
    \ Intended usage:\n       COMMON.\n   Author:\n       John Lazzaro <lazzaro@cs.berkeley.edu>\n\
    \   Change controller:\n       IETF Audio/Video Transport Working Group delegated\n\
    \       from the IESG.\n"
- title: A.  The Recovery Journal Channel Chapters
  contents:
  - 'A.  The Recovery Journal Channel Chapters

    '
- title: A.1.  Recovery Journal Definitions
  contents:
  - "A.1.  Recovery Journal Definitions\n   This appendix defines the terminology\
    \ and the coding idioms that are\n   used in the recovery journal bitfield descriptions\
    \ in Section 5\n   (journal header structure), Appendices A.2 to A.9 (channel\
    \ journal\n   chapters) and Appendices B.1 to B.5 (system journal chapters).\n\
    \   We assume that the recovery journal resides in the journal section of\n  \
    \ an RTP packet with sequence number I (\"packet I\") and that the\n   Checkpoint\
    \ Packet Seqnum field in the top-level recovery journal\n   header refers to a\
    \ previous packet with sequence number C (an\n   exception is the self-referential\
    \ C = I case).  Unless stated\n   otherwise, algorithms are assumed to use modulo\
    \ 2^16 arithmetic for\n   calculations on 16-bit sequence numbers and modulo 2^32\
    \ arithmetic\n   for calculations on 32-bit extended sequence numbers.\n   Several\
    \ bitfield coding idioms appear throughout the recovery journal\n   system, with\
    \ consistent semantics.  Most recovery journal elements\n   begin with an \"S\"\
    \ (Single-packet loss) bit.  S bits are designed to\n   help receivers efficiently\
    \ parse through the recovery journal\n   hierarchy in the common case of the loss\
    \ of a single packet.\n   As a rule, S bits MUST be set to 1.  However, an exception\
    \ applies if\n   a recovery journal element in packet I encodes data about a command\n\
    \   stored in the MIDI command section of packet I - 1.  In this case,\n   the\
    \ S bit of the recovery journal element MUST be set to 0.  If a\n   recovery journal\
    \ element has its S bit set to 0, all higher-level\n   recovery journal elements\
    \ that contain it MUST also have S bits that\n   are set to 0, including the top-level\
    \ recovery journal header.\n   Other consistent bitfield coding idioms are described\
    \ below:\n     o R flag bit.  R flag bits are reserved for future use.  Senders\n\
    \       MUST set R bits to 0.  Receivers MUST ignore R bit values.\n     o LENGTH\
    \ field.  All fields named LENGTH (as distinct from LEN)\n       code the number\
    \ of octets in the structure that contains it,\n       including the header it\
    \ resides in and all hierarchical levels\n       below it.  If a structure contains\
    \ a LENGTH field, a receiver\n       MUST use the LENGTH field value to advance\
    \ past the structure\n       during parsing, rather than use knowledge about the\
    \ internal\n       format of the structure.\n   We now define normative terms\
    \ used to describe recovery journal\n   semantics.\n     o Checkpoint history.\
    \  The checkpoint history of a recovery journal\n       is the concatenation of\
    \ the MIDI command sections of packets C\n       through I - 1.  The final command\
    \ in the MIDI command section for\n       packet I - 1 is considered the most\
    \ recent command; the first\n       command in the MIDI command section for packet\
    \ C is the oldest\n       command.  If command X is less recent than command Y,\
    \ X is\n       considered to be \"before Y\".  A checkpoint history with no\n\
    \       commands is considered to be empty.  The checkpoint history never\n  \
    \     contains the MIDI command section of packet I (the packet\n       containing\
    \ the recovery journal), so if C == I, the checkpoint\n       history is empty\
    \ by definition.\n     o Session history.  The session history of a recovery journal\
    \ is\n       the concatenation of MIDI command sections from the first packet\n\
    \       of the session up to packet I - 1.  The definitions of command\n     \
    \  recency and history emptiness follow those in the checkpoint\n       history.\
    \  The session history never contains the MIDI command\n       section of packet\
    \ I, and so the session history of the first\n       packet in the session is\
    \ empty by definition.\n     o Finished/unfinished commands.  If all octets of\
    \ a MIDI command\n       appear in the session history, the command is defined\
    \ as being\n       finished.  If some but not all octets of a command appear in\
    \ the\n       session history, the command is defined as being unfinished.\n \
    \      Unfinished commands occur if segments of a SysEx command appear\n     \
    \  in several RTP packets.  For example, if a SysEx command is coded\n       as\
    \ 3 segments, with segment 1 in packet K, segment 2 in packet K\n       + 1, and\
    \ segment 3 in packet K + 2, the session histories for\n       packets K + 1 and\
    \ K + 2 contain unfinished versions of the\n       command.  A session history\
    \ contains a finished version of a\n       cancelled SysEx command if the history\
    \ contains the cancel\n       sublist for the command.\n     o Reset State commands.\
    \  Reset State (RS) commands reset renderers\n       to an initialized \"powerup\"\
    \ condition.  The RS commands are:\n       System Reset (0xFF), General MIDI System\
    \ Enable (0xF0 0x7E 0xcc\n       0x09 0x01 0xF7), General MIDI 2 System Enable\
    \ (0xF0 0x7E 0xcc\n       0x09 0x03 0xF7), General MIDI System Disable (0xF0 0x7E\
    \ 0xcc 0x09\n       0x00 0xF7), Turn DLS On (0xF0 0x7E 0xcc 0x0A 0x01 0xF7), and\
    \ Turn\n       DLS Off (0xF0 0x7E 0xcc 0x0A 0x02 0xF7).  Registrations of\n  \
    \     subrender parameter token values (Appendix C.6.2) and IETF\n       standards-track\
    \ documents MAY specify additional RS commands.\n     o Active commands.  Active\
    \ command are MIDI commands that do not\n       appear before a Reset State command\
    \ in the session history.\n     o N-active commands.  N-active commands are MIDI\
    \ commands that do\n       not appear before one of the following commands in\
    \ the session\n       history:  MIDI Control Change numbers 123-127 (numbers with\
    \ All\n       Notes Off semantics) or 120 (All Sound Off), and any Reset State\n\
    \       command.\n     o C-active commands.  C-active commands are MIDI commands\
    \ that do\n       not appear before one of the following commands in the session\n\
    \       history:  MIDI Control Change number 121 (Reset All Controllers)\n   \
    \    and any Reset State command.\n     o Oldest-first ordering rule.  Several\
    \ recovery journal chapters\n       contain a list of elements, where each element\
    \ is associated with\n       a MIDI command that appears in the session history.\
    \  In most\n       cases, the chapter definition requires that list elements be\n\
    \       ordered in accordance with the \"oldest-first ordering rule\".\n     \
    \  Below, we normatively define this rule:\n       Elements associated with the\
    \ most recent command in the session\n       history coded in the list MUST appear\
    \ at the end of the list.\n       Elements associated with the oldest command\
    \ in the session\n       history coded in the list MUST appear at the start of\
    \ the list.\n       All other list elements MUST be arranged with respect to these\n\
    \       boundary elements, to produce a list ordering that strictly\n       reflects\
    \ the relative session history recency of the commands\n       coded by the elements\
    \ in the list.\n     o Parameter system.  A MIDI feature that provides two sets\
    \ of\n       16,384 parameters to expand the 0-127 controller number space.\n\
    \       The Registered Parameter Names (RPN) system and the Non-\n       Registered\
    \ Parameter Names (NRPN) system each provides 16,384\n       parameters.\n   \
    \  o Parameter system transaction.  The value of RPNs and NRPNs are\n       changed\
    \ by a series of Control Change commands that form a\n       parameter system\
    \ transaction.  A canonical transaction begins\n       with two Control Change\
    \ commands to set the parameter number\n       (controller numbers 99 and 98 for\
    \ NRPNs, controller numbers 101\n       and 100 for RPNs).  The transaction continues\
    \ with an arbitrary\n       number of Data Entry (controller numbers 6 and 38),\
    \ Data\n       Increment (controller number 96), and Data Decrement (controller\n\
    \       number 97) Control Change commands to set the parameter value.\n     \
    \  The transaction ends with a second pair of (99, 98) or (101, 100)\n       Control\
    \ Change commands that specify the null parameter (MSB\n       value 0x7F, LSB\
    \ value 0x7F).\n       Several variants of the canonical transaction sequence\
    \ are\n       possible.  Most commonly, the terminal pair of (99, 98) or (101,\n\
    \       100) Control Change commands may specify a parameter other than\n    \
    \   the null parameter.  In this case, the command pair terminates\n       the\
    \ first transaction and starts a second transaction.  The\n       command pair\
    \ is considered to be a part of both transactions.\n       This variant is legal\
    \ and recommended in [MIDI].  We refer to\n       this variant as a \"type 1 variant\"\
    .\n       Less commonly, the MSB (99 or 101) or LSB (98 or 100) command of\n \
    \      a (99, 98) or (101, 100) Control Change pair may be omitted.\n       If\
    \ the MSB command is omitted, the transaction uses the MSB value\n       of the\
    \ most recent C-active Control Change command for controller\n       number 99\
    \ or 101 that appears in the session history.  We refer\n       to this variant\
    \ as a \"type 2 variant\".\n       If the LSB command is omitted, the LSB value\
    \ 0x00 is assumed.  We\n       refer to this variant as a \"type 3 variant\".\
    \  The type 2 and type\n       3 variants are defined as legal, but are not recommended,\
    \ in\n       [MIDI].\n       System real-time commands may appear at any point\
    \ during a\n       transaction (even between octets of individual commands in\
    \ the\n       transaction).  More generally, [MIDI] does not forbid the\n    \
    \   appearance of unrelated MIDI commands during an open transaction.\n      \
    \ As a rule, these commands are considered to be \"outside\" the\n       transaction\
    \ and do not affect the status of the transaction in\n       any way.  Exceptions\
    \ to this rule are commands whose semantics\n       act to terminate transactions:\
    \  Reset State commands, and Control\n       Change (0xB) for controller number\
    \ 121 (Reset All Controllers)\n       [RP015].\n     o Initiated parameter system\
    \ transaction.  A canonical parameter\n       system transaction whose (99, 98)\
    \ or (101, 100) initial Control\n       Change command pair appears in the session\
    \ history is considered\n       to be an initiated parameter system transaction.\
    \  This definition\n       also holds for type 1 variants.  For type 2 variants\
    \ (dropped\n       MSB), a transaction whose initial LSB Control Change command\n\
    \       appears in the session history is an initiated transaction.  For\n   \
    \    type 3 variants (dropped LSB), a transaction is considered to be\n      \
    \ initiated if at least one transaction command follows the initial\n       MSB\
    \ (99 or 101) Control Change command in the session history.\n       The completion\
    \ of a transaction does not nullify its \"initiated\"\n       status.\n     o\
    \ Session history reference counts.  Several recovery journal\n       chapters\
    \ include a reference count field, which codes the total\n       number of commands\
    \ of a type that appear in the session history.\n       Examples include the Reset\
    \ and Tune Request command logs (Chapter\n       D, Appendix B.1) and the Active\
    \ Sense command (Chapter V,\n       Appendix B.2).  Upon the detection of a loss\
    \ event, reference\n       count fields let a receiver deduce if any instances\
    \ of the\n       command have been lost, by comparing the journal reference count\n\
    \       with its own reference count.  Thus, a reference count field\n       makes\
    \ sense, even for command types in which knowing the NUMBER\n       of lost commands\
    \ is irrelevant (as is true with all of the\n       example commands mentioned\
    \ above).\n   The chapter definitions in Appendices A.2 to A.9 and B.1 to B.5\n\
    \   reflect the default recovery journal behavior.  The ch_default,\n   ch_never,\
    \ and ch_anchor parameters modify these definitions, as\n   described in Appendix\
    \ C.2.3.\n   The chapter definitions specify if data MUST be present in the\n\
    \   journal.  Senders MAY also include non-required data in the journal.\n   This\
    \ optional data MUST comply with the normative chapter definition.\n   For example,\
    \ if a chapter definition states that a field codes data\n   from the most recent\
    \ active command in the session history, the\n   sender MUST NOT code inactive\
    \ commands or older commands in the\n   field.\n   Finally, we note that a channel\
    \ journal only encodes information\n   about MIDI commands appearing on the MIDI\
    \ channel the journal\n   protects.  All references to MIDI commands in Appendices\
    \ A.2 to A.9\n   should be read as \"MIDI commands appearing on this channel.\"\
    \n"
- title: 'A.2.  Chapter P: MIDI Program Change'
  contents:
  - "A.2.  Chapter P: MIDI Program Change\n   A channel journal MUST contain Chapter\
    \ P if an active Program Change\n   (0xC) command appears in the checkpoint history.\
    \  Figure A.2.1 shows\n   the format for Chapter P.\n                0       \
    \            1                   2\n                0 1 2 3 4 5 6 7 8 9 0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3\n               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \               |S|   PROGRAM   |B|   BANK-MSB  |X|  BANK-LSB   |\n          \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                    \
    \  Figure A.2.1 -- Chapter P format\n   The chapter has a fixed size of 24 bits.\
    \  The PROGRAM field indicates\n   the data value of the most recent active Program\
    \ Change command in\n   the session history.  By default, the B, BANK-MSB, X,\
    \ and BANK-LSB\n   fields MUST be set to 0.  Below, we define exceptions to this\
    \ default\n   condition.\n   If an active Control Change (0xB) command for controller\
    \ number 0\n   (Bank Select MSB) appears before the Program Change command in\
    \ the\n   session history, the B bit MUST be set to 1, and the BANK-MSB field\n\
    \   MUST code the data value of the Control Change command.\n   If B is set to\
    \ 1, the BANK-LSB field MUST code the data value of the\n   most recent Control\
    \ Change command for controller number 32 (Bank\n   Select LSB) that preceded\
    \ the Program Change command coded in the\n   PROGRAM field and followed the Control\
    \ Change command coded in the\n   BANK-MSB field.  If no such Control Change command\
    \ exists, the BANK-\n   LSB field MUST be set to 0.\n   If B is set to 1, and\
    \ if a Control Change command for controller\n   number 121 (Reset All Controllers)\
    \ appears in the MIDI stream between\n   the Control Change command coded by the\
    \ BANK-MSB field and the\n   Program Change command coded by the PROGRAM field,\
    \ the X bit MUST be\n   set to 1.\n   Note that [RP015] specifies that Reset All\
    \ Controllers does not reset\n   the values of controller numbers 0 (Bank Select\
    \ MSB) and 32 (Bank\n   Select LSB).  Thus, the X bit does not effect how receivers\
    \ will use\n   the BANK-LSB and BANK-MSB values when recovering from a lost Program\n\
    \   Change command.  The X bit serves to aid recovery in MIDI\n   applications\
    \ where controller numbers 0 and 32 are used in a non-\n   standard way.\n"
- title: 'A.3.  Chapter C: MIDI Control Change'
  contents:
  - "A.3.  Chapter C: MIDI Control Change\n   Figure A.3.1 shows the format for Chapter\
    \ C.\n       0                   1                   2                   3\n \
    \      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 8 0 1\n     \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |S|\
    \     LEN     |S|   NUMBER    |A|  VALUE/ALT  |S|   NUMBER    |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |A|  VALUE/ALT  |  ....                                         |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \                 Figure A.3.1 -- Chapter C format\n   The chapter consists of\
    \ a 1-octet header, followed by a variable\n   length list of 2-octet controller\
    \ logs.  The list MUST contain at\n   least one controller log.  The 7-bit LEN\
    \ field codes the number of\n   controller logs in the list, minus one.  We define\
    \ the semantics of\n   the controller log fields in Appendix A.3.2.\n   A channel\
    \ journal MUST contain Chapter C if the rules defined in this\n   appendix require\
    \ that one or more controller logs appear in the list.\n"
- title: A.3.1.  Log Inclusion Rules
  contents:
  - "A.3.1.  Log Inclusion Rules\n   A controller log encodes information about a\
    \ particular Control\n   Change command in the session history.\n   In the default\
    \ use of the payload format, list logs MUST encode\n   information about the most\
    \ recent active command in the session\n   history for a controller number.  Logs\
    \ encoding earlier commands MUST\n   NOT appear in the list.\n   Also, as a rule,\
    \ the list MUST contain a log for the most recent\n   active command for a controller\
    \ number that appears in the checkpoint\n   history.  Below, we define exceptions\
    \ to this rule:\n     o  MIDI streams may transmit 14-bit controller values using\
    \ paired\n        Most Significant Byte (MSB, controller numbers 0-31, 99, 101)\n\
    \        and Least Significant Byte (LSB, controller numbers 32-63, 98,\n    \
    \    100) Control Change commands [MIDI].\n        If the most recent active Control\
    \ Change command in the session\n        history for a 14-bit controller pair\
    \ uses the MSB number,\n        Chapter C MAY omit the controller log for the\
    \ most recent active\n        Control Change command for the associated LSB number,\
    \ as the\n        command ordering makes this LSB value irrelevant.  However,\
    \ this\n        exception MUST NOT be applied if the sender is not certain that\n\
    \        the MIDI source uses 14-bit semantics for the controller number\n   \
    \     pair.  Note that some MIDI sources ignore 14-bit controller\n        semantics\
    \ and use the LSB controller numbers as independent 7-\n        bit controllers.\n\
    \     o  If active Control Change commands for controller numbers 0 (Bank\n  \
    \      Select MSB) or 32 (Bank Select LSB) appear in the checkpoint\n        history,\
    \ and if the command instances are also coded in the\n        BANK-MSB and BANK-LSB\
    \ fields of the Chapter P (Appendix A.2),\n        Chapter C MAY omit the controller\
    \ logs for the commands.\n     o  Several controller number pairs are defined\
    \ to be mutually\n        exclusive.  Controller numbers 124 (Omni Off) and 125\
    \ (Omni On)\n        form a mutually exclusive pair, as do controller numbers\
    \ 126\n        (Mono) and 127 (Poly).\n        If active Control Change commands\
    \ for one or both members of a\n        mutually exclusive pair appear in the\
    \ checkpoint history, a log\n        for the controller number of the most recent\
    \ command for the\n        pair in the checkpoint history MUST appear in the controller\n\
    \        list.  However, the list MAY omit the controller log for the\n      \
    \  most recent active command for the other number in the pair.\n        If active\
    \ Control Change commands for one or both members of a\n        mutually exclusive\
    \ pair appear in the session history, and if a\n        log for the controller\
    \ number of the most recent command for the\n        pair does not appear in the\
    \ controller list, a log for the most\n        recent command for the other number\
    \ of the pair MUST NOT appear\n        in the controller list.\n     o  If an\
    \ active Control Change command for controller number 121\n        (Reset All\
    \ Controllers) appears in the session history, the\n        controller list MAY\
    \ omit logs for Control Change commands that\n        precede the Reset All Controllers\
    \ command in the session\n        history, under certain conditions.\n       \
    \ Namely, a log MAY be omitted if the sender is certain that a\n        command\
    \ stream follows the Reset All Controllers semantics\n        defined in [RP015],\
    \ and if the log codes a controller number for\n        which [RP015] specifies\
    \ a reset value.\n        For example, [RP015] specifies that controller number\
    \ 1\n        (Modulation Wheel) is reset to the value 0, and thus a\n        controller\
    \ log for Modulation Wheel MAY be omitted from the\n        controller log list.\
    \  In contrast, [RP015] specifies that\n        controller number 7 (Channel Volume)\
    \ is not reset, and thus a\n        controller log for Channel Volume MUST NOT\
    \ be omitted from the\n        controller log list.\n     o  Appendix A.3.4 defines\
    \ exception rules for the MIDI Parameter\n        System controller numbers 6,\
    \ 38, and 96-101.\n"
- title: A.3.2.  Controller Log Format
  contents:
  - "A.3.2.  Controller Log Format\n   Figure A.3.2 shows the controller log structure\
    \ of Chapter C.\n                       0                   1\n              \
    \         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      |S|    NUMBER   |A|  VALUE/ALT  |\n                   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                  Figure A.3.2 -- Chapter\
    \ C controller log\n   The 7-bit NUMBER field identifies the controller number\
    \ of the coded\n   command.  The 7-bit VALUE/ALT field codes recovery information\
    \ for\n   the command.  The A bit sets the format of the VALUE/ALT field.\n  \
    \ A log encodes recovery information using one of the following tools:\n   the\
    \ value tool, the toggle tool, or the count tool.\n   A log uses the value tool\
    \ if the A bit is set to 0.  The value tool\n   codes the 7-bit data value of\
    \ a command in the VALUE/ALT field.  The\n   value tool works best for controllers\
    \ that code a continuous\n   quantity, such as number 1 (Modulation Wheel).\n\
    \   The A bit is set to 1 to code the toggle or count tool.  These tools\n   work\
    \ best for controllers that code discrete actions.  Figure A.3.3\n   shows the\
    \ controller log for these tools.\n                       0                  \
    \ 1\n                       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                \
    \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                      |S|    NUMBER\
    \   |1|T|    ALT    |\n                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                 Figure A.3.3 -- Controller log for ALT tools\n   A log uses\
    \ the toggle tool if the T bit is set to 0.  A log uses the\n   count tool if\
    \ the T bit is set to 1.  Both methods use the 6-bit ALT\n   field as an unsigned\
    \ integer.\n   The toggle tool works best for controllers that act as on/off\n\
    \   switches, such as 64 (Damper Pedal (Sustain)).  These controllers\n   code\
    \ the \"off\" state with control values 0-63 and the \"on\" state with\n   64-127.\n\
    \   For the toggle tool, the ALT field codes the total number of toggles\n   (off->on\
    \ and on->off) due to Control Change commands in the session\n   history, up to\
    \ and including a toggle caused by the command coded by\n   the log.  The toggle\
    \ count includes toggles caused by Control Change\n   commands for controller\
    \ number 121 (Reset All Controllers).\n   Toggle counting is performed modulo\
    \ 64.  The toggle count is reset at\n   the start of a session, and whenever a\
    \ Reset State command (Appendix\n   A.1) appears in the session history.  When\
    \ these reset events occur,\n   the toggle count for a controller is set to 0\
    \ (for controllers whose\n   default value is 0-63) or 1 (for controllers whose\
    \ default value is\n   64-127).\n   The Damper Pedal (Sustain) controller illustrates\
    \ the benefits of the\n   toggle tool over the value tool for switch controllers.\
    \  As often\n   used in piano applications, the \"on\" state of the controller\
    \ lets\n   notes resonate, while the \"off\" state immediately damps notes to\n\
    \   silence.  The loss of the \"off\" command in an \"on->off->on\" sequence\n\
    \   results in ringing notes that should have been damped silent.  The\n   toggle\
    \ tool lets receivers detect this lost \"off\" command, but the\n   value tool\
    \ does not.\n   The count tool is conceptually similar to the toggle tool.  For\
    \ the\n   count tool, the ALT field codes the total number of Control Change\n\
    \   commands in the session history, up to and including the command\n   coded\
    \ by the log.  Command counting is performed modulo 64.  The\n   command count\
    \ is set to 0 at the start of the session and is reset to\n   0 whenever a Reset\
    \ State command (Appendix A.1) appears in the\n   session history.\n   Because\
    \ the count tool ignores the data value, it is a good match for\n   controllers\
    \ whose controller value is ignored, such as number 123\n   (All Notes Off). \
    \ More generally, the count tool may be used to code\n   a (modulo 64) identification\
    \ number for a command.\n"
- title: A.3.3.  Log List Coding Rules
  contents:
  - "A.3.3.  Log List Coding Rules\n   In this section, we describe the organization\
    \ of controller logs in\n   the Chapter C log list.\n   A log encodes information\
    \ about a particular Control Change command\n   in the session history.  In most\
    \ cases, a command SHOULD be coded by\n   a single tool (and, thus, a single log).\
    \  If a number is coded with a\n   single tool and this tool is the count tool,\
    \ recovery Control Change\n   commands generated by a receiver SHOULD use the\
    \ default control value\n   for the controller.\n   However, a command MAY be\
    \ coded by several tool types (and, thus,\n   several logs, each using a different\
    \ tool).  This technique may\n   improve recovery performance for controllers\
    \ with complex semantics,\n   such as controller number 84 (Portamento Control)\
    \ or controller\n   number 121 (Reset All Controllers) when used with a non-zero\
    \ data\n   octet (with the semantics described in [DLS2]).\n   If a command is\
    \ encoded by multiple tools, the logs MUST be placed in\n   the list in the following\
    \ order: count tool log (if any), followed by\n   value tool log (if any), followed\
    \ by toggle tool log (if any).\n   The Chapter C log list MUST obey the oldest-first\
    \ ordering rule\n   (defined in Appendix A.1).  Note that this ordering preserves\
    \ the\n   information necessary for the recovery of 14-bit controller values,\n\
    \   without precluding the use of MSB and LSB controller pairs as\n   independent\
    \ 7-bit controllers.\n   In the default use of the payload format, all logs that\
    \ appear in the\n   list for a controller number encode information about one\
    \ Control\n   Change command -- namely, the most recent active Control Change\n\
    \   command in the session history for the number.\n   This coding scheme provides\
    \ good recovery performance for the\n   standard uses of Control Change commands\
    \ defined in [MIDI].  However,\n   not all MIDI applications restrict the use\
    \ of Control Change commands\n   to those defined in [MIDI].\n   For example,\
    \ consider the common MIDI encoding of rotary encoders\n   (\"infinite\" rotation\
    \ knobs).  The mixing console MIDI convention\n   defined in [LCP] codes the position\
    \ of rotary encoders as a series of\n   Control Change commands.  Each command\
    \ encodes a relative change of\n   knob position from the last update (expressed\
    \ as a clockwise or\n   counter-clockwise knob turning angle).\n   As the knob\
    \ position is encoded incrementally over a series of\n   Control Change commands,\
    \ the best recovery performance is obtained if\n   the log list encodes all Control\
    \ Change commands for encoder\n   controller numbers that appear in the checkpoint\
    \ history, not only\n   the most recent command.\n   To support application areas\
    \ that use Control Change commands in this\n   way, Chapter C may be configured\
    \ to encode information about several\n   Control Change commands for a controller\
    \ number.  We use the term\n   \"enhanced\" to describe this encoding method,\
    \ which we describe below.\n   In Appendix C.2.3, we show how to configure a stream\
    \ to use enhanced\n   Chapter C encoding for specific controller numbers.  In\
    \ Section 5 in\n   the main text, we show how the H bits in the recovery journal\
    \ header\n   (Figure 8) and in the channel journal header (Figure 9) indicate\
    \ the\n   use of enhanced Chapter C encoding.\n   Here, we define how to encode\
    \ a Chapter C log list that uses the\n   enhanced encoding method.\n   Senders\
    \ that use the enhanced encoding method for a controller number\n   MUST obey\
    \ the rules below.  These rules let a receiver determine\n   which logs in the\
    \ list correspond to lost commands.  Note that these\n   rules override the exceptions\
    \ listed in Appendix A.3.1.\n     o  If N commands for a controller number are\
    \ encoded in the list,\n        the commands MUST be the N most recent commands\
    \ for the\n        controller number in the session history.  For example, for\
    \ N =\n        2, the sender MUST encode the most recent command and the second\n\
    \        most recent command, not the most recent command and the third\n    \
    \    most recent command.\n     o  If a controller number uses enhanced encoding,\
    \ the encoding of\n        the least-recent command for the controller number\
    \ in the log\n        list MUST include a count tool log.  In addition, if commands\n\
    \        are encoded for the controller number whose logs have S bits set\n  \
    \      to 0, the encoding of the least-recent command with S = 0 logs\n      \
    \  MUST include a count tool log.\n        The count tool is OPTIONAL for the\
    \ other commands for the\n        controller number encoded in the list, as a\
    \ receiver is able to\n        efficiently deduce the count tool value for these\
    \ commands, for\n        both single-packet and multi-packet loss events.\n  \
    \   o  The use of the value and toggle tools MUST be identical for all\n     \
    \   commands for a controller number encoded in the list.  For\n        example,\
    \ a value tool log either MUST appear for all commands\n        for the controller\
    \ number coded in the list, or alternatively,\n        value tool logs for the\
    \ controller number MUST NOT appear in the\n        list.  Likewise, a toggle\
    \ tool log either MUST appear for all\n        commands for the controller number\
    \ coded in the list, or\n        alternatively, toggle tool logs for the controller\
    \ number MUST\n        NOT appear in the list.\n     o  If a command is encoded\
    \ by multiple tools, the logs MUST be\n        placed in the list in the following\
    \ order: count tool log (if\n        any), followed by value tool log (if any),\
    \ followed by toggle\n        tool log (if any).\n   These rules permit a receiver\
    \ recovering from a packet loss to use\n   the count tool log to match the commands\
    \ encoded in the list with its\n   own history of the stream, as we describe below.\
    \  Note that the text\n   below describes a non-normative algorithm; receivers\
    \ are free to use\n   any algorithm to match its history with the log list.\n\
    \   In a typical implementation of the enhanced encoding method, a\n   receiver\
    \ computes and stores count, value, and toggle tool data field\n   values for\
    \ the most recent Control Change command it has received for\n   a controller\
    \ number.\n   After a loss event, a receiver parses the Chapter C list and\n \
    \  processes list logs for a controller number that uses enhanced\n   encoding\
    \ as follows.\n   The receiver compares the count tool ALT field for the least-recent\n\
    \   command for the controller number in the list against its stored\n   count\
    \ data for the controller number, to determine if recovery is\n   necessary for\
    \ the command coded in the list.  The value and toggle\n   tool logs (if any)\
    \ that directly follow the count tool log are\n   associated with this least-recent\
    \ command.\n   To check more-recent commands for the controller, the receiver\n\
    \   detects additional value and/or toggle tool logs for the controller\n   number\
    \ in the list and infers count tool data for the command coded\n   by these logs.\
    \  This inferred data is used to determine if recovery\n   is necessary for the\
    \ command coded by the value and/or toggle tool\n   logs.\n   In this way, a receiver\
    \ is able to execute only lost commands,\n   without executing a command twice.\
    \  While recovering from a single\n   packet loss, a receiver may skip through\
    \ S = 1 logs in the list, as\n   the first S = 0 log for an enhanced controller\
    \ number is always a\n   count tool log.\n   Note that the requirements in Appendix\
    \ C.2.2.2 for protective sender\n   and receiver actions during session startup\
    \ for multicast operation\n   are of particular importance for enhanced encoding,\
    \ as receivers need\n   to initialize its count tool data structures with recovery\
    \ journal\n   data in order to match commands correctly after a loss event.\n\
    \   Finally, we note in passing that in some applications of rotary\n   encoders,\
    \ a good user experience may be possible without the use of\n   enhanced encoding.\
    \  These applications are distinguished by visual\n   feedback of encoding position\
    \ that is driven by the post-recovery\n   rotary encoding stream, and relatively\
    \ low packet loss.  In these\n   domains, recovery performance may be acceptable\
    \ for rotary encoders\n   if the log list encodes only the most recent command,\
    \ if both count\n   and value logs appear for the command.\n"
- title: A.3.4.  The Parameter System
  contents:
  - "A.3.4.  The Parameter System\n   Readers may wish to review the Appendix A.1\
    \ definitions of \"parameter\n   system\", \"parameter system transaction\", and\
    \ \"initiated parameter\n   system transaction\" before reading this section.\n\
    \   Parameter system transactions update a MIDI Registered Parameter\n   Number\
    \ (RPN) or Non-Registered Parameter Number (NRPN) value.  A\n   parameter system\
    \ transaction is a sequence of Control Change commands\n   that may use the following\
    \ controllers numbers:\n     o  Data Entry MSB (6)\n     o  Data Entry LSB (38)\n\
    \     o  Data Increment (96)\n     o  Data Decrement (97)\n     o  Non-Registered\
    \ Parameter Number (NRPN) LSB (98)\n     o  Non-Registered Parameter Number (NRPN)\
    \ MSB (99)\n     o  Registered Parameter Number (RPN) LSB (100)\n     o  Registered\
    \ Parameter Number (RPN) MSB (101)\n   Control Change commands that are a part\
    \ of a parameter system\n   transaction MUST NOT be coded in Chapter C controller\
    \ logs.  Instead,\n   these commands are coded in Chapter M, the MIDI Parameter\
    \ chapter\n   defined in Appendix A.4.\n   However, Control Change commands that\
    \ use the listed controllers as\n   general-purpose controllers (i.e., outside\
    \ of a parameter system\n   transaction) MUST NOT be coded in Chapter M.\n   Instead,\
    \ the controllers are coded in Chapter C controller logs.  The\n   controller\
    \ logs follow the coding rules stated in Appendix A.3.2 and\n   A.3.3.  The rules\
    \ for coding paired LSB and MSB controllers, as\n   defined in Appendix A.3.1,\
    \ apply to the pairs (6, 38), (99, 98), and\n   (101, 100) when coded in Chapter\
    \ C.\n   If active Control Change commands for controller numbers 6, 38, or\n\
    \   96-101 appear in the checkpoint history, and these commands are used\n   as\
    \ general-purpose controllers, the most recent general-purpose\n   command instance\
    \ for these controller numbers MUST appear as entries\n   in the Chapter C controller\
    \ list.\n   MIDI syntax permits a source to use controllers 6, 38, 96, and 97\
    \ as\n   parameter-system controllers and general-purpose controllers in the\n\
    \   same stream.  An RTP MIDI sender MUST deduce the role of each Control\n  \
    \ Change command for these controller numbers by noting the placement\n   of the\
    \ command in the stream and MUST use this information to code\n   the command\
    \ in Chapter C or Chapter M, as appropriate.\n   Specifically, active Control\
    \ Change commands for controllers 6, 38,\n   96, and 97 act in a general-purpose\
    \ way when\n     o  no active Control Change commands that set an RPN or NRPN\n\
    \        parameter number appear in the session history, or\n     o  the most\
    \ recent active Control Change commands in the session\n        history that set\
    \ an RPN or NRPN parameter number code the null\n        parameter (MSB value\
    \ 0x7F, LSB value 0x7F), or\n     o  a Control Change command for controller number\
    \ 121 (Reset All\n        Controllers) appears more recently in the session history\
    \ than\n        all active Control Change commands that set an RPN or NRPN\n \
    \       parameter number (see [RP015] for details).\n   Finally, we note that\
    \ a MIDI source that follows the recommendations\n   of [MIDI] exclusively uses\
    \ numbers 98-101 as parameter system\n   controllers.  Alternatively, a MIDI source\
    \ may exclusively use 98-101\n   as general-purpose controllers and lose the ability\
    \ perform parameter\n   system transactions in a stream.\n   In the language of\
    \ [MIDI], the general-purpose use of controllers\n   98-101 constitutes a non-standard\
    \ controller assignment.  As most\n   real-world MIDI sources use the standard\
    \ controller assignment for\n   controller numbers 98-101, an RTP MIDI sender\
    \ SHOULD assume these\n   controllers act as parameter system controllers, unless\
    \ it knows that\n   a MIDI source uses controller numbers 98-101 in a general-purpose\n\
    \   way.\n"
- title: 'A.4.  Chapter M: MIDI Parameter System'
  contents:
  - "A.4.  Chapter M: MIDI Parameter System\n   Readers may wish to review the Appendix\
    \ A.1 definitions for\n   \"C-active\", \"parameter system\", \"parameter system\
    \ transaction\", and\n   \"initiated parameter system transaction\" before reading\
    \ this\n   appendix.\n   Chapter M protects parameter system transactions for\
    \ Registered\n   Parameter Number (RPN) and Non-Registered Parameter Number (NRPN)\n\
    \   values.  Figure A.4.1 shows the format for Chapter M.\n       0          \
    \         1                   2                   3\n       0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |S|P|E|U|W|Z|      LENGTH       |Q|  PENDING    |  Log list ... |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \            Figure A.4.1 -- Top-level Chapter M format\n   Chapter M begins with\
    \ a 2-octet header.  If the P header bit is set\n   to 1, a 1-octet field follows\
    \ the header, coding the 7-bit PENDING\n   value and its associated Q bit.\n \
    \  The 10-bit LENGTH field codes the size of Chapter M and conforms to\n   semantics\
    \ described in Appendix A.1.\n   Chapter M ends with a list of zero or more variable-length\
    \ parameter\n   logs.  Appendix A.4.2 defines the bitfield format of a parameter\
    \ log.\n   Appendix A.4.1 defines the inclusion semantics of the log list.\n \
    \  A channel journal MUST contain Chapter M if the rules defined in\n   Appendix\
    \ A.4.1 require that one or more parameter logs appear in the\n   list.\n   A\
    \ channel journal also MUST contain Chapter M if the most recent\n   C-active\
    \ Control Change command involved in a parameter system\n   transaction in the\
    \ checkpoint history is\n     o  an RPN MSB (101) or NRPN MSB (99) controller,\
    \ or\n     o  an RPN LSB (100) or NRPN LSB (98) controller that completes the\n\
    \        coding of the null parameter (MSB value 0x7F, LSB value 0x7F).\n   This\
    \ rule provides loss protection for partially transmitted\n   parameter numbers\
    \ and for the null parameter numbers.\n   If the most recent C-active Control\
    \ Change command involved in a\n   parameter system transaction in the session\
    \ history is for the RPN\n   MSB or NRPN MSB controller, the P header bit MUST\
    \ be set to 1, and\n   the PENDING field (and its associated Q bit) MUST follow\
    \ the Chapter\n   M header.  Otherwise, the P header bit MUST be set to 0, and\
    \ the\n   PENDING field and Q bit MUST NOT appear in Chapter M.\n   If PENDING\
    \ codes an NRPN MSB, the Q bit MUST be set to 1.  If PENDING\n   codes an RPN\
    \ MSB, the Q bit MUST be set to 0.\n   The E header bit codes the current transaction\
    \ state of the MIDI\n   stream.  If E = 1, an initiated transaction is in progress.\
    \  Below,\n   we define the rules for setting the E header bit:\n     o  If no\
    \ C-active parameter system transaction Control Change\n        commands appear\
    \ in the session history, the E bit MUST be set to\n        0.\n     o  If the\
    \ P header bit is set to 1, the E bit MUST be set to 0.\n     o  If the most recent\
    \ C-active parameter system transaction Control\n        Change command in the\
    \ session history is for the NRPN LSB or RPN\n        LSB controller number, and\
    \ if this command acts to complete the\n        coding of the null parameter (MSB\
    \ value 0x7F, LSB value 0x7F),\n        the E bit MUST be set to 0.\n     o  Otherwise,\
    \ an initiated transaction is in progress, and the E\n        bit MUST be set\
    \ to 1.\n   The U, W, and Z header bits code properties that are shared by all\n\
    \   parameter logs in the list.  If these properties are set, parameter\n   logs\
    \ may be coded with improved efficiency (we explain how in A.4.1).\n   By default,\
    \ the U, W, and Z bits MUST be set to 0.  If all parameter\n   logs in the list\
    \ code RPN parameters, the U bit MAY be set to 1.  If\n   all parameter logs in\
    \ the list code NRPN parameters, the W bit MAY be\n   set to 1.  If the parameter\
    \ numbers of all RPN and NRPN logs in the\n   list lie in the range 0-127 (and\
    \ thus have an MSB value of 0), the Z\n   bit MAY be set to 1.\n   Note that C-active\
    \ semantics appear in the preceding paragraphs\n   because [RP015] specifies that\
    \ pending Parameter System transactions\n   are closed by a Control Change command\
    \ for controller number 121\n   (Reset All Controllers).\n"
- title: A.4.1.  Log Inclusion Rules
  contents:
  - "A.4.1.  Log Inclusion Rules\n   Parameter logs code recovery information for\
    \ a specific RPN or NRPN\n   parameter.\n   A parameter log MUST appear in the\
    \ list if an active Control Change\n   command that forms a part of an initiated\
    \ transaction for the\n   parameter appears in the checkpoint history.\n   An\
    \ exception to this rule applies if the checkpoint history only\n   contains transaction\
    \ Control Change commands for controller numbers\n   98-101 that act to terminate\
    \ the transaction.  In this case, a log\n   for the parameter MAY be omitted from\
    \ the list.\n   A log MAY appear in the list if an active Control Change command\
    \ that\n   forms a part of an initiated transaction for the parameter appears\
    \ in\n   the session history.  Otherwise, a log for the parameter MUST NOT\n \
    \  appear in the list.\n   Multiple logs for the same RPN or NRPN parameter MUST\
    \ NOT appear in\n   the log list.\n   The parameter log list MUST obey the oldest-first\
    \ ordering rule\n   (defined in Appendix A.1), with the phrase \"parameter transaction\"\
    \n   replacing the word \"command\" in the rule definition.\n   Parameter logs\
    \ associated with the RPN or NRPN null parameter (LSB =\n   0x7F, MSB = 0x7F)\
    \ MUST NOT appear in the log list.  Chapter M uses\n   the E header bit (Figure\
    \ A.4.1) and the log list ordering rules to\n   code null parameter semantics.\n\
    \   Note that \"active\" semantics (rather than \"C-active\" semantics)\n   appear\
    \ in the preceding paragraphs because [RP015] specifies that\n   pending Parameter\
    \ System transactions are not reset by a Control\n   Change command for controller\
    \ number 121 (Reset All Controllers).\n   However, the rule that follows uses\
    \ C-active semantics, because it\n   concerns the protection of the transaction\
    \ system itself, and [RP015]\n   specifies that Reset All Controllers acts to\
    \ close a transaction in\n   progress.\n   In most cases, parameter logs for RPN\
    \ and NRPN parameters that are\n   assigned to the ch_never parameter (Appendix\
    \ C.2.3) MAY be omitted\n   from the list.  An exception applies if\n     o  the\
    \ log codes the most recent initiated transaction in the\n        session history,\
    \ and\n     o  a C-active command that forms a part of the transaction appears\n\
    \        in the checkpoint history, and\n     o  the E header bit for the top-level\
    \ Chapter M header (Figure\n        A.4.1) is set to 1.\n   In this case, a log\
    \ for the parameter MUST appear in the list.  This\n   log informs receivers recovering\
    \ from a loss that a transaction is in\n   progress, so that the receiver is able\
    \ to correctly interpret RPN or\n   NRPN Control Change commands that follow the\
    \ loss event.\n"
- title: A.4.2.  Log Coding Rules
  contents:
  - "A.4.2.  Log Coding Rules\n   Figure A.4.2 shows the parameter log structure of\
    \ Chapter M.\n       0                   1                   2               \
    \    3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 8 0 1\n\
    \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   \
    \   |S|  PNUM-LSB   |Q|  PNUM-MSB   |J|K|L|M|N|T|V|R|   Fields ...  |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      Figure A.4.2 -- Parameter log format\n   The log begins\
    \ with a header, whose default size (as shown in Figure\n   A.4.2) is 3 octets.\
    \  If the Q header bit is set to 0, the log encodes\n   an RPN parameter.  If\
    \ Q = 1, the log encodes an NRPN parameter.  The\n   7-bit PNUM-MSB and PNUM-LSB\
    \ fields code the parameter number and\n   reflect the Control Change command\
    \ data values for controllers 99 and\n   98 (for NRPNs) or 101 and 100 (for RPNs).\n\
    \   The J, K, L, M, and N header bits form a Table of Contents (TOC) for\n   the\
    \ log and signal the presence of fixed-sized fields that follow the\n   header.\
    \  A header bit that is set to 1 codes the presence of a field\n   in the log.\
    \  The ordering of fields in the log follows the ordering\n   of the header bits\
    \ in the TOC.  Appendices A.4.2.1-2 define the\n   fields associated with each\
    \ TOC header bit.\n   The T and V header bits code information about the parameter\
    \ log but\n   are not part of the TOC.  A set T or V bit does not signal the\n\
    \   presence of any parameter log field.\n   If the rules in Appendix A.4.1 state\
    \ that a log for a given parameter\n   MUST appear in Chapter M, the log MUST\
    \ code sufficient information to\n   protect the parameter from the loss of active\
    \ parameter transaction\n   Control Change commands in the checkpoint history.\n\
    \   This rule does not apply if the parameter coded by the log is\n   assigned\
    \ to the ch_never parameter (Appendix C.2.3).  In this case,\n   senders MAY choose\
    \ to set the J, K, L, M, and N TOC bits to 0, coding\n   a parameter log with\
    \ no fields.\n   Note that logs to protect parameters that are assigned to ch_never\n\
    \   are REQUIRED under certain conditions (see Appendix A.4.1).  The\n   purpose\
    \ of the log is to inform receivers recovering from a loss that\n   a transaction\
    \ is in progress, so that the receiver is able to\n   correctly interpret RPN\
    \ or NRPN Control Change commands that follow\n   the loss event.\n   Parameter\
    \ logs provide two tools for parameter protection: the value\n   tool and the\
    \ count tool.  Depending on the semantics of the\n   parameter, senders may use\
    \ either tool, both tools, or neither tool\n   to protect a given parameter.\n\
    \   The value tool codes information a receiver may use to determine the\n   current\
    \ value of an RPN or NRPN parameter.  If a parameter log uses\n   the value tool,\
    \ the V header bit MUST be set to 1, and the semantics\n   defined in Appendices\
    \ A.4.2.1 for setting the J, K, L, and M TOC bits\n   MUST be followed.  If a\
    \ parameter log does not use the value tool,\n   the V bit MUST be set to 0, and\
    \ the J, K, L, and M TOC bits MUST also\n   be set to 0.\n   The count tool codes\
    \ the number of transactions for an RPN or NRPN\n   parameter.  If a parameter\
    \ log uses the count tool, the T header bit\n   MUST be set to 1, and the semantics\
    \ defined in Appendices A.4.2.2 for\n   setting the N TOC bit MUST be followed.\
    \  If a parameter log does not\n   use the count tool, the T bit and the N TOC\
    \ bit MUST be set to 0.\n   Note that V and T are set if the sender uses value\
    \ (V) or count (T)\n   tool for the log on an ongoing basis.  Thus, V may be set\
    \ even if J =\n   K = L = M = 0, and T may be set even if N = 0.\n   In many cases,\
    \ all parameters coded in the log list are of one type\n   (RPN and NRPN), and\
    \ all parameter numbers lie in the range 0-127.  As\n   described in Appendix\
    \ A.4.1, senders MAY signal this condition by\n   setting the top-level Chapter\
    \ M header bit Z to 1 (to code the\n   restricted range) and by setting the U\
    \ or W bit to 1 (to code the\n   parameter type).\n   If the top-level Chapter\
    \ M header codes Z = 1 and either U = 1 or\n   W = 1, all logs in the parameter\
    \ log list MUST use a modified header\n   format.  This modification deletes bits\
    \ 8-15 of the bitfield shown in\n   Figure A.4.2, to yield a 2-octet header. \
    \ The values of the deleted\n   PNUM-MSB and Q fields may be inferred from the\
    \ U, W, and Z bit\n   values.\n"
- title: A.4.2.1.  The Value Tool
  contents:
  - "A.4.2.1.  The Value Tool\n   The value tool uses several fields to track the\
    \ value of an RPN or\n   NRPN parameter.\n   The J TOC bit codes the presence\
    \ of the octet shown in Figure A.4.3\n   in the field list.\n                \
    \             0\n                             0 1 2 3 4 5 6 7\n              \
    \              +-+-+-+-+-+-+-+-+\n                            |X|  ENTRY-MSB \
    \ |\n                            +-+-+-+-+-+-+-+-+\n                      Figure\
    \ A.4.3 -- ENTRY-MSB field\n   The 7-bit ENTRY-MSB field codes the data value\
    \ of the most recent\n   active Control Change command for controller number 6\
    \ (Data Entry\n   MSB) in the session history that appears in a transaction for\
    \ the log\n   parameter.\n   The X bit MUST be set to 1 if the command coded by\
    \ ENTRY-MSB precedes\n   the most recent Control Change command for controller\
    \ 121 (Reset All\n   Controllers) in the session history.  Otherwise, the X bit\
    \ MUST be\n   set to 0.\n   A parameter log that uses the value tool MUST include\
    \ the ENTRY-MSB\n   field if an active Control Change command for controller number\
    \ 6\n   appears in the checkpoint history.\n   Note that [RP015] specifies that\
    \ Control Change commands for\n   controller 121 (Reset All Controllers) do not\
    \ reset RPN and NRPN\n   values, and thus the X bit would not play a recovery\
    \ role for MIDI\n   systems that comply with [RP015].\n   However, certain renderers\
    \ (such as DLS 2 [DLS2]) specify that\n   certain RPN values are reset for some\
    \ uses of Reset All Controllers.\n   The X bit (and other bitfield features of\
    \ this nature in this\n   appendix) plays a role in recovery for renderers of\
    \ this type.\n   The K TOC bit codes the presence of the octet shown in Figure\
    \ A.4.4\n   in the field list.\n                             0\n             \
    \                0 1 2 3 4 5 6 7\n                            +-+-+-+-+-+-+-+-+\n\
    \                            |X|  ENTRY-LSB  |\n                            +-+-+-+-+-+-+-+-+\n\
    \                      Figure A.4.4 -- ENTRY-LSB field\n   The 7-bit ENTRY-LSB\
    \ field codes the data value of the most recent\n   active Control Change command\
    \ for controller number 38 (Data Entry\n   LSB) in the session history that appears\
    \ in a transaction for the log\n   parameter.\n   The X bit MUST be set to 1 if\
    \ the command coded by ENTRY-LSB precedes\n   the most recent Control Change command\
    \ for controller 121 (Reset All\n   Controllers) in the session history.  Otherwise,\
    \ the X bit MUST be\n   set to 0.\n   As a rule, a parameter log that uses the\
    \ value tool MUST include the\n   ENTRY-LSB field if an active Control Change\
    \ command for controller\n   number 38 appears in the checkpoint history.  However,\
    \ the ENTRY-LSB\n   field MUST NOT appear in a parameter log if the Control Change\n\
    \   command associated with the ENTRY-LSB precedes a Control Change\n   command\
    \ for controller number 6 (Data Entry MSB) that appears in a\n   transaction for\
    \ the log parameter in the session history.\n   The L TOC bit codes the presence\
    \ of the octets shown in Figure A.4.5\n   in the field list.\n               \
    \        0                   1\n                       0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5\n                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         \
    \             |G|X|       A-BUTTON            |\n                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                       Figure A.4.5 -- A-BUTTON field\n   The 14-bit A-BUTTON\
    \ field codes a count of the number of active\n   Control Change commands for\
    \ controller numbers 96 and 97 (Data\n   Increment and Data Decrement) in the\
    \ session history that appear in a\n   transaction for the log parameter.\n  \
    \ The M TOC bit codes the presence of the octets shown in Figure A.4.6\n   in\
    \ the field list.\n                       0                   1\n            \
    \           0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      |G|R|       C-BUTTON            |\n                   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                       Figure A.4.6 --\
    \ C-BUTTON field\n   The 14-bit C-BUTTON field has semantics identical to A-BUTTON,\
    \ except\n   that Data Increment and Data Decrement Control Change commands that\n\
    \   precede the most recent Control Change command for controller 121\n   (Reset\
    \ All Controllers) in the session history are not counted.\n   For both A-BUTTON\
    \ and C-BUTTON, Data Increment and Data Decrement\n   Control Change commands\
    \ are not counted if they precede Control\n   Changes commands for controller\
    \ numbers 6 (Data Entry MSB) or 38\n   (Data Entry LSB) that appear in a transaction\
    \ for the log parameter\n   in the session history.\n   The A-BUTTON and C-BUTTON\
    \ fields are interpreted as unsigned\n   integers, and the G bit associated the\
    \ field codes the sign of the\n   integer (G = 0 for positive or zero, G = 1 for\
    \ negative).\n   To compute and code the count value, initialize the count value\
    \ to 0,\n   add 1 for each qualifying Data Increment command, and subtract 1 for\n\
    \   each qualifying Data Decrement command.  After each add or subtract,\n   limit\
    \ the count magnitude to 16383.  The G bit codes the sign of the\n   count, and\
    \ the A-BUTTON or C-BUTTON field codes the count magnitude.\n   For the A-BUTTON\
    \ field, if the most recent qualified Data Increment\n   or Data Decrement command\
    \ precedes the most recent Control Change\n   command for controller 121 (Reset\
    \ All Controllers) in the session\n   history, the X bit associated with A-BUTTON\
    \ field MUST be set to 1.\n   Otherwise, the X bit MUST be set to 0.\n   A parameter\
    \ log that uses the value tool MUST include the A-BUTTON\n   and C-BUTTON fields\
    \ if an active Control Change command for\n   controller numbers 96 or 97 appears\
    \ in the checkpoint history.\n   However, to improve coding efficiency, this rule\
    \ has several\n   exceptions:\n     o  If the log includes the A-BUTTON field,\
    \ and if the X bit of the\n        A-BUTTON field is set to 1, the C-BUTTON field\
    \ (and its\n        associated R and G bits) MAY be omitted from the log.\n  \
    \   o  If the log includes the A-BUTTON field, and if the A-BUTTON and\n     \
    \   C-BUTTON fields (and their associated G bits) code identical\n        values,\
    \ the C-BUTTON field (and its associated R and G bits) MAY\n        be omitted\
    \ from the log.\n"
- title: A.4.2.2.  The Count Tool
  contents:
  - "A.4.2.2.  The Count Tool\n   The count tool tracks the number of transactions\
    \ for an RPN or NRPN\n   parameter.  The N TOC bit codes the presence of the octet\
    \ shown in\n   Figure A.4.7 in the field list.\n                          0\n\
    \                          0 1 2 3 4 5 6 7\n                         +-+-+-+-+-+-+-+-+\n\
    \                         |X|    COUNT    |\n                         +-+-+-+-+-+-+-+-+\n\
    \                     Figure A.4.7 -- COUNT field\n   The 7-bit COUNT codes the\
    \ number of initiated transactions for the\n   log parameter that appear in the\
    \ session history.  Initiated\n   transactions are counted if they contain one\
    \ or more active Control\n   Change commands, including commands for controllers\
    \ 98-101 that\n   initiate the parameter transaction.\n   If the most recent counted\
    \ transaction precedes the most recent\n   Control Change command for controller\
    \ 121 (Reset All Controllers) in\n   the session history, the X bit associated\
    \ with the COUNT field MUST\n   be set to 1.  Otherwise, the X bit MUST be set\
    \ to 0.\n   Transaction counting is performed modulo 128.  The transaction count\n\
    \   is set to 0 at the start of a session and is reset to 0 whenever a\n   Reset\
    \ State command (Appendix A.1) appears in the session history.\n   A parameter\
    \ log that uses the count tool MUST include the COUNT field\n   if an active command\
    \ that increments the transaction count (modulo\n   128) appears in the checkpoint\
    \ history.\n"
- title: 'A.5.  Chapter W: MIDI Pitch Wheel'
  contents:
  - "A.5.  Chapter W: MIDI Pitch Wheel\n   A channel journal MUST contain Chapter\
    \ W if a C-active MIDI Pitch\n   Wheel (0xE) command appears in the checkpoint\
    \ history.  Figure A.5.1\n   shows the format for Chapter W.\n               \
    \        0                   1\n                       0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5\n                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         \
    \             |S|     FIRST   |R|    SECOND   |\n                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      Figure A.5.1 -- Chapter W format\n   The chapter has a\
    \ fixed size of 16 bits.  The FIRST and SECOND fields\n   are the 7-bit values\
    \ of the first and second data octets of the most\n   recent active Pitch Wheel\
    \ command in the session history.\n   Note that Chapter W encodes C-active commands\
    \ and thus does not\n   encode active commands that are not C-active (see the\
    \ second-to-last\n   paragraph of Appendix A.1 for an explanation of chapter inclusion\n\
    \   text in this regard).\n   Chapter W does not encode \"active but not C-active\"\
    \ commands because\n   [RP015] declares that Control Change commands for controller\
    \ number\n   121 (Reset All Controllers) act to reset the Pitch Wheel value to\
    \ 0.\n   If Chapter W encoded \"active but not C-active\" commands, a repair\n\
    \   operation following a Reset All Controllers command could incorrectly\n  \
    \ repair the stream with a stale Pitch Wheel value.\n"
- title: 'A.6.  Chapter N: MIDI NoteOff and NoteOn'
  contents:
  - "A.6.  Chapter N: MIDI NoteOff and NoteOn\n   In this appendix, we consider NoteOn\
    \ commands with zero velocity to\n   be NoteOff commands.  Readers may wish to\
    \ review the Appendix A.1\n   definition of \"N-active commands\" before reading\
    \ this appendix.\n   Chapter N completely protects note commands in streams that\
    \ alternate\n   between NoteOn and NoteOff commands for a particular note number.\n\
    \   However, in rare applications, multiple overlapping NoteOn commands\n   may\
    \ appear for a note number.  Chapter E, described in Appendix A.7,\n   augments\
    \ Chapter N to completely protect these streams.\n   A channel journal MUST contain\
    \ Chapter N if an N-active MIDI NoteOn\n   (0x9) or NoteOff (0x8) command appears\
    \ in the checkpoint history.\n   Figure A.6.1 shows the format for Chapter N.\n\
    \       0                   1                   2                   3\n      \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 8 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |B|     LEN     |  LOW  | HIGH  |S|   NOTENUM   |Y|  VELOCITY   |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |S|\
    \   NOTENUM   |Y|  VELOCITY   |             ....              |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |    OFFBITS    |    OFFBITS    |     ....      |    OFFBITS    |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \                Figure A.6.1 -- Chapter N format\n   Chapter N consists of a\
    \ 2-octet header, followed by at least one of\n   the following data structures:\n\
    \      o A list of note logs to code NoteOn commands.\n      o A NoteOff bitfield\
    \ structure to code NoteOff commands.\n   We define the header bitfield semantics\
    \ in Appendix A.6.1.  We define\n   the note log semantics and the NoteOff bitfield\
    \ semantics in Appendix\n   A.6.2.\n   If one or more N-active NoteOn or NoteOff\
    \ commands in the checkpoint\n   history reference a note number, the note number\
    \ MUST be coded in\n   either the note log list or the NoteOff bitfield structure.\n\
    \   The note log list MUST contain an entry for all note numbers whose\n   most\
    \ recent checkpoint history appearance is in an N-active NoteOn\n   command. \
    \ The NoteOff bitfield structure MUST contain a set bit for\n   all note numbers\
    \ whose most recent checkpoint history appearance is\n   in an N-active NoteOff\
    \ command.\n   A note number MUST NOT be coded in both structures.\n   All note\
    \ logs and NoteOff bitfield set bits MUST code the most recent\n   N-active NoteOn\
    \ or NoteOff reference to a note number in the session\n   history.\n   The note\
    \ log list MUST obey the oldest-first ordering rule (defined\n   in Appendix A.1).\n"
- title: A.6.1.  Header Structure
  contents:
  - "A.6.1.  Header Structure\n   The header for Chapter N, shown in Figure A.6.2,\
    \ codes the size of\n   the note list and bitfield structures.\n             \
    \          0                   1\n                       0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5\n                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       \
    \               |B|     LEN     |  LOW  | HIGH  |\n                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      Figure A.6.2 -- Chapter N header\n   The LEN field, a 7-bit\
    \ integer value, codes the number of 2-octet\n   note logs in the note list. \
    \ Zero is a valid value for LEN and codes\n   an empty note list.\n   The 4-bit\
    \ LOW and HIGH fields code the number of OFFBITS octets that\n   follow the note\
    \ log list.  LOW and HIGH are unsigned integer values.\n   If LOW <= HIGH, there\
    \ are (HIGH - LOW + 1) OFFBITS octets in the\n   chapter.  The value pairs (LOW\
    \ = 15, HIGH = 0) and (LOW = 15, HIGH =\n   1) code an empty NoteOff bitfield\
    \ structure (i.e., no OFFBITS\n   octets).  Other (LOW > HIGH) value pairs MUST\
    \ NOT appear in the\n   header.\n   The B bit provides S-bit functionality (Appendix\
    \ A.1) for the NoteOff\n   bitfield structure.  By default, the B bit MUST be\
    \ set to 1.\n   However, if the MIDI command section of the previous packet (packet\
    \ I\n   - 1, with I as defined in Appendix A.1) includes a NoteOff command\n \
    \  for the channel, the B bit MUST be set to 0.  If the B bit is set to\n   0,\
    \ the higher-level recovery journal elements that contain Chapter N\n   MUST have\
    \ S bits that are set to 0, including the top-level journal\n   header.\n   The\
    \ LEN value of 127 codes a note list length of 127 or 128 note\n   logs, depending\
    \ on the values of LOW and HIGH.  If LEN = 127, LOW =\n   15, and HIGH = 0, the\
    \ note list holds 128 note logs, and the NoteOff\n   bitfield structure is empty.\
    \  For other values of LOW and HIGH, LEN =\n   127 codes that the note list contains\
    \ 127 note logs.  In this case,\n   the chapter has (HIGH - LOW + 1) NoteOff OFFBITS\
    \ octets if LOW <=\n   HIGH and has no OFFBITS octets if LOW = 15 and HIGH = 1.\n"
- title: A.6.2.  Note Structures
  contents:
  - "A.6.2.  Note Structures\n   Figure A.6.3 shows the 2-octet note log structure.\n\
    \                       0                   1\n                       0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5\n                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      |S|   NOTENUM   |Y|  VELOCITY   |\n                   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                     Figure A.6.3 -- Chapter\
    \ N note log\n   The 7-bit NOTENUM field codes the note number for the log.  A\
    \ note\n   number MUST NOT be represented by multiple note logs in the note\n\
    \   list.\n   The 7-bit VELOCITY field codes the velocity value for the most recent\n\
    \   N-active NoteOn command for the note number in the session history.\n   Multiple\
    \ overlapping NoteOns for a given note number may be coded\n   using Chapter E,\
    \ as discussed in Appendix A.7.\n   VELOCITY is never zero; NoteOn commands with\
    \ zero velocity are coded\n   as NoteOff commands in the NoteOff bitfield structure.\n\
    \   The note log does not code the execution time of the NoteOn command.\n   However,\
    \ the Y bit codes a hint from the sender about the NoteOn\n   execution time.\
    \  The Y bit codes a recommendation to play (Y = 1) or\n   skip (Y = 0) the NoteOn\
    \ command recovered from the note log.  See\n   Section 4.2 of [RFC4696] for non-normative\
    \ guidance on the use of the\n   Y bit.\n   Figure A.6.1 shows the NoteOff bitfield\
    \ structure, as the list of\n   OFFBITS octets at the end of the chapter.  A NoteOff\
    \ OFFBITS octet\n   codes NoteOff information for eight consecutive MIDI note\
    \ numbers,\n   with the most-significant bit representing the lowest note number.\n\
    \   The most-significant bit of the first OFFBITS octet codes the note\n   number\
    \ 8*LOW; the most-significant bit of the last OFFBITS octet\n   codes the note\
    \ number 8*HIGH.\n   A set bit codes a NoteOff command for the note number.  In\
    \ the most\n   efficient coding for the NoteOff bitfield structure, the first\
    \ and\n   last octets of the structure contain at least one set bit.  Note that\n\
    \   Chapter N does not code NoteOff velocity data.\n   Note that in the general\
    \ case, the recovery journal does not code the\n   relative placement of a NoteOff\
    \ command and a Change Control command\n   for controller 64 (Damper Pedal (Sustain)).\
    \  In many cases, a\n   receiver processing a loss event may deduce this relative\
    \ placement\n   from the history of the stream and thus determine if a NoteOff\
    \ note\n   is sustained by the pedal.  If such a determination is not possible,\n\
    \   receivers SHOULD err on the side of silencing pedal sustains, as\n   erroneously\
    \ sustained notes may produce unpleasant (albeit transient)\n   artifacts.\n"
- title: 'A.7.  Chapter E: MIDI Note Command Extras'
  contents:
  - "A.7.  Chapter E: MIDI Note Command Extras\n   Readers may wish to review the\
    \ Appendix A.1 definition of \"N-active\n   commands\" before reading this appendix.\
    \  In this appendix, a NoteOn\n   command with a velocity of 0 is considered to\
    \ be a NoteOff command\n   with a release velocity value of 64.\n   Chapter E\
    \ encodes recovery information about MIDI NoteOn (0x9) and\n   NoteOff (0x8) command\
    \ features that rarely appear in MIDI streams.\n   Receivers use Chapter E to\
    \ reduce transient artifacts for streams\n   where several NoteOn commands appear\
    \ for a note number without an\n   intervening NoteOff.  Receivers also use Chapter\
    \ E to reduce\n   transient artifacts for streams that use NoteOff release velocity.\n\
    \   Chapter E supplements the note information coded in Chapter N\n   (Appendix\
    \ A.6).\n   Figure A.7.1 shows the format for Chapter E.\n       0           \
    \        1                   2                   3\n       0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 8 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |S|     LEN     |S|   NOTENUM   |V|  COUNT/VEL  |S|  NOTENUM    |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |V|\
    \  COUNT/VEL  |  ....                                         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                       Figure A.7.1 -- Chapter E format\n   The chapter consists\
    \ of a 1-octet header, followed by a variable-\n   length list of 2-octet note\
    \ logs.  Appendix A.7.1 defines the\n   bitfield format for a note log.\n   The\
    \ log list MUST contain at least one note log.  The 7-bit LEN\n   header field\
    \ codes the number of note logs in the list, minus one.  A\n   channel journal\
    \ MUST contain Chapter E if the rules defined in this\n   appendix require that\
    \ one or more note logs appear in the list.  The\n   note log list MUST obey the\
    \ oldest-first ordering rule (defined in\n   Appendix A.1).\n"
- title: A.7.1.  Note Log Format
  contents:
  - "A.7.1.  Note Log Format\n   Figure A.7.2 reproduces the note log structure of\
    \ Chapter E.\n                       0                   1\n                 \
    \      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      |S|   NOTENUM   |V|  COUNT/VEL  |\n                   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                      Figure A.7.2 -- Chapter\
    \ E note log\n   A note log codes information about the MIDI note number coded\
    \ by the\n   7-bit NOTENUM field.  The nature of the information depends on the\n\
    \   value of the V flag bit.\n   If the V bit is set to 1, the COUNT/VEL field\
    \ codes the release\n   velocity value for the most recent N-active NoteOff command\
    \ for the\n   note number that appears in the session history.\n   If the V bit\
    \ is set to 0, the COUNT/VEL field codes a reference count\n   of the number of\
    \ NoteOn and NoteOff commands for the note number that\n   appear in the session\
    \ history.\n   The reference count is set to 0 at the start of the session.  NoteOn\n\
    \   commands increment the count by 1.  NoteOff commands decrement the\n   count\
    \ by 1.  However, a decrement that generates a negative count\n   value is not\
    \ performed.\n   If the reference count is in the range 0-126, the 7-bit COUNT/VEL\n\
    \   field codes an unsigned integer representation of the count.  If the\n   count\
    \ is greater than or equal to 127, COUNT/VEL is set to 127.\n   By default, the\
    \ count is reset to 0 whenever a Reset State command\n   (Appendix A.1) appears\
    \ in the session history, and whenever MIDI\n   Control Change commands for controller\
    \ numbers 123-127 (numbers with\n   All Notes Off semantics) or 120 (All Sound\
    \ Off) appear in the session\n   history.\n"
- title: A.7.2.  Log Inclusion Rules
  contents:
  - "A.7.2.  Log Inclusion Rules\n   If the most recent N-active NoteOn or NoteOff\
    \ command for a note\n   number in the checkpoint history is a NoteOff command\
    \ with a release\n   velocity value other than 64, a note log whose V bit is set\
    \ to 1 MUST\n   appear in Chapter E for the note number.\n   If the most recent\
    \ N-active NoteOn or NoteOff command for a note\n   number in the checkpoint history\
    \ is a NoteOff command, and if the\n   reference count for the note number is\
    \ greater than 0, a note log\n   whose V bit is set to 0 MUST appear in Chapter\
    \ E for the note number.\n   If the most recent N-active NoteOn or NoteOff command\
    \ for a note\n   number in the checkpoint history is a NoteOn command, and if\
    \ the\n   reference count for the note number is greater than 1, a note log\n\
    \   whose V bit is set to 0 MUST appear in Chapter E for the note number.\n  \
    \ At most, two note logs MAY appear in Chapter E for a note number: one\n   log\
    \ whose V bit is set to 0, and one log whose V bit is set to 1.\n   Chapter E\
    \ codes a maximum of 128 note logs.  If the log inclusion\n   rules yield more\
    \ than 128 REQUIRED logs, note logs whose V bit is set\n   to 1 MUST be dropped\
    \ from Chapter E in order to reach the 128-log\n   limit.  Note logs whose V bit\
    \ is set to 0 MUST NOT be dropped.\n   Most MIDI streams do not use NoteOn and\
    \ NoteOff commands in ways that\n   would trigger the log inclusion rules.  For\
    \ these streams, Chapter E\n   would never be REQUIRED to appear in a channel\
    \ journal.\n   The ch_never parameter (Appendix C.2.3) may be used to configure\
    \ the\n   log inclusion rules for Chapter E.\n"
- title: 'A.8.  Chapter T: MIDI Channel Aftertouch'
  contents:
  - "A.8.  Chapter T: MIDI Channel Aftertouch\n   A channel journal MUST contain Chapter\
    \ T if an N-active and C-active\n   MIDI Channel Aftertouch (0xD) command appears\
    \ in the checkpoint\n   history.  Figure A.8.1 shows the format for Chapter T.\n\
    \                             0\n                             0 1 2 3 4 5 6 7\n\
    \                            +-+-+-+-+-+-+-+-+\n                            |S|\
    \   PRESSURE  |\n                            +-+-+-+-+-+-+-+-+\n             \
    \         Figure A.8.1 -- Chapter T format\n   The chapter has a fixed size of\
    \ 8 bits.  The 7-bit PRESSURE field\n   holds the pressure value of the most recent\
    \ N-active and C-active\n   Channel Aftertouch command in the session history.\n\
    \   Chapter T only encodes commands that are C-active and N-active.  We\n   define\
    \ a C-active restriction because [RP015] declares that a Control\n   Change command\
    \ for controller 121 (Reset All Controllers) acts to\n   reset the channel pressure\
    \ to 0 (see the discussion at the end of\n   Appendix A.5 for a more complete\
    \ rationale).\n   We define an N-active restriction on the assumption that aftertouch\n\
    \   commands are linked to note activity, and thus Channel Aftertouch\n   commands\
    \ that are not N-active are stale and should not be used to\n   repair a stream.\n"
- title: 'A.9.  Chapter A: MIDI Poly Aftertouch'
  contents:
  - "A.9.  Chapter A: MIDI Poly Aftertouch\n   A channel journal MUST contain Chapter\
    \ A if a C-active Poly\n   Aftertouch (0xA) command appears in the checkpoint\
    \ history.  Figure\n   A.9.1 shows the format for Chapter A.\n       0       \
    \            1                   2                   3\n       0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 8 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |S|    LEN      |S|   NOTENUM   |X|  PRESSURE   |S|   NOTENUM   |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |X|\
    \  PRESSURE   |  ....                                         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                       Figure A.9.1 -- Chapter A format\n   The chapter consists\
    \ of a 1-octet header, followed by a variable-\n   length list of 2-octet note\
    \ logs.  A note log MUST appear for a note\n   number if a C-active Poly Aftertouch\
    \ command for the note number\n   appears in the checkpoint history.  A note number\
    \ MUST NOT be\n   represented by multiple note logs in the note list.  The note\
    \ log\n   list MUST obey the oldest-first ordering rule (defined in Appendix\n\
    \   A.1).\n   The 7-bit LEN field codes the number of note logs in the list, minus\n\
    \   one.  Figure A.9.2 reproduces the note log structure of Chapter A.\n     \
    \                  0                   1\n                       0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5\n                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      |S|   NOTENUM   |X|  PRESSURE   |\n                   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                      Figure A.9.2 -- Chapter\
    \ A note log\n   The 7-bit PRESSURE field codes the pressure value of the most\
    \ recent\n   C-active Poly Aftertouch command in the session history for the MIDI\n\
    \   note number coded in the 7-bit NOTENUM field.\n   As a rule, the X bit MUST\
    \ be set to 0.  However, the X bit MUST be\n   set to 1 if the command coded by\
    \ the log appears before one of the\n   following commands in the session history:\
    \ MIDI Control Change\n   numbers 123-127 (numbers with All Notes Off semantics)\
    \ or 120 (All\n   Sound Off).\n   We define C-active restrictions for Chapter\
    \ A because [RP015]\n   declares that a Control Change command for controller\
    \ 121 (Reset All\n   Controllers) acts to reset the polyphonic pressure to 0 (see\
    \ the\n   discussion at the end of Appendix A.5 for a more complete rationale).\n"
- title: B.  The Recovery Journal System Chapters
  contents:
  - 'B.  The Recovery Journal System Chapters

    '
- title: 'B.1.  System Chapter D: Simple System Commands'
  contents:
  - "B.1.  System Chapter D: Simple System Commands\n   The system journal MUST contain\
    \ Chapter D if an active MIDI Reset\n   (0xFF), MIDI Tune Request (0xF6), MIDI\
    \ Song Select (0xF3), undefined\n   MIDI System Common (0xF4 and 0xF5), or undefined\
    \ MIDI System Real-\n   time (0xF9 and 0xFD) command appears in the checkpoint\
    \ history.\n   Figure B.1.1 shows the variable-length format for Chapter D.\n\
    \       0                   1                   2                   3\n      \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |S|B|G|H|J|K|Y|Z|  Command logs ...                             |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \            Figure B.1.1 -- System Chapter D format\n   The chapter consists\
    \ of a 1-octet header, followed by one or more\n   command logs.  Header flag\
    \ bits indicate the presence of command logs\n   for the Reset (B = 1), Tune Request\
    \ (G = 1), Song Select (H = 1),\n   undefined System Common 0xF4 (J = 1), undefined\
    \ System Common 0xF5 (K\n   = 1), undefined System Real-time 0xF9 (Y = 1), or\
    \ undefined System\n   Real-time 0xFD (Z = 1) commands.\n   Command logs appear\
    \ in a list following the header, in the order that\n   the flag bits appear in\
    \ the header.\n   Figure B.1.2 shows the 1-octet command log format for the Reset\
    \ and\n   Tune Request commands.\n                            0\n            \
    \                0 1 2 3 4 5 6 7\n                           +-+-+-+-+-+-+-+-+\n\
    \                           |S|    COUNT    |\n                           +-+-+-+-+-+-+-+-+\n\
    \             Figure B.1.2 -- Command log for Reset and Tune Request\n   Chapter\
    \ D MUST contain the Reset command log if an active Reset\n   command appears\
    \ in the checkpoint history.  The 7-bit COUNT field\n   codes the total number\
    \ of Reset commands (modulo 128) present in the\n   session history.\n   Chapter\
    \ D MUST contain the Tune Request command log if an active Tune\n   Request command\
    \ appears in the checkpoint history.  The 7-bit COUNT\n   field codes the total\
    \ number of Tune Request commands (modulo 128)\n   present in the session history.\n\
    \   For these commands, the COUNT field acts as a reference count.  See\n   the\
    \ definition of \"session history reference counts\" in Appendix A.1\n   for more\
    \ information.\n   Figure B.1.3 shows the 1-octet command log format for the Song\
    \ Select\n   command.\n                               0\n                    \
    \           0 1 2 3 4 5 6 7\n                              +-+-+-+-+-+-+-+-+\n\
    \                              |S|    VALUE    |\n                           \
    \   +-+-+-+-+-+-+-+-+\n                 Figure B.1.3 -- Song Select command log\
    \ format\n   Chapter D MUST contain the Song Select command log if an active Song\n\
    \   Select command appears in the checkpoint history.  The 7-bit VALUE\n   field\
    \ codes the song number of the most recent active Song Select\n   command in the\
    \ session history.\n"
- title: B.1.1.  Undefined System Commands
  contents:
  - "B.1.1.  Undefined System Commands\n   In this section, we define the Chapter\
    \ D command logs for the\n   undefined System commands.  [MIDI] reserves the undefined\
    \ System\n   commands 0xF4, 0xF5, 0xF9, and 0xFD for future use.  At the time\
    \ of\n   this writing, any MIDI command stream that uses these commands is\n \
    \  non-compliant with [MIDI].  However, future versions of [MIDI] may\n   define\
    \ these commands, and a few products do use these commands in a\n   non-compliant\
    \ manner.\n   Figure B.1.4 shows the variable-length command log format for the\n\
    \   undefined System Common commands (0xF4 and 0xF5).\n       0              \
    \     1                   2                   3\n       0 1 2 3 4 5 6 7 8 9 0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |S|C|V|L|DSZ|      LENGTH       |    COUNT      |  VALUE ...    |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \  LEGAL ...                                                    |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \          Figure B.1.4 -- Undefined System Common command log format\n   The\
    \ command log codes a single command type (0xF4 or 0xF5, not both).\n   Chapter\
    \ D MUST contain a command log if an active 0xF4 command\n   appears in the checkpoint\
    \ history and MUST contain an independent\n   command log if an active 0xF5 command\
    \ appears in the checkpoint\n   history.\n   Chapter D consists of a two-octet\
    \ header followed by a variable\n   number of data fields.  Header flag bits indicate\
    \ the presence of the\n   COUNT field (C = 1), the VALUE field (V = 1), and the\
    \ LEGAL field (L\n   = 1).  The 10-bit LENGTH field codes the size of the command\
    \ log and\n   conforms to semantics described in Appendix A.1.\n   The 2-bit DSZ\
    \ field codes the number of data octets in the command\n   instance that appears\
    \ most recently in the session history.  If DSZ =\n   0-2, the command has 0-2\
    \ data octets.  If DSZ = 3, the command has 3\n   or more command data octets.\n\
    \   We now define the default rules for the use of the COUNT, VALUE, and\n   LEGAL\
    \ fields.  The session configuration tools defined in Appendix\n   C.2.3 may be\
    \ used to override this behavior.\n   By default, if the DSZ field is set to 0,\
    \ the command log MUST\n   include the COUNT field.  The 8-bit COUNT field codes\
    \ the total\n   number of commands of the type coded by the log (0xF4 or 0xF5)\n\
    \   present in the session history, modulo 256.\n   By default, if the DSZ field\
    \ is set to 1-3, the command log MUST\n   include the VALUE field.  The variable-length\
    \ VALUE field codes a\n   verbatim copy the data octets for the most recent use\
    \ of the command\n   type coded by the log (0xF4 or 0xF5) in the session history.\
    \  The\n   most-significant bit of the final data octet MUST be set to 1, and\n\
    \   the most-significant bit of all other data octets MUST be set to 0.\n   The\
    \ LEGAL field is reserved for future use.  If an update to [MIDI]\n   defines\
    \ the 0xF4 or 0xF5 command, an IETF standards-track document\n   may define the\
    \ LEGAL field.  Until such a document appears, senders\n   MUST NOT use the LEGAL\
    \ field, and receivers MUST use the LENGTH field\n   to skip over the LEGAL field.\
    \  The LEGAL field would be defined by\n   the IETF if the semantics of the new\
    \ 0xF4 or 0xF5 command could not\n   be protected from packet loss via the use\
    \ of the COUNT and VALUE\n   fields.\n   Figure B.1.5 shows the variable-length\
    \ command log format for the\n   undefined System Real-time commands (0xF9 and\
    \ 0xFD).\n       0                   1                   2                   3\n\
    \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |S|C|L|\
    \ LENGTH  |     COUNT     |  LEGAL ...                    |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \        Figure B.1.5 -- Undefined System Real-time command log format\n   The\
    \ command log codes a single command type (0xF9 or 0xFD, not both).\n   Chapter\
    \ D MUST contain a command log if an active 0xF9 command\n   appears in the checkpoint\
    \ history and MUST contain an independent\n   command log if an active 0xFD command\
    \ appears in the checkpoint\n   history.\n   Chapter D consists of a one-octet\
    \ header followed by a variable\n   number of data fields.  Header flag bits indicate\
    \ the presence of the\n   COUNT field (C = 1) and the LEGAL field (L = 1).  The\
    \ 5-bit LENGTH\n   field codes the size of the command log and conforms to semantics\n\
    \   described in Appendix A.1.\n   We now define the default rules for the use\
    \ of the COUNT and LEGAL\n   fields.  The session configuration tools defined\
    \ in Appendix C.2.3\n   may be used to override this behavior.\n   The 8-bit COUNT\
    \ field codes the total number of commands of the type\n   coded by the log present\
    \ in the session history, modulo 256.  By\n   default, the COUNT field MUST be\
    \ present in the command log.\n   The LEGAL field is reserved for future use.\
    \  If an update to [MIDI]\n   defines the 0xF9 or 0xFD command, an IETF standards-track\
    \ document\n   may define the LEGAL field to protect the command.  Until such\
    \ a\n   document appears, senders MUST NOT use the LEGAL field, and receivers\n\
    \   MUST use the LENGTH field to skip over the LEGAL field.  The LEGAL\n   field\
    \ would be defined by the IETF if the semantics of the new 0xF9\n   or 0xFD command\
    \ could not be protected from packet loss via the use\n   of the COUNT field.\n\
    \   Finally, we note that some non-standard uses of the undefined System\n   Real-time\
    \ commands act to implement non-compliant variants of the\n   MIDI sequencer system.\
    \  In Appendix B.3.1, we describe resiliency\n   tools for the MIDI sequencer\
    \ system that provide some protection in\n   this case.\n"
- title: 'B.2.  System Chapter V: Active Sense Command'
  contents:
  - "B.2.  System Chapter V: Active Sense Command\n   The system journal MUST contain\
    \ Chapter V if an active MIDI Active\n   Sense (0xFE) command appears in the checkpoint\
    \ history.  Figure B.2.1\n   shows the format for Chapter V.\n               \
    \                0\n                               0 1 2 3 4 5 6 7\n         \
    \                     +-+-+-+-+-+-+-+-+\n                              |S|   \
    \ COUNT    |\n                              +-+-+-+-+-+-+-+-+\n              \
    \       Figure B.2.1 -- System Chapter V format\n   The 7-bit COUNT field codes\
    \ the total number of Active Sense commands\n   (modulo 128) present in the session\
    \ history.  The COUNT field acts as\n   a reference count.  See the definition\
    \ of \"session history reference\n   counts\" in Appendix A.1 for more information.\n"
- title: 'B.3.  System Chapter Q: Sequencer State Commands'
  contents:
  - "B.3.  System Chapter Q: Sequencer State Commands\n   This appendix describes\
    \ Chapter Q, the system chapter for the MIDI\n   sequencer commands.\n   The system\
    \ journal MUST contain Chapter Q if an active MIDI Song\n   Position Pointer (0xF2),\
    \ MIDI Clock (0xF8), MIDI Start (0xFA), MIDI\n   Continue (0xFB), or MIDI Stop\
    \ (0xFC) command appears in the\n   checkpoint history, and if the rules defined\
    \ in this appendix require\n   a change in the Chapter Q bitfield contents because\
    \ of the command\n   appearance.\n   Figure B.3.1 shows the variable-length format\
    \ for Chapter Q.\n       0                   1                   2           \
    \        3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |S|N|D|C|T| TOP |            CLOCK              | TIMETOOLS ... |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \              ...              |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n \
    \                   Figure B.3.1 -- System Chapter Q format\n   Chapter Q consists\
    \ of a 1-octet header followed by several optional\n   fields, in the order shown\
    \ in Figure B.3.1.\n   Header flag bits signal the presence of the 16-bit CLOCK\
    \ field (C =\n   1) and the 24-bit TIMETOOLS field (T = 1).  The 3-bit TOP header\n\
    \   field is interpreted as an unsigned integer, as are CLOCK and\n   TIMETOOLS.\
    \  We describe the TIMETOOLS field in Appendix B.3.1.\n   Chapter Q encodes the\
    \ most recent state of the sequencer system.\n   Receivers use the chapter to\
    \ re-synchronize the sequencer after a\n   packet loss episode.  Chapter fields\
    \ encode the on/off state of the\n   sequencer, the current position in the song,\
    \ and the downbeat.\n   The N header bit encodes the relative occurrence of the\
    \ Start, Stop,\n   and Continue commands in the session history.  If an active\
    \ Start or\n   Continue command appears most recently, the N bit MUST be set to\
    \ 1.\n   If an active Stop appears most recently, or if no active Start, Stop,\n\
    \   or Continue commands appear in the session history, the N bit MUST be\n  \
    \ set to 0.\n   The C header flag, the TOP header field, and the CLOCK field act\
    \ to\n   code the current position in the sequence:\n     o  If C = 1, the 3-bit\
    \ TOP header field and the 16-bit CLOCK field\n        are combined to form the\
    \ 19-bit unsigned quantity 65536*TOP +\n        CLOCK.  This value encodes the\
    \ song position in units of MIDI\n        Clocks (24 clocks per quarter note),\
    \ modulo 524288.  Note that\n        the maximum song position value that may\
    \ be coded by the Song\n        Position Pointer command is 98303 clocks (which\
    \ may be coded\n        with 17 bits), and that MIDI-coded songs are generally\n\
    \        constructed to avoid durations longer than this value.  However,\n  \
    \      the 19-bit size may be useful for real-time applications, such\n      \
    \  as a drum machine MIDI output that is sending clock commands for\n        long\
    \ periods of time.\n     o  If C = 0, the song position is the start of the song.\
    \  The C = 0\n        position is identical to the position coded by C = 1, TOP\
    \ = 0,\n        and CLOCK = 0, for the case where the song position is less than\n\
    \        524288 MIDI clocks.  In certain situations (defined later in\n      \
    \  this section), normative text may require the C = 0 or the C =\n        1,\
    \ TOP = 0, CLOCK = 0 encoding of the start of the song.\n   The C, TOP, and CLOCK\
    \ fields MUST be set to code the current song\n   position, for both N = 0 and\
    \ N = 1 conditions.  If C = 0, the TOP\n   field MUST be set to 0.  See [MIDI]\
    \ for a precise definition of a\n   song position.\n   The D header bit encodes\
    \ information about the downbeat and acts to\n   qualify the song position coded\
    \ by the C, TOP, and CLOCK fields.\n   If the D bit is set to 1, the song position\
    \ represents the most\n   recent position in the sequence that has played.  If\
    \ D = 1, the next\n   Clock command (if N = 1) or the next (Continue, Clock) pair\
    \ (if\n   N = 0) acts to increment the song position by one clock, and to play\n\
    \   the updated position.\n   If the D bit is set to 0, the song position represents\
    \ a position in\n   the sequence that has not yet been played.  If D = 0, the\
    \ next Clock\n   command (if N = 1) or the next (Continue, Clock) pair (if N =\
    \ 0) acts\n   to play the point in the song coded by the song position.  The song\n\
    \   position is not incremented.\n   An example of a stream that uses D = 0 coding\
    \ is one whose most\n   recent sequence command is a Start or Song Position Pointer\
    \ command\n   (both N = 1 conditions).  However, it is also possible to construct\n\
    \   examples where D = 0 and N = 0.  A Start command immediately followed\n  \
    \ by a Stop command is coded in Chapter Q by setting C = 0, D = 0,\n   N = 0,\
    \ TOP = 0.\n   If N = 1 (coding Start or Continue), D = 0 (coding that the downbeat\n\
    \   has yet to be played), and the song position is at the start of the\n   song,\
    \ the C = 0 song position encoding MUST be used if a Start\n   command occurs\
    \ more recently than a Continue command in the session\n   history, and the C\
    \ = 1, TOP = 0, CLOCK = 0 song position encoding\n   MUST be used if a Continue\
    \ command occurs more recently than a Start\n   command in the session history.\n"
- title: B.3.1.  Non-compliant Sequencers
  contents:
  - "B.3.1.  Non-compliant Sequencers\n   The Chapter Q description in this appendix\
    \ assumes that the sequencer\n   system counts off time with Clock commands, as\
    \ mandated in [MIDI].\n   However, a few non-compliant products do not use Clock\
    \ commands to\n   count off time, but instead use non-standard methods.\n   Chapter\
    \ Q uses the TIMETOOLS field to provide resiliency support for\n   these non-standard\
    \ products.  By default, the TIMETOOLS field MUST\n   NOT appear in Chapter Q,\
    \ and the T header bit MUST be set to 0.  The\n   session configuration tools\
    \ described in Appendix C.2.3 may be used\n   to select TIMETOOLS coding.\n  \
    \ Figure B.3.2 shows the format of the 24-bit TIMETOOLS field.\n             \
    \   0                   1                   2\n                0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\n               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \               |                   TIME                        |\n          \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                    \
    \   Figure B.3.2 -- TIMETOOLS format\n   The TIME field is a 24-bit unsigned integer\
    \ quantity, with units of\n   milliseconds.  TIME codes an additive correction\
    \ term for the song\n   position coded by the TOP, CLOCK, and C fields.  TIME\
    \ is coded in\n   network byte order (big-endian).\n   A receiver computes the\
    \ correct song position by converting TIME into\n   units of MIDI clocks and adding\
    \ it to 65536*TOP + CLOCK (assuming\n   C = 1).  Alternatively, a receiver may\
    \ convert 65536*TOP + CLOCK into\n   milliseconds (assuming C = 1) and add it\
    \ to TIME.  The downbeat (D\n   header bit) semantics defined in Appendix B.3\
    \ apply to the corrected\n   song position.\n"
- title: 'B.4.  System Chapter F: MIDI Time Code Tape Position'
  contents:
  - "B.4.  System Chapter F: MIDI Time Code Tape Position\n   This appendix describes\
    \ Chapter F, the system chapter for the MIDI\n   Time Code (MTC) commands.  Readers\
    \ may wish to review the Appendix\n   A.1 definition of \"finished/unfinished\
    \ commands\" before reading this\n   appendix.\n   The system journal MUST contain\
    \ Chapter F if an active System Common\n   Quarter Frame command (0xF1) or an\
    \ active finished System Exclusive\n   (Universal Real Time) MTC Full Frame command\
    \ (F0 7F cc 01 01 hr mn sc\n   fr F7) appears in the checkpoint history.  Otherwise,\
    \ the system\n   journal MUST NOT contain Chapter F.\n   Figure B.4.1 shows the\
    \ variable-length format for Chapter F.\n       0                   1        \
    \           2                   3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |S|C|P|Q|D|POINT|  COMPLETE ...                                 |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \     ...       |  PARTIAL  ...                                 |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |     ...       |\n      +-+-+-+-+-+-+-+-+\n                    Figure\
    \ B.4.1 -- System Chapter F format\n   Chapter F holds information about recent\
    \ MTC tape positions coded in\n   the session history.  Receivers use Chapter\
    \ F to re-synchronize the\n   MTC system after a packet loss episode.\n   Chapter\
    \ F consists of a 1-octet header followed by several optional\n   fields, in the\
    \ order shown in Figure B.4.1.  The C and P header bits\n   form a Table of Contents\
    \ (TOC) and signal the presence of the 32-bit\n   COMPLETE field (C = 1) and the\
    \ 32-bit PARTIAL field (P = 1).\n   The Q header bit codes information about the\
    \ COMPLETE field format.\n   If Chapter F does not contain a COMPLETE field, Q\
    \ MUST be set to 0.\n   The D header bit codes the tape movement direction.  If\
    \ the tape is\n   moving forward, or if the tape direction is indeterminate, the\
    \ D bit\n   MUST be set to 0.  If the tape is moving in the reverse direction,\n\
    \   the D bit MUST be set to 1.  In most cases, the ordering of commands\n   in\
    \ the session history clearly defines the tape direction.  However,\n   a few\
    \ command sequences have an indeterminate direction (such as a\n   session history\
    \ consisting of one Full Frame command).\n   The 3-bit POINT header field is interpreted\
    \ as an unsigned integer.\n   Appendix B.4.1 defines how the POINT field codes\
    \ information about\n   the contents of the PARTIAL field.  If Chapter F does\
    \ not contain a\n   PARTIAL field, POINT MUST be set to 7 (if D = 0) or 0 (if\
    \ D = 1).\n   Chapter F MUST include the COMPLETE field if an active finished\
    \ Full\n   Frame command appears in the checkpoint history, or if an active\n\
    \   Quarter Frame command that completes the encoding of a frame value\n   appears\
    \ in the checkpoint history.\n   The COMPLETE field encodes the most recent active\
    \ complete MTC frame\n   value that appears in the session history.  This frame\
    \ value may take\n   the form of a series of 8 active Quarter Frame commands (0xF1\
    \ 0x0n\n   through 0xF1 0x7n for forward tape movement, 0xF1 0x7n through 0xF1\n\
    \   0x0n for reverse tape movement) or may take the form of an active\n   finished\
    \ Full Frame command.\n   If the COMPLETE field encodes a Quarter Frame command\
    \ series, the Q\n   header bit MUST be set to 1, and the COMPLETE field MUST have\
    \ the\n   format shown in Figure B.4.2.  The 4-bit fields MT0 through MT7 code\n\
    \   the data (lower) nibble for the Quarter Frame commands for Message\n   Type\
    \ 0 through Message Type 7 [MIDI].  These nibbles encode a\n   complete frame\
    \ value, in addition to fields reserved for future use\n   by [MIDI].\n      \
    \ 0                   1                   2                   3\n       0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |  MT0  |  MT1  |  MT2  |  MT3  |  MT4  |  MT5  |  MT6  |  MT7  |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \        Figure B.4.2 -- COMPLETE field format, Q = 1\n   In this usage, the frame\
    \ value encoded in the COMPLETE field MUST be\n   offset by 2 frames (relative\
    \ to the frame value encoded in the\n   Quarter Frame commands) if the frame value\
    \ codes a 0xF1 0x0n through\n   0xF1 0x7n command sequence.  This offset compensates\
    \ for the two-\n   frame latency of the Quarter Frame encoding for forward tape\n\
    \   movement.  No offset is applied if the frame value codes a 0xF1 0x7n\n   through\
    \ 0xF1 0x0n Quarter Frame command sequence.\n   The most recent active complete\
    \ MTC frame value may alternatively be\n   encoded by an active finished Full\
    \ Frame command.  In this case, the\n   Q header bit MUST be set to 0, and the\
    \ COMPLETE field MUST have\n   format shown in Figure B.4.3.  The HR, MN, SC,\
    \ and FR fields\n   correspond to the hr, mn, sc, and fr data octets of the Full\
    \ Frame\n   command.\n       0                   1                   2       \
    \            3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |      HR       |      MN       |      SC       |      FR       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \        Figure B.4.3 -- COMPLETE field format, Q = 0\n"
- title: B.4.1.  Partial Frames
  contents:
  - "B.4.1.  Partial Frames\n   The most recent active session history command that\
    \ encodes MTC frame\n   value data may be a Quarter Frame command other than a\
    \ forward-moving\n   0xF1 0x7n command (which completes a frame value for forward\
    \ tape\n   movement) or a reverse-moving 0xF1 0x1n command (which completes a\n\
    \   frame value for reverse tape movement).\n   We consider this type of Quarter\
    \ Frame command to be associated with\n   a partial frame value.  The Quarter\
    \ Frame sequence that defines a\n   partial frame value MUST either start at Message\
    \ Type 0 and increment\n   contiguously to an intermediate Message Type less than\
    \ 7, or start at\n   Message Type 7 and decrement contiguously to an intermediate\
    \ Message\n   type greater than 0.  A Quarter Frame command sequence that does\
    \ not\n   follow this pattern is not associated with a partial frame value.\n\
    \   Chapter F MUST include a PARTIAL field if the most recent active\n   command\
    \ in the checkpoint history that encodes MTC frame value data\n   is a Quarter\
    \ Frame command that is associated with a partial frame\n   value.  Otherwise,\
    \ Chapter F MUST NOT include a PARTIAL field.\n   The partial frame value consists\
    \ of the data (lower) nibbles of the\n   Quarter Frame command sequence.  The\
    \ PARTIAL field codes the partial\n   frame value, using the format shown in Figure\
    \ B.4.2.  Message Type\n   fields that are not associated with a Quarter Frame\
    \ command MUST be\n   set to 0.\n   The POINT header field indicates the Message\
    \ Type fields in the\n   PARTIAL field code valid data.  If P = 1, the POINT field\
    \ MUST encode\n   the unsigned integer value formed by the lower 3 bits of the\
    \ upper\n   nibble of the data value of the most recent active Quarter Frame\n\
    \   command in the session history.  If D = 0 and P = 1, POINT MUST take\n   on\
    \ a value in the range 0-6.  If D = 1 and P = 1, POINT MUST take on\n   a value\
    \ in the range 1-7.\n   If D = 0, MT fields (Figure B.4.2) in the inclusive range\
    \ from 0 up\n   to and including the POINT value encode the partial frame value.\
    \  If\n   D = 1, MT fields in the inclusive range from 7 down to and including\n\
    \   the POINT value encode the partial frame value.  Note that, unlike\n   the\
    \ COMPLETE field encoding, senders MUST NOT add a 2-frame offset to\n   the partial\
    \ frame value encoded in PARTIAL.\n   For the default semantics, if a recovery\
    \ journal contains Chapter F,\n   and if the session history codes a legal [MIDI]\
    \ series of Quarter\n   Frame and Full Frame commands, the chapter always contains\
    \ a COMPLETE\n   or a PARTIAL field (and may contain both fields).  Thus, a one-octet\n\
    \   Chapter F (C = P = 0) always codes the presence of an illegal command\n  \
    \ sequence in the session history (under some conditions, the C = 1,\n   P = 0\
    \ condition may also code the presence of an illegal command\n   sequence).  The\
    \ illegal command sequence conditions are transient in\n   nature and usually\
    \ indicate that a Quarter Frame command sequence\n   began with an intermediate\
    \ Message Type.\n"
- title: 'B.5.  System Chapter X: System Exclusive'
  contents:
  - "B.5.  System Chapter X: System Exclusive\n   This appendix describes Chapter\
    \ X, the system chapter for MIDI System\n   Exclusive (SysEx) commands (0xF0).\
    \  Readers may wish to review the\n   Appendix A.1 definition of \"finished/unfinished\
    \ commands\" before\n   reading this appendix.\n   Chapter X consists of a list\
    \ of one or more command logs.  Each log\n   in the list codes information about\
    \ a specific finished or unfinished\n   SysEx command that appears in the session\
    \ history.  The system\n   journal MUST contain Chapter X if the rules defined\
    \ in Appendix B.5.2\n   require that one or more logs appear in the list.\n  \
    \ The log list is not preceded by a header.  Instead, each log\n   implicitly\
    \ encodes its own length.  Given the length of the N'th list\n   log, the presence\
    \ of the (N+1)'th list log may be inferred from the\n   LENGTH field of the system\
    \ journal header (Figure 10 in Section 5 of\n   the main text).  The log list\
    \ MUST obey the oldest-first ordering\n   rule (defined in Appendix A.1).\n"
- title: B.5.1.  Chapter Format
  contents:
  - "B.5.1.  Chapter Format\n   Figure B.5.1 shows the bitfield format for the Chapter\
    \ X command log.\n       0                   1                   2           \
    \        3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |S|T|C|F|D|L|STA|    TCOUNT     |     COUNT     |  FIRST ...    |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \  DATA ...                                                     |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                 Figure B.5.1 -- Chapter X command log format\n   A Chapter X\
    \ command log consists of a 1-octet header, followed by the\n   optional TCOUNT,\
    \ COUNT, FIRST, and DATA fields.\n   The T, C, F, and D header bits act as a Table\
    \ of Contents (TOC) for\n   the log.  If T is set to 1, the 1-octet TCOUNT field\
    \ appears in the\n   log.  If C is set to 1, the 1-octet COUNT field appears in\
    \ the log.\n   If F is set to 1, the variable-length FIRST field appears in the\
    \ log.\n   If D is set to 1, the variable-length DATA field appears in the log.\n\
    \   The L header bit sets the coding tool for the log.  We define the log\n  \
    \ coding tools in Appendix B.5.2.\n   The STA field codes the status of the command\
    \ coded by the log.  The\n   2-bit STA value is interpreted as an unsigned integer.\
    \  If STA is 0,\n   the log codes an unfinished command.  Non-zero STA values\
    \ code\n   different classes of finished commands.  An STA value of 1 codes a\n\
    \   cancelled command, an STA value of 2 codes a command that uses the\n   \"\
    dropped F7\" construction, and an STA value of 3 codes all other\n   finished\
    \ commands.  Section 3.2 in the main text describes cancelled\n   and \"dropped\
    \ F7\" commands.\n   The S bit (Appendix A.1) of the first log in the list acts\
    \ as the S\n   bit for Chapter X.  For the other logs in the list, the S bit refers\n\
    \   to the log itself.  The value of the \"phantom\" S bit associated with\n \
    \  the first log is defined by the following rules:\n     o  If the list codes\
    \ one log, the phantom S-bit value is the same\n        as the Chapter X S-bit\
    \ value.\n     o  If the list codes multiple logs, the phantom S-bit value is\
    \ the\n        logical OR of the S-bit value of the first and second command\n\
    \        logs in the list.\n   In all other respects, the S bit follows the semantics\
    \ defined in\n   Appendix A.1.\n   The FIRST field (present if F = 1) encodes\
    \ a variable-length unsigned\n   integer value that sets the coverage of the DATA\
    \ field.\n   The FIRST field (present if F = 1) encodes a variable-length unsigned\n\
    \   integer value that specifies which SysEx data bytes are encoded in\n   the\
    \ DATA field of the log.  The FIRST field consists of an octet\n   whose most-significant\
    \ bit is set to 0, optionally preceded by one or\n   more octets whose most-significant\
    \ bit is set to 1.  The algorithm\n   shown in Figure B.5.2 decodes this format\
    \ into an unsigned integer,\n   to yield the value dec(FIRST).  FIRST uses a variable-length\
    \ encoding\n   because dec(FIRST) references a data octet in a SysEx command,\
    \ and a\n   SysEx command may contain an arbitrary number of data octets.\n  \
    \      One-Octet FIRST value:\n           Encoded form: 0ddddddd\n           Decoded\
    \ form: 00000000 00000000 00000000 0ddddddd\n        Two-Octet FIRST value:\n\
    \           Encoded form: 1ccccccc 0ddddddd\n           Decoded form: 00000000\
    \ 00000000 00cccccc cddddddd\n        Three-Octet FIRST value:\n           Encoded\
    \ form: 1bbbbbbb 1ccccccc 0ddddddd\n           Decoded form: 00000000 000bbbbb\
    \ bbcccccc cddddddd\n        Four-Octet FIRST value:\n           Encoded form:\
    \ 1aaaaaaa 1bbbbbbb 1ccccccc 0ddddddd\n           Decoded form: 0000aaaa aaabbbbb\
    \ bbcccccc cddddddd\n                Figure B.5.2 -- Decoding FIRST field formats\n\
    \   The DATA field (present if D = 1) encodes a modified version of the\n   data\
    \ octets of the SysEx command coded by the log.  Status octets\n   MUST NOT be\
    \ coded in the DATA field.\n   If F = 0, the DATA field begins with the first\
    \ data octet of the\n   SysEx command and includes all subsequent data octets\
    \ for the command\n   that appear in the session history.  If F = 1, the DATA\
    \ field begins\n   with the (dec(FIRST) + 1)'th data octet of the SysEx command\
    \ and\n   includes all subsequent data octets for the command that appear in\n\
    \   the session history.  Note that the word \"command\" in the\n   descriptions\
    \ above refers to the original SysEx command as it appears\n   in the source MIDI\
    \ data stream, not to a particular MIDI list SysEx\n   command segment.\n   The\
    \ length of the DATA field is coded implicitly, using the most-\n   significant\
    \ bit of each octet.  The most-significant bit of the final\n   octet of the DATA\
    \ field MUST be set to 1.  The most-significant bit\n   of all other DATA octets\
    \ MUST be set to 0.  This coding method relies\n   on the fact that the most-significant\
    \ bit of a MIDI data octet is 0\n   by definition.  Apart from this length-coding\
    \ modification, the DATA\n   field encodes a verbatim copy of all data octets\
    \ it encodes.\n"
- title: B.5.2.  Log Inclusion Semantics
  contents:
  - "B.5.2.  Log Inclusion Semantics\n   Chapter X offers two tools to protect SysEx\
    \ commands: the \"recency\"\n   tool and the \"list\" tool.  The tool definitions\
    \ use the concept of\n   the \"SysEx type\" of a command, which we now define.\n\
    \   Each SysEx command instance in a session, excepting MTC Full Frame\n   commands,\
    \ is said to have a \"SysEx type\".  Types are used in equality\n   comparisons:\
    \ two SysEx commands in a session are said to have \"the\n   same SysEx type\"\
    \ or \"different SysEx types\".\n   If efficiency is not a concern, a sender may\
    \ follow a simple typing\n   rule: every SysEx command in the session history\
    \ has a different\n   SysEx type, and thus no two commands in the session have\
    \ the same\n   type.\n   To improve efficiency, senders MAY implement exceptions\
    \ to this rule.\n   These exceptions declare that certain sets of SysEx command\
    \ instances\n   have the same SysEx type.  Any command not covered by an exception\n\
    \   follows the simple rule.  We list exceptions below:\n     o  All commands\
    \ with identical data octet fields (same number of\n        data octets, same\
    \ value for each data octet) have the same type.\n        This rule MUST be applied\
    \ to all SysEx commands in the session,\n        or not at all.  Note that the\
    \ implementation of this exception\n        requires no sender knowledge of the\
    \ format and semantics of the\n        SysEx commands in the stream, merely the\
    \ ability to count and\n        compare octets.\n     o  Two instances of the\
    \ same command whose semantics set or report\n        the value of the same \"\
    parameter\" have the same type.  The\n        implementation of this exception\
    \ requires specific knowledge of\n        the format and semantics of SysEx commands.\
    \  In practice, a\n        sender implementation chooses to support this exception\
    \ for\n        certain classes of commands (such as the Universal System\n   \
    \     Exclusive commands defined in [MIDI]).  If a sender supports\n        this\
    \ exception for a particular command in a class (for example,\n        the Universal\
    \ Real Time System Exclusive message for Master\n        Volume, F0 F7 cc 04 01\
    \ vv vv F7, defined in [MIDI]), it MUST\n        support the exception to all\
    \ instances of this particular\n        command in the session.\n   We now use\
    \ this definition of \"SysEx type\" to define the \"recency\"\n   tool and the\
    \ \"list\" tool for Chapter X.\n   By default, the Chapter X log list MUST code\
    \ sufficient information\n   to protect the rendered MIDI performance from indefinite\
    \ artifacts\n   caused by the loss of all finished or unfinished active SysEx\n\
    \   commands that appear in the checkpoint history (excluding finished\n   MTC\
    \ Full Frame commands, which are coded in Chapter F (Appendix\n   B.4)).\n   To\
    \ protect a command of a specific SysEx type with the recency tool,\n   senders\
    \ MUST code a log in the log list for the most recent finished\n   active instance\
    \ of the SysEx type that appears in the checkpoint\n   history.  Additionally,\
    \ if an unfinished active instance of the SysEx\n   type appears in the checkpoint\
    \ history, senders MUST code a log in\n   the log list for the unfinished command\
    \ instance.  The L header bit\n   of both command logs MUST be set to 0.\n   To\
    \ protect a command of a specific SysEx type with the list tool,\n   senders MUST\
    \ code a log in the Chapter X log list for each finished\n   or unfinished active\
    \ instance of the SysEx type that appears in the\n   checkpoint history.  The\
    \ L header bit of list tool command logs MUST\n   be set to 1.\n   As a rule,\
    \ a log REQUIRED by the list or recency tool MUST include a\n   DATA field that\
    \ codes all data octets that appear in the checkpoint\n   history for the SysEx\
    \ command instance associated with the log.  The\n   FIRST field MAY be used to\
    \ configure a DATA field that minimally\n   meets this requirement.\n   An exception\
    \ to this rule applies to cancelled commands (defined in\n   Section 3.2).  REQUIRED\
    \ command logs associated with cancelled\n   commands MAY be coded with no DATA\
    \ field.  However, if DATA appears\n   in the log, DATA MUST code all data octets\
    \ that appear in the\n   checkpoint history for the command associated with the\
    \ log.\n   As defined by the preceding text in this section, by default all\n\
    \   finished or unfinished active SysEx commands that appear in the\n   checkpoint\
    \ history (excluding finished MTC Full Frame commands) MUST\n   be protected by\
    \ the list tool or the recency tool.\n   For some MIDI source streams, this default\
    \ yields a Chapter X whose\n   size is too large.  For example, imagine that a\
    \ sender begins to\n   transcode a SysEx command with 10,000 data octets onto\
    \ a UDP RTP\n   stream \"on the fly\", by sending SysEx command segments as soon\
    \ as\n   data octets are delivered by the MIDI source.  After 1000 octets have\n\
    \   been sent, the expansion of Chapter X yields an RTP packet that is\n   too\
    \ large to fit in the Maximum Transmission Unit (MTU) for the\n   stream.\n  \
    \ In this situation, if a sender uses the closed-loop sending policy\n   for SysEx\
    \ commands, the RTP packet size may always be capped by\n   stalling the stream.\
    \  In a stream stall, once the packet reaches a\n   maximum size, the sender refrains\
    \ from sending new packets with non-\n   empty MIDI Command Sections until receiver\
    \ feedback permits the\n   trimming of Chapter X.  If the stream permits arbitrary\
    \ commands to\n   appear between SysEx segments (selectable during configuration\
    \ using\n   the tools defined in Appendix C.1), the sender may stall the SysEx\n\
    \   segment stream but continue to code other commands in the MIDI list.\n   Stalls\
    \ are a workable but sub-optimal solution to Chapter X size\n   issues.  As an\
    \ alternative to stalls, senders SHOULD take preemptive\n   action during session\
    \ configuration to reduce the anticipated size of\n   Chapter X, using the methods\
    \ described below:\n     o  Partitioned transport.  Appendix C.5 provides tools\
    \ for sending\n        a MIDI name space over several RTP streams.  Senders may\
    \ use\n        these tools to map a MIDI source into a low-latency UDP RTP\n \
    \       stream (for channel commands and short SysEx commands) and a\n       \
    \ reliable [RFC4571] TCP stream (for bulk-data SysEx commands).\n        The cm_unused\
    \ and cm_used parameters (Appendix C.1) may be used\n        to communicate the\
    \ nature of the SysEx command partition.  As\n        TCP is reliable, the RTP\
    \ MIDI TCP stream would not use the\n        recovery journal.  To minimize transmission\
    \ latency for short\n        SysEx commands, senders may begin segmental transmission\
    \ for all\n        SysEx commands over the UDP stream and then cancel the UDP\n\
    \        transmission of long commands (using tools described in Section\n   \
    \     3.2) and resend the commands over the TCP stream.\n     o  Selective protection.\
    \  Journal protection may not be necessary\n        for all SysEx commands in\
    \ a stream.  The ch_never parameter\n        (Appendix C.2) may be used to communicate\
    \ which SysEx commands\n        are excluded from Chapter X.\n"
- title: B.5.3.  TCOUNT and COUNT Fields
  contents:
  - "B.5.3.  TCOUNT and COUNT Fields\n   If the T header bit is set to 1, the 8-bit\
    \ TCOUNT field appears in\n   the command log.  If the C header bit is set to\
    \ 1, the 8-bit COUNT\n   field appears in the command log.  TCOUNT and COUNT are\
    \ interpreted\n   as unsigned integers.\n   The TCOUNT field codes the total number\
    \ of SysEx commands of the\n   SysEx type coded by the log that appear in the\
    \ session history, at\n   the moment after the (finished or unfinished) command\
    \ coded by the\n   log enters the session history.\n   The COUNT field codes the\
    \ total number of SysEx commands that appear\n   in the session history, excluding\
    \ commands that are excluded from\n   Chapter X via the ch_never parameter (Appendix\
    \ C.2), at the moment\n   after the (finished or unfinished) command coded by\
    \ the log enters\n   the session history.\n   Command counting for TCOUNT and\
    \ COUNT uses modulo-256 arithmetic.\n   MTC Full Frame command instances (Appendix\
    \ B.4) are included in\n   command counting if the TCOUNT and COUNT definitions\
    \ warrant their\n   inclusion, as are cancelled commands (Section 3.2).\n   Senders\
    \ use the TCOUNT and COUNT fields to track the identity and\n   (for TCOUNT) the\
    \ sequence position of a command instance.  Senders\n   MUST use the TCOUNT or\
    \ COUNT fields if identity or sequence\n   information is necessary to protect\
    \ the command type coded by the\n   log.\n   If a sender uses the COUNT field\
    \ in a session, the final command log\n   in every Chapter X in the stream MUST\
    \ code the COUNT field.  This\n   rule lets receivers resynchronize the COUNT\
    \ value after a packet\n   loss.\n"
- title: C.  Session Configuration Tools
  contents:
  - "C.  Session Configuration Tools\n   In Sections 6.1-2 of the main text, we show\
    \ session descriptions for\n   minimal native and mpeg4-generic RTP MIDI streams.\
    \  Minimal streams\n   lack the flexibility to support some applications.  In\
    \ this appendix,\n   we describe how to customize stream behavior through the\
    \ use of the\n   payload format parameters.\n   The appendix begins with 6 sections,\
    \ each devoted to parameters that\n   affect a particular aspect of stream behavior:\n\
    \     o  Appendix C.1 describes the stream subsetting system (cm_unused\n    \
    \    and cm_used).\n     o  Appendix C.2 describes the journalling system (ch_anchor,\n\
    \        ch_default, ch_never, j_sec, j_update).\n     o  Appendix C.3 describes\
    \ MIDI command timestamp semantics\n        (linerate, mperiod, octpos, tsmode).\n\
    \     o  Appendix C.4 describes the temporal duration (\"media time\") of\n  \
    \      an RTP MIDI packet (guardtime, rtp_maxptime, rtp_ptime).\n     o  Appendix\
    \ C.5 concerns stream description (musicport).\n     o  Appendix C.6 describes\
    \ MIDI rendering (chanmask, cid, inline,\n        multimode, render, rinit, subrender,\
    \ smf_cid, smf_info,\n        smf_inline, smf_url, url).\n   The parameters listed\
    \ above may optionally appear in session\n   descriptions of RTP MIDI streams.\
    \  If these parameters are used in an\n   SDP session description, the parameters\
    \ appear on an fmtp attribute\n   line.  This attribute line applies to the payload\
    \ type associated\n   with the fmtp line.\n   The parameters listed above add\
    \ extra functionality (\"features\") to\n   minimal RTP MIDI streams.  In Appendix\
    \ C.7, we show how to use these\n   features to support two classes of applications:\
    \ content-streaming\n   using RTSP (Appendix C.7.1) and network musical performance\
    \ using SIP\n   (Appendix C.7.2).\n   The participants in a multimedia session\
    \ MUST share a common view of\n   all of the RTP MIDI streams that appear in an\
    \ RTP session, as defined\n   by a single media (m=) line.  In some RTP MIDI applications,\
    \ the\n   \"common view\" restriction makes it difficult to use sendrecv streams\n\
    \   (all parties send and receive), as each party has its own\n   requirements.\
    \  For example, a two-party network musical performance\n   application may wish\
    \ to customize the renderer on each host to match\n   the CPU performance of the\
    \ host [NMP].\n   We solve this problem by using two RTP MIDI streams -- one sendonly,\n\
    \   one recvonly -- in lieu of one sendrecv stream.  The data flows in\n   the\
    \ two streams travel in opposite directions, to control receivers\n   configured\
    \ to use different renderers.  In the third example in\n   Appendix C.5, we show\
    \ how the musicport parameter may be used to\n   define virtual sendrecv streams.\n\
    \   As a general rule, the RTP MIDI protocol does not handle parameter\n   changes\
    \ during a session well, because the parameters describe\n   heavyweight or stateful\
    \ configuration that is not easily changed once\n   a session has begun.  Thus,\
    \ parties SHOULD NOT expect that parameter\n   change requests during a session\
    \ will be accepted by other parties.\n   However, implementors SHOULD support\
    \ in-session parameter changes\n   that are easy to handle (for example, the guardtime\
    \ parameter defined\n   in Appendix C.4) and SHOULD be capable of accepting requests\
    \ for\n   changes of those parameters, as received by its session management\n\
    \   protocol (for example, re-offers in SIP [RFC3264]).\n   Appendix D defines\
    \ the Augmented Backus-Naur Form (ABNF, [RFC4234])\n   syntax for the payload\
    \ parameters.  Section 11 provides information\n   to the Internet Assigned Numbers\
    \ Authority (IANA) on the media types\n   and parameters defined in this document.\n\
    \   Appendix C.6.5 defines the media type \"audio/asc\", a stored object\n   for\
    \ initializing mpeg4-generic renderers.  As described in Appendix\n   C.6, the\
    \ audio/asc media type is assigned to the \"rinit\" parameter to\n   specify an\
    \ initialization data object for the default mpeg4-generic\n   renderer.  Note\
    \ that RTP stream semantics are not defined for\n   \"audio/asc\".  Therefore,\
    \ the \"asc\" subtype MUST NOT appear on the\n   rtpmap line of a session description.\n"
- title: 'C.1.  Configuration Tools: Stream Subsetting'
  contents:
  - "C.1.  Configuration Tools: Stream Subsetting\n   As defined in Section 3.2 in\
    \ the main text, the MIDI list of an RTP\n   MIDI packet may encode any MIDI command\
    \ that may legally appear on a\n   MIDI 1.0 DIN cable.\n   In this appendix, we\
    \ define two parameters (cm_unused and cm_used)\n   that modify this default condition,\
    \ by excluding certain types of\n   MIDI commands from the MIDI list of all packets\
    \ in a stream.  For\n   example, if a multimedia session partitions a MIDI name\
    \ space into\n   two RTP MIDI streams, the parameters may be used to define which\n\
    \   commands appear in each stream.\n   In this appendix, we define a simple language\
    \ for specifying MIDI\n   command types.  If a command type is assigned to cm_unused,\
    \ the\n   commands coded by the string MUST NOT appear in the MIDI list.  If a\n\
    \   command type is assigned to cm_used, the commands coded by the string\n  \
    \ MAY appear in the MIDI list.\n   The parameter list may code multiple assignments\
    \ to cm_used and\n   cm_unused.  Assignments have a cumulative effect and are\
    \ applied in\n   the order of appearance in the parameter list.  A later assignment\
    \ of\n   a command type to the same parameter expands the scope of the earlier\n\
    \   assignment.  A later assignment of a command type to the opposite\n   parameter\
    \ cancels (partially or completely) the effect of an earlier\n   assignment.\n\
    \   To initialize the stream subsetting system, \"implicit\" assignments to\n\
    \   cm_unused and cm_used are processed before processing the actual\n   assignments\
    \ that appear in the parameter list.  The System Common\n   undefined commands\
    \ (0xF4, 0xF5) and the System Real-Time Undefined\n   commands (0xF9, 0xFD) are\
    \ implicitly assigned to cm_unused.  All\n   other command types are implicitly\
    \ assigned to cm_used.\n   Note that the implicit assignments code the default\
    \ behavior of an\n   RTP MIDI stream as defined in Section 3.2 in the main text\
    \ (namely,\n   that all commands that may legally appear on a MIDI 1.0 DIN cable\
    \ may\n   appear in the stream).  Also note that assignments of the System\n \
    \  Common undefined commands (0xF4, 0xF5) apply to the use of these\n   commands\
    \ in the MIDI source command stream, not the special use of\n   0xF4 and 0xF5\
    \ in SysEx segment encoding defined in Section 3.2 in the\n   main text.\n   As\
    \ a rule, parameter assignments obey the following syntax (see\n   Appendix D\
    \ for ABNF):\n     <parameter> = [channel list]<command-type list>[field list]\n\
    \   The command-type list is mandatory; the channel and field lists are\n   optional.\n\
    \   The command-type list specifies the MIDI command types for which the\n   parameter\
    \ applies.  The command-type list is a concatenated sequence\n   of one or more\
    \ of the letters (ABCFGHJKMNPQTVWXYZ).  The letters code\n   the following command\
    \ types:\n      o  A: Poly Aftertouch (0xA)\n      o  B: System Reset (0xFF)\n\
    \      o  C: Control Change (0xB)\n      o  F: System Time Code (0xF1)\n     \
    \ o  G: System Tune Request (0xF6)\n      o  H: System Song Select (0xF3)\n  \
    \    o  J: System Common Undefined (0xF4)\n      o  K: System Common Undefined\
    \ (0xF5)\n      o  N: NoteOff (0x8), NoteOn (0x9)\n      o  P: Program Change\
    \ (0xC)\n      o  Q: System Sequencer (0xF2, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC)\n \
    \     o  T: Channel Aftertouch (0xD)\n      o  V: System Active Sense (0xFE)\n\
    \      o  W: Pitch Wheel (0xE)\n      o  X: SysEx (0xF0)\n      o  Y: System Real-Time\
    \ Undefined (0xF9)\n      o  Z: System Real-Time Undefined (0xFD)\n   In addition\
    \ to the letters above, the letter M may also appear in the\n   command-type list.\
    \  The letter M refers to the MIDI parameter system\n   (see definition in Appendix\
    \ A.1 and in [MIDI]).  An assignment of M\n   to cm_unused codes that no RPN or\
    \ NRPN transactions may appear in the\n   MIDI list.\n   Note that if cm_unused\
    \ is assigned the letter M, Control Change (0xB)\n   commands for the controller\
    \ numbers in the standard controller\n   assignment might still appear in the\
    \ MIDI list.  For an explanation,\n   see Appendix A.3.4 for a discussion of the\
    \ \"general-purpose\" use of\n   parameter system controller numbers.\n   In the\
    \ text below, rules that apply to \"MIDI voice channel commands\"\n   also apply\
    \ to the letter M.\n   The letters in the command-type list MUST be uppercase\
    \ and MUST\n   appear in alphabetical order.  Letters other than\n   (ABCFGHJKMNPQTVWXYZ)\
    \ that appear in the list MUST be ignored.\n   For MIDI voice channel commands,\
    \ the channel list specifies the MIDI\n   channels for which the parameter applies.\
    \  If no channel list is\n   provided, the parameter applies to all MIDI channels\
    \ (0-15).  The\n   channel list takes the form of a list of channel numbers (0\
    \ through\n   15) and dash-separated channel number ranges (i.e., 0-5, 8-12, etc).\n\
    \   Dots (i.e., \".\" characters) separate elements in the channel list.\n   Recall\
    \ that System commands do not have a MIDI channel associated\n   with them.  Thus,\
    \ for most command-type letters that code System\n   commands (B, F, G, H, J,\
    \ K, Q, V, Y, and Z), the channel list is\n   ignored.\n   For the command-type\
    \ letter X, the appearance of certain numbers in\n   the channel list codes special\
    \ semantics.\n     o  The digit 0 codes that SysEx \"cancel\" sublists (Section\
    \ 3.2 in\n        the main text) MUST NOT appear in the MIDI list.\n     o  The\
    \ digit 1 codes that cancel sublists MAY appear in the MIDI\n        list (the\
    \ default condition).\n     o  The digit 2 codes that commands other than System\
    \ Real-time MIDI\n        commands MUST NOT appear between SysEx command segments\
    \ in the\n        MIDI list (the default condition).\n     o  The digit 3 codes\
    \ that any MIDI command type may appear between\n        SysEx command segments\
    \ in the MIDI list, with the exception of\n        the segmented encoding of a\
    \ second SysEx command (verbatim SysEx\n        commands are OK).\n   For command-type\
    \ X, the channel list MUST NOT contain both digits 0\n   and 1, and it MUST NOT\
    \ contain both digits 2 and 3.  For command-type\n   X, channel list numbers other\
    \ than the numbers defined above are\n   ignored.  If X does not have a channel\
    \ list, the semantics marked\n   \"the default condition\" in the list above apply.\n\
    \   The syntax for field lists in a parameter assignment follows the\n   syntax\
    \ for channel lists.  If no field list is provided, the\n   parameter applies\
    \ to all controller or note numbers.\n   For command-type C (Control Change),\
    \ the field list codes the\n   controller numbers (0-255) for which the parameter\
    \ applies.\n   For command-type M (Parameter System), the field list codes the\n\
    \   Registered Parameter Numbers (RPNs) and Non-Registered Parameter\n   Numbers\
    \ (NRPNs) for which the parameter applies.  The number range\n   0-16383 specifies\
    \ RPNs, the number range 16384-32767 specifies NRPNs\n   (16384 corresponds to\
    \ NRPN 0, 32767 corresponds to NRPN 16383).\n   For command-types N (NoteOn and\
    \ NoteOff) and A (Poly Aftertouch), the\n   field list codes the note numbers\
    \ for which the parameter applies.\n   For command-types J and K (System Common\
    \ Undefined), the field list\n   consists of a single digit, which specifies the\
    \ number of data octets\n   that follow the command octet.\n   For command-type\
    \ X (SysEx), the field list codes the number of data\n   octets that may appear\
    \ in a SysEx command.  Thus, the field list\n   0-255 specifies SysEx commands\
    \ with 255 or fewer data octets, the\n   field list 256-4294967295 specifies SysEx\
    \ commands with more than 255\n   data octets but excludes commands with 255 or\
    \ fewer data octets, and\n   the field list 0 excludes all commands.\n   A secondary\
    \ parameter assignment syntax customizes command-type X\n   (see Appendix D for\
    \ complete ABNF):\n     <parameter> = \"__\" <h-list> [\"_\" <h-list>] \"__\"\n\
    \   The assignment defines the class of SysEx commands that obeys the\n   semantics\
    \ of the assigned parameter.  The command class is specified\n   by listing the\
    \ permitted values of the first N data octets that\n   follow the SysEx 0xF0 command\
    \ octet.  Any SysEx command whose first N\n   data octets match the list is a\
    \ member of the class.\n   Each <h-list> defines a data octet of the command,\
    \ as a dot-separated\n   (\".\") list of one or more hexadecimal constants (such\
    \ as \"7F\") or\n   dash-separated hexadecimal ranges (such as \"01-1F\").  Underscores\n\
    \   (\"_\") separate each <h-list>.  Double-underscores (\"__\") delineate\n \
    \  the data octet list.\n   Using this syntax, each assignment specifies a single\
    \ SysEx command\n   class.  Session descriptions may use several assignments to\
    \ cm_used\n   and cm_unused to specify complex behaviors.\n   The example session\
    \ description below illustrates the use of the\n   stream subsetting parameters:\n\
    \   v=0\n   o=lazzaro 2520644554 2838152170 IN IP6 first.example.net\n   s=Example\n\
    \   t=0 0\n   m=audio 5004 RTP/AVP 96\n   c=IN IP6 2001:DB80::7F2E:172A:1E24\n\
    \   a=rtpmap:96 rtp-midi/44100\n   a=fmtp:96 cm_unused=ACGHJKNMPTVWXYZ; cm_used=__7F_00-7F_01_01__\n\
    \   The session description configures the stream for use in clock\n   applications.\
    \  All voice channels are unused, as are all System\n   Commands except those\
    \ used for MIDI Time Code (command-type F, and\n   the Full Frame SysEx command\
    \ that is matched by the string assigned\n   to cm_used), the System Sequencer\
    \ commands (command-type Q), and\n   System Reset (command-type B).\n"
- title: 'C.2.  Configuration Tools: The Journalling System'
  contents:
  - "C.2.  Configuration Tools: The Journalling System\n   In this appendix, we define\
    \ the payload format parameters that\n   configure stream journalling and the\
    \ recovery journal system.\n   The j_sec parameter (Appendix C.2.1) sets the journalling\
    \ method for\n   the stream.  The j_update parameter (Appendix C.2.2) sets the\n\
    \   recovery journal sending policy for the stream.  Appendix C.2.2 also\n   defines\
    \ the sending policies of the recovery journal system.\n   Appendix C.2.3 defines\
    \ several parameters that modify the recovery\n   journal semantics.  These parameters\
    \ change the default recovery\n   journal semantics as defined in Section 5 and\
    \ Appendices A-B.\n   The journalling method for a stream is set at the start\
    \ of a session\n   and MUST NOT be changed thereafter.  This requirement forbids\
    \ changes\n   to the j_sec parameter once a session has begun.\n   A related requirement,\
    \ defined in the appendix sections below,\n   forbids the acceptance of parameter\
    \ values that would violate the\n   recovery journal mandate.  In many cases,\
    \ a change in one of the\n   parameters defined in this appendix during an ongoing\
    \ session would\n   result in a violation of the recovery journal mandate for\
    \ an\n   implementation; in this case, the parameter change MUST NOT be\n   accepted.\n"
- title: C.2.1.  The j_sec Parameter
  contents:
  - "C.2.1.  The j_sec Parameter\n   Section 2.2 defines the default journalling method\
    \ for a stream.\n   Streams that use unreliable transport (such as UDP) default\
    \ to using\n   the recovery journal.  Streams that use reliable transport (such\
    \ as\n   TCP) default to not using a journal.\n   The parameter j_sec may be used\
    \ to override this default.  This memo\n   defines two symbolic values for j_sec:\
    \ \"none\", to indicate that all\n   stream payloads MUST NOT contain a journal\
    \ section, and \"recj\", to\n   indicate that all stream payloads MUST contain\
    \ a journal section that\n   uses the recovery journal format.\n   For example,\
    \ the j_sec parameter might be set to \"none\" for a UDP\n   stream that travels\
    \ between two hosts on a local network that is\n   known to provide reliable datagram\
    \ delivery.\n   The session description below configures a UDP stream that does\
    \ not\n   use the recovery journal:\n   v=0\n   o=lazzaro 2520644554 2838152170\
    \ IN IP4 first.example.net\n   s=Example\n   t=0 0\n   m=audio 5004 RTP/AVP 96\n\
    \   c=IN IP4 192.0.2.94\n   a=rtpmap:96 rtp-midi/44100\n   a=fmtp:96 j_sec=none\n\
    \   Other IETF standards-track documents may define alternative journal\n   formats.\
    \  These documents MUST define new symbolic values for the\n   j_sec parameter\
    \ to signal the use of the format.\n   Parties MUST NOT accept a j_sec value that\
    \ violates the recovery\n   journal mandate (see Section 4 for details).  If a\
    \ session\n   description uses a j_sec value unknown to the recipient, the\n \
    \  recipient MUST NOT accept the description.\n   Special j_sec issues arise when\
    \ sessions are managed by session\n   management tools (like RTSP, [RFC2326])\
    \ that use SDP for \"declarative\n   usage\" purposes (see the preamble of Section\
    \ 6 for details).  For\n   these session management tools, SDP does not code transport\
    \ details\n   (such as UDP or TCP) for the session.  Instead, server and client\n\
    \   negotiate transport details via other means (for RTSP, the SETUP\n   method).\n\
    \   In this scenario, the use of the j_sec parameter may be ill-advised,\n   as\
    \ the creator of the session description may not yet know the\n   transport type\
    \ for the session.  In this case, the session\n   description SHOULD configure\
    \ the journalling system using the\n   parameters defined in the remainder of\
    \ Appendix C.2, but it SHOULD\n   NOT use j_sec to set the journalling status.\
    \  Recall that if j_sec\n   does not appear in the session description, the default\
    \ method for\n   choosing the journalling method is in effect (no journal for\
    \ reliable\n   transport, recovery journal for unreliable transport).\n   However,\
    \ in declarative usage situations where the creator of the\n   session description\
    \ knows that journalling is always required or\n   never required, the session\
    \ description SHOULD use the j_sec\n   parameter.\n"
- title: C.2.2.  The j_update Parameter
  contents:
  - "C.2.2.  The j_update Parameter\n   In Section 4, we use the term \"sending policy\"\
    \ to describe the method\n   a sender uses to choose the checkpoint packet identity\
    \ for each\n   recovery journal in a stream.  In the sub-sections that follow,\
    \ we\n   normatively define three sending policies: anchor, closed-loop, and\n\
    \   open-loop.\n   As stated in Section 4, the default sending policy for a stream\
    \ is\n   the closed-loop policy.  The j_update parameter may be used to\n   override\
    \ this default.\n   We define three symbolic values for j_update: \"anchor\",\
    \ to indicate\n   that the stream uses the anchor sending policy, \"open-loop\"\
    , to\n   indicate that the stream uses the open-loop sending policy, and\n   \"\
    closed-loop\", to indicate that the stream uses the closed-loop\n   sending policy.\
    \  See Appendix C.2.3 for examples session descriptions\n   that use the j_update\
    \ parameter.\n   Parties MUST NOT accept a j_update value that violates the recovery\n\
    \   journal mandate (Section 4).\n   Other IETF standards-track documents may\
    \ define additional sending\n   policies for the recovery journal system.  These\
    \ documents MUST\n   define new symbolic values for the j_update parameter to\
    \ signal the\n   use of the new policy.  If a session description uses a j_update\n\
    \   value unknown to the recipient, the recipient MUST NOT accept the\n   description.\n"
- title: C.2.2.1.  The anchor Sending Policy
  contents:
  - "C.2.2.1.  The anchor Sending Policy\n   In the anchor policy, the sender uses\
    \ the first packet in the stream\n   as the checkpoint packet for all packets\
    \ in the stream.  The anchor\n   policy satisfies the recovery journal mandate\
    \ (Section 4), as the\n   checkpoint history always covers the entire stream.\n\
    \   The anchor policy does not require the use of the RTP control\n   protocol\
    \ (RTCP, [RFC3550]) or other feedback from receiver to sender.\n   Senders do\
    \ not need to take special actions to ensure that received\n   streams start up\
    \ free of artifacts, as the recovery journal always\n   covers the entire history\
    \ of the stream.  Receivers are relieved of\n   the responsibility of tracking\
    \ the changing identity of the\n   checkpoint packet, because the checkpoint packet\
    \ never changes.\n   The main drawback of the anchor policy is bandwidth efficiency.\n\
    \   Because the checkpoint history covers the entire stream, the size of\n   the\
    \ recovery journals produced by this policy usually exceeds the\n   journal size\
    \ of alternative policies.  For single-channel MIDI data\n   streams, the bandwidth\
    \ overhead of the anchor policy is often\n   acceptable (see Appendix A.4 of [NMP]).\
    \  For dense streams, the\n   closed-loop or open-loop policies may be more appropriate.\n"
- title: C.2.2.2.  The closed-loop Sending Policy
  contents:
  - "C.2.2.2.  The closed-loop Sending Policy\n   The closed-loop policy is the default\
    \ policy of the recovery journal\n   system.  For each packet in the stream, the\
    \ policy lets senders\n   choose the smallest possible checkpoint history that\
    \ satisfies the\n   recovery journal mandate.  As smaller checkpoint histories\
    \ generally\n   yield smaller recovery journals, the closed-loop policy reduces\
    \ the\n   bandwidth of a stream, relative to the anchor policy.\n   The closed-loop\
    \ policy relies on feedback from receiver to sender.\n   The policy assumes that\
    \ a receiver periodically informs the sender of\n   the highest sequence number\
    \ it has seen so far in the stream, coded\n   in the 32-bit extension format defined\
    \ in [RFC3550].  For RTCP,\n   receivers transmit this information in the Extended\
    \ Highest Sequence\n   Number Received (EHSNR) field of Receiver Reports.  RTCP\
    \ Sender or\n   Receiver Reports MUST be sent by any participant in a session\
    \ with\n   closed loop sending policy, unless another feedback mechanism has\n\
    \   been agreed upon.\n   The sender may safely use receiver sequence number feedback\
    \ to guide\n   checkpoint history management, because Section 4 requires that\n\
    \   receivers repair indefinite artifacts whenever a packet loss event\n   occur.\n\
    \   We now normatively define the closed-loop policy.  At the moment a\n   sender\
    \ prepares an RTP packet for transmission, the sender is aware\n   of R >= 0 receivers\
    \ for the stream.  Senders may become aware of a\n   receiver via RTCP traffic\
    \ from the receiver, via RTP packets from a\n   paired stream sent by the receiver\
    \ to the sender, via messages from a\n   session management tool, or by other\
    \ means.  As receivers join and\n   leave a session, the value of R changes.\n\
    \   Each known receiver k (1 <= k <= R) is associated with a 32-bit\n   extended\
    \ packet sequence number M(k), where the extension reflects\n   the sequence number\
    \ rollover count of the sender.\n   If the sender has received at least one feedback\
    \ report from receiver\n   k, M(k) is the most recent report of the highest RTP\
    \ packet sequence\n   number seen by the receiver, normalized to reflect the rollover\
    \ count\n   of the sender.\n   If the sender has not received a feedback report\
    \ from the receiver,\n   M(k) is the extended sequence number of the last packet\
    \ the sender\n   transmitted before it became aware of the receiver.  If the sender\n\
    \   became aware of this receiver before it sent the first packet in the\n   stream,\
    \ M(k) is the extended sequence number of the first packet in\n   the stream.\n\
    \   Given this definition of M(), we now state the closed-loop policy.\n   When\
    \ preparing a new packet for transmission, a sender MUST choose a\n   checkpoint\
    \ packet with extended sequence number N, such that M(k) >=\n   (N - 1) for all\
    \ k, 1 <= k <= R, where R >= 1.  The policy does not\n   restrict sender behavior\
    \ in the R == 0 (no known receivers) case.\n   Under the closed-loop policy as\
    \ defined above, a sender may transmit\n   packets whose checkpoint history is\
    \ shorter than the session history\n   (as defined in Appendix A.1).  In this\
    \ event, a new receiver that\n   joins the stream may experience indefinite artifacts.\n\
    \   For example, if a Control Change (0xB) command for Channel Volume\n   (controller\
    \ number 7) was sent early in a stream, and later a new\n   receiver joins the\
    \ session, the closed-loop policy may permit all\n   packets sent to the new receiver\
    \ to use a checkpoint history that\n   does not include the Channel Volume Control\
    \ Change command.  As a\n   result, the new receiver experiences an indefinite\
    \ artifact, and\n   plays all notes on a channel too loudly or too softly.\n \
    \  To address this issue, the closed-loop policy states that whenever a\n   sender\
    \ becomes aware of a new receiver, the sender MUST determine if\n   the receiver\
    \ would be subject to indefinite artifacts under the\n   closed-loop policy. \
    \ If so, the sender MUST ensure that the receiver\n   starts the session free\
    \ of indefinite artifacts.\n   For example, to solve the Channel Volume issue\
    \ described above, the\n   sender may code the current state of the Channel Volume\
    \ controller\n   numbers in the recovery journal Chapter C, until it receives\
    \ the\n   first RTCP RR report that signals that a packet containing this\n  \
    \ Chapter C has been received.\n   In satisfying this requirement, senders MAY\
    \ infer the initial MIDI\n   state of the receiver from the session description.\
    \  For example, the\n   stream example in Section 6.2 has the initial state defined\
    \ in [MIDI]\n   for General MIDI.\n   In a unicast RTP session, a receiver may\
    \ safely assume that the\n   sender is aware of its presence of a receiver from\
    \ the first packet\n   sent in the RTP stream.  However, in other types of RTP\
    \ sessions\n   (multicast, conference focus, RTP translator/mixer), a receiver\
    \ is\n   often not able to determine if the sender is initially aware of its\n\
    \   presence as a receiver.\n   To address this issue, the closed-loop policy\
    \ states that if a\n   receiver participates in a session where it may have access\
    \ to a\n   stream whose sender is not aware of the receiver, the receiver MUST\n\
    \   take actions to ensure that its rendered MIDI performance does not\n   contain\
    \ indefinite artifacts.  These protections will be necessarily\n   incomplete.\
    \  For example, a receiver may monitor the Checkpoint\n   Packet Seqnum for uncovered\
    \ loss events, and \"err on the side of\n   caution\" with respect to handling\
    \ stuck notes due to lost MIDI\n   NoteOff commands, but the receiver is not able\
    \ to compensate for the\n   lack of Channel Volume initialization data in the\
    \ recovery journal.\n   The receiver MUST NOT discontinue these protective actions\
    \ until it\n   is certain that the sender is aware of its presence.  If a receiver\n\
    \   is not able to ascertain sender awareness, the receiver MUST continue\n  \
    \ these protective actions for the duration of the session.\n   Note that in a\
    \ multicast session where all parties are expected to\n   send and receive, the\
    \ reception of RTCP receiver reports from the\n   sender about the RTP stream\
    \ a receiver is multicasting is evidence of\n   the sender's awareness that the\
    \ RTP stream multicast by the sender is\n   being monitored by the receiver. \
    \ Receivers may also obtain sender\n   awareness evidence from session management\
    \ tools, or by other means.\n   In practice, ongoing observation of the Checkpoint\
    \ Packet Seqnum to\n   determine if the sender is taking actions to prevent loss\
    \ events for\n   a receiver is a good indication of sender awareness, as is the\
    \ sudden\n   appearance of recovery journal chapters with numerous Control Change\n\
    \   controller data that was not foreshadowed by recent commands coded in\n  \
    \ the MIDI list shortly after sending an RTCP RR.\n   The final set of normative\
    \ closed-loop policy requirements concern\n   how senders and receivers handle\
    \ unplanned disruptions of RTCP\n   feedback from a receiver to a sender.  By\
    \ \"unplanned\", we refer to\n   disruptions that are not due to the signalled\
    \ termination of an RTP\n   stream, via an RTCP BYE or via session management\
    \ tools.\n   As defined earlier in this section, the closed-loop policy states\n\
    \   that a sender MUST choose a checkpoint packet with extended sequence\n   number\
    \ N, such that M(k) >= (N - 1) for all k, 1 <= k <= R, where R\n   >= 1.  If the\
    \ sender has received at least one feedback report from\n   receiver k, M(k) is\
    \ the most recent report of the highest RTP packet\n   sequence number seen by\
    \ the receiver, normalized to reflect the\n   rollover count of the sender.\n\
    \   If this receiver k stops sending feedback to the sender, the M(k)\n   value\
    \ used by the sender reflects the last feedback report from the\n   receiver.\
    \  As time progresses without feedback from receiver k, this\n   fixed M(k) value\
    \ forces the sender to increase the size of the\n   checkpoint history, and thus\
    \ increases the bandwidth of the stream.\n   At some point, the sender may need\
    \ to take action in order to limit\n   the bandwidth of the stream.  In most envisioned\
    \ uses of RTP MIDI,\n   long before this point is reached, the SSRC time-out mechanism\n\
    \   defined in [RFC3550] will remove the uncooperative receiver from the\n   session\
    \ (note that the closed-loop policy does not suggest or require\n   any special\
    \ sender behavior upon an SSRC time-out, other than the\n   sender actions related\
    \ to changing R, described earlier in this\n   section).\n   However, in rare\
    \ situations, the bandwidth of the stream (due to a\n   lack of feedback reports\
    \ from the sender) may become too large to\n   continue sending the stream to\
    \ the receiver before the SSRC time-out\n   occurs for the receiver.  In this\
    \ case, the closed-loop policy states\n   that the sender should invoke the SSRC\
    \ time-out for the receiver\n   early.\n   We now discuss receiver responsibilities\
    \ in the case of unplanned\n   disruptions of RTCP feedback from receiver to sender.\n\
    \   In the unicast case, if a sender invokes the SSRC time-out mechanism\n   for\
    \ a receiver, the receiver stops receiving packets from the sender.\n   The sender\
    \ behavior imposed by the guardtime parameter (Appendix\n   C.4.2) lets the receiver\
    \ conclude that an SSRC time-out has occurred\n   in a reasonable time period.\n\
    \   In this case of a time-out, a receiver MUST keep sending RTCP\n   feedback,\
    \ in order to re-establish the RTP flow from the sender.\n   Unless the receiver\
    \ expects a prompt recovery of the RTP flow, the\n   receiver MUST take actions\
    \ to ensure that the rendered MIDI\n   performance does not exhibit \"very long\
    \ transient artifacts\" (for\n   example, by silencing NoteOns to prevent stuck\
    \ notes) while awaiting\n   reconnection of the flow.\n   In the multicast case,\
    \ if a sender invokes the SSRC time-out\n   mechanism for a receiver, the receiver\
    \ may continue to receive\n   packets, but the sender will no longer be using\
    \ the M(k) feedback\n   from the receiver to choose each checkpoint packet.  If\
    \ the receiver\n   does not have additional information that precludes an SSRC\
    \ time-out\n   (such as RTCP Receiver Reports from the sender about an RTP stream\n\
    \   the receiver is multicasting back to the sender), the receiver MUST\n   monitor\
    \ the Checkpoint Packet Seqnum to detect an SSRC time-out.  If\n   an SSRC time-out\
    \ is detected, the receiver MUST follow the\n   instructions for SSRC time-outs\
    \ described for the unicast case above.\n   Finally, we note that the closed-loop\
    \ policy is suitable for use in\n   RTP/RTCP sessions that use multicast transport.\
    \  However, aspects of\n   the closed-loop policy do not scale well to sessions\
    \ with large\n   numbers of participants.  The sender state scales linearly with\
    \ the\n   number of receivers, as the sender needs to track the identity and\n\
    \   M(k) value for each receiver k.  The average recovery journal size is\n  \
    \ not independent of the number of receivers, as the RTCP reporting\n   interval\
    \ backoff slows down the rate of a full update of M(k) values.\n   The backoff\
    \ algorithm may also increase the amount of ancillary state\n   used by implementations\
    \ of the normative sender and receiver\n   behaviors defined in Section 4.\n"
- title: C.2.2.3.  The open-loop Sending Policy
  contents:
  - "C.2.2.3.  The open-loop Sending Policy\n   The open-loop policy is suitable for\
    \ sessions that are not able to\n   implement the receiver-to-sender feedback\
    \ required by the closed-loop\n   policy, and that are also not able to use the\
    \ anchor policy because\n   of bandwidth constraints.\n   The open-loop policy\
    \ does not place constraints on how a sender\n   chooses the checkpoint packet\
    \ for each packet in the stream.  In the\n   absence of such constraints, a receiver\
    \ may find that the recovery\n   journal in the packet that ends a loss event\
    \ has a checkpoint history\n   that does not cover the entire loss event.  We\
    \ refer to loss events\n   of this type as uncovered loss events.\n   To ensure\
    \ that uncovered loss events do not compromise the recovery\n   journal mandate,\
    \ the open-loop policy assigns specific recovery tasks\n   to senders, receivers,\
    \ and the creators of session descriptions.  The\n   underlying premise of the\
    \ open-loop policy is that the indefinite\n   artifacts produced during uncovered\
    \ loss events fall into two\n   classes.\n   One class of artifacts is recoverable\
    \ indefinite artifacts.\n   Receivers are able to repair recoverable artifacts\
    \ that occur during\n   an uncovered loss event without intervention from the\
    \ sender, at the\n   potential cost of unpleasant transient artifacts.\n   For\
    \ example, after an uncovered loss event, receivers are able to\n   repair indefinite\
    \ artifacts due to NoteOff (0x8) commands that may\n   have occurred during the\
    \ loss event, by executing NoteOff commands\n   for all active NoteOns commands.\
    \  This action causes a transient\n   artifact (a sudden silent period in the\
    \ performance), but ensures\n   that no stuck notes sound indefinitely.  We refer\
    \ to MIDI commands\n   that are amenable to repair in this fashion as recoverable\
    \ MIDI\n   commands.\n   A second class of artifacts is unrecoverable indefinite\
    \ artifacts.\n   If this class of artifact occurs during an uncovered loss event,\
    \ the\n   receiver is not able to repair the stream.\n   For example, after an\
    \ uncovered loss event, receivers are not able to\n   repair indefinite artifacts\
    \ due to Control Change (0xB) Channel\n   Volume (controller number 7) commands\
    \ that have occurred during the\n   loss event.  A repair is impossible because\
    \ the receiver has no way\n   of determining the data value of a lost Channel\
    \ Volume command.  We\n   refer to MIDI commands that are fragile in this way\
    \ as unrecoverable\n   MIDI commands.\n   The open-loop policy does not specify\
    \ how to partition the MIDI\n   command set into recoverable and unrecoverable\
    \ commands.  Instead, it\n   assumes that the creators of the session descriptions\
    \ are able to\n   come to agreement on a suitable recoverable/unrecoverable MIDI\n\
    \   command partition for an application.\n   Given these definitions, we now\
    \ state the normative requirements for\n   the open-loop policy.\n   In the open-loop\
    \ policy, the creators of the session description MUST\n   use the ch_anchor parameter\
    \ (defined in Appendix C.2.3) to protect\n   all unrecoverable MIDI command types\
    \ from indefinite artifacts, or\n   alternatively MUST use the cm_unused parameter\
    \ (defined in Appendix\n   C.1) to exclude the command types from the stream.\
    \  These options act\n   to shield command types from artifacts during an uncovered\
    \ loss\n   event.\n   In the open-loop policy, receivers MUST examine the Checkpoint\
    \ Packet\n   Seqnum field of the recovery journal header after every loss event,\n\
    \   to check if the loss event is an uncovered loss event.  Section 5\n   shows\
    \ how to perform this check.  If an uncovered loss event has\n   occurred, a receiver\
    \ MUST perform indefinite artifact recovery for\n   all MIDI command types that\
    \ are not shielded by ch_anchor and\n   cm_unused parameter assignments in the\
    \ session description.\n   The open-loop policy does not place specific constraints\
    \ on the\n   sender.  However, the open-loop policy works best if the sender\n\
    \   manages the size of the checkpoint history to ensure that uncovered\n   losses\
    \ occur infrequently, by taking into account the delay and loss\n   characteristics\
    \ of the network.  Also, as each checkpoint packet\n   change incurs the risk\
    \ of an uncovered loss, senders should only move\n   the checkpoint if it reduces\
    \ the size of the journal.\n"
- title: C.2.3.  Recovery Journal Chapter Inclusion Parameters
  contents:
  - "C.2.3.  Recovery Journal Chapter Inclusion Parameters\n   The recovery journal\
    \ chapter definitions (Appendices A-B) specify\n   under what conditions a chapter\
    \ MUST appear in the recovery journal.\n   In most cases, the definition states\
    \ that if a certain command\n   appears in the checkpoint history, a certain chapter\
    \ type MUST appear\n   in the recovery journal to protect the command.\n   In\
    \ this section, we describe the chapter inclusion parameters.  These\n   parameters\
    \ modify the conditions under which a chapter appears the\n   journal.  These\
    \ parameters are essential to the use of the open-loop\n   policy (Appendix C.2.2.3)\
    \ and may also be used to simplify\n   implementations of the closed-loop (Appendix\
    \ C.2.2.2) and anchor\n   (Appendix C.2.2.1) policies.\n   Each parameter represents\
    \ a type of chapter inclusion semantics.  An\n   assignment to a parameter declares\
    \ which chapters (or chapter\n   subsets) obey the inclusion semantics.  We describe\
    \ the assignment\n   syntax for these parameters later in this section.\n   A\
    \ party MUST NOT accept chapter inclusion parameter values that\n   violate the\
    \ recovery journal mandate (Section 4).  All assignments of\n   the subsetting\
    \ parameters (cm_used and cm_unused) MUST precede the\n   first assignment of\
    \ a chapter inclusion parameter in the parameter\n   list.\n   Below, we normatively\
    \ define the semantics of the chapter inclusion\n   parameters.  For clarity,\
    \ we define the action of parameters on\n   complete chapters.  If a parameter\
    \ is assigned a subset of a chapter,\n   the definition applies only to the chapter\
    \ subset.\n     o  ch_never.  A chapter assigned to the ch_never parameter MUST\
    \ NOT\n        appear in the recovery journal (Appendix A.4.1-2 defines\n    \
    \    exceptions to this rule for Chapter M).  To signal the exclusion\n      \
    \  of a chapter from the journal, an assignment to ch_never MUST be\n        made,\
    \ even if the commands coded by the chapter are assigned to\n        cm_unused.\
    \  This rule simplifies the handling of commands types\n        that may be coded\
    \ in several chapters.\n     o  ch_default.  A chapter assigned to the ch_default\
    \ parameter MUST\n        follow the default semantics for the chapter, as defined\
    \ in\n        Appendices A-B.\n     o  ch_anchor.  A chapter assigned to the ch_anchor\
    \ MUST obey a\n        modified version of the default chapter semantics.  In\
    \ the\n        modified semantics, all references to the checkpoint history are\n\
    \        replaced with references to the session history, and all\n        references\
    \ to the checkpoint packet are replaced with references\n        to the first\
    \ packet sent in the stream.\n   Parameter assignments obey the following syntax\
    \ (see Appendix D for\n   ABNF):\n     <parameter> = [channel list]<chapter list>[field\
    \ list]\n   The chapter list is mandatory; the channel and field lists are\n \
    \  optional.  Multiple assignments to parameters have a cumulative\n   effect\
    \ and are applied in the order of parameter appearance in a\n   media description.\n\
    \   To determine the semantics of a list of chapter inclusion parameter\n   assignments,\
    \ we begin by assuming an implicit assignment of all\n   channel and system chapters\
    \ to the ch_default parameter, with the\n   default values for the channel list\
    \ and field list for each chapter\n   that are defined below.\n   We then interpret\
    \ the semantics of the actual parameter assignments,\n   using the rules below.\n\
    \   A later assignment of a chapter to the same parameter expands the\n   scope\
    \ of the earlier assignment.  In most cases, a later assignment\n   of a chapter\
    \ to a different parameter cancels (partially or\n   completely) the effect of\
    \ an earlier assignment.\n   The chapter list specifies the channel or system\
    \ chapters for which\n   the parameter applies.  The chapter list is a concatenated\
    \ sequence\n   of one or more of the letters corresponding to the chapter types\n\
    \   (ACDEFMNPQTVWX).  In addition, the list may contain one or more of\n   the\
    \ letters for the sub-chapter types (BGHJKYZ) of System Chapter D.\n   The letters\
    \ in a chapter list MUST be uppercase and MUST appear in\n   alphabetical order.\
    \  Letters other than (ABCDEFGHJKMNPQTVWXYZ) that\n   appear in the chapter list\
    \ MUST be ignored.\n   The channel list specifies the channel journals for which\
    \ this\n   parameter applies; if no channel list is provided, the parameter\n\
    \   applies to all channel journals.  The channel list takes the form of\n   a\
    \ list of channel numbers (0 through 15) and dash-separated channel\n   number\
    \ ranges (i.e., 0-5, 8-12, etc.).  Dots (i.e., \".\" characters)\n   separate\
    \ elements in the channel list.\n   Several of the systems chapters may be configured\
    \ to have special\n   semantics.  Configuration occurs by specifying a channel\
    \ list for the\n   systems channel, using the coding described below (note that\
    \ MIDI\n   Systems commands do not have a \"channel\", and thus the original\n\
    \   purpose of the channel list does not apply to systems chapters).  The\n  \
    \ expression \"the digit N\" in the text below refers to the inclusion of\n  \
    \ N as a \"channel\" in the channel list for a systems chapter.\n   For the J\
    \ and K Chapter D sub-chapters (undefined System Common), the\n   digit 0 codes\
    \ that the parameter applies to the LEGAL field of the\n   associated command\
    \ log (Figure B.1.4 of Appendix B.1), the digit 1\n   codes that the parameter\
    \ applies to the VALUE field of the command\n   log, and the digit 2 codes that\
    \ the parameter applies to the COUNT\n   field of the command log.\n   For the\
    \ Y and Z Chapter D sub-chapters (undefined System Real-time),\n   the digit 0\
    \ codes that the parameter applies to the LEGAL field of\n   the associated command\
    \ log (Figure B.1.5 of Appendix B.1) and the\n   digit 1 codes that the parameter\
    \ applies to the COUNT field of the\n   command log.\n   For Chapter Q (Sequencer\
    \ State Commands), the digit 0 codes that the\n   parameter applies to the default\
    \ Chapter Q definition, which forbids\n   the TIME field.  The digit 1 codes that\
    \ the parameter applies to the\n   optional Chapter Q definition, which supports\
    \ the TIME field.\n   The syntax for field lists follows the syntax for channel\
    \ lists.  If\n   no field list is provided, the parameter applies to all controller\
    \ or\n   note numbers.  For Chapter C, if no field list is provided, the\n   controller\
    \ numbers do not use enhanced Chapter C encoding (Appendix\n   A.3.3).\n   For\
    \ Chapter C, the field list may take on values in the range 0 to\n   255.  A field\
    \ value X in the range 0-127 refers to a controller\n   number X, and indicates\
    \ that the controller number does not use\n   enhanced Chapter C encoding.  A\
    \ field value X in the range 128-255\n   refers to a controller number \"X minus\
    \ 128\" and indicates the\n   controller number does use the enhanced Chapter\
    \ C encoding.\n   Assignments made to configure the Chapter C encoding method\
    \ for a\n   controller number MUST be made to the ch_default or ch_anchor\n  \
    \ parameters, as assignments to ch_never act to exclude the number from\n   the\
    \ recovery journal (and thus the indicated encoding method is\n   irrelevant).\n\
    \   A Chapter C field list MUST NOT encode conflicting information about\n   the\
    \ enhanced encoding status of a particular controller number.  For\n   example,\
    \ values 0 and 128 MUST NOT both be coded by a field list.\n   For Chapter M,\
    \ the field list codes the Registered Parameter Numbers\n   (RPNs) and Non-Registered\
    \ Parameter Numbers (NRPNs) for which the\n   parameter applies.  The number range\
    \ 0-16383 specifies RPNs, the\n   number range 16384-32767 specifies NRPNs (16384\
    \ corresponds to NRPN\n   0, 32767 corresponds to NRPN 16383).\n   For Chapters\
    \ N and A, the field list codes the note numbers for which\n   the parameter applies.\
    \  The note number range specified for Chapter N\n   also applies to Chapter E.\n\
    \   For Chapter E, the digit 0 codes that the parameter applies to\n   Chapter\
    \ E note logs whose V bit is set to 0, and the digit 1 codes\n   that the parameter\
    \ applies to note logs whose V bit is set to 1.\n   For Chapter X, the field list\
    \ codes the number of data octets that\n   may appear in a SysEx command that\
    \ is coded in the chapter.  Thus,\n   the field list 0-255 specifies SysEx commands\
    \ with 255 or fewer data\n   octets, the field list 256-4294967295 specifies SysEx\
    \ commands with\n   more than 255 data octets but excludes commands with 255 or\
    \ fewer\n   data octets, and the field list 0 excludes all commands.\n   A secondary\
    \ parameter assignment syntax customizes Chapter X (see\n   Appendix D for complete\
    \ ABNF):\n     <parameter> = \"__\" <h-list> [\"_\" <h-list>] \"__\"\n   The assignment\
    \ defines a class of SysEx commands whose Chapter X\n   coding obeys the semantics\
    \ of the assigned parameter.  The command\n   class is specified by listing the\
    \ permitted values of the first N\n   data octets that follow the SysEx 0xF0 command\
    \ octet.  Any SysEx\n   command whose first N data octets match the list is a\
    \ member of the\n   class.\n   Each <h-list> defines a data octet of the command,\
    \ as a dot-separated\n   (\".\") list of one or more hexadecimal constants (such\
    \ as \"7F\") or\n   dash-separated hexadecimal ranges (such as \"01-1F\").  Underscores\n\
    \   (\"_\") separate each <h-list>.  Double-underscores (\"__\") delineate\n \
    \  the data octet list.\n   Using this syntax, each assignment specifies a single\
    \ SysEx command\n   class.  Session descriptions may use several assignments to\
    \ the same\n   (or different) parameters to specify complex Chapter X behaviors.\n\
    \   The ordering behavior of multiple assignments follows the guidelines\n   for\
    \ chapter parameter assignments described earlier in this section.\n   The example\
    \ session description below illustrates the use of the\n   chapter inclusion parameters:\n\
    \   v=0\n   o=lazzaro 2520644554 2838152170 IN IP6 first.example.net\n   s=Example\n\
    \   t=0 0\n   m=audio 5004 RTP/AVP 96\n   c=IN IP6 2001:DB80::7F2E:172A:1E24\n\
    \   a=rtpmap:96 rtp-midi/44100\n   a=fmtp:96 j_update=open-loop; cm_unused=ABCFGHJKMQTVWXYZ;\n\
    \   cm_used=__7E_00-7F_09_01.02.03__;\n   cm_used=__7F_00-7F_04_01.02__; cm_used=C7.64;\n\
    \   ch_never=ABCDEFGHJKMQTVWXYZ; ch_never=4.11-13N;\n   ch_anchor=P; ch_anchor=C7.64;\n\
    \   ch_anchor=__7E_00-7F_09_01.02.03__;\n   ch_anchor=__7F_00-7F_04_01.02__\n\
    \   (The a=fmtp line has been wrapped to fit the page to accommodate\n    memo\
    \ formatting restrictions; it comprises a single line in SDP.)\n   The j_update\
    \ parameter codes that the stream uses the open-loop\n   policy.  Most MIDI command-types\
    \ are assigned to cm_unused and thus\n   do not appear in the stream.  As a consequence,\
    \ the assignments to\n   the first ch_never parameter reflect that most chapters\
    \ are not in\n   use.\n   Chapter N for several MIDI channels is assigned to ch_never.\
    \  Chapter\n   N for MIDI channels other than 4, 11, 12, and 13 may appear in\
    \ the\n   recovery journal, using the (default) ch_default semantics.  In\n  \
    \ practice, this assignment pattern would reflect knowledge about a\n   resilient\
    \ rendering method in use for the excluded channels.\n   The MIDI Program Change\
    \ command and several MIDI Control Change\n   controller numbers are assigned\
    \ to ch_anchor.  Note that the ordering\n   of the ch_anchor chapter C assignment\
    \ after the ch_never command acts\n   to override the ch_never assignment for\
    \ the listed controller numbers\n   (7 and 64).\n   The assignment of command-type\
    \ X to cm_unused excludes most SysEx\n   commands from the stream.  Exceptions\
    \ are made for General MIDI\n   System On/Off commands and for the Master Volume\
    \ and Balance\n   commands, via the use of the secondary assignment syntax.  The\n\
    \   cm_used assignment codes the exception, and the ch_anchor assignment\n   codes\
    \ how these commands are protected in Chapter X.\n"
- title: 'C.3.  Configuration Tools: Timestamp Semantics'
  contents:
  - "C.3.  Configuration Tools: Timestamp Semantics\n   The MIDI command section of\
    \ the payload format consists of a list of\n   commands, each with an associated\
    \ timestamp.  The semantics of\n   command timestamps may be set during session\
    \ configuration, using the\n   parameters we describe in this section\n   The\
    \ parameter \"tsmode\" specifies the timestamp semantics for a\n   stream.  The\
    \ parameter takes on one of three token values: \"comex\",\n   \"async\", or \"\
    buffer\".\n   The default \"comex\" value specifies that timestamps code the\n\
    \   execution time for a command (Appendix C.3.1) and supports the\n   accurate\
    \ transcoding Standard MIDI Files (SMFs, [MIDI]).  The \"comex\"\n   value is\
    \ also RECOMMENDED for new MIDI user-interface controller\n   designs.  The \"\
    async\" value specifies an asynchronous timestamp\n   sampling algorithm for time-of-arrival\
    \ sources (Appendix C.3.2).  The\n   \"buffer\" value specifies a synchronous\
    \ timestamp sampling algorithm\n   (Appendix C.3.3) for time-of-arrival sources.\n\
    \   Ancillary parameters MAY follow tsmode in a media description.  We\n   define\
    \ these parameters in Appendices C.3.2-3 below.\n"
- title: C.3.1.  The comex Algorithm
  contents:
  - "C.3.1.  The comex Algorithm\n   The default \"comex\" (COMmand EXecution) tsmode\
    \ value specifies the\n   execution time for the command.  With comex, the difference\
    \ between\n   two timestamps indicates the time delay between the execution of\
    \ the\n   commands.  This difference may be zero, coding simultaneous\n   execution.\n\
    \   The comex interpretation of timestamps works well for transcoding a\n   Standard\
    \ MIDI File (SMF, [MIDI]) into an RTP MIDI stream, as SMFs\n   code a timestamp\
    \ for each MIDI command stored in the file.  To\n   transcode an SMF that uses\
    \ metric time markers, use the SMF tempo map\n   (encoded in the SMF as meta-events)\
    \ to convert metric SMF timestamp\n   units into seconds-based RTP timestamp units.\n\
    \   New MIDI controller designs (piano keyboard, drum pads, etc.) that\n   support\
    \ RTP MIDI and that have direct access to sensor data SHOULD\n   use comex interpretation\
    \ for timestamps, so that simultaneous\n   gestural events may be accurately coded\
    \ by RTP MIDI.\n   Comex is a poor choice for transcoding MIDI 1.0 DIN cables\
    \ [MIDI],\n   for a reason that we will now explain.  A MIDI DIN cable is an\n\
    \   asynchronous serial protocol (320 microseconds per MIDI byte).  MIDI\n   commands\
    \ on a DIN cable are not tagged with timestamps.  Instead,\n   MIDI DIN receivers\
    \ infer command timing from the time of arrival of\n   the bytes.  Thus, two two-byte\
    \ MIDI commands that occur at a source\n   simultaneously are encoded on a MIDI\
    \ 1.0 DIN cable with a 640\n   microsecond time offset.  A MIDI DIN receiver is\
    \ unable to tell if\n   this time offset existed in the source performance or\
    \ is an artifact\n   of the serial speed of the cable.  However, the RTP MIDI\
    \ comex\n   interpretation of timestamps declares that a timestamp offset between\n\
    \   two commands reflects the timing of the source performance.\n   This semantic\
    \ mismatch is the reason that comex is a poor choice for\n   transcoding MIDI\
    \ DIN cables.  Note that the choice of the RTP\n   timestamp rate (Section 6.1-2\
    \ in the main text) cannot fix this\n   inaccuracy issue.  In the sections that\
    \ follow, we describe two\n   alternative timestamp interpretations (\"async\"\
    \ and \"buffer\") that are\n   a better match to MIDI 1.0 DIN cable timing, and\
    \ to other MIDI time-\n   of-arrival sources.\n   The \"octpos\", \"linerate\"\
    , and \"mperiod\" ancillary parameters (defined\n   below) SHOULD NOT be used\
    \ with comex.\n"
- title: C.3.2.  The async Algorithm
  contents:
  - "C.3.2.  The async Algorithm\n   The \"async\" tsmode value specifies the asynchronous\
    \ sampling of a\n   MIDI time-of-arrival source.  In asynchronous sampling, the\
    \ moment an\n   octet is received from a source, it is labelled with a wall-clock\n\
    \   time value.  The time value has RTP timestamp units.\n   The \"octpos\" ancillary\
    \ parameter defines how RTP command timestamps\n   are derived from octet time\
    \ values.  If octpos has the token value\n   \"first\", a timestamp codes the\
    \ time value of the first octet of the\n   command.  If octpos has the token value\
    \ \"last\", a timestamp codes the\n   time value of the last octet of the command.\
    \  If the octpos parameter\n   does not appear in the media description, the sender\
    \ does not know\n   which octet of the command the timestamp references (for example,\
    \ the\n   sender may be relying on an operating system service that does not\n\
    \   specify this information).\n   The octpos semantics refer to the first or\
    \ last octet of a command as\n   it appears on a time-of-arrival MIDI source,\
    \ not as it appears in an\n   RTP MIDI packet.  This distinction is significant\
    \ because the RTP\n   coding may contain octets that are not present in the source.\
    \  For\n   example, the status octet of the first MIDI command in a packet may\n\
    \   have been added to the MIDI stream during transcoding, to comply with\n  \
    \ the RTP MIDI running status requirements (Section 3.2).\n   The \"linerate\"\
    \ ancillary parameter defines the timespan of one MIDI\n   octet on the transmission\
    \ medium of the MIDI source to be sampled\n   (such as a MIDI 1.0 DIN cable).\
    \  The parameter has units of\n   nanoseconds, and takes on integral values. \
    \ For MIDI 1.0 DIN cables,\n   the correct linerate value is 320000 (this value\
    \ is also the default\n   value for the parameter).\n   We now show a session\
    \ description example for the async algorithm.\n   Consider a sender that is transcoding\
    \ a MIDI 1.0 DIN cable source\n   into RTP.  The sender runs on a computing platform\
    \ that assigns time\n   values to every incoming octet of the source, and the\
    \ sender uses the\n   time values to label the first octet of each command in\
    \ the RTP\n   packet.  This session description describes the transcoding:\n \
    \  v=0\n   o=lazzaro 2520644554 2838152170 IN IP4 first.example.net\n   s=Example\n\
    \   t=0 0\n   m=audio 5004 RTP/AVP 96\n   c=IN IP4 192.0.2.94\n   a=rtpmap:96\
    \ rtp-midi/44100\n   a=sendonly\n   a=fmtp:96 tsmode=async; linerate=320000; octpos=first\n"
- title: C.3.3.  The buffer Algorithm
  contents:
  - "C.3.3.  The buffer Algorithm\n   The \"buffer\" tsmode value specifies the synchronous\
    \ sampling of a\n   MIDI time-of-arrival source.\n   In synchronous sampling,\
    \ octets received from a source are placed in\n   a holding buffer upon arrival.\
    \  At periodic intervals, the RTP sender\n   examines the buffer.  The sender\
    \ removes complete commands from the\n   buffer and codes those commands in an\
    \ RTP packet.  The command\n   timestamp codes the moment of buffer examination,\
    \ expressed in RTP\n   timestamp units.  Note that several commands may have the\
    \ same\n   timestamp value.\n   The \"mperiod\" ancillary parameter defines the\
    \ nominal periodic\n   sampling interval.  The parameter takes on positive integral\
    \ values\n   and has RTP timestamp units.\n   The \"octpos\" ancillary parameter,\
    \ defined in Appendix C.3.1 for\n   asynchronous sampling, plays a different role\
    \ in synchronous\n   sampling.  In synchronous sampling, the parameter specifies\
    \ the\n   timestamp semantics of a command whose octets span several sampling\n\
    \   periods.\n   If octpos has the token value \"first\", the timestamp reflects\
    \ the\n   arrival period of the first octet of the command.  If octpos has the\n\
    \   token value \"last\", the timestamp reflects the arrival period of the\n \
    \  last octet of the command.  The octpos semantics refer to the first\n   or\
    \ last octet of the command as it appears on a time-of-arrival\n   source, not\
    \ as it appears in the RTP packet.\n   If the octpos parameter does not appear\
    \ in the media description, the\n   timestamp MAY reflect the arrival period of\
    \ any octet of the command;\n   senders use this option to signal a lack of knowledge\
    \ about the\n   timing details of the buffering process at sub-command granularity.\n\
    \   We now show a session description example for the buffer algorithm.\n   Consider\
    \ a sender that is transcoding a MIDI 1.0 DIN cable source\n   into RTP.  The\
    \ sender runs on a computing platform that places source\n   data into a buffer\
    \ upon receipt.  The sender polls the buffer 1000\n   times a second, extracts\
    \ all complete commands from the buffer, and\n   places the commands in an RTP\
    \ packet.  This session description\n   describes the transcoding:\n   v=0\n \
    \  o=lazzaro 2520644554 2838152170 IN IP6 first.example.net\n   s=Example\n  \
    \ t=0 0\n   m=audio 5004 RTP/AVP 96\n   c=IN IP6 2001:DB80::7F2E:172A:1E24\n \
    \  a=rtpmap:96 rtp-midi/44100\n   a=sendonly\n   a=fmtp:96 tsmode=buffer; linerate=320000;\
    \ octpos=last; mperiod=44\n   The mperiod value of 44 is derived by dividing the\
    \ clock rate\n   specified by the rtpmap attribute (44100 Hz) by the 1000 Hz buffer\n\
    \   sampling rate and rounding to the nearest integer.  Command\n   timestamps\
    \ might not increment by exact multiples of 44, as the\n   actual sampling period\
    \ might not precisely match the nominal mperiod\n   value.\n"
- title: 'C.4.  Configuration Tools: Packet Timing Tools'
  contents:
  - "C.4.  Configuration Tools: Packet Timing Tools\n   In this appendix, we describe\
    \ session configuration tools for\n   customizing the temporal behavior of MIDI\
    \ stream packets.\n"
- title: C.4.1.  Packet Duration Tools
  contents:
  - "C.4.1.  Packet Duration Tools\n   Senders control the granularity of a stream\
    \ by setting the temporal\n   duration (\"media time\") of the packets in the\
    \ stream.  Short media\n   times (20 ms or less) often imply an interactive session.\
    \  Longer\n   media times (100 ms or more) usually indicate a content streaming\n\
    \   session.  The RTP AVP profile [RFC3551] recommends audio packet media\n  \
    \ times in a range from 0 to 200 ms.\n   By default, an RTP receiver dynamically\
    \ senses the media time of\n   packets in a stream and chooses the length of its\
    \ playout buffer to\n   match the stream.  A receiver typically sizes its playout\
    \ buffer to\n   fit several audio packets and adjusts the buffer length to reflect\n\
    \   the network jitter and the sender timing fidelity.\n   Alternatively, the\
    \ packet media time may be statically set during\n   session configuration.  Session\
    \ descriptions MAY use the RTP MIDI\n   parameter \"rtp_ptime\" to set the recommended\
    \ media time for a packet.\n   Session descriptions MAY also use the RTP MIDI\
    \ parameter\n   \"rtp_maxptime\" to set the maximum media time for a packet permitted\n\
    \   in a stream.  Both parameters MAY be used together to configure a\n   stream.\n\
    \   The values assigned to the rtp_ptime and rtp_maxptime parameters have\n  \
    \ the units of the RTP timestamp for the stream, as set by the rtpmap\n   attribute\
    \ (see Section 6.1).  Thus, if rtpmap sets the clock rate of\n   a stream to 44100\
    \ Hz, a maximum packet media time of 10 ms is coded\n   by setting rtp_maxptime=441.\
    \  As stated in the Appendix C preamble,\n   the senders and receivers of a stream\
    \ MUST agree on common values for\n   rtp_ptime and rtp_maxptime if the parameters\
    \ appear in the media\n   description for the stream.\n   0 ms is a reasonable\
    \ media time value for MIDI packets and is often\n   used in low-latency interactive\
    \ applications.  In a packet with a 0\n   ms media time, all commands execute\
    \ at the instant they are coded by\n   the packet timestamp.  The session description\
    \ below configures all\n   packets in the stream to have 0 ms media time:\n  \
    \ v=0\n   o=lazzaro 2520644554 2838152170 IN IP4 first.example.net\n   s=Example\n\
    \   t=0 0\n   m=audio 5004 RTP/AVP 96\n   c=IN IP4 192.0.2.94\n   a=rtpmap:96\
    \ rtp-midi/44100\n   a=fmtp:96 rtp_ptime=0; rtp_maxptime=0\n   The session attributes\
    \ ptime and maxptime [RFC4566] MUST NOT be used\n   to configure an RTP MIDI stream.\
    \  Sessions MUST use rtp_ptime in lieu\n   of ptime and MUST use rtp_maxptime\
    \ in lieu of maxptime.  RTP MIDI\n   defines its own parameters for media time\
    \ configuration because 0 ms\n   values for ptime and maxptime are forbidden by\
    \ [RFC3264] but are\n   essential for certain applications of RTP MIDI.\n   See\
    \ the Appendix C.7 examples for additional discussion about using\n   rtp_ptime\
    \ and rtp_maxptime for session configuration.\n"
- title: C.4.2.  The guardtime Parameter
  contents:
  - "C.4.2.  The guardtime Parameter\n   RTP permits a sender to stop sending audio\
    \ packets for an arbitrary\n   period of time during a session.  When sending\
    \ resumes, the RTP\n   sequence number series continues unbroken, and the RTP\
    \ timestamp\n   value reflects the media time silence gap.\n   This RTP feature\
    \ has its roots in telephony, but it is also well\n   matched to interactive MIDI\
    \ sessions, as players may fall silent for\n   several seconds during (or between)\
    \ songs.\n   Certain MIDI applications benefit from a slight enhancement to this\n\
    \   RTP feature.  In interactive applications, receivers may use on-line\n   network\
    \ models to guide heuristics for handling lost and late RTP\n   packets.  These\
    \ models may work poorly if a sender ceases packet\n   transmission for long periods\
    \ of time.\n   Session descriptions may use the parameter \"guardtime\" to set\
    \ a\n   minimum sending rate for a media session.  The value assigned to\n   guardtime\
    \ codes the maximum separation time between two sequential\n   packets, as expressed\
    \ in RTP timestamp units.\n   Typical guardtime values are 500-2000 ms.  This\
    \ value range is not a\n   normative bound, and parties SHOULD be prepared to\
    \ process values\n   outside this range.\n   The congestion control requirements\
    \ for sender implementations\n   (described in Section 8 and [RFC3550]) take precedence\
    \ over the\n   guardtime parameter.  Thus, if the guardtime parameter requests\
    \ a\n   minimum sending rate, but sending at this rate would violate the\n   congestion\
    \ control requirements, senders MUST ignore the guardtime\n   parameter value.\
    \  In this case, senders SHOULD use the lowest minimum\n   sending rate that satisfies\
    \ the congestion control requirements.\n   Below, we show a session description\
    \ that uses the guardtime\n   parameter.\n   v=0\n   o=lazzaro 2520644554 2838152170\
    \ IN IP6 first.example.net\n   s=Example\n   t=0 0\n   m=audio 5004 RTP/AVP 96\n\
    \   c=IN IP6 2001:DB80::7F2E:172A:1E24\n   a=rtpmap:96 rtp-midi/44100\n   a=fmtp:96\
    \ guardtime=44100; rtp_ptime=0; rtp_maxptime=0\n"
- title: 'C.5.  Configuration Tools: Stream Description'
  contents:
  - "C.5.  Configuration Tools: Stream Description\n   As we discussed in Section\
    \ 2.1, a party may send several RTP MIDI\n   streams in the same RTP session,\
    \ and several RTP sessions that carry\n   MIDI may appear in a multimedia session.\n\
    \   By default, the MIDI name space (16 channels + systems) of each RTP\n   stream\
    \ sent by a party in a multimedia session is independent.  By\n   independent,\
    \ we mean three distinct things:\n     o  If a party sends two RTP MIDI streams\
    \ (A and B), MIDI voice\n        channel 0 in stream A is a different \"channel\
    \ 0\" than MIDI voice\n        channel 0 in stream B.\n     o  MIDI voice channel\
    \ 0 in stream B is not considered to be\n        \"channel 16\" of a 32-channel\
    \ MIDI voice channel space whose\n        \"channel 0\" is channel 0 of stream\
    \ A.\n     o  Streams sent by different parties over different RTP sessions,\n\
    \        or over the same RTP session but with different payload type\n      \
    \  numbers, do not share the association that is shared by a MIDI\n        cable\
    \ pair that cross-connects two devices in a MIDI 1.0 DIN\n        network.  By\
    \ default, this association is only held by streams\n        sent by different\
    \ parties in the same RTP session that use the\n        same payload type number.\n\
    \   In this appendix, we show how to express that specific RTP MIDI\n   streams\
    \ in a multimedia session are not independent but instead are\n   related in one\
    \ of the three ways defined above.  We use two tools to\n   express these relations:\n\
    \     o  The musicport parameter.  This parameter is assigned a non-\n       \
    \ negative integer value between 0 and 4294967295.  It appears in\n        the\
    \ fmtp lines of payload types.\n     o  The FID grouping attribute [RFC3388] signals\
    \ that several RTP\n        sessions in a multimedia session are using the musicport\n\
    \        parameter to express an inter-session relationship.\n   If a multimedia\
    \ session has several payload types whose musicport\n   parameters are assigned\
    \ the same integer value, streams using these\n   payload types share an \"identity\
    \ relationship\" (including streams\n   that use the same payload type).  Streams\
    \ in an identity relationship\n   share two properties:\n     o  Identity relationship\
    \ streams sent by the same party target the\n        same MIDI name space.  Thus,\
    \ if streams A and B share an\n        identity relationship, voice channel 0\
    \ in stream A is the same\n        \"channel 0\" as voice channel 0 in stream\
    \ B.\n     o  Pairs of identity relationship streams that are sent by\n      \
    \  different parties share the association that is shared by a MIDI\n        cable\
    \ pair that cross-connects two devices in a MIDI 1.0 DIN\n        network.\n \
    \  A party MUST NOT send two RTP MIDI streams that share an identity\n   relationship\
    \ in the same RTP session.  Instead, each stream MUST be\n   in a separate RTP\
    \ session.  As explained in Section 2.1, this\n   restriction is necessary to\
    \ support the RTP MIDI method for the\n   synchronization of streams that share\
    \ a MIDI name space.\n   If a multimedia session has several payload types whose\
    \ musicport\n   parameters are assigned sequential values (i.e., i, i+1, ... i+k),\n\
    \   the streams using the payload types share an \"ordered relationship\".\n \
    \  For example, if payload type A assigns 2 to musicport and payload\n   type\
    \ B assigns 3 to musicport, A and B are in an ordered\n   relationship.\n   Streams\
    \ in an ordered relationship that are sent by the same party\n   are considered\
    \ by renderers to form a single larger MIDI space.  For\n   example, if stream\
    \ A has a musicport value of 2 and stream B has a\n   musicport value of 3, MIDI\
    \ voice channel 0 in stream B is considered\n   to be voice channel 16 in the\
    \ larger MIDI space formed by the\n   relationship.  Note that it is possible\
    \ for streams to participate in\n   both an identity relationship and an ordered\
    \ relationship.\n   We now state several rules for using musicport:\n     o  If\
    \ streams from several RTP sessions in a multimedia session use\n        the musicport\
    \ parameter, the RTP sessions MUST be grouped using\n        the FID grouping\
    \ attribute defined in [RFC3388].\n     o  An ordered or identity relationship\
    \ MUST NOT contain both native\n        RTP MIDI streams and mpeg4-generic RTP\
    \ MIDI streams.  An\n        exception applies if a relationship consists of sendonly\
    \ and\n        recvonly (but not sendrecv) streams.  In this case, the sendonly\n\
    \        streams MUST NOT contain both types of streams, and the recvonly\n  \
    \      streams MUST NOT contain both types of streams.\n     o  It is possible\
    \ to construct identity relationships that violate\n        the recovery journal\
    \ mandate (for example, sending NoteOns for a\n        voice channel on stream\
    \ A and NoteOffs for the same voice\n        channel on stream B).  Parties MUST\
    \ NOT generate (or accept)\n        session descriptions that exhibit this flaw.\n\
    \     o  Other payload formats MAY define musicport media type\n        parameters.\
    \  Formats would define these parameters so that their\n        sessions could\
    \ be bundled into RTP MIDI name spaces.  The\n        parameter definitions MUST\
    \ be compatible with the musicport\n        semantics defined in this appendix.\n\
    \   As a rule, at most one payload type in a relationship may specify a\n   MIDI\
    \ renderer.  An exception to the rule applies to relationships\n   that contain\
    \ sendonly and recvonly streams but no sendrecv streams.\n   In this case, one\
    \ sendonly session and one recvonly session may each\n   define a renderer.\n\
    \   Renderer specification in a relationship may be done using the tools\n   described\
    \ in Appendix C.6.  These tools work for both native streams\n   and mpeg4-generic\
    \ streams.  An mpeg4-generic stream that uses the\n   Appendix C.6 tools MUST\
    \ set all \"config\" parameters to the empty\n   string (\"\").\n   Alternatively,\
    \ for mpeg4-generic streams, renderer specification may\n   be done by setting\
    \ one \"config\" parameter in the relationship to the\n   renderer configuration\
    \ string, and all other config parameters to the\n   empty string (\"\").\n  \
    \ We now define sender and receiver rules that apply when a party sends\n   several\
    \ streams that target the same MIDI name space.\n   Senders MAY use the subsetting\
    \ parameters (Appendix C.1) to predefine\n   the partitioning of commands between\
    \ streams, or they MAY use a\n   dynamic partitioning strategy.\n   Receivers\
    \ that merge identity relationship streams into a single MIDI\n   command stream\
    \ MUST maintain the structural integrity of the MIDI\n   commands coded in each\
    \ stream during the merging process, in the same\n   way that software that merges\
    \ traditional MIDI 1.0 DIN cable flows is\n   responsible for creating a merged\
    \ command flow compatible with\n   [MIDI].\n   Senders MUST partition the name\
    \ space so that the rendered MIDI\n   performance does not contain indefinite\
    \ artifacts (as defined in\n   Section 4).  This responsibility holds even if\
    \ all streams are sent\n   over reliable transport, as different stream latencies\
    \ may yield\n   indefinite artifacts.  For example, stuck notes may occur in a\n\
    \   performance split over two TCP streams, if NoteOn commands are sent\n   on\
    \ one stream and NoteOff commands are sent on the other.\n   Senders MUST NOT\
    \ split a Registered Parameter Name (RPN) or Non-\n   Registered Parameter Name\
    \ (NRPN) transaction appearing on a MIDI\n   channel across multiple identity\
    \ relationship sessions.  Receivers\n   MUST assume that the RPN/NRPN transactions\
    \ that appear on different\n   identity relationship sessions are independent\
    \ and MUST preserve\n   transactional integrity during the MIDI merge.\n   A simple\
    \ way to safely partition voice channel commands is to place\n   all MIDI commands\
    \ for a particular voice channel into the same\n   session.  Safe partitioning\
    \ of MIDI Systems commands may be more\n   complicated for sessions that extensively\
    \ use System Exclusive.\n   We now show several session description examples that\
    \ use the\n   musicport parameter.\n   Our first session description example shows\
    \ two RTP MIDI streams that\n   drive the same General MIDI decoder.  The sender\
    \ partitions MIDI\n   commands between the streams dynamically.  The musicport\
    \ values\n   indicate that the streams share an identity relationship.\n   v=0\n\
    \   o=lazzaro 2520644554 2838152170 IN IP4 first.example.net\n   s=Example\n \
    \  t=0 0\n   a=group:FID 1 2\n   c=IN IP4 192.0.2.94\n   m=audio 5004 RTP/AVP\
    \ 96\n   a=rtpmap:96 mpeg4-generic/44100\n   a=mid:1\n   a=fmtp:96 streamtype=5;\
    \ mode=rtp-midi; profile-level-id=12;\n   config=7A0A0000001A4D546864000000060000000100604D54726B0\n\
    \   000000600FF2F000; musicport=12\n   m=audio 5006 RTP/AVP 96\n   a=rtpmap:96\
    \ mpeg4-generic/44100\n   a=mid:2\n   a=fmtp:96 streamtype=5; mode=rtp-midi; config=\"\
    \";\n   profile-level-id=12; musicport=12\n   (The a=fmtp lines have been wrapped\
    \ to fit the page to accommodate\n    memo formatting restrictions; they comprise\
    \ single lines in SDP.)\n   Recall that Section 2.1 defines rules for streams\
    \ that target the\n   same MIDI name space.  Those rules, implemented in the example\
    \ above,\n   require that each stream resides in a separate RTP session, and that\n\
    \   the grouping mechanisms defined in [RFC3388] signal an inter-session\n   relationship.\
    \  The \"group\" and \"mid\" attribute lines implement this\n   grouping mechanism.\n\
    \   A variant on this example, whose session description is not shown,\n   would\
    \ use two streams in an identity relationship driving the same\n   MIDI renderer,\
    \ each with a different transport type.  One stream\n   would use UDP and would\
    \ be dedicated to real-time messages.  A second\n   stream would use TCP [RFC4571]\
    \ and would be used for SysEx bulk data\n   messages.\n   In the next example,\
    \ two mpeg4-generic streams form an ordered\n   relationship to drive a Structured\
    \ Audio decoder with 32 MIDI voice\n   channels.  Both streams reside in the same\
    \ RTP session.\n   v=0\n   o=lazzaro 2520644554 2838152170 IN IP6 first.example.net\n\
    \   s=Example\n   t=0 0\n   m=audio 5006 RTP/AVP 96 97\n   c=IN IP6 2001:DB80::7F2E:172A:1E24\n\
    \   a=rtpmap:96 mpeg4-generic/44100\n   a=fmtp:96 streamtype=5; mode=rtp-midi;\
    \ config=\"\";\n   profile-level-id=13; musicport=5\n   a=rtpmap:97 mpeg4-generic/44100\n\
    \   a=fmtp:97 streamtype=5; mode=rtp-midi; config=\"\";\n   profile-level-id=13;\
    \ musicport=6; render=synthetic;\n   rinit=\"audio/asc\";\n   url=\"http://example.com/cardinal.asc\"\
    ;\n   cid=\"azsldkaslkdjqpwojdkmsldkfpe\"\n   (The a=fmtp lines have been wrapped\
    \ to fit the page to accommodate\n    memo formatting restrictions; they comprise\
    \ single lines in SDP.)\n   The sequential musicport values for the two sessions\
    \ establish the\n   ordered relationship.  The musicport=5 session maps to Structured\n\
    \   Audio extended channels range 0-15, the musicport=6 session maps to\n   Structured\
    \ Audio extended channels range 16-31.\n   Both config strings are empty.  The\
    \ configuration data is specified\n   by parameters that appear in the fmtp line\
    \ of the second media\n   description.  We define this configuration method in\
    \ Appendix C.6.\n   The next example shows two RTP MIDI streams (one recvonly,\
    \ one\n   sendonly) that form a \"virtual sendrecv\" session.  Each stream\n \
    \  resides in a different RTP session (a requirement because sendonly\n   and\
    \ recvonly are RTP session attributes).\n   v=0\n   o=lazzaro 2520644554 2838152170\
    \ IN IP4 first.example.net\n   s=Example\n   t=0 0\n   a=group:FID 1 2\n   c=IN\
    \ IP4 192.0.2.94\n   m=audio 5004 RTP/AVP 96\n   a=sendonly\n   a=rtpmap:96 mpeg4-generic/44100\n\
    \   a=mid:1\n   a=fmtp:96 streamtype=5; mode=rtp-midi; profile-level-id=12;\n\
    \   config=7A0A0000001A4D546864000000060000000100604D54726B0\n   000000600FF2F000;\
    \ musicport=12\n   m=audio 5006 RTP/AVP 96\n   a=recvonly\n   a=rtpmap:96 mpeg4-generic/44100\n\
    \   a=mid:2\n   a=fmtp:96 streamtype=5; mode=rtp-midi; profile-level-id=12;\n\
    \   config=7A0A0000001A4D546864000000060000000100604D54726B0\n   000000600FF2F000;\
    \ musicport=12\n   (The a=fmtp lines have been wrapped to fit the page to accommodate\n\
    \    memo formatting restrictions; they comprise single lines in SDP.)\n   To\
    \ signal the \"virtual sendrecv\" semantics, the two streams assign\n   musicport\
    \ to the same value (12).  As defined earlier in this\n   section, pairs of identity\
    \ relationship streams that are sent by\n   different parties share the association\
    \ that is shared by a MIDI\n   cable pair that cross-connects two devices in a\
    \ MIDI 1.0 network.  We\n   use the term \"virtual sendrecv\" because streams\
    \ sent by different\n   parties in a true sendrecv session also have this property.\n\
    \   As discussed in the preamble to Appendix C, the primary advantage of\n   the\
    \ virtual sendrecv configuration is that each party can customize\n   the property\
    \ of the stream it receives.  In the example above, each\n   stream defines its\
    \ own \"config\" string that could customize the\n   rendering algorithm for each\
    \ party (in fact, the particular strings\n   shown in this example are identical,\
    \ because General MIDI is not a\n   configurable MPEG 4 renderer).\n"
- title: 'C.6.  Configuration Tools: MIDI Rendering'
  contents:
  - "C.6.  Configuration Tools: MIDI Rendering\n   This appendix defines the session\
    \ configuration tools for rendering.\n   The \"render\" parameter specifies a\
    \ rendering method for a stream.\n   The parameter is assigned a token value that\
    \ signals the top-level\n   rendering class.  This memo defines four token values\
    \ for render:\n   \"unknown\", \"synthetic\", \"api\", and \"null\":\n     o \
    \ An \"unknown\" renderer is a renderer whose nature is unspecified.\n       \
    \ It is the default renderer for native RTP MIDI streams.\n     o  A \"synthetic\"\
    \ renderer transforms the MIDI stream into audio\n        output (or sometimes\
    \ into stage lighting changes or other\n        actions).  It is the default renderer\
    \ for mpeg4-generic RTP MIDI\n        streams.\n     o  An \"api\" renderer presents\
    \ the command stream to applications\n        via an Application Programmer Interface\
    \ (API).\n     o  The \"null\" renderer discards the MIDI stream.\n   The \"null\"\
    \ render value plays special roles during Offer/Answer\n   negotiations [RFC3264].\
    \  A party uses the \"null\" value in an answer\n   to reject an offered renderer.\
    \  Note that rejecting a renderer is\n   independent from rejecting a payload\
    \ type (coded by removing the\n   payload type from a media line) and rejecting\
    \ a media stream (coded\n   by zeroing the port of a media line that uses the\
    \ renderer).\n   Other render token values MAY be registered with IANA.  The token\n\
    \   value MUST adhere to the ABNF for render tokens defined in Appendix\n   D.\
    \  Registrations MUST include a complete specification of parameter\n   value\
    \ usage, similar in depth to the specifications that appear\n   throughout Appendix\
    \ C.6 for \"synthetic\" and \"api\" render values.  If\n   a party is offered\
    \ a session description that uses a render token\n   value that is not known to\
    \ the party, the party MUST NOT accept the\n   renderer.  Options include rejecting\
    \ the renderer (using the \"null\"\n   value), the payload type, the media stream,\
    \ or the session\n   description.\n   Other parameters MAY follow a render parameter\
    \ in a parameter list.\n   The additional parameters act to define the exact nature\
    \ of the\n   renderer.  For example, the \"subrender\" parameter (defined in\n\
    \   Appendix C.6.2) specifies the exact nature of the renderer.\n   Special rules\
    \ apply to using the render parameter in an mpeg4-generic\n   stream.  We define\
    \ these rules in Appendix C.6.5.\n"
- title: C.6.1.  The multimode Parameter
  contents:
  - "C.6.1.  The multimode Parameter\n   A media description MAY contain several render\
    \ parameters.  By\n   default, if a parameter list includes several render parameters,\
    \ a\n   receiver MUST choose exactly one renderer from the list to render the\n\
    \   stream.  The \"multimode\" parameter may be used to override this\n   default.\
    \  We define two token values for multimode: \"one\" and \"all\":\n     o  The\
    \ default \"one\" value requests rendering by exactly one of the\n        listed\
    \ renderers.\n     o  The \"all\" value requests the synchronized rendering of\
    \ the RTP\n        MIDI stream by all listed renderers, if possible.\n   If the\
    \ multimode parameter appears in a parameter list, it MUST\n   appear before the\
    \ first render parameter assignment.\n   Render parameters appear in the parameter\
    \ list in order of decreasing\n   priority.  A receiver MAY use the priority ordering\
    \ to decide which\n   renderer(s) to retain in a session.\n   If the \"offer\"\
    \ in an Offer/Answer-style negotiation [RFC3264]\n   contains a parameter list\
    \ with one or more render parameters, the\n   \"answer\" MUST set the render parameters\
    \ of all unchosen renderers to\n   \"null\".\n"
- title: C.6.2.  Renderer Specification
  contents:
  - "C.6.2.  Renderer Specification\n   The render parameter (Appendix C.6 preamble)\
    \ specifies, in a broad\n   sense, what a renderer does with a MIDI stream.  In\
    \ this appendix, we\n   describe the \"subrender\" parameter.  The token value\
    \ assigned to\n   subrender defines the exact nature of the renderer.  Thus, \"\
    render\"\n   and \"subrender\" combine to define a renderer, in the same way as\
    \ MIME\n   types and MIME subtypes combine to define a type of media [RFC2045].\n\
    \   If the subrender parameter is used for a renderer definition, it MUST\n  \
    \ appear immediately after the render parameter in the parameter list.\n   At\
    \ most one subrender parameter may appear in a renderer definition.\n   This document\
    \ defines one value for subrender: the value \"default\".\n   The \"default\"\
    \ token specifies the use of the default renderer for the\n   stream type (native\
    \ or mpeg4-generic).  The default renderer for\n   native RTP MIDI streams is\
    \ a renderer whose nature is unspecified\n   (see point 6 in Section 6.1 for details).\
    \  The default renderer for\n   mpeg4-generic RTP MIDI streams is an MPEG 4 Audio\
    \ Object Type whose\n   ID number is 13, 14, or 15 (see Section 6.2 for details).\n\
    \   If a renderer definition does not use the subrender parameter, the\n   value\
    \ \"default\" is assumed for subrender.\n   Other subrender token values may be\
    \ registered with IANA.  We now\n   discuss guidelines for registering subrender\
    \ values.\n   A subrender value is registered for a specific stream type (native\
    \ or\n   mpeg4-generic) and a specific render value (excluding \"null\" and\n\
    \   \"unknown\").  Registrations for mpeg4-generic subrender values are\n   restricted\
    \ to new MPEG 4 Audio Object Types that accept MIDI input.\n   The syntax of the\
    \ token MUST adhere to the token definition in\n   Appendix D.\n   For \"render=synthetic\"\
    \ renderers, a subrender value registration\n   specifies an exact method for\
    \ transforming the MIDI stream into audio\n   (or sometimes into video or control\
    \ actions, such as stage lighting).\n   For standardized renderers, this specification\
    \ is usually a pointer\n   to a standards document, perhaps supplemented by RTP-MIDI-specific\n\
    \   information.  For commercial products and open-source projects, this\n   specification\
    \ usually takes the form of instructions for interfacing\n   the RTP MIDI stream\
    \ with the product or project software.  A\n   \"render=synthetic\" registration\
    \ MAY specify additional Reset State\n   commands for the renderer (Appendix A.1).\n\
    \   A \"render=api\" subrender value registration specifies how an RTP MIDI\n\
    \   stream interfaces with an API (Application Programmers Interface).\n   This\
    \ specification is usually a pointer to programmer's documentation\n   for the\
    \ API, perhaps supplemented by RTP-MIDI-specific information.\n   A subrender\
    \ registration MAY specify an initialization file (referred\n   to in this document\
    \ as an initialization data object) for the stream.\n   The initialization data\
    \ object MAY be encoded in the parameter list\n   (verbatim or by reference) using\
    \ the coding tools defined in Appendix\n   C.6.3.  An initialization data object\
    \ MUST have a registered\n   [RFC4288] media type and subtype [RFC2045].\n   For\
    \ \"render=synthetic\" renderers, the data object usually encodes\n   initialization\
    \ data for the renderer (sample files, synthesis patch\n   parameters, reverberation\
    \ room impulse responses, etc.).\n   For \"render=api\" renderers, the data object\
    \ usually encodes data\n   about the stream used by the API (for example, for\
    \ an RTP MIDI stream\n   generated by a piano keyboard controller, the manufacturer\
    \ and model\n   number of the keyboard, for use in GUI presentation).\n   Usually,\
    \ only one initialization object is encoded for a renderer.\n   If a renderer\
    \ uses multiple data objects, the correct receiver\n   interpretation of multiple\
    \ data objects MUST be defined in the\n   subrender registration.\n   A subrender\
    \ value registration may also specify additional\n   parameters, to appear in\
    \ the parameter list immediately after\n   subrender.  These parameter names MUST\
    \ begin with the subrender\n   value, followed by an underscore (\"_\"), to avoid\
    \ name space\n   collisions with future RTP MIDI parameter names (for example,\
    \ a\n   parameter \"foo_bar\" defined for subrender value \"foo\").\n   We now\
    \ specify guidelines for interpreting the subrender parameter\n   during session\
    \ configuration.\n   If a party is offered a session description that uses a renderer\n\
    \   whose subrender value is not known to the party, the party MUST NOT\n   accept\
    \ the renderer.  Options include rejecting the renderer (using\n   the \"null\"\
    \ value), the payload type, the media stream, or the session\n   description.\n\
    \   Receivers MUST be aware of the Reset State commands (Appendix A.1)\n   for\
    \ the renderer specified by the subrender parameter and MUST insure\n   that the\
    \ renderer does not experience indefinite artifacts due to the\n   presence (or\
    \ the loss) of a Reset State command.\n"
- title: C.6.3.  Renderer Initialization
  contents:
  - "C.6.3.  Renderer Initialization\n   If the renderer for a stream uses an initialization\
    \ data object, an\n   \"rinit\" parameter MUST appear in the parameter list immediately\
    \ after\n   the \"subrender\" parameter.  If the renderer parameter list does\
    \ not\n   include a subrender parameter (recall the semantics for \"default\"\
    \ in\n   Appendix C.6.2), the \"rinit\" parameter MUST appear immediately after\n\
    \   the \"render\" parameter.\n   The value assigned to the rinit parameter MUST\
    \ be the media\n   type/subtype [RFC2045] for the initialization data object.\
    \  If an\n   initialization object type is registered with several media types,\n\
    \   including audio, the assignment to rinit MUST use the audio media\n   type.\n\
    \   RTP MIDI supports several parameters for encoding initialization data\n  \
    \ objects for renderers in the parameter list: \"inline\", \"url\", and\n   \"\
    cid\".\n   If the \"inline\", \"url\", and/or \"cid\" parameters are used by a\n\
    \   renderer, these parameters MUST immediately follow the \"rinit\"\n   parameter.\n\
    \   If a \"url\" parameter appears for a renderer, an \"inline\" parameter\n \
    \  MUST NOT appear.  If an \"inline\" parameter appears for a renderer, a\n  \
    \ \"url\" parameter MUST NOT appear.  However, neither \"url\" or \"inline\"\n\
    \   is required to appear.  If neither \"url\" or \"inline\" parameters\n   follow\
    \ \"rinit\", the \"cid\" parameter MUST follow \"rinit\".\n   The \"inline\" parameter\
    \ supports the inline encoding of the data\n   object.  The parameter is assigned\
    \ a double-quoted Base64 [RFC2045]\n   encoding of the binary data object, with\
    \ no line breaks.  Appendix\n   E.4 shows an example that constructs an inline\
    \ parameter value.\n   The \"url\" parameter is assigned a double-quoted string\
    \ representation\n   of a Uniform Resource Locator (URL) for the data object.\
    \  The string\n   MUST specify a HyperText Transport Protocol URL (HTTP, [RFC2616]).\n\
    \   HTTP MAY be used over TCP or MAY be used over a secure network\n   transport,\
    \ such as the method described in [RFC2818].  The media\n   type/subtype for the\
    \ data object SHOULD be specified in the\n   appropriate HTTP transport header.\n\
    \   The \"cid\" parameter supports data object caching.  The parameter is\n  \
    \ assigned a double-quoted string value that encodes a globally unique\n   identifier\
    \ for the data object.\n   A cid parameter MAY immediately follow an inline parameter,\
    \ in which\n   case the cid identifier value MUST be associated with the inline\
    \ data\n   object.\n   If a url parameter is present, and if the data object for\
    \ the URL is\n   expected to be unchanged for the life of the URL, a cid parameter\
    \ MAY\n   immediately follow the url parameter.  The cid identifier value MUST\n\
    \   be associated with the data object for the URL.  A cid parameter\n   assigned\
    \ to the same identifier value SHOULD be specified following\n   the data object\
    \ type/subtype in the appropriate HTTP transport\n   header.\n   If a url parameter\
    \ is present, and if the data object for the URL is\n   expected to change during\
    \ the life of the URL, a cid parameter MUST\n   NOT follow the url parameter.\
    \  A receiver interprets the presence of\n   a cid parameter as an indication\
    \ that it is safe to use a cached copy\n   of the url data object; the absence\
    \ of a cid parameter is an\n   indication that it is not safe to use a cached\
    \ copy, as it may\n   change.\n   Finally, the cid parameter MAY be used without\
    \ the inline and url\n   parameters.  In this case, the identifier references\
    \ a local or\n   distributed catalog of data objects.\n   In most cases, only\
    \ one data object is coded in the parameter list\n   for each renderer.  For example,\
    \ the default renderer for mpeg4-\n   generic streams uses a single data object\
    \ (see Appendix C.6.5 for\n   example usage).\n   However, a subrender registration\
    \ MAY permit the use of multiple data\n   objects for a renderer.  If multiple\
    \ data objects are encoded for a\n   renderer, each object encoding begins with\
    \ an \"rinit\" parameter,\n   followed by \"inline\", \"url\", and/or \"cid\"\
    \ parameters.\n   Initialization data objects MAY encapsulate a Standard MIDI\
    \ File\n   (SMF).  By default, the SMFs that are encapsulated in a data object\n\
    \   MUST be ignored by an RTP MIDI receiver.  We define parameters to\n   override\
    \ this default in Appendix C.6.4.\n   To end this section, we offer guidelines\
    \ for registering media types\n   for initialization data objects.  These guidelines\
    \ are in addition to\n   the information in [RFC4288] [RFC4289].\n   Some initialization\
    \ data objects are also capable of encoding MIDI\n   note information and thus\
    \ complete audio performances.  These objects\n   SHOULD be registered using the\
    \ \"audio\" media type, so that the\n   objects may also be used for store-and-forward\
    \ rendering, and\n   \"application\" media type, to support editing tools.  Initialization\n\
    \   objects without note storage, or initialization objects for non-audio\n  \
    \ renderers, SHOULD be registered only for an \"application\" media type.\n"
- title: C.6.4.  MIDI Channel Mapping
  contents:
  - "C.6.4.  MIDI Channel Mapping\n   In this appendix, we specify how to map MIDI\
    \ name spaces (16 voice\n   channels + systems) onto a renderer.\n   In the general\
    \ case:\n     o  A session may define an ordered relationship (Appendix C.5) that\n\
    \        presents more than one MIDI name space to a renderer.\n     o  A renderer\
    \ may accept an arbitrary number of MIDI name spaces,\n        or it may expect\
    \ a specific number of MIDI name spaces.\n   A session description SHOULD provide\
    \ a compatible MIDI name space to\n   each renderer in the session.  If a receiver\
    \ detects that a session\n   description has too many or too few MIDI name spaces\
    \ for a renderer,\n   MIDI data from extra stream name spaces MUST be discarded,\
    \ and extra\n   renderer name spaces MUST NOT be driven with MIDI data (except\
    \ as\n   described in Appendix C.6.4.1, below).\n   If a parameter list defines\
    \ several renderers and assigns the \"all\"\n   token value to the multimode parameter,\
    \ the same name space is\n   presented to each renderer.  However, the \"chanmask\"\
    \ parameter may be\n   used to mask out selected voice channels to each renderer.\
    \  We define\n   \"chanmask\" and other MIDI management parameters in the sub-sections\n\
    \   below.\n"
- title: C.6.4.1.  The smf_info Parameter
  contents:
  - "C.6.4.1.  The smf_info Parameter\n   The smf_info parameter defines the use of\
    \ the SMFs encapsulated in\n   renderer data objects (if any).  The smf_info parameter\
    \ also defines\n   the use of SMFs coded in the smf_inline, smf_url, and smf_cid\n\
    \   parameters (defined in Appendix C.6.4.2).\n   The smf_info parameter describes\
    \ the \"render\" parameter that most\n   recently precedes it in the parameter\
    \ list.  The smf_info parameter\n   MUST NOT appear in parameter lists that do\
    \ not use the \"render\"\n   parameter, and MUST NOT appear before the first use\
    \ of \"render\" in\n   the parameter list.\n   We define three token values for\
    \ smf_info: \"ignore\", \"sdp_start\", and\n   \"identity\":\n     o  The \"ignore\"\
    \ value indicates that the SMFs MUST be discarded.\n        This behavior is the\
    \ default SMF rendering behavior.\n     o  The \"sdp_start\" value codes that\
    \ SMFs MUST be rendered, and that\n        the rendering MUST begin upon the acceptance\
    \ of the session\n        description.  If a receiver is offered a session description\n\
    \        with a renderer that uses an smf_info parameter set to\n        sdp_start,\
    \ and if the receiver does not support rendering SMFs,\n        the receiver MUST\
    \ NOT accept the renderer associated with the\n        smf_info parameter.  Options\
    \ include rejecting the renderer (by\n        setting the \"render\" parameter\
    \ to \"null\"), the payload type, the\n        media stream, or the entire session\
    \ description.\n     o  The \"identity\" value indicates that the SMFs code the\
    \ identity\n        of the renderer.  The value is meant for use with the \"unknown\"\
    \n        renderer (see Appendix C.6 preamble).  The MIDI commands coded\n   \
    \     in the SMF are informational in nature and MUST NOT be presented\n     \
    \   to a renderer for audio presentation.  In typical use, the SMF\n        would\
    \ use SysEx Identity Reply commands (F0 7E nn 06 02, as\n        defined in [MIDI])\
    \ to identify devices, and use device-specific\n        SysEx commands to describe\
    \ current state of the devices (patch\n        memory contents, etc.).\n   Other\
    \ smf_info token values MAY be registered with IANA.  The token\n   value MUST\
    \ adhere to the ABNF for render tokens defined in Appendix\n   D.  Registrations\
    \ MUST include a complete specification of parameter\n   usage, similar in depth\
    \ to the specifications that appear in this\n   appendix for \"sdp_start\" and\
    \ \"identity\".\n   If a party is offered a session description that uses an smf_info\n\
    \   parameter value that is not known to the party, the party MUST NOT\n   accept\
    \ the renderer associated with the smf_info parameter.  Options\n   include rejecting\
    \ the renderer, the payload type, the media stream,\n   or the entire session\
    \ description.\n   We now define the rendering semantics for the \"sdp_start\"\
    \ token value\n   in detail.\n   The SMFs and RTP MIDI streams in a session description\
    \ share the same\n   MIDI name space(s).  In the simple case of a single RTP MIDI\
    \ stream\n   and a single SMF, the SMF MIDI commands and RTP MIDI commands are\n\
    \   merged into a single name space and presented to the renderer.  The\n   indefinite\
    \ artifact responsibilities for merged MIDI streams defined\n   in Appendix C.5\
    \ also apply to merging RTP and SMF MIDI data.\n   If a payload type codes multiple\
    \ SMFs, the SMF name spaces are\n   presented as an ordered entity to the renderer.\
    \  To determine the\n   ordering of SMFs for a renderer (which SMF is \"first\"\
    , which is\n   \"second\", etc.), use the following rules:\n     o  If the renderer\
    \ uses a single data object, the order of\n        appearance of the SMFs in the\
    \ object's internal structure\n        defines the order of the SMFs (the earliest\
    \ SMF in the object is\n        \"first\", the next SMF in the object is \"second\"\
    , etc.).\n     o  If multiple data objects are encoded for a renderer, the\n \
    \       appearance of each data object in the parameter list sets the\n      \
    \  relative order of the SMFs encoded in each data object (SMFs\n        encoded\
    \ in parameters that appear earlier in the list are\n        ordered before SMFs\
    \ encoded in parameters that appear later in\n        the list).\n     o  If SMFs\
    \ are encoded in data objects parameters and in the\n        parameters defined\
    \ in C.6.4.2, the relative order of the data\n        object parameters and C.6.4.2\
    \ parameters in the parameter list\n        sets the relative order of SMFs (SMFs\
    \ encoded in parameters that\n        appear earlier in the list are ordered before\
    \ SMFs in parameters\n        that appear later in the list).\n   Given this ordering\
    \ of SMFs, we now define the mapping of SMFs to\n   renderer name spaces.  The\
    \ SMF that appears first for a renderer maps\n   to the first renderer name space.\
    \  The SMF that appears second for a\n   renderer maps to the second renderer\
    \ name space, etc.  If the\n   associated RTP MIDI streams also form an ordered\
    \ relationship, the\n   first SMF is merged with the first name space of the relationship,\n\
    \   the second SMF is merged to the second name space of the\n   relationship,\
    \ etc.\n   Unless the streams and the SMFs both use MIDI Time Code, the time\n\
    \   offset between SMF and stream data is unspecified.  This restriction\n   limits\
    \ the use of SMFs to applications where synchronization is not\n   critical, such\
    \ as the transport of System Exclusive commands for\n   renderer initialization,\
    \ or human-SMF interactivity.\n   Finally, we note that each SMF in the sdp_start\
    \ discussion above\n   encodes exactly one MIDI name space (16 voice channels\
    \ + systems).\n   Thus, the use of the Device Name SMF meta event to specify several\n\
    \   MIDI name spaces in an SMF is not supported for sdp_start.\n"
- title: C.6.4.2.  The smf_inline, smf_url, and smf_cid Parameters
  contents:
  - "C.6.4.2.  The smf_inline, smf_url, and smf_cid Parameters\n   In some applications,\
    \ the renderer data object may not encapsulate\n   SMFs, but an application may\
    \ wish to use SMFs in the manner defined\n   in Appendix C.6.4.1.\n   The \"smf_inline\"\
    , \"smf_url\", and \"smf_cid\" parameters address this\n   situation.  These parameters\
    \ use the syntax and semantics of the\n   inline, url, and cid parameters defined\
    \ in Appendix C.6.3, except\n   that the encoded data object is an SMF.\n   The\
    \ \"smf_inline\", \"smf_url\", and \"smf_cid\" parameters belong to the\n   \"\
    render\" parameter that most recently precedes it in the session\n   description.\
    \  The \"smf_inline\", \"smf_url\", and \"smf_cid\" parameters\n   MUST NOT appear\
    \ in parameter lists that do not use the \"render\"\n   parameter and MUST NOT\
    \ appear before the first use of \"render\" in the\n   parameter list.  If several\
    \ \"smf_inline\", \"smf_url\", or \"smf_cid\"\n   parameters appear for a renderer,\
    \ the order of the parameters defines\n   the SMF name space ordering.\n"
- title: C.6.4.3.  The chanmask Parameter
  contents:
  - "C.6.4.3.  The chanmask Parameter\n   The chanmask parameter instructs the renderer\
    \ to ignore all MIDI\n   voice commands for certain channel numbers.  The parameter\
    \ value is a\n   concatenated string of \"1\" and \"0\" digits.  Each string position\
    \ maps\n   to a MIDI voice channel number (system channels may not be masked).\n\
    \   A \"1\" instructs the renderer to process the voice channel; a \"0\"\n   instructs\
    \ the renderer to ignore the voice channel.\n   The string length of the chanmask\
    \ parameter value MUST be 16 (for a\n   single stream or an identity relationship)\
    \ or a multiple of 16 (for\n   an ordered relationship).\n   The chanmask parameter\
    \ describes the \"render\" parameter that most\n   recently precedes it in the\
    \ session description; chanmask MUST NOT\n   appear in parameter lists that do\
    \ not use the \"render\" parameter and\n   MUST NOT appear before the first use\
    \ of \"render\" in the parameter\n   list.\n   The chanmask parameter describes\
    \ the final MIDI name spaces presented\n   to the renderer.  The SMF and stream\
    \ components of the MIDI name\n   spaces may not be independently masked.\n  \
    \ If a receiver is offered a session description with a renderer that\n   uses\
    \ the chanmask parameter, and if the receiver does not implement\n   the semantics\
    \ of the chanmask parameter, the receiver MUST NOT accept\n   the renderer unless\
    \ the chanmask parameter value contains only \"1\"s.\n"
- title: C.6.5.  The audio/asc Media Type
  contents:
  - "C.6.5.  The audio/asc Media Type\n   In Appendix 11.3, we register the audio/asc\
    \ media type.  The data\n   object for audio/asc is a binary encoding of the AudioSpecificConfig\n\
    \   data block used to initialize mpeg4-generic streams (Section 6.2 and\n   [MPEGAUDIO]).\n\
    \   An mpeg4-generic parameter list MAY use the render, subrender, and\n   rinit\
    \ parameters with the audio/asc media type for renderer\n   configuration.  Several\
    \ restrictions apply to the use of these\n   parameters in mpeg4-generic parameter\
    \ lists:\n     o  An mpeg4-generic media description that uses the render\n  \
    \      parameter MUST assign the empty string (\"\") to the mpeg4-generic\n  \
    \      \"config\" parameter.  The use of the streamtype, mode, and\n        profile-level-id\
    \ parameters MUST follow the normative text in\n        Section 6.2.\n     o \
    \ Sessions that use identity or ordered relationships MUST follow\n        the\
    \ mpeg4-generic configuration restrictions in Appendix C.5.\n     o  The render\
    \ parameter MUST be assigned the value \"synthetic\",\n        \"unknown\", \"\
    null\", or a render value that has been added to the\n        IANA repository\
    \ for use with mpeg4-generic RTP MIDI streams.\n        The \"api\" token value\
    \ for render MUST NOT be used.\n     o  If a subrender parameter is present, it\
    \ MUST immediately follow\n        the render parameter, and it MUST be assigned\
    \ the token value\n        \"default\" or assigned a subrender value added to\
    \ the IANA\n        repository for use with mpeg4-generic RTP MIDI streams.  A\n\
    \        subrender parameter assignment may be left out of the renderer\n    \
    \    configuration, in which case the implied value of subrender is\n        the\
    \ default value of \"default\".\n     o  If the render parameter is assigned the\
    \ value \"synthetic\" and\n        the subrender parameter has the value \"default\"\
    \ (assigned or\n        implied), the rinit parameter MUST be assigned the value\n\
    \        \"audio/asc\", and an AudioSpecificConfig data object MUST be\n     \
    \   encoded using the mechanisms defined in C.6.2-3.  The\n        AudioSpecificConfig\
    \ data MUST encode one of the MPEG 4 Audio\n        Object Types defined for use\
    \ with mpeg4-generic in Section 6.2.\n        If the subrender value is other\
    \ than \"default\", refer to the\n        subrender registration for information\
    \ on the use of \"audio/asc\"\n        with the renderer.\n     o  If the render\
    \ parameter is assigned the value \"null\" or\n        \"unknown\", the data object\
    \ MAY be omitted.\n   Several general restrictions apply to the use of the audio/asc\
    \ media\n   type in RTP MIDI:\n     o  A native stream MUST NOT assign \"audio/asc\"\
    \ to rinit.  The\n        audio/asc media type is not intended to be a general-purpose\n\
    \        container for rendering systems outside of MPEG usage.\n     o  The audio/asc\
    \ media type defines a stored object type; it does\n        not define semantics\
    \ for RTP streams.  Thus, audio/asc MUST NOT\n        appear on an rtpmap line\
    \ of a session description.\n   Below, we show session description examples for\
    \ audio/asc.  The\n   session description below uses the inline parameter to code\
    \ the\n   AudioSpecificConfig block for a mpeg4-generic General MIDI stream.\n\
    \   We derive the value assigned to the inline parameter in Appendix E.4.\n  \
    \ The subrender token value of \"default\" is implied by the absence of\n   the\
    \ subrender parameter in the parameter list.\n   v=0\n   o=lazzaro 2520644554\
    \ 2838152170 IN IP4 first.example.net\n   s=Example\n   t=0 0\n   m=audio 5004\
    \ RTP/AVP 96\n   c=IN IP4 192.0.2.94\n   a=rtpmap:96 mpeg4-generic/44100\n   a=fmtp:96\
    \ streamtype=5; mode=rtp-midi; config=\"\";\n   profile-level-id=12; render=synthetic;\
    \ rinit=\"audio/asc\";\n   inline=\"egoAAAAaTVRoZAAAAAYAAAABAGBNVHJrAAAABgD/LwAA\"\
    \n   (The a=fmtp line has been wrapped to fit the page to accommodate\n    memo\
    \ formatting restrictions; it comprises a single line in SDP.)\n   The session\
    \ description below uses the url parameter to code the\n   AudioSpecificConfig\
    \ block for the same General MIDI stream:\n   v=0\n   o=lazzaro 2520644554 2838152170\
    \ IN IP4 first.example.net\n   s=Example\n   t=0 0\n   m=audio 5004 RTP/AVP 96\n\
    \   c=IN IP4 192.0.2.94\n   a=rtpmap:96 mpeg4-generic/44100\n   a=fmtp:96 streamtype=5;\
    \ mode=rtp-midi; config=\"\";\n   profile-level-id=12; render=synthetic; rinit=\"\
    audio/asc\";\n   url=\"http://example.net/oski.asc\";\n   cid=\"xjflsoeiurvpa09itnvlduihgnvet98pa3w9utnuighbuk\"\
    \n   (The a=fmtp line has been wrapped to fit the page to accommodate\n    memo\
    \ formatting restrictions; it comprises a single line in SDP.)\n"
- title: C.7.  Interoperability
  contents:
  - "C.7.  Interoperability\n   In this appendix, we define interoperability guidelines\
    \ for two\n   application areas:\n     o  MIDI content-streaming applications.\
    \  RTP MIDI is added to\n        RTSP-based content-streaming servers, so that\
    \ viewers may\n        experience MIDI performances (produced by a specified client-\n\
    \        side renderer) in synchronization with other streams (video,\n      \
    \  audio).\n     o  Long-distance network musical performance applications.  RTP\n\
    \        MIDI is added to SIP-based voice chat or videoconferencing\n        programs,\
    \ as an alternative, or as an addition, to audio and/or\n        video RTP streams.\n\
    \   For each application, we define a core set of functionality that all\n   implementations\
    \ MUST implement.\n   The applications we address in this section are not an exhaustive\n\
    \   list of potential RTP MIDI uses.  We expect framework documents for\n   other\
    \ applications to be developed, within the IETF or within other\n   organizations.\
    \  We discuss other potential application areas for RTP\n   MIDI in Section 1\
    \ of the main text of this memo.\n"
- title: C.7.1.  MIDI Content Streaming Applications
  contents:
  - "C.7.1.  MIDI Content Streaming Applications\n   In content-streaming applications,\
    \ a user invokes an RTSP client to\n   initiate a request to an RTSP server to\
    \ view a multimedia session.\n   For example, clicking on a web page link for\
    \ an Internet Radio\n   channel launches an RTSP client that uses the link's RTSP\
    \ URL to\n   contact the RTSP server hosting the radio channel.\n   The content\
    \ may be pre-recorded (for example, on-demand replay of\n   yesterday's football\
    \ game) or \"live\" (for example, football game\n   coverage as it occurs), but\
    \ in either case the user is usually an\n   \"audience member\" as opposed to\
    \ a \"participant\" (as the user would be\n   in telephony).\n   Note that these\
    \ examples describe the distribution of audio content\n   to an audience member.\
    \  The interoperability guidelines in this\n   appendix address RTP MIDI applications\
    \ of this nature, not\n   applications such as the transmission of raw MIDI command\
    \ streams for\n   use in a professional environment (recording studio, performance\n\
    \   stage, etc.).\n   In an RTSP session, a client accesses a session description\
    \ that is\n   \"declared\" by the server, either via the RTSP DESCRIBE method,\
    \ or via\n   other means, such as HTTP or email.  The session description defines\n\
    \   the session from the perspective of the client.  For example, if a\n   media\
    \ line in the session description contains a non-zero port\n   number, it encodes\
    \ the server's preference for the client's port\n   numbers for RTP and RTCP reception.\
    \  Once media flow begins, the\n   server sends an RTP MIDI stream to the client,\
    \ which renders it for\n   presentation, perhaps in synchrony with video or other\
    \ audio streams.\n   We now define the interoperability text for content-streaming\
    \ RTSP\n   applications.\n   In most cases, server interoperability responsibilities\
    \ are described\n   in terms of limits on the \"reference\" session description\
    \ a server\n   provides for a performance if it has no information about the\n\
    \   capabilities of the client.  The reference session is a \"lowest\n   common\
    \ denominator\" session that maximizes the odds that a client\n   will be able\
    \ to view the session.  If a server is aware of the\n   capabilities of the client,\
    \ the server is free to provide a session\n   description customized for the client\
    \ in the DESCRIBE reply.\n   Clients MUST support unicast UDP RTP MIDI streams\
    \ that use the\n   recovery journal with the closed-loop or the anchor sending\
    \ policies.\n   Clients MUST be able to interpret stream subsetting and chapter\n\
    \   inclusion parameters in the session description that qualify the\n   sending\
    \ policies.  Client support of enhanced Chapter C encoding is\n   OPTIONAL.\n\
    \   The reference session description offered by a server MUST send all\n   RTP\
    \ MIDI UDP streams as unicast streams that use the recovery journal\n   and the\
    \ closed-loop or anchor sending policies.  Servers SHOULD use\n   the stream subsetting\
    \ and chapter inclusion parameters in the\n   reference session description, to\
    \ simplify the rendering task of the\n   client.  Server support of enhanced Chapter\
    \ C encoding is OPTIONAL.\n   Clients and servers MUST support the use of RTSP\
    \ interleaved mode (a\n   method for interleaving RTP onto the RTSP TCP transport).\n\
    \   Clients MUST be able to interpret the timestamp semantics signalled\n   by\
    \ the \"comex\" value of the tsmode parameter (i.e., the timestamp\n   semantics\
    \ of Standard MIDI Files [MIDI]).  Servers MUST use the\n   \"comex\" value for\
    \ the \"tsmode\" parameter in the reference session\n   description.\n   Clients\
    \ MUST be able to process an RTP MIDI stream whose packets\n   encode an arbitrary\
    \ temporal duration (\"media time\").  Thus, in\n   practice, clients MUST implement\
    \ a MIDI playout buffer.  Clients MUST\n   NOT depend on the presence of rtp_ptime,\
    \ rtp_maxtime, and guardtime\n   parameters in the session description in order\
    \ to process packets,\n   but they SHOULD be able to use these parameters to improve\
    \ packet\n   processing.\n   Servers SHOULD strive to send RTP MIDI streams in\
    \ the same way media\n   servers send conventional audio streams: a sequence of\
    \ packets that\n   either all code the same temporal duration (non-normative example:\
    \ 50\n   ms packets) or that code one of an integral number of temporal\n   durations\
    \ (non-normative example: 50 ms, 100 ms, 250 ms, or 500 ms\n   packets).  Servers\
    \ SHOULD encode information about the packetization\n   method in the rtp_ptime\
    \ and rtp_maxtime parameters in the session\n   description.\n   Clients MUST\
    \ be able to examine the render and subrender parameter,\n   to determine if a\
    \ multimedia session uses a renderer it supports.\n   Clients MUST be able to\
    \ interpret the default \"one\" value of the\n   \"multimode\" parameter, to identify\
    \ supported renderers from a list of\n   renderer descriptions.  Clients MUST\
    \ be able to interpret the\n   musicport parameter, to the degree that it is relevant\
    \ to the\n   renderers it supports.  Clients MUST be able to interpret the\n \
    \  chanmask parameter.\n   Clients supporting renderers whose data object (as\
    \ encoded by a\n   parameter value for \"inline\") could exceed 300 octets in\
    \ size MUST\n   support the url and cid parameters and thus must implement the\
    \ HTTP\n   protocol in addition to RTSP.\n   Servers MUST specify complete rendering\
    \ systems for RTP MIDI streams.\n   Note that a minimal RTP MIDI native stream\
    \ does not meet this\n   requirement (Section 6.1), as the rendering method for\
    \ such streams\n   is \"not specified\".\n   At the time of this memo, the only\
    \ way for servers to specify a\n   complete rendering system is to specify an\
    \ mpeg4-generic RTP MIDI\n   stream in mode rtp-midi (Section 6.2 and C.6.5).\
    \  As a consequence,\n   the only rendering systems that may be presently used\
    \ are General\n   MIDI [MIDI], DLS 2 [DLS2], or Structured Audio [MPEGSA].  Note\
    \ that\n   the maximum inline value for General MIDI is well under 300 octets\n\
    \   (and thus clients need not support the \"url\" parameter), and that the\n\
    \   maximum inline values for DLS 2 and Structured Audio may be much\n   larger\
    \ than 300 octets (and thus clients MUST support the url\n   parameter).\n   We\
    \ anticipate that the owners of rendering systems (both standardized\n   and proprietary)\
    \ will register subrender parameters for their\n   renderers.  Once registration\
    \ occurs, native RTP MIDI sessions may\n   use render and subrender (Appendix\
    \ C.6.2) to specify complete\n   rendering systems for RTSP content-streaming\
    \ multimedia sessions.\n   Servers MUST NOT use the sdp_start value for the smf_info\
    \ parameter\n   in the reference session description, as this use would require\
    \ that\n   clients be able to parse and render Standard MIDI Files.\n   Clients\
    \ MUST support mpeg4-generic mode rtp-midi General MIDI (GM)\n   sessions, at\
    \ a polyphony limited by the hardware capabilities of the\n   client.  This requirement\
    \ provides a \"lowest common denominator\"\n   rendering system for content providers\
    \ to target.  Note that this\n   requirement does not force implementors of a\
    \ non-GM renderer (such as\n   DLS 2 or Structured Audio) to add a second rendering\
    \ engine.\n   Instead, a client may satisfy the requirement by including a set\
    \ of\n   voice patches that implement the GM instrument set, and using this\n\
    \   emulation for mpeg4-generic GM sessions.\n   It is RECOMMENDED that servers\
    \ use General MIDI as the renderer for\n   the reference session description,\
    \ because clients are REQUIRED to\n   support it.  We do not require General MIDI\
    \ as the reference\n   renderer, because for normative applications it is an inappropriate\n\
    \   choice.  Servers using General MIDI as a \"lowest common denominator\"\n \
    \  renderer SHOULD use Universal Real-Time SysEx MIP message [SPMIDI] to\n   communicate\
    \ the priority of voices to polyphony-limited clients.\n"
- title: C.7.2.  MIDI Network Musical Performance Applications
  contents:
  - "C.7.2.  MIDI Network Musical Performance Applications\n   In Internet telephony\
    \ and videoconferencing applications, parties\n   interact over an IP network\
    \ as they would face-to-face.  Good user\n   experiences require low end-to-end\
    \ audio latency and tight\n   audiovisual synchronization (for \"lip-sync\").\
    \  The Session Initiation\n   Protocol (SIP, [RFC3261]) is used for session management.\n\
    \   In this appendix section, we define interoperability guidelines for\n   using\
    \ RTP MIDI streams in interactive SIP applications.  Our primary\n   interest\
    \ is supporting Network Musical Performances (NMP), where\n   musicians in different\
    \ locations interact over the network as if they\n   were in the same room.  See\
    \ [NMP] for background information on NMP,\n   and see [RFC4696] for a discussion\
    \ of low-latency RTP MIDI\n   implementation techniques for NMP.\n   Note that\
    \ the goal of NMP applications is telepresence: the parties\n   should hear audio\
    \ that is close to what they would hear if they were\n   in the same room.  The\
    \ interoperability guidelines in this appendix\n   address RTP MIDI applications\
    \ of this nature, not applications such\n   as the transmission of raw MIDI command\
    \ streams for use in a\n   professional environment (recording studio, performance\
    \ stage, etc.).\n   We focus on session management for two-party unicast sessions\
    \ that\n   specify a renderer for RTP MIDI streams.  Within this limited scope,\n\
    \   the guidelines defined here are sufficient to let applications\n   interoperate.\
    \  We define the REQUIRED capabilities of RTP MIDI\n   senders and receivers in\
    \ NMP sessions and define how session\n   descriptions exchanged are used to set\
    \ up network musical performance\n   sessions.\n   SIP lets parties negotiate\
    \ details of the session, using the\n   Offer/Answer protocol [RFC3264].  However,\
    \ RTP MIDI has so many\n   parameters that \"blind\" negotiations between two\
    \ parties using\n   different applications might not yield a common session\n\
    \   configuration.\n   Thus, we now define a set of capabilities that NMP parties\
    \ MUST\n   support.  Session description offers whose options lie outside the\n\
    \   envelope of REQUIRED party behavior risk negotiation failure.  We\n   also\
    \ define session description idioms that the RTP MIDI part of an\n   offer MUST\
    \ follow, in order to structure the offer for simpler\n   analysis.\n   We use\
    \ the term \"offerer\" for the party making a SIP offer, and\n   \"answerer\"\
    \ for the party answering the offer.  Finally, we note that\n   unless it is qualified\
    \ by the adjective \"sender\" or \"receiver\", a\n   statement that a party MUST\
    \ support X implies that it MUST support X\n   for both sending and receiving.\n\
    \   If an offerer wishes to define a \"sendrecv\" RTP MIDI stream, it may\n  \
    \ use a true sendrecv session or the \"virtual sendrecv\" construction\n   described\
    \ in the preamble to Appendix C and in Appendix C.5.  A true\n   sendrecv session\
    \ indicates that the offerer wishes to participate in\n   a session where both\
    \ parties use identically configured renderers.  A\n   virtual sendrecv session\
    \ indicates that the offerer is willing to\n   participate in a session where\
    \ the two parties may be using different\n   renderer configurations.  Thus, parties\
    \ MUST be prepared to see both\n   real and virtual sendrecv sessions in an offer.\n\
    \   Parties MUST support unicast UDP transport of RTP MIDI streams.\n   These\
    \ streams MUST use the recovery journal with the closed-loop or\n   anchor sending\
    \ policies.  These streams MUST use the stream\n   subsetting and chapter inclusion\
    \ parameters to declare the types of\n   MIDI commands that will be sent on the\
    \ stream (for sendonly streams)\n   or will be processed (for recvonly streams),\
    \ including the size\n   limits on System Exclusive commands.  Support of enhanced\
    \ Chapter C\n   encoding is OPTIONAL.\n   Note that both TCP and multicast UDP\
    \ support are OPTIONAL.  We make\n   TCP OPTIONAL because we expect NMP renderers\
    \ to rely on data objects\n   (signalled by \"rinit\" and associated parameters)\
    \ for initialization\n   at the start of the session, and only to use System Exclusive\n\
    \   commands for interactive control during the session.  These\n   interactive\
    \ commands are small enough to be protected via the\n   recovery journal mechanism\
    \ of RTP MIDI UDP streams.\n   We now discuss timestamps, packet timing, and packet\
    \ sending\n   algorithms.\n   Recall that the tsmode parameter controls the semantics\
    \ of command\n   timestamps in the MIDI list of RTP packets.\n   Parties MUST\
    \ support clock rates of 44.1 kHz, 48 kHz, 88.2 kHz, and\n   96 kHz.  Parties\
    \ MUST support streams using the \"comex\", \"async\", and\n   \"buffer\" tsmode\
    \ values.  Recvonly offers MUST offer the default\n   \"comex\".\n   Parties MUST\
    \ support a wide range of packet temporal durations: from\n   rtp_ptime and rtp_maxptime\
    \ values of 0, to rtp_ptime and rtp_maxptime\n   values that code 100 ms.  Thus,\
    \ receivers MUST be able to implement a\n   playout buffer.\n   Offers and answers\
    \ MUST present rtp_ptime, rtp_maxptime, and\n   guardtime values that support\
    \ the latency that users would expect in\n   the application, subject to bandwidth\
    \ constraints.  As senders MUST\n   abide by values set for these parameters in\
    \ a session description, a\n   receiver SHOULD use these values to size its playout\
    \ buffer to\n   produce the lowest reliable latency for a session.  Implementers\n\
    \   should refer to [RFC4696] for information on packet sending\n   algorithms\
    \ for latency-sensitive applications.  Parties MUST be able\n   to implement the\
    \ semantics of the guardtime parameter, for times from\n   5 ms to 5000 ms.\n\
    \   We now discuss the use of the render parameter.\n   Sessions MUST specify\
    \ complete rendering systems for all RTP MIDI\n   streams.  Note that a minimal\
    \ RTP MIDI native stream does not meet\n   this requirement (Section 6.1), as\
    \ the rendering method for such\n   streams is \"not specified\".\n   At the time\
    \ this writing, the only way for parties to specify a\n   complete rendering system\
    \ is to specify an mpeg4-generic RTP MIDI\n   stream in mode rtp-midi (Section\
    \ 6.2 and C.6.5).  We anticipate that\n   the owners of rendering systems (both\
    \ standardized and proprietary)\n   will register subrender values for their renderers.\
    \  Once IANA\n   registration occurs, native RTP MIDI sessions may use render\
    \ and\n   subrender (Appendix C.6.2) to specify complete rendering systems for\n\
    \   SIP network musical performance multimedia sessions.\n   All parties MUST\
    \ support General MIDI (GM) sessions, at a polyphony\n   limited by the hardware\
    \ capabilities of the party.  This requirement\n   provides a \"lowest common\
    \ denominator\" rendering system, without\n   which practical interoperability\
    \ will be quite difficult.  When using\n   GM, parties SHOULD use Universal Real-Time\
    \ SysEx MIP message [SPMIDI]\n   to communicate the priority of voices to polyphony-limited\
    \ clients.\n   Note that this requirement does not force implementors of a non-GM\n\
    \   renderer (for mpeg4-generic sessions, DLS 2, or Structured Audio) to\n   add\
    \ a second rendering engine.  Instead, a client may satisfy the\n   requirement\
    \ by including a set of voice patches that implement the GM\n   instrument set,\
    \ and using this emulation for mpeg4-generic GM\n   sessions.  We require GM support\
    \ so that an offerer that wishes to\n   maximize interoperability may do so by\
    \ offering GM if its preferred\n   renderer is not accepted by the answerer.\n\
    \   Offerers MUST NOT present several renderers as options in a session\n   description\
    \ by listing several payload types on a media line, as\n   Section 2.1 uses this\
    \ construct to let a party send several RTP MIDI\n   streams in the same RTP session.\n\
    \   Instead, an offerer wishing to present rendering options SHOULD offer\n  \
    \ a single payload type that offers several renderers.  In this\n   construct,\
    \ the parameter list codes a list of render parameters (each\n   followed by its\
    \ support parameters).  As discussed in Appendix C.6.1,\n   the order of renderers\
    \ in the list declares the offerer's preference.\n   The \"unknown\" and \"null\"\
    \ values MUST NOT appear in the offer.  The\n   answer MUST set all render values\
    \ except the desired renderer to\n   \"null\".  Thus, \"unknown\" MUST NOT appear\
    \ in the answer.\n   We use SHOULD instead of MUST in the first sentence in the\
    \ paragraph\n   above, because this technique does not work in all situations\n\
    \   (example:  an offerer wishes to offer both mpeg4-generic renderers\n   and\
    \ native RTP MIDI renderers as options).  In this case, the offerer\n   MUST present\
    \ a series of session descriptions, each offering a single\n   renderer, until\
    \ the answerer accepts a session description.\n   Parties MUST support the musicport,\
    \ chanmask, subrender, rinit, and\n   inline parameters.  Parties supporting renderers\
    \ whose data object\n   (as encoded by a parameter value for \"inline\") could\
    \ exceed 300\n   octets in size MUST support the url and cid parameters and thus\
    \ must\n   implement HTTP protocol.  Note that in mpeg4-generic, General MIDI\n\
    \   data objects cannot exceed 300 octets, but DLS 2 and Structured Audio\n  \
    \ data objects may.  Support for the other rendering parameters\n   (smf_cif,\
    \ smf_info, smf_inline, smf_url) is OPTIONAL.\n   Thus far in this document, our\
    \ discussion has assumed that the only\n   MIDI flows that drive a renderer are\
    \ the network flows described in\n   the session description.  In NMP applications,\
    \ this assumption would\n   require two rendering engines: one for local use by\
    \ a party, a second\n   for the remote party.\n   In practice, applications may\
    \ wish to have both parties share a\n   single rendering engine.  In this case,\
    \ the session description MUST\n   use a virtual sendrecv session and MUST use\
    \ the stream subsetting and\n   chapter inclusion parameters to allocate which\
    \ MIDI channels are\n   intended for use by a party.  If two parties are sharing\
    \ a MIDI\n   channels, the application MUST ensure that appropriate MIDI merging\n\
    \   occurs at the input to the renderer.\n   We now discuss the use of (non-MIDI)\
    \ audio streams in the session.\n   Audio streams may be used for two purposes:\
    \ as a \"talkback\" channel\n   for parties to converse, or as a way to conduct\
    \ a performance that\n   includes MIDI and audio channels.  In the latter case,\
    \ offers MUST\n   use sample rates and the packet temporal durations for the audio\
    \ and\n   MIDI streams that support low-latency synchronized rendering.\n   We\
    \ now show an example of an offer/answer exchange in a network\n   musical performance\
    \ application (next page).  Below, we show an offer\n   that complies with the\
    \ interoperability text in this appendix\n   section.\n   v=0\n   o=first 2520644554\
    \ 2838152170 IN IP4 first.example.net\n   s=Example\n   t=0 0\n   a=group:FID\
    \ 1 2\n   c=IN IP4 192.0.2.94\n   m=audio 16112 RTP/AVP 96\n   a=recvonly\n  \
    \ a=mid:1\n   a=rtpmap:96 mpeg4-generic/44100\n   a=fmtp:96 streamtype=5; mode=rtp-midi;\
    \ config=\"\";\n   profile-level-id=12; cm_unused=ABCFGHJKMNPQTVWXYZ; cm_used=2NPTW;\n\
    \   cm_used=2C0.1.7.10.11.64.121.123; cm_used=2M0.1.2\n   cm_used=X0-16; ch_never=ABCDEFGHJKMNPQTVWXYZ;\n\
    \   ch_default=2NPTW; ch_default=2C0.1.7.10.11.64.121.123;\n   ch_default=2M0.1.2;\
    \ cm_default=X0-16;\n   rtp_ptime=0; rtp_maxptime=0; guardtime=44100;\n   musicport=1;\
    \ render=synthetic; rinit=\"audio/asc\";\n   inline=\"egoAAAAaTVRoZAAAAAYAAAABAGBNVHJrAAAABgD/LwAA\"\
    \n   m=audio 16114 RTP/AVP 96\n   a=sendonly\n   a=mid:2\n   a=rtpmap:96 mpeg4-generic/44100\n\
    \   a=fmtp:96 streamtype=5; mode=rtp-midi; config=\"\";\n   profile-level-id=12;\
    \ cm_unused=ABCFGHJKMNPQTVWXYZ; cm_used=1NPTW;\n   cm_used=1C0.1.7.10.11.64.121.123;\
    \ cm_used=1M0.1.2\n   cm_used=X0-16; ch_never=ABCDEFGHJKMNPQTVWXYZ;\n   ch_default=1NPTW;\
    \ ch_default=1C0.1.7.10.11.64.121.123;\n   ch_default=1M0.1.2; cm_default=X0-16;\n\
    \   rtp_ptime=0; rtp_maxptime=0; guardtime=44100;\n   musicport=1; render=synthetic;\
    \ rinit=\"audio/asc\";\n   inline=\"egoAAAAaTVRoZAAAAAYAAAABAGBNVHJrAAAABgD/LwAA\"\
    \n   (The a=fmtp lines have been wrapped to fit the page to accommodate\n    memo\
    \ formatting restrictions; it comprises a single line in SDP.)\n   The owner line\
    \ (o=) identifies the session owner as \"first\".\n   The session description\
    \ defines two MIDI streams: a recvonly stream\n   on which \"first\" receives\
    \ a performance, and a sendonly stream that\n   \"first\" uses to send a performance.\
    \  The recvonly port number encodes\n   the ports on which \"first\" wishes to\
    \ receive RTP (16112) and RTCP\n   (16113) media at IP4 address 192.0.2.94.  The\
    \ sendonly port number\n   encodes the port on which \"first\" wishes to receive\
    \ RTCP for the\n   stream (16115).\n   The musicport parameters code that the\
    \ two streams share and identity\n   relationship and thus form a virtual sendrecv\
    \ stream.\n   Both streams are mpeg4-generic RTP MIDI streams that specify a\n\
    \   General MIDI renderer.  The stream subsetting parameters code that\n   the\
    \ recvonly stream uses MIDI channel 1 exclusively for voice\n   commands, and\
    \ that the sendonly stream uses MIDI channel 2\n   exclusively for voice commands.\
    \  This mapping permits the application\n   software to share a single renderer\
    \ for local and remote performers.\n   We now show the answer to the offer.\n\
    \   v=0\n   o=second 2520644554 2838152170 IN IP4 second.example.net\n   s=Example\n\
    \   t=0 0\n   a=group:FID 1 2\n   c=IN IP4 192.0.2.105\n   m=audio 5004 RTP/AVP\
    \ 96\n   a=sendonly\n   a=mid:1\n   a=rtpmap:96 mpeg4-generic/44100\n   a=fmtp:96\
    \ streamtype=5; mode=rtp-midi; config=\"\";\n   profile-level-id=12; cm_unused=ABCFGHJKMNPQTVWXYZ;\
    \ cm_used=2NPTW;\n   cm_used=2C0.1.7.10.11.64.121.123; cm_used=2M0.1.2\n   cm_used=X0-16;\
    \ ch_never=ABCDEFGHJKMNPQTVWXYZ;\n   ch_default=2NPTW; ch_default=2C0.1.7.10.11.64.121.123;\n\
    \   ch_default=2M0.1.2; cm_default=X0-16;\n   rtp_ptime=0; rtp_maxptime=882; guardtime=44100;\n\
    \   musicport=1; render=synthetic; rinit=\"audio/asc\";\n   inline=\"egoAAAAaTVRoZAAAAAYAAAABAGBNVHJrAAAABgD/LwAA\"\
    \n   m=audio 5006 RTP/AVP 96\n   a=recvonly\n   a=mid:2\n   a=rtpmap:96 mpeg4-generic/44100\n\
    \   a=fmtp:96 streamtype=5; mode=rtp-midi; config=\"\";\n   profile-level-id=12;\
    \ cm_unused=ABCFGHJKMNPQTVWXYZ; cm_used=1NPTW;\n   cm_used=1C0.1.7.10.11.64.121.123;\
    \ cm_used=1M0.1.2\n   cm_used=X0-16; ch_never=ABCDEFGHJKMNPQTVWXYZ;\n   ch_default=1NPTW;\
    \ ch_default=1C0.1.7.10.11.64.121.123;\n   ch_default=1M0.1.2; cm_default=X0-16;\n\
    \   rtp_ptime=0; rtp_maxptime=0; guardtime=88200;\n   musicport=1; render=synthetic;\
    \ rinit=\"audio/asc\";\n   inline=\"egoAAAAaTVRoZAAAAAYAAAABAGBNVHJrAAAABgD/LwAA\"\
    \n   (The a=fmtp lines have been wrapped to fit the page to accommodate\n    memo\
    \ formatting restrictions; they comprise single lines in SDP.)\n   The owner line\
    \ (o=) identifies the session owner as \"second\".\n   The port numbers for both\
    \ media streams are non-zero; thus, \"second\"\n   has accepted the session description.\
    \  The stream marked \"sendonly\"\n   in the offer is marked \"recvonly\" in the\
    \ answer, and vice versa,\n   coding the different view of the session held by\
    \ \"session\".  The IP4\n   number (192.0.2.105) and the RTP (5004 and 5006) and\
    \ RTCP (5005 and\n   5007) have been changed by \"second\" to match its transport\
    \ wishes.\n   In addition, \"second\" has made several parameter changes:\n  \
    \ rtp_maxptime for the sendonly stream has been changed to code 2 ms\n   (441\
    \ in clock units), and the guardtime for the recvonly stream has\n   been doubled.\
    \  As these parameter modifications request capabilities\n   that are REQUIRED\
    \ to be implemented by interoperable parties,\n   \"second\" can make these changes\
    \ with confidence that \"first\" can\n   abide by them.\n"
- title: D.  Parameter Syntax Definitions
  contents:
  - "D.  Parameter Syntax Definitions\n   In this appendix, we define the syntax for\
    \ the RTP MIDI media type\n   parameters in Augmented Backus-Naur Form (ABNF,\
    \ [RFC4234]).  When\n   using these parameters with SDP, all parameters MUST appear\
    \ on a\n   single fmtp attribute line of an RTP MIDI media description.  For\n\
    \   mpeg4-generic RTP MIDI streams, this line MUST also include any\n   mpeg4-generic\
    \ parameters (usage described in Section 6.2).  An fmtp\n   attribute line may\
    \ be defined (after [RFC3640]) as:\n   ;\n   ; SDP fmtp line definition\n   ;\n\
    \   fmtp = \"a=fmtp:\" token SP param-assign 0*(\";\" SP param-assign) CRLF\n\
    \   where <token> codes the RTP payload type.  Note that white space MUST\n  \
    \ NOT appear between the \"a=fmtp:\" and the RTP payload type.\n   We now define\
    \ the syntax of the parameters defined in Appendix C.\n   The definition takes\
    \ the form of the incremental assembly of the\n   <param-assign> token.  See [RFC3640]\
    \ for the syntax of the\n   mpeg4-generic parameters discussed in Section 6.2.\n\
    \   ;\n   ;\n   ; top-level definition for all parameters\n   ;\n   ;\n   ;\n\
    \   ; Parameters defined in Appendix C.1\n   param-assign =   (\"cm_unused=\"\
    \  (([channel-list] command-type\n                                     [f-list])\
    \ / sysex-data))\n   param-assign =/  (\"cm_used=\"    (([channel-list] command-type\n\
    \                                     [f-list]) / sysex-data))\n   ;\n   ; Parameters\
    \ defined in Appendix C.2\n   param-assign =/  (\"j_sec=\"      (\"none\" / \"\
    recj\" / *ietf-extension))\n   param-assign =/  (\"j_update=\"   (\"anchor\" /\
    \ \"closed-loop\" /\n                                    \"open-loop\" / *ietf-extension))\n\
    \   param-assign =/  (\"ch_default=\" (([channel-list] chapter-list\n        \
    \                             [f-list]) / sysex-data))\n   param-assign =/  (\"\
    ch_never=\"   (([channel-list] chapter-list\n                                \
    \     [f-list]) / sysex-data))\n   param-assign =/  (\"ch_anchor=\"  (([channel-list]\
    \ chapter-list\n                                     [f-list]) / sysex-data))\n\
    \   ;\n   ; Parameters defined in Appendix C.3\n   param-assign =/  (\"tsmode=\"\
    \     (\"comex\" / \"async\" / \"buffer\"))\n   param-assign =/  (\"linerate=\"\
    \    nonzero-four-octet)\n   param-assign =/  (\"octpos=\"      (\"first\" / \"\
    last\"))\n   param-assign =/  (\"mperiod=\"     nonzero-four-octet)\n   ;\n  \
    \ ; Parameter defined in Appendix C.4\n   param-assign =/  (\"guardtime=\"   \
    \  nonzero-four-octet)\n   param-assign =/  (\"rtp_ptime=\"     four-octet)\n\
    \   param-assign =/  (\"rtp_maxptime=\"  four-octet)\n   ;\n   ; Parameters defined\
    \ in Appendix C.5\n   param-assign =/  (\"musicport=\"     four-octet)\n   ;\n\
    \   ; Parameters defined in Appendix C.6\n   param-assign =/  (\"chanmask=\" \
    \    ( 1*( 16( \"0\" / \"1\" ) )))\n   param-assign =/  (\"cid=\"          double-quote\
    \ cid-block\n                                     double-quote)\n   param-assign\
    \ =/  (\"inline=\"       double-quote base-64-block\n                        \
    \             double-quote)\n   param-assign =/  (\"multimode=\"    (\"all\" /\
    \ \"one\"))\n   param-assign =/  (\"render=\"       (\"synthetic\" / \"api\" /\
    \ \"null\" /\n                                      \"unknown\" / *extension))\n\
    \   param-assign =/  (\"rinit=\"        mime-type \"/\" mime-subtype)\n   param-assign\
    \ =/  (\"smf_cid=\"      double-quote cid-block\n                            \
    \         double-quote)\n   param-assign =/  (\"smf_info=\"     (\"ignore\" /\
    \ \"identity\" /\n                                     \"sdp_start\" / *extension))\n\
    \   param-assign =/  (\"smf_inline=\"   double-quote base-64-block\n         \
    \                            double-quote)\n   param-assign =/  (\"smf_url=\"\
    \      double-quote uri-element\n                                     double-quote)\n\
    \   param-assign =/  (\"subrender=\"    (\"default\" / *extension))\n   param-assign\
    \ =/  (\"url=\"          double-quote uri-element\n                          \
    \           double-quote)\n   ;\n   ; list definitions for the cm_ command-type\n\
    \   ;\n   command-type    = command-part1 command-part2 command-part3\n   command-part1\
    \   = (*1\"A\") (*1\"B\") (*1\"C\") (*1\"F\") (*1\"G\") (*1\"H\")\n   command-part2\
    \   = (*1\"J\") (*1\"K\") (*1\"M\") (*1\"N\") (*1\"P\") (*1\"Q\")\n   command-part3\
    \   = (*1\"T\") (*1\"V\") (*1\"W\") (*1\"X\") (*1\"Y\") (*1\"Z\")\n   ;\n   ;\
    \ list definitions for the ch_ chapter-list\n   ;\n   chapter-list  =  ch-part1\
    \ ch-part2 ch-part3\n   ch-part1  = (*1\"A\") (*1\"B\") (*1\"C\") (*1\"D\") (*1\"\
    E\") (*1\"F\") (*1\"G\")\n   ch-part2  = (*1\"H\") (*1\"J\") (*1\"K\") (*1\"M\"\
    ) (*1\"N\") (*1\"P\") (*1\"Q\")\n   ch-part3  = (*1\"T\") (*1\"V\") (*1\"W\")\
    \ (*1\"X\") (*1\"Y\") (*1\"Z\")\n   ;\n   ; list definitions for the ch_ channel-list\n\
    \   ;\n   channel-list       = midi-chan-element *(\".\" midi-chan-element)\n\
    \   midi-chan-element  = midi-chan / midi-chan-range\n   midi-chan-range    =\
    \ midi-chan \"-\" midi-chan\n                      ; decimal value of left midi-chan\n\
    \                      ; MUST be strictly less than decimal\n                \
    \      ; value of right midi-chan\n   midi-chan          = %d0-15\n   ;\n   ;\
    \ list definitions for the ch_ field list (f-list)\n   ;\n   f-list          \
    \   = midi-field-element *(\".\" midi-field-element)\n   midi-field-element =\
    \ midi-field / midi-field-range\n   midi-field-range   = midi-field \"-\" midi-field\n\
    \                      ;\n                      ; decimal value of left midi-field\n\
    \                      ; MUST be strictly less than decimal\n                \
    \      ; value of right midi-field\n   midi-field         = four-octet\n     \
    \                 ;\n                      ; large range accommodates Chapter\
    \ M\n                      ; RPN (0-16383) and NRPN (16384-32767)\n          \
    \            ; parameters, and Chapter X octet sizes.\n   ;\n   ; definitions\
    \ for ch_ sysex-data\n   ;\n   sysex-data         = \"__\"  h-list *(\"_\" h-list)\
    \ \"__\"\n   h-list             = hex-field-element *(\".\" hex-field-element)\n\
    \   hex-field-element  = hex-octet / hex-field-range\n   hex-field-range    =\
    \ hex-octet \"-\" hex-octet\n                      ;\n                      ;\
    \ hexadecimal value of left hex-octet\n                      ; MUST be strictly\
    \ less than hexadecimal\n                      ; value of right hex-octet\n  \
    \ hex-octet          = 2(\"0\" / \"1\" / \"2\"/ \"3\" / \"4\" /\n            \
    \              \"5\" / \"6\" / \"7\" / \"8\" / \"9\" /\n                     \
    \     \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\")\n                      ;\n\
    \                      ; rewritten version of hex-octet in [RFC2045]\n       \
    \               ; (page 23).\n                      ; note that a-f are not permitted,\
    \ only A-F.\n                      ; hex-octet values MUST NOT exceed 7F.\n  \
    \ ;\n   ; definitions for rinit parameter\n   ;\n   mime-type          = \"audio\"\
    \ / \"application\"\n   mime-subtype       = token\n                      ;\n\
    \                      ; See Appendix C.6.2 for registration\n               \
    \       ; requirements for rinit type/subtypes.\n   ;\n   ; definitions for base64\
    \ encoding\n   ; copied from [RFC4566]\n   base-64-block      = *base64-unit [base64-pad]\n\
    \   base64-unit        =  4base64-char\n   base64-pad         =  2base64-char\
    \ \"==\" / 3base64-char \"=\"\n   base64-char        =  %x41-5A / %x61-7A / %x30-39\
    \ / \"+\" / \"/\"\n                      ;  A-Z, a-z, 0-9, \"+\" and \"/\"\n \
    \  ;\n   ; generic rules\n   ;\n   ietf-extension     = token\n              \
    \        ;\n                      ; ietf-extension may only be defined in\n  \
    \                    ; standards-track RFCs.\n   extension          = token\n\
    \                      ;\n                      ; extension may be defined by\
    \ filing\n                      ; a registration with IANA.\n   four-octet   \
    \      = %d0-4294967295\n                      ; unsigned encoding of 32-bits\n\
    \   nonzero-four-octet = %d1-4294967295\n                      ; unsigned encoding\
    \ of 32-bits, ex-zero\n   uri-element        = URI-reference\n               \
    \       ; as defined in [RFC3986]\n   double-quote       = %x22\n            \
    \          ; the double-quote (\") character\n   token              =  1*token-char\n\
    \                      ; copied from [RFC4566]\n   token-char         =  %x21\
    \ / %x23-27 / %x2A-2B / %x2D-2E /\n                         %x30-39 / %x41-5A\
    \ / %x5E-7E\n                      ; copied from [RFC4566]\n   cid-block     \
    \     = 1*cid-char\n   cid-char           =  token-char\n   cid-char         \
    \  =/  \"@\"\n   cid-char           =/  \",\"\n   cid-char           =/  \";\"\
    \n   cid-char           =/  \":\"\n   cid-char           =/  \"\\\"\n   cid-char\
    \           =/  \"/\"\n   cid-char           =/  \"[\"\n   cid-char          \
    \ =/  \"]\"\n   cid-char           =/  \"?\"\n   cid-char           =/  \"=\"\n\
    \                      ;\n                      ; add back in the tspecials [RFC2045],\
    \ except for\n                      ; double-quote and the non-email safe () <>\n\
    \                      ; note that \"cid\" defined above ensures that\n      \
    \                ; cid-block is enclosed with double-quotes\n   ; external references\n\
    \   ; URI-reference: from [RFC3986]\n   ;\n   ; End of ABNF\n   The mpeg4-generic\
    \ RTP payload [RFC3640] defines a \"mode\" parameter\n   that signals the type\
    \ of MPEG stream in use.  We add a new mode\n   value, \"rtp-midi\", using the\
    \ ABNF rule below:\n   ;\n   ; mpeg4-generic mode parameter extension\n   ;\n\
    \   mode              =/ \"rtp-midi\"\n                     ; as described in\
    \ Section 6.2 of this memo\n"
- title: E.  A MIDI Overview for Networking Specialists
  contents:
  - "E.  A MIDI Overview for Networking Specialists\n   This appendix presents an\
    \ overview of the MIDI standard, for the\n   benefit of networking specialists\
    \ new to musical applications.\n   Implementors should consult [MIDI] for a normative\
    \ description of\n   MIDI.\n   Musicians make music by performing a controlled\
    \ sequence of physical\n   movements.  For example, a pianist plays by coordinating\
    \ a series of\n   key presses, key releases, and pedal actions.  MIDI represents\
    \ a\n   musical performance by encoding these physical gestures as a sequence\n\
    \   of MIDI commands.  This high-level musical representation is compact\n   but\
    \ fragile: one lost command may be catastrophic to the performance.\n   MIDI commands\
    \ have much in common with the machine instructions of a\n   microprocessor. \
    \ MIDI commands are defined as binary elements.\n   Bitfields within a MIDI command\
    \ have a regular structure and a\n   specialized purpose.  For example, the upper\
    \ nibble of the first\n   command octet (the opcode field) codes the command type.\
    \  MIDI\n   commands may consist of an arbitrary number of complete octets, but\n\
    \   most MIDI commands are 1, 2, or 3 octets in length.\n       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \       |     Channel Voice Messages     |      Bitfield Pattern      |\n    \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n       |\
    \ NoteOff (end a note)           | 1000cccc 0nnnnnnn 0vvvvvvv |\n       |-------------------------------------------------------------|\n\
    \       | NoteOn (start a note)          | 1001cccc 0nnnnnnn 0vvvvvvv |\n    \
    \   |-------------------------------------------------------------|\n       |\
    \ PTouch (Polyphonic Aftertouch) | 1010cccc 0nnnnnnn 0aaaaaaa |\n       |-------------------------------------------------------------|\n\
    \       | CControl (Controller Change)   | 1011cccc 0xxxxxxx 0yyyyyyy |\n    \
    \   |-------------------------------------------------------------|\n       |\
    \ PChange (Program Change)       | 1100cccc 0ppppppp          |\n       |-------------------------------------------------------------|\n\
    \       | CTouch (Channel Aftertouch)    | 1101cccc 0aaaaaaa          |\n    \
    \   |-------------------------------------------------------------|\n       |\
    \ PWheel (Pitch Wheel)           | 1110cccc 0xxxxxxx 0yyyyyyy |\n        -------------------------------------------------------------\n\
    \                 Figure E.1 -- MIDI Channel Messages\n       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \       |      System Common Messages    |     Bitfield Pattern       |\n    \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n       |\
    \ System Exclusive               | 11110000, followed by a    |\n       |    \
    \                            | list of 0xxxxxx octets,    |\n       |        \
    \                        | followed by 11110111       |\n       |-------------------------------------------------------------|\n\
    \       | MIDI Time Code Quarter Frame   | 11110001 0xxxxxxx          |\n    \
    \   |-------------------------------------------------------------|\n       |\
    \ Song Position Pointer          | 11110010 0xxxxxxx 0yyyyyyy |\n       |-------------------------------------------------------------|\n\
    \       | Song Select                    | 11110011 0xxxxxxx          |\n    \
    \   |-------------------------------------------------------------|\n       |\
    \ Undefined                      | 11110100                   |\n       |-------------------------------------------------------------|\n\
    \       | Undefined                      | 11110101                   |\n    \
    \   |-------------------------------------------------------------|\n       |\
    \ Tune Request                   | 11110110                   |\n       |-------------------------------------------------------------|\n\
    \       | System Exclusive End Marker    | 11110111                   |\n    \
    \    -------------------------------------------------------------\n       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \       |    System Realtime Messages    |     Bitfield Pattern       |\n    \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n       |\
    \ Clock                          | 11111000                   |\n       |-------------------------------------------------------------|\n\
    \       | Undefined                      | 11111001                   |\n    \
    \   |-------------------------------------------------------------|\n       |\
    \ Start                          | 11111010                   |\n       |-------------------------------------------------------------|\n\
    \       | Continue                       | 11111011                   |\n    \
    \   |-------------------------------------------------------------|\n       |\
    \ Stop                           | 11111100                   |\n       |-------------------------------------------------------------|\n\
    \       | Undefined                      | 11111101                   |\n    \
    \   |-------------------------------------------------------------|\n       |\
    \ Active Sense                   | 11111110                   |\n       |-------------------------------------------------------------|\n\
    \       | System Reset                   | 11111111                   |\n    \
    \    -------------------------------------------------------------\n         \
    \             Figure E.2 -- MIDI System Messages\n   Figure E.1 and E.2 show the\
    \ MIDI command family.  There are three\n   major classes of commands: voice commands\
    \ (opcode field values in the\n   range 0x8 through 0xE), system common commands\
    \ (opcode field 0xF,\n   commands 0xF0 through 0xF7), and system real-time commands\
    \ (opcode\n   field 0xF, commands 0xF8 through 0xFF).  Voice commands code the\n\
    \   musical gestures for each timbre in a composition.  Systems commands\n   perform\
    \ functions that usually affect all voice channels, such as\n   System Reset (0xFF).\n"
- title: E.1.  Commands Types
  contents:
  - "E.1.  Commands Types\n   Voice commands execute on one of 16 MIDI channels, as\
    \ coded by its\n   4-bit channel field (field cccc in Figure E.1).  In most\n\
    \   applications, notes for different timbres are assigned to different\n   channels.\
    \  To support applications that require more than 16\n   channels, MIDI systems\
    \ use several MIDI command streams in parallel,\n   to yield 32, 48, or 64 MIDI\
    \ channels.\n   As an example of a voice command, consider a NoteOn command (opcode\n\
    \   0x9), with binary encoding 1001cccc 0nnnnnnn 0aaaaaaa.  This command\n   signals\
    \ the start of a musical note on MIDI channel cccc.  The note\n   has a pitch\
    \ coded by the note number nnnnnnn, and an onset amplitude\n   coded by note velocity\
    \ aaaaaaa.\n   Other voice commands signal the end of notes (NoteOff, opcode 0x8),\n\
    \   map a specific timbre to a MIDI channel (PChange, opcode 0xC), or set\n  \
    \ the value of parameters that modulate the timbral quality (all other\n   voice\
    \ commands).  The exact meaning of most voice channel commands\n   depends on\
    \ the rendering algorithms the MIDI receiver uses to\n   generate sound.  In most\
    \ applications, a MIDI sender has a model (in\n   some sense) of the rendering\
    \ method used by the receiver.\n   System commands perform a variety of global\
    \ tasks in the stream,\n   including \"sequencer\" playback control of pre-recorded\
    \ MIDI commands\n   (the Song Position Pointer, Song Select, Clock, Start, Continue,\
    \ and\n   Stop messages), SMPTE time code (the MIDI Time Code Quarter Frame\n\
    \   command), and the communication of device-specific data (the System\n   Exclusive\
    \ messages).\n"
- title: E.2.  Running Status
  contents:
  - "E.2.  Running Status\n   All MIDI command bitfields share a special structure:\
    \ the leading bit\n   of the first octet is set to 1, and the leading bit of all\
    \ subsequent\n   octets is set to 0.  This structure supports a data compression\n\
    \   system, called running status [MIDI], that improves the coding\n   efficiency\
    \ of MIDI.\n   In running status coding, the first octet of a MIDI voice command\
    \ may\n   be dropped if it is identical to the first octet of the previous MIDI\n\
    \   voice command.  This rule, in combination with a convention to\n   consider\
    \ NoteOn commands with a null third octet as NoteOff commands,\n   supports the\
    \ coding of note sequences using two octets per command.\n   Running status coding\
    \ is only used for voice commands.  The presence\n   of a system common message\
    \ in the stream cancels running status mode\n   for the next voice command.  However,\
    \ system real-time messages do\n   not cancel running status mode.\n"
- title: E.3.  Command Timing
  contents:
  - "E.3.  Command Timing\n   The bitfield formats in Figures E.1 and E.2 do not encode\
    \ the\n   execution time for a command.  Timing information is not a part of\n\
    \   the MIDI command syntax itself; different applications of the MIDI\n   command\
    \ language use different methods to encode timing.\n   For example, the MIDI command\
    \ set acts as the transport layer for\n   MIDI 1.0 DIN cables [MIDI].  MIDI cables\
    \ are short asynchronous\n   serial lines that facilitate the remote operation\
    \ of musical\n   instruments and audio equipment.  Timestamps are not sent over\
    \ a MIDI\n   1.0 DIN cable.  Instead, the standard uses an implicit \"time of\n\
    \   arrival\" code.  Receivers execute MIDI commands at the moment of\n   arrival.\n\
    \   In contrast, Standard MIDI Files (SMFs, [MIDI]), a file format for\n   representing\
    \ complete musical performances, add an explicit timestamp\n   to each MIDI command,\
    \ using a delta encoding scheme that is optimized\n   for statistics of musical\
    \ performance.  SMF timestamps usually code\n   timing using the metric notation\
    \ of a musical score.  SMF meta-events\n   are used to add a tempo map to the\
    \ file, so that score beats may be\n   accurately converted into units of seconds\
    \ during rendering.\n"
- title: E.4.  AudioSpecificConfig Templates for MMA Renderers
  contents:
  - "E.4.  AudioSpecificConfig Templates for MMA Renderers\n   In Section 6.2 and\
    \ Appendix C.6.5, we describe how session\n   descriptions include an AudioSpecificConfig\
    \ data block to specify a\n   MIDI rendering algorithm for mpeg4-generic RTP MIDI\
    \ streams.\n   The bitfield format of AudioSpecificConfig is defined in [MPEGAUDIO].\n\
    \   StructuredAudioSpecificConfig, a key data structure coded in\n   AudioSpecificConfig,\
    \ is defined in [MPEGSA].\n   For implementors wishing to specify Structured Audio\
    \ renderers, a\n   full understanding of [MPEGSA] and [MPEGAUDIO] is essential.\n\
    \   However, many implementors will limit their rendering options to the\n   two\
    \ MIDI Manufacturers Association renderers that may be specified in\n   AudioSpecificConfig:\
    \ General MIDI (GM, [MIDI]) and Downloadable\n   Sounds 2 (DLS 2, [DLS2]).\n \
    \  To aid these implementors, we reproduce the AudioSpecificConfig\n   bitfield\
    \ formats for a GM renderer and a DLS 2 renderer below.  We\n   have checked these\
    \ bitfields carefully and believe they are correct.\n   However, we stress that\
    \ the material below is informative, and that\n   [MPEGAUDIO] and [MPEGSA] are\
    \ the normative definitions for\n   AudioSpecificConfig.\n   As described in Section\
    \ 6.2, a minimal mpeg4-generic session\n   description encodes the AudioSpecificConfig\
    \ binary bitfield as a\n   hexadecimal string (whose format is defined in [RFC3640])\
    \ that is\n   assigned to the \"config\" parameter.  As described in Appendix\
    \ C.6.3,\n   a session description that uses the render parameter encodes the\n\
    \   AudioSpecificConfig binary bitfield as a Base64-encoded string\n   assigned\
    \ to the \"inline\" parameter, or in the body of an HTTP URL\n   assigned to the\
    \ \"url\" parameter.\n   Below, we show a simplified binary AudioSpecificConfig\
    \ bitfield\n   format, suitable for sending and receiving GM and DLS 2 data:\n\
    \       0                   1                   2                   3\n      \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      | AOTYPE  |FREQIDX|CHANNEL|SACNK|  FILE_BLK 1 (required) ...    |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |1|SACNK|\
    \              FILE_BLK 2 (optional) ...                |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |  ...  |1|SACNK| FILE_BLK N (optional) ...                     |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |0|0|\
    \        (first \"0\" bit terminates FILE_BLK list)\n      +-+-+\n           \
    \       Figure E.3 -- Simplified AudioSpecificConfig\n   The 5-bit AOTYPE field\
    \ specifies the Audio Object Type as an unsigned\n   integer.  The legal values\
    \ for use with mpeg4-generic RTP MIDI\n   streams are \"15\" (General MIDI), \"\
    14\" (DLS 2), and \"13\" (Structured\n   Audio).  Thus, receivers that do not\
    \ support all three mpeg4-generic\n   renderers may parse the first 5 bits of\
    \ an AudioSpecificConfig coded\n   in a session description and reject sessions\
    \ that specify unsupported\n   renderers.\n   The 4-bit FREQIDX field specifies\
    \ the sampling rate of the renderer.\n   We show the mapping of FREQIDX values\
    \ to sampling rates in Figure\n   E.4.  Senders MUST specify a sampling frequency\
    \ that matches the RTP\n   clock rate, if possible; if not, senders MUST specify\
    \ the escape\n   value.  Receivers MUST consult the RTP clock parameter for the\
    \ true\n   sampling rate if the escape value is specified.\n                 \
    \      FREQIDX    Sampling Frequency\n                         0x0           \
    \ 96000\n                         0x1            88200\n                     \
    \    0x2            64000\n                         0x3            48000\n   \
    \                      0x4            44100\n                         0x5    \
    \        32000\n                         0x6            24000\n              \
    \           0x7            22050\n                         0x8            16000\n\
    \                         0x9            12000\n                         0xa \
    \           11025\n                         0xb             8000\n           \
    \              0xc          reserved\n                         0xd          reserved\n\
    \                         0xe          reserved\n                         0xf\
    \         escape value\n                     Figure E.4 -- FreqIdx encoding\n\
    \   The 4-bit CHANNEL field specifies the number of audio channels for\n   the\
    \ renderer.  The values 0x1 to 0x5 specify 1 to 5 audio channels;\n   the value\
    \ 0x6 specifies 5+1 surround sound, and the value 0x7\n   specifies 7+1 surround\
    \ sound.  If the rtpmap line in the session\n   description specifies one of these\
    \ formats, CHANNEL MUST be set to\n   the corresponding value.  Otherwise, CHANNEL\
    \ MUST be set to 0x0.\n   The CHANNEL field is followed by a list of one or more\
    \ binary file\n   data blocks.  The 3-bit SACNK field (the chunk_type field in\
    \ class\n   StructuredAudioSpecificConfig, defined in [MPEGSA]) specifies the\n\
    \   type of each data block.\n   For General MIDI, only Standard MIDI Files may\
    \ appear in the list\n   (SACNK field value 2).  For DLS 2, only Standard MIDI\
    \ Files and DLS 2\n   RIFF files (SACNK field value 4) may appear.  For both of\
    \ these file\n   types, the FILE_BLK field has the format shown in Figure E.5:\
    \ a 32-\n   bit unsigned integer value (FILE_LEN) coding the number of bytes in\n\
    \   the SMF or RIFF file, followed by FILE_LEN bytes coding the file\n   data.\n\
    \       0                   1                   2                   3\n      \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |     FILE_LEN (32-bit, a byte count SMF file or RIFF file)     |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \  FILE_DATA (file contents, a list of FILE_LEN bytes) ...      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                  Figure E.5 -- The FILE_BLK field format\n   Note that several\
    \ files may follow CHANNEL field.  The \"1\" constant\n   fields in Figure E.3\
    \ code the presence of another file; the \"0\"\n   constant field codes the end\
    \ of the list.  The final \"0\" bit in\n   Figure E.3 codes the absence of special\
    \ coding tools (see [MPEGAUDIO]\n   for details).  Senders not using these tools\
    \ MUST append this \"0\"\n   bit; receivers that do not understand these coding\
    \ tools MUST ignore\n   all data following a \"1\" in this position.\n   The StructuredAudioSpecificConfig\
    \ bitfield structure requires the\n   presence of one FILE_BLK.  For mpeg4-generic\
    \ RTP MIDI use of DLS 2,\n   FILE_BLKs MUST code RIFF files or SMF files.  For\
    \ mpeg4-generic RTP\n   MIDI use of General MIDI, FILE_BLKs MUST code SMF files.\
    \  By default,\n   this SMF will be ignored (Appendix C.6.4.1).  In this default\
    \ case, a\n   GM StructuredAudioSpecificConfig bitfield SHOULD code a FILE_BLK\n\
    \   whose FILE_LEN is 0, and whose FILE_DATA is empty.\n   To complete this appendix,\
    \ we derive the\n   StructuredAudioSpecificConfig that we use in the General MIDI\
    \ session\n   examples in this memo.  Referring to Figure E.3, we note that for\
    \ GM,\n   AOTYPE = 15.  Our examples use a 44,100 Hz sample rate (FREQIDX = 4)\n\
    \   and are in mono (CHANNEL = 1).  For GM, a single SMF is encoded\n   (SACNK\
    \ = 2), using the SMF shown in Figure E.6 (a 26 byte file).\n               --------------------------------------------\n\
    \              |  MIDI File = <Header Chunk> <Track Chunk>  |\n              \
    \ --------------------------------------------\n   <Header Chunk> = <chunk type>\
    \ <length>     <format> <ntrks> <divsn>\n                    4D 54 68 64  00 00\
    \ 00 06  00 00    00 01   00 60\n   <Track Chunk> = <chunk type>  <length>   \
    \  <delta-time> <end-event>\n                   4D 54 72 6B   00 00 00 04  00\
    \           FF 2F 00\n            Figure E.6 -- SMF file encoded in the example\n\
    \   Placing these constants in binary format into the data structure\n   shown\
    \ in Figure E.3 yields the constant shown in Figure E.7.\n       0           \
    \        1                   2                   3\n       0 1 2 3 4 5 6 7 8 9\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |0 1 1 1 1|0 1 0 0|0 0 0 1|0 1 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |0\
    \ 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0|0 1 0 0|1 1 0 1|0 1 0 1|0 1 0 0|\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |0 1 1 0|1 0 0 0|0 1 1 0|0 1 0 0|0 0 0 0|0 0 0 0|0 0 0 0|0 0 0 0|\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |0\
    \ 0 0 0|0 0 0 0|0 0 0 0|0 1 1 0|0 0 0 0|0 0 0 0|0 0 0 0|0 0 0 0|\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |0 0 0 0|0 0 0 0|0 0 0 0|0 0 0 1|0 0 0 0|0 0 0 0|0 1 1 0|0 0 0 0|\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |0\
    \ 1 0 0|1 1 0 1|0 1 0 1|0 1 0 0|0 1 1 1|0 0 1 0|0 1 1 0|1 0 1 1|\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |0 0 0 0|0 0 0 0|0 0 0 0|0 0 0 0|0 0 0 0|0 0 0 0|0 0 0 0|0 1 1 0|\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |0\
    \ 0 0 0|0 0 0 0|1 1 1 1|1 1 1 1|0 0 1 0|1 1 1 1|0 0 0 0|0 0 0 0|\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |0|0|\n      +-+-+\n            Figure E.7 -- AudioSpecificConfig used\
    \ in GM examples\n   Expressing this bitfield as an ASCII hexadecimal string yields:\n\
    \      7A0A0000001A4D546864000000060000000100604D54726B0000000600FF2F000\n   This\
    \ string is assigned to the \"config\" parameter in the minimal\n   mpeg4-generic\
    \ General MIDI examples in this memo (such as the example\n   in Section 6.2).\
    \  Expressing this string in Base64 [RFC2045] yields:\n      egoAAAAaTVRoZAAAAAYAAAABAGBNVHJrAAAABgD/LwAA\n\
    \   This string is assigned to the \"inline\" parameter in the General MIDI\n\
    \   example shown in Appendix C.6.5.\n"
- title: References
  contents:
  - 'References

    '
- title: Normative References
  contents:
  - "Normative References\n   [MIDI]      MIDI Manufacturers Association.  \"The Complete\
    \ MIDI 1.0\n               Detailed Specification\", 1996.\n   [RFC3550]   Schulzrinne,\
    \ H., Casner, S., Frederick, R., and V.\n               Jacobson, \"RTP: A Transport\
    \ Protocol for Real-Time\n               Applications\", STD 64, RFC 3550, July\
    \ 2003.\n   [RFC3551]   Schulzrinne, H. and S. Casner, \"RTP Profile for Audio\
    \ and\n               Video Conferences with Minimal Control\", STD 65, RFC\n\
    \               3551, July 2003.\n   [RFC3640]   van der Meer, J., Mackie, D.,\
    \ Swaminathan, V., Singer,\n               D., and P. Gentric, \"RTP Payload Format\
    \ for Transport of\n               MPEG-4 Elementary Streams\", RFC 3640, November\
    \ 2003.\n   [MPEGSA]    International Standards Organization.  \"ISO/IEC 14496\n\
    \               MPEG-4\", Part 3 (Audio), Subpart 5 (Structured Audio),\n    \
    \           2001.\n   [RFC4566]   Handley, M., Jacobson, V., and C. Perkins, \"\
    SDP: Session\n               Description Protocol\", RFC 4566, July 2006.\n  \
    \ [MPEGAUDIO] International Standards Organization.  \"ISO 14496 MPEG-\n     \
    \          4\", Part 3 (Audio), 2001.\n   [RFC2045]   Freed, N. and N. Borenstein,\
    \ \"Multipurpose Internet Mail\n               Extensions (MIME) Part One: Format\
    \ of Internet Message\n               Bodies\", RFC 2045, November 1996.\n   [DLS2]\
    \      MIDI Manufacturers Association.  \"The MIDI Downloadable\n            \
    \   Sounds Specification\", v98.2, 1998.\n   [RFC4234]   Crocker, D. and P. Overell,\
    \ \"Augmented BNF for Syntax\n               Specifications: ABNF\", RFC 4234,\
    \ October 2005.\n   [RFC2119]   Bradner, S., \"Key words for use in RFCs to Indicate\n\
    \               Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC3711]\
    \   Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K.\n              \
    \ Norrman, \"The Secure Real-time Transport Protocol\n               (SRTP)\"\
    , RFC 3711, March 2004.\n   [RFC3264]   Rosenberg, J. and H. Schulzrinne, \"An\
    \ Offer/Answer Model\n               with Session Description Protocol (SDP)\"\
    , RFC 3264, June\n               2002.\n   [RFC3986]   Berners-Lee, T., Fielding,\
    \ R., and L. Masinter, \"Uniform\n               Resource Identifier (URI): Generic\
    \ Syntax\", STD 66, RFC\n               3986, January 2005.\n   [RFC2616]   Fielding,\
    \ R., Gettys, J., Mogul, J., Frystyk, H.,\n               Masinter, L., Leach,\
    \ P., and T. Berners-Lee, \"Hypertext\n               Transfer Protocol -- HTTP/1.1\"\
    , RFC 2616, June 1999.\n   [RFC3388]   Camarillo, G., Eriksson, G., Holler, J.,\
    \ and H.\n               Schulzrinne, \"Grouping of Media Lines in the Session\n\
    \               Description Protocol (SDP)\", RFC 3388, December 2002.\n   [RP015]\
    \     MIDI Manufacturers Association.  \"Recommended Practice\n              \
    \ 015 (RP-015): Response to Reset All Controllers\", 11/98.\n   [RFC4288]   Freed,\
    \ N. and J. Klensin, \"Media Type Specifications and\n               Registration\
    \ Procedures\", BCP 13, RFC 4288, December\n               2005.\n   [RFC3555]\
    \   Casner, S. and P. Hoschka, \"MIME Type Registration of RTP\n             \
    \  Payload Formats\", RFC 3555, July 2003.\n"
- title: Informative References
  contents:
  - "Informative References\n   [NMP]       Lazzaro, J. and J. Wawrzynek.  \"A Case\
    \ for Network\n               Musical Performance\", 11th International Workshop\
    \ on\n               Network and Operating Systems Support for Digital Audio\n\
    \               and Video (NOSSDAV 2001) June 25-26, 2001, Port\n            \
    \   Jefferson, New York.\n   [GRAME]     Fober, D., Orlarey, Y. and S. Letz. \
    \ \"Real Time Musical\n               Events Streaming over Internet\", Proceedings\
    \ of the\n               International Conference on WEB Delivering of Music 2001,\n\
    \               pages 147-154.\n   [RFC3261]   Rosenberg, J., Schulzrinne, H.,\
    \ Camarillo, G., Johnston,\n               A., Peterson, J., Sparks, R., Handley,\
    \ M., and E.\n               Schooler, \"SIP: Session Initiation Protocol\", RFC\
    \ 3261,\n               June 2002.\n   [RFC2326]   Schulzrinne, H., Rao, A., and\
    \ R. Lanphier, \"Real Time\n               Streaming Protocol (RTSP)\", RFC 2326,\
    \ April 1998.\n   [ALF]       Clark, D. D. and D. L. Tennenhouse. \"Architectural\n\
    \               considerations for a new generation of protocols\",\n        \
    \       SIGCOMM Symposium on Communications Architectures and\n              \
    \ Protocols , (Philadelphia, Pennsylvania), pp. 200--208,\n               IEEE,\
    \ Sept. 1990.\n   [RFC4696]   Lazzaro, J. and J. Wawrzynek, \"An Implementation\
    \ Guide\n               for RTP MIDI\", RFC 4696, November 2006.\n   [RFC2205]\
    \   Braden, R., Zhang, L., Berson, S., Herzog, S., and S.\n               Jamin,\
    \ \"Resource ReSerVation Protocol (RSVP) -- Version 1\n               Functional\
    \ Specification\", RFC 2205, September 1997.\n   [RFC4288]   Freed, N. and J.\
    \ Klensin, \"Media Type Specifications and\n               Registration Procedures\"\
    , BCP 13, RFC 4288, December\n               2005.\n   [RFC4289]   Freed, N. and\
    \ J. Klensin, \"Multipurpose Internet Mail\n               Extensions (MIME) Part\
    \ Four: Registration Procedures\",\n               BCP 13, RFC 4289, December\
    \ 2005.\n   [RFC4571]   Lazzaro, J. \"Framing Real-time Transport Protocol (RTP)\n\
    \               and RTP Control Protocol (RTCP) Packets over Connection-\n   \
    \            Oriented Transport\", RFC 4571, July 2006.\n   [RFC2818]   Rescorla,\
    \ E., \"HTTP Over TLS\", RFC 2818, May 2000.\n   [SPMIDI]    MIDI Manufacturers\
    \ Association.  \"Scalable Polyphony\n               MIDI, Specification and Device\
    \ Profiles\", Document\n               Version 1.0a, 2002.\n   [LCP]       Apple\
    \ Computer. \"Logic 7 Dedicated Control Surface\n               Support\", Appendix\
    \ B.  Product manual available from\n               www.apple.com.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   John Lazzaro (corresponding author)\n   UC Berkeley\n\
    \   CS Division\n   315 Soda Hall\n   Berkeley CA 94720-1776\n   EMail: lazzaro@cs.berkeley.edu\n\
    \   John Wawrzynek\n   UC Berkeley\n   CS Division\n   631 Soda Hall\n   Berkeley\
    \ CA 94720-1776\n   EMail: johnw@cs.berkeley.edu\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2006).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST,\n   AND THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,\n   EXPRESS OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT\n   THE USE OF THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY\n   IMPLIED WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR\n   PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
