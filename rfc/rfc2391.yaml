- title: __initial_text__
  contents:
  - '       Load Sharing using IP Network Address Translation (LSNAT)

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1998).  All Rights Reserved.\n"
- title: Preface
  contents:
  - "Preface\n   This document combines the idea of address translation described\
    \ in\n   RFC 1631 with real-time load share algorithms to introduce Load Share\n\
    \   Network Address Translators(or, simply LSNATs). LSNATs would\n   transparently\
    \ offload network load on a single server and distribute\n   the load across a\
    \ pool of servers.\n"
- title: Abstract
  contents:
  - "Abstract\n   Network Address Translators (NATs) translate IP addresses in a\n\
    \   datagram, transparent to end nodes, while routing the datagram. NATs\n   have\
    \ traditionally been been used to allow private network domains to\n   connect\
    \ to Global networks using as few as one globally unique IP\n   address.  In this\
    \ document, we extend the use of NATs to offer Load\n   share feature, where session\
    \ load can be distributed across a pool of\n   servers, instead of directing to\
    \ a single server.  Load sharing is\n   beneficial to service providers and system\
    \ administrators alike in\n   grappling with scalability of servers with increasing\
    \ session load.\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   Traditionally, Network Address Translators, or simply NATs\
    \ were used\n   to connect private network domains to globally unique public domain\n\
    \   IP networks. Applications originate in private domains and NATs would\n  \
    \ transparently translate datagrams belonging to these applications in\n   either\
    \ direction. This document combines the characteristic of\n   transparent address\
    \ translation with real-time load share algorithms\n   to introduce Load Share\
    \ Network Address Translators.\n   The problem of Load sharing or Load balancing\
    \ is not new and goes\n   back many years. A variety of techniques were applied\
    \ to address the\n   problem.  Some very ad-hoc and platform specific and some\
    \ employing\n   clever schemes to reorder DNS resource records. REF [11] uses\
    \ DNS\n   zone transfer program in name servers to periodically shuffle the\n\
    \   order of resource records for server nodes based on a pre-determined\n   load\
    \ balancing algorithm. The problem with this approach is that\n   reordering time\
    \ periods can be very large on the order of minutes and\n   does not reflect real-time\
    \ load variations on the servers.  Secondly,\n   all hosts in the server pool\
    \ are assumed to have equal capability to\n   offer all services. This may not\
    \ often be the case. In addition,\n   there may be requirement to support load\
    \ balancing for a few specific\n   services only. The load share approach outlined\
    \ in this document\n   addresses both these concerns and offers a solution that\
    \ does not\n   require changes to clients or servers and one that can be tailored\
    \ to\n   individual services or for all services.\n   For the reminder of this\
    \ document, we will refer to NAT routers that\n   provide load sharing support\
    \ as LSNATs. Unlike traditional NATs,\n   LSNATs are not required to operate between\
    \ private and public domain\n   routing realms alone. LSNATs also operate in a\
    \ single routing realm\n   and provide load sharing functionality.\n   The need\
    \ for Load sharing arises when a single server is not able to\n   cope with increasing\
    \ demand for multiple sessions simultaneously.\n   Clearly, load sharing across\
    \ multiple servers would enhance\n   responsiveness and scale well with session\
    \ load. Popular applications\n   inundating servers would include Web browsers,\
    \ remote login, file\n   transfer and mail applications.\n   When a client attempts\
    \ to access a server through an LSNAT router,\n   the router selects a node in\
    \ server pool, based on a load share\n   algorithm and redirect the request to\
    \ that node. LSNATs pose no\n   restriction on the organization and rearrangement\
    \ of nodes in server\n   pool. Nodes in a pool may be replaced, new nodes may\
    \ be added and\n   others may be in transition. Changes of this kind to server\
    \ pool can\n   be shielded from client nodes by making LSNAT router the focal\
    \ point\n   for change management.\n   There are limitations to using LSNATs.\
    \  Firstly, it is mandatory that\n   all requests and responses pertaining to\
    \ a session between a client\n   and server be routed via the same LSNAT router.\
    \ For this reason, we\n   recommend LSNATs to be operated on a single border router\
    \ to a stub\n   domain in which the server pool would be confined.  This would\
    \ ensure\n   that all traffic directed to servers from clients outside the domain\n\
    \   and vice versa would necessarily traverse the LSNAT border router.\n   Later\
    \ in the document, we will examine a special case of LSNAT setup,\n   which gets\
    \ around the topological constraint on server pool. Another\n   limitation of\
    \ LSNATs is the inability to switch loads between hosts\n   in the midst of sessions.\
    \ This is because LSNATs measure load in\n   granularity of sessions. Once a session\
    \ is assigned to a host, the\n   session cannot be moved to a different host till\
    \ the end of that\n   session. Other limitations, inherent to NATs, as outlined\
    \ in REF [1]\n   are also applicable to LSNATs.\n   As with traditional NATs,\
    \ LSNATs have the disadvantage of taking away\n   the end-to-end significance\
    \ of an IP address. The major advantage,\n   however, is that it can be installed\
    \ without changes to clients or\n   servers.\n"
- title: 2. Terminology and concepts used
  contents:
  - '2. Terminology and concepts used

    '
- title: 2.1. TU ports, Server ports, Client ports
  contents:
  - "2.1. TU ports, Server ports, Client ports\n   For the reminder of this document,\
    \ we will refer TCP/UDP ports\n   associated with an IP address simply as \"TU\
    \ ports\".\n   For most TCP/IP hosts, TU port range 0-1023 is used by servers\n\
    \   listening for incoming connections. Clients trying to initiate a\n   connection\
    \ typically select a TU port in the range of 1024-65535.\n   However, this convention\
    \ is not universal and not always followed. It\n   is possible for client nodes\
    \ to initiate connections using a TU port\n   number in the range of 0-1023, and\
    \ there are applications listening\n   on TU port numbers in the range of 1024-65535.\n\
    \   A complete list of TU port services may be found in REF [2].  The TU\n   ports\
    \ used by servers to listen for incoming connections are called\n   \"Server Ports\"\
    \ and the TU ports used by clients to initiate a\n   connection to server are\
    \ called \"Client Ports\".\n"
- title: 2.2. Session flow vs. Packet flow
  contents:
  - "2.2. Session flow vs. Packet flow\n   Connection or session flows are different\
    \ from packet flows. A\n   session flow  indicates the direction in which the\
    \ session was\n   initiated with reference to a network port. Packet flow is the\n\
    \   direction in which the packet has traversed with reference to a\n   network\
    \ port.  A session flow is uniquely identified by the direction\n   in which the\
    \ first packet of that session traversed.\n   Take for example, a telnet session.\
    \ The telnet session consists of\n   packet flows in both inbound and outbound\
    \ directions. Outbound telnet\n   packets carry terminal keystrokes from the client\
    \ and inbound telnet\n   packets carry screen displays from the telnet server.\
    \  Performing\n   address translation for a telnet session would involve translation\
    \ of\n   incoming as well as outgoing packets belonging to that session.\n   Packets\
    \ belonging to a TCP/UDP  session are uniquely identified by\n   the tuple of\
    \ (source IP address, source TU port, target IP address,\n   target TU port).\
    \ ICMP sessions that correlate queries and responses\n   using query id are uniquely\
    \ identified by the tuple of (source IP\n   address, ICMP Query Identifier, target\
    \ IP address). For lack of\n   well-known ways to distinguish, all other types\
    \ of sessions are\n   lumped together and distinguished by the tuple of (source\
    \ IP address,\n   IP protocol, target IP address).\n"
- title: 2.3. Start of session for TCP, UDP and others
  contents:
  - "2.3. Start of session for TCP, UDP and others\n   The first packet of every TCP\
    \ session tries to establish a session\n   and contains connection startup information.\
    \ The first packet of a\n   TCP session may be recognized by the presence of SYN\
    \ bit and absence\n   of ACK bit in the TCP flags. All TCP packets, with the exception\
    \ of\n   the first packet must have the ACK bit set.\n   The first packet of every\
    \ session, be it a TCP session, UDP session,\n   ICMP query session or any other\
    \ session, tries to establish a\n   session.  However, there is no deterministic\
    \ way of recognizing the\n   start of a UDP session or any other non-TCP session.\n\
    \   Start of session is significant with NATs, as a state describing\n   translation\
    \ parameters for the session is established  at the start\n   of session. Packets\
    \ pertaining to the session cannot undergo\n   translation, unless a state is\
    \ established by NAT at the start of\n   session.\n"
- title: 2.4. End of session for TCP, UDP and others
  contents:
  - "2.4. End of session for TCP, UDP and others\n   The end of a TCP session is detected\
    \ when FIN is acknowledged by both\n   halves of the session or when either half\
    \ receives RST bit in TCP\n   flags field. Within a short period (say, a couple\
    \ of seconds) after\n   one of the session partners sets RST bit, the session\
    \ can be safely\n   assumed to have been terminated.\n   For all other types of\
    \ session, there is no deterministic way of\n   determining the end of session\
    \ unless you know the application\n   protocol. Many heuristic approaches are\
    \ used to terminate sessions.\n   You can make the assumption that TCP sessions\
    \ that have not been used\n   for say, 24 hours, and non-TCP sessions that have\
    \ not been used for\n   say, 1 minute,  are terminated. Often this assumption\
    \ works, but\n   sometimes it doesn't. These idle period session timeouts may\
    \ vary\n   considerably across the board and may be made user configurable.\n\
    \   Another way to handle session terminations is to timestamp sessions\n   and\
    \ keep them as long as possible and retire the longest idle session\n   when it\
    \ becomes necessary.\n"
- title: 2.5. Basic Network Address Translation (Basic NAT)
  contents:
  - "2.5. Basic Network Address Translation (Basic NAT)\n   Basic NAT is a method\
    \ by which hosts in a private network domain are\n   allowed access to hosts in\
    \ the external network transparently.  A\n   block of external addresses are set\
    \ aside for translating addresses\n   of private hosts as the private hosts originate\
    \ sessions to\n   applications in external domain. Once an external address is\
    \ bound by\n   the NAT device to a specific private address, that address binding\n\
    \   remains in place for all subsequent sessions originating from the\n   same\
    \ private host. This binding may be terminated when there are no\n   sessions\
    \ left to use the binding.\n"
- title: 2.6. Network Address Port Translation (NAPT)
  contents:
  - "2.6. Network Address Port Translation (NAPT)\n   Network Address Port Translation(NAPT)\
    \ is a method by which hosts in\n   a private network domain are allowed simultaneous\
    \ access to hosts in\n   the external network transparently using a single registered\
    \ address.\n   This is made possible by multiplexing transport layer identifiers\
    \ of\n   private hosts into the transport identifiers of the single assigned\n\
    \   external address. For this reason, only the applications based on TCP\n  \
    \ and UDP protocols are supported by NAPT. ICMP query based\n   applications are\
    \ also supported as the ICMP header carries a query\n   identifier that is used\
    \ to corelate responses with requests.\n   Sessions other than TCP, UDP and ICMP\
    \ query type are simply not\n   permitted from local nodes, serviced by a NAPT\
    \ router.\n"
- title: 2.7. Load share
  contents:
  - "2.7. Load share\n   Load sharing for the purpose of this document is defined\
    \ as the\n   spread of session load amongst a cluster of servers  which are\n\
    \   functionally similar or the same.  In other words, each of the nodes\n   in\
    \ cluster can support a client session equally well with no\n   discernible difference\
    \ in functionality. Once a node is assigned to\n   service a session, that session\
    \ is bound to that node till\n   termination. Sessions are not allowed to swap\
    \ between nodes in the\n   midst of session.\n   Load sharing may be applicable\
    \ for all services, if all hosts in\n   server cluster carry the capability to\
    \ carry out all services.\n   Alternately, load sharing may be limited to one\
    \ or more specific\n   services alone and not to others.\n   Note, the term \"\
    Session load\" used in the context of load share is\n   different from the term\
    \ \"system load\" attributed to hosts by way of\n   CPU, memory and other resource\
    \ usage on the system.\n"
- title: 3. Overview of Load sharing
  contents:
  - "3. Overview of Load sharing\n   While both traditional NATs and LSNATs perform\
    \ address translations,\n   and provide transparent connectivity between end nodes,\
    \ there are\n   distinctions between the two. Traditional NATs initiate translations\n\
    \   on outbound sessions, by binding a private address to a global\n   address\
    \ (basic NAT) or by binding a tuple of private address and\n   transport identifier\
    \ (such as TCP/UDP port or ICPM query ID) to a\n   tuple of global address and\
    \ transport identifier. LSNATs, on the\n   other hand, initiate translations on\
    \ inbound sessions, by binding\n   each session represented by a tuple such as\
    \ (client address, client\n   TU port, virtual server address, server TU port)\
    \ to one of server\n   pool nodes, selected based on a real-time load-share algorithm.\
    \ A\n   virtual server address is a globally unique IP address that\n   identifies\
    \ a physical server or a group of servers that can provide\n   similar or same\
    \ functionality.\n   For the reminder of this document, we will refer traditional\
    \ NATs\n   simply as NATs and refer LSNATs exclusively in the context of load\n\
    \   share, without implying traditional NAT functionality.\n   LSNATs are not\
    \ limited to operate between private and public domain\n   routing realms. LSNATs\
    \ may operate within a single routing realm with\n   globally unique IP addresses,\
    \ just as well as between private and\n   public network domains. The only requirement\
    \ is that server pool be\n   confined to a stub domain, accessible to clients\
    \ outside the domain\n   through a single LSNAT border router. However, as you\
    \ will notice\n   later, this topology limitation on server pool can be overcome\
    \ under\n   certain configurations.\n   Load Share NAT operates as follows. A\
    \ client attempts to access a\n   server by using the server virtual address.\
    \ The LSNAT router\n   transparently redirects the request to one of the hosts\
    \ in server\n   pool, selected using a real-time load sharing algorithm. Multiple\n\
    \   sessions may be initiated from the same client, and each session\n   could\
    \ be directed to a different host based on load balance across\n   server pool\
    \ hosts at the time. If load share is desired for just a\n   few specific services,\
    \ the configuration on LSNAT could be defined to\n   restrict load share for just\
    \ the services desired.\n   In the case where virtual server address is same as\
    \ the interface\n   address of an LSNAT router, server applications (such as telnet)\
    \ on\n   LSNAT router must be disabled for external access on that address.\n\
    \   This is the limitation to using address owned by LSNAT router as the\n   virtual\
    \ server address.\n   Load share NAT operation is also applicable during individual\
    \ server\n   upgrades as follows. Say, a server, that needs to be upgraded is\n\
    \   statically mapped to a backup server on the inbound.  Subsequent to\n   this\
    \ mapping, new session requests to the original server would be\n   redirected\
    \ by LSNAT to the backup server.  As an extension, it is\n   also possible to\
    \ statically map a specific TU port service on a\n   server to that of  backup\
    \ sever.\n   We illustrate the operation of LSNAT in the following subsections,\n\
    \   where  (a) servers are confined to a stub domain, and belong to\n   globally\
    \ unique address space as shared by clients, (b) servers are\n   confined to private\
    \ address space stub domain, and (c) servers are\n   not restrained by any topological\
    \ limitations.\n"
- title: 3.1 Operation of LSNAT in a globally unique address space
  contents:
  - "3.1 Operation of LSNAT in a globally unique address space\n   In this section,\
    \ we will illustrate the operation of LSNAT in a\n   globally unique address space.\
    \ The border router with LSNAT enabled\n   on WAN link would perform load sharing\
    \ and address translations for\n   inbound sessions. However, sessions outbound\
    \ from the hosts in server\n   pool will not be subject to any type of translation,\
    \ as all nodes\n   have globally unique IP addresses.\n   In the example below,\
    \ servers S1 (172.85.0.1), S2(172.85.0.2) and\n   S3(172.85.0.3) form a server\
    \ pool, confined to a stub domain. LSNAT\n   on the border router is enabled on\
    \ the WAN link, such that the\n   virtual server address S(172.87.0.100) is mapped\
    \ to the server pool\n   consisting of hosts S1, S2 and S3. When a client 198.76.29.7\n\
    \   initiates a HTTP session to the virtual server S, the LSNAT router\n   examines\
    \ the load on hosts in server pool and selects a host, say S1\n   to service the\
    \ request. The transparent address and TU port\n   translations performed by the\
    \ LSNAT router become apparent as you\n   follow the down arrow line. IP packets\
    \ on the return path go through\n   similar address translation. Suppose, we have\
    \ another client\n   198.23.47.2 initiating telnet session to the same virtual\
    \ server S.\n   The LSNAT would determine that host S3 is a better choice to service\n\
    \   this session as S1 is busy with a session and redirect the session to\n  \
    \ S3. The second session redirection path is delineated with colons.\n   The procedure\
    \ continues for any number of sessions the same way.\n   Notice that this requires\
    \ no changes to clients or servers. All the\n   configuration and mapping necessary\
    \ would be limited just to the\n   LSNAT router.\n                           \
    \        \\ | /\n                                 +---------------+\n        \
    \                         |Backbone Router|\n                                \
    \ +---------------+\n                               WAN |\n                  \
    \                 |\n         Stub domain border .......|.........\n         \
    \                          |\n   {s=198.76.29.7, 2745, v         |           \
    \ {s=198.23.47.2,  3200,\n    d=172.87.0.100, 80 } v         |             d=172.87.0.100,\
    \ 23 }\n                         v +------------------+ :\n                  \
    \       v |Border Router with| :\n                         v |LSNAT enabled on\
    \  | :\n                         v |WAN interface     | :\n                  \
    \       v +------------------+ :\n                         v       |         \
    \     :\n                         v       |  LAN         :\n                 \
    \  ------v----------------------:---\n   {s=198.76.29.7, 2745, v |           \
    \ |         |:{s=198.23.47.2, 3200,\n    d=172.85.0.1,  80  }   |         |  \
    \       |  d=172.85.0.3,  23 }\n                         +--+      +--+      \
    \ +--+\n                         |S1|      |S2|       |S3|\n                 \
    \        |--|      |--|       |--|\n                        /____\\    /____\\\
    \     /____\\\n                    172.85.0.1   172.85.0.2  172.85.0.3\n    Figure\
    \ 1: Operation of LSNAT in Globally unique address space\n"
- title: 3.2. Operation of LSNAT in conjunction with a private network
  contents:
  - "3.2. Operation of LSNAT in conjunction with a private network\n   In this section,\
    \ we will illustrate the operation of LSNAT in\n   conjunction with NAT on the\
    \ same router. The NAT configuration is\n   required for translation of outbound\
    \ sessions and could be either\n   Basic NAT or NAPT.  The illustration below\
    \ will assume NAPT on the\n   outbound and LSNAT on the inbound on WAN link.\n\
    \   Say, an organization has a private IP network and a WAN link to\n   backbone\
    \ router. The private network's stub router is assigned a\n   globally valid address\
    \ on the WAN link and the remaining nodes in the\n   organization have IP addresses\
    \ that have only local significance. The\n   border router is NAPT configured\
    \ on the outbound allowing access to\n   external hosts, using the single registered\
    \ IP address.\n   In addition, say the organization has servers S1 (10.0.0.1),\n\
    \   S2(10.0.0.2) and S3 (10.0.0.3) that form a pool to provide inbound\n   access\
    \ to external clients. This is made possible by enabling LSNAT\n   on the WAN\
    \ link of the border router, such that virtual server\n   address S(198.76.28.4)\
    \ is mapped to the server pool consisting of\n   hosts S1, S2 and S3. When an\
    \ external client 198.76.29.7 initiates a\n   HTTP session to the virtual server\
    \ S, the LSNAT router examines load\n   on hosts in server pool and selects a\
    \ host, say S1 to service the\n   request. The transparent address  and TU port\
    \ translations performed\n   by the LSNAT router are apparent as you follow the\
    \ down arrow line.\n   IP packets on the return path go through similar address\
    \ translation.\n   Suppose, we have another client 198.23.47.2 initiating telnet\
    \ session\n   to the same address. The LSNAT would determine that host S3 is a\n\
    \   better choice to service this session as S1 is busy with a session\n   and\
    \ redirect the session to S3. The second session redirection path\n   is delineated\
    \ with colons. The procedure continues for any number of\n   sessions the same\
    \ way.\n                                   \\ | /\n                          \
    \       +---------------+\n                                 |Backbone Router|\n\
    \                                 +---------------+\n                        \
    \       WAN |\n                                   |\n        Stub domain border\
    \ ........|.........\n                                   |\n   {s=198.76.29.7,\
    \ 2745, v         |           {s=198.23.47.2, 3200,\n    d=198.76.28.4, 80   }v\
    \         |           :d=198.76.28.4, 23 }\n                         v+-------------------+:\n\
    \                         v|Border Router with |:\n                         v|\
    \  LSNAT and NAPT   |:\n                         v|enabled on WAN link|:\n   \
    \                      v+-------------------+:\n                         v   \
    \   |              :\n                         v      |  LAN         :\n     \
    \              ------v---------------------:------\n   {s=198.76.29.7, 2745, v\
    \ |            |       | : {s=198.23.47.2, 3200,\n    d=10.0.0.1,    80  }   |\
    \         |       |    d=10.0.0.3,    23 }\n                         +--+    \
    \  +--+     +--+\n                         |S1|      |S2|     |S3|\n         \
    \                |--|      |--|     |--|\n                        /____\\    /____\\\
    \   /____\\\n                       10.0.0.1  10.0.0.2  10.0.0.3\n     Figure\
    \ 2: Operation of LSNAT, in coexistence with NAPT\n   Once again, notice that\
    \ this requires no changes to clients or\n   servers.  The translation is completely\
    \ transparent to end nodes.\n   Address mapping on the LSNAT performs load sharing\
    \ and address\n   translations for inbound sessions. Sessions outbound from hosts\
    \ in\n   server pool are subject to NAPT. Both NAT and LSNAT co-exist with\n \
    \  each other in the same router.\n"
- title: 3.3. Load Sharing with no topological restraints on servers
  contents:
  - "3.3. Load Sharing with no topological restraints on servers\n   In this section,\
    \ we will illustrate a configuration in which load\n   sharing can be accomplished\
    \ on a router without enforcing topological\n   limitations on servers. In this\
    \ configuration, virtual server address\n   will be owned by the router that supports\
    \ load sharing. I.e., virtual\n   server address will be same as address of one\
    \ of the interfaces of\n   load share router. We will distinguish this configuration\
    \ from LSNAT\n   by referring this as \"Load Share Network Address Port Translation\"\
    \n   (LS-NAPT). Routers that support the LS-NAPT configuration will be\n   termed\
    \ \"LS-NAPT routers\", or simply LS-NAPTs.\n   In an LSNAT router, inbound TCP/UDP\
    \ sessions, represented by the\n   tuple of (client address, client TU port, virtual\
    \ server address,\n   service port) are translated into a tuple of (client address,\
    \ client\n   TU port, selected server address, service port). Translation is\n\
    \   carried out on all datagrams pertaining to the same session, in\n   either\
    \ direction. Whereas, LS-NAPT router would translate the same\n   session into\
    \ a tuple of (virtual server address, virtual server TU\n   port, selected server,\
    \ service port). Notice that LS-NAPT router\n   translates the client address\
    \ and TU port with the address and TU\n   port of virtual server, which is same\
    \ as the address of one of its\n   interfaces. By doing this, datagrams from clients\
    \ as well as servers\n   are forced to bear the address of LS-NAPT router as the\
    \ destination\n   address, thereby guaranteeing that the datagrams would necessarily\n\
    \   traverse the LS-NAPT router. As a result, there is no need to require\n  \
    \ servers to be under topological constraints.\n   Take for example, figure 1\
    \ in section 3.1. Let us say the router on\n   which load sharing is enabled is\
    \ not just a border router, but can be\n   any kind of router. Let us also say\
    \ that the virtual server address S\n   (172.87.0.100) is same as the address\
    \ of WAN link and LS-NAPT is\n   enabled on the WAN interface. Figure 3 summarizes\
    \ the new router\n   configuration.\n   When a client 198.76.29.7 initiates a\
    \ HTTP session to the virtual\n   server address S (i.e., address of the WAN interface),\
    \ the LS-NAPT\n   router examines load on hosts in server pool and selects a host,\
    \ say\n   S1 to service the request. Appropriately, the destination address is\n\
    \   translated to be S1 (172.85.0.1). Further, original client address\n   and\
    \ TU port are replaced with the address and TU port of the WAN\n   link.  As a\
    \ result, destination addresses as well as source address\n   and source TU port\
    \ are translated when the packet reaches S1, as can\n   be noticed from the down-arrow\
    \ path. IP packets on the return path go\n   through similar translation. The\
    \ second client 198.23.47.2 initiating\n   telnet session to the same virtual\
    \ server address S is load share\n   directed to S3. This packet once again undergoes\
    \ LS-NAPT translation,\n   just as with the first client. The data path and translations\
    \ can be\n   noticed following the colon line. The procedure continues for any\n\
    \   number of sessions the same way. The translations made to datagrams\n   in\
    \ either direction are completely transparent to end nodes.\n                \
    \                   \\ | /\n                              +---------------+\n\
    \                              |   Router      |\n                           \
    \   +---------------+\n                            WAN |\n                   \
    \             |\n                                |\n   {s=198.76.29.7, 2745, v\
    \      |                {s=198.23.47.2, 3200,\n    d=198.76.28.4, 80   }v    \
    \  | 198.76.28.4  :d=198.76.28.4, 23 }\n                         v +----------------+\
    \  :\n                         v | A Router with  |  :\n                     \
    \    v | LS-NAPT enabled|  :\n                            v | on WAN link    |\
    \  :\n                         v +----------------+  :\n                     \
    \    v               |     :\n                         v          LAN  |     :\n\
    \                   ------v---------------------:------\n   {s=198.76.28.4, 7001,\
    \ v|             |        |:{s=198.76.28.4,7002,\n    d=172.85.0.1,   80 }  |\
    \          |        |  d=172.85.0.3,  23 }\n                        +--+     \
    \  +--+      +--+\n                        |S1|       |S2|      |S3|\n       \
    \                 |--|       |--|      |--|\n                       /____\\  \
    \   /____\\    /____\\\n                     172.85.0.1 172.85.0.2 172.85.0.3\n\
    \     Figure 3: LS-NAPT configuration on a router\n   As you will notice, datagrams\
    \ from clients as well as servers are\n   forced to be directed to the router,\
    \ because they use WAN interface\n   address of router as the destination address\
    \ in their datagrams. With\n   the assurance that all packets from clients and\
    \ servers would\n   traverse the router, there is no longer a requirement for\
    \ servers to\n   be confined to a stub domain and for LSNAT to be enabled only\
    \ on\n   border router to the stub domain.\n   The LS-NAPT configuration described\
    \ in this section involves more\n   translations and hence is more complex compared\
    \ to LSNAT\n   configurations described in the previous sections. While the\n\
    \   processing is complex, there are benefits to this configuration.\n   Firstly,\
    \ it breaks down restraints on server topology. Secondly, it\n   scales with bandwidth\
    \ expansion for client access. Even if Service\n   providers have one link today\
    \ for client access, the LS-NAPT\n   configuration allows them to expand to more\
    \ links in the future\n   guaranteeing the same LS-NAPT load share service on\
    \ newer links.\n   The configuration is not without its limitations. Server applications\n\
    \   (such as telnet) on the router box would have to be disabled for the\n   interface\
    \ address assigned to be virtual server address. Load sharing\n   would be limited\
    \ to TCP and UDP applications only. Maximum\n   concurrently allowed sessions\
    \ would be limited by the maximum allowed\n   TCP/UDP client ports on the same\
    \ address. Assuming that ports 0-1023\n   must be set aside as well-known service\
    \ ports, that would leave a\n   maximum of 63K TCP client ports and 63K of UDP\
    \ client ports on the\n   LS-NAPT router to communicate with each load-share server.\
    \  As a\n   result, LS-NAPT routers will not be able to concurrently support more\n\
    \   than a maximum of (63K * count of Load-share servers) TCP sessions\n   and\
    \ (63K * count of Load-share servers) UDP sessions.\n"
- title: 4.0. Translation phases of a session in LSNAT router.
  contents:
  - "4.0. Translation phases of a session in LSNAT router.\n   As with NATs, LSNATs\
    \ must monitor the following three phases in\n   relation to Address translation.\n"
- title: '4.1. Session binding:'
  contents:
  - "4.1. Session binding:\n   Session binding is the phase in which an incoming session\
    \ is\n   associated with the address of a host in server pool. This\n   association\
    \ essentially sets the translation parameters for all\n   subsequent datagrams\
    \ pertaining to the session. For addresses that\n   have static mapping, the binding\
    \ happens at startup time. Otherwise,\n   each incoming session is dynamically\
    \ bound to a different host based\n   on a load sharing algorithm.\n"
- title: '4.2. Address lookup and translation:'
  contents:
  - "4.2. Address lookup and translation:\n   Once session binding is established\
    \ for a connection setup, all\n   subsequent packets belonging to the same connection\
    \ will be subject\n   to session lookup for translation purposes.\n   For outbound\
    \ packets of a session, the source IP address (and source\n   TU port, in case\
    \ of TCP/UDP sessions) and related fields (such as IP,\n   TCP, UDP and ICMP header\
    \ checksums) will undergo translation. For\n   inbound packets of a session, the\
    \ destination IP address (and\n   destination TU port, in case of TCP/UDP sessions)\
    \ and related fields\n   such as IP, TCP, UDP and ICMP header checksums) will\
    \ undergo\n   translation.\n   The header and payload modifications made to IP\
    \ datagrams subject to\n   LSNAT will be exactly same as those subject to traditional\
    \ NATs,\n   described in section 5.0 of REF [1]. Hence, the reader is urged to\n\
    \   refer REF [1] document for packet translation process.\n"
- title: '4.3. Session unbinding:'
  contents:
  - "4.3. Session unbinding:\n   Session unbinding is the phase in which a server\
    \ node is no longer\n   responsible for the session. Usually, session unbinding\
    \ happens when\n   the end of session is detected.  As described in the terminology\n\
    \   section, it is not always easy to determine end of session.\n"
- title: 5. Load share algorithms
  contents:
  - "5. Load share algorithms\n   Many algorithms are available to select a host from\
    \ a pool of servers\n   to service a new session. The load distribution is based\
    \ primarily on\n   (a) cost of accessing the network on which a  server resides\
    \ and load\n   on the network interface used to access the server, and (b)resource\n\
    \   availability and system load on the server. A variety of policies can\n  \
    \ be adapted to distribute sessions across the servers in a server\n   pool.\n\
    \   For simplicity, we will consider two types algorithms, based on\n   proximity\
    \ between server nodes and LSNAT router. The higher the cost\n   of access to\
    \ a sever, the farther the proximity of server is assumed\n   to be. The first\
    \ kind of algorithms will assume that all server pool\n   members are at equal\
    \ or nearly equal proximity to LSNAT router and\n   hence the load distribution\
    \ can be based solely on resource\n   availability or system load on remote servers.\
    \ Cost of network access\n   will be  considered irrelevant. The second kind would\
    \ assume that all\n   server pool members have equal resource availability and\
    \ the criteria\n   for selection would be proximity to servers. In other words,\
    \ we\n   consider algorithms which take into account the cost of network\n   access.\n"
- title: 5.1. Local Load share algorithms
  contents:
  - "5.1. Local Load share algorithms\n   Ideally speaking, the selection process\
    \ would have precise knowledge\n   of real-time resource availability and system\
    \ load for each host in\n   server pool, so that the selection of host with maximum\
    \ unutilized\n   capacity would be the obvious choice. However, this is not so\
    \ easy to\n   achieve.\n   We consider here two kinds of heuristic approaches\
    \ to monitor session\n   load on server pool members. The first kind is where\
    \ the load share\n   selector tracks system load on individual servers in non-intrusive\n\
    \   way.  The second kind is where the individual members actively\n   participate\
    \ in communicating with the load share selector, notifying\n   the selector of\
    \ their load capacity.\n   Listed below are the most common selection algorithms\
    \ adapted in the\n   non-intrusive category.\n   1. Round-Robin algorithm\n  \
    \    This is the simplest scheme, where a host is selected simply on a\n     \
    \ round robin basis, without regard to load on the host.\n   2. Least Load first\
    \ algorithm\n      This is an improvement over round-robin approach, in that,\
    \ the\n      host with least number of sessions bound to it is selected to\n \
    \     service a new session. This approach is not without its caveats.\n     \
    \ Each session is assumed to be as resource consuming as any other\n      session,\
    \ independent of the type of service the session represents\n      and all hosts\
    \ in server pool are assumed to be equally\n      resourceful.\n   3. Least traffic\
    \ first algorithm\n      A further improvement over the previous algorithm would\
    \ be to\n      measure system load by tracking packet count or byte count\n  \
    \    directed from or to each of the member hosts over a period of\n      time.\
    \ Although packet count is not the same as system load, it is\n      a reasonable\
    \ approximation.\n   4. Least Weighted Load first approach\n      This would be\
    \ an enhancement to the first two. This would allow\n      administrators to assign\
    \ (a) weights to sessions, based on likely\n      resource consumption estimates\
    \ of session types and (b) weights to\n      hosts based on resource availability.\n\
    \      The sum of all session loads by weight assigned to a server,\n      divided\
    \ by weight of server would be evaluated to select the\n      server with least\
    \ weighted load to assign for each new session.\n      Say, FTP sessions are assigned\
    \ 5 times the weight(5x) as a telnet\n      session(x), and server S3 is assumed\
    \ to be 3 times as resourceful\n      as server S1. Let us also say that S1 is\
    \ assigned 1 FTP session\n      and 1 telnet session, whereas S3 is assigned 2\
    \ FTP sessions and 5\n      telnet sessions. When a new telnet session need assignment,\
    \ the\n      weighted load on S3 is evaluated to be (2*5x+5*x)/3 = 5x, and the\n\
    \      load on S1 is evaluated to be (1*5x+1*x) = 6x. Server S3 is\n      selected\
    \ to bind the new telnet session, as the weighted load on\n      S3 is smaller\
    \ than that of S1.\n   5. Ping to find the most responsive host.\n      Till now,\
    \ capacity of a member host is determined exclusively by\n      the LSNAT using\
    \ heuristic approaches. In reality, it is impossible\n      to predict system\
    \ capacity from remote, without interaction with\n      member hosts. A prudent\
    \ approach would be to periodically ping\n      member hosts and measure the response\
    \ time to determine how busy\n      the hosts really are. Use the response time\
    \ in conjunction with\n      the heuristics to select the host most appropriate\
    \ for the new\n      session.\n   In the active category, we involve individual\
    \ member hosts in\n   resource utilization monitoring process. An agent software\
    \ on each\n   node would notify the monitoring agent on resource availability.\n\
    \   Clearly, this would imply having an application program (one that\n   does\
    \ not consume significant resources, by itself) to run on each\n   member node.\
    \ This strategy of involving member hosts in system load\n   monitoring is likely\
    \ to yield the most optimal results in the\n   selection process.\n"
- title: 5.2. Distributed Load share algorithms
  contents:
  - "5.2. Distributed Load share algorithms\n   When server nodes are distributed\
    \ geographically across different\n   areas and cost to access them vary widely,\
    \ the load share selector\n   could use that information in selecting a server\
    \ to service a new\n   session. In order to do this, the load share selector would\
    \ need to\n   consult the routing tables maintained by routing protocols such\
    \ as\n   RIP and OSPF to find the cost of accessing a server.\n   All algorithms\
    \ listed below would be non-intrusive kind where the\n   server nodes do not actively\
    \ participate in notifying the load share\n   selector of their load capacity.\n\
    \   1. Weighted Least Load first algorithm\n      The selection criteria would\
    \ be based on (a) cost of access to\n      server, and (b) the number of sessions\
    \ assigned to server.  The\n      product of cost and session load for each server\
    \ would be\n      evaluated to select the server with least weighted load for\
    \ each\n      new session. Say, cost of accessing server S1 is twice as much as\n\
    \      that of server S2. In that case, S1 will be assigned twice as much\n  \
    \    load as that of S2 during the distribution process. When a server\n     \
    \ is not accessible due to network failure, the cost of access is\n      set to\
    \ infinity and hence no further load can be assigned to that\n      server.\n\
    \   2. Weighted Least traffic first algorithm\n      An improvement over the previous\
    \ algorithm would be\n      to measure network load by tracking packet count or\
    \ byte\n      count directed from or to each of the member hosts over a\n    \
    \  period of time. Although packet count is not the same as\n      system load,\
    \ it is a reasonable approximation. So, the\n      product of cost and traffic\
    \ load (over a fixed duration)\n      for each server would be evaluated to select\
    \ the server\n      with least weighted traffic load for each new session.\n"
- title: 6. Dead host detection
  contents:
  - "6. Dead host detection\n   As sessions are assigned to hosts, it is important\
    \ to detect the\n   live-ness of the hosts. Otherwise, sessions could simply be\
    \ black-\n   holed into a dead host. Many heuristic approaches are adopted.\n\
    \   Sending pings periodically would be one way to determine the live-\n   ness.\
    \ Another approach would be to track datagrams originating from a\n   member host\
    \ in response to new session assignments.  If no response\n   is detected in a\
    \ few seconds, declare the server dead and do not\n   assign new sessions to this\
    \ host. The server can be monitored later\n   again after a long pause (say, in\
    \ the order of a few minutes) by\n   periodically reassigning new sessions and\
    \ monitoring response times\n   and so on.\n"
- title: 7. Miscellaneous
  contents:
  - "7. Miscellaneous\n   The IETF has been notified of potential intellectual Property\
    \ Rights\n   (IPR) issues with the technology described in this document.\n  \
    \ Interested people are requested to look in the IETF web page\n   (http://www.ietf.org)\
    \ under the Intellectual property Rights Notices\n   section for the current information.\n"
- title: 8. Security Considerations
  contents:
  - "8. Security Considerations\n   All security considerations associated with NAT\
    \ routers, described in\n   REF [1] are applicable to LSNAT routers as well.\n"
- title: REFERENCES
  contents:
  - "REFERENCES\n   [1] Egevang, K. and P. Francis, \"The IP Network Address Translator\n\
    \       (NAT)\", RFC 1631, May 1994.\n   [2] Reynolds, J., and J. Postel, \"Assigned\
    \ Numbers\", STD 2, RFC 1700,\n       October 1994.  See also: http://www.iana.org/numbers.html\n\
    \   [3] Braden, R., \"Requirements for Internet Hosts -- Communication\n     \
    \  Layers\", STD 3, RFC 1122, October 1989.\n   [4] Braden, R., \"Requirements\
    \ for Internet Hosts -- Application and\n       Support\", STD 3, RFC 1123, October\
    \ 1989.\n   [5] Baker, F., \"Requirements for IP Version 4 Routers\", RFC 1812,\n\
    \       June 1995.\n   [6] Postel, J., and J. Reynolds, \"File Transfer Protocol\
    \ (FTP)\", STD\n       9, RFC 959, October 1985.\n   [7] Postel, J., \"Transmission\
    \ Control Protocol\", STD 7, RFC 793,\n       September 1981.\n   [8] Postel,\
    \ J., \"Internet Control Message (ICMP) Specification\", STD\n       5, RFC 792,\
    \ September 1981.\n   [9] Postel, J., \"User Datagram Protocol (UDP)\", STD 6,\
    \ RFC 768,\n       August 1980.\n   [10] Mogul, J., and J. Postel, \"Internet\
    \ Standard Subnetting\n        Procedure\", STD 5, RFC 950, August 1985.\n   [11]\
    \ Brisco, T., \"DNS Support for Load Balancing\", RFC 1794, April\n        1995.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Pyda Srisuresh\n   Lucent Technologies\n   4464 Willow\
    \ Road\n   Pleasanton, CA 94588-8519\n   U.S.A.\n   Voice: (925) 737-2153\n  \
    \ Fax:   (925) 737-2110\n   EMail: suresh@ra.lucent.com\n   Der-hwa Gan\n   Juniper\
    \ Networks, Inc.\n   385 Ravensdale Drive.\n   Mountain View, CA 94043\n   U.S.A.\n\
    \   Voice: (650) 526-8074\n   Fax:   (650) 526-8001\n   EMail: dhg@juniper.net\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (1998).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
