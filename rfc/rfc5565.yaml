- title: __initial_text__
  contents:
  - '                        Softwire Mesh Framework

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2009 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\
    \ in effect on the date of\n   publication of this document (http://trustee.ietf.org/license-info).\n\
    \   Please review these documents carefully, as they describe your rights\n  \
    \ and restrictions with respect to this document.\n   This document may contain\
    \ material from IETF Documents or IETF\n   Contributions published or made publicly\
    \ available before November\n   10, 2008.  The person(s) controlling the copyright\
    \ in some of this\n   material may not have granted the IETF Trust the right to\
    \ allow\n   modifications of such material outside the IETF Standards Process.\n\
    \   Without obtaining an adequate license from the person(s) controlling\n   the\
    \ copyright in such materials, this document may not be modified\n   outside the\
    \ IETF Standards Process, and derivative works of it may\n   not be created outside\
    \ the IETF Standards Process, except to format\n   it for publication as an RFC\
    \ or to translate it into languages other\n   than English.\n"
- title: Abstract
  contents:
  - "Abstract\n   The Internet needs to be able to handle both IPv4 and IPv6 packets.\n\
    \   However, it is expected that some constituent networks of the\n   Internet\
    \ will be \"single-protocol\" networks.  One kind of single-\n   protocol network\
    \ can parse only IPv4 packets and can process only\n   IPv4 routing information;\
    \ another kind can parse only IPv6 packets\n   and can process only IPv6 routing\
    \ information.  It is nevertheless\n   required that either kind of single-protocol\
    \ network be able to\n   provide transit service for the \"other\" protocol. \
    \ This is done by\n   passing the \"other kind\" of routing information from one\
    \ edge of the\n   single-protocol network to the other, and by tunneling the \"\
    other\n   kind\" of data packet from one edge to the other.  The tunnels are\n\
    \   known as \"softwires\".  This framework document explains how the\n   routing\
    \ information and the data packets of one protocol are passed\n   through a single-protocol\
    \ network of the other protocol.  The\n   document is careful to specify when\
    \ this can be done with existing\n   technology and when it requires the development\
    \ of new or modified\n   technology.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Specification of Requirements ...................................6\n  \
    \ 3. Scenarios of Interest ...........................................7\n    \
    \  3.1. IPv6-over-IPv4 Scenario ....................................7\n      3.2.\
    \ IPv4-over-IPv6 Scenario ....................................9\n   4. General\
    \ Principles of the Solution .............................10\n      4.1. E-IP\
    \ and I-IP .............................................10\n      4.2. Routing\
    \ ...................................................10\n      4.3. Tunneled Forwarding\
    \ .......................................11\n   5. Distribution of Inter-AFBR\
    \ Routing Information .................11\n   6. Softwire Signaling .............................................13\n\
    \   7. Choosing to Forward through a Softwire .........................15\n  \
    \ 8. Selecting a Tunneling Technology ...............................15\n   9.\
    \ Selecting the Softwire for a Given Packet ......................16\n   10. Softwire\
    \ OAM and MIBs .........................................17\n      10.1. Operations\
    \ and Maintenance (OAM) .........................17\n      10.2. MIBs .....................................................18\n\
    \   11. Softwire Multicast ............................................18\n  \
    \    11.1. One-to-One Mappings ......................................18\n    \
    \       11.1.1. Using PIM in the Core .............................19\n      \
    \     11.1.2. Using mLDP and Multicast MPLS in the Core .........20\n      11.2.\
    \ MVPN-Like Schemes ........................................21\n   12. Inter-AS\
    \ Considerations .......................................22\n   13. Security Considerations\
    \ .......................................23\n      13.1. Problem Analysis .........................................23\n\
    \      13.2. Non-Cryptographic Techniques .............................24\n  \
    \    13.3. Cryptographic Techniques .................................26\n   14.\
    \ References ....................................................27\n      14.1.\
    \ Normative References .....................................27\n      14.2. Informative\
    \ References ...................................28\n   15. Contributors ..................................................30\n\
    \   16. Acknowledgments ...............................................30\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The routing information in any IP backbone network can be\
    \ thought of\n   as being in one of two categories: \"internal routing information\"\
    \ or\n   \"external routing information\".  The internal routing information\n\
    \   consists of routes to the nodes that belong to the backbone, and to\n   the\
    \ interfaces of those nodes.  External routing information consists\n   of routes\
    \ to destinations beyond the backbone, especially\n   destinations to which the\
    \ backbone is not directly attached.  In\n   general, BGP [RFC4271] is used to\
    \ distribute external routing\n   information, and an Interior Gateway Protocol\
    \ (IGP) such as OSPF\n   [RFC2328] or IS-IS [RFC1195] is used to distribute internal\
    \ routing\n   information.\n   Often an IP backbone will provide transit routing\
    \ services for\n   packets that originate outside the backbone and whose destinations\n\
    \   are outside the backbone.  These packets enter the backbone at one of\n  \
    \ its \"edge routers\".  They are routed through the backbone to another\n   edge\
    \ router, after which they leave the backbone and continue on\n   their way. \
    \ The edge nodes of the backbone are often known as\n   \"Provider Edge\" (PE)\
    \ routers.  The term \"ingress\" (or \"ingress PE\")\n   refers to the router\
    \ at which a packet enters the backbone, and the\n   term \"egress\" (or \"egress\
    \ PE\") refers to the router at which it\n   leaves the backbone.  Interior nodes\
    \ are often known as \"P routers\".\n   Routers that are outside the backbone\
    \ but directly attached to it are\n   known as \"Customer Edge\" (CE) routers.\
    \  (This terminology is taken\n   from [RFC4364].)\n   When a packet's destination\
    \ is outside the backbone, the routing\n   information that is needed within the\
    \ backbone in order to route the\n   packet to the proper egress is, by definition,\
    \ external routing\n   information.\n   Traditionally, the external routing information\
    \ has been distributed\n   by BGP to all the routers in the backbone, not just\
    \ to the edge\n   routers (i.e., not just to the ingress and egress points). \
    \ Each of\n   the interior nodes has been expected to look up the packet's\n \
    \  destination address and route it towards the egress point.  This is\n   known\
    \ as \"native forwarding\":  the interior nodes look into each\n   packet's header\
    \ in order to match the information in the header with\n   the external routing\
    \ information.\n   It is, however, possible to provide transit services without\n\
    \   requiring that all the backbone routers have the external routing\n   information.\
    \  The routing information that BGP distributes to each\n   ingress router specifies\
    \ the egress router for each route.  The\n   ingress router can therefore \"tunnel\"\
    \ the packet directly to the\n   egress router.  \"Tunneling the packet\" means\
    \ putting on some sort of\n   encapsulation header that will force the interior\
    \ routers to forward\n   the packet to the egress router.  The original packet\
    \ is known as the\n   \"encapsulation payload\".  The P routers do not look at\
    \ the packet\n   header of the payload but only at the encapsulation header. \
    \ Since\n   the path to the egress router is part of the internal routing\n  \
    \ information of the backbone, the interior routers then do not need to\n   know\
    \ the external routing information.  This is known as \"tunneled\n   forwarding\"\
    .  Of course, before the packet can leave the egress, it\n   has to be decapsulated.\n\
    \   The scenario where the P routers do not have external routes is\n   sometimes\
    \ known as a \"BGP-free core\".  That is something of a\n   misnomer, though,\
    \ since the crucial aspect of this scenario is not\n   that the interior nodes\
    \ don't run BGP, but that they don't maintain\n   the external routing information.\n\
    \   In recent years, we have seen this scenario deployed to support VPN\n   services,\
    \ as specified in [RFC4364].  An edge router maintains\n   multiple independent\
    \ routing/addressing spaces, one for each VPN to\n   which it interfaces.  However,\
    \ the routing information for the VPNs\n   is not maintained by the interior routers.\
    \  In most of these\n   scenarios, MPLS is used as the encapsulation mechanism\
    \ for getting\n   the packets from ingress to egress.  There are some deployments\
    \ in\n   which an IP-based encapsulation, such as L2TPv3 (Layer 2 Transport\n\
    \   Protocol) [RFC3931] or GRE (Generic Routing Encapsulation) [RFC2784]\n   is\
    \ used.\n   This same technique can also be useful when the external routing\n\
    \   information consists not of VPN routes, but of \"ordinary\" Internet\n   routes.\
    \  It can be used any time it is desired to keep external\n   routing information\
    \ out of a backbone's interior nodes, or in fact\n   any time it is desired for\
    \ any reason to avoid the native forwarding\n   of certain kinds of packets.\n\
    \   This framework focuses on two such scenarios.\n      1. In this scenario,\
    \ the backbone's interior nodes support only\n         IPv6.  They do not maintain\
    \ IPv4 routes at all, and are not\n         expected to parse IPv4 packet headers.\
    \  Yet, it is desired to\n         use such a backbone to provide transit services\
    \ for IPv4\n         packets.  Therefore, tunneled forwarding of IPv4 packets\
    \ is\n         required.  Of course, the edge nodes must have the IPv4 routes,\n\
    \         but the ingress must perform an encapsulation in order to get\n    \
    \     an IPv4 packet forwarded to the egress.\n      2. This scenario is the reverse\
    \ of scenario 1, i.e., the\n         backbone's interior nodes support only IPv4,\
    \ but it is desired\n         to use the backbone for IPv6 transit.\n   In these\
    \ scenarios, a backbone whose interior nodes support only one\n   of the two address\
    \ families is required to provide transit services\n   for the other.  The backbone's\
    \ edge routers must, of course, support\n   both address families.  We use the\
    \ term \"Address Family Border\n   Router\" (AFBR) to refer to these PE routers.\
    \  The tunnels that are\n   used for forwarding are referred to as \"softwires\"\
    .\n   These two scenarios are known as the \"Softwire Mesh Problem\"\n   [SW-PROB],\
    \ and the framework specified in this document is therefore\n   known as the \"\
    Softwire Mesh Framework\".  In this framework, only the\n   AFBRs need to support\
    \ both address families.  The CE routers support\n   only a single address family,\
    \ and the P routers support only the\n   other address family.\n   It is possible\
    \ to address these scenarios via a large variety of\n   tunneling technologies.\
    \  This framework does not mandate the use of\n   any particular tunneling technology.\
    \  In any given deployment, the\n   choice of tunneling technology is a matter\
    \ of policy.  The framework\n   accommodates at least the use of MPLS ([RFC3031],\
    \ [RFC3032]) -- both\n   LDP-based (Label Distribution Protocol, [RFC5036]) and\
    \ RSVP-TE-based\n   (Resource Reservation Protocol - Traffic Engineering, [RFC3209])\
    \ --\n   L2TPv3 [RFC3931], GRE [RFC2784], and IP-in-IP [RFC2003].  The\n   framework\
    \ will also accommodate the use of IPsec tunneling, when that\n   is necessary\
    \ in order to meet security requirements.\n   It is expected that, in many deployments,\
    \ the choice of tunneling\n   technology will be made by a simple expression of\
    \ policy, such as\n   \"always use IP-IP tunnels\", or \"always use LDP-based\
    \ MPLS\", or\n   \"always use L2TPv3\".\n   However, other deployments may have\
    \ a mixture of routers, some of\n   which support, say, both GRE and L2TPv3, but\
    \ others of which support\n   only one of those techniques.  It is desirable therefore\
    \ to allow the\n   network administration to create a small set of classes, and\
    \ to\n   configure each AFBR to be a member of one or more of these classes.\n\
    \   Then the routers can advertise their class memberships to each other,\n  \
    \ and the encapsulation policies can be expressed as, e.g., \"use L2TPv3\n   to\
    \ tunnel to routers in class X; use GRE to tunnel to routers in\n   class Y\"\
    .  To support such policies, it is necessary for the AFBRs to\n   be able to advertise\
    \ their class memberships; a standard way of doing\n   this must be developed.\n\
    \   Policy may also require a certain class of traffic to receive a\n   certain\
    \ quality of service, and this may impact the choice of tunnel\n   and/or tunneling\
    \ technology used for packets in that class.  This\n   needs to be accommodated\
    \ by the Softwire Mesh Framework.\n   The use of tunneled forwarding often requires\
    \ that some sort of\n   signaling protocol be used to set up and/or maintain the\
    \ tunnels.\n   Many of the tunneling technologies accommodated by this framework\n\
    \   already have their own signaling protocols.  However, some do not,\n   and\
    \ in some cases the standard signaling protocol for a particular\n   tunneling\
    \ technology may not be appropriate (for one or another\n   reason) in the scenarios\
    \ of interest.  In such cases (and in such\n   cases only), new signaling methodologies\
    \ need to be defined and\n   standardized.\n   In this framework, the softwires\
    \ do not form an overlay topology that\n   is visible to routing; routing adjacencies\
    \ are not maintained over\n   the softwires, and routing control packets are not\
    \ sent through the\n   softwires.  Routing adjacencies among backbone nodes (including\
    \ the\n   edge nodes) are maintained via the native technology of the backbone.\n\
    \   There is already a standard routing method for distributing external\n   routing\
    \ information among AFBRs, namely BGP.  However, in the\n   scenarios of interest,\
    \ we may be using IPv6-based BGP sessions to\n   pass IPv4 routing information,\
    \ and we may be using IPv4-based BGP\n   sessions to pass IPv6 routing information.\
    \  Furthermore, when IPv4\n   traffic is to be tunneled over an IPv6 backbone,\
    \ it is necessary to\n   encode the \"BGP next hop\" for an IPv4 route as an IPv6\
    \ address, and\n   vice versa.  The method for encoding an IPv4 address as the\
    \ next hop\n   for an IPv6 route is specified in [V6NLRI-V4NH]; the method for\n\
    \   encoding an IPv6 address as the next hop for an IPv4 route is\n   specified\
    \ in [V4NLRI-V6NH].\n"
- title: 2.  Specification of Requirements
  contents:
  - "2.  Specification of Requirements\n   The key words \"MUST\", \"MUST NOT\", \"\
    REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 3.  Scenarios of Interest
  contents:
  - '3.  Scenarios of Interest

    '
- title: 3.1.  IPv6-over-IPv4 Scenario
  contents:
  - "3.1.  IPv6-over-IPv4 Scenario\n   In this scenario, the client networks run IPv6\
    \ but the backbone\n   network runs IPv4.  This is illustrated in Figure 1.\n\
    \                          +--------+   +--------+\n                         \
    \ |  IPv6  |   |  IPv6  |\n                          | Client |   | Client |\n\
    \                          | Network|   | Network|\n                         \
    \ +--------+   +--------+\n                              |   \\     /   |\n  \
    \                            |    \\   /    |\n                              |\
    \     \\ /     |\n                              |      X      |\n            \
    \                  |     / \\     |\n                              |    /   \\\
    \    |\n                              |   /     \\   |\n                     \
    \     +--------+   +--------+\n                          |  AFBR  |   |  AFBR\
    \  |\n                       +--| IPv4/6 |---| IPv4/6 |--+\n                 \
    \      |  +--------+   +--------+  |\n       +--------+      |               \
    \            |       +--------+\n       |  IPv4  |      |                    \
    \       |       |  IPv4  |\n       | Client |      |                         \
    \  |       | Client |\n       | Network|------|            IPv4           |-------|\
    \ Network|\n       +--------+      |            only           |       +--------+\n\
    \                       |                           |\n                      \
    \ |  +--------+   +--------+  |\n                       +--|  AFBR  |---|  AFBR\
    \  |--+\n                          | IPv4/6 |   | IPv4/6 |\n                 \
    \         +--------+   +--------+\n                            |   \\     /  \
    \ |\n                            |    \\   /    |\n                          \
    \  |     \\ /     |\n                            |      X      |\n           \
    \                 |     / \\     |\n                            |    /   \\  \
    \  |\n                            |   /     \\   |\n                         +--------+\
    \   +--------+\n                         |  IPv6  |   |  IPv6  |\n           \
    \              | Client |   | Client |\n                         | Network|  \
    \ | Network|\n                         +--------+   +--------+\n             \
    \        Figure 1: IPv6-over-IPv4 Scenario\n   The IPv4 transit core may or may\
    \ not run MPLS.  If it does, MPLS may\n   be used as part of the solution.\n \
    \  While Figure 1 does not show any \"backdoor\" connections among the\n   client\
    \ networks, this framework assumes that there will be such\n   connections.  That\
    \ is, there is no assumption that the only path\n   between two client networks\
    \ is via the pictured transit-core network.\n   Hence, the routing solution must\
    \ be robust in any kind of topology.\n   Many mechanisms for providing IPv6 connectivity\
    \ across IPv4 networks\n   have been devised over the past ten years.  A number\
    \ of different\n   tunneling mechanisms have been used, some provisioned manually,\
    \ and\n   others based on special addressing.  More recently, L3VPN (Layer 3\n\
    \   Virtual Private Network) techniques from [RFC4364] have been extended\n  \
    \ to provide IPv6 connectivity, using MPLS in the AFBRs and,\n   optionally, in\
    \ the backbone [V6NLRI-V4NH].  The solution described in\n   this framework can\
    \ be thought of as a superset of [V6NLRI-V4NH], with\n   a more generalized scheme\
    \ for choosing the tunneling (softwire)\n   technology.  In this framework, MPLS\
    \ is allowed -- but not required\n   -- even at the AFBRs.  As in [V6NLRI-V4NH],\
    \ there is no manual\n   provisioning of tunnels, and no special addressing is\
    \ required.\n"
- title: 3.2.  IPv4-over-IPv6 Scenario
  contents:
  - "3.2.  IPv4-over-IPv6 Scenario\n   In this scenario, the client networks run IPv4\
    \ but the backbone\n   network runs IPv6.  This is illustrated in Figure 2.\n\
    \                          +--------+   +--------+\n                         \
    \ |  IPv4  |   |  IPv4  |\n                          | Client |   | Client |\n\
    \                          | Network|   | Network|\n                         \
    \ +--------+   +--------+\n                              |   \\     /   |\n  \
    \                            |    \\   /    |\n                              |\
    \     \\ /     |\n                              |      X      |\n            \
    \                  |     / \\     |\n                              |    /   \\\
    \    |\n                              |   /     \\   |\n                     \
    \     +--------+   +--------+\n                          |  AFBR  |   |  AFBR\
    \  |\n                       +--| IPv4/6 |---| IPv4/6 |--+\n                 \
    \      |  +--------+   +--------+  |\n       +--------+      |               \
    \            |       +--------+\n       |  IPv6  |      |                    \
    \       |       |  IPv6  |\n       | Client |      |                         \
    \  |       | Client |\n       | Network|------|            IPv6           |-------|\
    \ Network|\n       +--------+      |            only           |       +--------+\n\
    \                       |                           |\n                      \
    \ |  +--------+   +--------+  |\n                       +--|  AFBR  |---|  AFBR\
    \  |--+\n                          | IPv4/6 |   | IPv4/6 |\n                 \
    \         +--------+   +--------+\n                            |   \\     /  \
    \ |\n                            |    \\   /    |\n                          \
    \  |     \\ /     |\n                            |      X      |\n           \
    \                 |     / \\     |\n                            |    /   \\  \
    \  |\n                            |   /     \\   |\n                         +--------+\
    \   +--------+\n                         |  IPv4  |   |  IPv4  |\n           \
    \              | Client |   | Client |\n                         | Network|  \
    \ | Network|\n                         +--------+   +--------+\n             \
    \        Figure 2: IPv4-over-IPv6 Scenario\n   The IPv6 transit core may or may\
    \ not run MPLS.  If it does, MPLS may\n   be used as part of the solution.\n \
    \  While Figure 2 does not show any \"backdoor\" connections among the\n   client\
    \ networks, this framework assumes that there will be such\n   connections.  That\
    \ is, there is no assumption that the only path\n   between two client networks\
    \ is via the pictured transit-core network.\n   Hence, the routing solution must\
    \ be robust in any kind of topology.\n   While the issue of IPv6-over-IPv4 has\
    \ received considerable attention\n   in the past, the scenario of IPv4-over-IPv6\
    \ has not.  Yet, it is a\n   significant emerging requirement, as a number of\
    \ service providers\n   are building IPv6 backbone networks and do not wish to\
    \ provide native\n   IPv4 support in their core routers.  These service providers\
    \ have a\n   large legacy of IPv4 networks and applications that need to operate\n\
    \   across their IPv6 backbone.  Solutions for this do not exist yet\n   because\
    \ it had always been assumed that the backbone networks of the\n   foreseeable\
    \ future would be dual stack.\n"
- title: 4.  General Principles of the Solution
  contents:
  - "4.  General Principles of the Solution\n   This section gives a very brief overview\
    \ of the procedures.  The\n   subsequent sections provide more detail.\n"
- title: 4.1.  E-IP and I-IP
  contents:
  - "4.1.  E-IP and I-IP\n   In the following sections, we use the term \"I-IP\" (Internal\
    \ IP) to\n   refer to the form of IP (i.e., either IPv4 or IPv6) that is supported\n\
    \   by the transit network.  We use the term \"E-IP\" (External IP) to\n   refer\
    \ to the form of IP that is supported by the client networks.\n   In the scenarios\
    \ of interest, E-IP is IPv4 if and only if I-IP is\n   IPv6, and E-IP is IPv6\
    \ if and only if I-IP is IPv4.\n   We assume that the P routers support only I-IP.\
    \  That is, they are\n   expected to have only I-IP routing information, and they\
    \ are not\n   expected to be able to parse E-IP headers.  We similarly assume\
    \ that\n   the CE routers support only E-IP.\n   The AFBRs handle both I-IP and\
    \ E-IP.  However, only I-IP is used on\n   AFBR's \"core-facing interfaces\",\
    \ and E-IP is only used on its client-\n   facing interfaces.\n"
- title: 4.2.  Routing
  contents:
  - "4.2.  Routing\n   The P routers and the AFBRs of the transit network participate\
    \ in an\n   IGP for the purposes of distributing I-IP routing information.\n \
    \  The AFBRs use Internal BGP (IBGP) to exchange E-IP routing\n   information\
    \ with each other.  Either there is a full mesh of IBGP\n   connections among\
    \ the AFBRs, or else some or all of the AFBRs are\n   clients of a BGP Route Reflector.\
    \  Although these IBGP connections\n   are used to pass E-IP routing information\
    \ (i.e., the Network Layer\n   Reachability Information (NLRI) of the BGP updates\
    \ is in the E-IP\n   address family), the IBGP connections run over I-IP, and\
    \ the BGP next\n   hop for each E-IP NLRI is in the I-IP address family.\n"
- title: 4.3.  Tunneled Forwarding
  contents:
  - "4.3.  Tunneled Forwarding\n   When an ingress AFBR receives an E-IP packet from\
    \ a client-facing\n   interface, it looks up the packet's destination IP address.\
    \  In the\n   scenarios of interest, the best match for that address will be a\
    \ BGP-\n   distributed route whose next hop is the I-IP address of another AFBR,\n\
    \   the egress AFBR.\n   The ingress AFBR must forward the packet through a tunnel\
    \ (i.e,\n   through a softwire) to the egress AFBR.  This is done by\n   encapsulating\
    \ the packet, using an encapsulation header that the P\n   routers can process\
    \ and that will cause the P routers to send the\n   packet to the egress AFBR.\
    \  The egress AFBR then extracts the\n   payload, i.e., the original E-IP packet,\
    \ and forwards it further by\n   looking up its IP destination address.\n   Several\
    \ kinds of tunneling technologies are supported.  Some of those\n   technologies\
    \ require explicit AFBR-to-AFBR signaling before the\n   tunnel can be used, others\
    \ do not.\n   Transmitting a packet through a softwire always requires that an\n\
    \   encapsulation header be added to the original packet.  The resulting\n   packet\
    \ is therefore always longer than the encapsulation payload.  As\n   an operational\
    \ matter, the Maximum Transmission Unit (MTU) of the\n   softwire's path SHOULD\
    \ be large enough so that (a) no packet will\n   need to be fragmented before\
    \ being encapsulated, and (b) no\n   encapsulated packet will need to be fragmented\
    \ while it is being\n   forwarded along a softwire.  A general discussion of MTU\
    \ issues in\n   the context of tunneled forwarding may be found in [RFC4459].\n"
- title: 5.  Distribution of Inter-AFBR Routing Information
  contents:
  - "5.  Distribution of Inter-AFBR Routing Information\n   AFBRs peer with routers\
    \ in the client networks to exchange routing\n   information for the E-IP family.\n\
    \   AFBRs use BGP to distribute the E-IP routing information to each\n   other.\
    \  This can be done by an AFBR-AFBR mesh of IBGP sessions, but\n   more likely\
    \ is done through a BGP Route Reflector, i.e., where each\n   AFBR has an IBGP\
    \ session to one or two Route Reflectors rather than\n   to other AFBRs.\n   The\
    \ BGP sessions between the AFBRs, or between the AFBRs and the\n   Route Reflector,\
    \ will run on top of the I-IP address family.  That\n   is, if the transit core\
    \ supports only IPv6, the IBGP sessions used to\n   distribute IPv4 routing information\
    \ from the client networks will run\n   over IPv6; if the transit core supports\
    \ only IPv4, the IBGP sessions\n   used to distribute IPv6 routing information\
    \ from the client networks\n   will run over IPv4.  The BGP sessions thus use\
    \ the native networking\n   layer of the core; BGP messages are NOT tunneled through\
    \ softwires or\n   through any other mechanism.\n   In BGP, a routing update associates\
    \ an address prefix (or more\n   generally, NLRI) with the address of a BGP next\
    \ hop (NH).  The NLRI\n   is associated with a particular address family.  The\
    \ NH address is\n   also associated with a particular address family, which may\
    \ be the\n   same as or different than the address family associated with the\n\
    \   NLRI.  Generally, the NH address belongs to the address family that\n   is\
    \ used to communicate with the BGP speaker to whom the NH address\n   belongs.\n\
    \   Since routing updates that contain information about E-IP address\n   prefixes\
    \ are carried over BGP sessions that use I-IP transport, and\n   since the BGP\
    \ messages are not tunneled, a BGP update providing\n   information about an E-IP\
    \ address prefix will need to specify a next\n   hop address in the I-IP family.\n\
    \   Due to a variety of historical circumstances, when the NLRI and the\n   NH\
    \ in a given BGP update are of different address families, it is not\n   always\
    \ obvious how the NH should be encoded.  There is a different\n   encoding procedure\
    \ for each pair of address families.\n   In the case where the NLRI is in the\
    \ IPv6 address family, and the NH\n   is in the IPv4 address family, [V6NLRI-V4NH]\
    \ explains how to encode\n   the NH.\n   In the case where the NLRI is in the\
    \ IPv4 address family, and the NH\n   is in the IPv6 address family, [V4NLRI-V6NH]\
    \ explains how to encode\n   the NH.\n   If a BGP speaker sends an update for\
    \ an NLRI in the E-IP family, and\n   the update is being sent over a BGP session\
    \ that is running on top of\n   the I-IP network layer, and the BGP speaker is\
    \ advertising itself as\n   the NH for that NLRI, then the BGP speaker MUST, unless\
    \ explicitly\n   overridden by policy, specify the NH address in the I-IP family.\
    \  The\n   address family of the NH MUST NOT be changed by a Route Reflector.\n\
    \   In some cases (e.g., when [V4NLRI-V6NH] is used), one cannot follow\n   this\
    \ rule unless one's BGP peers have advertised a particular BGP\n   capability.\
    \  This leads to the following softwire deployment\n   restriction: if a BGP capability\
    \ is defined for the case in which an\n   E-IP NLRI has an I-IP NH, all the AFBRs\
    \ in a given transit core MUST\n   advertise that capability.\n   If an AFBR has\
    \ multiple IP addresses, the network administrators\n   usually have considerable\
    \ flexibility in choosing which one the AFBR\n   uses to identify itself as the\
    \ next hop in a BGP update.  However, if\n   the AFBR expects to receive packets\
    \ through a softwire of a\n   particular tunneling technology, and if the AFBR\
    \ is known to that\n   tunneling technology via a specific IP address, then that\
    \ same IP\n   address must be used to identify the AFBR in the next hop field\
    \ of\n   the BGP updates.  For example, if L2TPv3 tunneling is used, then the\n\
    \   IP address that the AFBR uses when engaging in L2TPv3 signaling must\n   be\
    \ the same as the IP address it uses to identify itself in the next\n   hop field\
    \ of a BGP update.\n   In [V6NLRI-V4NH], IPv6 routing information is distributed\
    \ using the\n   labeled IPv6 address family.  This allows the egress AFBR to\n\
    \   associate an MPLS label with each IPv6 address prefix.  If an ingress\n  \
    \ AFBR forwards packets through a softwire that can carry MPLS packets,\n   each\
    \ data packet can carry the MPLS label corresponding to the IPv6\n   route that\
    \ it matched.  This may be useful at the egress AFBR, for\n   demultiplexing and/or\
    \ enhanced performance.  It is also possible to\n   do the same for the IPv4 address\
    \ family, i.e., to use the labeled\n   IPv4 address family instead of the IPv4\
    \ address family.  The use of\n   the labeled IP address families in this manner\
    \ is OPTIONAL.\n"
- title: 6.  Softwire Signaling
  contents:
  - "6.  Softwire Signaling\n   A mesh of inter-AFBR softwires spanning the transit\
    \ core must be in\n   place before packets can flow between client networks. \
    \ Given N dual-\n   stack AFBRs, this requires N^2 \"point-to-point IP\" or \"\
    label switched\n   path\" (LSP) tunnels.  While in theory these could be configured\n\
    \   manually, that would result in a very undesirable O(N^2) provisioning\n  \
    \ problem.  Therefore, manual configuration of point-to-point tunnels\n   is not\
    \ considered part of this framework.\n   Because the transit core is providing\
    \ layer 3 transit services,\n   point-to-point tunnels are not required by this\
    \ framework;\n   multipoint-to-point tunnels are all that is needed.  In a multipoint-\n\
    \   to-point tunnel, when a packet emerges from the tunnel there is no\n   way\
    \ to tell which router put the packet into the tunnel.  This models\n   the native\
    \ IP forwarding paradigm, wherein the egress router cannot\n   determine a given\
    \ packet's ingress router.  Of course, point-to-point\n   tunnels might be required\
    \ for some reason beyond the basic\n   requirements described in this document.\
    \  For example, Quality of\n   Service (QoS) or security considerations might\
    \ require the use of\n   point-to-point tunnels.  So point-to-point tunnels are\
    \ allowed, but\n   not required, by this framework.\n   If it is desired to use\
    \ a particular tunneling technology for the\n   softwires, and if that technology\
    \ has its own \"native\" signaling\n   methodology, the presumption is that the\
    \ native signaling will be\n   used.  This would certainly apply to MPLS-based\
    \ softwires, where LDP\n   or RSVP-TE would be used.  An IPsec-based softwire\
    \ would use standard\n   IKEv2 (Internet Key Exchange) [RFC4306] and IPsec [RFC4301]\n\
    \   signaling, as that is necessary in order to guarantee the softwire's\n   security\
    \ properties.\n   A GRE-based softwire might or might not require signaling, depending\n\
    \   on whether various optional GRE header fields are to be used.  GRE\n   does\
    \ not have any \"native\" signaling, so for those cases, a signaling\n   procedure\
    \ needs to be developed to support softwires.\n   Another possible softwire technology\
    \ is L2TPv3.  While L2TPv3 does\n   have its own native signaling, that signaling\
    \ sets up point-to-point\n   tunnels.  For the purpose of softwires, it is better\
    \ to use L2TPv3 in\n   a multipoint-to-point mode, and this requires a different\
    \ kind of\n   signaling.\n   The signaling to be used for GRE and L2TPv3 to cover\
    \ these scenarios\n   is BGP-based, and is described in [RFC5512].\n   If IP-IP\
    \ tunneling is used, or if GRE tunneling is used without\n   options, no signaling\
    \ is required, as the only information needed by\n   the ingress AFBR to create\
    \ the encapsulation header is the IP address\n   of the egress AFBR, and that\
    \ is distributed by BGP.\n   When the encapsulation IP header is constructed,\
    \ there may be fields\n   in the IP whose value is determined neither by whatever\
    \ signaling has\n   been done nor by the distributed routing information.  The\
    \ values of\n   these fields are determined by policy in the ingress AFBR.  Examples\n\
    \   of such fields may be the TTL (Time to Live) field, the DSCP\n   (Diffserv\
    \ Service Classes) bits, etc.\n   It is desirable for all necessary softwires\
    \ to be fully set up before\n   the arrival of any packets that need to go through\
    \ the softwires.\n   That is, the softwires should be \"always on\".  From the\
    \ perspective\n   of any particular AFBR, the softwire endpoints are always BGP\
    \ next\n   hops of routes that the AFBR has installed.  This suggests that any\n\
    \   necessary softwire signaling should either be done as part of normal\n   system\
    \ startup (as would happen, e.g., with LDP-based MPLS) or else\n   be triggered\
    \ by the reception of BGP routing information (such as is\n   described in [RFC5512]);\
    \ it is also helpful if distribution of the\n   routing information that serves\
    \ as the trigger is prioritized.\n"
- title: 7.  Choosing to Forward through a Softwire
  contents:
  - "7.  Choosing to Forward through a Softwire\n   The decision to forward through\
    \ a softwire, instead of to forward\n   natively, is made by the ingress AFBR.\
    \  This decision is a matter of\n   policy.\n   In many cases, the policy will\
    \ be very simple.  Some useful policies\n   are:\n     - If routing says that\
    \ an E-IP packet has to be sent out a core-\n       facing interface to an I-IP\
    \ core, then send the packet through a\n       softwire.\n     - If routing says\
    \ that an E-IP packet has to be sent out an\n       interface that only supports\
    \ I-IP packets, then send the E-IP\n       packet through a softwire.\n     -\
    \ If routing says that the BGP next hop address for an E-IP packet\n       is\
    \ an I-IP address, then send the E-IP packet through a softwire.\n     - If the\
    \ route that is the best match for a particular packet's\n       destination address\
    \ is a BGP-distributed route, then send the\n       packet through a softwire\
    \ (i.e., tunnel all BGP-routed packets).\n   More complicated policies are also\
    \ possible, but a consideration of\n   those policies is outside the scope of\
    \ this document.\n"
- title: 8. Selecting a Tunneling Technology
  contents:
  - "8. Selecting a Tunneling Technology\n   The choice of tunneling technology is\
    \ a matter of policy configured\n   at the ingress AFBR.\n   It is envisioned\
    \ that, in most cases, the policy will be a very\n   simple one, and will be the\
    \ same at all the AFBRs of a given transit\n   core -- e.g., \"always use LDP-based\
    \ MPLS\" or \"always use L2TPv3\".\n   However, other deployments may have a mixture\
    \ of routers, some of\n   which support, say, both GRE and L2TPv3, but others\
    \ of which support\n   only one of those techniques.  It is desirable therefore\
    \ to allow the\n   network administration to create a small set of classes and\
    \ to\n   configure each AFBR to be a member of one or more of these classes.\n\
    \   Then the routers can advertise their class memberships to each other,\n  \
    \ and the encapsulation policies can be expressed as, e.g., \"use L2TPv3\n   to\
    \ talk to routers in class X; use GRE to talk to routers in class\n   Y\".  To\
    \ support such policies, it is necessary for the AFBRs to be\n   able to advertise\
    \ their class memberships.  [RFC5512] specifies a way\n   in which an AFBR may\
    \ advertise, to other AFBRS, various\n   characteristics that may be relevant\
    \ to the policy (e.g., \"I belong\n   to class Y\").  In many cases, these characteristics\
    \ can be\n   represented by arbitrarily selected communities or extended\n   communities,\
    \ and the policies at the ingress can be expressed in\n   terms of these classes\
    \ (i.e., communities).\n   Policy may also require a certain class of traffic\
    \ to receive a\n   certain quality of service, and this may impact the choice\
    \ of tunnel\n   and/or tunneling technology used for packets in that class.  This\n\
    \   framework allows a variety of tunneling technologies to be used for\n   instantiating\
    \ softwires.  The choice of tunneling technology is a\n   matter of policy, as\
    \ discussed in Section 1.\n   While in many cases the policy will be unconditional,\
    \ e.g., \"always\n   use L2TPv3 for softwires\", in other cases the policy may\
    \ specify that\n   the choice is conditional upon information about the softwire\
    \ remote\n   endpoint, e.g., \"use L2TPv3 to talk to routers in class X; use GRE\
    \ to\n   talk to routers in class Y\".  It is desirable therefore to allow the\n\
    \   network administration to create a small set of classes, and to\n   configure\
    \ each AFBR to be a member of one or more of these classes.\n   If each such class\
    \ is represented as a community or extended\n   community, then [RFC5512] specifies\
    \ a method that AFBRs can use to\n   advertise their class memberships to each\
    \ other.\n   This framework also allows for policies of arbitrary complexity,\n\
    \   which may depend on characteristics or attributes of individual\n   address\
    \ prefixes as well as on QoS or security considerations.\n   However, the specification\
    \ of such policies is not within the scope\n   of this document.\n"
- title: 9.  Selecting the Softwire for a Given Packet
  contents:
  - "9.  Selecting the Softwire for a Given Packet\n   Suppose it has been decided\
    \ to send a given packet through a\n   softwire.  Routing provides the address,\
    \ in the address family of the\n   transport network, of the BGP next hop.  The\
    \ packet MUST be sent\n   through a softwire whose remote endpoint address is\
    \ the same as the\n   BGP next hop address.\n   Sending a packet through a softwire\
    \ is a matter of first\n   encapsulating the packet with an encapsulation header\
    \ that can be\n   processed by the transit network and then transmitting towards\
    \ the\n   softwire's remote endpoint address.\n   In many cases, once one knows\
    \ the remote endpoint address, one has\n   all the information one needs in order\
    \ to form the encapsulation\n   header.  This will be the case if the tunnel technology\
    \ instantiating\n   the softwire is, e.g., LDP-based MPLS, IP-in-IP, or GRE without\n\
    \   optional header fields.\n   If the tunnel technology being used is L2TPv3\
    \ or GRE with optional\n   header fields, additional information from the remote\
    \ endpoint is\n   needed in order to form the encapsulation header.  The procedures\
    \ for\n   sending and receiving this information are described in [RFC5512].\n\
    \   If the tunnel technology being used is RSVP-TE-based MPLS or IPsec,\n   the\
    \ native signaling procedures of those technologies will need to be\n   used.\n\
    \   If the packet being sent through the softwire matches a route in the\n   labeled\
    \ IPv4 or labeled IPv6 address families, it should be sent\n   through the softwire\
    \ as an MPLS packet with the corresponding label.\n   Note that most of the tunneling\
    \ technologies mentioned in this\n   document are capable of carrying MPLS packets,\
    \ so this does not\n   presuppose support for MPLS in the core routers.\n"
- title: 10.  Softwire OAM and MIBs
  contents:
  - '10.  Softwire OAM and MIBs

    '
- title: 10.1.  Operations and Maintenance (OAM)
  contents:
  - "10.1.  Operations and Maintenance (OAM)\n   Softwires are essentially tunnels\
    \ connecting routers.  If they\n   disappear or degrade in performance, then connectivity\
    \ through those\n   tunnels will be impacted.  There are several techniques available\
    \ to\n   monitor the status of the tunnel endpoints (AFBRs) as well as the\n \
    \  tunnels themselves.  These techniques allow operations such as\n   softwire\
    \ path tracing, remote softwire endpoint pinging, and remote\n   softwire endpoint\
    \ liveness failure detection.\n   Examples of techniques applicable to softwire\
    \ OAM include:\n     o BGP/TCP timeouts between AFBRs\n     o ICMP or LSP echo\
    \ request and reply addressed to a particular AFBR\n     o BFD (Bidirectional\
    \ Forwarding Detection) [BFD] packet exchange\n       between AFBR routers\n \
    \  Another possibility for softwire OAM is to build something similar to\n   [RFC4378]\
    \ or, in other words, to create and generate softwire echo\n   request/reply packets.\
    \  The echo request sent to a well-known UDP\n   port would contain the egress\
    \ AFBR IP address and the softwire\n   identifier as the payload (similar to the\
    \ MPLS Forwarding Equivalence\n   Class contained in the LSP echo request).  The\
    \ softwire echo packet\n   would be encapsulated with the encapsulation header\
    \ and forwarded\n   across the same path (inband) as that of the softwire itself.\n\
    \   This mechanism can also be automated to periodically verify remote\n   softwire\
    \ endpoint reachability, with the loss of reachability being\n   signaled to the\
    \ softwire application on the local AFBR, thus enabling\n   suitable actions to\
    \ be taken.  Consideration must be given to the\n   trade-offs between the scalability\
    \ of such mechanisms versus the time\n   required for detection of loss of endpoint\
    \ reachability for such\n   automated mechanisms.\n   In general, a framework\
    \ for softwire OAM can, for a large part, be\n   based on the [RFC4176] framework.\n"
- title: 10.2.  MIBs
  contents:
  - "10.2.  MIBs\n   Specific MIBs do exist to manage elements of the Softwire Mesh\n\
    \   Framework.  However, there will be a need to either extend these MIBs\n  \
    \ or create new ones that reflect the functional elements that can be\n   SNMP-managed\
    \ within the softwire network.\n"
- title: 11.  Softwire Multicast
  contents:
  - "11.  Softwire Multicast\n   A set of client networks, running E-IP, that are\
    \ connected to a\n   provider's I-IP transit core may wish to run IP multicast\n\
    \   applications.  Extending IP multicast connectivity across the transit\n  \
    \ core can be done in a number of ways, each with a different set of\n   characteristics.\
    \  Most (though not all) of the possibilities are\n   either slight variations\
    \ of the procedures defined for L3VPNs in\n   [L3VPN-MCAST].\n   We will focus\
    \ on supporting those multicast features and protocols\n   that are typically\
    \ used across inter-provider boundaries.  Support is\n   provided for PIM-SM (Protocol\
    \ Independent Multicast - Sparse Mode)\n   and PIM-SSM (PIM Source-Specific Mode).\
    \  Support for BIDIR-PIM\n   (Bidirectional PIM), BSR (Bootstrap Router Mechanism\
    \ for PIM), and\n   AutoRP (Automatic Rendezvous Point Determination) is not provided\
    \ as\n   these features are not typically used across inter-provider\n   boundaries.\n"
- title: 11.1.  One-to-One Mappings
  contents:
  - "11.1.  One-to-One Mappings\n   In the \"one-to-one mapping\" scheme, each client\
    \ multicast tree is\n   extended through the transit core so that for each client\
    \ tree there\n   is exactly one tree through the core.\n   The one-to-one scheme\
    \ is not used in [L3VPN-MCAST] because it\n   requires an amount of state in the\
    \ core routers that is proportional\n   to the number of client multicast trees\
    \ passing through the core.  In\n   the VPN context, this is considered undesirable\
    \ because the amount of\n   state is unbounded and out of the control of the service\
    \ provider.\n   However, the one-to-one scheme models the typical \"Internet\n\
    \   multicast\" scenario where the client network and the transit core are\n \
    \  both IPv4 or both IPv6.  If it scales satisfactorily for that case,\n   it\
    \ should also scale satisfactorily for the case where the client\n   network and\
    \ the transit core support different versions of IP.\n"
- title: 11.1.1.  Using PIM in the Core
  contents:
  - "11.1.1.  Using PIM in the Core\n   When an AFBR receives an E-IP PIM control\
    \ message from one of its\n   CEs, it translates it from E-IP to I-IP, and forwards\
    \ it towards the\n   source of the tree.  Since the routers in the transit core\
    \ will not\n   generally have a route to the source of the tree, the AFBR must\n\
    \   include an \"RPF (Reverse Path Forwarding) Vector\" [RFC5496] in the\n   PIM\
    \ message.\n   Suppose an AFBR A receives an E-IP PIM Join/Prune message from\
    \ a CE\n   for either an (S,G) tree or a (*,G) tree.  The AFBR would have to\n\
    \   \"translate\" the PIM message into an I-IP PIM message.  It would then\n \
    \  send it to the neighbor that is the next hop along the route to the\n   root\
    \ of the (S,G) or (*,G) tree.  In the case of an (S,G) tree, the\n   root of the\
    \ tree is S; in the case of a (*,G) tree, the root of the\n   tree is the Rendezvous\
    \ Point (RP) for the group G.\n   Note that the address of the root of the tree\
    \ will be an E-IP\n   address.  Since the routers within the transit core (other\
    \ than the\n   AFBRs) do not have routes to E-IP addresses, A must put an RPF\
    \ Vector\n   [RFC5496] in the PIM Join/Prune message that it sends to its upstream\n\
    \   neighbor.  The RPF Vector will identify, as an I-IP address, the AFBR\n  \
    \ B that is the egress point in the transit network along the route to\n   the\
    \ root of the multicast tree.  AFBR B is AFBR A's BGP next hop for\n   the route\
    \ to the root of the tree.  The RPF Vector allows the core\n   routers to forward\
    \ PIM Join/Prune messages upstream towards the root\n   of the tree, even though\
    \ they do not maintain E-IP routes.\n   In order to translate an E-IP PIM message\
    \ into an I-IP PIM message,\n   the AFBR A must translate the address of S (in\
    \ the case of an (S,G)\n   group) or the address of G's RP from the E-IP address\
    \ family to the\n   I-IP address family, and the AFBR B must translate them back.\n\
    \   In the case where E-IP is IPv4 and I-IP is IPv6, it may be possible\n   to\
    \ do this translation algorithmically.  A can translate the IPv4 S\n   into the\
    \ corresponding IPv4-mapped IPv6 address [RFC4291], and then B\n   can translate\
    \ it back.  At the time of this writing, there is no such\n   thing as an IPv4-mapped\
    \ IPv6 multicast address, but if such a thing\n   were to be standardized, then\
    \ A could also translate the IPv4 G into\n   IPv6, and B could translate it back.\
    \  The precise circumstances under\n   which these translations are to be done\
    \ would be a matter of policy.\n   Obviously, this translation procedure does\
    \ not generalize to the case\n   where the client multicast is IPv6 but the core\
    \ is IPv4.  To handle\n   that case, one needs additional signaling between the\
    \ two AFBRs.\n   Each downstream AFBR needs to signal the upstream AFBR that it\
    \ needs\n   a multicast tunnel for (S,G).  The upstream AFBR must then assign\
    \ a\n   multicast address G' to the tunnel and inform the downstream of the\n\
    \   P-G value to use.  The downstream AFBR then uses PIM/IPv4 to join the\n  \
    \ (S',G') tree, where S' is the IPv4 address of the upstream ASBR\n   (Autonomous\
    \ System Border Router).\n   The (S',G') trees should be SSM trees.\n   This procedure\
    \ can be used to support client multicasts of either\n   IPv4 or IPv6 over a transit\
    \ core of the opposite protocol.  However,\n   it only works when the client multicasts\
    \ are SSM, since it provides\n   no method for mapping a client \"prune a source\
    \ off the (*,G) tree\"\n   operation into an operation on the (S',G') tree.  This\
    \ method also\n   requires additional signaling.  The BGP-based signaling of\n\
    \   [L3VPN-MCAST-BGP] is one signaling method that could be used.  Other\n   signaling\
    \ methods could be defined as well.\n"
- title: 11.1.2.  Using mLDP and Multicast MPLS in the Core
  contents:
  - "11.1.2.  Using mLDP and Multicast MPLS in the Core\n   LDP extensions for point-to-multipoint\
    \ and multipoint-to-multipoint\n   LSPs are specified in [MLDP]; we will use the\
    \ term \"mLDP\" to refer to\n   those LDP extensions.  If the transit core implements\
    \ mLDP and\n   supports multicast MPLS, then client Source-Specific Multicast\
    \ (SSM)\n   trees can be mapped one-to-one onto P2MP (Point-to-Multipoint) LSPs.\n\
    \   When an AFBR A receives an E-IP PIM Join/Prune message for (S,G) from\n  \
    \ one of its CEs, where G is an SSM group, it would use mLDP to join a\n   P2MP\
    \ LSP.  The root of the P2MP LSP would be the AFBR B that is A's\n   BGP next\
    \ hop on the route to S.  In mLDP, a P2MP LSP is uniquely\n   identified by a\
    \ combination of its root and an \"FEC (Forwarding\n   Equivalence Class) identifier\"\
    .  The original (S,G) can be\n   algorithmically encoded into the FEC identifier\
    \ so that all AFBRs\n   that need to join the P2MP LSP for (S,G) will generate\
    \ the same FEC\n   identifier.  When the root of the P2MP LSP (AFBR B) receives\
    \ such an\n   mLDP message, it extracts the original (S,G) from the FEC identifier,\n\
    \   creates an \"ordinary\" E-IP PIM Join/Prune message, and sends it to\n   the\
    \ CE that is its next hop on the route to S.\n   The method of encoding the (S,G)\
    \ into the FEC identifier needs to be\n   standardized.  The encoding must be\
    \ self-identifying so that a node\n   that is the root of a P2MP LSP can determine\
    \ whether a FEC identifier\n   is the result of having encoded a PIM (S,G).\n\
    \   The appropriate state machinery must be standardized so that PIM\n   events\
    \ at the AFBRs result in the proper mLDP events.  For example,\n   if at some\
    \ point an AFBR determines (via PIM procedures) that it no\n   longer has any\
    \ downstream receivers for (S,G), the AFBR should invoke\n   the proper mLDP procedures\
    \ to prune itself off the corresponding P2MP\n   LSP.\n   Note that this method\
    \ cannot be used when the G is a Sparse Mode\n   group.  The reason this method\
    \ cannot be used is that mLDP does not\n   have any function corresponding to\
    \ the PIM \"prune this source off the\n   shared tree\" function.  So if a P2MP\
    \ LSP were mapped one-to-one with\n   a P2MP LSP, duplicate traffic could end\
    \ up traversing the transit\n   core (i.e., traffic from S might travel down both\
    \ the shared tree and\n   S's source tree).  Alternatively, one could devise an\
    \ AFBR-to-AFBR\n   protocol to prune sources off the P2MP LSP at the root of the\
    \ LSP.\n   It is recommended, though, that client SM multicast groups be\n   supported\
    \ by other methods, such as those discussed below.\n   Client-side bidirectional\
    \ multicast groups set up by PIM-bidir could\n   be mapped using the above technique\
    \ to MP2MP (Multipoint-to-\n   Multipoint) LSPs set up by mLDP [MLDP].  We do\
    \ not consider this\n   further, as inter-provider bidirectional groups are not\
    \ in use\n   anywhere.\n"
- title: 11.2.  MVPN-Like Schemes
  contents:
  - "11.2.  MVPN-Like Schemes\n   The \"MVPN (Multicast VPN)-like schemes\" are those\
    \ described in\n   [L3VPN-MCAST] and its companion documents (such as\n   [L3VPN-MCAST-BGP]).\
    \  To apply those schemes to the softwire\n   environment, it is necessary only\
    \ to treat all the AFBRs of a given\n   transit core as if they were all, for\
    \ multicast purposes, PE routers\n   attached to the same VPN.\n   The MVPN-like\
    \ schemes do not require a one-to-one mapping between\n   client multicast trees\
    \ and transit-core multicast trees.  In the MVPN\n   environment, it is a requirement\
    \ that the number of trees in the core\n   scales less than linearly with the\
    \ number of client trees.  This\n   requirement may not hold in the softwire scenarios.\n\
    \   The MVPN-like schemes can support SM, SSM, and Bidir groups.  They\n   provide\
    \ a number of options for the control plane:\n     - LAN-like\n       Use a set\
    \ of multicast trees in the core to emulate a LAN (Local\n       Area Network)\
    \ and run the client-side PIM protocol over that\n       \"LAN\".  The \"LAN\"\
    \ can consist of a single Bidir tree containing\n       all the AFBRs or a set\
    \ of SSM trees, one rooted at each AFBR and\n       containing all the other AFBRs\
    \ as receivers.\n     - NBMA (Non-Broadcast Multiple Access), using BGP\n    \
    \   The client-side PIM signaling can be translated into BGP-based\n       signaling,\
    \ with a BGP Route Reflector mediating the signaling.\n   These two basic options\
    \ admit of many variations; a comprehensive\n   discussion is in [L3VPN-MCAST].\n\
    \   For the data plane, there are also a number of options:\n     - All multicast\
    \ data sent over the emulated LAN.  This particular\n       option is not very\
    \ attractive, though, for the softwire\n       scenarios, as every AFBR would\
    \ have to receive every client\n       multicast packet.\n     - Every multicast\
    \ group mapped to a tree that is considered\n       appropriate for that group,\
    \ in the sense of causing the traffic\n       of that group to go to \"too many\"\
    \ AFBRs that don't need to\n       receive it.\n   Again, a comprehensive discussion\
    \ of the issues can be found in\n   [L3VPN-MCAST].\n"
- title: 12.  Inter-AS Considerations
  contents:
  - "12.  Inter-AS Considerations\n   We have so far only considered the case where\
    \ a \"transit core\"\n   consists of a single Autonomous System (AS).  If the\
    \ transit core\n   consists of multiple ASes, then it may be necessary to use\
    \ softwires\n   whose endpoints are AFBRs attached to different Autonomous Systems.\n\
    \   In this case, the AFBR at the remote endpoint of a softwire is not\n   the\
    \ BGP next hop for packets that need to be sent on the softwire.\n   Since the\
    \ procedures described above require the address of a remote\n   softwire endpoint\
    \ to be the same as the address of the BGP next hop,\n   those procedures do not\
    \ work as specified when the transit core\n   consists of multiple ASes.\n   There\
    \ are several ways to deal with this situation.\n      1. Don't do it; require\
    \ that there be AFBRs at the edge of each AS\n         so that a transit core\
    \ does not extend more than one AS.\n      2. Use multi-hop EBGP to allow AFBRs\
    \ to send BGP routes to each\n         other, even if the ABFRs are not in the\
    \ same or in neighboring\n         ASes.\n      3. Ensure that an ASBR that is\
    \ not an AFBR does not change the\n         next hop field of the routes for which\
    \ encapsulation is needed.\n   In the latter two cases, BGP recursive next hop\
    \ resolution needs to\n   be done, and encapsulations may need to be \"stacked\"\
    \ (i.e., multiple\n   layers of encapsulation may need to be used).\n   For instance,\
    \ consider packet P with destination IP address D.\n   Suppose it arrives at ingress\
    \ AFBR A1 and that the route that is the\n   best match for D has BGP next hop\
    \ B1.  So A1 will encapsulate the\n   packet for delivery to B1.  If B1 is not\
    \ within A1's AS, A1 will need\n   to look up the route to B1 and then find the\
    \ BGP next hop, call it\n   B2, of that route.  If the interior routers of A1's\
    \ AS do not have\n   routes to B1, then A1 needs to encapsulate the packet a second\
    \ time,\n   this time for delivery to B2.\n"
- title: 13.  Security Considerations
  contents:
  - '13.  Security Considerations

    '
- title: 13.1.  Problem Analysis
  contents:
  - "13.1.  Problem Analysis\n   In the Softwire Mesh Framework, the data packets\
    \ that are\n   encapsulated are E-IP data packets that are traveling through the\n\
    \   Internet.  These data packets (the softwire \"payload\") may or may not\n\
    \   need such security features as authentication, integrity,\n   confidentiality,\
    \ or replay protection.  However, the security needs\n   of the payload packets\
    \ are independent of whether or not those\n   packets are traversing softwires.\
    \  The fact that a particular payload\n   packet is traveling through a softwire\
    \ does not in any way affect its\n   security needs.\n   Thus, the only security\
    \ issues we need to consider are those that\n   affect the I-IP encapsulation\
    \ headers, rather than those that affect\n   the E-IP payload.\n   Since the encapsulation\
    \ headers determine the routing of packets\n   traveling through softwires, they\
    \ must appear \"in the clear\".\n   In the Softwire Mesh Framework, for each receiving\
    \ endpoint of a\n   tunnel, there are one or more \"valid\" transmitting endpoints,\
    \ where\n   the valid transmitting endpoints are those that are authorized to\n\
    \   tunnel packets to the receiving endpoint.  If the encapsulation\n   header\
    \ has no guarantee of authentication or integrity, then it is\n   possible to\
    \ have spoofing attacks, in which unauthorized nodes send\n   encapsulated packets\
    \ to the receiving endpoint, giving the receiving\n   endpoint the invalid impression\
    \ the encapsulated packets have really\n   traveled through the softwire.  Replay\
    \ attacks are also possible.\n   The effect of such attacks is somewhat limited,\
    \ though.  The\n   receiving endpoint of a softwire decapsulates the payload and\
    \ does\n   further routing based on the IP destination address of the payload.\n\
    \   Since the payload packets are traveling through the Internet, they\n   have\
    \ addresses from the globally unique address space (rather than,\n   e.g., from\
    \ a private address space of some sort).  Therefore, these\n   attacks cannot\
    \ cause payload packets to be delivered to an address\n   other than the one appearing\
    \ in the destination IP address field of\n   the payload packet.\n   However,\
    \ attacks of this sort can result in policy violations.  The\n   authorized transmitting\
    \ endpoint(s) of a softwire may be following a\n   policy according to which only\
    \ certain payload packets get sent\n   through the softwire.  If unauthorized\
    \ nodes are able to encapsulate\n   the payload packets so that they arrive at\
    \ the receiving endpoint\n   looking as if they arrived from authorized nodes,\
    \ then the properly\n   authorized policies have been side-stepped.\n   Attacks\
    \ of the sort we are considering can also be used in denial-\n   of-service attacks\
    \ on the receiving tunnel endpoints.  However, such\n   attacks cannot be prevented\
    \ by use of cryptographic\n   authentication/integrity techniques, as the need\
    \ to do cryptography\n   on spoofed packets only makes the denial-of-service problem\
    \ worse.\n   (The assumption is that the cryptography mechanisms are likely to\
    \ be\n   more costly than the decapsulation/forwarding mechanisms.  So if one\n\
    \   tries to eliminate a flooding attack on the decapsulation/forwarding\n   mechanisms\
    \ by discarding packets that do not pass a cryptographic\n   integrity test, one\
    \ ends up just trading one kind of attack for\n   another.)\n   This section is\
    \ largely based on the security considerations section\n   of RFC 4023, which\
    \ also deals with encapsulations and tunnels.\n"
- title: 13.2.  Non-Cryptographic Techniques
  contents:
  - "13.2.  Non-Cryptographic Techniques\n   If a tunnel lies entirely within a single\
    \ administrative domain,\n   then, to a certain extent, there are certain non-cryptographic\n\
    \   techniques one can use to prevent spoofed packets from reaching a\n   tunnel's\
    \ receiving endpoint.  For example, when the tunnel\n   encapsulation is IP-based:\n\
    \     - The receiving endpoints of the tunnels can be given a distinct\n     \
    \  set of addresses, and those addresses can be made known to the\n       border\
    \ routers.  The border routers can then filter out packets,\n       destined to\
    \ those addresses, that arrive from outside the domain.\n     - The transmitting\
    \ endpoints of the tunnels can be given a distinct\n       set of addresses, and\
    \ those addresses can be made known to the\n       border routers and to the receiving\
    \ endpoints of the tunnels.\n       The border routers can filter out all packets\
    \ arriving from\n       outside the domain with source addresses that are in this\
    \ set,\n       and the receiving endpoints can discard all packets that appear\n\
    \       to be part of a softwire, but whose source addresses are not in\n    \
    \   this set.\n   If an MPLS-based encapsulation is used, the border routers can\
    \ refuse\n   to accept MPLS packets from outside the domain, or they can refuse\
    \ to\n   accept such MPLS packets whenever the top label corresponds to the\n\
    \   address of a tunnel receiving endpoint.\n   These techniques assume that,\
    \ within a domain, the network is secure\n   enough to prevent the introduction\
    \ of spoofed packets from within the\n   domain itself.  That may not always be\
    \ the case.  Also, these\n   techniques can be difficult or impossible to use\
    \ effectively for\n   tunnels that are not in the same administrative domain.\n\
    \   A different technique is to have the encapsulation header contain a\n   cleartext\
    \ password.  The 64-bit \"cookie\" of L2TPv3 [RFC3931] is\n   sometimes used in\
    \ this way.  This can be useful within an\n   administrative domain if it is regarded\
    \ as infeasible for an attacker\n   to spy on packets that originate in the domain\
    \ and that do not leave\n   the domain.  An attacker would then not be able to\
    \ discover the\n   password.  An attacker could, of course, try to guess the password,\n\
    \   but if the password is an arbitrary 64-bit binary sequence, brute\n   force\
    \ attacks that run through all the possible passwords would be\n   infeasible.\
    \  This technique may be easier to manage than ingress\n   filtering is, and may\
    \ be just as effective if the assumptions hold.\n   Like ingress filtering, though,\
    \ it may not be applicable for tunnels\n   that cross domain boundaries.\n   Therefore,\
    \ it is necessary to also consider the use of cryptographic\n   techniques for\
    \ setting up the tunnels and for passing data through\n   them.\n"
- title: 13.3.  Cryptographic Techniques
  contents:
  - "13.3.  Cryptographic Techniques\n   If the path between the two endpoints of\
    \ a tunnel is not adequately\n   secure, then:\n     - If a control protocol is\
    \ used to set up the tunnels (e.g., to\n       inform one tunnel endpoint of the\
    \ IP address of the other), the\n       control protocol MUST have an authentication\
    \ mechanism, and this\n       MUST be used when the tunnel is set up.  If the\
    \ tunnel is set up\n       automatically as the result of, for example, information\n\
    \       distributed by BGP, then the use of BGP's MD5-based\n       authentication\
    \ mechanism [RFC2385] is satisfactory.\n     - Data transmission through the tunnel\
    \ should be secured with\n       IPsec.  In the remainder of this section, we\
    \ specify the way\n       IPsec may be used, and the implementation requirements\
    \ we mention\n       are meant to be applicable whenever IPsec is being used.\n\
    \   We consider only the case where IPsec is used together with an IP-\n   based\
    \ tunneling mechanism.  Use of IPsec with an MPLS-based tunneling\n   mechanism\
    \ is for further study.\n   If it is deemed necessary to use tunnels that are\
    \ protected by IPsec,\n   the tunnel type SHOULD be negotiated by the tunnel endpoints\
    \ using\n   the procedures specified in [RFC5566].  That document allows the use\n\
    \   of IPsec tunnel mode but also allows one to treat the tunnel head and\n  \
    \ the tunnel tail as the endpoints of a Security Association, and to\n   use IPsec\
    \ transport mode.\n   In order to use IPsec transport mode, encapsulated packets\
    \ should be\n   viewed as originating at the tunnel head and as being destined\
    \ for\n   the tunnel tail.  A single IP address of the tunnel head will be used\n\
    \   as the source IP address, and a single IP address of the tunnel tail\n   will\
    \ be used as the destination IP address.  This technique can be\n   used to carry\
    \ MPLS packets through an IPsec Security Association, by\n   first encapsulating\
    \ the MPLS packets in MPLS-in-IP or MPLS-in-GRE\n   [RFC4023] and then applying\
    \ IPsec transport mode.\n   When IPsec is used to secure softwires, IPsec MUST\
    \ provide\n   authentication and integrity.  Thus, the implementation MUST support\n\
    \   either ESP (IP Encapsulating Security Payload) with null encryption\n   [RFC4303]\
    \ or else AH (IP Authentication Header) [RFC4302].  ESP with\n   encryption MAY\
    \ be supported.  If ESP is used, the tunnel tail MUST\n   check that the source\
    \ IP address of any packet received on a given SA\n   (IPsec Security Association)\
    \ is the one expected, as specified in\n   Section 5.2, step 4, of [RFC4301].\n\
    \   Since the softwires are set up dynamically as a byproduct of passing\n   routing\
    \ information, key distribution MUST be done automatically by\n   means of IKEv2\
    \ [RFC4306].  If a PKI (Public Key Infrastructure) is\n   not available, the IPsec\
    \ Tunnel Authenticator sub-TLV described in\n   [RFC5566] MUST be used and validated\
    \ before setting up an SA.\n   The selectors associated with the SA are the source\
    \ and destination\n   addresses of the encapsulation header, along with the IP\
    \ protocol\n   number representing the encapsulation protocol being used.\n"
- title: 14.  References
  contents:
  - '14.  References

    '
- title: 14.1.  Normative References
  contents:
  - "14.1.  Normative References\n   [RFC2003]      Perkins, C., \"IP Encapsulation\
    \ within IP\", RFC 2003,\n                  October 1996.\n   [RFC2119]      Bradner,\
    \ S., \"Key words for use in RFCs to Indicate\n                  Requirement Levels\"\
    , BCP 14, RFC 2119, March 1997.\n   [RFC2784]      Farinacci, D., Li, T., Hanks,\
    \ S., Meyer, D., and P.\n                  Traina, \"Generic Routing Encapsulation\
    \ (GRE)\", RFC\n                  2784, March 2000.\n   [RFC3031]      Rosen,\
    \ E., Viswanathan, A., and R. Callon,\n                  \"Multiprotocol Label\
    \ Switching Architecture\", RFC\n                  3031, January 2001.\n   [RFC3032]\
    \      Rosen, E., Tappan, D., Fedorkow, G., Rekhter, Y.,\n                  Farinacci,\
    \ D., Li, T., and A. Conta, \"MPLS Label Stack\n                  Encoding\",\
    \ RFC 3032, January 2001.\n   [RFC3209]      Awduche, D., Berger, L., Gan, D.,\
    \ Li, T., Srinivasan,\n                  V., and G. Swallow, \"RSVP-TE: Extensions\
    \ to RSVP for\n                  LSP Tunnels\", RFC 3209, December 2001.\n   [RFC3931]\
    \      Lau, J., Ed., Townsley, M., Ed., and I. Goyret, Ed.,\n                \
    \  \"Layer Two Tunneling Protocol - Version 3 (L2TPv3)\",\n                  RFC\
    \ 3931, March 2005.\n   [RFC4023]      Worster, T., Rekhter, Y., and E. Rosen,\
    \ Ed.,\n                  \"Encapsulating MPLS in IP or Generic Routing\n    \
    \              Encapsulation (GRE)\", RFC 4023, March 2005.\n   [RFC5512]    \
    \  Mohapatra, P. and E. Rosen, \"The BGP Encapsulation\n                  Subsequent\
    \ Address Family Identifier (SAFI) and the\n                  BGP Tunnel Encapsulation\
    \ Attribute\", RFC 5512, April\n                  2009.\n   [RFC5566]      Berger,\
    \ L., White, R. and E. Rosen, \"BGP IPsec Tunnel\n                  Encapsulation\
    \ Attribute\", RFC 5566, June 2009.\n   [V4NLRI-V6NH]  Le Faucheur, F. and E.\
    \ Rosen, \"Advertising IPv4\n                  Network Layer Reachability Information\
    \ with an IPv6\n                  Next Hop\", RFC 5549, May 2009.\n   [V6NLRI-V4NH]\
    \  De Clercq, J., Ooms, D., Prevost, S., and F. Le\n                  Faucheur,\
    \ \"Connecting IPv6 Islands over IPv4 MPLS\n                  Using IPv6 Provider\
    \ Edge Routers (6PE)\", RFC 4798,\n                  February 2007.\n"
- title: 14.2.  Informative References
  contents:
  - "14.2.  Informative References\n   [BFD]          Katz, D. and D. Ward, \"Bidirectional\
    \ Forwarding\n                  Detection\", Work in Progress, February 2009.\n\
    \   [L3VPN-MCAST]  Rosen, E., Ed., and R. Aggarwal, Ed., \"Multicast in\n    \
    \              MPLS/BGP IP VPNs\", Work in Progress, March 2009.\n   [L3VPN-MCAST-BGP]\n\
    \                  Aggarwal, R., Rosen, E., Morin, T. and Y. Rekhter,\n      \
    \            \"BGP Encodings and Procedures for Multicast in\n               \
    \   MPLS/BGP IP VPNs\", Work in Progress, April 2009.\n   [MLDP]         Minei,\
    \ I., Ed., Kompella, K., Wijnands, IJ., Ed., and\n                  B. Thomas,\
    \ \"Label Distribution Protocol Extensions for\n                  Point-to-Multipoint\
    \ and Multipoint-to-Multipoint Label\n                  Switched Paths\", Work\
    \ in Progress, April 2009.\n   [RFC1195]      Callon, R., \"Use of OSI IS-IS for\
    \ routing in TCP/IP\n                  and dual environments\", RFC 1195, December\
    \ 1990.\n   [RFC2328]      Moy, J., \"OSPF Version 2\", STD 54, RFC 2328, April\n\
    \                  1998.\n   [RFC2385]      Heffernan, A., \"Protection of BGP\
    \ Sessions via the TCP\n                  MD5 Signature Option\", RFC 2385, August\
    \ 1998.\n   [RFC4176]      El Mghazli, Y., Ed., Nadeau, T., Boucadair, M., Chan,\n\
    \                  K., and A. Gonguet, \"Framework for Layer 3 Virtual\n     \
    \             Private Networks (L3VPN) Operations and Management\",\n        \
    \          RFC 4176, October 2005.\n   [RFC4271]      Rekhter, Y., Ed., Li, T.,\
    \ Ed., and S. Hares, Ed., \"A\n                  Border Gateway Protocol 4 (BGP-4)\"\
    , RFC 4271, January\n                  2006.\n   [RFC4291]      Hinden, R. and\
    \ S. Deering, \"IP Version 6 Addressing\n                  Architecture\", RFC\
    \ 4291, February 2006.\n   [RFC4301]      Kent, S. and K. Seo, \"Security Architecture\
    \ for the\n                  Internet Protocol\", RFC 4301, December 2005.\n \
    \  [RFC4302]      Kent, S., \"IP Authentication Header\", RFC 4302,\n        \
    \          December 2005.\n   [RFC4303]      Kent, S., \"IP Encapsulating Security\
    \ Payload (ESP)\",\n                  RFC 4303, December 2005.\n   [RFC4306] \
    \     Kaufman, C., Ed., \"Internet Key Exchange (IKEv2)\n                  Protocol\"\
    , RFC 4306, December 2005.\n   [RFC4364]      Rosen, E. and Y. Rekhter, \"BGP/MPLS\
    \ IP Virtual Private\n                  Networks (VPNs)\", RFC 4364, February\
    \ 2006.\n   [RFC4378]      Allan, D., Ed., and T. Nadeau, Ed., \"A Framework for\n\
    \                  Multi-Protocol Label Switching (MPLS) Operations and\n    \
    \              Management (OAM)\", RFC 4378, February 2006.\n   [RFC4459]    \
    \  Savola, P., \"MTU and Fragmentation Issues with In-\n                  the-Network\
    \ Tunneling\", RFC 4459, April 2006.\n   [RFC5036]      Andersson, L., Ed., Minei,\
    \ I., Ed., and B. Thomas,\n                  Ed., \"LDP Specification\", RFC 5036,\
    \ October 2007.\n   [RFC5496]      Wijnands, IJ., Boers, A., and E. Rosen, \"\
    The Reverse\n                  Path Forwarding (RPF) Vector TLV\", RFC 5496, March\n\
    \                  2009.\n   [SW-PROB]      Li, X., Ed., Dawkins, S., Ed., Ward,\
    \ D., Ed., and A.\n                  Durand, Ed., \"Softwire Problem Statement\"\
    , RFC 4925,\n                  July 2007.\n"
- title: 15.  Contributors
  contents:
  - "15.  Contributors\n   Xing Li\n   Tsinghua University\n   Department of Electronic\
    \ Engineering, Tsinghua University\n   Beijing  100084\n   P.R.China\n   Phone:\
    \ +86-10-6278-5983\n   EMail: xing@cernet.edu.cn\n   Simon Barber\n   Cisco Systems,\
    \ Inc.\n   250 Longwater Avenue\n   Reading, ENGLAND, RG2 6GB\n   United Kingdom\n\
    \   EMail: sbarber@cisco.com\n   Pradosh Mohapatra\n   Cisco Systems, Inc.\n \
    \  3700 Cisco Way\n   San Jose, CA  95134\n   USA\n   EMail: pmohapat@cisco.com\n\
    \   John Scudder\n   Juniper Networks\n   1194 North Mathilda Avenue\n   Sunnyvale,\
    \ CA  94089\n   USA\n   EMail: jgs@juniper.net\n"
- title: 16.  Acknowledgments
  contents:
  - "16.  Acknowledgments\n   David Ward, Chris Cassar, Gargi Nalawade, Ruchi Kapoor,\
    \ Pranav Mehta,\n   Mingwei Xu, and Ke Xu provided useful input into this document.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Jianping Wu\n   Tsinghua University\n   Department of\
    \ Computer Science, Tsinghua University\n   Beijing  100084\n   P.R.China\n  \
    \ Phone: +86-10-6278-5983\n   EMail: jianping@cernet.edu.cn\n   Yong Cui\n   Tsinghua\
    \ University\n   Department of Computer Science, Tsinghua University\n   Beijing\
    \  100084\n   P.R.China\n   Phone: +86-10-6278-5822\n   EMail: yong@csnet1.cs.tsinghua.edu.cn\n\
    \   Chris Metz\n   Cisco Systems, Inc.\n   3700 Cisco Way\n   San Jose, CA  95134\n\
    \   USA\n   EMail: chmetz@cisco.com\n   Eric C. Rosen\n   Cisco Systems, Inc.\n\
    \   1414 Massachusetts Avenue\n   Boxborough, MA  01719\n   USA\n   EMail: erosen@cisco.com\n"
