- title: __initial_text__
  contents:
  - '  Block-Wise Transfers in the Constrained Application Protocol (CoAP)

    '
- title: Abstract
  contents:
  - "Abstract\n   The Constrained Application Protocol (CoAP) is a RESTful transfer\n\
    \   protocol for constrained nodes and networks.  Basic CoAP messages\n   work\
    \ well for small payloads from sensors and actuators; however,\n   applications\
    \ will need to transfer larger payloads occasionally --\n   for instance, for\
    \ firmware updates.  In contrast to HTTP, where TCP\n   does the grunt work of\
    \ segmenting and resequencing, CoAP is based on\n   datagram transports such as\
    \ UDP or Datagram Transport Layer Security\n   (DTLS).  These transports only\
    \ offer fragmentation, which is even\n   more problematic in constrained nodes\
    \ and networks, limiting the\n   maximum size of resource representations that\
    \ can practically be\n   transferred.\n   Instead of relying on IP fragmentation,\
    \ this specification extends\n   basic CoAP with a pair of \"Block\" options for\
    \ transferring multiple\n   blocks of information from a resource representation\
    \ in multiple\n   request-response pairs.  In many important cases, the Block\
    \ options\n   enable a server to be truly stateless: the server can handle each\n\
    \   block transfer separately, with no need for a connection setup or\n   other\
    \ server-side memory of previous block transfers.  Essentially,\n   the Block\
    \ options provide a minimal way to transfer larger\n   representations in a block-wise\
    \ fashion.\n   A CoAP implementation that does not support these options generally\n\
    \   is limited in the size of the representations that can be exchanged,\n   so\
    \ there is an expectation that the Block options will be widely used\n   in CoAP\
    \ implementations.  Therefore, this specification updates\n   RFC 7252.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 7841.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7959.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2016 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   4\n   2.  Block-Wise Transfers  . . . . . . . . . . . . . . . .\
    \ . . . .   6\n     2.1.  The Block2 and Block1 Options . . . . . . . . . . .\
    \ . . .   7\n     2.2.  Structure of a Block Option . . . . . . . . . . . . .\
    \ . .   8\n     2.3.  Block Options in Requests and Responses . . . . . . . .\
    \ .  10\n     2.4.  Using the Block2 Option . . . . . . . . . . . . . . . . .\
    \  12\n     2.5.  Using the Block1 Option . . . . . . . . . . . . . . . . .  14\n\
    \     2.6.  Combining Block-Wise Transfers with the Observe Option  .  15\n  \
    \   2.7.  Combining Block1 and Block2 . . . . . . . . . . . . . . .  16\n    \
    \ 2.8.  Combining Block2 with Multicast . . . . . . . . . . . . .  16\n     2.9.\
    \  Response Codes  . . . . . . . . . . . . . . . . . . . . .  17\n       2.9.1.\
    \  2.31 Continue . . . . . . . . . . . . . . . . . . . .  17\n       2.9.2.  4.08\
    \ Request Entity Incomplete  . . . . . . . . . . .  17\n       2.9.3.  4.13 Request\
    \ Entity Too Large . . . . . . . . . . . .  17\n     2.10. Caching Considerations\
    \  . . . . . . . . . . . . . . . . .  18\n   3.  Examples  . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . .  18\n     3.1.  Block2 Examples . . . . . .\
    \ . . . . . . . . . . . . . . .  19\n     3.2.  Block1 Examples . . . . . . .\
    \ . . . . . . . . . . . . . .  23\n     3.3.  Combining Block1 and Block2 . .\
    \ . . . . . . . . . . . . .  25\n     3.4.  Combining Observe and Block2  . .\
    \ . . . . . . . . . . . .  26\n   4.  The Size2 and Size1 Options . . . . . .\
    \ . . . . . . . . . . .  29\n   5.  HTTP-Mapping Considerations . . . . . . .\
    \ . . . . . . . . . .  31\n   6.  IANA Considerations . . . . . . . . . . . .\
    \ . . . . . . . . .  32\n   7.  Security Considerations . . . . . . . . . . .\
    \ . . . . . . . .  33\n     7.1.  Mitigating Resource Exhaustion Attacks  . .\
    \ . . . . . . .  33\n     7.2.  Mitigating Amplification Attacks  . . . . . .\
    \ . . . . . .  34\n   8.  References  . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  34\n     8.1.  Normative References  . . . . . . . . . . . . . .\
    \ . . . .  34\n     8.2.  Informative References  . . . . . . . . . . . . . .\
    \ . . .  35\n   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .\
    \ . .  36\n   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . .\
    \ .  37\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The work on Constrained RESTful Environments (CoRE) aims\
    \ at realizing\n   the Representational State Transfer (REST) architecture in\
    \ a suitable\n   form for the most constrained nodes (such as microcontrollers\
    \ with\n   limited RAM and ROM [RFC7228]) and networks (such as IPv6 over Low-\n\
    \   Power Wireless Personal Area Networks (6LoWPANs) [RFC4944])\n   [RFC7252].\
    \  The CoAP protocol is intended to provide RESTful [REST]\n   services not unlike\
    \ HTTP [RFC7230], while reducing the complexity of\n   implementation as well\
    \ as the size of packets exchanged in order to\n   make these services useful\
    \ in a highly constrained network of highly\n   constrained nodes.\n   This objective\
    \ requires restraint in a number of sometimes\n   conflicting ways:\n   o  reducing\
    \ implementation complexity in order to minimize code size,\n   o  reducing message\
    \ sizes in order to minimize the number of\n      fragments needed for each message\
    \ (to maximize the probability of\n      delivery of the message), the amount\
    \ of transmission power needed,\n      and the loading of the limited-bandwidth\
    \ channel,\n   o  reducing requirements on the environment such as stable storage,\n\
    \      good sources of randomness, or user-interaction capabilities.\n   Because\
    \ CoAP is based on datagram transports such as UDP or Datagram\n   Transport Layer\
    \ Security (DTLS), the maximum size of resource\n   representations that can be\
    \ transferred without too much\n   fragmentation is limited.  In addition, not\
    \ all resource\n   representations will fit into a single link-layer packet of\
    \ a\n   constrained network, which may cause adaptation layer fragmentation\n\
    \   even if IP-layer fragmentation is not required.  Using fragmentation\n   (either\
    \ at the adaptation layer or at the IP layer) for the transport\n   of larger\
    \ representations would be possible up to the maximum size of\n   the underlying\
    \ datagram protocol (such as UDP), but the\n   fragmentation/reassembly process\
    \ burdens the lower layers with\n   conversation state that is better managed\
    \ in the application layer.\n   The present specification defines a pair of CoAP\
    \ options to enable\n   block-wise access to resource representations.  The Block\
    \ options\n   provide a minimal way to transfer larger resource representations\
    \ in\n   a block-wise fashion.  The overriding objective is to avoid the need\n\
    \   for creating conversation state at the server for block-wise GET\n   requests.\
    \  (It is impossible to fully avoid creating conversation\n   state for POST/PUT,\
    \ if the creation/replacement of resources is to be\n   atomic; where that property\
    \ is not needed, there is no need to create\n   server conversation state in this\
    \ case, either.)\n   Block-wise transfers are realized as combinations of exchanges,\
    \ each\n   of which is performed according to the CoAP base protocol [RFC7252].\n\
    \   Each exchange in such a combination is governed by the specifications\n  \
    \ in [RFC7252], including the congestion control specifications\n   (Section 4.7\
    \ of [RFC7252]) and the security considerations\n   (Section 11 of [RFC7252];\
    \ additional security considerations then\n   apply to the transfers as a whole,\
    \ see Section 7).  The present\n   specification minimizes the constraints it\
    \ adds to those base\n   exchanges; however, not all variants of using CoAP are\
    \ very useful\n   inside a block-wise transfer (e.g., using Non-confirmable requests\n\
    \   within block-wise transfers outside the use case of Section 2.8 would\n  \
    \ escalate the overall non-delivery probability).  To be perfectly\n   clear,\
    \ the present specification also does not remove any of the\n   constraints posed\
    \ by the base specification it is strictly layered on\n   top of.  For example,\
    \ back-to-back packets are limited by the\n   congestion control described in\
    \ Section 4.7 of [RFC7252] (NSTART as a\n   limit for initiating exchanges, PROBING_RATE\
    \ as a limit for sending\n   with no response); block-wise transfers cannot send/solicit\
    \ more\n   traffic than a client could be sending to / soliciting from the same\n\
    \   server without the block-wise mode.\n   In some cases, the present specification\
    \ will RECOMMEND that a client\n   perform a sequence of block-wise transfers\
    \ \"without undue delay\".\n   This cannot be phrased as an interoperability requirement,\
    \ but is an\n   expectation on implementation quality.  Conversely, the expectation\n\
    \   is that servers will not have to go out of their way to accommodate\n   clients\
    \ that take considerable time to finish a block-wise transfer.\n   For example,\
    \ for a block-wise GET, if the resource changes while this\n   proceeds, the entity-tag\
    \ (ETag) for a further block obtained may be\n   different.  To avoid this happening\
    \ all the time for a fast-changing\n   resource, a server MAY try to keep a cache\
    \ around for a specific\n   client for a short amount of time.  The expectation\
    \ here is that the\n   lifetime for such a cache can be kept short, on the order\
    \ of a few\n   expected round-trip times, counting from the previous block\n \
    \  transferred.\n   In summary, this specification adds a pair of Block options\
    \ to CoAP\n   that can be used for block-wise transfers.  Benefits of using these\n\
    \   options include:\n   o  Transfers larger than what can be accommodated in\
    \ constrained-\n      network link-layer packets can be performed in smaller blocks.\n\
    \   o  No hard-to-manage conversation state is created at the adaptation\n   \
    \   layer or IP layer for fragmentation.\n   o  The transfer of each block is\
    \ acknowledged, enabling individual\n      retransmission if required.\n   o \
    \ Both sides have a say in the block size that actually will be\n      used.\n\
    \   o  The resulting exchanges are easy to understand using packet\n      analyzer\
    \ tools, and thus quite accessible to debugging.\n   o  If needed, the Block options\
    \ can also be used (without changes) to\n      provide random access to power-of-two\
    \ sized blocks within a\n      resource representation.\n   A CoAP implementation\
    \ that does not support these options generally\n   is limited in the size of\
    \ the representations that can be exchanged,\n   see Section 4.6 of [RFC7252].\
    \  Even though the options are Critical,\n   a server may decide to start using\
    \ them in an unsolicited way in a\n   response.  No effort was expended to provide\
    \ a capability indication\n   mechanism supporting that decision: since the block-wise\
    \ transfer\n   mechanisms are so fundamental to the use of CoAP for representations\n\
    \   larger than about a kilobyte, there is an expectation that they are\n   very\
    \ widely implemented.\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",\
    \ \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted\
    \ as described in RFC\n   2119, BCP 14 [RFC2119] and indicate requirement levels\
    \ for compliant\n   CoAP implementations.\n   In this document, the term \"byte\"\
    \ is used in its now customary sense\n   as a synonym for \"octet\".\n   Where\
    \ bit arithmetic is explained, this document uses the notation\n   familiar from\
    \ the programming language C, except that the operator\n   \"**\" stands for exponentiation.\n"
- title: 2.  Block-Wise Transfers
  contents:
  - "2.  Block-Wise Transfers\n   As discussed in the introduction, there are good\
    \ reasons to limit the\n   size of datagrams in constrained networks:\n   o  by\
    \ the maximum datagram size (~ 64 KiB for UDP)\n   o  by the desire to avoid IP\
    \ fragmentation (MTU of 1280 for IPv6)\n   o  by the desire to avoid adaptation-layer\
    \ fragmentation (60-80 bytes\n      for 6LoWPAN [RFC4919])\n   When a resource\
    \ representation is larger than can be comfortably\n   transferred in the payload\
    \ of a single CoAP datagram, a Block option\n   can be used to indicate a block-wise\
    \ transfer.  As payloads can be\n   sent both with requests and with responses,\
    \ this specification\n   provides two separate options for each direction of payload\
    \ transfer.\n   In naming these options (for block-wise transfers as well as in\n\
    \   Section 4), we use the number 1 (\"Block1\", \"Size1\") to refer to the\n\
    \   transfer of the resource representation that pertains to the request,\n  \
    \ and the number 2 (\"Block2\", \"Size2\") to refer to the transfer of the\n \
    \  resource representation for the response.\n   In the following, the term \"\
    payload\" will be used for the actual\n   content of a single CoAP message, i.e.,\
    \ a single block being\n   transferred, while the term \"body\" will be used for\
    \ the entire\n   resource representation that is being transferred in a block-wise\n\
    \   fashion.  The Content-Format Option applies to the body, not to the\n   payload;\
    \ in particular, the boundaries between the blocks may be in\n   places that are\
    \ not separating whole units in terms of the structure,\n   encoding, or content-coding\
    \ used by the Content-Format.  (Similarly,\n   the ETag Option defined in Section\
    \ 5.10.6 of [RFC7252] applies to the\n   whole representation of the resource,\
    \ and thus to the body of the\n   response.)\n   In most cases, all blocks being\
    \ transferred for a body (except for\n   the last one) will be of the same size.\
    \  (If the first request uses a\n   bigger block size than the receiver prefers,\
    \ subsequent requests will\n   use the preferred block size.)  The block size\
    \ is not fixed by the\n   protocol.  To keep the implementation as simple as possible,\
    \ the\n   Block options support only a small range of power-of-two block sizes,\n\
    \   from 2**4 (16) to 2**10 (1024) bytes.  As bodies often will not\n   evenly\
    \ divide into the power-of-two block size chosen, the size need\n   not be reached\
    \ in the final block (but even for the final block, the\n   chosen power-of-two\
    \ size will still be indicated in the block size\n   field of the Block option).\n"
- title: 2.1.  The Block2 and Block1 Options
  contents:
  - "2.1.  The Block2 and Block1 Options\n       +-----+---+---+---+---+--------+--------+--------+---------+\n\
    \       | No. | C | U | N | R | Name   | Format | Length | Default |\n       +-----+---+---+---+---+--------+--------+--------+---------+\n\
    \       |  23 | C | U | - | - | Block2 | uint   |    0-3 | (none)  |\n       |\
    \     |   |   |   |   |        |        |        |         |\n       |  27 | C\
    \ | U | - | - | Block1 | uint   |    0-3 | (none)  |\n       +-----+---+---+---+---+--------+--------+--------+---------+\n\
    \                       Table 1: Block Option Numbers\n   Both Block1 and Block2\
    \ Options can be present in both the request and\n   response messages.  In either\
    \ case, the Block1 Option pertains to the\n   request payload, and the Block2\
    \ Option pertains to the response\n   payload.\n   Hence, for the methods defined\
    \ in [RFC7252], Block1 is useful with\n   the payload-bearing POST and PUT requests\
    \ and their responses.\n   Block2 is useful with GET, POST, and PUT requests and\
    \ their payload-\n   bearing responses (2.01, 2.02, 2.04, and 2.05 -- see Section\
    \ 5.5 of\n   [RFC7252]).\n   Where Block1 is present in a request or Block2 in\
    \ a response (i.e.,\n   in that message to the payload of which it pertains) it\
    \ indicates a\n   block-wise transfer and describes how this specific block-wise\n\
    \   payload forms part of the entire body being transferred (\"descriptive\n \
    \  usage\").  Where it is present in the opposite direction, it provides\n   additional\
    \ control on how that payload will be formed or was\n   processed (\"control usage\"\
    ).\n   Implementation of either Block option is intended to be optional.\n   However,\
    \ when it is present in a CoAP message, it MUST be processed\n   (or the message\
    \ rejected); therefore, it is identified as a Critical\n   option.  Either Block\
    \ option MUST NOT occur more than once in a\n   single message.\n"
- title: 2.2.  Structure of a Block Option
  contents:
  - "2.2.  Structure of a Block Option\n   Three items of information may need to\
    \ be transferred in a Block\n   (Block1 or Block2) option:\n   o  the size of\
    \ the block (SZX);\n   o  whether more blocks are following (M);\n   o  the relative\
    \ number of the block (NUM) within a sequence of blocks\n      with the given\
    \ size.\n   The value of the Block option is a variable-size (0 to 3 byte)\n \
    \  unsigned integer (uint, see Section 3.2 of [RFC7252]).  This integer\n   value\
    \ encodes these three fields, see Figure 1.  (Due to the CoAP\n   uint-encoding\
    \ rules, when all of NUM, M, and SZX happen to be zero, a\n   zero-byte integer\
    \ will be sent.)\n           0\n           0 1 2 3 4 5 6 7\n          +-+-+-+-+-+-+-+-+\n\
    \          |  NUM  |M| SZX |\n          +-+-+-+-+-+-+-+-+\n           0      \
    \             1\n           0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \          |          NUM          |M| SZX |\n          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \           0                   1                   2\n           0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\n          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \          |                   NUM                 |M| SZX |\n          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                       Figure 1: Block Option Value\n   The block size is encoded\
    \ using a three-bit unsigned integer (0 for\n   2**4 bytes to 6 for 2**10 bytes),\
    \ which we call the \"SZX\" (\"size\n   exponent\"); the actual block size is\
    \ then \"2**(SZX + 4)\".  SZX is\n   transferred in the three least significant\
    \ bits of the option value\n   (i.e., \"val & 7\" where \"val\" is the value of\
    \ the option).\n   The fourth least significant bit, the M or \"more\" bit (\"\
    val & 8\"),\n   indicates whether more blocks are following or if the current\
    \ block-\n   wise transfer is the last block being transferred.\n   The option\
    \ value divided by sixteen (the NUM field) is the sequence\n   number of the block\
    \ currently being transferred, starting from zero.\n   The current transfer is,\
    \ therefore, about the \"size\" bytes starting\n   at byte \"NUM << (SZX + 4)\"\
    .\n   Implementation note:  As an implementation convenience, \"(val & ~0xF)\n\
    \      << (val & 7)\", i.e., the option value with the last 4 bits masked\n  \
    \    out, shifted to the left by the value of SZX, gives the byte\n      position\
    \ of the first byte of the block being transferred.\n   More specifically, within\
    \ the option value of a Block1 or Block2\n   Option, the meaning of the option\
    \ fields is defined as follows:\n   NUM:  Block Number, indicating the block number\
    \ being requested or\n      provided.  Block number 0 indicates the first block\
    \ of a body\n      (i.e., starting with the first byte of the body).\n   M: More\
    \ Flag (\"not last block\").  For descriptive usage, this flag,\n      if unset,\
    \ indicates that the payload in this message is the last\n      block in the body;\
    \ when set, it indicates that there are one or\n      more additional blocks available.\
    \  When a Block2 Option is used in\n      a request to retrieve a specific block\
    \ number (\"control usage\"),\n      the M bit MUST be sent as zero and ignored\
    \ on reception.  (In a\n      Block1 Option in a response, the M flag is used\
    \ to indicate\n      atomicity, see below.)\n   SZX:  Block Size.  The block size\
    \ is represented as a three-bit\n      unsigned integer indicating the size of\
    \ a block to the power of\n      two.  Thus, block size = 2**(SZX + 4).  The allowed\
    \ values of SZX\n      are 0 to 6, i.e., the minimum block size is 2**(0+4) =\
    \ 16 and the\n      maximum is 2**(6+4) = 1024.  The value 7 for SZX (which would\n\
    \      indicate a block size of 2048) is reserved, i.e., MUST NOT be sent\n  \
    \    and MUST lead to a 4.00 Bad Request response code upon reception\n      in\
    \ a request.\n   There is no default value for the Block1 and Block2 Options.\
    \  Absence\n   of one of these options is equivalent to an option value of 0 with\n\
    \   respect to the value of NUM and M that could be given in the option,\n   i.e.,\
    \ it indicates that the current block is the first and only block\n   of the transfer\
    \ (block number 0, M bit not set).  However, in\n   contrast to the explicit value\
    \ 0, which would indicate an SZX of 0\n   and thus a size value of 16 bytes, there\
    \ is no specific explicit size\n   implied by the absence of the option -- the\
    \ size is left unspecified.\n   (As for any uint, the explicit value 0 is efficiently\
    \ indicated by a\n   zero-length option; this, therefore, is different in semantics\
    \ from\n   the absence of the option.)\n"
- title: 2.3.  Block Options in Requests and Responses
  contents:
  - "2.3.  Block Options in Requests and Responses\n   The Block options are used\
    \ in one of three roles:\n   o  In descriptive usage, i.e., a Block2 Option in\
    \ a response (such as\n      a 2.05 response for GET), or a Block1 Option in a\
    \ request (a PUT\n      or POST):\n      *  The NUM field in the option value\
    \ describes what block number\n         is contained in the payload of this message.\n\
    \      *  The M bit indicates whether further blocks need to be\n         transferred\
    \ to complete the transfer of that body.\n      *  The block size implied by SZX\
    \ MUST match the size of the\n         payload in bytes, if the M bit is set.\
    \  (SZX does not govern\n         the payload size if M is unset).  For Block2,\
    \ if the request\n         suggested a larger value of SZX, the next request MUST\
    \ move SZX\n         down to the size given in the response.  (The effect is that,\n\
    \         if the server uses the smaller of (1) its preferred block size\n   \
    \      and (2) the block size requested, all blocks for a body use the\n     \
    \    same block size.)\n   o  A Block2 Option in control usage in a request (e.g.,\
    \ GET):\n      *  The NUM field in the Block2 Option gives the block number of\n\
    \         the payload that is being requested to be returned in the\n        \
    \ response.\n      *  In this case, the M bit has no function and MUST be set\
    \ to\n         zero.\n      *  The block size given (SZX) suggests a block size\
    \ (in the case\n         of block number 0) or repeats the block size of previous\
    \ blocks\n         received (in the case of a non-zero block number).\n   o  A\
    \ Block1 Option in control usage in a response (e.g., a 2.xx\n      response for\
    \ a PUT or POST request):\n      *  The NUM field of the Block1 Option indicates\
    \ what block number\n         is being acknowledged.\n      *  If the M bit was\
    \ set in the request, the server can choose\n         whether to act on each block\
    \ separately, with no memory, or\n         whether to handle the request for the\
    \ entire body atomically,\n         or any mix of the two.\n         +  If the\
    \ M bit is also set in the response, it indicates that\n            this response\
    \ does not carry the final response code to the\n            request, i.e., the\
    \ server collects further blocks from the\n            same endpoint and plans\
    \ to implement the request atomically\n            (e.g., acts only upon reception\
    \ of the last block of\n            payload).  In this case, the response MUST\
    \ NOT carry a\n            Block2 Option.\n         +  Conversely, if the M bit\
    \ is unset even though it was set in\n            the request, it indicates the\
    \ block-wise request was enacted\n            now specifically for this block,\
    \ and the response carries\n            the final response to this request (and\
    \ to any previous ones\n            with the M bit set in the response's Block1\
    \ Option in this\n            sequence of block-wise transfers); the client is\
    \ still\n            expected to continue sending further blocks, the request\n\
    \            method for which may or may not also be enacted per-block.\n    \
    \        (Note that the resource is now in a partially updated state;\n      \
    \      this approach is only appropriate where exposing such an\n            intermediate\
    \ state is acceptable.  The client can reduce the\n            window by quickly\
    \ continuing to update the resource, or, in\n            case of failure, restarting\
    \ the update.)\n      *  Finally, the SZX block size given in a control Block1\
    \ Option\n         indicates the largest block size preferred by the server for\n\
    \         transfers toward the resource that is the same or smaller than\n   \
    \      the one used in the initial exchange; the client SHOULD use\n         this\
    \ block size or a smaller one in all further requests in the\n         transfer\
    \ sequence, even if that means changing the block size\n         (and possibly\
    \ scaling the block number accordingly) from now\n         on.\n   Using one or\
    \ both Block options, a single REST operation can be split\n   into multiple CoAP\
    \ message exchanges.  As specified in [RFC7252],\n   each of these message exchanges\
    \ uses their own CoAP Message ID.\n   The Content-Format Option sent with the\
    \ requests or responses MUST\n   reflect the Content-Format of the entire body.\
    \  If blocks of a\n   response body arrive with different Content-Format Options,\
    \ it is up\n   to the client how to handle this error (it will typically abort\
    \ any\n   ongoing block-wise transfer).  If blocks of a request arrive at a\n\
    \   server with mismatching Content-Format Options, the server MUST NOT\n   assemble\
    \ them into a single request; this usually leads to a 4.08\n   (Request Entity\
    \ Incomplete, Section 2.9.2) error response on the\n   mismatching block.\n"
- title: 2.4.  Using the Block2 Option
  contents:
  - "2.4.  Using the Block2 Option\n   When a request is answered with a response\
    \ carrying a Block2 Option\n   with the M bit set, the requester may retrieve\
    \ additional blocks of\n   the resource representation by sending further requests\
    \ with the same\n   options as the initial request and a Block2 Option giving\
    \ the block\n   number and block size desired.  In a request, the client MUST\
    \ set the\n   M bit of a Block2 Option to zero and the server MUST ignore it on\n\
    \   reception.\n   To influence the block size used in a response, the requester\
    \ MAY\n   also use the Block2 Option on the initial request, giving the desired\n\
    \   size, a block number of zero and an M bit of zero.  A server MUST use\n  \
    \ the block size indicated or a smaller size.  Any further block-wise\n   requests\
    \ for blocks beyond the first one MUST indicate the same block\n   size that was\
    \ used by the server in the response for the first\n   request that gave a desired\
    \ size using a Block2 Option.\n   Once the Block2 Option is used by the requester\
    \ and a first response\n   has been received with a possibly adjusted block size,\
    \ all further\n   requests in a single block-wise transfer will ultimately converge\
    \ on\n   using the same size, except that there may not be enough content to\n\
    \   fill the last block (the one returned with the M bit not set).  (Note\n  \
    \ that the client may start using the Block2 Option in a second request\n   after\
    \ a first request without a Block2 Option resulted in a Block2\n   Option in the\
    \ response.)  The server uses the block size indicated in\n   the request option\
    \ or a smaller size, but the requester MUST take\n   note of the actual block\
    \ size used in the response it receives to its\n   initial request and proceed\
    \ to use it in subsequent requests.  The\n   server behavior MUST ensure that\
    \ this client behavior results in the\n   same block size for all responses in\
    \ a sequence (except for the last\n   one with the M bit not set, and possibly\
    \ the first one if the initial\n   request did not contain a Block2 Option).\n\
    \   Block-wise transfers can be used to GET resources whose\n   representations\
    \ are entirely static (not changing over time at all,\n   such as in a schema\
    \ describing a device), or for dynamically changing\n   resources.  In the latter\
    \ case, the Block2 Option SHOULD be used in\n   conjunction with the ETag Option\
    \ ([RFC7252], Section 5.10.6), to\n   ensure that the blocks being reassembled\
    \ are from the same version of\n   the representation: The server SHOULD include\
    \ an ETag Option in each\n   response.  If an ETag Option is available, the client,\
    \ when\n   reassembling the representation from the blocks being exchanged, MUST\n\
    \   compare ETag Options.  If the ETag Options do not match in a GET\n   transfer,\
    \ the requester has the option of attempting to retrieve\n   fresh values for\
    \ the blocks it retrieved first.  To minimize the\n   resulting inefficiency,\
    \ the server MAY cache the current value of a\n   representation for an ongoing\
    \ sequence of requests.  (The server may\n   identify the sequence by the combination\
    \ of the requesting endpoint\n   and the URI being the same in each block-wise\
    \ request.)  Note well\n   that this specification makes no requirement for the\
    \ server to\n   establish any state; however, servers that offer quickly changing\n\
    \   resources may thereby make it impossible for a client to ever\n   retrieve\
    \ a consistent set of blocks.  Clients that want to retrieve\n   all blocks of\
    \ a resource SHOULD strive to do so without undue delay.\n   Servers can fully\
    \ expect to be free to discard any cached state after\n   a period of EXCHANGE_LIFETIME\
    \ ([RFC7252], Section 4.8.2) after the\n   last access to the state, however,\
    \ there is no requirement to always\n   keep the state for as long.\n   The Block2\
    \ Option provides no way for a single endpoint to perform\n   multiple concurrently\
    \ proceeding block-wise response payload transfer\n   (e.g., GET) operations to\
    \ the same resource.  This is rarely a\n   requirement, but as a workaround, a\
    \ client may vary the cache key\n   (e.g., by using one of several URIs accessing\
    \ resources with the same\n   semantics, or by varying a proxy-safe elective option).\n"
- title: 2.5.  Using the Block1 Option
  contents:
  - "2.5.  Using the Block1 Option\n   In a request with a request payload (e.g.,\
    \ PUT or POST), the Block1\n   Option refers to the payload in the request (descriptive\
    \ usage).\n   In response to a request with a payload (e.g., a PUT or POST\n \
    \  transfer), the block size given in the Block1 Option indicates the\n   block\
    \ size preference of the server for this resource (control\n   usage).  Obviously,\
    \ at this point the first block has already been\n   transferred by the client\
    \ without benefit of this knowledge.  Still,\n   the client SHOULD heed the preference\
    \ indicated and, for all further\n   blocks, use the block size preferred by the\
    \ server or a smaller one.\n   Note that any reduction in the block size may mean\
    \ that the second\n   request starts with a block number larger than one, as the\
    \ first\n   request already transferred multiple blocks as counted in the smaller\n\
    \   size.\n   To counter the effects of adaptation-layer fragmentation on packet-\n\
    \   delivery probability, a client may want to give up retransmitting a\n   request\
    \ with a relatively large payload even before MAX_RETRANSMIT\n   has been reached,\
    \ and try restating the request as a block-wise\n   transfer with a smaller payload.\
    \  Note that this new attempt is then\n   a new message-layer transaction and\
    \ requires a new Message ID.\n   (Because of the uncertainty about whether the\
    \ request or the\n   acknowledgement was lost, this strategy is useful mostly\
    \ for\n   idempotent requests.)\n   In a block-wise transfer of a request payload\
    \ (e.g., a PUT or POST)\n   that is intended to be implemented in an atomic fashion\
    \ at the\n   server, the actual creation/replacement takes place at the time the\n\
    \   final block, i.e., a block with the M bit unset in the Block1 Option,\n  \
    \ is received.  In this case, all success responses to non-final blocks\n   carry\
    \ the response code 2.31 (Continue, Section 2.9.1).  If not all\n   previous blocks\
    \ are available at the server at the time of processing\n   the final block, the\
    \ transfer fails and error code 4.08 (Request\n   Entity Incomplete, Section 2.9.2)\
    \ MUST be returned.  A server MAY\n   also return a 4.08 error code for any (final\
    \ or non-final) Block1\n   transfer that is not in sequence; therefore, clients\
    \ that do not have\n   specific mechanisms to handle this case SHOULD always start\
    \ with\n   block zero and send the following blocks in order.\n   One reason that\
    \ a client might encounter a 4.08 error code is that\n   the server has already\
    \ timed out and discarded the partial request\n   body being assembled.  Clients\
    \ SHOULD strive to send all blocks of a\n   request without undue delay.  Servers\
    \ can fully expect to be free to\n   discard any partial request body when a period\
    \ of EXCHANGE_LIFETIME\n   ([RFC7252], Section 4.8.2) has elapsed after the most\
    \ recent block\n   was transferred; however, there is no requirement on a server\
    \ to\n   always keep the partial request body for as long.\n   The error code\
    \ 4.13 (Request Entity Too Large) can be returned at any\n   time by a server\
    \ that does not currently have the resources to store\n   blocks for a block-wise\
    \ request payload transfer that it would intend\n   to implement in an atomic\
    \ fashion.  (Note that a 4.13 response to a\n   request that does not employ Block1\
    \ is a hint for the client to try\n   sending Block1, and a 4.13 response with\
    \ a smaller SZX in its Block1\n   Option than requested is a hint to try a smaller\
    \ SZX.)\n   A block-wise transfer of a request payload that is implemented in\
    \ a\n   stateless fashion at the server is likely to leave the resource being\n\
    \   operated on in an inconsistent state while the transfer is still\n   ongoing\
    \ or when the client does not complete the transfer.  This\n   characteristic\
    \ is closer to that of remote file systems than to that\n   of HTTP, where state\
    \ is always kept on the server during a transfer.\n   Techniques well known from\
    \ shared file access (e.g., client-specific\n   temporary resources) can be used\
    \ to mitigate this difference from\n   HTTP.\n   The Block1 Option provides no\
    \ way for a single endpoint to perform\n   multiple concurrently proceeding block-wise\
    \ request payload transfer\n   (e.g., PUT or POST) operations to the same resource.\
    \  Starting a new\n   block-wise sequence of requests to the same resource (before\
    \ an old\n   sequence from the same endpoint was finished) simply overwrites the\n\
    \   context the server may still be keeping.  (This is probably exactly\n   what\
    \ one wants in this case -- the client may simply have restarted\n   and lost\
    \ its knowledge of the previous sequence.)\n"
- title: 2.6.  Combining Block-Wise Transfers with the Observe Option
  contents:
  - "2.6.  Combining Block-Wise Transfers with the Observe Option\n   The Observe\
    \ option provides a way for a client to be notified about\n   changes over time\
    \ of a resource [RFC7641].  Resources observed by\n   clients may be larger than\
    \ can be comfortably processed or\n   transferred in one CoAP message.  The following\
    \ rules apply to the\n   combination of block-wise transfers with notifications.\n\
    \   Observation relationships always apply to an entire resource; the\n   Block2\
    \ Option does not provide a way to observe a single block of a\n   resource.\n\
    \   As with basic GET transfers, the client can indicate its desired\n   block\
    \ size in a Block2 Option in the GET request establishing or\n   renewing the\
    \ observation relationship.  If the server supports block-\n   wise transfers,\
    \ it SHOULD take note of the block size and apply it as\n   a maximum size to\
    \ all notifications/responses resulting from the GET\n   request (until the client\
    \ is removed from the list of observers or\n   the entry in that list is updated\
    \ by the server receiving a new GET\n   request for the resource from the client).\n\
    \   When sending a 2.05 (Content) notification, the server only sends the\n  \
    \ first block of the representation.  The client retrieves the rest of\n   the\
    \ representation as if it had caused this first response by a GET\n   request,\
    \ i.e., by using additional GET requests with Block2 Options\n   containing NUM\
    \ values greater than zero.  (This results in the\n   transfer of the entire representation,\
    \ even if only some of the\n   blocks have changed with respect to a previous\
    \ notification.)\n   As with other dynamically changing resources, to ensure that\
    \ the\n   blocks being reassembled are from the same version of the\n   representation,\
    \ the server SHOULD include an ETag Option in each\n   response, and the reassembling\
    \ client MUST compare the ETag Options\n   (Section 2.4).  Even more so than for\
    \ the general case of Block2,\n   clients that want to retrieve all blocks of\
    \ a resource they have been\n   notified about with a first block SHOULD strive\
    \ to do so without\n   undue delay.\n   See Section 3.4 for examples.\n"
- title: 2.7.  Combining Block1 and Block2
  contents:
  - "2.7.  Combining Block1 and Block2\n   In PUT and particularly in POST exchanges,\
    \ both the request body and\n   the response body may be large enough to require\
    \ the use of block-\n   wise transfers.  First, the Block1 transfer of the request\
    \ body\n   proceeds as usual.  In the exchange of the last slice of this block-\n\
    \   wise transfer, the response carries the first slice of the Block2\n   transfer\
    \ (NUM is zero).  To continue this Block2 transfer, the client\n   continues to\
    \ send requests similar to the requests in the Block1\n   phase, but leaves out\
    \ the Block1 Options and includes a Block2\n   request option with non-zero NUM.\n\
    \   Block2 transfers that retrieve the response body for a request that\n   used\
    \ Block1 MUST be performed in sequential order.\n"
- title: 2.8.  Combining Block2 with Multicast
  contents:
  - "2.8.  Combining Block2 with Multicast\n   A client can use the Block2 Option\
    \ in a multicast GET request with\n   NUM = 0 to aid in limiting the size of the\
    \ response.\n   Similarly, a response to a multicast GET request can use a Block2\n\
    \   Option with NUM = 0 if the representation is large, or to further\n   limit\
    \ the size of the response.\n   In both cases, the client retrieves any further\
    \ blocks using unicast\n   exchanges; in the unicast requests, the client SHOULD\
    \ heed any block\n   size preferences indicated by the server in the response\
    \ to the\n   multicast request.\n   Other uses of the Block options in conjunction\
    \ with multicast\n   messages are for further study.\n"
- title: 2.9.  Response Codes
  contents:
  - "2.9.  Response Codes\n   Beyond the response codes defined in [RFC7252], this\
    \ specification\n   defines two response codes and extends the meaning of one.\n"
- title: 2.9.1.  2.31 Continue
  contents:
  - "2.9.1.  2.31 Continue\n   This new success status code indicates that the transfer\
    \ of this\n   block of the request body was successful and that the server\n \
    \  encourages sending further blocks, but that a final outcome of the\n   whole\
    \ block-wise request cannot yet be determined.  No payload is\n   returned with\
    \ this response code.\n"
- title: 2.9.2.  4.08 Request Entity Incomplete
  contents:
  - "2.9.2.  4.08 Request Entity Incomplete\n   This new client error status code\
    \ indicates that the server has not\n   received the blocks of the request body\
    \ that it needs to proceed.\n   The client has not sent all blocks, not sent them\
    \ in the order\n   required by the server, or has sent them long enough ago that\
    \ the\n   server has already discarded them.\n   (Note that one reason for not\
    \ having the necessary blocks at hand may\n   be a Content-Format mismatch, see\
    \ Section 2.3.  Implementation note:\n   A server can reject a Block1 transfer\
    \ with this code when NUM != 0\n   and a different Content-Format is indicated\
    \ than expected from the\n   current state of the resource.  If it implements\
    \ the transfer in a\n   stateless fashion, it can match up the Content-Format\
    \ of the block\n   against that of the existing resource.  If it implements the\
    \ transfer\n   in an atomic fashion, it can match up the block against the partially\n\
    \   reassembled piece of representation that is going to replace the\n   state\
    \ of the resource.)\n"
- title: 2.9.3.  4.13 Request Entity Too Large
  contents:
  - "2.9.3.  4.13 Request Entity Too Large\n   In Section 5.9.2.9 of [RFC7252], the\
    \ response code 4.13 (Request\n   Entity Too Large) is defined to be like HTTP\
    \ 413 \"Request Entity Too\n   Large\".  [RFC7252] also recommends that this response\
    \ SHOULD include\n   a Size1 Option (Section 4) to indicate the maximum size of\
    \ request\n   entity the server is able and willing to handle, unless the server\
    \ is\n   not in a position to make this information available.\n   The present\
    \ specification allows the server to return this response\n   code at any time\
    \ during a Block1 transfer to indicate that it does\n   not currently have the\
    \ resources to store blocks for a transfer that\n   it would intend to implement\
    \ in an atomic fashion.  It also allows\n   the server to return a 4.13 response\
    \ to a request that does not\n   employ Block1 as a hint for the client to try\
    \ sending Block1.\n   Finally, a 4.13 response to a request with a Block1 Option\
    \ (control\n   usage, see Section 2.3) where the response carries a smaller SZX\
    \ in\n   its Block1 Option is a hint to try that smaller SZX.\n"
- title: 2.10.  Caching Considerations
  contents:
  - "2.10.  Caching Considerations\n   This specification attempts to leave a variety\
    \ of implementation\n   strategies open for caches, in particular those in caching\
    \ proxies.\n   For example, a cache is free to cache blocks individually, but\
    \ also\n   could wait to obtain the complete representation before it serves\n\
    \   parts of it.  Partial caching may be more efficient in a cross-proxy\n   (equivalent\
    \ to a streaming HTTP proxy).  A cached block (partial\n   cached response) can\
    \ be used in place of a complete response to\n   satisfy a block-wise request\
    \ that is presented to a cache.  Note that\n   different blocks can have different\
    \ Max-Age values, as they are\n   transferred at different times.  A response\
    \ with a block updates the\n   freshness of the complete representation.  Individual\
    \ blocks can be\n   validated, and validating a single block validates the complete\n\
    \   representation.  A response with a Block1 Option in control usage\n   with\
    \ the M bit set invalidates cached responses for the target URI.\n   A cache or\
    \ proxy that combines responses (e.g., to split blocks in a\n   request or increase\
    \ the block size in a response, or a cross-proxy)\n   may need to combine 2.31\
    \ and 2.01/2.04 responses; a stateless server\n   may be responding with 2.01\
    \ only on the first Block1 block\n   transferred, which dominates any 2.04 responses\
    \ for later blocks.\n   If-None-Match only works correctly on Block1 requests\
    \ with (NUM=0)\n   and MUST NOT be used on Block1 requests with NUM != 0.\n"
- title: 3.  Examples
  contents:
  - "3.  Examples\n   This section gives a number of short examples with message flows\
    \ for\n   a block-wise GET, and for a PUT or POST.  These examples demonstrate\n\
    \   the basic operation, the operation in the presence of\n   retransmissions,\
    \ and examples for the operation of the block size\n   negotiation.\n   In all\
    \ these examples, a Block option is shown in a decomposed way\n   indicating the\
    \ kind of Block option (1 or 2) followed by a colon, and\n   then the block number\
    \ (NUM), more bit (M), and block size exponent\n   (2**(SZX+4)) separated by slashes.\
    \  For example, a Block2 Option\n   value of 33 would be shown as 2:2/0/32) and\
    \ a Block1 Option value of\n   59 would be shown as 1:3/1/128.\n   As in [RFC7252],\
    \ \"MID\" is used as an abbreviation for \"Message ID\".\n"
- title: 3.1.  Block2 Examples
  contents:
  - "3.1.  Block2 Examples\n   The first example (Figure 2) shows a GET request that\
    \ is split into\n   three blocks.  The server proposes a block size of 128, and\
    \ the\n   client agrees.  The first two ACKs contain a payload of 128 bytes\n\
    \   each, and the third ACK contains a payload between 1 and 128 bytes.\n   CLIENT\
    \                                                     SERVER\n     |         \
    \                                                   |\n     | CON [MID=1234],\
    \ GET, /status                       ------> |\n     |                       \
    \                                     |\n     | <------   ACK [MID=1234], 2.05\
    \ Content, 2:0/1/128          |\n     |                                      \
    \                      |\n     | CON [MID=1235], GET, /status, 2:1/0/128     \
    \       ------> |\n     |                                                    \
    \        |\n     | <------   ACK [MID=1235], 2.05 Content, 2:1/1/128         \
    \ |\n     |                                                            |\n   \
    \  | CON [MID=1236], GET, /status, 2:2/0/128            ------> |\n     |    \
    \                                                        |\n     | <------   ACK\
    \ [MID=1236], 2.05 Content, 2:2/0/128          |\n                      Figure\
    \ 2: Simple Block-Wise GET\n   In the second example (Figure 3), the client anticipates\
    \ the block-\n   wise transfer (e.g., because of a size indication in the link-format\n\
    \   description [RFC6690]) and sends a block size proposal.  All ACK\n   messages\
    \ except for the last carry 64 bytes of payload; the last one\n   carries between\
    \ 1 and 64 bytes.\n   CLIENT                                                 \
    \    SERVER\n     |                                                          |\n\
    \     | CON [MID=1234], GET, /status, 2:0/0/64           ------> |\n     |   \
    \                                                       |\n     | <------   ACK\
    \ [MID=1234], 2.05 Content, 2:0/1/64         |\n     |                       \
    \                                   |\n     | CON [MID=1235], GET, /status, 2:1/0/64\
    \           ------> |\n     |                                                \
    \          |\n     | <------   ACK [MID=1235], 2.05 Content, 2:1/1/64        \
    \ |\n     :                                                          :\n     :\
    \                          ...                             :\n     :         \
    \                                                 :\n     | CON [MID=1238], GET,\
    \ /status, 2:4/0/64           ------> |\n     |                              \
    \                            |\n     | <------   ACK [MID=1238], 2.05 Content,\
    \ 2:4/1/64         |\n     |                                                 \
    \         |\n     | CON [MID=1239], GET, /status, 2:5/0/64           ------> |\n\
    \     |                                                          |\n     | <------\
    \   ACK [MID=1239], 2.05 Content, 2:5/0/64         |\n              Figure 3:\
    \ Block-Wise GET with Early Negotiation\n   In the third example (Figure 4), the\
    \ client is surprised by the need\n   for a block-wise transfer, and unhappy with\
    \ the size chosen\n   unilaterally by the server.  As it did not send a size proposal\n\
    \   initially, the negotiation only influences the size from the second\n   message\
    \ exchange onward.  Since the client already obtained both the\n   first and second\
    \ 64-byte block in the first 128-byte exchange, it\n   goes on requesting the\
    \ third 64-byte block (\"2/0/64\").  None of this\n   is (or needs to be) understood\
    \ by the server, which simply responds\n   to the requests as it best can.\n \
    \  CLIENT                                                     SERVER\n     | \
    \                                                         |\n     | CON [MID=1234],\
    \ GET, /status                     ------> |\n     |                         \
    \                                 |\n     | <------   ACK [MID=1234], 2.05 Content,\
    \ 2:0/1/128        |\n     |                                                 \
    \         |\n     | CON [MID=1235], GET, /status, 2:2/0/64           ------> |\n\
    \     |                                                          |\n     | <------\
    \   ACK [MID=1235], 2.05 Content, 2:2/1/64         |\n     |                 \
    \                                         |\n     | CON [MID=1236], GET, /status,\
    \ 2:3/0/64           ------> |\n     |                                       \
    \                   |\n     | <------   ACK [MID=1236], 2.05 Content, 2:3/1/64\
    \         |\n     |                                                          |\n\
    \     | CON [MID=1237], GET, /status, 2:4/0/64           ------> |\n     |   \
    \                                                       |\n     | <------   ACK\
    \ [MID=1237], 2.05 Content, 2:4/1/64         |\n     |                       \
    \                                   |\n     | CON [MID=1238], GET, /status, 2:5/0/64\
    \           ------> |\n     |                                                \
    \          |\n     | <------   ACK [MID=1238], 2.05 Content, 2:5/0/64        \
    \ |\n              Figure 4: Block-Wise GET with Late Negotiation\n   In all these\
    \ (and the following) cases, retransmissions are handled\n   by the CoAP message\
    \ exchange layer, so they don't influence the block\n   operations (Figures 5\
    \ and 6).\n   CLIENT                                                     SERVER\n\
    \     |                                                          |\n     | CON\
    \ [MID=1234], GET, /status                     ------> |\n     |             \
    \                                             |\n     | <------   ACK [MID=1234],\
    \ 2.05 Content, 2:0/1/128        |\n     |                                   \
    \                       |\n     | CON [MID=1235], GE/////////////////////////\
    \              |\n     |                                                     \
    \     |\n     | (timeout)                                                |\n \
    \    |                                                          |\n     | CON\
    \ [MID=1235], GET, /status, 2:2/0/64           ------> |\n     |             \
    \                                             |\n     | <------   ACK [MID=1235],\
    \ 2.05 Content, 2:2/1/64         |\n     :                                   \
    \                       :\n     :                          ...               \
    \              :\n     :                                                     \
    \     :\n     | CON [MID=1238], GET, /status, 2:5/0/64           ------> |\n \
    \    |                                                          |\n     | <------\
    \   ACK [MID=1238], 2.05 Content, 2:5/0/64         |\n        Figure 5: Block-Wise\
    \ GET with Late Negotiation and Lost CON\n   CLIENT                          \
    \                           SERVER\n     |                                   \
    \                       |\n     | CON [MID=1234], GET, /status               \
    \      ------> |\n     |                                                     \
    \     |\n     | <------   ACK [MID=1234], 2.05 Content, 2:0/1/128        |\n \
    \    |                                                          |\n     | CON\
    \ [MID=1235], GET, /status, 2:2/0/64           ------> |\n     |             \
    \                                             |\n     | //////////////////////////////////tent,\
    \ 2:2/1/64         |\n     |                                                 \
    \         |\n     | (timeout)                                                |\n\
    \     |                                                          |\n     | CON\
    \ [MID=1235], GET, /status, 2:2/0/64           ------> |\n     |             \
    \                                             |\n     | <------   ACK [MID=1235],\
    \ 2.05 Content, 2:2/1/64         |\n     :                                   \
    \                       :\n     :                          ...               \
    \              :\n     :                                                     \
    \     :\n     | CON [MID=1238], GET, /status, 2:5/0/64           ------> |\n \
    \    |                                                          |\n     | <------\
    \   ACK [MID=1238], 2.05 Content, 2:5/0/64         |\n        Figure 6: Block-Wise\
    \ GET with Late Negotiation and Lost ACK\n"
- title: 3.2.  Block1 Examples
  contents:
  - "3.2.  Block1 Examples\n   The following examples demonstrate a PUT exchange;\
    \ a POST exchange\n   looks the same, with different requirements on atomicity/idempotence.\n\
    \   Note that, similar to GET, the responses to the requests that have a\n   more\
    \ bit in the request Block1 Option are provisional and carry the\n   response\
    \ code 2.31 (Continue); only the final response tells the\n   client that the\
    \ PUT succeeded.\n   CLIENT                                                  \
    \   SERVER\n     |                                                          |\n\
    \     | CON [MID=1234], PUT, /options, 1:0/1/128    ------>      |\n     |   \
    \                                                       |\n     | <------   ACK\
    \ [MID=1234], 2.31 Continue, 1:0/1/128       |\n     |                       \
    \                                   |\n     | CON [MID=1235], PUT, /options, 1:1/1/128\
    \    ------>      |\n     |                                                  \
    \        |\n     | <------   ACK [MID=1235], 2.31 Continue, 1:1/1/128       |\n\
    \     |                                                          |\n     | CON\
    \ [MID=1236], PUT, /options, 1:2/0/128    ------>      |\n     |             \
    \                                             |\n     | <------   ACK [MID=1236],\
    \ 2.04 Changed, 1:2/0/128        |\n                  Figure 7: Simple Atomic\
    \ Block-Wise PUT\n   A stateless server that simply builds/updates the resource\
    \ in place\n   (statelessly) may indicate this by not setting the more bit in\
    \ the\n   response (Figure 8); in this case, the response codes are valid\n  \
    \ separately for each block being updated.  This is of course only an\n   acceptable\
    \ behavior of the server if the potential inconsistency\n   present during the\
    \ run of the message exchange sequence does not lead\n   to problems, e.g., because\
    \ the resource being created or changed is\n   not yet or not currently in use.\n\
    \   CLIENT                                                     SERVER\n     |\
    \                                                          |\n     | CON [MID=1234],\
    \ PUT, /options, 1:0/1/128    ------>      |\n     |                         \
    \                                 |\n     | <------   ACK [MID=1234], 2.04 Changed,\
    \ 1:0/0/128        |\n     |                                                 \
    \         |\n     | CON [MID=1235], PUT, /options, 1:1/1/128    ------>      |\n\
    \     |                                                          |\n     | <------\
    \   ACK [MID=1235], 2.04 Changed, 1:1/0/128        |\n     |                 \
    \                                         |\n     | CON [MID=1236], PUT, /options,\
    \ 1:2/0/128    ------>      |\n     |                                        \
    \                  |\n     | <------   ACK [MID=1236], 2.04 Changed, 1:2/0/128\
    \        |\n                 Figure 8: Simple Stateless Block-Wise PUT\n   Finally,\
    \ a server receiving a block-wise PUT or POST may want to\n   indicate a smaller\
    \ block size preference (Figure 9).  In this case,\n   the client SHOULD continue\
    \ with a smaller block size; if it does, it\n   MUST adjust the block number to\
    \ properly count in that smaller size.\n   CLIENT                            \
    \                         SERVER\n     |                                     \
    \                     |\n     | CON [MID=1234], PUT, /options, 1:0/1/128    ------>\
    \      |\n     |                                                          |\n\
    \     | <------   ACK [MID=1234], 2.31 Continue, 1:0/1/32        |\n     |   \
    \                                                       |\n     | CON [MID=1235],\
    \ PUT, /options, 1:4/1/32     ------>      |\n     |                         \
    \                                 |\n     | <------   ACK [MID=1235], 2.31 Continue,\
    \ 1:4/1/32        |\n     |                                                  \
    \        |\n     | CON [MID=1236], PUT, /options, 1:5/1/32     ------>      |\n\
    \     |                                                          |\n     | <------\
    \   ACK [MID=1235], 2.31 Continue, 1:5/1/32        |\n     |                 \
    \                                         |\n     | CON [MID=1237], PUT, /options,\
    \ 1:6/0/32     ------>      |\n     |                                        \
    \                  |\n     | <------   ACK [MID=1236], 2.04 Changed, 1:6/0/32\
    \         |\n          Figure 9: Simple Atomic Block-Wise PUT with Negotiation\n"
- title: 3.3.  Combining Block1 and Block2
  contents:
  - "3.3.  Combining Block1 and Block2\n   Block options may be used in both directions\
    \ of a single exchange.\n   The following example demonstrates a block-wise POST\
    \ request,\n   resulting in a separate block-wise response.\n   CLIENT       \
    \                                              SERVER\n     |                \
    \                                              |\n     | CON [MID=1234], POST,\
    \ /soap, 1:0/1/128      ------>          |\n     |                           \
    \                                   |\n     | <------   ACK [MID=1234], 2.31 Continue,\
    \ 1:0/1/128           |\n     |                                              \
    \                |\n     | CON [MID=1235], POST, /soap, 1:1/1/128      ------>\
    \          |\n     |                                                         \
    \     |\n     | <------   ACK [MID=1235], 2.31 Continue, 1:1/1/128           |\n\
    \     |                                                              |\n     |\
    \ CON [MID=1236], POST, /soap, 1:2/0/128      ------>          |\n     |     \
    \                                                         |\n     | <------  \
    \ ACK [MID=1236], 2.04 Changed, 2:0/1/128, 1:2/0/128 |\n     |               \
    \                                               |\n     | CON [MID=1237], POST,\
    \ /soap, 2:1/0/128      ------>          |\n     | (no payload for requests with\
    \ Block2 with NUM != 0)          |\n     | (could also do late negotiation by\
    \ requesting,               |\n     |  e.g., 2:2/0/64)                       \
    \                      |\n     |                                             \
    \                 |\n     | <------   ACK [MID=1237], 2.04 Changed, 2:1/1/128\
    \            |\n     |                                                       \
    \       |\n     | CON [MID=1238], POST, /soap, 2:2/0/128      ------>        \
    \  |\n     |                                                              |\n\
    \     | <------   ACK [MID=1238], 2.04 Changed, 2:2/1/128            |\n     |\
    \                                                              |\n     | CON [MID=1239],\
    \ POST, /soap, 2:3/0/128      ------>          |\n     |                     \
    \                                         |\n     | <------   ACK [MID=1239],\
    \ 2.04 Changed, 2:3/0/128            |\n        Figure 10: Atomic Block-Wise POST\
    \ with Block-Wise Response\n   This model does provide for early negotiation input\
    \ to the Block2\n   block-wise transfer, as shown below.\n   CLIENT          \
    \                                           SERVER\n     |                   \
    \                                           |\n     | CON [MID=1234], POST, /soap,\
    \ 1:0/1/128 ------>               |\n     |                                  \
    \                            |\n     | <------   ACK [MID=1234], 2.31 Continue,\
    \ 1:0/1/128           |\n     |                                              \
    \                |\n     | CON [MID=1235], POST, /soap, 1:1/1/128 ------>    \
    \           |\n     |                                                        \
    \      |\n     | <------   ACK [MID=1235], 2.31 Continue, 1:1/1/128          \
    \ |\n     |                                                              |\n \
    \    | CON [MID=1236], POST, /soap, 1:2/0/128, 2:0/0/64 ------>     |\n     |\
    \                                                              |\n     | <------\
    \   ACK [MID=1236], 2.04 Changed, 1:2/0/128, 2:0/1/64  |\n     |             \
    \                                                 |\n     | CON [MID=1237], POST,\
    \ /soap, 2:1/0/64      ------>           |\n     | (no payload for requests with\
    \ Block2 with NUM != 0)          |\n     |                                   \
    \                           |\n     | <------   ACK [MID=1237], 2.04 Changed,\
    \ 2:1/1/64             |\n     |                                             \
    \                 |\n     | CON [MID=1238], POST, /soap, 2:2/0/64      ------>\
    \           |\n     |                                                        \
    \      |\n     | <------   ACK [MID=1238], 2.04 Changed, 2:2/1/64            \
    \ |\n     |                                                              |\n \
    \    | CON [MID=1239], POST, /soap, 2:3/0/64      ------>           |\n     |\
    \                                                              |\n     | <------\
    \   ACK [MID=1239], 2.04 Changed, 2:3/0/64             |\n        Figure 11: Atomic\
    \ Block-Wise POST with Block-Wise Response,\n                             Early\
    \ Negotiation\n"
- title: 3.4.  Combining Observe and Block2
  contents:
  - "3.4.  Combining Observe and Block2\n   In the following example, the server first\
    \ sends a direct response\n   (Observe sequence number 62350) to the initial GET\
    \ request (the\n   resulting block-wise transfer is as in Figure 4 and has therefore\n\
    \   been left out).  The second transfer is started by a 2.05\n   notification\
    \ that contains just the first block (Observe sequence\n   number 62354); the\
    \ client then goes on to obtain the rest of the\n   blocks.\n       CLIENT  SERVER\n\
    \         |      |\n         +----->|     Header: GET 0x41011636\n         | GET\
    \  |      Token: 0xfb\n         |      |   Uri-Path: status-icon\n         | \
    \     |    Observe: (empty)\n         |      |\n         |<-----+     Header:\
    \ 2.05 0x61451636\n         | 2.05 |      Token: 0xfb\n         |      |     Block2:\
    \ 0/1/128\n         |      |    Observe: 62350\n         |      |       ETag:\
    \ 6f00f38e\n         |      |    Payload: [128 bytes]\n         |      |\n   \
    \      |      |  (Usual GET transfer left out)\n           ...\n         |   \
    \   |  (Notification of first block)\n         |      |\n         |<-----+   \
    \  Header: 2.05 0x4145af9c\n         | 2.05 |      Token: 0xfb\n         |   \
    \   |     Block2: 0/1/128\n         |      |    Observe: 62354\n         |   \
    \   |       ETag: 6f00f392\n         |      |    Payload: [128 bytes]\n      \
    \   |      |\n         +- - ->|     Header: 0x6000af9c\n         |      |\n  \
    \       |      |  (Retrieval of remaining blocks)\n         |      |\n       \
    \  +----->|     Header: GET 0x41011637\n         | GET  |      Token: 0xfc\n \
    \        |      |   Uri-Path: status-icon\n         |      |     Block2: 1/0/128\n\
    \         |      |\n         |<-----+     Header: 2.05 0x61451637\n         |\
    \ 2.05 |      Token: 0xfc\n         |      |     Block2: 1/1/128\n         | \
    \     |       ETag: 6f00f392\n         |      |    Payload: [128 bytes]\n    \
    \     |      |\n         +----->|     Header: GET 0x41011638\n         | GET \
    \ |      Token: 0xfc\n         |      |   Uri-Path: status-icon\n         |  \
    \    |     Block2: 2/0/128\n         |      |\n         |<-----+     Header: 2.05\
    \ 0x61451638\n         | 2.05 |      Token: 0xfc\n         |      |     Block2:\
    \ 2/0/128\n         |      |       ETag: 6f00f392\n         |      |    Payload:\
    \ [53 bytes]\n           Figure 12: Observe Sequence with Block-Wise Response\n\
    \   (Note that the choice of token 0xfc in this example is arbitrary;\n   tokens\
    \ are just shown in this example to illustrate that the requests\n   for additional\
    \ blocks cannot make use of the token of the Observation\n   relationship.  As\
    \ a general comment on tokens, there is no other\n   mention of tokens in this\
    \ document, as block-wise transfers handle\n   tokens like any other CoAP exchange.\
    \  As usual, the client is free to\n   choose tokens for each exchange as it likes.)\n\
    \   In the following example, the client also uses early negotiation to\n   limit\
    \ the block size to 64 bytes.\n       CLIENT  SERVER\n         |      |\n    \
    \     +----->|     Header: GET 0x41011636\n         | GET  |      Token: 0xfb\n\
    \         |      |   Uri-Path: status-icon\n         |      |    Observe: (empty)\n\
    \         |      |     Block2: 0/0/64\n         |      |\n         |<-----+  \
    \   Header: 2.05 0x61451636\n         | 2.05 |      Token: 0xfb\n         |  \
    \    |     Block2: 0/1/64\n         |      |    Observe: 62350\n         |   \
    \   |       ETag: 6f00f38e\n         |      |    Max-Age: 60\n         |     \
    \ |    Payload: [64 bytes]\n         |      |\n         |      |  (Usual GET transfer\
    \ left out)\n           ...\n         |      |  (Notification of first block)\n\
    \         |      |\n         |<-----+     Header: 2.05 0x4145af9c\n         |\
    \ 2.05 |      Token: 0xfb\n         |      |     Block2: 0/1/64\n         |  \
    \    |    Observe: 62354\n         |      |       ETag: 6f00f392\n         | \
    \     |    Payload: [64 bytes]\n         |      |\n         +- - ->|     Header:\
    \ 0x6000af9c\n         |      |\n         |      |  (Retrieval of remaining blocks)\n\
    \         |      |\n         +----->|     Header: GET 0x41011637\n         | GET\
    \  |      Token: 0xfc\n         |      |   Uri-Path: status-icon\n         | \
    \     |     Block2: 1/0/64\n         |      |\n         |<-----+     Header: 2.05\
    \ 0x61451637\n         | 2.05 |      Token: 0xfc\n         |      |     Block2:\
    \ 1/1/64\n         |      |       ETag: 6f00f392\n         |      |    Payload:\
    \ [64 bytes]\n           ....\n         |      |\n         +----->|     Header:\
    \ GET 0x41011638\n         | GET  |      Token: 0xfc\n         |      |   Uri-Path:\
    \ status-icon\n         |      |     Block2: 4/0/64\n         |      |\n     \
    \    |<-----+     Header: 2.05 0x61451638\n         | 2.05 |      Token: 0xfc\n\
    \         |      |     Block2: 4/0/64\n         |      |       ETag: 6f00f392\n\
    \         |      |    Payload: [53 bytes]\n            Figure 13: Observe Sequence\
    \ with Early Negotiation\n"
- title: 4.  The Size2 and Size1 Options
  contents:
  - "4.  The Size2 and Size1 Options\n   In many cases when transferring a large resource\
    \ representation block\n   by block, it is advantageous to know the total size\
    \ early in the\n   process.  Some indication may be available from the maximum\
    \ size\n   estimate attribute \"sz\" provided in a resource description [RFC6690].\n\
    \   However, the size may vary dynamically, so a more up-to-date\n   indication\
    \ may be useful.\n   This specification defines two CoAP options, Size1 for indicating\
    \ the\n   size of the representation transferred in requests, and Size2 for\n\
    \   indicating the size of the representation transferred in responses.\n   (Size1\
    \ has already been defined in Section 5.10.9 of [RFC7252] to\n   provide \"size\
    \ information about the resource representation in a\n   request\"; however, that\
    \ section only details the narrow case of\n   indicating in 4.13 responses the\
    \ maximum size of request payload that\n   the server is able and willing to handle.\
    \  The present specification\n   provides details about its use as a request option\
    \ as well.)\n   The Size2 Option may be used for two purposes:\n   o  In a request,\
    \ to ask the server to provide a size estimate along\n      with the usual response\
    \ (\"size request\").  For this usage, the\n      value MUST be set to 0.\n  \
    \ o  In a response carrying a Block2 Option, to indicate the current\n      estimate\
    \ the server has of the total size of the resource\n      representation, measured\
    \ in bytes (\"size indication\").\n   Similarly, the Size1 Option may be used\
    \ for two purposes:\n   o  In a request carrying a Block1 Option, to indicate\
    \ the current\n      estimate the client has of the total size of the resource\n\
    \      representation, measured in bytes (\"size indication\").\n   o  In a 4.13\
    \ response, to indicate the maximum size that would have\n      been acceptable\
    \ [RFC7252], measured in bytes.\n   Apart from conveying/asking for size information,\
    \ the Size options\n   have no other effect on the processing of the request or\
    \ response.\n   If the client wants to minimize the size of the payload in the\n\
    \   resulting response, it should add a Block2 Option to the request with\n  \
    \ a small block size (e.g., setting SZX=0).\n   The Size options are \"elective\"\
    , i.e., a client MUST be prepared for\n   the server to ignore the size estimate\
    \ request.  Either Size option\n   MUST NOT occur more than once in a single message.\n\
    \        +-----+---+---+---+---+-------+--------+--------+---------+\n       \
    \ | No. | C | U | N | R | Name  | Format | Length | Default |\n        +-----+---+---+---+---+-------+--------+--------+---------+\n\
    \        |  60 |   |   | x |   | Size1 | uint   |    0-4 | (none)  |\n       \
    \ |     |   |   |   |   |       |        |        |         |\n        |  28 |\
    \   |   | x |   | Size2 | uint   |    0-4 | (none)  |\n        +-----+---+---+---+---+-------+--------+--------+---------+\n\
    \                       Table 2: Size Option Numbers\n   Implementation Notes:\n\
    \   o  As a quality of implementation consideration, block-wise transfers\n  \
    \    for which the total size considerably exceeds the size of one\n      block\
    \ are expected to include size indications, whenever those can\n      be provided\
    \ without undue effort (preferably with the first block\n      exchanged).  If\
    \ the size estimate does not change, the indication\n      does not need to be\
    \ repeated for every block.\n   o  The end of a block-wise transfer is governed\
    \ by the M bits in the\n      Block options, _not_ by exhausting the size estimates\
    \ exchanged.\n   o  As usual for an option of type uint, the value 0 is best expressed\n\
    \      as an empty option (0 bytes).  There is no default value for\n      either\
    \ Size option.\n   o  The Size options are neither critical nor unsafe, and are\
    \ marked\n      as No-Cache-Key.\n"
- title: 5.  HTTP-Mapping Considerations
  contents:
  - "5.  HTTP-Mapping Considerations\n   In this subsection, we give some brief examples\
    \ of the influence that\n   the Block options might have on intermediaries that\
    \ map between CoAP\n   and HTTP.\n   For mapping CoAP requests to HTTP, the intermediary\
    \ may want to map\n   the sequence of block-wise transfers into a single HTTP\
    \ transfer.\n   For example, for a GET request, the intermediary could perform\
    \ the\n   HTTP request once the first block has been requested and could then\n\
    \   fulfill all further block requests out of its cache.  A constrained\n   implementation\
    \ may not be able to cache the entire object and may use\n   a combination of\
    \ TCP flow control and (in particular if timeouts\n   occur) HTTP range requests\
    \ to obtain the information necessary for\n   the next block transfer at the right\
    \ time.\n   For PUT or POST requests, historically there was more variation in\n\
    \   how HTTP servers might implement ranges; recently, [RFC7233] has\n   defined\
    \ that Range header fields received with a request method other\n   than GET are\
    \ not to be interpreted.  So, in general, the CoAP-to-HTTP\n   intermediary will\
    \ have to try sending the payload of all the blocks\n   of a block-wise transfer\
    \ for these other methods within one HTTP\n   request.  If enough buffering is\
    \ available, this request can be\n   started when the last CoAP block is received.\
    \  A constrained\n   implementation may want to relieve its buffering by already\
    \ starting\n   to send the HTTP request at the time the first CoAP block is\n\
    \   received; any HTTP 408 status code that indicates that the HTTP\n   server\
    \ became impatient with the resulting transfer can then be\n   mapped into a CoAP\
    \ 4.08 response code (similarly, 413 maps to 4.13).\n   For mapping HTTP to CoAP,\
    \ the intermediary may want to map a single\n   HTTP transfer into a sequence\
    \ of block-wise transfers.  If the HTTP\n   client is too slow delivering a request\
    \ body on a PUT or POST, the\n   CoAP server might time out and return a 4.08\
    \ response code, which in\n   turn maps well to an HTTP 408 status code (again,\
    \ 4.13 maps to 413).\n   HTTP range requests received on the HTTP side may be\
    \ served out of a\n   cache and/or mapped to GET requests that request a sequence\
    \ of blocks\n   that cover the range.\n   (Note that, while the semantics of CoAP\
    \ 4.08 and HTTP 408 differ,\n   this difference is largely due to the different\
    \ way the two protocols\n   are mapped to transport.  HTTP has an underlying TCP\
    \ connection,\n   which supplies connection state, so an HTTP 408 status code\
    \ can\n   immediately be used to indicate that a timeout occurred during\n   transmitting\
    \ a request through that active TCP connection.  The CoAP\n   4.08 response code\
    \ indicates one or more missing blocks, which may be\n   due to timeouts or resource\
    \ constraints; as there is no connection\n   state, there is no way to deliver\
    \ such a response immediately;\n   instead, it is delivered on the next block\
    \ transfer.  Still, HTTP 408\n   is probably the best mapping back to HTTP, as\
    \ the timeout is the most\n   likely cause for a CoAP 4.08.  Note that there is\
    \ no way to\n   distinguish a timeout from a missing block for a server without\n\
    \   creating additional state, the need for which we want to avoid.)\n"
- title: 6.  IANA Considerations
  contents:
  - "6.  IANA Considerations\n   This document adds the following option numbers to\
    \ the \"CoAP Option\n   Numbers\" registry defined by [RFC7252]:\n           \
    \           +--------+--------+-----------+\n                      | Number |\
    \ Name   | Reference |\n                      +--------+--------+-----------+\n\
    \                      | 23     | Block2 | RFC 7959  |\n                     \
    \ |        |        |           |\n                      | 27     | Block1 | RFC\
    \ 7959  |\n                      |        |        |           |\n           \
    \           | 28     | Size2  | RFC 7959  |\n                      +--------+--------+-----------+\n\
    \                       Table 3: CoAP Option Numbers\n   This document adds the\
    \ following response codes to the \"CoAP Response\n   Codes\" registry defined\
    \ by [RFC7252]:\n             +------+---------------------------+-----------+\n\
    \             | Code | Description               | Reference |\n             +------+---------------------------+-----------+\n\
    \             | 2.31 | Continue                  | RFC 7959  |\n             |\
    \      |                           |           |\n             | 4.08 | Request\
    \ Entity Incomplete | RFC 7959  |\n             +------+---------------------------+-----------+\n\
    \                       Table 4: CoAP Response Codes\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   Providing access to blocks within a resource\
    \ may lead to surprising\n   vulnerabilities.  Where requests are not implemented\
    \ atomically, an\n   attacker may be able to exploit a race condition or confuse\
    \ a server\n   by inducing it to use a partially updated resource representation.\n\
    \   Partial transfers may also make certain problematic data invisible to\n  \
    \ Intrusion Detection Systems (IDSs); it is RECOMMENDED that an IDS\n   that analyzes\
    \ resource representations transferred by CoAP implement\n   the Block options\
    \ to gain access to entire resource representations.\n   Still, approaches such\
    \ as transferring even-numbered blocks on one\n   path and odd-numbered blocks\
    \ on another path, or even transferring\n   blocks multiple times with different\
    \ content and obtaining a\n   different interpretation of temporal order at the\
    \ IDS than at the\n   server, may prevent an IDS from seeing the whole picture.\
    \  These\n   kinds of attacks are well understood from IP fragmentation and TCP\n\
    \   segmentation; CoAP does not add fundamentally new considerations.\n   Where\
    \ access to a resource is only granted to clients making use of\n   specific security\
    \ associations, all blocks of that resource MUST be\n   subject to the same security\
    \ checks; it MUST NOT be possible for\n   unprotected exchanges to influence blocks\
    \ of an otherwise protected\n   resource.  As a related consideration, where object\
    \ security is\n   employed, PUT/POST should be implemented in the atomic fashion,\n\
    \   unless the object security operation is performed on each access and\n   the\
    \ creation of unusable resources can be tolerated.  Future end-to-\n   end security\
    \ mechanisms that may be added to CoAP itself may have\n   related security considerations,\
    \ this includes considerations about\n   caching of blocks in clients and in proxies\
    \ (see Sections 2.10 and 5\n   for different strategies in performing this caching);\
    \ these security\n   considerations will need to be described in the specifications\
    \ of\n   those mechanisms.\n   A stateless server might be susceptible to an attack\
    \ where the\n   adversary sends a Block1 (e.g., PUT) block with a high block number:\n\
    \   A naive implementation might exhaust its resources by creating a huge\n  \
    \ resource representation.\n   Misleading size indications may be used by an attacker\
    \ to induce\n   buffer overflows in poor implementations, for which the usual\n\
    \   considerations apply.\n"
- title: 7.1.  Mitigating Resource Exhaustion Attacks
  contents:
  - "7.1.  Mitigating Resource Exhaustion Attacks\n   Certain block-wise requests\
    \ may induce the server to create state,\n   e.g., to create a snapshot for the\
    \ block-wise GET of a fast-changing\n   resource to enable consistent access to\
    \ the same version of a\n   resource for all blocks, or to create temporary resource\n\
    \   representations that are collected until pressed into service by a\n   final\
    \ PUT or POST with the more bit unset.  All mechanisms that\n   induce a server\
    \ to create state that cannot simply be cleaned up\n   create opportunities for\
    \ denial-of-service attacks.  Servers SHOULD\n   avoid being subject to resource\
    \ exhaustion based on state created by\n   untrusted sources.  But even if this\
    \ is done, the mitigation may\n   cause a denial-of-service to a legitimate request\
    \ when it is drowned\n   out by other state-creating requests.  Wherever possible,\
    \ servers\n   should therefore minimize the opportunities to create state for\n\
    \   untrusted sources, e.g., by using stateless approaches.\n   Performing segmentation\
    \ at the application layer is almost always\n   better in this respect than at\
    \ the transport layer or lower (IP\n   fragmentation, adaptation-layer fragmentation),\
    \ for instance, because\n   there are application-layer semantics that can be\
    \ used for mitigation\n   or because lower layers provide security associations\
    \ that can\n   prevent attacks.  However, it is less common to apply timeouts\
    \ and\n   keepalive mechanisms at the application layer than at lower layers.\n\
    \   Servers MAY want to clean up accumulated state by timing it out (cf.\n   response\
    \ code 4.08), and clients SHOULD be prepared to run block-wise\n   transfers in\
    \ an expedient way to minimize the likelihood of running\n   into such a timeout.\n"
- title: 7.2.  Mitigating Amplification Attacks
  contents:
  - "7.2.  Mitigating Amplification Attacks\n   [RFC7252] discusses the susceptibility\
    \ of CoAP endpoints for use in\n   amplification attacks.\n   A CoAP server can\
    \ reduce the amount of amplification it provides to\n   an attacker by offering\
    \ large resource representations only in\n   relatively small blocks.  With this,\
    \ e.g., for a 1000-byte resource,\n   a 10-byte request might result in an 80-byte\
    \ response (with a 64-byte\n   block) instead of a 1016-byte response, considerably\
    \ reducing the\n   amplification provided.\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n  \
    \            DOI 10.17487/RFC2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC7252]  Shelby, Z., Hartke, K., and C. Bormann, \"The Constrained\n   \
    \           Application Protocol (CoAP)\", RFC 7252,\n              DOI 10.17487/RFC7252,\
    \ June 2014,\n              <http://www.rfc-editor.org/info/rfc7252>.\n   [RFC7641]\
    \  Hartke, K., \"Observing Resources in the Constrained\n              Application\
    \ Protocol (CoAP)\", RFC 7641,\n              DOI 10.17487/RFC7641, September\
    \ 2015,\n              <http://www.rfc-editor.org/info/rfc7641>.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [REST]     Fielding, R., \"Architectural Styles\
    \ and the Design of\n              Network-based Software Architectures\", Ph.D.\
    \ Dissertation,\n              University of California, Irvine, 2000,\n     \
    \         <http://www.ics.uci.edu/~fielding/pubs/dissertation/\n             \
    \ fielding_dissertation.pdf>.\n   [RFC4919]  Kushalnagar, N., Montenegro, G.,\
    \ and C. Schumacher, \"IPv6\n              over Low-Power Wireless Personal Area\
    \ Networks (6LoWPANs):\n              Overview, Assumptions, Problem Statement,\
    \ and Goals\",\n              RFC 4919, DOI 10.17487/RFC4919, August 2007,\n \
    \             <http://www.rfc-editor.org/info/rfc4919>.\n   [RFC4944]  Montenegro,\
    \ G., Kushalnagar, N., Hui, J., and D. Culler,\n              \"Transmission of\
    \ IPv6 Packets over IEEE 802.15.4\n              Networks\", RFC 4944, DOI 10.17487/RFC4944,\
    \ September 2007,\n              <http://www.rfc-editor.org/info/rfc4944>.\n \
    \  [RFC6690]  Shelby, Z., \"Constrained RESTful Environments (CoRE) Link\n   \
    \           Format\", RFC 6690, DOI 10.17487/RFC6690, August 2012,\n         \
    \     <http://www.rfc-editor.org/info/rfc6690>.\n   [RFC7228]  Bormann, C., Ersue,\
    \ M., and A. Keranen, \"Terminology for\n              Constrained-Node Networks\"\
    , RFC 7228,\n              DOI 10.17487/RFC7228, May 2014,\n              <http://www.rfc-editor.org/info/rfc7228>.\n\
    \   [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer\n \
    \             Protocol (HTTP/1.1): Message Syntax and Routing\",\n           \
    \   RFC 7230, DOI 10.17487/RFC7230, June 2014,\n              <http://www.rfc-editor.org/info/rfc7230>.\n\
    \   [RFC7233]  Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,\n     \
    \         \"Hypertext Transfer Protocol (HTTP/1.1): Range Requests\",\n      \
    \        RFC 7233, DOI 10.17487/RFC7233, June 2014,\n              <http://www.rfc-editor.org/info/rfc7233>.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   Much of the content of this document is the result of discussions\n\
    \   with the [RFC7252] authors, and via many CoRE WG discussions.\n   Charles\
    \ Palmer provided extensive editorial comments to a previous\n   draft version\
    \ of this document, some of which have been covered in\n   this document.  Esko\
    \ Dijk reviewed a more recent version, leading to\n   a number of further editorial\
    \ improvements, a solution to the 4.13\n   ambiguity problem, and the section\
    \ about combining Block and\n   multicast (Section 2.8).  Markus Becker proposed\
    \ getting rid of an\n   ill-conceived default value for the Block2 and Block1\
    \ Options.  Peter\n   Bigot insisted on a more systematic coverage of the options\
    \ and\n   response code.  Qin Wu provided a review for the IETF Operations\n \
    \  directorate, and Goeran Selander commented on the security\n   considerations.\n\
    \   Kepeng Li, Linyi Tian, and Barry Leiba wrote up an early version of\n   the\
    \ Size option, which is described in this document.  Klaus Hartke\n   wrote some\
    \ of the text describing the interaction of Block2 with\n   Observe.  Matthias\
    \ Kovatsch provided a number of significant\n   simplifications of the protocol.\n\
    \   The IESG reviewers provided very useful comments.  Spencer Dawkins\n   even\
    \ suggested new text.  He and Mirja Kuehlewind insisted on more\n   explicit information\
    \ about the layering of block-wise transfers on\n   top of the base protocol.\
    \  Ben Campbell helped untangle some MUST/\n   SHOULD soup.  Comments by Alexey\
    \ Melnikov, as well as the Gen-ART\n   review by Jouni Korhonen, resulted in further\
    \ improvements to the\n   text.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Carsten Bormann\n   Universitaet Bremen TZI\n   Postfach\
    \ 330440\n   Bremen  D-28359\n   Germany\n   Phone: +49-421-218-63921\n   Email:\
    \ cabo@tzi.org\n   Zach Shelby (editor)\n   ARM\n   150 Rose Orchard\n   San Jose,\
    \ CA  95134\n   United States of America\n   Phone: +1-408-203-9434\n   Email:\
    \ zach.shelby@arm.com\n"
