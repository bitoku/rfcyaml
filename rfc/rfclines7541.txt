Abstract This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.
In HTTP/1.1 (see [RFC7230]), header fields are not compressed.
As web pages have grown to require dozens to hundreds of requests, the redundant header fields in these requests unnecessarily consume bandwidth, measurably increasing latency.
SPDY [SPDY] initially addressed this redundancy by compressing header fields using the DEFLATE [DEFLATE] format, which proved very effective at efficiently representing the redundant header fields.
However, that approach exposed a security risk as demonstrated by the CRIME (Compression Ratio Info leak Made Easy) attack (see [CRIME]).
This specification defines HPACK, a new compressor that eliminates redundant header fields, limits vulnerability to known security attacks, and has a bounded memory requirement for use in constrained environments.
Potential security concerns for HPACK are described in Section 7.
The HPACK format is intentionally simple and inflexible.
Both characteristics reduce the risk of interoperability or security issues due to implementation error.
No extensibility mechanisms are defined; changes to the format are only possible by defining a complete replacement.
The format defined in this specification treats a list of header fields as an ordered collection of name value pairs that can include duplicate pairs.
Names and values are considered to be opaque sequences of octets, and the order of header fields is preserved after being compressed and decompressed.
Encoding is informed by header field tables that map header fields to indexed values.
These header field tables can be incrementally updated as new header fields are encoded or decoded.
In the encoded form, a header field is represented either literally or as a reference to a header field in one of the header field tables.
Therefore, a list of header fields can be encoded using a mixture of references and literal values.
Literal values are either encoded directly or use a static Huffman code.
The encoder is responsible for deciding which header fields to insert as new entries in the header field tables.
The decoder executes the modifications to the header field tables prescribed by the encoder, reconstructing the list of header fields in the process.
This enables decoders to remain simple and interoperate with a wide variety of encoders.
Examples illustrating the use of these different mechanisms to represent header fields are available in Appendix C. 1.2.
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119
All numeric values are in network byte order.
Values are unsigned unless otherwise indicated.
Literal values are provided in decimal or hexadecimal as appropriate.
This specification uses the following terms:
Header Field:  A name value pair.
Both the name and value are treated as opaque sequences of octets.
The dynamic table (see Section 2.3.2) is a table that associates stored header fields with index values.
This table is dynamic and specific to an encoding or decoding context.
The static table (see Section 2.3.1) is a table that statically associates header fields that occur frequently with index values.
This table is ordered, read only, always accessible, and it may be shared amongst all encoding or decoding contexts.
A header list is an ordered collection of header fields that are encoded jointly and can contain duplicate header fields.
A complete list of header fields contained in an HTTP/2 header block is a header list.
A header field can be represented in encoded form either as a literal or as an index (see Section 2.4).
Header Block:  An ordered list of header field representations, which, when decoded, yields a complete header list.
This specification does not describe a specific algorithm for an encoder.
Instead, it defines precisely how a decoder is expected to operate, allowing encoders to produce any encoding that this definition permits.
Header List Ordering HPACK preserves the ordering of header fields inside the header list.
An encoder MUST order header field representations in the header block according to their ordering in the original header list.
A decoder MUST order header fields in the decoded header list according to their ordering in the header block.
To decompress header blocks, a decoder only needs to maintain a dynamic table (see Section 2.3.2) as a decoding context.
No other dynamic state is needed.
When used for bidirectional communication, such as in HTTP, the encoding and decoding dynamic tables maintained by an endpoint are
completely independent, i.e., the request and response dynamic tables are separate.
Indexing Tables HPACK uses two tables for associating header fields to indexes.
The static table (see Section 2.3.1) is predefined and contains common header fields (most of them with an empty value).
The dynamic table (see Section 2.3.2) is dynamic and can be used by the encoder to index header fields repeated in the encoded header lists.
These two tables are combined into a single address space for defining index values (see Section 2.3.3).
The static table consists of a predefined static list of header fields.
Its entries are defined in Appendix A. 2.3.2.
The dynamic table consists of a list of header fields maintained in first in, first out order.
The first and newest entry in a dynamic table is at the lowest index, and the oldest entry of a dynamic table is at the highest index.
The dynamic table is initially empty.
Entries are added as each header block is decompressed.
The dynamic table can contain duplicate entries (i.e., entries with the same name and same value).
Therefore, duplicate entries MUST NOT be treated as an error by a decoder.
The encoder decides how to update the dynamic table and as such can control how much memory is used by the dynamic table.
To limit the memory requirements of the decoder, the dynamic table size is strictly bounded (see Section 4.2).
The decoder updates the dynamic table during the processing of a list of header field representations (see Section 3.2).
The static table and the dynamic table are combined into a single index address space.
Indices between 1 and the length of the static table (inclusive) refer to elements in the static table (see Section 2.3.1).
Indices strictly greater than the length of the static table refer to elements in the dynamic table (see Section 2.3.2).
The length of the static table is subtracted to find the index into the dynamic table.
Indices strictly greater than the sum of the lengths of both tables MUST be treated as a decoding error.
For a static table size of s and a dynamic table size of k, the following diagram shows the entire valid index address space.
An encoded header field can be represented either as an index or as a literal.
An indexed representation defines a header field as a reference to an entry in either the static table or the dynamic table (see Section 6.1).
A literal representation defines a header field by specifying its name and value.
The header field name can be represented literally or as a reference to an entry in either the static table or the dynamic table.
The header field value is represented literally.
Three different literal representations are defined:  A literal representation that adds the header field as a new entry at the beginning of the dynamic table (see Section 6.2.1).
A literal representation that does not add the header field to the dynamic table (see Section 6.2.2).
A literal representation that does not add the header field to the dynamic table, with the additional stipulation that this header field always use a literal representation, in particular when re  encoded by an intermediary (see Section 6.2.3).
This representation is intended for protecting header field values that are not to be put at risk by compressing them (see Section 7.1.3 for more details).
The selection of one of these literal representations can be guided by security considerations, in order to protect sensitive header field values (see Section 7.1).
The literal representation of a header field name or of a header field value can encode the sequence of octets either directly or using a static Huffman code (see Section 5.2).
Header Block Processing A decoder processes a header block sequentially to reconstruct the original header list.
A header block is the concatenation of header field representations.
The different possible header field representations are described in Section 6.
Once a header field is decoded and added to the reconstructed header list, the header field cannot be removed.
A header field added to the header list can be safely passed to the application.
By passing the resulting header fields to the application, a decoder can be implemented with minimal transitory memory commitment in addition to the memory required for the dynamic table.
Header Field Representation Processing The processing of a header block to obtain a header list is defined in this section.
To ensure that the decoding will successfully produce a header list, a decoder MUST obey the following rules.
All the header field representations contained in a header block are processed in the order in which they appear, as specified below.
Details on the formatting of the various header field representations and some additional processing instructions are found in Section 6.
An  indexed representation  entails the following actions:  The header field corresponding to the referenced entry in either the static table or dynamic table is appended to the decoded header list.
that is  not added  to the dynamic table
The header field is appended to the decoded header list.
that is  added  to the dynamic table
entails the following actions:  The header field is appended to the decoded header list.
The header field is inserted at the beginning of the dynamic table.
This insertion could result in the eviction of previous entries in the dynamic table (see Section 4.4).
To limit the memory requirements on the decoder side, the dynamic table is constrained in size.
The size of the dynamic table is the sum of the size of its entries.
The size of an entry is the sum of its name's length in octets (as defined in Section 5.2), its value's length in octets, and 32.
The size of an entry is calculated using the length of its name and value without any Huffman encoding applied.
Note: The additional 32 octets account for an estimated overhead associated with an entry.
For example, an entry structure using two 64 bit pointers to reference the name and the value of the entry and two 64 bit integers for counting the number of references to the name and value would have 32 octets of overhead.
Maximum Table Size Protocols that use HPACK determine the maximum size that the encoder is permitted to use for the dynamic table.
In HTTP/2, this value is determined by the SETTINGS HEADER TABLE SIZE setting (see Section 6.5.2 of [HTTP2]).
An encoder can choose to use less capacity than this maximum size (see Section 6.3), but the chosen size MUST stay lower than or equal to the maximum set by the protocol.
A change in the maximum size of the dynamic table is signaled via a dynamic table size update (see Section 6.3).
This dynamic table size update MUST occur at the beginning of the first header block following the change to the dynamic table size.
In HTTP/2, this follows a settings acknowledgment (see Section 6.5.3 of [HTTP2]).
Multiple updates to the maximum table size can occur between the transmission of two header blocks.
In the case that this size is changed more than once in this interval, the smallest maximum table size that occurs in that interval MUST be signaled in a dynamic table size update.
The final maximum size is always signaled, resulting in at most two dynamic table size updates.
This ensures that the decoder is able to perform eviction based on reductions in dynamic table size (see Section 4.3).
This mechanism can be used to completely clear entries from the dynamic table by setting a maximum size of 0, which can subsequently be restored.
When Dynamic Table Size Changes
Whenever the maximum size for the dynamic table is reduced, entries are evicted from the end of the dynamic table until the size of the dynamic table is less than or equal to the maximum size.
When Adding New Entries Before a new entry is added to the dynamic table, entries are evicted from the end of the dynamic table until the size of the dynamic table is less than or equal to (maximum size new entry size) or until the table is empty.
If the size of the new entry is less than or equal to the maximum size, that entry is added to the table.
It is not an error to attempt to add an entry that is larger than the maximum size; an attempt to add an entry larger than the maximum size causes the table to be emptied of all existing entries and results in an empty table.
A new entry can reference the name of an entry in the dynamic table that will be evicted when adding this new entry into the dynamic table.
Implementations are cautioned to avoid deleting the referenced name if the referenced entry is evicted from the dynamic table prior to inserting the new entry.
Primitive Type Representations HPACK encoding uses two primitive types: unsigned variable length integers and strings of octets.
Integer Representation Integers are used to represent name indexes, header field indexes, or string lengths.
An integer representation can start anywhere within an octet.
To allow for optimized processing, an integer representation always finishes at the end of an octet.
An integer is represented in two parts: a prefix that fills the current octet and an optional list of octets that are used if the integer value does not fit within the prefix.
The number of bits of the prefix (called N) is a parameter of the integer representation.
If the integer value is small enough, i.e., strictly less than 2^N 1, it is encoded within the N bit prefix. 0
Integer Value Encoded within the Prefix (Shown for N   5)
Otherwise, all the bits of the prefix are set to 1, and the value, decreased by 2^N 1, is encoded using a list of one or more octets.
The most significant bit of each octet is used as a continuation flag: its value is set to 1 except for the last octet in the list.
The remaining bits of the octets are used to encode the decreased value. 0
Integer Value Encoded after the Prefix (Shown for N   5)
Decoding the integer value from the list of octets starts by reversing the order of the octets in the list.
Then, for each octet, its most significant bit is removed.
The remaining bits of the octets are concatenated, and the resulting value is increased by 2^N 1 to obtain the integer value.
The prefix size, N, is always between 1 and 8 bits.
An integer starting at an octet boundary will have an 8 bit prefix.
Pseudocode to represent an integer I is as follows: if I < 2^N 1, encode I on N bits else
encode (2^N 1) on N bits
I (2^N 1) while I >  128 encode (I % 128   128) on 8 bits
128 encode I on 8 bits Pseudocode to decode an integer I is as follows
: decode I from the next N bits if I < 2^N 1, return I else
I Examples illustrating the encoding of integers are available in Appendix C.1.
This integer representation allows for values of indefinite size.
It is also possible for an encoder to send a large number of zero values, which can waste octets and could be used to overflow integer values.
Integer encodings that exceed implementation limits   in value or octet length   MUST be treated as decoding errors.
Different limits can be set for each of the different uses of integers, based on implementation constraints.
String Literal Representation Header field names and header field values can be represented as string literals.
A string literal is encoded as a sequence of octets, either by directly encoding the string literal's octets or by using a Huffman code (see [HUFFMAN]). 0
String Literal Representation A string literal representation contains the following fields:
A one bit flag, H, indicating whether or not the octets of the string are Huffman encoded.
The number of octets used to encode the string literal, encoded as an integer with a 7 bit prefix (see Section 5.1).
String Data:  The encoded data of the string literal.
If H is '0', then the encoded data is the raw octets of the string literal.
If H is '1', then the encoded data is the Huffman encoding of the string literal.
String literals that use Huffman encoding are encoded with the Huffman code defined in Appendix B (see examples for requests in Appendix C.4 and for responses in Appendix C.6).
The encoded data is the bitwise concatenation of the codes corresponding to each octet of the string literal.
As the Huffman encoded data doesn't always end at an octet boundary, some padding is inserted after it, up to the next octet boundary.
To prevent this padding from being misinterpreted as part of the string literal, the most significant bits of the code corresponding to the EOS (end of string)
Upon decoding, an incomplete code at the end of the encoded data is to be considered as padding and discarded.
A padding strictly longer than 7 bits MUST be treated as a decoding error.
A padding not corresponding to the most significant bits of the code for the EOS symbol MUST be treated as a decoding error.
A Huffman encoded string literal containing the EOS symbol MUST be treated as a decoding error.
This section describes the detailed format of each of the different header field representations and the dynamic table size update instruction.
An indexed header field representation identifies an entry in either the static table or the dynamic table (see Section 2.3).
An indexed header field representation causes a header field to be added to the decoded header list, as described in Section 3.2. 0
An indexed header field starts with the '1' 1 bit pattern, followed by the index of the matching header field, represented as an integer with a 7 bit prefix (see Section 5.1).
The index value of 0 is not used.
It MUST be treated as a decoding error if found in an indexed header field representation.
A literal header field representation contains a literal header field value.
Header field names are provided either as a literal or by reference to an existing table entry, either from the static table or the dynamic table (see Section 2.3).
This specification defines three forms of literal header field representations: with indexing, without indexing, and never indexed.
Literal Header Field with Incremental Indexing
A literal header field with incremental indexing representation results in appending a header field to the decoded header list and inserting it as a new entry into the dynamic table. 0
Figure 6: Literal Header Field with Incremental Indexing
Figure 7: Literal Header Field with Incremental Indexing
A literal header field with incremental indexing representation starts with the '01' 2 bit pattern.
If the header field name matches the header field name of an entry stored in the static table or the dynamic table, the header field name can be represented using the index of that entry.
In this case, the index of the entry is represented as an integer with a 6 bit prefix (see Section 5.1).
This value is always non zero.
Otherwise, the header field name is represented as a string literal (see Section 5.2).
A value 0 is used in place of the 6 bit index, followed by the header field name.
Either form of header field name representation is followed by the header field value represented as a string literal (see Section 5.2).
Literal Header Field without Indexing
A literal header field without indexing representation results in appending a header field to the decoded header list without altering the dynamic table.
Figure 8: Literal Header Field without Indexing
Figure 9: Literal Header Field without Indexing   New Name
A literal header field without indexing representation starts with the '0000' 4 bit pattern.
If the header field name matches the header field name of an entry stored in the static table or the dynamic table, the header field name can be represented using the index of that entry.
In this case, the index of the entry is represented as an integer with a 4 bit prefix (see Section 5.1).
This value is always non zero.
Otherwise, the header field name is represented as a string literal (see Section 5.2).
A value 0 is used in place of the 4 bit index, followed by the header field name.
Either form of header field name representation is followed by the header field value represented as a string literal (see Section 5.2).
A literal header field never indexed representation results in appending a header field to the decoded header list without altering the dynamic table.
Intermediaries MUST use the same representation for encoding this header field. 0
Figure 11: Literal Header Field
A literal header field never indexed representation starts with the '0001' 4 bit pattern.
When a header field is represented as a literal header field never indexed, it MUST always be encoded with this specific literal representation.
In particular, when a peer sends a header field that it received represented as a literal header field never indexed, it MUST use the same representation to forward this header field.
This representation is intended for protecting header field values that are not to be put at risk by compressing them (see Section 7.1 for more details).
The encoding of the representation is identical to the literal header field without indexing (see Section 6.2.2).
Dynamic Table Size Update A dynamic table size update signals a change to the size of the dynamic table.
Maximum Dynamic Table Size Change
A dynamic table size update starts with the '001' 3 bit pattern, followed by the new maximum size, represented as an integer with a 5 bit prefix (see Section 5.1).
The new maximum size MUST be lower than or equal to the limit determined by the protocol using HPACK.
A value that exceeds this limit MUST be treated as a decoding error.
In HTTP/2, this limit is the last value of the SETTINGS HEADER TABLE SIZE parameter (see Section 6.5.2 of [HTTP2]) received from the decoder and acknowledged by the encoder (see Section 6.5.3 of [HTTP2]).
Reducing the maximum size of the dynamic table can cause entries to be evicted (see Section 4.3).
This section describes potential areas of security concern with HPACK:
Use of compression as a length based oracle for verifying guesses about secrets that are compressed into a shared compression context.
Denial of service resulting from exhausting processing or memory capacity at a decoder.
Probing Dynamic Table State HPACK reduces the length of header field encodings by exploiting the redundancy inherent in protocols like HTTP.
The ultimate goal of this is to reduce the amount of data that is required to send HTTP requests or responses.
The compression context used to encode header fields can be probed by an attacker who can both define header fields to be encoded and transmitted and observe the length of those fields once they are encoded.
When an attacker can do both, they can adaptively modify requests in order to confirm guesses about the dynamic table state.
If a guess is compressed into a shorter length, the attacker can observe the encoded length and infer that the guess was correct.
This is possible even over the Transport Layer Security (TLS) protocol (see [TLS12]), because while TLS provides confidentiality protection for content, it only provides a limited amount of protection for the length of that content.
Note: Padding schemes only provide limited protection against an attacker with these capabilities, potentially only forcing an increased number of guesses to learn the length associated with a given guess.
Padding schemes also work directly against compression by increasing the number of bits that are transmitted.
Attacks like CRIME [CRIME] demonstrated the existence of these general attacker capabilities.
The specific attack exploited the fact that DEFLATE [DEFLATE] removes redundancy based on prefix matching.
This permitted the attacker to confirm guesses a character at a time, reducing an exponential time attack into a linear time attack.
Applicability to HPACK and HTTP HPACK mitigates but does not completely prevent attacks modeled on CRIME [CRIME] by forcing a guess to match an entire header field value rather than individual characters.
Attackers can only learn whether a guess is correct or not, so they are reduced to brute force guesses for the header field values.
The viability of recovering specific header field values therefore depends on the entropy of values.
As a result, values with high entropy are unlikely to be recovered successfully.
However, values with low entropy remain vulnerable.
Attacks of this nature are possible any time that two mutually distrustful entities control requests or responses that are placed onto a single HTTP/2 connection.
If the shared HPACK compressor permits one entity to add entries to the dynamic table and the other to access those entries, then the state of the table can be learned.
Having requests or responses from mutually distrustful entities occurs when an intermediary either:  sends requests from multiple clients on a single connection toward an origin server, or  takes responses from multiple origin servers and places them on a shared connection toward a client.
Web browsers also need to assume that requests made on the same connection by different web origins [ORIGIN] are made by mutually distrustful entities.
Mitigation Users of HTTP that require confidentiality for header fields can use values with entropy sufficient to make guessing infeasible.
However, this is impractical as a general solution because it forces all users of HTTP to take steps to mitigate attacks.
It would impose new constraints on how HTTP is used.
Rather than impose constraints on users of HTTP, an implementation of HPACK can instead constrain how compression is applied in order to limit the potential for dynamic table probing.
An ideal solution segregates access to the dynamic table based on the entity that is constructing header fields.
Header field values that are added to the table are attributed to an entity, and only the entity that created a particular value can extract that value.
To improve compression performance of this option, certain entries might be tagged as being public.
For example, a web browser might make the values of the Accept Encoding header field available in all requests.
An encoder without good knowledge of the provenance of header fields might instead introduce a penalty for a header field with many different values, such that a large number of attempts to guess a header field value results in the header field no longer being compared to the dynamic table entries in future messages, effectively preventing further guesses.
Note: Simply removing entries corresponding to the header field from the dynamic table can be ineffectual if the attacker has a reliable way of causing values to be reinstalled.
For example, a request to load an image in a web browser typically includes the Cookie header field (a potentially highly valued target for this sort of attack), and web sites can easily force an image to be loaded, thereby refreshing the entry in the dynamic table.
This response might be made inversely proportional to the length of the header field value.
Marking a header field as not using the dynamic table anymore might occur for shorter values more quickly or with higher probability than for longer values.
Never Indexed Literals Implementations can also choose to protect sensitive header fields by not compressing them and instead encoding their value as literals.
Refusing to generate an indexed representation for a header field is only effective if compression is avoided on all hops.
The never  indexed literal (see Section 6.2.3) can be used to signal to intermediaries that a particular value was intentionally sent as a literal.
An intermediary MUST NOT re encode a value that uses the never  indexed literal representation with another representation that would index it.
If HPACK is used for re encoding, the never indexed literal representation MUST be used.
The choice to use a never indexed literal representation for a header field depends on several factors.
Since HPACK doesn't protect against guessing an entire header field value, short or low entropy values are more readily recovered by an adversary.
Therefore, an encoder might choose not to index values with low entropy.
An encoder might also choose not to index values for header fields that are considered to be highly valuable or sensitive to recovery, such as the Cookie or Authorization header fields.
On the contrary, an encoder might prefer indexing values for header fields that have little or no value if they were exposed.
For instance, a User Agent header field does not commonly vary between requests and is sent to any server.
In that case, confirmation that a particular User Agent value has been used provides little value.
Note that these criteria for deciding to use a never indexed literal representation will evolve over time as new attacks are discovered.
There is no currently known attack against a static Huffman encoding.
A study has shown that using a static Huffman encoding table created an information leakage; however, this same study concluded that an attacker could not take advantage of this information leakage to recover any meaningful amount of information (see [PETAL]).
An attacker can try to cause an endpoint to exhaust its memory.
HPACK is designed to limit both the peak and state amounts of memory allocated by an endpoint.
The amount of memory used by the compressor is limited by the protocol using HPACK through the definition of the maximum size of the dynamic table.
In HTTP/2, this value is controlled by the decoder through the setting parameter SETTINGS HEADER TABLE SIZE (see Section 6.5.2 of [HTTP2]).
This limit takes into account both the size of the data stored in the dynamic table, plus a small allowance for overhead.
A decoder can limit the amount of state memory used by setting an appropriate value for the maximum size of the dynamic table.
In HTTP/2, this is realized by setting an appropriate value for the SETTINGS HEADER TABLE SIZE parameter.
An encoder can limit the amount of state memory it uses by signaling a lower dynamic table size than the decoder allows (see Section 6.3).
The amount of temporary memory consumed by an encoder or decoder can be limited by processing header fields sequentially.
An implementation does not need to retain a complete list of header fields.
Note, however, that it might be necessary for an application to retain a complete header list for other reasons; even though HPACK does not force this to occur, application constraints might make this necessary.
An implementation of HPACK needs to ensure that large values for integers, long encoding for integers, or long string literals do not create security weaknesses.
An implementation has to set a limit for the values it accepts for integers, as well as for the encoded length (see Section 5.1).
In the same way, it has to set a limit to the length it accepts for string literals (see Section 5.2).
Appendix A.  Static Table Definition
The static table (see Section 2.3.1) consists in a predefined and unchangeable list of header fields.
The static table was created from the most frequent header fields used by popular web sites, with the addition of HTTP/2 specific pseudo header fields (see Section 8.1.2.1 of [HTTP2]).
For header fields with a few frequent values, an entry was added for each of these frequent values.
For other header fields, an entry was added with an empty value.
Table 1 lists the predefined header fields that make up the static table and gives the index of each entry.
Static Table Entries Appendix B.
The following Huffman code is used when encoding string literals with a Huffman coding (see Section 5.2).
This Huffman code was generated from statistics obtained on a large sample of HTTP headers.
It is a canonical Huffman code (see [CANONICAL]) with some tweaking to ensure that no symbol has a unique code length.
Each row in the table defines the code used to represent a symbol:
sym:  The symbol to be represented.
It is the decimal value of an octet, possibly prepended with its ASCII representation.
A specific symbol, "EOS", is used to indicate the end of a string literal.
The Huffman code for the symbol represented as a base 2 integer, aligned on the most significant bit (MSB).
The Huffman code for the symbol, represented as a hexadecimal integer, aligned on the least significant bit (LSB).
The number of bits for the code representing the symbol.
This corresponds to the value 0x18 (in hexadecimal) encoded in 6 bits.
ffffea  [24] ( 10)   11111111
( 13)   11111111 11111111 11111111 111101
fffffeb  [28] ( 15)   11111111
ffffff4  [28] ( 25)   11111111
[ 6] '0' ( 48)   00000
[ 5] '1' ( 49)   00001
[ 5] '2' ( 50)   00010
[ 5] '3' ( 51)   011001
[ 6] '4' ( 52)   011010
[ 6] '5' ( 53)   011011
[ 6] '6' ( 54)   011100
[ 6] '7' ( 55)   011101
[ 6] '8' ( 56)   011110
[ 6] '9' ( 57)   011111
[13] 'A' ( 65)   100001
[ 6] 'B' ( 66)   1011101
[ 7] 'E' ( 69)   1100000
[ 7] 'F' ( 70)   1100001
[ 7] 'G' ( 71)   1100010
[ 7] 'H' ( 72)   1100011
[ 7] 'J' ( 74)   1100101
[ 7] 'K' ( 75)   1100110
[ 7] 'L' ( 76)   1100111
[ 7] 'M' ( 77)   1101000
[ 7] 'N' ( 78)   1101001
[ 7] 'O' ( 79)   1101010
[ 7] 'S' ( 83)   1101110
[ 7] 'T' ( 84)   1101111
[ 7] 'U' ( 85)   1110000
[ 7] 'W' ( 87)   1110010
[ 7] 'Z' ( 90)   11111101
[15] 'a' ( 97)   00011
[ 5] 'b' ( 98)   100011
[ 6] 'c' ( 99)   00100
[ 6] 'g' (103)   100110
[ 6] 'h' (104)   100111
[ 5] 'j' (106)   1110100
[ 7] 'k' (107)   1110101
[ 6] 'm' (109)   101001
[ 6] 'n' (110)   101010
[ 6] 'o' (111)   00111
[ 5] 'p' (112)   101011
[ 6] 'q' (113)   1110110
[ 7] 'r' (114)   101100
[ 6] 's' (115)   01000
[ 5] 't' (116)   01001
[ 5] 'u' (117)   101101
[ 6] 'v' (118)   1110111
[22] (137)   11111111 11111111 1011010
[20] (163)   11111111 11111111 011011
[22] (170)   11111111 11111111 011110
[23] (176)   11111111 11111111 00000
fffea  [20] (185)   11111111 11111111 100010
[26] (211)   11111111 11111111 11111100 000
[27] (245)   11111111 11111111 11111101 000
(251)   11111111 11111111 11111101 101
[26] EOS (256)   11111111 11111111 11111111 111111
3fffffff  [30] Appendix C.  Examples
This appendix contains examples covering integer encoding, header field representation, and the encoding of whole lists of header fields for both requests and responses, with and without Huffman coding.
This section shows the representation of integer values in detail (see Section 5.1).
Using a 5 Bit Prefix
The value 10 is to be encoded with a 5 bit prefix.
10 is less than 31 (2^5 1) and is represented using the 5 bit prefix. 0
10 stored on 5 bits   C.1.2.
Using a 5 Bit Prefix
I 1337 is to be encoded with a 5 bit prefix.
1337 is greater than 31 (2^5 1).
The 5 bit prefix is filled with its max value (31).
I   1337 (2^5 1)   1306.
I (1306) is greater than or equal to 128, so the while loop body executes:
154 154 is encoded in 8 bits as: 10011010 I is set to 10
I is no longer greater than or equal to 128, so the while loop terminates.
I, now 10, is encoded in 8 bits as: 00001010.
Prefix   31, I   1306   1   0   0   1   1   0
Starting at an Octet Boundary
The value 42 is to be encoded starting at an octet boundary.
This implies that a 8 bit prefix is used.
42 is less than 255 (2^8 1) and is represented using the 8 bit prefix. 0
42 stored on 8 bits   C.2.
This section shows several independent representation examples.
Literal Header Field with Indexing
The header field representation uses a literal name and a literal value.
The header field is added to the dynamic table.
custom header Hex dump of encoded data: 400a 6375 7374
Literal name (len   10) 6375
custom key: custom header Table size:  55 Decoded header list:
custom key: custom header C.2.2.
Literal Header Field without Indexing
The header field representation uses an indexed name and a literal value.
The header field is not added to the dynamic table.
Header list to encode: :
path: /sample/path Hex dump of encoded data: 040c 2f73 616d
/sample/path Dynamic table (after decoding)
Decoded header list: :path: /sample/path C.2.3.
The header field representation uses a literal name and a literal value.
The header field is not added to the dynamic table and must use the same representation if re encoded by an intermediary.
password: secret Hex dump of encoded data: 1008 7061 7373 776f
Decoded header list: password: secret C.2.4.
The header field representation uses an indexed header field from the static table.
Header list to encode: :
Request Examples without Huffman Coding
This section shows several consecutive header lists, corresponding to HTTP requests, on the same connection.
First Request Header list to encode: :
www.example.com Hex dump of encoded data: 8286 8441 0f77 7777 2e65
(s    57) :authority: www.example.com Table size:  57 Decoded header list:
Second Request Header list to encode: :
www.example.com cache control: no cache Hex dump of encoded data: 8286 84be 5808
X.no cache Decoding process: 82
no cache [  2] (s    57) :authority: www.example.com Table size: 110 Decoded header list:
www.example.com cache control: no cache C.3.3.
Third Request Header list to encode: :
www.example.com custom key: custom value Hex dump of encoded data: 8287 85bf 400a 6375 7374
Literal name (len   10) 6375
custom key: custom value [  2]
) cache control: no cache [  3]
(s    57) :authority: www.example.com Table size: 164 Decoded header list: :method: GET :scheme: https :path:
www.example.com custom key: custom value C.4.
Request Examples with Huffman Coding
This section shows the same examples as the previous section but uses Huffman encoding for the literal values.
First Request Header list to encode: :
www.example.com Hex dump of encoded data: 8286 8441
(s    57) :authority: www.example.com Table size:  57 Decoded header list:
Second Request Header list to encode: :
www.example.com cache control: no cache Hex dump of encoded data: 8286 84be 5886 a8eb 1064
no cache [  2] (s    57) :authority: www.example.com Table size: 110 Decoded header list:
www.example.com cache control: no cache C.4.3.
Third Request Header list to encode: :
www.example.com custom key: custom value Hex dump of encoded data: 8287 85bf 4088 25a8
custom key: custom value [  2]
) cache control: no cache [  3]
(s    57) :authority: www.example.com Table size: 164 Decoded header list: :method: GET :scheme: https :path:
www.example.com custom key: custom value C.5.
Response Examples without Huffman Coding
This section shows several consecutive header lists, corresponding to HTTP responses, on the same connection.
parameter SETTINGS HEADER TABLE SIZE is set to the value of 256 octets, causing some evictions to occur.
First Response Header list to encode: :status: 302 cache control:
Mon, 21 Oct 2013 20:13:21 GMT location:
Hex dump of encoded data: 4803 3330 3258 0770 7269 7661
4d6f 6e2c 2032 3120 4f63 7420 3230 3133
Mon, 21 Oct 2013 2032
3a32 3120 474d 546e 1768    20:13:21
3133   Mon, 21 Oct 2013 2032
Mon, 21 Oct 2013 20:13:21 GMT [  3]
status: 302 Table size: 222 Decoded header list: :status: 302 cache control:
Mon, 21 Oct 2013 20:13:21 GMT location: https://www.example.com C.5.2.
The (":status", "302") header field is evicted from the dynamic table to free space to allow adding the (":status", "307") header field.
Header list to encode: :
Mon, 21 Oct 2013 20:13:21 GMT location:
Hex dump of encoded data: 4803 3330
Mon, 21 Oct 2013 20:13:21 GMT [  4]
private Table size: 222 Decoded header list: :status: 307 cache control:
Mon, 21 Oct 2013 20:13:21 GMT location: https://www.example.com C.5.3.
Several header fields are evicted from the dynamic table during the processing of this header list.
Header list to encode: :
Mon, 21 Oct 2013 20:13:22 GMT location: https://www.example.com content encoding: gzip set cookie: foo ASDJKHQKBZXOQWEOPIUAXQWEOIU; max age 3600; version 1 Hex dump of encoded data: 88c1 611d
Oct 3230 3133 2032 303a 3133 3a32
AS 444a 4b48 514b 425a 584f 5157 454f 5049
UAXQWEOIU; max a 6765 3d33 3630 303b 2076 6572
3133   Mon, 21 Oct 2013 2032
foo ASDJKHQKBZXO 5157 454f 5049 5541 5851 5745 4f49 553b
foo ASDJKHQKBZXOQWEOPIUAXQWEOIU; max age 3600; version 1 [  2]
content encoding: gzip [  3]
Mon, 21 Oct 2013 20:13:22 GMT Table size: 215 Decoded header list: :status: 200 cache control:
Mon, 21 Oct 2013 20:13:22 GMT location: https://www.example.com content encoding: gzip set cookie: foo ASDJKHQKBZXOQWEOPIUAXQWEOIU; max age 3600;
Response Examples with Huffman Coding
This section shows the same examples as the previous section but uses Huffman encoding for the literal values.
parameter SETTINGS HEADER TABLE SIZE is set to the value of 256 octets, causing some evictions to occur.
The eviction mechanism uses the length of the decoded literal values, so the same evictions occur as in the previous section.
First Response Header list to encode: :status: 302 cache control:
Mon, 21 Oct 2013 20:13:21 GMT location:
Hex dump of encoded data: 4882 6402 5885 aec3 771a 4b61
Mon, 21 Oct 2013 20:13:21
9d29 ad17 1863 c78f 0b97
Mon, 21 Oct 2013 20:13:21 GMT [  3]
status: 302 Table size: 222 Decoded header list: :status: 302 cache control:
Mon, 21 Oct 2013 20:13:21 GMT location: https://www.example.com C.6.2.
The (":status", "302") header field is evicted from the dynamic table to free space to allow adding the (":status", "307") header field.
Header list to encode: :
Mon, 21 Oct 2013 20:13:21 GMT location:
Mon, 21 Oct 2013 20:13:21 GMT [  4]
private Table size: 222 Decoded header list: :status: 307 cache control:
Mon, 21 Oct 2013 20:13:21 GMT location: https://www.example.com C.6.3.
Several header fields are evicted from the dynamic table during the processing of this header list.
Header list to encode: :
Mon, 21 Oct 2013 20:13:22 GMT location: https://www.example.com content encoding: gzip set cookie: foo ASDJKHQKBZXOQWEOPIUAXQWEOIU; max age 3600; version 1 Hex dump of encoded data: 88c1 6196 d07a
[ 3960 d5af 2708 7f36
Mon, 21 Oct 2013 20:13:22
` d5af 2708 7f36 72c1 ab27
foo ASDJKHQKBZXOQWEOPIUAXQWEOIU; max age 3600; version 1 [  2]
content encoding: gzip [  3]
Mon, 21 Oct 2013 20:13:22 GMT Table size: 215 Decoded header list: :status: 200 cache control:
Mon, 21 Oct 2013 20:13:22 GMT location: https://www.example.com content encoding: gzip set cookie: foo ASDJKHQKBZXOQWEOPIUAXQWEOIU; max age 3600; version 1
