- contents:
  - '                  Service Location Protocol, Version 2

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   The Service Location Protocol provides a scalable framework for
    the\n   discovery and selection of network services.  Using this protocol,\n   computers
    using the Internet need little or no static configuration\n   of network services
    for network based applications.  This is\n   especially important as computers
    become more portable, and users\n   less tolerant or able to fulfill the demands
    of network system\n   administration.\n"
  title: Abstract
- contents:
  - "Table of Contents\n    1. Introduction                                                    3\n
    \       1.1. Applicability Statement  . . . . . . . . . . . . . . .    3\n    2.
    Terminology                                                     4\n        2.1.
    Notation Conventions . . . . . . . . . . . . . . . . .    4\n    3. Protocol Overview
    \                                              5\n    4. URLs used with Service
    Location                                 8\n        4.1. Service: URLs  . . .
    . . . . . . . . . . . . . . . . .    9\n        4.2. Naming Authorities   . .
    . . . . . . . . . . . . . . .   10\n        4.3. URL Entries  . . . . . . . .
    . . . . . . . . . . . . .   10\n    5. Service Attributes                                             10\n
    \   6. Required Features                                              12\n        6.1.
    Use of Ports, UDP, and Multicast   . . . . . . . . . .   13\n        6.2. Use
    of TCP   . . . . . . . . . . . . . . . . . . . . .   14\n        6.3. Retransmission
    of SLP messages   . . . . . . . . . . .   15\n        6.4. Strings in SLP messages
    \ . . . . . . . . . . . . . . .   16\n              6.4.1. Scope Lists in SLP
    . . . . . . . . . . . . . .   16\n    7. Errors                                                         17\n
    \   8. Required SLP Messages                                          17\n        8.1.
    Service Request  . . . . . . . . . . . . . . . . . . .   19\n        8.2. Service
    Reply  . . . . . . . . . . . . . . . . . . . .   21\n        8.3. Service Registration
    . . . . . . . . . . . . . . . . .   22\n        8.4. Service Acknowledgment .
    . . . . . . . . . . . . . . .   23\n        8.5. Directory Agent Advertisement.
    . . . . . . . . . . . .   24\n        8.6. Service Agent Advertisement. . . .
    . . . . . . . . . .   25\n    9. Optional Features                                              26\n
    \       9.1. Service Location Protocol Extensions . . . . . . . . .   27\n        9.2.
    Authentication Blocks  . . . . . . . . . . . . . . . .   28\n              9.2.1.
    SLP Message Authentication Rules . . . . . . .   29\n              9.2.2. DSA
    with SHA-1 in Authentication Blocks  . . .   30\n        9.3. Incremental Service
    Registration   . . . . . . . . . .   30\n        9.4. Tag Lists  . . . . . . .
    . . . . . . . . . . . . . . .   31\n   10. Optional SLP Messages                                          32\n
    \      10.1. Service Type Request   . . . . . . . . . . . . . . . .   32\n       10.2.
    Service Type Reply   . . . . . . . . . . . . . . . . .   32\n       10.3. Attribute
    Request  . . . . . . . . . . . . . . . . . .   33\n       10.4. Attribute Reply
    \ . . . . . . . . . . . . . . . . . . .   34\n       10.5. Attribute Request/Reply
    Examples . . . . . . . . . . .   34\n       10.6. Service Deregistration   . .
    . . . . . . . . . . . . .   36\n   11. Scopes                                                         37\n
    \      11.1. Scope Rules  . . . . . . . . . . . . . . . . . . . . .   37\n       11.2.
    Administrative and User Selectable Scopes. . . . . . .   38\n   12. Directory
    Agents                                               38\n       12.1. Directory
    Agent Rules  . . . . . . . . . . . . . . . .   39\n       12.2. Directory Agent
    Discovery  . . . . . . . . . . . . . .   39\n             12.2.1. Active DA Discovery
    \ . . . . . . . . . . . . .   40\n             12.2.2. Passive DA Advertising
    . . . . . . . . . . . .   40\n       12.3. Reliable Unicast to DAs and SAs. .
    . . . . . . . . . .   41\n       12.4. DA Scope Configuration   . . . . . . .
    . . . . . . . .   41\n       12.5. DAs and Authentication Blocks. . . . . . .
    . . . . . .   41\n   13. Protocol Timing Defaults                                       42\n
    \  14. Optional Configuration                                         43\n   15.
    IANA Considerations                                            44\n   16. Internationalization
    Considerations                            45\n   17. Security Considerations                                        46\n
    \   A. Appendix:  Changes to the Service Location Protocol from\n                  v1
    to v2                                            48\n    B. Appendix:  Service
    Discovery by Type:  Minimal SLPv2 Features  48\n    C. Appendix:  DAAdverts with
    arbitrary URLs                       49\n    D. Appendix:  SLP Protocol Extensions
    \                            50\n        D.1. Required Attribute Missing Option
    \ . . . . . . . . . .   50\n    E. Acknowledgments                                                50\n
    \   F. References                                                     51\n    G.
    Authors' Addresses                                             53\n    H. Full
    Copyright Statement                                       54\n"
  title: Table of Contents
- contents:
  - "1. Introduction\n   The Service Location Protocol (SLP) provides a flexible and
    scalable\n   framework for providing hosts with access to information about the\n
    \  existence, location, and configuration of networked services.\n   Traditionally,
    users have had to find services by knowing the name of\n   a network host (a human
    readable text string) which is an alias for a\n   network address.  SLP eliminates
    the need for a user to know the name\n   of a network host supporting a service.
    \ Rather, the user supplies\n   the desired type of service and a set of attributes
    which describe\n   the service.  Based on that description, the Service Location\n
    \  Protocol resolves the network address of the service for the user.\n   SLP
    provides a dynamic configuration mechanism for applications in\n   local area
    networks.  Applications are modeled as clients that need\n   to find servers attached
    to any of the available networks within an\n   enterprise.  For cases where there
    are many different clients and/or\n   services available, the protocol is adapted
    to make use of nearby\n   Directory Agents that offer a centralized repository
    for advertised\n   services.\n   This document updates SLPv1 [RFC 2165], correcting
    protocol errors,\n   adding some enhancements and removing some requirements.
    \ This\n   specification has two parts.  The first describes the required\n   features
    of the protocol.  The second describes the extended features\n   of the protocol
    which are optional, and allow greater scalability.\n"
  - contents:
    - "1.1. Applicability Statement\n   SLP is intended to function within networks
      under cooperative\n   administrative control.  Such networks permit a policy
      to be\n   implemented regarding security, multicast routing and organization
      of\n   services and clients into groups which are not be feasible on the\n   scale
      of the Internet as a whole.\n   SLP has been designed to serve enterprise networks
      with shared\n   services, and it may not necessarily scale for wide-area service\n
      \  discovery throughout the global Internet, or in networks where there\n   are
      hundreds of thousands of clients or tens of thousands of\n   services.\n"
    title: 1.1. Applicability Statement
  title: 1. Introduction
- contents:
  - "2. Terminology\n      User Agent (UA)\n                A process working on the
    user's behalf to establish\n                contact with some service.  The UA
    retrieves service\n                information from the Service Agents or Directory
    Agents.\n      Service Agent (SA) A process working on the behalf of one or more\n
    \               services to advertise the services.\n      Directory Agent (DA)
    A process which collects service\n                advertisements.  There can only
    be one DA present per\n                given host.\n      Service Type Each type
    of service has a unique Service Type\n                string.\n      Naming Authority
    The agency or group which catalogues given\n                Service Types and
    Attributes.  The default Naming\n                Authority is IANA.\n      Scope
    A set of services, typically making up a logical\n                administrative
    group.\n      URL A Universal Resource Locator [8].\n"
  - contents:
    - "2.1. Notation Conventions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
      and \"OPTIONAL\" in this\n   document are to be interpreted as described in
      RFC 2119  [9].\n      Syntax        Syntax for string based protocols follow
      the\n                    conventions defined for ABNF [11].\n      Strings       All
      strings are encoded using the UTF-8 [23]\n                    transformation
      of the Unicode [6] character set and\n                    are NOT null terminated
      when transmitted.  Strings\n                    are preceded by a two byte length
      field.\n      <string-list> A comma delimited list of strings with the\n                    following
      syntax:\n                       string-list = string / string `,' string-list\n
      \  In format diagrams, any field ending with a \\ indicates a variable\n   length
      field, given by a prior length field in the protocol.\n"
    title: 2.1. Notation Conventions
  title: 2. Terminology
- contents:
  - "3. Protocol Overview\n   The Service Location Protocol supports a framework by
    which client\n   applications are modeled as 'User Agents' and services are advertised\n
    \  by 'Service Agents.'  A third entity, called a 'Directory Agent'\n   provides
    scalability to the protocol.\n   The User Agent issues a 'Service Request' (SrvRqst)
    on behalf of the\n   client application, specifying the characteristics of the
    service\n   which the client requires.  The User Agent will receive a Service\n
    \  Reply (SrvRply) specifying the location of all services in the\n   network
    which satisfy the request.\n   The Service Location Protocol framework allows
    the User Agent to\n   directly issue requests to Service Agents.  In this case
    the request\n   is multicast.  Service Agents receiving a request for a service
    which\n   they advertise unicast a reply containing the service's location.\n
    \     +------------+ ----Multicast SrvRqst----> +---------------+\n      | User
    Agent |                            | Service Agent |\n      +------------+ <----Unicast
    SrvRply------ +---------------+\n   In larger networks, one or more Directory
    Agents are used.  The\n   Directory Agent functions as a cache.  Service Agents
    send register\n   messages (SrvReg) containing all the services they advertise
    to\n   Directory Agents and receive acknowledgements in reply (SrvAck).\n   These
    advertisements must be refreshed with the Directory Agent or\n   they expire.
    \ User Agents unicast requests to Directory Agents\n   instead of Service Agents
    if any Directory Agents are known.\n +-------+ -Unicast SrvRqst-> +-----------+
    <-Unicast SrvReg- +--------+\n | User  |                    | Directory |                   |Service
    |\n | Agent |                    |   Agent   |                   | Agent  |\n
    +-------+ <-Unicast SrvRply- +-----------+ -Unicast SrvAck-> +--------+\n   User
    and Service Agents discover Directory Agents two ways.  First,\n   they issue
    a multicast Service Request for the 'Directory Agent'\n   service when they start
    up.  Second, the Directory Agent sends an\n   unsolicited advertisement infrequently,
    which the User and Service\n   Agents listen for.  In either case the Agents receive
    a DA\n    Advertisement (DAAdvert).\n        +---------------+ --Multicast SrvRqst->
    +-----------+\n        |    User or    | <--Unicast DAAdvert-- | Directory |\n
    \       | Service Agent |                       |   Agent   |\n        +---------------+
    <-Multicast DAAdvert- +-----------+\n   Services are grouped together using 'scopes'.
    \ These are strings\n   which identify services which are administratively identified.
    \ A\n   scope could indicate a location, administrative grouping, proximity\n
    \  in a network topology or some other category.  Service Agents and\n   Directory
    Agents are always assigned a scope string.\n   A User Agent is normally assigned
    a scope string (in which case the\n   User Agent will only be able to discover
    that particular grouping of\n   services).  This allows a network administrator
    to 'provision'\n   services to users.  Alternatively, the User Agent may be configured\n
    \  with no scope at all.  In that case, it will discover all available\n   scopes
    and allow the client application to issue requests for any\n   service available
    on the network.\n   +---------+   Multicast  +-----------+   Unicast   +-----------+\n
    \  | Service | <--SrvRqst-- |   User    | --SrvRqst-> | Directory |\n   |  Agent
    \ |              |   Agent   |             |   Agent   |\n   | Scope=X |   Unicast
    \   | Scope=X,Y |   Unicast   |  Scope=Y  |\n   +---------+ --SrvRply--> +-----------+
    <-SrvRply-- +-----------+\n   In the above illustration, the User Agent is configured
    with scopes X\n   and Y. If a service is sought in scope X, the request is multicast.\n
    \  If it is sought in scope Y, the request is unicast to the DA.\n   Finally,
    if the request is to be made in both scopes, the request\n   must be both unicast
    and multicast.\n   Service Agents and User Agents may verify digital signatures
    provided\n   with DAAdverts.  User Agents and Directory Agents may verify service\n
    \  information registered by Service Agents.  The keying material to use\n   to
    verify digital signatures is identified using a SLP Security\n   Parameter Index,
    or SLP SPI.\n   Every host configured to generate a digital signature includes
    the\n   SLP SPI used to verify it in the Authentication Block it transmits.\n
    \  Every host which can verify a digital signature must be configured\n   with
    keying material and other parameters corresponding with the SLP\n   SPI such that
    it can perform verifying calculations.\n   SAs MUST accept multicast service requests
    and unicast service\n   requests.  SAs MAY accept other requests (Attribute and
    Service Type\n   Requests).  SAs MUST listen for multicast DA Advertisements.\n
    \  The features described up to this point are required to implement.  A\n   minimum
    implementation consists of a User Agent, Service Agent or\n   both.\n   There
    are several optional features in the protocol.  Note that DAs\n   MUST support
    all these message types, but DA support is itself\n   optional to deploy on networks
    using SLP. UAs and SAs MAY support\n   these message types.  These operations
    are primarily for interactive\n   use (browsing or selectively updating service
    registrations.)  UAs\n   and SAs either support them or not depending on the requirements
    and\n   constraints of the environment where they will be used.\n  Service Type
    Request   A request for all types of service on the\n                         network.
    \ This allows generic service browsers\n                         to be built.\n
    \ Service Type Reply     A reply to a Service Type Request.\n  Attribute Request
    \     A request for attributes of a given type of\n                         service
    or attributes of a given service.\n  Attribute Reply        A reply to an Attribute
    Request.\n  Service Deregister     A request to deregister a service or some\n
    \                        attributes of a service.\n  Service Update         A
    subsequent SrvRqst to an advertisement.\n                         This allows
    individual dynamic attributes to\n                         be updated.\n  SA Advertisement
    \      In the absence of Directory Agents, a User\n                         agent
    may request Service Agents in order\n                         to discover their
    scope configuration.  The\n                         User Agent may use these scopes
    in requests.\n   In the absence of Multicast support, Broadcast MAY be used.  The\n
    \  location of DAs may be staticly configured, discovered using SLP as\n   described
    above, or configured using DHCP. If a message is too large,\n   it may be unicast
    using TCP.\n   A SLPv2 implementation SHOULD support SLPv1 [22].  This support\n
    \  includes:\n    1. SLPv2 DAs are deployed, phasing out SLPv1 DAs.\n    2. Unscoped
    SLPv1 requests are considered to be of DEFAULT scope.\n       SLPv1 UAs MUST be
    reconfigured to have a scope if possible.\n    3. There is no way for an SLPv2
    DA to behave as an unscoped SLPv1\n       DA. SLPv1 SAs MUST be reconfigured to
    have a scope if possible.\n    4. SLPv2 DAs answer SLPv1 requests with SLPv1 replies
    and SLPv2\n       requests with SLPv2 replies.\n    5. SLPv2 DAs use registrations
    from SLPv1 and SLPv2 in the same\n       way.  That is, incoming requests from
    agents using either version\n       of the protocol will be matched against this
    common set of\n       registered services.\n    6. SLPv2 registrations which use
    Language Tags which are greater\n       than 2 characters long will be inaccessible
    to SLPv1 UAs.\n    7. SLPv2 DAs MUST return only service type strings in SrvTypeRply\n
    \      messages which conform to SLPv1 service type string syntax, ie.\n       they
    MUST NOT return Service Type strings for abstract service\n       types.\n    8.
    SLPv1 SrvRqsts and AttrRqsts by Service Type do not match Service\n       URLs
    with abstract service types.  They only match Service URLs\n       with concrete
    service types.\n   SLPv1 UAs will not receive replies from SLPv2 SAs and SLPv2
    UAs will\n   not receive replies from SLPv1 SAs.  In order to interoperate UAs
    and\n   SAs of different versions require a SLPv2 DA to be present on the\n   network
    which supports both protocols.\n   The use of abstract service types in SLPv2
    presents a backward\n   compatibility issue for SLPv1.  It is possible that a
    SLPv1 UA will\n   request a service type which is actually an abstract service
    type.\n   Based on the rules above, the SLPv1 UA will never receive an abstract\n
    \  Service URL reply.  For example, the service type 'service:x' in a\n   SLPv1
    AttrRqst will not return the attributes of 'service:x:y://orb'.\n   If the request
    was made with SLPv2, it would return the attributes of\n   this service.\n"
  title: 3. Protocol Overview
- contents:
  - "4. URLs used with Service Location\n   A Service URL indicates the location of
    a service.  This URL may be\n   of the service: scheme [13] (reviewed in section
    4.1), or any other\n   URL scheme conforming to the URI standard [8], except that
    URLs\n   without address specifications SHOULD NOT be advertised by SLP. The\n
    \  service type for an 'generic' URL is its scheme name.  For example,\n   the
    service type string for \"http://www.srvloc.org\" would be \"http\".\n   Reserved
    characters in URLs follow the rules in RFC 2396 [8].\n"
  - contents:
    - "4.1. Service: URLs\n   Service URL syntax and semantics are defined in  [13].
      \ Any network\n   service may be encoded in a Service URL.\n   This section
      provides an introduction to Service URLs and an example\n   showing a simple
      application of them, representing standard network\n   services.\n   A Service
      URL may be of the form:\n      \"service:\"<srvtype>\"://\"<addrspec>\n   The
      Service Type of this service: URL is defined to be the string up\n   to (but
      not including) the final `:'  before <addrspec>, the address\n   specification.\n
      \  <addrspec> is a hostname (which should be used if possible) or dotted\n   decimal
      notation for a hostname, followed by an optional `:'  and\n   port number.\n
      \  A service: scheme URL may be formed with any standard protocol name\n   by
      concatenating \"service:\" and the reserved port [1] name.  For\n   example,
      \"service:tftp://myhost\" would indicate a tftp service.  A\n   tftp service
      on a nonstandard port could be\n   \"service:tftp://bad.glad.org:8080\".\n   Service
      Types SHOULD be defined by a \"Service Template\" [13], which\n   provides expected
      attributes, values and protocol behavior.  An\n   abstract service type (also
      described in [13]) has the form\n      \"service:<abstract-type>:<concrete-type>\".\n
      \  The service type string \"service:<abstract-type>\" matches all\n   services
      of that abstract type.  If the concrete type is included\n   also, only these
      services match the request.  For example:  a SrvRqst\n   or AttrRqst which specifies
      \"service:printer\" as the Service Type\n   will match the URL service:printer:lpr://hostname
      and\n   service:printer:http://hostname.  If the requests specified\n   \"service:printer:http\"
      they would match only the latter URL.\n   An optional substring MAY follow the
      last `.'  character in the\n   <srvtype> (or <abstract-type> in the case of
      an abstract service type\n   URL). This substring is the Naming Authority, as
      described in Section\n   9.6.  Service types with different Naming Authorities
      are quite\n   distinct.  In other words, service:x.one and service:x.two are\n
      \  different service types, as are service:abstract.one:y and\n   service:abstract.two:y.\n"
    title: '4.1. Service: URLs'
  - contents:
    - "4.2. Naming Authorities\n   A Naming Authority MAY optionally be included as
      part of the Service\n   Type string.  The Naming Authority of a service defines
      the meaning\n   of the Service Types and attributes registered with and provided
      by\n   Service Location.  The Naming Authority itself is typically a string\n
      \  which uniquely identifies an organization.  IANA is the implied\n   Naming
      Authority when no string is appended.  \"IANA\" itself MUST NOT\n   be included
      explicitly.\n   Naming Authorities may define Service Types which are experimental,\n
      \  proprietary or for private use.  Using a Naming Authority, one may\n   either
      simply ignore attributes upon registration or create a local-\n   use only set
      of attributes for one's site.  The procedure to use is\n   to create a 'unique'
      Naming Authority string and then specify the\n   Standard Attribute Definitions
      as described above.  This Naming\n   Authority will accompany registration and
      queries, as described in\n   Sections 8.1 and 8.3.  Service Types SHOULD be
      registered with IANA\n   to allow for Internet-wide interoperability.\n"
    title: 4.2. Naming Authorities
  - contents:
    - "4.3. URL Entries\n      0                   1                   2                   3\n
      \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |   Reserved    |          Lifetime             |   URL Length  |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |URL len, contd.|            URL (variable length)              \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |# of URL auths |            Auth. blocks (if any)              \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  SLP stores URLs in protocol elements called URL Entries, which\n   associate
      a length, a lifetime, and possibly authentication\n   information along with
      the URL. URL Entries, defined as shown above,\n   are used in Service Replies
      and Service Registrations.\n"
    title: 4.3. URL Entries
  title: 4. URLs used with Service Location
- contents:
  - "5. Service Attributes\n   A service advertisement is often accompanied by Service
    Attributes.\n   These attributes are used by UAs in Service Requests to select\n
    \  appropriate services.\n   The allowable attributes which may be used are typically
    specified by\n   a Service Template  [13] for a particular service type.  Services\n
    \  which are advertised according to a standard template MUST register\n   all
    service attributes which the standard template requires.  URLs\n   with schemes
    other than \"service:\" MAY be registered with attributes.\n   Non-standard attribute
    names SHOULD begin with \"x-\", because no\n   standard attribute name will ever
    have those initial characters.\n   An attribute list is a string encoding of the
    attributes of a\n   service.  The following ABNF [11] grammar defines attribute
    lists:\n   attr-list = attribute / attribute `,' attr-list\n   attribute = `('
    attr-tag `=' attr-val-list `)' / attr-tag\n   attr-val-list = attr-val / attr-val
    `,' attr-val-list\n   attr-tag = 1*safe-tag\n   attr-val = intval / strval / boolval
    / opaque\n   intval = [-]1*DIGIT\n   strval = 1*safe-val\n   boolval = \"true\"
    / \"false\"\n   opaque = \"\\FF\" 1*escape-val\n   safe-val = ; Any character
    except reserved.\n   safe-tag = ; Any character except reserved, star and bad-tag.\n
    \  reserved = `(' / `)' / `,' / `\\' / `!'  / `<' / `=' / `>' / `~' / CTL\n   escape-val
    = `\\' HEXDIG HEXDIG\n   bad-tag = CR / LF / HTAB / `_'\n    star = `*'\n   The
    <attr-list>, if present, MUST be scanned prior to evaluation for\n   all occurrences
    of the escape character `\\'.  Reserved characters\n   MUST be escaped (other
    characters MUST NOT be escaped).  All escaped\n   characters must be restored
    to their value before attempting string\n   matching.  For Opaque values, escaped
    characters are not converted -\n   they are interpreted as bytes.\n      Boolean
    \     Strings which have the form \"true\" or \"false\" can\n                   only
    take one value and may only be compared with\n                   '='.  Booleans
    are case insensitive when compared.\n      Integer      Strings which take the
    form [-] 1*<digit> and fall\n                   in the range \"-2147483648\" to
    \"2147483647\" are\n                   considered to be Integers.  These are compared
    using\n                   integer comparison.\n      String       All other Strings
    are matched using strict lexical\n                   ordering (see Section 6.4).\n
    \     Opaque       Opaque values are sequences of bytes.  These are\n                   distinguished
    from Strings since they begin with\n                   the sequence \"\\FF\".
    \ This, unescaped, is an illegal\n                   UTF-8 encoding, indicating
    that what follows is a\n                   sequence of bytes expressed in escape
    notation which\n                   constitute the binary value.  For example,
    a '0' byte\n                   is encoded \"\\FF\\00\".\n   A string which contains
    escaped values other than from the reserved\n   set of characters is illegal.
    \ If such a string is included in an\n   <attr-list>, <tag-list> or search filter,
    the SA or DA which receives\n   it MUST return a PARSE_ERROR to the message.\n
    \  A keyword has only an <attr-tag>, and no values.  Attributes can have\n   one
    or multiple values.  All values are expressed as strings.\n   When values have
    been advertised by a SA or are registered in a DA,\n   they can take on implicit
    typing rules for matching incoming\n   requests.\n   Stored values must be consistent,
    i.e., x=4,true,sue,\\ff\\00\\00 is\n   disallowed.  A DA or SA receiving such
    an <attr-list> MUST return an\n   INVALID_REGISTRATION error.\n"
  title: 5. Service Attributes
- contents:
  - "6. Required Features\n   This section defines the minimal implementation requirements
    for SAs\n   and UAs as well as their interaction with DAs.  A DA is not required\n
    \  for SLP to function, but if it is present, the UA and SA MUST\n   interact
    with it as defined below.\n   A minimal implementation may consist of either a
    UA or SA or both.\n   The only required features of a UA are that it can issue
    SrvRqsts\n   according to the rules below and interpret DAAdverts, SAAdverts and\n
    \  SrvRply messages.  The UA MUST issue requests to DAs as they are\n   discovered.
    \ An SA MUST reply to appropriate SrvRqsts with SrvRply or\n   SAAdvert messages.
    \ The SA MUST also register with DAs as they are\n   discovered.\n   UAs perform
    discovery by issuing Service Request messages.  SrvRqst\n   messages are issued,
    using UDP, following these prioritized rules:\n    1. A UA issues a request to
    a DA which it has been configured with\n       by DHCP.\n    2. A UA issues requests
    to DAs which it has been statically\n       configured with.\n    3. UA uses multicast/convergence
    SrvRqsts to discover DAs, then uses\n       that set of DAs.  A UA that does not
    know of any DAs SHOULD retry\n       DA discovery, increasing the waiting interval
    between subsequent\n       attempts exponentially (doubling the wait interval
    each time.)\n       The recommended minimum waiting interval is CONFIG_DA_FIND\n
    \      seconds.\n    4. A UA with no knowledge of DAs sends requests using multicast\n
    \      convergence to SAs.  SAs unicast replies to UAs according to the\n       multicast
    convergence algorithm.\n   UAs and SAs are configured with a list of scopes to
    use according to\n   these prioritized rules:\n    1. With DHCP.\n    2. With
    static configuration.  The static configuration may be\n       explicitly set
    to NO SCOPE for UAs, if the User Selectable Scope\n       model is used.  See
    section 11.2.\n    3. In the absence of configuration, the agent's scope is \"DEFAULT\".\n
    \  A UA MUST issue requests with one or more of the scopes it has been\n   configured
    to use.\n   A UA which has been statically configured with NO SCOPE LIST will
    use\n   DA or SA discovery to determine its scope list dynamically.  In this\n
    \  case it uses an empty scope list to discover DAs and possibly SAs.\n   Then
    it uses the scope list it obtains from DAAdverts and possibly\n   SAAdverts in
    subsequent requests.\n   The SA MUST register all its services with any DA it
    discovers, if\n   the DA advertises any of the scopes it has been configured with.
    \ A\n   SA obtains information about DAs as a UA does.  In addition, the SA\n
    \  MUST listen for multicast unsolicited DAAdverts.  The SA registers by\n   sending
    SrvReg messages to DAs, which reply with SrvReg messages to\n   indicate success.
    \ SAs register in ALL the scopes they were\n   configured to use.\n"
  - contents:
    - "6.1. Use of Ports, UDP, and Multicast\n   DAs MUST accept unicast requests
      and multicast directory agent\n   discovery service requests (for the service
      type \"service:directory-\n   agent\").\n   SAs MUST accept multicast requests
      and unicast requests both.  The SA\n   can distinguish between them by whether
      the REQUEST MCAST flag is set\n   in the SLP Message header.\n   The Service
      Location Protocol uses multicast for discovering DAs and\n   for issuing requests
      to SAs by default.\n   The reserved listening port for SLP is 427.  This is
      the destination\n   port for all SLP messages.  SLP messages MAY be transmitted
      on an\n   ephemeral port.  Replies and acknowledgements are sent to the port\n
      \  from which the request was issued.  The default maximum transmission\n   unit
      for UDP messages is 1400 bytes excluding UDP and other headers.\n   If a SLP
      message does not fit into a UDP datagram it MUST be\n   truncated to fit, and
      the OVERFLOW flag is set in the reply message.\n   A UA which receives a truncated
      message MAY open a TCP connection\n   (see section 6.2) with the DA or SA and
      retransmit the request, using\n   the same XID. It MAY also attempt to make
      use of the truncated reply\n   or reformulate a more restrictive request which
      will result in a\n   smaller reply.\n   SLP Requests messages are multicast
      to The Administratively Scoped\n   SLP Multicast [17] address, which is 239.255.255.253.
      \ The default\n   TTL to use for multicast is 255.\n   In isolated networks,
      broadcasts will work in place of multicast.  To\n   that end, SAs SHOULD and
      DAs MUST listen for broadcast Service\n   Location messages at port 427.  This
      allows UAs which do not support\n   multicast the use of Service Location on
      isolated networks.\n   Setting multicast TTL to less than 255 (the default)
      limits the range\n   of SLP discovery in a network, and localizes service information
      in\n   the network.\n"
    title: 6.1. Use of Ports, UDP, and Multicast
  - contents:
    - "6.2. Use of TCP\n   A SrvReg or SrvDeReg may be too large to fit into a datagram.
      \ To\n   send such large SLP messages, a TCP (unicast) connection MUST be\n
      \  established.\n   To avoid the need to implement TCP, one MUST insure that:\n
      \   -  UAs never issue requests larger than the Path MTU. SAs can omit\n       TCP
      support only if they never have to receive unicast requests\n       longer than
      the path MTU.\n    -  UAs can accept replies with the 'OVERFLOW' flag set, and
      make use\n       of the first result included, or reformulate the request.\n
      \   -  Ensure that a SA can send a SrvRply, SrvReg, or SrvDeReg in\n       a
      single datagram.  This means limiting the size of URLs,\n       the number of
      attributes and the number of authenticators\n       transmitted.\n   DAs MUST
      be able to respond to UDP and TCP requests, as well as\n   multicast DA Discovery
      SrvRqsts.  SAs MUST be able to respond to TCP\n   unless the SA will NEVER receive
      a request or send a reply which will\n   exceed a datagram in size (e.g., some
      embedded systems).\n   A TCP connection MAY be used for a single SLP transaction,
      or for\n   multiple transactions.  Since there are length fields in the message\n
      \  headers, SLP Agents can send multiple requests along a connection and\n   read
      the return stream for acknowledgments and replies.\n   The initiating agent
      SHOULD close the TCP connection.  The DA SHOULD\n   wait at least CONFIG_CLOSE_CONN
      seconds before closing an idle\n   connection.  DAs and SAs SHOULD close an
      idle TCP connection after\n   CONFIG_CLOSE_CONN seconds to ensure robust operation,
      even when the\n   initiating agent neglects to close it.  See Section 13 for
      timing\n   rules.\n"
    title: 6.2. Use of TCP
  - contents:
    - "6.3. Retransmission of SLP messages\n   Requests which fail to elicit a response
      are retransmitted.  The\n   initial retransmission occurs after a CONFIG_RETRY
      wait period.\n   Retransmissions MUST be made with exponentially increasing
      wait\n   intervals (doubling the wait each time).  This applies to unicast as\n
      \  well as multicast SLP requests.\n   Unicast requests to a DA or SA should
      be retransmitted until either a\n   response (which might be an error) has been
      obtained, or for\n   CONFIG_RETRY_MAX seconds.\n   Multicast requests SHOULD
      be reissued over CONFIG_MC_MAX seconds\n   until a result has been obtained.
      \ UAs need only wait till they\n   obtain the first reply which matches their
      request.  That is,\n   retransmission is not required if the requesting agent
      is prepared to\n   use the 'first reply' instead of 'as many replies as possible
      within\n   a bounded time interval.'\n   When SLP SrvRqst, SrvTypeRqst, and
      AttrRqst messages are multicast,\n   they contain a <PRList> of previous responders.
      \ Initially the\n   <PRList> is empty.  When these requests are unicast, the
      <PRList> is\n   always empty.\n   Any DA or SA which sees its address in the
      <PRList> MUST NOT respond\n   to the request.\n   The message SHOULD be retransmitted
      until the <PRList> causes no\n   further responses to be elicited or the previous
      responder list and\n   the request will not fit into a single datagram or until\n
      \  CONFIG_MC_MAX seconds elapse.\n   UAs which retransmit a request use the
      same XID. This allows a DA or\n   SA to cache its reply to the original request
      and then send it again,\n   should a duplicate request arrive.  This cached
      information should\n   only be held very briefly.  XIDs SHOULD be randomly chosen
      to avoid\n   duplicate XIDs in requests if UAs restart frequently.\n"
    title: 6.3. Retransmission of SLP messages
  - contents:
    - "6.4. Strings in SLP messages\n   The escape character is a backslash (UTF-8
      0x5c) followed by the two\n   hexadecimal digits of the escaped character.  Only
      reserved\n   characters are escaped.  For example, a comma (UTF-8 0x29) is escaped\n
      \  as `\\29', and a backslash `\\' is escaped as `\\5c'.  String lists used\n
      \  in SLP define the comma to be the delimiter between list elements, so\n   commas
      in data strings must be escaped in this manner.  Backslashes\n   are the escape
      character so they also must always be escaped when\n   included in a string
      literally.\n   String comparison for order and equality in SLP MUST be case\n
      \  insensitive inside the 0x00-0x7F subrange of UTF-8 (which corresponds\n   to
      ASCII character encoding).  Case insensitivity SHOULD be supported\n   throughout
      the entire UTF-8 encoded Unicode [6] character set.\n   The case insensitivity
      rule applies to all string matching in SLPv2,\n   including Scope strings, SLP
      SPI strings, service types, attribute\n   tags and values in query handling,
      language tags, previous responder\n   lists.  Comparisons of URL strings, however,
      is case sensitive.\n   White space (SPACE, CR, LF, TAB) internal to a string
      value is folded\n   to a single SPACE character for the sake of string comparisons.\n
      \  White space preceding or following a string value is ignored for the\n   purposes
      of string comparison.  For example, \"  Some String  \"\n   matches \"SOME    STRING\".\n
      \  String comparisons (using comparison operators such as `<=' or `>=')\n   are
      done using lexical ordering in UTF-8 encoded characters, not\n   using any language
      specific rules.\n   The reserved character `*' may precede, follow or be internal
      to a\n   string value in order to indicate substring matching.  The query\n
      \  including this character matches any character sequence which\n   conforms
      to the letters which are not wildcarded.\n"
    - contents:
      - "6.4.1. Scope Lists in SLP\n   Scope Lists in SLPv2 have the following grammar:\n
        \  scope-list = scope-val / scope-val `,' scope-list\n   scope-val = 1*safe\n
        \   safe = ; Any character except reserved.\n   reserved = `(' / `)' / `,'
        / `\\' / `!'  / `<' / `=' / `>' / `~' / CTL\n         / `;' / `*' / `+'\n
        \  escape-val = `\\' HEXDIG HEXDIG\n   Scopes which include any reserved characters
        must replace the escaped\n   character with the escaped-val format.\n"
      title: 6.4.1. Scope Lists in SLP
    title: 6.4. Strings in SLP messages
  title: 6. Required Features
- contents:
  - "7. Errors\n   If the Error Code in a SLP reply message is nonzero, the rest of
    the\n   message MAY be truncated.  No data is necessarily transmitted or\n   should
    be expected after the header and the error code, except\n   possibly for some
    optional extensions to clarify the error, for\n   example as in section D.1.\n
    \  Errors are only returned for unicast requests.  Multicast requests\n   are
    silently discarded if they result in an error.\n   LANGUAGE_NOT_SUPPORTED = 1:
    There is data for the service type in\n         the scope in the AttrRqst or SrvRqst,
    but not in the requested\n         language.\n   PARSE_ERROR = 2: The message
    fails to obey SLP syntax.\n   INVALID_REGISTRATION = 3: The SrvReg has problems
    -- e.g., a zero\n         lifetime or an omitted Language Tag.\n   SCOPE_NOT_SUPPORTED
    = 4: The SLP message did not include a scope in\n         its <scope-list> supported
    by the SA or DA.\n   AUTHENTICATION_UNKNOWN = 5: The DA or SA receives a request
    for an\n         unsupported SLP SPI.\n   AUTHENTICATION_ABSENT = 6: The DA expected
    URL and ATTR\n         authentication in the SrvReg and did not receive it.\n
    \  AUTHENTICATION_FAILED = 7: The DA detected an authentication error in\n         an
    Authentication block.\n   VER_NOT_SUPPORTED = 9: Unsupported version number in
    message header.\n   INTERNAL_ERROR = 10: The DA (or SA) is too sick to respond.\n
    \  DA_BUSY_NOW = 11: UA or SA SHOULD retry, using exponential back off.\n   OPTION_NOT_UNDERSTOOD
    = 12: The DA (or SA) received an unknown option\n         from the mandatory range
    (see section 9.1).\n   INVALID_UPDATE = 13: The DA received a SrvReg without FRESH
    set, for\n         an unregistered service or with inconsistent Service Types.\n
    \  MSG_NOT_SUPPORTED = 14: The SA received an AttrRqst or SrvTypeRqst\n         and
    does not support it.\n   REFRESH_REJECTED = 15: The SA sent a SrvReg or partial
    SrvDereg to a\n         DA more frequently than the DA's min-refresh-interval.\n"
  title: 7. Errors
- contents:
  - "8. Required SLP Messages\n   All length fields in SLP messages are in network
    byte order.  Where '\n   tuples' are defined, these are sequences of bytes, in
    the precise\n   order listed, in network byte order.\n   SLP messages all begin
    with the following header:\n      0                   1                   2                   3\n
    \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |    Version    |  Function-ID  |            Length             |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    | Length, contd.|O|F|R|       reserved          |Next Ext Offset|\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |  Next Extension Offset, contd.|              XID              |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \    |      Language Tag Length      |         Language Tag          \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \         Message Type             Abbreviation     Function-ID\n          Service
    Request          SrvRqst              1\n          Service Reply            SrvRply
    \             2\n          Service Registration     SrvReg               3\n          Service
    Deregister       SrvDeReg             4\n          Service Acknowledge      SrvAck
    \              5\n          Attribute Request        AttrRqst             6\n
    \         Attribute Reply          AttrRply             7\n          DA Advertisement
    \        DAAdvert             8\n          Service Type Request     SrvTypeRqst
    \         9\n          Service Type Reply       SrvTypeRply          10\n          SA
    Advertisement         SAAdvert             11\n   SAs and UAs MUST support SrvRqst,
    SrvRply and DAAdvert.  SAs MUST\n   also support SrvReg, SAAdvert and SrvAck.
    \ For UAs and SAs, support\n   for other messages are OPTIONAL.\n     - Length
    is the length of the entire SLP message, header included.\n     - The flags are:
    \ OVERFLOW (0x80) is set when a message's length\n       exceeds what can fit
    into a datagram.  FRESH (0x40) is set on\n       every new SrvReg.  REQUEST MCAST
    (0x20) is set when multicasting\n       or broadcasting requests.  Reserved bits
    MUST be 0.\n     - Next Extension Offset is set to 0 unless extensions are used.\n
    \      The first extension begins at 'offset' bytes, from the message's\n       beginning.
    \ It is placed after the SLP message data.  See\n       Section 9.1 for how to
    interpret unrecognized SLP Extensions.\n     - XID is set to a unique value for
    each unique request.  If the\n       request is retransmitted, the same XID is
    used.  Replies set\n       the XID to the same value as the xid in the request.
    \ Only\n       unsolicited DAAdverts are sent with an XID of 0.\n     - Lang Tag
    Length is the length in bytes of the Language Tag field.\n     - Language Tag
    conforms to [7].  The Language Tag in a reply MUST\n       be the same as the
    Language Tag in the request.  This field must\n       be encoded 1*8ALPHA *(\"-\"
    1*8ALPHA).\n   If an option is specified, and not included in the message, the\n
    \  receiver MUST respond with a PARSE_ERROR.\n"
  - contents:
    - "8.1. Service Request\n      0                   1                   2                   3\n
      \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |       Service Location header (function = SrvRqst = 1)        |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |      length of <PRList>       |        <PRList> String        \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |   length of <service-type>    |    <service-type> String      \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |    length of <scope-list>     |     <scope-list> String       \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |  length of predicate string   |  Service Request <predicate>  \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |  length of <SLP SPI> string   |       <SLP SPI> String        \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  In order for a Service to match a SrvRqst, it must belong to at least\n   one
      requested scope, support the requested service type, and match\n   the predicate.
      \ If the predicate is present, the language of the\n   request (ignoring the
      dialect part of the Language Tag) must match\n   the advertised service.\n   <PRList>
      is the Previous Responder List.  This <string-list> contains\n   dotted decimal
      notation IP (v4) addresses, and is iteratively\n   multicast to obtain all possible
      results (see Section 6.3).  UAs\n   SHOULD implement this discovery algorithm.
      \ SAs MUST use this to\n   discover all available DAs in their scope, if they
      are not already\n   configured with DA addresses by some other means.\n   A
      SA silently drops all requests which include the SA's address in\n   the <PRList>.
      \ An SA which has multiple network interfaces MUST check\n   if any of the entries
      in the <PRList> equal any of its interfaces.\n   An entry in the PRList which
      does not conform to an IPv4 dotted\n   decimal address is ignored:  The rest
      of the <PRList> is processed\n   normally and an error is not returned.\n   Once
      a <PRList> plus the request exceeds the path MTU, multicast\n   convergence
      stops.  This algorithm is not intended to find all\n   instances; it finds 'enough'
      to provide useful results.\n   The <scope-list> is a <string-list> of configured
      scope names.  SAs\n   and DAs which have been configured with any of the scopes
      in this\n   list will respond.  DAs and SAs MUST reply to unicast requests with
      a\n   SCOPE_NOT_SUPPORTED error if the <scope-list> is omitted or fails to\n
      \  include a scope they support (see Section 11).  The only exceptions\n   to
      this are described in Section 11.2.\n   The <service-type> string is discussed
      in Section 4.  Normally, a\n   SrvRqst elicits a SrvRply.  There are two exceptions:
      \ If the\n   <service-type> is set to \"service:directory-agent\", DAs respond
      to\n   the SrvRqst with a DAAdvert (see Section 8.5.)  If set to\n   \"service:service-agent\",
      SAs respond with a SAAdvert (see Section\n   8.6.)  If this field is omitted,
      a PARSE_ERROR is returned - as this\n   field is REQUIRED.\n   The <predicate>
      is a LDAPv3 search filter [14].  This field is\n   OPTIONAL. Services may be
      discovered simply by type and scope.\n   Otherwise, services are discovered
      which satisfy the <predicate>.  If\n   present, it is compared to each registered
      service.  If the attribute\n   in the filter has been registered with multiple
      values, the filter is\n   compared to each value and the results are ORed together,
      i.e.,\n   \"(x=3)\" matches a registration of (x=1,2,3); \"(!(Y=0))\" matches\n
      \  (y=0,1) since Y can be nonzero.  Note the matching is case\n   insensitive.
      \ Keywords (i.e., attributes without values) are matched\n   with a \"presence\"
      filter, as in \"(keyword=*)\".\n   An incoming request term MUST have the same
      type as the attribute in\n   a registration in order to match.  Thus, \"(x=33)\"
      will not match '\n   x=true', etc.  while \"(y=foo)\" will match 'y=FOO'.\n
      \  \"(|(x=33)(y=foo))\" will be satisfied, even though \"(x=33)\" cannot be\n
      \  satisfied, because of the `|' (boolean disjunction).\n   Wildcard matching
      MUST be done with the '=' filter.  In any other\n   case, a PARSE_ERROR is returned.
      \ Request terms which include\n   wildcards are interpreted to be Strings.  That
      is, (x=34*) would\n   match 'x=34foo', but not 'x=3432' since the first value
      is a String\n   while the second value is an Integer; Strings don't match Integers.\n
      \  Examples of Predicates follow.  <t> indicates the service type of the\n   SrvRqst,
      <s> gives the <scope-list> and <p> is the predicate string.\n      <t>=service:http
      \ <s>=DEFAULT  <p>=  (empty string)\n               This is a minimal request
      string.  It matches all http\n               services advertised with the default
      scope.\n      <t>=service:pop3  <s>=SALES,DEFAULT  <p>=(user=wump)\n               This
      is a request for all pop3 services available in\n               the SALES or
      DEFAULT scope which serve mail to the user\n               `wump'.\n      <t>=service:backup
      \ <s>=BLDG 32  <p>=(&(q<=3)(speed>=1000))\n               This returns the backup
      service which has a queue length\n               less than 3 and a speed greater
      than 1000.  It will\n               return this only for services registered
      with the BLDG 32\n               scope.\n      <t>=service:directory-agent  <s>=DEFAULT
      \ <p>=\n               This returns DAAdverts for all DAs in the DEFAULT scope.\n
      \  DAs are discovered by sending a SrvRqst with the service type set to\n   \"service:directory-agent\".
      \ If a predicate is included in the\n   SrvRqst, the DA SHOULD respond only
      if the predicate can be satisfied\n   with the DA's attributes.  The <scope-list>
      MUST contain all scopes\n   configured for the UA or SA which is discovering
      DAs.\n   The <SLP SPI> string indicates a SLP SPI that the requester has been\n
      \  configured with.  If this string is omitted, the responder does not\n   include
      any Authentication Blocks in its reply.  If it is included,\n   the responder
      MUST return a reply which has an associated\n   authentication block with the
      SLP SPI in the SrvRqst.  If no replies\n   may be returned because the SLP SPI
      is not supported, the responder\n   returns an AUTHENTICATION_UNKNOWN error.\n"
    title: 8.1. Service Request
  - contents:
    - "8.2. Service Reply\n      0                   1                   2                   3\n
      \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |        Service Location header (function = SrvRply = 2)       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |        Error Code             |        URL Entry count        |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |       <URL Entry 1>          ...       <URL Entry N>          \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  The service reply contains zero or more URL entries (see Section\n   4.3).
      \ A service reply with zero URL entries MUST be returned in\n   response to
      a unicast Service Request, if no matching URLs are\n   present.  A service reply
      with zero URL entries MUST NOT be sent in\n   response to a multicast or broadcast
      service request (instead, if\n   there was no match found or an error processing
      the request, the\n   service reply should not be generated at all).\n   If the
      reply overflows, the UA MAY simply use the first URL Entry in\n   the list.
      \ A URL obtained by SLP may not be cached longer than\n   Lifetime seconds,
      unless there is a URL Authenticator block present.\n   In that case, the cache
      lifetime is indicated by the Timestamp in the\n   URL Authenticator (see Section
      9.2).\n   An authentication block is returned in the URL Entries, including
      the\n   SLP SPI in the SrvRqst.  If no SLP SPI was included in the request,\n
      \  no Authentication Blocks are returned in the reply.  URL\n   Authentication
      Blocks are defined in Section 9.2.1.\n   If a SrvRply is sent by UDP, a URL
      Entry MUST NOT be included unless\n   it fits entirely without truncation.\n"
    title: 8.2. Service Reply
  - contents:
    - "8.3. Service Registration\n      0                   1                   2
      \                  3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |         Service Location header (function = SrvReg = 3)       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                          <URL-Entry>                          \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    | length of service type string |        <service-type>         \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |     length of <scope-list>    |         <scope-list>          \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |  length of attr-list string   |          <attr-list>          \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |# of AttrAuths |(if present) Attribute Authentication Blocks...\\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  The <entry> is a URL Entry (see section 4.3).  The Lifetime defines\n   how
      long a DA can cache the registration.  SAs SHOULD reregister\n   before this
      lifetime expires (but SHOULD NOT more often than once per\n   second).  The
      Lifetime MAY be set to any value between 0 and 0xffff\n   (maximum, around 18
      hours).  Long-lived registrations remain stale\n   longer if the service fails
      and the SA does not deregister the\n   service.\n   The <service-type> defines
      the service type of the URL to be\n   registered, regardless of the scheme of
      the URL. The <scope-list>\n   MUST contain the names of all scopes configured
      for the SA, which the\n   DA it is registering with supports.  The default value
      for the\n   <scope-list> is \"DEFAULT\" (see Section 11).\n   The SA MUST register
      consistently with all DAs.  If a SA is\n   configured with scopes X and Y and
      there are three DAs, whose scopes\n   are \"X\", \"Y\" and \"X,Y\" respectively,
      the SA will register the with\n   all three DAs in their respective scopes.
      \ All future updates and\n   deregistrations of the service must be sent to
      the same set of DAs in\n   the same scopes the service was initially registered
      in.\n   The <attr-list>, if present, specifies the attributes and values to\n
      \  be associated with the URL by the DA (see Section 5).\n   A SA configured
      with the ability to sign service registrations MUST\n   sign each of the URLs
      and Attribute Lists using each of the keys it\n   is configured to use, and
      the DA it is registering with accepts.\n   (The SA MUST acquire DAAdverts for
      all DAs it will register with to\n   obtain the DA's SLP SPI list and attributes,
      as described in Section\n   8.5).  The SA supplies a SLP SPI in each authentication
      block\n   indicating the SLP SPI configuration required to verify the digital\n
      \  signature.  The format of the digital signatures used is defined in\n   section
      9.2.1.\n   Subsequent registrations of previously registered services MUST\n
      \  contain the same list of SLP SPIs as previous ones or else DAs will\n   reject
      them, replying with an AUTHENTICATION_ABSENT error.\n   A registration with
      the FRESH flag set will replace *entirely* any\n   previous registration for
      the same URL in the same language.  If the\n   FRESH flag is not set, the registration
      is an \"incremental\"\n   registration (see Section 9.3).\n"
    title: 8.3. Service Registration
  - contents:
    - "8.4. Service Acknowledgment\n      0                   1                   2
      \                  3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |          Service Location header (function = SrvAck = 5)      |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |          Error Code           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  A DA returns a SrvAck to an SA after a SrvReg.  It carries only a two\n   byte
      Error Code (see Section 7).\n"
    title: 8.4. Service Acknowledgment
  - contents:
    - "8.5. Directory Agent Advertisement\n      0                   1                   2
      \                  3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |        Service Location header (function = DAAdvert = 8)      |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |          Error Code           |  DA Stateless Boot Timestamp  |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |DA Stateless Boot Time,, contd.|         Length of URL         |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    \\                              URL                              \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |     Length of <scope-list>    |         <scope-list>          \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |     Length of <attr-list>     |          <attr-list>          \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |    Length of <SLP SPI List>   |     <SLP SPI List> String     \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    | # Auth Blocks |         Authentication block (if any)         \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  The Error Code is set to 0 when the DAAdvert is multicast.  If the\n   DAAdvert
      is being returned due to a unicast SrvRqst (ie.  a request\n   without the REQUEST
      MCAST flag set) the DA returns the same errors a\n   SrvRply would.\n   The
      <scope-list> of the SrvRqst must either be omitted or include a\n   scope which
      the DA supports.  The DA Stateless Boot Timestamp\n   indicates the state of
      the DA (see section 12.1).\n   The DA MAY include a list of its attributes in
      the DAAdvert.  This\n   list SHOULD be kept short, as the DAAdvert must fit
      into a datagram\n   in order to be multicast.\n   A potential scaling problem
      occurs in SLPv2 if SAs choose too low a\n   Lifetime.  In this case, an onerous
      amount of reregistration occurs\n   as more services are deployed.  SLPv2 allows
      DAs to control SAs\n   frequency of registration.  A DA MAY reissue a DAAdvert
      with a new\n   set of attributes at any time, to change the reregistration behavior\n
      \  of SAs.  These apply only to subsequent registrations; existing\n   service
      registrations with the DA retain their registered lifetimes.\n   If the DAAdvert
      includes the attribute \"min-refresh-interval\" it MUST\n   be set to a single
      Integer value indicating a number of seconds.  If\n   this attribute is present
      SAs MUST NOT refresh any particular service\n   advertisement more frequently
      than this value.  If SrvReg with the\n   FRESH FLAG not set or SrvDereg with
      a non-empty tag list updating a\n   particular service are received more often
      than the value for the\n   DA's advertised \"min-refresh-interval\" attribute
      the DA SHOULD reject\n   the message and return a REFRESH_REJECTED error in
      the SrvAck.\n   The URL is \"service:directory-agent://\"<addr> of the DA, where
      <addr>\n   is the dotted decimal numeric address of the DA. The <scope-list>
      of\n   the DA MUST NOT be NULL.\n   The SLP SPI List is the list of SPIs that
      the DA is capable of\n   verifying.  SAs MUST NOT register services with authentication
      blocks\n   for those SLP SPIs which are not on the list.  DAs will reject\n
      \  service registrations which they cannot verify, returning an\n   AUTHENTICATION_UNKNOWN
      error.\n   The format of DAAdvert signatures is defined in Section 9.2.1.\n
      \  The SLP SPI which is used to verify the DAAdvert is included in the\n   Authentication
      Block.  When DAAdverts are multicast, they may have to\n   transmit multiple
      DAAdvert Authentication Blocks.  If the DA is\n   configured to be able to generate
      signatures for more than one SPI,\n   the DA MUST include one Authentication
      Block for each SPI.  If all\n   these Authentication Blocks do not fit in a
      single datagram (to\n   multicast or broadcast) the DA MUST send separate DAAdverts
      so that\n   Authentication Blocks for all the SPIs the DA is capable of\n   generating
      are sent.\n   If the DAAdvert is being sent in response to a SrvRqst, the DAAdvert\n
      \  contains only the authentication block with the SLP SPI in the\n   SrvRqst,
      if the DA is configured to be able to produce digital\n   signatures using that
      SLP SPI. If the SrvRqst is unicast to the DA\n   (the REQUEST MCAST flag in
      the header is not set) and an unsupported\n   SLP SPI is included, the DA replies
      with a DAAdvert with the Error\n   Code set to an AUTHENTICATION_UNKNOWN error.\n
      \  UAs SHOULD be configured with SLP SPIs that will allow them to verify\n   DA
      Advertisements.  If the UA is configured with SLP SPIs and\n   receives a DAAdvert
      which fails to be verified using one of them, the\n   UA MUST discard it.\n"
    title: 8.5. Directory Agent Advertisement
  - contents:
    - "8.6. Service Agent Advertisement\n   User Agents MUST NOT solicit SA Advertisements
      if they have been\n   configured to use a particular DA, if they have been configured
      with\n   a <scope-list> or if DAs have been discovered.  UAs solicit SA\n   Advertisements
      only when they are explicitly configured to use User\n   Selectable scopes (see
      Section 11.2) in order to discover the scopes\n   that SAs support.  This allows
      UAs without scope configuration to\n   make use of either DAs or SAs without
      any functional difference\n   except performance.\n   A SA MAY be configured
      with attributes, and SHOULD support the\n   attribute 'service-type' whose value
      is all the service types of\n   services represented by the SA. SAs MUST NOT
      respond if the SrvRqst\n   predicate is not satisfied.  For example, only SAs
      offering 'nfs'\n   services SHOULD respond with a SAAdvert to a SrvRqst for
      service type\n   \"service:service-agent\" which includes a predicate \"(service-\n
      \  type=nfs)\".\n      0                   1                   2                   3\n
      \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |        Service Location header (function = SAAdvert = 11)     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |         Length of URL         |              URL              \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |     Length of <scope-list>    |         <scope-list>          \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |     Length of <attr-list>     |          <attr-list>          \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    | # auth blocks |        authentication block (if any)          \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  The SA responds only to multicast SA discovery requests which either\n   include
      no <scope-list> or a scope which they are configured to use.\n   The SAAdvert
      MAY include a list of attributes the SA supports.  This\n   attribute list SHOULD
      be kept short so that the SAAdvert will not\n   exceed the path MTU in size.\n
      \  The URL is \"service:service-agent://\"<addr> of the SA, where <addr>\n   is
      the dotted decimal numeric address of the SA. The <scope-list> of\n   the SA
      MUST NOT be null.\n   The SAAdvert contains one SAAdvert Authentication block
      for each SLP\n   SPI the SA can produce Authentication Blocks for.  If the UA
      can\n   verify the Authentication Block of the SAAdvert, and the SAAdvert\n
      \  fails to be verified, the UA MUST discard it.\n"
    title: 8.6. Service Agent Advertisement
  title: 8. Required SLP Messages
- contents:
  - "9. Optional Features\n   The features described in this section are not mandatory.
    \ Some are\n   useful for interactive use of SLP (where a user rather than a program\n
    \  will select services, using a browsing interface for example) and for\n   scalability
    of SLP to larger networks.\n"
  - contents:
    - "9.1. Service Location Protocol Extensions\n   The format of a Service Location
      Extension is:\n      0                   1                   2                   3\n
      \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |         Extension ID          |       Next Extension Offset   |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    | Offset, contd.|                Extension Data                 \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Extension IDs are assigned in the following way:\n   0x0000-0x3FFF Standardized.
      \ Optional to implement.  Ignore if\n         unrecognized.\n   0x4000-0x7FFF
      Standardized.  Mandatory to implement.  A UA or SA\n         which receives
      this option in a reply and does not understand\n         it MUST silently discard
      the reply.  A DA or SA which receives\n         this option in a request and
      does not understand it MUST return\n         an OPTION_NOT_UNDERSTOOD error.\n
      \  0x8000-0x8FFF For private use (not standardized).  Optional to\n         implement.
      \ Ignore if unrecognized.\n   0x9000-0xFFFF Reserved.\n   The three byte offset
      to next extension indicates the position of the\n   next extension as offset
      from the beginning of the SLP message.\n   The offset value is 0 if there are
      no extensions following the\n   current extension.\n   If the offset is 0, the
      length of the current Extension Data is\n   determined by subtracting total
      length of the SLP message as given in\n   the SLP message header minus the offset
      of the current extension.\n   Extensions defined in this document are in Section
      D.  See section 15\n   for procedures that are required when specifying new
      SLP extensions.\n"
    title: 9.1. Service Location Protocol Extensions
  - contents:
    - "9.2. Authentication Blocks\n      0                   1                   2
      \                  3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |  Block Structure Descriptor   |  Authentication Block Length  |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                           Timestamp                           |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |     SLP SPI String Length     |         SLP SPI String        \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |              Structured Authentication Block ...              \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Authentication blocks are returned with certain SLP messages to\n   verify
      that the contents have not been modified, and have been\n   transmitted by an
      authorized agent.  The authentication data\n   (contained in the Structured
      Authentication Block) is typically case\n   sensitive.  Even though SLP registration
      data (e.g., attribute\n   values) are typically are not case sensitive, the
      case of the\n   registration data has to be preserved by the registering DA
      so that\n   UAs will be able to verify the data used for calculating digital\n
      \  signature data.\n   The Block Structure Descriptor (BSD) identifies the format
      of the\n   Authenticator which follows.  BSDs 0x0000-0x7FFF will be maintained\n
      \  by IANA. BSDs 0x8000-0x8FFF are for private use.\n   The Authentication Block
      Length is the length of the entire block,\n   starting with the BSD.\n   The
      Timestamp is the time that the authenticator expires (to prevent\n   replay
      attacks.)  The Timestamp is a 32-bit unsigned fixed-point\n   number of seconds
      relative to 0h on 1 January 1970.  SAs use this\n   value to indicate when the
      validity of the digital signature expires.\n   This Timestamp will wrap back
      to 0 in the year 2106.  Once the value\n   of the Timestamp wraps, the time
      at which the Timestamp is relative\n   to resets.  For example, after 06h28
      and 16 seconds 5 February 2106,\n   all Timestamp values will be relative to
      that epoch date.\n   The SLP Security Parameters Index (SPI) string identifies
      the key\n   length, algorithm parameters and keying material to be used by agents\n
      \  to verify the signature data in the Structured Authentication Block.\n   The
      SLP SPI string has the same grammar as the <scope-val> defined in\n   Section
      6.4.1.\n   Reserved characters in SLP SPI strings must be escaped using the
      same\n   convention as used throughout SLPv2.\n   SLP SPIs deployed in a site
      MUST be unique.  An SLP SPI used for\n   BSD=0x0002 must not be the same as
      used for some other BSD.\n   All SLP agents MUST implement DSA [20] (BSD=0x0002).
      \ SAs MUST\n   register services with DSA authentication blocks, and they MAY\n
      \  register them with other authentication blocks using other\n   algorithms.
      \ SAs MUST use DSA authentication blocks in SrvDeReg\n   messages and DAs MUST
      use DSA authentication blocks in unsolicited\n   DAAdverts.\n"
    - contents:
      - "9.2.1. SLP Message Authentication Rules\n   The sections below define how
        to calculate the value to apply to the\n   algorithm identified by the BSD
        value.  The components listed are\n   used as if they were a contiguous single
        byte aligned buffer in the\n   order given.\n      URL\n          16-bit Length
        of SLP SPI String, SLP SPI String.\n          16-bit Length of URL, URL,\n
        \         32-bit Timestamp.\n      Attribute List\n          16-bit Length
        of SLP SPI String, SLP SPI String,\n          16-bit length of <attr-list>,
        <attr-list>,\n          32-bit Timestamp.\n      DAAdvert\n          16-bit
        Length of SLP SPI String, SLP SPI String,\n          32-bit DA Stateless Boot
        Timestamp,\n          16-bit Length of URL, URL,\n          16-bit Length
        of <attr-list>, <attr-list>,\n          16-bit Length of DA's <scope-list>,
        DA's <scope-list>,\n          16-bit Length of DA's <SLP SPI List>, DA's <SLP
        SPI List>,\n          32-bit Timestamp.\n          The first SLP SPI is the
        SLP SPI in the Authentication\n          Block.  This SLP SPI indicates the
        keying material and other\n          parameters to use to verify the DAAdvert.
        \ The SLP SPI List is\n          the list of SLP SPIs the DA itself supports,
        and is able to\n          verify.\n      SAAdvert\n          16-bit Length
        of SLP SPI String, SLP SPI String,\n          16-bit Length of URL, URL,\n
        \         16-bit Length of <attr-list>, <attr-list>,\n          16-bit Length
        of <scope-list>, <scope-list>,\n          32-bit Timestamp.\n"
      title: 9.2.1. SLP Message Authentication Rules
    - contents:
      - "9.2.2 DSA with SHA-1 in Authentication Blocks\n   BSD=0x0002 is defined to
        be DSA with SHA-1.  The signature\n   calculation is defined by [20].  The
        signature format conforms to\n   that in the X.509 v3 certificate:\n    1.
        The signature algorithm identifier (an OID)\n    2. The signature value (an
        octet string)\n    3. The certificate path.\n   All data is represented in
        ASN.1 encoding:\n        id-dsa-with-sha1 ID  ::=  {\n                        iso(1)
        member-body(2) us(840) x9-57 (10040)\n                        x9cm(4) 3 }\n
        \  i.e., the ASN.1 encoding of 1.2.840.10040.4.3 followed immediately\n   by:\n
        \       Dss-Sig-Value  ::=  SEQUENCE  {\n                        r       INTEGER,\n
        \                       s       INTEGER  }\n   i.e., the binary ASN.1 encoding
        of r and s computed using DSA and\n   SHA-1.  This is followed by a certificate
        path, as defined by X.509\n   [10], [2], [3], [4], [5].\n   Authentication
        Blocks for BSD=0x0002 have the following format.  In\n   the future, BSDs
        may be assigned which have different formats.\n      0                   1
        \                  2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2
        3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \    |                   ASN.1 encoded DSA signature                 \\\n
        \    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
      title: 9.2.2 DSA with SHA-1 in Authentication Blocks
    title: 9.2. Authentication Blocks
  - contents:
    - "9.3. Incremental Service Registration\n   Incremental registrations update
      attribute values for a previously\n   registered service.  Incremental service
      registrations are useful\n   when only a single attribute has changed, for instance.
      \ In an\n   incremental registration, the FRESH flag in the SrvReg header is
      NOT\n   set.\n   The new registration's attributes replace the previous\n   registration's,
      but do not affect attributes which were included\n   previously and are not
      present in the update.\n   For example, suppose service:x://a.org has been registered
      with\n   attributes A=1, B=2, C=3.  If an incremental registration comes for\n
      \  service:x://a.org with attributes C=30, D=40, then the attributes for\n   the
      service after the update are A=1, B=2, C=30, D=40.\n   Incremental registrations
      MUST NOT be performed for services\n   registered with Authentication Blocks.
      \ These must be registered with\n   ALL attributes, with the FRESH flag in the
      SrvReg header set.  DAs\n   which receive such registration messages return
      an\n   AUTHENTICATION_FAILED error.\n   If the FRESH flag is not set and the
      DA does not have a prior\n   registration for the service, the incremental registration
      fails with\n   error code INVALID_UPDATE.\n   The SA MUST use the same <scope-list>
      in an update message as was\n   used in the prior registration.  If this is
      not done, the DA returns\n   a SCOPE_NOT_SUPPORTED error.  In order to change
      the scope of a\n   service advertisement it MUST be deregistered first and reregistered\n
      \  with a new <scope-list>.\n   The SA MUST use the same <service-type> in an
      update message as was\n   used in a prior registration of the same URL. If this
      is not done,\n   the DA returns an INVALID_UPDATE error.\n"
    title: 9.3. Incremental Service Registration
  - contents:
    - "9.4. Tag Lists\n   Tag lists are used in SrvDeReg and AttrReq messages.  The
      syntax of a\n   <tag-list> item is:\n   tag-filter = simple-tag / substring\n
      \  simple-tag = 1*filt-char\n   substring = [initial] any [final]\n   initial
      = 1*filt-char\n     any = `*' *(filt-char `*')\n   final = 1*filt-char\n   filt-char
      = Any character excluding <reserved> and <bad-tag> (see\n         grammar in
      Section 5).\n   Wild card characters in a <tag-list> item match arbitrary sequences\n
      \  of characters.  For instance \"*bob*\" matches \"some bob I know\",\n   \"bigbob\",
      \"bobby\" and \"bob\".\n"
    title: 9.4. Tag Lists
  title: 9. Optional Features
- contents:
  - "10. Optional SLP Messages\n   The additional requests provide features for user
    interaction and for\n   efficient updating of service advertisements with dynamic
    attributes.\n"
  - contents:
    - "10.1. Service Type Request\n   The Service Type Request (SrvTypeRqst) allows
      a UA to discover all\n   types of service on a network.  This is useful for
      general purpose\n   service browsers.\n      0                   1                   2
      \                  3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |      Service Location header (function = SrvTypeRqst = 9)     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |        length of PRList       |        <PRList> String        \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |   length of Naming Authority  |   <Naming Authority String>   \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |     length of <scope-list>    |      <scope-list> String      \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  The <PRList> list and <scope-list> are interpreted as in Section 8.1.\n   The
      Naming Authority string, if present in the request, will limit\n   the reply
      to Service Type strings with the specified Naming\n   Authority.  If the Naming
      Authority string is absent, the IANA\n   registered service types will be returned.
      \ If the length of the\n   Naming Authority is set to 0xFFFF, the Naming Authority
      string is\n   omitted and ALL Service Types are returned, regardless of Naming\n
      \  Authority.\n"
    title: 10.1. Service Type Request
  - contents:
    - "10.2. Service Type Reply\n      0                   1                   2                   3\n
      \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |      Service Location header (function = SrvTypeRply = 10)    |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |           Error Code          |    length of <srvType-list>   |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                       <srvtype--list>                         \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  The service-type Strings (as described in Section 4.1) are provided\n   in
      <srvtype-list>, which is a <string-list>.\n   If a service type has a Naming
      Authority other than IANA it MUST be\n   returned following the service type
      string and a `.'  character.\n   Service types with the IANA Naming Authority
      do not include a Naming\n   Authority string.\n"
    title: 10.2. Service Type Reply
  - contents:
    - "10.3. Attribute Request\n   The Attribute Request (AttrRqst) allows a UA to
      discover attributes\n   of a given service (by supplying its URL) or for an
      entire service\n   type.  The latter feature allows the UA to construct a query
      for an\n   available service by selecting desired features.  The UA may request\n
      \  that all attributes are returned, or only a subset of them.\n      0                   1
      \                  2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |       Service Location header (function = AttrRqst = 6)       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |       length of PRList        |        <PRList> String        \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |         length of URL         |              URL              \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |    length of <scope-list>     |      <scope-list> string      \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |  length of <tag-list> string  |       <tag-list> string       \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |   length of <SLP SPI> string  |        <SLP SPI> string       \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  The <PRList>, <scope-list> and <SLP SPI> string are interpreted as in\n   Section
      8.1.\n   The URL field can take two forms.  It can simply be a Service Type\n
      \  (see Section 4.1), such as \"http\" or \"service:tftp\".  In this case,\n
      \  all attributes and the full range of values for each attribute of all\n   services
      of the given Service Type is returned.\n   The URL field may alternatively be
      a full URL, such as\n   \"service:printer:lpr://igore.wco.ftp.com:515/draft\"
      or\n   \"nfs://max.net/znoo\".  In this, only the registered attributes for\n
      \  the specified URL are returned.\n   The <tag-list> field is a <string-list>
      of attribute tags, as defined\n   in Section 9.4 which indicates the attributes
      to return in the\n   AttrRply.  If <tag-list> is omitted, all attributes are
      returned.\n   <tag-list> MUST be omitted and a full URL MUST be included when\n
      \  attributes when a SLP SPI List string is included, otherwise the DA\n   will
      reply with an AUTHENTICATION_FAILED error.\n"
    title: 10.3. Attribute Request
  - contents:
    - "10.4. Attribute Reply\n      0                   1                   2                   3\n
      \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |       Service Location header (function = AttrRply = 7)       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |         Error Code            |      length of <attr-list>    |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                         <attr-list>                           \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |# of AttrAuths |  Attribute Authentication Block (if present)  \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  The format of the <attr-list> and the Authentication Block is as\n   specified
      for SrvReg (see Section 9.2.1).\n   Attribute replies SHOULD be returned with
      the original case of the\n   string registration intact, as they are likely
      to be human readable.\n   In the case where the AttrRqst was by service type,
      all attributes\n   defined for the service type, and all their values are returned.\n
      \  Although white space is folded for string matching, attribute tags\n   and
      values MUST be returned with their original white space\n   preserved.\n   Only
      one copy of each attribute tag or String value should be\n   returned, arbitrarily
      choosing one version (with respect to upper and\n   lower case and white space
      internal to the strings):  Duplicate\n   attributes and values SHOULD be removed.
      \ An arbitrary version of the\n   string value and tag name is chosen for the
      merge.  For example:\n   \"(A=a a,b)\" merged with \"(a=A   A,B)\" may yield
      \"(a=a a,B)\".\n"
    title: 10.4. Attribute Reply
  - contents:
    - "10.5. Attribute Request/Reply Examples\n   Suppose that printer services have
      been registered as follows:\n   Registered Service:\n     URL        = service:printer:lpr://igore.wco.ftp.com/draft\n
      \    scope-list = Development\n     Lang. Tag  = en\n     Attributes = (Name=Igore),(Description=For
      developers only),\n                  (Protocol=LPR),(location-description=12th
      floor),\n                  (Operator=James Dornan \\3cdornan@monster\\3e),\n
      \                 (media-size=na-letter),(resolution=res-600),x-OK\n     URL
      \       = service:printer:lpr://igore.wco.ftp.com/draft\n     scope-list = Development\n
      \    Lang. Tag  = de\n     Attributes = (Name=Igore),(Description=Nur fuer Entwickler),\n
      \                 (Protocol=LPR),(location-description=13te Etage),\n                  (Operator=James
      Dornan \\3cdornan@monster\\3e),\n                  (media-size=na-letter),(resolution=res-600),x-OK\n
      \    URL        = service:printer:http://not.wco.ftp.com/cgi-bin/pub-prn\n     scope-list
      = Development\n     Lang. Tag  = en\n     Attributes = (Name=Not),(Description=Experimental
      IPP printer),\n                  (Protocol=http),(location-description=QA bench),\n
      \                 (media-size=na-letter),(resolution=other),x-BUSY\n   Notice
      the first printer, \"Igore\" is registered in both English and\n   German.  The
      `<' and `>' characters in the Operator attribute value\n   which are part of
      the Email address had to be escaped, as they are\n   reserved characters for
      values.\n   Attribute tags are not translated, though attribute values may be,\n
      \  see [13].\n   The attribute Request:\n     URL        = service:printer:lpr://igore.wco.ftp.com/draft\n
      \    scope-list = Development\n     Lang. Tag  = de\n     tag-list   = resolution,loc*\n
      \  receives the Attribute Reply:\n     (location-description=13te Etage),(resolution=res-600)\n
      \  The attribute Request:\n     URL        = service:printer\n     scope-list
      = Development\n     Lang. Tag  = en\n     tag-list   = x-*,resolution,protocol\n
      \  receives an Attribute Reply containing:\n     (protocols=http,LPR),(resolution=res-600,other),x-OK,x-BUSY\n
      \  The first request is by service instance and returns the requested\n   values,
      in German.  The second request is by abstract service type\n   (see Section
      4) and returns values from both \"Igore\" and \"Not\".\n   An attribute Authentication
      Block is returned if an authentication\n   block with the SLP SPI in the AttrRqst
      can be returned.  Note that\n   the <attr-list> returned from a DA with an Authentication
      Block MUST\n   be identical to the <attr-list> registered by a SA, in order
      for the\n   authentication verification calculations to be possible.\n   A SA
      or DA only returns an Attribute Authentication Block if the\n   AttrRqst included
      a full URL in the request and no tag list.\n   If an SLP SPI is specified in
      a unicast request (the REQUEST MCAST\n   flag in the header is not set) and
      the SA or DA cannot return an\n   Authentication Block with that SLP SPI, an
      AUTHENTICATION_UNKNOWN\n   error is returned.  The # of Attr Auths field is
      set to 0 if there no\n   Authentication Block is included, or 1 if an Authentication
      Block\n   follows.\n"
    title: 10.5. Attribute Request/Reply Examples
  - contents:
    - "10.6. Service Deregistration\n   A DA deletes a service registration when its
      Lifetime expires.\n   Services SHOULD be deregistered when they are no longer
      available,\n   rather than leaving the registrations to time out.\n      0                   1
      \                  2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |         Service Location header (function = SrvDeReg = 4)     |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |    Length of <scope-list>     |         <scope-list>          \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |                           URL Entry                           \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |      Length of <tag-list>     |            <tag-list>         \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  The <scope-list> is a <string-list> (see section 2.1).\n   The SA MUST retry
      if there is no response from the DA, see Section\n   12.3.  The DA acknowledges
      a SrvDeReg with a SrvAck.  Once the SA\n   receives an acknowledgment indicating
      success, the service and/or\n   attributes are no longer advertised by the DA.
      The DA deregisters the\n   service or service attributes from every scope specified
      in the\n   SrvDeReg which it was previously registered in.\n   The SA MUST deregister
      all services with the same scope list used to\n   register the service with
      a DA. If this is not done in the SrvDeReg\n   message, the DA returns a SCOPE_NOT_SUPPORTED
      error.  The Lifetime\n   field in the URL Entry is ignored for the purposes
      of the SrvDeReg.\n   The <tag-list> is a <string-list> of attribute tags to
      deregister as\n   defined in Section 9.4.  If no <tag-list> is present, the
      SrvDeReg\n   deregisters the service in all languages it has been registered
      in.\n   If the <tag-list> is present, the SrvDeReg deregisters the attributes\n
      \  whose tags are listed in the tag spec.  Services registered with\n   Authentication
      Blocks MUST NOT include a <tag-list> in a SrvDeReg\n   message:  A DA will respond
      with an AUTHENTICATION_FAILED error in\n   this case.\n   If the service to
      be deregistered was registered with an\n   authentication block or blocks, a
      URL authentication block for each\n   of the SLP SPIs registered must be included
      in the SrvDeReg.\n   Otherwise, the DA returns an AUTHENTICATION_ABSENT error.
      \ If the\n   message fails to be verified by the DA, an AUTHENTICATION_FAILED\n
      \  error is returned by the DA.\n"
    title: 10.6. Service Deregistration
  title: 10. Optional SLP Messages
- contents:
  - "11. Scopes\n   Scopes are sets of services.  The primary use of Scopes is to
    provide\n   the ability to create administrative groupings of services.  A set
    of\n   services may be assigned a scope by network administrators.  A client\n
    \  seeking services is configured to use one or more scopes.  The user\n   will
    only discover those services which have been configured for him\n   or her to
    use.  By configuring UAs and SAs with scopes,\n   administrators may provision
    services.  Scopes strings are case\n   insensitive.  The default SCOPE string
    is \"DEFAULT\".\n   Scopes are the primary means an administrator has to scale
    SLP\n   deployments to larger networks.  When DAs with NON-DEFAULT scopes are\n
    \  present on the network, further gains can be had by configuring UAs\n   and
    SAs to have a predefined non-default scope.  These agents can\n   then perform
    DA discovery and make requests using their scope.  This\n   will limit the number
    of replies.\n"
  - contents:
    - "11.1. Scope Rules\n   SLP messages which fail to contain a scope that the receiving
      Agent\n   is configured to use are dropped (if the request was multicast) or
      a\n   SCOPE_NOT_SUPPORTED error is returned (if the request was unicast).\n
      \  Every SrvRqst (except for DA and SA discovery requests), SrvReg,\n   AttrRqst,
      SrvTypeRqst, DAAdvert, and SAAdvert message MUST include a\n   <scope-list>.\n
      \  A UA MUST unicast its SLP messages to a DA which supports the desired\n   scope,
      in preference to multicasting a request to SAs.  A UA MAY\n   multicast the
      request if no DA is available in the scope it is\n   configured to use.\n"
    title: 11.1. Scope Rules
  - contents:
    - "11.2. Administrative and User Selectable Scopes\n   All requests and services
      are scoped.  The two exceptions are\n   SrvRqsts for \"service:directory-agent\"
      and \"service:service-agent\".\n   These MAY have a zero-length <scope-list>
      when used to enable the\n   user to make scope selections.  In this case UAs
      obtain their scope\n   list from DAAdverts (or if DAs are not available, from
      SAAdverts.)\n   Otherwise, if SAs and UAs are to use any scope other than the
      default\n   (i.e., \"DEFAULT\"), the UAs and SAs are configured with lists of\n
      \  scopes to use by system administrators, perhaps automatically by way\n   of
      DHCP option 78 or 79 [21].  Such administrative scoping allows\n   services
      to be provisioned, so that users will only see services they\n   are intended
      to see.\n   User configurable scopes allow a user to discover any service, but\n
      \  require them to do their own selection of scope.  This is similar to\n   the
      way AppleTalk [12] and SMB [19] networking allow user selection\n   of AppleTalk
      Zone or workgroups.\n   Note that the two configuration choices are not compatible.
      \ One\n   model allows administrators control over service provision.  The\n
      \  other delegates this to users (who may not be prepared to do any\n   configuration
      of their system).\n"
    title: 11.2. Administrative and User Selectable Scopes
  title: 11. Scopes
- contents:
  - "12. Directory Agents\n   DAs cache service location and attribute information.
    \ They exist to\n   enhance the performance and scalability of SLP. Multiple DAs
    provide\n   further scalability and robustness of operation, since they can each\n
    \  store service information for the same SAs, in case one of the DAs\n   fails.\n
    \  A DA provides a centralized store for service information.  This is\n   useful
    in a network with several subnets or with many SLP Agents.\n   The DA address
    can be dynamically configured with UAs and SAs using\n   DHCP, or by using static
    configuration.\n   SAs configured to use DAs with DHCP or static configuration
    MUST\n   unicast a SrvRqst to the DA, when the SA is initialized.  The SrvRqst\n
    \  omits the scope list and sets the service type of the request to\n   \"service:directory-agent\".
    \ The DA will return a DAAdvert with its\n   attributes, SLP SPI list, and other
    parameters which are essential\n   for proper SA to DA communication.\n   Passive
    detection of DAs by SAs enables services to be advertised\n   consistently among
    DAs of the same scope.  Advertisements expire if\n   not renewed, leaving only
    transient stale registrations in DAs, even\n   in the case of a failure of a SA.\n
    \  A single DA can support many UAs.  UAs send the same requests to DAs\n   that
    they would send to SAs and expect the same results.  DAs reduce\n   the load on
    SAs, making simpler implementations of SAs possible.\n   UAs MUST be prepared
    for the possibility that the service information\n   they obtain from DAs is stale.\n"
  - contents:
    - "12.1. Directory Agent Rules\n   When DAs are present, each SA MUST register
      its services with DAs\n   that support one or more of its scope(s).\n   UAs
      MUST unicast requests directly to a DA (when scoping rules\n   allow), hence
      avoiding using the multicast convergence algorithm, to\n   obtain service information.
      \ This decreases network utilization and\n   increases the speed at which UAs
      can obtain service information.\n   DAs MUST flush service advertisements once
      their lifetime expires or\n   their URL Authentication Block \"Timestamp\" of
      expiration is past.\n   DAAdverts MUST include DA Stateless Boot Timestamp,
      in the same\n   format as the Authentication Block (see Section 9.2).  The Timestamp\n
      \  in the Authentication Block indicates the time at which all previous\n   registrations
      were lost (i.e., the last stateless reboot).  The\n   Timestamp is set to 0
      in a DAAdvert to notify UAs and SAs that the DA\n   is going down.  DAs MUST
      NOT use equal or lesser Boot Timestamps to\n   previous ones, if they go down
      and restart without service\n   registration state.  This would mislead SAs
      to not reregister with\n   the DA.\n   DAs which receive a multicast SrvRqst
      for the service type\n   \"service:directory-agent\" MUST silently discard it
      if the <scope-\n   list> is (a) not omitted and (b) does not include a scope
      they are\n   configured to use.  Otherwise the DA MUST respond with a DAAdvert.\n
      \  DAs MUST respond to AttrRqst and SrvTypeRqst messages (these are\n   OPTIONAL
      only for SAs, not DAs.)\n"
    title: 12.1. Directory Agent Rules
  - contents:
    - "12.2. Directory Agent Discovery\n   UAs can discover DAs using static configuration,
      DHCP options 78 and\n   79, or by multicasting (or broadcasting) Service Requests
      using the\n   convergence algorithm in Section 6.3.\n   See Section 6 regarding
      unsolicited DAAdverts.  Section 12.2.2\n   describes how SAs may reduce the
      number of times they must reregister\n   with DAs in response to unsolicited
      DAAdverts.\n   DAs MUST send unsolicited DAAdverts once per CONFIG_DA_BEAT.
      An\n   unsolicited DAAdvert has an XID of 0.  SAs MUST listen for DAAdverts,\n
      \  passively, as described in Section 8.5.  UAs MAY do this.  If they do\n   not
      listen for unsolicited DAAdverts, however, they will not discover\n   DAs as
      they become available.  UAs SHOULD, in this case, do periodic\n   active DA
      discovery, see Section 6.\n   A URL with the scheme \"service:directory-agent\"
      indicates the DA's\n   location as defined in Section 8.5.  For example:\n   \"service:directory-agent://foobawooba.org\".\n
      \  The following sections suggest timing algorithms which enhance the\n   scalability
      of SLP.\n"
    - contents:
      - "12.2.1. Active DA Discovery\n   After a UA or SA restarts, its initial DA
        discovery request SHOULD be\n   delayed for some random time uniformly distributed
        from 0 to\n   CONFIG_START_WAIT seconds.\n   The UA or SA sends the DA Discovery
        request using a SrvRqst, as\n   described in Section 8.1.  DA Discovery requests
        MUST include a\n   Previous Responder List.  SrvRqsts for Active DA Discovery
        SHOULD NOT\n   be sent more than once per CONFIG_DA_FIND seconds.\n   After
        discovering a new DA, a SA MUST wait a random time between 0\n   and CONFIG_REG_ACTIVE
        seconds before registering their services.\n"
      title: 12.2.1. Active DA Discovery
    - contents:
      - "12.2.2. Passive DA Advertising\n   A DA MUST multicast (or broadcast) an
        unsolicited DAAdvert every\n   CONFIG_DA_BEAT seconds.  CONFIG_DA_BEAT SHOULD
        be specified to\n   prevent DAAdverts from using more than 1% of the available
        bandwidth.\n   All UAs and SAs which receive the unsolicited DAAdvert SHOULD
        examine\n   its DA stateless Boot Timestamp.  If it is set to 0, the DA is
        going\n   down and no further messages should be sent to it.\n   If a SA detects
        a DA it has never encountered (with a nonzero\n   timestamp,) the SA must
        register with it.  SAs MUST examine the\n   DAAdvert's timestamp to determine
        if the DA has had a stateless\n   reboot since the SA last registered with
        it.  If so it registers with\n   the DA. SAs MUST wait a random interval between
        0 and\n   CONFIG_REG_PASSIVE before beginning DA registration.\n"
      title: 12.2.2. Passive DA Advertising
    title: 12.2. Directory Agent Discovery
  - contents:
    - "12.3. Reliable Unicast to DAs and SAs\n   If a DA or SA fails to respond to
      a unicast UDP message in\n   CONFIG_RETRY seconds, the message should be retried.
      \ The wait\n   interval for each subsequent retransmission MUST exponentially\n
      \  increase, doubling each time.  If a DA or SA fails to respond after\n   CONFIG_RETRY_MAX
      seconds, the sender should consider the receiver to\n   have gone down.  The
      UA should use a different DA. If no such DA\n   responds, DA discovery should
      be used to find a new DA. If no DA is\n   available, multicast requests to SAs
      are used.\n"
    title: 12.3. Reliable Unicast to DAs and SAs
  - contents:
    - "12.4. DA Scope Configuration\n   By default, DAs are configured with the \"DEFAULT\"
      scope.\n   Administrators may add other configured scopes, in order to support\n
      \  UAs and SAs in non default scopes.  The default configuration MUST\n   NOT
      be removed from the DA unless:\n    -  There are other DAs which support the
      \"DEFAULT\" scope, or\n    -  All UAs and SAs have been configured with non-default
      scopes.\n   Non-default scopes can be phased-in as the SLP deployment grows.\n
      \  Default scopes should be phased out only when the non-default scopes\n   are
      universally configured.\n   If a DA and SA are coresident on a host (quite possibly
      implemented\n   by the same process), configuration of the host is considerably\n
      \  simplified if the SA supports only scopes also supported by the DA.\n   That
      is, the SA SHOULD NOT advertise services in any scopes which are\n   not supported
      by the coresident DA. This means that incoming requests\n   can be answered
      by a single data store; the SA and DA registrations\n   do not need to be kept
      separately.\n"
    title: 12.4. DA Scope Configuration
  - contents:
    - "12.5. DAs and Authentication Blocks\n   DAs are not configured to sign service
      registrations or attribute\n   lists.  They simply cache services registered
      by Service Agents.  DAs\n   MUST NOT accept registrations including authentication
      blocks for SLP\n   SPIs which it is not configured with, see Section 8.5.\n
      \  A DA protects registrations which are made with authentication blocks\n   using
      SLP SPIs it is configured to use.  If a service S is\n   registered, a subsequent
      registration (which will replace the\n   adertisement) or a deregistration (which
      will remove it) MUST include\n   an Authentication Block with the corresponding
      SLP SPI, see Section\n   8.3 and Section 10.6.\n   Example:\n   A DA is configured
      to be able to verify Authentication Blocks with\n   SLP SPIs \"X,Y\", that is
      X and Y.\n   An SA registers a service with an Authentication Block with SPI
      \"Z\".\n   The DA stores the registration, but discards the Authentication\n
      \  Block.  If a UA requests a service with an SLP SPI string \"Z\", the DA\n
      \  will respond with an AUTHENTICATION_UNKNOWN error.\n   An SA registers a
      service S with Authentication Blocks including SLP\n   SPIs \"X\" and \"Y\".
      \ If a UA requests a service with an SLP SPI string\n   \"X\" the DA will be
      able to return S (if the service type, language,\n   scope and predicate of
      the SrvRqst match S) The DA will also return\n   the Authentication Block with
      SLP SPI set to \"X\".  If the DA receives\n   a subsequent SrvDeReg for S (which
      will remove the advertisement) or\n   a subsequent SrvReg for S (which will
      replace it), the message must\n   include two URL Authentication Blocks, one
      each for SPIs \"X\" and \"Y\".\n   If either of these were absent, the DA would
      return an\n   AUTHENTICATION_ABSENT error.\n"
    title: 12.5. DAs and Authentication Blocks
  title: 12. Directory Agents
- contents:
  - '13. Protocol Timing Defaults

    '
  - 'Interval name        Section  Default Value   Meaning

    '
  - '-------------------  -------  -------------   ------------------------

    '
  - "CONFIG_MC_MAX        6.3      15 seconds      Max time to wait for a\n                                              complete
    multicast query\n                                              response (all values.)\n"
  - "CONFIG_START_WAIT    12.2.1   3 seconds       Wait to perform DA\n                                              discovery
    on reboot.\n"
  - "CONFIG_RETRY         12.3     2 seconds       Wait interval before\n                                              initial
    retransmission\n                                              of multicast or
    unicast\n                                              requests.\n"
  - "CONFIG_RETRY_MAX     12.3     15 seconds      Give up on unicast\n                                              request
    retransmission.\n"
  - "CONFIG_DA_BEAT       12.2.2   3 hours         DA Heartbeat, so that SAs\n                                              passively
    detect new DAs.\n"
  - "CONFIG_DA_FIND       12.3     900 seconds     Minimum interval to wait\n                                              before
    repeating Active\n                                              DA discovery.\n"
  - "CONFIG_REG_PASSIVE   12.2     1-3 seconds     Wait to register services\n                                              on
    passive DA discovery.\n"
  - "CONFIG_REG_ACTIVE    8.3      1-3 seconds     Wait to register services\n                                              on
    active DA discovery.\n"
  - "CONFIG_CLOSE_CONN    6.2      5 minutes       DAs and SAs close idle\n                                              connections.\n"
  title: 13. Protocol Timing Defaults
- contents:
  - "14. Optional Configuration\n      Broadcast Only\n               Any SLP agent
    SHOULD be configurable to use broadcast\n               only.  See Sections 6.1
    and 12.2.\n      Predefined DA\n               A UA or SA SHOULD be configurable
    to use a predefined DA.\n      No DA Discovery\n               The UA or SA SHOULD
    be configurable to ONLY use\n               predefined and DHCP-configured DAs
    and perform no active\n               or passive DA discovery.\n      Multicast
    TTL\n               The default multicast TTL is 255.  Agents SHOULD be\n               configurable
    to use other values.  A lower value will\n               focus the multicast convergence
    algorithm on smaller\n               subnetworks, decreasing the number of responses
    and\n               increases the performance of service location.  This\n               may
    result in UAs obtaining different results for the\n               identical requests
    depending on where they are connected\n               to the network.\n      Timing
    Values\n               Time values other than the default MAY be configurable.\n
    \              See Section 13.\n      Scopes\n               A UA MAY be configurable
    to support User Selectable\n               scopes by omitting all predefined scopes.
    \ See\n               Section 11.2.  A UA or SA MUST be configurable to use\n
    \              specific scopes by default.  Additionally, a UA or SA\n               MUST
    be configurable to use specific scopes for requests\n               for and registrations
    of specific service types.  The\n               scope or scopes of a DA MUST be
    configurable.  The\n               default value for a DA is to have the scope
    \"DEFAULT\" if\n               not otherwise configured.\n      DHCP Configuration\n
    \              DHCP options 78 and 79 may be used to configure SLP. If\n               DA
    locations are configured using DHCP, these SHOULD\n               be used in preference
    to DAs discovered actively or\n               passively.  One or more of the scopes
    configured using\n               DHCP MUST be used in requests.  The entire configured\n
    \              <scope-list> MUST be used in registration and DA\n               configuration
    messages.\n      Service Template\n               UAs and SAs MAY be configured
    by using Service Templates.\n               Besides simplifying the specification
    of attribute\n               values, this also allows them to enforce the inclusion\n
    \              of 'required' attributes in SrvRqst, SrvReg and SrvDeReg\n               messages.
    \ DAs MAY be configured with templates to\n               allow them to WARN UAs
    and SAs in these cases.  See\n               Section 10.4.\n      SLP SPI for
    service discovery\n               Agents SHOULD be configurable to support SLP
    SPIs using\n               the following parameters:  BSD=2 (DSA with SHA-1) and\n
    \              a public key identified by the SLP SPI String.  In\n               the
    future, when a Public Key Infrastructure exists,\n               SLP Agents may
    be able to obtain public keys and\n               cryptographic parameters corresponding
    to the names used\n               in SLP SPI Strings.\n               Note that
    if the SLP SPI string chosen is identical\n               to a scope string, it
    is effectively the same as a\n               Protected Scope in SLPv1.  Namely,
    every SA advertising\n               in that scope would be configured with the
    same Private\n               Key.  Every DA and UA of that scope would be configured\n
    \              with the appropriate Public Key to verify signatures\n               produced
    by those SAs.  This is a convenient way to\n               configure SLP deployments
    in the absence of a Public Key\n               Infrastructure.  Currently, it
    would be too difficult to\n               manage the keying of UAs and DAs if
    each SA had its own\n               key.\n      SLP SPI for Directory Agent discovery\n
    \              Agents SHOULD be configurable to support SLP SPIs as\n               above,
    to be used when discovering DAs.  This SPI SHOULD\n               be sent in SrvRqsts
    to discover DAs and be used to verify\n               multicast DAAdvert messages.\n
    \     SA and DA Private Key\n               SAs and DAs which can generate digital
    signatures require\n               a Private Key and a corresponding SLP SPI indentifier\n
    \              to include in the Authentication Block.  The SLP SPI\n               identifies
    the Public Key to use to verify the digital\n               signature in the Authentication
    Block.\n"
  title: 14. Optional Configuration
- contents:
  - "15. IANA Considerations\n   SLP includes four sets of identifiers which may be
    registered with\n   IANA. The policies for these registrations (See [18]) are
    noted in\n   each case.\n   The Block Structure Descriptor (BSD) identifies the
    format of the\n   Authenticator which follows.  BSDs 0x8000-0x8FFF are for Private
    Use.\n   Further Block Structured Descriptor (BSD) values, from the range\n   0x0003-0x7FFF
    may be standardized in the future by submitting a\n   document which describes:\n
    \     -     The data format of the Structured Authenticator block.\n      -     Which
    cryptographic algorithm to use (including a reference\n            to a technical
    specification of the algorithm.)\n      -     The format of any keying material
    required for\n            preconfiguring UAs, DAs and SAs.  Also include any\n
    \           considerations regarding key distribution.\n      -     Security considerations
    to alert others to the strengths and\n            weaknesses of the approach.\n
    \  The IANA will assign Cryptographic BSD numbers on the basis of IETF\n   Consenus.\n
    \  New function-IDs, in the range 12-255, may be standardized by the\n   method
    of IETF Consensus.\n   New SLP Extensions with types in the range 2-65535 may
    be registered\n   following review by a Designated Expert.\n   New error numbers
    in the range 15-65535 are assigned on the basis of\n   a Standards Action.\n   Protocol
    elements used with Service Location Protocol may also\n   require IANA registration
    actions.  SLP is used in conjunction with\n   \"service:\" URLs and Service Templates
    [13].  These are standardized\n   by review of a Designated Expert and a mailing
    list (See [13].)\n"
  title: 15. IANA Considerations
- contents:
  - "16. Internationalization Considerations\n   SLP messages support the use of multiple
    languages by providing a\n   Language Tag field in the common message header (see
    Section 8).\n   Services MAY be registered in multiple languages.  This provides\n
    \  attributes so that users with different language skills may select\n   services
    interactively.\n   Attribute tags are not translated.  Attribute values may be\n
    \  translated unless the Service Template [13] defines the attribute\n   values
    to be 'literal'.\n   A service which is registered in multiple languages may be
    queried in\n   multiple languages.  The language of the SrvRqst or AttrRqst is
    used\n   to satisfy the request.  If the requested language is not supported,\n
    \  a LANGUAGE_NOT_SUPPORTED error is returned.  SrvRply and AttrRply\n   messages
    are always in the same language of the request.\n   A DA or SA MAY be configured
    with translations of Service Templates\n   [13] for the same service type.  This
    will allow the DA or SA to\n   translate a request (say in Italian) to the language
    of the service\n   advertisement (say in English) and then translate the reply
    back to\n   Italian.  Similarly, a UA MAY use templates to translate outgoing\n
    \  requests and incoming replies.\n   The dialect field in the Language Tag MAY
    be used:  Requests which\n   can be fulfilled by matching a language and dialect
    will be preferred\n   to those which match only the language portion.  Otherwise,
    dialects\n   have no effect on matching requests.\n"
  title: 16. Internationalization Considerations
- contents:
  - "17. Security Considerations\n   SLP provides for authentication of service URLs
    and service\n   attributes.  This provides UAs and DAs with knowledge of the\n
    \  integrity of service URLs and attributes included in SLP messages.\n   The
    only systems which can generate digital signatures are those\n   which have been
    configured by administrators in advance.  Agents\n   which verify signed data
    may assume it is 'trustworthy' inasmuch as\n   administrators have ensured the
    cryptographic keying of SAs and DAs\n   reflects 'trustworthiness.'\n   Service
    Location does not provide confidentiality.  Because the\n   objective of this
    protocol is to advertise services to a community of\n   users, confidentiality
    might not generally be needed when this\n   protocol is used in non-sensitive
    environments.  Specialized schemes\n   might be able to provide confidentiality,
    if needed in the future.\n   Sites requiring confidentiality should implement
    the IP Encapsulating\n   Security Payload (ESP) [3] to provide confidentiality
    for Service\n   Location messages.\n   If Agents are not configured to generate
    Authentication Blocks and\n   Agents are not configured to verify them, an adversary
    might easily\n   use this protocol to advertise services on servers controlled
    by the\n   adversary and thereby gain access to users' private information.\n
    \  Further, an adversary using this protocol will find it much easier to\n   engage
    in selective denial of service attacks.  Sites that are in\n   potentially hostile
    environments (e.g., are directly connected to the\n   Internet) should consider
    the advantages of distributing keys\n   associated with SLP SPIs prior to deploying
    the sensitive directory\n   agents or service agents.\n   SLP is useful as a bootstrap
    protocol.  It may be used in\n   environments in which no preconfiguration is
    possible.  In such\n   situations, a certain amount of \"blind faith\" is required:
    \ Without\n   any prior configuration it is impossible to use any of the security\n
    \  mechanisms described above.  SLP will make use of the mechanisms\n   provided
    by the Security Area of the IETF for key distribution as\n   they become available.
    \ At this point it would only be possible to\n   gain the benefits associated
    with the use of Authentication Blocks if\n   cryptographic information and SLP
    SPIs can be preconfigured with the\n   end systems before they use SLP.\n   SLPv2
    enables a number of security policies with the mechanisms it\n   includes.  A
    SLPv2 UA could, for instance, reject any SLP message\n   which did not carry an
    authentication block which it could verify.\n   This is not the only policy which
    is possible to implement.\n"
  - "A. Appendix:  Changes to the Service Location Protocol from v1 to v2\n   SLP
    version 2 (SLPv2) corrects race conditions present in SLPv1 [22].\n   In addition,
    authentication has been reworked to provide more\n   flexibility and protection
    (especially for DA Advertisements).  SLPv2\n   also changes the formats and definition
    of many flags and values and\n   reduces the number of 'required features.'  SLPv2
    clarifies and\n   changes the use of 'Scopes', eliminating support for 'unscoped\n
    \  directory agents' and 'unscoped requests'.  SLPv2 uses LDAPv3\n   compatible
    string encodings of attributes and search filters.  Other\n   changes (such as
    Language and Character set handling) adopt practices\n   recommended by the Internet
    Engineering Steering Group.\n   Effort has been made to make SLPv2 operate the
    same whether DAs are\n   present or not.  For this reason, a new message (the
    SAAdvert) has\n   been added.  This allows UAs to discover scope information in
    the\n   absence of administrative configuration and DAs.  This was not\n   possible
    in SLPv1.\n   SLPv2 is incompatible in some respects with SLPv1.  If a DA which\n
    \  supports both SLPv1 and SLPv2 with the same scope is present,\n   services
    advertised by SAs using either version of the protocol will\n   be available to
    both SLPv1 and SLPv2 UAs.  SLPv1 DAs SHOULD be phased\n   out and replace with
    SLPv2 DAs which support both versions of the\n   protocol.\n   SLPv1 allows services
    to be advertised and requested without a scope.\n   Further, DAs can be configured
    without a scope.  This is incompatible\n   with SLPv2 and presents scalability
    problems.  To facilitate this\n   forward migration, SLPv1 agents MUST use scopes
    for all registrations\n   and requests.  SLPv1 DAs MUST be configured with a scope
    list.  This\n   constitutes a revision of RFC 2165 [22].\n"
  - "B. Appendix:  Service Discovery by Type:  Minimal SLPv2 Features\n   Service
    Agents may advertise services without attributes.  This will\n   enable only discovery
    of services by type.  Service types discovered\n   this way will have a Service
    Template [13] defined which specifies\n   explicitly that no attributes are associated
    with the service\n   advertisement.  Service types associated with Service Templates
    which\n   specify attributes MUST NOT be advertised by SAs which do not support\n
    \  attributes.\n   While discovery of service by service type is a subset of the\n
    \  features possible using SLPv2 this form of discovery is consistent\n   with
    the current generation of products that allow simple browsing of\n   all services
    in a 'zone' or 'workgroup' by type.  In some cases,\n   attribute discovery, security
    and feature negotiation is handled by\n   application layer protocols - all that
    is required is the basic\n   discovery of services that support a certain service.\n
    \  UAs requesting only service of that service type would only need to\n   support
    service type and scope fields of the Service Request.  UAs\n   would still perform
    DA discovery and unicast SLPv2 SrvRqst messages\n   to DAs in their scope once
    they were discovered instead of\n   multicasting them.\n   SAs would also perform
    DA discovery and use a SLPv2 SrvReg to\n   register all their advertised services
    with SLPv2 DAs in their scope.\n   These advertisements would needless to say
    contain no attribute\n   string.\n   These minimal SAs could ignore the Language
    Tag in requests since\n   SrvRqst messages would contain no attributes, hence
    no strings would\n   be internationalized.  Further, any non-null predicate string
    would\n   fail to match a service advertisement with no attributes, so these\n
    \  SAs would not have to parse and interpret search filters.  Overflow\n   will
    never occur in SrvRqst, SrvRply or SrvReg messages so TCP\n   message handling
    would not have to be implemented.  Finally, all\n   AttrRqst messages could be
    dropped by the SA, since no attributes are\n   supported.\n"
  - "C. Appendix:  DAAdverts with arbitrary URLs\n   Using Active DA Discovery, a
    SrvRqst with its service type field set\n   to \"service:directory-agent\".  DAs
    will respond with a DAAdvert\n   containing a URL with the \"service:directory-agent:\"
    scheme.  This is\n   the same DAAdvert that such a DA would multicast in unsolicited
    DA\n   advertisements.\n   A UA or SA which receives an unsolicited DAAdvert MUST
    examine the\n   URL to determine if it has a recognized scheme.  If the UA or
    SA does\n   not recognize the DAAdvert's URL scheme, the DAAdvert is silently\n
    \  discarded.  This document specifies only how to use URLs with the\n   \"service:directory-agent:\"
    scheme.\n   This provides the possibility for forward compatibility with future\n
    \  versions of SLP and enables other services to advertise their ability\n   to
    serve as a clearinghouse for service location information.\n   For example, if
    LDAPv3 [15] is used for service registration and\n   discovery by a set of end
    systems, they could interpret a LDAP URL\n   [16] to passively discover the LDAP
    server to use for this purpose.\n   This document does not specify how this is
    done:  SLPv2 agents\n   without further support would simply discard this DAAdvert.\n"
  - 'D. Appendix:  SLP Protocol Extensions

    '
  - contents:
    - "D.1. Required Attribute Missing Option\n      0                   1                   2
      \                  3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |    Extension Type = 0x0001    |        Extension Length       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |      Template IDVer Length    |     Template IDVer String     \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \    |Required Attr <tag-list> Length|    Required Attr <tag-list>   \\\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Required attributes and the format of the IDVer string are defined by\n   [13].\n
      \  If a SA or DA receives a SrvRqst or a SrvReg which fails to include a\n   Required
      Attribute for the requested Service Type (according to the\n   Service Template),
      it MAY return the Required Attribute Extension in\n   addition to the reply
      corresponding to the message.  The sender\n   SHOULD reissue the message with
      a search filter including the\n   attributes listed in the returned Required
      Attribute Extension.\n   Similarly, the Required Attribute Extension may be
      returned in\n   response to a SrvDereg message that contains a required attribute\n
      \  tag.\n   The Template IDVer String is the name and version number string
      of\n   the Service Template which defines the given attribute as required.\n
      \  It SHOULD be included, but can be omitted if a given SA or DA has\n   been
      individually configured to have 'required attributes.'\n   The Required Attribute
      <tag-list> MUST NOT include wild cards.\n"
    title: D.1. Required Attribute Missing Option
  title: 17. Security Considerations
- contents:
  - "E. Acknowledgments\n   This document incorporates ideas from work on several
    discovery\n   protocols, including RDP by Perkins and Harjono, and PDS by Michael\n
    \  Day.  We are grateful for contributions by Ye Gu and Peter Ford.\n   John Veizades
    was instrumental in the standardization of the Service\n   Location Protocol.
    \ Implementors at Novell, Axis Communications and\n   Sun Microsystems have contributed
    significantly to make this a much\n   clearer and more consistent document.\n"
  title: E. Acknowledgments
- contents:
  - "F. References\n    [1] Port numbers, July 1997.\n        ftp://ftp.isi.edu/in-notes/iana/assignments/port-numbers.\n
    \   [2] ISO/IEC JTC1/SC 21.  Certificate Extensions.  Draft Amendment\n        DAM
    4 to ISO/IEC 9594-2, December 1996.\n    [3] ISO/IEC JTC1/SC 21.  Certificate
    Extensions.  Draft Amendment\n        DAM 2 to ISO/IEC 9594-6, December 1996.\n
    \   [4] ISO/IEC JTC1/SC 21.  Certificate Extensions.  Draft Amendment\n        DAM
    1 to ISO/IEC 9594-7, December 1996.\n    [5] ISO/IEC JTC1/SC 21.  Certificate
    Extensions.  Draft Amendment\n        DAM 1 to ISO/IEC 9594-8, December 1996.\n
    \   [6] Unicode Technical Report #8.  The Unicode Standard, version 2.1.\n        Technical
    report, The Unicode Consortium, 1998.\n    [7] Alvestrand, H., \"Tags for the
    Identification of Languages\",\n        RFC 1766, March 1995.\n    [8] Berners-Lee,
    T., Fielding, R. and L. Masinter, \"Uniform\n        Resource Identifiers (URI):
    Generic Syntax\", RFC 2396,\n        August 1998.\n    [9] Bradner, S., \"Key
    Words for Use in RFCs to Indicate Requirement\n        Levels\", BCP 14, RFC 2119,
    March 1997.\n   [10] CCITT.  The Directory Authentication Framework.  Recommendation\n
    \       X.509, 1988.\n   [11] Crocker, D. and P. Overell, \"Augmented BNF for
    Syntax\n        Specifications: ABNF\", RFC 2234, November 1997.\n   [12] S. Gursharan,
    R. Andrews, and A. Oppenheimer.  Inside AppleTalk.\n        Addison-Wesley, 1990.\n
    \  [13] Guttman, E., Perkins, C. and J. Kempf, \"Service Templates and\n        service:
    Schemes\", RFC 2609, June 1999.\n   [14] Howes, T., \"The String Representation
    of LDAP Search Filters\",\n        RFC 2254, December 1997.\n   [15] Wahl, M.,
    Howes, T. and S. Kille, \"Lightweight Directory\n        Access Protocol (v3)\",
    RFC 2251, December 1997.\n   [16] Howes, T. and M. Smith, \"The LDAP URL Format\",
    RFC 2255,\n        December 1997.\n   [17] Meyer, D., \"Administratively Scoped
    IP Multicast\", RFC 2365,\n        July 1998.\n   [18] Narten, T. and H. Alvestrand,
    \"Guidelines for Writing\n        an IANA Considerations Section in RFCs, BCP
    26, RFC 2434,\n        October 1998.\n   [19] Microsoft Networks.  SMB File Sharing
    Protocol Extensions 3.0,\n        Document Version 1.09, November 1989.\n   [20]
    National Institute of Standards and Technology.  Digital\n        signature standard.
    \ Technical Report NIST FIPS PUB 186, U.S.\n        Department of Commerce, May
    1994.\n   [21] Perkins, C. and E. Guttman, \"DHCP Options for Service Location\n
    \       Protocol\", RFC 2610, June 1999.\n   [22] Veizades, J., Guttman, E., Perkins,
    C. and S. Kaplan, \"Service\n        Location Protocol\", RFC 2165, July 1997.\n
    \  [23] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\",\n        RFC
    2279, January 1998.\n"
  title: F. References
- contents:
  - "G.  Authors' Addresses\n   Erik Guttman\n   Sun Microsystems\n   Bahnstr. 2\n
    \  74915 Waibstadt\n   Germany\n   Phone:    +49 7263 911 701\n   EMail:    Erik.Guttman@sun.com\n
    \  Charles Perkins\n   Sun Microsystems\n   901 San Antonio Road\n   Palo Alto,
    CA 94040\n   USA\n   Phone: +1 650 786 6464\n   EMail: cperkins@sun.com\n   John
    Veizades\n   @Home Network\n   425 Broadway\n   Redwood City, CA 94043\n   USA\n
    \  Phone:    +1 650 569 5243\n   EMail:    veizades@home.net\n   Michael Day\n
    \  Vinca Corporation.\n   1201 North 800 East\n   Orem, Utah 84097   USA\n   Phone:
    +1 801 376-5083\n   EMail: mday@vinca.com\n"
  title: G.  Authors' Addresses
- contents:
  - "H.  Full Copyright Statement\n   Copyright (C) The Internet Society (1999).  All
    Rights Reserved.\n   This document and translations of it may be copied and furnished
    to\n   others, and derivative works that comment on or otherwise explain it\n
    \  or assist in its implementation may be prepared, copied, published\n   and
    distributed, in whole or in part, without restriction of any\n   kind, provided
    that the above copyright notice and this paragraph are\n   included on all such
    copies and derivative works.  However, this\n   document itself may not be modified
    in any way, such as by removing\n   the copyright notice or references to the
    Internet Society or other\n   Internet organizations, except as needed for the
    purpose of\n   developing Internet standards in which case the procedures for\n
    \  copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\"\n"
  title: H.  Full Copyright Statement
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
