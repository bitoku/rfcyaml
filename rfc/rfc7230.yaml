- contents:
  - '   Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing

    '
  title: __initial_text__
- contents:
  - "Abstract\n   The Hypertext Transfer Protocol (HTTP) is a stateless application-\n
    \  level protocol for distributed, collaborative, hypertext information\n   systems.
    \ This document provides an overview of HTTP architecture and\n   its associated
    terminology, defines the \"http\" and \"https\" Uniform\n   Resource Identifier
    (URI) schemes, defines the HTTP/1.1 message\n   syntax and parsing requirements,
    and describes related security\n   concerns for implementations.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7230.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................5\n
    \     1.1. Requirements Notation ......................................6\n      1.2.
    Syntax Notation ............................................6\n   2. Architecture
    ....................................................6\n      2.1. Client/Server
    Messaging ....................................7\n      2.2. Implementation Diversity
    ...................................8\n      2.3. Intermediaries .............................................9\n
    \     2.4. Caches ....................................................11\n      2.5.
    Conformance and Error Handling ............................12\n      2.6. Protocol
    Versioning .......................................13\n      2.7. Uniform Resource
    Identifiers ..............................16\n           2.7.1. http URI Scheme
    ....................................17\n           2.7.2. https URI Scheme ...................................18\n
    \          2.7.3. http and https URI Normalization and Comparison ....19\n   3.
    Message Format .................................................19\n      3.1.
    Start Line ................................................20\n           3.1.1.
    Request Line .......................................21\n           3.1.2. Status
    Line ........................................22\n      3.2. Header Fields .............................................22\n
    \          3.2.1. Field Extensibility ................................23\n           3.2.2.
    Field Order ........................................23\n           3.2.3. Whitespace
    .........................................24\n           3.2.4. Field Parsing ......................................25\n
    \          3.2.5. Field Limits .......................................26\n           3.2.6.
    Field Value Components .............................27\n      3.3. Message Body
    ..............................................28\n           3.3.1. Transfer-Encoding
    ..................................28\n           3.3.2. Content-Length .....................................30\n
    \          3.3.3. Message Body Length ................................32\n      3.4.
    Handling Incomplete Messages ..............................34\n      3.5. Message
    Parsing Robustness ................................34\n   4. Transfer Codings
    ...............................................35\n      4.1. Chunked Transfer
    Coding ...................................36\n           4.1.1. Chunk Extensions
    ...................................36\n           4.1.2. Chunked Trailer Part
    ...............................37\n           4.1.3. Decoding Chunked ...................................38\n
    \     4.2. Compression Codings .......................................38\n           4.2.1.
    Compress Coding ....................................38\n           4.2.2. Deflate
    Coding .....................................38\n           4.2.3. Gzip Coding
    ........................................39\n      4.3. TE ........................................................39\n
    \     4.4. Trailer ...................................................40\n   5.
    Message Routing ................................................40\n      5.1.
    Identifying a Target Resource .............................40\n      5.2. Connecting
    Inbound ........................................41\n      5.3. Request Target
    ............................................41\n           5.3.1. origin-form
    ........................................42\n           5.3.2. absolute-form ......................................42\n
    \          5.3.3. authority-form .....................................43\n           5.3.4.
    asterisk-form ......................................43\n      5.4. Host ......................................................44\n
    \     5.5. Effective Request URI .....................................45\n      5.6.
    Associating a Response to a Request .......................46\n      5.7. Message
    Forwarding ........................................47\n           5.7.1. Via ................................................47\n
    \          5.7.2. Transformations ....................................49\n   6.
    Connection Management ..........................................50\n      6.1.
    Connection ................................................51\n      6.2. Establishment
    .............................................52\n      6.3. Persistence ...............................................52\n
    \          6.3.1. Retrying Requests ..................................53\n           6.3.2.
    Pipelining .........................................54\n      6.4. Concurrency
    ...............................................55\n      6.5. Failures and Timeouts
    .....................................55\n      6.6. Tear-down .................................................56\n
    \     6.7. Upgrade ...................................................57\n   7.
    ABNF List Extension: #rule .....................................59\n   8. IANA
    Considerations ............................................61\n      8.1. Header
    Field Registration .................................61\n      8.2. URI Scheme
    Registration ...................................62\n      8.3. Internet Media
    Type Registration ..........................62\n           8.3.1. Internet Media
    Type message/http ...................62\n           8.3.2. Internet Media Type
    application/http ...............63\n      8.4. Transfer Coding Registry ..................................64\n
    \          8.4.1. Procedure ..........................................65\n           8.4.2.
    Registration .......................................65\n      8.5. Content Coding
    Registration ...............................66\n      8.6. Upgrade Token Registry
    ....................................66\n           8.6.1. Procedure ..........................................66\n
    \          8.6.2. Upgrade Token Registration .........................67\n   9.
    Security Considerations ........................................67\n      9.1.
    Establishing Authority ....................................67\n      9.2. Risks
    of Intermediaries ...................................68\n      9.3. Attacks via
    Protocol Element Length .......................69\n      9.4. Response Splitting
    ........................................69\n      9.5. Request Smuggling .........................................70\n
    \     9.6. Message Integrity .........................................70\n      9.7.
    Message Confidentiality ...................................71\n      9.8. Privacy
    of Server Log Information .........................71\n   10. Acknowledgments
    ...............................................72\n   11. References ....................................................74\n
    \     11.1. Normative References .....................................74\n      11.2.
    Informative References ...................................75\n   Appendix A. HTTP
    Version History ..................................78\n      A.1. Changes from
    HTTP/1.0  ....................................78\n           A.1.1.  Multihomed
    Web Servers ............................78\n           A.1.2.  Keep-Alive Connections
    ............................79\n           A.1.3.  Introduction of Transfer-Encoding
    .................79\n      A.2.  Changes from RFC 2616 ....................................80\n
    \  Appendix B. Collected ABNF ........................................82\n   Index
    .............................................................85\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The Hypertext Transfer Protocol (HTTP) is a stateless application-\n
    \  level request/response protocol that uses extensible semantics and\n   self-descriptive
    message payloads for flexible interaction with\n   network-based hypertext information
    systems.  This document is the\n   first in a series of documents that collectively
    form the HTTP/1.1\n   specification:\n   1.  \"Message Syntax and Routing\" (this
    document)\n   2.  \"Semantics and Content\" [RFC7231]\n   3.  \"Conditional Requests\"
    [RFC7232]\n   4.  \"Range Requests\" [RFC7233]\n   5.  \"Caching\" [RFC7234]\n
    \  6.  \"Authentication\" [RFC7235]\n   This HTTP/1.1 specification obsoletes
    RFC 2616 and RFC 2145 (on HTTP\n   versioning).  This specification also updates
    the use of CONNECT to\n   establish a tunnel, previously defined in RFC 2817,
    and defines the\n   \"https\" URI scheme that was described informally in RFC
    2818.\n   HTTP is a generic interface protocol for information systems.  It is\n
    \  designed to hide the details of how a service is implemented by\n   presenting
    a uniform interface to clients that is independent of the\n   types of resources
    provided.  Likewise, servers do not need to be\n   aware of each client's purpose:
    an HTTP request can be considered in\n   isolation rather than being associated
    with a specific type of client\n   or a predetermined sequence of application
    steps.  The result is a\n   protocol that can be used effectively in many different
    contexts and\n   for which implementations can evolve independently over time.\n
    \  HTTP is also designed for use as an intermediation protocol for\n   translating
    communication to and from non-HTTP information systems.\n   HTTP proxies and gateways
    can provide access to alternative\n   information services by translating their
    diverse protocols into a\n   hypertext format that can be viewed and manipulated
    by clients in the\n   same way as HTTP services.\n   One consequence of this flexibility
    is that the protocol cannot be\n   defined in terms of what occurs behind the
    interface.  Instead, we\n   are limited to defining the syntax of communication,
    the intent of\n   received communication, and the expected behavior of recipients.
    \ If\n   the communication is considered in isolation, then successful actions\n
    \  ought to be reflected in corresponding changes to the observable\n   interface
    provided by servers.  However, since multiple clients might\n   act in parallel
    and perhaps at cross-purposes, we cannot require that\n   such changes be observable
    beyond the scope of a single response.\n   This document describes the architectural
    elements that are used or\n   referred to in HTTP, defines the \"http\" and \"https\"
    URI schemes,\n   describes overall network operation and connection management,
    and\n   defines HTTP message framing and forwarding requirements.  Our goal\n
    \  is to define all of the mechanisms necessary for HTTP message\n   handling
    that are independent of message semantics, thereby defining\n   the complete set
    of requirements for message parsers and message-\n   forwarding intermediaries.\n"
  - contents:
    - "1.1.  Requirements Notation\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
      and \"OPTIONAL\" in this\n   document are to be interpreted as described in
      [RFC2119].\n   Conformance criteria and considerations regarding error handling
      are\n   defined in Section 2.5.\n"
    title: 1.1.  Requirements Notation
  - contents:
    - "1.2.  Syntax Notation\n   This specification uses the Augmented Backus-Naur
      Form (ABNF)\n   notation of [RFC5234] with a list extension, defined in Section
      7,\n   that allows for compact definition of comma-separated lists using a\n
      \  '#' operator (similar to how the '*' operator indicates repetition).\n   Appendix
      B shows the collected grammar with all list operators\n   expanded to standard
      ABNF notation.\n   The following core rules are included by reference, as defined
      in\n   [RFC5234], Appendix B.1: ALPHA (letters), CR (carriage return), CRLF\n
      \  (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double quote),\n   HEXDIG
      (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF (line\n   feed), OCTET
      (any 8-bit sequence of data), SP (space), and VCHAR (any\n   visible [USASCII]
      character).\n   As a convention, ABNF rule names prefixed with \"obs-\" denote\n
      \  \"obsolete\" grammar rules that appear for historical reasons.\n"
    title: 1.2.  Syntax Notation
  title: 1.  Introduction
- contents:
  - "2.  Architecture\n   HTTP was created for the World Wide Web (WWW) architecture
    and has\n   evolved over time to support the scalability needs of a worldwide\n
    \  hypertext system.  Much of that architecture is reflected in the\n   terminology
    and syntax productions used to define HTTP.\n"
  - contents:
    - "2.1.  Client/Server Messaging\n   HTTP is a stateless request/response protocol
      that operates by\n   exchanging messages (Section 3) across a reliable transport-
      or\n   session-layer \"connection\" (Section 6).  An HTTP \"client\" is a\n
      \  program that establishes a connection to a server for the purpose of\n   sending
      one or more HTTP requests.  An HTTP \"server\" is a program\n   that accepts
      connections in order to service HTTP requests by sending\n   HTTP responses.\n
      \  The terms \"client\" and \"server\" refer only to the roles that these\n
      \  programs perform for a particular connection.  The same program might\n   act
      as a client on some connections and a server on others.  The term\n   \"user
      agent\" refers to any of the various client programs that\n   initiate a request,
      including (but not limited to) browsers, spiders\n   (web-based robots), command-line
      tools, custom applications, and\n   mobile apps.  The term \"origin server\"
      refers to the program that can\n   originate authoritative responses for a given
      target resource.  The\n   terms \"sender\" and \"recipient\" refer to any implementation
      that sends\n   or receives a given message, respectively.\n   HTTP relies upon
      the Uniform Resource Identifier (URI) standard\n   [RFC3986] to indicate the
      target resource (Section 5.1) and\n   relationships between resources.  Messages
      are passed in a format\n   similar to that used by Internet mail [RFC5322] and
      the Multipurpose\n   Internet Mail Extensions (MIME) [RFC2045] (see Appendix
      A of\n   [RFC7231] for the differences between HTTP and MIME messages).\n   Most
      HTTP communication consists of a retrieval request (GET) for a\n   representation
      of some resource identified by a URI.  In the simplest\n   case, this might
      be accomplished via a single bidirectional\n   connection (===) between the
      user agent (UA) and the origin\n   server (O).\n            request   >\n       UA
      ======================================= O\n                                   <
      \  response\n   A client sends an HTTP request to a server in the form of a
      request\n   message, beginning with a request-line that includes a method, URI,\n
      \  and protocol version (Section 3.1.1), followed by header fields\n   containing
      request modifiers, client information, and representation\n   metadata (Section
      3.2), an empty line to indicate the end of the\n   header section, and finally
      a message body containing the payload\n   body (if any, Section 3.3).\n   A
      server responds to a client's request by sending one or more HTTP\n   response
      messages, each beginning with a status line that includes\n   the protocol version,
      a success or error code, and textual reason\n   phrase (Section 3.1.2), possibly
      followed by header fields containing\n   server information, resource metadata,
      and representation metadata\n   (Section 3.2), an empty line to indicate the
      end of the header\n   section, and finally a message body containing the payload
      body (if\n   any, Section 3.3).\n   A connection might be used for multiple
      request/response exchanges,\n   as defined in Section 6.3.\n   The following
      example illustrates a typical message exchange for a\n   GET request (Section
      4.3.1 of [RFC7231]) on the URI\n   \"http://www.example.com/hello.txt\":\n   Client
      request:\n     GET /hello.txt HTTP/1.1\n     User-Agent: curl/7.16.3 libcurl/7.16.3
      OpenSSL/0.9.7l zlib/1.2.3\n     Host: www.example.com\n     Accept-Language:
      en, mi\n   Server response:\n     HTTP/1.1 200 OK\n     Date: Mon, 27 Jul 2009
      12:28:53 GMT\n     Server: Apache\n     Last-Modified: Wed, 22 Jul 2009 19:15:56
      GMT\n     ETag: \"34aa387-d-1568eb00\"\n     Accept-Ranges: bytes\n     Content-Length:
      51\n     Vary: Accept-Encoding\n     Content-Type: text/plain\n     Hello World!
      My payload includes a trailing CRLF.\n"
    title: 2.1.  Client/Server Messaging
  - contents:
    - "2.2.  Implementation Diversity\n   When considering the design of HTTP, it
      is easy to fall into a trap\n   of thinking that all user agents are general-purpose
      browsers and all\n   origin servers are large public websites.  That is not
      the case in\n   practice.  Common HTTP user agents include household appliances,\n
      \  stereos, scales, firmware update scripts, command-line programs,\n   mobile
      apps, and communication devices in a multitude of shapes and\n   sizes.  Likewise,
      common HTTP origin servers include home automation\n   units, configurable networking
      components, office machines,\n   autonomous robots, news feeds, traffic cameras,
      ad selectors, and\n   video-delivery platforms.\n   The term \"user agent\"
      does not imply that there is a human user\n   directly interacting with the
      software agent at the time of a\n   request.  In many cases, a user agent is
      installed or configured to\n   run in the background and save its results for
      later inspection (or\n   save only a subset of those results that might be interesting
      or\n   erroneous).  Spiders, for example, are typically given a start URI\n
      \  and configured to follow certain behavior while crawling the Web as a\n   hypertext
      graph.\n   The implementation diversity of HTTP means that not all user agents\n
      \  can make interactive suggestions to their user or provide adequate\n   warning
      for security or privacy concerns.  In the few cases where\n   this specification
      requires reporting of errors to the user, it is\n   acceptable for such reporting
      to only be observable in an error\n   console or log file.  Likewise, requirements
      that an automated action\n   be confirmed by the user before proceeding might
      be met via advance\n   configuration choices, run-time options, or simple avoidance
      of the\n   unsafe action; confirmation does not imply any specific user\n   interface
      or interruption of normal processing if the user has\n   already made that choice.\n"
    title: 2.2.  Implementation Diversity
  - contents:
    - "2.3.  Intermediaries\n   HTTP enables the use of intermediaries to satisfy
      requests through a\n   chain of connections.  There are three common forms of
      HTTP\n   intermediary: proxy, gateway, and tunnel.  In some cases, a single\n
      \  intermediary might act as an origin server, proxy, gateway, or\n   tunnel,
      switching behavior based on the nature of each request.\n            >             >
      \            >             >\n       UA =========== A =========== B ===========
      C =========== O\n                  <             <             <             <\n
      \  The figure above shows three intermediaries (A, B, and C) between the\n   user
      agent and origin server.  A request or response message that\n   travels the
      whole chain will pass through four separate connections.\n   Some HTTP communication
      options might apply only to the connection\n   with the nearest, non-tunnel
      neighbor, only to the endpoints of the\n   chain, or to all connections along
      the chain.  Although the diagram\n   is linear, each participant might be engaged
      in multiple,\n   simultaneous communications.  For example, B might be receiving\n
      \  requests from many clients other than A, and/or forwarding requests\n   to
      servers other than C, at the same time that it is handling A's\n   request.
      \ Likewise, later requests might be sent through a different\n   path of connections,
      often based on dynamic configuration for load\n   balancing.\n   The terms \"upstream\"
      and \"downstream\" are used to describe\n   directional requirements in relation
      to the message flow: all\n   messages flow from upstream to downstream.  The
      terms \"inbound\" and\n   \"outbound\" are used to describe directional requirements
      in relation\n   to the request route: \"inbound\" means toward the origin server
      and\n   \"outbound\" means toward the user agent.\n   A \"proxy\" is a message-forwarding
      agent that is selected by the\n   client, usually via local configuration rules,
      to receive requests\n   for some type(s) of absolute URI and attempt to satisfy
      those\n   requests via translation through the HTTP interface.  Some\n   translations
      are minimal, such as for proxy requests for \"http\" URIs,\n   whereas other
      requests might require translation to and from entirely\n   different application-level
      protocols.  Proxies are often used to\n   group an organization's HTTP requests
      through a common intermediary\n   for the sake of security, annotation services,
      or shared caching.\n   Some proxies are designed to apply transformations to
      selected\n   messages or payloads while they are being forwarded, as described
      in\n   Section 5.7.2.\n   A \"gateway\" (a.k.a. \"reverse proxy\") is an intermediary
      that acts as\n   an origin server for the outbound connection but translates
      received\n   requests and forwards them inbound to another server or servers.\n
      \  Gateways are often used to encapsulate legacy or untrusted\n   information
      services, to improve server performance through\n   \"accelerator\" caching,
      and to enable partitioning or load balancing\n   of HTTP services across multiple
      machines.\n   All HTTP requirements applicable to an origin server also apply
      to\n   the outbound communication of a gateway.  A gateway communicates with\n
      \  inbound servers using any protocol that it desires, including private\n   extensions
      to HTTP that are outside the scope of this specification.\n   However, an HTTP-to-HTTP
      gateway that wishes to interoperate with\n   third-party HTTP servers ought
      to conform to user agent requirements\n   on the gateway's inbound connection.\n
      \  A \"tunnel\" acts as a blind relay between two connections without\n   changing
      the messages.  Once active, a tunnel is not considered a\n   party to the HTTP
      communication, though the tunnel might have been\n   initiated by an HTTP request.
      \ A tunnel ceases to exist when both\n   ends of the relayed connection are
      closed.  Tunnels are used to\n   extend a virtual connection through an intermediary,
      such as when\n   Transport Layer Security (TLS, [RFC5246]) is used to establish\n
      \  confidential communication through a shared firewall proxy.\n   The above
      categories for intermediary only consider those acting as\n   participants in
      the HTTP communication.  There are also\n   intermediaries that can act on lower
      layers of the network protocol\n   stack, filtering or redirecting HTTP traffic
      without the knowledge or\n   permission of message senders.  Network intermediaries
      are\n   indistinguishable (at a protocol level) from a man-in-the-middle\n   attack,
      often introducing security flaws or interoperability problems\n   due to mistakenly
      violating HTTP semantics.\n   For example, an \"interception proxy\" [RFC3040]
      (also commonly known\n   as a \"transparent proxy\" [RFC1919] or \"captive portal\")
      differs from\n   an HTTP proxy because it is not selected by the client.  Instead,
      an\n   interception proxy filters or redirects outgoing TCP port 80 packets\n
      \  (and occasionally other common port traffic).  Interception proxies\n   are
      commonly found on public network access points, as a means of\n   enforcing
      account subscription prior to allowing use of non-local\n   Internet services,
      and within corporate firewalls to enforce network\n   usage policies.\n   HTTP
      is defined as a stateless protocol, meaning that each request\n   message can
      be understood in isolation.  Many implementations depend\n   on HTTP's stateless
      design in order to reuse proxied connections or\n   dynamically load balance
      requests across multiple servers.  Hence, a\n   server MUST NOT assume that
      two requests on the same connection are\n   from the same user agent unless
      the connection is secured and\n   specific to that agent.  Some non-standard
      HTTP extensions (e.g.,\n   [RFC4559]) have been known to violate this requirement,
      resulting in\n   security and interoperability problems.\n"
    title: 2.3.  Intermediaries
  - contents:
    - "2.4.  Caches\n   A \"cache\" is a local store of previous response messages
      and the\n   subsystem that controls its message storage, retrieval, and deletion.\n
      \  A cache stores cacheable responses in order to reduce the response\n   time
      and network bandwidth consumption on future, equivalent\n   requests.  Any client
      or server MAY employ a cache, though a cache\n   cannot be used by a server
      while it is acting as a tunnel.\n   The effect of a cache is that the request/response
      chain is shortened\n   if one of the participants along the chain has a cached
      response\n   applicable to that request.  The following illustrates the resulting\n
      \  chain if B has a cached copy of an earlier response from O (via C)\n   for
      a request that has not been cached by UA or A.\n               >             >\n
      \         UA =========== A =========== B - - - - - - C - - - - - - O\n                     <
      \            <\n   A response is \"cacheable\" if a cache is allowed to store
      a copy of\n   the response message for use in answering subsequent requests.
      \ Even\n   when a response is cacheable, there might be additional constraints\n
      \  placed by the client or by the origin server on when that cached\n   response
      can be used for a particular request.  HTTP requirements for\n   cache behavior
      and cacheable responses are defined in Section 2 of\n   [RFC7234].\n   There
      is a wide variety of architectures and configurations of caches\n   deployed
      across the World Wide Web and inside large organizations.\n   These include
      national hierarchies of proxy caches to save\n   transoceanic bandwidth, collaborative
      systems that broadcast or\n   multicast cache entries, archives of pre-fetched
      cache entries for\n   use in off-line or high-latency environments, and so on.\n"
    title: 2.4.  Caches
  - contents:
    - "2.5.  Conformance and Error Handling\n   This specification targets conformance
      criteria according to the role\n   of a participant in HTTP communication.  Hence,
      HTTP requirements are\n   placed on senders, recipients, clients, servers, user
      agents,\n   intermediaries, origin servers, proxies, gateways, or caches,\n
      \  depending on what behavior is being constrained by the requirement.\n   Additional
      (social) requirements are placed on implementations,\n   resource owners, and
      protocol element registrations when they apply\n   beyond the scope of a single
      communication.\n   The verb \"generate\" is used instead of \"send\" where a
      requirement\n   differentiates between creating a protocol element and merely\n
      \  forwarding a received element downstream.\n   An implementation is considered
      conformant if it complies with all of\n   the requirements associated with the
      roles it partakes in HTTP.\n   Conformance includes both the syntax and semantics
      of protocol\n   elements.  A sender MUST NOT generate protocol elements that
      convey a\n   meaning that is known by that sender to be false.  A sender MUST
      NOT\n   generate protocol elements that do not match the grammar defined by\n
      \  the corresponding ABNF rules.  Within a given message, a sender MUST\n   NOT
      generate protocol elements or syntax alternatives that are only\n   allowed
      to be generated by participants in other roles (i.e., a role\n   that the sender
      does not have for that message).\n   When a received protocol element is parsed,
      the recipient MUST be\n   able to parse any value of reasonable length that
      is applicable to\n   the recipient's role and that matches the grammar defined
      by the\n   corresponding ABNF rules.  Note, however, that some received protocol\n
      \  elements might not be parsed.  For example, an intermediary\n   forwarding
      a message might parse a header-field into generic\n   field-name and field-value
      components, but then forward the header\n   field without further parsing inside
      the field-value.\n   HTTP does not have specific length limitations for many
      of its\n   protocol elements because the lengths that might be appropriate will\n
      \  vary widely, depending on the deployment context and purpose of the\n   implementation.
      \ Hence, interoperability between senders and\n   recipients depends on shared
      expectations regarding what is a\n   reasonable length for each protocol element.
      \ Furthermore, what is\n   commonly understood to be a reasonable length for
      some protocol\n   elements has changed over the course of the past two decades
      of HTTP\n   use and is expected to continue changing in the future.\n   At a
      minimum, a recipient MUST be able to parse and process protocol\n   element
      lengths that are at least as long as the values that it\n   generates for those
      same protocol elements in other messages.  For\n   example, an origin server
      that publishes very long URI references to\n   its own resources needs to be
      able to parse and process those same\n   references when received as a request
      target.\n   A recipient MUST interpret a received protocol element according
      to\n   the semantics defined for it by this specification, including\n   extensions
      to this specification, unless the recipient has determined\n   (through experience
      or configuration) that the sender incorrectly\n   implements what is implied
      by those semantics.  For example, an\n   origin server might disregard the contents
      of a received\n   Accept-Encoding header field if inspection of the User-Agent
      header\n   field indicates a specific implementation version that is known to\n
      \  fail on receipt of certain content codings.\n   Unless noted otherwise, a
      recipient MAY attempt to recover a usable\n   protocol element from an invalid
      construct.  HTTP does not define\n   specific error handling mechanisms except
      when they have a direct\n   impact on security, since different applications
      of the protocol\n   require different error handling strategies.  For example,
      a Web\n   browser might wish to transparently recover from a response where
      the\n   Location header field doesn't parse according to the ABNF, whereas a\n
      \  systems control client might consider any form of error recovery to\n   be
      dangerous.\n"
    title: 2.5.  Conformance and Error Handling
  - contents:
    - "2.6.  Protocol Versioning\n   HTTP uses a \"<major>.<minor>\" numbering scheme
      to indicate versions\n   of the protocol.  This specification defines version
      \"1.1\".  The\n   protocol version as a whole indicates the sender's conformance
      with\n   the set of requirements laid out in that version's corresponding\n
      \  specification of HTTP.\n   The version of an HTTP message is indicated by
      an HTTP-version field\n   in the first line of the message.  HTTP-version is
      case-sensitive.\n     HTTP-version  = HTTP-name \"/\" DIGIT \".\" DIGIT\n     HTTP-name
      \    = %x48.54.54.50 ; \"HTTP\", case-sensitive\n   The HTTP version number
      consists of two decimal digits separated by a\n   \".\" (period or decimal point).
      \ The first digit (\"major version\")\n   indicates the HTTP messaging syntax,
      whereas the second digit (\"minor\n   version\") indicates the highest minor
      version within that major\n   version to which the sender is conformant and
      able to understand for\n   future communication.  The minor version advertises
      the sender's\n   communication capabilities even when the sender is only using
      a\n   backwards-compatible subset of the protocol, thereby letting the\n   recipient
      know that more advanced features can be used in response\n   (by servers) or
      in future requests (by clients).\n   When an HTTP/1.1 message is sent to an
      HTTP/1.0 recipient [RFC1945]\n   or a recipient whose version is unknown, the
      HTTP/1.1 message is\n   constructed such that it can be interpreted as a valid
      HTTP/1.0\n   message if all of the newer features are ignored.  This specification\n
      \  places recipient-version requirements on some new features so that a\n   conformant
      sender will only use compatible features until it has\n   determined, through
      configuration or the receipt of a message, that\n   the recipient supports HTTP/1.1.\n
      \  The interpretation of a header field does not change between minor\n   versions
      of the same major HTTP version, though the default behavior\n   of a recipient
      in the absence of such a field can change.  Unless\n   specified otherwise,
      header fields defined in HTTP/1.1 are defined\n   for all versions of HTTP/1.x.
      \ In particular, the Host and Connection\n   header fields ought to be implemented
      by all HTTP/1.x implementations\n   whether or not they advertise conformance
      with HTTP/1.1.\n   New header fields can be introduced without changing the
      protocol\n   version if their defined semantics allow them to be safely ignored
      by\n   recipients that do not recognize them.  Header field extensibility is\n
      \  discussed in Section 3.2.1.\n   Intermediaries that process HTTP messages
      (i.e., all intermediaries\n   other than those acting as tunnels) MUST send
      their own HTTP-version\n   in forwarded messages.  In other words, they are
      not allowed to\n   blindly forward the first line of an HTTP message without
      ensuring\n   that the protocol version in that message matches a version to
      which\n   that intermediary is conformant for both the receiving and sending
      of\n   messages.  Forwarding an HTTP message without rewriting the\n   HTTP-version
      might result in communication errors when downstream\n   recipients use the
      message sender's version to determine what\n   features are safe to use for
      later communication with that sender.\n   A client SHOULD send a request version
      equal to the highest version\n   to which the client is conformant and whose
      major version is no\n   higher than the highest version supported by the server,
      if this is\n   known.  A client MUST NOT send a version to which it is not\n
      \  conformant.\n   A client MAY send a lower request version if it is known
      that the\n   server incorrectly implements the HTTP specification, but only
      after\n   the client has attempted at least one normal request and determined\n
      \  from the response status code or header fields (e.g., Server) that\n   the
      server improperly handles higher request versions.\n   A server SHOULD send
      a response version equal to the highest version\n   to which the server is conformant
      that has a major version less than\n   or equal to the one received in the request.
      \ A server MUST NOT send\n   a version to which it is not conformant.  A server
      can send a 505\n   (HTTP Version Not Supported) response if it wishes, for any
      reason,\n   to refuse service of the client's major protocol version.\n   A
      server MAY send an HTTP/1.0 response to a request if it is known or\n   suspected
      that the client incorrectly implements the HTTP\n   specification and is incapable
      of correctly processing later version\n   responses, such as when a client fails
      to parse the version number\n   correctly or when an intermediary is known to
      blindly forward the\n   HTTP-version even when it doesn't conform to the given
      minor version\n   of the protocol.  Such protocol downgrades SHOULD NOT be performed\n
      \  unless triggered by specific client attributes, such as when one or\n   more
      of the request header fields (e.g., User-Agent) uniquely match\n   the values
      sent by a client known to be in error.\n   The intention of HTTP's versioning
      design is that the major number\n   will only be incremented if an incompatible
      message syntax is\n   introduced, and that the minor number will only be incremented
      when\n   changes made to the protocol have the effect of adding to the message\n
      \  semantics or implying additional capabilities of the sender.\n   However,
      the minor version was not incremented for the changes\n   introduced between
      [RFC2068] and [RFC2616], and this revision has\n   specifically avoided any
      such changes to the protocol.\n   When an HTTP message is received with a major
      version number that the\n   recipient implements, but a higher minor version
      number than what the\n   recipient implements, the recipient SHOULD process
      the message as if\n   it were in the highest minor version within that major
      version to\n   which the recipient is conformant.  A recipient can assume that
      a\n   message with a higher minor version, when sent to a recipient that\n   has
      not yet indicated support for that higher version, is\n   sufficiently backwards-compatible
      to be safely processed by any\n   implementation of the same major version.\n"
    title: 2.6.  Protocol Versioning
  - contents:
    - "2.7.  Uniform Resource Identifiers\n   Uniform Resource Identifiers (URIs)
      [RFC3986] are used throughout\n   HTTP as the means for identifying resources
      (Section 2 of [RFC7231]).\n   URI references are used to target requests, indicate
      redirects, and\n   define relationships.\n   The definitions of \"URI-reference\",
      \"absolute-URI\", \"relative-part\",\n   \"scheme\", \"authority\", \"port\",
      \"host\", \"path-abempty\", \"segment\",\n   \"query\", and \"fragment\" are
      adopted from the URI generic syntax.  An\n   \"absolute-path\" rule is defined
      for protocol elements that can\n   contain a non-empty path component.  (This
      rule differs slightly from\n   the path-abempty rule of RFC 3986, which allows
      for an empty path to\n   be used in references, and path-absolute rule, which
      does not allow\n   paths that begin with \"//\".)  A \"partial-URI\" rule is
      defined for\n   protocol elements that can contain a relative URI but not a
      fragment\n   component.\n     URI-reference = <URI-reference, see [RFC3986],
      Section 4.1>\n     absolute-URI  = <absolute-URI, see [RFC3986], Section 4.3>\n
      \    relative-part = <relative-part, see [RFC3986], Section 4.2>\n     scheme
      \       = <scheme, see [RFC3986], Section 3.1>\n     authority     = <authority,
      see [RFC3986], Section 3.2>\n     uri-host      = <host, see [RFC3986], Section
      3.2.2>\n     port          = <port, see [RFC3986], Section 3.2.3>\n     path-abempty
      \ = <path-abempty, see [RFC3986], Section 3.3>\n     segment       = <segment,
      see [RFC3986], Section 3.3>\n     query         = <query, see [RFC3986], Section
      3.4>\n     fragment      = <fragment, see [RFC3986], Section 3.5>\n     absolute-path
      = 1*( \"/\" segment )\n     partial-URI   = relative-part [ \"?\" query ]\n
      \  Each protocol element in HTTP that allows a URI reference will\n   indicate
      in its ABNF production whether the element allows any form\n   of reference
      (URI-reference), only a URI in absolute form\n   (absolute-URI), only the path
      and optional query components, or some\n   combination of the above.  Unless
      otherwise indicated, URI references\n   are parsed relative to the effective
      request URI (Section 5.5).\n"
    - contents:
      - "2.7.1.  http URI Scheme\n   The \"http\" URI scheme is hereby defined for
        the purpose of minting\n   identifiers according to their association with
        the hierarchical\n   namespace governed by a potential HTTP origin server
        listening for\n   TCP ([RFC0793]) connections on a given port.\n     http-URI
        = \"http:\" \"//\" authority path-abempty [ \"?\" query ]\n                [
        \"#\" fragment ]\n   The origin server for an \"http\" URI is identified by
        the authority\n   component, which includes a host identifier and optional
        TCP port\n   ([RFC3986], Section 3.2.2).  The hierarchical path component
        and\n   optional query component serve as an identifier for a potential\n
        \  target resource within that origin server's name space.  The optional\n
        \  fragment component allows for indirect identification of a secondary\n
        \  resource, independent of the URI scheme, as defined in Section 3.5 of\n
        \  [RFC3986].\n   A sender MUST NOT generate an \"http\" URI with an empty
        host\n   identifier.  A recipient that processes such a URI reference MUST\n
        \  reject it as invalid.\n   If the host identifier is provided as an IP address,
        the origin\n   server is the listener (if any) on the indicated TCP port at
        that IP\n   address.  If host is a registered name, the registered name is
        an\n   indirect identifier for use with a name resolution service, such as\n
        \  DNS, to find an address for that origin server.  If the port\n   subcomponent
        is empty or not given, TCP port 80 (the reserved port\n   for WWW services)
        is the default.\n   Note that the presence of a URI with a given authority
        component does\n   not imply that there is always an HTTP server listening
        for\n   connections on that host and port.  Anyone can mint a URI.  What the\n
        \  authority component determines is who has the right to respond\n   authoritatively
        to requests that target the identified resource.  The\n   delegated nature
        of registered names and IP addresses creates a\n   federated namespace, based
        on control over the indicated host and\n   port, whether or not an HTTP server
        is present.  See Section 9.1 for\n   security considerations related to establishing
        authority.\n   When an \"http\" URI is used within a context that calls for
        access to\n   the indicated resource, a client MAY attempt access by resolving
        the\n   host to an IP address, establishing a TCP connection to that address\n
        \  on the indicated port, and sending an HTTP request message\n   (Section
        3) containing the URI's identifying data (Section 5) to the\n   server.  If
        the server responds to that request with a non-interim\n   HTTP response message,
        as described in Section 6 of [RFC7231], then\n   that response is considered
        an authoritative answer to the client's\n   request.\n   Although HTTP is
        independent of the transport protocol, the \"http\"\n   scheme is specific
        to TCP-based services because the name delegation\n   process depends on TCP
        for establishing authority.  An HTTP service\n   based on some other underlying
        connection protocol would presumably\n   be identified using a different URI
        scheme, just as the \"https\"\n   scheme (below) is used for resources that
        require an end-to-end\n   secured connection.  Other protocols might also
        be used to provide\n   access to \"http\" identified resources -- it is only
        the authoritative\n   interface that is specific to TCP.\n   The URI generic
        syntax for authority also includes a deprecated\n   userinfo subcomponent
        ([RFC3986], Section 3.2.1) for including user\n   authentication information
        in the URI.  Some implementations make use\n   of the userinfo component for
        internal configuration of\n   authentication information, such as within command
        invocation\n   options, configuration files, or bookmark lists, even though
        such\n   usage might expose a user identifier or password.  A sender MUST
        NOT\n   generate the userinfo subcomponent (and its \"@\" delimiter) when
        an\n   \"http\" URI reference is generated within a message as a request\n
        \  target or header field value.  Before making use of an \"http\" URI\n   reference
        received from an untrusted source, a recipient SHOULD parse\n   for userinfo
        and treat its presence as an error; it is likely being\n   used to obscure
        the authority for the sake of phishing attacks.\n"
      title: 2.7.1.  http URI Scheme
    - contents:
      - "2.7.2.  https URI Scheme\n   The \"https\" URI scheme is hereby defined for
        the purpose of minting\n   identifiers according to their association with
        the hierarchical\n   namespace governed by a potential HTTP origin server
        listening to a\n   given TCP port for TLS-secured connections ([RFC5246]).\n
        \  All of the requirements listed above for the \"http\" scheme are also\n
        \  requirements for the \"https\" scheme, except that TCP port 443 is the\n
        \  default if the port subcomponent is empty or not given, and the user\n
        \  agent MUST ensure that its connection to the origin server is secured\n
        \  through the use of strong encryption, end-to-end, prior to sending\n   the
        first HTTP request.\n     https-URI = \"https:\" \"//\" authority path-abempty
        [ \"?\" query ]\n                 [ \"#\" fragment ]\n   Note that the \"https\"
        URI scheme depends on both TLS and TCP for\n   establishing authority.  Resources
        made available via the \"https\"\n   scheme have no shared identity with the
        \"http\" scheme even if their\n   resource identifiers indicate the same authority
        (the same host\n   listening to the same TCP port).  They are distinct namespaces
        and\n   are considered to be distinct origin servers.  However, an extension\n
        \  to HTTP that is defined to apply to entire host domains, such as the\n
        \  Cookie protocol [RFC6265], can allow information set by one service\n   to
        impact communication with other services within a matching group\n   of host
        domains.\n   The process for authoritative access to an \"https\" identified\n
        \  resource is defined in [RFC2818].\n"
      title: 2.7.2.  https URI Scheme
    - contents:
      - "2.7.3.  http and https URI Normalization and Comparison\n   Since the \"http\"
        and \"https\" schemes conform to the URI generic\n   syntax, such URIs are
        normalized and compared according to the\n   algorithm defined in Section
        6 of [RFC3986], using the defaults\n   described above for each scheme.\n
        \  If the port is equal to the default port for a scheme, the normal\n   form
        is to omit the port subcomponent.  When not being used in\n   absolute form
        as the request target of an OPTIONS request, an empty\n   path component is
        equivalent to an absolute path of \"/\", so the\n   normal form is to provide
        a path of \"/\" instead.  The scheme and host\n   are case-insensitive and
        normally provided in lowercase; all other\n   components are compared in a
        case-sensitive manner.  Characters other\n   than those in the \"reserved\"
        set are equivalent to their\n   percent-encoded octets: the normal form is
        to not encode them (see\n   Sections 2.1 and 2.2 of [RFC3986]).\n   For example,
        the following three URIs are equivalent:\n      http://example.com:80/~smith/home.html\n
        \     http://EXAMPLE.com/%7Esmith/home.html\n      http://EXAMPLE.com:/%7esmith/home.html\n"
      title: 2.7.3.  http and https URI Normalization and Comparison
    title: 2.7.  Uniform Resource Identifiers
  title: 2.  Architecture
- contents:
  - "3.  Message Format\n   All HTTP/1.1 messages consist of a start-line followed
    by a sequence\n   of octets in a format similar to the Internet Message Format\n
    \  [RFC5322]: zero or more header fields (collectively referred to as\n   the
    \"headers\" or the \"header section\"), an empty line indicating the\n   end of
    the header section, and an optional message body.\n     HTTP-message   = start-line\n
    \                     *( header-field CRLF )\n                      CRLF\n                      [
    message-body ]\n   The normal procedure for parsing an HTTP message is to read
    the\n   start-line into a structure, read each header field into a hash table\n
    \  by field name until the empty line, and then use the parsed data to\n   determine
    if a message body is expected.  If a message body has been\n   indicated, then
    it is read as a stream until an amount of octets\n   equal to the message body
    length is read or the connection is closed.\n   A recipient MUST parse an HTTP
    message as a sequence of octets in an\n   encoding that is a superset of US-ASCII
    [USASCII].  Parsing an HTTP\n   message as a stream of Unicode characters, without
    regard for the\n   specific encoding, creates security vulnerabilities due to
    the\n   varying ways that string processing libraries handle invalid\n   multibyte
    character sequences that contain the octet LF (%x0A).\n   String-based parsers
    can only be safely used within protocol elements\n   after the element has been
    extracted from the message, such as within\n   a header field-value after message
    parsing has delineated the\n   individual fields.\n   An HTTP message can be parsed
    as a stream for incremental processing\n   or forwarding downstream.  However,
    recipients cannot rely on\n   incremental delivery of partial messages, since
    some implementations\n   will buffer or delay message forwarding for the sake
    of network\n   efficiency, security checks, or payload transformations.\n   A
    sender MUST NOT send whitespace between the start-line and the\n   first header
    field.  A recipient that receives whitespace between the\n   start-line and the
    first header field MUST either reject the message\n   as invalid or consume each
    whitespace-preceded line without further\n   processing of it (i.e., ignore the
    entire line, along with any\n   subsequent lines preceded by whitespace, until
    a properly formed\n   header field is received or the header section is terminated).\n
    \  The presence of such whitespace in a request might be an attempt to\n   trick
    a server into ignoring that field or processing the line after\n   it as a new
    request, either of which might result in a security\n   vulnerability if other
    implementations within the request chain\n   interpret the same message differently.
    \ Likewise, the presence of\n   such whitespace in a response might be ignored
    by some clients or\n   cause others to cease parsing.\n"
  - contents:
    - "3.1.  Start Line\n   An HTTP message can be either a request from client to
      server or a\n   response from server to client.  Syntactically, the two types
      of\n   message differ only in the start-line, which is either a request-line\n
      \  (for requests) or a status-line (for responses), and in the algorithm\n   for
      determining the length of the message body (Section 3.3).\n   In theory, a client
      could receive requests and a server could receive\n   responses, distinguishing
      them by their different start-line formats,\n   but, in practice, servers are
      implemented to only expect a request (a\n   response is interpreted as an unknown
      or invalid request method) and\n   clients are implemented to only expect a
      response.\n     start-line     = request-line / status-line\n"
    - contents:
      - "3.1.1.  Request Line\n   A request-line begins with a method token, followed
        by a single space\n   (SP), the request-target, another single space (SP),
        the protocol\n   version, and ends with CRLF.\n     request-line   = method
        SP request-target SP HTTP-version CRLF\n   The method token indicates the
        request method to be performed on the\n   target resource.  The request method
        is case-sensitive.\n     method         = token\n   The request methods defined
        by this specification can be found in\n   Section 4 of [RFC7231], along with
        information regarding the HTTP\n   method registry and considerations for
        defining new methods.\n   The request-target identifies the target resource
        upon which to apply\n   the request, as defined in Section 5.3.\n   Recipients
        typically parse the request-line into its component parts\n   by splitting
        on whitespace (see Section 3.5), since no whitespace is\n   allowed in the
        three components.  Unfortunately, some user agents\n   fail to properly encode
        or exclude whitespace found in hypertext\n   references, resulting in those
        disallowed characters being sent in a\n   request-target.\n   Recipients of
        an invalid request-line SHOULD respond with either a\n   400 (Bad Request)
        error or a 301 (Moved Permanently) redirect with\n   the request-target properly
        encoded.  A recipient SHOULD NOT attempt\n   to autocorrect and then process
        the request without a redirect, since\n   the invalid request-line might be
        deliberately crafted to bypass\n   security filters along the request chain.\n
        \  HTTP does not place a predefined limit on the length of a\n   request-line,
        as described in Section 2.5.  A server that receives a\n   method longer than
        any that it implements SHOULD respond with a 501\n   (Not Implemented) status
        code.  A server that receives a\n   request-target longer than any URI it
        wishes to parse MUST respond\n   with a 414 (URI Too Long) status code (see
        Section 6.5.12 of\n   [RFC7231]).\n   Various ad hoc limitations on request-line
        length are found in\n   practice.  It is RECOMMENDED that all HTTP senders
        and recipients\n   support, at a minimum, request-line lengths of 8000 octets.\n"
      title: 3.1.1.  Request Line
    - contents:
      - "3.1.2.  Status Line\n   The first line of a response message is the status-line,
        consisting\n   of the protocol version, a space (SP), the status code, another\n
        \  space, a possibly empty textual phrase describing the status code,\n   and
        ending with CRLF.\n     status-line = HTTP-version SP status-code SP reason-phrase
        CRLF\n   The status-code element is a 3-digit integer code describing the\n
        \  result of the server's attempt to understand and satisfy the client's\n
        \  corresponding request.  The rest of the response message is to be\n   interpreted
        in light of the semantics defined for that status code.\n   See Section 6
        of [RFC7231] for information about the semantics of\n   status codes, including
        the classes of status code (indicated by the\n   first digit), the status
        codes defined by this specification,\n   considerations for the definition
        of new status codes, and the IANA\n   registry.\n     status-code    = 3DIGIT\n
        \  The reason-phrase element exists for the sole purpose of providing a\n
        \  textual description associated with the numeric status code, mostly\n   out
        of deference to earlier Internet application protocols that were\n   more
        frequently used with interactive text clients.  A client SHOULD\n   ignore
        the reason-phrase content.\n     reason-phrase  = *( HTAB / SP / VCHAR / obs-text
        )\n"
      title: 3.1.2.  Status Line
    title: 3.1.  Start Line
  - contents:
    - "3.2.  Header Fields\n   Each header field consists of a case-insensitive field
      name followed\n   by a colon (\":\"), optional leading whitespace, the field
      value, and\n   optional trailing whitespace.\n     header-field   = field-name
      \":\" OWS field-value OWS\n     field-name     = token\n     field-value    =
      *( field-content / obs-fold )\n     field-content  = field-vchar [ 1*( SP /
      HTAB ) field-vchar ]\n     field-vchar    = VCHAR / obs-text\n     obs-fold
      \      = CRLF 1*( SP / HTAB )\n                    ; obsolete line folding\n
      \                   ; see Section 3.2.4\n   The field-name token labels the
      corresponding field-value as having\n   the semantics defined by that header
      field.  For example, the Date\n   header field is defined in Section 7.1.1.2
      of [RFC7231] as containing\n   the origination timestamp for the message in
      which it appears.\n"
    - contents:
      - "3.2.1.  Field Extensibility\n   Header fields are fully extensible: there
        is no limit on the\n   introduction of new field names, each presumably defining
        new\n   semantics, nor on the number of header fields used in a given\n   message.
        \ Existing fields are defined in each part of this\n   specification and in
        many other specifications outside this document\n   set.\n   New header fields
        can be defined such that, when they are understood\n   by a recipient, they
        might override or enhance the interpretation of\n   previously defined header
        fields, define preconditions on request\n   evaluation, or refine the meaning
        of responses.\n   A proxy MUST forward unrecognized header fields unless the
        field-name\n   is listed in the Connection header field (Section 6.1) or the
        proxy\n   is specifically configured to block, or otherwise transform, such\n
        \  fields.  Other recipients SHOULD ignore unrecognized header fields.\n   These
        requirements allow HTTP's functionality to be enhanced without\n   requiring
        prior update of deployed intermediaries.\n   All defined header fields ought
        to be registered with IANA in the\n   \"Message Headers\" registry, as described
        in Section 8.3 of [RFC7231].\n"
      title: 3.2.1.  Field Extensibility
    - contents:
      - "3.2.2.  Field Order\n   The order in which header fields with differing field
        names are\n   received is not significant.  However, it is good practice to
        send\n   header fields that contain control data first, such as Host on\n
        \  requests and Date on responses, so that implementations can decide\n   when
        not to handle a message as early as possible.  A server MUST NOT\n   apply
        a request to the target resource until the entire request\n   header section
        is received, since later header fields might include\n   conditionals, authentication
        credentials, or deliberately misleading\n   duplicate header fields that would
        impact request processing.\n   A sender MUST NOT generate multiple header
        fields with the same field\n   name in a message unless either the entire
        field value for that\n   header field is defined as a comma-separated list
        [i.e., #(values)]\n   or the header field is a well-known exception (as noted
        below).\n   A recipient MAY combine multiple header fields with the same field\n
        \  name into one \"field-name: field-value\" pair, without changing the\n
        \  semantics of the message, by appending each subsequent field value to\n
        \  the combined field value in order, separated by a comma.  The order\n   in
        which header fields with the same field name are received is\n   therefore
        significant to the interpretation of the combined field\n   value; a proxy
        MUST NOT change the order of these field values when\n   forwarding a message.\n
        \     Note: In practice, the \"Set-Cookie\" header field ([RFC6265]) often\n
        \     appears multiple times in a response message and does not use the\n
        \     list syntax, violating the above requirements on multiple header\n      fields
        with the same name.  Since it cannot be combined into a\n      single field-value,
        recipients ought to handle \"Set-Cookie\" as a\n      special case while processing
        header fields.  (See Appendix A.2.3\n      of [Kri2001] for details.)\n"
      title: 3.2.2.  Field Order
    - contents:
      - "3.2.3.  Whitespace\n   This specification uses three rules to denote the
        use of linear\n   whitespace: OWS (optional whitespace), RWS (required whitespace),
        and\n   BWS (\"bad\" whitespace).\n   The OWS rule is used where zero or more
        linear whitespace octets\n   might appear.  For protocol elements where optional
        whitespace is\n   preferred to improve readability, a sender SHOULD generate
        the\n   optional whitespace as a single SP; otherwise, a sender SHOULD NOT\n
        \  generate optional whitespace except as needed to white out invalid or\n
        \  unwanted protocol elements during in-place message filtering.\n   The RWS
        rule is used when at least one linear whitespace octet is\n   required to
        separate field tokens.  A sender SHOULD generate RWS as a\n   single SP.\n
        \  The BWS rule is used where the grammar allows optional whitespace\n   only
        for historical reasons.  A sender MUST NOT generate BWS in\n   messages.  A
        recipient MUST parse for such bad whitespace and remove\n   it before interpreting
        the protocol element.\n     OWS            = *( SP / HTAB )\n                    ;
        optional whitespace\n     RWS            = 1*( SP / HTAB )\n                    ;
        required whitespace\n     BWS            = OWS\n                    ; \"bad\"
        whitespace\n"
      title: 3.2.3.  Whitespace
    - contents:
      - "3.2.4.  Field Parsing\n   Messages are parsed using a generic algorithm,
        independent of the\n   individual header field names.  The contents within
        a given field\n   value are not parsed until a later stage of message interpretation\n
        \  (usually after the message's entire header section has been\n   processed).
        \ Consequently, this specification does not use ABNF rules\n   to define each
        \"Field-Name: Field Value\" pair, as was done in\n   previous editions.  Instead,
        this specification uses ABNF rules that\n   are named according to each registered
        field name, wherein the rule\n   defines the valid grammar for that field's
        corresponding field values\n   (i.e., after the field-value has been extracted
        from the header\n   section by a generic field parser).\n   No whitespace
        is allowed between the header field-name and colon.  In\n   the past, differences
        in the handling of such whitespace have led to\n   security vulnerabilities
        in request routing and response handling.  A\n   server MUST reject any received
        request message that contains\n   whitespace between a header field-name and
        colon with a response code\n   of 400 (Bad Request).  A proxy MUST remove
        any such whitespace from a\n   response message before forwarding the message
        downstream.\n   A field value might be preceded and/or followed by optional\n
        \  whitespace (OWS); a single SP preceding the field-value is preferred\n
        \  for consistent readability by humans.  The field value does not\n   include
        any leading or trailing whitespace: OWS occurring before the\n   first non-whitespace
        octet of the field value or after the last\n   non-whitespace octet of the
        field value ought to be excluded by\n   parsers when extracting the field
        value from a header field.\n   Historically, HTTP header field values could
        be extended over\n   multiple lines by preceding each extra line with at least
        one space\n   or horizontal tab (obs-fold).  This specification deprecates
        such\n   line folding except within the message/http media type\n   (Section
        8.3.1).  A sender MUST NOT generate a message that includes\n   line folding
        (i.e., that has any field-value that contains a match to\n   the obs-fold
        rule) unless the message is intended for packaging\n   within the message/http
        media type.\n   A server that receives an obs-fold in a request message that
        is not\n   within a message/http container MUST either reject the message
        by\n   sending a 400 (Bad Request), preferably with a representation\n   explaining
        that obsolete line folding is unacceptable, or replace\n   each received obs-fold
        with one or more SP octets prior to\n   interpreting the field value or forwarding
        the message downstream.\n   A proxy or gateway that receives an obs-fold in
        a response message\n   that is not within a message/http container MUST either
        discard the\n   message and replace it with a 502 (Bad Gateway) response,
        preferably\n   with a representation explaining that unacceptable line folding
        was\n   received, or replace each received obs-fold with one or more SP\n
        \  octets prior to interpreting the field value or forwarding the\n   message
        downstream.\n   A user agent that receives an obs-fold in a response message
        that is\n   not within a message/http container MUST replace each received\n
        \  obs-fold with one or more SP octets prior to interpreting the field\n   value.\n
        \  Historically, HTTP has allowed field content with text in the\n   ISO-8859-1
        charset [ISO-8859-1], supporting other charsets only\n   through use of [RFC2047]
        encoding.  In practice, most HTTP header\n   field values use only a subset
        of the US-ASCII charset [USASCII].\n   Newly defined header fields SHOULD
        limit their field values to\n   US-ASCII octets.  A recipient SHOULD treat
        other octets in field\n   content (obs-text) as opaque data.\n"
      title: 3.2.4.  Field Parsing
    - contents:
      - "3.2.5.  Field Limits\n   HTTP does not place a predefined limit on the length
        of each header\n   field or on the length of the header section as a whole,
        as described\n   in Section 2.5.  Various ad hoc limitations on individual
        header\n   field length are found in practice, often depending on the specific\n
        \  field semantics.\n   A server that receives a request header field, or
        set of fields,\n   larger than it wishes to process MUST respond with an appropriate
        4xx\n   (Client Error) status code.  Ignoring such header fields would\n   increase
        the server's vulnerability to request smuggling attacks\n   (Section 9.5).\n
        \  A client MAY discard or truncate received header fields that are\n   larger
        than the client wishes to process if the field semantics are\n   such that
        the dropped value(s) can be safely ignored without changing\n   the message
        framing or response semantics.\n"
      title: 3.2.5.  Field Limits
    - contents:
      - "3.2.6.  Field Value Components\n   Most HTTP header field values are defined
        using common syntax\n   components (token, quoted-string, and comment) separated
        by\n   whitespace or specific delimiting characters.  Delimiters are chosen\n
        \  from the set of US-ASCII visual characters not allowed in a token\n   (DQUOTE
        and \"(),/:;<=>?@[\\]{}\").\n     token          = 1*tchar\n     tchar          =
        \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n                    /
        \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n                    /
        DIGIT / ALPHA\n                    ; any VCHAR, except delimiters\n   A string
        of text is parsed as a single value if it is quoted using\n   double-quote
        marks.\n     quoted-string  = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n     qdtext
        \        = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text\n     obs-text       =
        %x80-FF\n   Comments can be included in some HTTP header fields by surrounding\n
        \  the comment text with parentheses.  Comments are only allowed in\n   fields
        containing \"comment\" as part of their field value definition.\n     comment
        \       = \"(\" *( ctext / quoted-pair / comment ) \")\"\n     ctext          =
        HTAB / SP / %x21-27 / %x2A-5B / %x5D-7E / obs-text\n   The backslash octet
        (\"\\\") can be used as a single-octet quoting\n   mechanism within quoted-string
        and comment constructs.  Recipients\n   that process the value of a quoted-string
        MUST handle a quoted-pair\n   as if it were replaced by the octet following
        the backslash.\n     quoted-pair    = \"\\\" ( HTAB / SP / VCHAR / obs-text
        )\n   A sender SHOULD NOT generate a quoted-pair in a quoted-string except\n
        \  where necessary to quote DQUOTE and backslash octets occurring within\n
        \  that string.  A sender SHOULD NOT generate a quoted-pair in a comment\n
        \  except where necessary to quote parentheses [\"(\" and \")\"] and\n   backslash
        octets occurring within that comment.\n"
      title: 3.2.6.  Field Value Components
    title: 3.2.  Header Fields
  - contents:
    - "3.3.  Message Body\n   The message body (if any) of an HTTP message is used
      to carry the\n   payload body of that request or response.  The message body
      is\n   identical to the payload body unless a transfer coding has been\n   applied,
      as described in Section 3.3.1.\n     message-body = *OCTET\n   The rules for
      when a message body is allowed in a message differ for\n   requests and responses.\n
      \  The presence of a message body in a request is signaled by a\n   Content-Length
      or Transfer-Encoding header field.  Request message\n   framing is independent
      of method semantics, even if the method does\n   not define any use for a message
      body.\n   The presence of a message body in a response depends on both the\n
      \  request method to which it is responding and the response status code\n   (Section
      3.1.2).  Responses to the HEAD request method (Section 4.3.2\n   of [RFC7231])
      never include a message body because the associated\n   response header fields
      (e.g., Transfer-Encoding, Content-Length,\n   etc.), if present, indicate only
      what their values would have been if\n   the request method had been GET (Section
      4.3.1 of [RFC7231]). 2xx\n   (Successful) responses to a CONNECT request method
      (Section 4.3.6 of\n   [RFC7231]) switch to tunnel mode instead of having a message
      body.\n   All 1xx (Informational), 204 (No Content), and 304 (Not Modified)\n
      \  responses do not include a message body.  All other responses do\n   include
      a message body, although the body might be of zero length.\n"
    - contents:
      - "3.3.1.  Transfer-Encoding\n   The Transfer-Encoding header field lists the
        transfer coding names\n   corresponding to the sequence of transfer codings
        that have been (or\n   will be) applied to the payload body in order to form
        the message\n   body.  Transfer codings are defined in Section 4.\n     Transfer-Encoding
        = 1#transfer-coding\n   Transfer-Encoding is analogous to the Content-Transfer-Encoding
        field\n   of MIME, which was designed to enable safe transport of binary data\n
        \  over a 7-bit transport service ([RFC2045], Section 6).  However, safe\n
        \  transport has a different focus for an 8bit-clean transfer protocol.\n
        \  In HTTP's case, Transfer-Encoding is primarily intended to accurately\n
        \  delimit a dynamically generated payload and to distinguish payload\n   encodings
        that are only applied for transport efficiency or security\n   from those
        that are characteristics of the selected resource.\n   A recipient MUST be
        able to parse the chunked transfer coding\n   (Section 4.1) because it plays
        a crucial role in framing messages\n   when the payload body size is not known
        in advance.  A sender MUST\n   NOT apply chunked more than once to a message
        body (i.e., chunking an\n   already chunked message is not allowed).  If any
        transfer coding\n   other than chunked is applied to a request payload body,
        the sender\n   MUST apply chunked as the final transfer coding to ensure that
        the\n   message is properly framed.  If any transfer coding other than\n   chunked
        is applied to a response payload body, the sender MUST either\n   apply chunked
        as the final transfer coding or terminate the message\n   by closing the connection.\n
        \  For example,\n     Transfer-Encoding: gzip, chunked\n   indicates that
        the payload body has been compressed using the gzip\n   coding and then chunked
        using the chunked coding while forming the\n   message body.\n   Unlike Content-Encoding
        (Section 3.1.2.1 of [RFC7231]),\n   Transfer-Encoding is a property of the
        message, not of the\n   representation, and any recipient along the request/response
        chain\n   MAY decode the received transfer coding(s) or apply additional\n
        \  transfer coding(s) to the message body, assuming that corresponding\n   changes
        are made to the Transfer-Encoding field-value.  Additional\n   information
        about the encoding parameters can be provided by other\n   header fields not
        defined by this specification.\n   Transfer-Encoding MAY be sent in a response
        to a HEAD request or in a\n   304 (Not Modified) response (Section 4.1 of
        [RFC7232]) to a GET\n   request, neither of which includes a message body,
        to indicate that\n   the origin server would have applied a transfer coding
        to the message\n   body if the request had been an unconditional GET.  This
        indication\n   is not required, however, because any recipient on the response
        chain\n   (including the origin server) can remove transfer codings when they\n
        \  are not needed.\n   A server MUST NOT send a Transfer-Encoding header field
        in any\n   response with a status code of 1xx (Informational) or 204 (No\n
        \  Content).  A server MUST NOT send a Transfer-Encoding header field in\n
        \  any 2xx (Successful) response to a CONNECT request (Section 4.3.6 of\n
        \  [RFC7231]).\n   Transfer-Encoding was added in HTTP/1.1.  It is generally
        assumed\n   that implementations advertising only HTTP/1.0 support will not\n
        \  understand how to process a transfer-encoded payload.  A client MUST\n
        \  NOT send a request containing Transfer-Encoding unless it knows the\n   server
        will handle HTTP/1.1 (or later) requests; such knowledge might\n   be in the
        form of specific user configuration or by remembering the\n   version of a
        prior received response.  A server MUST NOT send a\n   response containing
        Transfer-Encoding unless the corresponding\n   request indicates HTTP/1.1
        (or later).\n   A server that receives a request message with a transfer coding
        it\n   does not understand SHOULD respond with 501 (Not Implemented).\n"
      title: 3.3.1.  Transfer-Encoding
    - contents:
      - "3.3.2.  Content-Length\n   When a message does not have a Transfer-Encoding
        header field, a\n   Content-Length header field can provide the anticipated
        size, as a\n   decimal number of octets, for a potential payload body.  For
        messages\n   that do include a payload body, the Content-Length field-value\n
        \  provides the framing information necessary for determining where the\n
        \  body (and message) ends.  For messages that do not include a payload\n
        \  body, the Content-Length indicates the size of the selected\n   representation
        (Section 3 of [RFC7231]).\n     Content-Length = 1*DIGIT\n   An example is\n
        \    Content-Length: 3495\n   A sender MUST NOT send a Content-Length header
        field in any message\n   that contains a Transfer-Encoding header field.\n
        \  A user agent SHOULD send a Content-Length in a request message when\n   no
        Transfer-Encoding is sent and the request method defines a meaning\n   for
        an enclosed payload body.  For example, a Content-Length header\n   field
        is normally sent in a POST request even when the value is 0\n   (indicating
        an empty payload body).  A user agent SHOULD NOT send a\n   Content-Length
        header field when the request message does not contain\n   a payload body
        and the method semantics do not anticipate such a\n   body.\n   A server MAY
        send a Content-Length header field in a response to a\n   HEAD request (Section
        4.3.2 of [RFC7231]); a server MUST NOT send\n   Content-Length in such a response
        unless its field-value equals the\n   decimal number of octets that would
        have been sent in the payload\n   body of a response if the same request had
        used the GET method.\n   A server MAY send a Content-Length header field in
        a 304 (Not\n   Modified) response to a conditional GET request (Section 4.1
        of\n   [RFC7232]); a server MUST NOT send Content-Length in such a response\n
        \  unless its field-value equals the decimal number of octets that would\n
        \  have been sent in the payload body of a 200 (OK) response to the same\n
        \  request.\n   A server MUST NOT send a Content-Length header field in any
        response\n   with a status code of 1xx (Informational) or 204 (No Content).
        \ A\n   server MUST NOT send a Content-Length header field in any 2xx\n   (Successful)
        response to a CONNECT request (Section 4.3.6 of\n   [RFC7231]).\n   Aside
        from the cases defined above, in the absence of\n   Transfer-Encoding, an
        origin server SHOULD send a Content-Length\n   header field when the payload
        body size is known prior to sending the\n   complete header section.  This
        will allow downstream recipients to\n   measure transfer progress, know when
        a received message is complete,\n   and potentially reuse the connection for
        additional requests.\n   Any Content-Length field value greater than or equal
        to zero is\n   valid.  Since there is no predefined limit to the length of
        a\n   payload, a recipient MUST anticipate potentially large decimal\n   numerals
        and prevent parsing errors due to integer conversion\n   overflows (Section
        9.3).\n   If a message is received that has multiple Content-Length header\n
        \  fields with field-values consisting of the same decimal value, or a\n   single
        Content-Length header field with a field value containing a\n   list of identical
        decimal values (e.g., \"Content-Length: 42, 42\"),\n   indicating that duplicate
        Content-Length header fields have been\n   generated or combined by an upstream
        message processor, then the\n   recipient MUST either reject the message as
        invalid or replace the\n   duplicated field-values with a single valid Content-Length
        field\n   containing that decimal value prior to determining the message body\n
        \  length or forwarding the message.\n      Note: HTTP's use of Content-Length
        for message framing differs\n      significantly from the same field's use
        in MIME, where it is an\n      optional field used only within the \"message/external-body\"\n
        \     media-type.\n"
      title: 3.3.2.  Content-Length
    - contents:
      - "3.3.3.  Message Body Length\n   The length of a message body is determined
        by one of the following\n   (in order of precedence):\n   1.  Any response
        to a HEAD request and any response with a 1xx\n       (Informational), 204
        (No Content), or 304 (Not Modified) status\n       code is always terminated
        by the first empty line after the\n       header fields, regardless of the
        header fields present in the\n       message, and thus cannot contain a message
        body.\n   2.  Any 2xx (Successful) response to a CONNECT request implies that\n
        \      the connection will become a tunnel immediately after the empty\n       line
        that concludes the header fields.  A client MUST ignore any\n       Content-Length
        or Transfer-Encoding header fields received in\n       such a message.\n   3.
        \ If a Transfer-Encoding header field is present and the chunked\n       transfer
        coding (Section 4.1) is the final encoding, the message\n       body length
        is determined by reading and decoding the chunked\n       data until the transfer
        coding indicates the data is complete.\n       If a Transfer-Encoding header
        field is present in a response and\n       the chunked transfer coding is
        not the final encoding, the\n       message body length is determined by reading
        the connection until\n       it is closed by the server.  If a Transfer-Encoding
        header field\n       is present in a request and the chunked transfer coding
        is not\n       the final encoding, the message body length cannot be determined\n
        \      reliably; the server MUST respond with the 400 (Bad Request)\n       status
        code and then close the connection.\n       If a message is received with
        both a Transfer-Encoding and a\n       Content-Length header field, the Transfer-Encoding
        overrides the\n       Content-Length.  Such a message might indicate an attempt
        to\n       perform request smuggling (Section 9.5) or response splitting\n
        \      (Section 9.4) and ought to be handled as an error.  A sender MUST\n
        \      remove the received Content-Length field prior to forwarding such\n
        \      a message downstream.\n   4.  If a message is received without Transfer-Encoding
        and with\n       either multiple Content-Length header fields having differing\n
        \      field-values or a single Content-Length header field having an\n       invalid
        value, then the message framing is invalid and the\n       recipient MUST
        treat it as an unrecoverable error.  If this is a\n       request message,
        the server MUST respond with a 400 (Bad Request)\n       status code and then
        close the connection.  If this is a response\n       message received by a
        proxy, the proxy MUST close the connection\n       to the server, discard
        the received response, and send a 502 (Bad\n       Gateway) response to the
        client.  If this is a response message\n       received by a user agent, the
        user agent MUST close the\n       connection to the server and discard the
        received response.\n   5.  If a valid Content-Length header field is present
        without\n       Transfer-Encoding, its decimal value defines the expected
        message\n       body length in octets.  If the sender closes the connection
        or\n       the recipient times out before the indicated number of octets are\n
        \      received, the recipient MUST consider the message to be\n       incomplete
        and close the connection.\n   6.  If this is a request message and none of
        the above are true, then\n       the message body length is zero (no message
        body is present).\n   7.  Otherwise, this is a response message without a
        declared message\n       body length, so the message body length is determined
        by the\n       number of octets received prior to the server closing the\n
        \      connection.\n   Since there is no way to distinguish a successfully
        completed,\n   close-delimited message from a partially received message interrupted\n
        \  by network failure, a server SHOULD generate encoding or\n   length-delimited
        messages whenever possible.  The close-delimiting\n   feature exists primarily
        for backwards compatibility with HTTP/1.0.\n   A server MAY reject a request
        that contains a message body but not a\n   Content-Length by responding with
        411 (Length Required).\n   Unless a transfer coding other than chunked has
        been applied, a\n   client that sends a request containing a message body
        SHOULD use a\n   valid Content-Length header field if the message body length
        is known\n   in advance, rather than the chunked transfer coding, since some\n
        \  existing services respond to chunked with a 411 (Length Required)\n   status
        code even though they understand the chunked transfer coding.\n   This is
        typically because such services are implemented via a gateway\n   that requires
        a content-length in advance of being called and the\n   server is unable or
        unwilling to buffer the entire request before\n   processing.\n   A user agent
        that sends a request containing a message body MUST send\n   a valid Content-Length
        header field if it does not know the server\n   will handle HTTP/1.1 (or later)
        requests; such knowledge can be in\n   the form of specific user configuration
        or by remembering the version\n   of a prior received response.\n   If the
        final response to the last request on a connection has been\n   completely
        received and there remains additional data to read, a user\n   agent MAY discard
        the remaining data or attempt to determine if that\n   data belongs as part
        of the prior response body, which might be the\n   case if the prior message's
        Content-Length value is incorrect.  A\n   client MUST NOT process, cache,
        or forward such extra data as a\n   separate response, since such behavior
        would be vulnerable to cache\n   poisoning.\n"
      title: 3.3.3.  Message Body Length
    title: 3.3.  Message Body
  - contents:
    - "3.4.  Handling Incomplete Messages\n   A server that receives an incomplete
      request message, usually due to\n   a canceled request or a triggered timeout
      exception, MAY send an\n   error response prior to closing the connection.\n
      \  A client that receives an incomplete response message, which can\n   occur
      when a connection is closed prematurely or when decoding a\n   supposedly chunked
      transfer coding fails, MUST record the message as\n   incomplete.  Cache requirements
      for incomplete responses are defined\n   in Section 3 of [RFC7234].\n   If a
      response terminates in the middle of the header section (before\n   the empty
      line is received) and the status code might rely on header\n   fields to convey
      the full meaning of the response, then the client\n   cannot assume that meaning
      has been conveyed; the client might need\n   to repeat the request in order
      to determine what action to take next.\n   A message body that uses the chunked
      transfer coding is incomplete if\n   the zero-sized chunk that terminates the
      encoding has not been\n   received.  A message that uses a valid Content-Length
      is incomplete\n   if the size of the message body received (in octets) is less
      than the\n   value given by Content-Length.  A response that has neither chunked\n
      \  transfer coding nor Content-Length is terminated by closure of the\n   connection
      and, thus, is considered complete regardless of the number\n   of message body
      octets received, provided that the header section was\n   received intact.\n"
    title: 3.4.  Handling Incomplete Messages
  - contents:
    - "3.5.  Message Parsing Robustness\n   Older HTTP/1.0 user agent implementations
      might send an extra CRLF\n   after a POST request as a workaround for some early
      server\n   applications that failed to read message body content that was not\n
      \  terminated by a line-ending.  An HTTP/1.1 user agent MUST NOT preface\n   or
      follow a request with an extra CRLF.  If terminating the request\n   message
      body with a line-ending is desired, then the user agent MUST\n   count the terminating
      CRLF octets as part of the message body length.\n   In the interest of robustness,
      a server that is expecting to receive\n   and parse a request-line SHOULD ignore
      at least one empty line (CRLF)\n   received prior to the request-line.\n   Although
      the line terminator for the start-line and header fields is\n   the sequence
      CRLF, a recipient MAY recognize a single LF as a line\n   terminator and ignore
      any preceding CR.\n   Although the request-line and status-line grammar rules
      require that\n   each of the component elements be separated by a single SP
      octet,\n   recipients MAY instead parse on whitespace-delimited word boundaries\n
      \  and, aside from the CRLF terminator, treat any form of whitespace as\n   the
      SP separator while ignoring preceding or trailing whitespace;\n   such whitespace
      includes one or more of the following octets: SP,\n   HTAB, VT (%x0B), FF (%x0C),
      or bare CR.  However, lenient parsing can\n   result in security vulnerabilities
      if there are multiple recipients\n   of the message and each has its own unique
      interpretation of\n   robustness (see Section 9.5).\n   When a server listening
      only for HTTP request messages, or processing\n   what appears from the start-line
      to be an HTTP request message,\n   receives a sequence of octets that does not
      match the HTTP-message\n   grammar aside from the robustness exceptions listed
      above, the server\n   SHOULD respond with a 400 (Bad Request) response.\n"
    title: 3.5.  Message Parsing Robustness
  title: 3.  Message Format
- contents:
  - "4.  Transfer Codings\n   Transfer coding names are used to indicate an encoding
    transformation\n   that has been, can be, or might need to be applied to a payload
    body\n   in order to ensure \"safe transport\" through the network.  This\n   differs
    from a content coding in that the transfer coding is a\n   property of the message
    rather than a property of the representation\n   that is being transferred.\n
    \    transfer-coding    = \"chunked\" ; Section 4.1\n                        /
    \"compress\" ; Section 4.2.1\n                        / \"deflate\" ; Section
    4.2.2\n                        / \"gzip\" ; Section 4.2.3\n                        /
    transfer-extension\n     transfer-extension = token *( OWS \";\" OWS transfer-parameter
    )\n   Parameters are in the form of a name or name=value pair.\n     transfer-parameter
    = token BWS \"=\" BWS ( token / quoted-string )\n   All transfer-coding names
    are case-insensitive and ought to be\n   registered within the HTTP Transfer Coding
    registry, as defined in\n   Section 8.4.  They are used in the TE (Section 4.3)
    and\n   Transfer-Encoding (Section 3.3.1) header fields.\n"
  - contents:
    - "4.1.  Chunked Transfer Coding\n   The chunked transfer coding wraps the payload
      body in order to\n   transfer it as a series of chunks, each with its own size
      indicator,\n   followed by an OPTIONAL trailer containing header fields.  Chunked\n
      \  enables content streams of unknown size to be transferred as a\n   sequence
      of length-delimited buffers, which enables the sender to\n   retain connection
      persistence and the recipient to know when it has\n   received the entire message.\n
      \    chunked-body   = *chunk\n                      last-chunk\n                      trailer-part\n
      \                     CRLF\n     chunk          = chunk-size [ chunk-ext ] CRLF\n
      \                     chunk-data CRLF\n     chunk-size     = 1*HEXDIG\n     last-chunk
      \    = 1*(\"0\") [ chunk-ext ] CRLF\n     chunk-data     = 1*OCTET ; a sequence
      of chunk-size octets\n   The chunk-size field is a string of hex digits indicating
      the size of\n   the chunk-data in octets.  The chunked transfer coding is complete\n
      \  when a chunk with a chunk-size of zero is received, possibly followed\n   by
      a trailer, and finally terminated by an empty line.\n   A recipient MUST be
      able to parse and decode the chunked transfer\n   coding.\n"
    - contents:
      - "4.1.1.  Chunk Extensions\n   The chunked encoding allows each chunk to include
        zero or more chunk\n   extensions, immediately following the chunk-size, for
        the sake of\n   supplying per-chunk metadata (such as a signature or hash),\n
        \  mid-message control information, or randomization of message body\n   size.\n
        \    chunk-ext      = *( \";\" chunk-ext-name [ \"=\" chunk-ext-val ] )\n
        \    chunk-ext-name = token\n     chunk-ext-val  = token / quoted-string\n
        \  The chunked encoding is specific to each connection and is likely to\n
        \  be removed or recoded by each recipient (including intermediaries)\n   before
        any higher-level application would have a chance to inspect\n   the extensions.
        \ Hence, use of chunk extensions is generally limited\n   to specialized HTTP
        services such as \"long polling\" (where client and\n   server can have shared
        expectations regarding the use of chunk\n   extensions) or for padding within
        an end-to-end secured connection.\n   A recipient MUST ignore unrecognized
        chunk extensions.  A server\n   ought to limit the total length of chunk extensions
        received in a\n   request to an amount reasonable for the services provided,
        in the\n   same way that it applies length limitations and timeouts for other\n
        \  parts of a message, and generate an appropriate 4xx (Client Error)\n   response
        if that amount is exceeded.\n"
      title: 4.1.1.  Chunk Extensions
    - contents:
      - "4.1.2.  Chunked Trailer Part\n   A trailer allows the sender to include additional
        fields at the end\n   of a chunked message in order to supply metadata that
        might be\n   dynamically generated while the message body is sent, such as
        a\n   message integrity check, digital signature, or post-processing\n   status.
        \ The trailer fields are identical to header fields, except\n   they are sent
        in a chunked trailer instead of the message's header\n   section.\n     trailer-part
        \  = *( header-field CRLF )\n   A sender MUST NOT generate a trailer that
        contains a field necessary\n   for message framing (e.g., Transfer-Encoding
        and Content-Length),\n   routing (e.g., Host), request modifiers (e.g., controls
        and\n   conditionals in Section 5 of [RFC7231]), authentication (e.g., see\n
        \  [RFC7235] and [RFC6265]), response control data (e.g., see Section\n   7.1
        of [RFC7231]), or determining how to process the payload (e.g.,\n   Content-Encoding,
        Content-Type, Content-Range, and Trailer).\n   When a chunked message containing
        a non-empty trailer is received,\n   the recipient MAY process the fields
        (aside from those forbidden\n   above) as if they were appended to the message's
        header section.  A\n   recipient MUST ignore (or consider as an error) any
        fields that are\n   forbidden to be sent in a trailer, since processing them
        as if they\n   were present in the header section might bypass external security\n
        \  filters.\n   Unless the request includes a TE header field indicating \"trailers\"\n
        \  is acceptable, as described in Section 4.3, a server SHOULD NOT\n   generate
        trailer fields that it believes are necessary for the user\n   agent to receive.
        \ Without a TE containing \"trailers\", the server\n   ought to assume that
        the trailer fields might be silently discarded\n   along the path to the user
        agent.  This requirement allows\n   intermediaries to forward a de-chunked
        message to an HTTP/1.0\n   recipient without buffering the entire response.\n"
      title: 4.1.2.  Chunked Trailer Part
    - contents:
      - "4.1.3.  Decoding Chunked\n   A process for decoding the chunked transfer
        coding can be represented\n   in pseudo-code as:\n     length := 0\n     read
        chunk-size, chunk-ext (if any), and CRLF\n     while (chunk-size > 0) {\n
        \       read chunk-data and CRLF\n        append chunk-data to decoded-body\n
        \       length := length + chunk-size\n        read chunk-size, chunk-ext
        (if any), and CRLF\n     }\n     read trailer field\n     while (trailer field
        is not empty) {\n        if (trailer field is allowed to be sent in a trailer)
        {\n            append trailer field to existing header fields\n        }\n
        \       read trailer-field\n     }\n     Content-Length := length\n     Remove
        \"chunked\" from Transfer-Encoding\n     Remove Trailer from existing header
        fields\n"
      title: 4.1.3.  Decoding Chunked
    title: 4.1.  Chunked Transfer Coding
  - contents:
    - "4.2.  Compression Codings\n   The codings defined below can be used to compress
      the payload of a\n   message.\n"
    - contents:
      - "4.2.1.  Compress Coding\n   The \"compress\" coding is an adaptive Lempel-Ziv-Welch
        (LZW) coding\n   [Welch] that is commonly produced by the UNIX file compression\n
        \  program \"compress\".  A recipient SHOULD consider \"x-compress\" to be\n
        \  equivalent to \"compress\".\n"
      title: 4.2.1.  Compress Coding
    - contents:
      - "4.2.2.  Deflate Coding\n   The \"deflate\" coding is a \"zlib\" data format
        [RFC1950] containing a\n   \"deflate\" compressed data stream [RFC1951] that
        uses a combination of\n   the Lempel-Ziv (LZ77) compression algorithm and
        Huffman coding.\n      Note: Some non-conformant implementations send the
        \"deflate\"\n      compressed data without the zlib wrapper.\n"
      title: 4.2.2.  Deflate Coding
    - contents:
      - "4.2.3.  Gzip Coding\n   The \"gzip\" coding is an LZ77 coding with a 32-bit
        Cyclic Redundancy\n   Check (CRC) that is commonly produced by the gzip file
        compression\n   program [RFC1952].  A recipient SHOULD consider \"x-gzip\"
        to be\n   equivalent to \"gzip\".\n"
      title: 4.2.3.  Gzip Coding
    title: 4.2.  Compression Codings
  - contents:
    - "4.3.  TE\n   The \"TE\" header field in a request indicates what transfer codings,\n
      \  besides chunked, the client is willing to accept in response, and\n   whether
      or not the client is willing to accept trailer fields in a\n   chunked transfer
      coding.\n   The TE field-value consists of a comma-separated list of transfer\n
      \  coding names, each allowing for optional parameters (as described in\n   Section
      4), and/or the keyword \"trailers\".  A client MUST NOT send\n   the chunked
      transfer coding name in TE; chunked is always acceptable\n   for HTTP/1.1 recipients.\n
      \    TE        = #t-codings\n     t-codings = \"trailers\" / ( transfer-coding
      [ t-ranking ] )\n     t-ranking = OWS \";\" OWS \"q=\" rank\n     rank      =
      ( \"0\" [ \".\" 0*3DIGIT ] )\n                / ( \"1\" [ \".\" 0*3(\"0\") ]
      )\n   Three examples of TE use are below.\n     TE: deflate\n     TE:\n     TE:
      trailers, deflate;q=0.5\n   The presence of the keyword \"trailers\" indicates
      that the client is\n   willing to accept trailer fields in a chunked transfer
      coding, as\n   defined in Section 4.1.2, on behalf of itself and any downstream\n
      \  clients.  For requests from an intermediary, this implies that\n   either:
      (a) all downstream clients are willing to accept trailer\n   fields in the forwarded
      response; or, (b) the intermediary will\n   attempt to buffer the response on
      behalf of downstream recipients.\n   Note that HTTP/1.1 does not define any
      means to limit the size of a\n   chunked response such that an intermediary
      can be assured of\n   buffering the entire response.\n   When multiple transfer
      codings are acceptable, the client MAY rank\n   the codings by preference using
      a case-insensitive \"q\" parameter\n   (similar to the qvalues used in content
      negotiation fields, Section\n   5.3.1 of [RFC7231]).  The rank value is a real
      number in the range 0\n   through 1, where 0.001 is the least preferred and
      1 is the most\n   preferred; a value of 0 means \"not acceptable\".\n   If the
      TE field-value is empty or if no TE field is present, the only\n   acceptable
      transfer coding is chunked.  A message with no transfer\n   coding is always
      acceptable.\n   Since the TE header field only applies to the immediate connection,
      a\n   sender of TE MUST also send a \"TE\" connection option within the\n   Connection
      header field (Section 6.1) in order to prevent the TE\n   field from being forwarded
      by intermediaries that do not support its\n   semantics.\n"
    title: 4.3.  TE
  - contents:
    - "4.4.  Trailer\n   When a message includes a message body encoded with the chunked\n
      \  transfer coding and the sender desires to send metadata in the form\n   of
      trailer fields at the end of the message, the sender SHOULD\n   generate a Trailer
      header field before the message body to indicate\n   which fields will be present
      in the trailers.  This allows the\n   recipient to prepare for receipt of that
      metadata before it starts\n   processing the body, which is useful if the message
      is being streamed\n   and the recipient wishes to confirm an integrity check
      on the fly.\n     Trailer = 1#field-name\n"
    title: 4.4.  Trailer
  title: 4.  Transfer Codings
- contents:
  - "5.  Message Routing\n   HTTP request message routing is determined by each client
    based on\n   the target resource, the client's proxy configuration, and\n   establishment
    or reuse of an inbound connection.  The corresponding\n   response routing follows
    the same connection chain back to the\n   client.\n"
  - contents:
    - "5.1.  Identifying a Target Resource\n   HTTP is used in a wide variety of applications,
      ranging from\n   general-purpose computers to home appliances.  In some cases,\n
      \  communication options are hard-coded in a client's configuration.\n   However,
      most HTTP clients rely on the same resource identification\n   mechanism and
      configuration techniques as general-purpose Web\n   browsers.\n   HTTP communication
      is initiated by a user agent for some purpose.\n   The purpose is a combination
      of request semantics, which are defined\n   in [RFC7231], and a target resource
      upon which to apply those\n   semantics.  A URI reference (Section 2.7) is typically
      used as an\n   identifier for the \"target resource\", which a user agent would\n
      \  resolve to its absolute form in order to obtain the \"target URI\".\n   The
      target URI excludes the reference's fragment component, if any,\n   since fragment
      identifiers are reserved for client-side processing\n   ([RFC3986], Section
      3.5).\n"
    title: 5.1.  Identifying a Target Resource
  - contents:
    - "5.2.  Connecting Inbound\n   Once the target URI is determined, a client needs
      to decide whether a\n   network request is necessary to accomplish the desired
      semantics and,\n   if so, where that request is to be directed.\n   If the client
      has a cache [RFC7234] and the request can be satisfied\n   by it, then the request
      is usually directed there first.\n   If the request is not satisfied by a cache,
      then a typical client\n   will check its configuration to determine whether
      a proxy is to be\n   used to satisfy the request.  Proxy configuration is implementation-\n
      \  dependent, but is often based on URI prefix matching, selective\n   authority
      matching, or both, and the proxy itself is usually\n   identified by an \"http\"
      or \"https\" URI.  If a proxy is applicable,\n   the client connects inbound
      by establishing (or reusing) a connection\n   to that proxy.\n   If no proxy
      is applicable, a typical client will invoke a handler\n   routine, usually specific
      to the target URI's scheme, to connect\n   directly to an authority for the
      target resource.  How that is\n   accomplished is dependent on the target URI
      scheme and defined by its\n   associated specification, similar to how this
      specification defines\n   origin server access for resolution of the \"http\"
      (Section 2.7.1) and\n   \"https\" (Section 2.7.2) schemes.\n   HTTP requirements
      regarding connection management are defined in\n   Section 6.\n"
    title: 5.2.  Connecting Inbound
  - contents:
    - "5.3.  Request Target\n   Once an inbound connection is obtained, the client
      sends an HTTP\n   request message (Section 3) with a request-target derived
      from the\n   target URI.  There are four distinct formats for the request-target,\n
      \  depending on both the method being requested and whether the request\n   is
      to a proxy.\n     request-target = origin-form\n                    / absolute-form\n
      \                   / authority-form\n                    / asterisk-form\n"
    - contents:
      - "5.3.1.  origin-form\n   The most common form of request-target is the origin-form.\n
        \    origin-form    = absolute-path [ \"?\" query ]\n   When making a request
        directly to an origin server, other than a\n   CONNECT or server-wide OPTIONS
        request (as detailed below), a client\n   MUST send only the absolute path
        and query components of the target\n   URI as the request-target.  If the
        target URI's path component is\n   empty, the client MUST send \"/\" as the
        path within the origin-form of\n   request-target.  A Host header field is
        also sent, as defined in\n   Section 5.4.\n   For example, a client wishing
        to retrieve a representation of the\n   resource identified as\n     http://www.example.org/where?q=now\n
        \  directly from the origin server would open (or reuse) a TCP\n   connection
        to port 80 of the host \"www.example.org\" and send the\n   lines:\n     GET
        /where?q=now HTTP/1.1\n     Host: www.example.org\n   followed by the remainder
        of the request message.\n"
      title: 5.3.1.  origin-form
    - contents:
      - "5.3.2.  absolute-form\n   When making a request to a proxy, other than a
        CONNECT or server-wide\n   OPTIONS request (as detailed below), a client MUST
        send the target\n   URI in absolute-form as the request-target.\n     absolute-form
        \ = absolute-URI\n   The proxy is requested to either service that request
        from a valid\n   cache, if possible, or make the same request on the client's
        behalf\n   to either the next inbound proxy server or directly to the origin\n
        \  server indicated by the request-target.  Requirements on such\n   \"forwarding\"
        of messages are defined in Section 5.7.\n   An example absolute-form of request-line
        would be:\n     GET http://www.example.org/pub/WWW/TheProject.html HTTP/1.1\n
        \  To allow for transition to the absolute-form for all requests in some\n
        \  future version of HTTP, a server MUST accept the absolute-form in\n   requests,
        even though HTTP/1.1 clients will only send them in\n   requests to proxies.\n"
      title: 5.3.2.  absolute-form
    - contents:
      - "5.3.3.  authority-form\n   The authority-form of request-target is only used
        for CONNECT\n   requests (Section 4.3.6 of [RFC7231]).\n     authority-form
        = authority\n   When making a CONNECT request to establish a tunnel through
        one or\n   more proxies, a client MUST send only the target URI's authority\n
        \  component (excluding any userinfo and its \"@\" delimiter) as the\n   request-target.
        \ For example,\n     CONNECT www.example.com:80 HTTP/1.1\n"
      title: 5.3.3.  authority-form
    - contents:
      - "5.3.4.  asterisk-form\n   The asterisk-form of request-target is only used
        for a server-wide\n   OPTIONS request (Section 4.3.7 of [RFC7231]).\n     asterisk-form
        \ = \"*\"\n   When a client wishes to request OPTIONS for the server as a
        whole, as\n   opposed to a specific named resource of that server, the client
        MUST\n   send only \"*\" (%x2A) as the request-target.  For example,\n     OPTIONS
        * HTTP/1.1\n   If a proxy receives an OPTIONS request with an absolute-form
        of\n   request-target in which the URI has an empty path and no query\n   component,
        then the last proxy on the request chain MUST send a\n   request-target of
        \"*\" when it forwards the request to the indicated\n   origin server.\n   For
        example, the request\n     OPTIONS http://www.example.org:8001 HTTP/1.1\n
        \  would be forwarded by the final proxy as\n     OPTIONS * HTTP/1.1\n     Host:
        www.example.org:8001\n   after connecting to port 8001 of host \"www.example.org\".\n"
      title: 5.3.4.  asterisk-form
    title: 5.3.  Request Target
  - contents:
    - "5.4.  Host\n   The \"Host\" header field in a request provides the host and
      port\n   information from the target URI, enabling the origin server to\n   distinguish
      among resources while servicing requests for multiple\n   host names on a single
      IP address.\n     Host = uri-host [ \":\" port ] ; Section 2.7.1\n   A client
      MUST send a Host header field in all HTTP/1.1 request\n   messages.  If the
      target URI includes an authority component, then a\n   client MUST send a field-value
      for Host that is identical to that\n   authority component, excluding any userinfo
      subcomponent and its \"@\"\n   delimiter (Section 2.7.1).  If the authority
      component is missing or\n   undefined for the target URI, then a client MUST
      send a Host header\n   field with an empty field-value.\n   Since the Host field-value
      is critical information for handling a\n   request, a user agent SHOULD generate
      Host as the first header field\n   following the request-line.\n   For example,
      a GET request to the origin server for\n   <http://www.example.org/pub/WWW/>
      would begin with:\n     GET /pub/WWW/ HTTP/1.1\n     Host: www.example.org\n
      \  A client MUST send a Host header field in an HTTP/1.1 request even if\n   the
      request-target is in the absolute-form, since this allows the\n   Host information
      to be forwarded through ancient HTTP/1.0 proxies\n   that might not have implemented
      Host.\n   When a proxy receives a request with an absolute-form of\n   request-target,
      the proxy MUST ignore the received Host header field\n   (if any) and instead
      replace it with the host information of the\n   request-target.  A proxy that
      forwards such a request MUST generate a\n   new Host field-value based on the
      received request-target rather than\n   forward the received Host field-value.\n
      \  Since the Host header field acts as an application-level routing\n   mechanism,
      it is a frequent target for malware seeking to poison a\n   shared cache or
      redirect a request to an unintended server.  An\n   interception proxy is particularly
      vulnerable if it relies on the\n   Host field-value for redirecting requests
      to internal servers, or for\n   use as a cache key in a shared cache, without
      first verifying that\n   the intercepted connection is targeting a valid IP
      address for that\n   host.\n   A server MUST respond with a 400 (Bad Request)
      status code to any\n   HTTP/1.1 request message that lacks a Host header field
      and to any\n   request message that contains more than one Host header field
      or a\n   Host header field with an invalid field-value.\n"
    title: 5.4.  Host
  - contents:
    - "5.5.  Effective Request URI\n   Since the request-target often contains only
      part of the user agent's\n   target URI, a server reconstructs the intended
      target as an\n   \"effective request URI\" to properly service the request.
      \ This\n   reconstruction involves both the server's local configuration and\n
      \  information communicated in the request-target, Host header field,\n   and
      connection context.\n   For a user agent, the effective request URI is the target
      URI.\n   If the request-target is in absolute-form, the effective request URI\n
      \  is the same as the request-target.  Otherwise, the effective request\n   URI
      is constructed as follows:\n      If the server's configuration (or outbound
      gateway) provides a\n      fixed URI scheme, that scheme is used for the effective
      request\n      URI.  Otherwise, if the request is received over a TLS-secured
      TCP\n      connection, the effective request URI's scheme is \"https\"; if not,\n
      \     the scheme is \"http\".\n      If the server's configuration (or outbound
      gateway) provides a\n      fixed URI authority component, that authority is
      used for the\n      effective request URI.  If not, then if the request-target
      is in\n      authority-form, the effective request URI's authority component
      is\n      the same as the request-target.  If not, then if a Host header\n      field
      is supplied with a non-empty field-value, the authority\n      component is
      the same as the Host field-value.  Otherwise, the\n      authority component
      is assigned the default name configured for\n      the server and, if the connection's
      incoming TCP port number\n      differs from the default port for the effective
      request URI's\n      scheme, then a colon (\":\") and the incoming port number
      (in\n      decimal form) are appended to the authority component.\n      If
      the request-target is in authority-form or asterisk-form, the\n      effective
      request URI's combined path and query component is\n      empty.  Otherwise,
      the combined path and query component is the\n      same as the request-target.\n
      \     The components of the effective request URI, once determined as\n      above,
      can be combined into absolute-URI form by concatenating the\n      scheme, \"://\",
      authority, and combined path and query component.\n   Example 1: the following
      message received over an insecure TCP\n   connection\n     GET /pub/WWW/TheProject.html
      HTTP/1.1\n     Host: www.example.org:8080\n   has an effective request URI of\n
      \    http://www.example.org:8080/pub/WWW/TheProject.html\n   Example 2: the
      following message received over a TLS-secured TCP\n   connection\n     OPTIONS
      * HTTP/1.1\n     Host: www.example.org\n   has an effective request URI of\n
      \    https://www.example.org\n   Recipients of an HTTP/1.0 request that lacks
      a Host header field\n   might need to use heuristics (e.g., examination of the
      URI path for\n   something unique to a particular host) in order to guess the\n
      \  effective request URI's authority component.\n   Once the effective request
      URI has been constructed, an origin server\n   needs to decide whether or not
      to provide service for that URI via\n   the connection in which the request
      was received.  For example, the\n   request might have been misdirected, deliberately
      or accidentally,\n   such that the information within a received request-target
      or Host\n   header field differs from the host or port upon which the connection\n
      \  has been made.  If the connection is from a trusted gateway, that\n   inconsistency
      might be expected; otherwise, it might indicate an\n   attempt to bypass security
      filters, trick the server into delivering\n   non-public content, or poison
      a cache.  See Section 9 for security\n   considerations regarding message routing.\n"
    title: 5.5.  Effective Request URI
  - contents:
    - "5.6.  Associating a Response to a Request\n   HTTP does not include a request
      identifier for associating a given\n   request message with its corresponding
      one or more response messages.\n   Hence, it relies on the order of response
      arrival to correspond\n   exactly to the order in which requests are made on
      the same\n   connection.  More than one response message per request only occurs\n
      \  when one or more informational responses (1xx, see Section 6.2 of\n   [RFC7231])
      precede a final response to the same request.\n   A client that has more than
      one outstanding request on a connection\n   MUST maintain a list of outstanding
      requests in the order sent and\n   MUST associate each received response message
      on that connection to\n   the highest ordered request that has not yet received
      a final\n   (non-1xx) response.\n"
    title: 5.6.  Associating a Response to a Request
  - contents:
    - "5.7.  Message Forwarding\n   As described in Section 2.3, intermediaries can
      serve a variety of\n   roles in the processing of HTTP requests and responses.
      \ Some\n   intermediaries are used to improve performance or availability.\n
      \  Others are used for access control or to filter content.  Since an\n   HTTP
      stream has characteristics similar to a pipe-and-filter\n   architecture, there
      are no inherent limits to the extent an\n   intermediary can enhance (or interfere)
      with either direction of the\n   stream.\n   An intermediary not acting as a
      tunnel MUST implement the Connection\n   header field, as specified in Section
      6.1, and exclude fields from\n   being forwarded that are only intended for
      the incoming connection.\n   An intermediary MUST NOT forward a message to itself
      unless it is\n   protected from an infinite request loop.  In general, an intermediary\n
      \  ought to recognize its own server names, including any aliases, local\n   variations,
      or literal IP addresses, and respond to such requests\n   directly.\n"
    - contents:
      - "5.7.1.  Via\n   The \"Via\" header field indicates the presence of intermediate\n
        \  protocols and recipients between the user agent and the server (on\n   requests)
        or between the origin server and the client (on responses),\n   similar to
        the \"Received\" header field in email (Section 3.6.7 of\n   [RFC5322]).  Via
        can be used for tracking message forwards, avoiding\n   request loops, and
        identifying the protocol capabilities of senders\n   along the request/response
        chain.\n     Via = 1#( received-protocol RWS received-by [ RWS comment ] )\n
        \    received-protocol = [ protocol-name \"/\" ] protocol-version\n                         ;
        see Section 6.7\n     received-by       = ( uri-host [ \":\" port ] ) / pseudonym\n
        \    pseudonym         = token\n   Multiple Via field values represent each
        proxy or gateway that has\n   forwarded the message.  Each intermediary appends
        its own information\n   about how the message was received, such that the
        end result is\n   ordered according to the sequence of forwarding recipients.\n
        \  A proxy MUST send an appropriate Via header field, as described\n   below,
        in each message that it forwards.  An HTTP-to-HTTP gateway\n   MUST send an
        appropriate Via header field in each inbound request\n   message and MAY send
        a Via header field in forwarded response\n   messages.\n   For each intermediary,
        the received-protocol indicates the protocol\n   and protocol version used
        by the upstream sender of the message.\n   Hence, the Via field value records
        the advertised protocol\n   capabilities of the request/response chain such
        that they remain\n   visible to downstream recipients; this can be useful
        for determining\n   what backwards-incompatible features might be safe to
        use in\n   response, or within a later request, as described in Section 2.6.\n
        \  For brevity, the protocol-name is omitted when the received protocol\n
        \  is HTTP.\n   The received-by portion of the field value is normally the
        host and\n   optional port number of a recipient server or client that\n   subsequently
        forwarded the message.  However, if the real host is\n   considered to be
        sensitive information, a sender MAY replace it with\n   a pseudonym.  If a
        port is not provided, a recipient MAY interpret\n   that as meaning it was
        received on the default TCP port, if any, for\n   the received-protocol.\n
        \  A sender MAY generate comments in the Via header field to identify\n   the
        software of each recipient, analogous to the User-Agent and\n   Server header
        fields.  However, all comments in the Via field are\n   optional, and a recipient
        MAY remove them prior to forwarding the\n   message.\n   For example, a request
        message could be sent from an HTTP/1.0 user\n   agent to an internal proxy
        code-named \"fred\", which uses HTTP/1.1 to\n   forward the request to a public
        proxy at p.example.net, which\n   completes the request by forwarding it to
        the origin server at\n   www.example.com.  The request received by www.example.com
        would then\n   have the following Via header field:\n     Via: 1.0 fred, 1.1
        p.example.net\n   An intermediary used as a portal through a network firewall
        SHOULD\n   NOT forward the names and ports of hosts within the firewall region\n
        \  unless it is explicitly enabled to do so.  If not enabled, such an\n   intermediary
        SHOULD replace each received-by host of any host behind\n   the firewall by
        an appropriate pseudonym for that host.\n   An intermediary MAY combine an
        ordered subsequence of Via header\n   field entries into a single such entry
        if the entries have identical\n   received-protocol values.  For example,\n
        \    Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy\n   could be collapsed
        to\n     Via: 1.0 ricky, 1.1 mertz, 1.0 lucy\n   A sender SHOULD NOT combine
        multiple entries unless they are all\n   under the same organizational control
        and the hosts have already been\n   replaced by pseudonyms.  A sender MUST
        NOT combine entries that have\n   different received-protocol values.\n"
      title: 5.7.1.  Via
    - contents:
      - "5.7.2.  Transformations\n   Some intermediaries include features for transforming
        messages and\n   their payloads.  A proxy might, for example, convert between
        image\n   formats in order to save cache space or to reduce the amount of\n
        \  traffic on a slow link.  However, operational problems might occur\n   when
        these transformations are applied to payloads intended for\n   critical applications,
        such as medical imaging or scientific data\n   analysis, particularly when
        integrity checks or digital signatures\n   are used to ensure that the payload
        received is identical to the\n   original.\n   An HTTP-to-HTTP proxy is called
        a \"transforming proxy\" if it is\n   designed or configured to modify messages
        in a semantically\n   meaningful way (i.e., modifications, beyond those required
        by normal\n   HTTP processing, that change the message in a way that would
        be\n   significant to the original sender or potentially significant to\n
        \  downstream recipients).  For example, a transforming proxy might be\n   acting
        as a shared annotation server (modifying responses to include\n   references
        to a local annotation database), a malware filter, a\n   format transcoder,
        or a privacy filter.  Such transformations are\n   presumed to be desired
        by whichever client (or client organization)\n   selected the proxy.\n   If
        a proxy receives a request-target with a host name that is not a\n   fully
        qualified domain name, it MAY add its own domain to the host\n   name it received
        when forwarding the request.  A proxy MUST NOT\n   change the host name if
        the request-target contains a fully qualified\n   domain name.\n   A proxy
        MUST NOT modify the \"absolute-path\" and \"query\" parts of the\n   received
        request-target when forwarding it to the next inbound\n   server, except as
        noted above to replace an empty path with \"/\" or\n   \"*\".\n   A proxy
        MAY modify the message body through application or removal of\n   a transfer
        coding (Section 4).\n   A proxy MUST NOT transform the payload (Section 3.3
        of [RFC7231]) of\n   a message that contains a no-transform cache-control
        directive\n   (Section 5.2 of [RFC7234]).\n   A proxy MAY transform the payload
        of a message that does not contain\n   a no-transform cache-control directive.
        \ A proxy that transforms a\n   payload MUST add a Warning header field with
        the warn-code of 214\n   (\"Transformation Applied\") if one is not already
        in the message (see\n   Section 5.5 of [RFC7234]).  A proxy that transforms
        the payload of a\n   200 (OK) response can further inform downstream recipients
        that a\n   transformation has been applied by changing the response status
        code\n   to 203 (Non-Authoritative Information) (Section 6.3.4 of [RFC7231]).\n
        \  A proxy SHOULD NOT modify header fields that provide information\n   about
        the endpoints of the communication chain, the resource state,\n   or the selected
        representation (other than the payload) unless the\n   field's definition
        specifically allows such modification or the\n   modification is deemed necessary
        for privacy or security.\n"
      title: 5.7.2.  Transformations
    title: 5.7.  Message Forwarding
  title: 5.  Message Routing
- contents:
  - "6.  Connection Management\n   HTTP messaging is independent of the underlying
    transport- or\n   session-layer connection protocol(s).  HTTP only presumes a
    reliable\n   transport with in-order delivery of requests and the corresponding\n
    \  in-order delivery of responses.  The mapping of HTTP request and\n   response
    structures onto the data units of an underlying transport\n   protocol is outside
    the scope of this specification.\n   As described in Section 5.2, the specific
    connection protocols to be\n   used for an HTTP interaction are determined by
    client configuration\n   and the target URI.  For example, the \"http\" URI scheme\n
    \  (Section 2.7.1) indicates a default connection of TCP over IP, with a\n   default
    TCP port of 80, but the client might be configured to use a\n   proxy via some
    other connection, port, or protocol.\n   HTTP implementations are expected to
    engage in connection management,\n   which includes maintaining the state of current
    connections,\n   establishing a new connection or reusing an existing connection,\n
    \  processing messages received on a connection, detecting connection\n   failures,
    and closing each connection.  Most clients maintain\n   multiple connections in
    parallel, including more than one connection\n   per server endpoint.  Most servers
    are designed to maintain thousands\n   of concurrent connections, while controlling
    request queues to enable\n   fair use and detect denial-of-service attacks.\n"
  - contents:
    - "6.1.  Connection\n   The \"Connection\" header field allows the sender to indicate
      desired\n   control options for the current connection.  In order to avoid\n
      \  confusing downstream recipients, a proxy or gateway MUST remove or\n   replace
      any received connection options before forwarding the\n   message.\n   When
      a header field aside from Connection is used to supply control\n   information
      for or about the current connection, the sender MUST list\n   the corresponding
      field-name within the Connection header field.  A\n   proxy or gateway MUST
      parse a received Connection header field before\n   a message is forwarded and,
      for each connection-option in this field,\n   remove any header field(s) from
      the message with the same name as the\n   connection-option, and then remove
      the Connection header field itself\n   (or replace it with the intermediary's
      own connection options for the\n   forwarded message).\n   Hence, the Connection
      header field provides a declarative way of\n   distinguishing header fields
      that are only intended for the immediate\n   recipient (\"hop-by-hop\") from
      those fields that are intended for all\n   recipients on the chain (\"end-to-end\"),
      enabling the message to be\n   self-descriptive and allowing future connection-specific
      extensions\n   to be deployed without fear that they will be blindly forwarded
      by\n   older intermediaries.\n   The Connection header field's value has the
      following grammar:\n     Connection        = 1#connection-option\n     connection-option
      = token\n   Connection options are case-insensitive.\n   A sender MUST NOT send
      a connection option corresponding to a header\n   field that is intended for
      all recipients of the payload.  For\n   example, Cache-Control is never appropriate
      as a connection option\n   (Section 5.2 of [RFC7234]).\n   The connection options
      do not always correspond to a header field\n   present in the message, since
      a connection-specific header field\n   might not be needed if there are no parameters
      associated with a\n   connection option.  In contrast, a connection-specific
      header field\n   that is received without a corresponding connection option
      usually\n   indicates that the field has been improperly forwarded by an\n   intermediary
      and ought to be ignored by the recipient.\n   When defining new connection options,
      specification authors ought to\n   survey existing header field names and ensure
      that the new connection\n   option does not share the same name as an already
      deployed header\n   field.  Defining a new connection option essentially reserves
      that\n   potential field-name for carrying additional information related to\n
      \  the connection option, since it would be unwise for senders to use\n   that
      field-name for anything else.\n   The \"close\" connection option is defined
      for a sender to signal that\n   this connection will be closed after completion
      of the response.  For\n   example,\n     Connection: close\n   in either the
      request or the response header fields indicates that\n   the sender is going
      to close the connection after the current\n   request/response is complete (Section
      6.6).\n   A client that does not support persistent connections MUST send the\n
      \  \"close\" connection option in every request message.\n   A server that does
      not support persistent connections MUST send the\n   \"close\" connection option
      in every response message that does not\n   have a 1xx (Informational) status
      code.\n"
    title: 6.1.  Connection
  - contents:
    - "6.2.  Establishment\n   It is beyond the scope of this specification to describe
      how\n   connections are established via various transport- or session-layer\n
      \  protocols.  Each connection applies to only one transport link.\n"
    title: 6.2.  Establishment
  - contents:
    - "6.3.  Persistence\n   HTTP/1.1 defaults to the use of \"persistent connections\",
      allowing\n   multiple requests and responses to be carried over a single\n   connection.
      \ The \"close\" connection option is used to signal that a\n   connection will
      not persist after the current request/response.  HTTP\n   implementations SHOULD
      support persistent connections.\n   A recipient determines whether a connection
      is persistent or not\n   based on the most recently received message's protocol
      version and\n   Connection header field (if any):\n   o  If the \"close\" connection
      option is present, the connection will\n      not persist after the current
      response; else,\n   o  If the received protocol is HTTP/1.1 (or later), the
      connection\n      will persist after the current response; else,\n   o  If the
      received protocol is HTTP/1.0, the \"keep-alive\" connection\n      option is
      present, the recipient is not a proxy, and the recipient\n      wishes to honor
      the HTTP/1.0 \"keep-alive\" mechanism, the\n      connection will persist after
      the current response; otherwise,\n   o  The connection will close after the
      current response.\n   A client MAY send additional requests on a persistent
      connection\n   until it sends or receives a \"close\" connection option or receives
      an\n   HTTP/1.0 response without a \"keep-alive\" connection option.\n   In
      order to remain persistent, all messages on a connection need to\n   have a
      self-defined message length (i.e., one not defined by closure\n   of the connection),
      as described in Section 3.3.  A server MUST read\n   the entire request message
      body or close the connection after sending\n   its response, since otherwise
      the remaining data on a persistent\n   connection would be misinterpreted as
      the next request.  Likewise, a\n   client MUST read the entire response message
      body if it intends to\n   reuse the same connection for a subsequent request.\n
      \  A proxy server MUST NOT maintain a persistent connection with an\n   HTTP/1.0
      client (see Section 19.7.1 of [RFC2068] for information and\n   discussion of
      the problems with the Keep-Alive header field\n   implemented by many HTTP/1.0
      clients).\n   See Appendix A.1.2 for more information on backwards compatibility\n
      \  with HTTP/1.0 clients.\n"
    - contents:
      - "6.3.1.  Retrying Requests\n   Connections can be closed at any time, with
        or without intention.\n   Implementations ought to anticipate the need to
        recover from\n   asynchronous close events.\n   When an inbound connection
        is closed prematurely, a client MAY open a\n   new connection and automatically
        retransmit an aborted sequence of\n   requests if all of those requests have
        idempotent methods (Section\n   4.2.2 of [RFC7231]).  A proxy MUST NOT automatically
        retry\n   non-idempotent requests.\n   A user agent MUST NOT automatically
        retry a request with a non-\n   idempotent method unless it has some means
        to know that the request\n   semantics are actually idempotent, regardless
        of the method, or some\n   means to detect that the original request was never
        applied.  For\n   example, a user agent that knows (through design or configuration)\n
        \  that a POST request to a given resource is safe can repeat that\n   request
        automatically.  Likewise, a user agent designed specifically\n   to operate
        on a version control repository might be able to recover\n   from partial
        failure conditions by checking the target resource\n   revision(s) after a
        failed connection, reverting or fixing any\n   changes that were partially
        applied, and then automatically retrying\n   the requests that failed.\n   A
        client SHOULD NOT automatically retry a failed automatic retry.\n"
      title: 6.3.1.  Retrying Requests
    - contents:
      - "6.3.2.  Pipelining\n   A client that supports persistent connections MAY
        \"pipeline\" its\n   requests (i.e., send multiple requests without waiting
        for each\n   response).  A server MAY process a sequence of pipelined requests
        in\n   parallel if they all have safe methods (Section 4.2.1 of [RFC7231]),\n
        \  but it MUST send the corresponding responses in the same order that\n   the
        requests were received.\n   A client that pipelines requests SHOULD retry
        unanswered requests if\n   the connection closes before it receives all of
        the corresponding\n   responses.  When retrying pipelined requests after a
        failed\n   connection (a connection not explicitly closed by the server in
        its\n   last complete response), a client MUST NOT pipeline immediately after\n
        \  connection establishment, since the first remaining request in the\n   prior
        pipeline might have caused an error response that can be lost\n   again if
        multiple requests are sent on a prematurely closed\n   connection (see the
        TCP reset problem described in Section 6.6).\n   Idempotent methods (Section
        4.2.2 of [RFC7231]) are significant to\n   pipelining because they can be
        automatically retried after a\n   connection failure.  A user agent SHOULD
        NOT pipeline requests after\n   a non-idempotent method, until the final response
        status code for\n   that method has been received, unless the user agent has
        a means to\n   detect and recover from partial failure conditions involving
        the\n   pipelined sequence.\n   An intermediary that receives pipelined requests
        MAY pipeline those\n   requests when forwarding them inbound, since it can
        rely on the\n   outbound user agent(s) to determine what requests can be safely\n
        \  pipelined.  If the inbound connection fails before receiving a\n   response,
        the pipelining intermediary MAY attempt to retry a sequence\n   of requests
        that have yet to receive a response if the requests all\n   have idempotent
        methods; otherwise, the pipelining intermediary\n   SHOULD forward any received
        responses and then close the\n   corresponding outbound connection(s) so that
        the outbound user\n   agent(s) can recover accordingly.\n"
      title: 6.3.2.  Pipelining
    title: 6.3.  Persistence
  - contents:
    - "6.4.  Concurrency\n   A client ought to limit the number of simultaneous open
      connections\n   that it maintains to a given server.\n   Previous revisions
      of HTTP gave a specific number of connections as a\n   ceiling, but this was
      found to be impractical for many applications.\n   As a result, this specification
      does not mandate a particular maximum\n   number of connections but, instead,
      encourages clients to be\n   conservative when opening multiple connections.\n
      \  Multiple connections are typically used to avoid the \"head-of-line\n   blocking\"
      problem, wherein a request that takes significant\n   server-side processing
      and/or has a large payload blocks subsequent\n   requests on the same connection.
      \ However, each connection consumes\n   server resources.  Furthermore, using
      multiple connections can cause\n   undesirable side effects in congested networks.\n
      \  Note that a server might reject traffic that it deems abusive or\n   characteristic
      of a denial-of-service attack, such as an excessive\n   number of open connections
      from a single client.\n"
    title: 6.4.  Concurrency
  - contents:
    - "6.5.  Failures and Timeouts\n   Servers will usually have some timeout value
      beyond which they will\n   no longer maintain an inactive connection.  Proxy
      servers might make\n   this a higher value since it is likely that the client
      will be making\n   more connections through the same proxy server.  The use
      of\n   persistent connections places no requirements on the length (or\n   existence)
      of this timeout for either the client or the server.\n   A client or server
      that wishes to time out SHOULD issue a graceful\n   close on the connection.
      \ Implementations SHOULD constantly monitor\n   open connections for a received
      closure signal and respond to it as\n   appropriate, since prompt closure of
      both sides of a connection\n   enables allocated system resources to be reclaimed.\n
      \  A client, server, or proxy MAY close the transport connection at any\n   time.
      \ For example, a client might have started to send a new request\n   at the
      same time that the server has decided to close the \"idle\"\n   connection.
      \ From the server's point of view, the connection is being\n   closed while
      it was idle, but from the client's point of view, a\n   request is in progress.\n
      \  A server SHOULD sustain persistent connections, when possible, and\n   allow
      the underlying transport's flow-control mechanisms to resolve\n   temporary
      overloads, rather than terminate connections with the\n   expectation that clients
      will retry.  The latter technique can\n   exacerbate network congestion.\n   A
      client sending a message body SHOULD monitor the network connection\n   for
      an error response while it is transmitting the request.  If the\n   client sees
      a response that indicates the server does not wish to\n   receive the message
      body and is closing the connection, the client\n   SHOULD immediately cease
      transmitting the body and close its side of\n   the connection.\n"
    title: 6.5.  Failures and Timeouts
  - contents:
    - "6.6.  Tear-down\n   The Connection header field (Section 6.1) provides a \"close\"\n
      \  connection option that a sender SHOULD send when it wishes to close\n   the
      connection after the current request/response pair.\n   A client that sends
      a \"close\" connection option MUST NOT send further\n   requests on that connection
      (after the one containing \"close\") and\n   MUST close the connection after
      reading the final response message\n   corresponding to this request.\n   A
      server that receives a \"close\" connection option MUST initiate a\n   close
      of the connection (see below) after it sends the final response\n   to the request
      that contained \"close\".  The server SHOULD send a\n   \"close\" connection
      option in its final response on that connection.\n   The server MUST NOT process
      any further requests received on that\n   connection.\n   A server that sends
      a \"close\" connection option MUST initiate a close\n   of the connection (see
      below) after it sends the response containing\n   \"close\".  The server MUST
      NOT process any further requests received\n   on that connection.\n   A client
      that receives a \"close\" connection option MUST cease sending\n   requests
      on that connection and close the connection after reading\n   the response message
      containing the \"close\"; if additional pipelined\n   requests had been sent
      on the connection, the client SHOULD NOT\n   assume that they will be processed
      by the server.\n   If a server performs an immediate close of a TCP connection,
      there is\n   a significant risk that the client will not be able to read the
      last\n   HTTP response.  If the server receives additional data from the\n   client
      on a fully closed connection, such as another request that was\n   sent by the
      client before receiving the server's response, the\n   server's TCP stack will
      send a reset packet to the client;\n   unfortunately, the reset packet might
      erase the client's\n   unacknowledged input buffers before they can be read
      and interpreted\n   by the client's HTTP parser.\n   To avoid the TCP reset
      problem, servers typically close a connection\n   in stages.  First, the server
      performs a half-close by closing only\n   the write side of the read/write connection.
      \ The server then\n   continues to read from the connection until it receives
      a\n   corresponding close by the client, or until the server is reasonably\n
      \  certain that its own TCP stack has received the client's\n   acknowledgement
      of the packet(s) containing the server's last\n   response.  Finally, the server
      fully closes the connection.\n   It is unknown whether the reset problem is
      exclusive to TCP or might\n   also be found in other transport connection protocols.\n"
    title: 6.6.  Tear-down
  - contents:
    - "6.7.  Upgrade\n   The \"Upgrade\" header field is intended to provide a simple
      mechanism\n   for transitioning from HTTP/1.1 to some other protocol on the
      same\n   connection.  A client MAY send a list of protocols in the Upgrade\n
      \  header field of a request to invite the server to switch to one or\n   more
      of those protocols, in order of descending preference, before\n   sending the
      final response.  A server MAY ignore a received Upgrade\n   header field if
      it wishes to continue using the current protocol on\n   that connection.  Upgrade
      cannot be used to insist on a protocol\n   change.\n     Upgrade          =
      1#protocol\n     protocol         = protocol-name [\"/\" protocol-version]\n
      \    protocol-name    = token\n     protocol-version = token\n   A server that
      sends a 101 (Switching Protocols) response MUST send an\n   Upgrade header field
      to indicate the new protocol(s) to which the\n   connection is being switched;
      if multiple protocol layers are being\n   switched, the sender MUST list the
      protocols in layer-ascending\n   order.  A server MUST NOT switch to a protocol
      that was not indicated\n   by the client in the corresponding request's Upgrade
      header field.  A\n   server MAY choose to ignore the order of preference indicated
      by the\n   client and select the new protocol(s) based on other factors, such
      as\n   the nature of the request or the current load on the server.\n   A server
      that sends a 426 (Upgrade Required) response MUST send an\n   Upgrade header
      field to indicate the acceptable protocols, in order\n   of descending preference.\n
      \  A server MAY send an Upgrade header field in any other response to\n   advertise
      that it implements support for upgrading to the listed\n   protocols, in order
      of descending preference, when appropriate for a\n   future request.\n   The
      following is a hypothetical example sent by a client:\n     GET /hello.txt HTTP/1.1\n
      \    Host: www.example.com\n     Connection: upgrade\n     Upgrade: HTTP/2.0,
      SHTTP/1.3, IRC/6.9, RTA/x11\n   The capabilities and nature of the application-level
      communication\n   after the protocol change is entirely dependent upon the new\n
      \  protocol(s) chosen.  However, immediately after sending the 101\n   (Switching
      Protocols) response, the server is expected to continue\n   responding to the
      original request as if it had received its\n   equivalent within the new protocol
      (i.e., the server still has an\n   outstanding request to satisfy after the
      protocol has been changed,\n   and is expected to do so without requiring the
      request to be\n   repeated).\n   For example, if the Upgrade header field is
      received in a GET request\n   and the server decides to switch protocols, it
      first responds with a\n   101 (Switching Protocols) message in HTTP/1.1 and
      then immediately\n   follows that with the new protocol's equivalent of a response
      to a\n   GET on the target resource.  This allows a connection to be upgraded\n
      \  to protocols with the same semantics as HTTP without the latency cost\n   of
      an additional round trip.  A server MUST NOT switch protocols\n   unless the
      received message semantics can be honored by the new\n   protocol; an OPTIONS
      request can be honored by any protocol.\n   The following is an example response
      to the above hypothetical\n   request:\n     HTTP/1.1 101 Switching Protocols\n
      \    Connection: upgrade\n     Upgrade: HTTP/2.0\n     [... data stream switches
      to HTTP/2.0 with an appropriate response\n     (as defined by new protocol)
      to the \"GET /hello.txt\" request ...]\n   When Upgrade is sent, the sender
      MUST also send a Connection header\n   field (Section 6.1) that contains an
      \"upgrade\" connection option, in\n   order to prevent Upgrade from being accidentally
      forwarded by\n   intermediaries that might not implement the listed protocols.
      \ A\n   server MUST ignore an Upgrade header field that is received in an\n
      \  HTTP/1.0 request.\n   A client cannot begin using an upgraded protocol on
      the connection\n   until it has completely sent the request message (i.e., the
      client\n   can't change the protocol it is sending in the middle of a message).\n
      \  If a server receives both an Upgrade and an Expect header field with\n   the
      \"100-continue\" expectation (Section 5.1.1 of [RFC7231]), the\n   server MUST
      send a 100 (Continue) response before sending a 101\n   (Switching Protocols)
      response.\n   The Upgrade header field only applies to switching protocols on
      top\n   of the existing connection; it cannot be used to switch the\n   underlying
      connection (transport) protocol, nor to switch the\n   existing communication
      to a different connection.  For those\n   purposes, it is more appropriate to
      use a 3xx (Redirection) response\n   (Section 6.4 of [RFC7231]).\n   This specification
      only defines the protocol name \"HTTP\" for use by\n   the family of Hypertext
      Transfer Protocols, as defined by the HTTP\n   version rules of Section 2.6
      and future updates to this\n   specification.  Additional tokens ought to be
      registered with IANA\n   using the registration procedure defined in Section
      8.6.\n"
    title: 6.7.  Upgrade
  title: 6.  Connection Management
- contents:
  - "7.  ABNF List Extension: #rule\n   A #rule extension to the ABNF rules of [RFC5234]
    is used to improve\n   readability in the definitions of some header field values.\n
    \  A construct \"#\" is defined, similar to \"*\", for defining\n   comma-delimited
    lists of elements.  The full form is \"<n>#<m>element\"\n   indicating at least
    <n> and at most <m> elements, each separated by a\n   single comma (\",\") and
    optional whitespace (OWS).\n   In any production that uses the list construct,
    a sender MUST NOT\n   generate empty list elements.  In other words, a sender
    MUST generate\n   lists that satisfy the following syntax:\n     1#element =>
    element *( OWS \",\" OWS element )\n   and:\n     #element => [ 1#element ]\n
    \  and for n >= 1 and m > 1:\n     <n>#<m>element => element <n-1>*<m-1>( OWS
    \",\" OWS element )\n   For compatibility with legacy list rules, a recipient
    MUST parse and\n   ignore a reasonable number of empty list elements: enough to
    handle\n   common mistakes by senders that merge values, but not so much that\n
    \  they could be used as a denial-of-service mechanism.  In other words,\n   a
    recipient MUST accept lists that satisfy the following syntax:\n     #element
    => [ ( \",\" / element ) *( OWS \",\" [ OWS element ] ) ]\n     1#element => *(
    \",\" OWS ) element *( OWS \",\" [ OWS element ] )\n   Empty elements do not contribute
    to the count of elements present.\n   For example, given these ABNF productions:\n
    \    example-list      = 1#example-list-elmt\n     example-list-elmt = token ;
    see Section 3.2.6\n   Then the following are valid values for example-list (not
    including\n   the double quotes, which are present for delimitation only):\n     \"foo,bar\"\n
    \    \"foo ,bar,\"\n     \"foo , ,bar,charlie   \"\n   In contrast, the following
    values would be invalid, since at least\n   one non-empty element is required
    by the example-list production:\n     \"\"\n     \",\"\n     \",   ,\"\n   Appendix
    B shows the collected ABNF for recipients after the list\n   constructs have been
    expanded.\n"
  title: '7.  ABNF List Extension: #rule'
- contents:
  - '8.  IANA Considerations

    '
  - contents:
    - "8.1.  Header Field Registration\n   HTTP header fields are registered within
      the \"Message Headers\"\n   registry maintained at\n   <http://www.iana.org/assignments/message-headers/>.\n
      \  This document defines the following HTTP header fields, so the\n   \"Permanent
      Message Header Field Names\" registry has been updated\n   accordingly (see
      [BCP90]).\n   +-------------------+----------+----------+---------------+\n
      \  | Header Field Name | Protocol | Status   | Reference     |\n   +-------------------+----------+----------+---------------+\n
      \  | Connection        | http     | standard | Section 6.1   |\n   | Content-Length
      \   | http     | standard | Section 3.3.2 |\n   | Host              | http     |
      standard | Section 5.4   |\n   | TE                | http     | standard | Section
      4.3   |\n   | Trailer           | http     | standard | Section 4.4   |\n   |
      Transfer-Encoding | http     | standard | Section 3.3.1 |\n   | Upgrade           |
      http     | standard | Section 6.7   |\n   | Via               | http     | standard
      | Section 5.7.1 |\n   +-------------------+----------+----------+---------------+\n
      \  Furthermore, the header field-name \"Close\" has been registered as\n   \"reserved\",
      since using that name as an HTTP header field might\n   conflict with the \"close\"
      connection option of the Connection header\n   field (Section 6.1).\n   +-------------------+----------+----------+-------------+\n
      \  | Header Field Name | Protocol | Status   | Reference   |\n   +-------------------+----------+----------+-------------+\n
      \  | Close             | http     | reserved | Section 8.1 |\n   +-------------------+----------+----------+-------------+\n
      \  The change controller is: \"IETF (iesg@ietf.org) - Internet\n   Engineering
      Task Force\".\n"
    title: 8.1.  Header Field Registration
  - contents:
    - "8.2.  URI Scheme Registration\n   IANA maintains the registry of URI Schemes
      [BCP115] at\n   <http://www.iana.org/assignments/uri-schemes/>.\n   This document
      defines the following URI schemes, so the \"Permanent\n   URI Schemes\" registry
      has been updated accordingly.\n   +------------+------------------------------------+---------------+\n
      \  | URI Scheme | Description                        | Reference     |\n   +------------+------------------------------------+---------------+\n
      \  | http       | Hypertext Transfer Protocol        | Section 2.7.1 |\n   |
      https      | Hypertext Transfer Protocol Secure | Section 2.7.2 |\n   +------------+------------------------------------+---------------+\n"
    title: 8.2.  URI Scheme Registration
  - contents:
    - "8.3.  Internet Media Type Registration\n   IANA maintains the registry of Internet
      media types [BCP13] at\n   <http://www.iana.org/assignments/media-types>.\n
      \  This document serves as the specification for the Internet media\n   types
      \"message/http\" and \"application/http\".  The following has been\n   registered
      with IANA.\n"
    - contents:
      - "8.3.1.  Internet Media Type message/http\n   The message/http type can be
        used to enclose a single HTTP request or\n   response message, provided that
        it obeys the MIME restrictions for\n   all \"message\" types regarding line
        length and encodings.\n   Type name:  message\n   Subtype name:  http\n   Required
        parameters:  N/A\n   Optional parameters:  version, msgtype\n      version:
        \ The HTTP-version number of the enclosed message (e.g.,\n         \"1.1\").
        \ If not present, the version can be determined from the\n         first line
        of the body.\n      msgtype:  The message type -- \"request\" or \"response\".
        \ If not\n         present, the type can be determined from the first line
        of the\n         body.\n   Encoding considerations:  only \"7bit\", \"8bit\",
        or \"binary\" are\n      permitted\n   Security considerations:  see Section
        9\n   Interoperability considerations:  N/A\n   Published specification:  This
        specification (see Section 8.3.1).\n   Applications that use this media type:
        \ N/A\n   Fragment identifier considerations:  N/A\n   Additional information:\n
        \     Magic number(s):  N/A\n      Deprecated alias names for this type:  N/A\n
        \     File extension(s):  N/A\n      Macintosh file type code(s):  N/A\n   Person
        and email address to contact for further information:\n      See Authors'
        Addresses section.\n   Intended usage:  COMMON\n   Restrictions on usage:
        \ N/A\n   Author:  See Authors' Addresses section.\n   Change controller:
        \ IESG\n"
      title: 8.3.1.  Internet Media Type message/http
    - contents:
      - "8.3.2.  Internet Media Type application/http\n   The application/http type
        can be used to enclose a pipeline of one or\n   more HTTP request or response
        messages (not intermixed).\n   Type name:  application\n   Subtype name:  http\n
        \  Required parameters:  N/A\n   Optional parameters:  version, msgtype\n
        \     version:  The HTTP-version number of the enclosed messages (e.g.,\n
        \        \"1.1\").  If not present, the version can be determined from the\n
        \        first line of the body.\n      msgtype:  The message type -- \"request\"
        or \"response\".  If not\n         present, the type can be determined from
        the first line of the\n         body.\n   Encoding considerations:  HTTP messages
        enclosed by this type are in\n      \"binary\" format; use of an appropriate
        Content-Transfer-Encoding\n      is required when transmitted via email.\n
        \  Security considerations:  see Section 9\n   Interoperability considerations:
        \ N/A\n   Published specification:  This specification (see Section 8.3.2).\n
        \  Applications that use this media type:  N/A\n   Fragment identifier considerations:
        \ N/A\n   Additional information:\n      Deprecated alias names for this type:
        \ N/A\n      Magic number(s):  N/A\n      File extension(s):  N/A\n      Macintosh
        file type code(s):  N/A\n   Person and email address to contact for further
        information:\n      See Authors' Addresses section.\n   Intended usage:  COMMON\n
        \  Restrictions on usage:  N/A\n   Author:  See Authors' Addresses section.\n
        \  Change controller:  IESG\n"
      title: 8.3.2.  Internet Media Type application/http
    title: 8.3.  Internet Media Type Registration
  - contents:
    - "8.4.  Transfer Coding Registry\n   The \"HTTP Transfer Coding Registry\" defines
      the namespace for\n   transfer coding names.  It is maintained at\n   <http://www.iana.org/assignments/http-parameters>.\n"
    - contents:
      - "8.4.1.  Procedure\n   Registrations MUST include the following fields:\n
        \  o  Name\n   o  Description\n   o  Pointer to specification text\n   Names
        of transfer codings MUST NOT overlap with names of content\n   codings (Section
        3.1.2.1 of [RFC7231]) unless the encoding\n   transformation is identical,
        as is the case for the compression\n   codings defined in Section 4.2.\n   Values
        to be added to this namespace require IETF Review (see Section\n   4.1 of
        [RFC5226]), and MUST conform to the purpose of transfer coding\n   defined
        in this specification.\n   Use of program names for the identification of
        encoding formats is\n   not desirable and is discouraged for future encodings.\n"
      title: 8.4.1.  Procedure
    - contents:
      - "8.4.2.  Registration\n   The \"HTTP Transfer Coding Registry\" has been updated
        with the\n   registrations below:\n   +------------+--------------------------------------+---------------+\n
        \  | Name       | Description                          | Reference     |\n
        \  +------------+--------------------------------------+---------------+\n
        \  | chunked    | Transfer in a series of chunks       | Section 4.1   |\n
        \  | compress   | UNIX \"compress\" data format [Welch]  | Section 4.2.1 |\n
        \  | deflate    | \"deflate\" compressed data            | Section 4.2.2 |\n
        \  |            | ([RFC1951]) inside the \"zlib\" data   |               |\n
        \  |            | format ([RFC1950])                   |               |\n
        \  | gzip       | GZIP file format [RFC1952]           | Section 4.2.3 |\n
        \  | x-compress | Deprecated (alias for compress)      | Section 4.2.1 |\n
        \  | x-gzip     | Deprecated (alias for gzip)          | Section 4.2.3 |\n
        \  +------------+--------------------------------------+---------------+\n"
      title: 8.4.2.  Registration
    title: 8.4.  Transfer Coding Registry
  - contents:
    - "8.5.  Content Coding Registration\n   IANA maintains the \"HTTP Content Coding
      Registry\" at\n   <http://www.iana.org/assignments/http-parameters>.\n   The
      \"HTTP Content Coding Registry\" has been updated with the\n   registrations
      below:\n   +------------+--------------------------------------+---------------+\n
      \  | Name       | Description                          | Reference     |\n   +------------+--------------------------------------+---------------+\n
      \  | compress   | UNIX \"compress\" data format [Welch]  | Section 4.2.1 |\n
      \  | deflate    | \"deflate\" compressed data            | Section 4.2.2 |\n
      \  |            | ([RFC1951]) inside the \"zlib\" data   |               |\n
      \  |            | format ([RFC1950])                   |               |\n   |
      gzip       | GZIP file format [RFC1952]           | Section 4.2.3 |\n   | x-compress
      | Deprecated (alias for compress)      | Section 4.2.1 |\n   | x-gzip     |
      Deprecated (alias for gzip)          | Section 4.2.3 |\n   +------------+--------------------------------------+---------------+\n"
    title: 8.5.  Content Coding Registration
  - contents:
    - "8.6.  Upgrade Token Registry\n   The \"Hypertext Transfer Protocol (HTTP) Upgrade
      Token Registry\"\n   defines the namespace for protocol-name tokens used to
      identify\n   protocols in the Upgrade header field.  The registry is maintained
      at\n   <http://www.iana.org/assignments/http-upgrade-tokens>.\n"
    - contents:
      - "8.6.1.  Procedure\n   Each registered protocol name is associated with contact
        information\n   and an optional set of specifications that details how the
        connection\n   will be processed after it has been upgraded.\n   Registrations
        happen on a \"First Come First Served\" basis (see\n   Section 4.1 of [RFC5226])
        and are subject to the following rules:\n   1.  A protocol-name token, once
        registered, stays registered forever.\n   2.  The registration MUST name a
        responsible party for the\n       registration.\n   3.  The registration MUST
        name a point of contact.\n   4.  The registration MAY name a set of specifications
        associated with\n       that token.  Such specifications need not be publicly
        available.\n   5.  The registration SHOULD name a set of expected \"protocol-version\"\n
        \      tokens associated with that token at the time of registration.\n   6.
        \ The responsible party MAY change the registration at any time.\n       The
        IANA will keep a record of all such changes, and make them\n       available
        upon request.\n   7.  The IESG MAY reassign responsibility for a protocol
        token.  This\n       will normally only be used in the case when a responsible
        party\n       cannot be contacted.\n   This registration procedure for HTTP
        Upgrade Tokens replaces that\n   previously defined in Section 7.2 of [RFC2817].\n"
      title: 8.6.1.  Procedure
    - contents:
      - "8.6.2.  Upgrade Token Registration\n   The \"HTTP\" entry in the upgrade
        token registry has been updated with\n   the registration below:\n   +-------+----------------------+----------------------+-------------+\n
        \  | Value | Description          | Expected Version     | Reference   |\n
        \  |       |                      | Tokens               |             |\n
        \  +-------+----------------------+----------------------+-------------+\n
        \  | HTTP  | Hypertext Transfer   | any DIGIT.DIGIT      | Section 2.6 |\n
        \  |       | Protocol             | (e.g, \"2.0\")         |             |\n
        \  +-------+----------------------+----------------------+-------------+\n
        \  The responsible party is: \"IETF (iesg@ietf.org) - Internet\n   Engineering
        Task Force\".\n"
      title: 8.6.2.  Upgrade Token Registration
    title: 8.6.  Upgrade Token Registry
  title: 8.  IANA Considerations
- contents:
  - "9.  Security Considerations\n   This section is meant to inform developers, information
    providers,\n   and users of known security considerations relevant to HTTP message\n
    \  syntax, parsing, and routing.  Security considerations about HTTP\n   semantics
    and payloads are addressed in [RFC7231].\n"
  - contents:
    - "9.1.  Establishing Authority\n   HTTP relies on the notion of an authoritative
      response: a response\n   that has been determined by (or at the direction of)
      the authority\n   identified within the target URI to be the most appropriate
      response\n   for that request given the state of the target resource at the
      time\n   of response message origination.  Providing a response from a\n   non-authoritative
      source, such as a shared cache, is often useful to\n   improve performance and
      availability, but only to the extent that the\n   source can be trusted or the
      distrusted response can be safely used.\n   Unfortunately, establishing authority
      can be difficult.  For example,\n   phishing is an attack on the user's perception
      of authority, where\n   that perception can be misled by presenting similar
      branding in\n   hypertext, possibly aided by userinfo obfuscating the authority\n
      \  component (see Section 2.7.1).  User agents can reduce the impact of\n   phishing
      attacks by enabling users to easily inspect a target URI\n   prior to making
      an action, by prominently distinguishing (or\n   rejecting) userinfo when present,
      and by not sending stored\n   credentials and cookies when the referring document
      is from an\n   unknown or untrusted source.\n   When a registered name is used
      in the authority component, the \"http\"\n   URI scheme (Section 2.7.1) relies
      on the user's local name resolution\n   service to determine where it can find
      authoritative responses.  This\n   means that any attack on a user's network
      host table, cached names,\n   or name resolution libraries becomes an avenue
      for attack on\n   establishing authority.  Likewise, the user's choice of server
      for\n   Domain Name Service (DNS), and the hierarchy of servers from which it\n
      \  obtains resolution results, could impact the authenticity of address\n   mappings;
      DNS Security Extensions (DNSSEC, [RFC4033]) are one way to\n   improve authenticity.\n
      \  Furthermore, after an IP address is obtained, establishing authority\n   for
      an \"http\" URI is vulnerable to attacks on Internet Protocol\n   routing.\n
      \  The \"https\" scheme (Section 2.7.2) is intended to prevent (or at\n   least
      reveal) many of these potential attacks on establishing\n   authority, provided
      that the negotiated TLS connection is secured and\n   the client properly verifies
      that the communicating server's identity\n   matches the target URI's authority
      component (see [RFC2818]).\n   Correctly implementing such verification can
      be difficult (see\n   [Georgiev]).\n"
    title: 9.1.  Establishing Authority
  - contents:
    - "9.2.  Risks of Intermediaries\n   By their very nature, HTTP intermediaries
      are men-in-the-middle and,\n   thus, represent an opportunity for man-in-the-middle
      attacks.\n   Compromise of the systems on which the intermediaries run can result\n
      \  in serious security and privacy problems.  Intermediaries might have\n   access
      to security-related information, personal information about\n   individual users
      and organizations, and proprietary information\n   belonging to users and content
      providers.  A compromised\n   intermediary, or an intermediary implemented or
      configured without\n   regard to security and privacy considerations, might
      be used in the\n   commission of a wide range of potential attacks.\n   Intermediaries
      that contain a shared cache are especially vulnerable\n   to cache poisoning
      attacks, as described in Section 8 of [RFC7234].\n   Implementers need to consider
      the privacy and security implications\n   of their design and coding decisions,
      and of the configuration\n   options they provide to operators (especially the
      default\n   configuration).\n   Users need to be aware that intermediaries are
      no more trustworthy\n   than the people who run them; HTTP itself cannot solve
      this problem.\n"
    title: 9.2.  Risks of Intermediaries
  - contents:
    - "9.3.  Attacks via Protocol Element Length\n   Because HTTP uses mostly textual,
      character-delimited fields, parsers\n   are often vulnerable to attacks based
      on sending very long (or very\n   slow) streams of data, particularly where
      an implementation is\n   expecting a protocol element with no predefined length.\n
      \  To promote interoperability, specific recommendations are made for\n   minimum
      size limits on request-line (Section 3.1.1) and header fields\n   (Section 3.2).
      \ These are minimum recommendations, chosen to be\n   supportable even by implementations
      with limited resources; it is\n   expected that most implementations will choose
      substantially higher\n   limits.\n   A server can reject a message that has
      a request-target that is too\n   long (Section 6.5.12 of [RFC7231]) or a request
      payload that is too\n   large (Section 6.5.11 of [RFC7231]).  Additional status
      codes related\n   to capacity limits have been defined by extensions to HTTP
      [RFC6585].\n   Recipients ought to carefully limit the extent to which they
      process\n   other protocol elements, including (but not limited to) request\n
      \  methods, response status phrases, header field-names, numeric values,\n   and
      body chunks.  Failure to limit such processing can result in\n   buffer overflows,
      arithmetic overflows, or increased vulnerability to\n   denial-of-service attacks.\n"
    title: 9.3.  Attacks via Protocol Element Length
  - contents:
    - "9.4.  Response Splitting\n   Response splitting (a.k.a, CRLF injection) is
      a common technique,\n   used in various attacks on Web usage, that exploits
      the line-based\n   nature of HTTP message framing and the ordered association
      of\n   requests to responses on persistent connections [Klein].  This\n   technique
      can be particularly damaging when the requests pass through\n   a shared cache.\n
      \  Response splitting exploits a vulnerability in servers (usually\n   within
      an application server) where an attacker can send encoded data\n   within some
      parameter of the request that is later decoded and echoed\n   within any of
      the response header fields of the response.  If the\n   decoded data is crafted
      to look like the response has ended and a\n   subsequent response has begun,
      the response has been split and the\n   content within the apparent second response
      is controlled by the\n   attacker.  The attacker can then make any other request
      on the same\n   persistent connection and trick the recipients (including\n
      \  intermediaries) into believing that the second half of the split is\n   an
      authoritative answer to the second request.\n   For example, a parameter within
      the request-target might be read by\n   an application server and reused within
      a redirect, resulting in the\n   same parameter being echoed in the Location
      header field of the\n   response.  If the parameter is decoded by the application
      and not\n   properly encoded when placed in the response field, the attacker
      can\n   send encoded CRLF octets and other content that will make the\n   application's
      single response look like two or more responses.\n   A common defense against
      response splitting is to filter requests for\n   data that looks like encoded
      CR and LF (e.g., \"%0D\" and \"%0A\").\n   However, that assumes the application
      server is only performing URI\n   decoding, rather than more obscure data transformations
      like charset\n   transcoding, XML entity translation, base64 decoding, sprintf\n
      \  reformatting, etc.  A more effective mitigation is to prevent\n   anything
      other than the server's core protocol libraries from sending\n   a CR or LF
      within the header section, which means restricting the\n   output of header
      fields to APIs that filter for bad octets and not\n   allowing application servers
      to write directly to the protocol\n   stream.\n"
    title: 9.4.  Response Splitting
  - contents:
    - "9.5.  Request Smuggling\n   Request smuggling ([Linhart]) is a technique that
      exploits\n   differences in protocol parsing among various recipients to hide\n
      \  additional requests (which might otherwise be blocked or disabled by\n   policy)
      within an apparently harmless request.  Like response\n   splitting, request
      smuggling can lead to a variety of attacks on HTTP\n   usage.\n   This specification
      has introduced new requirements on request\n   parsing, particularly with regard
      to message framing in\n   Section 3.3.3, to reduce the effectiveness of request
      smuggling.\n"
    title: 9.5.  Request Smuggling
  - contents:
    - "9.6.  Message Integrity\n   HTTP does not define a specific mechanism for ensuring
      message\n   integrity, instead relying on the error-detection ability of\n   underlying
      transport protocols and the use of length or\n   chunk-delimited framing to
      detect completeness.  Additional integrity\n   mechanisms, such as hash functions
      or digital signatures applied to\n   the content, can be selectively added to
      messages via extensible\n   metadata header fields.  Historically, the lack
      of a single integrity\n   mechanism has been justified by the informal nature
      of most HTTP\n   communication.  However, the prevalence of HTTP as an information\n
      \  access mechanism has resulted in its increasing use within\n   environments
      where verification of message integrity is crucial.\n   User agents are encouraged
      to implement configurable means for\n   detecting and reporting failures of
      message integrity such that those\n   means can be enabled within environments
      for which integrity is\n   necessary.  For example, a browser being used to
      view medical history\n   or drug interaction information needs to indicate to
      the user when\n   such information is detected by the protocol to be incomplete,\n
      \  expired, or corrupted during transfer.  Such mechanisms might be\n   selectively
      enabled via user agent extensions or the presence of\n   message integrity metadata
      in a response.  At a minimum, user agents\n   ought to provide some indication
      that allows a user to distinguish\n   between a complete and incomplete response
      message (Section 3.4) when\n   such verification is desired.\n"
    title: 9.6.  Message Integrity
  - contents:
    - "9.7.  Message Confidentiality\n   HTTP relies on underlying transport protocols
      to provide message\n   confidentiality when that is desired.  HTTP has been
      specifically\n   designed to be independent of the transport protocol, such
      that it\n   can be used over many different forms of encrypted connection, with\n
      \  the selection of such transports being identified by the choice of\n   URI
      scheme or within user agent configuration.\n   The \"https\" scheme can be used
      to identify resources that require a\n   confidential connection, as described
      in Section 2.7.2.\n"
    title: 9.7.  Message Confidentiality
  - contents:
    - "9.8.  Privacy of Server Log Information\n   A server is in the position to
      save personal data about a user's\n   requests over time, which might identify
      their reading patterns or\n   subjects of interest.  In particular, log information
      gathered at an\n   intermediary often contains a history of user agent interaction,\n
      \  across a multitude of sites, that can be traced to individual users.\n   HTTP
      log information is confidential in nature; its handling is often\n   constrained
      by laws and regulations.  Log information needs to be\n   securely stored and
      appropriate guidelines followed for its analysis.\n   Anonymization of personal
      information within individual entries\n   helps, but it is generally not sufficient
      to prevent real log traces\n   from being re-identified based on correlation
      with other access\n   characteristics.  As such, access traces that are keyed
      to a specific\n   client are unsafe to publish even if the key is pseudonymous.\n
      \  To minimize the risk of theft or accidental publication, log\n   information
      ought to be purged of personally identifiable\n   information, including user
      identifiers, IP addresses, and\n   user-provided query parameters, as soon as
      that information is no\n   longer necessary to support operational needs for
      security, auditing,\n   or fraud control.\n"
    title: 9.8.  Privacy of Server Log Information
  title: 9.  Security Considerations
- contents:
  - "10.  Acknowledgments\n   This edition of HTTP/1.1 builds on the many contributions
    that went\n   into RFC 1945, RFC 2068, RFC 2145, and RFC 2616, including\n   substantial
    contributions made by the previous authors, editors, and\n   Working Group Chairs:
    Tim Berners-Lee, Ari Luotonen, Roy T. Fielding,\n   Henrik Frystyk Nielsen, Jim
    Gettys, Jeffrey C. Mogul, Larry Masinter,\n   and Paul J. Leach.  Mark Nottingham
    oversaw this effort as Working\n   Group Chair.\n   Since 1999, the following
    contributors have helped improve the HTTP\n   specification by reporting bugs,
    asking smart questions, drafting or\n   reviewing text, and evaluating open issues:\n
    \  Adam Barth, Adam Roach, Addison Phillips, Adrian Chadd, Adrian Cole,\n   Adrien
    W. de Croy, Alan Ford, Alan Ruttenberg, Albert Lunde, Alek\n   Storm, Alex Rousskov,
    Alexandre Morgaut, Alexey Melnikov, Alisha\n   Smith, Amichai Rothman, Amit Klein,
    Amos Jeffries, Andreas Maier,\n   Andreas Petersson, Andrei Popov, Anil Sharma,
    Anne van Kesteren,\n   Anthony Bryan, Asbjorn Ulsberg, Ashok Kumar, Balachander\n
    \  Krishnamurthy, Barry Leiba, Ben Laurie, Benjamin Carlyle, Benjamin\n   Niven-Jenkins,
    Benoit Claise, Bil Corry, Bill Burke, Bjoern\n   Hoehrmann, Bob Scheifler, Boris
    Zbarsky, Brett Slatkin, Brian Kell,\n   Brian McBarron, Brian Pane, Brian Raymor,
    Brian Smith, Bruce Perens,\n   Bryce Nesbitt, Cameron Heavon-Jones, Carl Kugler,
    Carsten Bormann,\n   Charles Fry, Chris Burdess, Chris Newman, Christian Huitema,
    Cyrus\n   Daboo, Dale Robert Anderson, Dan Wing, Dan Winship, Daniel Stenberg,\n
    \  Darrel Miller, Dave Cridland, Dave Crocker, Dave Kristol, Dave\n   Thaler,
    David Booth, David Singer, David W. Morris, Diwakar Shetty,\n   Dmitry Kurochkin,
    Drummond Reed, Duane Wessels, Edward Lee, Eitan\n   Adler, Eliot Lear, Emile Stephan,
    Eran Hammer-Lahav, Eric D.\n   Williams, Eric J. Bowman, Eric Lawrence, Eric Rescorla,
    Erik\n   Aronesty, EungJun Yi, Evan Prodromou, Felix Geisendoerfer, Florian\n
    \  Weimer, Frank Ellermann, Fred Akalin, Fred Bohle, Frederic Kayser,\n   Gabor
    Molnar, Gabriel Montenegro, Geoffrey Sneddon, Gervase Markham,\n   Gili Tzabari,
    Grahame Grieve, Greg Slepak, Greg Wilkins, Grzegorz\n   Calkowski, Harald Tveit
    Alvestrand, Harry Halpin, Helge Hess, Henrik\n   Nordstrom, Henry S. Thompson,
    Henry Story, Herbert van de Sompel,\n   Herve Ruellan, Howard Melman, Hugo Haas,
    Ian Fette, Ian Hickson, Ido\n   Safruti, Ilari Liusvaara, Ilya Grigorik, Ingo
    Struck, J. Ross Nicoll,\n   James Cloos, James H. Manger, James Lacey, James M.
    Snell, Jamie\n   Lokier, Jan Algermissen, Jari Arkko, Jeff Hodges (who came up
    with\n   the term 'effective Request-URI'), Jeff Pinner, Jeff Walden, Jim\n   Luther,
    Jitu Padhye, Joe D. Williams, Joe Gregorio, Joe Orton, Joel\n   Jaeggli, John
    C. Klensin, John C. Mallery, John Cowan, John Kemp,\n   John Panzer, John Schneider,
    John Stracke, John Sullivan, Jonas\n   Sicking, Jonathan A. Rees, Jonathan Billington,
    Jonathan Moore,\n   Jonathan Silvera, Jordi Ros, Joris Dobbelsteen, Josh Cohen,
    Julien\n   Pierre, Jungshik Shin, Justin Chapweske, Justin Erenkrantz, Justin\n
    \  James, Kalvinder Singh, Karl Dubost, Kathleen Moriarty, Keith\n   Hoffman,
    Keith Moore, Ken Murchison, Koen Holtman, Konstantin\n   Voronkov, Kris Zyp, Leif
    Hedstrom, Lionel Morand, Lisa Dusseault,\n   Maciej Stachowiak, Manu Sporny, Marc
    Schneider, Marc Slemko, Mark\n   Baker, Mark Pauley, Mark Watson, Markus Isomaki,
    Markus Lanthaler,\n   Martin J. Duerst, Martin Musatov, Martin Nilsson, Martin
    Thomson,\n   Matt Lynch, Matthew Cox, Matthew Kerwin, Max Clark, Menachem Dodge,\n
    \  Meral Shirazipour, Michael Burrows, Michael Hausenblas, Michael\n   Scharf,
    Michael Sweet, Michael Tuexen, Michael Welzl, Mike Amundsen,\n   Mike Belshe,
    Mike Bishop, Mike Kelly, Mike Schinkel, Miles Sabin,\n   Murray S. Kucherawy,
    Mykyta Yevstifeyev, Nathan Rixham, Nicholas\n   Shanks, Nico Williams, Nicolas
    Alvarez, Nicolas Mailhot, Noah Slater,\n   Osama Mazahir, Pablo Castro, Pat Hayes,
    Patrick R. McManus, Paul E.\n   Jones, Paul Hoffman, Paul Marquess, Pete Resnick,
    Peter Lepeska,\n   Peter Occil, Peter Saint-Andre, Peter Watkins, Phil Archer,
    Phil\n   Hunt, Philippe Mougin, Phillip Hallam-Baker, Piotr Dobrogost, Poul-\n
    \  Henning Kamp, Preethi Natarajan, Rajeev Bector, Ray Polk, Reto\n   Bachmann-Gmuer,
    Richard Barnes, Richard Cyganiak, Rob Trace, Robby\n   Simpson, Robert Brewer,
    Robert Collins, Robert Mattson, Robert\n   O'Callahan, Robert Olofsson, Robert
    Sayre, Robert Siemer, Robert de\n   Wilde, Roberto Javier Godoy, Roberto Peon,
    Roland Zink, Ronny\n   Widjaja, Ryan Hamilton, S. Mike Dierken, Salvatore Loreto,
    Sam\n   Johnston, Sam Pullara, Sam Ruby, Saurabh Kulkarni, Scott Lawrence\n   (who
    maintained the original issues list), Sean B. Palmer, Sean\n   Turner, Sebastien
    Barnoud, Shane McCarron, Shigeki Ohtsu, Simon\n   Yarde, Stefan Eissing, Stefan
    Tilkov, Stefanos Harhalakis, Stephane\n   Bortzmeyer, Stephen Farrell, Stephen
    Kent, Stephen Ludin, Stuart\n   Williams, Subbu Allamaraju, Subramanian Moonesamy,
    Susan Hares,\n   Sylvain Hellegouarch, Tapan Divekar, Tatsuhiro Tsujikawa, Tatsuya\n
    \  Hayashi, Ted Hardie, Ted Lemon, Thomas Broyer, Thomas Fossati, Thomas\n   Maslen,
    Thomas Nadeau, Thomas Nordin, Thomas Roessler, Tim Bray, Tim\n   Morgan, Tim Olsen,
    Tom Zhou, Travis Snoozy, Tyler Close, Vincent\n   Murphy, Wenbo Zhu, Werner Baumann,
    Wilbur Streett, Wilfredo Sanchez\n   Vega, William A. Rowe Jr., William Chan,
    Willy Tarreau, Xiaoshu Wang,\n   Yaron Goland, Yngve Nysaeter Pettersen, Yoav
    Nir, Yogesh Bang,\n   Yuchung Cheng, Yutaka Oiwa, Yves Lafon (long-time member
    of the\n   editor team), Zed A. Shaw, and Zhong Yu.\n   See Section 16 of [RFC2616]
    for additional acknowledgements from\n   prior revisions.\n"
  title: 10.  Acknowledgments
- contents:
  - '11.  References

    '
  - contents:
    - "11.1.  Normative References\n   [RFC0793]     Postel, J., \"Transmission Control
      Protocol\", STD 7,\n                 RFC 793, September 1981.\n   [RFC1950]
      \    Deutsch, L. and J-L. Gailly, \"ZLIB Compressed Data\n                 Format
      Specification version 3.3\", RFC 1950, May 1996.\n   [RFC1951]     Deutsch,
      P., \"DEFLATE Compressed Data Format\n                 Specification version
      1.3\", RFC 1951, May 1996.\n   [RFC1952]     Deutsch, P., Gailly, J-L., Adler,
      M., Deutsch, L., and\n                 G. Randers-Pehrson, \"GZIP file format
      specification\n                 version 4.3\", RFC 1952, May 1996.\n   [RFC2119]
      \    Bradner, S., \"Key words for use in RFCs to Indicate\n                 Requirement
      Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC3986]     Berners-Lee, T., Fielding,
      R., and L. Masinter,\n                 \"Uniform Resource Identifier (URI):
      Generic Syntax\",\n                 STD 66, RFC 3986, January 2005.\n   [RFC5234]
      \    Crocker, D., Ed. and P. Overell, \"Augmented BNF for\n                 Syntax
      Specifications: ABNF\", STD 68, RFC 5234,\n                 January 2008.\n
      \  [RFC7231]     Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext\n                 Transfer
      Protocol (HTTP/1.1): Semantics and Content\",\n                 RFC 7231, June
      2014.\n   [RFC7232]     Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext\n
      \                Transfer Protocol (HTTP/1.1): Conditional Requests\",\n                 RFC
      7232, June 2014.\n   [RFC7233]     Fielding, R., Ed., Lafon, Y., Ed., and J.
      Reschke, Ed.,\n                 \"Hypertext Transfer Protocol (HTTP/1.1): Range\n
      \                Requests\", RFC 7233, June 2014.\n   [RFC7234]     Fielding,
      R., Ed., Nottingham, M., Ed., and J. Reschke,\n                 Ed., \"Hypertext
      Transfer Protocol (HTTP/1.1): Caching\",\n                 RFC 7234, June 2014.\n
      \  [RFC7235]     Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext\n                 Transfer
      Protocol (HTTP/1.1): Authentication\",\n                 RFC 7235, June 2014.\n
      \  [USASCII]     American National Standards Institute, \"Coded Character\n
      \                Set -- 7-bit American Standard Code for Information\n                 Interchange\",
      ANSI X3.4, 1986.\n   [Welch]       Welch, T., \"A Technique for High-Performance
      Data\n                 Compression\", IEEE Computer 17(6), June 1984.\n"
    title: 11.1.  Normative References
  - contents:
    - "11.2.  Informative References\n   [BCP115]      Hansen, T., Hardie, T., and
      L. Masinter, \"Guidelines\n                 and Registration Procedures for
      New URI Schemes\",\n                 BCP 115, RFC 4395, February 2006.\n   [BCP13]
      \      Freed, N., Klensin, J., and T. Hansen, \"Media Type\n                 Specifications
      and Registration Procedures\", BCP 13,\n                 RFC 6838, January 2013.\n
      \  [BCP90]       Klyne, G., Nottingham, M., and J. Mogul, \"Registration\n                 Procedures
      for Message Header Fields\", BCP 90,\n                 RFC 3864, September 2004.\n
      \  [Georgiev]    Georgiev, M., Iyengar, S., Jana, S., Anubhai, R.,\n                 Boneh,
      D., and V. Shmatikov, \"The Most Dangerous Code\n                 in the World:
      Validating SSL Certificates in Non-\n                 browser Software\", In
      Proceedings of the 2012 ACM\n                 Conference on Computer and Communications
      Security (CCS\n                 '12), pp. 38-49, October 2012,\n                 <http://doi.acm.org/10.1145/2382196.2382204>.\n
      \  [ISO-8859-1]  International Organization for Standardization,\n                 \"Information
      technology -- 8-bit single-byte coded\n                 graphic character sets
      -- Part 1: Latin alphabet No.\n                 1\", ISO/IEC 8859-1:1998, 1998.\n
      \  [Klein]       Klein, A., \"Divide and Conquer - HTTP Response\n                 Splitting,
      Web Cache Poisoning Attacks, and Related\n                 Topics\", March 2004,
      <http://packetstormsecurity.com/\n                 papers/general/whitepaper_httpresponse.pdf>.\n
      \  [Kri2001]     Kristol, D., \"HTTP Cookies: Standards, Privacy, and\n                 Politics\",
      ACM Transactions on Internet\n                 Technology 1(2), November 2001,\n
      \                <http://arxiv.org/abs/cs.SE/0105018>.\n   [Linhart]     Linhart,
      C., Klein, A., Heled, R., and S. Orrin, \"HTTP\n                 Request Smuggling\",
      June 2005,\n                 <http://www.watchfire.com/news/whitepapers.aspx>.\n
      \  [RFC1919]     Chatel, M., \"Classical versus Transparent IP Proxies\",\n
      \                RFC 1919, March 1996.\n   [RFC1945]     Berners-Lee, T., Fielding,
      R., and H. Nielsen,\n                 \"Hypertext Transfer Protocol -- HTTP/1.0\",
      RFC 1945,\n                 May 1996.\n   [RFC2045]     Freed, N. and N. Borenstein,
      \"Multipurpose Internet\n                 Mail Extensions (MIME) Part One: Format
      of Internet\n                 Message Bodies\", RFC 2045, November 1996.\n   [RFC2047]
      \    Moore, K., \"MIME (Multipurpose Internet Mail\n                 Extensions)
      Part Three: Message Header Extensions for\n                 Non-ASCII Text\",
      RFC 2047, November 1996.\n   [RFC2068]     Fielding, R., Gettys, J., Mogul,
      J., Nielsen, H., and\n                 T. Berners-Lee, \"Hypertext Transfer
      Protocol --\n                 HTTP/1.1\", RFC 2068, January 1997.\n   [RFC2145]
      \    Mogul, J., Fielding, R., Gettys, J., and H. Nielsen,\n                 \"Use
      and Interpretation of HTTP Version Numbers\",\n                 RFC 2145, May
      1997.\n   [RFC2616]     Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,\n
      \                Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext\n
      \                Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.\n   [RFC2817]
      \    Khare, R. and S. Lawrence, \"Upgrading to TLS Within\n                 HTTP/1.1\",
      RFC 2817, May 2000.\n   [RFC2818]     Rescorla, E., \"HTTP Over TLS\", RFC 2818,
      May 2000.\n   [RFC3040]     Cooper, I., Melve, I., and G. Tomlinson, \"Internet
      Web\n                 Replication and Caching Taxonomy\", RFC 3040,\n                 January
      2001.\n   [RFC4033]     Arends, R., Austein, R., Larson, M., Massey, D., and
      S.\n                 Rose, \"DNS Security Introduction and Requirements\",\n
      \                RFC 4033, March 2005.\n   [RFC4559]     Jaganathan, K., Zhu,
      L., and J. Brezak, \"SPNEGO-based\n                 Kerberos and NTLM HTTP Authentication
      in Microsoft\n                 Windows\", RFC 4559, June 2006.\n   [RFC5226]
      \    Narten, T. and H. Alvestrand, \"Guidelines for Writing\n                 an
      IANA Considerations Section in RFCs\", BCP 26,\n                 RFC 5226, May
      2008.\n   [RFC5246]     Dierks, T. and E. Rescorla, \"The Transport Layer\n
      \                Security (TLS) Protocol Version 1.2\", RFC 5246,\n                 August
      2008.\n   [RFC5322]     Resnick, P., \"Internet Message Format\", RFC 5322,\n
      \                October 2008.\n   [RFC6265]     Barth, A., \"HTTP State Management
      Mechanism\", RFC 6265,\n                 April 2011.\n   [RFC6585]     Nottingham,
      M. and R. Fielding, \"Additional HTTP Status\n                 Codes\", RFC
      6585, April 2012.\n"
    title: 11.2.  Informative References
  title: 11.  References
- contents:
  - "Appendix A.  HTTP Version History\n   HTTP has been in use since 1990.  The first
    version, later referred\n   to as HTTP/0.9, was a simple protocol for hypertext
    data transfer\n   across the Internet, using only a single request method (GET)
    and no\n   metadata.  HTTP/1.0, as defined by [RFC1945], added a range of\n   request
    methods and MIME-like messaging, allowing for metadata to be\n   transferred and
    modifiers placed on the request/response semantics.\n   However, HTTP/1.0 did
    not sufficiently take into consideration the\n   effects of hierarchical proxies,
    caching, the need for persistent\n   connections, or name-based virtual hosts.
    \ The proliferation of\n   incompletely implemented applications calling themselves
    \"HTTP/1.0\"\n   further necessitated a protocol version change in order for two\n
    \  communicating applications to determine each other's true\n   capabilities.\n
    \  HTTP/1.1 remains compatible with HTTP/1.0 by including more stringent\n   requirements
    that enable reliable implementations, adding only those\n   features that can
    either be safely ignored by an HTTP/1.0 recipient\n   or only be sent when communicating
    with a party advertising\n   conformance with HTTP/1.1.\n   HTTP/1.1 has been
    designed to make supporting previous versions easy.\n   A general-purpose HTTP/1.1
    server ought to be able to understand any\n   valid request in the format of HTTP/1.0,
    responding appropriately\n   with an HTTP/1.1 message that only uses features
    understood (or\n   safely ignored) by HTTP/1.0 clients.  Likewise, an HTTP/1.1
    client\n   can be expected to understand any valid HTTP/1.0 response.\n   Since
    HTTP/0.9 did not support header fields in a request, there is\n   no mechanism
    for it to support name-based virtual hosts (selection of\n   resource by inspection
    of the Host header field).  Any server that\n   implements name-based virtual
    hosts ought to disable support for\n   HTTP/0.9.  Most requests that appear to
    be HTTP/0.9 are, in fact,\n   badly constructed HTTP/1.x requests caused by a
    client failing to\n   properly encode the request-target.\n"
  - contents:
    - "A.1.  Changes from HTTP/1.0\n   This section summarizes major differences between
      versions HTTP/1.0\n   and HTTP/1.1.\n"
    - contents:
      - "A.1.1.  Multihomed Web Servers\n   The requirements that clients and servers
        support the Host header\n   field (Section 5.4), report an error if it is
        missing from an\n   HTTP/1.1 request, and accept absolute URIs (Section 5.3)
        are among\n   the most important changes defined by HTTP/1.1.\n   Older HTTP/1.0
        clients assumed a one-to-one relationship of IP\n   addresses and servers;
        there was no other established mechanism for\n   distinguishing the intended
        server of a request than the IP address\n   to which that request was directed.
        \ The Host header field was\n   introduced during the development of HTTP/1.1
        and, though it was\n   quickly implemented by most HTTP/1.0 browsers, additional\n
        \  requirements were placed on all HTTP/1.1 requests in order to ensure\n
        \  complete adoption.  At the time of this writing, most HTTP-based\n   services
        are dependent upon the Host header field for targeting\n   requests.\n"
      title: A.1.1.  Multihomed Web Servers
    - contents:
      - "A.1.2.  Keep-Alive Connections\n   In HTTP/1.0, each connection is established
        by the client prior to\n   the request and closed by the server after sending
        the response.\n   However, some implementations implement the explicitly negotiated\n
        \  (\"Keep-Alive\") version of persistent connections described in Section\n
        \  19.7.1 of [RFC2068].\n   Some clients and servers might wish to be compatible
        with these\n   previous approaches to persistent connections, by explicitly\n
        \  negotiating for them with a \"Connection: keep-alive\" request header\n
        \  field.  However, some experimental implementations of HTTP/1.0\n   persistent
        connections are faulty; for example, if an HTTP/1.0 proxy\n   server doesn't
        understand Connection, it will erroneously forward\n   that header field to
        the next inbound server, which would result in a\n   hung connection.\n   One
        attempted solution was the introduction of a Proxy-Connection\n   header field,
        targeted specifically at proxies.  In practice, this\n   was also unworkable,
        because proxies are often deployed in multiple\n   layers, bringing about
        the same problem discussed above.\n   As a result, clients are encouraged
        not to send the Proxy-Connection\n   header field in any requests.\n   Clients
        are also encouraged to consider the use of Connection:\n   keep-alive in requests
        carefully; while they can enable persistent\n   connections with HTTP/1.0
        servers, clients using them will need to\n   monitor the connection for \"hung\"
        requests (which indicate that the\n   client ought stop sending the header
        field), and this mechanism ought\n   not be used by clients at all when a
        proxy is being used.\n"
      title: A.1.2.  Keep-Alive Connections
    - contents:
      - "A.1.3.  Introduction of Transfer-Encoding\n   HTTP/1.1 introduces the Transfer-Encoding
        header field\n   (Section 3.3.1).  Transfer codings need to be decoded prior
        to\n   forwarding an HTTP message over a MIME-compliant protocol.\n"
      title: A.1.3.  Introduction of Transfer-Encoding
    title: A.1.  Changes from HTTP/1.0
  - contents:
    - "A.2.  Changes from RFC 2616\n   HTTP's approach to error handling has been
      explained.  (Section 2.5)\n   The HTTP-version ABNF production has been clarified
      to be case-\n   sensitive.  Additionally, version numbers have been restricted
      to\n   single digits, due to the fact that implementations are known to\n   handle
      multi-digit version numbers incorrectly.  (Section 2.6)\n   Userinfo (i.e.,
      username and password) are now disallowed in HTTP and\n   HTTPS URIs, because
      of security issues related to their transmission\n   on the wire.  (Section
      2.7.1)\n   The HTTPS URI scheme is now defined by this specification;\n   previously,
      it was done in Section 2.4 of [RFC2818].  Furthermore, it\n   implies end-to-end
      security.  (Section 2.7.2)\n   HTTP messages can be (and often are) buffered
      by implementations;\n   despite it sometimes being available as a stream, HTTP
      is\n   fundamentally a message-oriented protocol.  Minimum supported sizes\n
      \  for various protocol elements have been suggested, to improve\n   interoperability.
      \ (Section 3)\n   Invalid whitespace around field-names is now required to be
      rejected,\n   because accepting it represents a security vulnerability.  The
      ABNF\n   productions defining header fields now only list the field value.\n
      \  (Section 3.2)\n   Rules about implicit linear whitespace between certain
      grammar\n   productions have been removed; now whitespace is only allowed where\n
      \  specifically defined in the ABNF.  (Section 3.2.3)\n   Header fields that
      span multiple lines (\"line folding\") are\n   deprecated.  (Section 3.2.4)\n
      \  The NUL octet is no longer allowed in comment and quoted-string text,\n   and
      handling of backslash-escaping in them has been clarified.  The\n   quoted-pair
      rule no longer allows escaping control characters other\n   than HTAB.  Non-US-ASCII
      content in header fields and the reason\n   phrase has been obsoleted and made
      opaque (the TEXT rule was\n   removed).  (Section 3.2.6)\n   Bogus Content-Length
      header fields are now required to be handled as\n   errors by recipients.  (Section
      3.3.2)\n   The algorithm for determining the message body length has been\n
      \  clarified to indicate all of the special cases (e.g., driven by\n   methods
      or status codes) that affect it, and that new protocol\n   elements cannot define
      such special cases.  CONNECT is a new, special\n   case in determining message
      body length. \"multipart/byteranges\" is no\n   longer a way of determining
      message body length detection.\n   (Section 3.3.3)\n   The \"identity\" transfer
      coding token has been removed.  (Sections 3.3\n   and 4)\n   Chunk length does
      not include the count of the octets in the chunk\n   header and trailer.  Line
      folding in chunk extensions is disallowed.\n   (Section 4.1)\n   The meaning
      of the \"deflate\" content coding has been clarified.\n   (Section 4.2.2)\n
      \  The segment + query components of RFC 3986 have been used to define\n   the
      request-target, instead of abs_path from RFC 1808.  The\n   asterisk-form of
      the request-target is only allowed with the OPTIONS\n   method.  (Section 5.3)\n
      \  The term \"Effective Request URI\" has been introduced.  (Section 5.5)\n
      \  Gateways do not need to generate Via header fields anymore.\n   (Section
      5.7.1)\n   Exactly when \"close\" connection options have to be sent has been\n
      \  clarified.  Also, \"hop-by-hop\" header fields are required to appear\n   in
      the Connection header field; just because they're defined as hop-\n   by-hop
      in this specification doesn't exempt them.  (Section 6.1)\n   The limit of two
      connections per server has been removed.  An\n   idempotent sequence of requests
      is no longer required to be retried.\n   The requirement to retry requests under
      certain circumstances when\n   the server prematurely closes the connection
      has been removed.  Also,\n   some extraneous requirements about when servers
      are allowed to close\n   connections prematurely have been removed.  (Section
      6.3)\n   The semantics of the Upgrade header field is now defined in responses\n
      \  other than 101 (this was incorporated from [RFC2817]).  Furthermore,\n   the
      ordering in the field value is now significant.  (Section 6.7)\n   Empty list
      elements in list productions (e.g., a list header field\n   containing \", ,\")
      have been deprecated.  (Section 7)\n   Registration of Transfer Codings now
      requires IETF Review\n   (Section 8.4)\n   This specification now defines the
      Upgrade Token Registry, previously\n   defined in Section 7.2 of [RFC2817].
      \ (Section 8.6)\n   The expectation to support HTTP/0.9 requests has been removed.\n
      \  (Appendix A)\n   Issues with the Keep-Alive and Proxy-Connection header fields
      in\n   requests are pointed out, with use of the latter being discouraged\n
      \  altogether.  (Appendix A.1.2)\n"
    title: A.2.  Changes from RFC 2616
  title: Appendix A.  HTTP Version History
- contents:
  - "Appendix B.  Collected ABNF\n   BWS = OWS\n   Connection = *( \",\" OWS ) connection-option
    *( OWS \",\" [ OWS\n    connection-option ] )\n   Content-Length = 1*DIGIT\n   HTTP-message
    = start-line *( header-field CRLF ) CRLF [ message-body\n    ]\n   HTTP-name =
    %x48.54.54.50 ; HTTP\n   HTTP-version = HTTP-name \"/\" DIGIT \".\" DIGIT\n   Host
    = uri-host [ \":\" port ]\n   OWS = *( SP / HTAB )\n   RWS = 1*( SP / HTAB )\n
    \  TE = [ ( \",\" / t-codings ) *( OWS \",\" [ OWS t-codings ] ) ]\n   Trailer
    = *( \",\" OWS ) field-name *( OWS \",\" [ OWS field-name ] )\n   Transfer-Encoding
    = *( \",\" OWS ) transfer-coding *( OWS \",\" [ OWS\n    transfer-coding ] )\n
    \  URI-reference = <URI-reference, see [RFC3986], Section 4.1>\n   Upgrade = *(
    \",\" OWS ) protocol *( OWS \",\" [ OWS protocol ] )\n   Via = *( \",\" OWS )
    ( received-protocol RWS received-by [ RWS comment\n    ] ) *( OWS \",\" [ OWS
    ( received-protocol RWS received-by [ RWS\n    comment ] ) ] )\n   absolute-URI
    = <absolute-URI, see [RFC3986], Section 4.3>\n   absolute-form = absolute-URI\n
    \  absolute-path = 1*( \"/\" segment )\n   asterisk-form = \"*\"\n   authority
    = <authority, see [RFC3986], Section 3.2>\n   authority-form = authority\n   chunk
    = chunk-size [ chunk-ext ] CRLF chunk-data CRLF\n   chunk-data = 1*OCTET\n   chunk-ext
    = *( \";\" chunk-ext-name [ \"=\" chunk-ext-val ] )\n   chunk-ext-name = token\n
    \  chunk-ext-val = token / quoted-string\n   chunk-size = 1*HEXDIG\n   chunked-body
    = *chunk last-chunk trailer-part CRLF\n   comment = \"(\" *( ctext / quoted-pair
    / comment ) \")\"\n   connection-option = token\n   ctext = HTAB / SP / %x21-27
    ; '!'-'''\n    / %x2A-5B ; '*'-'['\n    / %x5D-7E ; ']'-'~'\n    / obs-text\n
    \  field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n   field-name
    = token\n   field-value = *( field-content / obs-fold )\n   field-vchar = VCHAR
    / obs-text\n   fragment = <fragment, see [RFC3986], Section 3.5>\n   header-field
    = field-name \":\" OWS field-value OWS\n   http-URI = \"http://\" authority path-abempty
    [ \"?\" query ] [ \"#\"\n    fragment ]\n   https-URI = \"https://\" authority
    path-abempty [ \"?\" query ] [ \"#\"\n    fragment ]\n   last-chunk = 1*\"0\"
    [ chunk-ext ] CRLF\n   message-body = *OCTET\n   method = token\n   obs-fold =
    CRLF 1*( SP / HTAB )\n   obs-text = %x80-FF\n   origin-form = absolute-path [
    \"?\" query ]\n   partial-URI = relative-part [ \"?\" query ]\n   path-abempty
    = <path-abempty, see [RFC3986], Section 3.3>\n   port = <port, see [RFC3986],
    Section 3.2.3>\n   protocol = protocol-name [ \"/\" protocol-version ]\n   protocol-name
    = token\n   protocol-version = token\n   pseudonym = token\n   qdtext = HTAB /
    SP / \"!\" / %x23-5B ; '#'-'['\n    / %x5D-7E ; ']'-'~'\n    / obs-text\n   query
    = <query, see [RFC3986], Section 3.4>\n   quoted-pair = \"\\\" ( HTAB / SP / VCHAR
    / obs-text )\n   quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n   rank
    = ( \"0\" [ \".\" *3DIGIT ] ) / ( \"1\" [ \".\" *3\"0\" ] )\n   reason-phrase
    = *( HTAB / SP / VCHAR / obs-text )\n   received-by = ( uri-host [ \":\" port
    ] ) / pseudonym\n   received-protocol = [ protocol-name \"/\" ] protocol-version\n
    \  relative-part = <relative-part, see [RFC3986], Section 4.2>\n   request-line
    = method SP request-target SP HTTP-version CRLF\n   request-target = origin-form
    / absolute-form / authority-form /\n    asterisk-form\n   scheme = <scheme, see
    [RFC3986], Section 3.1>\n   segment = <segment, see [RFC3986], Section 3.3>\n
    \  start-line = request-line / status-line\n   status-code = 3DIGIT\n   status-line
    = HTTP-version SP status-code SP reason-phrase CRLF\n   t-codings = \"trailers\"
    / ( transfer-coding [ t-ranking ] )\n   t-ranking = OWS \";\" OWS \"q=\" rank\n
    \  tchar = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\"
    / \".\" /\n    \"^\" / \"_\" / \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\n   token
    = 1*tchar\n   trailer-part = *( header-field CRLF )\n   transfer-coding = \"chunked\"
    / \"compress\" / \"deflate\" / \"gzip\" /\n    transfer-extension\n   transfer-extension
    = token *( OWS \";\" OWS transfer-parameter )\n   transfer-parameter = token BWS
    \"=\" BWS ( token / quoted-string )\n   uri-host = <host, see [RFC3986], Section
    3.2.2>\n"
  title: Appendix B.  Collected ABNF
- contents:
  - "Index\n   A\n      absolute-form (of request-target)  42\n      accelerator  10\n
    \     application/http Media Type  63\n      asterisk-form (of request-target)
    \ 43\n      authoritative response  67\n      authority-form (of request-target)
    \ 42-43\n   B\n      browser  7\n   C\n      cache  11\n      cacheable  12\n
    \     captive portal  11\n      chunked (Coding Format)  28, 32, 36\n      client
    \ 7\n      close  51, 56\n      compress (Coding Format)  38\n      connection
    \ 7\n      Connection header field  51, 56\n      Content-Length header field
    \ 30\n   D\n      deflate (Coding Format)  38\n      Delimiters  27\n      downstream
    \ 10\n   E\n      effective request URI  45\n   G\n      gateway  10\n      Grammar\n
    \        absolute-form  42\n         absolute-path  16\n         absolute-URI
    \ 16\n         ALPHA  6\n         asterisk-form  41, 43\n         authority  16\n
    \        authority-form  42-43\n         BWS  25\n         chunk  36\n         chunk-data
    \ 36\n         chunk-ext  36\n         chunk-ext-name  36\n         chunk-ext-val
    \ 36\n         chunk-size  36\n         chunked-body  36\n         comment  27\n
    \        Connection  51\n         connection-option  51\n         Content-Length
    \ 30\n         CR  6\n         CRLF  6\n         ctext  27\n         CTL  6\n
    \        DIGIT  6\n         DQUOTE  6\n         field-content  23\n         field-name
    \ 23, 40\n         field-value  23\n         field-vchar  23\n         fragment
    \ 16\n         header-field  23, 37\n         HEXDIG  6\n         Host  44\n         HTAB
    \ 6\n         HTTP-message  19\n         HTTP-name  14\n         http-URI  17\n
    \        HTTP-version  14\n         https-URI  18\n         last-chunk  36\n         LF
    \ 6\n         message-body  28\n         method  21\n         obs-fold  23\n         obs-text
    \ 27\n         OCTET  6\n         origin-form  42\n         OWS  25\n         partial-URI
    \ 16\n         port  16\n         protocol-name  47\n         protocol-version
    \ 47\n         pseudonym  47\n         qdtext  27\n         query  16\n         quoted-pair
    \ 27\n         quoted-string  27\n         rank  39\n         reason-phrase  22\n
    \        received-by  47\n         received-protocol  47\n         request-line
    \ 21\n         request-target  41\n         RWS  25\n         scheme  16\n         segment
    \ 16\n         SP  6\n         start-line  21\n         status-code  22\n         status-line
    \ 22\n         t-codings  39\n         t-ranking  39\n         tchar  27\n         TE
    \ 39\n         token  27\n         Trailer  40\n         trailer-part  37\n         transfer-coding
    \ 35\n         Transfer-Encoding  28\n         transfer-extension  35\n         transfer-parameter
    \ 35\n         Upgrade  57\n         uri-host  16\n         URI-reference  16\n
    \        VCHAR  6\n         Via  47\n      gzip (Coding Format)  39\n   H\n      header
    field  19\n      header section  19\n      headers  19\n      Host header field
    \ 44\n      http URI scheme  17\n      https URI scheme  17\n   I\n      inbound
    \ 9\n      interception proxy  11\n      intermediary  9\n   M\n      Media Type\n
    \        application/http  63\n         message/http  62\n      message  7\n      message/http
    Media Type  62\n      method  21\n   N\n      non-transforming proxy  49\n   O\n
    \     origin server  7\n      origin-form (of request-target)  42\n      outbound
    \ 10\n   P\n      phishing  67\n      proxy  10\n   R\n      recipient  7\n      request
    \ 7\n      request-target  21\n      resource  16\n      response  7\n      reverse
    proxy  10\n   S\n      sender  7\n      server  7\n      spider  7\n   T\n      target
    resource  40\n      target URI  40\n      TE header field  39\n      Trailer header
    field  40\n      Transfer-Encoding header field  28\n      transforming proxy
    \ 49\n      transparent proxy  11\n      tunnel  10\n   U\n      Upgrade header
    field  57\n      upstream  9\n      URI scheme\n         http  17\n         https
    \ 17\n      user agent  7\n   V\n      Via header field  47\n"
  title: Index
- contents:
  - "Authors' Addresses\n   Roy T. Fielding (editor)\n   Adobe Systems Incorporated\n
    \  345 Park Ave\n   San Jose, CA  95110\n   USA\n   EMail: fielding@gbiv.com\n
    \  URI:   http://roy.gbiv.com/\n   Julian F. Reschke (editor)\n   greenbytes GmbH\n
    \  Hafenweg 16\n   Muenster, NW  48155\n   Germany\n   EMail: julian.reschke@greenbytes.de\n
    \  URI:   http://greenbytes.de/tech/webdav/\n"
  title: Authors' Addresses
