- contents:
  - "             Interactive Connectivity Establishment (ICE):\n       A Protocol
    for Network Address Translator (NAT) Traversal\n"
  title: __initial_text__
- contents:
  - "Abstract\n   This document describes a protocol for Network Address Translator\n
    \  (NAT) traversal for UDP-based communication.  This protocol is called\n   Interactive
    Connectivity Establishment (ICE).  ICE makes use of the\n   Session Traversal
    Utilities for NAT (STUN) protocol and its\n   extension, Traversal Using Relay
    NAT (TURN).\n   This document obsoletes RFC 5245.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8445.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2018 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   5\n   2.  Overview of ICE . . . . . . . . . . . . . . . . . . . .
    . . .   6\n     2.1.  Gathering Candidates  . . . . . . . . . . . . . . . . .
    .   8\n     2.2.  Connectivity Checks . . . . . . . . . . . . . . . . . . .  10\n
    \    2.3.  Nominating Candidate Pairs and Concluding ICE . . . . . .  12\n     2.4.
    \ ICE Restart . . . . . . . . . . . . . . . . . . . . . . .  13\n     2.5.  Lite
    Implementations  . . . . . . . . . . . . . . . . . .  13\n   3.  ICE Usage . .
    . . . . . . . . . . . . . . . . . . . . . . . .  13\n   4.  Terminology . . .
    . . . . . . . . . . . . . . . . . . . . . .  13\n   5.  ICE Candidate Gathering
    and Exchange  . . . . . . . . . . . .  17\n     5.1.  Full Implementation . .
    . . . . . . . . . . . . . . . . .  17\n       5.1.1.  Gathering Candidates  .
    . . . . . . . . . . . . . . .  18\n         5.1.1.1.  Host Candidates . . . .
    . . . . . . . . . . . . .  18\n         5.1.1.2.  Server-Reflexive and Relayed
    Candidates . . . . .  20\n         5.1.1.3.  Computing Foundations . . . . . .
    . . . . . . . .  21\n         5.1.1.4.  Keeping Candidates Alive  . . . . . .
    . . . . . .  21\n       5.1.2.  Prioritizing Candidates . . . . . . . . . . .
    . . . .  22\n         5.1.2.1.  Recommended Formula . . . . . . . . . . . . .
    . .  22\n         5.1.2.2.  Guidelines for Choosing Type and Local\n                   Preferences
    . . . . . . . . . . . . . . . . . . .  23\n       5.1.3.  Eliminating Redundant
    Candidates  . . . . . . . . . .  23\n     5.2.  Lite Implementation Procedures
    \ . . . . . . . . . . . . .  23\n     5.3.  Exchanging Candidate Information  .
    . . . . . . . . . . .  24\n     5.4.  ICE Mismatch  . . . . . . . . . . . . .
    . . . . . . . . .  26\n   6.  ICE Candidate Processing  . . . . . . . . . . .
    . . . . . . .  26\n     6.1.  Procedures for Full Implementation  . . . . . .
    . . . . .  26\n       6.1.1.  Determining Role  . . . . . . . . . . . . . . .
    . . .  26\n       6.1.2.  Forming the Checklists  . . . . . . . . . . . . . .
    .  28\n         6.1.2.1.  Checklist State . . . . . . . . . . . . . . . . .  28\n
    \        6.1.2.2.  Forming Candidate Pairs . . . . . . . . . . . . .  28\n         6.1.2.3.
    \ Computing Pair Priority and Ordering Pairs  . . .  31\n         6.1.2.4.  Pruning
    the Pairs . . . . . . . . . . . . . . . .  31\n         6.1.2.5.  Removing Lower-Priority
    Pairs . . . . . . . . . .  31\n         6.1.2.6.  Computing Candidate Pair States
    . . . . . . . . .  32\n       6.1.3.  ICE State . . . . . . . . . . . . . . .
    . . . . . . .  36\n       6.1.4.  Scheduling Checks . . . . . . . . . . . . .
    . . . . .  36\n         6.1.4.1.  Triggered-Check Queue . . . . . . . . . . .
    . . .  36\n         6.1.4.2.  Performing Connectivity Checks  . . . . . . . .
    .  36\n     6.2.  Lite Implementation Procedures  . . . . . . . . . . . . .  38\n
    \  7.  Performing Connectivity Checks  . . . . . . . . . . . . . . .  38\n     7.1.
    \ STUN Extensions . . . . . . . . . . . . . . . . . . . . .  38\n       7.1.1.
    \ PRIORITY  . . . . . . . . . . . . . . . . . . . . . .  38\n       7.1.2.  USE-CANDIDATE
    . . . . . . . . . . . . . . . . . . . .  38\n       7.1.3.  ICE-CONTROLLED and
    ICE-CONTROLLING  . . . . . . . . .  39\n     7.2.  STUN Client Procedures  . .
    . . . . . . . . . . . . . . .  39\n       7.2.1.  Creating Permissions for Relayed
    Candidates . . . . .  39\n       7.2.2.  Forming Credentials . . . . . . . . .
    . . . . . . . .  39\n       7.2.3.  Diffserv Treatment  . . . . . . . . . . .
    . . . . . .  40\n       7.2.4.  Sending the Request . . . . . . . . . . . . .
    . . . .  40\n       7.2.5.  Processing the Response . . . . . . . . . . . . .
    . .  40\n         7.2.5.1.  Role Conflict . . . . . . . . . . . . . . . . . .
    \ 40\n         7.2.5.2.  Failure . . . . . . . . . . . . . . . . . . . . .  41\n
    \          7.2.5.2.1.  Non-Symmetric Transport Addresses . . . . . .  41\n           7.2.5.2.2.
    \ ICMP Error  . . . . . . . . . . . . . . . . .  41\n           7.2.5.2.3.  Timeout
    . . . . . . . . . . . . . . . . . . .  41\n           7.2.5.2.4.  Unrecoverable
    STUN Response . . . . . . . . .  41\n         7.2.5.3.  Success . . . . . . .
    . . . . . . . . . . . . . .  42\n           7.2.5.3.1.  Discovering Peer-Reflexive
    Candidates . . . .  42\n           7.2.5.3.2.  Constructing a Valid Pair . . .
    . . . . . . .  43\n           7.2.5.3.3.  Updating Candidate Pair States  . .
    . . . . .  44\n           7.2.5.3.4.  Updating the Nominated Flag . . . . . .
    . . .  44\n         7.2.5.4.  Checklist State Updates . . . . . . . . . . . .
    .  44\n     7.3.  STUN Server Procedures  . . . . . . . . . . . . . . . . .  45\n
    \      7.3.1.  Additional Procedures for Full Implementations  . . .  45\n         7.3.1.1.
    \ Detecting and Repairing Role Conflicts  . . . . .  46\n         7.3.1.2.  Computing
    Mapped Addresses  . . . . . . . . . . .  47\n         7.3.1.3.  Learning Peer-Reflexive
    Candidates  . . . . . . .  47\n         7.3.1.4.  Triggered Checks  . . . . .
    . . . . . . . . . . .  47\n         7.3.1.5.  Updating the Nominated Flag . .
    . . . . . . . . .  49\n       7.3.2.  Additional Procedures for Lite Implementations
    \ . . .  49\n   8.  Concluding ICE Processing . . . . . . . . . . . . . . . .
    . .  50\n     8.1.  Procedures for Full Implementations . . . . . . . . . . .
    \ 50\n       8.1.1.  Nominating Pairs  . . . . . . . . . . . . . . . . . .  50\n
    \      8.1.2.  Updating Checklist and ICE States . . . . . . . . . .  51\n     8.2.
    \ Procedures for Lite Implementations . . . . . . . . . . .  52\n     8.3.  Freeing
    Candidates  . . . . . . . . . . . . . . . . . . .  53\n       8.3.1.  Full Implementation
    Procedures  . . . . . . . . . . .  53\n       8.3.2.  Lite Implementation Procedures
    \ . . . . . . . . . . .  53\n   9.  ICE Restarts  . . . . . . . . . . . . . .
    . . . . . . . . . .  53\n   10. ICE Option  . . . . . . . . . . . . . . . . .
    . . . . . . . .  54\n   11. Keepalives  . . . . . . . . . . . . . . . . . . .
    . . . . . .  54\n   12. Data Handling . . . . . . . . . . . . . . . . . . . .
    . . . .  55\n     12.1.  Sending Data . . . . . . . . . . . . . . . . . . . .
    . .  55\n       12.1.1.  Procedures for Lite Implementations  . . . . . . . .
    \ 56\n     12.2.  Receiving Data . . . . . . . . . . . . . . . . . . . . .  56\n
    \  13. Extensibility Considerations  . . . . . . . . . . . . . . . .  57\n   14.
    Setting Ta and RTO  . . . . . . . . . . . . . . . . . . . . .  57\n     14.1.
    \ General  . . . . . . . . . . . . . . . . . . . . . . . .  57\n     14.2.  Ta
    . . . . . . . . . . . . . . . . . . . . . . . . . . .  58\n     14.3.  RTO  .
    . . . . . . . . . . . . . . . . . . . . . . . . .  58\n   15. Examples  . . .
    . . . . . . . . . . . . . . . . . . . . . . .  59\n     15.1.  Example with IPv4
    Addresses  . . . . . . . . . . . . . .  60\n     15.2.  Example with IPv6 Addresses
    \ . . . . . . . . . . . . . .  65\n   16. STUN Extensions . . . . . . . . . .
    . . . . . . . . . . . . .  69\n     16.1.  Attributes . . . . . . . . . . . .
    . . . . . . . . . . .  69\n     16.2.  New Error-Response Codes . . . . . . .
    . . . . . . . . .  70\n   17. Operational Considerations  . . . . . . . . . .
    . . . . . . .  70\n     17.1.  NAT and Firewall Types . . . . . . . . . . . .
    . . . . .  70\n     17.2.  Bandwidth Requirements . . . . . . . . . . . . . .
    . . .  70\n       17.2.1.  STUN and TURN Server-Capacity Planning . . . . . .
    .  71\n       17.2.2.  Gathering and Connectivity Checks  . . . . . . . . .  71\n
    \      17.2.3.  Keepalives . . . . . . . . . . . . . . . . . . . . .  72\n     17.3.
    \ ICE and ICE-Lite . . . . . . . . . . . . . . . . . . . .  72\n     17.4.  Troubleshooting
    and Performance Management . . . . . . .  72\n     17.5.  Endpoint Configuration
    . . . . . . . . . . . . . . . . .  73\n   18. IAB Considerations  . . . . . .
    . . . . . . . . . . . . . . .  73\n     18.1.  Problem Definition . . . . . .
    . . . . . . . . . . . . .  73\n     18.2.  Exit Strategy  . . . . . . . . . .
    . . . . . . . . . . .  74\n     18.3.  Brittleness Introduced by ICE  . . . .
    . . . . . . . . .  74\n     18.4.  Requirements for a Long-Term Solution  . .
    . . . . . . .  75\n     18.5.  Issues with Existing NAPT Boxes  . . . . . . .
    . . . . .  75\n   19. Security Considerations . . . . . . . . . . . . . . . .
    . . .  76\n     19.1.  IP Address Privacy . . . . . . . . . . . . . . . . . .
    .  76\n     19.2.  Attacks on Connectivity Checks . . . . . . . . . . . . .  77\n
    \    19.3.  Attacks on Server-Reflexive Address Gathering  . . . . .  80\n     19.4.
    \ Attacks on Relayed Candidate Gathering . . . . . . . . .  80\n     19.5.  Insider
    Attacks  . . . . . . . . . . . . . . . . . . . .  81\n       19.5.1.  STUN Amplification
    Attack  . . . . . . . . . . . . .  81\n   20. IANA Considerations . . . . . .
    . . . . . . . . . . . . . . .  82\n     20.1.  STUN Attributes  . . . . . . .
    . . . . . . . . . . . . .  82\n     20.2.  STUN Error Responses . . . . . . .
    . . . . . . . . . . .  82\n     20.3.  ICE Options  . . . . . . . . . . . . .
    . . . . . . . . .  82\n   21. Changes from RFC 5245 . . . . . . . . . . . . .
    . . . . . . .  83\n   22. References  . . . . . . . . . . . . . . . . . . . .
    . . . . .  84\n     22.1.  Normative References . . . . . . . . . . . . . . .
    . . .  84\n     22.2.  Informative References . . . . . . . . . . . . . . . .
    .  85\n   Appendix A.  Lite and Full Implementations  . . . . . . . . . . .  89\n
    \  Appendix B.  Design Motivations . . . . . . . . . . . . . . . . .  90\n     B.1.
    \ Pacing of STUN Transactions . . . . . . . . . . . . . . .  90\n     B.2.  Candidates
    with Multiple Bases  . . . . . . . . . . . . .  92\n     B.3.  Purpose of the
    Related-Address and Related-Port\n           Attributes  . . . . . . . . . . .
    . . . . . . . . . . . .  94\n     B.4.  Importance of the STUN Username . . .
    . . . . . . . . . .  95\n     B.5.  The Candidate Pair Priority Formula . . .
    . . . . . . . .  96\n     B.6.  Why Are Keepalives Needed?  . . . . . . . . .
    . . . . . .  96\n     B.7.  Why Prefer Peer-Reflexive Candidates? . . . . . .
    . . . .  97\n     B.8.  Why Are Binding Indications Used for Keepalives?  . .
    . .  97\n     B.9.  Selecting Candidate Type Preference . . . . . . . . . . .
    \ 97\n   Appendix C.  Connectivity-Check Bandwidth . . . . . . . . . . . .  99\n
    \  Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . . 100\n   Authors'
    Addresses  . . . . . . . . . . . . . . . . . . . . . . . 100\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Protocols establishing communication sessions between peers
    typically\n   involve exchanging IP addresses and ports for the data sources and\n
    \  sinks.  However, this poses challenges when operated through Network\n   Address
    Translators (NATs) [RFC3235].  These protocols also seek to\n   create a data
    flow directly between participants, so that there is no\n   application-layer
    intermediary between them.  This is done to reduce\n   data latency, decrease
    packet loss, and reduce the operational costs\n   of deploying the application.
    \ However, this is difficult to\n   accomplish through NATs.  A full treatment
    of the reasons for this is\n   beyond the scope of this specification.\n   Numerous
    solutions have been defined for allowing these protocols to\n   operate through
    NATs.  These include Application Layer Gateways\n   (ALGs), the Middlebox Control
    Protocol [RFC3303], the original Simple\n   Traversal of UDP Through NAT (STUN)
    specification [RFC3489] (note\n   that RFC 3489 has been obsoleted by RFC 5389),
    and Realm Specific IP\n   [RFC3102] [RFC3103] along with session description extensions
    needed\n   to make them work, such as the Session Description Protocol (SDP)\n
    \  attribute [RFC4566] for the Real-Time Control Protocol (RTCP)\n   [RFC3605].
    \ Unfortunately, these techniques all have pros and cons\n   that make each one
    optimal in some network topologies, but a poor\n   choice in others.  The result
    is that administrators and implementers\n   are making assumptions about the topologies
    of the networks in which\n   their solutions will be deployed.  This introduces
    complexity and\n   brittleness into the system.\n   This specification defines
    Interactive Connectivity Establishment\n   (ICE) as a technique for NAT traversal
    for UDP-based data streams\n   (though ICE has been extended to handle other transport
    protocols,\n   such as TCP [RFC6544]).  ICE works by exchanging a multiplicity
    of IP\n   addresses and ports, which are then tested for connectivity by\n   peer-to-peer
    connectivity checks.  The IP addresses and ports are\n   exchanged using ICE-usage-specific
    mechanisms (e.g., in an Offer/\n   Answer exchange), and the connectivity checks
    are performed using\n   STUN [RFC5389].  ICE also makes use of Traversal Using
    Relay around\n   NAT (TURN) [RFC5766], an extension to STUN.  Because ICE exchanges
    a\n   multiplicity of IP addresses and ports for each media stream, it also\n
    \  allows for address selection for multihomed and dual-stack hosts.\n   For this
    reason, RFC 5245 [RFC5245] deprecated the solutions\n   previously defined in
    RFC 4091 [RFC4091] and RFC 4092 [RFC4092].\n   Appendix B provides background
    information and motivations regarding\n   the design decisions that were made
    when designing ICE.\n"
  title: 1.  Introduction
- contents:
  - "2.  Overview of ICE\n   In a typical ICE deployment, there are two endpoints
    (ICE agents)\n   that want to communicate.  Note that ICE is not intended for
    NAT\n   traversal for the signaling protocol, which is assumed to be provided\n
    \  via another mechanism.  ICE assumes that the agents are able to\n   establish
    a signaling connection between each other.\n   Initially, the agents are ignorant
    of their own topologies.  In\n   particular, the agents may or may not be behind
    NATs (or multiple\n   tiers of NATs).  ICE allows the agents to discover enough
    information\n   about their topologies to potentially find one or more paths by
    which\n   they can establish a data session.\n   Figure 1 shows a typical ICE
    deployment.  The agents are labeled L\n   and R.  Both L and R are behind their
    own respective NATs, though\n   they may not be aware of it.  The type of NAT
    and its properties are\n   also unknown.  L and R are capable of engaging in a
    candidate\n   exchange process, whose purpose is to set up a data session between
    L\n   and R.  Typically, this exchange will occur through a signaling\n   server
    (e.g., a SIP proxy).\n   In addition to the agents, a signaling server, and NATs,
    ICE is\n   typically used in concert with STUN or TURN servers in the network.\n
    \  Each agent can have its own STUN or TURN server, or they can be the\n   same.\n
    \                              +---------+\n             +--------+        |Signaling|
    \        +--------+\n             | STUN   |        |Server   |         | STUN
    \  |\n             | Server |        +---------+         | Server |\n             +--------+
    \      /           \\        +--------+\n                             /             \\\n
    \                           /               \\\n                           / <-
    Signaling -> \\\n                          /                   \\\n                   +--------+
    \              +--------+\n                   |  NAT   |               |  NAT
    \  |\n                   +--------+               +--------+\n                      /
    \                            \\\n                     /                               \\\n
    \                +-------+                       +-------+\n                 |
    Agent |                       | Agent |\n                 |   L   |                       |
    \  R   |\n                 +-------+                       +-------+\n                     Figure
    1: ICE Deployment Scenario\n   The basic idea behind ICE is as follows: each agent
    has a variety of\n   candidate transport addresses (combination of IP address
    and port for\n   a particular transport protocol, which is always UDP in this\n
    \  specification) it could use to communicate with the other agent.\n   These
    might include:\n   o  A transport address on a directly attached network interface\n
    \  o  A translated transport address on the public side of a NAT (a\n      \"server-reflexive\"
    address)\n   o  A transport address allocated from a TURN server (a \"relayed\n
    \     address\")\n   Potentially, any of L's candidate transport addresses can
    be used to\n   communicate with any of R's candidate transport addresses.  In\n
    \  practice, however, many combinations will not work.  For instance, if\n   L
    and R are both behind NATs, their directly attached interface\n   addresses are
    unlikely to be able to communicate directly (this is\n   why ICE is needed, after
    all!).  The purpose of ICE is to discover\n   which pairs of addresses will work.
    \ The way that ICE does this is to\n   systematically try all possible pairs (in
    a carefully sorted order)\n   until it finds one or more that work.\n"
  - contents:
    - "2.1.  Gathering Candidates\n   In order to execute ICE, an ICE agent identifies
      and gathers one or\n   more address candidates.  A candidate has a transport
      address -- a\n   combination of IP address and port for a particular transport\n
      \  protocol (with only UDP specified here).  There are different types\n   of
      candidates; some are derived from physical or logical network\n   interfaces,
      and others are discoverable via STUN and TURN.\n   The first category of candidates
      are those with a transport address\n   obtained directly from a local interface.
      \ Such a candidate is called\n   a \"host candidate\".  The local interface
      could be Ethernet or Wi-Fi,\n   or it could be one that is obtained through
      a tunnel mechanism, such\n   as a Virtual Private Network (VPN) or Mobile IP
      (MIP).  In all cases,\n   such a network interface appears to the agent as a
      local interface\n   from which ports (and thus candidates) can be allocated.\n
      \  Next, the agent uses STUN or TURN to obtain additional candidates.\n   These
      come in two flavors: translated addresses on the public side of\n   a NAT (server-reflexive
      candidates) and addresses on TURN servers\n   (relayed candidates).  When TURN
      servers are utilized, both types of\n   candidates are obtained from the TURN
      server.  If only STUN servers\n   are utilized, only server-reflexive candidates
      are obtained from\n   them.  The relationship of these candidates to the host
      candidate is\n   shown in Figure 2.  In this figure, both types of candidates
      are\n   discovered using TURN.  In the figure, the notation X:x means IP\n   address
      X and UDP port x.\n                      To Internet\n                          |\n
      \                         |\n                          |  /------------  Relayed\n
      \                     Y:y | /               Address\n                      +--------+\n
      \                     |        |\n                      |  TURN  |\n                      |
      Server |\n                      |        |\n                      +--------+\n
      \                         |\n                          |\n                          |
      /------------  Server\n                   X1':x1'|/               Reflexive\n
      \                   +------------+         Address\n                    |    NAT
      \    |\n                    +------------+\n                          |\n                          |
      /------------  Local\n                      X:x |/               Address\n                      +--------+\n
      \                     |        |\n                      | Agent  |\n                      |
      \       |\n                      +--------+\n                     Figure 2:
      Candidate Relationships\n   When the agent sends a TURN Allocate request from
      IP address and port\n   X:x, the NAT (assuming there is one) will create a binding
      X1':x1',\n   mapping this server-reflexive candidate to the host candidate X:x.\n
      \  Outgoing packets sent from the host candidate will be translated by\n   the
      NAT to the server-reflexive candidate.  Incoming packets sent to\n   the server-reflexive
      candidate will be translated by the NAT to the\n   host candidate and forwarded
      to the agent.  The host candidate\n   associated with a given server-reflexive
      candidate is the \"base\".\n      Note: \"Base\" refers to the address an agent
      sends from for a\n      particular candidate.  Thus, as a degenerate case, host
      candidates\n      also have a base, but it's the same as the host candidate.\n
      \  When there are multiple NATs between the agent and the TURN server,\n   the
      TURN request will create a binding on each NAT, but only the\n   outermost server-reflexive
      candidate (the one nearest the TURN\n   server) will be discovered by the agent.
      \ If the agent is not behind\n   a NAT, then the base candidate will be the
      same as the server-\n   reflexive candidate, and the server-reflexive candidate
      is redundant\n   and will be eliminated.\n   The Allocate request then arrives
      at the TURN server.  The TURN\n   server allocates a port y from its local IP
      address Y, and generates\n   an Allocate response, informing the agent of this
      relayed candidate.\n   The TURN server also informs the agent of the server-reflexive\n
      \  candidate, X1':x1', by copying the source transport address of the\n   Allocate
      request into the Allocate response.  The TURN server acts as\n   a packet relay,
      forwarding traffic between L and R.  In order to send\n   traffic to L, R sends
      traffic to the TURN server at Y:y, and the TURN\n   server forwards that to
      X1':x1', which passes through the NAT where\n   it is mapped to X:x and delivered
      to L.\n   When only STUN servers are utilized, the agent sends a STUN Binding\n
      \  request [RFC5389] to its STUN server.  The STUN server will inform\n   the
      agent of the server-reflexive candidate X1':x1' by copying the\n   source transport
      address of the Binding request into the Binding\n   response.\n"
    title: 2.1.  Gathering Candidates
  - contents:
    - "2.2.  Connectivity Checks\n   Once L has gathered all of its candidates, it
      orders them by highest-\n   to-lowest priority and sends them to R over the
      signaling channel.\n   When R receives the candidates from L, it performs the
      same gathering\n   process and responds with its own list of candidates.  At
      the end of\n   this process, each ICE agent has a complete list of both its\n
      \  candidates and its peer's candidates.  It pairs them up, resulting in\n   candidate
      pairs.  To see which pairs work, each agent schedules a\n   series of connectivity
      checks.  Each check is a STUN request/response\n   transaction that the client
      will perform on a particular candidate\n   pair by sending a STUN request from
      the local candidate to the remote\n   candidate.\n   The basic principle of
      the connectivity checks is simple:\n   1.  Sort the candidate pairs in priority
      order.\n   2.  Send checks on each candidate pair in priority order.\n   3.
      \ Acknowledge checks received from the other agent.\n   With both agents performing
      a check on a candidate pair, the result\n   is a 4-way handshake:\n                  L
      \                       R\n                  -                        -\n                  STUN
      request ->             \\  L's\n                            <- STUN response
      \ /  check\n                             <- STUN request  \\  R's\n                  STUN
      response ->            /  check\n                    Figure 3: Basic Connectivity
      Check\n   It is important to note that STUN requests are sent to and from the\n
      \  exact same IP addresses and ports that will be used for data (e.g.,\n   RTP,
      RTCP, or other protocols).  Consequently, agents demultiplex\n   STUN and data
      using the contents of the packets rather than the port\n   on which they are
      received.\n   Because a STUN Binding request is used for the connectivity check,\n
      \  the STUN Binding response will contain the agent's translated\n   transport
      address on the public side of any NATs between the agent\n   and its peer.  If
      this transport address is different from that of\n   other candidates the agent
      already learned, it represents a new\n   candidate (peer-reflexive candidate),
      which then gets tested by ICE\n   just the same as any other candidate.\n   Because
      the algorithm above searches all candidate pairs, if a\n   working pair exists,
      the algorithm will eventually find it no matter\n   what order the candidates
      are tried in.  In order to produce faster\n   (and better) results, the candidates
      are sorted in a specified order.\n   The resulting list of sorted candidate
      pairs is called the\n   \"checklist\".\n   The agent works through the checklist
      by sending a STUN request for\n   the next candidate pair on the list periodically.
      \ These are called\n   \"ordinary checks\".  When a STUN transaction succeeds,
      one or more\n   candidate pairs will become so-called \"valid pairs\" and will
      be added\n   to a candidate-pair list called the \"valid list\".\n   As an optimization,
      as soon as R gets L's check message, R schedules\n   a connectivity-check message
      to be sent to L on the same candidate\n   pair.  This is called a \"triggered
      check\", and it accelerates the\n   process of finding valid pairs.\n   At the
      end of this handshake, both L and R know that they can send\n   (and receive)
      messages end to end in both directions.\n   In general, the priority algorithm
      is designed so that candidates of\n   a similar type get similar priorities
      so that more direct routes\n   (that is, routes without data relays or NATs)
      are preferred over\n   indirect routes (routes with data relays or NATs).  Within
      those\n   guidelines, however, agents have a fair amount of discretion about\n
      \  how to tune their algorithms.\n   A data stream might consist of multiple
      components (pieces of a data\n   stream that require their own set of candidates,
      e.g., RTP and RTCP).\n"
    title: 2.2.  Connectivity Checks
  - contents:
    - "2.3.  Nominating Candidate Pairs and Concluding ICE\n   ICE assigns one of
      the ICE agents in the role of the controlling\n   agent, and the other in the
      role of the controlled agent.  For each\n   component of a data stream, the
      controlling agent nominates a valid\n   pair (from the valid list) to be used
      for data.  The exact timing of\n   the nomination is based on local policy.\n
      \  When nominating, the controlling agent lets the checks continue until\n   at
      least one valid pair for each component of a data stream is found,\n   and then
      it picks a valid pair and sends a STUN request on that pair,\n   using an attribute
      to indicate to the controlled peer that it has\n   been nominated.  This is
      shown in Figure 4.\n             L                        R\n             -
      \                       -\n             STUN request ->             \\  L's\n
      \                      <- STUN response  /  check\n                        <-
      STUN request  \\  R's\n             STUN response ->            /  check\n             STUN
      request + attribute -> \\  L's\n                       <- STUN response  /  check\n
      \                          Figure 4: Nomination\n   Once the controlled agent
      receives the STUN request with the\n   attribute, it will check (unless the
      check has already been done) the\n   same pair.  If the transactions above succeed,
      the agents will set\n   the nominated flag for the pairs and will cancel any
      future checks\n   for that component of the data stream.  Once an agent has
      set the\n   nominated flag for each component of a data stream, the pairs become\n
      \  the selected pairs.  After that, only the selected pairs will be used\n   for
      sending and receiving data associated with that data stream.\n"
    title: 2.3.  Nominating Candidate Pairs and Concluding ICE
  - contents:
    - "2.4.  ICE Restart\n   Once ICE is concluded, it can be restarted at any time
      for one or all\n   of the data streams by either ICE agent.  This is done by
      sending\n   updated candidate information indicating a restart.\n"
    title: 2.4.  ICE Restart
  - contents:
    - "2.5.  Lite Implementations\n   Certain ICE agents will always be connected
      to the public Internet\n   and have a public IP address at which it can receive
      packets from any\n   correspondent.  To make it easier for these devices to
      support ICE,\n   ICE defines a special type of implementation called \"lite\"
      (in\n   contrast to the normal full implementation).  Lite agents only use\n
      \  host candidates and do not generate connectivity checks or run state\n   machines,
      though they need to be able to respond to connectivity\n   checks.\n"
    title: 2.5.  Lite Implementations
  title: 2.  Overview of ICE
- contents:
  - "3.  ICE Usage\n   This document specifies generic use of ICE with protocols that\n
    \  provide means to exchange candidate information between ICE agents.\n   The
    specific details (i.e., how to encode candidate information and\n   the actual
    candidate exchange process) for different protocols using\n   ICE (referred to
    as \"using protocol\") are described in separate usage\n   documents.\n   One
    mechanism that allows agents to exchange candidate information is\n   the utilization
    of Offer/Answer semantics (which are based on\n   [RFC3264]) as part of the SIP
    protocol [RFC3261] [ICE-SIP-SDP].\n   [RFC7825] defines an ICE usage for the Real-Time
    Streaming Protocol\n   (RTSP).  Note, however, that the ICE usage is based on
    RFC 5245.\n"
  title: 3.  ICE Usage
- contents:
  - "4.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\",
    \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described
    in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all\n   capitals,
    as shown here.\n   Readers need to be familiar with the terminology defined in
    [RFC5389]\n   and NAT Behavioral requirements for UDP [RFC4787].\n   This specification
    makes use of the following additional terminology:\n   ICE Session:  An ICE session
    consists of all ICE-related actions\n      starting with the candidate gathering,
    followed by the\n      interactions (candidate exchange, connectivity checks,\n
    \     nominations, and keepalives) between the ICE agents until all the\n      candidates
    are released or an ICE restart is triggered.\n   ICE Agent, Agent:  An ICE agent
    (sometimes simply referred to as an\n      \"agent\") is the protocol implementation
    involved in the ICE\n      candidate exchange.  There are two agents involved
    in a typical\n      candidate exchange.\n   Initiating Peer, Initiating Agent,
    Initiator:  An initiating agent is\n      an ICE agent that initiates the ICE
    candidate exchange process.\n   Responding Peer, Responding Agent, Responder:
    \ A responding agent is\n      an ICE agent that receives and responds to the
    candidate exchange\n      process initiated by the initiating agent.\n   ICE Candidate
    Exchange, Candidate Exchange:  The process where ICE\n      agents exchange information
    (e.g., candidates and passwords) that\n      is needed to perform ICE.  Offer/Answer
    with SDP encoding\n      [RFC3264] is one example of a protocol that can be used
    for\n      exchanging the candidate information.\n   Peer:  From the perspective
    of one of the ICE agents in a session,\n      its peer is the other agent.  Specifically,
    from the perspective\n      of the initiating agent, the peer is the responding
    agent.  From\n      the perspective of the responding agent, the peer is the\n
    \     initiating agent.\n   Transport Address:  The combination of an IP address
    and the\n      transport protocol (such as UDP or TCP) port.\n   Data, Data Stream,
    Data Session:  When ICE is used to set up data\n      sessions, the data is transported
    using some protocol.  Media is\n      usually transported over RTP, composed of
    a stream of RTP packets.\n      Data session refers to data packets that are exchanged
    between the\n      peer on the path created and tested with ICE.\n   Candidate,
    Candidate Information:  A transport address that is a\n      potential point of
    contact for receipt of data.  Candidates also\n      have properties -- their
    type (server reflexive, relayed, or\n      host), priority, foundation, and base.\n
    \  Component:  A component is a piece of a data stream.  A data stream\n      may
    require multiple components, each of which has to work in\n      order for the
    data stream as a whole to work.  For RTP/RTCP data\n      streams, unless RTP
    and RTCP are multiplexed in the same port,\n      there are two components per
    data stream -- one for RTP, and one\n      for RTCP.  A component has a candidate
    pair, which cannot be used\n      by other components.\n   Host Candidate:  A
    candidate obtained by binding to a specific port\n      from an IP address on
    the host.  This includes IP addresses on\n      physical interfaces and logical
    ones, such as ones obtained\n      through VPNs.\n   Server-Reflexive Candidate:
    \ A candidate whose IP address and port\n      are a binding allocated by a NAT
    for an ICE agent after it sends a\n      packet through the NAT to a server, such
    as a STUN server.\n   Peer-Reflexive Candidate:  A candidate whose IP address
    and port are\n      a binding allocated by a NAT for an ICE agent after it sends
    a\n      packet through the NAT to its peer.\n   Relayed Candidate:  A candidate
    obtained from a relay server, such as\n      a TURN server.\n   Base:  The transport
    address that an ICE agent sends from for a\n      particular candidate.  For host,
    server-reflexive, and peer-\n      reflexive candidates, the base is the same
    as the host candidate.\n      For relayed candidates, the base is the same as
    the relayed\n      candidate (i.e., the transport address used by the TURN server
    to\n      send from).\n   Related Address and Port:  A transport address related
    to a\n      candidate, which is useful for diagnostics and other purposes.  If\n
    \     a candidate is server or peer reflexive, the related address and\n      port
    is equal to the base for that server or peer-reflexive\n      candidate.  If the
    candidate is relayed, the related address and\n      port are equal to the mapped
    address in the Allocate response that\n      provided the client with that relayed
    candidate.  If the candidate\n      is a host candidate, the related address and
    port is identical to\n      the host candidate.\n   Foundation:  An arbitrary
    string used in the freezing algorithm to\n      group similar candidates.  It
    is the same for two candidates that\n      have the same type, base IP address,
    protocol (UDP, TCP, etc.),\n      and STUN or TURN server.  If any of these are
    different, then the\n      foundation will be different.\n   Local Candidate:
    \ A candidate that an ICE agent has obtained and may\n      send to its peer.\n
    \  Remote Candidate:  A candidate that an ICE agent received from its\n      peer.\n
    \  Default Destination/Candidate:  The default destination for a\n      component
    of a data stream is the transport address that would be\n      used by an ICE
    agent that is not ICE aware.  A default candidate\n      for a component is one
    whose transport address matches the default\n      destination for that component.\n
    \  Candidate Pair:  A pair containing a local candidate and a remote\n      candidate.\n
    \  Check, Connectivity Check, STUN Check:  A STUN Binding request for\n      the
    purpose of verifying connectivity.  A check is sent from the\n      base of the
    local candidate to the remote candidate of a candidate\n      pair.\n   Checklist:
    \ An ordered set of candidate pairs that an ICE agent will\n      use to generate
    checks.\n   Ordinary Check:  A connectivity check generated by an ICE agent as
    a\n      consequence of a timer that fires periodically, instructing it to\n      send
    a check.\n   Triggered Check:  A connectivity check generated as a consequence
    of\n      the receipt of a connectivity check from the peer.\n   Valid Pair:  A
    candidate pair whose local candidate equals the mapped\n      address of a successful
    connectivity-check response and whose\n      remote candidate equals the destination
    address to which the\n      connectivity-check request was sent.\n   Valid List:
    \ An ordered set of candidate pairs for a data stream that\n      have been validated
    by a successful STUN transaction.\n   Checklist Set:  The ordered list of all
    checklists.  The order is\n      determined by each ICE usage.\n   Full Implementation:
    \ An ICE implementation that performs the\n      complete set of functionality
    defined by this specification.\n   Lite Implementation:  An ICE implementation
    that omits certain\n      functions, implementing only as much as is necessary
    for a peer\n      that is not a lite implementation to gain the benefits of ICE.\n
    \     Lite implementations do not maintain any of the state machines and\n      do
    not generate connectivity checks.\n   Controlling Agent:  The ICE agent that nominates
    a candidate pair.\n      In any session, there is always one controlling agent
    and one\n      controlled agent.\n   Controlled Agent:  The ICE agent that waits
    for the controlling agent\n      to nominate a candidate pair.\n   Nomination:
    \ The process of the controlling agent indicating to the\n      controlled agent
    which candidate pair the ICE agents will use for\n      sending and receiving
    data.  The nomination process defined in\n      this specification was referred
    to as \"regular nomination\" in RFC\n      5245.  The nomination process that
    was referred to as \"aggressive\n      nomination\" in RFC 5245 has been deprecated
    in this specification.\n   Nominated, Nominated Flag:  Once the nomination of
    a candidate pair\n      has succeeded, the candidate pair has become nominated,
    and the\n      value of its nominated flag is set to true.\n   Selected Pair,
    Selected Candidate Pair:  The candidate pair used for\n      sending and receiving
    data for a component of a data stream is\n      referred to as the \"selected
    pair\".  Before selected pairs have\n      been produced for a data stream, any
    valid pair associated with a\n      component of a data stream can be used for
    sending and receiving\n      data for the component.  Once there are nominated
    pairs for each\n      component of a data stream, the nominated pairs become the\n
    \     selected pairs for the data stream.  The candidates associated\n      with
    the selected pairs are referred to as \"selected candidates\".\n   Using Protocol,
    ICE Usage:  The protocol that uses ICE for NAT\n      traversal.  A usage specification
    defines the protocol-specific\n      details on how the procedures defined here
    are applied to that\n      protocol.\n   Timer Ta:  The timer for generating new
    STUN or TURN transactions.\n   Timer RTO (Retransmission Timeout):  The retransmission
    timer for a\n      given STUN or TURN transaction.\n"
  title: 4.  Terminology
- contents:
  - "5.  ICE Candidate Gathering and Exchange\n   As part of ICE processing, both
    the initiating and responding agents\n   gather candidates, prioritize and eliminate
    redundant candidates, and\n   exchange candidate information with the peer as
    defined by the using\n   protocol (ICE usage).  Specifics of the candidate-encoding
    mechanism\n   and the semantics of candidate information exchange is out of scope\n
    \  of this specification.\n"
  - contents:
    - '5.1.  Full Implementation

      '
    - contents:
      - "5.1.1.  Gathering Candidates\n   An ICE agent gathers candidates when it
        believes that communication\n   is imminent.  An initiating agent can do this
        based on a user\n   interface cue or on an explicit request to initiate a
        session.  Every\n   candidate has a transport address.  It also has a type
        and a base.\n   Four types are defined and gathered by this specification
        -- host\n   candidates, server-reflexive candidates, peer-reflexive candidates,\n
        \  and relayed candidates.  The server-reflexive candidates are gathered\n
        \  using STUN or TURN, and relayed candidates are obtained through TURN.\n
        \  Peer-reflexive candidates are obtained in later phases of ICE, as a\n   consequence
        of connectivity checks.\n   The process for gathering candidates at the responding
        agent is\n   identical to the process for the initiating agent.  It is RECOMMENDED\n
        \  that the responding agent begin this process immediately on receipt\n   of
        the candidate information, prior to alerting the user of the\n   application
        associated with the ICE session.\n"
      - contents:
        - "5.1.1.1.  Host Candidates\n   Host candidates are obtained by binding to
          ports on an IP address\n   attached to an interface (physical or virtual,
          including VPN\n   interfaces) on the host.\n   For each component of each
          data stream the ICE agent wishes to use,\n   the agent SHOULD obtain a candidate
          on each IP address that the host\n   has, with the exceptions listed below.
          \ The agent obtains each\n   candidate by binding to a UDP port on the specific
          IP address.  A\n   host candidate (and indeed every candidate) is always
          associated with\n   a specific component for which it is a candidate.\n
          \  Each component has an ID assigned to it, called the \"component ID\".\n
          \  For RTP/RTCP data streams, unless both RTP and RTCP are multiplexed\n
          \  in the same UDP port (RTP/RTCP multiplexing), the RTP itself has a\n
          \  component ID of 1, and RTCP has a component ID of 2.  In case of RTP/\n
          \  RTCP multiplexing, a component ID of 1 is used for both RTP and RTCP.\n
          \  When candidates are obtained, unless the agent knows for sure that\n
          \  RTP/RTCP multiplexing will be used (i.e., the agent knows that the\n
          \  other agent also supports, and is willing to use, RTP/RTCP\n   multiplexing),
          or unless the agent only supports RTP/RTCP\n   multiplexing, the agent MUST
          obtain a separate candidate for RTCP.\n   If an agent has obtained a candidate
          for RTCP, and ends up using RTP/\n   RTCP multiplexing, the agent does not
          need to perform connectivity\n   checks on the RTCP candidate.  Absence
          of a component ID 2 as such\n   does not imply use of RTCP/RTP multiplexing,
          as it could also mean\n   that RTCP is not used.\n   If an agent is using
          separate candidates for RTP and RTCP, it will\n   end up with 2*K host candidates
          if an agent has K IP addresses.\n   Note that the responding agent, when
          obtaining its candidates, will\n   typically know if the other agent supports
          RTP/RTCP multiplexing, in\n   which case it will not need to obtain a separate
          candidate for RTCP.\n   However, absence of a component ID 2 as such does
          not imply use of\n   RTCP/RTP multiplexing, as it could also mean that RTCP
          is not used.\n   The use of multiple components, other than for RTP/RTCP
          streams, is\n   discouraged as it increases the complexity of ICE processing.
          \ If\n   multiple components are needed, the component IDs SHOULD start
          with 1\n   and increase by 1 for each component.\n   The base for each host
          candidate is set to the candidate itself.\n   The host candidates are gathered
          from all IP addresses with the\n   following exceptions:\n   o  Addresses
          from a loopback interface MUST NOT be included in the\n      candidate addresses.\n
          \  o  Deprecated IPv4-compatible IPv6 addresses [RFC4291] and IPv6 site-\n
          \     local unicast addresses [RFC3879] MUST NOT be included in the\n      address
          candidates.\n   o  IPv4-mapped IPv6 addresses SHOULD NOT be included in
          the address\n      candidates unless the application using ICE does not
          support IPv4\n      (i.e., it is an IPv6-only application [RFC4038]).\n
          \  o  If gathering one or more host candidates that correspond to an\n      IPv6
          address that was generated using a mechanism that prevents\n      location
          tracking [RFC7721], host candidates that correspond to\n      IPv6 addresses
          that do allow location tracking, are configured on\n      the same interface,
          and are part of the same network prefix MUST\n      NOT be gathered.  Similarly,
          when host candidates corresponding to\n      an IPv6 address generated using
          a mechanism that prevents location\n      tracking are gathered, then host
          candidates corresponding to IPv6\n      link-local addresses [RFC4291] MUST
          NOT be gathered.\n   The IPv6 default address selection specification [RFC6724]
          specifies\n   that temporary addresses [RFC4941] are to be preferred over
          permanent\n   addresses.\n"
        title: 5.1.1.1.  Host Candidates
      - contents:
        - "5.1.1.2.  Server-Reflexive and Relayed Candidates\n   An ICE agent SHOULD
          gather server-reflexive and relayed candidates.\n   However, use of STUN
          and TURN servers may be unnecessary in certain\n   networks and use of TURN
          servers may be expensive, so some\n   deployments may elect not to use them.
          \ If an agent does not gather\n   server-reflexive or relayed candidates,
          it is RECOMMENDED that the\n   functionality be implemented and just disabled
          through configuration,\n   so that it can be re-enabled through configuration
          if conditions\n   change in the future.\n   The agent pairs each host candidate
          with the STUN or TURN servers\n   with which it is configured or has discovered
          by some means.  It is\n   RECOMMENDED that a domain name be configured,
          the DNS procedures in\n   [RFC5389] (using SRV records with the \"stun\"
          service) be used to\n   discover the STUN server, and the DNS procedures
          in [RFC5766] (using\n   SRV records with the \"turn\" service) be used to
          discover the TURN\n   server.\n   When multiple STUN or TURN servers are
          available (or when they are\n   learned through DNS records and multiple
          results are returned), the\n   agent MAY gather candidates for all of them
          and SHOULD gather\n   candidates for at least one of them (one STUN server
          and one TURN\n   server).  It does so by pairing host candidates with STUN
          or TURN\n   servers, and for each pair, the agent sends a Binding or Allocate\n
          \  request to the server from the host candidate.  Binding requests to a\n
          \  STUN server are not authenticated, and any ALTERNATE-SERVER attribute\n
          \  in a response is ignored.  Agents MUST support the backwards-\n   compatibility
          mode for the Binding request defined in [RFC5389].\n   Allocate requests
          SHOULD be authenticated using a long-term\n   credential obtained by the
          client through some other means.\n   The gathering process is controlled
          using a timer, Ta.  Every time Ta\n   expires, the agent can generate another
          new STUN or TURN transaction.\n   This transaction can be either a retry
          of a previous transaction that\n   failed with a recoverable error (such
          as authentication failure) or a\n   transaction for a new host candidate
          and STUN or TURN server pair.\n   The agent SHOULD NOT generate transactions
          more frequently than once\n   per each ta expiration.  See Section 14 for
          guidance on how to set Ta\n   and the STUN retransmit timer, RTO.\n   The
          agent will receive a Binding or Allocate response.  A successful\n   Allocate
          response will provide the agent with a server-reflexive\n   candidate (obtained
          from the mapped address) and a relayed candidate\n   in the XOR-RELAYED-ADDRESS
          attribute.  If the Allocate request is\n   rejected because the server lacks
          resources to fulfill it, the agent\n   SHOULD instead send a Binding request
          to obtain a server-reflexive\n   candidate.  A Binding response will provide
          the agent with only a\n   server-reflexive candidate (also obtained from
          the mapped address).\n   The base of the server-reflexive candidate is the
          host candidate from\n   which the Allocate or Binding request was sent.
          \ The base of a\n   relayed candidate is that candidate itself.  If a relayed
          candidate\n   is identical to a host candidate (which can happen in rare
          cases),\n   the relayed candidate MUST be discarded.\n   If an IPv6-only
          agent is in a network that utilizes NAT64 [RFC6146]\n   and DNS64 [RFC6147]
          technologies, it may also gather IPv4 server-\n   reflexive and/or relayed
          candidates from IPv4-only STUN or TURN\n   servers.  IPv6-only agents SHOULD
          also utilize IPv6 prefix discovery\n   [RFC7050] to discover the IPv6 prefix
          used by NAT64 (if any) and\n   generate server-reflexive candidates for
          each IPv6-only interface,\n   accordingly.  The NAT64 server-reflexive candidates
          are prioritized\n   like IPv4 server-reflexive candidates.\n"
        title: 5.1.1.2.  Server-Reflexive and Relayed Candidates
      - contents:
        - "5.1.1.3.  Computing Foundations\n   The ICE agent assigns each candidate
          a foundation.  Two candidates\n   have the same foundation when all of the
          following are true:\n   o  They have the same type (host, relayed, server
          reflexive, or peer\n      reflexive).\n   o  Their bases have the same IP
          address (the ports can be different).\n   o  For reflexive and relayed candidates,
          the STUN or TURN servers\n      used to obtain them have the same IP address
          (the IP address used\n      by the agent to contact the STUN or TURN server).\n
          \  o  They were obtained using the same transport protocol (TCP, UDP).\n
          \  Similarly, two candidates have different foundations if their types\n
          \  are different, their bases have different IP addresses, the STUN or\n
          \  TURN servers used to obtain them have different IP addresses (the IP\n
          \  addresses used by the agent to contact the STUN or TURN server), or\n
          \  their transport protocols are different.\n"
        title: 5.1.1.3.  Computing Foundations
      - contents:
        - "5.1.1.4.  Keeping Candidates Alive\n   Once server-reflexive and relayed
          candidates are allocated, they MUST\n   be kept alive until ICE processing
          has completed, as described in\n   Section 8.3.  For server-reflexive candidates
          learned through a\n   Binding request, the bindings MUST be kept alive by
          additional\n   Binding requests to the server.  Refreshes for allocations
          are done\n   using the Refresh transaction, as described in [RFC5766].  The\n
          \  Refresh requests will also refresh the server-reflexive candidate.\n
          \  Host candidates do not time out, but the candidate addresses may\n   change
          or disappear for a number of reasons.  An ICE agent SHOULD\n   monitor the
          interfaces it uses, invalidate candidates whose base has\n   gone away,
          and acquire new candidates as appropriate when new IP\n   addresses (on
          new or currently used interfaces) appear.\n"
        title: 5.1.1.4.  Keeping Candidates Alive
      title: 5.1.1.  Gathering Candidates
    - contents:
      - "5.1.2.  Prioritizing Candidates\n   The prioritization process results in
        the assignment of a priority to\n   each candidate.  Each candidate for a
        data stream MUST have a unique\n   priority that MUST be a positive integer
        between 1 and (2**31 - 1).\n   This priority will be used by ICE to determine
        the order of the\n   connectivity checks and the relative preference for candidates.\n
        \  Higher-priority values give more priority over lower values.\n   An ICE
        agent SHOULD compute this priority using the formula in\n   Section 5.1.2.1
        and choose its parameters using the guidelines in\n   Section 5.1.2.2.  If
        an agent elects to use a different formula, ICE\n   may take longer to converge
        since the agents will not be coordinated\n   in their checks.\n   The process
        for prioritizing candidates is common across the\n   initiating and the responding
        agent.\n"
      - contents:
        - "5.1.2.1.  Recommended Formula\n   The recommended formula combines a preference
          for the candidate type\n   (server reflexive, peer reflexive, relayed, and
          host), a preference\n   for the IP address for which the candidate was obtained,
          and a\n   component ID using the following formula:\n   priority = (2^24)*(type
          preference) +\n              (2^8)*(local preference) +\n              (2^0)*(256
          - component ID)\n   The type preference MUST be an integer from 0 (lowest
          preference) to\n   126 (highest preference) inclusive, MUST be identical
          for all\n   candidates of the same type, and MUST be different for candidates
          of\n   different types.  The type preference for peer-reflexive candidates\n
          \  MUST be higher than that of server-reflexive candidates.  Setting the\n
          \  value to 0 means that candidates of this type will only be used as a\n
          \  last resort.  Note that candidates gathered based on the procedures\n
          \  of Section 5.1.1 will never be peer-reflexive candidates; candidates\n
          \  of this type are learned from the connectivity checks performed by\n
          \  ICE.\n   The local preference MUST be an integer from 0 (lowest preference)
          to\n   65535 (highest preference) inclusive.  When there is only a single
          IP\n   address, this value SHOULD be set to 65535.  If there are multiple\n
          \  candidates for a particular component for a particular data stream\n
          \  that have the same type, the local preference MUST be unique for each\n
          \  one.  If an ICE agent is dual stack, the local preference SHOULD be\n
          \  set according to the current best practice described in [RFC8421].\n
          \  The component ID MUST be an integer between 1 and 256 inclusive.\n"
        title: 5.1.2.1.  Recommended Formula
      - contents:
        - "5.1.2.2.  Guidelines for Choosing Type and Local Preferences\n   The RECOMMENDED
          values for type preferences are 126 for host\n   candidates, 110 for peer-reflexive
          candidates, 100 for server-\n   reflexive candidates, and 0 for relayed
          candidates.\n   If an ICE agent is multihomed and has multiple IP addresses,
          the\n   recommendations in [RFC8421] SHOULD be followed.  If multiple TURN\n
          \  servers are used, local priorities for the candidates obtained from\n
          \  the TURN servers are chosen in a similar fashion as for multihomed\n
          \  local candidates: the local preference value is used to indicate a\n
          \  preference among different servers, but the preference MUST be unique\n
          \  for each one.\n   When choosing type preferences, agents may take into
          account factors\n   such as latency, packet loss, cost, network topology,
          security,\n   privacy, and others.\n"
        title: 5.1.2.2.  Guidelines for Choosing Type and Local Preferences
      title: 5.1.2.  Prioritizing Candidates
    - contents:
      - "5.1.3.  Eliminating Redundant Candidates\n   Next, the ICE agents (initiating
        and responding) eliminate redundant\n   candidates.  Two candidates can have
        the same transport address yet\n   different bases, and these would not be
        considered redundant.\n   Frequently, a server-reflexive candidate and a host
        candidate will be\n   redundant when the agent is not behind a NAT.  A candidate
        is\n   redundant if and only if its transport address and base equal those\n
        \  of another candidate.  The agent SHOULD eliminate the redundant\n   candidate
        with the lower priority.\n"
      title: 5.1.3.  Eliminating Redundant Candidates
    title: 5.1.  Full Implementation
  - contents:
    - "5.2.  Lite Implementation Procedures\n   Lite implementations only utilize
      host candidates.  For each IP\n   address, independent of an IP address family,
      there MUST be zero or\n   one candidate.  With the lite implementation, ICE
      cannot be used to\n   dynamically choose amongst candidates.  Therefore, including
      more\n   than one candidate from a particular IP address family is NOT\n   RECOMMENDED,
      since only a connectivity check can truly determine\n   whether to use one address
      or the other.  Instead, it is RECOMMENDED\n   that agents that have multiple
      public IP addresses run full ICE\n   implementations to ensure the best usage
      of its addresses.\n   Each component has an ID assigned to it, called the \"component
      ID\".\n   For RTP/RTCP data streams, unless RTCP is multiplexed in the same\n
      \  port with RTP, the RTP itself has a component ID of 1 and RTCP a\n   component
      ID of 2.  If an agent is using RTCP without multiplexing,\n   it MUST obtain
      candidates for it.  However, absence of a component ID\n   2 as such does not
      imply use of RTCP/RTP multiplexing, as it could\n   also mean that RTCP is not
      used.\n   Each candidate is assigned a foundation.  The foundation MUST be\n
      \  different for two candidates allocated from different IP addresses;\n   otherwise,
      it MUST be the same.  A simple integer that increments for\n   each IP address
      will suffice.  In addition, each candidate MUST be\n   assigned a unique priority
      amongst all candidates for the same data\n   stream.  If the formula in Section
      5.1.2.1 is used to calculate the\n   priority, the type preference value SHOULD
      be set to 126.  If a host\n   is IPv4 only, the local preference value SHOULD
      be set to 65535.  If\n   a host is IPv6 or dual stack, the local preference
      value SHOULD be\n   set to the precedence value for IP addresses described in
      RFC 6724\n   [RFC6724].\n   Next, an agent chooses a default candidate for each
      component of each\n   data stream.  If a host is IPv4 only, there would only
      be one\n   candidate for each component of each data stream; therefore, that\n
      \  candidate is the default.  If a host is IPv6 only, the default\n   candidate
      would typically be a globally scoped IPv6 address.  Dual-\n   stack hosts SHOULD
      allow configuration whether IPv4 or IPv6 is used\n   for the default candidate,
      and the configuration needs to be based on\n   which one its administrator believes
      has a higher chance of success\n   in the current network environment.\n   The
      procedures in this section are common across the initiating and\n   responding
      agents.\n"
    title: 5.2.  Lite Implementation Procedures
  - contents:
    - "5.3.  Exchanging Candidate Information\n   ICE agents (initiating and responding)
      need the following information\n   about candidates to be exchanged.  Each ICE
      usage MUST define how the\n   information is exchanged with the using protocol.
      \ This section\n   describes the information that needs to be exchanged.\n   Candidates:
      \  One or more candidates.  For each candidate:\n      Address:  The IP address
      and transport protocol port of the\n         candidate.\n      Transport:  The
      transport protocol of the candidate.  This MAY be\n         omitted if the using
      protocol only runs over a single transport\n         protocol.\n      Foundation:
      \ A sequence of up to 32 characters.\n      Component ID:  The component ID
      of the candidate.  This MAY be\n         omitted if the using protocol does
      not use the concept of\n         components.\n      Priority:  The 32-bit priority
      of the candidate.\n      Type:  The type of the candidate.\n      Related Address
      and Port:  The related IP address and port of the\n         candidate.  These
      MAY be omitted or set to invalid values if\n         the agent does not want
      to reveal them, e.g., for privacy\n         reasons.\n      Extensibility Parameters:
      \ The using protocol might define means\n         for adding new per-candidate
      ICE parameters in the future.\n   Lite or Full:   Whether the agent is a lite
      agent or full agent.\n   Connectivity-Check Pacing Value:  The pacing value
      for connectivity\n      checks that the agent wishes to use.  This MAY be omitted
      if the\n      agent wishes to use a defined default value.\n   Username Fragment
      and Password:  Values used to perform connectivity\n      checks.  The values
      MUST be unguessable, with at least 128 bits of\n      random number generator
      output used to generate the password, and\n      at least 24 bits of output
      to generate the username fragment.\n   Extensions:  New media-stream or session-level
      attributes (ICE\n      options).\n   If the using protocol is vulnerable to,
      and able to detect, ICE\n   mismatch (Section 5.4), a way is needed for the
      detecting agent to\n   convey this information to its peer.  It is a boolean
      flag.\n   The using protocol may (or may not) need to deal with backwards\n
      \  compatibility with older implementations that do not support ICE.  If\n   a
      fallback mechanism to non-ICE is supported and is being used, then\n   presumably
      the using protocol provides a way of conveying the default\n   candidate (its
      IP address and port) in addition to the ICE\n   parameters.\n   Once an agent
      has sent its candidate information, it MUST be prepared\n   to receive both
      STUN and data packets on each candidate.  As\n   discussed in Section 12.1,
      data packets can be sent to a candidate\n   prior to its appearance as the default
      destination for data.\n"
    title: 5.3.  Exchanging Candidate Information
  - contents:
    - "5.4.  ICE Mismatch\n   Certain middleboxes, such as ALGs, can alter signaling
      information in\n   ways that break ICE (e.g., by rewriting IP addresses in SDP).
      \ This\n   is referred to as \"ICE mismatch\".  If the using protocol is\n   vulnerable
      to ICE mismatch, the responding agent needs to be able to\n   detect it and
      inform the peer ICE agent about the ICE mismatch.\n   Each using protocol needs
      to define whether the using protocol is\n   vulnerable to ICE mismatch, how
      ICE mismatch is detected, and whether\n   specific actions need to be taken
      when ICE mismatch is detected.\n"
    title: 5.4.  ICE Mismatch
  title: 5.  ICE Candidate Gathering and Exchange
- contents:
  - "6.  ICE Candidate Processing\n   Once an ICE agent has gathered its candidates
    and exchanged\n   candidates with its peer (Section 5), it will determine its
    own role.\n   In addition, full implementations will form checklists and begin\n
    \  performing connectivity checks with the peer.\n"
  - contents:
    - '6.1.  Procedures for Full Implementation

      '
    - contents:
      - "6.1.1.  Determining Role\n   For each session, each ICE agent (initiating
        and responding) takes on\n   a role.  There are two roles -- controlling and
        controlled.  The\n   controlling agent is responsible for the choice of the
        final\n   candidate pairs used for communications.  The sections below describe\n
        \  in detail the actual procedures followed by controlling and\n   controlled
        agents.\n   The rules for determining the role and the impact on behavior
        are as\n   follows:\n   Both agents are full:  The initiating agent that started
        the ICE\n      processing MUST take the controlling role, and the other MUST
        take\n      the controlled role.  Both agents will form checklists, run the\n
        \     ICE state machines, and generate connectivity checks.  The\n      controlling
        agent will execute the logic in Section 8.1 to\n      nominate pairs that
        will become (if the connectivity checks\n      associated with the nominations
        succeed) the selected pairs, and\n      then both agents end ICE as described
        in Section 8.1.2.\n   One agent full, one lite:  The full agent MUST take
        the controlling\n      role, and the lite agent MUST take the controlled role.
        \ The full\n      agent will form checklists, run the ICE state machines,
        and\n      generate connectivity checks.  That agent will execute the logic\n
        \     in Section 8.1 to nominate pairs that will become (if the\n      connectivity
        checks associated with the nominations succeed) the\n      selected pairs
        and use the logic in Section 8.1.2 to end ICE.  The\n      lite implementation
        will just listen for connectivity checks,\n      receive them and respond
        to them, and then conclude ICE as\n      described in Section 8.2.  For the
        lite implementation, the state\n      of ICE processing for each data stream
        is considered to be\n      Running, and the state of ICE overall is Running.\n
        \  Both lite:  The initiating agent that started the ICE processing MUST\n
        \     take the controlling role, and the other MUST take the controlled\n
        \     role.  In this case, no connectivity checks are ever sent.\n      Rather,
        once the candidates are exchanged, each agent performs the\n      processing
        described in Section 8 without connectivity checks.  It\n      is possible
        that both agents will believe they are controlled or\n      controlling.  In
        the latter case, the conflict is resolved through\n      glare detection capabilities
        in the signaling protocol enabling\n      the candidate exchange.  The state
        of ICE processing for each data\n      stream is considered to be Running,
        and the state of ICE overall\n      is Running.\n   Once the roles are determined
        for a session, they persist throughout\n   the lifetime of the session.  The
        roles can be redetermined as part\n   of an ICE restart (Section 9), but an
        ICE agent MUST NOT redetermine\n   the role as part of an ICE restart unless
        one or more of the\n   following criteria is fulfilled:\n   Full becomes lite:
        \ If the controlling agent is full, and switches to\n      lite, the roles
        MUST be redetermined if the peer agent is also\n      full.\n   Role conflict:
        \ If the ICE restart causes a role conflict, the roles\n      might be redetermined
        due to the role conflict procedures in\n      Section 7.3.1.1.\n   NOTE: There
        are certain Third Party Call Control (3PCC) [RFC3725]\n   scenarios where
        an ICE restart might cause a role conflict.\n   NOTE: The agents need to inform
        each other whether they are full or\n   lite before the roles are determined.
        \ The mechanism for that is\n   specific to the signaling protocol and outside
        the scope of the\n   document.\n   An agent MUST accept if the peer initiates
        a redetermination of the\n   roles even if the criteria for doing so are not
        fulfilled.  This can\n   happen if the peer is compliant with RFC 5245.\n"
      title: 6.1.1.  Determining Role
    - contents:
      - "6.1.2.  Forming the Checklists\n   There is one checklist for each data stream.
        \ To form a checklist,\n   initiating and responding ICE agents form candidate
        pairs, compute\n   pair priorities, order pairs by priority, prune pairs,
        remove lower-\n   priority pairs, and set checklist states.  If candidates
        are added to\n   a checklist (e.g., due to detection of peer-reflexive candidates),\n
        \  the agent will re-perform these steps for the updated checklist.\n"
      - contents:
        - "6.1.2.1.  Checklist State\n   Each checklist has a state, which captures
          the state of ICE checks\n   for the data stream associated with the checklist.
          \ The states are:\n   Running:  The checklist is neither Completed nor Failed
          yet.\n      Checklists are initially set to the Running state.\n   Completed:
          \ The checklist contains a nominated pair for each\n      component of the
          data stream.\n   Failed:  The checklist does not have a valid pair for each
          component\n      of the data stream, and all of the candidate pairs in the\n
          \     checklist are in either the Failed or the Succeeded state.  In\n      other
          words, at least one component of the checklist has candidate\n      pairs
          that are all in the Failed state, which means the component\n      has failed,
          which means the checklist has failed.\n"
        title: 6.1.2.1.  Checklist State
      - contents:
        - "6.1.2.2.  Forming Candidate Pairs\n   The ICE agent pairs each local candidate
          with each remote candidate\n   for the same component of the same data stream
          with the same IP\n   address family.  It is possible that some of the local
          candidates\n   won't get paired with remote candidates, and some of the
          remote\n   candidates won't get paired with local candidates.  This can
          happen\n   if one agent doesn't include candidates for all of the components
          for\n   a data stream.  If this happens, the number of components for that\n
          \  data stream is effectively reduced and is considered to be equal to\n
          \  the minimum across both agents of the maximum component ID provided\n
          \  by each agent across all components for the data stream.\n   In the case
          of RTP, this would happen when one agent provides\n   candidates for RTCP,
          and the other does not.  As another example, the\n   initiating agent can
          multiplex RTP and RTCP on the same port\n   [RFC5761].  However, since the
          initiating agent doesn't know if the\n   peer agent can perform such multiplexing,
          it includes candidates for\n   RTP and RTCP on separate ports.  If the peer
          agent can perform such\n   multiplexing, it would include just a single
          component for each\n   candidate -- for the combined RTP/RTCP mux.  ICE
          would end up acting\n   as if there was just a single component for this
          candidate.\n   With IPv6, it is common for a host to have multiple host
          candidates\n   for each interface.  To keep the amount of resulting candidate
          pairs\n   reasonable and to avoid candidate pairs that are highly unlikely
          to\n   work, IPv6 link-local addresses MUST NOT be paired with other than\n
          \  link-local addresses.\n   The candidate pairs whose local and remote
          candidates are both the\n   default candidates for a particular component
          is called the \"default\n   candidate pair\" for that component.  This is
          the pair that would be\n   used to transmit data if both agents had not
          been ICE aware.\n   Figure 5 shows the properties of and relationships between
          transport\n   addresses, candidates, candidate pairs, and checklists.\n
          \             +--------------------------------------------+\n              |
          \                                           |\n              | +---------------------+
          \                   |\n              | |+----+ +----+ +----+ |   +Type            |\n
          \             | || IP | |Port| |Tran| |   +Priority        |\n              |
          ||Addr| |    | |    | |   +Foundation      |\n              | |+----+ +----+
          +----+ |   +Component ID    |\n              | |      Transport      |   +Related
          Address |\n              | |        Addr         |                    |\n
          \             | +---------------------+   +Base            |\n              |
          \            Candidate                      |\n              +--------------------------------------------+\n
          \             *                                         *\n              *
          \   *************************************\n              *    *\n            +-------------------------------+\n
          \           |                               |\n            | Local     Remote
          \             |\n            | +----+    +----+   +default?  |\n            |
          |Cand|    |Cand|   +valid?    |\n            | +----+    +----+   +nominated?|\n
          \           |                    +State     |\n            |                               |\n
          \           |                               |\n            |          Candidate
          Pair       |\n            +-------------------------------+\n            *
          \                             *\n            *                  ************\n
          \           *                  *\n            +------------------+\n            |
          \ Candidate Pair  |\n            +------------------+\n            +------------------+\n
          \           |  Candidate Pair  |\n            +------------------+\n            +------------------+\n
          \           |  Candidate Pair  |\n            +------------------+\n                 Checklist\n
          \               Figure 5: Conceptual Diagram of a Checklist\n"
        title: 6.1.2.2.  Forming Candidate Pairs
      - contents:
        - "6.1.2.3.  Computing Pair Priority and Ordering Pairs\n   The ICE agent
          computes a priority for each candidate pair.  Let G be\n   the priority
          for the candidate provided by the controlling agent.\n   Let D be the priority
          for the candidate provided by the controlled\n   agent.  The priority for
          a pair is computed as follows:\n      pair priority = 2^32*MIN(G,D) + 2*MAX(G,D)
          + (G>D?1:0)\n   The agent sorts each checklist in decreasing order of candidate
          pair\n   priority.  If two pairs have identical priority, the ordering amongst\n
          \  them is arbitrary.\n"
        title: 6.1.2.3.  Computing Pair Priority and Ordering Pairs
      - contents:
        - "6.1.2.4.  Pruning the Pairs\n   This sorted list of candidate pairs is
          used to determine a sequence\n   of connectivity checks that will be performed.
          \ Each check involves\n   sending a request from a local candidate to a
          remote candidate.\n   Since an ICE agent cannot send requests directly from
          a reflexive\n   candidate (server reflexive or peer reflexive), but only
          from its\n   base, the agent next goes through the sorted list of candidate
          pairs.\n   For each pair where the local candidate is reflexive, the candidate\n
          \  MUST be replaced by its base.\n   The agent prunes each checklist.  This
          is done by removing a\n   candidate pair if it is redundant with a higher-priority
          candidate\n   pair in the same checklist.  Two candidate pairs are redundant
          if\n   their local candidates have the same base and their remote candidates\n
          \  are identical.  The result is a sequence of ordered candidate pairs,\n
          \  called the \"checklist\" for that data stream.\n"
        title: 6.1.2.4.  Pruning the Pairs
      - contents:
        - "6.1.2.5.  Removing Lower-Priority Pairs\n   In order to limit the attacks
          described in Section 19.5.1, an ICE\n   agent MUST limit the total number
          of connectivity checks the agent\n   performs across all checklists in the
          checklist set.  This is done by\n   limiting the total number of candidate
          pairs in the checklist set.\n   The default limit of candidate pairs for
          the checklist set is 100,\n   but the value MUST be configurable.  The limit
          is enforced by, within\n   in each checklist, discarding lower-priority
          candidate pairs until\n   the total number of candidate pairs in the checklist
          set is smaller\n   than the limit value.  The discarding SHOULD be done
          evenly so that\n   the number of candidate pairs in each checklist is reduced
          the same\n   amount.\n   It is RECOMMENDED that a lower-limit value than
          the default is picked\n   when possible, and that the value is set to the
          maximum number of\n   plausible candidate pairs that might be created in
          an actual\n   deployment configuration.  The requirement for configuration
          is meant\n   to provide a tool for fixing this value in the field if, once\n
          \  deployed, it is found to be problematic.\n"
        title: 6.1.2.5.  Removing Lower-Priority Pairs
      - contents:
        - "6.1.2.6.  Computing Candidate Pair States\n   Each candidate pair in the
          checklist has a foundation (the\n   combination of the foundations of the
          local and remote candidates in\n   the pair) and one of the following states:\n
          \  Waiting:  A check has not been sent for this pair, but the pair is\n
          \     not Frozen.\n   In-Progress:  A check has been sent for this pair,
          but the\n      transaction is in progress.\n   Succeeded:  A check has been
          sent for this pair, and it produced a\n      successful result.\n   Failed:
          \ A check has been sent for this pair, and it failed (a\n      response
          to the check was never received, or a failure response\n      was received).\n
          \  Frozen:  A check for this pair has not been sent, and it cannot be\n
          \     sent until the pair is unfrozen and moved into the Waiting state.\n
          \  Pairs move between states as shown in Figure 6.\n      +-----------+\n
          \     |           |\n      |           |\n      |  Frozen   |\n      |           |\n
          \     |           |\n      +-----------+\n            |\n            |unfreeze\n
          \           |\n            V\n      +-----------+         +-----------+\n
          \     |           |         |           |\n      |           | perform |
          \          |\n      |  Waiting  |-------->|In-Progress|\n      |           |
          \        |           |\n      |           |         |           |\n      +-----------+
          \        +-----------+\n                                  / |\n                                //
          \ |\n                              //    |\n                            //
          \     |\n                           /        |\n                         //
          \        |\n               failure //           |success\n                     //
          \            |\n                    /               |\n                  //
          \               |\n                //                  |\n              //
          \                   |\n             V                      V\n      +-----------+
          \        +-----------+\n      |           |         |           |\n      |
          \          |         |           |\n      |   Failed  |         | Succeeded
          |\n      |           |         |           |\n      |           |         |
          \          |\n      +-----------+         +-----------+\n              Figure
          6: Pair State Finite State Machine (FSM)\n   The initial states for each
          pair in a checklist are computed by\n   performing the following sequence
          of steps:\n   1.  The checklists are placed in an ordered list (the order
          is\n       determined by each ICE usage), called the \"checklist set\".\n
          \  2.  The ICE agent initially places all candidate pairs in the Frozen\n
          \      state.\n   3.  The agent sets all of the checklists in the checklist
          set to the\n       Running state.\n   4.  For each foundation, the agent
          sets the state of exactly one\n       candidate pair to the Waiting state
          (unfreezing it).  The\n       candidate pair to unfreeze is chosen by finding
          the first\n       candidate pair (ordered by the lowest component ID and
          then the\n       highest priority if component IDs are equal) in the first\n
          \      checklist (according to the usage-defined checklist set order)\n
          \      that has that foundation.\n   NOTE: The procedures above are different
          from RFC 5245, where only\n   candidate pairs in the first checklist were
          initially placed in the\n   Waiting state.  Now it applies to candidate
          pairs in the first\n   checklist that have that foundation, even if the
          checklist is not the\n   first one in the checklist set.\n   The table below
          illustrates an example.\n   Table legend:\n   Each row (m1, m2,...) represents
          a checklist associated with a\n   data stream. m1 represents the first checklist
          in the checklist\n   set.\n   Each column (f1, f2,...) represents a foundation.
          \ Every candidate\n   pair within a given column share the same foundation.\n
          \  f-cp represents a candidate pair in the Frozen state.\n   w-cp represents
          a candidate pair in the Waiting state.\n   1.  The agent sets all of the
          pairs in the checklist set to the\n       Frozen state.\n         f1    f2
          \   f3    f4    f5\n       -----------------------------\n   m1 | f-cp  f-cp
          \ f-cp\n      |\n   m2 | f-cp  f-cp  f-cp  f-cp\n      |\n   m3 | f-cp                    f-cp\n
          \  2.  For each foundation, the candidate pair with the lowest\n       component
          ID is placed in the Waiting state, unless a\n       candidate pair associated
          with the same foundation has\n       already been put in the Waiting state
          in one of the\n       other examined checklists in the checklist set.\n
          \        f1    f2    f3    f4    f5\n       -----------------------------\n
          \  m1 | w-cp  w-cp  w-cp\n      |\n   m2 | f-cp  f-cp  f-cp  w-cp\n      |\n
          \  m3 | f-cp                    w-cp\n                        Table 1: Pair
          State Example\n   In the first checklist (m1), the candidate pair for each
          foundation\n   is placed in the Waiting state, as no pairs for the same
          foundations\n   have yet been placed in the Waiting state.\n   In the second
          checklist (m2), the candidate pair for foundation f4 is\n   placed in the
          Waiting state.  The candidate pair for foundations f1,\n   f2, and f3 are
          kept in the Frozen state, as candidate pairs for those\n   foundations have
          already been placed in the Waiting state (within\n   checklist m1).\n   In
          the third checklist (m3), the candidate pair for foundation f5 is\n   placed
          in the Waiting state.  The candidate pair for foundation f1 is\n   kept
          in the Frozen state, as a candidate pair for that foundation has\n   already
          been placed in the Waiting state (within checklist m1).\n   Once each checklist
          have been processed, one candidate pair for each\n   foundation in the checklist
          set has been placed in the Waiting state.\n"
        title: 6.1.2.6.  Computing Candidate Pair States
      title: 6.1.2.  Forming the Checklists
    - contents:
      - "6.1.3.  ICE State\n   The ICE agent has a state determined by the state of
        the checklists.\n   The state is Completed if all checklists are Completed,
        Failed if all\n   checklists are Failed, or Running otherwise.\n"
      title: 6.1.3.  ICE State
    - contents:
      - '6.1.4.  Scheduling Checks

        '
      - contents:
        - "6.1.4.1.  Triggered-Check Queue\n   Once the ICE agent has computed the
          checklists and created the\n   checklist set, as described in Section 6.1.2,
          the agent will begin\n   performing connectivity checks (ordinary and triggered).
          \ For\n   triggered connectivity checks, the agent maintains a FIFO queue
          for\n   each checklist, referred to as the \"triggered-check queue\", which\n
          \  contains candidate pairs for which checks are to be sent at the next\n
          \  available opportunity.  The triggered-check queue is initially empty.\n"
        title: 6.1.4.1.  Triggered-Check Queue
      - contents:
        - "6.1.4.2.  Performing Connectivity Checks\n   The generation of ordinary
          and triggered connectivity checks is\n   governed by timer Ta.  As soon
          as the initial states for the\n   candidate pairs in the checklist set have
          been set, a check is\n   performed for a candidate pair within the first
          checklist in the\n   Running state, following the procedures in Section
          7.  After that,\n   whenever Ta fires the next checklist in the Running
          state in the\n   checklist set is picked, and a check is performed for a
          candidate\n   within that checklist.  After the last checklist in the Running
          state\n   in the checklist set has been processed, the first checklist is\n
          \  picked again, etc.\n   Whenever Ta fires, the ICE agent will perform
          a check for a candidate\n   pair within the checklist that was picked by
          performing the following\n   steps:\n   1.  If the triggered-check queue
          associated with the checklist\n       contains one or more candidate pairs,
          the agent removes the top\n       pair from the queue, performs a connectivity
          check on that pair,\n       puts the candidate pair state to In-Progress,
          and aborts the\n       subsequent steps.\n   2.  If there is no candidate
          pair in the Waiting state, and if there\n       are one or more pairs in
          the Frozen state, the agent checks the\n       foundation associated with
          each pair in the Frozen state.  For a\n       given foundation, if there
          is no pair (in any checklist in the\n       checklist set) in the Waiting
          or In-Progress state, the agent\n       puts the candidate pair state to
          Waiting and continues with the\n       next step.\n   3.  If there are one
          or more candidate pairs in the Waiting state,\n       the agent picks the
          highest-priority candidate pair (if there are\n       multiple pairs with
          the same priority, the pair with the lowest\n       component ID is picked)
          in the Waiting state, performs a\n       connectivity check on that pair,
          puts the candidate pair state to\n       In-Progress, and aborts the subsequent
          steps.\n   4.  If this step is reached, no check could be performed for
          the\n       checklist that was picked.  So, without waiting for timer Ta
          to\n       expire again, select the next checklist in the Running state
          and\n       return to step #1.  If this happens for every single checklist
          in\n       the Running state, meaning there are no remaining candidate pairs\n
          \      to perform connectivity checks for, abort these steps.\n   Once the
          agent has picked a candidate pair for which a connectivity\n   check is
          to be performed, the agent starts a check and sends the\n   Binding request
          from the base associated with the local candidate of\n   the pair to the
          remote candidate of the pair, as described in\n   Section 7.2.4.\n   Based
          on local policy, an agent MAY choose to terminate performing\n   the connectivity
          checks for one or more checklists in the checklist\n   set at any time.
          \ However, only the controlling agent is allowed to\n   conclude ICE (Section
          8).\n   To compute the message integrity for the check, the agent uses the\n
          \  remote username fragment and password learned from the candidate\n   information
          obtained from its peer.  The local username fragment is\n   known directly
          by the agent for its own candidate.\n"
        title: 6.1.4.2.  Performing Connectivity Checks
      title: 6.1.4.  Scheduling Checks
    title: 6.1.  Procedures for Full Implementation
  - contents:
    - "6.2.  Lite Implementation Procedures\n   Lite implementations skip most of
      the steps in Section 6 except for\n   verifying the peer's ICE support and determining
      its role in the ICE\n   processing.\n   If the lite implementation is the controlling
      agent (which will only\n   happen if the peer ICE agent is also a lite implementation),
      it\n   selects a candidate pair based on the ones in the candidate exchange\n
      \  (for IPv4, there is only ever one pair) and then updates the peer\n   with
      the new candidate information reflecting that selection, if\n   needed (it is
      never needed for an IPv4-only host).\n"
    title: 6.2.  Lite Implementation Procedures
  title: 6.  ICE Candidate Processing
- contents:
  - "7.  Performing Connectivity Checks\n   This section describes how connectivity
    checks are performed.\n   An ICE agent MUST be compliant to [RFC5389].  A full
    implementation\n   acts both as a STUN client and a STUN server, while a lite\n
    \  implementation only acts as a STUN server (as it does not generate\n   connectivity
    checks).\n"
  - contents:
    - "7.1.  STUN Extensions\n   ICE extends STUN with the attributes: PRIORITY, USE-CANDIDATE,
      ICE-\n   CONTROLLED, and ICE-CONTROLLING.  These attributes are formally\n   defined
      in Section 16.1.  This section describes the usage of the\n   attributes.\n
      \  The attributes are only applicable to ICE connectivity checks.\n"
    - contents:
      - "7.1.1.  PRIORITY\n   The PRIORITY attribute MUST be included in a Binding
        request and be\n   set to the value computed by the algorithm in Section 5.1.2
        for the\n   local candidate, but with the candidate type preference of peer-\n
        \  reflexive candidates.\n"
      title: 7.1.1.  PRIORITY
    - contents:
      - "7.1.2.  USE-CANDIDATE\n   The controlling agent MUST include the USE-CANDIDATE
        attribute in\n   order to nominate a candidate pair (Section 8.1.1).  The
        controlled\n   agent MUST NOT include the USE-CANDIDATE attribute in a Binding\n
        \  request.\n"
      title: 7.1.2.  USE-CANDIDATE
    - contents:
      - "7.1.3.  ICE-CONTROLLED and ICE-CONTROLLING\n   The controlling agent MUST
        include the ICE-CONTROLLING attribute in a\n   Binding request.  The controlled
        agent MUST include the ICE-\n   CONTROLLED attribute in a Binding request.\n
        \  The content of either attribute is used as tiebreaker values when an\n
        \  ICE role conflict occurs (Section 7.3.1.1).\n"
      title: 7.1.3.  ICE-CONTROLLED and ICE-CONTROLLING
    title: 7.1.  STUN Extensions
  - contents:
    - '7.2.  STUN Client Procedures

      '
    - contents:
      - "7.2.1.  Creating Permissions for Relayed Candidates\n   If the connectivity
        check is being sent using a relayed local\n   candidate, the client MUST create
        a permission first if it has not\n   already created one previously.  It would
        have created one previously\n   if it had told the TURN server to create a
        permission for the given\n   relayed candidate towards the IP address of the
        remote candidate.  To\n   create the permission, the ICE agent follows the
        procedures defined\n   in [RFC5766].  The permission MUST be created towards
        the IP address\n   of the remote candidate.  It is RECOMMENDED that the agent
        defer\n   creation of a TURN channel until ICE completes, in which case\n
        \  permissions for connectivity checks are normally created using a\n   CreatePermission
        request.  Once established, the agent MUST keep the\n   permission active
        until ICE concludes.\n"
      title: 7.2.1.  Creating Permissions for Relayed Candidates
    - contents:
      - "7.2.2.  Forming Credentials\n   A connectivity-check Binding request MUST
        utilize the STUN short-term\n   credential mechanism.\n   The username for
        the credential is formed by concatenating the\n   username fragment provided
        by the peer with the username fragment of\n   the ICE agent sending the request,
        separated by a colon (\":\").\n   The password is equal to the password provided
        by the peer.\n   For example, consider the case where ICE agent L is the initiating\n
        \  agent and ICE agent R is the responding agent.  Agent L included a\n   username
        fragment of LFRAG for its candidates and a password of\n   LPASS.  Agent R
        provided a username fragment of RFRAG and a password\n   of RPASS.  A connectivity
        check from L to R utilizes the username\n   RFRAG:LFRAG and a password of
        RPASS.  A connectivity check from R to\n   L utilizes the username LFRAG:RFRAG
        and a password of LPASS.  The\n   responses utilize the same usernames and
        passwords as the requests\n   (note that the USERNAME attribute is not present
        in the response).\n"
      title: 7.2.2.  Forming Credentials
    - contents:
      - "7.2.3.  Diffserv Treatment\n   If the agent is using Differentiated Services
        Code Point (DSCP)\n   markings [RFC2475] in data packets that it will send,
        the agent\n   SHOULD apply the same markings to Binding requests and responses
        that\n   it will send.\n   If multiple DSCP markings are used on the data
        packets, the agent\n   SHOULD choose one of them for use with the connectivity
        check.\n"
      title: 7.2.3.  Diffserv Treatment
    - contents:
      - "7.2.4.  Sending the Request\n   A connectivity check is generated by sending
        a Binding request from\n   the base associated with a local candidate to a
        remote candidate.\n   [RFC5389] describes how Binding requests are constructed
        and\n   generated.\n   Support for backwards compatibility with RFC 3489 MUST
        NOT be assumed\n   when performing connectivity checks.  The FINGERPRINT mechanism
        MUST\n   be used for connectivity checks.\n"
      title: 7.2.4.  Sending the Request
    - contents:
      - "7.2.5.  Processing the Response\n   This section defines additional procedures
        for processing Binding\n   responses specific to ICE connectivity checks.\n
        \  When a Binding response is received, it is correlated to the\n   corresponding
        Binding request using the transaction ID [RFC5389],\n   which then associates
        the response with the candidate pair for which\n   the Binding request was
        sent.  After that, the response is processed\n   according to the procedures
        for a role conflict, a failure, or a\n   success, according to the procedures
        below.\n"
      - contents:
        - "7.2.5.1.  Role Conflict\n   If the Binding request generates a 487 (Role
          Conflict) error response\n   (Section 7.3.1.1), and if the ICE agent included
          an ICE-CONTROLLED\n   attribute in the request, the agent MUST switch to
          the controlling\n   role.  If the agent included an ICE-CONTROLLING attribute
          in the\n   request, the agent MUST switch to the controlled role.\n   Once
          the agent has switched its role, the agent MUST add the\n   candidate pair
          whose check generated the 487 error response to the\n   triggered-check
          queue associated with the checklist to which the pair\n   belongs, and set
          the candidate pair state to Waiting.  When the\n   triggered connectivity
          check is later performed, the ICE-CONTROLLING/\n   ICE-CONTROLLED attribute
          of the Binding request will indicate the\n   agent's new role.  The agent
          MUST change the tiebreaker value.\n   NOTE: A role switch requires an agent
          to recompute pair priorities\n   (Section 6.1.2.3), since the priority values
          depend on the role.\n   NOTE: A role switch will also impact whether the
          agent is responsible\n   for nominating candidate pairs, and whether the
          agent is responsible\n   for initiating the exchange of the updated candidate
          information with\n   the peer once ICE is concluded.\n"
        title: 7.2.5.1.  Role Conflict
      - contents:
        - "7.2.5.2.  Failure\n   This section describes cases when the candidate pair
          state is set to\n   Failed.\n   NOTE: When the ICE agent sets the candidate
          pair state to Failed as a\n   result of a connectivity-check error, the
          agent does not change the\n   states of other candidate pairs with the same
          foundation.\n"
        - contents:
          - "7.2.5.2.1.  Non-Symmetric Transport Addresses\n   The ICE agent MUST
            check that the source and destination transport\n   addresses in the Binding
            request and response are symmetric.  That\n   is, the source IP address
            and port of the response MUST be equal to\n   the destination IP address
            and port to which the Binding request was\n   sent, and the destination
            IP address and port of the response MUST be\n   equal to the source IP
            address and port from which the Binding\n   request was sent.  If the
            addresses are not symmetric, the agent MUST\n   set the candidate pair
            state to Failed.\n"
          title: 7.2.5.2.1.  Non-Symmetric Transport Addresses
        - contents:
          - "7.2.5.2.2.  ICMP Error\n   An ICE agent MAY support processing of ICMP
            errors for connectivity\n   checks.  If the agent supports processing
            of ICMP errors, and if a\n   Binding request generates a hard ICMP error,
            the agent SHOULD set the\n   state of the candidate pair to Failed.  Implementers
            need to be aware\n   that ICMP errors can be used as a method for Denial-of-Service
            (DoS)\n   attacks when making a decision on how and if to process ICMP
            errors.\n"
          title: 7.2.5.2.2.  ICMP Error
        - contents:
          - "7.2.5.2.3.  Timeout\n   If the Binding request transaction times out,
            the ICE agent MUST set\n   the candidate pair state to Failed.\n"
          title: 7.2.5.2.3.  Timeout
        - contents:
          - "7.2.5.2.4.  Unrecoverable STUN Response\n   If the Binding request generates
            a STUN error response that is\n   unrecoverable [RFC5389], the ICE agent
            SHOULD set the candidate pair\n   state to Failed.\n"
          title: 7.2.5.2.4.  Unrecoverable STUN Response
        title: 7.2.5.2.  Failure
      - contents:
        - "7.2.5.3.  Success\n   A connectivity check is considered a success if each
          of the following\n   criteria is true:\n   o  The Binding request generated
          a success response; and\n   o  The source and destination transport addresses
          in the Binding\n      request and response are symmetric.\n   If a check
          is considered a success, the ICE agent performs (in order)\n   the actions
          described in the following sections.\n"
        - contents:
          - "7.2.5.3.1.  Discovering Peer-Reflexive Candidates\n   The ICE agent MUST
            check the mapped address from the STUN response.\n   If the transport
            address does not match any of the local candidates\n   that the agent
            knows about, the mapped address represents a new\n   candidate: a peer-reflexive
            candidate.  Like other candidates, a\n   peer-reflexive candidate has
            a type, base, priority, and foundation.\n   They are computed as follows:\n
            \  o  The type is peer reflexive.\n   o  The base is the local candidate
            of the candidate pair from which\n      the Binding request was sent.\n
            \  o  The priority is the value of the PRIORITY attribute in the Binding\n
            \     request.\n   o  The foundation is described in Section 5.1.1.3.\n
            \  The peer-reflexive candidate is then added to the list of local\n   candidates
            for the data stream.  The username fragment and password\n   are the same
            as for all other local candidates for that data stream.\n   The ICE agent
            does not need to pair the peer-reflexive candidate with\n   remote candidates,
            as a valid pair will be created due to the\n   procedures in Section 7.2.5.3.2.
            \ If an agent wishes to pair the\n   peer-reflexive candidate with remote
            candidates other than the one in\n   the valid pair that will be generated,
            the agent MAY provide updated\n   candidate information to the peer that
            includes the peer-reflexive\n   candidate.  This will cause the peer-reflexive
            candidate to be paired\n   with all other remote candidates.\n"
          title: 7.2.5.3.1.  Discovering Peer-Reflexive Candidates
        - contents:
          - "7.2.5.3.2.  Constructing a Valid Pair\n   The ICE agent constructs a
            candidate pair whose local candidate\n   equals the mapped address of
            the response and whose remote candidate\n   equals the destination address
            to which the request was sent.  This\n   is called a \"valid pair\".\n
            \  The valid pair might equal the pair that generated the connectivity\n
            \  check, a different pair in the checklist, or a pair currently not in\n
            \  the checklist.\n   The agent maintains a separate list, referred to
            as the \"valid list\".\n   There is a valid list for each checklist in
            the checklist set.  The\n   valid list will contain valid pairs.  Initially,
            each valid list is\n   empty.\n   Each valid pair within the valid list
            has a flag, called the\n   \"nominated flag\".  When a valid pair is added
            to a valid list, the\n   flag value is set to 'false'.\n   The valid pair
            will be added to a valid list as follows:\n   1.  If the valid pair equals
            the pair that generated the check, the\n       pair is added to the valid
            list associated with the checklist to\n       which the pair belongs;
            or\n   2.  If the valid pair equals another pair in a checklist, that
            pair\n       is added to the valid list associated with the checklist
            of that\n       pair.  The pair that generated the check is not added
            to a valid\n       list; or\n   3.  If the valid pair is not in any checklist,
            the agent computes the\n       priority for the pair based on the priority
            of each candidate,\n       using the algorithm in Section 6.1.2.  The
            priority of the local\n       candidate depends on its type.  Unless the
            type is peer\n       reflexive, the priority is equal to the priority
            signaled for\n       that candidate in the candidate exchange.  If the
            type is peer\n       reflexive, it is equal to the PRIORITY attribute
            the agent placed\n       in the Binding request that just completed.  The
            priority of the\n       remote candidate is taken from the candidate information
            of the\n       peer.  If the candidate does not appear there, then the
            check has\n       been a triggered check to a new remote candidate.  In
            that case,\n       the priority is taken as the value of the PRIORITY
            attribute in\n       the Binding request that triggered the check that
            just completed.\n       The pair is then added to the valid list.\n   NOTE:
            It will be very common that the valid pair will not be in any\n   checklist.
            \ Recall that the checklist has pairs whose local\n   candidates are never
            reflexive; those pairs had their local\n   candidates converted to the
            base of the reflexive candidates and were\n   then pruned if they were
            redundant.  When the response to the Binding\n   request arrives, the
            mapped address will be reflexive if there is a\n   NAT between the two.
            \ In that case, the valid pair will have a local\n   candidate that doesn't
            match any of the pairs in the checklist.\n"
          title: 7.2.5.3.2.  Constructing a Valid Pair
        - contents:
          - "7.2.5.3.3.  Updating Candidate Pair States\n   The ICE agent sets the
            states of both the candidate pair that\n   generated the check and the
            constructed valid pair (which may be\n   different) to Succeeded.\n   The
            agent MUST set the states for all other Frozen candidate pairs in\n   all
            checklists with the same foundation to Waiting.\n   NOTE: Within a given
            checklist, candidate pairs with the same\n   foundations will typically
            have different component ID values.\n"
          title: 7.2.5.3.3.  Updating Candidate Pair States
        - contents:
          - "7.2.5.3.4.  Updating the Nominated Flag\n   If the controlling agent
            sends a Binding request with the USE-\n   CANDIDATE attribute set, and
            if the ICE agent receives a successful\n   response to the request, the
            agent sets the nominated flag of the\n   pair to true.  If the request
            fails (Section 7.2.5.2), the agent MUST\n   remove the candidate pair
            from the valid list, set the candidate pair\n   state to Failed, and set
            the checklist state to Failed.\n   If the controlled agent receives a
            successful response to a Binding\n   request sent by the agent, and that
            Binding request was triggered by\n   a received Binding request with the
            USE-CANDIDATE attribute set\n   (Section 7.3.1.4), the agent sets the
            nominated flag of the pair to\n   true.  If the triggered request fails,
            the agent MUST remove the\n   candidate pair from the valid list, set
            the candidate pair state to\n   Failed, and set the checklist state to
            Failed.\n   Once the nominated flag is set for a component of a data stream,
            it\n   concludes the ICE processing for that component (Section 8).\n"
          title: 7.2.5.3.4.  Updating the Nominated Flag
        title: 7.2.5.3.  Success
      - contents:
        - "7.2.5.4.  Checklist State Updates\n   Regardless of whether a connectivity
          check was successful or failed,\n   the completion of the check may require
          updating of checklist states.\n   For each checklist in the checklist set,
          if all of the candidate\n   pairs are in either Failed or Succeeded state,
          and if there is not a\n   valid pair in the valid list for each component
          of the data stream\n   associated with the checklist, the state of the checklist
          is set to\n   Failed.  If there is a valid pair for each component in the
          valid\n   list, the state of the checklist is set to Succeeded.\n"
        title: 7.2.5.4.  Checklist State Updates
      title: 7.2.5.  Processing the Response
    title: 7.2.  STUN Client Procedures
  - contents:
    - "7.3.  STUN Server Procedures\n   An ICE agent (lite or full) MUST be prepared
      to receive Binding\n   requests on the base of each candidate it included in
      its most recent\n   candidate exchange.\n   The agent MUST use the short-term
      credential mechanism (i.e., the\n   MESSAGE-INTEGRITY attribute) to authenticate
      the request and perform\n   a message integrity check.  Likewise, the short-term
      credential\n   mechanism MUST be used for the response.  The agent MUST consider
      the\n   username to be valid if it consists of two values separated by a\n   colon,
      where the first value is equal to the username fragment\n   generated by the
      agent in a candidate exchange for a session in\n   progress.  It is possible
      (and in fact very likely) that the\n   initiating agent will receive a Binding
      request prior to receiving\n   the candidates from its peer.  If this happens,
      the agent MUST\n   immediately generate a response (including computation of
      the mapped\n   address as described in Section 7.3.1.2).  The agent has sufficient\n
      \  information at this point to generate the response; the password from\n   the
      peer is not required.  Once the answer is received, it MUST\n   proceed with
      the remaining steps required; namely, see Sections\n   7.3.1.3, 7.3.1.4, and
      7.3.1.5 for full implementations.  In cases\n   where multiple STUN requests
      are received before the answer, this may\n   cause several pairs to be queued
      up in the triggered-check queue.\n   An agent MUST NOT utilize the ALTERNATE-SERVER
      mechanism and MUST NOT\n   support the backwards-compatibility mechanisms defined
      in RFC 5389\n   (for working with the protocol in RFC 3489).  It MUST utilize
      the\n   FINGERPRINT mechanism.\n   If the agent is using DSCP markings [RFC2475]
      in its data packets, it\n   SHOULD apply the same markings to Binding responses.
      \ The same would\n   apply to any Layer 2 markings the endpoint might be applying
      to data\n   packets.\n"
    - contents:
      - "7.3.1.  Additional Procedures for Full Implementations\n   This subsection
        defines the additional server procedures applicable\n   to full implementations,
        when the full implementation accepts the\n   Binding request.\n"
      - contents:
        - "7.3.1.1.  Detecting and Repairing Role Conflicts\n   In certain usages
          of ICE (such as 3PCC), both ICE agents may end up\n   choosing the same
          role, resulting in a role conflict.  The section\n   describes a mechanism
          for detecting and repairing role conflicts.\n   The usage document MUST
          specify whether this mechanism is needed.\n   An agent MUST examine the
          Binding request for either the ICE-\n   CONTROLLING or ICE-CONTROLLED attribute.
          \ It MUST follow these\n   procedures:\n   o  If the agent is in the controlling
          role, and the ICE-CONTROLLING\n      attribute is present in the request:\n
          \     *  If the agent's tiebreaker value is larger than or equal to the\n
          \        contents of the ICE-CONTROLLING attribute, the agent generates\n
          \        a Binding error response and includes an ERROR-CODE attribute\n
          \        with a value of 487 (Role Conflict) but retains its role.\n      *
          \ If the agent's tiebreaker value is less than the contents of\n         the
          ICE-CONTROLLING attribute, the agent switches to the\n         controlled
          role.\n   o  If the agent is in the controlled role, and the ICE-CONTROLLED\n
          \     attribute is present in the request:\n      *  If the agent's tiebreaker
          value is larger than or equal to the\n         contents of the ICE-CONTROLLED
          attribute, the agent switches to\n         the controlling role.\n      *
          \ If the agent's tiebreaker value is less than the contents of\n         the
          ICE-CONTROLLED attribute, the agent generates a Binding\n         error
          response and includes an ERROR-CODE attribute with a\n         value of
          487 (Role Conflict) but retains its role.\n   o  If the agent is in the
          controlled role and the ICE-CONTROLLING\n      attribute was present in
          the request, or if the agent was in the\n      controlling role and the
          ICE-CONTROLLED attribute was present in\n      the request, there is no
          conflict.\n   A change in roles will require an agent to recompute pair
          priorities\n   (Section 6.1.2.3), since those priorities are a function
          of role.\n   The change in role will also impact whether the agent is responsible\n
          \  for selecting nominated pairs and initiating exchange with updated\n
          \  candidate information upon conclusion of ICE.\n   The remaining subsections
          in Section 7.3.1 are followed if the agent\n   generated a successful response
          to the Binding request, even if the\n   agent changed roles.\n"
        title: 7.3.1.1.  Detecting and Repairing Role Conflicts
      - contents:
        - "7.3.1.2.  Computing Mapped Addresses\n   For requests received on a relayed
          candidate, the source transport\n   address used for STUN processing (namely,
          generation of the\n   XOR-MAPPED-ADDRESS attribute) is the transport address
          as seen by the\n   TURN server.  That source transport address will be present
          in the\n   XOR-PEER-ADDRESS attribute of a Data Indication message, if the\n
          \  Binding request was delivered through a Data Indication.  If the\n   Binding
          request was delivered through a ChannelData message, the\n   source transport
          address is the one that was bound to the channel.\n"
        title: 7.3.1.2.  Computing Mapped Addresses
      - contents:
        - "7.3.1.3.  Learning Peer-Reflexive Candidates\n   If the source transport
          address of the request does not match any\n   existing remote candidates,
          it represents a new peer-reflexive remote\n   candidate.  This candidate
          is constructed as follows:\n   o  The type is peer reflexive.\n   o  The
          priority is the value of the PRIORITY attribute in the Binding\n      request.\n
          \  o  The foundation is an arbitrary value, different from the\n      foundations
          of all other remote candidates.  If any subsequent\n      candidate exchanges
          contain this peer-reflexive candidate, it will\n      signal the actual
          foundation for the candidate.\n   o  The component ID is the component ID
          of the local candidate to\n      which the request was sent.\n   This candidate
          is added to the list of remote candidates.  However,\n   the ICE agent does
          not pair this candidate with any local candidates.\n"
        title: 7.3.1.3.  Learning Peer-Reflexive Candidates
      - contents:
        - "7.3.1.4.  Triggered Checks\n   Next, the agent constructs a pair whose
          local candidate has the\n   transport address (as seen by the agent) on
          which the STUN request\n   was received and a remote candidate equal to
          the source transport\n   address where the request came from (which may
          be the peer-reflexive\n   remote candidate that was just learned).  The
          local candidate will be\n   either a host candidate (for cases where the
          request was not received\n   through a relay) or a relayed candidate (for
          cases where it is\n   received through a relay).  The local candidate can
          never be a\n   server-reflexive candidate.  Since both candidates are known
          to the\n   agent, it can obtain their priorities and compute the candidate
          pair\n   priority.  This pair is then looked up in the checklist.  There
          can\n   be one of several outcomes:\n   o  When the pair is already on the
          checklist:\n      *  If the state of that pair is Succeeded, nothing further
          is\n         done.\n      *  If the state of that pair is In-Progress, the
          agent cancels the\n         In-Progress transaction.  Cancellation means
          that the agent\n         will not retransmit the Binding requests associated
          with the\n         connectivity-check transaction, will not treat the lack
          of\n         response to be a failure, but will wait the duration of the\n
          \        transaction timeout for a response.  In addition, the agent\n         MUST
          enqueue the pair in the triggered checklist associated\n         with the
          checklist, and set the state of the pair to Waiting,\n         in order
          to trigger a new connectivity check of the pair.\n         Creating a new
          connectivity check enables validating\n         In-Progress pairs as soon
          as possible, without having to wait\n         for retransmissions of the
          Binding requests associated with the\n         original connectivity-check
          transaction.\n      *  If the state of that pair is Waiting, Frozen, or
          Failed, the\n         agent MUST enqueue the pair in the triggered checklist\n
          \        associated with the checklist (if not already present), and set\n
          \        the state of the pair to Waiting, in order to trigger a new\n         connectivity
          check of the pair.  Note that a state change of\n         the pair from
          Failed to Waiting might also trigger a state\n         change of the associated
          checklist.\n   These steps are done to facilitate rapid completion of ICE
          when both\n   agents are behind NAT.\n   o  If the pair is not already on
          the checklist:\n      *  The pair is inserted into the checklist based on
          its priority.\n      *  Its state is set to Waiting.\n      *  The pair
          is enqueued into the triggered-check queue.\n   When a triggered check is
          to be sent, it is constructed and processed\n   as described in Section
          7.2.4.  These procedures require the agent to\n   know the transport address,
          username fragment, and password for the\n   peer.  The username fragment
          for the remote candidate is equal to the\n   part after the colon of the
          USERNAME in the Binding request that was\n   just received.  Using that
          username fragment, the agent can check the\n   candidates received from
          its peer (there may be more than one in\n   cases of forking) and find this
          username fragment.  The corresponding\n   password is then picked.\n"
        title: 7.3.1.4.  Triggered Checks
      - contents:
        - "7.3.1.5.  Updating the Nominated Flag\n   If the controlled agent receives
          a Binding request with the USE-\n   CANDIDATE attribute set, and if the
          ICE agent accepts the request,\n   the following action is based on the
          state of the pair computed in\n   Section 7.3.1.4:\n   o  If the state of
          this pair is Succeeded, it means that the check\n      previously sent by
          this pair produced a successful response and\n      generated a valid pair
          (Section 7.2.5.3.2).  The agent sets the\n      nominated flag value of
          the valid pair to true.\n   o  If the received Binding request triggered
          a new check to be\n      enqueued in the triggered-check queue (Section
          7.3.1.4), once the\n      check is sent and if it generates a successful
          response, and\n      generates a valid pair, the agent sets the nominated
          flag of the\n      pair to true.  If the request fails (Section 7.2.5.2),
          the agent\n      MUST remove the candidate pair from the valid list, set
          the\n      candidate pair state to Failed, and set the checklist state to\n
          \     Failed.\n   If the controlled agent does not accept the request from
          the\n   controlling agent, the controlled agent MUST reject the nomination\n
          \  request with an appropriate error code response (e.g., 400)\n   [RFC5389].\n
          \  Once the nominated flag is set for a component of a data stream, it\n
          \  concludes the ICE processing for that component.  See Section 8.\n"
        title: 7.3.1.5.  Updating the Nominated Flag
      title: 7.3.1.  Additional Procedures for Full Implementations
    - contents:
      - "7.3.2.  Additional Procedures for Lite Implementations\n   If the controlled
        agent receives a Binding request with the USE-\n   CANDIDATE attribute set,
        and if the ICE agent accepts the request,\n   the agent constructs a candidate
        pair whose local candidate has the\n   transport address on which the request
        was received, and whose remote\n   candidate is equal to the source transport
        address of the request\n   that was received.  This candidate pair is assigned
        an arbitrary\n   priority and placed into the valid list of the associated
        checklist.\n   The agent sets the nominated flag for that pair to true.\n
        \  Once the nominated flag is set for a component of a data stream, it\n   concludes
        the ICE processing for that component.  See Section 8.\n"
      title: 7.3.2.  Additional Procedures for Lite Implementations
    title: 7.3.  STUN Server Procedures
  title: 7.  Performing Connectivity Checks
- contents:
  - "8.  Concluding ICE Processing\n   This section describes how an ICE agent completes
    ICE.\n"
  - contents:
    - "8.1.  Procedures for Full Implementations\n   Concluding ICE involves nominating
      pairs by the controlling agent and\n   updating state machinery.\n"
    - contents:
      - "8.1.1.  Nominating Pairs\n   Prior to nominating, the controlling agent lets
        connectivity checks\n   continue until some stopping criterion is met.  After
        that, based on\n   an evaluation criterion, the controlling agent picks a
        pair among the\n   valid pairs in the valid list for nomination.\n   Once
        the controlling agent has picked a valid pair for nomination, it\n   repeats
        the connectivity check that produced this valid pair (by\n   enqueueing the
        pair that generated the check into the triggered-check\n   queue), this time
        with the USE-CANDIDATE attribute\n   (Section 7.2.5.3.4).  The procedures
        for the controlled agent are\n   described in Section 7.3.1.5.\n   Eventually,
        if the nominations succeed, both the controlling and\n   controlled agents
        will have a single nominated pair in the valid list\n   for each component
        of the data stream.  Once an ICE agent sets the\n   state of the checklist
        to Completed (when there is a nominated pair\n   for each component of the
        data stream), that pair becomes the\n   selected pair for that agent and is
        used for sending and receiving\n   data for that component of the data stream.\n
        \  If an agent is not able to produce selected pairs for each component\n
        \  of a data stream, the agent MUST take proper actions for informing\n   the
        other agent, e.g., by removing the stream.  The exact actions are\n   outside
        the scope of this specification.\n   The criteria for stopping the connectivity
        checks and for picking a\n   pair for nomination are outside the scope of
        this specification.\n   They are a matter of local optimization.  The only
        requirement is\n   that the agent MUST eventually pick one and only one candidate
        pair\n   and generate a check for that pair with the USE-CANDIDATE attribute\n
        \  set.\n   Once the controlling agent has successfully nominated a candidate\n
        \  pair (Section 7.2.5.3.4), the agent MUST NOT nominate another pair\n   for
        same component of the data stream within the ICE session.  Doing\n   so requires
        an ICE restart.\n   A controlling agent that does not support this specification
        (i.e.,\n   it is implemented according to RFC 5245) might nominate more than
        one\n   candidate pair.  This was referred to as \"aggressive nomination\"
        in\n   RFC 5245.  If more than one candidate pair is nominated by the\n   controlling
        agent, and if the controlled agent accepts multiple\n   nominations requests,
        the agents MUST produce the selected pairs and\n   use the pairs with the
        highest priority.\n   The usage of the 'ice2' ICE option (Section 10) by endpoints\n
        \  supporting this specification is supposed to prevent controlling\n   agents
        that are implemented according to RFC 5245 from using\n   aggressive nomination.\n
        \  NOTE: In RFC 5245, usage of \"aggressive nomination\" allowed agents to\n
        \  continuously nominate pairs, before a pair was eventually selected,\n   in
        order to allow sending of data on those pairs.  In this\n   specification,
        data can always be sent on any valid pair, without\n   nomination.  Hence,
        there is no longer a need for aggressive\n   nomination.\n"
      title: 8.1.1.  Nominating Pairs
    - contents:
      - "8.1.2.  Updating Checklist and ICE States\n   For both a controlling and
        a controlled agent, when a candidate pair\n   for a component of a data stream
        gets nominated, it might impact\n   other pairs in the checklist associated
        with the data stream.  It\n   might also impact the state of the checklist:\n
        \  o  Once a candidate pair for a component of a data stream has been\n      nominated,
        and the state of the checklist associated with the data\n      stream is Running,
        the ICE agent MUST remove all candidate pairs\n      for the same component
        from the checklist and from the triggered-\n      check queue.  If the state
        of a pair is In-Progress, the agent\n      cancels the In-Progress transaction.
        \ Cancellation means that the\n      agent will not retransmit the Binding
        requests associated with the\n      connectivity-check transaction, will not
        treat the lack of\n      response to be a failure, but will wait the duration
        of the\n      transaction timeout for a response.\n   o  Once candidate pairs
        for each component of a data stream have been\n      nominated, and the state
        of the checklist associated with the data\n      stream is Running, the ICE
        agent sets the state of the checklist\n      to Completed.\n   o  Once a candidate
        pair for a component of a data stream has been\n      nominated, an agent
        MUST continue to respond to any Binding\n      request it might still receive
        for the nominated pair and for any\n      remaining candidate pairs in the
        checklist associated with the\n      data stream.  As defined in Section 7.3.1.4,
        when the state of a\n      pair is Succeeded, an agent will no longer generate
        triggered\n      checks when receiving a Binding request for the pair.\n   Once
        the state of each checklist in the checklist set is Completed,\n   the agent
        sets the state of the ICE session to Completed.\n   If the state of a checklist
        is Failed, ICE has not been able to\n   successfully complete the process
        for the data stream associated with\n   the checklist.  The correct behavior
        depends on the state of the\n   checklists in the checklist set.  If the controlling
        agent wants to\n   continue the session without the data stream associated
        with the\n   Failed checklist, and if there are still one or more checklists
        in\n   Running or Completed mode, the agent can let the ICE processing\n   continue.
        \ The agent MUST take proper actions for removing the failed\n   data stream.
        \ If the controlling agent does not want to continue the\n   session and MUST
        terminate the session, the state of the ICE session\n   is set to Failed.\n
        \  If the state of each checklist in the checklist set is Failed, the\n   state
        of the ICE session is set to Failed.  Unless the controlling\n   agent wants
        to continue the session without the data streams, it MUST\n   terminate the
        session.\n"
      title: 8.1.2.  Updating Checklist and ICE States
    title: 8.1.  Procedures for Full Implementations
  - contents:
    - "8.2.  Procedures for Lite Implementations\n   When ICE concludes, a lite ICE
      agent can free host candidates that\n   were not used by ICE, as described in
      Section 8.3.\n   If the peer is a full agent, once the lite agent accepts a
      nomination\n   request for a candidate pair, the lite agent considers the pair\n
      \  nominated.  Once there are nominated pairs for each component of a\n   data
      stream, the pairs become the selected pairs for the components\n   of the data
      stream.  Once the lite agent has produced selected pairs\n   for all components
      of all data streams, the ICE session state is set\n   to Completed.\n   If the
      peer is a lite agent, the agent pairs local candidates with\n   remote candidates
      that are of the same data stream and have the same\n   component, transport
      protocol, and IP address family.  For each\n   component of each data stream,
      if there is only one candidate pair,\n   that pair is added to the valid list.
      \ If there is more than one\n   pair, it is RECOMMENDED that an agent follow
      the procedures of RFC\n   6724 [RFC6724] to select a pair and add it to the
      valid list.\n   If all of the components for all data streams had one pair,
      the state\n   of ICE processing is Completed.  Otherwise, the controlling agent\n
      \  MUST send an updated candidate list to reconcile different agents\n   selecting
      different candidate pairs.  ICE processing is complete\n   after and only after
      the updated candidate exchange is complete.\n"
    title: 8.2.  Procedures for Lite Implementations
  - contents:
    - '8.3.  Freeing Candidates

      '
    - contents:
      - "8.3.1.  Full Implementation Procedures\n   The rules in this section describe
        when it is safe for an agent to\n   cease sending or receiving checks on a
        candidate that did not become\n   a selected candidate (i.e., is not associated
        with a selected pair)\n   and when to free the candidate.\n   Once a checklist
        has reached the Completed state, the agent SHOULD\n   wait an additional three
        seconds, and then it can cease responding to\n   checks or generating triggered
        checks on all local candidates other\n   than the ones that became selected
        candidates.  Once all ICE sessions\n   have ceased using a given local candidate
        (a candidate may be used by\n   multiple ICE sessions, e.g., in forking scenarios),
        the agent can\n   free that candidate.  The three-second delay handles cases
        when\n   aggressive nomination is used, and the selected pairs can quickly\n
        \  change after ICE has completed.\n   Freeing of server-reflexive candidates
        is never explicit; it happens\n   by lack of a keepalive.\n"
      title: 8.3.1.  Full Implementation Procedures
    - contents:
      - "8.3.2.  Lite Implementation Procedures\n   A lite implementation can free
        candidates that did not become\n   selected candidates as soon as ICE processing
        has reached the\n   Completed state for all ICE sessions using those candidates.\n"
      title: 8.3.2.  Lite Implementation Procedures
    title: 8.3.  Freeing Candidates
  title: 8.  Concluding ICE Processing
- contents:
  - "9.  ICE Restarts\n   An ICE agent MAY restart ICE for existing data streams.
    \ An ICE\n   restart causes all previous states of the data streams, excluding
    the\n   roles of the agents, to be flushed.  The only difference between an\n
    \  ICE restart and a brand new data session is that during the restart,\n   data
    can continue to be sent using existing data sessions, and a new\n   data session
    always requires the roles to be determined.\n   The following actions can be accomplished
    only by using an ICE\n   restart (the agent MUST use ICE restarts to do so):\n
    \  o  Change the destinations of data streams.\n   o  Change from a lite implementation
    to a full implementation.\n   o  Change from a full implementation to a lite implementation.\n
    \  To restart ICE, an agent MUST change both the password and the\n   username
    fragment for the data stream(s) being restarted.\n   When the ICE is restarted,
    the candidate set for the new ICE session\n   might include some, none, or all
    of the candidates used in the\n   current ICE session.\n   As described in Section
    6.1.1, agents MUST NOT redetermine the roles\n   as part as an ICE restart, unless
    certain criteria that require the\n   roles to be redetermined are fulfilled.\n"
  title: 9.  ICE Restarts
- contents:
  - "10.  ICE Option\n   This section defines a new ICE option, 'ice2'.  When an ICE
    agent\n   includes 'ice2' in a candidate exchange, the ICE option indicates\n
    \  that it is compliant to this specification.  For example, the agent\n   will
    not use the aggressive nomination procedure defined in RFC 5245.\n   In addition,
    it will ensure that a peer compliant with RFC 5245 does\n   not use aggressive
    nomination either, as required by Section 14 of\n   RFC 5245 for peers that receive
    unknown ICE options.\n   An agent compliant to this specification MUST inform
    the peer about\n   the compliance using the 'ice2' option.\n   NOTE: The encoding
    of the 'ice2' option, and the message(s) used to\n   carry it to the peer, are
    protocol specific.  The encoding for SDP\n   [RFC4566] is defined in [ICE-SIP-SDP].\n"
  title: 10.  ICE Option
- contents:
  - "11.  Keepalives\n   All endpoints MUST send keepalives for each data session.
    \ These\n   keepalives serve the purpose of keeping NAT bindings alive for the\n
    \  data session.  The keepalives SHOULD be sent using a format that is\n   supported
    by its peer.  ICE endpoints allow for STUN-based keepalives\n   for UDP streams,
    and as such, STUN keepalives MUST be used when an\n   ICE agent is a full ICE
    implementation and is communicating with a\n   peer that supports ICE (lite or
    full).\n   An agent MUST send a keepalive on each candidate pair that is used\n
    \  for sending data if no packet has been sent on that pair in the last\n   Tr
    seconds.  Agents SHOULD use a Tr value of 15 seconds.  Agents MAY\n   use a bigger
    value but MUST NOT use a value smaller than 15 seconds.\n   Once selected pairs
    have been produced for a data stream, keepalives\n   are only sent on those pairs.\n
    \  An agent MUST stop sending keepalives on a data stream if the data\n   stream
    is removed.  If the ICE session is terminated, an agent MUST\n   stop sending
    keepalives on all data streams.\n   An agent MAY use another value for Tr, e.g.,
    based on configuration\n   or network/NAT characteristics.  For example, if an
    agent has a\n   dynamic way to discover the binding lifetimes of the intervening\n
    \  NATs, it can use that value to determine Tr.  Administrators\n   deploying
    ICE in more controlled networking environments SHOULD set\n   Tr to the longest
    duration possible in their environment.\n   When STUN is being used for keepalives,
    a STUN Binding Indication is\n   used [RFC5389].  The Indication MUST NOT utilize
    any authentication\n   mechanism.  It SHOULD contain the FINGERPRINT attribute
    to aid in\n   demultiplexing, but it SHOULD NOT contain any other attributes.
    \ It\n   is used solely to keep the NAT bindings alive.  The Binding\n   Indication
    is sent using the same local and remote candidates that\n   are being used for
    data.  Though Binding Indications are used for\n   keepalives, an agent MUST be
    prepared to receive a connectivity check\n   as well.  If a connectivity check
    is received, a response is\n   generated as discussed in [RFC5389], but there
    is no impact on ICE\n   processing otherwise.\n   Agents MUST by default use STUN
    keepalives.  Individual ICE usages\n   and ICE extensions MAY specify usage-/extension-specific
    keepalives.\n"
  title: 11.  Keepalives
- contents:
  - '12.  Data Handling

    '
  - contents:
    - "12.1.  Sending Data\n   An ICE agent MAY send data on any valid pair before
      selected pairs\n   have been produced for the data stream.\n   Once selected
      pairs have been produced for a data stream, an agent\n   MUST send data on those
      pairs only.\n   An agent sends data from the base of the local candidate to
      the\n   remote candidate.  In the case of a local relayed candidate, data is\n
      \  forwarded through the base (located in the TURN server), using the\n   procedures
      defined in [RFC5766].\n   If the local candidate is a relayed candidate, it
      is RECOMMENDED that\n   an agent creates a channel on the TURN server towards
      the remote\n   candidate.  This is done using the procedures for channel creation
      as\n   defined in Section 11 of [RFC5766].\n   The selected pair for a component
      of a data stream is:\n   o  empty if the state of the checklist for that data
      stream is\n      Running, and there is no previous selected pair for that component\n
      \     due to an ICE restart\n   o  equal to the previous selected pair for a
      component of a data\n      stream if the state of the checklist for that data
      stream is\n      Running, and there was a previous selected pair for that component\n
      \     due to an ICE restart\n   Unless an agent is able to produce a selected
      pair for each component\n   associated with a data stream, the agent MUST NOT
      continue sending\n   data for any component associated with that data stream.\n"
    - contents:
      - "12.1.1.  Procedures for Lite Implementations\n   A lite implementation MUST
        NOT send data until it has a valid list\n   that contains a candidate pair
        for each component of that data\n   stream.  Once that happens, the ICE agent
        MAY begin sending data\n   packets.  To do that, it sends data to the remote
        candidate in the\n   pair (setting the destination address and port of the
        packet equal to\n   that remote candidate) and will send it from the base
        associated with\n   the candidate pair used for sending data.  In case of
        a relayed\n   candidate, data is sent from the agent and forwarded through
        the base\n   (located in the TURN server), using the procedures defined in\n
        \  [RFC5766].\n"
      title: 12.1.1.  Procedures for Lite Implementations
    title: 12.1.  Sending Data
  - contents:
    - "12.2.  Receiving Data\n   Even though ICE agents are only allowed to send data
      using valid\n   candidate pairs (and, once selected pairs have been produced,
      only on\n   the selected pairs), ICE implementations SHOULD by default be\n
      \  prepared to receive data on any of the candidates provided in the\n   most
      recent candidate exchange with the peer.  ICE usages MAY define\n   rules that
      differ from this, e.g., by defining that data will not be\n   sent until selected
      pairs have been produced for a data stream.\n   When an agent receives an RTP
      packet with a new source or destination\n   IP address for a particular RTP/RTCP
      data stream, it is RECOMMENDED\n   that the agent readjust its jitter buffers.\n
      \  Section 8.2 of RFC 3550 [RFC3550] describes an algorithm for\n   detecting
      synchronization source (SSRC) collisions and loops.  These\n   algorithms are
      based, in part, on seeing different source transport\n   addresses with the
      same SSRC.  However, when ICE is used, such\n   changes will sometimes occur
      as the data streams switch between\n   candidates.  An agent will be able to
      determine that a data stream is\n   from the same peer as a consequence of the
      STUN exchange that\n   proceeds media data transmission.  Thus, if there is
      a change in the\n   source transport address, but the media data packets come
      from the\n   same peer agent, this MUST NOT be treated as an SSRC collision.\n"
    title: 12.2.  Receiving Data
  title: 12.  Data Handling
- contents:
  - "13.  Extensibility Considerations\n   This specification makes very specific
    choices about how both ICE\n   agents in a session coordinate to arrive at the
    set of candidate\n   pairs that are selected for data.  It is anticipated that
    future\n   specifications will want to alter these algorithms, whether they are\n
    \  simple changes like timer tweaks or larger changes like a revamp of\n   the
    priority algorithm.  When such a change is made, providing\n   interoperability
    between the two agents in a session is critical.\n   First, ICE provides the ICE
    option concept.  Each extension or change\n   to ICE is associated with an ICE
    option.  When an agent supports such\n   an extension or change, it provides the
    ICE option to the peer agent\n   as part of the candidate exchange.\n   One of
    the complications in achieving interoperability is that ICE\n   relies on a distributed
    algorithm running on both agents to converge\n   on an agreed set of candidate
    pairs.  If the two agents run different\n   algorithms, it can be difficult to
    guarantee convergence on the same\n   candidate pairs.  The nomination procedure
    described in Section 8\n   eliminates some of the need for tight coordination
    by delegating the\n   selection algorithm completely to the controlling agent,
    and ICE will\n   converge perfectly even when both agents use different pair\n
    \  prioritization algorithms.  One of the keys to such convergence is\n   triggered
    checks, which ensure that the nominated pair is validated\n   by both agents.\n
    \  ICE is also extensible to other data streams beyond RTP and for\n   transport
    protocols beyond UDP.  Extensions to ICE for non-RTP data\n   streams need to
    specify how many components they utilize and assign\n   component IDs to them,
    starting at 1 for the most important component\n   ID.  Specifications for new
    transport protocols MUST define how, if\n   at all, various steps in the ICE processing
    differ from UDP.\n"
  title: 13.  Extensibility Considerations
- contents:
  - '14.  Setting Ta and RTO

    '
  - contents:
    - "14.1.  General\n   During the ICE gathering phase (Section 5.1.1) and while
      ICE is\n   performing connectivity checks (Section 7), an ICE agent triggers\n
      \  STUN and TURN transactions.  These transactions are paced at a rate\n   indicated
      by Ta, and the retransmission interval for each transaction\n   is calculated
      based on the retransmission timer for the STUN\n   transactions (RTO) [RFC5389].\n
      \  This section describes how the Ta and RTO values are computed during\n   the
      ICE gathering phase and while ICE is performing connectivity\n   checks.\n   NOTE:
      Previously, in RFC 5245, different formulas were defined for\n   computing Ta
      and RTO, depending on whether or not ICE was used for a\n   real-time data stream
      (e.g., RTP).\n   The formulas below result in a behavior whereby an agent will
      send\n   its first packet for every single connectivity check before\n   performing
      a retransmit.  This can be seen in the formulas for the\n   RTO (which represents
      the retransmit interval).  Those formulas scale\n   with N, the number of checks
      to be performed.  As a result of this,\n   ICE maintains a nicely constant rate,
      but it becomes more sensitive\n   to packet loss.  The loss of the first single
      packet for any\n   connectivity check is likely to cause that pair to take a
      long time\n   to be validated, and instead, a lower-priority check (but one
      for\n   which there was no packet loss) is much more likely to complete\n   first.
      \ This results in ICE performing suboptimally, choosing lower-\n   priority
      pairs over higher-priority pairs.\n"
    title: 14.1.  General
  - contents:
    - "14.2.  Ta\n   ICE agents SHOULD use a default Ta value, 50 ms, but MAY use
      another\n   value based on the characteristics of the associated data.\n   If
      an agent wants to use a Ta value other than the default value, the\n   agent
      MUST indicate the proposed value to its peer during the\n   establishment of
      the ICE session.  Both agents MUST use the higher\n   value of the proposed
      values.  If an agent does not propose a value,\n   the default value is used
      for that agent when comparing which value\n   is higher.\n   Regardless of the
      Ta value chosen for each agent, the combination of\n   all transactions from
      all agents (if a given implementation runs\n   several concurrent agents) MUST
      NOT be sent more often than once\n   every 5 ms (as though there were one global
      Ta value for pacing all\n   agents).  See Appendix B.1 for the background of
      using a value of\n   5 ms with ICE.\n   NOTE: Appendix C shows examples of required
      bandwidth, using\n   different Ta values.\n"
    title: 14.2.  Ta
  - contents:
    - "14.3.  RTO\n   During the ICE gathering phase, ICE agents SHOULD calculate
      the RTO\n   value using the following formula:\n     RTO = MAX (500ms, Ta *
      (Num-Of-Cands))\n     Num-Of-Cands: the number of server-reflexive and relay
      candidates\n   For connectivity checks, agents SHOULD calculate the RTO value
      using\n   the following formula:\n     RTO = MAX (500ms, Ta * N * (Num-Waiting
      + Num-In-Progress))\n     N: the total number of connectivity checks to be performed.\n
      \    Num-Waiting: the number of checks in the checklist set in the\n     Waiting
      state.\n     Num-In-Progress: the number of checks in the checklist set in the\n
      \    In-Progress state.\n     Note that the RTO will be different for each transaction
      as the\n     number of checks in the Waiting and In-Progress states change.\n
      \  Agents MAY calculate the RTO value using other mechanisms than those\n   described
      above.  Agents MUST NOT use an RTO value smaller than\n   500 ms.\n"
    title: 14.3.  RTO
  title: 14.  Setting Ta and RTO
- contents:
  - "15.  Examples\n   This section shows two ICE examples: one using IPv4 addresses
    and one\n   using IPv6 addresses.\n   To facilitate understanding, transport addresses
    are listed using\n   variables that have mnemonic names.  The format of the name
    is\n   entity-type-seqno: \"entity\" refers to the entity whose IP address the\n
    \  transport address is on and is one of \"L\", \"R\", \"STUN\", or \"NAT\".\n
    \  The type is either \"PUB\" for transport addresses that are public or\n   \"PRIV\"
    for transport addresses that are private [RFC1918].  Finally,\n   seq-no is a
    sequence number that is different for each transport\n   address of the same type
    on a particular entity.  Each variable has\n   an IP address and port, denoted
    by varname.IP and varname.PORT,\n   respectively, where varname is the name of
    the variable.\n   In the call flow itself, STUN messages are annotated with several\n
    \  attributes.  The \"S=\" attribute indicates the source transport\n   address
    of the message.  The \"D=\" attribute indicates the destination\n   transport
    address of the message.  The \"MA=\" attribute is used in\n   STUN Binding response
    messages and refers to the mapped address.\n   \"USE-CAND\" implies the presence
    of the USE-CANDIDATE attribute.\n   The call flow examples omit STUN authentication
    operations and focus\n   on a single data stream between two full implementations.\n"
  - contents:
    - "15.1.  Example with IPv4 Addresses\n   The example below is using the topology
      shown in Figure 7.\n                                  +-------+\n                                  |STUN
      \  |\n                                  |Server |\n                                  +-------+\n
      \                                     |\n                           +---------------------+\n
      \                          |                     |\n                           |
      \     Internet       |\n                           |                     |\n
      \                          +---------------------+\n                             |
      \               |\n                             |                |\n                      +---------+
      \            |\n                      |   NAT   |             |\n                      +---------+
      \            |\n                           |                  |\n                           |
      \                 |\n                        +-----+            +-----+\n                        |
      \ L  |            |  R  |\n                        +-----+            +-----+\n
      \                       Figure 7: Example Topology\n   In the example, ICE agents
      L and R are full ICE implementations.\n   Both agents have a single IPv4 address,
      and both are configured with\n   the same STUN server.  The NAT has an endpoint-independent
      mapping\n   property and an address-dependent filtering property.  The IP\n
      \  addresses of the ICE agents, the STUN server, and the NAT are shown\n   below:\n
      \  ENTITY                   IP Address  Mnemonic name\n   --------------------------------------------------\n
      \  ICE Agent L:             10.0.1.1    L-PRIV-1\n   ICE Agent R:             192.0.2.1
      \  R-PUB-1\n   STUN Server:             192.0.2.2   STUN-PUB-1\n   NAT (Public):
      \           192.0.2.3   NAT-PUB-1\n             L             NAT           STUN
      \            R\n             |STUN alloc.   |              |              |\n
      \            |(1) STUN Req  |              |              |\n             |S=$L-PRIV-1
      \  |              |              |\n             |D=$STUN-PUB-1 |              |
      \             |\n             |------------->|              |              |\n
      \            |              |(2) STUN Req  |              |\n             |
      \             |S=$NAT-PUB-1  |              |\n             |              |D=$STUN-PUB-1
      |              |\n             |              |------------->|              |\n
      \            |              |(3) STUN Res  |              |\n             |
      \             |S=$STUN-PUB-1 |              |\n             |              |D=$NAT-PUB-1
      \ |              |\n             |              |MA=$NAT-PUB-1 |              |\n
      \            |              |<-------------|              |\n             |(4)
      STUN Res  |              |              |\n             |S=$STUN-PUB-1 |              |
      \             |\n             |D=$L-PRIV-1   |              |              |\n
      \            |MA=$NAT-PUB-1 |              |              |\n             |<-------------|
      \             |              |\n             |(5) L's Candidate Information|
      \             |\n             |------------------------------------------->|\n
      \            |              |              |              | STUN\n             |
      \             |              |              | alloc.\n             |              |
      \             |(6) STUN Req  |\n             |              |              |S=$R-PUB-1
      \   |\n             |              |              |D=$STUN-PUB-1 |\n             |
      \             |              |<-------------|\n             |              |
      \             |(7) STUN Res  |\n             |              |              |S=$STUN-PUB-1
      |\n             |              |              |D=$R-PUB-1    |\n             |
      \             |              |MA=$R-PUB-1   |\n             |              |
      \             |------------->|\n             |(8) R's Candidate Information|
      \             |\n             |<-------------------------------------------|\n
      \            |              |         (9) Bind Req        |Begin\n             |
      \             |         S=$R-PUB-1          |Connectivity\n             |              |
      \        D=$L-PRIV-1         |Checks\n             |              |         <-------------------|\n
      \            |              |         Dropped             |\n             |(10)
      Bind Req |              |              |\n             |S=$L-PRIV-1   |              |
      \             |\n             |D=$R-PUB-1    |              |              |\n
      \            |------------->|              |              |\n             |
      \             |(11) Bind Req |              |\n             |              |S=$NAT-PUB-1
      \ |              |\n             |              |D=$R-PUB-1    |              |\n
      \            |              |---------------------------->|\n             |
      \             |(12) Bind Res |              |\n             |              |S=$R-PUB-1
      \   |              |\n             |              |D=$NAT-PUB-1  |              |\n
      \            |              |MA=$NAT-PUB-1 |              |\n             |
      \             |<----------------------------|\n             |(13) Bind Res |
      \             |              |\n             |S=$R-PUB-1    |              |
      \             |\n             |D=$L-PRIV-1   |              |              |\n
      \            |MA=$NAT-PUB-1 |              |              |\n             |<-------------|
      \             |              |\n             |Data          |              |
      \             |\n             |===========================================>|\n
      \            |              |              |              |\n             |
      \             |(14) Bind Req |              |\n             |              |S=$R-PUB-1
      \   |              |\n             |              |D=$NAT-PUB-1  |              |\n
      \            |              |<----------------------------|\n             |(15)
      Bind Req |              |              |\n             |S=$R-PUB-1    |              |
      \             |\n             |D=$L-PRIV-1   |              |              |\n
      \            |<-------------|              |              |\n             |(16)
      Bind Res |              |              |\n             |S=$L-PRIV-1   |              |
      \             |\n             |D=$R-PUB-1    |              |              |\n
      \            |MA=$R-PUB-1   |              |              |\n             |------------->|
      \             |              |\n             |              |(17) Bind Res |
      \             |\n             |              |S=$NAT-PUB-1  |              |\n
      \            |              |D=$R-PUB-1    |              |\n             |
      \             |MA=$R-PUB-1   |              |\n             |              |---------------------------->|\n
      \            |Data          |              |              |\n             |<===========================================|\n
      \            |              |              |              |\n                                .......\n
      \            |              |              |              |\n             |(18)
      Bind Req |              |              |\n             |S=$L-PRIV-1   |              |
      \             |\n             |D=$R-PUB-1    |              |              |\n
      \            |USE-CAND      |              |              |\n             |------------->|
      \             |              |\n             |              |(19) Bind Req |
      \             |\n             |              |S=$NAT-PUB-1  |              |\n
      \            |              |D=$R-PUB-1    |              |\n             |
      \             |USE-CAND      |              |\n             |              |---------------------------->|\n
      \            |              |(20) Bind Res |              |\n             |
      \             |S=$R-PUB-1    |              |\n             |              |D=$NAT-PUB-1
      \ |              |\n             |              |MA=$NAT-PUB-1 |              |\n
      \            |              |<----------------------------|\n             |(21)
      Bind Res |              |              |\n             |S=$R-PUB-1    |              |
      \             |\n             |D=$L-PRIV-1   |              |              |\n
      \            |MA=$NAT-PUB-1 |              |              |\n             |<-------------|
      \             |              |\n             |              |              |
      \             |\n                          Figure 8: Example Flow\n   Messages
      1-4: Agent L gathers a host candidate from its local IP\n   address, and from
      that it sends a STUN Binding request to the STUN\n   server.  The request creates
      a NAT binding.  The NAT public IP\n   address of the binding becomes agent L's
      server-reflexive candidate.\n   Message 5: Agent L sends its local candidate
      information to agent R,\n   using the signaling protocol associated with the
      ICE usage.\n   Messages 6-7: Agent R gathers a host candidate from its local
      IP\n   address, and from that it sends a STUN Binding request to the STUN\n
      \  server.  Since agent R is not behind a NAT, R's server-reflexive\n   candidate
      will be identical to the host candidate.\n   Message 8: Agent R sends its local
      candidate information to agent L,\n   using the signaling protocol associated
      with the ICE usage.\n   Since both agents are full ICE implementations, the
      initiating agent\n   (agent L) becomes the controlling agent.\n   Agents L and
      R both pair up the candidates.  Both agents initially\n   have two pairs.  However,
      agent L will prune the pair containing its\n   server-reflexive candidate, resulting
      in just one (L1).  At agent L,\n   this pair has a local candidate of $L_PRIV_1
      and a remote candidate\n   of $R_PUB_1.  At agent R, there are two pairs.  The
      highest-priority\n   pair (R1) has a local candidate of $R_PUB_1 and a remote
      candidate of\n   $L_PRIV_1, and the second pair (R2) has a local candidate of
      $R_PUB_1\n   and a remote candidate of $NAT_PUB_1.  The pairs are shown below
      (the\n   pair numbers are for reference purposes only):\n                            Pairs\n
      \  ENTITY                   Local         Remote     Pair #     Valid\n   ------------------------------------------------------------------\n
      \  ICE Agent L:             L_PRIV_1      R_PUB_1       L1\n   ICE Agent R:
      \            R_PUB_1       L_PRIV_1      R1\n                            R_PUB_1
      \      NAT_PUB_1     R2\n   Message 9: Agent R initiates a connectivity check
      for pair #2.  As\n   the remote candidate of the pair is the private address
      of agent L,\n   the check will not be successful, as the request cannot be routed\n
      \  from R to L, and will be dropped by the network.\n   Messages 10-13: Agent
      L initiates a connectivity check for pair L1.\n   The check succeeds, and L
      creates a new pair (L2).  The local\n   candidate of the new pair is $NAT_PUB_1,
      and the remote candidate is\n   $R_PUB_1.  The pair (L2) is added to the valid
      list of agent L.\n   Agent L can now send and receive data on the pair (L2)
      if it wishes.\n                            Pairs\n   ENTITY                   Local
      \        Remote     Pair #     Valid\n   ------------------------------------------------------------------\n
      \  ICE Agent L:             L_PRIV_1      R_PUB_1       L1\n                            NAT_PUB_1
      \    R_PUB_1       L2        X\n   ICE Agent R:             R_PUB_1       L_PRIV_1
      \     R1\n                            R_PUB_1       NAT_PUB_1     R2\n   Messages
      14-17: When agent R receives the Binding request from agent\n   L (message 11),
      it will initiate a triggered connectivity check.  The\n   pair matches one of
      agent R's existing pairs (R2).  The check\n   succeeds, and the pair (R2) is
      added to the valid list of agent R.\n   Agent R can now send and receive data
      on the pair (R2) if it wishes.\n                            Pairs\n   ENTITY
      \                  Local         Remote     Pair #     Valid\n   ------------------------------------------------------------------\n
      \  ICE Agent L:             L_PRIV_1      R_PUB_1       L1\n                            NAT_PUB_1
      \    R_PUB_1       L2        X\n   ICE Agent R:             R_PUB_1       L_PRIV_1
      \     R1\n                            R_PUB_1       NAT_PUB_1     R2        X\n
      \  Messages 18-21: At some point, the controlling agent (agent L)\n   decides
      to nominate a pair (L2) in the valid list.  It performs a\n   connectivity check
      on the pair (L2) and includes the USE-CANDIDATE\n   attribute in the Binding
      request.  As the check succeeds, agent L\n   sets the nominated flag value of
      the pair (L2) to 'true', and agent R\n   sets the nominated flag value of the
      matching pair (R2) to 'true'.\n   As there are no more components associated
      with the stream, the\n   nominated pairs become the selected pairs.  Consequently,
      processing\n   for this stream moves into the Completed state.  The ICE process
      also\n   moves into the Completed state.\n"
    title: 15.1.  Example with IPv4 Addresses
  - contents:
    - "15.2.  Example with IPv6 Addresses\n   The example below is using the topology
      shown in Figure 9.\n                                +-------+\n                                |STUN
      \  |\n                                |Server |\n                                +-------+\n
      \                                   |\n                         +---------------------+\n
      \                        |                     |\n                         |
      \     Internet       |\n                         |                     |\n                         +---------------------+\n
      \                           |                |\n                            |
      \               |\n                            |                |\n                            |
      \               |\n                            |                |\n                            |
      \               |\n                            |                |\n                         +-----+
      \         +-----+\n                         |  L  |          |  R  |\n                         +-----+
      \         +-----+\n                        Figure 9: Example Topology\n   In
      the example, ICE agents L and R are full ICE implementations.\n   Both agents
      have a single IPv6 address, and both are configured with\n   the same STUN server.
      \ The IP addresses of the ICE agents and the\n   STUN server are shown below:\n
      \  ENTITY                   IP Address  mnemonic name\n   --------------------------------------------------\n
      \  ICE Agent L:             2001:db8::3   L-PUB-1\n   ICE Agent R:             2001:db8::5
      \  R-PUB-1\n   STUN Server:             2001:db8::9   STUN-PUB-1\n             L
      \                          STUN             R\n             |STUN alloc.                  |
      \             |\n             |(1) STUN Req                 |              |\n
      \            |S=$L-PUB-1                   |              |\n             |D=$STUN-PUB-1
      \               |              |\n             |---------------------------->|
      \             |\n             |(2) STUN Res                 |              |\n
      \            | S=$STUN-PUB-1               |              |\n             |
      D=$L-PUB-1                  |              |\n             | MA=$L-PUB-1                 |
      \             |\n             |<----------------------------|              |\n
      \            |(3) L's Candidate Information|              |\n             |------------------------------------------->|\n
      \            |                             |              | STUN\n             |
      \                            |              | alloc.\n             |                             |(4)
      STUN Req  |\n             |                             |S=$R-PUB-1    |\n             |
      \                            |D=$STUN-PUB-1 |\n             |                             |<-------------|\n
      \            |                             |(5) STUN Res  |\n             |
      \                            |S=$STUN-PUB-1 |\n             |                             |D=$R-PUB-1
      \   |\n             |                             |MA=$R-PUB-1   |\n             |
      \                            |------------->|\n             |(6) R's Candidate
      Information|              |\n             |<-------------------------------------------|\n
      \            |(7) Bind Req                 |              |\n             |S=$L-PUB-1
      \                  |              |\n             |D=$R-PUB-1                   |
      \             |\n             |------------------------------------------->|\n
      \            |(8) Bind Res                 |              |\n             |S=$R-PUB-1
      \                  |              |\n             |D=$L-PUB-1                   |
      \             |\n             |MA=$L-PUB-1                  |              |\n
      \            |<-------------------------------------------|\n             |Data
      \                        |              |\n             |===========================================>|\n
      \            |                             |              |\n             |(9)
      Bind Req                 |              |\n             |S=$R-PUB-1                   |
      \             |\n             |D=$L-PUB-1                   |              |\n
      \            |<-------------------------------------------|\n             |(10)
      Bind Res                |              |\n             |S=$L-PUB-1                   |
      \             |\n             |D=$R-PUB-1                   |              |\n
      \            |MA=$R-PUB-1                  |              |\n             |------------------------------------------->|\n
      \            |Data                         |              |\n             |<===========================================|\n
      \            |                             |              |\n                                .......\n
      \            |                             |              |\n             |(11)
      Bind Req                |              |\n             |S=$L-PUB-1                   |
      \             |\n             |D=$R-PUB-1                   |              |\n
      \            |USE-CAND                     |              |\n             |------------------------------------------->|\n
      \            |(12) Bind Res                |              |\n             |S=$R-PUB-1
      \                  |              |\n             |D=$L-PUB-1                   |
      \             |\n             |MA=$L-PUB-1                  |              |\n
      \            |<-------------------------------------------|\n             |
      \             |              |              |\n                          Figure
      10: Example Flow\n   Messages 1-2: Agent L gathers a host candidate from its
      local IP\n   address, and from that it sends a STUN Binding request to the STUN\n
      \  server.  Since agent L is not behind a NAT, L's server-reflexive\n   candidate
      will be identical to the host candidate.\n   Message 3: Agent L sends its local
      candidate information to agent R,\n   using the signaling protocol associated
      with the ICE usage.\n   Messages 4-5: Agent R gathers a host candidate from
      its local IP\n   address, and from that it sends a STUN Binding request to the
      STUN\n   server.  Since agent R is not behind a NAT, R's server-reflexive\n
      \  candidate will be identical to the host candidate.\n   Message 6: Agent R
      sends its local candidate information to agent L,\n   using the signaling protocol
      associated with the ICE usage.\n   Since both agents are full ICE implementations,
      the initiating agent\n   (agent L) becomes the controlling agent.\n   Agents
      L and R both pair up the candidates.  Both agents initially\n   have one pair
      each.  At agent L, the pair (L1) has a local candidate\n   of $L_PUB_1 and a
      remote candidate of $R_PUB_1.  At agent R, the pair\n   (R1) has a local candidate
      of $R_PUB_1 and a remote candidate of\n   $L_PUB_1.  The pairs are shown below
      (the pair numbers are for\n   reference purpose only):\n                            Pairs\n
      \  ENTITY                   Local         Remote     Pair #     Valid\n   ------------------------------------------------------------------\n
      \  ICE Agent L:             L_PUB_1       R_PUB_1       L1\n   ICE Agent R:
      \            R_PUB_1       L_PUB_1       R1\n   Messages 7-8: Agent L initiates
      a connectivity check for pair L1.\n   The check succeeds, and the pair (L1)
      is added to the valid list of\n   agent L.  Agent L can now send and receive
      data on the pair (L1) if\n   it wishes.\n                            Pairs\n
      \  ENTITY                   Local         Remote     Pair #     Valid\n   ------------------------------------------------------------------\n
      \  ICE Agent L:             L_PUB_1       R_PUB_1       L1         X\n   ICE
      Agent R:             R_PUB_1       L_PUB_1       R1\n   Messages 9-10: When
      agent R receives the Binding request from agent L\n   (message 7), it will initiate
      a triggered connectivity check.  The\n   pair matches agent R's existing pair
      (R1).  The check succeeds, and\n   the pair (R1) is added to the valid list
      of agent R.  Agent R can now\n   send and receive data on the pair (R1) if it
      wishes.\n                            Pairs\n   ENTITY                   Local
      \        Remote     Pair #     Valid\n   ------------------------------------------------------------------\n
      \  ICE Agent L:             L_PUB_1       R_PUB_1       L1         X\n   ICE
      Agent R:             R_PUB_1       L_PUB_1       R1         X\n   Messages 11-12:
      At some point, the controlling agent (agent L)\n   decides to nominate a pair
      (L1) in the valid list.  It performs a\n   connectivity check on the pair (L1)
      and includes the USE-CANDIDATE\n   attribute in the Binding request.  As the
      check succeeds, agent L\n   sets the nominated flag value of the pair (L1) to
      'true', and agent R\n   sets the nominated flag value of the matching pair (R1)
      to 'true'.\n   As there are no more components associated with the stream, the\n
      \  nominated pairs become the selected pairs.  Consequently, processing\n   for
      this stream moves into the Completed state.  The ICE process also\n   moves
      into the Completed state.\n"
    title: 15.2.  Example with IPv6 Addresses
  title: 15.  Examples
- contents:
  - '16.  STUN Extensions

    '
  - contents:
    - "16.1.  Attributes\n   This specification defines four STUN attributes: PRIORITY,\n
      \  USE-CANDIDATE, ICE-CONTROLLED, and ICE-CONTROLLING.\n   The PRIORITY attribute
      indicates the priority that is to be\n   associated with a peer-reflexive candidate,
      if one will be discovered\n   by this check.  It is a 32-bit unsigned integer
      and has an attribute\n   value of 0x0024.\n   The USE-CANDIDATE attribute indicates
      that the candidate pair\n   resulting from this check will be used for transmission
      of data.  The\n   attribute has no content (the Length field of the attribute
      is zero);\n   it serves as a flag.  It has an attribute value of 0x0025.\n   The
      ICE-CONTROLLED attribute is present in a Binding request.  The\n   attribute
      indicates that the client believes it is currently in the\n   controlled role.
      \ The content of the attribute is a 64-bit unsigned\n   integer in network byte
      order, which contains a random number.  The\n   number is used for solving role
      conflicts, when it is referred to as\n   the \"tiebreaker value\".  An ICE agent
      MUST use the same number for\n   all Binding requests, for all streams, within
      an ICE session, unless\n   it has received a 487 response, in which case it
      MUST change the\n   number (Section 7.2.5.1).  The agent MAY change the number
      when an\n   ICE restart occurs.\n   The ICE-CONTROLLING attribute is present
      in a Binding request.  The\n   attribute indicates that the client believes
      it is currently in the\n   controlling role.  The content of the attribute is
      a 64-bit unsigned\n   integer in network byte order, which contains a random
      number.  As\n   for the ICE-CONTROLLED attribute, the number is used for solving
      role\n   conflicts.  An agent MUST use the same number for all Binding\n   requests,
      for all streams, within an ICE session, unless it has\n   received a 487 response,
      in which case it MUST change the number\n   (Section 7.2.5.1).  The agent MAY
      change the number when an ICE\n   restart occurs.\n"
    title: 16.1.  Attributes
  - contents:
    - "16.2.  New Error-Response Codes\n   This specification defines a single error-response
      code:\n   487 (Role Conflict):  The Binding request contained either the ICE-\n
      \     CONTROLLING or ICE-CONTROLLED attribute, indicating an ICE role\n      that
      conflicted with the server.  The remote server compared the\n      tiebreaker
      values of the client and the server and determined that\n      the client needs
      to switch roles.\n"
    title: 16.2.  New Error-Response Codes
  title: 16.  STUN Extensions
- contents:
  - "17.  Operational Considerations\n   This section discusses issues relevant to
    operators operating\n   networks where ICE will be used by endpoints.\n"
  - contents:
    - "17.1.  NAT and Firewall Types\n   ICE was designed to work with existing NAT
      and firewall equipment.\n   Consequently, it is not necessary to replace or
      reconfigure existing\n   firewall and NAT equipment in order to facilitate deployment
      of ICE.\n   Indeed, ICE was developed to be deployed in environments where the\n
      \  Voice over IP (VoIP) operator has no control over the IP network\n   infrastructure,
      including firewalls and NATs.\n   That said, ICE works best in environments
      where the NAT devices are\n   \"behave\" compliant, meeting the recommendations
      defined in [RFC4787]\n   and [RFC5382].  In networks with behave-compliant NAT,
      ICE will work\n   without the need for a TURN server, thus improving voice quality,\n
      \  decreasing call setup times, and reducing the bandwidth demands on\n   the
      network operator.\n"
    title: 17.1.  NAT and Firewall Types
  - contents:
    - "17.2.  Bandwidth Requirements\n   Deployment of ICE can have several interactions
      with available\n   network capacity that operators need to take into consideration.\n"
    - contents:
      - "17.2.1.  STUN and TURN Server-Capacity Planning\n   First and foremost, ICE
        makes use of TURN and STUN servers, which\n   would typically be located in
        data centers.  The STUN servers require\n   relatively little bandwidth.  For
        each component of each data stream,\n   there will be one or more STUN transactions
        from each client to the\n   STUN server.  In a basic voice-only IPv4 VoIP
        deployment, there will\n   be four transactions per call (one for RTP and
        one for RTCP, for both\n   the caller and callee).  Each transaction is a
        single request and a\n   single response, the former being 20 bytes long,
        and the latter, 28.\n   Consequently, if a system has N users, and each makes
        four calls in a\n   busy hour, this would require N*1.7bps.  For one million
        users, this\n   is 1.7 Mbps, a very small number (relatively speaking).\n
        \  TURN traffic is more substantial.  The TURN server will see traffic\n   volume
        equal to the STUN volume (indeed, if TURN servers are\n   deployed, there
        is no need for a separate STUN server), in addition\n   to the traffic for
        the actual data.  The amount of calls requiring\n   TURN for data relay is
        highly dependent on network topologies, and\n   can and will vary over time.
        \ In a network with 100% behave-compliant\n   NATs, it is exactly zero.\n
        \  The planning considerations above become more significant in\n   multimedia
        scenarios (e.g., audio and video conferences) and when the\n   numbers of
        participants in a session grow.\n"
      title: 17.2.1.  STUN and TURN Server-Capacity Planning
    - contents:
      - "17.2.2.  Gathering and Connectivity Checks\n   The process of gathering candidates
        and performing connectivity\n   checks can be bandwidth intensive.  ICE has
        been designed to pace\n   both of these processes.  The gathering and connectivity-check
        phases\n   are meant to generate traffic at roughly the same bandwidth as
        the\n   data traffic itself will consume once the ICE process concludes.\n
        \  This was done to ensure that if a network is designed to support\n   communication
        traffic of a certain type (voice, video, or just text),\n   it will have sufficient
        capacity to support the ICE checks for that\n   data.  Once ICE has concluded,
        the subsequent ICE keepalives will\n   later cause a marginal increase in
        the total bandwidth utilization;\n   however, this will typically be an extremely
        small increase.\n   Congestion due to the gathering and check phases has proven
        to be a\n   problem in deployments that did not utilize pacing.  Typically,\n
        \  access links became congested as the endpoints flooded the network\n   with
        checks as fast as they could send them.  Consequently, network\n   operators
        need to ensure that their ICE implementations support the\n   pacing feature.
        \ Though this pacing does increase call setup times,\n   it makes ICE network
        friendly and easier to deploy.\n"
      title: 17.2.2.  Gathering and Connectivity Checks
    - contents:
      - "17.2.3.  Keepalives\n   STUN keepalives (in the form of STUN Binding Indications)
        are sent in\n   the middle of a data session.  However, they are sent only
        in the\n   absence of actual data traffic.  In deployments with continuous
        media\n   and without utilizing Voice Activity Detection (VAD), or deployments\n
        \  where VAD is utilized together with short interval (max 1 second)\n   comfort
        noise, the keepalives are never used and there is no increase\n   in bandwidth
        usage.  When VAD is being used without comfort noise,\n   keepalives will
        be sent during silence periods.  This involves a\n   single packet every 15-20
        seconds, far less than the packet every\n   20-30 ms that is sent when there
        is voice.  Therefore, keepalives do\n   not have any real impact on capacity
        planning.\n"
      title: 17.2.3.  Keepalives
    title: 17.2.  Bandwidth Requirements
  - contents:
    - "17.3.  ICE and ICE-Lite\n   Deployments utilizing a mix of ICE and ICE-lite
      interoperate with\n   each other.  They have been explicitly designed to do
      so.\n   However, ICE-lite can only be deployed in limited use cases.  Those\n
      \  cases, and the caveats involved in doing so, are documented in\n   Appendix
      A.\n"
    title: 17.3.  ICE and ICE-Lite
  - contents:
    - "17.4.  Troubleshooting and Performance Management\n   ICE utilizes end-to-end
      connectivity checks and places much of the\n   processing in the endpoints.
      \ This introduces a challenge to the\n   network operator -- how can they troubleshoot
      ICE deployments?  How\n   can they know how ICE is performing?\n   ICE has built-in
      features to help deal with these problems.\n   Signaling servers, typically
      deployed in data centers of the network\n   operator, will see the contents
      of the candidate exchanges that\n   convey the ICE parameters.  These parameters
      include the type of each\n   candidate (host, server reflexive, or relayed),
      along with their\n   related addresses.  Once ICE processing has completed,
      an updated\n   candidate exchange takes place, signaling the selected address
      (and\n   its type).  This updated signaling is performed exactly for the\n   purposes
      of educating network equipment (such as a diagnostic tool\n   attached to a
      signaling) about the results of ICE processing.\n   As a consequence, through
      the logs generated by a signaling server, a\n   network operator can observe
      what types of candidates are being used\n   for each call and what addresses
      were selected by ICE.  This is the\n   primary information that helps evaluate
      how ICE is performing.\n"
    title: 17.4.  Troubleshooting and Performance Management
  - contents:
    - "17.5.  Endpoint Configuration\n   ICE relies on several pieces of data being
      configured into the\n   endpoints.  This configuration data includes timers,
      credentials for\n   TURN servers, and hostnames for STUN and TURN servers.  ICE
      itself\n   does not provide a mechanism for this configuration.  Instead, it
      is\n   assumed that this information is attached to whatever mechanism is\n
      \  used to configure all of the other parameters in the endpoint.  For\n   SIP
      phones, standard solutions such as the configuration framework\n   [RFC6080]
      have been defined.\n"
    title: 17.5.  Endpoint Configuration
  title: 17.  Operational Considerations
- contents:
  - "18.  IAB Considerations\n   The IAB has studied the problem of \"Unilateral Self-Address
    Fixing\"\n   (UNSAF), which is the general process by which an ICE agent attempts\n
    \  to determine its address in another realm on the other side of a NAT\n   through
    a collaborative protocol reflection mechanism [RFC3424].  ICE\n   is an example
    of a protocol that performs this type of function.\n   Interestingly, the process
    for ICE is not unilateral, but bilateral,\n   and the difference has a significant
    impact on the issues raised by\n   the IAB.  Indeed, ICE can be considered a Bilateral
    Self-Address\n   Fixing (B-SAF) protocol, rather than an UNSAF protocol.  Regardless,\n
    \  the IAB has mandated that any protocols developed for this purpose\n   document
    a specific set of considerations.  This section meets those\n   requirements.\n"
  - contents:
    - "18.1.  Problem Definition\n   From RFC 3424, any UNSAF proposal needs to provide:\n
      \     Precise definition of a specific, limited-scope problem that is to\n      be
      solved with the UNSAF proposal.  A short term fix should not be\n      generalized
      to solve other problems.  Such generalizations lead to\n      the the prolonged
      dependence on and usage of the supposed short\n      term fix -- meaning that
      it is no longer accurate to call it\n      \"short term\".\n   The specific
      problems being solved by ICE are:\n      Providing a means for two peers to
      determine the set of transport\n      addresses that can be used for communication.\n
      \     Providing a means for an agent to determine an address that is\n      reachable
      by another peer with which it wishes to communicate.\n"
    title: 18.1.  Problem Definition
  - contents:
    - "18.2.  Exit Strategy\n   From RFC 3424, any UNSAF proposal needs to provide:\n
      \     Description of an exit strategy/transition plan.  The better short\n      term
      fixes are the ones that will naturally see less and less use\n      as the appropriate
      technology is deployed.\n   ICE itself doesn't easily get phased out.  However,
      it is useful even\n   in a globally connected Internet, to serve as a means
      for detecting\n   whether a router failure has temporarily disrupted connectivity,
      for\n   example.  ICE also helps prevent certain security attacks that have\n
      \  nothing to do with NAT.  However, what ICE does is help phase out\n   other
      UNSAF mechanisms.  ICE effectively picks amongst those\n   mechanisms, prioritizing
      ones that are better and deprioritizing ones\n   that are worse.  As NATs begin
      to dissipate as IPv6 is introduced,\n   server-reflexive and relayed candidates
      (both forms of UNSAF\n   addresses) simply never get used, because higher-priority\n
      \  connectivity exists to the native host candidates.  Therefore, the\n   servers
      get used less and less and can eventually be removed when\n   their usage goes
      to zero.\n   Indeed, ICE can assist in the transition from IPv4 to IPv6.  It
      can\n   be used to determine whether to use IPv6 or IPv4 when two dual-stack\n
      \  hosts communicate with SIP (IPv6 gets used).  It can also allow a\n   network
      with both 6to4 and native v6 connectivity to determine which\n   address to
      use when communicating with a peer.\n"
    title: 18.2.  Exit Strategy
  - contents:
    - "18.3.  Brittleness Introduced by ICE\n   From RFC 3424, any UNSAF proposal
      needs to provide:\n      Discussion of specific issues that may render systems
      more\n      \"brittle\".  For example, approaches that involve using data at\n
      \     multiple network layers create more dependencies, increase\n      debugging
      challenges, and make it harder to transition.\n   ICE actually removes brittleness
      from existing UNSAF mechanisms.  In\n   particular, classic STUN (as described
      in RFC 3489 [RFC3489]) has\n   several points of brittleness.  One of them is
      the discovery process\n   that requires an ICE agent to try to classify the
      type of NAT it is\n   behind.  This process is error prone.  With ICE, that
      discovery\n   process is simply not used.  Rather than unilaterally assessing
      the\n   validity of the address, its validity is dynamically determined by\n
      \  measuring connectivity to a peer.  The process of determining\n   connectivity
      is very robust.\n   Another point of brittleness in classic STUN and any other
      unilateral\n   mechanism is its absolute reliance on an additional server.  ICE\n
      \  makes use of a server for allocating unilateral addresses, but it\n   allows
      agents to directly connect if possible.  Therefore, in some\n   cases, the failure
      of a STUN server would still allow for a call to\n   progress when ICE is used.\n
      \  Another point of brittleness in classic STUN is that it assumes the\n   STUN
      server is on the public Internet.  Interestingly, with ICE, that\n   is not
      necessary.  There can be a multitude of STUN servers in a\n   variety of address
      realms.  ICE will discover the one that has\n   provided a usable address.\n
      \  The most troubling point of brittleness in classic STUN is that it\n   doesn't
      work in all network topologies.  In cases where there is a\n   shared NAT between
      each agent and the STUN server, traditional STUN\n   may not work.  With ICE,
      that restriction is removed.\n   Classic STUN also introduces some security
      considerations.\n   Fortunately, those security considerations are also mitigated
      by ICE.\n   Consequently, ICE serves to repair the brittleness introduced in\n
      \  classic STUN, and it does not introduce any additional brittleness\n   into
      the system.\n   The penalty of these improvements is that ICE increases session\n
      \  establishment times.\n"
    title: 18.3.  Brittleness Introduced by ICE
  - contents:
    - "18.4.  Requirements for a Long-Term Solution\n   From RFC 3424, any UNSAF proposal
      needs to provide the following:\n      Identify requirements for longer term,
      sound technical solutions;\n      contribute to the process of finding the right
      longer term\n      solution.\n   Our conclusions from RFC 3489 remain unchanged.
      \ However, we feel ICE\n   actually helps because we believe it can be part
      of the long-term\n   solution.\n"
    title: 18.4.  Requirements for a Long-Term Solution
  - contents:
    - "18.5.  Issues with Existing NAPT Boxes\n   From RFC 3424, any UNSAF proposal
      needs to provide:\n      Discussion of the impact of the noted practical issues
      with\n      existing, deployed NA[P]Ts and experience reports.\n   A number
      of NAT boxes are now being deployed into the market that try\n   to provide
      \"generic\" ALG functionality.  These generic ALGs hunt for\n   IP addresses,
      in either text or binary form within a packet, and\n   rewrite them if they
      match a binding.  This interferes with classic\n   STUN.  However, the update
      to STUN [RFC5389] uses an encoding that\n   hides these binary addresses from
      generic ALGs.\n   Existing NAPT boxes have non-deterministic and typically short\n
      \  expiration times for UDP-based bindings.  This requires\n   implementations
      to send periodic keepalives to maintain those\n   bindings.  ICE uses a default
      of 15 s, which is a very conservative\n   estimate.  Eventually, over time,
      as NAT boxes become compliant to\n   behave [RFC4787], this minimum keepalive
      will become deterministic\n   and well known, and the ICE timers can be adjusted.
      \ Having a way to\n   discover and control the minimum keepalive interval would
      be far\n   better still.\n"
    title: 18.5.  Issues with Existing NAPT Boxes
  title: 18.  IAB Considerations
- contents:
  - '19.  Security Considerations

    '
  - contents:
    - "19.1.  IP Address Privacy\n   The process of probing for candidates reveals
      the source addresses of\n   the client and its peer to any on-network listening
      attacker, and the\n   process of exchanging candidates reveals the addresses
      to any\n   attacker that is able to see the negotiation.  Some addresses, such\n
      \  as the server-reflexive addresses gathered through the local\n   interface
      of VPN users, may be sensitive information.  If these\n   potential attacks
      cannot be mitigated, ICE usages can define\n   mechanisms for controlling which
      addresses are revealed to the\n   negotiation and/or probing process.  Individual
      implementations may\n   also have implementation-specific rules for controlling
      which\n   addresses are revealed.  For example, [WebRTC-IP-HANDLING] provides\n
      \  additional information about the privacy aspects of revealing IP\n   addresses
      via ICE for WebRTC applications.  ICE implementations where\n   such issues
      can arise are RECOMMENDED to provide a programmatic or\n   user interface that
      provides control over which network interfaces\n   are used to generate candidates.\n
      \  Based on the types of candidates provided by the peer, and the\n   results
      of the connectivity tests performed against those candidates,\n   the peer might
      be able to determine characteristics of the local\n   network, e.g., if different
      timings are apparent to the peer.  Within\n   the limit, the peer might be able
      to probe the local network.\n   There are several types of attacks possible
      in an ICE system.  The\n   subsections consider these attacks and their countermeasures.\n"
    title: 19.1.  IP Address Privacy
  - contents:
    - "19.2.  Attacks on Connectivity Checks\n   An attacker might attempt to disrupt
      the STUN connectivity checks.\n   Ultimately, all of these attacks fool an ICE
      agent into thinking\n   something incorrect about the results of the connectivity
      checks.\n   Depending on the type of attack, the attacker needs to have different\n
      \  capabilities.  In some cases, the attacker needs to be on the path of\n   the
      connectivity checks.  In other cases, the attacker does not need\n   to be on
      the path, as long as it is able to generate STUN\n   connectivity checks.  While
      attacks on connectivity checks are\n   typically performed by network entities,
      if an attacker is able to\n   control an endpoint, it might be able to trigger
      connectivity-check\n   attacks.  The possible false conclusions an attacker
      can try and\n   cause are:\n   False Invalid:  An attacker can fool a pair of
      agents into thinking a\n      candidate pair is invalid, when it isn't.  This
      can be used to\n      cause an agent to prefer a different candidate (such as
      one\n      injected by the attacker) or to disrupt a call by forcing all\n      candidates
      to fail.\n   False Valid:  An attacker can fool a pair of agents into thinking
      a\n      candidate pair is valid, when it isn't.  This can cause an agent\n
      \     to proceed with a session but then not be able to receive any\n      data.\n
      \  False Peer-Reflexive Candidate:  An attacker can cause an agent to\n      discover
      a new peer-reflexive candidate when it is not expected\n      to.  This can
      be used to redirect data streams to a DoS target or\n      to the attacker,
      for eavesdropping or other purposes.\n   False Valid on False Candidate:  An
      attacker has already convinced an\n      agent that there is a candidate with
      an address that does not\n      actually route to that agent (e.g., by injecting
      a false peer-\n      reflexive candidate or false server-reflexive candidate).
      \ The\n      attacker then launches an attack that forces the agents to believe\n
      \     that this candidate is valid.\n      If an attacker can cause a false
      peer-reflexive candidate or false\n      valid on a false candidate, it can
      launch any of the attacks\n      described in [RFC5389].\n   To force the false
      invalid result, the attacker has to wait for the\n   connectivity check from
      one of the agents to be sent.  When it is,\n   the attacker needs to inject
      a fake response with an unrecoverable\n   error response (such as a 400), or
      drop the response so that it never\n   reaches the agent.  However, since the
      candidate is, in fact, valid,\n   the original request may reach the peer agent
      and result in a success\n   response.  The attacker needs to force this packet
      or its response to\n   be dropped through a DoS attack, a Layer 2 network disruption,
      or\n   another technique.  If it doesn't do this, the success response will\n
      \  also reach the originator, alerting it to a possible attack.  The\n   ability
      for the attacker to generate a fake response is mitigated\n   through the STUN
      short-term credential mechanism.  In order for this\n   response to be processed,
      the attacker needs the password.  If the\n   candidate exchange signaling is
      secured, the attacker will not have\n   the password, and its response will
      be discarded.\n   Spoofed ICMP Hard Errors (Type 3, codes 2-4) can also be used
      to\n   create false invalid results.  If an ICE agent implements a response\n
      \  to these ICMP errors, the attacker is capable of generating an ICMP\n   message
      that is delivered to the agent sending the connectivity\n   check.  The validation
      of the ICMP error message by the agent is its\n   only defense.  For Type 3
      code=4, the outer IP header provides no\n   validation, unless the connectivity
      check was sent with DF=0.  For\n   codes 2 or 3, which are originated by the
      host, the address is\n   expected to be any of the remote agent's host, reflexive,
      or relay\n   candidate IP addresses.  The ICMP message includes the IP header
      and\n   UDP header of the message triggering the error.  These fields also\n
      \  need to be validated.  The IP destination and UDP destination port\n   need
      to match either the targeted candidate address and port or the\n   candidate's
      base address.  The source IP address and port can be any\n   candidate for the
      same base address of the agent sending the\n   connectivity check.  Thus, any
      attacker having access to the exchange\n   of the candidates will have the necessary
      information.  Hence, the\n   validation is a weak defense, and the sending of
      spoofed ICMP attacks\n   is also possible for off-path attackers from a node
      in a network\n   without source address validation.\n   Forcing the fake valid
      result works in a similar way.  The attacker\n   needs to wait for the Binding
      request from each agent and inject a\n   fake success response.  Again, due
      to the STUN short-term credential\n   mechanism, in order for the attacker to
      inject a valid success\n   response, the attacker needs the password.  Alternatively,
      the\n   attacker can route (e.g., using a tunneling mechanism) a valid\n   success
      response, which normally would be dropped or rejected by the\n   network, to
      the agent.\n   Forcing the false peer-reflexive candidate result can be done
      with\n   either fake requests or responses, or with replays.  We consider the\n
      \  fake requests and responses case first.  It requires the attacker to\n   send
      a Binding request to one agent with a source IP address and port\n   for the
      false candidate.  In addition, the attacker needs to wait for\n   a Binding
      request from the other agent and generate a fake response\n   with a XOR-MAPPED-ADDRESS
      attribute containing the false candidate.\n   Like the other attacks described
      here, this attack is mitigated by\n   the STUN message integrity mechanisms
      and secure candidate exchanges.\n   Forcing the false peer-reflexive candidate
      result with packet replays\n   is different.  The attacker waits until one of
      the agents sends a\n   check.  It intercepts this request and replays it towards
      the other\n   agent with a faked source IP address.  It also needs to prevent
      the\n   original request from reaching the remote agent, by either launching\n
      \  a DoS attack to cause the packet to be dropped or forcing it to be\n   dropped
      using Layer 2 mechanisms.  The replayed packet is received at\n   the other
      agent, and accepted, since the integrity check passes (the\n   integrity check
      cannot and does not cover the source IP address and\n   port).  It is then responded
      to.  This response will contain a XOR-\n   MAPPED-ADDRESS with the false candidate,
      and it will be sent to that\n   false candidate.  The attacker then needs to
      receive it and relay it\n   towards the originator.\n   The other agent will
      then initiate a connectivity check towards that\n   false candidate.  This validation
      needs to succeed.  This requires\n   the attacker to force a false valid on
      a false candidate.  The\n   injecting of fake requests or responses to achieve
      this goal is\n   prevented using the integrity mechanisms of STUN and the candidate\n
      \  exchange.  Thus, this attack can only be launched through replays.\n   To
      do that, the attacker needs to intercept the check towards this\n   false candidate
      and replay it towards the other agent.  Then, it\n   needs to intercept the
      response and replay that back as well.\n   This attack is very hard to launch
      unless the attacker is identified\n   by the fake candidate.  This is because
      it requires the attacker to\n   intercept and replay packets sent by two different
      hosts.  If both\n   agents are on different networks (e.g., across the public
      Internet),\n   this attack can be hard to coordinate, since it needs to occur\n
      \  against two different endpoints on different parts of the network at\n   the
      same time.\n   If the attacker itself is identified by the fake candidate, the\n
      \  attack is easier to coordinate.  However, if the data path is secured\n   (e.g.,
      using the Secure Real-time Transport Protocol (SRTP)\n   [RFC3711]), the attacker
      will not be able to process the data\n   packets, but will only be able to discard
      them, effectively disabling\n   the data stream.  However, this attack requires
      the agent to disrupt\n   packets in order to block the connectivity check from
      reaching the\n   target.  In that case, if the goal is to disrupt the data stream,\n
      \  it's much easier to just disrupt it with the same mechanism, rather\n   than
      attack ICE.\n"
    title: 19.2.  Attacks on Connectivity Checks
  - contents:
    - "19.3.  Attacks on Server-Reflexive Address Gathering\n   ICE endpoints make
      use of STUN Binding requests for gathering server-\n   reflexive candidates
      from a STUN server.  These requests are not\n   authenticated in any way.  As
      a consequence, there are numerous\n   techniques an attacker can employ to provide
      the client with a false\n   server-reflexive candidate:\n   o  An attacker can
      compromise the DNS, causing DNS queries to return\n      a rogue STUN server
      address.  That server can provide the client\n      with fake server-reflexive
      candidates.  This attack is mitigated\n      by DNS security, though DNSSEC
      is not required to address it.\n   o  An attacker that can observe STUN messages
      (such as an attacker on\n      a shared network segment, like Wi-Fi) can inject
      a fake response\n      that is valid and will be accepted by the client.\n   o
      \ An attacker can compromise a STUN server and cause it to send\n      responses
      with incorrect mapped addresses.\n   A false mapped address learned by these
      attacks will be used as a\n   server-reflexive candidate in the establishment
      of the ICE session.\n   For this candidate to actually be used for data, the
      attacker also\n   needs to attack the connectivity checks, and in particular,
      force a\n   false valid on a false candidate.  This attack is very hard to launch\n
      \  if the false address identifies a fourth party (neither the\n   initiator,
      responder, nor attacker), since it requires attacking the\n   checks generated
      by each ICE agent in the session and is prevented by\n   SRTP if it identifies
      the attacker itself.\n   If the attacker elects not to attack the connectivity
      checks, the\n   worst it can do is prevent the server-reflexive candidate from
      being\n   used.  However, if the peer agent has at least one candidate that
      is\n   reachable by the agent under attack, the STUN connectivity checks\n   themselves
      will provide a peer-reflexive candidate that can be used\n   for the exchange
      of data.  Peer-reflexive candidates are generally\n   preferred over server-reflexive
      candidates.  As such, an attack\n   solely on the STUN address gathering will
      normally have no impact on\n   a session at all.\n"
    title: 19.3.  Attacks on Server-Reflexive Address Gathering
  - contents:
    - "19.4.  Attacks on Relayed Candidate Gathering\n   An attacker might attempt
      to disrupt the gathering of relayed\n   candidates, forcing the client to believe
      it has a false relayed\n   candidate.  Exchanges with the TURN server are authenticated
      using a\n   long-term credential.  Consequently, injection of fake responses
      or\n   requests will not work.  In addition, unlike Binding requests,\n   Allocate
      requests are not susceptible to replay attacks with modified\n   source IP addresses
      and ports, since the source IP address and port\n   are not utilized to provide
      the client with its relayed candidate.\n   Even if an attacker has caused the
      client to believe in a false\n   relayed candidate, the connectivity checks
      cause such a candidate to\n   be used only if they succeed.  Thus, an attacker
      needs to launch a\n   false valid on a false candidate, per above, which is
      a very\n   difficult attack to coordinate.\n"
    title: 19.4.  Attacks on Relayed Candidate Gathering
  - contents:
    - "19.5.  Insider Attacks\n   In addition to attacks where the attacker is a third
      party trying to\n   insert fake candidate information or STUN messages, there
      are attacks\n   possible with ICE when the attacker is an authenticated and
      valid\n   participant in the ICE exchange.\n"
    - contents:
      - "19.5.1.  STUN Amplification Attack\n   The STUN amplification attack is similar
        to a \"voice hammer\" attack,\n   where the attacker causes other agents to
        direct voice packets to the\n   attack target.  However, instead of voice
        packets being directed to\n   the target, STUN connectivity checks are directed
        to the target.  The\n   attacker sends a large number of candidates, say,
        50.  The responding\n   agent receives the candidate information and starts
        its checks, which\n   are directed at the target, and consequently, never
        generate a\n   response.  In the case of WebRTC, the user might not even be
        aware\n   that this attack is ongoing, since it might be triggered in the\n
        \  background by malicious JavaScript code that the user has fetched.\n   The
        answerer will start a new connectivity check every Ta ms (say,\n   Ta=50ms).
        \ However, the retransmission timers are set to a large\n   number due to
        the large number of candidates.  As a consequence,\n   packets will be sent
        at an interval of one every Ta milliseconds and\n   then with increasing intervals
        after that.  Thus, STUN will not send\n   packets at a rate faster than data
        would be sent, and the STUN\n   packets persist only briefly, until ICE fails
        for the session.\n   Nonetheless, this is an amplification mechanism.\n   It
        is impossible to eliminate the amplification, but the volume can\n   be reduced
        through a variety of heuristics.  ICE agents SHOULD limit\n   the total number
        of connectivity checks they perform to 100.\n   Additionally, agents MAY limit
        the number of candidates they will\n   accept.\n   Frequently, protocols that
        wish to avoid these kinds of attacks force\n   the initiator to wait for a
        response prior to sending the next\n   message.  However, in the case of ICE,
        this is not possible.  It is\n   not possible to differentiate the following
        two cases:\n   o  There was no response because the initiator is being used
        to\n      launch a DoS attack against an unsuspecting target that will not\n
        \     respond.\n   o  There was no response because the IP address and port
        are not\n      reachable by the initiator.\n   In the second case, another
        check will be sent at the next\n   opportunity, while in the former case,
        no further checks will be\n   sent.\n"
      title: 19.5.1.  STUN Amplification Attack
    title: 19.5.  Insider Attacks
  title: 19.  Security Considerations
- contents:
  - "20.  IANA Considerations\n   The original ICE specification registered four STUN
    attributes and\n   one new STUN error response.  The STUN attributes and error
    response\n   are reproduced here.  In addition, this specification registers a
    new\n   ICE option.\n"
  - contents:
    - "20.1.  STUN Attributes\n   IANA has registered four STUN attributes:\n      0x0024
      PRIORITY\n      0x0025 USE-CANDIDATE\n      0x8029 ICE-CONTROLLED\n      0x802A
      ICE-CONTROLLING\n"
    title: 20.1.  STUN Attributes
  - contents:
    - "20.2.  STUN Error Responses\n   IANA has registered the following STUN error-response
      code:\n    487   Role Conflict: The client asserted an ICE role (controlling
      or\n          controlled) that is in conflict with the role of the server.\n"
    title: 20.2.  STUN Error Responses
  - contents:
    - "20.3.  ICE Options\n   IANA has registered the following ICE option in the
      \"ICE Options\"\n   subregistry of the \"Interactive Connectivity Establishment
      (ICE)\"\n   registry, following the procedures defined in [RFC6336].\n   ICE
      Option name:\n      ice2\n   Contact:\n      Name:    IESG\n      Email:   iesg@ietf.org\n
      \  Change Controller:\n      IESG\n   Description:\n      The ICE option indicates
      that the ICE agent using the ICE option\n      is implemented according to RFC
      8445.\n   Reference:\n      RFC 8445\n"
    title: 20.3.  ICE Options
  title: 20.  IANA Considerations
- contents:
  - "21.  Changes from RFC 5245\n   The purpose of this updated ICE specification
    is to:\n   o  Clarify procedures in RFC 5245.\n   o  Make technical changes, due
    to discovered flaws in RFC 5245 and\n      feedback from the community that has
    implemented and deployed ICE\n      applications based on RFC 5245.\n   o  Make
    the procedures independent of the signaling protocol, by\n      removing the SIP
    and SDP procedures.  Procedures specific to a\n      signaling protocol will be
    defined in separate usage documents.\n      [ICE-SIP-SDP] defines ICE usage with
    SIP and SDP.\n   The following technical changes have been done:\n   o  Aggressive
    nomination removed.\n   o  The procedures for calculating candidate pair states
    and\n      scheduling connectivity checks modified.\n   o  Procedures for calculation
    of Ta and RTO modified.\n   o  Active checklist and Frozen checklist definitions
    removed.\n   o  'ice2' ICE option added.\n   o  IPv6 considerations modified.\n
    \  o  Usage with no-op for keepalives, and keepalives with non-ICE\n      peers,
    removed.\n"
  title: 21.  Changes from RFC 5245
- contents:
  - '22.  References

    '
  - contents:
    - "22.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n
      \             DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n
      \  [RFC4941]  Narten, T., Draves, R., and S. Krishnan, \"Privacy\n              Extensions
      for Stateless Address Autoconfiguration in\n              IPv6\", RFC 4941,
      DOI 10.17487/RFC4941, September 2007,\n              <https://www.rfc-editor.org/info/rfc4941>.\n
      \  [RFC5389]  Rosenberg, J., Mahy, R., Matthews, P., and D. Wing,\n              \"Session
      Traversal Utilities for NAT (STUN)\", RFC 5389,\n              DOI 10.17487/RFC5389,
      October 2008,\n              <https://www.rfc-editor.org/info/rfc5389>.\n   [RFC5766]
      \ Mahy, R., Matthews, P., and J. Rosenberg, \"Traversal Using\n              Relays
      around NAT (TURN): Relay Extensions to Session\n              Traversal Utilities
      for NAT (STUN)\", RFC 5766,\n              DOI 10.17487/RFC5766, April 2010,\n
      \             <https://www.rfc-editor.org/info/rfc5766>.\n   [RFC6336]  Westerlund,
      M. and C. Perkins, \"IANA Registry for\n              Interactive Connectivity
      Establishment (ICE) Options\",\n              RFC 6336, DOI 10.17487/RFC6336,
      July 2011,\n              <https://www.rfc-editor.org/info/rfc6336>.\n   [RFC6724]
      \ Thaler, D., Ed., Draves, R., Matsumoto, A., and T. Chown,\n              \"Default
      Address Selection for Internet Protocol Version 6\n              (IPv6)\", RFC
      6724, DOI 10.17487/RFC6724, September 2012,\n              <https://www.rfc-editor.org/info/rfc6724>.\n
      \  [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119
      Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,
      <https://www.rfc-editor.org/info/rfc8174>.\n"
    title: 22.1.  Normative References
  - contents:
    - "22.2.  Informative References\n   [ICE-SIP-SDP]\n              Petit-Huguenin,
      M., Nandakumar, S., and A. Keranen,\n              \"Session Description Protocol
      (SDP) Offer/Answer\n              procedures for Interactive Connectivity Establishment\n
      \             (ICE)\", Work in Progress,\n              draft-ietf-mmusic-ice-sip-sdp-21,
      June 2018.\n   [RFC1918]  Rekhter, Y., Moskowitz, B., Karrenberg, D., de Groot,
      G.,\n              and E. Lear, \"Address Allocation for Private Internets\",\n
      \             BCP 5, RFC 1918, DOI 10.17487/RFC1918, February 1996,\n              <https://www.rfc-editor.org/info/rfc1918>.\n
      \  [RFC2475]  Blake, S., Black, D., Carlson, M., Davies, E., Wang, Z.,\n              and
      W. Weiss, \"An Architecture for Differentiated\n              Services\", RFC
      2475, DOI 10.17487/RFC2475, December 1998,\n              <https://www.rfc-editor.org/info/rfc2475>.\n
      \  [RFC3102]  Borella, M., Lo, J., Grabelsky, D., and G. Montenegro,\n              \"Realm
      Specific IP: Framework\", RFC 3102,\n              DOI 10.17487/RFC3102, October
      2001,\n              <https://www.rfc-editor.org/info/rfc3102>.\n   [RFC3103]
      \ Borella, M., Grabelsky, D., Lo, J., and K. Taniguchi,\n              \"Realm
      Specific IP: Protocol Specification\", RFC 3103,\n              DOI 10.17487/RFC3103,
      October 2001,\n              <https://www.rfc-editor.org/info/rfc3103>.\n   [RFC3235]
      \ Senie, D., \"Network Address Translator (NAT)-Friendly\n              Application
      Design Guidelines\", RFC 3235,\n              DOI 10.17487/RFC3235, January
      2002,\n              <https://www.rfc-editor.org/info/rfc3235>.\n   [RFC3261]
      \ Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,\n              A.,
      Peterson, J., Sparks, R., Handley, M., and E.\n              Schooler, \"SIP:
      Session Initiation Protocol\", RFC 3261,\n              DOI 10.17487/RFC3261,
      June 2002,\n              <https://www.rfc-editor.org/info/rfc3261>.\n   [RFC3264]
      \ Rosenberg, J. and H. Schulzrinne, \"An Offer/Answer Model\n              with
      Session Description Protocol (SDP)\", RFC 3264,\n              DOI 10.17487/RFC3264,
      June 2002,\n              <https://www.rfc-editor.org/info/rfc3264>.\n   [RFC3303]
      \ Srisuresh, P., Kuthan, J., Rosenberg, J., Molitor, A., and\n              A.
      Rayhan, \"Middlebox communication architecture and\n              framework\",
      RFC 3303, DOI 10.17487/RFC3303, August 2002,\n              <https://www.rfc-editor.org/info/rfc3303>.\n
      \  [RFC3424]  Daigle, L., Ed. and IAB, \"IAB Considerations for\n              UNilateral
      Self-Address Fixing (UNSAF) Across Network\n              Address Translation\",
      RFC 3424, DOI 10.17487/RFC3424,\n              November 2002, <https://www.rfc-editor.org/info/rfc3424>.\n
      \  [RFC3489]  Rosenberg, J., Weinberger, J., Huitema, C., and R. Mahy,\n              \"STUN
      - Simple Traversal of User Datagram Protocol (UDP)\n              Through Network
      Address Translators (NATs)\", RFC 3489,\n              DOI 10.17487/RFC3489,
      March 2003,\n              <https://www.rfc-editor.org/info/rfc3489>.\n   [RFC3550]
      \ Schulzrinne, H., Casner, S., Frederick, R., and V.\n              Jacobson,
      \"RTP: A Transport Protocol for Real-Time\n              Applications\", STD
      64, RFC 3550, DOI 10.17487/RFC3550,\n              July 2003, <https://www.rfc-editor.org/info/rfc3550>.\n
      \  [RFC3605]  Huitema, C., \"Real Time Control Protocol (RTCP) attribute\n              in
      Session Description Protocol (SDP)\", RFC 3605,\n              DOI 10.17487/RFC3605,
      October 2003,\n              <https://www.rfc-editor.org/info/rfc3605>.\n   [RFC3711]
      \ Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K.\n              Norrman,
      \"The Secure Real-time Transport Protocol (SRTP)\",\n              RFC 3711,
      DOI 10.17487/RFC3711, March 2004,\n              <https://www.rfc-editor.org/info/rfc3711>.\n
      \  [RFC3725]  Rosenberg, J., Peterson, J., Schulzrinne, H., and G.\n              Camarillo,
      \"Best Current Practices for Third Party Call\n              Control (3pcc)
      in the Session Initiation Protocol (SIP)\",\n              BCP 85, RFC 3725,
      DOI 10.17487/RFC3725, April 2004,\n              <https://www.rfc-editor.org/info/rfc3725>.\n
      \  [RFC3879]  Huitema, C. and B. Carpenter, \"Deprecating Site Local\n              Addresses\",
      RFC 3879, DOI 10.17487/RFC3879, September\n              2004, <https://www.rfc-editor.org/info/rfc3879>.\n
      \  [RFC4038]  Shin, M-K., Ed., Hong, Y-G., Hagino, J., Savola, P., and\n              E.
      Castro, \"Application Aspects of IPv6 Transition\",\n              RFC 4038,
      DOI 10.17487/RFC4038, March 2005,\n              <https://www.rfc-editor.org/info/rfc4038>.\n
      \  [RFC4091]  Camarillo, G. and J. Rosenberg, \"The Alternative Network\n              Address
      Types (ANAT) Semantics for the Session Description\n              Protocol (SDP)
      Grouping Framework\", RFC 4091,\n              DOI 10.17487/RFC4091, June 2005,\n
      \             <https://www.rfc-editor.org/info/rfc4091>.\n   [RFC4092]  Camarillo,
      G. and J. Rosenberg, \"Usage of the Session\n              Description Protocol
      (SDP) Alternative Network Address\n              Types (ANAT) Semantics in the
      Session Initiation Protocol\n              (SIP)\", RFC 4092, DOI 10.17487/RFC4092,
      June 2005,\n              <https://www.rfc-editor.org/info/rfc4092>.\n   [RFC4103]
      \ Hellstrom, G. and P. Jones, \"RTP Payload for Text\n              Conversation\",
      RFC 4103, DOI 10.17487/RFC4103, June 2005,\n              <https://www.rfc-editor.org/info/rfc4103>.\n
      \  [RFC4291]  Hinden, R. and S. Deering, \"IP Version 6 Addressing\n              Architecture\",
      RFC 4291, DOI 10.17487/RFC4291, February\n              2006, <https://www.rfc-editor.org/info/rfc4291>.\n
      \  [RFC4566]  Handley, M., Jacobson, V., and C. Perkins, \"SDP: Session\n              Description
      Protocol\", RFC 4566, DOI 10.17487/RFC4566,\n              July 2006, <https://www.rfc-editor.org/info/rfc4566>.\n
      \  [RFC4787]  Audet, F., Ed. and C. Jennings, \"Network Address\n              Translation
      (NAT) Behavioral Requirements for Unicast\n              UDP\", BCP 127, RFC
      4787, DOI 10.17487/RFC4787, January\n              2007, <https://www.rfc-editor.org/info/rfc4787>.\n
      \  [RFC5245]  Rosenberg, J., \"Interactive Connectivity Establishment\n              (ICE):
      A Protocol for Network Address Translator (NAT)\n              Traversal for
      Offer/Answer Protocols\", RFC 5245,\n              DOI 10.17487/RFC5245, April
      2010,\n              <https://www.rfc-editor.org/info/rfc5245>.\n   [RFC5382]
      \ Guha, S., Ed., Biswas, K., Ford, B., Sivakumar, S., and P.\n              Srisuresh,
      \"NAT Behavioral Requirements for TCP\", BCP 142,\n              RFC 5382, DOI
      10.17487/RFC5382, October 2008,\n              <https://www.rfc-editor.org/info/rfc5382>.\n
      \  [RFC5761]  Perkins, C. and M. Westerlund, \"Multiplexing RTP Data and\n              Control
      Packets on a Single Port\", RFC 5761,\n              DOI 10.17487/RFC5761, April
      2010,\n              <https://www.rfc-editor.org/info/rfc5761>.\n   [RFC6080]
      \ Petrie, D. and S. Channabasappa, Ed., \"A Framework for\n              Session
      Initiation Protocol User Agent Profile Delivery\",\n              RFC 6080,
      DOI 10.17487/RFC6080, March 2011,\n              <https://www.rfc-editor.org/info/rfc6080>.\n
      \  [RFC6146]  Bagnulo, M., Matthews, P., and I. van Beijnum, \"Stateful\n              NAT64:
      Network Address and Protocol Translation from IPv6\n              Clients to
      IPv4 Servers\", RFC 6146, DOI 10.17487/RFC6146,\n              April 2011, <https://www.rfc-editor.org/info/rfc6146>.\n
      \  [RFC6147]  Bagnulo, M., Sullivan, A., Matthews, P., and I. van\n              Beijnum,
      \"DNS64: DNS Extensions for Network Address\n              Translation from
      IPv6 Clients to IPv4 Servers\", RFC 6147,\n              DOI 10.17487/RFC6147,
      April 2011,\n              <https://www.rfc-editor.org/info/rfc6147>.\n   [RFC6298]
      \ Paxson, V., Allman, M., Chu, J., and M. Sargent,\n              \"Computing
      TCP's Retransmission Timer\", RFC 6298,\n              DOI 10.17487/RFC6298,
      June 2011,\n              <https://www.rfc-editor.org/info/rfc6298>.\n   [RFC6544]
      \ Rosenberg, J., Keranen, A., Lowekamp, B., and A. Roach,\n              \"TCP
      Candidates with Interactive Connectivity\n              Establishment (ICE)\",
      RFC 6544, DOI 10.17487/RFC6544,\n              March 2012, <https://www.rfc-editor.org/info/rfc6544>.\n
      \  [RFC6928]  Chu, J., Dukkipati, N., Cheng, Y., and M. Mathis,\n              \"Increasing
      TCP's Initial Window\", RFC 6928,\n              DOI 10.17487/RFC6928, April
      2013,\n              <https://www.rfc-editor.org/info/rfc6928>.\n   [RFC7050]
      \ Savolainen, T., Korhonen, J., and D. Wing, \"Discovery of\n              the
      IPv6 Prefix Used for IPv6 Address Synthesis\",\n              RFC 7050, DOI
      10.17487/RFC7050, November 2013,\n              <https://www.rfc-editor.org/info/rfc7050>.\n
      \  [RFC7721]  Cooper, A., Gont, F., and D. Thaler, \"Security and Privacy\n
      \             Considerations for IPv6 Address Generation Mechanisms\",\n              RFC
      7721, DOI 10.17487/RFC7721, March 2016,\n              <https://www.rfc-editor.org/info/rfc7721>.\n
      \  [RFC7825]  Goldberg, J., Westerlund, M., and T. Zeng, \"A Network\n              Address
      Translator (NAT) Traversal Mechanism for Media\n              Controlled by
      the Real-Time Streaming Protocol (RTSP)\",\n              RFC 7825, DOI 10.17487/RFC7825,
      December 2016,\n              <https://www.rfc-editor.org/info/rfc7825>.\n   [RFC8421]
      \ Martinsen, P., Reddy, T., and P. Patil, \"Interactive\n              Connectivity
      Establishment (ICE) Multihomed and IPv4/IPv6\n              Dual-Stack Guidelines\",
      RFC 8421, DOI 10.17487/RFC8421,\n              July 2018, <https://www.rfc-editor.org/info/rfc8421>.\n
      \  [WebRTC-IP-HANDLING]\n              Uberti, J. and G. Shieh, \"WebRTC IP
      Address Handling\n              Requirements\", Work in Progress, draft-ietf-rtcweb-ip-\n
      \             handling-09, June 2018.\n"
    title: 22.2.  Informative References
  title: 22.  References
- contents:
  - "Appendix A.  Lite and Full Implementations\n   ICE allows for two types of implementations.
    \ A full implementation\n   supports the controlling and controlled roles in a
    session and can\n   also perform address gathering.  In contrast, a lite implementation\n
    \  is a minimalist implementation that does little but respond to STUN\n   checks,
    and it only supports the controlled role in a session.\n   Because ICE requires
    both endpoints to support it in order to bring\n   benefits to either endpoint,
    incremental deployment of ICE in a\n   network is more complicated.  Many sessions
    involve an endpoint that\n   is, by itself, not behind a NAT and not one that
    would worry about\n   NAT traversal.  A very common case is to have one endpoint
    that\n   requires NAT traversal (such as a VoIP hard phone or soft phone) make\n
    \  a call to one of these devices.  Even if the phone supports a full\n   ICE
    implementation, ICE won't be used at all if the other device\n   doesn't support
    it.  The lite implementation allows for a low-cost\n   entry point for these devices.
    \ Once they support the lite\n   implementation, full implementations can connect
    to them and get the\n   full benefits of ICE.\n   Consequently, a lite implementation
    is only appropriate for devices\n   that will *always* be connected to the public
    Internet and have a\n   public IP address at which it can receive packets from
    any\n   correspondent.  ICE will not function when a lite implementation is\n
    \  placed behind a NAT.\n   ICE allows a lite implementation to have a single
    IPv4 host candidate\n   and several IPv6 addresses.  In that case, candidate pairs
    are\n   selected by the controlling agent using a static algorithm, such as\n
    \  the one in RFC 6724, which is recommended by this specification.\n   However,
    static mechanisms for address selection are always prone to\n   error, since they
    can never reflect the actual topology or provide\n   actual guarantees on connectivity.
    \ They are always heuristics.\n   Consequently, if an ICE agent is implementing
    ICE just to select\n   between its IPv4 and IPv6 addresses, and none of its IP
    addresses are\n   behind NAT, usage of full ICE is still RECOMMENDED in order
    to\n   provide the most robust form of address selection possible.\n   It is important
    to note that the lite implementation was added to\n   this specification to provide
    a stepping stone to full\n   implementation.  Even for devices that are always
    connected to the\n   public Internet with just a single IPv4 address, a full\n
    \  implementation is preferable if achievable.  Full implementations\n   also
    obtain the security benefits of ICE unrelated to NAT traversal.\n   Finally, it
    is often the case that a device that finds itself with a\n   public address today
    will be placed in a network tomorrow where it\n   will be behind a NAT.  It is
    difficult to definitively know, over the\n   lifetime of a device or product,
    if it will always be used on the\n   public Internet.  Full implementation provides
    assurance that\n   communications will always work.\n"
  title: Appendix A.  Lite and Full Implementations
- contents:
  - "Appendix B.  Design Motivations\n   ICE contains a number of normative behaviors
    that may themselves be\n   simple but derive from complicated or non-obvious thinking
    or use\n   cases that merit further discussion.  Since these design motivations\n
    \  are not necessary to understand for purposes of implementation, they\n   are
    discussed here.  This appendix is non-normative.\n"
  - contents:
    - "B.1.  Pacing of STUN Transactions\n   STUN transactions used to gather candidates
      and to verify\n   connectivity are paced out at an approximate rate of one new\n
      \  transaction every Ta milliseconds.  Each transaction, in turn, has a\n   retransmission
      timer RTO that is a function of Ta as well.  Why are\n   these transactions
      paced, and why are these formulas used?\n   Sending of these STUN requests will
      often have the effect of creating\n   bindings on NAT devices between the client
      and the STUN servers.\n   Experience has shown that many NAT devices have upper
      limits on the\n   rate at which they will create new bindings.  Discussions
      in the IETF\n   ICE WG during the work on this specification concluded that
      once\n   every 5 ms is well supported.  This is why Ta has a lower bound of\n
      \  5 ms.  Furthermore, transmission of these packets on the network\n   makes
      use of bandwidth and needs to be rate limited by the ICE agent.\n   Deployments
      based on earlier draft versions of [RFC5245] tended to\n   overload rate-constrained
      access links and perform poorly overall, in\n   addition to negatively impacting
      the network.  As a consequence, the\n   pacing ensures that the NAT device does
      not get overloaded and that\n   traffic is kept at a reasonable rate.\n   The
      definition of a \"reasonable\" rate is that STUN MUST NOT use more\n   bandwidth
      than the RTP itself will use, once data starts flowing.\n   The formula for
      Ta is designed so that, if a STUN packet were sent\n   every Ta seconds, it
      would consume the same amount of bandwidth as\n   RTP packets, summed across
      all data streams.  Of course, STUN has\n   retransmits, and the desire is to
      pace those as well.  For this\n   reason, RTO is set such that the first retransmit
      on the first\n   transaction happens just as the first STUN request on the last\n
      \  transaction occurs.  Pictorially:\n              First Packets              Retransmits\n
      \                   |                        |\n                    |                        |\n
      \            -------+------           -------+------\n            /               \\
      \       /               \\\n           /                 \\      /                 \\\n
      \          +--+    +--+    +--+    +--+    +--+    +--+\n           |A1|    |B1|
      \   |C1|    |A2|    |B2|    |C2|\n           +--+    +--+    +--+    +--+    +--+
      \   +--+\n        ---+-------+-------+-------+-------+-------+------------ Time\n
      \          0       Ta      2Ta     3Ta     4Ta     5Ta\n   In this picture,
      there are three transactions that will be sent (for\n   example, in the case
      of candidate gathering, there are three host\n   candidate/STUN server pairs).
      \ These are transactions A, B, and C.\n   The retransmit timer is set so that
      the first retransmission on the\n   first transaction (packet A2) is sent at
      time 3Ta.\n   Subsequent retransmits after the first will occur even less\n
      \  frequently than Ta milliseconds apart, since STUN uses an exponential\n   backoff
      on its retransmissions.\n   This mechanism of a global minimum pacing interval
      of 5 ms is not\n   generally applicable to transport protocols, but it is applicable
      to\n   ICE based on the following reasoning.\n   o  Start with the following
      rules that would be generally applicable\n      to transport protocols:\n      1.
      \ Let MaxBytes be the maximum number of bytes allowed to be\n          outstanding
      in the network at startup, which SHOULD be 14600,\n          as defined in Section
      2 of [RFC6928].\n      2.  Let HTO be the transaction timeout, which SHOULD
      be 2*RTT if\n          RTT is known or 500 ms otherwise.  This is based on the
      RTO\n          for STUN messages from [RFC5389] and the TCP initial RTO,\n          which
      is 1 sec in [RFC6298].\n      3.  Let MinPacing be the minimum pacing interval
      between\n          transactions, which is 5 ms (see above).\n   o  Observe that
      agents typically do not know the RTT for ICE\n      transactions (connectivity
      checks in particular), meaning that HTO\n      will almost always be 500 ms.\n
      \  o  Observe that a MinPacing of 5 ms and HTO of 500 ms gives at most\n      100
      packets/HTO, which for a typical ICE check of less than 120\n      bytes means
      a maximum of 12000 outstanding bytes in the network,\n      which is less than
      the maximum expressed by rule 1.\n   o  Thus, for ICE, the rule set reduces
      to just the MinPacing rule,\n      which is equivalent to having a global Ta
      value.\n"
    title: B.1.  Pacing of STUN Transactions
  - contents:
    - "B.2.  Candidates with Multiple Bases\n   Section 5.1.3 talks about eliminating
      candidates that have the same\n   transport address and base.  However, candidates
      with the same\n   transport addresses but different bases are not redundant.
      \ When can\n   an ICE agent have two candidates that have the same IP address
      and\n   port but different bases?  Consider the topology of Figure 11:\n          +----------+\n
      \         | STUN Srvr|\n          +----------+\n               |\n               |\n
      \            -----\n           //     \\\\\n          |         |\n         |
      \ B:net10  |\n          |         |\n           \\\\     //\n             -----\n
      \              |\n               |\n          +----------+\n          |   NAT
      \   |\n          +----------+\n               |\n               |\n             -----\n
      \          //     \\\\\n          |    A    |\n         |192.168/16 |\n          |
      \        |\n           \\\\     //\n             -----\n               |\n               |\n
      \              |192.168.1.100      -----\n          +----------+           //
      \    \\\\             +----------+\n          |          |          |         |
      \           |          |\n          | Initiator|---------|  C:net10  |-----------|
      Responder|\n          |          |10.0.1.100|         | 10.0.1.101 |          |\n
      \         +----------+           \\\\     //             +----------+\n                                   -----\n
      \          Figure 11: Identical Candidates with Different Bases\n   In this
      case, the initiating agent is multihomed.  It has one IP\n   address, 10.0.1.100,
      on network C, which is a net 10 private network.\n   The responding agent is
      on this same network.  The initiating agent\n   is also connected to network
      A, which is 192.168/16, and has an IP\n   address of 192.168.1.100.  There is
      a NAT on this network, natting\n   into network B, which is another net 10 private
      network, but it is\n   not connected to network C.  There is a STUN server on
      network B.\n   The initiating agent obtains a host candidate on its IP address
      on\n   network C (10.0.1.100:2498) and a host candidate on its IP address on\n
      \  network A (192.168.1.100:3344).  It performs a STUN query to its\n   configured
      STUN server from 192.168.1.100:3344.  This query passes\n   through the NAT,
      which happens to assign the binding 10.0.1.100:2498.\n   The STUN server reflects
      this in the STUN Binding response.  Now, the\n   initiating agent has obtained
      a server-reflexive candidate with a\n   transport address that is identical
      to a host candidate\n   (10.0.1.100:2498).  However, the server-reflexive candidate
      has a\n   base of 192.168.1.100:3344, and the host candidate has a base of\n
      \  10.0.1.100:2498.\n"
    title: B.2.  Candidates with Multiple Bases
  - contents:
    - "B.3.  Purpose of the Related-Address and Related-Port Attributes\n   The candidate
      attribute contains two values that are not used at all\n   by ICE itself --
      related address and related port.  Why are they\n   present?\n   There are two
      motivations for its inclusion.  The first is\n   diagnostic.  It is very useful
      to know the relationship between the\n   different types of candidates.  By
      including it, an ICE agent can\n   know which relayed candidate is associated
      with which reflexive\n   candidate, which in turn is associated with a specific
      host\n   candidate.  When checks for one candidate succeed but not for others,\n
      \  this provides useful diagnostics on what is going on in the network.\n   The
      second reason has to do with off-path Quality-of-Service (QoS)\n   mechanisms.
      \ When ICE is used in environments such as PacketCable\n   2.0, proxies will,
      in addition to performing normal SIP operations,\n   inspect the SDP in SIP
      messages and extract the IP address and port\n   for data traffic.  They can
      then interact, through policy servers,\n   with access routers in the network,
      to establish guaranteed QoS for\n   the data flows.  This QoS is provided by
      classifying the RTP traffic\n   based on 5-tuple and then providing it a guaranteed
      rate, or marking\n   its DSCP appropriately.  When a residential NAT is present,
      and a\n   relayed candidate gets selected for data, this relayed candidate will\n
      \  be a transport address on an actual TURN server.  That address says\n   nothing
      about the actual transport address in the access router that\n   would be used
      to classify packets for QoS treatment.  Rather, the\n   server-reflexive candidate
      towards the TURN server is needed.  By\n   carrying the translation in the SDP,
      the proxy can use that transport\n   address to request QoS from the access
      router.\n"
    title: B.3.  Purpose of the Related-Address and Related-Port Attributes
  - contents:
    - "B.4.  Importance of the STUN Username\n   ICE requires the usage of message
      integrity with STUN using its\n   short-term credential functionality.  The
      actual short-term\n   credential is formed by exchanging username fragments
      in the\n   candidate exchange.  The need for this mechanism goes beyond just\n
      \  security; it is actually required for correct operation of ICE in the\n   first
      place.\n   Consider ICE agents L, R, and Z.  L and R are within private\n   enterprise
      1, which is using 10.0.0.0/8.  Z is within private\n   enterprise 2, which is
      also using 10.0.0.0/8.  As it turns out, R and\n   Z both have IP address 10.0.1.1.
      \ L sends candidates to Z.  Z\n   responds to L with its host candidates.  In
      this case, those\n   candidates are 10.0.1.1:8866 and 10.0.1.1:8877.  As it
      turns out, R\n   is in a session at that same time and is also using 10.0.1.1:8866
      and\n   10.0.1.1:8877 as host candidates.  This means that R is prepared to\n
      \  accept STUN messages on those ports, just as Z is.  L will send a\n   STUN
      request to 10.0.1.1:8866 and another to 10.0.1.1:8877.  However,\n   these do
      not go to Z as expected.  Instead, they go to R!  If R just\n   replied to them,
      L would believe it has connectivity to Z, when in\n   fact it has connectivity
      to a completely different user, R.  To fix\n   this, STUN short-term credential
      mechanisms are used.  The username\n   fragments are sufficiently random; thus
      it is highly unlikely that R\n   would be using the same values as Z.  Consequently,
      R would reject\n   the STUN request since the credentials were invalid.  In
      essence, the\n   STUN username fragments provide a form of transient host identifiers,\n
      \  bound to a particular session established as part of the candidate\n   exchange.\n
      \  An unfortunate consequence of the non-uniqueness of IP addresses is\n   that,
      in the above example, R might not even be an ICE agent.  It\n   could be any
      host, and the port to which the STUN packet is directed\n   could be any ephemeral
      port on that host.  If there is an application\n   listening on this socket
      for packets, and it is not prepared to\n   handle malformed packets for whatever
      protocol is in use, the\n   operation of that application could be affected.
      \ Fortunately, since\n   the ports exchanged are ephemeral and usually drawn
      from the dynamic\n   or registered range, the odds are good that the port is
      not used to\n   run a server on host R, but rather is the agent side of some\n
      \  protocol.  This decreases the probability of hitting an allocated\n   port,
      due to the transient nature of port usage in this range.\n   However, the possibility
      of a problem does exist, and network\n   deployers need to be prepared for it.
      \ Note that this is not a\n   problem specific to ICE; stray packets can arrive
      at a port at any\n   time for any type of protocol, especially ones on the public\n
      \  Internet.  As such, this requirement is just restating a general\n   design
      guideline for Internet applications -- be prepared for unknown\n   packets on
      any port.\n"
    title: B.4.  Importance of the STUN Username
  - contents:
    - "B.5.  The Candidate Pair Priority Formula\n   The priority for a candidate
      pair has an odd form.  It is:\n      pair priority = 2^32*MIN(G,D) + 2*MAX(G,D)
      + (G>D?1:0)\n   Why is this?  When the candidate pairs are sorted based on this\n
      \  value, the resulting sorting has the MAX/MIN property.  This means\n   that
      the pairs are first sorted based on decreasing value of the\n   minimum of the
      two priorities.  For pairs that have the same value of\n   the minimum priority,
      the maximum priority is used to sort amongst\n   them.  If the max and the min
      priorities are the same, the\n   controlling agent's priority is used as the
      tiebreaker in the last\n   part of the expression.  The factor of 2*32 is used
      since the\n   priority of a single candidate is always less than 2*32, resulting
      in\n   the pair priority being a \"concatenation\" of the two component\n   priorities.
      \ This creates the MAX/MIN sorting.  MAX/MIN ensures that,\n   for a particular
      ICE agent, a lower-priority candidate is never used\n   until all higher-priority
      candidates have been tried.\n"
    title: B.5.  The Candidate Pair Priority Formula
  - contents:
    - "B.6.  Why Are Keepalives Needed?\n   Once data begins flowing on a candidate
      pair, it is still necessary\n   to keep the bindings alive at intermediate NATs
      for the duration of\n   the session.  Normally, the data stream packets themselves
      (e.g.,\n   RTP) meet this objective.  However, several cases merit further\n
      \  discussion.  Firstly, in some RTP usages, such as SIP, the data\n   streams
      can be \"put on hold\".  This is accomplished by using the SDP\n   \"sendonly\"
      or \"inactive\" attributes, as defined in RFC 3264\n   [RFC3264].  RFC 3264
      directs implementations to cease transmission of\n   data in these cases.  However,
      doing so may cause NAT bindings to\n   time out, and data won't be able to come
      off hold.\n   Secondly, some RTP payload formats, such as the payload format
      for\n   text conversation [RFC4103], may send packets so infrequently that\n
      \  the interval exceeds the NAT binding timeouts.\n   Thirdly, if silence suppression
      is in use, long periods of silence\n   may cause data transmission to cease
      sufficiently long for NAT\n   bindings to time out.\n   For these reasons, the
      data packets themselves cannot be relied upon.\n   ICE defines a simple periodic
      keepalive utilizing STUN Binding\n   Indications.  This makes its bandwidth
      requirements highly\n   predictable and thus amenable to QoS reservations.\n"
    title: B.6.  Why Are Keepalives Needed?
  - contents:
    - "B.7.  Why Prefer Peer-Reflexive Candidates?\n   Section 5.1.2 describes procedures
      for computing the priority of a\n   candidate based on its type and local preferences.
      \ That section\n   requires that the type preference for peer-reflexive candidates\n
      \  always be higher than server reflexive.  Why is that?  The reason has\n   to
      do with the security considerations in Section 19.  It is much\n   easier for
      an attacker to cause an ICE agent to use a false server-\n   reflexive candidate
      rather than a false peer-reflexive candidate.\n   Consequently, attacks against
      address gathering with Binding requests\n   are thwarted by ICE by preferring
      the peer-reflexive candidates.\n"
    title: B.7.  Why Prefer Peer-Reflexive Candidates?
  - contents:
    - "B.8.  Why Are Binding Indications Used for Keepalives?\n   Data keepalives
      are described in Section 11.  These keepalives make\n   use of STUN when both
      endpoints are ICE capable.  However, rather\n   than using a Binding request
      transaction (which generates a\n   response), the keepalives use an Indication.
      \ Why is that?\n   The primary reason has to do with network QoS mechanisms.
      \ Once data\n   begins flowing, network elements will assume that the data stream
      has\n   a fairly regular structure, making use of periodic packets at fixed\n
      \  intervals, with the possibility of jitter.  If an ICE agent is\n   sending
      data packets, and then receives a Binding request, it would\n   need to generate
      a response packet along with its data packets.  This\n   will increase the actual
      bandwidth requirements for the 5-tuple\n   carrying the data packets and introduce
      jitter in the delivery of\n   those packets.  Analysis has shown that this is
      a concern in certain\n   Layer 2 access networks that use fairly tight packet
      schedulers for\n   data.\n   Additionally, using a Binding Indication allows
      integrity to be\n   disabled, which may result in better performance.  This
      is useful for\n   large-scale endpoints, such as Public Switched Telephone Network\n
      \  (PSTN) gateways and Session Border Controllers (SBCs).\n"
    title: B.8.  Why Are Binding Indications Used for Keepalives?
  - contents:
    - "B.9.  Selecting Candidate Type Preference\n   One criterion for selecting type
      and local preference values is the\n   use of a data intermediary, such as a
      TURN server, a tunnel service\n   such as a VPN server, or NAT.  With a data
      intermediary, if data is\n   sent to that candidate, it will first transit the
      data intermediary\n   before being received.  One type of candidate that involves
      a data\n   intermediary is the relayed candidate.  Another type is the host\n
      \  candidate, which is obtained from a VPN interface.  When data is\n   transited
      through a data intermediary, it can have a positive or\n   negative effect on
      the latency between transmission and reception.\n   It may or may not increase
      the packet losses, because of the\n   additional router hops that may be taken.
      \ It may increase the cost\n   of providing service, since data will be routed
      in and right back out\n   of a data intermediary run by a provider.  If these
      concerns are\n   important, the type preference for relayed candidates needs
      to be\n   carefully chosen.\n   Another criterion for selecting preferences
      is the IP address family.\n   ICE works with both IPv4 and IPv6.  It provides
      a transition\n   mechanism that allows dual-stack hosts to prefer connectivity
      over\n   IPv6 but to fall back to IPv4 in case the v6 networks are\n   disconnected.
      \ Implementation SHOULD follow the guidelines from\n   [RFC8421] to avoid excessive
      delays in the connectivity-check phase\n   if broken paths exist.\n   Another
      criterion for selecting preferences is topological awareness.\n   This is beneficial
      for candidates that make use of intermediaries.\n   In those cases, if an ICE
      agent has preconfigured or dynamically\n   discovered knowledge of the topological
      proximity of the\n   intermediaries to itself, it can use that to assign higher
      local\n   preferences to candidates obtained from closer intermediaries.\n   Another
      criterion for selecting preferences might be security or\n   privacy.  If a
      user is a telecommuter, and therefore connected to a\n   corporate network and
      a local home network, the user may prefer their\n   voice traffic to be routed
      over the VPN or similar tunnel in order to\n   keep it on the corporate network
      when communicating within the\n   enterprise but may use the local network when
      communicating with\n   users outside of the enterprise.  In such a case, a VPN
      address would\n   have a higher local preference than any other address.\n"
    title: B.9.  Selecting Candidate Type Preference
  title: Appendix B.  Design Motivations
- contents:
  - "Appendix C.  Connectivity-Check Bandwidth\n   The tables below show, for IPv4
    and IPv6, the bandwidth required for\n   performing connectivity checks, using
    different Ta values (given in\n   ms) and different ufrag sizes (given in bytes).\n
    \  The results were provided by Jusin Uberti (Google) on 11 April 2016.\n                     IP
    version: IPv4\n                     Packet len (bytes): 108 + ufrag\n                          |\n
    \                      ms |     4     8    12    16\n                     -----|------------------------\n
    \                     500 | 1.86k 1.98k 2.11k 2.24k\n                      200
    | 4.64k 4.96k 5.28k  5.6k\n                      100 | 9.28k 9.92k 10.6k 11.2k\n
    \                      50 | 18.6k 19.8k 21.1k 22.4k\n                       20
    | 46.4k 49.6k 52.8k 56.0k\n                       10 | 92.8k 99.2k  105k  112k\n
    \                       5 |  185k  198k  211k  224k\n                        2
    |  464k  496k  528k  560k\n                        1 |  928k  992k 1.06M 1.12M\n
    \                    IP version: IPv6\n                     Packet len (bytes):
    128 + ufrag\n                          |\n                       ms |     4     8
    \   12    16\n                     -----|------------------------\n                      500
    | 2.18k  2.3k 2.43k 2.56k\n                      200 | 5.44k 5.76k 6.08k  6.4k\n
    \                     100 | 10.9k 11.5k 12.2k 12.8k\n                       50
    | 21.8k 23.0k 24.3k 25.6k\n                       20 | 54.4k 57.6k 60.8k 64.0k\n
    \                      10 |  108k  115k  121k  128k\n                        5
    |  217k  230k  243k  256k\n                        2 |  544k  576k  608k  640k\n
    \                       1 | 1.09M 1.15M 1.22M 1.28M\n                  Figure
    12: Connectivity-Check Bandwidth\n"
  title: Appendix C.  Connectivity-Check Bandwidth
- contents:
  - "Acknowledgements\n   Most of the text in this document comes from the original
    ICE\n   specification, RFC 5245.  The authors would like to thank everyone\n   who
    has contributed to that document.  For additional contributions\n   to this revision
    of the specification, we would like to thank Emil\n   Ivov, Paul Kyzivat, Pal-Erik
    Martinsen, Simon Perrault, Eric\n   Rescorla, Thomas Stach, Peter Thatcher, Martin
    Thomson, Justin\n   Uberti, Suhas Nandakumar, Taylor Brandstetter, Peter Saint-Andre,\n
    \  Harald Alvestrand, and Roman Shpount.  Ben Campbell did the AD\n   review.
    \ Stephen Farrell did the sec-dir review.  Stewart Bryant did\n   the gen-art
    review.  Qin We did the ops-dir review.  Magnus\n   Westerlund did the tsv-art
    review.\n"
  title: Acknowledgements
- contents:
  - "Authors' Addresses\n   Ari Keranen\n   Ericsson\n   Hirsalantie 11\n   02420
    Jorvas\n   Finland\n   Email: ari.keranen@ericsson.com\n   Christer Holmberg\n
    \  Ericsson\n   Hirsalantie 11\n   02420 Jorvas\n   Finland\n   Email: christer.holmberg@ericsson.com\n
    \  Jonathan Rosenberg\n   jdrosen.net\n   Monmouth, NJ\n   United States of America\n
    \  Email: jdrosen@jdrosen.net\n   URI:   http://www.jdrosen.net\n"
  title: Authors' Addresses
