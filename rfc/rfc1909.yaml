- title: __initial_text__
  contents:
  - '              An Administrative Infrastructure for SNMPv2

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  This memo does not specify an Internet standard of any\n   kind.\
    \  Discussion and suggestions for improvement are requested.\n   Distribution\
    \ of this memo is unlimited.\n"
- title: Table of Contents
  contents:
  - 'Table of Contents

    '
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   A management system contains:  several (potentially many)\
    \ nodes, each\n   with a processing entity, termed an agent, which has access\
    \ to\n   management instrumentation; at least one management station; and, a\n\
    \   management protocol, used to convey management information between\n   the\
    \ agents and management stations.  Operations of the protocol are\n   carried\
    \ out under an administrative framework which defines\n   authentication, authorization,\
    \ access control, and privacy policies.\n   Management stations execute management\
    \ applications which monitor and\n   control managed elements.  Managed elements\
    \ are devices such as\n   hosts, routers, terminal servers, etc., which are monitored\
    \ and\n   controlled via access to their management information.\n   It is the\
    \ purpose of this document, An Administrative Infrastructure\n   for SNMPv2, to\
    \ define an administrative framework which realizes\n   effective management in\
    \ a variety of configurations and environments.\n   The SNMPv2 framework is fully\
    \ described in [1-6].  This framework is\n   derived from the original Internet-standard\
    \ Network Management\n   Framework (SNMPv1), which consists of these three documents:\n\
    \      STD 16, RFC 1155 [7] which defines the Structure of Management\n      Information\
    \ (SMI), the mechanisms used for describing and naming\n      objects for the\
    \ purpose of management.\n      STD 16, RFC 1212 [8] which defines a more concise\
    \ description\n      mechanism, which is wholly consistent with the SMI.\n   \
    \   STD 15, RFC 1157 [9] which defines the Simple Network Management\n      Protocol\
    \ (SNMP), the protocol used for network access to managed\n      objects.\n  \
    \ For information on coexistence between SNMPv1 and SNMPv2, consult\n   [10].\n"
- title: 2.  Overview
  contents:
  - "2.  Overview\n   A management domain typically contains a large amount of management\n\
    \   information.  Each individual item of management information is an\n   instance\
    \ of a managed object type.  The definition of a related set\n   of managed object\
    \ types is contained in a Management Information Base\n   (MIB) module.  Many\
    \ such MIB modules are defined.  For each managed\n   object type it describes,\
    \ a MIB module defines not only the semantics\n   and syntax of that managed object\
    \ type, but also the method of\n   identifying an individual instance so that\
    \ multiple instances of the\n   same managed object type can be distinguished.\n"
- title: 2.1.  Contexts
  contents:
  - "2.1.  Contexts\n   Typically, there are many instances of each managed object\
    \ type\n   within a management domain.  For simplicity, the method for\n   identifying\
    \ instances specified by the MIB module does not allow each\n   instance to be\
    \ distinguished amongst the set of all instances within\n   the management domain;\
    \ rather, it allows each instance to be\n   identified only within some scope\
    \ or \"context\", where there are\n   multiple such contexts within the management\
    \ domain.  Often, a\n   context is a physical device, or perhaps, a logical device,\
    \ although\n   a context can also encompass multiple devices, or a subset of a\n\
    \   single device, or even a subset of multiple devices.  Thus, in order\n   to\
    \ identify an individual item of management information within the\n   management\
    \ domain, its context must be identified in addition to its\n   object type and\
    \ its instance.\n   For example, the managed object type, ifDescr [11], is defined\
    \ as the\n   description of a network interface.  To identify the description\
    \ of\n   device-X's first network interface, three pieces of information are\n\
    \   needed, e.g., device-X (the context), ifDescr (the managed object\n   type),\
    \ and \"1\" (the instance).\n   Note that each context has (at least) one globally-unique\n\
    \   identification within the management domain.  Note also that the same\n  \
    \ item of management information can exist in multiple contexts.  So,\n   an item\
    \ of management information can have multiple globally-unique\n   identifications,\
    \ either because it exists in multiple contexts,\n   and/or because each such\
    \ context has multiple globally-unique\n   identifications.\n"
- title: '2.2.  Authorization: Access Rights and MIB Views'
  contents:
  - "2.2.  Authorization: Access Rights and MIB Views\n   For security reasons, it\
    \ is often valuable to be able to restrict the\n   access rights of some management\
    \ applications to only a subset of the\n   management information in the management\
    \ domain.  To provide this\n   capability, access to a context is via a \"MIB\
    \ view\" which details a\n   specific set of managed object types (and optionally,\
    \ the specific\n   instances of object types) within that context.  For example,\
    \ for a\n   given context, there will typically always be one MIB view which\n\
    \   provides access to all management information in that context, and\n   often\
    \ there will be other MIB views each of which contains some\n   subset of the\
    \ information.  So, by providing access rights to a\n   management application\
    \ in terms of the particular (subset) MIB view\n   it can access for that context,\
    \ then the management application is\n   restricted in the desired manner.\n \
    \  Since managed object types (and their instances) are identified via\n   the\
    \ tree-like naming structure of ISO's OBJECT IDENTIFIERs [12, 1],\n   it is convenient\
    \ to define a MIB view as the combination of a set of\n   \"view subtrees\", where\
    \ each view subtree is a sub-tree within the\n   managed object naming tree. \
    \ Thus, a simple MIB view (e.g., all\n   managed objects within the Internet Network\
    \ Management Framework) can\n   be defined as a single view sub-tree, while more\
    \ complicated MIB\n   views (e.g., all information relevant to a particular network\n\
    \   interface) can be represented by the union of multiple view sub-\n   trees.\n\
    \   While any set of managed objects can be described by the union of\n   some\
    \ number of view subtrees, situations can arise that would require\n   a very\
    \ large number of view subtrees.  This could happen, for\n   example, when specifying\
    \ all columns in one conceptual row of a MIB\n   table because they would appear\
    \ in separate subtrees, one per column,\n   each with a very similar format. \
    \ Because the formats are similar,\n   the required set of subtrees can easily\
    \ be aggregated into one\n   structure.  This structure is named a family of view\
    \ subtrees after\n   the set of subtrees that it conceptually represents.  A family\
    \ of\n   view subtrees can either be included or excluded from a MIB view.\n \
    \  In addition to restricting access rights by identifying (sub-)sets of\n   management\
    \ information, it is also valuable to restrict the requests\n   allowed on the\
    \ management information within a particular context.\n   For example, one management\
    \ application might be prohibited from\n   write-access to a particular context,\
    \ while another might be allowed\n   to perform any type of operation.\n"
- title: 2.3.  Authentication and Privacy
  contents:
  - "2.3.  Authentication and Privacy\n   The enforcement of access rights requires\
    \ the means not only to\n   identify the entity on whose behalf a request is generated\
    \ but also\n   to authenticate such identification.  Another security capability\n\
    \   which is (optionally) provided is the ability to protect the data\n   within\
    \ an SNMPv2 operation from disclosure (i.e., to encrypt the\n   data).  This is\
    \ particularly useful when sensitive data (e.g.,\n   passwords, or security keys)\
    \ are accessed via SNMPv2 requests.\n   Recommendations for which algorithms are\
    \ best for authentication and\n   privacy are subject to change.  Such changes\
    \ may occur as and when\n   new research results on the vulnerability of various\
    \ algorithms are\n   published, and/or with the prevailing status of export control\
    \ and\n   patent issues.  Thus, it is valuable to allow these algorithms to be\n\
    \   specified as parameters, so that new algorithms can be accommodated\n   over\
    \ time.  In particular, one type of algorithm which may become\n   useful in the\
    \ future is the set of algorithms associated with\n   asymmetric (public key)\
    \ cryptography.\n   Note that not all accesses via SNMPv2 requests need to be\
    \ secure.\n   Indeed, there are purposes for which insecure access is required.\n\
    \   One example of this is the ability of a management application to\n   learn\
    \ about devices of which it has no previous knowledge.  Another\n   example is\
    \ to perform any synchronization which the security\n   algorithms need before\
    \ they can be used to communicate securely.\n   This need for insecure access\
    \ is accommodated by defining one of the\n   algorithms for authentication as\
    \ providing no authentication, and\n   similarly, one of the algorithms for privacy\
    \ as providing no\n   protection against disclosure.  (The combination of these\
    \ two\n   insecure algorithms is sometimes referred to as \"noAuth/noPriv\".)\n"
- title: 2.4.  Access Control
  contents:
  - "2.4.  Access Control\n   An access control policy specifies the types of SNMPv2\
    \ requests and\n   associated MIB views which are authorized for a particular\
    \ identity\n   (on whose behalf a request is generated) when using a particular\n\
    \   level of security to access a particular context.\n"
- title: 2.5.  Security Models
  contents:
  - "2.5.  Security Models\n   A security model defines the mechanisms used to achieve\
    \ an\n   administratively-defined level of security for protocol interactions:\n"
- title: (1)  by defining the security parameters associated with a
  contents:
  - "(1)  by defining the security parameters associated with a\n     communication,\
    \ including the authentication and privacy algorithms\n     and the security keys\
    \ (if any) used.\n"
- title: (2)  by defining how entities on whose behalf requests are generated are
  contents:
  - "(2)  by defining how entities on whose behalf requests are generated are\n  \
    \   identified.\n"
- title: (3)  by defining how contexts are identified.
  contents:
  - '(3)  by defining how contexts are identified.

    '
- title: (4)  by defining the mechanisms by which an access control policy is
  contents:
  - "(4)  by defining the mechanisms by which an access control policy is\n     derived\
    \ whenever management information is to be accessed.\n"
- title: 2.6.  Proxy
  contents:
  - "2.6.  Proxy\n   It is an SNMPv2 agent which responds to requests for access to\n\
    \   management information.  Each such request is contained within an\n   SNMPv2\
    \ message which provides the capability to perform a single\n   operation on a\
    \ list of items of management information.  Rather than\n   having to identify\
    \ the context as well as the managed object type and\n   instance for each item\
    \ of management information, each SNMPv2 message\n   is concerned with only a\
    \ single context.  Thus, an SNMPv2 agent must\n   be able to process requests\
    \ for all items of management information\n   within the one or more contexts\
    \ it supports.\n   In responding to a request, an SNMPv2 agent might be acting\
    \ as a\n   proxy for some other agent.  The term \"proxy\" has historically been\n\
    \   used very loosely, with multiple different meanings.  These different\n  \
    \ meanings include (among others):\n"
- title: (1)  the forwarding of SNMPv2 requests on to other SNMP agents without
  contents:
  - "(1)  the forwarding of SNMPv2 requests on to other SNMP agents without\n    \
    \ regard for what managed object types are being accessed; for\n     example,\
    \ in order to forward SNMPv2 request from one transport\n     domain to another,\
    \ or to translate SNMPv2 requests into SNMPv1\n     requests;\n"
- title: (2)  the translation of SNMPv2 requests into operations of some non-SNMP
  contents:
  - "(2)  the translation of SNMPv2 requests into operations of some non-SNMP\n  \
    \   management protocol;\n"
- title: (3)  support for aggregated managed objects where the value of one
  contents:
  - "(3)  support for aggregated managed objects where the value of one\n     managed\
    \ object instance depends upon the values of multiple other\n     (remote) items\
    \ of management information.\n   Each of these scenarios can be advantageous;\
    \ for example, support for\n   aggregation for management information can significantly\
    \ reduce the\n   bandwidth requirements of large-scale management activities.\n\
    \   However, using a single term to cover multiple different scenarios\n   causes\
    \ confusion.\n   To avoid such confusion, this SNMPv2 administrative framework\
    \ uses\n   the term \"proxy\" with a much more tightly defined meaning, which\n\
    \   covers only the first of those listed above.  Specifically, the\n   distinction\
    \ between a \"regular SNMPv2 agent\" and a \"proxy SNMPv2\n   agent\" is simple:\n\
    \  -  a proxy SNMPv2 agent is an SNMPv2 agent which forwards requests on\n   \
    \  to other agents according to the context, and irrespective of the\n     specific\
    \ managed object types being accessed;\n  -  in contrast, an SNMPv2 agent which\
    \ processes SNMPv2 requests\n     according to the (names of the) individual managed\
    \ object types and\n     instances being accessed, is NOT a proxy SNMPv2 agent\
    \ from the\n     perspective of this administrative model.\n   Thus, when an SNMPv2\
    \ agent acts as a proxy SNMPv2 agent for a\n   particular context, although information\
    \ on how to forward the\n   request is specifically associated with that context,\
    \ the proxy\n   SNMPv2 agent has no need of a detailed definition of the MIB view\n\
    \   (since the proxy SNMPv2 agent forwards the request irrespective of\n   the\
    \ managed object types).\n   In contrast, a SNMPv2 agent operating without proxy\
    \ must have the\n   detailed definition of the MIB view, and even if it needs\
    \ to issue\n   requests to other agents, that need is dependent on the individual\n\
    \   managed object instances being accessed (i.e., not only on the\n   context).\n"
- title: 3.  Elements of the Model
  contents:
  - "3.  Elements of the Model\n   This section provides a more formal description\
    \ of the model.\n"
- title: 3.1.  SNMPv2 Entity
  contents:
  - "3.1.  SNMPv2 Entity\n   An SNMPv2 entity is an actual process which performs\
    \ management\n   operations by generating and/or responding to SNMPv2 protocol\n\
    \   messages in the manner specified in [4].  An SNMPv2 entity assumes\n   the\
    \ identity of a particular administrative entity when processing an\n   SNMPv2\
    \ message.\n   An SNMPv2 entity is not required to process multiple protocol\n\
    \   messages concurrently, regardless of whether such messages require it\n  \
    \ to assume the identity of the same or different administrative\n   entity. \
    \ Thus, an implementation of an SNMPv2 entity which supports\n   more than one\
    \ administrative entity need not be multi-threaded.\n   However, there may be\
    \ situations where implementors may choose to use\n   multi-threading.\n   An\
    \ SNMPv2 entity listens for incoming, unsolicited SNMPv2 messages on\n   each\
    \ transport service address for which it is configured to do so.\n   It is a local\
    \ matter whether an SNMPv2 entity also listens for SNMPv2\n   messages on any\
    \ other transport service addresses.  In the absence of\n   any other information\
    \ on where to listen, an SNMPv2 entity must\n   listen on the transport service\
    \ addresses corresponding to the\n   standard transport-layer \"ports\" [5] on\
    \ its local network-layer\n   addresses.\n"
- title: 3.2.  SNMPv2 Agent
  contents:
  - "3.2.  SNMPv2 Agent\n   An SNMPv2 agent is the operational role assumed by an\
    \ SNMPv2 entity\n   when it acts in an agent role.  Specifically, an SNMPv2 agent\n\
    \   performs SNMPv2 management operations in response to received SNMPv2\n   protocol\
    \ messages (except for inform notifications).\n   In order to be manageable, all\
    \ network components need to be\n   instrumented.  SNMPv2 access to the instrumented\
    \ information is via\n   the managed objects supported by an SNMPv2 agent in one\
    \ or more\n   contexts.\n"
- title: 3.3.  SNMPv2 Manager
  contents:
  - "3.3.  SNMPv2 Manager\n   An SNMPv2 manager is the operational role assumed by\
    \ an SNMPv2 entity\n   when it acts in a manager role on behalf of management\
    \ applications.\n   Specifically, an SNMPv2 manager initiates SNMPv2 management\n\
    \   operations by the generation of appropriate SNMPv2 protocol messages,\n  \
    \ or when it receives and processes trap and inform notifications.\n   It is interesting\
    \ to consider the case of managing an SNMPv2 manager.\n   It is highly desirable\
    \ that an SNMPv2 manager, just like any other\n   networking application, be instrumented\
    \ for the purposes of being\n   managed.  Such instrumentation of an SNMPv2 manager\
    \ (just like for\n   any other networking application) is accessible via the managed\n\
    \   objects supported by an SNMPv2 agent.  As such, an SNMPv2 manager is\n   no\
    \ different from any other network application in that it has\n   instrumentation,\
    \ but does not itself have managed objects.\n   That is, an SNMPv2 manager does\
    \ not itself have managed objects.\n   Rather, it is an associated SNMPv2 agent\
    \ supporting managed objects\n   which provides access to the SNMPv2 manager's\
    \ instrumentation.\n"
- title: 3.4.  SNMPv2 Dual-Role Entity
  contents:
  - "3.4.  SNMPv2 Dual-Role Entity\n   An SNMPv2 entity which sometimes acts in an\
    \ agent role and sometimes\n   acts in a manager role, is termed an SNMPv2 dual-role\
    \ entity.  An\n   SNMPv2 dual-role entity initiates requests by acting in a manager\n\
    \   role, and processes requests regarding management information\n   accessible\
    \ to it (locally or via proxy) through acting in an agent\n   role.  In the case\
    \ of sending inform notifications, an SNMPv2 dual-\n   role entity acts in a manager\
    \ role in initiating an inform\n   notification containing management information\
    \ which is accessible to\n   it when acting in an agent role.\n   An SNMPv2 entity\
    \ which can act only in an SNMPv2 manager role is not\n   SNMP-manageable, since\
    \ there is no way to access its management\n   instrumentation.  In order to be\
    \ SNMP-manageable, an SNMPv2 entity\n   must be able to act in an SNMPv2 agent\
    \ role in order to allow its\n   instrumentation to be accessed.  Thus, it is\
    \ highly desirable that\n   all SNMPv2 entities be either SNMPv2 agents or SNMPv2\
    \ dual-role\n   entities.\n   There are two categories of SNMPv2 dual-role entities:\
    \  proxy SNMPv2\n   agents and (so-called) mid-level managers.  Proxy SNMPv2 agents\
    \ only\n   forward requests/responses; they do not originate requests.  In\n \
    \  contrast, mid-level managers often originate requests.  (Note that\n   the\
    \ term proxy SNMPv2 agent does not include an SNMPv2 agent which\n   translates\
    \ SNMPv2 requests into the requests of some other management\n   protocol; see\
    \ section 2.6.)\n"
- title: 3.5.  View Subtree and Families
  contents:
  - "3.5.  View Subtree and Families\n   A view subtree is the set of all MIB object\
    \ instances which have a\n   common ASN.1 OBJECT IDENTIFIER prefix to their names.\
    \  A view subtree\n   is identified by the OBJECT IDENTIFIER value which is the\
    \ longest\n   OBJECT IDENTIFIER prefix common to all (potential) MIB object\n\
    \   instances in that subtree.\n   A family of view subtrees is a pairing of an\
    \ OBJECT IDENTIFIER value\n   (called the family name) together with a bitstring\
    \ value (called the\n   family mask).  The family mask indicates which sub-identifiers\
    \ of the\n   associated family name are significant to the family's definition.\n\
    \   For each possible managed object instance, that instance belongs to a\n  \
    \ particular view subtree family if both of the following conditions\n   are true:\n"
- title: o    the OBJECT IDENTIFIER name of the managed object instance contains
  contents:
  - "o    the OBJECT IDENTIFIER name of the managed object instance contains\n   \
    \  at least as many sub-identifiers as does the family name, and\n"
- title: o    each sub-identifier in the OBJECT IDENTIFIER name of the managed
  contents:
  - "o    each sub-identifier in the OBJECT IDENTIFIER name of the managed\n     object\
    \ instance matches the corresponding sub-identifier of the\n     family name whenever\
    \ the corresponding bit of the associated family\n     mask is non-zero.\n   When\
    \ the configured value of the family mask is all ones, the view\n   subtree family\
    \ is identical to the single view subtree identified by\n   the family name.\n\
    \   When the configured value of the family mask is shorter than required\n  \
    \ to perform the above test, its value is implicitly extended with\n   ones. \
    \ Consequently, a view subtree family having a family mask of\n   zero length\
    \ always corresponds to a single view subtree.\n"
- title: 3.6.  MIB View
  contents:
  - "3.6.  MIB View\n   A MIB view is a subset of the set of all instances of all\
    \ object\n   types defined according to the SMI [1] within an SNMPv2 context,\n\
    \   subject to the following constraints:\n"
- title: o    It is possible to specify a MIB view which contains the full set of
  contents:
  - "o    It is possible to specify a MIB view which contains the full set of\n  \
    \   all object instances within an SNMPv2 context.\n"
- title: o    Each object instance within a MIB view is uniquely named by an
  contents:
  - "o    Each object instance within a MIB view is uniquely named by an\n     ASN.1\
    \ OBJECT IDENTIFIER value.\n   As such, identically named instances of a particular\
    \ object type must\n   be contained within different SNMPv2 contexts.  That is,\
    \ a particular\n   object instance name resolves within a particular SNMPv2 context\
    \ to\n   at most one object instance.\n   A MIB view is defined as a collection\
    \ of view subtree families, where\n   each view subtree family has a type.  The\
    \ type determines whether the\n   view subtree family is included in, or excluded\
    \ from, the MIB view.\n   A managed object instance is contained/not contained\
    \ within the MIB\n   view according to the view subtree families to which the\
    \ instance\n   belongs:\n"
- title: o    If a managed object instance belongs to none of the relevant
  contents:
  - "o    If a managed object instance belongs to none of the relevant\n     subtree\
    \ families, then that instance is not in the MIB view.\n"
- title: o    If a managed object instance belongs to exactly one of the relevant
  contents:
  - "o    If a managed object instance belongs to exactly one of the relevant\n  \
    \   subtree families, then that instance is included in, or excluded\n     from,\
    \ the relevant MIB view according to the type of that subtree\n     family.\n"
- title: o    If a managed object instance belongs to more than one of the
  contents:
  - "o    If a managed object instance belongs to more than one of the\n     relevant\
    \ subtree families, then that instance is included in, or\n     excluded from,\
    \ the relevant MIB view according to the type of a\n     particular one of the\
    \ subtree families to which it belongs.  The\n     particular subtree family is\
    \ the one for which, first, the\n     associated family name comprises the greatest\
    \ number of sub-\n     identifiers, and, second, the associated family name is\n\
    \     lexicographically greatest.\n"
- title: 3.7.  SNMPv2 Context
  contents:
  - "3.7.  SNMPv2 Context\n   An SNMPv2 context is a collection of management information\n\
    \   accessible by an SNMPv2 entity.  The collection of management\n   information\
    \ identified by a context is either local or proxy.\n   For a local SNMPv2 context\
    \ which is realized by an SNMPv2 entity,\n   that SNMPv2 entity uses locally-defined\
    \ mechanisms to access the\n   management information identified by the SNMPv2\
    \ context.\n   For a proxy SNMPv2 context, the SNMPv2 entity acts as a proxy SNMPv2\n\
    \   agent to access the management information identified by the SNMPv2\n   context.\n\
    \   The term remote SNMPv2 context is used at an SNMPv2 manager to\n   indicate\
    \ a SNMPv2 context (either local or proxy) which is not\n   realized by the local\
    \ SNMPv2 entity (i.e.,  the local SNMPv2 entity\n   uses neither locally-defined\
    \ mechanisms, nor acts as a proxy SNMPv2\n   agent, to access the management information\
    \ identified by the SNMPv2\n   context).\n"
- title: 3.7.1.  Local SNMPv2 Context
  contents:
  - "3.7.1.  Local SNMPv2 Context\n   A local context refers to a collection of MIB\
    \ objects which\n   (logically) belong to a single entity within a managed device.\
    \  When\n   an SNMPv2 entity accesses that management information, it does so\n\
    \   using locally-defined mechanisms.\n   Because a device may contain several\
    \ such local entities, each local\n   context has associated with it a \"local\
    \ entity\" name.  Further,\n   because management information changes over time,\
    \ each local context\n   also has associated with it an associated temporal domain,\
    \ termed its\n   \"local time\".  This allows, for example, one context to refer\
    \ to the\n   current values of a device's parameters, and a different context\
    \ to\n   refer to the values that the same parameters for the same device will\n\
    \   have after the device's next restart.\n"
- title: 3.7.2.  Proxy SNMPv2 Context
  contents:
  - "3.7.2.  Proxy SNMPv2 Context\n   A proxy relationship exists when a proxy SNMPv2\
    \ agent processes a\n   received SNMPv2 message (a request or a response) by forwarding\
    \ it to\n   another entity, solely according to the SNMPv2 context of the\n  \
    \ received message.  Such a context is called a proxy SNMPv2 context.\n   When\
    \ an SNMPv2 entity processes management requests/responses for a\n   proxy context,\
    \ it is operating as a proxy SNMPv2 agent.\n   The transparency principle that\
    \ defines the behavior of an SNMPv2\n   entity in general, applies in particular\
    \ to a proxy SNMPv2 context:\n     The manner in which a receiving SNMPv2 entity\
    \ processes SNMPv2\n     protocol messages sent by another SNMPv2 entity is entirely\n\
    \     transparent to the sending SNMPv2 entity.\n   Implicit in the transparency\
    \ principle is the requirement that the\n   semantics of SNMPv2 management operations\
    \ are preserved between any\n   two SNMPv2 peers.  In particular, the \"as if\
    \ simultaneous\" semantics\n   of a\n   Set operation are extremely difficult\
    \ to guarantee if its scope\n   extends to management information resident at\
    \ multiple network\n   locations.  Note however, that agents which support the\
    \ forwarding of\n   Set operations concerning information at multiple locations\
    \ are not\n   considered to be proxy SNMPv2 agents (see section 2.6 above).\n\
    \   Also implicit in the transparency principle is the requirement that,\n   throughout\
    \ its interaction with a proxy SNMPv2 agent, an SNMPv2\n   manager is supplied\
    \ with no information about the nature or progress\n   of the proxy mechanisms\
    \ used to perform its requests.  That is, it\n   should seem to the SNMPv2 manager\
    \ (except for any distinction in an\n   underlying transport address) as if it\
    \ were interacting via SNMPv2\n   directly with the proxied device.  Thus, a timeout\
    \ in the\n   communication between a proxy SNMPv2 agent and its proxied device\n\
    \   should be represented as a timeout in the communication between the\n   SNMPv2\
    \ manager and the proxy SNMPv2 agent.  Similarly, an error\n   response from a\
    \ proxied device should - as much as possible - be\n   represented by the corresponding\
    \ error response in the interaction\n   between the proxy SNMPv2 agent and SNMPv2\
    \ manager.\n"
- title: 3.8.  SNMPv2 PDUs and Operations
  contents:
  - "3.8.  SNMPv2 PDUs and Operations\n   An SNMPv2 PDU is defined in [4].  Each SNMPv2\
    \ PDU specifies a\n   particular operation, one of:\n               GetBulkRequest\n\
    \               GetNextRequest\n               GetRequest\n               Inform\n\
    \               Report\n               Response\n               SNMPv2-Trap\n\
    \               SetRequest\n"
- title: 3.8.1.  The Report-PDU
  contents:
  - "3.8.1.  The Report-PDU\n   [4] requires that an administrative framework which\
    \ makes use of the\n   Report-PDU must define its usage and semantics.  With this\n\
    \   administrative framework, the Report-PDU differs from the other PDU\n   types\
    \ described in [4] in that it is not a protocol operation between\n   SNMPv2 managers\
    \ and agents, but rather is an aspect of error-\n   reporting between SNMPv2 entities.\
    \ Specifically, it is an interaction\n   between two protocol engines.\n   A communication\
    \ between SNMPv2 entities is in the form of an SNMPv2\n   message.  Such a message\
    \ is formatted as a \"wrapper\" encapsulating a\n   PDU according to the \"Elements\
    \ of Procedure\" for the security model\n   used for transmission of the message.\n\
    \   While processing a received communication, an SNMPv2 entity may\n   determine\
    \ that the received message is unacceptable due to a problem\n   associated with\
    \ the contents of the message \"wrapper\".  In this case,\n   an appropriate counter\
    \ is incremented and the received message is\n   discarded without further processing\
    \ (and without transmission of a\n   Response-PDU).\n   However, if an SNMPv2\
    \ entity acting in the agent role makes such a\n   determination, then after incrementing\
    \ the appropriate counter, it\n   may be required to generate a Report-PDU and\
    \ to send it to the\n   transport address which originated the received message.\n\
    \   If the agent is able to determine the value of the request-id field\n   of\
    \ the received PDU [4], then it must use that value for the\n   request-id field\
    \ of the Report-PDU.  Otherwise, the value 2147483647\n   is used.\n   The error-status\
    \ and error-index fields of the Report-PDU are always\n   set to zero.  The variable-bindings\
    \ field contains a single variable:\n   the identity of the counter which was\
    \ incremented and its new value.\n   There is at least one case in which a Report-PDU\
    \ must not be sent by\n   an SNMPv2 entity acting in the agent role: if the received\
    \ message\n   was tagged as a Report-PDU.  Particular security models may identify\n\
    \   other such cases.\n"
- title: 3.9.  SNMPv2 Access Control Policy
  contents:
  - "3.9.  SNMPv2 Access Control Policy\n   An SNMPv2 access policy specifies the\
    \ types of SNMPv2 operations\n   authorized for a particular identity using a\
    \ particular level of\n   security, and if the operation is to be performed on\
    \ a local SNMPv2\n   context, two accessible MIB views.  The two MIB views are\
    \ a read-view\n   and a write-view.  A read-view is a set of object instances\n\
    \   authorized for the identity when reading objects.  Reading objects\n   occurs\
    \ when processing a retrieval (get, get-next, get-bulk)\n   operation and when\
    \ sending a notification.  A write-view is the set\n   of object instances authorized\
    \ for the identity when writing objects.\n   Writing objects occurs when processing\
    \ a set operation.  An\n   identity's access rights may be different at different\
    \ agents.\n   A security model defines how an SNMPv2 access policy is derived;\n\
    \   however, the application of an SNMPv2 access control policy is\n   performed\
    \ only:\n"
- title: o    on receipt of GetRequest, GetNextRequest, GetBulkRequest, and
  contents:
  - "o    on receipt of GetRequest, GetNextRequest, GetBulkRequest, and\n     SetRequest\
    \ operations; and\n"
- title: o    prior to transmission of SNMPv2-Trap and Inform operations.
  contents:
  - "o    prior to transmission of SNMPv2-Trap and Inform operations.\n   Note that\
    \ application of an SNMPv2 access control policy is never\n   performed for Response\
    \ or Report operations.\n"
- title: 4.  Security Considerations
  contents:
  - "4.  Security Considerations\n   Security issues are not directly discussed in\
    \ this memo.\n"
- title: 5.  Editor's Address
  contents:
  - "5.  Editor's Address\n   Keith McCloghrie\n   Cisco Systems, Inc.\n   170 West\
    \ Tasman Drive\n   San Jose, CA  95134-1706\n   US\n   Phone: +1 408 526 5260\n\
    \   EMail: kzm@cisco.com\n"
- title: 6.  Acknowledgements
  contents:
  - "6.  Acknowledgements\n   This document is the result of significant work by three\
    \ major\n   contributors:\n     Keith McCloghrie (Cisco Systems, kzm@cisco.com)\n\
    \     Marshall T. Rose (Dover Beach Consulting, mrose@dbc.mtview.ca.us)\n    \
    \ Glenn W. Waters (Bell-Northern Research Ltd., gwaters@bnr.ca)\n   The authors\
    \ wish to acknowledge James M. Galvin of Trusted\n   Information Systems who contributed\
    \ significantly to earlier work on\n   which this memo is based, and the general\
    \ contributions of members of\n   the SNMPv2 Working Group, and, in particular,\
    \ Aleksey Y. Romanov and\n   Steven L. Waldbusser.\n   A special thanks is extended\
    \ for the contributions of:\n     Uri Blumenthal (IBM)\n     Shawn Routhier (Epilogue)\n\
    \     Barry Sheehan (IBM)\n     Bert Wijnen (IBM)\n"
- title: 7.  References
  contents:
  - '7.  References

    '
- title: '[1]  The SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and'
  contents:
  - "[1]  The SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and\n    \
    \ S. Waldbusser, \"Structure of Management Information for Version 2\n     of\
    \ the Simple Network Management Protocol (SNMPv2)\", RFC 1902,\n     January 1996.\n"
- title: '[2]  The SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and'
  contents:
  - "[2]  The SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and\n    \
    \ S. Waldbusser, \"Textual Conventions for Version 2 of the Simple\n     Network\
    \ Management Protocol (SNMPv2)\", RFC 1903, January 1996.\n"
- title: '[3]  The SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and'
  contents:
  - "[3]  The SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and\n    \
    \ S., Waldbusser, \"Conformance Statements for Version 2 of the Simple\n     Network\
    \ Management Protocol (SNMPv2)\", RFC 1904, January 1996.\n"
- title: '[4]  The SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and'
  contents:
  - "[4]  The SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and\n    \
    \ S. Waldbusser, \"Protocol Operations for Version 2 of the Simple\n     Network\
    \ Management Protocol (SNMPv2)\", RFC 1905, January 1996.\n"
- title: '[5]  The SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and'
  contents:
  - "[5]  The SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and\n    \
    \ Waldbusser, S., \"Transport Mappings for Version 2 of the Simple\n     Network\
    \ Management Protocol (SNMPv2)\", RFC 1906, January 1996.\n"
- title: '[6]  The SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and'
  contents:
  - "[6]  The SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and\n    \
    \ Waldbusser, S., \"Management Information Base for Version 2 of the\n     Simple\
    \ Network Management Protocol (SNMPv2)\", RFC 1907,\n     January 1996.\n"
- title: '[7]  Rose, M., and K. McCloghrie, "Structure and Identification of'
  contents:
  - "[7]  Rose, M., and K. McCloghrie, \"Structure and Identification of\n     Management\
    \ Information for TCP/IP-based internets\", STD 16, RFC\n     1155, May 1990.\n"
- title: '[8]  Rose, M., and K. McCloghrie, "Concise MIB Definitions", STD 16,'
  contents:
  - "[8]  Rose, M., and K. McCloghrie, \"Concise MIB Definitions\", STD 16,\n    \
    \ RFC 1212, March 1991.\n"
- title: '[9]  Case, J., Fedor, M., Schoffstall, M., and J. Davin, "Simple'
  contents:
  - "[9]  Case, J., Fedor, M., Schoffstall, M., and J. Davin, \"Simple\n     Network\
    \ Management Protocol\", STD 15, RFC 1157, SNMP Research,\n     Performance Systems\
    \ International, MIT Laboratory for Computer\n     Science, May 1990.\n"
- title: '[10] The SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and'
  contents:
  - "[10] The SNMPv2 Working Group, Case, J., McCloghrie, K., Rose, M., and\n    \
    \ Waldbusser, S., \"Coexistence between Version 1 and Version 2 of the\n     Internet-standard\
    \ Network Management Framework\", RFC 1908, January\n     1996.\n"
- title: '[11] McCloghrie, K., and F. Kastenholz, "Evolution of the Interfaces'
  contents:
  - "[11] McCloghrie, K., and F. Kastenholz, \"Evolution of the Interfaces\n     Group\
    \ of MIB-II\", RFC 1573, Cisco Systems, FTP Software, January\n     1994.\n"
- title: '[12] Information processing systems - Open Systems Interconnection -'
  contents:
  - "[12] Information processing systems - Open Systems Interconnection -\n     Specification\
    \ of Abstract Syntax Notation One (ASN.1),\n     International Organization for\
    \ Standardization.  International\n     Standard 8824, (December, 1987).\n"
- title: APPENDIX A - Disambiguating the SNMPv2 Protocol Definition
  contents:
  - 'APPENDIX A - Disambiguating the SNMPv2 Protocol Definition

    '
- title: The descriptions in [4] of the role in which an SNMPv2 entity acts when
  contents:
  - 'The descriptions in [4] of the role in which an SNMPv2 entity acts when

    '
- title: sending an Inform-Request PDU are ambiguous.  The following updates
  contents:
  - 'sending an Inform-Request PDU are ambiguous.  The following updates

    '
- title: serve to remove those ambiguities.
  contents:
  - 'serve to remove those ambiguities.

    '
- title: '(1)  Add the following sentence to section 2.1:'
  contents:
  - "(1)  Add the following sentence to section 2.1:\n          Further, when an SNMPv2\
    \ entity sends an inform notification,\n          it acts in a manager role in\
    \ respect to initiating the\n          operation, but the management information\
    \ contained in the\n          inform notification is associated with that entity\
    \ acting in\n          an agent role.  By convention, the inform is sent from\
    \ the\n          same transport address as the associated agent role is\n    \
    \      listening on.\n"
- title: '(2)  Modify the last sentence of the second paragraph in section 2.3:'
  contents:
  - "(2)  Modify the last sentence of the second paragraph in section 2.3:\n     \
    \     This type is used by one SNMPv2 entity, acting in a manager\n          role,\
    \ to notify another SNMPv2 entity, also acting in a\n          manager role, of\
    \ management information associated with the\n          sending SNMPv2 entity\
    \ acting in an agent role.\n"
- title: (3)  Modify the second paragraph of section 4.2 (concerning the
  contents:
  - "(3)  Modify the second paragraph of section 4.2 (concerning the\n     generation\
    \ of Inform-Request PDUs):\n          It is mandatory that all SNMPv2 entities\
    \ acting in a manager\n          role be able to generate the following PDU types:\
    \ GetRequest-\n          PDU, GetNextRequest-PDU, GetBulkRequest-PDU, SetRequest-PDU,\n\
    \          and Response-PDU; further, all such implementations must be\n     \
    \     able to receive the following PDU types: Response-PDU,\n          SNMPv2-Trap-PDU,\
    \ InformRequest-PDU.  It is mandatory that all\n          dual-role SNMPv2 entities\
    \ must be able to generate an Inform-\n          Request PDU.\n"
- title: '(4)  Modify the first paragraph of section 4.2.7:'
  contents:
  - "(4)  Modify the first paragraph of section 4.2.7:\n          An InformRequest-PDU\
    \ is generated and transmitted at the\n          request of an application in\
    \ a SNMPv2 entity acting in a\n          manager role, that wishes to notify another\
    \ application (via\n          an SNMPv2 entity also acting in a manager role)\
    \ of information\n          in a MIB view which is accessible to the sending SNMPv2\
    \ entity\n          when acting in an agent role.\n"
- title: APPENDIX B - Who Sends Inform-Requests?
  contents:
  - 'APPENDIX B - Who Sends Inform-Requests?

    '
- title: B.1.   Management Philosophy
  contents:
  - "B.1.   Management Philosophy\n   Ever since its beginnings as SGMP, through its\
    \ definition as SNMPv1,\n   and continuing with the definition of SNMPv2, SNMP\
    \ has embodied more\n   than just a management protocol and the definitions of\
    \ MIB objects.\n   Specifically, SNMP has also had a fundamental philosophy of\n\
    \   management, consisting of a number of design strategies.  These\n   strategies\
    \ have always included the following:\n"
- title: (1)  The impact of incorporating an SNMP agent into a system should be
  contents:
  - "(1)  The impact of incorporating an SNMP agent into a system should be\n    \
    \ minimal, so that both: a) it is feasible to do so even in the\n     smallest/cheapest\
    \ of systems, and b) the operational role and\n     performance of a system is\
    \ not compromised by the inclusion of an\n     SNMP agent.  This promotes widespread\
    \ development, which allows\n     ubiquitous deployment of manageable systems.\n"
- title: (2)  Every system (potentially) incorporates an SNMP agent.  In
  contents:
  - "(2)  Every system (potentially) incorporates an SNMP agent.  In\n     contrast,\
    \ the number of SNMP managers is limited.  Thus, there is a\n     significantly\
    \ larger number of SNMP agents than SNMP managers.\n     Therefore, overall system\
    \ development/complexity/cost is optimized\n     if the SNMP agent is allowed\
    \ to be simple and any required\n     complexity is performed by an SNMP manager.\n"
- title: (3)  The number of unsolicited messages generated by SNMP agents is
  contents:
  - "(3)  The number of unsolicited messages generated by SNMP agents is\n     minimized.\
    \  This enables the amount of network management traffic\n     to be controlled\
    \ by the small number of SNMP managers which are\n     (more) directly controlled\
    \ by network operators.  In fact, this\n     control is considered of greater\
    \ importance than any additional\n     protocol overhead which might be incurred.\
    \  Monitoring of network\n     state at any significant level of detail is accomplished\
    \ primarily\n     by SNMP managers polling for the appropriate information, with\
    \ the\n     use of unsolicited messages confined to those situations where it\n\
    \     is necessary to properly guide an SNMP manager regarding the timing\n  \
    \   and focus of its polling.  This strategy is sometimes referred to\n     as\
    \ \"trap-directed polling\".\n"
- title: B.2.   The Danger of Trap Storms
  contents:
  - "B.2.   The Danger of Trap Storms\n   The need for such control over the amount\
    \ of network management\n   traffic is due to the potential that the SNMP manager\
    \ receiving an\n   unsolicited message does not want, no longer wants, or already\
    \ knows\n   of the information contained in the message.  This potential is\n\
    \   significantly reduced by having the majority of messages be specific\n   requests\
    \ for information by SNMP managers and responses (to those\n   requests) from\
    \ SNMP agents.\n   The danger of not having the amount of network management be\n\
    \   controlled in this manner is the potential for a \"storm\" of useless\n  \
    \ traps.  As a simple example of \"useless\", consider that after a\n   building\
    \ power outage, every device in the network sends a coldStart\n   trap, even though\
    \ every SNMP manager and every network operator\n   already knows what happened.\
    \  For a simple example of \"storm\",\n   consider the result if each transmitted\
    \ trap caused the sending of\n   another.  The greater the number of problems\
    \ in the state of the\n   network, the greater the risk of such a storm occurring,\
    \ especially\n   in the unstructured, heterogeneous environment typical of today's\n\
    \   internets.\n   While SNMP philosophy considers the above to be more important\
    \ than\n   any lack of reliability in unsolicited messages, some\n   users/developers\
    \ have been wary of using traps because of the use\n   (typically) of an unreliable\
    \ transport protocol and because traps are\n   not acknowledged.  However, following\
    \ this logic would imply that\n   having acknowledged-traps would make them reliable;\
    \ of course, this\n   is false since no amount of re- transmission will succeed\
    \ if the\n   receiver and/or the connectivity to the receiver is down.  A SNMP\n\
    \   manager cannot just sit and wait and assume the network is fine just\n   because\
    \ it is not receiving any unsolicited messages.\n"
- title: B.3.   Inform-Requests
  contents:
  - "B.3.   Inform-Requests\n   One of the new features of SNMPv2 is the Inform-request\
    \ PDU.  The\n   Inform-Request contains management information specified in terms\
    \ of\n   MIB objects for a context supported by the sender.  Since by\n   definition,\
    \ an SNMPv2 manager does not itself have managed objects\n   (see sections 3.3),\
    \ the managed objects contained in the Inform-\n   request belong to a context\
    \ of an SNMPv2 agent, just like the managed\n   objects contained in an SNMPv2-Trap.\n\
    \   However, it is not the purpose of an Inform-request to change the\n   above\
    \ described philosophy, i.e., it would be wrong to consider it as\n   an \"acknowledged\
    \ trap\".  To do so, would make the likelihood and\n   effect of trap storms worse.\
    \  Recall the building power outage\n   example:  with regular traps, the SNMP\
    \ manager's buffer just\n   overflows when it receives messages faster than it\
    \ can cope with; in\n   contrast, if every device in the network were to send\
    \ a coldStart\n   Inform-request, then after a power outage, all will re-transmit\
    \ their\n   Inform-request several times unless the receiving SNMP managers send\n\
    \   responses.  In the best case when no messages are lost or re-\n   transmitted,\
    \ there are twice as many useless messages; in the worst\n   case, the SNMP manager\
    \ is unable to respond at all and every message\n   is re-transmitted its maximum\
    \ number of times.\n   The above serves to explain the rationale behind the definition\
    \ (see\n   Appendix A's update to section 4.2.7 of [4]) that:\n     An InformRequest-PDU\
    \ is generated and transmitted at the request of\n     an application in a SNMPv2\
    \ entity acting in a manager role, that\n     wishes to notify another application\
    \ (via an SNMPv2 entity also\n     acting in a manager role) of information in\
    \ a MIB view which is\n     accessible to the sending SNMPv2 entity when acting\
    \ in an agent\n     role.\n   This definition says that SNMPv2 agents do not send\
    \ Inform-Requests,\n   which has three implications (ordered in terms of importance):\n"
- title: (1)  the number of devices which send Inform-requests is required to be
  contents:
  - "(1)  the number of devices which send Inform-requests is required to be\n   \
    \  a small subset of all devices in the network;\n"
- title: (2)  while some devices traditionally considered to be SNMP agents are
  contents:
  - "(2)  while some devices traditionally considered to be SNMP agents are\n    \
    \ perfectly capable of sending Inform-requests, the overall system\n     development/complexity/cost\
    \ is not increased as it would be by\n     having to configure/re-configure every\
    \ SNMPv2 agent as to which\n     Inform-requests to send where and how often;\
    \ and\n"
- title: (3)  the cost of implementing an SNMPv2 agent in the smallest/cheapest
  contents:
  - "(3)  the cost of implementing an SNMPv2 agent in the smallest/cheapest\n    \
    \ system is not increased.\n"
