- contents:
  - '    Policy Core Lightweight Directory Access Protocol (LDAP) Schema

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2004).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document defines a mapping of the Policy Core Information Model\n
    \  to a form that can be implemented in a directory that uses\n   Lightweight
    Directory Access Protocol (LDAP) as its access protocol.\n   This model defines
    two hierarchies of object classes: structural\n   classes representing information
    for representing and controlling\n   policy data as specified in RFC 3060, and
    relationship classes that\n   indicate how instances of the structural classes
    are related to each\n   other.  Classes are also added to the LDAP schema to improve
    the\n   performance of a client's interactions with an LDAP server when the\n
    \  client is retrieving large amounts of policy-related information.\n   These
    classes exist only to optimize LDAP retrievals: there are no\n   classes in the
    information model that correspond to them.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.  Introduction .................................................
    \ 2\n   2.  The Policy Core Information Model ............................  4\n
    \  3.  Inheritance Hierarchy for the PCLS ...........................  5\n   4.
    \ General Discussion of Mapping the Information Model to LDAP ..  6\n       4.1.
    \ Summary of Class and Association Mappings ..............  7\n       4.2.  Usage
    of DIT Content and Structure Rules and Name Forms.  9\n       4.3.  Naming Attributes
    in the PCLS .......................... 10\n       4.4.  Rule-Specific and Reusable
    Conditions and Actions ...... 11\n       4.5.  Location and Retrieval of Policy
    Objects in the\n             Directory ..............................................
    16\n             4.5.1.  Aliases and Other DIT-Optimization Techniques .. 19\n
    \  5.  Class Definitions ............................................ 19\n       5.1.
    \ The Abstract Class \"pcimPolicy\" ........................ 21\n       5.2.  The
    Three Policy Group Classes ......................... 22\n       5.3.  The Three
    Policy Rule Classes .......................... 23\n       5.4.  The Class pcimRuleConditionAssociation
    ................. 30\n       5.5.  The Class pcimRuleValidityAssociation ..................
    32\n       5.6.  The Class pcimRuleActionAssociation .................... 34\n
    \      5.7.  The Auxiliary Class pcimConditionAuxClass .............. 36\n       5.8.
    \ The Auxiliary Class pcimTPCAuxClass .................... 36\n       5.9.  The
    Auxiliary Class pcimConditionVendorAuxClass ........ 40\n       5.10. The Auxiliary
    Class pcimActionAuxClass ................. 41\n       5.11. The Auxiliary Class
    pcimActionVendorAuxClass ........... 42\n       5.12. The Class pcimPolicyInstance
    ........................... 43\n       5.13. The Auxiliary Class pcimElementAuxClass
    ................ 44\n       5.14. The Three Policy Repository Classes ....................
    45\n       5.15. The Auxiliary Class pcimSubtreesPtrAuxClass ............ 46\n
    \      5.16. The Auxiliary Class pcimGroupContainmentAuxClass ....... 48\n       5.17.
    The Auxiliary Class pcimRuleContainmentAuxClass ........ 49\n   6.  Extending
    the Classes Defined in This Document ............... 50\n       6.1.  Subclassing
    pcimConditionAuxClass and pcimActionAuxClass 50\n       6.2.  Using the Vendor
    Policy Attributes ..................... 50\n       6.3.  Using Time Validity Periods
    ............................ 51\n   7.  Security Considerations ......................................
    51\n   8.  IANA Considerations .......................................... 53\n
    \      8.1.  Object Identifiers ..................................... 53\n       8.2.
    \ Object Identifier Descriptors .......................... 53\n   9.  Acknowledgments
    .............................................. 56\n   10. Appendix:  Constructing
    the Value of orderedCIMKeys .......... 57\n   11. References ...................................................
    58\n       11.1. Normative References ................................... 58\n
    \      11.2. Informative References ................................. 59\n   12.
    Authors' Addresses ........................................... 60\n   13. Full
    Copyright Statement ..................................... 61\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This document takes as its starting point the object-oriented\n
    \  information model for representing information for representing and\n   controlling
    policy data as specified in [1].  Lightweight Directory\n   Access Protocol (LDAP)
    [2] implementers, please note that the use of\n   the term \"policy\" in this
    document does not refer to the use of the\n   term \"policy\" as defined in X.501
    [4].  Rather, the use of the term\n   \"policy\" throughout this document is defined
    as follows:\n      Policy is defined as a set of rules to administer, manage,
    and\n      control access to network resources.\n   This work is currently under
    joint development in the IETF's Policy\n   Framework working group and in the
    Policy working group of the\n   Distributed Management Task Force (DMTF).  This
    model defines two\n   hierarchies of object classes: structural classes representing
    policy\n   information and control of policies, and relationship classes that\n
    \  indicate how instances of the structural classes are related to each\n   other.
    \ In general, both of these class hierarchies will need to be\n   mapped to a
    particular data store.\n   This document defines the mapping of these information
    model classes\n   to a directory that uses LDAP as its access protocol.  Two types
    of\n   mappings are involved:\n      -  For the structural classes in the information
    model, the\n         mapping is basically one-for-one: information model classes
    map\n         to LDAP classes, information model properties map to LDAP\n         attributes.\n
    \     -  For the relationship classes in the information model,\n         different
    mappings are possible.  In this document, the Policy\n         Core Information
    Model's (PCIM's) relationship classes and\n         their properties are mapped
    in three ways: to LDAP auxiliary\n         classes, to attributes representing
    distinguished name (DN)\n         references, and to superior-subordinate relationships
    in the\n         Directory Information Tree (DIT).\n   Implementations that use
    an LDAP directory as their policy repository\n   and want to implement policy
    information according to RFC 3060 [1]\n   SHALL use the LDAP schema defined in
    this document, or a schema that\n   subclasses from the schema defined in this
    document.  The use of the\n   information model defined in reference [1] as the
    starting point\n   enables the inheritance and the relationship class hierarchies
    to be\n   extensible, such that other types of policy repositories, such as\n
    \  relational databases, can also use this information.\n   This document fits
    into the overall framework for representing,\n   deploying, and managing policies
    being developed by the Policy\n   Framework Working Group.\n   The LDAP schema
    described in this document uses the prefix \"pcim\" to\n   identify its classes
    and attributes.  It consists of ten very general\n   classes: pcimPolicy (an abstract
    class), three policy group classes\n   (pcimGroup, pcimGroupAuxClass, and pcimGroupInstance),
    three policy\n   rule classes (pcimRule, pcimRuleAuxClass, and pcimRuleInstance),
    and\n   three special auxiliary classes (pcimConditionAuxClass,\n   pcimTPCAuxClass,
    and pcimActionAuxClass).  (Note that the\n   PolicyTimePeriodCondition auxiliary
    class defined in [1] would\n   normally have been named pcimTimePeriodConditionAuxClass,
    but this\n   name is too long for some directories.  Therefore, we have\n   abbreviated
    this name to be pcimTPCAuxClass).\n   The mapping for the PCIM classes pcimGroup
    and pcimRule is designed\n   to be as flexible as possible.  Three classes are
    defined for these\n   two PCIM classes.  First, an abstract superclass is defined
    that\n   contains all required properties of each PCIM class.  Then, both an\n
    \  auxiliary class as well as a structural class are derived from the\n   abstract
    superclass.  This provides maximum flexibility for the\n   developer.\n   The
    schema also contains two less general classes:\n   pcimConditionVendorAuxClass
    and pcimActionVendorAuxClass.  To achieve\n   the mapping of the information model's
    relationships, the schema also\n   contains two auxiliary classes: pcimGroupContainmentAuxClass
    and\n   pcimRuleContainmentAuxClass.  Capturing the distinction between\n   rule-specific
    and reusable policy conditions and policy actions\n   introduces seven other classes:
    pcimRuleConditionAssociation,\n   pcimRuleValidityAssociation, pcimRuleActionAssociation,\n
    \  pcimPolicyInstance, and three policy repository classes\n   (pcimRepository,
    pcimRepositoryAuxClass, and pcimRepositoryInstance).\n   Finally, the schema includes
    two classes (pcimSubtreesPtrAuxClass and\n   pcimElementAuxClass) for optimizing
    LDAP retrievals.  In all, the\n   schema contains 23 classes.\n   Within the context
    of this document, the term \"PCLS\" (Policy Core\n   LDAP Schema) is used to refer
    to the LDAP class definitions that this\n   document contains.  The term \"PCIM\"
    refers to classes defined in [1].\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
    \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\",
    and \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC
    2119 [10].\n"
  title: 1.  Introduction
- contents:
  - "2.  The Policy Core Information Model\n   This document contains an LDAP schema
    representing the classes\n   defined in the companion document \"Policy Core Information\n
    \  Model -- Version 1 Specification\" [1].  Other documents may\n   subsequently
    be produced, with mappings of this same PCIM to other\n   storage technologies.
    \ Since the detailed semantics of the PCIM\n   classes appear only in [1], that
    document is a prerequisite for\n   reading and understanding this document.\n"
  title: 2.  The Policy Core Information Model
- contents:
  - "3.  Inheritance Hierarchy for the PCLS\n   The following diagram illustrates
    the class hierarchy for the LDAP\n   Classes defined in this document:\n        top\n
    \        |\n         +--dlm1ManagedElement (abstract)\n         |   |\n         |
    \  +--pcimPolicy (abstract)\n         |   |   |\n         |   |   +--pcimGroup
    (abstract)\n         |   |   |  |\n         |   |   |  +--pcimGroupAuxClass (auxiliary)\n
    \        |   |   |  |\n         |   |   |  +--pcimGroupInstance (structural)\n
    \        |   |   |\n         |   |   +--pcimRule (abstract)\n         |   |   |
    \ |\n         |   |   |  +--pcimRuleAuxClass (auxiliary)\n         |   |   |  |\n
    \        |   |   |  +--pcimRuleInstance (structural)\n         |   |   |\n         |
    \  |   +--pcimRuleConditionAssociation (structural)\n         |   |   |\n         |
    \  |   +--pcimRuleValidityAssociation (structural)\n         |   |   |\n         |
    \  |   +--pcimRuleActionAssociation (structural)\n         |   |   |\n         |
    \  |   +--pcimPolicyInstance (structural)\n         |   |   |\n         |   |
    \  +--pcimElementAuxClass (auxiliary)\n         |   |\n         |   +--dlm1ManagedSystemElement
    (abstract)\n         |       |\n         |       +--dlm1LogicalElement (abstract)\n
    \        |           |\n         |           +--dlm1System (abstract)\n         |
    \              |\n         |               +--dlm1AdminDomain (abstract)\n         |
    \                  |\n         |                   +--pcimRepository (abstract)\n
    \        |                      |\n         |                      +--pcimRepositoryAuxClass
    (auxiliary)\n        top\n         |                      |\n         |                      +--pcimRepositoryInstance\n
    \        |                         (structural)\n         |\n         +--pcimConditionAuxClass
    (auxiliary)\n         |   |\n         |   +---pcimTPCAuxClass (auxiliary)\n         |
    \  |\n         |   +---pcimConditionVendorAuxClass (auxiliary)\n         |\n         +--pcimActionAuxClass
    (auxiliary)\n         |   |\n         |   +---pcimActionVendorAuxClass (auxiliary)\n
    \        |\n         +--pcimSubtreesPtrAuxClass (auxiliary)\n         |\n         +--pcimGroupContainmentAuxClass
    (auxiliary)\n         |\n         +--pcimRuleContainmentAuxClass (auxiliary)\n
    \        Figure 1.  LDAP Class Inheritance Hierarchy for the PCLS\n"
  title: 3.  Inheritance Hierarchy for the PCLS
- contents:
  - "4.  General Discussion of Mapping the Information Model to LDAP\n   The classes
    described in Section 5 below contain certain\n   optimizations for a directory
    that uses LDAP as its access protocol.\n   One example of this is the use of auxiliary
    classes to represent some\n   of the associations defined in the information model.
    \ Other data\n   stores might need to implement these associations differently.
    \ A\n   second example is the introduction of classes specifically designed\n
    \  to optimize retrieval of large amounts of policy-related data from a\n   directory.
    \ This section discusses some general topics related to the\n   mapping from the
    information model to LDAP.\n   The remainder of this section will discuss the
    following topics.\n   Section 4.1 will discuss the strategy used in mapping the
    classes and\n   associations defined in [1] to a form that can be represented
    in a\n   directory that uses LDAP as its access protocol.  Section 4.2\n   discusses
    DIT content and structure rules, as well as name forms.\n   Section 4.3 describes
    the strategy used in defining naming attributes\n   for the schema described in
    Section 5 of this document.  Section 4.4\n   defines the strategy recommended
    for locating and retrieving\n   PCIM-derived objects in the directory.\n"
  - contents:
    - "4.1.  Summary of Class and Association Mappings\n   Fifteen of the classes
      in the PCLS come directly from the nine\n   corresponding classes in the information
      model.  Note that names of\n   classes begin with an upper case character in
      the information model\n   (although for CIM in particular, case is not significant
      in class and\n   property names), but with a lower case character in LDAP.  This
      is\n   because although LDAP doesn't care, X.500 doesn't allow class names\n
      \  to begin with an uppercase character.  Note also that the prefix\n   \"pcim\"
      is used to identify these LDAP classes.\n      +---------------------------+-------------------------------+\n
      \     | Information Model         | LDAP Class(es)                |\n      +---------------------------+-------------------------------+\n
      \     +---------------------------+-------------------------------+\n      |
      Policy                    | pcimPolicy                    |\n      +---------------------------+-------------------------------+\n
      \     | PolicyGroup               | pcimGroup                     |\n      |
      \                          |   pcimGroupAuxClass           |\n      |                           |
      \  pcimGroupInstance           |\n      +---------------------------+-------------------------------+\n
      \     | PolicyRule                | pcimRule                      |\n      |
      \                          |   pcimRuleAuxClass            |\n      |                           |
      \  pcimRuleInstance            |\n      +---------------------------+-------------------------------+\n
      \     | PolicyCondition           | pcimConditionAuxClass         |\n      +---------------------------+-------------------------------+\n
      \     | PolicyAction              | pcimActionAuxClass            |\n      +---------------------------+-------------------------------+\n
      \     | VendorPolicyCondition     | pcimConditionVendorAuxClass   |\n      +---------------------------+-------------------------------+\n
      \     | VendorPolicyAction        | pcimActionVendorAuxClass      |\n      +---------------------------+-------------------------------+\n
      \     | PolicyTimePeriodCondition | pcimTPCAuxClass               |\n      +---------------------------+-------------------------------+\n
      \     | PolicyRepository          | pcimRepository                |\n      |
      \                          |   pcimRepositoryAuxClass      |\n      |                           |
      \  pcimRepositoryInstance      |\n      +---------------------------+-------------------------------+\n
      \         Figure 2.  Mapping of Information Model Classes to LDAP\n   The associations
      in the information model map to attributes that\n   reference DNs (Distinguished
      Names) or to Directory Information Tree\n   (DIT) containment (i.e., superior-subordinate
      relationships) in LDAP.\n   Two of the attributes that reference DNs appear
      in auxiliary classes,\n   which allow each of them to represent several relationships
      from the\n   information model.\n"
    - '+----------------------------------+----------------------------------+

      '
    - '| Information Model Association     | LDAP Attribute / Class          |

      '
    - '+-----------------------------------+---------------------------------+

      '
    - '+-----------------------------------+---------------------------------+

      '
    - '| PolicyGroupInPolicyGroup          | pcimGroupsAuxContainedSet in    |

      '
    - '|                                   |  pcimGroupContainmentAuxClass   |

      '
    - '+-----------------------------------+---------------------------------+

      '
    - '| PolicyRuleInPolicyGroup           | pcimRulesAuxContainedSet in     |

      '
    - '|                                   |  pcimRuleContainmentAuxClass    |

      '
    - '+-----------------------------------+---------------------------------+

      '
    - '| PolicyConditionInPolicyRule       | DIT containment or              |

      '
    - '|                                   | pcimRuleConditionList in        |

      '
    - '|                                   |  pcimRule or                    |

      '
    - '|                                   | pcimConditionDN in              |

      '
    - '|                                   |  pcimRuleConditionAssociation   |

      '
    - '+-----------------------------------+---------------------------------+

      '
    - '| PolicyActionInPolicyRule          | DIT containment or              |

      '
    - '|                                   | pcimRuleActionList in           |

      '
    - '|                                   |  pcimRule or                    |

      '
    - '|                                   | pcimActionDN in                 |

      '
    - '|                                   |  pcimRuleActionAssociation      |

      '
    - '+-----------------------------------+---------------------------------+

      '
    - '| PolicyRuleValidityPeriod          | pcimRuleValidityPeriodList      |

      '
    - '|                                   |  in pcimRule or (if reusable)   |

      '
    - '|                                   |  referenced through the         |

      '
    - '|                                   | pcimTimePeriodConditionDN in    |

      '
    - '|                                   |  pcimRuleValidityAssociation    |

      '
    - '+-----------------------------------+---------------------------------+

      '
    - '| PolicyConditionInPolicyRepository | DIT containment                 |

      '
    - '+-----------------------------------+---------------------------------+

      '
    - '| PolicyActionInPolicyRepository    | DIT containment                 |

      '
    - '+-----------------------------------+---------------------------------+

      '
    - '| PolicyRepositoryInPolicyRepository| DIT containment                 |

      '
    - "+-----------------------------------+---------------------------------+\n      Figure
      3.  Mapping of Information Model Associations to LDAP\n   Of the remaining classes
      in the PCLS, two (pcimElementAuxClass and\n   pcimSubtreesPtrAuxClass) are included
      to make navigation through the\n   DIT and retrieval of the entries found there
      more efficient.  This\n   topic is discussed below in Section 4.5.\n   The remaining
      four classes in the PCLS, pcimRuleConditionAssociation,\n   pcimRuleValidityAssociation,
      pcimRuleActionAssociation, and\n   pcimPolicyInstance, are all involved with
      the representation of\n   policy conditions and policy actions in an LDAP directory.
      \ This\n   topic is discussed below in Section 4.4.\n"
    title: 4.1.  Summary of Class and Association Mappings
  - contents:
    - "4.2.  Usage of DIT Content and Structure Rules and Name Forms\n   There are
      three powerful tools that can be used to help define\n   schemata. The first,
      DIT content rules, is a way of defining the\n   content of an entry for a structural
      object class.  It can be used to\n   specify the following characteristics of
      the entry:\n      -  additional mandatory attributes that the entries are required\n
      \        to contain\n      -  additional optional attributes the entries are
      allowed to\n         contain\n      -  the set of additional auxiliary object
      classes that these\n         entries are allowed to be members of\n      -  any
      optional attributes from the structural and auxiliary\n         object class
      definitions that the entries are required to\n         preclude\n   DIT content
      rules are NOT mandatory for any structural object class.\n   A DIT structure
      rule, together with a name form, controls the\n   placement and naming of an
      entry within the scope of a subschema.\n   Name forms define which attribute
      type(s) are required and are\n   allowed to be used in forming the Relative
      Distinguished Names (RDNs)\n   of entries.  DIT structure rules specify which
      entries are allowed to\n   be superior to other entries, and hence control the
      way that RDNs are\n   added together to make DNs.\n   A name form specifies
      the following:\n      -  the structural object class of the entries named by
      this name\n         form\n      -  attributes that are required to be used in
      forming the RDNs of\n         these entries\n      -  attributes that are allowed
      to be used in forming the RDNs of\n         these entries\n      -  an object
      identifier to uniquely identify this name form\n   Note that name forms can
      only be specified for structural object\n   classes.  However, every entry in
      the DIT must have a name form\n   controlling it.\n   Unfortunately, current
      LDAP servers vary quite a lot in their support\n   of these features.  There
      are also three crucial implementation\n   points that must be followed.  First,
      X.500 use of structure rules\n   requires that a structural object class with
      no superior structure\n   rule be a subschema administrative point.  This is
      exactly NOT what\n   we want for policy information.  Second, when an auxiliary
      class is\n   subclassed, if a content rule exists for the structural class that\n
      \  the auxiliary class refers to, then that content rule needs to be\n   augmented.
      \ Finally, most LDAP servers unfortunately do not support\n   inheritance of
      structure and content rules.\n   Given these concerns, DIT structure and content
      rules have been\n   removed from the PCLS.  This is because, if included, they
      would be\n   normative references and would require OIDs.  However, we don't
      want\n   to lose the insight gained in building the structure and content\n
      \  rules of the previous version of the schema.  Therefore, we describe\n   where
      such rules could be used in this schema, what they would\n   control, and what
      their effect would be.\n"
    title: 4.2.  Usage of DIT Content and Structure Rules and Name Forms
  - contents:
    - "4.3.  Naming Attributes in the PCLS\n   Instances in a directory are identified
      by distinguished names (DNs),\n   which provide the same type of hierarchical
      organization that a file\n   system provides in a computer system.  A distinguished
      name is a\n   sequence of RDNs.  An RDN provides a unique identifier for an\n
      \  instance within the context of its immediate superior, in the same\n   way
      that a filename provides a unique identifier for a file within\n   the context
      of the folder in which it resides.\n   To preserve maximum naming flexibility
      for policy administrators,\n   three optional (i.e., \"MAY\") naming attributes
      have been defined.\n   They are:\n      -  Each of the structural classes defined
      in this schema has its\n         own unique (\"MAY\") naming attribute.  Since
      the naming\n         attributes are different, a policy administrator can, by
      using\n         these attributes, guarantee that there will be no name\n         collisions
      between instances of different classes, even if the\n         same value is
      assigned to the instances' respective naming\n         attributes.\n      -
      \ The LDAP attribute cn (corresponding to X.500's commonName) is\n         included
      as a MAY attribute in the abstract class pcimPolicy,\n         and thus by inheritance
      in all of its subclasses.  In X.500,\n         commonName typically functions
      as an RDN attribute, for naming\n         instances of many classes (e.g., X.500's
      person class).\n      -  A special attribute is provided for implementations
      that expect\n         to map between native CIM and LDAP representations of
      policy\n         information.  This attribute, called orderedCimKeys, is defined\n
      \        in the class dlm1ManagedElement [6].  The value of this\n         attribute
      is derived algorithmically from values that are\n         already present in
      a CIM policy instance.  The normative\n         reference for this algorithm
      is contained in [6].  See the\n         appendix of this document for a description
      of the algorithm.\n   Since any of these naming attributes MAY be used for naming
      an\n   instance of a PCLS class, implementations MUST be able to accommodate\n
      \  instances named in any of these ways.\n   Note that it is recommended that
      two or more of these attributes\n   SHOULD NOT be used together to form a multi-part
      RDN, since support\n   for multi-part RDNs is limited among existing directory\n
      \  implementations.\n"
    title: 4.3.  Naming Attributes in the PCLS
  - contents:
    - "4.4.  Rule-Specific and Reusable Conditions and Actions\n   The PCIM [1] distinguishes
      between two types of policy conditions and\n   policy actions:  those associated
      with a single policy rule, and\n   those that are reusable, in the sense that
      they may be associated\n   with more than one policy rule.  While there is no
      inherent\n   functional difference between a rule-specific condition or action
      and\n   a reusable one, there is both a usage, as well as, an implementation\n
      \  difference between them.\n   Defining a condition or action as reusable vs.
      rule-specific reflects\n   a conscious decision on the part of the administrator
      in defining how\n   they are used.  In addition, there are variations that reflect\n
      \  implementing rule-specific vs. reusable policy conditions and actions\n   and
      how they are treated in a policy repository.  The major\n   implementation differences
      between a rule-specific and a reusable\n   condition or action are delineated
      below:\n   1.  It is natural for a rule-specific condition or action to be\n
      \      removed from the policy repository at the same time the rule is.\n       It
      is just the opposite for reusable conditions and actions.\n       This is because
      the condition or action is conceptually attached\n       to the rule in the
      rule-specific case, whereas it is referenced\n       (e.g., pointed at) in the
      reusable case.  The persistence of a\n       pcimRepository instance is independent
      of the persistence of a\n       pcimRule instance.\n   2.  Access permissions
      for a rule-specific condition or action are\n       usually identical to those
      for the rule itself.  On the other\n       hand, access permissions of reusable
      conditions and actions must\n       be expressible without reference to a policy
      rule.\n   3.  Rule-specific conditions and actions require fewer accesses,\n
      \      because the conditions and actions are \"attached\" to the rule.\n       In
      contrast, reusable conditions and actions require more\n       accesses, because
      each condition or action that is reusable\n       requires a separate access.\n
      \  4.  Rule-specific conditions and actions are designed for use by a\n       single
      rule.  As the number of rules that use the same\n       rule-specific condition
      increase, subtle problems are created\n       (the most obvious being how to
      keep the rule-specific conditions\n       and actions updated to reflect the
      same value).  Reusable\n       conditions and actions lend themselves for use
      by multiple\n       independent rules.\n   5.  Reusable conditions and actions
      offer an optimization when\n       multiple rules are using the same condition
      or action.  This is\n       because the reusable condition or action only needs
      be updated\n       once, and by virtue of DN reference, the policy rules will
      be\n       automatically updated.\n   The preceding paragraph does not contain
      an exhaustive list of the\n   ways in which reusable and rule-specific conditions
      should be treated\n   differently.  Its purpose is merely to justify making
      a semantic\n   distinction between rule-specific and reusable, and then reflecting\n
      \  this distinction in the policy repository itself.\n   When the policy repository
      is realized in an LDAP-accessible\n   directory, the distinction between rule-specific
      and reusable\n   conditions and actions is realized via placement of auxiliary
      classes\n   and via DIT containment.  Figure 4 illustrates a policy rule Rule1\n
      \  with one rule-specific condition CA and one rule-specific action AB.\n                    +-----+\n
      \                   |Rule1|\n                    |     |\n              +-----|-
      \  -|-----+\n              |     +-----+     |\n              |       * *       |\n
      \             |       * *       |\n              |    **** ****    |\n              |
      \   *       *    |\n              v    *       *    v\n            +--------+
      \  +--------+\n            | CA+ca  |   | AB+ab  |\n            +--------+   +--------+\n
      \                         +------------------------------+\n                          |LEGEND:
      \                      |\n                          |  ***** DIT containment
      \      |\n                          |    +   auxiliary attachment  |\n                          |
      \ ----> DN reference          |\n                          +------------------------------+\n
      \          Figure 4  Rule-Specific Policy Conditions and Actions\n   Because
      the condition and action are specific to Rule1, the auxiliary\n   classes ca
      and ab that represent them are attached, respectively, to\n   the structural
      classes CA and AB.  These structural classes represent\n   not the condition
      ca and action ab themselves, but rather the\n   associations between Rule1 and
      ca, and between Rule1 and ab.\n   As Figure 4 illustrates, Rule1 contains DN
      references to the\n   structural classes CA and AB that appear below it in the
      DIT.  At\n   first glance it might appear that these DN references are\n   unnecessary,
      since a subtree search below Rule1 would find all of the\n   structural classes
      representing the associations between Rule1 and\n   its conditions and actions.
      \ Relying only on a subtree search,\n   though, runs the risk of missing conditions
      or actions that should\n   have appeared in the subtree, but for some reason
      did not, or of\n   finding conditions or actions that were inadvertently placed
      in the\n   subtree, or that should have been removed from the subtree, but for\n
      \  some reason were not.  Implementation experience has suggested that\n   many
      (but not all) of these risks are eliminated.\n   However, it must be noted that
      this comes at a price.  The use of DN\n   references, as shown in Figure 4 above,
      thwarts inheritance of access\n   control information as well as existence dependency
      information.  It\n   also is subject to referential integrity considerations.
      \ Therefore,\n   it is being included as an option for the designer.\n   Figure
      5 illustrates a second way of representing rule-specific\n   conditions and
      actions in an LDAP-accessible directory: attachment of\n   the auxiliary classes
      directly to the instance representing the\n   policy rule.  When all of the
      conditions and actions are attached to\n   a policy rule in this way, the rule
      is termed a \"simple\" policy rule.\n   When conditions and actions are not
      attached directly to a policy\n   rule, the rule is termed a \"complex\" policy
      rule.\n                    +-----------+\n                    |Rule1+ca+ab|\n
      \                   |           |\n                    +-----------+\n                          +------------------------------+\n
      \                         |LEGEND:                       |\n                          |
      \   +   auxiliary attachment  |\n                          +------------------------------+\n
      \                     Figure 5.  A Simple Policy Rule\n   The simple/complex
      distinction for a policy rule is not all or\n   nothing.  A policy rule may
      have its conditions attached to itself\n   and its actions attached to other
      entries, or it may have its actions\n   attached to itself and its conditions
      attached to other entries.\n   However, it SHALL NOT have either its conditions
      or its actions\n   attached both to itself and to other entries, with one exception:
      \ a\n   policy rule may reference its validity periods with the\n   pcimRuleValidityPeriodList
      attribute, but have its other conditions\n   attached to itself.\n   The tradeoffs
      between simple and complex policy rules are between the\n   efficiency of simple
      rules and the flexibility and greater potential\n   for reuse of complex rules.
      \ With a simple policy rule, the semantic\n   options are limited:\n   -   All
      conditions are ANDed together.  This combination can be\n       represented
      in two ways in the Disjunctive Normal Form (DNF)/\n       Conjunctive Normal
      Form (CNF) (please see [1] for definitions of\n       these terms) expressions
      characteristic of policy conditions:  as\n       a DNF expression with a single
      AND group, or as a CNF expression\n       with multiple single-condition OR
      groups.  The first of these is\n       arbitrarily chosen as the representation
      for the ANDed conditions\n       in a simple policy rule.\n   -   If multiple
      actions are included, no order can be specified for\n       them.\n   If a policy
      administrator needs to combine conditions in some other\n   way, or if there
      is a set of actions that must be ordered, then the\n   only option is to use
      a complex policy rule.\n   Finally, Figure 6 illustrates the same policy rule
      Rule1, but this\n   time its condition and action are reusable.  The association
      classes\n   CA and AB are still present, and they are still DIT contained under\n
      \  Rule1.  But rather than having the auxiliary classes ca and ab\n   attached
      directly to the association classes CA and AB, each now\n   contains DN references
      to other entries to which these auxiliary\n   classes are attached.  These other
      entries, CIA and AIB, are DIT\n   contained under RepositoryX, which is an instance
      of the class\n   pcimRepository.  Because they are named under an instance of\n
      \  pcimRepository, ca and ab are clearly identified as reusable.\n                   +-----+
      \            +-------------+\n                   |Rule1|             | RepositoryX
      |\n                 +-|-   -|--+          |             |\n                 |
      +-----+  |          +-------------+\n                 |   * *    |             *
      \      *\n                 |   * *    |             *       *\n                 |
      *** **** |             *       *\n                 | *      * v             *
      \      *\n                 | *     +---+            *       *\n                 |
      *     |AB |         +------+   *\n                 v *     |  -|-------->|AIB+ab|
      \  *\n                +---+    +---+         +------+   *\n                |CA
      |                         +------+\n                |  -|------------------------>|CIA+ca|\n
      \               +---+                         +------+\n                          +------------------------------+\n
      \                         |LEGEND:                       |\n                          |
      \ ***** DIT containment       |\n                          |    +   auxiliary
      attachment  |\n                          |  ----> DN reference          |\n
      \                         +------------------------------+\n             Figure
      6.  Reusable Policy Conditions and Actions\n   The classes pcimConditionAuxClass
      and pcimActionAuxClass do not\n   themselves represent actual conditions and
      actions:  these are\n   introduced in their subclasses.  What pcimConditionAuxClass
      and\n   pcimActionAuxClass do introduce are the semantics of being a policy\n
      \  condition or a policy action.  These are the semantics that all the\n   subclasses
      of pcimConditionAuxClass and pcimActionAuxClass inherit.\n   Among these semantics
      are those of representing either a\n   rule-specific or a reusable policy condition
      or policy action.\n   In order to preserve the ability to represent a rule-specific
      or a\n   reusable condition or action, as well as a simple policy rule, all\n
      \  the subclasses of pcimConditionAuxClass and pcimActionAuxClass MUST\n   also
      be auxiliary classes.\n"
    title: 4.4.  Rule-Specific and Reusable Conditions and Actions
  - contents:
    - "4.5.  Location and Retrieval of Policy Objects in the Directory\n   When a
      Policy Decision Point (PDP) goes to an LDAP directory to\n   retrieve the policy
      object instances relevant to the Policy\n   Enforcement Points (PEPs) it serves,
      it is faced with two related\n   problems:\n   -   How does it locate and retrieve
      the directory entries that apply\n       to its PEPs?  These entries may include
      instances of the PCLS\n       classes, instances of domain-specific subclasses
      of these\n       classes, and instances of other classes modeling such resources\n
      \      as user groups, interfaces, and address ranges.\n   -   How does it retrieve
      the directory entries it needs in an\n       efficient manner, so that retrieval
      of policy information from\n       the directory does not become a roadblock
      to scalability?  There\n       are two facets to this efficiency:  retrieving
      only the relevant\n       directory entries, and retrieving these entries using
      as few LDAP\n       calls as possible.\n   The placement of objects in the Directory
      Information Tree (DIT)\n   involves considerations other than how the policy-related
      objects\n   will be retrieved by a PDP.  Consequently, all that the PCLS can
      do\n   is to provide a \"toolkit\" of classes to assist the policy\n   administrator
      as the DIT is being designed and built.  A PDP SHOULD\n   be able to take advantage
      of any tools that the policy administrator\n   is able to build into the DIT,
      but it MUST be able to use a less\n   efficient means of retrieval if that is
      all it has available to it.\n   The basic idea behind the LDAP optimization
      classes is a simple one:\n   make it possible for a PDP to retrieve all the
      policy-related objects\n   it needs, and only those objects, using as few LDAP
      calls as\n   possible.  An important assumption underlying this approach is
      that\n   the policy administrator has sufficient control over the underlying\n
      \  DIT structure to define subtrees for storing policy information.  If\n   the
      policy administrator does not have this level of control over DIT\n   structure,
      a PDP can still retrieve the policy-related objects it\n   needs individually.
      \ But it will require more LDAP access operations\n   to do the retrieval in
      this way.  Figure 7 illustrates how LDAP\n   optimization is accomplished.\n
      \                      +-----+\n      ---------------->|  A  |\n      DN reference
      to  |     |    DN references to subtrees   +---+\n      starting object  +-----+
      \   +-------------------------->| C |\n                       |  o--+----+         +---+
      \            +---+\n                       |  o--+------------->| B |            /
      \    \\\n                       +-----+              +---+           /       \\\n
      \                     /       \\            /     \\         /   ...   \\\n
      \                    /         \\          /       \\\n                    /
      \          \\        /   ...   \\\n      Figure 7.  Using the pcimSubtreesPtrAuxClass
      to Locate Policies\n   The PDP is configured initially with a DN reference to
      some entry in\n   the DIT.  The structural class of this entry is not important;
      the\n   PDP is interested only in the pcimSubtreesPtrAuxClass attached to it.\n
      \  This auxiliary class contains a multi-valued attribute with DN\n   references
      to objects that anchor subtrees containing policy-related\n   objects of interest
      to the PDP.  Since pcimSubtreesPtrAuxClass is an\n   auxiliary class, it can
      be attached to an entry that the PDP would\n   need to access anyway - perhaps
      an entry containing initial\n   configuration settings for the PDP, or for a
      PEP that uses the PDP.\n   Once it has retrieved the DN references, the PDP
      will direct to each\n   of the objects identified by them an LDAP request that
      all entries in\n   its subtree be evaluated against the selection criteria specified
      in\n   the request.  The LDAP-enabled directory then returns all entries in\n
      \  that subtree that satisfy the specified criteria.\n   The selection criteria
      always specify that object class=\"pcimPolicy\".\n   Since all classes representing
      policy rules, policy conditions, and\n   policy actions, both in the PCLS and
      in any domain-specific schema\n   derived from it, are subclasses of the abstract
      class policy, this\n   criterion evaluates to TRUE for all instances of these
      classes.  To\n   accommodate special cases where a PDP needs to retrieve objects
      that\n   are not inherently policy-related (for example, an IP address range\n
      \  object referenced by a subclass of pcimActionAuxClass representing\n   the
      DHCP action \"assign from this address range\"), the auxiliary\n   class pcimElementAuxClass
      can be used to \"tag\" an entry, so that it\n   will be found by the selection
      criterion \"object class=pcimPolicy\".\n   The approach described in the preceding
      paragraph will not work for\n   certain directory implementations, because these
      implementations do\n   not support matching of auxiliary classes in the objectClass\n
      \  attribute.  For environments where these implementations are expected\n   to
      be present, the \"tagging\" of entries as relevant to policy can be\n   accomplished
      by inserting the special value \"POLICY\" into the list of\n   values contained
      in the pcimKeywords attribute (provided by the\n   pcimPolicy class).\n   If
      a PDP needs only a subset of the policy-related objects in the\n   indicated
      subtrees, then it can be configured with additional\n   selection criteria based
      on the pcimKeywords attribute defined in the\n   pcimPolicy class.  This attribute
      supports both standardized and\n   administrator- defined values.  For example,
      a PDP could be\n   configured to request only those policy-related objects containing\n
      \  the keywords \"DHCP\" and \"Eastern US\".\n   To optimize what is expected
      to be a typical case, the initial\n   request from the client includes not only
      the object to which its\n   \"seed\" DN references, but also the subtree contained
      under this\n   object.  The filter for searching this subtree is whatever the
      client\n   is going to use later to search the other subtrees:  object\n   class=\"pcimPolicy\"
      or the presence of the keyword \"POLICY\", and/or\n   presence of a more specific
      value of pcimKeywords (e.g., \"QoS Edge\n   Policy\").\n   Returning to the
      example in Figure 7, we see that in the best case, a\n   PDP can get all the
      policy-related objects it needs, and only those\n   objects, with exactly three
      LDAP requests:  one to its starting\n   object A to get the references to B
      and C, as well as the\n   policy-related objects it needs from the subtree under
      A, and then\n   one each to B and C to get all the policy-related objects that
      pass\n   the selection criteria with which it was configured.  Once it has\n
      \  retrieved all of these objects, the PDP can then traverse their\n   various
      DN references locally to understand the semantic\n   relationships among them.
      \ The PDP should also be prepared to find a\n   reference to another subtree
      attached to any of the objects it\n   retrieves, and to follow this reference
      first, before it follows any\n   of the semantically significant references
      it has received.  This\n   recursion permits a structured approach to identifying
      related\n   policies.  In Figure 7, for example, if the subtree under B includes\n
      \  departmental policies and the one under C includes divisional\n   policies,
      then there might be a reference from the subtree under C to\n   an object D
      that roots the subtree of corporate-level policies.\n   A PDP SHOULD understand
      the pcimSubtreesPtrAuxClass class, SHOULD be\n   capable of retrieving and processing
      the entries in the subtrees it\n   references, and SHOULD be capable of doing
      all of this recursively.\n   The same requirements apply to any other entity
      needing to retrieve\n   policy information from the directory.  Thus, a Policy
      Management\n   Tool that retrieves policy entries from the directory in order
      to\n   perform validation and conflict detection SHOULD also understand and\n
      \  be capable of using the pcimSubtreesPtrAuxClass.  All of these\n   requirements
      are \"SHOULD\"s rather than \"MUST\"s because an LDAP client\n   that doesn't
      implement them can still access and retrieve the\n   directory entries it needs.
      \ The process of doing so will just be\n   less efficient than it would have
      been if the client had implemented\n   these optimizations.\n   When it is serving
      as a tool for creating policy entries in the\n   directory, a Policy Management
      Tool SHOULD support creation of\n   pcimSubtreesPtrAuxClass entries and their
      references to object\n   instances.\n"
    - contents:
      - "4.5.1.  Aliases and Other DIT-Optimization Techniques\n   Additional flexibility
        in DIT structure is available to the policy\n   administrator via LDAP aliasing
        and other techniques.  Previous\n   versions of this document have used aliases.
        \ However, because\n   aliases are experimental, the use of aliases has been
        removed from\n   this version of this document.  This is because the IETF
        has yet to\n   produce a specification on how aliases are represented in the\n
        \  directory or how server implementations are to process aliases.\n"
      title: 4.5.1.  Aliases and Other DIT-Optimization Techniques
    title: 4.5.  Location and Retrieval of Policy Objects in the Directory
  title: 4.  General Discussion of Mapping the Information Model to LDAP
- contents:
  - "5.  Class Definitions\n   The semantics for the policy information classes that
    are to be\n   mapped directly from the information model to an LDAP representation\n
    \  are detailed in [1].  Consequently, all that this document presents\n   for
    these classes is the specification for how to do the mapping from\n   the information
    model (which is independent of repository type and\n   access protocol) to a form
    that can be accessed using LDAP.  Remember\n   that some new classes needed to
    be created (that were not part of\n   [1]) to implement the LDAP mapping.  These
    new LDAP-only classes are\n   fully documented in this document.\n   The formal
    language for specifying the classes, attributes, and DIT\n   structure and content
    rules is that defined in reference [3].  If\n   your implementation does not support
    auxiliary class inheritance, you\n   will have to list auxiliary classes in content
    rules explicitly or\n   define them in another (implementation-specific) way.\n
    \  The following notes apply to this section in its entirety.\n   Note 1: in the
    following definitions, the class and attribute\n   definitions follow RFC 2252
    [3] but they are line-wrapped to enhance\n   human readability.\n   Note 2: where
    applicable, the possibilities for specifying DIT\n   structure and content rules
    are noted.  However, care must be taken\n   in specifying DIT structure rules.
    \ This is because X.501 [4] states\n   that an entry may only exist in the DIT
    as a subordinate to another\n   superior entry (the superior) if a DIT structure
    rule exists in the\n   governing subschema which:\n   1)  indicates a name form
    for the structural object class of the\n       subordinate entry, and\n   2)  either
    includes the entry's superior structure rule as a possible\n       superior structure
    rule, or\n   3)  does not specify a superior structure rule.\n   If this last
    case (3) applies, then the entry is defined to be a\n   subschema administrative
    point.  This is not what is desired.\n   Therefore, care must be taken in defining
    structure rules, and in\n   particular, they must be locally augmented.\n   Note
    3: Wherever possible, both an equality and a substring matching\n   rule are defined
    for a particular attribute (as well as an ordering\n   match rule to enable sorting
    of matching results).  This provides two\n   different choices for the developer
    for maximum flexibility.\n   For example, consider the pcimRoles attribute (section
    5.3).  Suppose\n   that a PEP has reported that it is interested in pcimRules
    for three\n   roles R1, R2, and R3.  If the goal is to minimize queries, then
    the\n   PDP can supply three substring filters containing the three role\n   names.\n
    \  These queries will return all of the pcimRules that apply to the PEP,\n   but
    they may also get some that do not apply (e.g., ones that contain\n   one of the
    roles R1, R2, or R3 and one or more other roles present in\n   a role-combination
    [1]).\n   Another strategy would be for the PDP to use only equality filters.\n
    \  This approach eliminates the extraneous replies, but it requires the\n   PDP
    to explicitly build the desired role-combinations itself.  It\n   also requires
    extra queries.  Note that this approach is practical\n   only because the role
    names in a role combination are required to\n   appear in alphabetical order.\n
    \  Note 4: in the following definitions, note that all LDAP matching\n   rules
    are defined in [3] and in [9].  The corresponding X.500\n   matching rules are
    defined in [8].\n   Note 5: some of the following attribute definitions specify\n
    \  additional constraints on various data types (e.g., this integer has\n   values
    that are valid  from 1..10).  Text has been added to instruct\n   servers and
    applications what to do if a value outside of this range\n   is encountered.  In
    all cases, if a constraint is violated, then the\n   policy rule SHOULD be treated
    as being disabled, meaning that\n   execution of the policy rule SHOULD be stopped.\n"
  - contents:
    - "5.1.  The Abstract Class pcimPolicy\n   The abstract class pcimPolicy is a
      direct mapping of the abstract\n   class Policy from the PCIM.  The class value
      \"pcimPolicy\" is also\n   used as the mechanism for identifying policy-related
      instances in the\n   Directory Information Tree.  An instance of any class may
      be \"tagged\"\n   with this class value by attaching to it the auxiliary class\n
      \  pcimElementAuxClass.  Since pcimPolicy is derived from the class\n   dlm1ManagedElement
      defined in reference [6], this specification has a\n   normative dependency
      on that element of reference [6].\n   The class definition is as follows:\n
      \      ( 1.3.6.1.1.6.1.1 NAME 'pcimPolicy'\n         DESC 'An abstract class
      that is the base class for all classes\n               that describe policy-related
      instances.'\n         SUP dlm1ManagedElement\n         ABSTRACT\n         MAY
      ( cn $ dlmCaption $ dlmDescription $ orderedCimKeys $\n               pcimKeywords
      )\n       )\n   The attribute cn is defined in RFC 2256 [7].  The dlmCaption,\n
      \  dlmDescription, and orderedCimKeys attributes are defined in [6].\n   The
      pcimKeywords attribute is a multi-valued attribute that contains\n   a set of
      keywords to assist directory clients in locating the policy\n   objects identified
      by these keywords.  It is defined as follows:\n       ( 1.3.6.1.1.6.2.3 NAME
      'pcimKeywords'\n              DESC 'A set of keywords to assist directory clients
      in\n                    locating the policy objects applicable to them.'\n              EQUALITY
      caseIgnoreMatch\n              ORDERING caseIgnoreOrderingMatch\n              SUBSTR
      caseIgnoreSubstringsMatch\n              SYNTAX 1.3.6.1.4.1.1466.115.121.1.15\n
      \      )\n"
    title: 5.1.  The Abstract Class pcimPolicy
  - contents:
    - "5.2.  The Three Policy Group Classes\n   PCIM [1] defines the PolicyGroup class
      to serve as a generalized\n   aggregation mechanism, enabling PolicyRules and/or
      PolicyGroups to be\n   aggregated together.  PCLS maps this class into three
      LDAP classes,\n   called pcimGroup, pcimGroupAuxClass, and pcimGroupInstance.
      \ This is\n   done in order to provide maximum flexibility for the DIT designer.\n
      \  The class definitions for the three policy group classes are listed\n   below.
      \ These class definitions do not include attributes to realize\n   the PolicyRuleInPolicyGroup
      and PolicyGroupInPolicyGroup associations\n   from the PCIM.  This is because
      a pcimGroup object refers to\n   instances of pcimGroup and pcimRule via, respectively,
      the attribute\n   pcimGroupsAuxContainedSet in the pcimGroupContainmentAuxClass
      object\n   class and the attribute pcimRulesAuxContainedSet in the\n   pcimRuleContainmentAuxClass
      object class.\n   To maximize flexibility, the pcimGroup class is defined as
      abstract.\n   The subclass pcimGroupAuxClass provides for auxiliary attachment
      to\n   another entry, while the structural subclass pcimGroupInstance is\n   available
      to represent a policy group as a standalone entry.\n   The class definitions
      are as follows.  First, the definition of the\n   abstract class pcimGroup:\n
      \      ( 1.3.6.1.1.6.1.2 NAME 'pcimGroup'\n              DESC 'A container for
      a set of related pcimRules and/or\n                    a set of related pcimGroups.'\n
      \             SUP pcimPolicy\n              ABSTRACT\n              MAY ( pcimGroupName
      )\n       )\n   The one attribute of pcimGroup is pcimGroupName.  This attribute
      is\n   used to define a user-friendly name of this policy group, and may be\n
      \  used as a naming attribute if desired.  It is defined as follows:\n       (
      1.3.6.1.1.6.2.4 NAME 'pcimGroupName'\n              DESC 'The user-friendly
      name of this policy group.'\n              EQUALITY caseIgnoreMatch\n              ORDERING
      caseIgnoreOrderingMatch\n              SUBSTR caseIgnoreSubstringsMatch\n              SYNTAX
      1.3.6.1.4.1.1466.115.121.1.15\n              SINGLE-VALUE\n       )\n   The
      two subclasses of pcimGroup are defined as follows.  The class\n   pcimGroupAuxClass
      is an auxiliary class that can be used to collect a\n   set of related pcimRule
      and/or pcimGroup classes.  It is defined as\n   follows:\n       ( 1.3.6.1.1.6.1.3
      NAME 'pcimGroupAuxClass'\n              DESC 'An auxiliary class that collects
      a set of related\n                    pcimRule and/or pcimGroup entries.'\n
      \             SUP pcimGroup\n              AUXILIARY\n       )\n   The class
      pcimGroupInstance is a structural class that can be used to\n   collect a set
      of related pcimRule and/or pcimGroup classes.  It is\n   defined as follows:\n
      \      ( 1.3.6.1.1.6.1.4 NAME 'pcimGroupInstance'\n              DESC 'A structural
      class that collects a set of related\n                    pcimRule and/or pcimGroup
      entries.'\n              SUP pcimGroup\n              STRUCTURAL\n       )\n
      \  A DIT content rule could be written to enable an instance of\n   pcimGroupInstance
      to have attached to it either references to one or\n   more policy groups (using
      pcimGroupContainmentAuxClass) or references\n   to one or more policy rules
      (using pcimRuleContainmentAuxClass).\n   This would be used to formalize the
      semantics of the PolicyGroup\n   class [1].  Since these semantics do not include
      specifying any\n   properties of the PolicyGroup class, the content rule would
      not need\n   to specify any attributes.\n   Similarly, three separate DIT structure
      rules could be written, each\n   of which would refer to a specific name form
      that identified one of\n   the three possible naming attributes (i.e., pcimGroupName,
      cn, and\n   orderedCIMKeys) for the pcimGroup object class.  This structure
      rule\n   SHOULD include a superiorStructureRule (see Note 2 at the beginning\n
      \  of section 5).  The three name forms referenced by the three\n   structure
      rules would each define one of the three naming attributes.\n"
    title: 5.2.  The Three Policy Group Classes
  - contents:
    - "5.3.  The Three Policy Rule Classes\n   The information model defines a PolicyRule
      class to represent the \"If\n   Condition then Action\" semantics associated
      with processing policy\n   information.  For maximum flexibility, the PCLS maps
      this class into\n   three LDAP classes.\n   To maximize flexibility, the pcimRule
      class is defined as abstract.\n   The subclass pcimRuleAuxClass provides for
      auxiliary attachment to\n   another entry, while the structural subclass pcimRuleInstance
      is\n   available to represent a policy rule as a standalone entry.\n   The conditions
      and actions associated with a policy rule are modeled,\n   respectively, with
      auxiliary subclasses of the auxiliary classes\n   pcimConditionAuxClass and
      pcimActionAuxClass.  Each of these\n   auxiliary subclasses is attached to an
      instance of one of three\n   structural classes.  A subclass of pcimConditionAuxClass
      is attached\n   to an instance of pcimRuleInstance, to an instance of\n   pcimRuleConditionAssociation,
      or to an instance of\n   pcimPolicyInstance.  Similarly, a subclass of pcimActionAuxClass
      is\n   attached to an instance of pcimRuleInstance, to an instance of\n   pcimRuleActionAssociation,
      or to an instance of pcimPolicyInstance.\n   The pcimRuleValidityPeriodList
      attribute (defined below) realizes the\n   PolicyRuleValidityPeriod association
      defined in the PCIM.  Since this\n   association has no additional properties
      besides those that tie the\n   association to its associated objects, this association
      can be\n   realized by simply using an attribute.  Thus, the\n   pcimRuleValidityPeriodList
      attribute is simply a multi-valued\n   attribute that provides an unordered
      set of DN references to one or\n   more instances of the pcimTPCAuxClass, indicating
      when the policy\n   rule is scheduled to be active and when it is scheduled
      to be\n   inactive.  A policy rule is scheduled to be active if it is active\n
      \  according to AT LEAST ONE of the pcimTPCAuxClass instances referenced\n   by
      this attribute.\n   The PolicyConditionInPolicyRule and PolicyActionInPolicyRule\n
      \  associations, however, do have additional attributes.  The\n   association
      PolicyActionInPolicyRule defines an integer attribute to\n   sequence the actions,
      and the association PolicyConditionInPolicyRule\n   has both an integer attribute
      to group the condition terms as well as\n   a Boolean property to specify whether
      a condition is to be negated.\n   In the PCLS, these additional association
      attributes are represented\n   as attributes of two classes introduced specifically
      to model these\n   associations.  These classes are the pcimRuleConditionAssociation\n
      \  class and the pcimRuleActionAssociation class, which are defined in\n   Sections
      5.4 and 5.5, respectively.  Thus, they do not appear as\n   attributes of the
      class pcimRule.  Instead, the pcimRuleConditionList\n   and pcimRuleActionList
      attributes can be used to reference these\n   classes.\n   The class definitions
      for the three pcimRule classes are as follows.\n   The abstract class pcimRule
      is a base class for representing the \"If\n   Condition then Action\" semantics
      associated with a policy rule.  It\n   is defined as follows:\n     ( 1.3.6.1.1.6.1.5
      NAME 'pcimRule'\n            DESC 'The base class for representing the \"If
      Condition\n                  then Action\" semantics associated with a policy
      rule.'\n            SUP pcimPolicy\n            ABSTRACT\n            MAY (
      pcimRuleName $ pcimRuleEnabled $\n                  pcimRuleConditionListType
      $ pcimRuleConditionList $\n                  pcimRuleActionList $ pcimRuleValidityPeriodList
      $\n                  pcimRuleUsage $ pcimRulePriority $\n                  pcimRuleMandatory
      $ pcimRuleSequencedActions $\n                  pcimRoles )\n     )\n   The
      PCIM [1] defines seven properties for the PolicyRule class.  The\n   PCLS defines
      eleven attributes for the pcimRule class, which is the\n   LDAP equivalent of
      the PolicyRule class.  Of these eleven attributes,\n   seven are mapped directly
      from corresponding properties in PCIM's\n   PolicyRule class.  The remaining
      four attributes are a class-specific\n   optional naming attribute, and three
      attributes used to realize the\n   three associations that the pcimRule class
      participates in.\n   The pcimRuleName attribute is used as a user-friendly name
      of this\n   policy rule, and can also serve as the class-specific optional naming\n
      \  attribute.  It is defined as follows:\n        ( 1.3.6.1.1.6.2.5 NAME 'pcimRuleName'\n
      \              DESC 'The user-friendly name of this policy rule.'\n               EQUALITY
      caseIgnoreMatch\n               ORDERING caseIgnoreOrderingMatch\n               SUBSTR
      caseIgnoreSubstringsMatch\n               SYNTAX 1.3.6.1.4.1.1466.115.121.1.15\n
      \              SINGLE-VALUE\n        )\n   The pcimRuleEnabled attribute is
      an integer enumeration indicating\n   whether a policy rule is administratively
      enabled (value=1),\n   administratively disabled (value=2), or enabled for debug
      (value=3).\n   It is defined as follows:\n        ( 1.3.6.1.1.6.2.6 NAME 'pcimRuleEnabled'\n
      \              DESC 'An integer indicating whether a policy rule is\n                     administratively
      enabled (value=1), disabled\n                     (value=2), or enabled for
      debug (value=3).'\n               EQUALITY integerMatch\n               ORDERING
      integerOrderingMatch\n               SYNTAX 1.3.6.1.4.1.1466.115.121.1.27\n
      \              SINGLE-VALUE\n        )\n   Note: All other values for the pcimRuleEnabled
      attribute are\n   considered errors, and the administrator SHOULD treat this
      rule as\n   being disabled if an invalid value is found.\n   The pcimRuleConditionListType
      attribute is used to indicate whether\n   the list of policy conditions associated
      with this policy rule is in\n   disjunctive normal form (DNF, value=1) or conjunctive
      normal form\n   (CNF, value=2).  It is defined as follows:\n     ( 1.3.6.1.1.6.2.7
      NAME 'pcimRuleConditionListType'\n            DESC 'A value of 1 means that
      this policy rule is in\n                  disjunctive normal form; a value of
      2 means that this\n                  policy rule is in conjunctive normal form.'\n
      \           EQUALITY integerMatch\n            ORDERING integerOrderingMatch\n
      \           SYNTAX 1.3.6.1.4.1.1466.115.121.1.27\n            SINGLE-VALUE\n
      \    )\n   Note: any value other than 1 or 2 for the pcimRuleConditionListType\n
      \  attribute is considered an error.  Administrators SHOULD treat this\n   rule
      as being disabled if an invalid value is found, since it is\n   unclear how
      to structure the condition list.\n   The pcimRuleConditionList attribute is
      a multi-valued attribute that\n   is used to realize the policyRuleInPolicyCondition
      association\n   defined in [1].  It contains a set of DNs of\n   pcimRuleConditionAssociation
      entries representing associations\n   between this policy rule and its conditions.
      \ No order is implied.\n   It is defined as follows:\n     ( 1.3.6.1.1.6.2.8
      NAME 'pcimRuleConditionList'\n            DESC 'Unordered set of DNs of pcimRuleConditionAssociation\n
      \                 entries representing associations between this policy\n                  rule
      and its conditions.'\n            EQUALITY distinguishedNameMatch\n            SYNTAX
      1.3.6.1.4.1.1466.115.121.1.12\n     )\n   The pcimRuleActionList attribute is
      a multi-valued attribute that is\n   used to realize the policyRuleInPolicyAction
      association defined in\n   [1].  It contains a set of DNs of pcimRuleActionAssociation
      entries\n   representing associations between this policy rule and its actions.\n
      \  No order is implied.  It is defined as follows:\n     ( 1.3.6.1.1.6.2.9 NAME
      'pcimRuleActionList'\n            DESC 'Unordered set of DNs of pcimRuleActionAssociation\n
      \                 entries representing associations between this policy\n                  rule
      and its actions.'\n           EQUALITY distinguishedNameMatch\n           SYNTAX
      1.3.6.1.4.1.1466.115.121.1.12\n     )\n   The pcimRuleValidityPeriodList attribute
      is a multi-valued attribute\n   that is used to realize the pcimRuleValidityPeriod
      association that\n   is defined in [1].  It contains a set of DNs of\n   pcimRuleValidityAssociation
      entries that determine when the pcimRule\n   is scheduled to be active or inactive.
      \ No order is implied.  It is\n   defined as follows:\n     ( 1.3.6.1.1.6.2.10
      NAME 'pcimRuleValidityPeriodList'\n            DESC 'Unordered set of DNs of
      pcimRuleValidityAssociation\n                  entries that determine when the
      pcimRule is scheduled\n                  to be active or inactive.'\n            EQUALITY
      distinguishedNameMatch\n            SYNTAX 1.3.6.1.4.1.1466.115.121.1.12\n     )\n
      \  The pcimRuleUsage attribute is a free-form string providing\n   guidelines
      on how this policy should be used.  It is defined as\n   follows:\n     ( 1.3.6.1.1.6.2.11
      NAME 'pcimRuleUsage'\n            DESC 'This attribute is a free-form sting
      providing\n                  guidelines on how this policy should be used.'\n
      \           EQUALITY caseIgnoreMatch\n            ORDERING caseIgnoreOrderingMatch\n
      \           SUBSTR caseIgnoreSubstringsMatch\n            SYNTAX 1.3.6.1.4.1.1466.115.121.1.15\n
      \           SINGLE-VALUE\n     )\n   The pcimRulePriority attribute is a non-negative
      integer that is used\n   to prioritize this pcimRule relative to other pcimRules.
      \ A larger\n   value indicates a higher priority.  It is defined as follows:\n
      \    ( 1.3.6.1.1.6.2.12 NAME 'pcimRulePriority'\n            DESC 'A non-negative
      integer for prioritizing this\n                  pcimRule relative to other
      pcimRules.  A larger\n                  value indicates a higher priority.'\n
      \           EQUALITY integerMatch\n            ORDERING integerOrderingMatch\n
      \           SYNTAX 1.3.6.1.4.1.1466.115.121.1.27\n            SINGLE-VALUE\n
      \    )\n   Note: if the value of the pcimRulePriority field is 0, then it SHOULD\n
      \  be treated as \"don't care\".  On the other hand, if the value is\n   negative,
      then it SHOULD be treated as an error and Administrators\n   SHOULD treat this
      rule as being disabled.\n   The pcimRuleMandatory attribute is a Boolean attribute
      that, if TRUE,\n   indicates that for this policy rule, the evaluation of its
      conditions\n   and execution of its actions (if the condition is satisfied)
      is\n   required.  If it is FALSE, then the evaluation of its conditions and\n
      \  execution of its actions (if the condition is satisfied) is not\n   required.
      \ This attribute is defined as follows:\n     ( 1.3.6.1.1.6.2.13 NAME 'pcimRuleMandatory'\n
      \           DESC 'If TRUE, indicates that for this policy rule, the\n                  evaluation
      of its conditions and execution of its\n                  actions (if the condition
      is satisfied) is required.'\n            EQUALITY booleanMatch\n            SYNTAX
      1.3.6.1.4.1.1466.115.121.1.7\n            SINGLE-VALUE\n     )\n   The pcimRuleSequencedActions
      attribute is an integer enumeration that\n   is used to indicate that the ordering
      of actions defined by the\n   pcimActionOrder attribute is either  mandatory(value=1),\n
      \  recommended(value=2), or dontCare(value=3).  It is defined as\n   follows:\n
      \    ( 1.3.6.1.1.6.2.14 NAME 'pcimRuleSequencedActions'\n            DESC 'An
      integer enumeration indicating that the ordering of\n                  actions
      defined by the pcimActionOrder attribute is\n                  mandatory(1),
      recommended(2), or dontCare(3).'\n            EQUALITY integerMatch\n            ORDERING
      integerOrderingMatch\n            SYNTAX 1.3.6.1.4.1.1466.115.121.1.27\n            SINGLE-VALUE\n
      \    )\n   Note: if the value of pcimRulesSequencedActions field is not one
      of\n   these three values, then Administrators SHOULD treat this rule as\n   being
      disabled.\n   The pcimRoles attribute represents the policyRoles property of
      [1].\n   Each value of this attribute represents a role-combination, which is\n
      \  a string of the form:\n       <RoleName>[&&<RoleName>]* where the individual
      role names appear\n   in alphabetical order according to the collating sequence
      for UCS-2.\n   This attribute is defined as follows:\n     ( 1.3.6.1.1.6.2.15
      NAME 'pcimRoles'\n            DESC 'Each value of this attribute represents
      a role-\n                  combination.'\n            EQUALITY caseIgnoreMatch\n
      \           ORDERING caseIgnoreOrderingMatch\n            SUBSTR caseIgnoreSubstringsMatch\n
      \           SYNTAX 1.3.6.1.4.1.1466.115.121.1.15\n     )\n   Note: if the value
      of the pcimRoles attribute does not conform to the\n   format \"<RoleName>[&&<RoleName>]*\"
      (see Section 6.3.7 of [1]), then\n   this attribute is malformed and its policy
      rule SHOULD be treated as\n   being disabled.\n   The two subclasses of the
      pcimRule class are defined as follows.\n   First, the pcimRuleAuxClass is an
      auxiliary class for representing\n   the \"If Condition then Action\" semantics
      associated with a policy\n   rule.  Its class definition is as follows:\n     (
      1.3.6.1.1.6.1.6 NAME 'pcimRuleAuxClass'\n            DESC 'An auxiliary class
      for representing the \"If Condition\n                 then Action\" semantics
      associated with a policy rule.'\n            SUP pcimRule\n            AUXILIARY\n
      \    )\n   The pcimRuleInstance is a structural class for representing the \"If\n
      \  Condition then Action\" semantics associated with a policy rule.  Its\n   class
      definition is as follows:\n     ( 1.3.6.1.1.6.1.7 NAME 'pcimRuleInstance'\n
      \           DESC 'A structural class for representing the \"If Condition\n                 then
      Action\" semantics associated with a policy rule.'\n            SUP pcimRule\n
      \           STRUCTURAL\n     )\n   A DIT content rule could be written to enable
      an instance of\n   pcimRuleInstance to have attached to it either references
      to one or\n   more policy conditions (using pcimConditionAuxClass) or references
      to\n   one or more policy actions (using pcimActionAuxClass).  This would be\n
      \  used to formalize the semantics of the PolicyRule class [1].  Since\n   these
      semantics do not include specifying any properties of the\n   PolicyRule class,
      the content rule would not need to specify any\n   attributes.\n   Similarly,
      three separate DIT structure rules could be written, each\n   of which would
      refer to a specific name form that identified one of\n   its three possible
      naming attributes (i.e., pcimRuleName, cn, and\n   orderedCIMKeys).  This structure
      rule SHOULD include a\n   superiorStructureRule (see Note 2 at the beginning
      of section 5).\n   The three name forms referenced by the three structure rules
      would\n   each define one of the three naming attributes.\n"
    title: 5.3.  The Three Policy Rule Classes
  - contents:
    - "5.4.  The Class pcimRuleConditionAssociation\n   This class contains attributes
      to represent the properties of the\n   PCIM's PolicyConditionInPolicyRule association.
      \ Instances of this\n   class are related to an instance of pcimRule via DIT
      containment.\n   The policy conditions themselves are represented by auxiliary\n
      \  subclasses of the auxiliary class pcimConditionAuxClass.  These\n   auxiliary
      classes are attached directly to instances of\n   pcimRuleConditionAssociation
      for rule-specific policy conditions.\n   For a reusable policy condition, the
      policyCondition auxiliary\n   subclass is attached to an instance of the class
      pcimPolicyInstance\n   (which is presumably associated with a pcimRepository
      by DIT\n   containment), and the policyConditionDN attribute (of this class)
      is\n   used to reference the reusable policyCondition instance.\n   The class
      definition is as follows:\n     ( 1.3.6.1.1.6.1.8 NAME 'pcimRuleConditionAssociation'\n
      \           DESC 'This class contains attributes characterizing the\n                  relationship
      between a policy rule and one of its\n                  policy conditions.'\n
      \           SUP pcimPolicy\n            MUST ( pcimConditionGroupNumber $ pcimConditionNegated
      )\n            MAY ( pcimConditionName $ pcimConditionDN )\n     )\n   The attributes
      of this class are defined as follows.\n   The pcimConditionGroupNumber attribute
      is a non-negative integer.  It\n   is used to identify the group to which the
      condition referenced by\n   this association is assigned.  This attribute is
      defined as follows:\n     ( 1.3.6.1.1.6.2.16\n            NAME 'pcimConditionGroupNumber'\n
      \           DESC 'The number of the group to which a policy condition\n                  belongs.
      \ This is used to form the DNF or CNF\n                  expression associated
      with a policy rule.'\n            EQUALITY integerMatch\n            ORDERING
      integerOrderingMatch\n            SYNTAX 1.3.6.1.4.1.1466.115.121.1.27\n            SINGLE-VALUE\n
      \    )\n   Note that this number is non-negative.  A negative value for this\n
      \  attribute is invalid, and any policy rule that refers to an invalid\n   entry
      SHOULD be treated as being disabled.\n   The pcimConditionNegated attribute
      is a Boolean attribute that\n   indicates whether this policy condition is to
      be negated or not.  If\n   it is TRUE (FALSE), it indicates that a policy condition
      IS (IS NOT)\n   negated in the DNF or CNF expression associated with a policy
      rule.\n   This attribute is defined as follows:\n     ( 1.3.6.1.1.6.2.17\n            NAME
      'pcimConditionNegated'\n            DESC 'If TRUE (FALSE), it indicates that
      a policy condition\n                  IS (IS NOT) negated in the DNF or CNF
      expression\n                  associated with a policy rule.'\n            EQUALITY
      booleanMatch\n            SYNTAX 1.3.6.1.4.1.1466.115.121.1.7\n            SINGLE-VALUE\n
      \    )\n   The pcimConditionName is a user-friendly name for identifying this\n
      \  policy condition, and may be used as a naming attribute if desired.\n   This
      attribute is defined as follows:\n     ( 1.3.6.1.1.6.2.18\n            NAME
      'pcimConditionName'\n            DESC 'A user-friendly name for a policy condition.'\n
      \           EQUALITY caseIgnoreMatch\n            ORDERING caseIgnoreOrderingMatch\n
      \           SUBSTR caseIgnoreSubstringsMatch\n            SYNTAX 1.3.6.1.4.1.1466.115.121.1.15\n
      \           SINGLE-VALUE\n     )\n   The pcimConditionDN attribute is a DN that
      references an instance of\n   a reusable policy condition.  This attribute is
      defined as follows:\n     ( 1.3.6.1.1.6.2.19\n            NAME 'pcimConditionDN'\n
      \           DESC 'A DN that references an instance of a reusable policy\n                  condition.'\n
      \           EQUALITY distinguishedNameMatch\n            SYNTAX 1.3.6.1.4.1.1466.115.121.1.12\n
      \           SINGLE-VALUE\n     )\n   A DIT content rule could be written to
      enable an instance of\n   pcimRuleConditionAssociation to have attached to it
      an instance of\n   the auxiliary class pcimConditionAuxClass, or one of its
      subclasses.\n   This would be used to formalize the semantics of the\n   PolicyConditionInPolicyRule
      association.  Specifically, this would be\n   used to represent a rule-specific
      policy condition [1].\n   Similarly, three separate DIT structure rules could
      be written.  Each\n   of these DIT structure rules would refer to a specific
      name form that\n   defined two important semantics.  First, each name form would\n
      \  identify one of the three possible naming attributes (i.e.,\n   pcimConditionName,
      cn, and orderedCIMKeys) for the\n   pcimRuleConditionAssociation object class.
      \ Second, each name form\n   would require that an instance of the pcimRuleConditionAssociation\n
      \  class have as its superior an instance of the pcimRule class.  This\n   structure
      rule SHOULD also include a superiorStructureRule (see Note\n   2 at the beginning
      of section 5).\n"
    title: 5.4.  The Class pcimRuleConditionAssociation
  - contents:
    - "5.5.  The Class pcimRuleValidityAssociation\n   The policyRuleValidityPeriod
      aggregation is mapped to the PCLS\n   pcimRuleValidityAssociation class.  This
      class represents the\n   scheduled activation and deactivation of a policy rule
      by binding the\n   definition of times that the policy is active to the policy
      rule\n   itself.  The \"scheduled\" times are either identified through an\n
      \  attached auxiliary class pcimTPCAuxClass, or are referenced through\n   its
      pcimTimePeriodConditionDN attribute.\n   This class is defined as follows:\n
      \    ( 1.3.6.1.1.6.1.9 NAME 'pcimRuleValidityAssociation'\n           DESC 'This
      defines the scheduled activation or deactivation\n                 of a policy
      rule.'\n           SUP pcimPolicy\n           STRUCTURAL\n           MAY ( pcimValidityConditionName
      $ pcimTimePeriodConditionDN )\n     )\n   The attributes of this class are defined
      as follows:\n   The pcimValidityConditionName attribute is used to define a\n
      \  user-friendly name of this condition, and may be used as a naming\n   attribute
      if desired.  This attribute is defined as follows:\n     ( 1.3.6.1.1.6.2.20\n
      \           NAME 'pcimValidityConditionName'\n            DESC 'A user-friendly
      name for identifying an instance of\n                  a pcimRuleValidityAssociation
      entry.'\n            EQUALITY caseIgnoreMatch\n            ORDERING caseIgnoreOrderingMatch\n
      \           SUBSTR caseIgnoreSubstringsMatch\n            SYNTAX 1.3.6.1.4.1.1466.115.121.1.15\n
      \           SINGLE-VALUE\n     )\n   The pcimTimePeriodConditionDN attribute
      is a DN that references a\n   reusable time period condition.  It is defined
      as follows:\n     ( 1.3.6.1.1.6.2.21\n            NAME 'pcimTimePeriodConditionDN'\n
      \            DESC 'A reference to a reusable policy time period\n                   condition.'\n
      \           EQUALITY distinguishedNameMatch\n            SYNTAX 1.3.6.1.4.1.1466.115.121.1.12\n
      \           SINGLE-VALUE\n     )\n   A DIT content rule could be written to
      enable an instance of\n   pcimRuleValidityAssociation to have attached to it
      an instance of the\n   auxiliary class pcimTPCAuxClass, or one of its subclasses.
      \ This\n   would be used to formalize the semantics of the\n   PolicyRuleValidityPeriod
      aggregation [1].\n   Similarly, three separate DIT structure rules could be
      written.  Each\n   of these DIT structure rules would refer to a specific name
      form that\n   defined two important semantics.  First, each name form would\n
      \  identify one of the three possible naming attributes (i.e.,\n   pcimValidityConditionName,
      cn, and orderedCIMKeys) for the\n   pcimRuleValidityAssociation object class.
      \ Second, each name form\n   would require that an instance of the pcimRuleValidityAssociation\n
      \  class have as its superior an instance of the pcimRule class.  This\n   structure
      rule SHOULD also include a superiorStructureRule (see Note\n   2 at the beginning
      of section 5).\n"
    title: 5.5.  The Class pcimRuleValidityAssociation
  - contents:
    - "5.6.  The Class pcimRuleActionAssociation\n   This class contains an attribute
      to represent the one property of the\n   PCIM PolicyActionInPolicyRule association,
      ActionOrder.  This\n   property is used to specify an order for executing the
      actions\n   associated with a policy rule.  Instances of this class are related\n
      \  to an instance of pcimRule via DIT containment.  The actions\n   themselves
      are represented by auxiliary subclasses of the auxiliary\n   class pcimActionAuxClass.\n
      \  These auxiliary classes are attached directly to instances of\n   pcimRuleActionAssociation
      for rule-specific policy actions.  For a\n   reusable policy action, the pcimAction
      auxiliary subclass is attached\n   to an instance of the class pcimPolicyInstance
      (which is presumably\n   associated with a pcimRepository by DIT containment),
      and the\n   pcimActionDN attribute (of this class) is used to reference the\n
      \  reusable pcimCondition instance.\n   The class definition is as follows:\n
      \    ( 1.3.6.1.1.6.1.10 NAME 'pcimRuleActionAssociation'\n            DESC 'This
      class contains attributes characterizing the\n                  relationship
      between a policy rule and one of its\n                  policy actions.'\n            SUP
      pcimPolicy\n            MUST ( pcimActionOrder )\n            MAY ( pcimActionName
      $ pcimActionDN )\n     )\n   The pcimActionName attribute is used to define
      a user-friendly name\n   of this action, and may be used as a naming attribute
      if desired.\n   This attribute is defined as follows:\n     ( 1.3.6.1.1.6.2.22\n
      \           NAME 'pcimActionName'\n            DESC 'A user-friendly name for
      a policy action.'\n            EQUALITY caseIgnoreMatch\n            ORDERING
      caseIgnoreOrderingMatch\n            SUBSTR caseIgnoreSubstringsMatch\n            SYNTAX
      1.3.6.1.4.1.1466.115.121.1.15\n            SINGLE-VALUE\n     )\n   The pcimActionOrder
      attribute is an unsigned integer that is used to\n   indicate the relative position
      of an action in a sequence of actions\n   that are associated with a given policy
      rule.  When this number is\n   positive, it indicates a place in the sequence
      of actions to be\n   performed, with smaller values indicating earlier positions
      in the\n   sequence.  If the value is zero, then this indicates that the order\n
      \  is irrelevant.  Note that if two or more actions have the same\n   non-zero
      value, they may be performed in any order as long as they\n   are each performed
      in the correct place in the overall sequence of\n   actions.  This attribute
      is defined as follows:\n     ( 1.3.6.1.1.6.2.23\n            NAME 'pcimActionOrder'\n
      \           DESC 'An integer indicating the relative order of an action\n                  in
      the context of a policy rule.'\n            EQUALITY integerMatch\n            ORDERING
      integerOrderingMatch\n            SYNTAX 1.3.6.1.4.1.1466.115.121.1.27\n            SINGLE-VALUE\n
      \    )\n   Note: if the value of the pcimActionOrder field is negative, then
      it\n   SHOULD be treated as an error and any policy rule that refers to such\n
      \  an entry SHOULD be treated as being disabled.\n   The pcimActionDN attribute
      is a DN that references a reusable policy\n   action.  It is defined as follows:\n
      \    ( 1.3.6.1.1.6.2.24\n            NAME 'pcimActionDN'\n            DESC 'A
      DN that references a reusable policy action.'\n            EQUALITY distinguishedNameMatch\n
      \           SYNTAX 1.3.6.1.4.1.1466.115.121.1.12\n            SINGLE-VALUE\n
      \    )\n   A DIT content rule could be written to enable an instance of\n   pcimRuleActionAssociation
      to have attached to it an instance of the\n   auxiliary class pcimActionAuxClass,
      or one of its subclasses.  This\n   would be used to formalize the semantics
      of the\n   PolicyActionInPolicyRule association.  Specifically, this would be\n
      \  used to represent a rule-specific policy action [1].\n   Similarly, three
      separate DIT structure rules could be written.  Each\n   of these DIT structure
      rules would refer to a specific name form that\n   defined two important semantics.
      \ First, each name form would\n   identify one of the three possible naming
      attributes (i.e.,\n   pcimActionName, cn, and orderedCIMKeys) for the\n   pcimRuleActionAssociation
      object class.  Second, each name form would\n   require that an instance of
      the pcimRuleActionAssociation class have\n   as its superior an instance of
      the pcimRule class.  This structure\n   rule should also include a superiorStructureRule
      (see Note 2 at the\n   beginning of section 5).\n"
    title: 5.6.  The Class pcimRuleActionAssociation
  - contents:
    - "5.7.  The Auxiliary Class pcimConditionAuxClass\n   The purpose of a policy
      condition is to determine whether or not the\n   set of actions (contained in
      the pcimRule that the condition applies\n   to) should be executed or not.  This
      class defines the basic\n   organizational semantics of a policy condition,
      as specified in [1].\n   Subclasses of this auxiliary class can be attached
      to instances of\n   three other classes in the PCLS.  When a subclass of this
      class is\n   attached to an instance of pcimRuleConditionAssociation, or to
      an\n   instance of pcimRule, it represents a rule-specific policy condition.\n
      \  When a subclass of this class is attached to an instance of\n   pcimPolicyInstance,
      it represents a reusable policy condition.\n   Since all of the classes to which
      subclasses of this auxiliary class\n   may be attached are derived from the
      pcimPolicy class, the attributes\n   of pcimPolicy will already be defined for
      the entries to which these\n   subclasses attach.  Thus, this class is derived
      directly from \"top\".\n   The class definition is as follows:\n     ( 1.3.6.1.1.6.1.11
      NAME 'pcimConditionAuxClass'\n            DESC 'A class representing a condition
      to be evaluated in\n                  conjunction with a policy rule.'\n            SUP
      top\n            AUXILIARY\n     )\n"
    title: 5.7.  The Auxiliary Class pcimConditionAuxClass
  - contents:
    - "5.8.  The Auxiliary Class pcimTPCAuxClass\n   The PCIM defines a time period
      class, PolicyTimePeriodCondition, to\n   provide a means of representing the
      time periods during which a\n   policy rule is valid, i.e., active.  It also
      defines an aggregation,\n   PolicyRuleValidityPeriod, so that time periods can
      be associated with\n   a PolicyRule.  The LDAP mapping also provides two classes,
      one for\n   the time condition itself, and one for the aggregation.\n   In the
      PCIM, the time period class is named\n   PolicyTimePeriodCondition. However,
      the resulting name of the\n   auxiliary class in this mapping (pcimTimePeriodConditionAuxClass)\n
      \  exceeds the length of a name that some directories can store.\n   Therefore,
      the name has been shortened to pcimTPCAuxClass.\n   The class definition is
      as follows:\n     ( 1.3.6.1.1.6.1.12 NAME 'pcimTPCAuxClass'\n            DESC
      'This provides the capability of enabling or disabling\n                  a
      policy rule according to a predetermined schedule.'\n            SUP pcimConditionAuxClass\n
      \           AUXILIARY\n            MAY ( pcimTPCTime $ pcimTPCMonthOfYearMask
      $\n                  pcimTPCDayOfMonthMask $ pcimTPCDayOfWeekMask $\n                  pcimTPCTimeOfDayMask
      $ pcimTPCLocalOrUtcTime )\n     )\n   The attributes of the pcimTPCAuxClass
      are defined as follows.\n   The pcimTPCTime attribute represents the time period
      that a policy\n   rule is enabled for.  This attribute is defined as a string
      in [1]\n   with a special format which defines a time period with a starting\n
      \  date and an ending date separated by a forward slash (\"/\"), as\n   follows:\n
      \      yyyymmddThhmmss/yyyymmddThhmmss\n   where the first date and time may
      be replaced with the string\n   \"THISANDPRIOR\" or the second date and time
      may be replaced with the\n   string \"THISANDFUTURE\".  This attribute is defined
      as follows:\n        ( 1.3.6.1.1.6.2.25\n               NAME 'pcimTPCTime'\n
      \              DESC 'The start and end times on which a policy rule is\n                     valid.'\n
      \              EQUALITY caseIgnoreMatch\n               ORDERING caseIgnoreOrderingMatch\n
      \              SUBSTR caseIgnoreSubstringsMatch\n               SYNTAX 1.3.6.1.4.1.1466.115.121.1.44\n
      \              SINGLE-VALUE\n        )\n   The value of this attribute SHOULD
      be checked against its defined\n   format (\"yyyymmddThhmmss/yyyymmddThhmmss\",
      where the first and second\n   date strings may be replaced with the strings
      \"THISANDPRIOR\" and\n   \"THISANDFUTURE\").  If the value of this attribute
      does not conform to\n   this syntax, then this SHOULD be considered an error
      and the policy\n   rule SHOULD be treated as being disabled.\n   The next four
      attributes (pcimTPCMonthOfYearMask,\n   pcimTPCDayOfMonthMask, pcimTPCDayOfWeekMask,
      and\n   pcimTPCTimeOfDayMask) are all defined as octet strings in [1].\n   However,
      the semantics of each of these attributes are contained in\n   bit strings of
      various fixed lengths.  Therefore, the PCLS uses a\n   syntax of Bit String
      to represent each of them.  The definition of\n   these four attributes are
      as follows.\n   The pcimTPCMonthOfYearMask attribute defines a 12-bit mask\n
      \  identifying the months of the year in which a policy rule is valid.\n   The
      format is a bit string of length 12, representing the months of\n   the year
      from January through December.  The definition of this\n   attribute is as follows:\n
      \    ( 1.3.6.1.1.6.2.26\n            NAME 'pcimTPCMonthOfYearMask'\n            DESC
      'This identifies the valid months of the year for a\n                  policy
      rule using a 12-bit string that represents the\n                  months of
      the year from January through December.'\n            EQUALITY bitStringMatch\n
      \           SYNTAX 1.3.6.1.4.1.1466.115.121.1.6\n            SINGLE-VALUE\n
      \    )\n   The value of this attribute SHOULD be checked against its defined\n
      \  format.  If the value of this attribute does not conform to this\n   syntax,
      then this SHOULD be considered an error and the policy rule\n   SHOULD be treated
      as being disabled.\n   The pcimTPCMonthOfDayMask attribute defines a mask identifying
      the\n   days of the month on which a policy rule is valid.  The format is a\n
      \  bit string of length 62.  The first 31 positions represent the days\n   of
      the month in ascending order, from day 1 to day 31.  The next 31\n   positions
      represent the days of the month in descending order, from\n   the last day to
      the day 31 days from the end.  The definition of this\n   attribute is as follows:\n
      \    ( 1.3.6.1.1.6.2.27\n            NAME 'pcimTPCDayOfMonthMask'\n            DESC
      'This identifies the valid days of the month for a\n                  policy
      rule using a 62-bit string. The first 31\n                  positions represent
      the days of the month in ascending\n                  order, and the next 31
      positions represent the days of\n                  the month in descending order.'\n
      \           EQUALITY bitStringMatch\n            SYNTAX 1.3.6.1.4.1.1466.115.121.1.6\n
      \           SINGLE-VALUE\n     )\n   The value of this attribute SHOULD be checked
      against its defined\n   format.  If the value of this attribute does not conform
      to this\n   syntax, then this SHOULD be considered an error and the policy rule\n
      \  SHOULD be treated as being disabled.\n   The pcimTPCDayOfWeekMask attribute
      defines a mask identifying the\n   days of the week on which a policy rule is
      valid.  The format is a\n   bit string of length 7, representing the days of
      the week from Sunday\n   through Saturday.  The definition of this attribute
      is as follows:\n     ( 1.3.6.1.1.6.2.28\n            NAME 'pcimTPCDayOfWeekMask'\n
      \           DESC 'This identifies the valid days of the week for a\n                  policy
      rule using a 7-bit string. This represents\n                  the days of the
      week from Sunday through Saturday.'\n            EQUALITY bitStringMatch\n            SYNTAX
      1.3.6.1.4.1.1466.115.121.1.6\n            SINGLE-VALUE\n     )\n   The value
      of this attribute SHOULD be checked against its defined\n   format.  If the
      value of this attribute does not conform to this\n   syntax, then this SHOULD
      be considered an error and the policy rule\n   SHOULD be treated as being disabled.\n
      \  The pcimTPCTimeOfDayMask attribute defines the range of times at\n   which
      a policy rule is valid.  If the second time is earlier than the\n   first, then
      the interval spans midnight.  The format of the string is\n   Thhmmss/Thhmmss.
      \ The definition of this attribute is as follows:\n     ( 1.3.6.1.1.6.2.29\n
      \           NAME 'pcimTPCTimeOfDayMask'\n            DESC 'This identifies the
      valid range of times for a policy\n                  using the format Thhmmss/Thhmmss.'\n
      \           EQUALITY caseIgnoreMatch\n            ORDERING caseIgnoreOrderingMatch\n
      \           SUBSTR caseIgnoreSubstringsMatch\n            SYNTAX 1.3.6.1.4.1.1466.115.121.1.44\n
      \           SINGLE-VALUE\n     )\n   The value of this attribute SHOULD be checked
      against its defined\n   format.  If the value of this attribute does not conform
      to this\n   syntax, then this SHOULD be considered an error and the policy rule\n
      \  SHOULD be treated as being disabled.\n   Finally, the pcimTPCLocalOrUtcTime
      attribute is used to choose\n   between local or UTC time representation.  This
      is mapped as a simple\n   integer syntax, with the value of 1 representing local
      time and the\n   value of 2 representing UTC time.  The definition of this attribute\n
      \  is as follows:\n     ( 1.3.6.1.1.6.2.30\n            NAME 'pcimTPCLocalOrUtcTime'\n
      \           DESC 'This defines whether the times in this instance\n                  represent
      local (value=1) times or UTC (value=2)\n                  times.'\n            EQUALITY
      integerMatch\n            ORDERING integerOrderingMatch\n            SYNTAX
      1.3.6.1.4.1.1466.115.121.1.27\n            SINGLE-VALUE\n     )\n   Note: if
      the value of the pcimTPCLocalOrUtcTime is not 1 or 2, then\n   this SHOULD be
      considered an error and the policy rule SHOULD be\n   disabled. If the attribute
      is not present at all, then all times are\n   interpreted as if it were present
      with the value 2, that is, UTC\n   time.\n"
    title: 5.8.  The Auxiliary Class pcimTPCAuxClass
  - contents:
    - "5.9.  The Auxiliary Class pcimConditionVendorAuxClass\n   This class provides
      a general extension mechanism for representing\n   policy conditions that have
      not been modeled with specific\n   properties. Instead, its two properties are
      used to define the\n   content and format of the condition, as explained below.
      \ This class\n   is intended for vendor-specific extensions that are not amenable
      to\n   using pcimCondition; standardized extensions SHOULD NOT use this\n   class.\n
      \  The class definition is as follows:\n     ( 1.3.6.1.1.6.1.13 NAME 'pcimConditionVendorAuxClass'\n
      \           DESC 'A class that defines a registered means to describe a\n                  policy
      condition.'\n            SUP pcimConditionAuxClass\n            AUXILIARY\n
      \           MAY ( pcimVendorConstraintData $\n                 pcimVendorConstraintEncoding
      )\n     )\n   The pcimVendorConstraintData attribute is a multi-valued attribute.\n
      \  It provides a general mechanism for representing policy conditions\n   that
      have not been modeled as specific attributes.  This information\n   is encoded
      in a set of octet strings.  The format of the octet\n   strings is identified
      by the OID stored in the\n   pcimVendorConstraintEncoding attribute.  This attribute
      is defined as\n   follows:\n     ( 1.3.6.1.1.6.2.31\n            NAME 'pcimVendorConstraintData'\n
      \           DESC 'Mechanism for representing constraints that have not\n                  been
      modeled as specific attributes.  Their format is\n                  identified
      by the OID stored in the attribute\n                  pcimVendorConstraintEncoding.'\n
      \           EQUALITY octetStringMatch\n            ORDERING octetStringOrderingMatch\n
      \           SYNTAX 1.3.6.1.4.1.1466.115.121.1.40\n     )\n   The pcimVendorConstraintEncoding
      attribute is used to identify the\n   format and semantics for the pcimVendorConstraintData
      attribute.\n   This attribute is defined as follows:\n     ( 1.3.6.1.1.6.2.32\n
      \           NAME 'pcimVendorConstraintEncoding'\n            DESC 'An OID identifying
      the format and semantics for the\n                  pcimVendorConstraintData
      for this instance.'\n            EQUALITY objectIdentifierMatch\n            SYNTAX
      1.3.6.1.4.1.1466.115.121.1.38\n            SINGLE-VALUE\n     )\n"
    title: 5.9.  The Auxiliary Class pcimConditionVendorAuxClass
  - contents:
    - "5.10.  The Auxiliary Class pcimActionAuxClass\n   The purpose of a policy action
      is to execute one or more operations\n   that will affect network traffic and/or
      systems, devices, etc. in\n   order to achieve a desired policy state.  This
      class is used to\n   represent an action to be performed as a result of a policy
      rule\n   whose condition clause was satisfied.\n   Subclasses of this auxiliary
      class can be attached to instances of\n   three other classes in the PCLS.  When
      a subclass of this class is\n   attached to an instance of pcimRuleActionAssociation,
      or to an\n   instance of pcimRule, it represents a rule-specific policy action.\n
      \  When a subclass of this class is attached to an instance of\n   pcimPolicyInstance,
      it represents a reusable policy action.\n   Since all of the classes to which
      subclasses of this auxiliary class\n   may be attached are derived from the
      pcimPolicy class, the attributes\n   of the pcimPolicy class will already be
      defined for the entries to\n   which these subclasses attach.  Thus, this class
      is derived directly\n   from \"top\".\n   The class definition is as follows:\n
      \    ( 1.3.6.1.1.6.1.14 NAME 'pcimActionAuxClass'\n            DESC 'A class
      representing an action to be performed as a\n                  result of a policy
      rule.'\n            SUP top\n            AUXILIARY\n     )\n"
    title: 5.10.  The Auxiliary Class pcimActionAuxClass
  - contents:
    - "5.11.  The Auxiliary Class pcimActionVendorAuxClass\n   The purpose of this
      class is to provide a general extension mechanism\n   for representing policy
      actions that have not been modeled with\n   specific properties.  Instead, its
      two properties are used to define\n   the content and format of the action,
      as explained below.\n   As its name suggests, this class is intended for vendor-specific\n
      \  extensions that are not amenable to using the standard pcimAction\n   class.
      \ Standardized extensions SHOULD NOT use this class.\n   The class definition
      is as follows:\n     ( 1.3.6.1.1.6.1.15 NAME 'pcimActionVendorAuxClass'\n            DESC
      'A class that defines a registered means to describe a\n                  policy
      action.'\n            SUP pcimActionAuxClass\n            AUXILIARY\n            MAY
      ( pcimVendorActionData $ pcimVendorActionEncoding )\n     )\n   The pcimVendorActionData
      attribute is a multi-valued attribute.  It\n   provides a general mechanism
      for representing policy actions that\n   have not been modeled as specific attributes.
      \ This information is\n   encoded in a set of octet strings.  The format of
      the octet strings\n   is identified by the OID stored in the pcimVendorActionEncoding\n
      \  attribute.  This attribute is defined as follows:\n     ( 1.3.6.1.1.6.2.33\n
      \           NAME 'pcimVendorActionData'\n            DESC ' Mechanism for representing
      policy actions that have\n                   not been modeled as specific attributes.
      \ Their\n                   format is identified by the OID stored in the\n
      \                  attribute pcimVendorActionEncoding.'\n            EQUALITY
      octetStringMatch\n            ORDERING octetStringOrderingMatch\n            SYNTAX
      1.3.6.1.4.1.1466.115.121.1.40\n     )\n   The pcimVendorActionEncoding attribute
      is used to identify the format\n   and semantics for the pcimVendorActionData
      attribute.  This attribute\n   is defined as follows:\n     ( 1.3.6.1.1.6.2.34\n
      \           NAME 'pcimVendorActionEncoding'\n            DESC 'An OID identifying
      the format and semantics for the\n                  pcimVendorActionData attribute
      of this instance.'\n            EQUALITY objectIdentifierMatch\n            SYNTAX
      1.3.6.1.4.1.1466.115.121.1.38\n            SINGLE-VALUE\n     )\n"
    title: 5.11.  The Auxiliary Class pcimActionVendorAuxClass
  - contents:
    - "5.12.  The Class pcimPolicyInstance\n   This class is not defined in the PCIM.
      \ Its role is to serve as a\n   structural class to which auxiliary classes
      representing policy\n   information are attached when the information is reusable.
      \ For\n   auxiliary classes representing policy conditions and policy actions,\n
      \  there are alternative structural classes that may be used.  See\n   Section
      4.4 for a complete discussion of reusable policy conditions\n   and actions,
      and of the role that this class plays in how they are\n   represented.\n   The
      class definition is as follows:\n     ( 1.3.6.1.1.6.1.16 NAME 'pcimPolicyInstance'\n
      \           DESC 'A structural class to which aux classes containing\n                  reusable
      policy information can be attached.'\n            SUP pcimPolicy\n            MAY
      ( pcimPolicyInstanceName )\n     )\n   The pcimPolicyInstanceName attribute
      is used to define a\n   user-friendly name of this class, and may be used as
      a naming\n   attribute if desired.  It is defined as follows:\n     ( 1.3.6.1.1.6.2.35
      NAME 'pcimPolicyInstanceName'\n            DESC 'The user-friendly name of this
      policy instance.'\n            EQUALITY caseIgnoreMatch\n            ORDERING
      caseIgnoreOrderingMatch\n            SUBSTR caseIgnoreSubstringsMatch\n            SYNTAX
      1.3.6.1.4.1.1466.115.121.1.15\n            SINGLE-VALUE\n     )\n   A DIT content
      rule could be written to enable an instance of\n   pcimPolicyInstance to have
      attached to it either instances of one or\n   more of the auxiliary object classes
      pcimConditionAuxClass and\n   pcimActionAuxClass.  Since these semantics do
      not include specifying\n   any properties, the content rule would not need to
      specify any\n   attributes.  Note that other content rules could be defined
      to enable\n   other policy-related auxiliary classes to be attached to\n   pcimPolicyInstance.\n
      \  Similarly, three separate DIT structure rules could be written.  Each\n   of
      these DIT structure rules would refer to a specific name form that\n   defined
      two important semantics.  First, each name form would\n   identify one of the
      three possible naming attributes (i.e.,\n   pcimPolicyInstanceName, cn, and
      orderedCIMKeys) for this object\n   class.  Second, each name form would require
      that an instance of the\n   pcimPolicyInstance class have as its superior an
      instance of the\n   pcimRepository class.  This structure rule SHOULD also include
      a\n   superiorStructureRule (see Note 2 at the beginning of section 5).\n"
    title: 5.12.  The Class pcimPolicyInstance
  - contents:
    - "5.13.  The Auxiliary Class pcimElementAuxClass\n   This class introduces no
      additional attributes, beyond those defined\n   in the class pcimPolicy from
      which it is derived.  Its role is to\n   \"tag\" an instance of a class defined
      outside the realm of policy\n   information as represented by PCIM as being
      nevertheless relevant to\n   a policy specification.  This tagging can potentially
      take place at\n   two levels:\n   -   Every instance to which pcimElementAuxClass
      is attached becomes\n       an instance of the class pcimPolicy, since pcimElementAuxClass
      is\n       a subclass of pcimPolicy.  Searching for object\n       class=\"pcimPolicy\"
      will return the instance.  (As noted earlier,\n       this approach does NOT
      work for some directory implementations.\n       To accommodate these implementations,
      policy-related entries\n       SHOULD be tagged with the pcimKeyword \"POLICY\".)\n
      \  -   With the pcimKeywords attribute that it inherits from pcimPolicy,\n       an
      instance to which pcimElementAuxClass is attached can be\n       tagged as being
      relevant to a particular type or category of\n       policy information, using
      standard keywords,\n       administrator-defined keywords, or both.\n   The
      class definition is as follows:\n     ( 1.3.6.1.1.6.1.17 NAME 'pcimElementAuxClass'\n
      \           DESC 'An auxiliary class used to tag instances of classes\n                  defined
      outside the realm of policy as relevant to a\n                  particular policy
      specification.'\n            SUP pcimPolicy\n            AUXILIARY\n     )\n"
    title: 5.13.  The Auxiliary Class pcimElementAuxClass
  - contents:
    - "5.14.  The Three Policy Repository Classes\n   These classes provide a container
      for reusable policy information,\n   such as reusable policy conditions and/or
      reusable policy actions.\n   This document is concerned with mapping just the
      properties that\n   appear in these classes.  Conceptually, this may be thought
      of as a\n   special location in the DIT where policy information may reside.\n
      \  Since pcimRepository is derived from the class dlm1AdminDomain\n   defined
      in reference [6], this specification has a normative\n   dependency on that
      element of reference [6] (as well as on its entire\n   derivation hierarchy,
      which also appears in reference [6]).  To\n   maximize flexibility, the pcimRepository
      class is defined as\n   abstract.  A subclass pcimRepositoryAuxClass provides
      for auxiliary\n   attachment to another entry, while a structural subclass\n
      \  pcimRepositoryInstance is available to represent a policy repository\n   as
      a standalone entry.\n   The definition for the pcimRepository class is as follows:\n
      \    ( 1.3.6.1.1.6.1.18 NAME 'pcimRepository'\n            DESC 'A container
      for reusable policy information.'\n            SUP dlm1AdminDomain\n            ABSTRACT\n
      \           MAY ( pcimRepositoryName )\n     )\n   The pcimRepositoryName attribute
      is used to define a user-friendly\n   name of this class, and may be used as
      a naming attribute if desired.\n   It is defined as follows:\n     ( 1.3.6.1.1.6.2.36
      NAME 'pcimRepositoryName'\n            DESC 'The user-friendly name of this
      policy repository.'\n            EQUALITY caseIgnoreMatch\n            ORDERING
      caseIgnoreOrderingMatch\n            SUBSTR caseIgnoreSubstringsMatch\n            SYNTAX
      1.3.6.1.4.1.1466.115.121.1.15\n            SINGLE-VALUE\n     )\n   The two
      subclasses of pcimRepository are defined as follows.  First,\n   the pcimRepositoryAuxClass
      is an auxiliary class that can be used to\n   aggregate reusable policy information.
      \ It is defined as follows:\n     ( 1.3.6.1.1.6.1.19 NAME 'pcimRepositoryAuxClass'\n
      \           DESC 'An auxiliary class that can be used to aggregate\n                  reusable
      policy information.'\n            SUP pcimRepository\n            AUXILIARY\n
      \    )\n   In cases where structural classes are needed instead of an auxiliary\n
      \  class, the pcimRepositoryInstance class is a structural class that\n   can
      be used to aggregate reusable policy information.  It is defined\n   as follows:\n
      \    ( 1.3.6.1.1.6.1.20 NAME 'pcimRepositoryInstance'\n            DESC 'A structural
      class that can be used to aggregate\n                  reusable policy information.'\n
      \           SUP pcimRepository\n            STRUCTURAL\n     )\n   Three separate
      DIT structure rules could be written for this class.\n   Each of these DIT structure
      rules would refer to a specific name form\n   that enabled an instance of the
      pcimRepository class to be named\n   under any superior using one of the three
      possible naming attributes\n   (i.e., pcimRepositoryName, cn, and orderedCIMKeys).
      \ This structure\n   rule SHOULD also include a superiorStructureRule (see Note
      2 at the\n   beginning of section 5).\n"
    title: 5.14.  The Three Policy Repository Classes
  - contents:
    - "5.15.  The Auxiliary Class pcimSubtreesPtrAuxClass\n   This auxiliary class
      provides a single, multi-valued attribute that\n   references a set of objects
      that are at the root of DIT subtrees\n   containing policy-related information.
      \ By attaching this attribute\n   to instances of various other classes, a policy
      administrator has a\n   flexible way of providing an entry point into the directory
      that\n   allows a client to locate and retrieve the policy information\n   relevant
      to it.\n   It is intended that these entries are placed in the DIT such that\n
      \  well-known DNs can be used to reference a well-known structural entry\n   that
      has the pcimSubtreesPtrAuxClass attached to it.  In effect, this\n   defines
      a set of entry points.  Each of these entry points can\n   contain and/or reference
      all related policy entries for\n   any well-known policy domains.  The pcimSubtreesPtrAuxClass
      functions\n   as a tag to identify portions of the DIT that contain policy\n
      \  information.\n   This object does not provide the semantic linkages between
      individual\n   policy objects, such as those between a policy group and the
      policy\n   rules that belong to it.  Its only role is to enable efficient bulk\n
      \  retrieval of policy-related objects, as described in Section 4.5.\n   Once
      the objects have been retrieved, a directory client can\n   determine the semantic
      linkages by following references contained in\n   multi-valued attributes, such
      as pcimRulesAuxContainedSet.\n   Since policy-related objects will often be
      included in the DIT\n   subtree beneath an object to which this auxiliary class
      is attached,\n   a client SHOULD request the policy-related objects from the
      subtree\n   under the object with these references at the same time that it\n
      \  requests the references themselves.\n   Since clients are expected to behave
      in this way, the policy\n   administrator SHOULD make sure that this subtree
      does not contain so\n   many objects unrelated to policy that an initial search
      done in this\n   way results in a performance problem.  The pcimSubtreesPtrAuxClass\n
      \  SHOULD NOT be attached to the partition root for a large directory\n   partition
      containing a relatively few number of policy-related\n   objects along with
      a large number of objects unrelated to policy\n   (again, \"policy\" here refers
      to the PCIM, not the X.501, definition\n   and use of \"policy\").  A better
      approach would be to introduce a\n   container object immediately below the
      partition root, attach\n   pcimSubtreesPtrAuxClass to this container object,
      and then place all\n   of the policy-related objects in that subtree.\n   The
      class definition is as follows:\n     ( 1.3.6.1.1.6.1.21 NAME 'pcimSubtreesPtrAuxClass'\n
      \           DESC 'An auxiliary class providing DN references to roots of\n                  DIT
      subtrees containing policy-related objects.'\n            SUP top\n            AUXILIARY\n
      \           MAY ( pcimSubtreesAuxContainedSet )\n     )\n   The attribute pcimSubtreesAuxContainedSet
      provides an unordered set\n   of DN references to instances of one or more objects
      under which\n   policy-related information is present.  The objects referenced
      may or\n   may not themselves contain policy-related information.  The attribute\n
      \  definition is as follows:\n     ( 1.3.6.1.1.6.2.37\n            NAME 'pcimSubtreesAuxContainedSet'\n
      \           DESC 'DNs of objects that serve as roots for DIT subtrees\n                  containing
      policy-related objects.'\n            EQUALITY distinguishedNameMatch\n            SYNTAX
      1.3.6.1.4.1.1466.115.121.1.12\n     )\n   Note that the cn attribute does NOT
      need to be defined for this\n   class. This is because an auxiliary class is
      used as a means to\n   collect common attributes and treat them as properties
      of an object.\n   A good analogy is a #include file, except that since an auxiliary\n
      \  class is a class, all the benefits of a class (e.g., inheritance) can\n   be
      applied to an auxiliary class.\n"
    title: 5.15.  The Auxiliary Class pcimSubtreesPtrAuxClass
  - contents:
    - "5.16.  The Auxiliary Class pcimGroupContainmentAuxClass\n   This auxiliary
      class provides a single, multi-valued attribute that\n   references a set of
      pcimGroups.  By attaching this attribute to\n   instances of various other classes,
      a policy administrator has a\n   flexible way of providing an entry point into
      the directory that\n   allows a client to locate and retrieve the pcimGroups
      relevant to it.\n   As is the case with pcimRules, a policy administrator might
      have\n   several different references to a pcimGroup in the overall directory\n
      \  structure. The pcimGroupContainmentAuxClass is the mechanism that\n   makes
      it possible for the policy administrator to define all these\n   different references.\n
      \  The class definition is as follows:\n     ( 1.3.6.1.1.6.1.22 NAME 'pcimGroupContainmentAuxClass'\n
      \           DESC 'An auxiliary class used to bind pcimGroups to an\n                  appropriate
      container object.'\n            SUP top\n            AUXILIARY\n            MAY
      ( pcimGroupsAuxContainedSet )\n     )\n   The attribute pcimGroupsAuxContainedSet
      provides an unordered set of\n   references to instances of one or more pcimGroups
      associated with the\n   instance of a structural class to which this attribute
      has been\n   appended.\n   The attribute definition is as follows:\n     ( 1.3.6.1.1.6.2.38\n
      \           NAME 'pcimGroupsAuxContainedSet'\n            DESC 'DNs of pcimGroups
      associated in some way with the\n                  instance to which this attribute
      has been appended.'\n            EQUALITY distinguishedNameMatch\n            SYNTAX
      1.3.6.1.4.1.1466.115.121.1.12\n     )\n   Note that the cn attribute does NOT
      have to be defined for this class\n   for the same reasons as those given for
      the pcimSubtreesPtrAuxClass\n   in section 5.15.\n"
    title: 5.16.  The Auxiliary Class pcimGroupContainmentAuxClass
  - contents:
    - "5.17.  The Auxiliary Class pcimRuleContainmentAuxClass\n   This auxiliary class
      provides a single, multi-valued attribute that\n   references a set of pcimRules.
      \ By attaching this attribute to\n   instances of various other classes, a policy
      administrator has a\n   flexible way of providing an entry point into the directory
      that\n   allows a client to locate and retrieve the pcimRules relevant to it.\n
      \  A policy administrator might have several different references to a\n   pcimRule
      in the overall directory structure.  For example, there\n   might be references
      to all pcimRules for traffic originating in a\n   particular subnet from a directory
      entry that represents that subnet.\n   At the same time, there might be references
      to all pcimRules related\n   to a particular DiffServ setting from an instance
      of a pcimGroup\n   explicitly introduced as a container for DiffServ-related
      pcimRules.\n   The pcimRuleContainmentAuxClass is the mechanism that makes it\n
      \  possible for the policy administrator to define all these separate\n   references.\n
      \  The class definition is as follows:\n     ( 1.3.6.1.1.6.1.23 NAME 'pcimRuleContainmentAuxClass'\n
      \           DESC 'An auxiliary class used to bind pcimRules to an\n                  appropriate
      container object.'\n            SUP top\n            AUXILIARY\n            MAY
      ( pcimRulesAuxContainedSet )\n     )\n   The attribute pcimRulesAuxContainedSet
      provides an unordered set of\n   references to one or more instances of pcimRules
      associated with the\n   instance of a structural class to which this attribute
      has been\n   appended.  The attribute definition is as follows:\n     ( 1.3.6.1.1.6.2.39\n
      \           NAME 'pcimRulesAuxContainedSet'\n            DESC 'DNs of pcimRules
      associated in some way with the\n                  instance to which this attribute
      has been appended.'\n            EQUALITY distinguishedNameMatch\n            SYNTAX
      1.3.6.1.4.1.1466.115.121.1.12\n     )\n   The cn attribute does NOT have to
      be defined for this class for the\n   same reasons as those given for the pcimSubtreesPtrAuxClass
      in\n   section 5.15.\n"
    title: 5.17.  The Auxiliary Class pcimRuleContainmentAuxClass
  title: 5.  Class Definitions
- contents:
  - "6.  Extending the Classes Defined in This Document\n   The following subsections
    provide general guidance on how to create a\n   domain-specific schema derived
    from this document, discuss how the\n   vendor classes in the PCLS should be used,
    and explain how\n   policyTimePeriodConditions are related to other policy conditions.\n"
  - contents:
    - "6.1.  Subclassing pcimConditionAuxClass and pcimActionAuxClass\n   In Section
      4.4, there is a discussion of how, by representing policy\n   conditions and
      policy actions as auxiliary classes in a schema, the\n   flexibility is retained
      to instantiate a particular condition or\n   action as either rule-specific
      or reusable.  This flexibility is lost\n   if a condition or action class is
      defined as structural rather than\n   auxiliary.  For standardized schemata,
      this document specifies that\n   domain-specific information MUST be expressed
      in auxiliary subclasses\n   of pcimConditionAuxClass and pcimActionAuxClass.
      \ It is RECOMMENDED\n   that non-standardized schemata follow this practice
      as well.\n"
    title: 6.1.  Subclassing pcimConditionAuxClass and pcimActionAuxClass
  - contents:
    - "6.2.  Using the Vendor Policy Attributes\n   As discussed Section 5.9, the
      attributes pcimVendorConstraintData and\n   pcimVendorConstraintEncoding are
      included in the\n   pcimConditionVendorAuxClass to provide a mechanism for representing\n
      \  vendor-specific policy conditions that are not amenable to being\n   represented
      with the pcimCondition class (or its subclasses).  The\n   attributes pcimVendorActionData
      and pcimVendorActionEncoding in the\n   pcimActionVendorAuxClass class play
      the same role with respect to\n   actions.  This enables interoperability between
      different vendors who\n   could not otherwise interoperate.\n   For example,
      imagine a network composed of access devices from vendor\n   A, edge and core
      devices from vendor B, and a policy server from\n   vendor C. It is desirable
      for this policy server to be able to\n   configure and manage all of the devices
      from vendors A and B.\n   Unfortunately, these devices will in general have
      little in common\n   (e.g., different mechanisms, different ways for controlling
      those\n   mechanisms, different operating systems, different commands, and so\n
      \  forth).  The extension conditions provide a way for vendor-specific\n   commands
      to be encoded as octet strings, so that a single policy\n   server can commonly
      manage devices from different vendors.\n"
    title: 6.2.  Using the Vendor Policy Attributes
  - contents:
    - "6.3.  Using Time Validity Periods\n   Time validity periods are defined as
      an auxiliary subclass of\n   pcimConditionAuxClass, called pcimTPCAuxClass.
      \ This is to allow\n   their inclusion in the AND/OR condition definitions for
      a pcimRule.\n   Care should be taken not to subclass pcimTPCAuxClass to add\n
      \  domain-specific condition properties.\n   For example, it would be incorrect
      to add IPsec- or QoS-specific\n   condition properties to the pcimTPCAuxClass
      class, just because IPsec\n   or QoS includes time in its condition definition.
      \ The correct\n   subclassing would be to create IPsec or QoS-specific subclasses
      of\n   pcimConditionAuxClass and then combine instances of these\n   domain-specific
      condition classes with the appropriate validity\n   period criteria.  This is
      accomplished using the AND/OR association\n   capabilities for policy conditions
      in pcimRules.\n"
    title: 6.3.  Using Time Validity Periods
  title: 6.  Extending the Classes Defined in This Document
- contents:
  - "7.  Security Considerations\n   The PCLS, presented in this document, provides
    a mapping of the\n   object-oriented model for describing policy information (PCIM)
    into a\n   data model that forms the basic framework for describing the\n   structure
    of policy data, in the case where the policy repository\n   takes the form of
    an LDAP-accessible directory.\n   PCLS is not intended to represent any particular
    system design or\n   implementation.  PCLS is not directly useable in a real world
    system,\n   without the discipline-specific mappings that are works in progress\n
    \  in the Policy Framework Working Group of the IETF.\n   These other derivative
    documents, which use PCIM and its\n   discipline-specific extensions as a base,
    will need to convey more\n   specific security considerations (refer to RFC 3060
    for more\n   information.)\n   The reason that PCLS, as defined here, is not representative
    of any\n   real-world system, is that its object classes were designed to be\n
    \  independent of any specific discipline, or policy domain.  For\n   example,
    DiffServ and IPsec represent two different policy domains.\n   Each document that
    extends PCIM to one of these domains will derive\n   subclasses from the classes
    and relationships defined in PCIM, in\n   order to represent extensions of a generic
    model to cover specific\n   technical domains.\n   PCIM-derived documents will
    thus subclass the PCIM classes into\n   classes specific to each technical policy
    domain (QOS, IPsec, etc.),\n   which will, in turn, be mapped, to directory-specific
    schemata\n   consistent with the PCLS documented here.\n   Even though discipline-specific
    security requirements are not\n   appropriate for PCLS, specific security requirements
    MUST be defined\n   for each operational real-world application of PCIM.  Just
    as there\n   will be a wide range of operational, real-world systems using PCIM,\n
    \  there will also be a wide range of security requirements for these\n   systems.
    \ Some operational, real-world systems that are deployed\n   using PCLS may have
    extensive security requirements that impact\n   nearly all object classes utilized
    by such a system, while other\n   systems' security requirements might have very
    little impact.\n   The derivative documents, discussed above, will create the
    context\n   for applying operational, real-world, system-level security\n   requirements
    against the various models that derive from PCIM,\n   consistent with PCLS.\n
    \  In some real-world scenarios, the values associated with certain\n   properties,
    within certain instantiated object classes, may represent\n   information associated
    with scarce, and/or costly (and therefore\n   valuable) resources.  It may be
    the case that these values must not\n   be disclosed to, or manipulated by, unauthorized
    parties.\n   Since this document forms the basis for the representation of a\n
    \  policy data model in a specific format (an LDAP-accessible\n   directory),
    it is herein appropriate to reference the data\n   model-specific tools and mechanisms
    that are available for achieving\n   the authentication and authorization implicit
    in a requirement that\n   restricts read and/or read- write access to these values
    stored in a\n   directory.\n   General LDAP security considerations apply, as
    documented in RFC 3377\n   [2]. LDAP-specific authentication and authorization
    tools and\n   mechanisms are found in the following standards track documents,\n
    \  which are appropriate for application to the management of security\n   applied
    to policy data models stored in an LDAP-accessible directory:\n     -   RFC 2829
    (Authentication Methods for LDAP)\n     -   RFC 2830 (Lightweight Directory Access
    Protocol (v3): Extension\n         for Transport Layer Security)\n   Any identified
    security requirements that are not dealt with in the\n   appropriate discipline-specific
    information model documents, or in\n   this document, MUST be dealt with in the
    derivative data model\n   documents which are specific to each discipline.\n"
  title: 7.  Security Considerations
- contents:
  - "8.  IANA Considerations\n   Refer to RFC 3383, \"Internet Assigned Numbers Authority
    (IANA)\n   Considerations for the Lightweight Directory Access Protocol (LDAP)\"\n
    \  [16].\n"
  - contents:
    - "8.1.  Object Identifiers\n   The IANA has registered an LDAP Object Identifier
      for use in this\n   technical specification according to the following template:\n
      \  Subject: Request for LDAP OID Registration\n   Person & email address to
      contact for further information:\n      Bob Moore (remoore@us.ibm.com)\n   Specification:
      RFC 3703\n   Author/Change Controller: IESG\n   Comments:\n      The assigned
      OID will be used as a base for identifying\n      a number of schema elements
      defined in this document.\n   IANA has assigned an OID of 1.3.6.1.1.6 with the
      name of pcimSchema\n   to this registration as recorded in the following registry:\n
      \     http://www.iana.org/assignments/smi-numbers\n"
    title: 8.1.  Object Identifiers
  - contents:
    - "8.2.  Object Identifier Descriptors\n   The IANA has registered the LDAP Descriptors
      used in this technical\n   specification as detailed in the following template:\n
      \  Subject: Request for LDAP Descriptor Registration Update\n   Descriptor (short
      name): see comment\n   Object Identifier: see comment\n   Person & email address
      to contact for further information:\n      Bob Moore (remoore@us.ibm.com)\n
      \  Usage: see comment\n   Specification: RFC 3703\n   Author/Change Controller:
      IESG\n   Comments:\n   The following descriptors have been added:\n   NAME                            Type
      \   OID\n   --------------                  ----    ------------\n   pcimPolicy
      \                     O       1.3.6.1.1.6.1.1\n   pcimGroup                       O
      \      1.3.6.1.1.6.1.2\n   pcimGroupAuxClass               O       1.3.6.1.1.6.1.3\n
      \  pcimGroupInstance               O       1.3.6.1.1.6.1.4\n   pcimRule                        O
      \      1.3.6.1.1.6.1.5\n   pcimRuleAuxClass                O       1.3.6.1.1.6.1.6\n
      \  pcimRuleInstance                O       1.3.6.1.1.6.1.7\n   pcimRuleConditionAssociation
      \   O       1.3.6.1.1.6.1.8\n   pcimRuleValidityAssociation     O       1.3.6.1.1.6.1.9\n
      \  pcimRuleActionAssociation       O       1.3.6.1.1.6.1.10\n   pcimConditionAuxClass
      \          O       1.3.6.1.1.6.1.11\n   pcimTPCAuxClass                 O       1.3.6.1.1.6.1.12\n
      \  pcimConditionVendorAuxClass     O       1.3.6.1.1.6.1.13\n   pcimActionAuxClass
      \             O       1.3.6.1.1.6.1.14\n   pcimActionVendorAuxClass        O
      \      1.3.6.1.1.6.1.15\n   pcimPolicyInstance              O       1.3.6.1.1.6.1.16\n
      \  pcimElementAuxClass             O       1.3.6.1.1.6.1.17\n   pcimRepository
      \                 O       1.3.6.1.1.6.1.18\n   pcimRepositoryAuxClass          O
      \      1.3.6.1.1.6.1.19\n   pcimRepositoryInstance          O       1.3.6.1.1.6.1.20\n
      \  pcimSubtreesPtrAuxClass         O       1.3.6.1.1.6.1.21\n   pcimGroupContainmentAuxClass
      \   O       1.3.6.1.1.6.1.22\n   pcimRuleContainmentAuxClass     O       1.3.6.1.1.6.1.23\n
      \  pcimKeywords                    A       1.3.6.1.1.6.2.3\n   pcimGroupName
      \                  A       1.3.6.1.1.6.2.4\n   pcimRuleName                    A
      \      1.3.6.1.1.6.2.5\n   pcimRuleEnabled                 A       1.3.6.1.1.6.2.6\n
      \  pcimRuleConditionListType       A       1.3.6.1.1.6.2.7\n   pcimRuleConditionList
      \          A       1.3.6.1.1.6.2.8\n   pcimRuleActionList              A       1.3.6.1.1.6.2.9\n
      \  pcimRuleValidityPeriodList      A       1.3.6.1.1.6.2.10\n   pcimRuleUsage
      \                  A       1.3.6.1.1.6.2.11\n   pcimRulePriority                A
      \      1.3.6.1.1.6.2.12\n   pcimRuleMandatory               A       1.3.6.1.1.6.2.13\n
      \  pcimRuleSequencedActions        A       1.3.6.1.1.6.2.14\n   pcimRoles                       A
      \      1.3.6.1.1.6.2.15\n   pcimConditionGroupNumber        A       1.3.6.1.1.6.2.16\n
      \  NAME                            Type    OID\n   --------------                  ----
      \   ------------\n   pcimConditionNegated            A       1.3.6.1.1.6.2.17\n
      \  pcimConditionName               A       1.3.6.1.1.6.2.18\n   pcimConditionDN
      \                A       1.3.6.1.1.6.2.19\n   pcimValidityConditionName       A
      \      1.3.6.1.1.6.2.20\n   pcimTimePeriodConditionDN       A       1.3.6.1.1.6.2.21\n
      \  pcimActionName                  A       1.3.6.1.1.6.2.22\n   pcimActionOrder
      \                A       1.3.6.1.1.6.2.23\n   pcimActionDN                    A
      \      1.3.6.1.1.6.2.24\n   pcimTPCTime                     A       1.3.6.1.1.6.2.25\n
      \  pcimTPCMonthOfYearMask          A       1.3.6.1.1.6.2.26\n   pcimTPCDayOfMonthMask
      \          A       1.3.6.1.1.6.2.27\n   pcimTPCDayOfWeekMask            A       1.3.6.1.1.6.2.28\n
      \  pcimTPCTimeOfDayMask            A       1.3.6.1.1.6.2.29\n   pcimTPCLocalOrUtcTime
      \          A       1.3.6.1.1.6.2.30\n   pcimVendorConstraintData        A       1.3.6.1.1.6.2.31\n
      \  pcimVendorConstraintEncoding    A       1.3.6.1.1.6.2.32\n   pcimVendorActionData
      \           A       1.3.6.1.1.6.2.33\n   pcimVendorActionEncoding        A       1.3.6.1.1.6.2.34\n
      \  pcimPolicyInstanceName          A       1.3.6.1.1.6.2.35\n   pcimRepositoryName
      \             A       1.3.6.1.1.6.2.36\n   pcimSubtreesAuxContainedSet     A
      \      1.3.6.1.1.6.2.37\n   pcimGroupsAuxContainedSet       A       1.3.6.1.1.6.2.38\n
      \  pcimRulesAuxContainedSet        A       1.3.6.1.1.6.2.39\n   where Type A
      is Attribute, Type O is ObjectClass\n   These assignments are recorded in the
      following registry:\n      http://www.iana.org/assignments/ldap-parameters\n"
    title: 8.2.  Object Identifier Descriptors
  title: 8.  IANA Considerations
- contents:
  - "9.  Acknowledgments\n   We would like to thank Kurt Zeilenga, Roland Hedburg,
    and Steven Legg\n   for doing a review of this document and making many helpful\n
    \  suggestions and corrections.\n   Several of the policy classes in this model
    first appeared in early\n   IETF drafts on IPsec policy and QoS policy.  The authors
    of these\n   drafts were Partha Bhattacharya, Rob Adams, William Dixon, Roy\n
    \  Pereira, Raju Rajan, Jean-Christophe Martin, Sanjay Kamat, Michael\n   See,
    Rajiv Chaudhury, Dinesh Verma, George Powers, and Raj Yavatkar.\n   This document
    is closely aligned with the work being done in the\n   Distributed Management
    Task Force (DMTF) Policy and Networks working\n   groups.  We would especially
    like to thank Lee Rafalow, Glenn Waters,\n   David Black, Michael Richardson,
    Mark Stevens, David Jones, Hugh\n   Mahon, Yoram Snir, and Yoram Ramberg for their
    helpful comments.\n"
  title: 9.  Acknowledgments
- contents:
  - "10.  Appendix:  Constructing the Value of orderedCIMKeys\n   This appendix is
    non-normative, and is included in this document as a\n   guide to implementers
    that wish to exchange information between CIM\n   schemata and LDAP schemata.\n
    \  Within a CIM name space, the naming is basically flat; all instances\n   are
    identified by the values of their key properties, and each\n   combination of
    key values must be unique.  A limited form of\n   hierarchical naming is available
    in CIM, however, by using weak\n   associations: since a weak association involves
    propagation of key\n   properties and their values from the superior object to
    the\n   subordinate one, the subordinate object can be thought of as being\n   named
    \"under\" the superior object.  Once they have been propagated,\n   however, propagated
    key properties and their values function in\n   exactly the same way that native
    key properties and their values do\n   in identifying a CIM instance.\n   The
    CIM mapping document [6] introduces a special attribute,\n   orderedCIMKeys, to
    help map from the CIM_ManagedElement class to the\n   LDAP class dlm1ManagedElement.
    \ This attribute SHOULD only be used in\n   an environment where it is necessary
    to map between an\n   LDAP-accessible directory and a CIM repository.  For an
    LDAP\n   environment, other LDAP naming attributes are defined (i.e., cn and a\n
    \  class-specific naming attribute) that SHOULD be used instead.\n   The role
    of orderedCIMKeys is to represent the information necessary\n   to correlate an
    entry in an LDAP-accessible directory with an\n   instance in a CIM name space.
    \ Depending on how naming of CIM-related\n   entries is handled in an LDAP directory,
    the value of orderedCIMKeys\n   represents one of two things:\n     - If the DIT
    hierarchy does not mirror the \"weakness hierarchy\" of\n       the CIM name space,
    then orderedCIMKeys represents all the\n       keys of the CIM instance, both
    native and propagated.\n     - If the DIT hierarchy does mirror the \"weakness
    hierarchy\" of the\n       CIM name space, then orderedCIMKeys may represent either
    all the\n       keys of the instance, or only the native keys.\n   Regardless
    of which of these alternatives is taken, the syntax of\n   orderedCIMKeys is the
    same - a DirectoryString of the form\n       <className>.<key>=<value>[,<key>=<value>]*\n
    \  where the <key>=<value> elements are ordered by the names of the key\n   properties,
    according to the collating sequence for US ASCII.  The\n   only spaces allowed
    in the DirectoryString are those that fall within\n   a <value> element.  As with
    alphabetizing the key properties, the\n   goal of suppressing the spaces is once
    again to make the results of\n   string operations predictable.\n   The values
    of the <value> elements are derived from the various CIM\n   syntaxes according
    to a grammar specified in [5].\n"
  title: '10.  Appendix:  Constructing the Value of orderedCIMKeys'
- contents:
  - '11.  References

    '
  - contents:
    - "11.1.  Normative References\n   [1]   Moore, B., Ellesson,E., Strassner, J.
      and A. Westerinen \"Policy\n         Core Information Model -- Version 1 Specification\",
      RFC 3060,\n         February 2001.\n   [2]   Hodges, J. and R. Morgan, \"Lightweight
      Directory Access\n         Protocol (v3): Technical Specification\", RFC 3377,
      September\n         2002.\n   [3]   Wahl, M., Coulbeck, A., Howes,T. and S.
      Kille, \"Lightweight\n         Directory Access Protocol (v3): Attribute Syntax
      Definitions\",\n         RFC 2252, December 1997.\n   [4]   The Directory: Models.
      \ ITU-T Recommendation X.501, 2001.\n   [5]   Distributed Management Task Force,
      Inc., \"Common Information\n         Model (CIM) Specification\", Version 2.2,
      June 14, 1999.  This\n         document is available on the following DMTF web
      page:\n         http://www.dmtf.org/standards/documents/CIM/DSP0004.pdf\n   [6]
      \  Distributed Management Task Force, Inc., \"DMTF LDAP Schema for\n         the
      CIM v2.5 Core Information Model\", April 15, 2002.  This\n         document
      is available on the following DMTF web page:\n         http://www.dmtf.org/standards/documents/DEN/DSP0123.pdf\n
      \  [7]   Wahl, M., \"A Summary of the X.500(96) User Schema for use with\n         LDAPv3\",
      RFC 2256, December 1997.\n   [8]   The Directory: Selected Attribute Types.
      \ ITU-T Recommendation\n         X.520, 2001.\n   [9]   Zeilenga, K., Ed., \"Lightweight
      Directory Access Protocol\n         (LDAP): Additional Matching Rules\", RFC
      3698, February 2004.\n   [10]  Bradner, S., \"Key words for use in RFCs to Indicate
      Requirement\n         Levels\", BCP 14, RFC 2119, March 1997.\n"
    title: 11.1.  Normative References
  - contents:
    - "11.2.  Informative References\n   [11]  Hovey, R. and S. Bradner, \"The Organizations
      Involved in the\n         IETF Standards Process\", BCP 11, RFC 2028, October
      1996.\n   [12]  Strassner, J., policy architecture BOF presentation, 42nd IETF\n
      \        Meeting, Chicago, Illinois, October 1998.  Minutes of this BOF\n         are
      available at the following location:\n         http://www.ietf.org/proceedings/98aug/index.html.\n
      \  [13]  Yavatkar, R., Guerin, R. and D. Pendarakis, \"A Framework for\n         Policy-based
      Admission Control\", RFC 2753, January 2000.\n   [14]  Wahl, M., Alvestrand,
      H., Hodges, J. and R. Morgan,\n         \"Authentication Methods for LDAP\",
      RFC 2829, May 2000\n   [15]  Hodges, J., Morgan, R. and M. Wahl, \"Lightweight
      Directory\n         Access Protocol (v3): Extension for Transport Layer Security\",\n
      \        RFC 2830, May 2000.\n   [16]  Zeilenga, K., \"Internet Assigned Numbers
      Authority (IANA)\n         Considerations for the Lightweight Directory Access
      Protocol\n         (LDAP)\", BCP 64, RFC 3383, September 2002.\n"
    title: 11.2.  Informative References
  title: 11.  References
- contents:
  - "12.  Authors' Addresses\n   John Strassner\n   Intelliden Corporation\n   90
    South Cascade Avenue\n   Colorado Springs, CO  80903\n   Phone: +1.719.785.0648\n
    \  Fax:   +1.719.785.0644\n   EMail: john.strassner@intelliden.com\n   Bob Moore\n
    \  IBM Corporation\n   P. O. Box 12195, BRQA/B501/G206\n   3039 Cornwallis Rd.\n
    \  Research Triangle Park, NC  27709-2195\n   Phone: +1 919-254-4436\n   Fax:
    \  +1 919-254-6243\n   EMail: remoore@us.ibm.com\n   Ryan Moats\n   Lemur Networks,
    Inc.\n   15621 Drexel Circle\n   Omaha, NE 68135\n   Phone: +1-402-894-9456\n
    \  EMail: rmoats@lemurnetworks.net\n   Ed Ellesson\n   3026 Carriage Trail\n   Hillsborough,
    NC 27278\n   Phone: +1 919-644-3977\n   EMail: ellesson@mindspring.com\n"
  title: 12.  Authors' Addresses
- contents:
  - "13.  Full Copyright Statement\n   Copyright (C) The Internet Society (2004).
    \ This document is subject\n   to the rights, licenses and restrictions contained
    in BCP 78 and\n   except as set forth therein, the authors retain all their rights.\n
    \  This document and the information contained herein are provided on an\n   \"AS
    IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE\n   REPRESENTS OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY AND THE\n   INTERNET ENGINEERING TASK FORCE
    DISCLAIM ALL WARRANTIES, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO
    ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE ANY
    RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: 13.  Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed\n
    \  to pertain to the implementation or use of the technology\n   described in
    this document or the extent to which any license\n   under such rights might or
    might not be available; nor does it\n   represent that it has made any independent
    effort to identify any\n   such rights.  Information on the procedures with respect
    to\n   rights in RFC documents can be found in BCP 78 and BCP 79.\n   Copies of
    IPR disclosures made to the IETF Secretariat and any\n   assurances of licenses
    to be made available, or the result of an\n   attempt made to obtain a general
    license or permission for the use\n   of such proprietary rights by implementers
    or users of this\n   specification can be obtained from the IETF on-line IPR repository\n
    \  at http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention\n   any copyrights, patents or patent applications, or other\n
    \  proprietary rights that may cover technology that may be required\n   to implement
    this standard.  Please address the information to the\n   IETF at ietf-ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
